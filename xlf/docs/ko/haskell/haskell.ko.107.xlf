<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="1cbb4c1f2e7daa321ba6fcea8db0876732346830" translate="yes" xml:space="preserve">
          <source>Functions for tracing and monitoring execution.</source>
          <target state="translated">추적 및 실행 모니터링 기능.</target>
        </trans-unit>
        <trans-unit id="16479fdb416d456904dff714b27125ccc720f7ec" translate="yes" xml:space="preserve">
          <source>Functions in the module &lt;code&gt;GHC.Stack&lt;/code&gt; can be used to get the current stack and render it.</source>
          <target state="translated">&lt;code&gt;GHC.Stack&lt;/code&gt; 모듈의 함수 는 현재 스택을 가져 와서 렌더링하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b4538c6823abddd718b4a67c6f47e9707112536" translate="yes" xml:space="preserve">
          <source>Functions loaded from MAPI DLL</source>
          <target state="translated">MAPI DLL에서로드 된 함수</target>
        </trans-unit>
        <trans-unit id="991363ecbdab5aa793ffe2963ab2340e55ed7869" translate="yes" xml:space="preserve">
          <source>Functions on strings</source>
          <target state="translated">문자열의 함수</target>
        </trans-unit>
        <trans-unit id="acd1d73a01569b4597b066ffad662bac0febbd6d" translate="yes" xml:space="preserve">
          <source>Functions on type literals</source>
          <target state="translated">타입 리터럴의 함수</target>
        </trans-unit>
        <trans-unit id="eae4e0d01438335e190495d84c53f36a1091da41" translate="yes" xml:space="preserve">
          <source>Functions that can be fused by the compiler are documented with the phrase &quot;Subject to fusion&quot;.</source>
          <target state="translated">컴파일러에 의해 융합 될 수있는 함수는 &quot;융합 대상&quot;이라는 문구와 함께 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf76ba3ead8b51a76bd5375c7610a24216c56497" translate="yes" xml:space="preserve">
          <source>Functions used frequently when reading textual data.</source>
          <target state="translated">텍스트 데이터를 읽을 때 자주 사용되는 기능.</target>
        </trans-unit>
        <trans-unit id="bf5a0c8672a8cfdd38dd0c49de54779584af909e" translate="yes" xml:space="preserve">
          <source>Functor</source>
          <target state="translated">Functor</target>
        </trans-unit>
        <trans-unit id="4e092e6221592052ff27de9c36b604a94b3b2bfa" translate="yes" xml:space="preserve">
          <source>Functor and monad classes</source>
          <target state="translated">펑터 및 모나드 클래스</target>
        </trans-unit>
        <trans-unit id="de3a870c86fad9ae631a01eb1c00a47d95865fc9" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right.</source>
          <target state="translated">왼쪽에서 오른쪽으로 순회 할 수있는 데이터 구조를 나타내는 펑터.</target>
        </trans-unit>
        <trans-unit id="bbce868c145bac81161a114f3f858a43df4b009e" translate="yes" xml:space="preserve">
          <source>Further bindings can be added to this &lt;code&gt;let&lt;/code&gt; statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this &lt;code&gt;let&lt;/code&gt; we have to line them up:</source>
          <target state="translated">이 &lt;code&gt;let&lt;/code&gt; 문에 추가 바인딩을 추가 할 수 있으므로 GHCi는 프롬프트를 변경하여 다음 줄이 이전 줄을 계속한다는 것을 나타냅니다. 참고 레이아웃은 지금이 더 바인딩을 추가, 효과에 있음을 &lt;code&gt;let&lt;/code&gt; 우리가 그들을 줄을있다 :</target>
        </trans-unit>
        <trans-unit id="49fac13714bb93079e42783f2bb2ccb3989a542a" translate="yes" xml:space="preserve">
          <source>Further, any definition must satisfy the following:</source>
          <target state="translated">또한 모든 정의는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d13054939bf42393691d74b91312a9380f6750a" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt;&lt;code&gt;-l
⟨flags⟩&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt; &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; &lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="08da0d9c9c42c5828b70fcadcfc0cc2b4842f426" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;profiling#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또한 GHC를 사용하면 이벤트 로그 데이터 ( &lt;a href=&quot;profiling#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; 참조 )가 사용자 정의 &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 를&lt;/a&gt; 통해 작성 되는 방식을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20e7c89627716c573e1aa633f5ad999d25b91e8d" translate="yes" xml:space="preserve">
          <source>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</source>
          <target state="translated">또한 GHC는 메타 데이터로 소스 코드에 주석을 달 때 사용할 수있는 간단한 주석 메커니즘을 제공하며, 나중에 컴파일러 API 또는 컴파일러 플러그인으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82324c0c7e914d3c23571245dd382b3b90349133" translate="yes" xml:space="preserve">
          <source>Furthermore, GHCi will print the result of the I/O action if (and only if):</source>
          <target state="translated">또한 GHCi는 다음과 같은 경우 I / O 작업 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6db505903547bc2c8bcd995bca119457f6ba82f6" translate="yes" xml:space="preserve">
          <source>Furthermore, as sketched below, you may have big problems running programs compiled using unstable interfaces.</source>
          <target state="translated">또한 아래 스케치와 같이 불안정한 인터페이스를 사용하여 컴파일 된 프로그램을 실행하는 데 큰 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2c15d21b992fb8a453c178e3d2d2c870eaaae3" translate="yes" xml:space="preserve">
          <source>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a &lt;em&gt;rigid&lt;/em&gt; type; that is, the type is fully known to the type checker, and no inference is involved.</source>
          <target state="translated">또한 별개의 어휘 유형 변수는 별개의 유형 변수를 나타냅니다. 이는 모든 프로그래머가 작성한 유형 서명 (자유 범위 지정 유형 변수를 포함하는 서명 포함)이 &lt;em&gt;엄격한&lt;/em&gt; 유형을 나타냅니다 . 즉, 유형은 유형 검사기에 완전히 알려져 있으며 추론이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80b236431e261295b1f5b32062e509044fb85c6f" translate="yes" xml:space="preserve">
          <source>Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let &lt;code&gt;D&lt;/code&gt; be a prototypical type constructor (&lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;) with three type arguments, which have roles &lt;code&gt;nominal&lt;/code&gt;, &lt;code&gt;representational&lt;/code&gt; resp. &lt;code&gt;phantom&lt;/code&gt;. Then there is an instance of the form</source>
          <target state="translated">또한 모든 유형 생성자에 대해 유형 생성자 아래에서 강제 할 수있는 인스턴스가 있습니다. 예를 들어, &lt;code&gt;D&lt;/code&gt; 는 역할이 &lt;code&gt;nominal&lt;/code&gt; , &lt;code&gt;representational&lt;/code&gt; resp 를 갖는 세 가지 유형 인수를 가진 프로토 타입 유형 생성자 ( &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; ) 라고하자 . &lt;code&gt;phantom&lt;/code&gt; . 그런 다음 양식의 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="406f927a9f4a120e269216ff8cb7178a7f5cb0c5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dad09ada7622a5ff58effb3bd3aac868b8da28f5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b37d25bdd8ec825cf9b78ad8552aaf509c01998" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="44ff1800f7634bcf2c0b0c914a264ded817850d3" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2cb5d14e799a2d7958a05582a6f9320def2c5536" translate="yes" xml:space="preserve">
          <source>Furthermore, the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">또한 닫는 &lt;code&gt;#-}&lt;/code&gt; 은 여는 &lt;code&gt;{-#&lt;/code&gt; 오른쪽의 열에서 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa16c9671ec072c0212b1b51c49a6c158062b0d0" translate="yes" xml:space="preserve">
          <source>Furthermore, type &lt;code&gt;t&lt;/code&gt; is constrained to have a &lt;code&gt;Typeable&lt;/code&gt; instance. The following are therefore illegal:</source>
          <target state="translated">또한, 유형 &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;Typeable&lt;/code&gt; 인스턴스 를 갖도록 제한됩니다 . 따라서 다음은 불법입니다 :</target>
        </trans-unit>
        <trans-unit id="2081970b86a7491a8d3bcc2579c359ea225ff58b" translate="yes" xml:space="preserve">
          <source>Furthermore, we restrict the following features:</source>
          <target state="translated">또한 다음과 같은 기능을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="db033d11f970572cb3e9cddec9da0ae34cfa380a" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">&lt;code&gt;Text&lt;/code&gt; 와 몇 가지 일반적인 인코딩 간에 변환하기위한 가용성 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 지향 함수</target>
        </trans-unit>
        <trans-unit id="a475567b5216c28471ecd6c4d8d53d3b335fb9fb" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between lazy &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">게으른 &lt;code&gt;Text&lt;/code&gt; 와 몇 가지 일반적인 인코딩 간에 변환하기위한 가용성 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 지향 함수</target>
        </trans-unit>
        <trans-unit id="cdf2e5fcd33e60c149dbaeb7315f4ef9de629849" translate="yes" xml:space="preserve">
          <source>Fusion</source>
          <target state="translated">Fusion</target>
        </trans-unit>
        <trans-unit id="159a326f6758bdce7f9997d0ada252499a6c2735" translate="yes" xml:space="preserve">
          <source>Future versions of &lt;code&gt;integer_gmp&lt;/code&gt; may not support negative &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; values anymore.</source>
          <target state="translated">&lt;code&gt;integer_gmp&lt;/code&gt; 의 이후 버전은 더 이상 음수 &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; 값을 지원하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5254c66df5fb20f0f8f5d6b6fad2ca033bf6a230" translate="yes" xml:space="preserve">
          <source>GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</source>
          <target state="translated">GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</target>
        </trans-unit>
        <trans-unit id="a55c9301ac576415d00c242a35c90cc869774f23" translate="yes" xml:space="preserve">
          <source>GADTSyntax</source>
          <target state="translated">GADTSyntax</target>
        </trans-unit>
        <trans-unit id="b91e38c288753eac615e73903fc03c7c3f13ec52" translate="yes" xml:space="preserve">
          <source>GADTs</source>
          <target state="translated">GADTs</target>
        </trans-unit>
        <trans-unit id="f31ea1a5194f51cb6d88f62e8060b3252067edcb" translate="yes" xml:space="preserve">
          <source>GBinaryGet</source>
          <target state="translated">GBinaryGet</target>
        </trans-unit>
        <trans-unit id="630e224c436c0a989f821b5b56c84b74804fbf46" translate="yes" xml:space="preserve">
          <source>GBinaryPut</source>
          <target state="translated">GBinaryPut</target>
        </trans-unit>
        <trans-unit id="7a52054f44519ad82fe4dc7c2dba3037f7ea46fd" translate="yes" xml:space="preserve">
          <source>GCC style response files.</source>
          <target state="translated">GCC 스타일 응답 파일.</target>
        </trans-unit>
        <trans-unit id="9b8227183b46b7bedd6daac69544744f519a2020" translate="yes" xml:space="preserve">
          <source>GCDetails</source>
          <target state="translated">GCDetails</target>
        </trans-unit>
        <trans-unit id="1fb7f8ebd1ef6f3150ef633cd4b56e250a52dea9" translate="yes" xml:space="preserve">
          <source>GCFlags</source>
          <target state="translated">GCFlags</target>
        </trans-unit>
        <trans-unit id="726e40cb883acbb4ae39a6abc67af0f3d15c0557" translate="yes" xml:space="preserve">
          <source>GET_FILEEX_INFO_LEVELS</source>
          <target state="translated">GET_FILEEX_INFO_LEVELS</target>
        </trans-unit>
        <trans-unit id="4deab4e364b1f9987c532fb9308d3fa747de34eb" translate="yes" xml:space="preserve">
          <source>GHC</source>
          <target state="translated">GHC</target>
        </trans-unit>
        <trans-unit id="71e2fb25bf34a1d6ca4d0e65e2d0d3bee84e64bf" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</source>
          <target state="translated">GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</target>
        </trans-unit>
        <trans-unit id="f8b0fde53dfe6ccde028a6e0d7a726451f64e9f6" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;.</source>
          <target state="translated">GHC는 (대부분) Haskell Foreign Function Interface를 따르며, 그 정의는 &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt; 의 Haskell Report의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="71a795962bc4f20caecc626cc98073806d56af3d" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC ( 항상 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 와 함께 )는 &quot;충분히 작은&quot;기능 / 값을 인라인 (또는 &quot;펼치기&quot;)하려고 시도하여 호출 오버 헤드를 피하고 다른 더 놀라운 최적화를 노출시킵니다. GHC에는 많은 벤치 마크를 사용하여 오랜 기간 동안 조정 된 휴리스틱 세트가 있으며 호출 사이트에서 함수를 인라인하는 것이 유리한 시점을 결정합니다. 휴리스틱은 함수가 유익 할 때 함수를 인라인하도록 설계되었지만 과도한 코드 팽창이 발생하지 않습니다. 함수가 너무 크게 보이면 인라인되지 않으며 특정 크기보다 큰 함수는 인터페이스 파일로 정의를 내 보내지 않아도됩니다. 이러한 휴리스틱 결정을 제어하는 ​​일부 임계 값은 플래그를 사용하여 변경할 수 있습니다 ( &lt;a href=&quot;using-optimisation#options-f&quot;&gt;플랫폼 독립 플래그 -f *&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bd5aeb70f3062d7e5273699b9f6ad00fc86027b7" translate="yes" xml:space="preserve">
          <source>GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families &lt;code&gt;(+), (*), (^)&lt;/code&gt; for addition, multiplication, and exponentiation. Numbers may be compared using &lt;code&gt;(&amp;lt;=?)&lt;/code&gt;, which returns a promoted boolean value, or &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, which compares numbers as a constraint. For example:</source>
          <target state="translated">GHC 7.8은 타입 레벨 자연수를 포함한 산술 표현을 평가할 수 있습니다. 이러한 표현은 유형, 가정 &lt;code&gt;(+), (*), (^)&lt;/code&gt; 하여 더하기, 곱하기 및 지수를 사용하여 구성 할 수 있습니다 . 번호를 사용하여 비교 될 수있다 &lt;code&gt;(&amp;lt;=?)&lt;/code&gt; , 승격 부울 값, 또는 반환을 &lt;code&gt;(&amp;lt;=)&lt;/code&gt; , 제약으로 번호를 비교한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93d695e035decd28303f08218eaa7d61529f41ac" translate="yes" xml:space="preserve">
          <source>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type &lt;code&gt;Bool&lt;/code&gt; and the &amp;ldquo;promoted kind&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; are actually identical. (Note that term &lt;code&gt;True&lt;/code&gt; and the type &lt;code&gt;'True&lt;/code&gt; are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</source>
          <target state="translated">GHC 8은 종류와 종류가 실제로는 동일하다고 선언함으로써 종류 다형성의 아이디어를 확장합니다. GHC 내의 어떤 것도 유형과 종류를 구별하지 않습니다. 이것에 대해 생각하는 또 다른 방법은 &lt;code&gt;Bool&lt;/code&gt; 유형 과 &quot;promoted kind&quot; &lt;code&gt;Bool&lt;/code&gt; 이 실제로 동일하다는 것입니다. ( &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;'True&lt;/code&gt; ' 라는 용어 는 표현식에서 사용하고 후자는 유형에서 사용할 수 있기 때문에 여전히 구별됩니다.) 유형과 종류의 구별이 부족하다는 것은 의존적으로 유형이 지정된 언어의 특징입니다. 완전 의존적으로 유형이 지정된 언어는 표현과 유형의 차이를 제거하지만 GHC에서 수행하는 것은 다른 날의 이야기입니다.</target>
        </trans-unit>
        <trans-unit id="83ef026940faed1f89548023088d18a255245d64" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2는 모듈 서명 ( &lt;code&gt;hsig&lt;/code&gt; 파일)을 지원하므로 , 모듈 구현 대신 서명을 작성하여 나중에 구현 선택을 연기 할 수 있습니다. 이 기능은 &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; 없이 사용할 수 없습니다 . 이 매뉴얼 항목은 서명의 구문과 의미에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="6a35186132a8c1a5f44b29b9623541079c426c64" translate="yes" xml:space="preserve">
          <source>GHC Extensions: this is the Approved Way to get at GHC-specific extensions.</source>
          <target state="translated">GHC 확장 : 이것은 GHC 특정 확장을 얻는 승인 된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="abcf3ed735387a1fc13551630355fd6051450c51" translate="yes" xml:space="preserve">
          <source>GHC Note: in order to call &lt;code&gt;waitForProcess&lt;/code&gt; without blocking all the other threads in the system, you must compile the program with &lt;code&gt;-threaded&lt;/code&gt;.</source>
          <target state="translated">GHC 주 : 전화를하기 위해 &lt;code&gt;waitForProcess&lt;/code&gt; 을 시스템의 다른 모든 스레드를 차단하지 않고, 당신이 프로그램을 컴파일해야 &lt;code&gt;-threaded&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ef7fdb5e004e11962f2db47b8f53e696192e47e" translate="yes" xml:space="preserve">
          <source>GHC adopts &lt;strong&gt;Reject if in doubt&lt;/strong&gt; for now. We can see how painful it is in practice, and try something more ambitious if necessary.</source>
          <target state="translated">GHC는 현재 &lt;strong&gt;의심스러운 경우 거부를&lt;/strong&gt; 채택 합니다. 우리는 그것이 실제로 얼마나 고통 스러운지 알 수 있으며 필요하다면 더 야심 찬 것을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="41082220042afac899ff2b83b24c9b3630d70113" translate="yes" xml:space="preserve">
          <source>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a &lt;code&gt;foreign export&lt;/code&gt;. This memory is not normally freed until &lt;code&gt;hs_exit()&lt;/code&gt;; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call &lt;code&gt;hs_thread_done()&lt;/code&gt; from the thread whose memory you want to free.</source>
          <target state="translated">GHC는 스레드가 &lt;code&gt;foreign export&lt;/code&gt; 를 통해 Haskell 함수를 호출 할 때 소량의 스레드 로컬 메모리를 할당합니다 . 이 메모리는 일반적으로 &lt;code&gt;hs_exit()&lt;/code&gt; 까지 해제되지 않습니다 . Haskell에 대한 후속 호출이 빠르도록 메모리가 캐시됩니다. 그러나 응용 프로그램이 오래 실행되고 Haskell을 호출하는 새 스레드가 반복적으로 생성되는 경우 Haskell 함수 호출을 완료 한 스레드에서이 메모리가 해제되도록 할 수 있습니다. 이렇게하려면 메모리를 해제 할 스레드에서 &lt;code&gt;hs_thread_done()&lt;/code&gt; 을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bfd38ebcc64be5e8d02f6d23ecc2c6046c1c0fd" translate="yes" xml:space="preserve">
          <source>GHC allows existentials to be used with records syntax as well. For example:</source>
          <target state="translated">GHC를 사용하면 레코드 구문과 함께 존재도 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c1ae7a2aaa5f27ea408c81b882456db054bdf4d" translate="yes" xml:space="preserve">
          <source>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</source>
          <target state="translated">GHC를 사용하면 숫자 리터럴을 10 진수, 8 진수, 16 진수, 2 진수 또는 부동 소수점 표기법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b980cf594e963e0e8219b555b4d47dab40b3eb42" translate="yes" xml:space="preserve">
          <source>GHC allows stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations, enabled by &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GHC는 독립형 수 &lt;code&gt;deriving&lt;/code&gt; 으로 사용 선언, &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8296b4add8c32598594b426a3d8785f116cea0b4" translate="yes" xml:space="preserve">
          <source>GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</source>
          <target state="translated">GHC를 사용하면 형식 생성자, 클래스 및 형식 변수가 연산자가되고 식과 매우 유사하게 접두사가 작성 될 수 있습니다. 더 구체적으로:</target>
        </trans-unit>
        <trans-unit id="eb4326185e022f2904a00d722e6d3c8a8c919585" translate="yes" xml:space="preserve">
          <source>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</source>
          <target state="translated">GHC는 또한 가시적 인 종류 적용을 허용하는데, 여기서 사용자는 종류 인수가 종류 다형성 경우에 인스턴스화되도록 선언 할 수 있습니다. 사용법은 위에서 지정한 것처럼 용어 수준에서 보이는 유형 응용 프로그램과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="e0505316426448a3c6e8360de65d79da12c2648e" translate="yes" xml:space="preserve">
          <source>GHC also supports &lt;em&gt;kind-heterogeneous&lt;/em&gt; equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled &lt;code&gt;~~&lt;/code&gt;. Here are the kinds of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; to better understand their difference:</source>
          <target state="translated">GHC는 두 종류의 잠재적으로 다른 종류와 관련된 &lt;em&gt;종류 이종의&lt;/em&gt; 평등 도 지원합니다 . 이기종 평등의 철자가 &lt;code&gt;~~&lt;/code&gt; 입니다. 차이점을 더 잘 이해하기 위해 &lt;code&gt;~&lt;/code&gt; 와 &lt;code&gt;~~&lt;/code&gt; 의 종류는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ba76d7ceb7b661bae37e18ce6f07732378f6626a" translate="yes" xml:space="preserve">
          <source>GHC always treats the &lt;em&gt;last&lt;/em&gt; parameter of the instance (&lt;code&gt;Foo&lt;/code&gt; in this example) as the type whose instance is being derived.</source>
          <target state="translated">GHC는 항상 인스턴스 의 &lt;em&gt;마지막&lt;/em&gt; 매개 변수 ( 이 예에서는 &lt;code&gt;Foo&lt;/code&gt; )를 인스턴스가 파생되는 유형으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3c323be157c96acdab287f807375f9b719b64a63" translate="yes" xml:space="preserve">
          <source>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</source>
          <target state="translated">GHC는 두려운 단일 형성 제한 (Haskell 보고서의 섹션 4.5.5)을 암시 적 매개 변수에 적용합니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="085bc7758e841a7674950854ea86b028e0155c10" translate="yes" xml:space="preserve">
          <source>GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</source>
          <target state="translated">GHC는 소스 파일이 ASCII 또는 UTF-8 전용이고 다른 인코딩은 인식되지 않는다고 가정합니다. 그러나 주석에서 유효하지 않은 UTF-8 시퀀스는 무시되므로 주석이 아닌 소스 코드가 ASCII 인 경우 Latin-1과 같은 다른 인코딩을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db91b54c27a7f2bcbfa6b8c3b3b4820b8e9289ae" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3ac693ce7ba01fac9e81d67e5485761f5520b6" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC는 가비지 수집기를 사용하여 스레드가 교착 상태를 감지하려고합니다. 도달 할 수없는 스레드 (실제 객체의 포인터를 따라 찾을 수 없음)는 교착 상태 여야하며이 경우 스레드에 예외가 전송됩니다. 스레드가 교착 상태에있는 방식에 따라 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 은 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="51e22a881769a40b9be873a2cbaae3065ee10a9c" translate="yes" xml:space="preserve">
          <source>GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE&amp;rsquo;s, can avoid parsing, typechecking, and renaming all over again. These files contain</source>
          <target state="translated">GHC는 컴파일 할 때 Haskell 소스 파일에 대한 풍부한 정보를 작성합니다. 확장 인터페이스 파일은 IDE와 같은 외부 도구가 구문 분석, 유형 검사 및 이름 바꾸기를 피할 수 있도록이 정보 중 일부를 디스크에 유지하는 방법입니다. 이 파일들은</target>
        </trans-unit>
        <trans-unit id="95040b8ff0496443822f0456826fbfe3fd01b8e2" translate="yes" xml:space="preserve">
          <source>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file&amp;rsquo;s modification date is earlier than the &lt;code&gt;.o&lt;/code&gt; file&amp;rsquo;s date (i.e. the source hasn&amp;rsquo;t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying &amp;ldquo;Compilation IS NOT required&amp;rdquo;. What a beautiful sight!</source>
          <target state="translated">GHC는 각 인터페이스 파일 및 인터페이스 파일 내의 각 선언에 대한 지문 (사실 MD5 해시)을 계산합니다. 또한 모든 인터페이스 파일에 파일을 마지막으로 컴파일 할 때 사용한 모든 지문 목록을 유지합니다. 소스 파일의 수정 날짜가 &lt;code&gt;.o&lt;/code&gt; 파일 날짜 보다 빠르면 (즉, 파일이 마지막으로 컴파일 된 이후 소스가 변경되지 않은 경우) 재 컴파일 검사가 켜져 있으면 GHC는 영리합니다. 이것은 이번에 필요한 것에 대한 지문과 마지막에 필요한 것에 대한 지문 (컴파일되는 모듈의 인터페이스 파일에서 수집)을 비교합니다. 모두 동일하면 &quot;컴파일이 필요하지 않습니다&quot;라는 프로세스의 초기에 컴파일이 중지됩니다. 정말 아름다운 광경입니다!</target>
        </trans-unit>
        <trans-unit id="7db002a47d7a1c542bad6dcda111e3df7de5d2cf" translate="yes" xml:space="preserve">
          <source>GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt;, which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</source>
          <target state="translated">GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; , which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</target>
        </trans-unit>
        <trans-unit id="6a07d417f72643413044febaee57f46f8892bf38" translate="yes" xml:space="preserve">
          <source>GHC can be quite a bit more aggressive with pieces of code if it knows they are not exported.</source>
          <target state="translated">GHC는 코드가 내보내지지 않았다는 것을 알고 있으면 좀 더 공격적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20b3fdac58effb1981a662cd5b9d15a2246601cf" translate="yes" xml:space="preserve">
          <source>GHC comes with a number of libraries. These are described in separate documentation.</source>
          <target state="translated">GHC는 많은 라이브러리와 함께 제공됩니다. 이것들은 별도의 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e04da29f82d35f8657a7c056280732b0f61a3942" translate="yes" xml:space="preserve">
          <source>GHC comes with a time and space profiling system, so that you can answer questions like &amp;ldquo;why is my program so slow?&amp;rdquo;, or &amp;ldquo;why is my program using so much memory?&amp;rdquo;.</source>
          <target state="translated">GHC는 시간 및 공간 프로파일 링 시스템과 함께 제공되므로&amp;ldquo;프로그램이 왜 느린가요?&amp;rdquo;또는&amp;ldquo;프로그램이 왜 메모리를 많이 사용합니까?&amp;rdquo;와 같은 질문에 대답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da055bb0f39bef03c75247c94877951076bed2b9" translate="yes" xml:space="preserve">
          <source>GHC compiles some program constructs slowly:</source>
          <target state="translated">GHC는 일부 프로그램 구성을 천천히 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="de2e40df6054756a65674cc009e4351de51b3690" translate="yes" xml:space="preserve">
          <source>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</source>
          <target state="translated">GHC는 부동 소수점 환경을 완전히 무시하며 런타임은이를 수정하거나 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="549d84269c7b3028d7034e66451015b450c55e63" translate="yes" xml:space="preserve">
          <source>GHC creates a subdirectory &lt;code&gt;.hpc&lt;/code&gt; in the current directory, and puts HPC index (&lt;code&gt;.mix&lt;/code&gt;) files in there, one for each module compiled. You don&amp;rsquo;t need to worry about these files: they contain information needed by the &lt;code&gt;hpc&lt;/code&gt; tool to generate the coverage data for compiled modules after the program is run.</source>
          <target state="translated">GHC 는 현재 디렉토리에 하위 디렉토리 &lt;code&gt;.hpc&lt;/code&gt; 를 생성하고 컴파일 된 각 모듈마다 하나씩 HPC 색인 ( &lt;code&gt;.mix&lt;/code&gt; ) 파일을 저장합니다. 이 파일들에 대해 걱정할 필요가 없습니다. 파일에는 프로그램 실행 후 컴파일 된 모듈의 적용 범위 데이터를 생성하기 위해 &lt;code&gt;hpc&lt;/code&gt; 도구에 필요한 정보 가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="704d8fd09c4c661d97d55003569a629d6a64a062" translate="yes" xml:space="preserve">
          <source>GHC currently does kind checking before expanding synonyms (though even that could be changed).</source>
          <target state="translated">GHC는 현재 동의어를 확장하기 전에 종류 검사를 수행합니다 (변경 될 수도 있음).</target>
        </trans-unit>
        <trans-unit id="d5c2a962ee75e672cc63c1570d298f7423d987d4" translate="yes" xml:space="preserve">
          <source>GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that&amp;rsquo;s called higher-order matching).</source>
          <target state="translated">GHC는 현재 규칙 LHS를 표현식과 일치시키기 위해 매우 간단한 구문 일치 알고리즘을 사용합니다. 그것은 LHS 및 발현을 구문 상으로 모듈로 알파 변환으로 만드는 치환을 추구한다. 필요한 경우 표현식이 아닌 패턴 (규칙)이 확장됩니다. (표현식을 확장하면 게으름 버그가 발생할 수 있습니다.) 그러나 베타 변환 (고차 매칭이라고 함)은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef6d67c2bca6e1b47545829cfc42b1d411dd7f6d" translate="yes" xml:space="preserve">
          <source>GHC disambiguates between multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor &lt;code&gt;T&lt;/code&gt;, the checker returns:</source>
          <target state="translated">GHC 는이 이론적 근거에 근거하여 여러 개의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 명확하게 설명합니다. 보다 정형화 된 것을 만들기 위해 패턴 일치 검사기가 일부 데이터 유형 생성자 &lt;code&gt;T&lt;/code&gt; 에 대한 생성자 세트를 요청 하면 검사기는 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bd05d936e9882b073172126b6706e5f4c689fb33" translate="yes" xml:space="preserve">
          <source>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for &lt;em&gt;literals&lt;/em&gt; and not arbitrary type expressions. For example, a constraint of the form &lt;code&gt;KnownNat (a + b)&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be simplified to &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt;; instead, GHC will keep the constraint as is, until it can simplify &lt;code&gt;a + b&lt;/code&gt; to a constant value.</source>
          <target state="translated">GHC는 프로그램에서 어떤 구체적인 유형 수준 리터럴이 사용되고 있는지 알게 되 자마자 제약 조건을 해제합니다. 이것은 임의의 유형 표현식이 아닌 &lt;em&gt;리터럴&lt;/em&gt; 에만 작동합니다 . 예를 들어, 상기 형태의 제약 조건 &lt;code&gt;KnownNat (a + b)&lt;/code&gt; 것이다 &lt;em&gt;하지&lt;/em&gt; 단순화 될 &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt; ; 대신, GHC는 &lt;code&gt;a + b&lt;/code&gt; 를 일정한 값으로 단순화 할 수있을 때까지 제약 조건을 그대로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="167343e68b8bf1a9e7ec5d0c5832fa2540cf35a0" translate="yes" xml:space="preserve">
          <source>GHC does not allow you to have a data type with a context that mentions type variables that are not data type parameters. For example:</source>
          <target state="translated">GHC에서는 데이터 유형 매개 변수가 아닌 유형 변수를 언급하는 컨텍스트가있는 데이터 유형을 가질 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b579c8b8d2f4a7ab2a00594e0e2267c4041770d7" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t do the fixity resolution in expressions during parsing as required by Haskell 98 (but not by Haskell 2010). For example, according to the Haskell 98 report, the following expression is legal:</source>
          <target state="translated">GHC는 Haskell 98에 의해 요구되는 바에 따라 구문 분석하는 동안 표현에서 고정도 해결을 수행하지 않습니다 (하스켈 2010에서는 아님). 예를 들어, Haskell 98 보고서에 따르면 다음 표현은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="8769daf9bb42ddf2fdd9c103027d5dea23101781" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with &lt;code&gt;ghc --make&lt;/code&gt; can be up to twice as fast as running &lt;code&gt;ghc&lt;/code&gt; individually on each source file.</source>
          <target state="translated">각 컴파일마다 GHC를 다시 시작할 필요가 없으므로 컴파일간에 정보를 캐시 할 수 있습니다. &lt;code&gt;ghc --make&lt;/code&gt; 를 사용하여 다중 모듈 프로그램을 컴파일하면 각 소스 파일에서 개별적으로 &lt;code&gt;ghc&lt;/code&gt; 를 실행하는 것보다 최대 2 배 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="7fc5be5c4ca5725b6d97a12bfd6fd11cb070f451" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</source>
          <target state="translated">GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</target>
        </trans-unit>
        <trans-unit id="f91f388f5cbc4088b94a5ec84cec7c04e6042e38" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full-laziness. When optimisation in on, and &lt;code&gt;-fno-full-laziness&lt;/code&gt; is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn&amp;rsquo;t consistently apply full-laziness, so don&amp;rsquo;t rely on it.</source>
          <target state="translated">GHC는 완전한 게으름을 구현하지 않습니다. on에서 최적화되고 &lt;code&gt;-fno-full-laziness&lt;/code&gt; 가 제공되지 않으면 루프에서 반복 계산을 추출하는 것과 같이 공유를 증가시키는 일부 변환이 수행됩니다. 이것들은 완전히 게으른 구현과 동일한 변환입니다. 차이점은 GHC가 완전히 게으름을 지속적으로 적용하지 않으므로 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bfe0f580bb15aa44cde9df1fbad436113357809b" translate="yes" xml:space="preserve">
          <source>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more &lt;em&gt;loop breakers&lt;/em&gt; that is never inlined (see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Secrets of the GHC inliner, JFP 12(4) July 2002&lt;/a&gt;). GHC tries not to select a function with an &lt;code&gt;INLINE&lt;/code&gt; pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the &lt;code&gt;INLINE&lt;/code&gt; pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an &lt;code&gt;INLINE&lt;/code&gt; pragma is always ignored.</source>
          <target state="translated">GHC는 인라인이 영원히 지속될 수 없음을 보장합니다. 모든 상호 재귀 그룹 은 절대 인라인되지 않은 하나 이상의 &lt;em&gt;루프 차단기에&lt;/em&gt; 의해 차단됩니다 ( &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;GHC 인라이너의 비밀, 2002 년 7 월 12 일 JFP 12 (4) 참조&lt;/a&gt; ). GHC는 &lt;code&gt;INLINE&lt;/code&gt; pragma를 루프 차단기로 사용하여 기능을 선택하지 않지만, 선택이 없으면 INLINE 기능도 선택할 수 있으며,이 경우 &lt;code&gt;INLINE&lt;/code&gt; pragma는 무시됩니다. 예를 들어, 자체 재귀 함수의 경우 루프 차단기는 함수 자체 만 될 수 있으므로 &lt;code&gt;INLINE&lt;/code&gt; pragma는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e987d1c3d82c8013500d719ac2e258ed684a94" translate="yes" xml:space="preserve">
          <source>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC&amp;rsquo;s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC&amp;rsquo;s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</source>
          <target state="translated">GHC는 내장 ghc 패키지를 통해 내부 API를 사용자에게 공개합니다. Haskell 코드를 프로그래밍 방식으로 분석하거나 컴파일하기 위해 GHC의 전체 컴파일 드라이버를 활용하는 프로그램을 작성할 수 있습니다. 또한, GHC는 GHC의 내부 중간 표현 인 Core를보고 변경할 수있는 모듈 인 컴파일 중에 컴파일러 플러그인을로드 할 수있는 기능을 제공합니다. 플러그인은 실험 최적화 또는 분석에 적합하며 많은 경우에 컴파일러 개발에 대한 진입 장벽을 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="7c167fa8597da83d2d6c70ee64cf8fd148a64239" translate="yes" xml:space="preserve">
          <source>GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">GHC는 추가 호출 규칙 &lt;code&gt;prim&lt;/code&gt; 을 사용하여 FFI를 확장합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="2709b25bb09f206c0b1acccbf37562ea657795ca" translate="yes" xml:space="preserve">
          <source>GHC extends this list with several more classes that may be automatically derived:</source>
          <target state="translated">GHC는 자동으로 파생 될 수있는 몇 가지 클래스를 추가하여이 목록을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="2927c8c0dcc59d688d14e863c87024ee56f40a67" translate="yes" xml:space="preserve">
          <source>GHC has a &lt;code&gt;-dynload&lt;/code&gt; linking flag to select the method that is used to find shared libraries at runtime. There are currently two modes:</source>
          <target state="translated">GHC에는 런타임시 공유 라이브러리를 찾는 데 사용되는 메소드를 선택하기 위한 &lt;code&gt;-dynload&lt;/code&gt; 링크 플래그가 있습니다. 현재 두 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37868d9918c1e5d3985d0159ec2eb8abe357d679" translate="yes" xml:space="preserve">
          <source>GHC has a comprehensive optimiser, so when you want to Really Go For It (and you&amp;rsquo;ve got time to spare) GHC can produce pretty fast code. Alternatively, the default option is to compile as fast as possible while not making too much effort to optimise the generated code (although GHC probably isn&amp;rsquo;t what you&amp;rsquo;d describe as a fast compiler :-).</source>
          <target state="translated">GHC는 포괄적 인 옵티 마이저를 가지고 있으므로 실제로 사용하고 싶을 때 (그리고 여유 시간이있을 때) GHC는 매우 빠른 코드를 생성 할 수 있습니다. 또는 기본 옵션은 생성 된 코드를 최적화하기 위해 너무 많은 노력을 기울이지 않으면 서 가능한 한 빨리 컴파일하는 것입니다 (GHC는 아마도 빠른 컴파일러라고 설명하지는 않습니다 :-).</target>
        </trans-unit>
        <trans-unit id="50704903e2fa0767c23ef5592e01c0142e232598" translate="yes" xml:space="preserve">
          <source>GHC has a custom solver for discharging constraints that involve class &lt;code&gt;Typeable&lt;/code&gt;, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances.</source>
          <target state="translated">GHC에는 &lt;code&gt;Typeable&lt;/code&gt; 클래스 와 관련된 제약 조건을 배출하는 사용자 정의 솔버가 있으며 필기 인스턴스는 금지되어 있습니다. 이를 통해 프로그래머는 가짜 인스턴스를 작성하여 형식 시스템을 전복시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd2651a370808140aecb0389d7da1dfec93f9973" translate="yes" xml:space="preserve">
          <source>GHC has a few built-in functions with special behaviour. In particular:</source>
          <target state="translated">GHC에는 특별한 동작을 가진 몇 가지 내장 기능이 있습니다. 특히:</target>
        </trans-unit>
        <trans-unit id="8bdd8132100b5a3de15d0bde30890b059463f096" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse &lt;code&gt;-Werror&lt;/code&gt;, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; , use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; . To reverse &lt;code&gt;-Werror&lt;/code&gt; , which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b5cd4da1d694b042ff22d18106007056b905706" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse``-Werror``, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC에는 컴파일 중에 생성 될 수있는 치명적이지 않은 오류 메시지 유형 (예 : 경고)을 선택하는 여러 옵션이 있습니다. 일부 옵션은 개별 경고를 제어하고 다른 옵션은 경고 모음을 제어합니다. 개인 경고 해제하려면 &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; 사용 &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; . 모든 경고를 오류로 만드는``-Werror ''를 되돌리려면 -Wwarn을 사용 &lt;code&gt;-Wwarn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc26cabb6e31043f801f34ba96fce33c2cd76158" translate="yes" xml:space="preserve">
          <source>GHC has experimental support for &lt;em&gt;signature thinning&lt;/em&gt;, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list &lt;em&gt;after&lt;/em&gt; merging, in particular, you may refer to entities which are not declared in the body of the local &lt;code&gt;hsig&lt;/code&gt; file.</source>
          <target state="translated">GHC는 서명 자체를 모듈로 내보내기하지 않고 서명에 명시 적 내보내기 목록이있을 때 사용되는 &lt;em&gt;시그너처 thinning&lt;/em&gt; 을 실험적으로 지원 합니다. 이 경우 내보내기 목록 &lt;em&gt;은&lt;/em&gt; 병합 &lt;em&gt;후&lt;/em&gt; 최종 내보내기 목록에 적용됩니다 . 특히 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일 의 본문에 선언되지 않은 엔터티를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae1857d5e68b869ba0f3a7a41a92f227174acdbb" translate="yes" xml:space="preserve">
          <source>GHC has extremely flaky support for &lt;em&gt;impredicative polymorphism&lt;/em&gt;, enabled with &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt;. If it worked, this would mean that you &lt;em&gt;could&lt;/em&gt; call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</source>
          <target state="translated">GHC는 매우 색다른 지원이 &lt;em&gt;impredicative 다형성&lt;/em&gt; 활성화, &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; 을&lt;/a&gt; . 이 일 경우,이는 것을 의미 &lt;em&gt;할 수&lt;/em&gt; 다형성 유형을 통해 다형성 다형성 유형의 기능과의 파라미터 데이터 구조를 호출합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7863559f9ec9cb2b2a5ec1dc3cee9a5175090f2" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC에는 컴파일 타임에 컴파일러 플러그인을로드 할 수있는 기능이 있습니다. 이 기능은 &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt; 에서 제공하는 기능과 유사하며 사용자가 제약 조건 솔버의 동작을 조정하고 컴파일 파이프 라인을 검사 및 수정하며 GHC의 중간 언어 인 Core를 변환 및 검사 할 수있는 플러그인을 작성할 수 있습니다. 플러그인은 실험 분석 또는 최적화에 적합하며 GHC의 소스 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a2700135014d3391d235e2779538d1dbae6f7d0" translate="yes" xml:space="preserve">
          <source>GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (&lt;code&gt;-lm&lt;/code&gt; math library, for example).</source>
          <target state="translated">GHC는 사용자 제공, GHC 제공 및 시스템 제공 ( 예 : &lt;code&gt;-lm&lt;/code&gt; math 라이브러리)을 포함하여 다양한 라이브러리와 코드를 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6fb872fe440b0daf385b4b8ff21367d65f6f7fa0" translate="yes" xml:space="preserve">
          <source>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), described in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;, and a batch compiler, described throughout &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</source>
          <target state="translated">GHC에는 GHCi &lt;a href=&quot;ghci#ghci&quot;&gt;사용에&lt;/a&gt; 설명 된 대화식 Haskell 인터프리터 (GHCi라고도 함) 와 &lt;a href=&quot;using#using-ghc&quot;&gt;GHC 사용&lt;/a&gt; 전체에 설명 된 배치 컴파일러가 있습니다. 실제로 GHC는 대화식 또는 배치 시스템을 제공하기 위해 다른 옵션으로 실행되는 단일 프로그램으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2dfd60f79ee4ba2079225942cc8483b2227556fc" translate="yes" xml:space="preserve">
          <source>GHC home page</source>
          <target state="translated">GHC 홈페이지</target>
        </trans-unit>
        <trans-unit id="f354abc94fdf02ee4cd7aec76ce15252272ca1c5" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">GHC는 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 최적화를 설정하면 어설 션을 무시합니다 . 즉, 형태의 표현 &lt;code&gt;assert pred e&lt;/code&gt; 로 다시 작성합니다 &lt;code&gt;e&lt;/code&gt; . &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 어설 션을 비활성화 할 수도 있습니다. &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt; 옵션을 사용하면 최적화가 설정된 경우에도 어설 션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d193c3b9ee9bd64a2c40a91ed8f0f72fd80e9a86" translate="yes" xml:space="preserve">
          <source>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in &lt;a href=&quot;#ffi-ghcexts&quot;&gt;GHC extensions to the FFI Chapter&lt;/a&gt;, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</source>
          <target state="translated">GHC는 Haskell 2010 보고서의 FFI 장에 대한 여러 GHC 특정 확장을 구현합니다. 이러한 확장은 &lt;a href=&quot;#ffi-ghcexts&quot;&gt;FHC 장에 대한 GHC 확장에&lt;/a&gt; 설명되어 있지만 이러한 기능을 사용하는 프로그램은 이식 가능하지 않습니다. 따라서 이러한 기능은 가능하면 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="1383e2906207b123b97681b2a7fc069bbcc74f65" translate="yes" xml:space="preserve">
          <source>GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt;. For example, the type</source>
          <target state="translated">GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt; . For example, the type</target>
        </trans-unit>
        <trans-unit id="b01529699aab62d7c26cc7ea486b2bf3a314d4cc" translate="yes" xml:space="preserve">
          <source>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</source>
          <target state="translated">GHC는 선점 형 멀티 태스킹을 구현합니다. 스레드 실행은 임의 방식으로 인터리브됩니다. 보다 구체적으로, 스레드는 일부 메모리를 할당 할 때마다 선점 될 수 있습니다. 불행히도 할당이없는 타이트 루프가 다른 스레드를 잠그는 경향이 있음을 의미합니다 (단, 병리학 적 벤치 마크 스타일 코드에서만 발생 함).</target>
        </trans-unit>
        <trans-unit id="784ab21057de1abbfb56e2df7ec894a968e45b8e" translate="yes" xml:space="preserve">
          <source>GHC implements some major extensions to Haskell to support concurrent and parallel programming. Let us first establish terminology:</source>
          <target state="translated">GHC는 동시 및 병렬 프로그래밍을 지원하기 위해 Haskell에 대한 몇 가지 주요 확장 기능을 구현합니다. 먼저 용어를 설정합시다 :</target>
        </trans-unit>
        <trans-unit id="384027abc0c0211dec27023d54430b773e937baf" translate="yes" xml:space="preserve">
          <source>GHC implements this test conservatively when type functions, or type variables, are involved. For example</source>
          <target state="translated">GHC는 타입 함수 나 타입 변수가 관련 될 때이 테스트를 보수적으로 구현합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ac0d768afcace80925944278709c9070e93b287f" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC에는 컴파일 타임에 임의의 프로세스를 실행할 수있는 다양한 플래그가 포함되어 있습니다. 이러한 예 중 하나는 &lt;a href=&quot;phases#pre-processor&quot;&gt;사용자 지정 전 처리기&lt;/a&gt; 플래그입니다. 또 다른 하나는 템플릿 Haskell이 IO 작업을 포함하여 컴파일시 Haskell 코드를 실행하는 기능입니다. Safe Haskell &lt;em&gt;은 이러한 위험을 해결하지 못합니다&lt;/em&gt; (템플릿 Haskell은 허용되지 않는 기능 임).</target>
        </trans-unit>
        <trans-unit id="5a501e79a5be96c764587e4f4a538a164615c592" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC에는 대칭 공유 메모리 다중 프로세서 (SMP)에서 Haskell 프로그램을 병렬로 실행할 수있는 기능이 포함되어 있습니다. 기본적으로 GHC는 하나의 프로세서에서 프로그램을 실행합니다. 당신이 병렬로 실행하려는 경우 당신은 당신의 프로그램을 연결해야 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , 그리고 RTS와 실행 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 옵션; &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;SMP 병렬 처리 사용&lt;/a&gt; 참조 ). 런타임은 사용 가능한 OS 스레드 중에서 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS 옵션으로 지정한 수만큼 병렬로 실행중인 Haskell 스레드를 예약합니다 .</target>
        </trans-unit>
        <trans-unit id="8a61ad13cc654370f6a14c4d7207d6379e372d1d" translate="yes" xml:space="preserve">
          <source>GHC is a large program consisting of a number of stages. You can tell GHC to dump information from various stages of compilation using the &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; flags listed below. Note that some of these tend to produce a lot of output. You can prevent them from clogging up your standard output by passing &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC는 여러 단계로 구성된 대규모 프로그램입니다. 아래 나열된 &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; 플래그를 사용하여 다양한 컴파일 단계에서 정보를 덤프하도록 GHC에 지시 할 수 있습니다 . 이들 중 일부는 많은 출력을 생성하는 경향이 있습니다. &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; 을&lt;/a&gt; 전달하여 표준 출력이 막히지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e827b1ebcca328b1f8fef7330a8dfc0af882c0d" translate="yes" xml:space="preserve">
          <source>GHC is built on a raft of primitive data types and operations; &amp;ldquo;primitive&amp;rdquo; in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn&amp;rsquo;t, we&amp;rsquo;d like to know about it.</source>
          <target state="translated">GHC는 기본 데이터 유형과 작업에 기반을두고 있습니다. 하스켈 자체에서 정의 될 수 없다는 의미에서 &quot;원시적&quot;. 이 코드를 사용하여 빠른 코드를 작성할 수는 있지만 일반적으로 더 높은 수준의 언어 기능 및 라이브러리를 사용하는 것이 훨씬 덜 고통스럽고 장기적으로 더 만족 스럽습니다. 운 좋게도, 작성한 코드는 어떠한 경우에도 효율적인 언 박스 버전에 최적화됩니다. 그렇지 않다면, 우리는 그것에 대해 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="036d822f43fafc704cccf229faeb8f39d429451c" translate="yes" xml:space="preserve">
          <source>GHC is itself a Haskell program, so if you need to pass options directly to GHC&amp;rsquo;s runtime system you can enclose them in &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (see &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Running a compiled program&lt;/a&gt;).</source>
          <target state="translated">GHC 자체는 Haskell 프로그램이므로 옵션을 GHC 런타임 시스템에 직접 전달해야하는 경우 &lt;code&gt;+RTS ... -RTS&lt;/code&gt; 묶을 수 있습니다 ( &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;컴파일 된 프로그램 실행&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5f1fbb021ad6ec77459e40f9cdfa738fe516428c" translate="yes" xml:space="preserve">
          <source>GHC is surprisingly zippy for normal compilations without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;!</source>
          <target state="translated">GHC는 놀랍게도 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 가&lt;/a&gt; 없는 일반 컴파일에 적합합니다 !</target>
        </trans-unit>
        <trans-unit id="e1b0068bc94f72b8b3701c6252a51b85e66a7b86" translate="yes" xml:space="preserve">
          <source>GHC is very cautious about duplicating work. For example, consider</source>
          <target state="translated">GHC는 작업 중복에 대해 매우 신중합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="1e880a64634c393c137ab909ff23b9fa67d62722" translate="yes" xml:space="preserve">
          <source>GHC is very sensitive about interface files. For example, if it picks up a non-standard &lt;code&gt;Prelude.hi&lt;/code&gt; file, pretty terrible things will happen. If you turn on &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;-XNoImplicitPrelude option, the compiler will almost surely die, unless you know what you are doing.</source>
          <target state="translated">GHC는 인터페이스 파일에 매우 민감합니다. 예를 들어 비표준 &lt;code&gt;Prelude.hi&lt;/code&gt; 파일을 선택하면 꽤 끔찍한 일이 발생합니다. 당신이 설정 한 경우 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; -XNoImplicitPrelude 옵션 당신은 당신이 무엇을하고 있는지 알지 못한다면, 컴파일러는 거의 확실하게 죽을 것이다.</target>
        </trans-unit>
        <trans-unit id="8f98bd19130c85af22543d9122fb6b893c3ab021" translate="yes" xml:space="preserve">
          <source>GHC keeps trying to apply the rules as it optimises the program. For example, consider:</source>
          <target state="translated">GHC는 프로그램을 최적화 할 때 규칙을 계속 적용하려고합니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c971ed60f0f8cac8a9dfb32c0fc05213d73e4927" translate="yes" xml:space="preserve">
          <source>GHC knows about two package databases in particular:</source>
          <target state="translated">GHC는 특히 두 가지 패키지 데이터베이스에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee518910a69d6b3ec07ce5ab8b5533533d1b86a4" translate="yes" xml:space="preserve">
          <source>GHC lets you change the default RTS options for a program at compile time, using the &lt;code&gt;-with-rtsopts&lt;/code&gt; flag (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). A common use for this is to give your program a default heap and/or stack size that is greater than the default. For example, to set &lt;code&gt;-H128m -K64m&lt;/code&gt;, link with &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt;.</source>
          <target state="translated">GHC를 사용하면 컴파일시 &lt;code&gt;-with-rtsopts&lt;/code&gt; 플래그 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; )를 사용하여 프로그램의 기본 RTS 옵션을 변경할 수 있습니다 . 이를위한 일반적인 용도는 프로그램에 기본보다 큰 기본 힙 및 / 또는 스택 크기를 제공하는 것입니다. 예를 들어, 설정 &lt;code&gt;-H128m -K64m&lt;/code&gt; 와 링크 &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb99e557b948da3d443c3d321414623817fdd5f6" translate="yes" xml:space="preserve">
          <source>GHC lets you exercise rudimentary control over certain RTS settings for any given program, by compiling in a &amp;ldquo;hook&amp;rdquo; that is called by the run-time system. The RTS contains stub definitions for these hooks, but by writing your own version and linking it on the GHC command line, you can override the defaults.</source>
          <target state="translated">GHC를 사용하면 런타임 시스템에서 호출하는 &quot;후크&quot;를 컴파일하여 특정 프로그램에 대한 특정 RTS 설정을 기초적으로 제어 할 수 있습니다. RTS에는 이러한 후크에 대한 스텁 정의가 포함되어 있지만 자체 버전을 작성하고 GHC 명령 행에서 링크하면 기본값을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad9041737a68aff4c044f186cb6f1f6cdc933e2" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC는 &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; 언어 확장으로이 제한을 해제합니다 . 제한은 처음에는 꽤 어리석은 일이므로 &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8ba60a7f4df257517ab7d5d783f3cc489a09b60" translate="yes" xml:space="preserve">
          <source>GHC loves single-constructor data-types:</source>
          <target state="translated">GHC는 단일 생성자 데이터 유형을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="7fe0475e3ee29056ea60e7039fdeca427dd3ce9a" translate="yes" xml:space="preserve">
          <source>GHC maintains a property that the kind of all inhabited types (as distinct from type constructors or type-level data) tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value. Note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; is parameterised by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt;; this is precisely what we mean by the fact that a type's kind encodes the runtime representation.</source>
          <target state="translated">GHC는 거주하는 모든 유형의 유형 (유형 생성자 또는 유형 레벨 데이터와 구별됨)이 해당 유형의 값의 런타임 표현을 알려주는 특성을 유지합니다. 이 데이터 유형은 런타임 값의 선택을 인코딩합니다. 참고 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; 의해 매개 변수화된다 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt; 을 ; 이것은 타입의 종류가 런타임 표현을 인코딩한다는 사실에 의해 우리가 의미하는 바입니다.</target>
        </trans-unit>
        <trans-unit id="1ff86cb3c00be570a738bdb82648ae498fe4fba6" translate="yes" xml:space="preserve">
          <source>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer&amp;rsquo;s!</source>
          <target state="translated">GHC는 규칙의 LHS와 RHS가 동일한 의미를 갖는지 검증하려고 시도하지 않습니다. 그것은 일반적으로 결정 불가능하며 가장 흥미로운 경우에는 불가능합니다. 책임은 전적으로 프로그래머의 책임입니다!</target>
        </trans-unit>
        <trans-unit id="b7463d030f30e5fbf0ea5c1acd7285f721a4849a" translate="yes" xml:space="preserve">
          <source>GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</source>
          <target state="translated">GHC는 규칙이 합리적이거나 종료되는지 확인하려고 시도하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37534f2a655b7b54b3a6e0e503e96b3a7186887d" translate="yes" xml:space="preserve">
          <source>GHC may produce the following standard DIEs in the &lt;code&gt;.debug_info&lt;/code&gt; section,</source>
          <target state="translated">GHC는 &lt;code&gt;.debug_info&lt;/code&gt; 섹션 에서 다음 표준 DIE를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="421a7300b70d01de5b5db3b095ba0095f1fbdbfa" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">C를 통해 컴파일 할 때 GHC에 더 이상 외부 헤더 파일이 포함되지 않으므로이 검사는 수행되지 않습니다. &lt;a href=&quot;codegens#native-code-gen&quot;&gt;기본 코드 생성기&lt;/a&gt; ( &lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt; )와 호환되고 FFI 사양을 엄격하게 준수하도록 변경되었습니다. FFI 호출에는 매크로 확장 및 C 헤더 파일을 사용할 때 적용될 수있는 기타 CPP 변환이 적용되지 않아야합니다. 이 접근 방식은 또한 모듈 및 패키지 경계에 걸쳐 외래 호출의 인라인을 단순화합니다. 외래 호출의 인라인 버전을 컴파일 할 때 헤더 파일을 사용할 필요가 없으므로 컴파일러는 어떤 상황에서도 외래 호출을 자유롭게 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9906447d97115265712315061f7cad299f0951" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</target>
        </trans-unit>
        <trans-unit id="2b8ae90a6a33abf2e10b63d4f5e2fffb42594017" translate="yes" xml:space="preserve">
          <source>GHC normally imports &lt;code&gt;Prelude.hi&lt;/code&gt; files for you. If you&amp;rsquo;d rather it didn&amp;rsquo;t, then give it a &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; option. The idea is that you can then import a Prelude of your own. (But don&amp;rsquo;t call it &lt;code&gt;Prelude&lt;/code&gt;; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</source>
          <target state="translated">GHC는 일반적으로 &lt;code&gt;Prelude.hi&lt;/code&gt; 파일을 가져옵니다 . 그렇지 않은 경우 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; 옵션을 지정하십시오. 아이디어는 Prelude를 직접 가져올 수 있다는 것입니다. 그러나 &lt;code&gt;Prelude&lt;/code&gt; 라고하지 마십시오 . Haskell 모듈 네임 스페이스는 단순하므로 Prelude 모듈과 충돌해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="51a9a8d7dba56ae1e5e3495d0ce96e9d8abfbf97" translate="yes" xml:space="preserve">
          <source>GHC note: a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use an explicit &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; to close &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibility to ensure that this doesn't happen.</source>
          <target state="translated">GHC 참고 : 가비지 수집기가 프로그램에 의해 참조되지 않은 것으로 감지되면 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 이 자동으로 닫힙니다. 그러나이 동작에 의존하는 것은 일반적으로 권장되지 않습니다. 가비지 수집기는 예측할 수 없습니다. 가능하면 명시 적 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 를 사용하여 더 이상 필요하지 않은 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 닫으십시오 . GHC는 현재 파일 디스크립터가 부족할 때 파일 디스크립터를 비우려고 시도하지 않으며, 이것이 발생하지 않도록하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="40c291d3bf2780069335f412ddeb31f3318572c7" translate="yes" xml:space="preserve">
          <source>GHC note: the number of capabilities is specified by the &lt;code&gt;+RTS -N&lt;/code&gt; option when the program is started. Capabilities can be fixed to actual processor cores with &lt;code&gt;+RTS -qa&lt;/code&gt; if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</source>
          <target state="translated">GHC 참고 : 기능의 수 는 프로그램이 시작될 때 &lt;code&gt;+RTS -N&lt;/code&gt; 옵션으로 지정됩니다 . 기본 운영 체제에서 지원하는 경우 &lt;code&gt;+RTS -qa&lt;/code&gt; 를 사용하여 기능을 실제 프로세서 코어에 고정 할 수 있지만 실제로는 불필요하지만 (실제로 성능이 저하 될 수 있으며 실험이 권장됩니다).</target>
        </trans-unit>
        <trans-unit id="115bd9cb4711dab5b627ce7841a7aee928c90c42" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. 가비지 수집 힙에서 고정 된 메모리를 사용하므로 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 메모리를 해제하기 위해 종료자가 필요하지 않습니다. 의 사용 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 및 관련 기능을 강하게에 우선 추천 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 파이널 라이저와 함께.</target>
        </trans-unit>
        <trans-unit id="a7fc1755b99d460ddf9637e41ae7dfe1a9d17f2f" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. 가비지 수집 힙에서 고정 된 메모리를 사용하므로 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 메모리를 해제하기 위해 종료자가 필요하지 않습니다. 의 사용 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 및 관련 기능을 강하게에 우선 추천 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 파이널 라이저와 함께.</target>
        </trans-unit>
        <trans-unit id="5ae0796132c03a976f52dda473c00aecb4b90673" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. 가비지 수집 힙에서 고정 된 메모리를 사용하므로 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 메모리를 해제하기 위해 종료자가 필요하지 않습니다. 의 사용 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 및 관련 기능을 강하게에 우선 추천 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 파이널 라이저와 함께.</target>
        </trans-unit>
        <trans-unit id="24fb1c4b67d287bddf5427dde444bedfc6f05944" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, as for mallocForeignPtr. Unlike mallocForeignPtr, a ForeignPtr created with mallocPlainForeignPtr carries no finalizers. It is not possible to add a finalizer to a ForeignPtr created with mallocPlainForeignPtr. This is useful for ForeignPtrs that will live only inside Haskell (such as those created for packed strings). Attempts to add a finalizer to a ForeignPtr created this way, or to finalize such a pointer, will throw an exception.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. mallocForeignPtr과 같이 가비지 수집 힙에 고정 된 메모리를 사용합니다. mallocForeignPtr과 달리 mallocPlainForeignPtr로 작성된 ForeignPtr은 종료자를 갖지 않습니다. mallocPlainForeignPtr로 작성된 ForeignPtr에 종료자를 추가 할 수 없습니다. 이는 Haskell 내부에만 존재하는 ForeignPtr (예 : 묶음 문자열 용으로 만들어진 것)에 유용합니다. 이런 방식으로 생성 된 ForeignPtr에 종료자를 추가하거나 이러한 포인터를 완료하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d58dcbe271b06625548680cc1dda88780faf7c0e" translate="yes" xml:space="preserve">
          <source>GHC now instead allows you to specify the kind of a type variable directly, wherever a type variable is explicitly bound, with the extension &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대신 GHC를 사용하면 &lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; 확장자를 사용하여 유형 변수가 명시 적으로 바인딩 된 모든 유형 변수를 직접 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c69341d0b595bd8749c9faf56b39f2a229d74154" translate="yes" xml:space="preserve">
          <source>GHC now permits such instances to be derived instead, using the extension &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;, so one can write</source>
          <target state="translated">GHC는 이제 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 이러한 인스턴스를 대신 파생 시킬 수 있으므로</target>
        </trans-unit>
        <trans-unit id="af2ccd36d80a45d87b36d0a6f6c0151c8a23dc7f" translate="yes" xml:space="preserve">
          <source>GHC now supports a new way to coordinate the activities of Concurrent Haskell threads, called Software Transactional Memory (STM). The &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM papers&lt;/a&gt; are an excellent introduction to what STM is, and how to use it.</source>
          <target state="translated">GHC는 이제 STM (Software Transactional Memory)이라는 동시 Haskell 스레드의 활동을 조정하는 새로운 방법을 지원합니다. &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM 논문은&lt;/a&gt; 훌륭한 STM이 무엇인지 소개 및 사용 방법입니다.</target>
        </trans-unit>
        <trans-unit id="64f783c1668ce53c92c18c3d1d3894883677132f" translate="yes" xml:space="preserve">
          <source>GHC offers a helping hand here, doing all of this for you. For every use of &lt;code&gt;assert&lt;/code&gt; in the user&amp;rsquo;s source:</source>
          <target state="translated">GHC는이 모든 일을 도와주는 도움의 손길을 제공합니다. 사용자 소스에서 &lt;code&gt;assert&lt;/code&gt; 를 사용할 때마다 :</target>
        </trans-unit>
        <trans-unit id="fcb7a200658d0d266c01f6180b030b6fa3a1603b" translate="yes" xml:space="preserve">
          <source>GHC only knows about packages that are &lt;em&gt;installed&lt;/em&gt;. Installed packages live in package databases. For details on package databases and how to control which package databases or specific set of packages are visible to GHC, see &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt;.</source>
          <target state="translated">GHC는 &lt;em&gt;설치된&lt;/em&gt; 패키지에 대해서만 알고 있습니다. 설치된 패키지는 패키지 데이터베이스에 존재합니다. 패키지 데이터베이스 또는 패키지의 특정 세트가 GHC에 볼 수 있습니다 제어 패키지 데이터베이스에 대한 자세한 내용 및 방법을 참조 &lt;a href=&quot;#package-databases&quot;&gt;패키지 데이터베이스&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="044a66191238583d5e4cb81ccc743141923ed216" translate="yes" xml:space="preserve">
          <source>GHC performs implicit quantification as follows. At the outermost level (only) of user-written types, if and only if there is no explicit &lt;code&gt;forall&lt;/code&gt;, GHC finds all the type variables mentioned in the type that are not already in scope, and universally quantifies them. For example, the following pairs are equivalent:</source>
          <target state="translated">GHC는 다음과 같이 암시 적 정량을 수행합니다. 명시 적으로 &lt;code&gt;forall&lt;/code&gt; 이없는 경우에만 사용자 작성 유형의 가장 바깥 레벨 (유일) 에서 GHC는 아직 범위에 포함되지 않은 유형에 언급 된 모든 유형 변수를 찾고이를 보편적으로 정량화합니다. 예를 들어 다음 쌍은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e903f8397c8f5bbb60d7d8d13ff6bba05d63b1b1" translate="yes" xml:space="preserve">
          <source>GHC permits writing kinds with this syntax, provided that the &lt;code&gt;ExplicitForAll&lt;/code&gt; and &lt;code&gt;PolyKinds&lt;/code&gt; language extensions are enabled. Just like the invisible &lt;code&gt;forall&lt;/code&gt;, one can put explicit kind signatures on visibly bound kind variables, so the following is syntactically valid:</source>
          <target state="translated">GHC permits writing kinds with this syntax, provided that the &lt;code&gt;ExplicitForAll&lt;/code&gt; and &lt;code&gt;PolyKinds&lt;/code&gt; language extensions are enabled. Just like the invisible &lt;code&gt;forall&lt;/code&gt; , one can put explicit kind signatures on visibly bound kind variables, so the following is syntactically valid:</target>
        </trans-unit>
        <trans-unit id="d06dacacd81451db2de5b66239661a3e25c08242" translate="yes" xml:space="preserve">
          <source>GHC re-calculates the dependencies each time it is invoked, so the dependencies never get out of sync with the source.</source>
          <target state="translated">GHC는 호출 될 때마다 종속성을 다시 계산하므로 종속성이 소스와 동기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="176ba65a9c9ed02539731d0438e0a1ebfea8e580" translate="yes" xml:space="preserve">
          <source>GHC relaxes this rule in two ways:</source>
          <target state="translated">GHC는이 규칙을 두 가지 방법으로 완화합니다.</target>
        </trans-unit>
        <trans-unit id="12676104a819fe3298a0f123f390ea42a18a068d" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHC는 &lt;code&gt;a&lt;/code&gt; 의 종류가 &lt;code&gt;Type&lt;/code&gt; 이 아니라 종류 변수 &lt;code&gt;k&lt;/code&gt; 여야 한다는 오류를보고합니다 . 모든 형식에 대한 형식 서명을 보면 &lt;code&gt;forall a. Proxy a&lt;/code&gt; Proxy a , GHC는 &lt;code&gt;Type&lt;/code&gt; 으로 제한되지 않고 종류를 일반화해야 한다고 가정 &lt;code&gt;a&lt;/code&gt; . 함수 정의는 형식 서명보다 더 구체적으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1031c0bc27b3b9bb273d87c196ba3e6cd2a9cd" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt; , not &lt;code&gt;Type&lt;/code&gt; . This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt; , GHC assumes &lt;code&gt;a&lt;/code&gt; &amp;rsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt; . The function definition is then rejected for being more specific than its type signature.</target>
        </trans-unit>
        <trans-unit id="3372876691ddf4da952bbb863dd592b0bdfda843" translate="yes" xml:space="preserve">
          <source>GHC requires that in the presence of a standalone kind signature, data declarations must bind all their inputs. For example:</source>
          <target state="translated">GHC requires that in the presence of a standalone kind signature, data declarations must bind all their inputs. For example:</target>
        </trans-unit>
        <trans-unit id="8ce6db855a940e9d5cc1b17135bac5edb333da21" translate="yes" xml:space="preserve">
          <source>GHC requires the use of &lt;code&gt;hs-boot&lt;/code&gt; files to cut the recursive loops among mutually recursive modules as described in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;. This more of an infelicity than a bug: the Haskell Report says (&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;)</source>
          <target state="translated">GHC는 상호 재귀 모듈 &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;을 컴파일하는 방법에&lt;/a&gt; 설명 된대로 상호 재귀 모듈 사이에서 재귀 루프를 절단하기 위해 &lt;code&gt;hs-boot&lt;/code&gt; 파일을 사용해야 합니다 . 하스켈 보고서는 다음과 같이 버그보다 악의가 없다고 말합니다 ( &lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;5.7 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="879d61f80d5636605c655dddfca637fdc98e1ecb" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건을 세 단계로 해결 합니다.</target>
        </trans-unit>
        <trans-unit id="d6ca94a0a11ffefc0bfeb9a72c46f7879523913b" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건을 세 단계로 해결 합니다.</target>
        </trans-unit>
        <trans-unit id="0af504294df234353ca10b5e8500115149162959" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;HasCallStack&lt;/code&gt; constraints in two steps:</source>
          <target state="translated">GHC는 &lt;code&gt;HasCallStack&lt;/code&gt; 제약 조건을 두 단계로 해결 합니다.</target>
        </trans-unit>
        <trans-unit id="5fb168dd0c0c05efa3e7b65980a111be49e483f6" translate="yes" xml:space="preserve">
          <source>GHC sometimes suggests valid hole fits for typed holes, which is configurable by a few flags.</source>
          <target state="translated">GHC는 때때로 몇 가지 플래그로 구성 할 수있는 유형이 지정된 구멍에 유효한 구멍 맞춤을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="bbd754859d95122a24081dbae7deca815e9a4eb6" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;kind-indexed&lt;/em&gt; type families, where the family matches both on the kind and type. GHC will &lt;em&gt;not&lt;/em&gt; infer this behaviour without a complete user-supplied kind signature, as doing so would sometimes infer non-principal types. Indeed, we can see kind-indexing as a form of polymorphic recursion, where a type is used at a kind other than its most general in its own definition.</source>
          <target state="translated">GHC는 &lt;em&gt;종류&lt;/em&gt; 및 유형이 모두 일치 하는 &lt;em&gt;종류 색인&lt;/em&gt; 유형 패밀리를 지원 합니다. GHC는 때때로 사용자가 제공 한 친절한 서명이 &lt;em&gt;없으면&lt;/em&gt; 이 동작을 추론 &lt;em&gt;하지 않을&lt;/em&gt; 것입니다. &lt;em&gt;그렇게하지 않으면&lt;/em&gt; 때로는 비 주체 유형을 유추 할 수 있습니다. 실제로, 우리는 종류-인덱싱을 다형성 재귀의 형태로 볼 수 있는데, 여기에서 타입은 자체 정의에서 가장 일반적인 종류가 아닌 다른 종류로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c3dfb75078d385b6ef1bb4183e0a2d7abc030a2" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;lexically scoped type variables&lt;/em&gt;, without which some type signatures are simply impossible to write. For example:</source>
          <target state="translated">GHC는 &lt;em&gt;어휘 범위가 지정된 유형 변수를&lt;/em&gt; 지원 하지만 일부 유형 서명은 단순히 쓰기가 불가능합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="276796f5e524e49d992d91729272ac0e608e0dda" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded labels&lt;/em&gt;, a form of identifier whose interpretation may depend both on its type and on its literal text. When the &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; extension is enabled, an overloaded label can be written with a prefix hash, for example &lt;code&gt;#foo&lt;/code&gt;. The type of this expression is &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC는 형식과 리터럴 텍스트에 따라 해석이 달라질 수있는 식별자 형식의 &lt;em&gt;오버로드 된 레이블을&lt;/em&gt; 지원 합니다. 때 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; 의&lt;/a&gt; 확장이 활성화되어, 오버로드 된 라벨은 예를 들어, 접두사 해시 쓸 수 &lt;code&gt;#foo&lt;/code&gt; . 이 표현식의 유형은 &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6df65e180903b70882d6d577b9e27d68c01ffd47" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded string literals&lt;/em&gt;. Normally a string literal has type &lt;code&gt;String&lt;/code&gt;, but with overloaded string literals enabled (with &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt;) a string literal has type &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC는 &lt;em&gt;오버로드 된 문자열 리터럴을&lt;/em&gt; 지원합니다 . 일반적으로 문자열 리터럴에는 &lt;code&gt;String&lt;/code&gt; 유형이 있지만 오버로드 된 문자열 리터럴이 활성화 된 경우 ( &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; 사용&lt;/a&gt; ) 문자열 리터럴의 유형은 &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ef938ede98487b50d238f507d6fb11faed2c901" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloading of the list notation&lt;/em&gt;. Let us recap the notation for constructing lists. In Haskell, the list notation can be used in the following seven ways:</source>
          <target state="translated">GHC는 &lt;em&gt;목록 표기법의 오버로드를&lt;/em&gt; 지원합니다 . 목록 구성에 대한 표기법을 다시 살펴 보겠습니다. Haskell에서는 목록 표기법을 다음 7 가지 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03b404046146b764985d1282deeeddd9a94f050" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC는 특별한 옵션이나 특정 방식으로 컴파일 된 라이브러리를 요구하지 않고 기본적으로 동시 하스켈을 지원합니다. Concurrent Haskell의 지원 라이브러리에 액세스하려면 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent를&lt;/a&gt; 가져 오십시오 . Concurrent Haskell에 대한 자세한 내용은 해당 모듈의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="88817a222e891093a054f7b9fd3592132552247b" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</target>
        </trans-unit>
        <trans-unit id="87e3cb78467ec8b2b366442091554c58737c171b" translate="yes" xml:space="preserve">
          <source>GHC supports an extension of pattern matching called &lt;em&gt;bang patterns&lt;/em&gt;, written &lt;code&gt;!pat&lt;/code&gt;. Bang patterns are under consideration for Haskell Prime. The &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskell prime feature description&lt;/a&gt; contains more discussion and examples than the material below.</source>
          <target state="translated">GHC는 &lt;code&gt;!pat&lt;/code&gt; 작성된 &lt;em&gt;bang 패턴&lt;/em&gt; 이라고하는 패턴 일치 확장을 지원합니다 . 하스켈 프라임은 뱅 패턴을 고려하고 있습니다. &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;하스켈 주요 기능 설명은&lt;/a&gt; 아래의 내용보다 더 많은 논의와 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1059d9fa9d503ddf0254f07f1659e4736d333d97" translate="yes" xml:space="preserve">
          <source>GHC supports arrays of unboxed elements, for several basic arithmetic element types including &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt;: see the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; library for details. These arrays are likely to be much faster than using standard Haskell 98 arrays from the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; library.</source>
          <target state="translated">GHC는 &lt;code&gt;Int&lt;/code&gt; 및 &lt;code&gt;Char&lt;/code&gt; 를 포함한 여러 기본 산술 요소 유형에 대해 언 &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;박스형&lt;/a&gt; 요소의 배열을 지원합니다 . 자세한 내용은 Data.Array.Unboxed 라이브러리를 참조하십시오. 이러한 배열은 &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; 라이브러리의 표준 Haskell 98 배열을 사용하는 것보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="3948db87d05dfc40c1f63f054a27ea693124c87e" translate="yes" xml:space="preserve">
          <source>GHC supports both concurrency and parallelism.</source>
          <target state="translated">GHC는 동시성과 병렬 처리를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a13a7734a043f66e1714f2fd0d2b999f5bd2929a" translate="yes" xml:space="preserve">
          <source>GHC supports multiple backend code generators. This is the part of the compiler responsible for taking the last intermediate representation that GHC uses (a form called Cmm that is a simple, C like language) and compiling it to executable code. The backends that GHC support are described below.</source>
          <target state="translated">GHC는 여러 백엔드 코드 생성기를 지원합니다. 이것은 GHC가 사용하는 마지막 중간 표현 (단순한 C와 같은 Cmm이라는 형식)을 가져와 실행 코드로 컴파일하는 컴파일러의 일부입니다. GHC가 지원하는 백엔드가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="30f8743edba346dec74c124074534d3915ad7f3b" translate="yes" xml:space="preserve">
          <source>GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind &lt;code&gt;Nat&lt;/code&gt;, while string literals are of kind &lt;code&gt;Symbol&lt;/code&gt;. This feature is enabled by the &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">GHC는 유형 수준에서 숫자 및 문자열 리터럴을 지원하므로 미리 정의 된 많은 유형 수준 상수에 편리하게 액세스 할 수 있습니다. 숫자 리터럴은 &lt;code&gt;Nat&lt;/code&gt; 이고 문자열 리터럴은 &lt;code&gt;Symbol&lt;/code&gt; 입니다. 이 기능은 &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; 언어 확장으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c771ee603c6b7794f2ea84ef821582ce945de09" translate="yes" xml:space="preserve">
          <source>GHC supports numerous language extensions, including concurrency, a foreign function interface, exceptions, type system extensions such as multi-parameter type classes, local universal and existential quantification, functional dependencies, scoped type variables and explicit unboxed types. These are all described in &lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC Language Features&lt;/a&gt;.</source>
          <target state="translated">GHC는 동시성, 외부 함수 인터페이스, 예외, 다중 매개 변수 유형 클래스와 같은 유형 시스템 확장, 로컬 범용 및 실존 적 수량화, 기능 종속성, 범위 유형 변수 및 명시 적 언 박스형 유형을 포함한 다양한 언어 확장을 지원합니다. 이것들은 모두 &lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC 언어 기능에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dfeb95a50670f1d64eaee09cc2e384aca52156c" translate="yes" xml:space="preserve">
          <source>GHC supports running Haskell programs in parallel on an SMP (symmetric multiprocessor).</source>
          <target state="translated">GHC는 SMP (대칭 멀티 프로세서)에서 Haskell 프로그램의 병렬 실행을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a087224f52d11f82f5a88e556729ad1748a912eb" translate="yes" xml:space="preserve">
          <source>GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don&amp;rsquo;t normally affect the meaning of the program, but they might affect the efficiency of the generated code.</source>
          <target state="translated">GHC는 여러 pragma 또는 소스 코드에 배치 된 컴파일러에 대한 지침을 지원합니다. Pragma는 일반적으로 프로그램의 의미에 영향을 미치지 않지만 생성 된 코드의 효율성에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64c6177d894ac3ebf6c13eb6a39c9b7bbe9fb3b9" translate="yes" xml:space="preserve">
          <source>GHC supports the compilation of mutually recursive modules. This section explains how.</source>
          <target state="translated">GHC는 상호 재귀 모듈의 컴파일을 지원합니다. 이 섹션에서는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b94800f31025b5e612b01265b145926a94da2a20" translate="yes" xml:space="preserve">
          <source>GHC supports these language options:</source>
          <target state="translated">GHC는 다음 언어 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="376872360d159bedd1e4e2c8ef10c95b85bee963" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHC는 유형 매개 변수에 대해 공칭, 표현 및 팬텀의 세 가지 역할을 지원합니다. 유형 매개 변수가 명목상의 역할을하는 경우, 다른 두 유형이 실제로 다르지 않아야합니다. 유형 계열 축소 후 동일해야합니다. 유형 매개 변수에 표현 역할이있는 경우 두 유형이 모두 동일한 표현을 가져야합니다. ( &lt;code&gt;T&lt;/code&gt; 의 첫 번째 매개 변수의 역할이 표현적인 경우, &lt;code&gt;Age&lt;/code&gt; 와 &lt;code&gt;Int&lt;/code&gt; 가 동일한 표현을 갖기 때문에 &lt;code&gt;T Age Bool c&lt;/code&gt; 와 &lt;code&gt;T Int Bool c&lt;/code&gt; 는 동일한 표현을 갖습니다.) 유형 매개 변수가 가상 역할을하는 경우 추가 정보.</target>
        </trans-unit>
        <trans-unit id="739585d733fbd90b635381ce1f62b05fe70f7220" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt; &amp;rsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</target>
        </trans-unit>
        <trans-unit id="f0d48f22ae2a3222802a96b3a539281e8893f263" translate="yes" xml:space="preserve">
          <source>GHC takes a conservative position: it accepts the first two, but not the third. The rule is this: each constraint in the inferred instance context must consist only of type variables, with no repetitions.</source>
          <target state="translated">GHC는 보수적 인 입장을 취합니다. 첫 번째는 받아들이지 만 세 번째는받지 않습니다. 규칙은 이것입니다. 유추 인스턴스 컨텍스트의 각 제약 조건은 반복없이 유형 변수로만 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="af1345dfc47c5e1308fe80cc43e2e8fda6407651" translate="yes" xml:space="preserve">
          <source>GHC then checks for pattern coverage using each of these sets. If any of these sets passes the pattern coverage checker with no warnings, then we are done. If each set produces at least one warning, then GHC must pick one of the sets of warnings depending on how good the results are. The results are prioritized in this order:</source>
          <target state="translated">그런 다음 GHC는 이러한 각 세트를 사용하여 패턴 적용 범위를 확인합니다. 이 세트 중 하나라도 경고없이 패턴 적용 범위 검사기를 통과하면 완료됩니다. 각 세트가 하나 이상의 경고를 생성하는 경우 GHC는 결과의 수준에 따라 경고 세트 중 하나를 선택해야합니다. 결과는 다음 순서로 우선 순위가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="4f506a7b6cf4858f54fbbea3adb5c9aafc2629c4" translate="yes" xml:space="preserve">
          <source>GHC tracks a distinction between what we call &lt;em&gt;inferred&lt;/em&gt; and &lt;em&gt;specified&lt;/em&gt; type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</source>
          <target state="translated">GHC는 우리가 &lt;em&gt;유추 된&lt;/em&gt; 것과 &lt;em&gt;지정된&lt;/em&gt; 유형 변수 라고 부르는 것을 구별 합니다. 보이는 유형 응용 프로그램으로 인스턴스화 할 때는 지정된 유형 변수 만 사용할 수 있습니다. 예제는 이것을 잘 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b0056c6884fc97fc67e74fdba9e10f40ad69bfb2" translate="yes" xml:space="preserve">
          <source>GHC used to have an implementation of generic classes as defined in the paper &amp;ldquo;Derivable type classes&amp;rdquo;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general &lt;a href=&quot;#generic-programming&quot;&gt;support for generic programming&lt;/a&gt;.</source>
          <target state="translated">GHC는 &quot;Derivable type classes&quot;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105에 정의 된 일반 클래스의 구현을 사용했습니다. 이것은 &lt;a href=&quot;#generic-programming&quot;&gt;일반 프로그래밍에 대한&lt;/a&gt; 보다 일반적인 지원 으로 제거 및 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6146a11d5bcfee2fd36a56319860854e84371c0e" translate="yes" xml:space="preserve">
          <source>GHC uses a copying garbage collector by default. &amp;ldquo;bytes copied during GC&amp;rdquo; tells you how many bytes it had to copy during garbage collection.</source>
          <target state="translated">GHC는 기본적으로 복사 가비지 수집기를 사용합니다. &amp;ldquo;GC 중에 복사 된 바이트&amp;rdquo;는 가비지 수집 중에 복사해야하는 바이트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b767adcd6d48a9a1db03ff8580662a14fddf6ff9" translate="yes" xml:space="preserve">
          <source>GHC uses the &lt;a href=&quot;#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</source>
          <target state="translated">GHC는 &lt;a href=&quot;#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; 를 사용하여 인스턴스 확인이 종료되도록합니다. 수량화 된 제약 조건에 맞게 이러한 규칙을 어떻게 수정합니까? 두 가지 방법으로.</target>
        </trans-unit>
        <trans-unit id="ca01e41132644bdb3e286bc222d38e9f775ccd4e" translate="yes" xml:space="preserve">
          <source>GHC versions before 8.8 defined undocumented functions &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; instead of &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;. Those names are now deprecated.</source>
          <target state="translated">GHC의 8.8 정의 문서화되지 않은 기능의 이전 버전 &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; 및 &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; 대신 &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; 및 &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; . 해당 이름은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60b8a79c38bec7cc0926fc1ac31c53e115e9aa07" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all exported functions not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC는 INLINE으로 표시되지 않은 모든 내 보낸 기능에 대해 &lt;code&gt;SCC&lt;/code&gt; 주석을 자동으로 추가 합니다. 인라인 기능에 코스트 센터가 필요한 경우 수동으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="e90ca342877325f438cbed76b283486d9d43d4bf" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all top-level bindings not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC는 INLINE으로 표시되지 않은 모든 최상위 바인딩에 대해 &lt;code&gt;SCC&lt;/code&gt; 주석을 자동으로 추가 합니다. 인라인 기능에 코스트 센터가 필요한 경우 수동으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b91bde5a658ad123b14fffc8376301c68f7acc1" translate="yes" xml:space="preserve">
          <source>GHC will complain about this, because you might later add</source>
          <target state="translated">나중에 추가 할 수 있기 때문에 GHC가 이에 대해 불평합니다.</target>
        </trans-unit>
        <trans-unit id="888ad4028beff57dc284f4b0b4cb77697614c65e" translate="yes" xml:space="preserve">
          <source>GHC will generate an instance that is equivalent to</source>
          <target state="translated">GHC는 다음과 같은 인스턴스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fd5d18e4a6d13e92f35cab7d827b6e1c50ef7f4c" translate="yes" xml:space="preserve">
          <source>GHC will rewrite this to also include the source location where the assertion was made,</source>
          <target state="translated">GHC는이 주장을 다시 작성하여 주장이 이루어진 출처 위치를 포함 시키며,</target>
        </trans-unit>
        <trans-unit id="3b8666db2e1c25642043eb4c9311786ee0fbf20e" translate="yes" xml:space="preserve">
          <source>GHC will successfully compile this module with &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt;, because the default export list will include &lt;code&gt;program&lt;/code&gt; rather than &lt;code&gt;main&lt;/code&gt;, as the Haskell Report typically requires.</source>
          <target state="translated">기본 내보내기 목록에는 Haskell 보고서가 일반적으로 요구하는 것처럼 기본 내보내기 목록에 &lt;code&gt;main&lt;/code&gt; 대신 &lt;code&gt;program&lt;/code&gt; 이 포함되므로 GHC는 &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt; 로이 모듈을 성공적으로 컴파일 합니다.</target>
        </trans-unit>
        <trans-unit id="71826e517742bea19038f247c0110ae19fac4e07" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s &lt;code&gt;-main-is&lt;/code&gt; option can be used to change the name of the top-level entry point from &lt;code&gt;main&lt;/code&gt; to any other variable. When compiling the main module and &lt;code&gt;-main-is&lt;/code&gt; has been used to rename the default entry point, GHC will also use the alternate name in the default export list.</source>
          <target state="translated">GHC의 &lt;code&gt;-main-is&lt;/code&gt; 옵션을 사용하여 최상위 엔트리 포인트 이름을 &lt;code&gt;main&lt;/code&gt; 에서 다른 변수 로 변경할 수 있습니다 . 기본 모듈을 컴파일 할 때 &lt;code&gt;-main-is&lt;/code&gt; 를 사용하여 기본 진입 점의 이름을 바꾸면 GHC는 기본 내보내기 목록의 대체 이름도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b7940b1f55c055977ec4b26434a6019b2252f161" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is controlled by options, which for historical reasons are also sometimes referred to as command-line flags or arguments. Options can be specified in three ways:</source>
          <target state="translated">GHC의 동작은 옵션에 의해 제어되며, 역사적 이유로 때때로 명령 행 플래그 또는 인수라고도합니다. 옵션은 세 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e4a533f14309a808a844f31df8d6cfa4f088440" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is firstly controlled by a mode flag. Only one of these flags may be given, but it does not necessarily need to be the first option on the command-line. For instance,</source>
          <target state="translated">GHC의 동작은 먼저 모드 플래그에 의해 제어됩니다. 이러한 플래그 중 하나만 제공 할 수 있지만 반드시 명령 행에서 첫 번째 옵션 일 필요는 없습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bf906368ac038f94bf26ce6b52010381e9b9d4b3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s compiled output normally goes into a &lt;code&gt;.hc&lt;/code&gt;, &lt;code&gt;.o&lt;/code&gt;, etc., file, depending on the last-run compilation phase. The option &lt;code&gt;-o file&lt;/code&gt; re-directs the output of that last-run phase to ⟨file⟩.</source>
          <target state="translated">GHC의 컴파일 된 출력은 일반적으로 마지막 실행 컴파일 단계에 따라 &lt;code&gt;.hc&lt;/code&gt; , &lt;code&gt;.o&lt;/code&gt; 등 파일 로 들어갑니다 . &lt;code&gt;-o file&lt;/code&gt; 옵션 은 마지막 실행 단계의 출력을 ⟨file⟩로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="4eaf5334b602d1dc2d125684f67fbc356d5c1cda" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s default behaviour is that &lt;em&gt;exactly one instance must match the constraint it is trying to resolve&lt;/em&gt;. For example, the constraint &lt;code&gt;C Int Bool&lt;/code&gt; matches instances (A) and (B), and hence would be rejected; while &lt;code&gt;C Int Char&lt;/code&gt; matches only (A) and hence (A) is chosen.</source>
          <target state="translated">GHC의 기본 동작은 &lt;em&gt;정확히 하나의 인스턴스가 해결하려는 제약 조건과 일치해야한다는 것입니다&lt;/em&gt; . 예를 들어 제약 조건 &lt;code&gt;C Int Bool&lt;/code&gt; 은 인스턴스 (A) 및 (B)와 일치하므로 거부됩니다. 반면 &lt;code&gt;C Int Char&lt;/code&gt; 일치하는 경우에만 (A) 따라서 (A)가 선택된다.</target>
        </trans-unit>
        <trans-unit id="c8a2481a78caced9f750c28e9ecbbf9c5b39a8d3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation diverges from the Haskell 98 definition in the sense that Unicode alphabetic characters which are neither upper nor lower case will still be identified as alphabetic by &lt;code&gt;isAlpha&lt;/code&gt;.</source>
          <target state="translated">GHC의 구현은 대문자 또는 소문자가 아닌 유니 코드 알파벳 문자가 여전히 &lt;code&gt;isAlpha&lt;/code&gt; 에 의해 알파벳으로 식별된다는 점에서 Haskell 98 정의와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0d8ddddf05368a7d9eeb185f0d525cf13f5ca7e5" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of &lt;code&gt;array&lt;/code&gt; takes the value of an array slot from the last (index,value) pair in the list, and does no checking for duplicates. The reason for this is efficiency, pure and simple.</source>
          <target state="translated">GHC의 &lt;code&gt;array&lt;/code&gt; 구현은 목록의 마지막 (인덱스, 값) 쌍에서 배열 슬롯의 값을 가져 오며 중복을 검사하지 않습니다. 그 이유는 순수하고 단순하며 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="681323083d71785f12a1d947d44622299b5d2e3b" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of the &lt;code&gt;Read&lt;/code&gt; class for integral types accepts hexadecimal and octal literals (the code in the Haskell 98 report doesn&amp;rsquo;t). So, for example,</source>
          <target state="translated">정수 유형에 대한 GHC의 &lt;code&gt;Read&lt;/code&gt; 클래스 구현 은 16 진 및 8 진 리터럴을 허용합니다 (Haskell 98 보고서의 코드는 그렇지 않습니다). 예를 들어</target>
        </trans-unit>
        <trans-unit id="fa910ad711028cf4d2f6aa78f6b468a6abe9cc47" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation the mdo-notation closely follows the original translation as described in the paper &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;, which in turn is based on the work &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the &lt;code&gt;rec&lt;/code&gt; keyword, as we describe next.</source>
          <target state="translated">GHC의 mdo-notation 구현은 &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Haskell&lt;/a&gt; 에 대한 재귀 적 수행 문서에 설명 된대로 원래의 번역과 밀접한 관련 이 있으며, 이는 &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;모나 딕 계산에서의 가치 재귀&lt;/a&gt; 작업에 기반합니다 . 또한 GHC 는 다음에 설명하는 것처럼 &lt;code&gt;rec&lt;/code&gt; 키워드로 플래그가 낮은 하위 구문을 사용하여 이전 논문에서 설명한 구문을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="ed1e2dd4714860c447f66e579db44cd5338ed6ec" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s inliner can be persuaded into non-termination using the standard way to encode recursion via a data type:</source>
          <target state="translated">GHC의 인라이너는 데이터 유형을 통해 재귀를 인코딩하는 표준 방법을 사용하여 비 종료로 설득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7270364eb5fb9843c4759fc3f49b280307e959e9" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s optimiser can diverge if you write rewrite rules (&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that don&amp;rsquo;t terminate, or (less satisfactorily) if you code up recursion through data types (&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;). To avoid making the compiler fall into an infinite loop, the optimiser carries a &amp;ldquo;tick count&amp;rdquo; and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</source>
          <target state="translated">GHC 옵티마이 저는 종료되지 않는 재 작성 규칙 ( &lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt; )을 작성 하거나 데이터 유형을 통해 재귀를 코딩하는 경우 ( &lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHC의 버그&lt;/a&gt; ) 덜 만족할 수 있습니다 . 컴파일러가 무한 루프에 빠지지 않도록하기 위해 옵티마이 저는 &quot;틱 카운트&quot;를 수행하고이 카운트가 초과되면 인라이닝 규칙을 적용하지 않습니다. 한계는 프로그램 크기의 배수로 설정되므로 큰 프로그램은 더 많은 눈금을 얻습니다. &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; 플래그는 승수를 변경할 수 있습니다. 기본값은 100입니다. 100보다 큰 숫자는 더 많은 눈금을 제공하고 100보다 작은 숫자는 더 적은 눈금을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3978a882c19969786036cd225ec74df6cbf83e05" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s parallelism support has improved in 6.12.1 as a result of much experimentation and tuning in the runtime system. We&amp;rsquo;d still be interested to hear how well it works for you, and we&amp;rsquo;re also interested in collecting parallel programs to add to our benchmarking suite.</source>
          <target state="translated">GHC의 병렬 처리 지원은 런타임 시스템에서 많은 실험과 조정의 결과로 6.12.1에서 개선되었습니다. 우리는 여전히 그것이 당신에게 얼마나 잘 작동하는지 듣고 싶으며, 벤치마킹 제품군에 추가 할 병렬 프로그램을 수집하는 데 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e3bdec967fe5a92f92f545009ebde19c94ff56" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system assigns costs to cost centres. A cost is simply the time or space (memory) required to evaluate an expression. Cost centres are program annotations around expressions; all costs incurred by the annotated expression are assigned to the enclosing cost centre. Furthermore, GHC will remember the stack of enclosing cost centres for any given expression at run-time and generate a call-tree of cost attributions.</source>
          <target state="translated">GHC의 프로파일 링 시스템은 코스트 센터에 비용을 할당합니다. 비용은 단순히 식을 평가하는 데 필요한 시간 또는 공간 (메모리)입니다. 코스트 센터는 표현식 주위의 프로그램 주석입니다. 주석이 달린 표현식에 의해 발생 된 모든 비용은 둘러싸는 코스트 센터에 할당됩니다. 또한 GHC는 런타임에 특정 표현식에 대한 엔 클로징 코스트 센터 스택을 기억하고 비용 속성의 콜 트리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c44af933474ed5e269dd484ced236e4d2057d778" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system supports &amp;ldquo;cost centre stacks&amp;rdquo;: a way of seeing the profile of a Haskell program in a call-graph like structure. See &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt; for more details.</source>
          <target state="translated">GHC의 프로파일 링 시스템은 &quot;비용 센터 스택&quot;을 지원합니다. 이는 콜 그래프와 같은 구조로 Haskell 프로그램의 프로파일을 보는 방법입니다. 자세한 내용은 &lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8705e16011627590f47ff878b246c3728533b3b6" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system has built-in support for collecting stack trace information from a running Haskell program. This currently requires that the &lt;code&gt;libdw&lt;/code&gt; library from the &lt;code&gt;elfutils&lt;/code&gt; package is available. Of course, the backtrace will be of little use unless debug information is available in the executable and its dependent libraries.</source>
          <target state="translated">GHC의 런타임 시스템은 실행중인 Haskell 프로그램에서 스택 추적 정보를 수집하는 기능을 기본적으로 지원합니다. 현재 &lt;code&gt;elfutils&lt;/code&gt; 패키지 의 &lt;code&gt;libdw&lt;/code&gt; 라이브러리를 사용할 수 있어야합니다. 물론, 디버그 정보가 실행 파일과 종속 라이브러리에서 사용 가능하지 않으면 역 추적은 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34ecd7773e52e6b1108977b176ca3c2b9e8f2456" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;#367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;#367&lt;/a&gt; for further discussion.</target>
        </trans-unit>
        <trans-unit id="edf33651c39771e5da51f29e8aae689306e3130d" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;Issue #367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHC의 런타임 시스템은 협업 멀티 태스킹을 구현하며, 프로그램이 할당 될 때만 컨텍스트 전환이 발생할 수 있습니다. 이는 할당되지 않은 프로그램은 컨텍스트 전환이되지 않을 수 있음을 의미합니다. 일관성이없는 상태를 관찰 한 후 교착 상태가 발생할 수있는 STM을 사용하는 프로그램의 경우 특히 그렇습니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;문제 # 367&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="495b902a4d269ea40b19611761afea825c104875" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s type system supports &lt;em&gt;arbitrary-rank&lt;/em&gt; explicit universal quantification in types. For example, all the following types are legal:</source>
          <target state="translated">GHC의 유형 시스템은 유형에서 &lt;em&gt;임의의 등급의&lt;/em&gt; 명시 적 범용 정량을 지원합니다. 예를 들어 다음 유형이 모두 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="82fd95c3a56752e08f77eb38c5bdbdcb6be4a696" translate="yes" xml:space="preserve">
          <source>GHC's &lt;code&gt;DataKinds&lt;/code&gt; language extension lifts data constructors, natural numbers, and strings to the type level. This module provides the primitives needed for working with type-level numbers (the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Nat&quot;&gt;Nat&lt;/a&gt;&lt;/code&gt; kind) and strings (the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Symbol&quot;&gt;Symbol&lt;/a&gt;&lt;/code&gt;) kind. It also defines the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:TypeError&quot;&gt;TypeError&lt;/a&gt;&lt;/code&gt; type family, a feature that makes use of type-level strings to support user defined type errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364440218c4abb707fa15b5beedbc3d1c2676890" translate="yes" xml:space="preserve">
          <source>GHC's Ix typeclass implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afa5da65b91efe9b8ba677184df9d9635364492" translate="yes" xml:space="preserve">
          <source>GHC's array implementation.</source>
          <target state="translated">GHC의 어레이 구현.</target>
        </trans-unit>
        <trans-unit id="76da1a73e21244ea0ab9be4c1d1fee4004005654" translate="yes" xml:space="preserve">
          <source>GHC's implementation of concurrency</source>
          <target state="translated">GHC의 동시성 구현</target>
        </trans-unit>
        <trans-unit id="98be7070373a5168f3480205560843e2f04494b4" translate="yes" xml:space="preserve">
          <source>GHC's implementation of the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; data type.</source>
          <target state="translated">GHC의 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 데이터 유형 구현</target>
        </trans-unit>
        <trans-unit id="768bc13ad5b2e61fd8fe71e1fff8dfdfc664e459" translate="yes" xml:space="preserve">
          <source>GHC, by default, no longer depends on cygwin, but is a native Windows program. It is built using mingw, and it uses mingw&amp;rsquo;s GHC while compiling your Haskell sources (even if you call it from cygwin&amp;rsquo;s bash), but what matters here is that - just like any other normal windows program - neither GHC nor the executables it produces are aware of Cygwin&amp;rsquo;s pretended unix hierarchy. GHC will happily accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\\&lt;/code&gt; as path separators, but it won&amp;rsquo;t know where to find &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; or &lt;code&gt;/bin/bash&lt;/code&gt; or the like. This causes all kinds of fun when GHC is used from within Cygwin&amp;rsquo;s bash, or in make-sessions running under Cygwin.</source>
          <target state="translated">기본적으로 GHC는 더 이상 cygwin에 의존하지 않지만 기본 Windows 프로그램입니다. 그것은 mingw를 사용하여 빌드되었으며, 하스켈 소스를 컴파일하는 동안 mingw의 GHC를 사용하지만 (cygwin의 bash에서 호출하더라도) 여기에서 중요한 것은 다른 일반 Windows 프로그램과 마찬가지로 GHC 또는 실행 파일도 아닙니다. Cygwin의 유닉스 계층 구조를 알고 있습니다. GHC는 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;\\&lt;/code&gt; 를 경로 구분 기호로 행복하게 받아들이지 만 &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; 또는 &lt;code&gt;/bin/bash&lt;/code&gt; 등 을 찾을 수있는 곳을 모릅니다 . Cygwin의 bash 내에서 또는 Cygwin에서 실행되는 make-session에서 GHC를 사용할 때 모든 종류의 재미가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6fb0c28210e389deb1f0d69554122e023c56379f" translate="yes" xml:space="preserve">
          <source>GHC.Arr</source>
          <target state="translated">GHC.Arr</target>
        </trans-unit>
        <trans-unit id="da7f85eb75adadb0e3a66f594e581f331c40d7de" translate="yes" xml:space="preserve">
          <source>GHC.Base</source>
          <target state="translated">GHC.Base</target>
        </trans-unit>
        <trans-unit id="44509152f33f388480bcf9fe3d5b92c807be396b" translate="yes" xml:space="preserve">
          <source>GHC.ByteOrder</source>
          <target state="translated">GHC.ByteOrder</target>
        </trans-unit>
        <trans-unit id="f5b98f829355a95c653079b181f31daa126ed048" translate="yes" xml:space="preserve">
          <source>GHC.Char</source>
          <target state="translated">GHC.Char</target>
        </trans-unit>
        <trans-unit id="5e37af3d561ae073b83498872c71cf34be86dde1" translate="yes" xml:space="preserve">
          <source>GHC.Clock</source>
          <target state="translated">GHC.Clock</target>
        </trans-unit>
        <trans-unit id="8ffe6289544c44961284b55760ff10d112e4541c" translate="yes" xml:space="preserve">
          <source>GHC.Conc</source>
          <target state="translated">GHC.Conc</target>
        </trans-unit>
        <trans-unit id="dda0f595676f0ffb55c5548c6bb829dd285e7a06" translate="yes" xml:space="preserve">
          <source>GHC.Conc.IO</source>
          <target state="translated">GHC.Conc.IO</target>
        </trans-unit>
        <trans-unit id="2746731219cdf08f53175830aa9803d04aec4700" translate="yes" xml:space="preserve">
          <source>GHC.Conc.Sync</source>
          <target state="translated">GHC.Conc.Sync</target>
        </trans-unit>
        <trans-unit id="83fb25acb9eec7e0c6a528766737ddb292ac4508" translate="yes" xml:space="preserve">
          <source>GHC.Enum</source>
          <target state="translated">GHC.Enum</target>
        </trans-unit>
        <trans-unit id="9123ccdd7f945599c7fe10322ef603202538a9aa" translate="yes" xml:space="preserve">
          <source>GHC.Environment</source>
          <target state="translated">GHC.Environment</target>
        </trans-unit>
        <trans-unit id="b529524b0f71b0e58a38870afdf56699c7ebc263" translate="yes" xml:space="preserve">
          <source>GHC.Err</source>
          <target state="translated">GHC.Err</target>
        </trans-unit>
        <trans-unit id="8b82280ee98eb05df4a8965fe52566cac340fb84" translate="yes" xml:space="preserve">
          <source>GHC.Event</source>
          <target state="translated">GHC.Event</target>
        </trans-unit>
        <trans-unit id="12dc6472d306520b873a5a7a5654adf7b54689d0" translate="yes" xml:space="preserve">
          <source>GHC.Exception</source>
          <target state="translated">GHC.Exception</target>
        </trans-unit>
        <trans-unit id="c96bbd598503766a9fb6318fd8c79f4a71a78f43" translate="yes" xml:space="preserve">
          <source>GHC.Exception.Type</source>
          <target state="translated">GHC.Exception.Type</target>
        </trans-unit>
        <trans-unit id="90ef3784b2d875dcdf89ad8e658a107594b6af29" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack</source>
          <target state="translated">GHC.ExecutionStack</target>
        </trans-unit>
        <trans-unit id="48bff078e8cb052ebe31cac8d746bbc2937065cb" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack.Internal</source>
          <target state="translated">GHC.ExecutionStack.Internal</target>
        </trans-unit>
        <trans-unit id="740178902f8692cff1b10349f3d117b77680a7ca" translate="yes" xml:space="preserve">
          <source>GHC.Exts</source>
          <target state="translated">GHC.Exts</target>
        </trans-unit>
        <trans-unit id="7252e677664eb73a80122c6cd32aed07da4dcc79" translate="yes" xml:space="preserve">
          <source>GHC.Fingerprint</source>
          <target state="translated">GHC.Fingerprint</target>
        </trans-unit>
        <trans-unit id="15c984e784209d339e39d4b4707e5f0cefa9a13a" translate="yes" xml:space="preserve">
          <source>GHC.Float</source>
          <target state="translated">GHC.Float</target>
        </trans-unit>
        <trans-unit id="58b89be8337bef1dda3eb53785a12275cdc95c37" translate="yes" xml:space="preserve">
          <source>GHC.Float.RealFracMethods</source>
          <target state="translated">GHC.Float.RealFracMethods</target>
        </trans-unit>
        <trans-unit id="d587f40187b4db2d663256a48f3d1af2342efc78" translate="yes" xml:space="preserve">
          <source>GHC.Foreign</source>
          <target state="translated">GHC.Foreign</target>
        </trans-unit>
        <trans-unit id="3a626e20fa6f4e8f1c340c9eb7363e38c3316f5e" translate="yes" xml:space="preserve">
          <source>GHC.ForeignPtr</source>
          <target state="translated">GHC.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="d71c5bdbb27faa86159462f837dd83ea05d16901" translate="yes" xml:space="preserve">
          <source>GHC.GHCi</source>
          <target state="translated">GHC.GHCi</target>
        </trans-unit>
        <trans-unit id="300f938fef529877e36ee6eaa4a48f9f6ec09c20" translate="yes" xml:space="preserve">
          <source>GHC.Generics</source>
          <target state="translated">GHC.Generics</target>
        </trans-unit>
        <trans-unit id="e588603f44d2b51014250aa9f9d2afcfb672ba1d" translate="yes" xml:space="preserve">
          <source>GHC.IO</source>
          <target state="translated">GHC.IO</target>
        </trans-unit>
        <trans-unit id="a7741f8875636325e2148da2b4d2c46725337155" translate="yes" xml:space="preserve">
          <source>GHC.IO.Buffer</source>
          <target state="translated">GHC.IO.Buffer</target>
        </trans-unit>
        <trans-unit id="8823ff4de4c4340532b0cfa4463cf1fbb930f4a4" translate="yes" xml:space="preserve">
          <source>GHC.IO.BufferedIO</source>
          <target state="translated">GHC.IO.BufferedIO</target>
        </trans-unit>
        <trans-unit id="cb68556602bb0930005cd834412eb8de48905349" translate="yes" xml:space="preserve">
          <source>GHC.IO.Device</source>
          <target state="translated">GHC.IO.Device</target>
        </trans-unit>
        <trans-unit id="fbb7b69e98746b76a700b33f458ce5eedeb38078" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding</source>
          <target state="translated">GHC.IO.Encoding</target>
        </trans-unit>
        <trans-unit id="075bca53a743a5950f147684fa2c43f7f4ca0a1b" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Failure</source>
          <target state="translated">GHC.IO.Encoding.Failure</target>
        </trans-unit>
        <trans-unit id="fd2256eb1195a9c0458ef61c670f8ce80ea2ddb6" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Iconv</source>
          <target state="translated">GHC.IO.Encoding.Iconv</target>
        </trans-unit>
        <trans-unit id="00ded5a18e213f9805bc47d5e3787e0e350eb295" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Latin1</source>
          <target state="translated">GHC.IO.Encoding.Latin1</target>
        </trans-unit>
        <trans-unit id="ed9f709b9190c0954fa475c593069d81ded2a81f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF16</source>
          <target state="translated">GHC.IO.Encoding.UTF16</target>
        </trans-unit>
        <trans-unit id="1400abe49cf09bd1d336af6fdf075939f1efe75a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF32</source>
          <target state="translated">GHC.IO.Encoding.UTF32</target>
        </trans-unit>
        <trans-unit id="d878692ff2f4d831a32544a843c5acdc396b31f1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF8</source>
          <target state="translated">GHC.IO.Encoding.UTF8</target>
        </trans-unit>
        <trans-unit id="a84fd41659f18777189c7604f42de55b37d600dc" translate="yes" xml:space="preserve">
          <source>GHC.IO.Exception</source>
          <target state="translated">GHC.IO.Exception</target>
        </trans-unit>
        <trans-unit id="3664164a0a9f493250d7fca47e9c76fc73868ad4" translate="yes" xml:space="preserve">
          <source>GHC.IO.FD</source>
          <target state="translated">GHC.IO.FD</target>
        </trans-unit>
        <trans-unit id="707404689126a6d53ef5f85fb2bd01c00e0a6591" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle</source>
          <target state="translated">GHC.IO.Handle</target>
        </trans-unit>
        <trans-unit id="c4329ea977d1ffef67c80fe9b38f4268fbeb38ba" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.FD</source>
          <target state="translated">GHC.IO.Handle.FD</target>
        </trans-unit>
        <trans-unit id="923ccd81fee0632b161ee012f081f9bec1732ce1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Internals</source>
          <target state="translated">GHC.IO.Handle.Internals</target>
        </trans-unit>
        <trans-unit id="5f3751921c284354cc2714892e3de0248f4d7485" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Lock</source>
          <target state="translated">GHC.IO.Handle.Lock</target>
        </trans-unit>
        <trans-unit id="e9353efafa30350ec1b9fe2d5006dfa9d249cb1f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Text</source>
          <target state="translated">GHC.IO.Handle.Text</target>
        </trans-unit>
        <trans-unit id="0f48b5ff0fc29f2510c5ce2cd8ffb3341bb5b961" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Types</source>
          <target state="translated">GHC.IO.Handle.Types</target>
        </trans-unit>
        <trans-unit id="ccc52eccb2a6780a1feac3b140e02e5ed802441c" translate="yes" xml:space="preserve">
          <source>GHC.IO.IOMode</source>
          <target state="translated">GHC.IO.IOMode</target>
        </trans-unit>
        <trans-unit id="24072f4819afbd54c776518117a1b6955ba52e5a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Unsafe</source>
          <target state="translated">GHC.IO.Unsafe</target>
        </trans-unit>
        <trans-unit id="f02420ddb4478ea0713456e578325339787566cf" translate="yes" xml:space="preserve">
          <source>GHC.IOArray</source>
          <target state="translated">GHC.IOArray</target>
        </trans-unit>
        <trans-unit id="b099c579304d78700a56073579e16c9fb676186b" translate="yes" xml:space="preserve">
          <source>GHC.IORef</source>
          <target state="translated">GHC.IORef</target>
        </trans-unit>
        <trans-unit id="eb37a2aa23ca64e584c27fb9ac978b06a058cc51" translate="yes" xml:space="preserve">
          <source>GHC.Int</source>
          <target state="translated">GHC.Int</target>
        </trans-unit>
        <trans-unit id="0316241109fb8335149365d396b185cfa3658769" translate="yes" xml:space="preserve">
          <source>GHC.Integer</source>
          <target state="translated">GHC.Integer</target>
        </trans-unit>
        <trans-unit id="e484f5e76ac61e9bf4935aeb1f0f874dbb1c3a03" translate="yes" xml:space="preserve">
          <source>GHC.Integer.GMP.Internals</source>
          <target state="translated">GHC.Integer.GMP.Internals</target>
        </trans-unit>
        <trans-unit id="9edc8b73c4df17cdf1c86c03183217a78388cfe5" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms</source>
          <target state="translated">GHC.Integer.Logarithms</target>
        </trans-unit>
        <trans-unit id="788a99d5f2c3235b7c75ab1d70542647afac52ac" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms.Internals</source>
          <target state="translated">GHC.Integer.Logarithms.Internals</target>
        </trans-unit>
        <trans-unit id="cb20764f134c9f093388b799d6edb5c287e142c7" translate="yes" xml:space="preserve">
          <source>GHC.Ix</source>
          <target state="translated">GHC.Ix</target>
        </trans-unit>
        <trans-unit id="ead6a709bdc7b877770a207b97e68a4689718427" translate="yes" xml:space="preserve">
          <source>GHC.List</source>
          <target state="translated">GHC.List</target>
        </trans-unit>
        <trans-unit id="3d57cef545987da93a04e0d694042818f1a1bb34" translate="yes" xml:space="preserve">
          <source>GHC.MVar</source>
          <target state="translated">GHC.MVar</target>
        </trans-unit>
        <trans-unit id="023c57f0497f42e3b02a80cf9d26961f9f6b6620" translate="yes" xml:space="preserve">
          <source>GHC.Maybe</source>
          <target state="translated">GHC.Maybe</target>
        </trans-unit>
        <trans-unit id="164e6fbb161369078c402583c719d0b484bd9cd0" translate="yes" xml:space="preserve">
          <source>GHC.Natural</source>
          <target state="translated">GHC.Natural</target>
        </trans-unit>
        <trans-unit id="ae65dd69d6e330d710167ceb0ad3a94a6e56becc" translate="yes" xml:space="preserve">
          <source>GHC.Num</source>
          <target state="translated">GHC.Num</target>
        </trans-unit>
        <trans-unit id="5f7fc148c0a98a886a6a3bc6e44459e890a898b5" translate="yes" xml:space="preserve">
          <source>GHC.OldList</source>
          <target state="translated">GHC.OldList</target>
        </trans-unit>
        <trans-unit id="219f66845e1b6ccbde2aed8e298fc6202552996a" translate="yes" xml:space="preserve">
          <source>GHC.Profiling</source>
          <target state="translated">GHC.Profiling</target>
        </trans-unit>
        <trans-unit id="5b41899d682d90939969cd71598e1a3c11e49f01" translate="yes" xml:space="preserve">
          <source>GHC.Ptr</source>
          <target state="translated">GHC.Ptr</target>
        </trans-unit>
        <trans-unit id="6c493d68cbbd0903b98d07ddd334636ef44bbad5" translate="yes" xml:space="preserve">
          <source>GHC.RTS.Flags</source>
          <target state="translated">GHC.RTS.Flags</target>
        </trans-unit>
        <trans-unit id="c73e800dcd91edda6a6064deafb3d149d5c87f67" translate="yes" xml:space="preserve">
          <source>GHC.Read</source>
          <target state="translated">GHC.Read</target>
        </trans-unit>
        <trans-unit id="adc72ff9dcbbbacc479bcf7a5fc93c1182110918" translate="yes" xml:space="preserve">
          <source>GHC.Real</source>
          <target state="translated">GHC.Real</target>
        </trans-unit>
        <trans-unit id="6e5b89f9359d5a8bfd2c995515e3c8e2b55f3d6f" translate="yes" xml:space="preserve">
          <source>GHC.Records</source>
          <target state="translated">GHC.Records</target>
        </trans-unit>
        <trans-unit id="0b8521cdcc8c1ef2fd7980f6838d4055504ad2f4" translate="yes" xml:space="preserve">
          <source>GHC.ResponseFile</source>
          <target state="translated">GHC.ResponseFile</target>
        </trans-unit>
        <trans-unit id="3a165be025ea55dd62132f6d49a476a3baddb4bc" translate="yes" xml:space="preserve">
          <source>GHC.ST</source>
          <target state="translated">GHC.ST</target>
        </trans-unit>
        <trans-unit id="592556288d1e596e190164182dec84105b7b17e3" translate="yes" xml:space="preserve">
          <source>GHC.STRef</source>
          <target state="translated">GHC.STRef</target>
        </trans-unit>
        <trans-unit id="c812e3b66e96d4c9aea90e1021417aa178911a2a" translate="yes" xml:space="preserve">
          <source>GHC.Show</source>
          <target state="translated">GHC.Show</target>
        </trans-unit>
        <trans-unit id="22ed618911df1208a7b9b442d70898fc766ec074" translate="yes" xml:space="preserve">
          <source>GHC.Stable</source>
          <target state="translated">GHC.Stable</target>
        </trans-unit>
        <trans-unit id="a20386e520454f3f0f4eb16c34205fd57a4fcb9d" translate="yes" xml:space="preserve">
          <source>GHC.StableName</source>
          <target state="translated">GHC.StableName</target>
        </trans-unit>
        <trans-unit id="d96d568a6576a1e6aecb421974f05a14305bd684" translate="yes" xml:space="preserve">
          <source>GHC.Stack</source>
          <target state="translated">GHC.Stack</target>
        </trans-unit>
        <trans-unit id="021dc0f948747311677c43f8e4143154b011d4e0" translate="yes" xml:space="preserve">
          <source>GHC.Stack.CCS</source>
          <target state="translated">GHC.Stack.CCS</target>
        </trans-unit>
        <trans-unit id="679e7a678858657deeca5fb088d20447dbea9966" translate="yes" xml:space="preserve">
          <source>GHC.Stack.Types</source>
          <target state="translated">GHC.Stack.Types</target>
        </trans-unit>
        <trans-unit id="53710d33b34d9d6d31c7ecc3d9f9075270dc3145" translate="yes" xml:space="preserve">
          <source>GHC.StaticPtr</source>
          <target state="translated">GHC.StaticPtr</target>
        </trans-unit>
        <trans-unit id="7aca1996a3eb2739ab68b28f09387d1bdeef97de" translate="yes" xml:space="preserve">
          <source>GHC.Stats</source>
          <target state="translated">GHC.Stats</target>
        </trans-unit>
        <trans-unit id="52b6bdf52e6d2e6b85bf9394f21a48cc173b0453" translate="yes" xml:space="preserve">
          <source>GHC.TopHandler</source>
          <target state="translated">GHC.TopHandler</target>
        </trans-unit>
        <trans-unit id="a3585409158ac22303c455ac2f18bcd1f244ee48" translate="yes" xml:space="preserve">
          <source>GHC.TypeLits</source>
          <target state="translated">GHC.TypeLits</target>
        </trans-unit>
        <trans-unit id="5f4a237ca09fe1e39f1f4f57427500e3d5dde282" translate="yes" xml:space="preserve">
          <source>GHC.TypeNats</source>
          <target state="translated">GHC.TypeNats</target>
        </trans-unit>
        <trans-unit id="13937217117037ac8a14c5edc72c2b6bb8c575fd" translate="yes" xml:space="preserve">
          <source>GHC.Unicode</source>
          <target state="translated">GHC.Unicode</target>
        </trans-unit>
        <trans-unit id="1fdf724e37267fb3fb33f0dc048df4cee704bb65" translate="yes" xml:space="preserve">
          <source>GHC.Weak</source>
          <target state="translated">GHC.Weak</target>
        </trans-unit>
        <trans-unit id="ad4252ce69afb4d732c694779c89b861201a0b0c" translate="yes" xml:space="preserve">
          <source>GHC.Word</source>
          <target state="translated">GHC.Word</target>
        </trans-unit>
        <trans-unit id="4024a57753a6b7a3c40980a3cd0d4c49ca032099" translate="yes" xml:space="preserve">
          <source>GHCForeignImportPrim</source>
          <target state="translated">GHCForeignImportPrim</target>
        </trans-unit>
        <trans-unit id="f2f693f86b66430c4306b15c72b79c14a03a02ab" translate="yes" xml:space="preserve">
          <source>GHCi</source>
          <target state="translated">GHCi</target>
        </trans-unit>
        <trans-unit id="6b49fe46f1283625854f08ffa7ba78c6c9050030" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cdb6d8296bb43f9daf1bdf2b77da4db467b8f4d7" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 Haskell 표현을 대화식으로 평가하고 프로그램을 해석 할 수있는 GHC의 대화식 환경입니다. &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs에&lt;/a&gt; 대해 잘 알고 있다면 GHCi와 함께 집에있을 것입니다. 그러나 GHCi 또한 대화식 로딩 컴파일 된 코드에 대한 지원뿐만 아니라, 모든 보유지지 &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; GHC이 제공하는 언어를 확장한다. GHCi에는 대화식 디버거도 포함되어 있습니다 &lt;a href=&quot;#ghci-debugger&quot;&gt;(GHCi 디버거&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c594049ce431e4e83a8bbd749ab3a0ead79c69f9" translate="yes" xml:space="preserve">
          <source>GHCi actually accepts statements rather than just expressions at the prompt. This means you can bind values and functions to names, and use them in future expressions or statements.</source>
          <target state="translated">GHCi는 실제로 프롬프트에서 단순한 표현이 아닌 진술을 받아들입니다. 즉, 값과 함수를 이름에 바인딩하여 향후 식이나 명령문에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7854b19af27cbb06e171f164ce43770bc4a0b097" translate="yes" xml:space="preserve">
          <source>GHCi actually maintains &lt;em&gt;two&lt;/em&gt; sets of options:</source>
          <target state="translated">GHCi는 실제로 &lt;em&gt;두 가지&lt;/em&gt; 옵션 세트를 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="61c86bc68706119b7609650a914602b052655cdc" translate="yes" xml:space="preserve">
          <source>GHCi can also load plain object files (&lt;code&gt;.o&lt;/code&gt; or &lt;code&gt;.obj&lt;/code&gt; depending on your platform) or static archives (&lt;code&gt;.a&lt;/code&gt;) from the command-line. Just add the name the object file or library to the command line. On Windows GHCi also supports the &lt;code&gt;big-obj&lt;/code&gt; format.</source>
          <target state="translated">GHCi는 명령 행에서 일반 객체 파일 ( 플랫폼에 따라 &lt;code&gt;.o&lt;/code&gt; 또는 &lt;code&gt;.obj&lt;/code&gt; ) 또는 정적 아카이브 ( &lt;code&gt;.a&lt;/code&gt; )를 로드 할 수도 있습니다 . 오브젝트 파일 또는 라이브러리 이름을 명령 행에 추가하십시오. Windows에서 GHCi는 &lt;code&gt;big-obj&lt;/code&gt; 형식 도 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="07b8d7c354ee687c28dd2a23b15bfd5ced9be453" translate="yes" xml:space="preserve">
          <source>GHCi can use the profiling system to collect stack trace information when running interpreted code. To gain access to stack traces, start GHCi like this:</source>
          <target state="translated">GHCi는 프로파일 링 시스템을 사용하여 해석 된 코드를 실행할 때 스택 추적 정보를 수집 할 수 있습니다. 스택 추적에 액세스하려면 다음과 같이 GHCi를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b50b888b5a01174ea88ffe286c7e481b07e9ce3d" translate="yes" xml:space="preserve">
          <source>GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</source>
          <target state="translated">GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;/&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; &lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</target>
        </trans-unit>
        <trans-unit id="f211d1e24170f67686b938b7af0ca37f8a56b146" translate="yes" xml:space="preserve">
          <source>GHCi commands all begin with &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo; and consist of a single command name followed by zero or more parameters. The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands.</source>
          <target state="translated">GHCi 명령은 모두&amp;ldquo; &lt;code&gt;:&lt;/code&gt; &amp;rdquo;로 시작 하며 단일 명령 이름과 0 개 이상의 매개 변수로 구성됩니다. 명령 이름은 축약 될 수 있으며, 더 일반적으로 사용되는 명령을 위해 모호성이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="cdeb81402d6c2b81eaa4ac1ca68fa6f4bf53dc3f" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;.</source>
          <target state="translated">GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a2a469d965ea434ea6094be9ac79416520cda211" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;.</source>
          <target state="translated">GHCi에는 변수 값을 검사하기 위해 실행중인 계산을 중지 할 수있는 간단한 명령 스타일 디버거가 포함되어 있습니다. 디버거는 GHCi에 통합되어 있으며 기본적으로 켜져 있습니다. 디버깅 기능을 활성화하기 위해 플래그가 필요하지 않습니다. 한 가지 주요 제한 사항이 있습니다. 중단 점 및 단일 스테핑은 해석 된 모듈에서만 사용 가능합니다. 컴파일 된 코드는 디버거에 보이지 않습니다 &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="431b343589f64d92b46f202b4777afcb250c044a" translate="yes" xml:space="preserve">
          <source>GHCi does more than simple expression evaluation at the prompt. If you enter an expression of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then GHCi &lt;em&gt;executes&lt;/em&gt; it as an IO-computation.</source>
          <target state="translated">GHCi는 프롬프트에서 단순한 표현 평가 이상의 기능을 수행합니다. 일부 &lt;code&gt;a&lt;/code&gt; 에 대해 &lt;code&gt;IO a&lt;/code&gt; 유형의 표현식을 입력하면 GHCi가이를 IO 계산으로 &lt;em&gt;실행&lt;/em&gt; 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8c6bf6320b5a1d66ecb2b14b4d8bbf578afbaf4" translate="yes" xml:space="preserve">
          <source>GHCi does not respect the &lt;code&gt;default&lt;/code&gt; declaration in the module whose scope you are in. Instead, for expressions typed at the command line, you always get the default default-type behaviour; that is, &lt;code&gt;default(Int,Double)&lt;/code&gt;.</source>
          <target state="translated">GHCi는 범위가있는 모듈 의 &lt;code&gt;default&lt;/code&gt; 선언을 존중하지 않습니다 . 대신 명령 행에 입력 된 표현식의 경우 항상 기본 기본 유형 동작을 얻습니다. 즉, &lt;code&gt;default(Int,Double)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a337aefb4df415fd5ebe89389f3ec26434d221e1" translate="yes" xml:space="preserve">
          <source>GHCi has loaded the &lt;code&gt;Main&lt;/code&gt; module, and the prompt has changed to &lt;code&gt;*Main&amp;gt;&lt;/code&gt; to indicate that the current context for expressions typed at the prompt is the &lt;code&gt;Main&lt;/code&gt; module we just loaded (we&amp;rsquo;ll explain what the &lt;code&gt;*&lt;/code&gt; means later in &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). So we can now type expressions involving the functions from &lt;code&gt;Main.hs&lt;/code&gt;:</source>
          <target state="translated">GHCi는로드 &lt;code&gt;Main&lt;/code&gt; 모듈을하고 프롬프트가 변경되었습니다 &lt;code&gt;*Main&amp;gt;&lt;/code&gt; 프롬프트에서 입력 한 표현의 현재 상황이 발생한 것을 나타 내기 위해서 &lt;code&gt;Main&lt;/code&gt; (우리가 설명 할 것이다 우리가로드 모듈 무슨 &lt;code&gt;*&lt;/code&gt; 수단 나중에 &lt;a href=&quot;#ghci-scope&quot;&gt;범위에 정말 무엇 프롬프트에서?&lt;/a&gt; ). 이제 &lt;code&gt;Main.hs&lt;/code&gt; 의 함수와 관련된 표현식을 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e7e52195cfae2c519c03e23e784d7a20ae2e810" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6&lt;/a&gt; of the expression on which the breakpoint was placed ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; ), and additionally a binding for the result of the expression ( &lt;code&gt;_result&lt;/code&gt; ). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4760f6a58d8645892518b92f9d2d0455de2f6de1" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi는 브레이크 포인트가 배치 된 표현 의 자유 변수 &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; 에 대한 바인딩 ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; )을 추가로 제공했으며, 추가로 표현 결과에 대한 바인딩 ( &lt;code&gt;_result&lt;/code&gt; )을 제공했습니다. 이러한 변수는 GHCi에서 정의 할 수있는 다른 변수와 같습니다. 프롬프트에서 입력하는 표현식에 사용할 수 있으며 &lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; 등으로 유형을 요청할 수 있습니다 . 그러나 한 가지 중요한 차이점이 있습니다. 이러한 변수에는 부분 유형 만있을 수 있습니다. 예를 들어, 우리는의 값을 표시하려고하면 &lt;code&gt;left&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d52ffb5498f59a8fef6a199eb895dfb10991a53d" translate="yes" xml:space="preserve">
          <source>GHCi interprets the whole line as an expression to evaluate. The expression may not span several lines - as soon as you press enter, GHCi will attempt to evaluate it.</source>
          <target state="translated">GHCi는 전체 라인을 평가할 표현식으로 해석합니다. 표현식은 여러 줄에 걸쳐 있지 않을 수 있습니다. Enter 키를 누르면 GHCi가이를 평가하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d000c11f6d43ecae04979b2322aedc62f59206e3" translate="yes" xml:space="preserve">
          <source>GHCi is invoked with the command &lt;code&gt;ghci&lt;/code&gt; or &lt;code&gt;ghc --interactive&lt;/code&gt;. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said &lt;code&gt;:load modules&lt;/code&gt; at the GHCi prompt (see &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;). For example, to start GHCi and load the program whose topmost module is in the file &lt;code&gt;Main.hs&lt;/code&gt;, we could say:</source>
          <target state="translated">GHCi는 &lt;code&gt;ghci&lt;/code&gt; 또는 &lt;code&gt;ghc --interactive&lt;/code&gt; 명령으로 호출됩니다 . 명령 행에 하나 이상의 모듈 또는 파일 이름을 지정할 수도 있습니다. 이는 GHCi 프롬프트에서 &lt;code&gt;:load modules&lt;/code&gt; 을 말한 것처럼 GHCi에 지정된 모듈 또는 파일 이름 (및 이들이 의존하는 모든 모듈)을 로드 하도록 지시합니다 ( &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi 명령&lt;/a&gt; 참조 ). 예를 들어 GHCi를 시작하고 최상위 모듈이 &lt;code&gt;Main.hs&lt;/code&gt; 파일에있는 프로그램을로드하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02cd23e6d70f664fac3cadb490523ec73e9c61c9" translate="yes" xml:space="preserve">
          <source>GHCi options may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and unset using &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt;&lt;code&gt;:unset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHCi 옵션은 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; set을 사용하여 설정 하고 &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt; &lt;code&gt;:unset&lt;/code&gt; 을&lt;/a&gt; 사용하여 설정 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23865ba11579e59cab852eaf50893d8f8310f50d" translate="yes" xml:space="preserve">
          <source>GHCi tells us that, among other bindings, &lt;code&gt;f&lt;/code&gt; is in scope. However, its type is not fully known yet, and thus it is not possible to apply it to any arguments. Nevertheless, observe that the type of its first argument is the same as the type of &lt;code&gt;x&lt;/code&gt;, and its result type is shared with &lt;code&gt;_result&lt;/code&gt;.</source>
          <target state="translated">GHCi는 다른 결합들 중에서 &lt;code&gt;f&lt;/code&gt; 가 범위 내에 있다고 말한다 . 그러나 해당 유형은 아직 완전히 알려지지 않았으므로 인수에 적용 할 수 없습니다. 그럼에도 불구하고 첫 번째 인수의 유형은 &lt;code&gt;x&lt;/code&gt; 의 유형과 동일 하며 결과 유형은 &lt;code&gt;_result&lt;/code&gt; 와 공유됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c860feb5ec1b15da2c58750a623feabad614260" translate="yes" xml:space="preserve">
          <source>GHCi uses &lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt; under the hood. You can configure it to, among other things, prune duplicates from GHCi history. See: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline user preferences&lt;/a&gt;.</source>
          <target state="translated">GHCi는 &lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt; 을 후드 아래에서 사용합니다 . 무엇보다도 GHCi 히스토리에서 복제본을 제거하도록 구성 할 수 있습니다. &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline 사용자 환경 설정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27b5ae81e5a8c6380c3ff5286cbd9fbd01c0708a" translate="yes" xml:space="preserve">
          <source>GHCi will tab-complete names that are in scope; for example, if you run GHCi and type &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; then GHCi will expand it to &lt;code&gt;Just&lt;/code&gt;.</source>
          <target state="translated">GHCi는 범위 내에있는 이름을 탭 완성합니다. 당신이 GHCi를 실행하고 입력하는 경우, 예를 들어, &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; 다음 GHCi가로 확장됩니다 &lt;code&gt;Just&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="912aae042df048a72c9945fa25dfdd84648ce03f" translate="yes" xml:space="preserve">
          <source>GHCi.BinaryArray</source>
          <target state="translated">GHCi.BinaryArray</target>
        </trans-unit>
        <trans-unit id="ebc86550d6d8c6805a075e4ee82223ab44c22f1b" translate="yes" xml:space="preserve">
          <source>GHCi.Message</source>
          <target state="translated">GHCi.Message</target>
        </trans-unit>
        <trans-unit id="b7f4cbe61fcbdf53e726dde698f6d8427d6f6967" translate="yes" xml:space="preserve">
          <source>GHCi.ObjLink</source>
          <target state="translated">GHCi.ObjLink</target>
        </trans-unit>
        <trans-unit id="ef375e610fc95f4a10dd98a324ea900410775563" translate="yes" xml:space="preserve">
          <source>GHCi.RemoteTypes</source>
          <target state="translated">GHCi.RemoteTypes</target>
        </trans-unit>
        <trans-unit id="546802906c4994371bd7abbe6ba80eda19818ed8" translate="yes" xml:space="preserve">
          <source>GHCi.ResolvedBCO</source>
          <target state="translated">GHCi.ResolvedBCO</target>
        </trans-unit>
        <trans-unit id="f0b490ca46daa8f25bfa4855b33e28ba0663f27e" translate="yes" xml:space="preserve">
          <source>GHCi.Signals</source>
          <target state="translated">GHCi.Signals</target>
        </trans-unit>
        <trans-unit id="7899287feb51f897b8a19c276da822182ac21af9" translate="yes" xml:space="preserve">
          <source>GHCi.StaticPtrTable</source>
          <target state="translated">GHCi.StaticPtrTable</target>
        </trans-unit>
        <trans-unit id="bb3d877b385e2643cf85046824f0351addc9a45b" translate="yes" xml:space="preserve">
          <source>GHCi.TH</source>
          <target state="translated">GHCi.TH</target>
        </trans-unit>
        <trans-unit id="1d7f50c80144815a35dcdd8cead270f10c32bacd" translate="yes" xml:space="preserve">
          <source>GHCi.Utils</source>
          <target state="translated">GHCi.Utils</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="9adb6994755f905f75af8a5e2ea3803352181ba0" translate="yes" xml:space="preserve">
          <source>Garbage collection requires more memory than the actual residency. The factor depends on the kind of garbage collection algorithm in use: a major GC in the standard generation copying collector will usually require \(3L\) bytes of memory, where \(L\) is the amount of live data. This is because by default (see the RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; option) we allow the old generation to grow to twice its size (\(2L\)) before collecting it, and we require additionally \(L\) bytes to copy the live data into. When using compacting collection (see the &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option), this is reduced to \(2L\), and can further be reduced by tweaking the &lt;code&gt;-F
⟨factor⟩&lt;/code&gt; option. Also add the size of the allocation area (see &lt;code&gt;-A
⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">가비지 콜렉션에는 실제 상주보다 많은 메모리가 필요합니다. 이 요소는 사용중인 가비지 수집 알고리즘의 종류에 따라 다릅니다. 표준 세대 복사 수집기의 주요 GC에는 일반적으로 \ (3L \) 바이트의 메모리가 필요합니다. 여기서 \ (L \)는 라이브 데이터의 양입니다. 기본적으로 (RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; 옵션 참조 ) 수집하기 전에 이전 세대의 크기를 두 배 (\ (2L \))로 늘리고 추가로 \ (L \) 바이트가 필요하기 때문입니다. 라이브 데이터. 압축 콜렉션을 사용하는 경우 ( &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 옵션 참조 )이 값은 \ (2L \)로 줄어들고 &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; 옵션 을 조정하여 더 줄일 수 있습니다 . 할당 영역의 크기도 추가하십시오 ( &lt;code&gt;-A ⟨size⟩&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5ef3a23ff5d0585af5a5a4d93589e0f9057a7a61" translate="yes" xml:space="preserve">
          <source>GenLanguageDef</source>
          <target state="translated">GenLanguageDef</target>
        </trans-unit>
        <trans-unit id="54007d0d2b9f177a727f3b24f2d943df20b8deca" translate="yes" xml:space="preserve">
          <source>GenParser</source>
          <target state="translated">GenParser</target>
        </trans-unit>
        <trans-unit id="9cebabfd017fca2459439f2cdddbfa91800ffe40" translate="yes" xml:space="preserve">
          <source>GenTokenParser</source>
          <target state="translated">GenTokenParser</target>
        </trans-unit>
        <trans-unit id="11d4fb3475a101d8c9ae85b42e237a2007bc5294" translate="yes" xml:space="preserve">
          <source>General Quantity Semaphores</source>
          <target state="translated">일반 수량 세마포어</target>
        </trans-unit>
        <trans-unit id="5c4940d2f6feb1f80aee808047b0cd3c6532766b" translate="yes" xml:space="preserve">
          <source>General combining function</source>
          <target state="translated">일반 결합 기능</target>
        </trans-unit>
        <trans-unit id="3571f6a92057b6b6050f2f5c27ff1f749bf598bf" translate="yes" xml:space="preserve">
          <source>General combining functions</source>
          <target state="translated">일반적인 결합 기능</target>
        </trans-unit>
        <trans-unit id="d43b7ab00d837792990ac04a2a3ceeb8dca84942" translate="yes" xml:space="preserve">
          <source>General definitions for superclass methods</source>
          <target state="translated">수퍼 클래스 메소드에 대한 일반 정의</target>
        </trans-unit>
        <trans-unit id="51482529c6677f2a5e1536e3abbc044e55d04df8" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 접기는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 인스턴스를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cb698a6fdef53a2047596be60a1e1ba2d67960a" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4da0f615e29aa775c1b4d14d76dc1ab67db6f413" translate="yes" xml:space="preserve">
          <source>General marshalling utilities</source>
          <target state="translated">일반 마샬링 유틸리티</target>
        </trans-unit>
        <trans-unit id="3e8d2ea2ea48695ac53dc1175beaebda38571966" translate="yes" xml:space="preserve">
          <source>General rendering</source>
          <target state="translated">일반 렌더링</target>
        </trans-unit>
        <trans-unit id="b5c117841ab98d064d9ec4fdda7883c977e283c9" translate="yes" xml:space="preserve">
          <source>General-purpose finite sequences.</source>
          <target state="translated">범용 유한 시퀀스.</target>
        </trans-unit>
        <trans-unit id="95e3e92034cf70ddc1aa314c5db463429c48b08c" translate="yes" xml:space="preserve">
          <source>GeneralCategory</source>
          <target state="translated">GeneralCategory</target>
        </trans-unit>
        <trans-unit id="588fb85f0da12d2db4af030769a3fe542d141ec2" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2828c3cdd240b29b7adddd99ced6ba83ae84c8d8" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61a01cc59f938a5a2397118a9603bef23b0e4c2" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483a67423e4f02af497f083df740c06f787f15ed" translate="yes" xml:space="preserve">
          <source>Generalisations of list functions</source>
          <target state="translated">리스트 함수의 일반화</target>
        </trans-unit>
        <trans-unit id="9eac298b6aa11d6f17eff26f7546fc361e27b466" translate="yes" xml:space="preserve">
          <source>Generalised Algebraic Data Types generalise ordinary algebraic data types by allowing constructors to have richer return types. Here is an example:</source>
          <target state="translated">일반화 된 대수 데이터 형식 생성자가 더 풍부한 반환 형식을 가질 수 있도록하여 일반 대수 데이터 형식을 일반화합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82396ff476196b610167e5598629b6fdb9407c80" translate="yes" xml:space="preserve">
          <source>Generalised list comprehensions are a further enhancement to the list comprehension syntactic sugar to allow operations such as sorting and grouping which are familiar from SQL. They are fully described in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;Comprehensive comprehensions: comprehensions with &amp;ldquo;order by&amp;rdquo; and &amp;ldquo;group by&amp;rdquo;&lt;/a&gt;, except that the syntax we use differs slightly from the paper.</source>
          <target state="translated">일반화 된 목록 이해는 SQL에 익숙한 정렬 및 그룹화와 같은 조작을 허용하기 위해 목록 이해 구문 설탕을 더욱 향상시킵니다. 그것들은 우리가 사용하는 구문이 논문과 약간 다르다는 것을 제외하고는 &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;포괄적 인 이해 : &quot;순서 순&quot;과 &quot;그룹 순&quot;&lt;/a&gt; 에 대한 이해에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="573d76545cf52f17a400f8d78e7b0bd044b970f2" translate="yes" xml:space="preserve">
          <source>Generalizations of Control.Exception</source>
          <target state="translated">Control.Exception의 일반화</target>
        </trans-unit>
        <trans-unit id="f1955dbc970386d87459b85c65d5689fcd0a3342" translate="yes" xml:space="preserve">
          <source>Generalized abstracted pattern of safe resource acquisition and release in the face of errors. The first action &quot;acquires&quot; some value, which is &quot;released&quot; by the second action at the end. The third action &quot;uses&quot; the value and its result is the result of the &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce773570cb4c3e2d017c427de373025af29832e" translate="yes" xml:space="preserve">
          <source>Generalized casts for higher-order kinds</source>
          <target state="translated">고차 종류의 일반 캐스트</target>
        </trans-unit>
        <trans-unit id="3389ef31a5ee4e0a49d994e2e340b2c46172d24e" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using propositional equality</source>
          <target state="translated">건의 성 평등을 사용하는 일반화 된 형식 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="60044df19e927ec8addc3d0c22ff3af4bc023cc2" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using representational equality</source>
          <target state="translated">표현 평등을 사용하는 일반화 된 형식 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="cdde5c558c7ac937fc8c98638e3ae4ebfda3b764" translate="yes" xml:space="preserve">
          <source>Generalized functions</source>
          <target state="translated">일반화 된 기능</target>
        </trans-unit>
        <trans-unit id="5d04310694030c511391766d6d01208fdf93d744" translate="yes" xml:space="preserve">
          <source>Generalized version of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c694cfeb74e8c5c7ea7a993e0762b168e17f097b" translate="yes" xml:space="preserve">
          <source>GeneralizedNewtypeDeriving</source>
          <target state="translated">GeneralizedNewtypeDeriving</target>
        </trans-unit>
        <trans-unit id="8bba990109118772a7f157201f4852b56a93e1e4" translate="yes" xml:space="preserve">
          <source>Generally speaking, when &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 켜져 있을 때 GHC는 선언에 대해 가장 일반적인 종류를 유추하려고합니다. 많은 경우 (예 : 데이터 유형 선언에서) 정의에는 종류 유추를 알리는 오른쪽이 있습니다. 그러나 항상 그런 것은 아닙니다. 치다</target>
        </trans-unit>
        <trans-unit id="6d38b600df6d5f10e2c48ed50d09c245ecf3d220" translate="yes" xml:space="preserve">
          <source>Generally, you can only give a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma for a function defined in the same module. However if a function &lt;code&gt;f&lt;/code&gt; is given an &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; pragma at its definition site, then it can subsequently be specialised by importing modules (see &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;). For example</source>
          <target state="translated">일반적으로 동일한 모듈에 정의 된 함수에 대해서만 &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt; pragma를 제공 할 수 있습니다 . 그러나 함수 &lt;code&gt;f&lt;/code&gt; 에 정의 사이트에서 &lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; pragma 가 제공되면 모듈을 가져 와서 특수화 할 수 있습니다 ( &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt; 참조 ). 예를 들어</target>
        </trans-unit>
        <trans-unit id="d08cc5e55e4bb93f6a515a38b1f75c093fe6e0b3" translate="yes" xml:space="preserve">
          <source>Generate a capturable name. Occurrences of such names will be resolved according to the Haskell scoping rules at the occurrence site.</source>
          <target state="translated">캡처 가능한 이름을 생성하십시오. 이러한 이름의 발생은 발생 사이트의 Haskell 범위 지정 규칙에 따라 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="aeed47864f8a7339cdf8be33e82f7d412fe366b8" translate="yes" xml:space="preserve">
          <source>Generate a fresh name, which cannot be captured.</source>
          <target state="translated">캡처 할 수없는 새 이름을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="745ffd8ce042664827fc6bde881b37f864469beb" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; 도구의 입력에 적합한 형식으로 패키지 종속성의 그래프를 생성하십시오 . 예를 들어, 종속성 그래프의 PDF를 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4920f76f167528645c1fe9c22d2dcaa6a089bd0a" translate="yes" xml:space="preserve">
          <source>Generate a shared library (as opposed to an executable)</source>
          <target state="translated">공유 라이브러리 생성 (실행 파일이 아닌)</target>
        </trans-unit>
        <trans-unit id="0e4ae4a96f85bdbccc43169fe49910079cdbd8ff" translate="yes" xml:space="preserve">
          <source>Generate a standalone static library (as opposed to an executable). This is useful when cross compiling. The library together with all its dependencies ends up in in a single static library that can be linked against.</source>
          <target state="translated">실행 파일이 아닌 독립형 정적 라이브러리를 생성하십시오. 크로스 컴파일 할 때 유용합니다. 라이브러리는 모든 종속성과 함께 연결할 수있는 단일 정적 라이브러리로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="48fa807100bcd28bd53cce9c992b8ed46f5f86ef" translate="yes" xml:space="preserve">
          <source>Generate byte-code</source>
          <target state="translated">바이트 코드 생성</target>
        </trans-unit>
        <trans-unit id="545a23517098db1358fda76a5894abc504c8e13a" translate="yes" xml:space="preserve">
          <source>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">객체 코드 대신 바이트 코드를 생성하십시오. 이것이 GHCi의 기본값입니다. 바이트 코드는 현재 대화식 인터프리터에서만 사용할 수 있으며 디스크에는 저장되지 않습니다. 이 옵션은 &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt; 효과를 되돌릴 때만 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="3e361635a833ea10d7f04f532a6187549e8cd183" translate="yes" xml:space="preserve">
          <source>Generate code for a position-independent executable (where available)</source>
          <target state="translated">위치 독립적 실행 파일 (사용 가능한 경우)에 대한 코드 생성</target>
        </trans-unit>
        <trans-unit id="4be18defb8001300394d722f2553ae2882459ebd" translate="yes" xml:space="preserve">
          <source>Generate code for linking against dynamic libraries</source>
          <target state="translated">동적 라이브러리와의 링크를위한 코드 생성</target>
        </trans-unit>
        <trans-unit id="d7e41ba37b4936caed0d16b2edacb4f90c82806d" translate="yes" xml:space="preserve">
          <source>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use &lt;a href=&quot;#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위치 독립적 실행 파일에 링크 할 수있는 방식으로 코드 생성 현재 Linux x86 및 x86-64에서 작동합니다. Windows에서는 위치 독립적 인 코드가 사용되지 않으므로 플래그는 해당 플랫폼에서 작동하지 않습니다. 최종 실행 파일을 연결하려면 &lt;a href=&quot;#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce6b34021a0cac78d62ed0e9e10bda04e18b425e" translate="yes" xml:space="preserve">
          <source>Generate colour output.</source>
          <target state="translated">컬러 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0951be6b0579ecfa709ec3e3d4e23d98d9697421" translate="yes" xml:space="preserve">
          <source>Generate encapsulated PostScript suitable for inclusion in LaTeX documents. Usually, the PostScript graph is drawn in landscape mode in an area 9 inches wide by 6 inches high, and &lt;code&gt;hp2ps&lt;/code&gt; arranges for this area to be approximately centred on a sheet of a4 paper. This format is convenient of studying the graph in detail, but it is unsuitable for inclusion in LaTeX documents. The &lt;code&gt;-e&lt;/code&gt; option causes the graph to be drawn in portrait mode, with float specifying the width in inches, millimetres or points (the default). The resulting PostScript file conforms to the Encapsulated PostScript (EPS) convention, and it can be included in a LaTeX document using Rokicki&amp;rsquo;s dvi-to-PostScript converter &lt;code&gt;dvips&lt;/code&gt;.</source>
          <target state="translated">LaTeX 문서에 포함하기에 적합한 캡슐화 된 PostScript를 생성하십시오. 일반적으로 PostScript 그래프는 가로 9 인치 x 세로 6 인치 영역에서 가로 모드로 그려지며 &lt;code&gt;hp2ps&lt;/code&gt; 는이 영역이 대략 a4 용지 한 가운데에 정렬 되도록 합니다. 이 형식은 그래프를 자세히 연구하는 데 편리하지만 LaTeX 문서에 포함하기에는 적합하지 않습니다. &lt;code&gt;-e&lt;/code&gt; 옵션은 플로트 인치, 밀리미터 또는 포인트 (기본값)의 폭을 지정하여 세로 모드에서 그릴 수있는 그래프를 야기한다. 결과 PostScript 파일은 EPS (Encapsulated PostScript) 규칙을 준수하며 Rokicki의 dvi-to-PostScript 변환기 &lt;code&gt;dvips&lt;/code&gt; 를 사용하여 LaTeX 문서에 포함시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2af2316bd5693a2c95e9b58e4d09197236c735b7" translate="yes" xml:space="preserve">
          <source>Generate object code</source>
          <target state="translated">객체 코드 생성</target>
        </trans-unit>
        <trans-unit id="a0c3e54eb051234ea1cd507d92e6426c516da62b" translate="yes" xml:space="preserve">
          <source>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</source>
          <target state="translated">객체 코드를 생성하십시오. 이것은 GHCi 외부의 기본값이며 GHCi와 함께 사용하여 바이트 코드보다 우선적으로 객체 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5f95dcb03ea38c6a355f6b7e37726ccf839b63" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</source>
          <target state="translated">위치 독립적 인 코드 (공유 라이브러리에 넣을 수있는 코드)를 생성하십시오. 이것은 현재 Linux x86 및 x86-64에서 작동합니다. Windows에서는 위치 독립적 인 코드가 사용되지 않으므로 플래그는 해당 플랫폼에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cf6f42463945c51e0a71346f97c9c182c3bb40d" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (where available)</source>
          <target state="translated">위치 독립적 인 코드 생성 (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="7b85081d19a7d760ce6025f60cc20a50bec6fa8f" translate="yes" xml:space="preserve">
          <source>Generate warnings for Template Haskell splices</source>
          <target state="translated">Generate warnings for Template Haskell splices</target>
        </trans-unit>
        <trans-unit id="e379c504cb4385507060a36357b57f5b6a5617c5" translate="yes" xml:space="preserve">
          <source>Generated by preprocessors to convey source line numbers of the original source.</source>
          <target state="translated">원래 소스의 소스 라인 번호를 전달하기 위해 전처리기에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab5544c727327bbc41b60d8a2cb8ebc8ae7d766" translate="yes" xml:space="preserve">
          <source>Generates a &amp;ldquo;tags&amp;rdquo; file for Vi-style editors (&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt;&lt;code&gt;:ctags&lt;/code&gt;&lt;/a&gt;) or Emacs-style editors (&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt;&lt;code&gt;:etags&lt;/code&gt;&lt;/a&gt;). If no filename is specified, the default &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;TAGS&lt;/code&gt; is used, respectively. Tags for all the functions, constructors and types in the currently loaded modules are created. All modules must be interpreted for these commands to work.</source>
          <target state="translated">Vi 스타일 편집기 ( &lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt; &lt;code&gt;:ctags&lt;/code&gt; &lt;/a&gt; ) 또는 Emacs 스타일 편집기 ( &lt;a href=&quot;#ghci-cmd-:etags&quot;&gt; &lt;code&gt;:etags&lt;/code&gt; &lt;/a&gt; ) 의 &quot;태그&quot;파일을 생성합니다 . 파일 이름을 지정하지 않으면 기본 &lt;code&gt;tags&lt;/code&gt; 또는 &lt;code&gt;TAGS&lt;/code&gt; 가 각각 사용됩니다. 현재로드 된 모듈의 모든 함수, 생성자 및 유형에 대한 태그가 생성됩니다. 이 명령이 작동하려면 모든 모듈을 해석해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1bd17d2e723ab01d0f385c562085a77dec9c6bb" translate="yes" xml:space="preserve">
          <source>Generates a basic heap profile, in the file &lt;code&gt;prog.hp&lt;/code&gt;. To produce the heap profile graph, use &lt;strong&gt;hp2ps&lt;/strong&gt; (see &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; Rendering heap profiles to PostScript&lt;/a&gt;). The basic heap profile is broken down by data constructor, with other types of closures (functions, thunks, etc.) grouped into broad categories (e.g. &lt;code&gt;FUN&lt;/code&gt;, &lt;code&gt;THUNK&lt;/code&gt;). To get a more detailed profile, use the full profiling support (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;). Can be shortened to &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;prog.hp&lt;/code&gt; 파일에서 기본 힙 프로파일을 생성합니다 . 힙 프로파일 그래프를 생성하려면 &lt;strong&gt;hp2ps를&lt;/strong&gt; 사용 하십시오 ( &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; 힙 스크립트를 포스트 스크립트로 렌더링&lt;/a&gt; 참조 ). 기본 힙 프로파일은 다른 유형의 클로저 (함수, 썽크 등)가 광범위한 카테고리 (예 : &lt;code&gt;FUN&lt;/code&gt; , &lt;code&gt;THUNK&lt;/code&gt; ) 로 그룹화 된 데이터 생성자에 의해 분류됩니다 . 보다 자세한 프로파일을 얻으려면 전체 프로파일 링 지원 ( &lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링&lt;/a&gt; )을 사용하십시오. &lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; 로 단축 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f0c21738d6aa19fd6331a752c61d756e4c5d1e2" translate="yes" xml:space="preserve">
          <source>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt;.</source>
          <target state="translated">단일 GHC 실행에서 동적 및 정적 오브젝트 파일을 모두 생성합니다. 이 옵션은 기능적으로 GHC를 두 번 실행하는 것과 동일하며, 두 번째로 &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="e8bac696a293ef57322d908f3d774edadb0d2504" translate="yes" xml:space="preserve">
          <source>Generates the following instance</source>
          <target state="translated">다음 인스턴스를 생성합니다</target>
        </trans-unit>
        <trans-unit id="b291fccbb185f31ef661a2c06451e129d98c552c" translate="yes" xml:space="preserve">
          <source>Generating and unfolding ByteStrings</source>
          <target state="translated">ByteString 생성 및 펼치기</target>
        </trans-unit>
        <trans-unit id="09707d339d82aeb457a3844716013ddd13f46175" translate="yes" xml:space="preserve">
          <source>Generation and unfolding</source>
          <target state="translated">생성 및 전개</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="8bf59fb56a7fbc2509919ea5d6c04c72c7dbee3a" translate="yes" xml:space="preserve">
          <source>Generic constructor classes</source>
          <target state="translated">일반 생성자 클래스</target>
        </trans-unit>
        <trans-unit id="7d2bc27114c5d7ad7c30dc9b313f1b4d989a4929" translate="yes" xml:space="preserve">
          <source>Generic instances</source>
          <target state="translated">일반 인스턴스</target>
        </trans-unit>
        <trans-unit id="edd1e9ecd70c1b3bcef6a000b5ca8391176387c6" translate="yes" xml:space="preserve">
          <source>Generic operations defined in terms of &lt;code&gt;gunfold&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gunfold&lt;/code&gt; 정의 된 일반 작업</target>
        </trans-unit>
        <trans-unit id="62cabccddee103de78ef3b1f3cad602975680931" translate="yes" xml:space="preserve">
          <source>Generic programming support in GHC allows defining classes with methods that do not need a user specification when instantiating: the method body is automatically derived by GHC. This is similar to what happens for standard classes such as &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt;, for instance, but now for user-defined classes.</source>
          <target state="translated">GHC의 일반 프로그래밍 지원을 통해 인스턴스화시 사용자 지정이 필요없는 메소드로 클래스를 정의 할 수 있습니다. 메소드 본문은 GHC에 의해 자동으로 파생됩니다. 이것은 예를 들어 &lt;code&gt;Read&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; 와 같은 표준 클래스에서 발생하는 것과 유사 하지만 이제는 사용자 정의 클래스에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9bcfe34f539771b337b3c156114a2353174cdfa" translate="yes" xml:space="preserve">
          <source>Generic representation type</source>
          <target state="translated">일반 표현 유형</target>
        </trans-unit>
        <trans-unit id="f4695d8314afc3c9511e416fc10b8ff8fb7380b0" translate="yes" xml:space="preserve">
          <source>Generic representation types</source>
          <target state="translated">일반 표현 유형</target>
        </trans-unit>
        <trans-unit id="f51bcf3a7bcfa796b47cb80453f8bc18c1267d2f" translate="yes" xml:space="preserve">
          <source>Generic support</source>
          <target state="translated">일반 지원</target>
        </trans-unit>
        <trans-unit id="0331b125fb4cfaa359feb76babfc239c8fc6a530" translate="yes" xml:space="preserve">
          <source>Generic type classes</source>
          <target state="translated">제네릭 형식 클래스</target>
        </trans-unit>
        <trans-unit id="5cbb5c3303885c08bc437203ebbbcd41ffc5bbf1" translate="yes" xml:space="preserve">
          <source>Generic1</source>
          <target state="translated">Generic1</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="6f167df17b817244e8d92e3121badbef21fa27f9" translate="yes" xml:space="preserve">
          <source>Get a lazy ByteString that is terminated with a NUL byte. The returned string does not contain the NUL byte. Fails if it reaches the end of input without finding a NUL.</source>
          <target state="translated">NUL 바이트로 끝나는 게으른 ByteString을 가져옵니다. 리턴 된 문자열은 NUL 바이트를 포함하지 않습니다. NUL을 찾지 않고 입력의 끝에 도달하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c239d3b622f7fd565781d4f4dcab4e09927edb9e" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">$ PATH 변수에서 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 목록을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="1f1899930b9569e10c6cfc88a4f4b7498dee068a" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">$ PATH 변수에서 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 목록을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="af251c391320051e268fa05c67fd1aedca208ee5" translate="yes" xml:space="preserve">
          <source>Get a reference to a free variable at a breakpoint</source>
          <target state="translated">중단 점에서 자유 변수에 대한 참조 얻기</target>
        </trans-unit>
        <trans-unit id="57078d0a3c8b109b1f4379a4aa38d26dc7512eab" translate="yes" xml:space="preserve">
          <source>Get a specific component of the state, using a projection function supplied.</source>
          <target state="translated">제공된 프로젝션 함수를 사용하여 상태의 특정 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2662cd1869f4ae3db82467978d3f7b0019412bbe" translate="yes" xml:space="preserve">
          <source>Get a string representation of the current execution stack state.</source>
          <target state="translated">현재 실행 스택 상태의 문자열 표현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6c31e11b823050ba2cea2c8460aec3b4022e12b5" translate="yes" xml:space="preserve">
          <source>Get a trace of the current execution stack state.</source>
          <target state="translated">현재 실행 스택 상태의 추적을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c2e76620f050a66a8250541fdce2ec4f919515c5" translate="yes" xml:space="preserve">
          <source>Get all extensions.</source>
          <target state="translated">모든 확장을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="42372be9103fc691ad731746a614a19b7f331cb5" translate="yes" xml:space="preserve">
          <source>Get an environment value or a default value.</source>
          <target state="translated">환경 값 또는 기본값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dbb6b436eb32ee410eebe762e1c62025718fa179" translate="yes" xml:space="preserve">
          <source>Get an execution stack.</source>
          <target state="translated">실행 스택을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a8196f1a388937eb3c1622a100e017f856c9eea6" translate="yes" xml:space="preserve">
          <source>Get current runtime system statistics.</source>
          <target state="translated">현재 런타임 시스템 통계를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e715c7dae3e98783c9bdf9c4e4ab64aac77cb14" translate="yes" xml:space="preserve">
          <source>Get state from the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Note that the state is local to the Haskell module in which the Template Haskell expression is executed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 모나드 에서 상태를 얻습니다 . 상태는 Template Haskell 표현식이 실행되는 Haskell 모듈에 국한됩니다.</target>
        </trans-unit>
        <trans-unit id="3aeb2eca8a488b50abdc7a58183f5262c45f8bd7" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 를 a의 머리에 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e515f15bea5855df5eb0cbb2b2918fe8e0d835d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 주어진 값과 연관된합니다.</target>
        </trans-unit>
        <trans-unit id="add5e999e95e74780d3f395fb32f6bda146264c9" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 를 a의 머리에 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cb72e96eed05217967ca7009b90c06b60dd3df" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 주어진 값과 연관된합니다.</target>
        </trans-unit>
        <trans-unit id="6be4742313ddbe2b9ab325b82b61b955b5264d92" translate="yes" xml:space="preserve">
          <source>Get the UT1 time of a local time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">특정 자오선에서 현지 시간의 UT1 시간을 가져옵니다 (도, 양수는 동쪽).</target>
        </trans-unit>
        <trans-unit id="72efa4e3276ea481268ea1bf73cc2a94fbd81a20" translate="yes" xml:space="preserve">
          <source>Get the UTC time of a local time in a time zone.</source>
          <target state="translated">시간대에서 현지 시간의 UTC 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7f011efdea73fd8590a82ad76b2135b1a44dfcb1" translate="yes" xml:space="preserve">
          <source>Get the base name, without an extension or path.</source>
          <target state="translated">확장자 나 경로없이 기본 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98b9a6f135af51d0129f1689a0b25dbe177eead3" translate="yes" xml:space="preserve">
          <source>Get the contents of the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 환경 변수 의 내용을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0b700626a66522b75396b422eaadb24213066b7c" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; from the system clock.</source>
          <target state="translated">시스템 시계에서 현재 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; 을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0270de0567bc90a30e367bf358f647b2ce50ddaa" translate="yes" xml:space="preserve">
          <source>Get the current POSIX time from the system clock.</source>
          <target state="translated">시스템 시계에서 현재 POSIX 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cfadd67e7a7e19604994f22e158522395dbaf06e" translate="yes" xml:space="preserve">
          <source>Get the current line input history.</source>
          <target state="translated">현재 줄 입력 기록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="66262b55256050223b751d7abe957f7eec02fd90" translate="yes" xml:space="preserve">
          <source>Get the current time-zone.</source>
          <target state="translated">현재 시간대를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e7163ecf6dc60dacacf312a4e68e048ac45e8b8b" translate="yes" xml:space="preserve">
          <source>Get the current value of &lt;code&gt;errno&lt;/code&gt; in the current thread.</source>
          <target state="translated">현재 스레드에서 &lt;code&gt;errno&lt;/code&gt; 의 현재 값을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="d1d2b0b9bd8a9db6da9a73ad6ce4498757df48e6" translate="yes" xml:space="preserve">
          <source>Get the default size of the terminal. For resizeable terminals (e.g., &lt;code&gt;xterm&lt;/code&gt;), these may not correspond to the actual dimensions.</source>
          <target state="translated">터미널의 기본 크기를 가져옵니다. 크기 조정 가능한 터미널 (예 : &lt;code&gt;xterm&lt;/code&gt; )의 경우 실제 크기와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="229fedca2524f6589d1fa7505416425ee29197a8" translate="yes" xml:space="preserve">
          <source>Get the directory name, move up one level.</source>
          <target state="translated">디렉토리 이름을 가져 와서 한 단계 위로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="8db9a8dd60cf3b1a36fa15f815b60c5ad67c15ec" translate="yes" xml:space="preserve">
          <source>Get the drive from a filepath.</source>
          <target state="translated">파일 경로에서 드라이브를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="61a15789e89a9c4b730cbee22dba43d0dca29efe" translate="yes" xml:space="preserve">
          <source>Get the echoing status of a handle connected to a terminal.</source>
          <target state="translated">터미널에 연결된 핸들의 에코 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e4b0de19671fd4212da0915b4b88fb238c175abf" translate="yes" xml:space="preserve">
          <source>Get the extension of a file, returns &lt;code&gt;&quot;&quot;&lt;/code&gt; for no extension, &lt;code&gt;.ext&lt;/code&gt; otherwise.</source>
          <target state="translated">파일의 확장자를 가져오고 확장자가 없으면 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;.ext&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b728f0791284fd67656c0aa4feb4d641406bdcd3" translate="yes" xml:space="preserve">
          <source>Get the file name.</source>
          <target state="translated">파일 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="49ee7152dd7f669fc2d1e6f53b094147b3cae76a" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">다른 문자열에서 하위 문자열의 첫 번째 색인을 가져 오거나 문자열을 찾을 수 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 가져 옵니다. &lt;code&gt;findSubstring p s&lt;/code&gt; 는 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f14dd66fb1e3670e1835aac5f144235035b8e6b1" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee775ce9d7b994986c62951bb94f01d85eb44d2c" translate="yes" xml:space="preserve">
          <source>Get the fraction of a day since midnight given a time of day.</source>
          <target state="translated">주어진 시간에 자정 이후의 하루의 일부를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a2a3573464388922e250a7eb45275992553e7757" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">창의 제목을 사용하여 현재 콘솔 창의 핸들을 가져옵니다. 참조 : &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c5f2319e438a4baa014695b30ce229379a38b83" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window.</source>
          <target state="translated">현재 콘솔 창의 핸들을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0a7f4400d930923897bb54c841a6213ed68644f4" translate="yes" xml:space="preserve">
          <source>Get the label for a given key.</source>
          <target state="translated">주어진 키의 레이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5aeda20685c51fc6abcd2b337403dbbcd7923a16" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 레이블을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="fa9be9ab91ef24c2b81729a5316d49813c0c3129" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 레이블을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9e900e82bce3a84192ef0492d0d7a7d7cc15cf88" translate="yes" xml:space="preserve">
          <source>Get the local time of a UT1 time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">특정 자오선에서 UT1 시간의 현지 시간을 가져옵니다 (도, 양은 동쪽).</target>
        </trans-unit>
        <trans-unit id="a833157a0c1508bf9bcfd2a53e5dcc6026df288f" translate="yes" xml:space="preserve">
          <source>Get the local time of a UTC time in a time zone.</source>
          <target state="translated">시간대에서 UTC 시간의 현지 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d2cb2c2ac1383013616533e9898eff073620487a" translate="yes" xml:space="preserve">
          <source>Get the local time-zone for a given time (varying as per summertime adjustments).</source>
          <target state="translated">주어진 시간 동안 현지 시간대를 가져옵니다 (여름 시간 조정에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="6114c6996f47966af81f9bc3720926a914d7721e" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 모듈을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="195b1279f51510a869c9ae7e93ef77f8d07cfcaf" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 모듈을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="dfd8ea5bc6022f728ddbfd7c123fbf615d9688aa" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TBQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">&lt;code&gt;TBQueue&lt;/code&gt; 에서 제거하지 않고 다음 값을 가져 와서 채널이 비어 있으면 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="ea4da6389ff2053f72d8e6ce3d12629df113a35f" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TChan&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">&lt;code&gt;TChan&lt;/code&gt; 에서 다음 값을 제거하지 말고 채널이 비어 있는지 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="12978c3ca4699ea4b74cf23abc51101451dfa99c" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">채널을 비우면 다시 시도 하여 &lt;code&gt;TQueue&lt;/code&gt; 에서 제거하지 않고 다음 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="bf9180c869cf2ed71dc13f9fcb1eb1c6e3205b73" translate="yes" xml:space="preserve">
          <source>Get the number of picoseconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt; 의 피코 초 수를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="c41d9abbda9d142fc31fefd829bb6067eeb4ce90" translate="yes" xml:space="preserve">
          <source>Get the number of the Monday-starting week in the year and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Monday is 1, Sunday is 7 (as &lt;code&gt;%u&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">해당 연도의 요일과 요일을 구하십시오. 첫 번째 월요일 주 1의 첫 번째 날, 올해 이전의 모든 일 주 0입니다 (같은 &lt;code&gt;%W&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ). 월요일 일요일 (로 7, 1 &lt;code&gt;%u&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0df1f5547dc8aa7816f6fad31fb426c23b895b69" translate="yes" xml:space="preserve">
          <source>Get the number of the Sunday-starting week in the year and the day of the week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Sunday is 0, Saturday is 6 (as &lt;code&gt;%w&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">연도의 요일과 요일의 수를 구하십시오. 첫 번째 일요일은 주 1의 첫 번째 요일이며, 그 이전의 모든 요일은 주 0입니다 ( &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;%U&lt;/code&gt; 로 ). 일요일 토요일 (로 6이며, 0 &lt;code&gt;%w&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="121d46ceb7a963cb07f940143c37c6199a392894" translate="yes" xml:space="preserve">
          <source>Get the permissions of a file or directory.</source>
          <target state="translated">파일 또는 디렉토리의 권한을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0b02102ad5781ec349c4ebacac0f7e53440d1227" translate="yes" xml:space="preserve">
          <source>Get the precedence of a fixity value.</source>
          <target state="translated">고정도 값의 우선 순위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e7143c5b76253904c07ab35abe499b891a12912e" translate="yes" xml:space="preserve">
          <source>Get the remaining bytes as a lazy ByteString. Note that this can be an expensive function to use as it forces reading all input and keeping the string in-memory.</source>
          <target state="translated">나머지 바이트를 게으른 ByteString으로 가져옵니다. 이 기능은 모든 입력을 읽고 문자열을 메모리에 유지해야하므로 값 비싼 기능이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1304ab12c0cdd21150623c6715f63616fbbb4e78" translate="yes" xml:space="preserve">
          <source>Get the seconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; 에서 초를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="934367e164393d0463e93c43a0ab568d78bce4aa" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 소스 범위를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3c3cbce66b5c2a88daa26c2b44a8fd7660727935" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 소스 범위를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d92d0722c9103f5297ca98c8e8cc4cdf409d235d" translate="yes" xml:space="preserve">
          <source>Get the stack trace attached to an object.</source>
          <target state="translated">객체에 연결된 스택 추적을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ef4ec76b2d57cdc855102b78c7d2aacd5eb5df5f" translate="yes" xml:space="preserve">
          <source>Get the string corresponding to the given format specifier.</source>
          <target state="translated">주어진 형식 지정자에 해당하는 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="87aef325e766ce9f4d00515df7046505bd4518cc" translate="yes" xml:space="preserve">
          <source>Get the system time, epoch start of 1970 UTC, leap-seconds ignored. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; is typically much faster than &lt;code&gt;getCurrentTime&lt;/code&gt;.</source>
          <target state="translated">시스템 시간 (1970 UTC 시작, 윤초 무시)을 얻습니다. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; 은 일반적으로 &lt;code&gt;getCurrentTime&lt;/code&gt; 보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="7079387e20d5a7e77408141907d7b3e57605a870" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 의 꼬리를 얻으십시오 .</target>
        </trans-unit>
        <trans-unit id="0d673419acfa57ddfd2386504b1ce9ad7e3752ee" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 의 꼬리를 얻으십시오 .</target>
        </trans-unit>
        <trans-unit id="9fd6f0d6fca981e6ab4e6521490eddb2c5712dc5" translate="yes" xml:space="preserve">
          <source>Get the time of day given a time since midnight. Time more than 24h will be converted to leap-seconds.</source>
          <target state="translated">자정 이후 시간이 주어진 시간을 가져옵니다. 24 시간 이상의 시간은 윤초로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8502401c97ea5b01798883d629ca915252c4bb4a" translate="yes" xml:space="preserve">
          <source>Get the time of day given the fraction of a day since midnight.</source>
          <target state="translated">자정 이후 하루 중 일부만 주어진 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="87868e820d0672f58ddcfe614c42c8b0983a793a" translate="yes" xml:space="preserve">
          <source>Get the time since midnight for a given time of day.</source>
          <target state="translated">하루 중 자정부터 시간을받습니다.</target>
        </trans-unit>
        <trans-unit id="1b78fe6cc806943f6f8e66a65db6ae9cfdb7e198" translate="yes" xml:space="preserve">
          <source>Get the total number of bytes read to this point.</source>
          <target state="translated">이 시점까지 읽은 총 바이트 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b2759c7b05c76b086373cf3cd5862282e5c13612" translate="yes" xml:space="preserve">
          <source>Get user name. See: &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;, &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</source>
          <target state="translated">사용자 이름을 가져옵니다. 참조 : &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt; , &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5c8a83eb7ab72a3dc65bc027d0f4aa047843fc7" translate="yes" xml:space="preserve">
          <source>Get/Set Foreground Window.</source>
          <target state="translated">전경 창 가져 오기 / 설정.</target>
        </trans-unit>
        <trans-unit id="903bf1d323eabebea6c98315f978de0785ae607a" translate="yes" xml:space="preserve">
          <source>GetDCExFlags</source>
          <target state="translated">GetDCExFlags</target>
        </trans-unit>
        <trans-unit id="89693458149c776750a29304631c344bbe585ec6" translate="yes" xml:space="preserve">
          <source>GetOpt</source>
          <target state="translated">GetOpt</target>
        </trans-unit>
        <trans-unit id="bebb9ee2bec563ef922802bc58d46f783e690375" translate="yes" xml:space="preserve">
          <source>Gets a GHC Handle File description from the given OS Handle or POSIX fd.</source>
          <target state="translated">주어진 OS 핸들 또는 POSIX fd에서 GHC 핸들 파일 설명을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="391454aac39ac02e0b6599b94000d8e1ad34b74e" translate="yes" xml:space="preserve">
          <source>Gets specific component of the state, using a projection function supplied.</source>
          <target state="translated">제공된 투영 함수를 사용하여 상태의 특정 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6061427a31c5db7d197b3782356bc17d6f9846c4" translate="yes" xml:space="preserve">
          <source>Gets the constructor for an index (algebraic datatypes only)</source>
          <target state="translated">인덱스의 생성자를 가져옵니다 (대수 데이터 유형 만 해당)</target>
        </trans-unit>
        <trans-unit id="d48574aaa6a44f8bb266db4ad641f32e96c244ee" translate="yes" xml:space="preserve">
          <source>Gets the constructors of an algebraic datatype</source>
          <target state="translated">대수 데이터 유형의 생성자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="30d18e2f7f8f2762c44e631f431574183f3d5e0a" translate="yes" xml:space="preserve">
          <source>Gets the datatype of a constructor</source>
          <target state="translated">생성자의 데이터 유형을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="d4dc76f4469b81893c0ae2bc88486f930017fb3d" translate="yes" xml:space="preserve">
          <source>Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.</source>
          <target state="translated">생성자의 필드 레이블을 가져옵니다. 레이블 목록은 원래 생성자 선언에 제공된 순서와 동일한 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e7a5b1389209d807faab0ae733fe92f6a6a0918a" translate="yes" xml:space="preserve">
          <source>Gets the fixity of a constructor</source>
          <target state="translated">생성자의 고정도를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="2aeda0e99dcc18340bc33ab99d623627ed797ffd" translate="yes" xml:space="preserve">
          <source>Gets the index of a constructor (algebraic datatypes only)</source>
          <target state="translated">생성자의 색인을 가져옵니다 (대수 데이터 유형 만 해당)</target>
        </trans-unit>
        <trans-unit id="24b5a11d77af890b85eeec066f5550cfcba9c2d2" translate="yes" xml:space="preserve">
          <source>Gets the maximum constructor index of an algebraic datatype</source>
          <target state="translated">대수 데이터 유형의 최대 생성자 색인을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="63208cbec1942c64c7945f85554d64b17e167933" translate="yes" xml:space="preserve">
          <source>Gets the module of a type constructor: take *.*.*... before name</source>
          <target state="translated">형식 생성자의 모듈을 가져옵니다. 이름 앞에 *. *. * ...를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a14644b47cefa2fe7b14baa4f1e18f50cba475e7" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of a datatype</source>
          <target state="translated">데이터 유형의 공개 프리젠 테이션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="aa6153842db5ae726fc9aeb6bbb6b9011dfbc619" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of constructors</source>
          <target state="translated">생성자의 공개 프리젠 테이션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="703cb827ba9bdd1f867b291abff6c22c30e6a5e1" translate="yes" xml:space="preserve">
          <source>Gets the string for a constructor</source>
          <target state="translated">생성자에 대한 문자열을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="073e5a617058affe4e3dd60346b258d7e3ada99f" translate="yes" xml:space="preserve">
          <source>Gets the type constructor including the module</source>
          <target state="translated">모듈을 포함한 형식 생성자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="878dc6c0dba59b9499bd6c7cb41176237f1830f2" translate="yes" xml:space="preserve">
          <source>Gets the unqualified type constructor: drop *.*.*... before name</source>
          <target state="translated">규정되지 않은 유형 생성자를 가져옵니다. 이름 앞에 drop *. *. * ...</target>
        </trans-unit>
        <trans-unit id="eae1640c76d18f7f4e0493ecb26f076efc1608f6" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플러그인 모듈에 인수를 제공하십시오. 모듈은 &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt; 으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e2007c872e45e146dace044ab7de7d8433373895" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;</source>
          <target state="translated">플러그인 모듈에 인수를 제공하십시오. &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; 으로 모듈을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="df37476f32c9a34e20351ac98761daee0a7c8824" translate="yes" xml:space="preserve">
          <source>Give explicit type signatures:</source>
          <target state="translated">명시적인 유형 서명을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b1486578eb7ad0f6181dbd9aee1d050053d73d85" translate="yes" xml:space="preserve">
          <source>GiveGCStats</source>
          <target state="translated">GiveGCStats</target>
        </trans-unit>
        <trans-unit id="76d11fa818460b917132ef39c92a210ad06313c6" translate="yes" xml:space="preserve">
          <source>Given a CNF and the address of one its compact blocks, returns the next compact block and its utilized size, or &lt;code&gt;nullAddr#&lt;/code&gt; if the argument was the last compact block in the CNF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94191c500f1483bd7efa1a2a99e51782da6743c9" translate="yes" xml:space="preserve">
          <source>Given a compact and the address of one its blocks, returns the next block and its size, or #nullAddr if the argument was the last block in the compact.</source>
          <target state="translated">압축과 블록 중 하나의 주소가 주어지면 다음 블록과 크기, 또는 인수가 압축의 마지막 블록 인 경우 #nullAddr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a80b2cab78c4d18e4e971d00e535e51ca962e1e" translate="yes" xml:space="preserve">
          <source>Given a list of path segments, expand &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;. The path segments must not contain path separators.</source>
          <target state="translated">경로 세그먼트 목록이 제공되면을 확장하십시오 &lt;code&gt;.&lt;/code&gt; 와 &lt;code&gt;..&lt;/code&gt; . . 경로 세그먼트에는 경로 구분 기호가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3c7188c588c63ac10069c82a4b6f332a946f2d2" translate="yes" xml:space="preserve">
          <source>Given a list of strings, concatenate them into a single string with escaping of certain characters, and the addition of a newline between each string. The escaping is done by adding a single backslash character before any whitespace, single quote, double quote, or backslash character, so this escaping character must be removed. Unescaped whitespace (in this case, newline) is part of this &quot;transport&quot; format to indicate the end of the previous string and the start of a new string.</source>
          <target state="translated">문자열 목록이 제공되면 특정 문자를 이스케이프하고 각 문자열 사이에 줄 바꿈을 추가하여 단일 문자열로 연결하십시오. 이스케이프는 공백, 작은 따옴표, 큰 따옴표 또는 백 슬래시 문자 앞에 단일 백 슬래시 문자를 추가하여 수행되므로이 ​​이스케이프 문자를 제거해야합니다. 이스케이프 처리되지 않은 공백 (이 경우 줄 바꾸기)은이 &quot;전송&quot;형식의 일부로 이전 문자열의 끝과 새 문자열의 시작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16da4c70b81333f0df3ff68a48df5f83b45f827d" translate="yes" xml:space="preserve">
          <source>Given a means of mapping the elements of a structure to lists, computes the concatenation of all such lists in order.</source>
          <target state="translated">구조의 요소를 목록에 매핑하는 수단이 주어지면 모든 목록의 연결을 순서대로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3a801cbb38fd452cebffd80bbe0ff104534670f0" translate="yes" xml:space="preserve">
          <source>Given a name or path, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; appends the &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; to the query and searches for executable files in the list of given search directories and returns all occurrences.</source>
          <target state="translated">이름 또는 경로가 지정되면 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; 을 조회에 추가하고 지정된 검색 디렉토리 목록에서 실행 파일을 검색하고 모든 발생을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f60a5850abfa409415094c2e4639245bcd5e4453" translate="yes" xml:space="preserve">
          <source>Given a parallel comprehension of the form:</source>
          <target state="translated">다음과 같은 형식의 병렬 이해가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7f7b64d5937cb8bf270b46af60debea6611cd0d2" translate="yes" xml:space="preserve">
          <source>Given a pattern synonym definition of the form</source>
          <target state="translated">양식의 패턴 동의어 정의가 주어짐</target>
        </trans-unit>
        <trans-unit id="965f2d8e8f9362b4a99f9e5b536b6cb970cf61ea" translate="yes" xml:space="preserve">
          <source>Given a program &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; and arguments &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; returns a string suitable for pasting into &lt;code&gt;/bin/sh&lt;/code&gt; (on Unix systems) or &lt;code&gt;CMD.EXE&lt;/code&gt; (on Windows).</source>
          <target state="translated">감안할 때 프로그램 &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; 와 인수 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 에 붙여 넣는 캐릭터에 적합한 반환 &lt;code&gt;/bin/sh&lt;/code&gt; (유닉스 시스템) 또는 &lt;code&gt;CMD.EXE&lt;/code&gt; (Windows에서)를.</target>
        </trans-unit>
        <trans-unit id="3eb5e163812056919d8a8728f088bc84becbf489" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. In the case where the source and destination are the same array the source and destination regions may overlap.</source>
          <target state="translated">소스 배열, 소스 배열에 대한 오프셋, 대상 배열, 대상 배열에 대한 오프셋 및 복사 할 요소가 여러 개인 경우, 소스 배열에서 대상 배열로 요소를 복사하십시오. 두 배열 모두 지정된 범위를 완전히 포함해야하지만 이것은 확인되지 않습니다. 소스와 대상이 동일한 배열 인 경우 소스와 대상 영역이 겹칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="397134dbcf199297b7dfe8e0847122e69780ab05" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. The two arrays must not be the same array in different states, but this is not checked either.</source>
          <target state="translated">소스 배열, 소스 배열에 대한 오프셋, 대상 배열, 대상 배열에 대한 오프셋 및 복사 할 요소가 여러 개인 경우, 소스 배열에서 대상 배열로 요소를 복사하십시오. 두 배열 모두 지정된 범위를 완전히 포함해야하지만 이것은 확인되지 않습니다. 두 어레이는 서로 다른 상태에서 동일한 어레이가 아니어야하지만이 역시 점검되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b650bc9b9dd959ede9c56caf5b27fbb08e9b7a5" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. The source and destination arrays can refer to the same array. Both arrays must fully contain the specified ranges, but this is not checked. The regions are allowed to overlap, although this is only possible when the same array is provided as both the source and the destination.</source>
          <target state="translated">소스 배열, 소스 배열에 대한 오프셋, 대상 배열, 대상 배열에 대한 오프셋 및 복사 할 요소가 여러 개인 경우, 소스 배열에서 대상 배열로 요소를 복사하십시오. 소스 및 대상 배열은 동일한 배열을 참조 할 수 있습니다. 두 배열 모두 지정된 범위를 완전히 포함해야하지만 이것은 확인되지 않습니다. 동일한 배열이 소스와 대상으로 모두 제공되는 경우에만 가능하지만 영역은 겹칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9806083ebd16a3822ef2b68e8b1fdca151f0e70" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, and a number of elements to copy, create a new array with the elements from the source array. The provided array must fully contain the specified range, but this is not checked.</source>
          <target state="translated">소스 배열, 소스 배열에 대한 오프셋 및 복사 할 여러 요소가 주어지면 소스 배열의 요소로 새 배열을 만듭니다. 제공된 배열은 지정된 범위를 완전히 포함해야하지만 이것은 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="969049b655813db2b900482374a384fed3209666" translate="yes" xml:space="preserve">
          <source>Given a string of concatenated strings, separate each by removing a layer of &lt;em&gt;quoting&lt;/em&gt; and/or &lt;em&gt;escaping&lt;/em&gt; of certain characters.</source>
          <target state="translated">연결된 문자열 문자열이 제공되면 특정 문자 의 &lt;em&gt;인용&lt;/em&gt; 및 / 또는 &lt;em&gt;이스케이프&lt;/em&gt; 레이어를 제거하여 각각을 분리하십시오 .</target>
        </trans-unit>
        <trans-unit id="03e6b879d2b54e40963864600799d0ff4945f213" translate="yes" xml:space="preserve">
          <source>Given a value of type &lt;code&gt;Right a&lt;/code&gt;, GHC must produce a value of type &lt;code&gt;Right b&lt;/code&gt;. Since the argument to the &lt;code&gt;Right&lt;/code&gt; constructor has type &lt;code&gt;Either Int a&lt;/code&gt;, the code recursively calls &lt;code&gt;fmap&lt;/code&gt; on it to produce a value of type &lt;code&gt;Either Int b&lt;/code&gt;, which is used in turn to construct a final value of type &lt;code&gt;Right b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Right a&lt;/code&gt; 유형의 값이 주어지면 GHC는 &lt;code&gt;Right b&lt;/code&gt; 유형의 값을 생성해야합니다 . &lt;code&gt;Right&lt;/code&gt; 생성자에 대한 인수 는 &lt;code&gt;Either Int a&lt;/code&gt; 유형 을 가지므로, 코드는 &lt;code&gt;fmap&lt;/code&gt; 을 재귀 적으로 호출 하여 &lt;code&gt;Either Int b&lt;/code&gt; 유형의 값을 생성합니다.이 유형 은 결국 &lt;code&gt;Right b&lt;/code&gt; 유형의 최종 값을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7aaad46966fd2f7a4a7364b632ff8275c3c05bbf" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to Orthodox Christian tradition</source>
          <target state="translated">1 년 동안 정통 기독교 전통에 따라 부활절을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4140020fabc63460d4c747a4e5f0b417d3732e7f" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to the Gregorian method</source>
          <target state="translated">1 년 동안 그레고리오 방식에 따라 부활절을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="a90b9b7c80eb2a84b94bea4951e31b81448a4a8d" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to Orthodox Christian tradition</source>
          <target state="translated">1 년 동안 정통 기독교 전통에 따라 파스칼 보름달을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="db828b10c64e473910ca6113376ab95106d563c4" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to the Gregorian method</source>
          <target state="translated">1 년 동안 그레고리오 방식에 따라 파스카 보름달 찾기</target>
        </trans-unit>
        <trans-unit id="230679363978006fa3682de32adc84e8302aac8e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">임의의 주소와 정렬 제약 조건이 주어지면 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; 은 정렬 제약 조건을 충족시키는 다음으로 높은 주소를 생성합니다. 정렬 제약 조건 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 로 나눌 수있는 모든 주소에 의해 충족됩니다 . 이 작업은 dem 등원입니다.</target>
        </trans-unit>
        <trans-unit id="273674e552deb353cd1f1485d7f784e9fb5ab934" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">임의의 주소와 정렬 제약 조건이 주어지면 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; 은 정렬 제약 조건을 충족시키는 다음으로 높은 주소를 생성합니다. 정렬 제약 조건 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 로 나눌 수있는 모든 주소에 의해 충족됩니다 . 이 작업은 dem 등원입니다.</target>
        </trans-unit>
        <trans-unit id="94a3648c0f213883825b8c965009fc57ba6053ee" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">Int 단위의 배열과 오프셋이 주어지면 요소를 읽으십시오. 인덱스는 범위 내에있는 것으로 가정합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c8a17c8b3ab79de903cc8400da257eb8e7123d8d" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">Int 단위의 배열과 오프셋이 주어지면 요소를 작성하십시오. 인덱스는 범위 내에있는 것으로 가정합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="92bd8db55a8df2cebbe00df902cea1d4c45498b3" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in machine words, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0feba2d471191afd123d35121507798423702da8" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in machine words, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1f573275c2dbc9e7b212c54458e83eb9b94330" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in Int units, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열, Int 단위의 오프셋, 예상 이전 값 및 새 값이 주어지면 원자 비교를 수행하고 현재 값이 제공된 이전 값과 일치하면 새 값을 씁니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="abab7f85bdf29364faddd13dc4b78d374fc5dda4" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in machine words, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a4380d626de6e7a7cb655bd3acb03a426c4955" translate="yes" xml:space="preserve">
          <source>Given an array, an offset, the expected old value, and the new value, perform an atomic compare and swap (i.e. write the new value if the current value and the old value are the same pointer). Returns 0 if the swap succeeds and 1 if it fails. Additionally, returns the element at the offset after the operation completes. This means that on a success the new value is returned, and on a failure the actual old value (not the expected one) is returned. Implies a full memory barrier. The use of a pointer equality on a lifted value makes this function harder to use correctly than &lt;code&gt;casIntArray#&lt;/code&gt;. All of the difficulties of using &lt;code&gt;reallyUnsafePtrEquality#&lt;/code&gt; correctly apply to &lt;code&gt;casArray#&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146fbb7f3f09edd6ae4d6b2a239b5ce5de075b01" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋, AND에 대한 값, 원자에 대한 AND의 값이 요소에 제공됩니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="49755d03cb750cc282b1378fdb97b26101b9cc3a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋과 NAND에 대한 값이 주어지면 원자 적으로 값을 요소에 NAND합니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ea6fdeeb52e6775a8f40a257cda009b7a5a4220c" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋, OR에 대한 값, 원자에 대한 OR 값 또는 요소에 대한 값이 제공됩니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4777b0fe2da60d417590241fa61d0ccc6e0bb4b4" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋과 XOR에 대한 값이 주어지면 원자 적으로 값을 요소에 XOR합니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="29c06c151d779aa5995efae3b3901f99e551b9c5" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋 및 추가 할 값이 주어지면 원소에 값을 원자 적으로 추가합니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="20a058f6323b50073951b1b5f3f5e171eb991d2b" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋 및 빼기 값이 주어지면 원소에 대해 값을 원자 적으로 빼냅니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a30e79c6cce3e1df46121660ce9f45643cc0eeab" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a9ceb938d8f49b5b2ea5c52e2126a50123f314" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e005649850d5d7a3f7b482df99d3f3969f5374d" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71007d72dc6db74da700d9af9cc75f192be2766a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20812dbea90228bd71715ad0ffda8d1cecc9bc0" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8efe4a9e8663db39594eab24695687808cdd1d9" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1133d340ebaabdb6f3a72cccae83fbf1b0c933cc" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">점을 감안 &lt;code&gt;Int#&lt;/code&gt; 의 종류되지 &lt;code&gt;Type&lt;/code&gt; , 그 다음은 그 다음 &lt;code&gt;Maybe Int#&lt;/code&gt; 허용되지 않습니다. 입력 변수는 경향이 있기 때문에 유사 종류이어야 &lt;code&gt;Type&lt;/code&gt; (예를 들면, &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; , 모든 입력 변수는 종류가 &lt;code&gt;Type&lt;/code&gt; ) 다형성은 기본 유형에 비해 작동하지 않는 경향이 있습니다. 물러서서 다형성 함수가 데이터에 대한 포인터를 조작해야하고 대부분의 기본 유형은 개봉되어 있지 않기 때문에이 방법은 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="997d69bcb3242b4498d781fc27199701d0a45530" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;rsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">Given that &lt;code&gt;Int#&lt;/code&gt; &amp;rsquo;s kind is not &lt;code&gt;Type&lt;/code&gt; , it then it follows that &lt;code&gt;Maybe Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; , all the type variables have kind &lt;code&gt;Type&lt;/code&gt; ), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</target>
        </trans-unit>
        <trans-unit id="83affa710671002c026d340422ac4f2dacd5da78" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">이것이 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 에서 작동한다고 가정하면 0 이하의 반복을 요청하면 실패 할 수 있으며 기본 정의는 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="5eaccc9b609fc135977a1c7db325f9c1b56135cd" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">이것이 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 에서 작동한다고 가정하면 0 이하의 반복을 요청하면 실패 할 수 있으며 기본 정의는 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="3f88a1db5338e0d53c15325042511dce1cff7e31" translate="yes" xml:space="preserve">
          <source>Given the dependency information that we have for &lt;code&gt;Collects&lt;/code&gt;, however, we can deduce that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must be equal because they both appear as the second parameter in a &lt;code&gt;Collects&lt;/code&gt; constraint with the same first parameter &lt;code&gt;c&lt;/code&gt;. Hence we can infer a shorter and more accurate type for &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;code&gt;Collects&lt;/code&gt; 에 대한 종속성 정보를 고려할 때 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 모두 동일한 첫 번째 매개 변수 &lt;code&gt;c&lt;/code&gt; 를 가진 &lt;code&gt;Collects&lt;/code&gt; 제약 조건 에서 두 번째 매개 변수로 나타나기 때문에 동일해야한다고 추론 할 수 있습니다 . 따라서 &lt;code&gt;f&lt;/code&gt; 에 대해 더 짧고 정확한 유형을 유추 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac01c957b2153efeefd66d648f6d151ec2182d8f" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 예제가 주어진 경우 : &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18d2d272bdc4a0484a15d052c32887610cf8fa0a" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 예제가 주어진 경우 : &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cab47cf0c2da762f2cc7ef137cb437446a0f551" translate="yes" xml:space="preserve">
          <source>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are &lt;em&gt;open;&lt;/em&gt; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</source>
          <target state="translated">GADT (Generalized Algebraic Data Types)에서 제공하는 기능을 고려할 때 위와 같은 정의가 실현 가능한 것처럼 보일 수 있습니다. 그러나 GADT와 달리 유형 패밀리는 &lt;em&gt;개방&lt;/em&gt; 되어 &lt;em&gt;있습니다. &lt;/em&gt;즉, 다른 모듈에서 새 인스턴스를 항상 추가 할 수 있습니다. 여러 데이터 인스턴스에서 패턴 일치를 지원하려면 확장 가능한 사례 구조 형식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a67b69f19a4f3217074f6e6525e405d47da97d1b" translate="yes" xml:space="preserve">
          <source>Given the maximum size needed and a function to make the contents of a ByteString, createAndTrim makes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The generating function is required to return the actual final size (&amp;lt;= the maximum size), and the resulting byte array is realloced to this size.</source>
          <target state="translated">필요한 최대 크기와 ByteString의 내용을 만드는 함수가 주어지면 createAndTrim이 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 만듭니다 . 실제 최종 크기 (&amp;lt;= 최대 크기)를 반환하려면 생성 함수가 필요하며 결과 바이트 배열이이 크기로 재 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="c2632edc2edf21e0a0a8e5fc487c9aa010583290" translate="yes" xml:space="preserve">
          <source>Given the name or path of an executable file, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; searches for such a file in a list of system-defined locations, which generally includes &lt;code&gt;PATH&lt;/code&gt; and possibly more. The full path to the executable is returned if found. For example, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; would normally give you the path to GHC.</source>
          <target state="translated">실행 파일의 이름 또는 경로가 주어지면 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 은 일반적으로 &lt;code&gt;PATH&lt;/code&gt; 등을 포함하는 시스템 정의 위치 목록에서 해당 파일을 검색합니다 . 발견되면 실행 파일의 전체 경로가 리턴됩니다. 예를 들어, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; 는 일반적으로 GHC에 대한 경로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="779a07f028388c39babdff239bfbe6bdbccb0d49" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a CNF and the address of the root object in the old address space, fix up the internal pointers inside the CNF to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized CNF. It returns the new CNF and the new adjusted root address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2966883e0811760b82984a872c8146237c738512" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a compact, and the address of the root object in the old address space, fix up the internal pointers inside the compact to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized compact, and returns the new compact and the new adjusted root address.</source>
          <target state="translated">컴팩트의 첫 번째 블록에 대한 포인터와 이전 주소 공간에있는 루트 객체의 주소가 주어지면 메모리에 직렬화되었을 때와 다른 메모리 위치를 설명하도록 컴팩트 내부의 내부 포인터를 수정하십시오. 이 메소드는 직렬화 된 압축 파일을 가져온 후 정확히 한 번 호출되어야하며 새로운 압축 및 새로운 조정 된 루트 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="137079684701bb7548bd7c488c5563dff2fd8425" translate="yes" xml:space="preserve">
          <source>Given this declaration the following are examples of well-formed and malformed types:</source>
          <target state="translated">이 선언에 따라 다음은 올바른 형식과 잘못된 형식의 예입니다.</target>
        </trans-unit>
        <trans-unit id="873940b25d330c24756f020ef03429c4416f9796" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">주기 &lt;code&gt;+RTS -?&lt;/code&gt; RTS 옵션 옵션은 프로그램에서 실제로 사용할 수있는 RTS 옵션을 인쇄합니다 (컴파일 방법에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="be7adce77c3e4198098a2e71503600194529aaa3" translate="yes" xml:space="preserve">
          <source>Giving a RULE for a class method is a bad idea:</source>
          <target state="translated">클래스 메소드에 규칙을 부여하는 것은 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="8d25ca6db124879efd114f19378aa116f6113a87" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskell은 변화하는 시스템이므로 반드시 버그가있을 것입니다. 하나를 찾으면 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;이 위키 페이지&lt;/a&gt; 를보고하는 방법에 대한 정보 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9429e6f82d8b0009815227447cf86510d9540831" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</target>
        </trans-unit>
        <trans-unit id="49faa083913d16c0e2a54c17a0448d08510853d6" translate="yes" xml:space="preserve">
          <source>Global name bound outside of the TH AST: An original name (occurrences only, not binders) Need the namespace too to be sure which thing we are naming</source>
          <target state="translated">TH AST 외부에 묶인 전역 이름 : 원래 이름 (결합 만 아님), 네임 스페이스도 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="01f513a4447d5115abfb616f7ec10f25746d29b6" translate="yes" xml:space="preserve">
          <source>GmpLimb</source>
          <target state="translated">GmpLimb</target>
        </trans-unit>
        <trans-unit id="aa3cc86bd45eeace37c215b8088bc77246462145" translate="yes" xml:space="preserve">
          <source>GmpLimb#</source>
          <target state="translated">GmpLimb#</target>
        </trans-unit>
        <trans-unit id="e3f4ca0fa20ec8fe55958aea64bc1f20ad3d5908" translate="yes" xml:space="preserve">
          <source>GmpSize</source>
          <target state="translated">GmpSize</target>
        </trans-unit>
        <trans-unit id="f9096f37d45d4b60dbfdaece3f6a53686498ed20" translate="yes" xml:space="preserve">
          <source>GmpSize#</source>
          <target state="translated">GmpSize#</target>
        </trans-unit>
        <trans-unit id="047ca4adf26df35e0e106b392ff26750f40b42ad" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">&lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC 홈페이지로&lt;/a&gt; 이동 하여 &quot;다운로드&quot;링크를 따라 해당 플랫폼에 맞는 GHC를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="33a4ab0ac66bca29f2e473fa3c763622fc606b83" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">넘어 &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; (참조 &lt;a href=&quot;#disambiguate-fields&quot;&gt;기록 필드 동음&lt;/a&gt; )의 &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; 의&lt;/a&gt; 확장은 여러 데이터 유형이 단일 모듈에서 같은 필드 이름을 사용하여 선언 할 수 있습니다. 예를 들어 다음을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="83c45b6127df9cef6499283275e95f71b0480b90" translate="yes" xml:space="preserve">
          <source>Governs the maximum size that GHC will allow a function unfolding to be. (An unfolding has a &amp;ldquo;size&amp;rdquo; that reflects the cost in terms of &amp;ldquo;code bloat&amp;rdquo; of expanding (aka inlining) that unfolding at a call site. A bigger function would be assigned a bigger cost.)</source>
          <target state="translated">GHC가 함수 전개를 허용 할 최대 크기를 제어합니다. (펼치기에는 콜 사이트에서 펼쳐지는 확장 (일명 인라인)의 &quot;코드 팽창&quot;이라는 관점에서 비용을 반영하는 &quot;크기&quot;가 있습니다. 더 큰 기능에는 더 큰 비용이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7405ebcedde5be8d095a986ea8794e19ee84e2" translate="yes" xml:space="preserve">
          <source>Graph</source>
          <target state="translated">Graph</target>
        </trans-unit>
        <trans-unit id="6e7c6bbc4315ba0876f76436ec1b10c7c4900224" translate="yes" xml:space="preserve">
          <source>Graph Algorithms</source>
          <target state="translated">그래프 알고리즘</target>
        </trans-unit>
        <trans-unit id="13a49a7899b38d84a4d5a0dc4d03c8c74c885e97" translate="yes" xml:space="preserve">
          <source>Graph Construction</source>
          <target state="translated">그래프 구성</target>
        </trans-unit>
        <trans-unit id="49a0417afd89473041a3a240cc4fdf45ab515a14" translate="yes" xml:space="preserve">
          <source>Graph Properties</source>
          <target state="translated">그래프 속성</target>
        </trans-unit>
        <trans-unit id="56cffb9f02e2f33c7ba6c576362663ee3a363685" translate="yes" xml:space="preserve">
          <source>Graph Transformations</source>
          <target state="translated">그래프 변환</target>
        </trans-unit>
        <trans-unit id="ab255c27aec8dfb7cbe347babe25d68cec1ce7a6" translate="yes" xml:space="preserve">
          <source>Graphics</source>
          <target state="translated">Graphics</target>
        </trans-unit>
        <trans-unit id="97dd933a2545d2eb99d8307684e2d9b87677156f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window</source>
          <target state="translated">Graphics.Win32.Window</target>
        </trans-unit>
        <trans-unit id="ee1004fcc1994df1683067a7bfd7341361dfb44a" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.ForegroundWindow</source>
          <target state="translated">Graphics.Win32.Window.ForegroundWindow</target>
        </trans-unit>
        <trans-unit id="d1bc1481fd09f7ee3129f3e57f9838dbb896968f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.HotKey</source>
          <target state="translated">Graphics.Win32.Window.HotKey</target>
        </trans-unit>
        <trans-unit id="78399476ef1665a7b5a92cf906aaca4e5a94e9a0" translate="yes" xml:space="preserve">
          <source>Graphs</source>
          <target state="translated">Graphs</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="b48836bd60f1a3a7305ae4aec52e094503f42798" translate="yes" xml:space="preserve">
          <source>Gregorian calendar</source>
          <target state="translated">그레고리 언 달력</target>
        </trans-unit>
        <trans-unit id="f6735a5ee92cee7bdb9905cfbf3933c275bf1379" translate="yes" xml:space="preserve">
          <source>Group has execute permission.</source>
          <target state="translated">그룹에 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8475ab1269f38d6db9942d6f399693e2156d4e54" translate="yes" xml:space="preserve">
          <source>Group has read permission.</source>
          <target state="translated">그룹에 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="79d8e1e9bb326b307875f64fd38768b5f6c5819e" translate="yes" xml:space="preserve">
          <source>Group has read, write and execute permission.</source>
          <target state="translated">그룹에 읽기, 쓰기 및 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c53ff78e371c1a2b8d488e2fc1d060ea6dec5848" translate="yes" xml:space="preserve">
          <source>Group has write permission.</source>
          <target state="translated">그룹에 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eee03f5a54518b4c420cc3f8e3597ce16394ed9" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">그룹 명령문 ( &lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="8c256d9ea28df636c9ea97e0bd7bc8b310405f3a" translate="yes" xml:space="preserve">
          <source>GroupEntry</source>
          <target state="translated">GroupEntry</target>
        </trans-unit>
        <trans-unit id="db7b9205a31d4756e235da565a7056d8dfe9976e" translate="yes" xml:space="preserve">
          <source>GroupID</source>
          <target state="translated">GroupID</target>
        </trans-unit>
        <trans-unit id="0fa12c8aef8520289b3fda84e17c7ecf08c5916b" translate="yes" xml:space="preserve">
          <source>GroupLimit</source>
          <target state="translated">GroupLimit</target>
        </trans-unit>
        <trans-unit id="6e66568583d15b8f37bae367b73bca77f4f263a2" translate="yes" xml:space="preserve">
          <source>Guard</source>
          <target state="translated">Guard</target>
        </trans-unit>
        <trans-unit id="a34b607e9430e338b04442f386b47b4fa716604d" translate="yes" xml:space="preserve">
          <source>GuardBinBox</source>
          <target state="translated">GuardBinBox</target>
        </trans-unit>
        <trans-unit id="ffe2108ae6d15e93e23a98471348ba5a1ca19ad1" translate="yes" xml:space="preserve">
          <source>GuardQ</source>
          <target state="translated">GuardQ</target>
        </trans-unit>
        <trans-unit id="9d4e8921b3246a85e29c8e15986569808f47530a" translate="yes" xml:space="preserve">
          <source>Guards against negative result values</source>
          <target state="translated">음수 결과 값으로부터 보호</target>
        </trans-unit>
        <trans-unit id="2c496671c5aeaa700e44bad718187d2166004827" translate="yes" xml:space="preserve">
          <source>Guards against null pointers</source>
          <target state="translated">널 포인터로부터 보호</target>
        </trans-unit>
        <trans-unit id="164f197e970b9a4693e48dec5f9fde7a61f1e29f" translate="yes" xml:space="preserve">
          <source>Guards are translated with the &lt;code&gt;guard&lt;/code&gt; function, which requires a &lt;code&gt;MonadPlus&lt;/code&gt; instance:</source>
          <target state="translated">Guard는 &lt;code&gt;guard&lt;/code&gt; 기능 으로 변환되며 &lt;code&gt;MonadPlus&lt;/code&gt; 인스턴스 가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="e62fe40c3c7f3f2deb0de6c6043dabd4db714129" translate="yes" xml:space="preserve">
          <source>Guards for IO operations that may fail</source>
          <target state="translated">실패 할 수있는 IO 작업을위한 보호</target>
        </trans-unit>
        <trans-unit id="a43bb729fa241f8f31f96c2a898f1cc684df64fc" translate="yes" xml:space="preserve">
          <source>Guards:</source>
          <target state="translated">Guards:</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1903ce5d09493a6a7499083e60f2b56bf4b0c409" translate="yes" xml:space="preserve">
          <source>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, &quot;&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;&quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt;.</source>
          <target state="translated">Guy Blelloch, Daniel Ferizovic 및 Yihan Sun, &quot; &lt;em&gt;병렬 주문 세트에 합류&lt;/em&gt; &quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e55b9d60fb7a6cf6f7ce67a80dbe3d9177b3561" translate="yes" xml:space="preserve">
          <source>HACKER TERRITORY. HACKER TERRITORY. (You were warned.)</source>
          <target state="translated">해커 지역. 해커 지역. (경고를 받았습니다)</target>
        </trans-unit>
        <trans-unit id="acd811416f69270a003e4a499661392fc925bc40" translate="yes" xml:space="preserve">
          <source>HALF_PTR</source>
          <target state="translated">HALF_PTR</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="6ed004a7b7a1c11f9e4775140206605dc080f051" translate="yes" xml:space="preserve">
          <source>HARDWAREINPUT</source>
          <target state="translated">HARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="f5cfba667f7d2beb3b73c3b20abeade23152bb66" translate="yes" xml:space="preserve">
          <source>HINSTANCE</source>
          <target state="translated">HINSTANCE</target>
        </trans-unit>
        <trans-unit id="8a62310d9f9283fd8fa6380ec446bd6f54f73354" translate="yes" xml:space="preserve">
          <source>HKEY</source>
          <target state="translated">HKEY</target>
        </trans-unit>
        <trans-unit id="5791388c5a16d4f31ae65db03aaa4f3178f401a8" translate="yes" xml:space="preserve">
          <source>HMODULE</source>
          <target state="translated">HMODULE</target>
        </trans-unit>
        <trans-unit id="2fcf51d2569194bb43ab5be7b0476126449060b3" translate="yes" xml:space="preserve">
          <source>HOWEVER, this is normally not what you want to do!</source>
          <target state="translated">그러나 이것은 일반적으로 원하는 것이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="7b153a8b1b4a64b4d58ebc99748e1fdb8bb2ce66" translate="yes" xml:space="preserve">
          <source>HPC displays both kinds of information in two primary ways: textual reports with summary statistics (&lt;code&gt;hpc report&lt;/code&gt;) and sources with color mark-up (&lt;code&gt;hpc markup&lt;/code&gt;). For boolean coverage, there are four possible outcomes for each guard, condition or qualifier: both True and False values occur; only True; only False; never evaluated. In hpc-markup output, highlighting with a yellow background indicates a part of the program that was never evaluated; a green background indicates an always-True expression and a red background indicates an always-False one.</source>
          <target state="translated">HPC는 요약 통계가 포함 된 텍스트 보고서 ( &lt;code&gt;hpc report&lt;/code&gt; )와 색상 표시가있는 소스 ( &lt;code&gt;hpc markup&lt;/code&gt; )의 두 가지 기본 방식으로 두 가지 정보를 모두 표시합니다 . 부울 범위의 경우 각 가드, ​​조건 또는 한정자에 대해 네 가지 가능한 결과가 있습니다. True 및 False 값이 모두 발생합니다. 오직 True; 오직 거짓; 평가되지 않았습니다. hpc-markup 출력에서 ​​배경이 노란색으로 강조 표시되면 평가되지 않은 프로그램의 일부가 나타납니다. 녹색 배경은 항상 참 표현을 나타내고 빨간색 배경은 항상 거짓 표현을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47ed5ab5211983547bd7d8aabed6ed2c5abe106e" translate="yes" xml:space="preserve">
          <source>HPC does not attempt to lock the &lt;code&gt;.tix&lt;/code&gt; file, so multiple concurrently running binaries in the same directory will exhibit a race condition. At compile time, there is no way to change the name of the &lt;code&gt;.tix&lt;/code&gt; file generated; at runtime, the name of the generated &lt;code&gt;.tix&lt;/code&gt; file can be changed using &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;HPCTIXFILE&lt;/code&gt;&lt;/a&gt;; the name of the &lt;code&gt;.tix&lt;/code&gt; file will also change if you rename the binary. HPC does not work with GHCi.</source>
          <target state="translated">HPC는 &lt;code&gt;.tix&lt;/code&gt; 파일 을 잠그려고 시도하지 않으므로 동일한 디렉토리에서 동시에 실행중인 여러 바이너리가 경쟁 조건을 나타냅니다. 컴파일 타임에는 생성 된 &lt;code&gt;.tix&lt;/code&gt; 파일 의 이름을 변경할 방법이 없습니다 . 실행시에, 상기 생성 된 이름 &lt;code&gt;.tix&lt;/code&gt; 의 파일을 사용하여 변경 될 수 &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;HPCTIXFILE&lt;/code&gt; 을&lt;/a&gt; ; 바이너리 이름을 바꾸면 &lt;code&gt;.tix&lt;/code&gt; 파일 의 이름 도 변경됩니다. HPC는 GHCi에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="febecd78643af3bbe821cd38f1706523b419bad4" translate="yes" xml:space="preserve">
          <source>HPC instrumentation is enabled with the &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 HPC 인스 트루먼 테이션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad412bd3c8b51f7888829d92fba476811cbd227" translate="yes" xml:space="preserve">
          <source>HPrintfType</source>
          <target state="translated">HPrintfType</target>
        </trans-unit>
        <trans-unit id="968ef45f0adcb52b1756f92401b8ae3c14068ab8" translate="yes" xml:space="preserve">
          <source>HRESULT</source>
          <target state="translated">HRESULT</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="24c886a7fc41f29ab0b6c49144b140aa92eedda1" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML은 HTML 태그에 올바르게 넣을 수있는 클래스입니다. 따라서 이것은 하나 이상의 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 요소 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac1ac628be09ebd8c6adfbc13285eba17cc52c5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , for example.</target>
        </trans-unit>
        <trans-unit id="1e7921313c83d0f9960cb8d909e3d6ec7f554cae" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML은 HTML 태그에 올바르게 넣을 수있는 클래스입니다. 따라서 이것은 하나 이상의 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 요소 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="845da765199169e6dfadc88839ff4b7a816e8285" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , for example.</target>
        </trans-unit>
        <trans-unit id="a6d5fa3003a8ccf9ca70c73c5cd9675cec2a1610" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML은 HTML 태그에 올바르게 넣을 수있는 클래스입니다. 따라서 이것은 하나 이상의 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 요소 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a95c580c1b1d21bdccf222c58c09aa34cf85bae5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , for example.</target>
        </trans-unit>
        <trans-unit id="3f9cd56b1730d21793c75a28009298dbbbcdaebf" translate="yes" xml:space="preserve">
          <source>HTMLTABLE</source>
          <target state="translated">HTMLTABLE</target>
        </trans-unit>
        <trans-unit id="5d9e357312135edfa3b6c194ceac1b283c40f259" translate="yes" xml:space="preserve">
          <source>HValue</source>
          <target state="translated">HValue</target>
        </trans-unit>
        <trans-unit id="2f065fef793ed1d56fb008208ad8eb240a319915" translate="yes" xml:space="preserve">
          <source>HValueRef</source>
          <target state="translated">HValueRef</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="393fb1d92f907d4faa4bc03c878b793a3ae03095" translate="yes" xml:space="preserve">
          <source>Handle an error.</source>
          <target state="translated">오류를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="9adc28e5d73e222c9d3f7a1f421808c2f422d355" translate="yes" xml:space="preserve">
          <source>Handle an exception.</source>
          <target state="translated">예외를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="a865e149a9130ddafd312446888b46b4743e1256" translate="yes" xml:space="preserve">
          <source>Handle operations implemented by file descriptors (FDs)</source>
          <target state="translated">파일 디스크립터 (FD)로 구현 된 조작 처리</target>
        </trans-unit>
        <trans-unit id="e01aaadb8e09dac1ef68d5f980b78d216f59db96" translate="yes" xml:space="preserve">
          <source>Handle properties</source>
          <target state="translated">핸들 속성</target>
        </trans-unit>
        <trans-unit id="4e5478f1470187011e4c429f38a2f668e2221916" translate="yes" xml:space="preserve">
          <source>Handle to read from</source>
          <target state="translated">읽을 핸들</target>
        </trans-unit>
        <trans-unit id="cfa84d65d44fe1cfe4fde201cc224ca2ba61ea4b" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stderr&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stderr&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; 에 사용할 핸들 (Nothing =&amp;gt; 기존 &lt;code&gt;stderr&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="0c0b0ea87bc2047414b75a0418c93c0c73335c5f" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdin&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdin&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 에 사용할 핸들 (Nothing =&amp;gt; 기존 &lt;code&gt;stdin&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="f3660bc26cde8292b8f071aaeac565d95442b6df" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdout&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdout&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 에 사용할 핸들 (Nothing =&amp;gt; 기존 &lt;code&gt;stdout&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="91dfd9b7d2ac9eea27abf91b17116f0a194d5836" translate="yes" xml:space="preserve">
          <source>Handle to write to</source>
          <target state="translated">쓸 핸들</target>
        </trans-unit>
        <trans-unit id="4fc8f4ac4ee90b96880236742e3ee6972ce929c5" translate="yes" xml:space="preserve">
          <source>HandleFinalizer</source>
          <target state="translated">HandleFinalizer</target>
        </trans-unit>
        <trans-unit id="2f9893d29577c61dae5b7756f8892a181b356a13" translate="yes" xml:space="preserve">
          <source>HandlePosition</source>
          <target state="translated">HandlePosition</target>
        </trans-unit>
        <trans-unit id="02cd2075a6637789c42ae7bd6b7089a7e6d77028" translate="yes" xml:space="preserve">
          <source>HandlePosn</source>
          <target state="translated">HandlePosn</target>
        </trans-unit>
        <trans-unit id="8669a86e97e301f504a17c89995da4d28985c624" translate="yes" xml:space="preserve">
          <source>HandleType</source>
          <target state="translated">HandleType</target>
        </trans-unit>
        <trans-unit id="4af10b83952cbc0eefb09be94c848941cb2f60f3" translate="yes" xml:space="preserve">
          <source>Handle__</source>
          <target state="translated">Handle__</target>
        </trans-unit>
        <trans-unit id="be0212bf33313087973171061ef96d564becfb55" translate="yes" xml:space="preserve">
          <source>Handler</source>
          <target state="translated">Handler</target>
        </trans-unit>
        <trans-unit id="5286415fae901d21b38c1d749f8ab46e4728bc6e" translate="yes" xml:space="preserve">
          <source>Handler to invoke if an exception is raised</source>
          <target state="translated">예외가 발생하면 호출 할 핸들러</target>
        </trans-unit>
        <trans-unit id="14535b564a9d5d580a5ef44e0cc03f73609cf431" translate="yes" xml:space="preserve">
          <source>HandlerFun</source>
          <target state="translated">HandlerFun</target>
        </trans-unit>
        <trans-unit id="fc9575096055be030a95175a15be095262410643" translate="yes" xml:space="preserve">
          <source>Handling Type-specific Modifiers</source>
          <target state="translated">유형별 수정 자 처리</target>
        </trans-unit>
        <trans-unit id="3b82b9585c9008b66d22e6f407dfa6cdeb89a2db" translate="yes" xml:space="preserve">
          <source>Handling hard link using Win32 API. [NTFS only]</source>
          <target state="translated">Win32 API를 사용하여 하드 링크 처리 [NTFS 만 해당]</target>
        </trans-unit>
        <trans-unit id="0721f48d368df7f5160916c0069bca6f821d3701" translate="yes" xml:space="preserve">
          <source>Handling signals</source>
          <target state="translated">신호 처리</target>
        </trans-unit>
        <trans-unit id="824156b97fa215b3e57f4c35b718839b27b32f4a" translate="yes" xml:space="preserve">
          <source>Handling symbolic link using Win32 API. [Vista of later and desktop app only]</source>
          <target state="translated">Win32 API를 사용하여 심볼릭 링크 처리 [나중의 Vista 및 데스크톱 앱에만 해당]</target>
        </trans-unit>
        <trans-unit id="89aab9f219783f5483f9c8a2f555018716574e03" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 신호 처리</target>
        </trans-unit>
        <trans-unit id="3ad2b4d3875aa4ad0be9d5cb9d1098c6ae4770cb" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 신호 처리</target>
        </trans-unit>
        <trans-unit id="993d612407c57078184116f64cae6bcafc5ebc5a" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 신호 처리</target>
        </trans-unit>
        <trans-unit id="048292f565b5b22828fa076edbb58a73e8cfd5b8" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이벤트 로그 기록기를 이벤트 로그 데이터에 버퍼링합니다. 사용자 정의 &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 에&lt;/a&gt; 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a2180742f74260bd275e7151aa4ebb625f061aec" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Return true on success. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hands buffered event log data to your event log writer. Return true on success. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3affea459771f35ab73628ef32521d013f015828" translate="yes" xml:space="preserve">
          <source>HangupOnClose</source>
          <target state="translated">HangupOnClose</target>
        </trans-unit>
        <trans-unit id="6bfec95216610c8923fdb3b58c6820e2638d7012" translate="yes" xml:space="preserve">
          <source>Hard link name</source>
          <target state="translated">하드 링크 이름</target>
        </trans-unit>
        <trans-unit id="151f3938abe034f9943c5ceef0c5082df3ebe59c" translate="yes" xml:space="preserve">
          <source>Hard links</source>
          <target state="translated">하드 링크</target>
        </trans-unit>
        <trans-unit id="cfda26ce9011e1d31a770fb6f43ec4f97f72200e" translate="yes" xml:space="preserve">
          <source>HardwareFault</source>
          <target state="translated">HardwareFault</target>
        </trans-unit>
        <trans-unit id="a40e006669de268a9bb2acc2447224d0f6c74cbc" translate="yes" xml:space="preserve">
          <source>HasCallStack</source>
          <target state="translated">HasCallStack</target>
        </trans-unit>
        <trans-unit id="d5a8afb8c704edab0aaea5d1e5ddc323a689f7a5" translate="yes" xml:space="preserve">
          <source>HasCallStack call stacks</source>
          <target state="translated">HasCallStack 호출 스택</target>
        </trans-unit>
        <trans-unit id="d56fbf4c5db38163d687f59e194a828baa7c9bd2" translate="yes" xml:space="preserve">
          <source>HasField</source>
          <target state="translated">HasField</target>
        </trans-unit>
        <trans-unit id="20dd461a479f96766729c9d640324e99a0d215cb" translate="yes" xml:space="preserve">
          <source>HasJobControl</source>
          <target state="translated">HasJobControl</target>
        </trans-unit>
        <trans-unit id="4932242cd8f456e18307629642a2aa4a2f8e249e" translate="yes" xml:space="preserve">
          <source>HasResolution</source>
          <target state="translated">HasResolution</target>
        </trans-unit>
        <trans-unit id="19eda78b3bcf5dc9a7065d2ad4cee793b2e7eef4" translate="yes" xml:space="preserve">
          <source>HasSavedIDs</source>
          <target state="translated">HasSavedIDs</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="0229c5fae78a9965d4f45ca37d03dc1236ff8fa7" translate="yes" xml:space="preserve">
          <source>Hashes a &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Two &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt;s may hash to the same value, although in practice this is unlikely. The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; returned makes a good hash key.</source>
          <target state="translated">해시 &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . 실제로는 아니지만 두 개의 &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 가 동일한 값으로 해시 될 수 있습니다. 반환 된 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 좋은 해시 키를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="5901d3877bf9e737aa3e94d79bb4ea0286df3607" translate="yes" xml:space="preserve">
          <source>Haskeline has two ways of interacting with the user:</source>
          <target state="translated">Haskeline에는 두 가지 방법으로 사용자와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d92a7b159921baa977febb12420c1df0529b818" translate="yes" xml:space="preserve">
          <source>Haskeline's behavior may be modified by editing your &lt;code&gt;~/.haskeline&lt;/code&gt; file. For details, see: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/CustomKeyBindings&quot;&gt;https://github.com/judah/haskeline/wiki/CustomKeyBindings&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="065908ba2e214305b72d700a33ff216d049eb661" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 allows for integer literals to be given in decimal, octal (prefixed by &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or hexadecimal notation (prefixed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="translated">Haskell 2010 및 Haskell 98을 사용하면 정수 리터럴을 10 진수, 8 진수 ( &lt;code&gt;0o&lt;/code&gt; 또는 &lt;code&gt;0O&lt;/code&gt; 접두사 ) 또는 16 진 표기법 ( &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; 접두사) 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6da42c988c0cf83b43592a40a36bf805281eb533" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 define floating literals with the syntax &lt;code&gt;1.2e6&lt;/code&gt;. These literals have the type &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">Haskell 2010 및 Haskell 98은 &lt;code&gt;1.2e6&lt;/code&gt; 구문으로 부동 리터럴을 정의합니다 . 이 리터럴은 &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="0aef0b7881ddce0846355a38d3d56808bc487369" translate="yes" xml:space="preserve">
          <source>Haskell 2010 functions</source>
          <target state="translated">하스켈 2010 기능</target>
        </trans-unit>
        <trans-unit id="c2dfdff50d43589a65e10f3de801e5cd1f3481ad" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add &amp;ldquo;&lt;code&gt;deriving( Eq, Ord )&lt;/code&gt;&amp;rdquo; to a data type declaration, to generate a standard instance declaration for classes specified in the &lt;code&gt;deriving&lt;/code&gt; clause. In Haskell 98, the only classes that may appear in the &lt;code&gt;deriving&lt;/code&gt; clause are the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">Haskell 98은 프로그래머가&amp;ldquo; &lt;code&gt;deriving( Eq, Ord )&lt;/code&gt; &amp;rdquo;를 데이터 유형 선언에 추가하여 &lt;code&gt;deriving&lt;/code&gt; 절에 지정된 클래스에 대한 표준 인스턴스 선언을 생성 할 수 있습니다 . Haskell 98에서 &lt;code&gt;deriving&lt;/code&gt; 항목에 나타날 수있는 유일한 클래스 는 표준 클래스 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c13a83f3c36a18ef798acce46700a669fd2d9a2f" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</source>
          <target state="translated">Haskell 98을 사용하면 프로그래머는 데이터 클래스 선언에 파생 절을 추가하여 지정된 클래스에 대한 표준 인스턴스 선언을 생성 할 수 있습니다. GHC는이 메커니즘을 여러 축을 따라 확장합니다.</target>
        </trans-unit>
        <trans-unit id="9fc350c1e6daa1d0a99b5e176fd6627f03f073af" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows you to define a default implementation when declaring a class:</source>
          <target state="translated">Haskell 98을 사용하면 클래스를 선언 할 때 기본 구현을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdbe3cc69c9d59fa9c998d2ffb90eaf9b74ed7ed" translate="yes" xml:space="preserve">
          <source>Haskell 98 prohibits class method types to mention constraints on the class type variable, thus:</source>
          <target state="translated">Haskell 98은 클래스 메소드 유형이 클래스 유형 변수에 대한 제한 조건을 언급하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="1da9fcbc717e278cc072c704bc0fb1543efb67d0" translate="yes" xml:space="preserve">
          <source>Haskell 98 regards all four as ambiguous, but with the &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; extension, GHC will accept the former two. The rules are precisely the same as those for instance declarations in Haskell 98, where the method names on the left-hand side of the method bindings in an instance declaration refer unambiguously to the method of that class (provided they are in scope at all), even if there are other variables in scope with the same name. This reduces the clutter of qualified names when you import two records from different modules that use the same field name.</source>
          <target state="translated">Haskell 98은이 네 가지를 모두 모호한 것으로 간주하지만 &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; 확장을 통해 GHC는 이전 두 가지를 허용합니다. 규칙은 Haskell 98의 인스턴스 선언과 정확히 동일합니다. 여기서 인스턴스 선언에서 메소드 바인딩의 왼쪽에있는 메소드 이름은 해당 클래스의 메소드를 명확하게 참조합니다 (범위 내에있는 경우). 범위 내에 동일한 이름을 가진 다른 변수가있는 경우에도 마찬가지입니다. 이는 동일한 필드 이름을 사용하는 다른 모듈에서 두 개의 레코드를 가져올 때 규정 된 이름의 혼란을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3e37b99ac7bc7b32576c5a86ef921f839207b134" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; never uses the default &quot;6-digit&quot; precision used by C printf.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 C printf가 사용하는 기본 &quot;6 자리&quot;정밀도를 절대 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="803931392d9e7f7a42786baf24bd3acbb21d2297" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; prints the exponent of e-format numbers without a gratuitous plus sign, and with the minimum possible number of digits.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 무료로 더하기 부호없이 가능한 최소 자릿수로 전자 형식 숫자의 지수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5a988b88b57fc6a5015c3bdce6eced1db2e93fb3" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; treats the &quot;precision&quot; specifier as indicating the number of digits after the decimal point.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 소수점 이하 자릿수를 나타내는 것으로 &quot;정밀도&quot;지정자를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="de5a761278ad7995ae6ea10eb54d7d46a18911b2" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; will place a zero after a decimal point when possible.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 가능하면 소수점 다음에 0을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="5db5bb3ecf93ed4bf68c234dce9b122cc069d4fc" translate="yes" xml:space="preserve">
          <source>Haskell allows datatypes to be given contexts, e.g.</source>
          <target state="translated">Haskell은 데이터 타입에 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3ba63f358f6ed0e157b0d31998c471fd73b1c809" translate="yes" xml:space="preserve">
          <source>Haskell compiler</source>
          <target state="translated">하스켈 컴파일러</target>
        </trans-unit>
        <trans-unit id="c96570b066116767adb53a9bedbb0995cb0718ff" translate="yes" xml:space="preserve">
          <source>Haskell defines operations to read and write characters from and to files, represented by values of type &lt;code&gt;Handle&lt;/code&gt;. Each value of this type is a &lt;em&gt;handle&lt;/em&gt;: a record used by the Haskell run-time system to &lt;em&gt;manage&lt;/em&gt; I/O with file system objects. A handle has at least the following properties:</source>
          <target state="translated">Haskell은 &lt;code&gt;Handle&lt;/code&gt; 유형의 값으로 표시되는 파일에서 문자를 읽고 쓰는 작업을 정의합니다 . 이 유형의 각 값은 &lt;em&gt;핸들입니다&lt;/em&gt; . 파일 시스템 오브젝트로 I / O 를 &lt;em&gt;관리&lt;/em&gt; 하기 &lt;em&gt;위해&lt;/em&gt; Haskell 런타임 시스템에서 사용하는 레코드 입니다. 핸들에는 최소한 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="57185b2c62d4c8656c31d0f4760835255a021285" translate="yes" xml:space="preserve">
          <source>Haskell expressions can be typed at the prompt:</source>
          <target state="translated">프롬프트에서 Haskell 표현식을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36b350cda5fbb367cf839d60b51cc0cd72d5f14c" translate="yes" xml:space="preserve">
          <source>Haskell file</source>
          <target state="translated">하스켈 파일</target>
        </trans-unit>
        <trans-unit id="c9588bea707a1b459133b5d157a94371293bfcc8" translate="yes" xml:space="preserve">
          <source>Haskell identifier, e.g. &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt;</source>
          <target state="translated">하스켈 식별자 (예 : &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;Baz&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8864d7903427f164a617a184e73202acec74086a" translate="yes" xml:space="preserve">
          <source>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper &amp;ldquo;Restricted Data Types in Haskell&amp;rdquo; (Haskell Workshop 1999) John Hughes had to define the data type:</source>
          <target state="translated">Haskell은 각 유형 변수의 종류를 유추합니다. 함수에 대한 타입 시그니처를 제공하는 것이 좋 듯이 명시 적으로 (기계 검사 된) 문서로 종류를 제공하는 것이 좋습니다. 어떤 경우에는 그렇게하는 것이 필수적입니다. 예를 들어, 논문 &quot;하스켈의 제한된 데이터 유형&quot;(Haskell Workshop 1999)에서 John Hughes는 데이터 유형을 정의해야했습니다.</target>
        </trans-unit>
        <trans-unit id="03044d4dffb5ba6961d6c201b79e6123773d3291" translate="yes" xml:space="preserve">
          <source>Haskell lexer: returns the lexed string, rather than the lexeme</source>
          <target state="translated">Haskell lexer : lexeme이 아닌 lexed 문자열을 반환</target>
        </trans-unit>
        <trans-unit id="3a6fb7995adcbbff55a20ec28fb0709de06184c0" translate="yes" xml:space="preserve">
          <source>Haskell library authors have a choice. Most should just use Safe inference. Assuming you avoid any unsafe features of the language then your modules will be marked safe. Inferred vs. Explicit has the following trade-offs:</source>
          <target state="translated">하스켈 도서관 저자가 선택할 수 있습니다. 대부분은 안전한 추론을 사용해야합니다. 언어의 안전하지 않은 기능을 피한다고 가정하면 모듈이 안전으로 표시됩니다. 유추 된 것과 명시적인 것에는 다음과 같은 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc3010148ab07280017396fcfee70d4ee8ced651" translate="yes" xml:space="preserve">
          <source>Haskell offers a powerful type system and separation of pure and effectual functions through the &lt;code&gt;IO&lt;/code&gt; monad. However, there are several loop holes in the type system, the most obvious being the &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; function. The safe language dialect of Safe Haskell disallows the use of such functions. This can be useful restriction as it makes Haskell code easier to analyse and reason about. It also codifies the existing culture in the Haskell community of trying to avoid unsafe functions unless absolutely necessary. As such, using the safe language (through the &lt;code&gt;-XSafe&lt;/code&gt; flag) can be thought of as a way of enforcing good style, similar to the function of &lt;code&gt;-Wall&lt;/code&gt;.</source>
          <target state="translated">Haskell은 &lt;code&gt;IO&lt;/code&gt; 모나드를 통해 강력한 유형 시스템과 순수하고 효과적인 기능을 분리 합니다. 그러나 타입 시스템에는 몇 개의 루프 홀이 있으며, 가장 확실한 것은 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; 함수입니다. Safe Haskell의 안전한 언어 방언은 그러한 기능의 사용을 허용하지 않습니다. Haskell 코드를보다 쉽게 ​​분석하고 추론 할 수있게하므로 유용한 제한 사항이 될 수 있습니다. 또한 하스켈 커뮤니티의 기존 문화가 꼭 필요한 경우가 아니라면 안전하지 않은 기능을 피하려고 노력하고 있음을 체계화합니다. 따라서 &lt;code&gt;-XSafe&lt;/code&gt; 플래그를 통해 안전한 언어를 사용하는 것은 &lt;code&gt;-Wall&lt;/code&gt; 기능과 유사한 좋은 스타일을 적용하는 방법으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bc620cd7bebfbd449c887c8393ef71a9cb0048a" translate="yes" xml:space="preserve">
          <source>Haskell provides indexable &lt;em&gt;arrays&lt;/em&gt;, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. Functions restricted in this way can be implemented efficiently; in particular, a programmer may reasonably expect rapid access to the components. To ensure the possibility of such an implementation, arrays are treated as data, not as general functions.</source>
          <target state="translated">Haskell은 색인 가능한 &lt;em&gt;배열을&lt;/em&gt; 제공 하는데, 이는 도메인이 정수의 연속적인 부분 집합에 대해 동형 인 함수로 생각할 수 있습니다. 이러한 방식으로 제한된 기능은 효율적으로 구현 될 수 있습니다. 특히, 프로그래머는 구성 요소에 대한 빠른 액세스를 합리적으로 기대할 수 있습니다. 이러한 구현의 가능성을 보장하기 위해 배열은 일반적인 기능이 아닌 데이터로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="7368b5caa5272a65112545054af26ecf77386013" translate="yes" xml:space="preserve">
          <source>Haskell representation for &lt;code&gt;errno&lt;/code&gt; values. The implementation is deliberately exposed, to allow users to add their own definitions of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 값에 대한 Haskell 표현 . 사용자가 자신의 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 값 정의를 추가 할 수 있도록 구현이 의도적으로 노출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ccc207680c476b314f16992dfd19a9a9a258a751" translate="yes" xml:space="preserve">
          <source>Haskell representations of &lt;code&gt;errno&lt;/code&gt; values</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 값 의 하스켈 표현</target>
        </trans-unit>
        <trans-unit id="5341eea214941c8fa9b89302f00f8e694f12278b" translate="yes" xml:space="preserve">
          <source>Haskell source files may be named on the command line, and they will be loaded exactly as in interactive mode. The expression is evaluated in the context of the loaded modules.</source>
          <target state="translated">Haskell 소스 파일은 명령 행에서 이름이 지정 될 수 있으며 대화식 모드에서와 같이 정확하게로드됩니다. 로드 된 모듈의 컨텍스트에서 표현식이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ae2da82a38cbe99fd9ff682badbaaec111364bd4" translate="yes" xml:space="preserve">
          <source>Haskell specifies that when compiling module &lt;code&gt;M&lt;/code&gt;, any instance declaration in any module &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; is visible. (Module &lt;code&gt;A&lt;/code&gt; is &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is imported directly by &lt;code&gt;M&lt;/code&gt;, or if &lt;code&gt;A&lt;/code&gt; is below a module that &lt;code&gt;M&lt;/code&gt; imports directly.) In principle, GHC must therefore read the interface files of every module below &lt;code&gt;M&lt;/code&gt;, just in case they contain an instance declaration that matters to &lt;code&gt;M&lt;/code&gt;. This would be a disaster in practice, so GHC tries to be clever.</source>
          <target state="translated">Haskell은 모듈 &lt;code&gt;M&lt;/code&gt; 을 컴파일 할 때 &amp;ldquo;아래&amp;rdquo; &lt;code&gt;M&lt;/code&gt; 의 모든 모듈에서 인스턴스 선언을 볼 수 있도록 지정합니다. (모듈 &lt;code&gt;A&lt;/code&gt; 는 &quot;아래&quot;입니다 &lt;code&gt;M&lt;/code&gt; 경우 &lt;code&gt;A&lt;/code&gt; 는 직접 가져 &lt;code&gt;M&lt;/code&gt; , 또는 경우에 &lt;code&gt;A&lt;/code&gt; 는 모듈 아래에있게 &lt;code&gt;M&lt;/code&gt; 의 직접 수입.) 원칙적으로는, GHC 그러므로 아래의 모든 모듈의 인터페이스 파일을 읽을 수 있어야합니다 &lt;code&gt;M&lt;/code&gt; 을 가 포함 된 단지의 경우, 에 중요한 인스턴스 선언 &lt;code&gt;M&lt;/code&gt; . 이것은 실제로 재앙 일 것이므로 GHC는 영리하려고 노력합니다.</target>
        </trans-unit>
        <trans-unit id="78504a490dcd1a405c09c255b59b6c836880bb83" translate="yes" xml:space="preserve">
          <source>Haskell symbol, e.g. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:%&lt;/code&gt;</source>
          <target state="translated">하스켈 기호 (예 : &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;:%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df367f209bd79c811db4b993c1f851b5f670ca59" translate="yes" xml:space="preserve">
          <source>Haskell threads and Operating System threads</source>
          <target state="translated">하스켈 스레드 및 운영 체제 스레드</target>
        </trans-unit>
        <trans-unit id="b5e4d1115a8c2e36e70d3db1df85b3ba04c82997" translate="yes" xml:space="preserve">
          <source>Haskell threads can communicate via &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, a kind of synchronised mutable variable (see &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt;). Several common concurrency abstractions can be built from &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, and these are provided by the &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; library. In GHC, threads may also communicate via exceptions.</source>
          <target state="translated">Haskell 스레드는 동기화 된 가변 변수 인 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 통해 통신 할 수 있습니다 ( &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt; 참조 ). &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 로부터 몇 가지 공통된 동시성 추상화를 구축 할 수 있으며 &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 라이브러리에서 제공 합니다. GHC에서 스레드는 예외를 통해 통신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1152cd8067628adcb5244f0c52d2f1ebdecd3c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;FILE&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="c52c7986de5b1f1002d0a36e02ab2dcd634cb9aa" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419c0d47d2c63155c445b3a35a04cad638377266" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;bool&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="79c49075305812472dc2df8b13ecac0efe944296" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054a037a3aeec17395419134ad5d32666e879988" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;char&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="f25580ef2a6155308670fc91ba09e1731599c485" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdab6efef7ff3df329d3bbc78a8616b4cb3989a6" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;clock_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="be18749c4ec22337441649343d257d0370d5f71d" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86270c6c52b37291a4f83ecf2067e3d22c57c6e" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;double&lt;/code&gt; 유형을 나타내는 하스켈 유형 .</target>
        </trans-unit>
        <trans-unit id="b2d34f9c0e00a8d1af686c82fb43c8d820dc5922" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0598f733099fb128ae47c1c3166b704c545480c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;float&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="1c49950cb050a7da15661bd7e456a284ef08804b" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9783270eb36d4323f4eecfe9fe711bc1dd549c60" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;fpos_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="ebe2bccc8d0a138a668828ba79fe80867499c2cf" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3828a73b928783c1ab6b138f30ed4a7fd77963fd" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;int&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="0c7bc99c01a214a0469bc841c3db1a8545153961" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ecaafcc8282e441e1b10f5ce390edc54ce196b7b" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123f078eb33cc5f8ac71fcc1a58b2e7c9744c67a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;jmp_buf&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="9f0b2e804cd5163bf59ec18f25ed125a68b853e7" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a09db76fc4cf39e52e96e84ca7eceffcb2dc6cb" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;long long&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="5e4fc6d51b08d08bf0bcba3ee05d06de32a72f6f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc0cd5923376a1c5f20498ef35d8c0014b53573" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; 타입을 나타내는 하스켈 타입 .</target>
        </trans-unit>
        <trans-unit id="050743a39470101ce4c3aaee27cdf563c19fb3e4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b7d113d99751c0327aea4d8129f5aed9f4e0a54" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e280e77ea88a2a6aea1fcccbe66210a18677d7c4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;ptrdiff_t&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="dbd3c68fb579759e59f8406834e1d8e6ff601638" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c33de586ddf7a29484efc41926b3029b29a9d4f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;short&lt;/code&gt; 타입을 나타내는 하스켈 타입 .</target>
        </trans-unit>
        <trans-unit id="5b8524f5a4f304e126b6b8a367dfaecb35880702" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6814ce0babdcf6409207c9d5c62a5d21549d670" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;sig_atomic_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="f3fa5599c0fc034cd4f240400ef25ab1428a1102" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc79efb4536a8d15f8e47bcacf02aad5c789afda" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type.</source>
          <target state="translated">는 C 대표 하스켈 타입 &lt;code&gt;signed char&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="81af0438927840f3b83280a00faeb91e716cbe5a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e53c7ba3862ff8361e9698b99ceeef6ee695ac" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;size_t&lt;/code&gt; 타입을 나타내는 하스켈 타입 .</target>
        </trans-unit>
        <trans-unit id="178d1b8d5a62b7a3369b736f6da7852035c7e2ba" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b7b2f84ee34dce910b692ae6d7694070d1eec8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;suseconds_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="fe2ceebfe4035ae5db79a948b4348c1b6a632760" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da77000fdb42bf1ac5567a3f5f38306a7b9ce31a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;time_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="47fddfc3c7f8cfce68e214eb884c6dbf75a02426" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13ec168e35067e10a3716ba2d1e66444d65a0d79" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51aa5d4ba2ad63bf1d5b193a1d5d1d64e9d7c6d8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">는 C 대표 하스켈 타입 &lt;code&gt;unsigned char&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ba250403e40dc5a5fe395ae550e60698ea8a63db" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba16416656c8c1c9c85455bf689f834b7cb3e7a3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa56d97929c4f9c0dd6851175b77e5a237a45c9f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type.</source>
          <target state="translated">는 C 대표 하스켈 타입 &lt;code&gt;unsigned int&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="61828b7780ff4e1e0e7f03ddf27e366de45f4b08" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7478eb320307f22ab3f106029e32684ea1826e3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;unsigned long long&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="180a5fcc065de54f77fac57594eab1aba819d926" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095152341382e5cc99a0893c334b897d9021c542" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;unsigned long&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="8e9fa8fbdf77f67a6bcf25da092f95906229af86" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="388c8c93c58b5915ed0bbd05b942d6bcdbd88ea2" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482e4215906c2a0c84b2e998c4bb04b882601162" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;unsigned short&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="0a6c68ad3241c76347c98ebc10b0631bbe19f4b1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d9d916e0cff4b8f444a4bb2b23b5595b6e4e0a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c48c6e42125f2dcb7f39d4c8e9601abc37dca1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;useconds_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="7b0bee0937b5c01758b70e929129631f1bb26b33" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47e3f97a5805a43b017fd566e8e3a0455b50952" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;wchar_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="1342a24a0d486add6662622e572d9396963bb62c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f95906d00942f31be1d4b6bbf300429b06aed957" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d7a20dd1cef70b191b1919721181f45bec4aa1" translate="yes" xml:space="preserve">
          <source>Haskell type signatures are implicitly quantified. When the language option &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is used, the keyword &lt;code&gt;forall&lt;/code&gt; allows us to say exactly what this means. For example:</source>
          <target state="translated">하스켈 타입 시그니처는 암시 적으로 정량화됩니다. 언어 옵션 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 이 사용될 때, &lt;code&gt;forall&lt;/code&gt; 키워드를 사용하면 이것이 의미하는 바를 정확하게 말할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="312958a763351ecbecd34417b742da475b01a5b7" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; (list), &lt;code&gt;ST&lt;/code&gt; (both strict and lazy versions), &lt;code&gt;IO&lt;/code&gt;, and many other monads have &lt;code&gt;MonadFix&lt;/code&gt; instances. On the negative side, the continuation monad, with the signature &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, does not.</source>
          <target state="translated">Haskell 's &lt;code&gt;Maybe&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; (목록), &lt;code&gt;ST&lt;/code&gt; (엄격하고 게으른 버전 모두), &lt;code&gt;IO&lt;/code&gt; 및 기타 여러 모나드에는 &lt;code&gt;MonadFix&lt;/code&gt; 인스턴스가 있습니다. 부정적인 측면에서 서명 &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt; a- &amp;gt; r)-&amp;gt; r 과 함께 연속 모나드 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="286ac067159c9b8667979c69f2ab39f042776595" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="translated">Haskell의 기본 메커니즘 ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, 섹션 4.3.4&lt;/a&gt; )은 &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt; 가 지정 될 때 문자열 리터럴을 포함하도록 확장 됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="5c360d83894c7aaa51597c83bb2ca4c5910f6876" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">Haskell의 독점 제한 ( Haskell 보고서의 &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;섹션 4.5.5&lt;/a&gt; 참조 )은 &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt; &lt;code&gt;NoMonomorphismRestriction&lt;/code&gt; &lt;/a&gt; 으로 완전히 끌 수 있습니다 . GHC 7.8.1부터 GHCi의 대화식 옵션에서 단일형 제한이 기본적으로 해제되어 있습니다 ( &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;대화식 평가를위한 옵션 설정 만 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1a141ab08d985dedb9f98957467226e86a2237bf" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s overloading (using type classes) is elegant, neat, etc., etc., but it is death to performance if left to linger in an inner loop. How can you squash it?</source>
          <target state="translated">Haskell의 오버로드 (유형 클래스 사용)는 우아하고 깔끔한 등입니다. 그러나 내부 루프에 남아 있으면 성능이 저하됩니다. 어떻게 스쿼시 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="6dcc270971fff7841b459ba1100736aab53d82ce" translate="yes" xml:space="preserve">
          <source>Haskell2010</source>
          <target state="translated">Haskell2010</target>
        </trans-unit>
        <trans-unit id="8611224d67199ccb4a7a8d4b25bc635c1cfc3a48" translate="yes" xml:space="preserve">
          <source>Haskell98</source>
          <target state="translated">Haskell98</target>
        </trans-unit>
        <trans-unit id="b3c55f7ef7d356d7c9a7ac63331871b50a302e38" translate="yes" xml:space="preserve">
          <source>Haskellish interface to memcpy and memmove</source>
          <target state="translated">memcpy 및 memmove에 대한 Haskellish 인터페이스</target>
        </trans-unit>
        <trans-unit id="b408395f7a6c9ad5cc0948fe6c746bdc2863b6c4" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate constraints in a type signature. For example</source>
          <target state="translated">컴파일러가 형식 서명의 중복 제약 조건에 대해 경고하도록하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bb44315e3933ae78ec7b2d4c76e749754a530e44" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you&amp;rsquo;ve deleted (one) mention of it in the export list.</source>
          <target state="translated">내보내기 목록의 중복 항목에 대해 컴파일러가 경고하도록하십시오. 이는 큰 반출 목록을 유지하고 반출 목록에서 멘션을 삭제 한 후 정의를 계속 반출하지 않으려는 경우에 유용한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="fc7ae11dc5a0a8877bcb29fcbae185b9eb38ee9a" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in a type signature. In particular:</source>
          <target state="translated">컴파일러가 형식 서명의 중복 제약 조건에 대해 경고하도록하십시오. 특히:</target>
        </trans-unit>
        <trans-unit id="83f4f4e6d95b4c6cd8400d7a4c53dd54d2cb85e3" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in type signatures.</source>
          <target state="translated">컴파일러가 형식 서명의 중복 제약 조건에 대해 경고하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="624af9c99c0374959007cf34d186babd80bc825f" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</source>
          <target state="translated">Have the compiler warn if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</target>
        </trans-unit>
        <trans-unit id="9ba1acc7c9ce9a9b091d8587b0cb7dcc3c4e1695" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">Prelude를 내재적으로 가져 오는 경우 컴파일러에 경고를 표시하십시오. 이는 Prelude 모듈을 &lt;code&gt;import ... Prelude ...&lt;/code&gt; 행을 사용하여 명시 적으로 가져 오거나 내재 된 가져 오기를 사용하지 않는 경우 ( &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma에 의해)가 아닌 한 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="27968fc346539074eff95309c304b2956773d765" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import ... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</target>
        </trans-unit>
        <trans-unit id="9b28e1b8588f425f51c4575626ab47cf2ecc0796" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if there are tabs in your source file.</source>
          <target state="translated">소스 파일에 탭이 있으면 컴파일러에 경고를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="70054c2390d77cf46a86a1147ea85118a1ef3f99" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</source>
          <target state="translated">컴파일러가 소스에서 Haskell Monomorphism Restriction이 적용되는 위치를 경고 / 알리도록합니다. MR을 자동으로 적용하면 예상치 못한 동작이 발생할 수 있으므로 적용 중임을 명시 적으로 경고하는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2afe399bfaedad9702ee7fd70b7b7244f971386" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the &amp;lsquo;default default&amp;rsquo; for Haskell 1.4 caused the otherwise unconstrained value &lt;code&gt;1&lt;/code&gt; to be given the type &lt;code&gt;Int&lt;/code&gt;, whereas Haskell 98 and later defaults it to &lt;code&gt;Integer&lt;/code&gt;. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</source>
          <target state="translated">컴파일러가 소스에서 Haskell 기본 설정 메커니즘이 시작되는 위치를 경고 / 알림으로 알려주십시오. 이는 하나의 기본값을 다른 것으로 가정하는 컨텍스트의 코드를 변환 할 때 유용한 정보입니다 (예 : Haskell 1.4의 '기본 기본값') 그렇지 않으면 제약이없는 값 &lt;code&gt;1&lt;/code&gt; 에 유형 &lt;code&gt;Int&lt;/code&gt; 가 부여되고 Haskell 98 이상에서는 기본값이 &lt;code&gt;Integer&lt;/code&gt; 가 됩니다. 이것은 성능과 동작의 차이로 이어질 수 있으므로 이것에 대해 침묵하지 않는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5498abf9bbeb2f58bbb844fe2ccb526cf856d105" translate="yes" xml:space="preserve">
          <source>Having compiled the program for profiling, you now need to run it to generate the profile. For example, a simple time profile can be generated by running the program with &lt;code&gt;+RTS -p&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt;), which generates a file named &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; where ⟨prog⟩ is the name of your program (without the &lt;code&gt;.exe&lt;/code&gt; extension, if you are on Windows).</source>
          <target state="translated">프로파일 링을 위해 프로그램을 컴파일 한 후에는 프로파일을 생성하기 위해 프로그램을 실행해야합니다. 예를 들어, &lt;code&gt;+RTS -p&lt;/code&gt; ( &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; 참조 )로 프로그램을 실행하여 간단한 시간 프로파일을 생성 할 수 있습니다. 이 파일은 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; 라는 파일을 생성합니다. 여기서 ⟨prog⟩는 프로그램 이름 ( &lt;code&gt;.exe&lt;/code&gt; 확장자 없이 ) Windows에있는 경우).</target>
        </trans-unit>
        <trans-unit id="9c5b0196dfa158a640e0507548062ffac1c9509d" translate="yes" xml:space="preserve">
          <source>Having run the program, we can generate a textual summary of coverage:</source>
          <target state="translated">프로그램을 실행 한 후, 텍스트 범위의 요약을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e7c42bd3113b21fb94871ff334499b878d14a0e" translate="yes" xml:space="preserve">
          <source>Having said that, we &lt;em&gt;can&lt;/em&gt; document exactly what GHC does with respect to the floating point state, so that if you really need to use &lt;code&gt;fenv.h&lt;/code&gt; then you can do so with full knowledge of the pitfalls:</source>
          <target state="translated">우리는 그런 말을 한 &lt;em&gt;수&lt;/em&gt; 당신이 정말로 사용해야 할 경우 그래서, GHC는 부동 소수점 상태에 대한 수행을 정확히 문서화 &lt;code&gt;fenv.h&lt;/code&gt; 다음 함정의 전체 지식을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3bf4aec16734a9e97669c90f0df9d922bc22aee2" translate="yes" xml:space="preserve">
          <source>Head and tail of string broken at substring</source>
          <target state="translated">부분 문자열에서 끊어진 끈의 머리와 꼬리</target>
        </trans-unit>
        <trans-unit id="d1d7ca754b0a092c3e57740e0999c3698d86bf13" translate="yes" xml:space="preserve">
          <source>Heap fragmentation</source>
          <target state="translated">힙 조각화</target>
        </trans-unit>
        <trans-unit id="572f0f8bd257503295a21f9d80fde910db01c38c" translate="yes" xml:space="preserve">
          <source>HeapByCCS</source>
          <target state="translated">HeapByCCS</target>
        </trans-unit>
        <trans-unit id="8c6ad9c60a037be60f4d12e9727ec1dd6fb58d15" translate="yes" xml:space="preserve">
          <source>HeapByClosureType</source>
          <target state="translated">HeapByClosureType</target>
        </trans-unit>
        <trans-unit id="67189d744bb418e35b57f2c375c2f70ffcda9c38" translate="yes" xml:space="preserve">
          <source>HeapByDescr</source>
          <target state="translated">HeapByDescr</target>
        </trans-unit>
        <trans-unit id="ac2ddc42c46684b8a60b44d593d3341dc156883c" translate="yes" xml:space="preserve">
          <source>HeapByLDV</source>
          <target state="translated">HeapByLDV</target>
        </trans-unit>
        <trans-unit id="ab2990dbf6d95e591ed5d567962d304a62d73db5" translate="yes" xml:space="preserve">
          <source>HeapByMod</source>
          <target state="translated">HeapByMod</target>
        </trans-unit>
        <trans-unit id="c5860308e2043941209f92548c297cda091fbd26" translate="yes" xml:space="preserve">
          <source>HeapByRetainer</source>
          <target state="translated">HeapByRetainer</target>
        </trans-unit>
        <trans-unit id="449a4bf1c2c9b0156bb827447b1b70399b9a2bbe" translate="yes" xml:space="preserve">
          <source>HeapByType</source>
          <target state="translated">HeapByType</target>
        </trans-unit>
        <trans-unit id="0a4f1a75f10d18da48ca6030d1af26f2b38bc7d5" translate="yes" xml:space="preserve">
          <source>HeapOverflow</source>
          <target state="translated">HeapOverflow</target>
        </trans-unit>
        <trans-unit id="fba6d5e717ea526f849b6efdaf8193417b738a9d" translate="yes" xml:space="preserve">
          <source>Heaps</source>
          <target state="translated">Heaps</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="5b912a2c5bb90bae872b79adf45f16133c4fd255" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 구현 으로 사용하기 위해 &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; 를 완전히 평가하는 도우미</target>
        </trans-unit>
        <trans-unit id="aa871229f3037dd5b17c54f9bd6a24abf6b10e89" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 구현 으로 사용하기 위해 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 을 완전히 평가하는 도우미</target>
        </trans-unit>
        <trans-unit id="01aa287a9e6ccd271de097c45912c21c3a884f7b" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 구현 으로 사용하기 위해 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 를 완전히 평가하는 도우미</target>
        </trans-unit>
        <trans-unit id="42aad862bc90fff6991f6294f9c9fa7c57b05312" translate="yes" xml:space="preserve">
          <source>Helpers for &lt;code&gt;RealFloat&lt;/code&gt; type-class operations</source>
          <target state="translated">&lt;code&gt;RealFloat&lt;/code&gt; 유형 클래스 작업을 위한 도우미</target>
        </trans-unit>
        <trans-unit id="96b3626fe3abd6dd061729bf2a8d1e0b63df13e7" translate="yes" xml:space="preserve">
          <source>Helpers for defining &quot;wrapper&quot; functions</source>
          <target state="translated">&quot;래퍼&quot;기능 정의를위한 헬퍼</target>
        </trans-unit>
        <trans-unit id="9b312d08020a7a266d812110fde12a2a83862f68" translate="yes" xml:space="preserve">
          <source>Hence, the original expression must have a type which is an instance of the &lt;code&gt;Show&lt;/code&gt; class, or GHCi will complain:</source>
          <target state="translated">따라서 원래 표현식에는 &lt;code&gt;Show&lt;/code&gt; 클래스 의 인스턴스 인 유형이 있어야합니다 . 그렇지 않으면 GHCi가 다음과 같이 불평합니다.</target>
        </trans-unit>
        <trans-unit id="ecbcb0e424c40d9931c2c7c8b44c33c5f4e12465" translate="yes" xml:space="preserve">
          <source>Here</source>
          <target state="translated">Here</target>
        </trans-unit>
        <trans-unit id="fbb03ee11c282574e4295542c0218f98b1aad7d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;A&lt;/code&gt; imports &lt;code&gt;B&lt;/code&gt;, but &lt;code&gt;B&lt;/code&gt; imports &lt;code&gt;A&lt;/code&gt; with a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import; or, equivalently, the module import graph must be acyclic if &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports are ignored.</source>
          <target state="translated">여기 수입 &lt;code&gt;B&lt;/code&gt; 만, &lt;code&gt;B&lt;/code&gt; 의 수입 A의 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 순환 종속성 나누기 프라그. 모듈 임포트 그래프의 모든 루프는 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 임포트로 끊어야합니다. 또는 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 가져 오기가 무시되는 경우 모듈 가져 오기 그래프는 비순환이어야합니다 . &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8399ef26432f55f6e29dace236362d3bda6f8aa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; is ambiguous in the definition of &lt;code&gt;D&lt;/code&gt; but later specified to be &lt;code&gt;Int&lt;/code&gt; using type applications.</source>
          <target state="translated">여기서 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;D&lt;/code&gt; 의 정의에서 모호 하지만 나중에 유형 응용 프로그램을 사용하여 &lt;code&gt;Int&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="84d964c9cfca665c8adcbfb18e361180bdc190f2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are class parameters, but the type is also indexed on a third parameter &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;c&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 는 클래스 매개 변수이지만 유형은 세 번째 매개 변수 &lt;code&gt;x&lt;/code&gt; 에서도 색인됩니다 .</target>
        </trans-unit>
        <trans-unit id="a83c105689c8fd61a7dfc1566a878cd9f0c4ca65" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;lsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;lsquo;s type), and so all is well.</source>
          <target state="translated">여기서 &lt;code&gt;f1&lt;/code&gt; 은 패턴 동의어를 사용하지 않습니다. 숫자 패턴과 일치하도록 &lt;code&gt;42&lt;/code&gt; &lt;em&gt;필요&lt;/em&gt; 제약을 만족시키기 위해 발신자 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; 가 나타나지 않도록 &lt;code&gt;f1&lt;/code&gt; 의 유형. &lt;code&gt;show&lt;/code&gt; 호출 은 &lt;code&gt;(Show b)&lt;/code&gt; 제약 조건을 생성합니다 . 여기서 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;MkT&lt;/code&gt; 의 패턴 일치에 의해 바인딩되는 존재 유형 변수 입니다. 그러나 동일한 패턴 일치는 제약 조건 &lt;code&gt;(Show b)&lt;/code&gt; ( &lt;code&gt;MkT&lt;/code&gt; 유형 참조 ) 도 &lt;em&gt;제공&lt;/em&gt; 하므로 모든 것이 잘됩니다.</target>
        </trans-unit>
        <trans-unit id="4b59b8aee2721ff8de102981e018fa8f69756fd0" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;rsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;rsquo;s type), and so all is well.</source>
          <target state="translated">여기서 &lt;code&gt;f1&lt;/code&gt; 은 패턴 동의어를 사용하지 않습니다. 숫자 패턴과 일치하도록 &lt;code&gt;42&lt;/code&gt; &lt;em&gt;필요&lt;/em&gt; 제약을 만족시키기 위해 발신자 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; 가 나타나지 않도록 &lt;code&gt;f1&lt;/code&gt; 의 유형. &lt;code&gt;show&lt;/code&gt; 를 호출 하면 &lt;code&gt;(Show b)&lt;/code&gt; 제약 조건이 생성됩니다. 여기서 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;MkT&lt;/code&gt; 의 패턴 일치에 의해 바인딩 된 실존 적 유형 변수 입니다. 그러나 동일한 패턴 일치 가 제약 조건 &lt;code&gt;(Show b)&lt;/code&gt; 도 &lt;em&gt;제공&lt;/em&gt; 하므로 ( &lt;code&gt;MkT&lt;/code&gt; 유형 참조 ) 모든 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6ef93a85414044a6743aade675856cb8b2404a3" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence &lt;code&gt;f&lt;/code&gt; is closed. The same reasoning applies to &lt;code&gt;g&lt;/code&gt;, except that it has one closed free variable, namely &lt;code&gt;f&lt;/code&gt;. Similarly &lt;code&gt;h&lt;/code&gt; is closed, &lt;em&gt;even though it is not bound at top level&lt;/em&gt;, because its only free variable &lt;code&gt;f&lt;/code&gt; is closed. But &lt;code&gt;k&lt;/code&gt; is not closed, because it mentions &lt;code&gt;x&lt;/code&gt; which is not closed (because it is not let-bound).</source>
          <target state="translated">여기서 &lt;code&gt;f&lt;/code&gt; 는 자유 변수가 없기 때문에 일반화됩니다. 이의 결합기는 단일 형성 제한에 영향을받지 않으며; 따라서 &lt;code&gt;f&lt;/code&gt; 가 닫힙니다. 하나의 닫힌 자유 변수, 즉 &lt;code&gt;f&lt;/code&gt; 가 있다는 점을 제외하고 는 동일한 추론이 &lt;code&gt;g&lt;/code&gt; 에 적용됩니다 . 마찬가지로 &lt;code&gt;h&lt;/code&gt; 폐쇄 &lt;em&gt;가 최상위에 결합되지 않은 경우에도&lt;/em&gt; 그 유일한 자유 변수 때문에, &lt;code&gt;f&lt;/code&gt; 폐쇄된다. 그러나 &lt;code&gt;k&lt;/code&gt; 는 닫히지 않습니다. 왜냐하면 닫히지 않은 &lt;code&gt;x&lt;/code&gt; 를 언급 했기 때문입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6b823e1758b1c0ce3297af5a6572a41579e18c99" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; must be updating &lt;code&gt;T&lt;/code&gt; because neither &lt;code&gt;S&lt;/code&gt; nor &lt;code&gt;U&lt;/code&gt; have both fields.</source>
          <target state="translated">여기서 &lt;code&gt;f&lt;/code&gt; 업데이트해야 &lt;code&gt;T&lt;/code&gt; 를 도 있기 때문에 &lt;code&gt;S&lt;/code&gt; 나 &lt;code&gt;U&lt;/code&gt; 가 두 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44e1be2ff74797a08ba2e1197bb693a802bcebd" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;lsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">여기에서 &lt;code&gt;h&lt;/code&gt; 의 유형은 &lt;code&gt;b&lt;/code&gt; 에서 모호해 보이지만 여기에는 합법적 인 호출이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b246caf870407f889ea8871b1250446e1716fa4c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;rsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">여기서 &lt;code&gt;h&lt;/code&gt; 의 유형은 &lt;code&gt;b&lt;/code&gt; 에서 모호해 보이지만 다음 은 법적 호출입니다.</target>
        </trans-unit>
        <trans-unit id="5580273dadf2edf4e8b3e5d2e96253462581e863" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;lsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">여기서 &lt;code&gt;strange&lt;/code&gt; 유형은 모호하지만 &lt;code&gt;foo&lt;/code&gt; 호출 은 &lt;code&gt;(D Bool b)&lt;/code&gt; 인스턴스에 의해 용해되는 제약 조건 &lt;code&gt;(D Bool beta)&lt;/code&gt; 을 발생시키기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="49cd73f3d29efb220092644a24b1f6c41bca4225" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;rsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">여기서 &lt;code&gt;strange&lt;/code&gt; 유형은 모호하지만 &lt;code&gt;foo&lt;/code&gt; 의 호출 은 &lt;code&gt;(D Bool b)&lt;/code&gt; 인스턴스 에서 사용할 수있는 제약 조건 &lt;code&gt;(D Bool beta)&lt;/code&gt; 을 발생시키기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e74f35f734a03f3bce931bb0f5d5375f57de25" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="translated">여기서 &lt;code&gt;tag&lt;/code&gt; 는 올바른 유형의 선택기 함수 &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt; 가있는 공개 필드 입니다. &lt;code&gt;self&lt;/code&gt; 유형은 외부에서 숨겨져; 함수로 &lt;code&gt;_this&lt;/code&gt; , &lt;code&gt;_inc&lt;/code&gt; 또는 &lt;code&gt;_display&lt;/code&gt; 를 적용하려고 하면 컴파일 타임 오류가 발생합니다. 즉, &lt;em&gt;GHC는 유형이 실질적으로 정량화 된 변수를 언급하지 않는 필드에 대해서만 레코드 선택기 함수를 정의합니다&lt;/em&gt; . (이 예제는 레코드 선택기가 정의되지 않는 필드에서 밑줄을 사용했지만 프로그래밍 스타일 일 뿐이며 GHC는이를 무시합니다.)</target>
        </trans-unit>
        <trans-unit id="de5848d57cf456303e6aaae0111187f76226179d" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; and the pattern binding &lt;code&gt;(y,z)&lt;/code&gt; remain lazy. Reason: there is no good moment to force them, until first use.</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 와 패턴 바인딩 &lt;code&gt;(y,z)&lt;/code&gt; 은 게으르게 유지됩니다. 이유 : 처음 사용할 때까지 강제로 할 수있는 좋은 순간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="98c889417053878657fe2e9a8e21f6e33d087297" translate="yes" xml:space="preserve">
          <source>Here GHC has translated the expression into</source>
          <target state="translated">여기서 GHC는 그 표현을</target>
        </trans-unit>
        <trans-unit id="4200822fb94b0bfc0d0b0fd94e6cf82c6d349ff5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="translated">여기서 gHC는 최상위 &lt;code&gt;g&lt;/code&gt; 인스턴스에서 제한 조건 &lt;code&gt;(C c Int)&lt;/code&gt; 을 해결하지 않습니다. g 의 특정 호출이 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 를 모두 같은 유형으로 인스턴스화 할 수 있으므로 제한 조건이 다른 방식으로 해결 될 수 있기 때문입니다. 후자의 제한은 원칙적으로 구속 조건 해석기를 완료하는 것입니다. (관심있는 사람들은 &lt;code&gt;TcInteract&lt;/code&gt; 에서 &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; 지정된 오버랩] 을 읽을 수 있습니다.) 피하기 쉽습니다. 형식 서명에서 최상위 인스턴스와 일치하는 제약 조건을 피하십시오. &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt; &lt;/a&gt; 플래그 는 그러한 서명에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="c0cb08091788d9276ad005df64a62df2471916ac" translate="yes" xml:space="preserve">
          <source>Here are a few examples of using the &lt;code&gt;filepath&lt;/code&gt; functions together:</source>
          <target state="translated">다음은 &lt;code&gt;filepath&lt;/code&gt; 함수를 함께 사용하는 몇 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8a79e773a9d37344cccecd1e6b27389b6ae9d630" translate="yes" xml:space="preserve">
          <source>Here are some examples of admissible and illegal type instances:</source>
          <target state="translated">다음은 허용 및 불법 유형 인스턴스의 예입니다.</target>
        </trans-unit>
        <trans-unit id="25023bd7f5466b38299a82f7530be3c8c581e9e8" translate="yes" xml:space="preserve">
          <source>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</source>
          <target state="translated">다음은이 번역이 작동하는 방법에 대한 몇 가지 예입니다. 각 서열의 첫 번째 발현은 하스켈 공급원입니다. 다음은 핵심입니다.</target>
        </trans-unit>
        <trans-unit id="a53d0f1e137d9d27c69f2dc138fdd7c31d405ef3" translate="yes" xml:space="preserve">
          <source>Here are some examples of using said representation. Consider a few types of the &lt;code&gt;Type&lt;/code&gt; universe encoded like this:</source>
          <target state="translated">다음은 상기 표현을 사용하는 몇 가지 예입니다. 다음 과 같이 인코딩 된 몇 가지 유형의 &lt;code&gt;Type&lt;/code&gt; 유니버스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="1938696280e6b5bf3660612c2408006d76611c9a" translate="yes" xml:space="preserve">
          <source>Here are some examples that illustrate the property:</source>
          <target state="translated">속성을 보여주는 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="7e3cfeff552447efcf37ae18b5959e5301027734" translate="yes" xml:space="preserve">
          <source>Here are some export lists and their meaning:</source>
          <target state="translated">내보내기 목록과 그 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="757e98b8dc27b605d3ba22a718bc090780c91f60" translate="yes" xml:space="preserve">
          <source>Here are some more details:</source>
          <target state="translated">자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fef4a6f74860fdc9aa02bdcc17602e952e06fa44" translate="yes" xml:space="preserve">
          <source>Here are some other important points in using the recursive-do notation:</source>
          <target state="translated">재귀 표기법을 사용할 때의 다른 중요한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7acccdf9bd48aabe31c92ed0d7e8b5709c940249" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code for &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Functor&lt;/code&gt; 와 &lt;code&gt;Foldable&lt;/code&gt; 에 대해 생성 된 코드의 차이점은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="17ba5c6ad5fee6c15536c72e587bdaba386e2b34" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code in each extension:</source>
          <target state="translated">각 확장에서 생성 된 코드의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75d0fd5666cf351f1559a1cb0f0f5ec8ec9e925e" translate="yes" xml:space="preserve">
          <source>Here are the key definitions, all available from &lt;code&gt;GHC.Exts&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;GHC.Exts&lt;/code&gt; 에서 제공되는 주요 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="06158caf9a087d2325d1d35545027e3560435152" translate="yes" xml:space="preserve">
          <source>Here are the salient features</source>
          <target state="translated">두드러진 특징은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5858cb273a5f386866d01967e86562b0221422f8" translate="yes" xml:space="preserve">
          <source>Here follow the properties:</source>
          <target state="translated">다음은 속성을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="06ba49b7a3494e39c5e9ac6930fb642d56cb237a" translate="yes" xml:space="preserve">
          <source>Here is a brief description of the syntax of this file:</source>
          <target state="translated">다음은이 파일의 구문에 대한 간략한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="5105a9eca2c2d760c9113cca77cea941a304a915" translate="yes" xml:space="preserve">
          <source>Here is a recursive case</source>
          <target state="translated">재귀 적 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18950c0f655cc85f7d1a80526879f141a4d6d368" translate="yes" xml:space="preserve">
          <source>Here is a reduced representation for &lt;code&gt;Tree&lt;/code&gt; with nearly all meta-information removed, for now keeping only the most essential aspects:</source>
          <target state="translated">다음은 거의 모든 메타 정보가 제거 된 &lt;code&gt;Tree&lt;/code&gt; 의 축소 표현 입니다. 이제 가장 중요한 측면 만 유지합니다.</target>
        </trans-unit>
        <trans-unit id="28fb01aed2be37a9164cef272d31b4a46e6c1038" translate="yes" xml:space="preserve">
          <source>Here is a simple (albeit contrived) example:</source>
          <target state="translated">다음은 간단한 (생각되었지만) 예입니다.</target>
        </trans-unit>
        <trans-unit id="d4e51f8f8c6252d41c390512eb60cd71252079ee" translate="yes" xml:space="preserve">
          <source>Here is a simple non-recursive case:</source>
          <target state="translated">간단한 비재 귀적 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5d55f3cbfa08c1d6611de1d00732137a0861eda" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;mdo&lt;/code&gt;-expression, and its translation to &lt;code&gt;rec&lt;/code&gt; blocks:</source>
          <target state="translated">다음은 예제 &lt;code&gt;mdo&lt;/code&gt; -expression 과 &lt;code&gt;rec&lt;/code&gt; 블록으로 의 변환입니다 .</target>
        </trans-unit>
        <trans-unit id="0b2a7e6f45cd62f2ccce2503e6f62a2ed13efd54" translate="yes" xml:space="preserve">
          <source>Here is an example of a constrained kind:</source>
          <target state="translated">다음은 제한된 종류의 예입니다.</target>
        </trans-unit>
        <trans-unit id="2a3922bbc09781ebd37624e0cd064a9ad42e44e9" translate="yes" xml:space="preserve">
          <source>Here is an example of a program with a couple of SCCs:</source>
          <target state="translated">다음은 몇 가지 SCC가있는 프로그램의 예입니다.</target>
        </trans-unit>
        <trans-unit id="afe44385b028eb6afad10373c4fd9bacc89b3246" translate="yes" xml:space="preserve">
          <source>Here is an example of how one can derive &lt;code&gt;Lift&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;Lift&lt;/code&gt; 를 파생시키는 방법의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c1c0fbe0a0af6bebfb37d12467531a81c8a76ffa" translate="yes" xml:space="preserve">
          <source>Here is an example of this in action:</source>
          <target state="translated">다음은 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="5870318040b4cbc35ef0a6a189cf2b6b2009b5dc" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level numeric literals to provide a safe interface to a low-level function:</source>
          <target state="translated">다음은 유형 수준의 숫자 리터럴을 사용하여 하위 수준 함수에 안전한 인터페이스를 제공하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="cae619abf546c35dc2c1fbfcf0f55d35804f8535" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level string literals to simulate simple record operations:</source>
          <target state="translated">간단한 레코드 작업을 시뮬레이션하기 위해 형식 수준 문자열 리터럴을 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ff9206b7ffb5ba70efe3f04ba78d877b18348c4" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; data type with the &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">다음은 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 및 catchError 예외 메커니즘 과 함께 사용자 정의 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 데이터 유형을 사용하는 방법을 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 입니다. 사용자가 빈 문자열 또는 5자를 초과하는 문자열을 입력하면 예제에서 예외가 발생합니다. 그렇지 않으면 문자열의 길이를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="43b381c025413f1d67c38ee5f2502e185d0fb7d3" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom error data type with the &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">다음은 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 및 catchError 예외 메커니즘 과 함께 사용자 정의 오류 데이터 유형을 사용하는 방법을 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 입니다. 사용자가 빈 문자열 또는 5자를 초과하는 문자열을 입력하면 예제에서 예외가 발생합니다. 그렇지 않으면 문자열의 길이를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="535dae368fdcd63238ee3ab417dc08f09f956a7e" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="translated">오버로드 된 레이블을 레코드 선택기로 사용하는 방법을 보여주는 &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; 의 레코드 액세스 예제 확장은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="784d5081f398d0ca7b17da03a0bb36a22a2ccb4a" translate="yes" xml:space="preserve">
          <source>Here is what this example does:</source>
          <target state="translated">이 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="578112844f2ecfeb7d7b37c0671697fae621d8a3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Eq [a]&lt;/code&gt; in the signature overlaps with the top-level instance for &lt;code&gt;Eq [a]&lt;/code&gt;. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble &lt;code&gt;Eq a&lt;/code&gt; constraint. Best avoided by instead writing:</source>
          <target state="translated">여기서, &lt;code&gt;Eq [a]&lt;/code&gt; 의 최상위 인스턴스 서명에 중첩 &lt;code&gt;Eq [a]&lt;/code&gt; . GHC는 전자를 사용하기 위해 몇 가지 노력을 기울이지 만, 후자를 사용해야한다면 불용성 &lt;code&gt;Eq a&lt;/code&gt; 제약 이있을 것이다 . 대신 다음과 같이 작성하면 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c371834414978339130daf2ead6f2a828c5e1113" translate="yes" xml:space="preserve">
          <source>Here the call to &lt;code&gt;(==)&lt;/code&gt; makes GHC think that the &lt;code&gt;(Eq a)&lt;/code&gt; constraint is needed, so no warning is issued.</source>
          <target state="translated">여기서 &lt;code&gt;(==)&lt;/code&gt; 를 호출 하면 GHC는 &lt;code&gt;(Eq a)&lt;/code&gt; 제약 조건이 필요 하다고 생각 하므로 경고가 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0780d7d3b68e7e37a7a3d46a9b887e1652449c4c" translate="yes" xml:space="preserve">
          <source>Here the definition of &lt;code&gt;id&lt;/code&gt; will be rejected because type variable &lt;code&gt;t&lt;/code&gt; appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that &lt;code&gt;Id&lt;/code&gt; is injective, which means it will be possible to infer &lt;code&gt;t&lt;/code&gt; at call sites from the type of the argument:</source>
          <target state="translated">유형 변수 &lt;code&gt;t&lt;/code&gt; 는 유형 계열 응용 프로그램에서만 나타나므로 모호 하기 때문에 여기서 &lt;code&gt;id&lt;/code&gt; 의 정의는 거부 됩니다. 그러나이 코드는 GHC에 &lt;code&gt;Id&lt;/code&gt; 가 주입 형 이라고 말하면 받아 들여질 것 입니다. 즉 , 인수 유형에서 콜 사이트에서 &lt;code&gt;t&lt;/code&gt; 를 유추 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb28975e9efa83a5c3e0e5ff9c5c0721160939d1" translate="yes" xml:space="preserve">
          <source>Here the signature in the instance declaration is more polymorphic than that required by the instantiated class method.</source>
          <target state="translated">여기서 인스턴스 선언의 서명은 인스턴스화 된 클래스 메소드에 필요한 것보다 다형성입니다.</target>
        </trans-unit>
        <trans-unit id="a63289520236e8e709917ef260fdeb154c06ebad" translate="yes" xml:space="preserve">
          <source>Here the superclass cycle does terminate but it&amp;rsquo;s not entirely straightforward to see that it does.</source>
          <target state="translated">여기서 슈퍼 클래스주기는 종료되지만 완전히 이해되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b4dc560bdf4032142e8540022e116649150a8cf" translate="yes" xml:space="preserve">
          <source>Here the type signature on the expression can be pushed inwards to give a type signature for f. Similarly, and more commonly, one can give a type signature for the function itself:</source>
          <target state="translated">여기서 식의 형식 서명을 안쪽으로 밀어 f에 대한 형식 서명을 제공 할 수 있습니다. 마찬가지로 더 일반적으로 함수 자체에 대한 형식 서명을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b36ee31bac07794278327e4cd5b5ef2a73c1d649" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="translated">여기서 형식 변수 &lt;code&gt;a&lt;/code&gt; 는 생성자의 결과 형식에 나타나지 않습니다. 생성자의 유형으로 보편적으로 수량화되지만 이러한 유형 변수를 종종 &quot;존재&quot;라고합니다. 실제로, 위 선언은 정확히 같은 유형을 선언합니다. &lt;code&gt;data Foo&lt;/code&gt; 에서 &lt;a href=&quot;#existential-quantification&quot;&gt;실존 데이터 생성자를 정량화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7055c1ade07b4400baffd8a9bc31bf6ec6a1358e" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on #14998.)</source>
          <target state="translated">여기서 범용 유형 변수 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;P&lt;/code&gt; 의 정의를 범위로 지정 하지만 실존 적 &lt;code&gt;b&lt;/code&gt; 는 그렇지 않습니다. (참조 # 14998에 대한 토론.)</target>
        </trans-unit>
        <trans-unit id="871671537306449b461ce4b0a7359a84ae8901b9" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on Trac #14998.)</source>
          <target state="translated">여기서 범용 타입 변수 는 &lt;code&gt;P&lt;/code&gt; 의 정의에 &lt;code&gt;a&lt;/code&gt; 범위입니다 만 존재하는 &lt;code&gt;b&lt;/code&gt; 는 그렇지 않습니다. (Trac # 14998에 대한 논의 참조)</target>
        </trans-unit>
        <trans-unit id="2389ab12d149719f8b2ae9fd37c6e9f5221e6a85" translate="yes" xml:space="preserve">
          <source>Here we cannot derive the instance</source>
          <target state="translated">여기서는 인스턴스를 파생시킬 수 없습니다</target>
        </trans-unit>
        <trans-unit id="62ae36999c62764581c349a16fd30283eb606e25" translate="yes" xml:space="preserve">
          <source>Here we do not need to give a type signature to &lt;code&gt;w&lt;/code&gt;, because it is an argument of constructor &lt;code&gt;T1&lt;/code&gt; and that tells GHC all it needs to know.</source>
          <target state="translated">여기서 생성자 인수이므로 &lt;code&gt;w&lt;/code&gt; 에 타입 서명을 줄 필요가 없습니다. &lt;code&gt;T1&lt;/code&gt; GHC에게 알아야 할 모든 것을 알려 .</target>
        </trans-unit>
        <trans-unit id="ec7e465fc20c2c4537d95dc677ec8ee61bfb8cc2" translate="yes" xml:space="preserve">
          <source>Here we give two data instance declarations, one in which the last parameter is &lt;code&gt;[v]&lt;/code&gt;, and one for which it is &lt;code&gt;Int&lt;/code&gt;. Since you cannot give any &lt;em&gt;subsequent&lt;/em&gt; instances for &lt;code&gt;(GMap Flob ...)&lt;/code&gt;, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike &lt;code&gt;Type&lt;/code&gt;).</source>
          <target state="translated">여기에 두 개의 데이터 인스턴스 선언이 있습니다. 하나는 마지막 매개 변수가 &lt;code&gt;[v]&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;Int&lt;/code&gt; 입니다. &lt;code&gt;(GMap Flob ...)&lt;/code&gt; 에 대한 &lt;em&gt;후속&lt;/em&gt; 인스턴스를 제공 할 수 없으므로이 기능은 무료 색인 매개 변수가 유한 한 수의 대안이있는 유형 인 경우에 가장 유용합니다 ( &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bb8ea8d6762e5ffea3bc702011bc02d989b8554" translate="yes" xml:space="preserve">
          <source>Here we have used the runtime system&amp;rsquo;s &lt;code&gt;-V0&lt;/code&gt; option to disable the RTS&amp;rsquo;s periodic timer which may interfere with our debugging session. Upon breaking into the program &lt;code&gt;gdb&lt;/code&gt; shows us a location in our source program corresponding to the current point of execution.</source>
          <target state="translated">여기서는 런타임 시스템의 &lt;code&gt;-V0&lt;/code&gt; 옵션을 사용하여 디버깅 세션을 방해 할 수있는 RTS의주기 타이머를 비활성화했습니다. 프로그램에 침입하면 &lt;code&gt;gdb&lt;/code&gt; 는 현재 실행 지점에 해당하는 소스 프로그램의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a3afdf03ab0d6bca83111ae2999d98d94e34ee27" translate="yes" xml:space="preserve">
          <source>Here we make use of the &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; instance.</source>
          <target state="translated">여기에서 우리는 &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; 인스턴스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1a886cd62bbad757f26446c67a18256a063af6b3" translate="yes" xml:space="preserve">
          <source>Here we notice the first bit of the stack trace has many unidentified stack frames at address &lt;code&gt;0x006eb0c0&lt;/code&gt;. If we ask &lt;code&gt;gdb&lt;/code&gt; about this location, we find that these frames are actually STG update closures,</source>
          <target state="translated">여기서 우리는 스택 트레이스의 첫 번째 비트가 주소 &lt;code&gt;0x006eb0c0&lt;/code&gt; 에 식별되지 않은 많은 스택 프레임을 가지고 있음을 알 수 있습니다. 우리가 묻는다면 &lt;code&gt;gdb&lt;/code&gt; 에이 위치에 대해 하면이 프레임은 실제로 STG 업데이트 클로저이며</target>
        </trans-unit>
        <trans-unit id="488b44824899a32a3b4c8c755fe86357e03b142e" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;calculateLength&lt;/code&gt; by making it to pass its result to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="translated">여기에 &lt;code&gt;calculateLength&lt;/code&gt; 를 사용 하여 결과를 &lt;code&gt;print&lt;/code&gt; 로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="05ec54bf728aec9e4101e212b40848364c009d88" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;a href=&quot;#class-default-signatures&quot;&gt;default signature&lt;/a&gt; to specify that the user does not have to provide an implementation for &lt;code&gt;put&lt;/code&gt;, as long as there is a &lt;code&gt;Generic&lt;/code&gt; instance for the type to instantiate. For the &lt;code&gt;UserTree&lt;/code&gt; type, for instance, the user can just write:</source>
          <target state="translated">여기에서는 &lt;a href=&quot;#class-default-signatures&quot;&gt;기본 서명&lt;/a&gt; 을 사용 하여 인스턴스화 할 형식 의 &lt;code&gt;Generic&lt;/code&gt; 인스턴스 가있는 한 사용자가 &lt;code&gt;put&lt;/code&gt; 구현을 제공 할 필요가 없도록 지정합니다 . 예를 들어 &lt;code&gt;UserTree&lt;/code&gt; 유형의 경우 사용자는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbee547f7180c83e7a6749bef178b8c2b89e5ea0" translate="yes" xml:space="preserve">
          <source>Here we used the &lt;code&gt;-g&lt;/code&gt; option to inform GHC that it should add debugging information in the produced binary. There are three levels of debugging output: &lt;code&gt;-g0&lt;/code&gt; (no debugging information, the default), &lt;code&gt;-g1&lt;/code&gt; (sufficient for basic backtraces), &lt;code&gt;-g2&lt;/code&gt; (or just &lt;code&gt;-g&lt;/code&gt; for short; emitting everything GHC knows). Note that this debugging information does not affect the optimizations performed by GHC.</source>
          <target state="translated">여기서는 &lt;code&gt;-g&lt;/code&gt; 옵션을 사용 하여 생성 된 바이너리에 디버깅 정보를 추가해야한다는 것을 GHC에 알 렸습니다. 이 디버깅 출력의 세 가지 수준입니다 &lt;code&gt;-g0&lt;/code&gt; (NO 디버깅 정보, 기본값) &lt;code&gt;-g1&lt;/code&gt; (기본 역 추적에 충분), &lt;code&gt;-g2&lt;/code&gt; (또는 &lt;code&gt;-g&lt;/code&gt; 짧게는 -g , GHC가 알고있는 모든 것을 방출 . 이 디버깅 정보는 GHC가 수행하는 최적화에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01e42929be7de1f61c123076ae26c4541b6debae" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a command that takes an argument. It&amp;rsquo;s a re-implementation of &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 인수를 취하는 명령의 예입니다. &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; 를&lt;/a&gt; 다시 구현 한 것입니다 . .</target>
        </trans-unit>
        <trans-unit id="4acf1f68d1ec65b2583dd0678b0010301a2d55c6" translate="yes" xml:space="preserve">
          <source>Here's a rule of thumb for deciding which catch-style function to use:</source>
          <target state="translated">사용할 catch 스타일 함수를 결정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95a4a684360c29ba16a972e43ea2e7da727acaed" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(!:)&lt;/code&gt; is a recursive function that indexes arrays of type &lt;code&gt;Arr e&lt;/code&gt;. Consider a call to &lt;code&gt;(!:)&lt;/code&gt; at type &lt;code&gt;(Int,Int)&lt;/code&gt;. The second specialisation will fire, and the specialised function will be inlined. It has two calls to &lt;code&gt;(!:)&lt;/code&gt;, both at type &lt;code&gt;Int&lt;/code&gt;. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</source>
          <target state="translated">여기서 &lt;code&gt;(!:)&lt;/code&gt; 는 &lt;code&gt;Arr e&lt;/code&gt; 유형의 배열을 색인화하는 재귀 함수입니다 . &lt;code&gt;(Int,Int)&lt;/code&gt; 유형의 ( &lt;code&gt;(!:)&lt;/code&gt; 호출을 고려하십시오 . 두 번째 전문화가 시작되고 특수 기능이 인라인됩니다. 그것은 두 통화를 갖고 &lt;code&gt;(!:)&lt;/code&gt; , 유형에 모두 &lt;code&gt;Int&lt;/code&gt; 있습니다. 이 두 가지 부름은 첫 번째 전문 분야를 시작하며, 그의 전문 분야도 인라인됩니다. 결과는 인덱싱 함수의 유형 기반 언 롤링입니다.</target>
        </trans-unit>
        <trans-unit id="2d758383a9a92043fe5183bea22cf4899f5af4a1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; packages an integer with a function &lt;code&gt;even&lt;/code&gt; that maps an integer to &lt;code&gt;Bool&lt;/code&gt;; and &lt;code&gt;MkFoo 'c'
isUpper&lt;/code&gt; packages a character with a compatible function. These two things are each of type &lt;code&gt;Foo&lt;/code&gt; and can be put in a list.</source>
          <target state="translated">여기에서 &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; 는 정수를 &lt;code&gt;Bool&lt;/code&gt; 에 매핑하는 함수 &lt;code&gt;even&lt;/code&gt; 하여 정수를 패키지합니다 . 및 &lt;code&gt;MkFoo 'c' isUpper&lt;/code&gt; 호환 기능을 가진 캐릭터를 패키지. 이 두 가지 유형은 각각 &lt;code&gt;Foo&lt;/code&gt; 유형입니다. 이며 목록에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5517fa5111843903c7c77f59041df2d9a2ca820f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; is a type-level proxy that does not have any associated values.</source>
          <target state="translated">여기서 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; 은 연결된 값이없는 유형 수준 프록시입니다.</target>
        </trans-unit>
        <trans-unit id="8f15a44a2381b42f996544079219567c930d6553" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Adder&lt;/code&gt; is the name of the root module in the module tree (as mentioned above, there must be a single root module, and hence a single module tree in the DLL). Compile everything up:</source>
          <target state="translated">여기서 &lt;code&gt;Adder&lt;/code&gt; 는 모듈 트리에있는 루트 모듈의 이름입니다 (위에서 언급 한 것처럼 단일 루트 모듈이 있어야하므로 DLL에 단일 모듈 트리가 있어야 함). 모든 것을 컴파일하십시오 :</target>
        </trans-unit>
        <trans-unit id="b53104e9ecb02cbdb4ecf1e67b8e325444d3f1eb" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;C&lt;/code&gt; is a superclass of &lt;code&gt;D&lt;/code&gt;, but it&amp;rsquo;s OK for a class operation &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;C&lt;/code&gt; to mention &lt;code&gt;D&lt;/code&gt;. (It would not be OK for &lt;code&gt;D&lt;/code&gt; to be a superclass of &lt;code&gt;C&lt;/code&gt;.)</source>
          <target state="translated">여기서 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;D&lt;/code&gt; 의 수퍼 클래스 이지만 &lt;code&gt;C&lt;/code&gt; 의 클래스 연산 &lt;code&gt;op&lt;/code&gt; 가 &lt;code&gt;D&lt;/code&gt; 를 언급 해도 괜찮습니다 . ( &lt;code&gt;D&lt;/code&gt; 가 &lt;code&gt;C&lt;/code&gt; 의 수퍼 클래스 가되는 것은 좋지 않습니다. .)</target>
        </trans-unit>
        <trans-unit id="525ca7533aa751d8d94cbfeb12f8015edba62f9e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;a&lt;/code&gt; is imported, and &lt;code&gt;c&lt;/code&gt; is bound at top level, so neither contribute to the expansion of the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo;. The motivation here is that it should be easy for the reader to figure out what the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to.</source>
          <target state="translated">여기서 &lt;code&gt;a&lt;/code&gt; 는 가져오고 &lt;code&gt;c&lt;/code&gt; 는 최상위 레벨에 바인딩되므로&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo; 의 확장에 기여하지 않습니다 . 여기서의 동기는 독자가&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo;이 무엇으로 확장 되는지 쉽게 알아낼 수 있어야한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="822db033e370efbb31959c405529a4c4c05b2667" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;g1&lt;/code&gt; are rank-1 types, and can be written in standard Haskell (e.g. &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;). The &lt;code&gt;forall&lt;/code&gt; makes explicit the universal quantification that is implicitly added by Haskell.</source>
          <target state="translated">여기서 &lt;code&gt;f1&lt;/code&gt; 과 &lt;code&gt;g1&lt;/code&gt; 은 순위 -1 유형이며 표준 Haskell로 작성 될 수 있습니다 (예 : &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt; ). &lt;code&gt;forall&lt;/code&gt; 암시 적으로 하스켈에 의해 추가 명시 적으로 보편적 인 정량화한다.</target>
        </trans-unit>
        <trans-unit id="d071a90d49169c0a3e8d456b4967a92a718fd1e4" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f2&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;f2&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 에서는 엄격 하지만 &lt;code&gt;y&lt;/code&gt; 에서는 엄격 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="86a370b87ed8c118346ca1a94d53f0f726f6b04d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f3&lt;/code&gt; and &lt;code&gt;f4&lt;/code&gt; are identical; putting a bang before a pattern that forces evaluation anyway does nothing.</source>
          <target state="translated">여기서 &lt;code&gt;f3&lt;/code&gt; 과 &lt;code&gt;f4&lt;/code&gt; 는 동일합니다. 어쨌든 평가를 강제하는 패턴 앞에 뱅을 두는 것은 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c65a0ece61fefd2d00d0da0d24e0dfd8498a8191" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;g&lt;/code&gt; 는 모호한 유형을 가지며 거부되지만 &lt;code&gt;f&lt;/code&gt; 는 좋습니다. &lt;code&gt;f&lt;/code&gt; 의 호출 사이트 에서 &lt;code&gt;?x&lt;/code&gt; 에 대한 바인딩 은 매우 명확하며 &lt;code&gt;a&lt;/code&gt; 유형을 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="1bce2925ca8d4f31f00ac8bdae65f0eb431772ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;g&lt;/code&gt; 는 모호한 유형이며 거부되지만 &lt;code&gt;f&lt;/code&gt; 는 괜찮습니다. &lt;code&gt;f&lt;/code&gt; 의 호출 사이트 에서 &lt;code&gt;?x&lt;/code&gt; 에 대한 바인딩 은 매우 명확하며 유형 &lt;code&gt;a&lt;/code&gt; 를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="18c00320ffe8585a72819af79238d88877a38e42" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;k&lt;/code&gt; is brought into scope by &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt; 의해 범위로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="2d9559bc1d51eb924585ebc31815ff13fbf5ec88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;lookup&lt;/code&gt; is declared &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt;, but it cannot be specialised for type &lt;code&gt;T&lt;/code&gt; at its definition site, because that type does not exist yet. Instead a client module can define &lt;code&gt;T&lt;/code&gt; and then specialise &lt;code&gt;lookup&lt;/code&gt; at that type.</source>
          <target state="translated">여기서 &lt;code&gt;lookup&lt;/code&gt; 는 &lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; 로 선언 되지만 해당 유형이 아직 없기 때문에 정의 사이트에서 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 특수화 할 수 없습니다 . 대신 클라이언트 모듈은 &lt;code&gt;T&lt;/code&gt; 를 정의한 다음 해당 유형에 대한 &lt;code&gt;lookup&lt;/code&gt; 를 전문화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34766b2e0766ed22f1c9cb7f203525612e940b47" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;m x&lt;/code&gt; depends on the value of &lt;code&gt;x&lt;/code&gt; produced by the first statement, so the expression cannot be translated using &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;m x&lt;/code&gt; 는 첫 번째 명령문에서 생성 된 &lt;code&gt;x&lt;/code&gt; 의 값에 따라 달라 지므로 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 을 사용하여 표현식을 변환 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="34b4a2ef77ba3c50370d37583f31a5be57b46894" translate="yes" xml:space="preserve">
          <source>Here, a value of type &lt;code&gt;NumInst a&lt;/code&gt; is equivalent to an explicit &lt;code&gt;(Num a)&lt;/code&gt; dictionary.</source>
          <target state="translated">여기서 &lt;code&gt;NumInst a&lt;/code&gt; 유형의 값은 명시 적 &lt;code&gt;(Num a)&lt;/code&gt; 사전과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fb49fc1ba82e874567baa5a0ecc23830d8c61be" translate="yes" xml:space="preserve">
          <source>Here, after GHC inlines the body of &lt;code&gt;foldl&lt;/code&gt; to a call site, it will perform call-pattern specialisation very aggressively on &lt;code&gt;foldl_loop&lt;/code&gt; due to the use of &lt;code&gt;SPEC&lt;/code&gt; in the argument of the loop body. &lt;code&gt;SPEC&lt;/code&gt; from &lt;code&gt;GHC.Types&lt;/code&gt; is specifically recognised by the compiler.</source>
          <target state="translated">여기서 GHC는 &lt;code&gt;foldl&lt;/code&gt; 의 본문을 콜 사이트로 인라인 한 후 루프 본문의 인수에서 &lt;code&gt;SPEC&lt;/code&gt; 를 사용하기 때문에 &lt;code&gt;foldl_loop&lt;/code&gt; 에서 콜 패턴 전문화를 매우 적극적으로 수행합니다 . &lt;code&gt;SPEC&lt;/code&gt; 에서 &lt;code&gt;GHC.Types&lt;/code&gt; 은 특히 컴파일러에 의해 인식된다.</target>
        </trans-unit>
        <trans-unit id="16a46da6469aa7d877a4dc019b4026c861a1827c" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s kind pattern.</source>
          <target state="translated">여기서 오른쪽 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; 은 왼쪽에서 발생하지 않는 종류 변수 &lt;code&gt;a&lt;/code&gt; 를 언급하지만 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 의 종류 패턴에 의해 &lt;em&gt;암시 적으로&lt;/em&gt; 바인딩 되므로 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="3f03837283c8b527b9aef380941c96008f2bd16a" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s kind pattern.</source>
          <target state="translated">여기서 오른쪽 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; 은 왼쪽에서 발생하지 않는 종류 변수 &lt;code&gt;a&lt;/code&gt; 를 언급하지만 , &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 의 종류 패턴에 &lt;em&gt;암시 적으로&lt;/em&gt; 묶여 있기 때문에 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c488bb6442c8bfe3891b456a0f20d4c493678b2" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="translated">여기서 &lt;code&gt;T Loop&lt;/code&gt; 타입을 사용하려고 시도하면 그 정의가 끝없이 반복 되므로 타입 체커를 무한 루프로 던질 것입니다. 다른 경우 에는 생성 된 코드가 유형 검사기를 루프에 넣지 않아도 &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 를 활성화해야 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5c4e32b86bb284d5a60b6c3cdd6f27f34dd9bca" translate="yes" xml:space="preserve">
          <source>Here, neither &lt;code&gt;D&lt;/code&gt; nor &lt;code&gt;T&lt;/code&gt; is declared in module &lt;code&gt;Orphan&lt;/code&gt;. We call such modules &amp;ldquo;orphan modules&amp;rdquo;. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</source>
          <target state="translated">여기서 &lt;code&gt;D&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Orphan&lt;/code&gt; 모듈에서 선언 되지 않습니다 . 이러한 모듈을 &quot;고아 모듈&quot;이라고합니다. GHC는 고아 모듈을 식별하고 컴파일중인 모듈 아래에있는 모든 고아 모듈의 인터페이스 파일을 방문합니다. 이것은 일반적으로 낭비되는 작업이지만 피할 수는 없습니다. 따라서 가능한 한 적은 수의 고아 모듈을 갖도록 최선을 다해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e284f329aaa0b1d6c1613a8401892863365a886" translate="yes" xml:space="preserve">
          <source>Here, only &lt;code&gt;b&lt;/code&gt; is levity polymorphic. There are no variables with a levity-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC&amp;rsquo;s &lt;code&gt;$&lt;/code&gt; operator, slightly more general than the Haskell 98 version.</source>
          <target state="translated">여기서 &lt;code&gt;b&lt;/code&gt; 만이 다형성 다형성입니다. levity-polymorphic 유형의 변수는 없습니다. 그리고 코드 생성기는 이것에 아무런 문제가 없습니다. 실제로 이것은 GHC의 &lt;code&gt;$&lt;/code&gt; 연산자 의 실제 유형이며 Haskell 98 버전보다 약간 더 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="e4fa6e7e82de32b187a53fa81558ae736ecfa4c2" translate="yes" xml:space="preserve">
          <source>Here, the kind signature is hidden inside &lt;code&gt;'Just&lt;/code&gt;, and there is no outermost kind signature. We can fix this example by providing an outermost kind signature:</source>
          <target state="translated">여기에서 종류 서명은 &lt;code&gt;'Just&lt;/code&gt; 안에 숨겨져 있으며 가장 바깥 쪽 종류 서명은 없습니다. 가장 바깥 쪽 종류의 서명을 제공하여이 예제를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b5d58882f8e59923897d88bfc5d873faefaaa3" translate="yes" xml:space="preserve">
          <source>Here, the pattern signatures for &lt;code&gt;ys&lt;/code&gt; and &lt;code&gt;zs&lt;/code&gt; are fine, but the one for &lt;code&gt;v&lt;/code&gt; is not because &lt;code&gt;b&lt;/code&gt; is not in scope.</source>
          <target state="translated">여기서 &lt;code&gt;ys&lt;/code&gt; 와 &lt;code&gt;zs&lt;/code&gt; 의 패턴 서명 은 문제가 없지만, &lt;code&gt;b&lt;/code&gt; 의 범위 가 아니기 때문에 &lt;code&gt;v&lt;/code&gt; 의 서명 은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f4fd0ff1134c3450c4876a8a1789e7f8711d1446" translate="yes" xml:space="preserve">
          <source>Here, the pattern type signature &lt;code&gt;[t::a]&lt;/code&gt; mentions a lexical type variable that is not already in scope. Indeed, it &lt;em&gt;must not&lt;/em&gt; already be in scope, because it is bound by the pattern match. The effect is to bring it into scope, standing for the existentially-bound type variable.</source>
          <target state="translated">여기서, 패턴 타입 시그니처 &lt;code&gt;[t::a]&lt;/code&gt; 는 아직 범위 내에 있지 않은 어휘 타입 변수를 언급합니다. 실제로 패턴 일치에 의해 바인딩되므로 범위 내에 &lt;em&gt;있지 않아야합니다&lt;/em&gt; . 그 효과는 범위가 존재하여 존재 바인딩 유형 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8bdce5ce5dbc2679c8b93240f55e76cb9b685ca9" translate="yes" xml:space="preserve">
          <source>Here, the quantified constraint &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; behaves a bit like a local instance declaration, and makes the instance typeable.</source>
          <target state="translated">여기에서 모두에 대한 정량화 된 제약 &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; 는 로컬 인스턴스 선언과 약간 유사하게 작동하며 인스턴스를 입력 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c090bb2c03f8b4d1d81b664c6c433e2433be0999" translate="yes" xml:space="preserve">
          <source>Here, the right-hand side of the data instance mentions the type variable &lt;code&gt;d&lt;/code&gt; that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</source>
          <target state="translated">여기서 데이터 인스턴스의 오른쪽 에는 왼쪽에없는 유형 변수 &lt;code&gt;d&lt;/code&gt; 가 있습니다. 이러한 데이터 인스턴스는 형식 안전성을 손상시킬 수 있으므로 허용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4418932eacd33c51523f80d662c6aae5a1a8913" translate="yes" xml:space="preserve">
          <source>Here, the type bound by &lt;code&gt;MkFoo&lt;/code&gt; &amp;ldquo;escapes&amp;rdquo;, because &lt;code&gt;a&lt;/code&gt; is the result of &lt;code&gt;f1&lt;/code&gt;. One way to see why this is wrong is to ask what type &lt;code&gt;f1&lt;/code&gt; has:</source>
          <target state="translated">여기서 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;f1&lt;/code&gt; 의 결과 이므로 &lt;code&gt;MkFoo&lt;/code&gt; 에 의해 바인딩 된 유형은 &quot;이스케이프&quot; 됩니다. 이것이 왜 잘못된 지 확인하는 한 가지 방법은 &lt;code&gt;f1&lt;/code&gt; 유형 이 무엇인지 묻는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d4ced41f435896f3835e3f3db385a593236b5ec7" translate="yes" xml:space="preserve">
          <source>Here, the type signature &lt;code&gt;forall s. ST s Bool&lt;/code&gt; brings the type variable &lt;code&gt;s&lt;/code&gt; into scope, in the annotated expression &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt;.</source>
          <target state="translated">여기에서 모든 유형의 서명이 &lt;code&gt;forall s. ST s Bool&lt;/code&gt; 은 어노테이션이있는 표현식 &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt; 에서 유형 변수 &lt;code&gt;s&lt;/code&gt; 를 범위로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1f4651a64ece58d66fdaa4f04e3c286eafc03da8" translate="yes" xml:space="preserve">
          <source>HexFloatLiterals</source>
          <target state="translated">HexFloatLiterals</target>
        </trans-unit>
        <trans-unit id="11a841be90249e5ae1849d3a9dba8043e7e8343e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="a09789d874bf0321af31ee0c488ee82ce979a4fc" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="676e2bd2392778df9648ce9b835686f2ab072c23" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="f3393a2a683412902536f7d98b83a3d288d91c93" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="accee792a95e9e1c8fe72eb8b06937ee9369fa1e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="2f2e79d74e1610058532c363754e327e415fd68b" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="bd739f1c73011a1d448318bcfa789ba656618089" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="91d7f9927e5a55d877174d8d404732deead30952" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="807a40d7e8f0a1f48786149c90e1e7c0cd76acce" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="b74ea0e4e3ddeac5ecbd3ecbed85a2f70045728a" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="25ad5ace69a8a8ba3fb3a937ad28617759385a28" translate="yes" xml:space="preserve">
          <source>Hexadecimal numbers</source>
          <target state="translated">16 진수</target>
        </trans-unit>
        <trans-unit id="03b3e0f65de320839723c279978dd47f65d6150a" translate="yes" xml:space="preserve">
          <source>Hidden packages (those for which the &lt;code&gt;exposed&lt;/code&gt; flag is &lt;code&gt;False&lt;/code&gt;) are shown in parentheses in the list of packages.</source>
          <target state="translated">숨겨진 패키지 ( &lt;code&gt;exposed&lt;/code&gt; 플래그가 &lt;code&gt;False&lt;/code&gt; 인 패키지)는 패키지 목록에서 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6062001c6bab0163b0a4b2529719b8bde4b508" translate="yes" xml:space="preserve">
          <source>Hide all packages by default</source>
          <target state="translated">기본적으로 모든 패키지 숨기기</target>
        </trans-unit>
        <trans-unit id="feef4327e8cde9c994f26b136ddb595802f03d1c" translate="yes" xml:space="preserve">
          <source>Hide all packages for plugins by default</source>
          <target state="translated">플러그인의 모든 패키지를 기본적으로 숨기십시오</target>
        </trans-unit>
        <trans-unit id="ec916c3e8ddb513e159b7a5e33949a183f39cac6" translate="yes" xml:space="preserve">
          <source>Hide package ⟨pkg⟩</source>
          <target state="translated">패키지 숨기기</target>
        </trans-unit>
        <trans-unit id="7bd735044c33670955e5379d6a592895b1193122" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 생성자에 대해 최고 허용 연산자 우선 순위 (답 : 9)</target>
        </trans-unit>
        <trans-unit id="7f2e4337cf1098bf05ffcad5c2206b7483c99a77" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 생성자에 대해 최고 허용 연산자 우선 순위 (답 : 9)</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="2d84546cb2321a589250e0442876d448b09183af" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">역사적으로 &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; 관용구에 대한 안전한 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="a7e46fa97c09f5c0c83b2e88f3881c7a3e4f4f7c" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">역사적으로 &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; 관용구에 대한 안전한 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="807422feeeae1e65868373709a1281920ada2d92" translate="yes" xml:space="preserve">
          <source>Holding a &lt;code&gt;Weak ThreadId&lt;/code&gt;, on the other hand, will not prevent the thread from receiving &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions. It is still possible to throw an exception to a &lt;code&gt;Weak ThreadId&lt;/code&gt;, but the caller must use &lt;code&gt;deRefWeak&lt;/code&gt; first to determine whether the thread still exists.</source>
          <target state="translated">반면에 &lt;code&gt;Weak ThreadId&lt;/code&gt; 유지 하면 스레드가 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 를 수신하지 못하게됩니다 . &lt;code&gt;Weak ThreadId&lt;/code&gt; 에 예외를 던질 수는 있지만 호출자는 스레드가 여전히 존재하는지 여부를 판별하기 위해 먼저 &lt;code&gt;deRefWeak&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3a0d96a8a98d1e4dce5ef0782487ab394c743475" translate="yes" xml:space="preserve">
          <source>Hole-fit plugins are plugins that are called when a typed-hole error message is being generated, and allows you to access information about the typed-hole at compile time, and allows you to customize valid hole fit suggestions.</source>
          <target state="translated">Hole-fit 플러그인은 typed-hole 오류 메시지가 생성 될 때 호출되는 플러그인으로, 컴파일 타임에 typed-hole에 대한 정보에 액세스 할 수 있으며 유효한 구멍 맞춤 제안을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d098c08c4ae6f34d5c4821e087cb66e14f878118" translate="yes" xml:space="preserve">
          <source>Home directory (pw_dir)</source>
          <target state="translated">홈 디렉토리 (pw_dir)</target>
        </trans-unit>
        <trans-unit id="aca79641b581fd367113ced98f70f47d0abeb2c8" translate="yes" xml:space="preserve">
          <source>Homomorphism</source>
          <target state="translated">Homomorphism</target>
        </trans-unit>
        <trans-unit id="78abe60fa7d802d62efa64043a705bae7407a631" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned decoding</source>
          <target state="translated">호스트 엔디안, 정렬되지 않은 디코딩</target>
        </trans-unit>
        <trans-unit id="c639806398d26813e0fb48c1ebdba5cd82bf177b" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned writes</source>
          <target state="translated">호스트 엔디안, 정렬되지 않은 쓰기</target>
        </trans-unit>
        <trans-unit id="72a0f916e4e9bfcfeeae189f694538c5874f3603" translate="yes" xml:space="preserve">
          <source>Host-specific binary encodings</source>
          <target state="translated">호스트 별 이진 인코딩</target>
        </trans-unit>
        <trans-unit id="6c7fcd531348b3bb6fd008f425ab3f45a52aad77" translate="yes" xml:space="preserve">
          <source>HotLink</source>
          <target state="translated">HotLink</target>
        </trans-unit>
        <trans-unit id="f9cb8d909445ac44cd2fd5ac585df15ae8f92ebf" translate="yes" xml:space="preserve">
          <source>Hotlinks</source>
          <target state="translated">Hotlinks</target>
        </trans-unit>
        <trans-unit id="24af6649766c375876b6b100497556d3aa591028" translate="yes" xml:space="preserve">
          <source>Hour twelve</source>
          <target state="translated">12시</target>
        </trans-unit>
        <trans-unit id="08b758819da040d3f055ca34119b72fa2b2d6747" translate="yes" xml:space="preserve">
          <source>Hour zero</source>
          <target state="translated">제로 시간</target>
        </trans-unit>
        <trans-unit id="e21e7b28bb4ec8bce45d51234ba921345ac168b2" translate="yes" xml:space="preserve">
          <source>How does the heap residency reported by the heap profiler relate to the actual memory residency of your program when you run it? You might see a large discrepancy between the residency reported by the heap profiler, and the residency reported by tools on your system (eg. &lt;code&gt;ps&lt;/code&gt; or &lt;code&gt;top&lt;/code&gt; on Unix, or the Task Manager on Windows). There are several reasons for this:</source>
          <target state="translated">힙 프로파일 러가보고 한 힙 상주가 프로그램을 실행할 때 실제 메모리 상주와 어떤 관련이 있습니까? 힙 프로파일 러에서보고 한 상주와 시스템의 도구 (예 : Unix에서 &lt;code&gt;ps&lt;/code&gt; 또는 &lt;code&gt;top&lt;/code&gt; , Windows의 작업 관리자)에 의해보고 된 상주간에 큰 차이가있을 수 있습니다 . 이에 대한 몇 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1927f75bb049c830748f2729f0038bde12efc0c1" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline dictionaries?</source>
          <target state="translated">컴파일러가 사전을 인라인하기 위해 얼마나 간절해야합니까?</target>
        </trans-unit>
        <trans-unit id="e0a1c6fc2034630838e97a64d94b3af46c9319cd" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline functions?</source>
          <target state="translated">컴파일러가 함수를 인라인하기 위해 얼마나 간절해야합니까?</target>
        </trans-unit>
        <trans-unit id="a4fb79d40430db562ab3ac45f29bc78e66d5fe1c" translate="yes" xml:space="preserve">
          <source>How long the program has been running (CPU time and elapsed wall clock time).</source>
          <target state="translated">프로그램이 실행 된 시간 (CPU 시간 및 경과 된 벽시계 시간)</target>
        </trans-unit>
        <trans-unit id="917d1059c1e62cf270bb88e3227c70dfbd432932" translate="yes" xml:space="preserve">
          <source>How long this garbage collection took (CPU time and elapsed wall clock time).</source>
          <target state="translated">이 가비지 콜렉션에 소요 된 시간 (CPU 시간 및 경과 된 벽시계 시간)</target>
        </trans-unit>
        <trans-unit id="36c6b03bfc8f9cb787a541e4b6548f8ac93d5025" translate="yes" xml:space="preserve">
          <source>How many bytes are currently live.</source>
          <target state="translated">현재 사용중인 바이트 수</target>
        </trans-unit>
        <trans-unit id="01af7076602466fb2dd0d00c85e7ba87a68dda6f" translate="yes" xml:space="preserve">
          <source>How many bytes did the program allocate while inside of this cost-centre? This does not include allocations while in child cost-centres.</source>
          <target state="translated">이 비용 센터 내부에서 프로그램이 몇 바이트를 할당 했습니까? 하위 비용 센터에있는 동안에는 할당이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7ee2b37aca604bce9e3efa4a6ecb13d165e0be0" translate="yes" xml:space="preserve">
          <source>How many bytes to read</source>
          <target state="translated">읽을 바이트 수</target>
        </trans-unit>
        <trans-unit id="4ce115a90f4bba549deae5cc5d88db46fb3644d7" translate="yes" xml:space="preserve">
          <source>How many bytes we allocated this garbage collection.</source>
          <target state="translated">이 가비지 수집을 할당 한 바이트 수</target>
        </trans-unit>
        <trans-unit id="8b589f57e5f67f3a65c8a115f4df2b5dfeb110e4" translate="yes" xml:space="preserve">
          <source>How many bytes we copied this garbage collection.</source>
          <target state="translated">이 가비지 수집을 복사 한 바이트 수</target>
        </trans-unit>
        <trans-unit id="ff3e1b1a1b256a5e6dd2b8ae3a5665856b88bb55" translate="yes" xml:space="preserve">
          <source>How many capabilities the program was started with (e.g. using the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option). Note that the number of capabilities may change during execution due to the &lt;code&gt;setNumCapabilities&lt;/code&gt; function.</source>
          <target state="translated">프로그램이 시작된 기능 수 (예 : &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 옵션 사용) &lt;code&gt;setNumCapabilities&lt;/code&gt; 함수 로 인해 실행 중에 기능 수가 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd9b9ae41e95b919cfc203a74328458cee852026" translate="yes" xml:space="preserve">
          <source>How many page faults occurred since the end of the last garbage collection.</source>
          <target state="translated">마지막 가비지 수집이 끝난 후 발생한 페이지 오류 수입니다.</target>
        </trans-unit>
        <trans-unit id="7e0ec711a7a2aca8bf80c57d5b99771cc152f07c" translate="yes" xml:space="preserve">
          <source>How many page faults occurred this garbage collection.</source>
          <target state="translated">이 가비지 콜렉션이 발생한 페이지 결함 수입니다.</target>
        </trans-unit>
        <trans-unit id="ee49e11e7b07eb02b05621505c38a7360c70468d" translate="yes" xml:space="preserve">
          <source>How many profiler &amp;ldquo;ticks&amp;rdquo; elapsed over the course of the program&amp;rsquo;s execution.</source>
          <target state="translated">프로그램 실행 과정에서 경과 된 프로파일 러 &quot;틱&quot;수.</target>
        </trans-unit>
        <trans-unit id="9d0f356fd0d39a80e2dc0473264e53a3f5be1255" translate="yes" xml:space="preserve">
          <source>How many stack frames in the given &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt; 의 스택 프레임 수</target>
        </trans-unit>
        <trans-unit id="4ff13443abfdd5f6196035361c4d9c8b1b84e9e8" translate="yes" xml:space="preserve">
          <source>How many ticks was the program&amp;rsquo;s execution inside of this cost-centre? This does not include child cost-centres.</source>
          <target state="translated">이 비용 센터 내에서 프로그램의 실행 횟수는 몇 번입니까? 아동 비용 센터는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab8938746f1911b57d597b21fb5c265320965f8d" translate="yes" xml:space="preserve">
          <source>How many times was this cost-centre entered?</source>
          <target state="translated">이 비용 센터는 몇 번이나 입력 되었습니까?</target>
        </trans-unit>
        <trans-unit id="6758180b138745f6df61fe36255468b563201977" translate="yes" xml:space="preserve">
          <source>How much time between profiler ticks.</source>
          <target state="translated">프로파일 러 틱 사이의 시간</target>
        </trans-unit>
        <trans-unit id="fc67db788a397c6ce747c2f5326f08e707314b58" translate="yes" xml:space="preserve">
          <source>How to determine stderr</source>
          <target state="translated">stderr를 결정하는 방법</target>
        </trans-unit>
        <trans-unit id="6dec927eb4441c4b466135f3fe2523a9b41513ff" translate="yes" xml:space="preserve">
          <source>How to determine stdin</source>
          <target state="translated">표준 입력을 결정하는 방법</target>
        </trans-unit>
        <trans-unit id="83c69a711aceee10fc43cfaec8ddc771d114f1fc" translate="yes" xml:space="preserve">
          <source>How to determine stdout</source>
          <target state="translated">표준 출력을 결정하는 방법</target>
        </trans-unit>
        <trans-unit id="12e3b28c9f66467f3782a09db7380eb03a095bea" translate="yes" xml:space="preserve">
          <source>How to handle the sign of a numeric field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">숫자 필드의 부호를 처리하는 방법. &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; 가 우선적 으로 상호 배타적 입니다.</target>
        </trans-unit>
        <trans-unit id="b5d91c4a03978824020eb2d8b5470646f57802ab" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="translated">그러나 당신이 사용하는 경우 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt; 의 이름 범위에 무엇이든 다음 GHC 대신 사용 &lt;code&gt;toList&lt;/code&gt; , &lt;code&gt;fromList&lt;/code&gt; 및 &lt;code&gt;fromListN&lt;/code&gt; 을 . 즉, 이러한 기능은 리 바인드 가능합니다. cf 리 &lt;a href=&quot;#rebindable-syntax&quot;&gt;바인딩 가능한 구문 및 암시 적 Prelude 가져 오기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6040c9b47e1b3417452306269aaf1ff946d1bdd0" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="translated">그러나 GHCi의 오버랩 규칙에 대한 &lt;a href=&quot;ghci#ghci-decls&quot;&gt;유형, 클래스 및 기타 선언&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27d3f3db18b261148fadac31985fc664c11dd948" translate="yes" xml:space="preserve">
          <source>However take care that the generated definitions are still in the input of &lt;code&gt;typeCheckResultAction&lt;/code&gt;. If your don&amp;rsquo;t take care to filter the typechecked input, the behavior of your tool might be inconsistent.</source>
          <target state="translated">그러나 생성 된 정의가 여전히 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 의 입력에 있는지주의하십시오 . 유형 확인 입력을 필터링하지 않으면 공구 동작이 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d170d05fd2a443fae748aa5bc3ef7be0adca547e" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">그러나 모나드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75d85dddd307adff786f4e64b0c8bb94a7e37fed" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">그러나 모나드 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc54057c2f535150522eb952fec80397f100d689" translate="yes" xml:space="preserve">
          <source>However using Debug.Trace.trace is alright because it uses Windows debugging output support rather than &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">그러나 Debug.Trace.trace는 &lt;code&gt;stderr&lt;/code&gt; 대신 Windows 디버깅 출력 지원을 사용하기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="f8025ea24ecfecdd0f3e045637833ba460a0d7ea" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; creates a &lt;em&gt;bound&lt;/em&gt; thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 는 &lt;em&gt;바운드&lt;/em&gt; 스레드를 작성하는데 , OpenGL과 같은 스레드 로컬 상태를 사용하는 외부 (Haskell이 아닌) 라이브러리를 호출해야하는 경우에 필요합니다 ( &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e98e07fdef4dfe8b0cb3689c59c1f96f6cc38a2e" translate="yes" xml:space="preserve">
          <source>However, &lt;em&gt;nested&lt;/em&gt; bangs in a let/where pattern binding behave uniformly with all other forms of pattern matching. For example</source>
          <target state="translated">그러나 let / where 패턴 바인딩의 &lt;em&gt;중첩 된&lt;/em&gt; 뱅은 다른 모든 형태의 패턴 일치와 균일하게 동작합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e5f527eafccf9b322040b38f8d30b103c69e2e35" translate="yes" xml:space="preserve">
          <source>However, apart from these restrictions, many things are allowed, including expressions which are not fully evaluated! Annotation expressions will be evaluated by the compiler just like Template Haskell splices are. So, this annotation is fine:</source>
          <target state="translated">그러나 이러한 제한 외에도 완전히 평가되지 않은 표현을 포함하여 많은 것들이 허용됩니다! 주석 표현식은 Template Haskell 스플 라이스와 마찬가지로 컴파일러에서 평가합니다. 따라서이 주석은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="8194ed59efdaf1498fbfe96f3c1af7f347e02a51" translate="yes" xml:space="preserve">
          <source>However, because GHC must &lt;em&gt;infer&lt;/em&gt; the type when part of a type is left out, it is unable to use polymorphic recursion. The same restriction takes place when the type signature is omitted completely.</source>
          <target state="translated">그러나 GHC는 형식의 일부가 생략 될 때 형식을 &lt;em&gt;유추&lt;/em&gt; 해야하므로 다형성 재귀를 사용할 수 없습니다. 형식 서명이 완전히 생략 된 경우에도 동일한 제한이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5fc0cb9f7adb2ad4d1a50c3ef7d1d89e881714f8" translate="yes" xml:space="preserve">
          <source>However, by a simple extension to the type class system of Haskell, we can support dynamic binding. Basically, we express the use of a dynamically bound variable as a constraint on the type. These constraints lead to types of the form &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt;, which says &amp;ldquo;this function uses a dynamically-bound variable &lt;code&gt;?x&lt;/code&gt; of type &lt;code&gt;t'&lt;/code&gt;&amp;rdquo;. For example, the following expresses the type of a sort function, implicitly parameterised by a comparison function named &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">그러나 Haskell의 타입 클래스 시스템에 대한 간단한 확장으로 동적 바인딩을 지원할 수 있습니다. 기본적으로 동적 바인딩 된 변수를 형식의 제약 조건으로 사용합니다. 이러한 제약 조건은 &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt; 형식으로 이어 지며 ,이 함수는&amp;ldquo;이 함수는 동적으로 바인딩 된 변수 &lt;code&gt;?x&lt;/code&gt; 유형 &lt;code&gt;t'&lt;/code&gt; 을 사용 합니다. 예를 들어, 다음은 &lt;code&gt;cmp&lt;/code&gt; 라는 비교 함수에 의해 암시 적으로 매개 변수화 된 정렬 함수의 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a905a90165b9acad9dcb4130ba63d5758f8a8d3c" translate="yes" xml:space="preserve">
          <source>However, consider the following example:</source>
          <target state="translated">그러나 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e08e1079e26d8ee5d64f16ab7646e745157e03bd" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="translated">그러나 &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 확장을 활성화하면 모듈을 컴파일 할 수 있습니다. 다음을 포함하여 다양한 확장에서 유사한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b8273c78a4e8dc99cc6fb13390e41af1c9b00ab" translate="yes" xml:space="preserve">
          <source>However, for GADTs there is the following additional constraint: every constructor that has a field &lt;code&gt;f&lt;/code&gt; must have the same result type (modulo alpha conversion) Hence, in the above example, we cannot merge the &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt; fields above into a single name. Although their field types are both &lt;code&gt;Term Int&lt;/code&gt;, their selector functions actually have different types:</source>
          <target state="translated">그러나 GADT의 경우 다음과 같은 추가 제약 조건이 있습니다. 필드 &lt;code&gt;f&lt;/code&gt; 가있는 모든 생성자 는 동일한 결과 유형 (모듈로 알파 변환)을 가져야합니다. 따라서 위 예에서 &lt;code&gt;num&lt;/code&gt; 및 &lt;code&gt;arg&lt;/code&gt; 필드를 단일 이름으로 병합 할 수 없습니다 . 필드 유형은 모두 &lt;code&gt;Term Int&lt;/code&gt; 이지만 선택기 기능은 실제로 다른 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bda4519b4ae553699a88736ad05de49408b09efc" translate="yes" xml:space="preserve">
          <source>However, for most applications, it should suffice to just use the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; flags.</source>
          <target state="translated">그러나 대부분의 응용 프로그램에서는 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; 플래그 만 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="ad986013ad68059837a38c8bd173d49d68173827" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;CProv&lt;/code&gt; is non-empty, while &lt;code&gt;CReq&lt;/code&gt; is, the above pattern type signature for &lt;code&gt;P&lt;/code&gt; must be specified as</source>
          <target state="translated">그러나 &lt;code&gt;CProv&lt;/code&gt; 이 비어있는 동안, &lt;code&gt;CReq&lt;/code&gt; 가 있습니다에 대한 위의 패턴 유형 서명 &lt;code&gt;P&lt;/code&gt; 는 로 지정해야</target>
        </trans-unit>
        <trans-unit id="d463e6d4a25197f32ed78eb56a6036ea10aebfec" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; ends in a separator, the default databases (i.e. the user and global package databases, in that order) are appended to the path. For example, to augment the usual set of packages with a database of your own, you could say (on Unix):</source>
          <target state="translated">그러나 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 가 구분 기호로 끝나는 경우 기본 데이터베이스 (예 : 사용자 및 전역 패키지 데이터베이스)가 경로에 추가됩니다. 예를 들어, 자신의 데이터베이스로 일반적인 패키지 세트를 보강하려면 (유닉스에서) 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="967aa81a898dabc9a0655eae4604ccf80453bdf1" translate="yes" xml:space="preserve">
          <source>However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당신이 당신의 프로그램이 운영 체제에서 제공하는 스레드 패키지를 사용 할 것으로 예상 외국 도서관과 상호 작용하려는 경우, 당신은 사용하여 수행 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="48f6dfd00eff21ddfaf5b9214e0d18073ac349d6" translate="yes" xml:space="preserve">
          <source>However, in all patterns &lt;em&gt;other&lt;/em&gt; than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, &lt;em&gt;the signature brings that type variable into scope&lt;/em&gt;. For example:</source>
          <target state="translated">그러나, 모든 패턴에서 &lt;em&gt;다른&lt;/em&gt; 패턴 바인딩보다 범위에없는 타입의 변수를 말할 수있는 패턴 유형 서명; 이 경우 &lt;em&gt;서명은 해당 유형 변수를 scope로 가져옵니다&lt;/em&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84c24910fabe3813ad18d23c698dd48a88899c66" translate="yes" xml:space="preserve">
          <source>However, it appears that if you add a space at the end of the line, then &lt;code&gt;cpp&lt;/code&gt; (at least GNU &lt;code&gt;cpp&lt;/code&gt; and possibly other &lt;code&gt;cpp&lt;/code&gt;s) leaves the backslash-space pairs alone and the string gap works as expected.</source>
          <target state="translated">그러나 줄 끝에 공백을 추가하면 &lt;code&gt;cpp&lt;/code&gt; (적어도 GNU &lt;code&gt;cpp&lt;/code&gt; 및 다른 &lt;code&gt;cpp&lt;/code&gt; )가 백 슬래시 공백 쌍을 그대로두고 문자열 간격이 예상대로 작동하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="28c91a74d73602f60fc3e23aaa16816234c03e5d" translate="yes" xml:space="preserve">
          <source>However, it is possible to perform a bit of &amp;ldquo;backwards&amp;rdquo; evaluation. For example, here is how we could get GHC to compute arbitrary logarithms at the type level:</source>
          <target state="translated">그러나 약간의 &quot;뒤로&quot;평가를 수행 할 수 있습니다. 예를 들어, 다음은 유형 수준에서 GHC가 임의의 로그를 계산하도록하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1f3a4b89e8199e4d733ca299842a306ab859485c" translate="yes" xml:space="preserve">
          <source>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell&amp;rsquo;s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; for each type variable &lt;code&gt;a&lt;/code&gt;, and defaults the type variable if</source>
          <target state="translated">그러나 사용자가 유형을 지정해야하는 것은 번거로운 일이므로 GHCi는 다음과 같이 Haskell의 유형 기본 규칙 (Haskell 2010 보고서의 4.3.4 단원)을 확장합니다. 표준 규칙 은 각 유형 변수 &lt;code&gt;a&lt;/code&gt; 에 대한 각 제약 조건 그룹 &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; 을 취하고 기본 유형 변수 인 경우</target>
        </trans-unit>
        <trans-unit id="4a41cd61107bf2e5acee8876cf3ea899f304dcd8" translate="yes" xml:space="preserve">
          <source>However, not all is lost. We can still do this:</source>
          <target state="translated">그러나 모든 것이 손실되는 것은 아닙니다. 우리는 여전히 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7187323d3950a28b28f87b9f4c602a2796f69d8b" translate="yes" xml:space="preserve">
          <source>However, note that it is reasonable to have a module &lt;code&gt;Main&lt;/code&gt; in a file named &lt;code&gt;foo.hs&lt;/code&gt;, but this only works because GHC never needs to search for the interface for module &lt;code&gt;Main&lt;/code&gt; (because it is never imported). It is therefore possible to have several &lt;code&gt;Main&lt;/code&gt; modules in separate source files in the same directory, and GHC will not get confused.</source>
          <target state="translated">그러나 &lt;code&gt;foo.hs&lt;/code&gt; 라는 파일에 &lt;code&gt;Main&lt;/code&gt; 모듈을 사용하는 것이 합리적 이지만 GHC는 모듈 &lt;code&gt;Main&lt;/code&gt; 에 대한 인터페이스를 검색 할 필요가 없기 때문에 작동합니다 ( 가져 오기 가 수행되지 않기 때문). 따라서 동일한 디렉토리에있는 별도의 소스 파일에 여러 개의 &lt;code&gt;Main&lt;/code&gt; 모듈 이있을 수 있으며 GHC는 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcbd4b2fd1492cb8e585fb78fb46502a8ccda050" translate="yes" xml:space="preserve">
          <source>However, regardless of the flag setting, the quantifiers are printed under these circumstances:</source>
          <target state="translated">그러나 플래그 설정에 관계없이 수량자는 다음과 같은 상황에서 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="35326ee19484ea5250a5955bf9162649c5ce6743" translate="yes" xml:space="preserve">
          <source>However, since version 8.4 this is no longer the case: GHC &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread.</source>
          <target state="translated">그러나 버전 8.4 이후 이러한 일이 더 이상 가능하지 않습니다 : GHC는 &lt;strong&gt;보장&lt;/strong&gt; 이 가비지 컬렉션이 중에 발생하지 않습니다 &lt;code&gt;unsafe&lt;/code&gt; 경우에도 바이트 코드 인터프리터, 전화, 그리고 더 보장 &lt;code&gt;unsafe&lt;/code&gt; 호출이 호출 스레드에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3168a5cfff35597637af368edcde71624cd723d0" translate="yes" xml:space="preserve">
          <source>However, sometimes there are no such calls, in which case the pragma can be useful.</source>
          <target state="translated">그러나 때로는 그러한 호출이 없으므로 pragma가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1896001a515ea20b3107b6872d509be571c338" translate="yes" xml:space="preserve">
          <source>However, standalone deriving differs from a &lt;code&gt;deriving&lt;/code&gt; clause in a number of important ways:</source>
          <target state="translated">그러나 독립형 파생은 여러 가지 중요한 측면에서 &lt;code&gt;deriving&lt;/code&gt; 조항 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="d2ba9a199527bbadec33a09879e817a0f6de5758" translate="yes" xml:space="preserve">
          <source>However, starting with &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt;, the default implementation is based on &lt;code&gt;DefaultSignatures&lt;/code&gt; allowing for more accurate auto-derived &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; instances. If you need the previously used exact default &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method implementation semantics, use</source>
          <target state="translated">그러나 &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt; 부터 기본 구현은 보다 정확한 자동 파생 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; 인스턴스를 허용 하는 &lt;code&gt;DefaultSignatures&lt;/code&gt; 를 기반으로 합니다. 이전에 사용 된 정확한 기본 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 메소드 구현 시맨틱 이 필요한 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7024ade898249c07bcf841caece72369d63586b1" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; axioms both match the wanted constraint &lt;code&gt;C a&lt;/code&gt;. There are several possible approaches for handling these overlapping local axioms:</source>
          <target state="translated">그러나 &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; 및 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; 축은 모두 원하는 구속 조건 &lt;code&gt;C a&lt;/code&gt; 와 일치합니다 . 이러한 중복 로컬 공리를 처리하기위한 몇 가지 가능한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8981ad8f62f6891902d31a96ee844f6c284310" translate="yes" xml:space="preserve">
          <source>However, the instance declaration must still conform to the rules for instance termination: see &lt;a href=&quot;#instance-termination&quot;&gt;Instance termination rules&lt;/a&gt;.</source>
          <target state="translated">그러나 인스턴스 선언은 여전히 &lt;a href=&quot;#instance-termination&quot;&gt;인스턴스 종료 규칙을 따라야&lt;/a&gt; 합니다 ( 인스턴스 종료 규칙 참조) .</target>
        </trans-unit>
        <trans-unit id="f0881e26d84cd12d8c7fd2b522507d9075fd4696" translate="yes" xml:space="preserve">
          <source>However, the real implemenation uses memcmp to compare the end of the string only, with no reverse required..</source>
          <target state="translated">그러나 실제 구현에서는 memcmp를 사용하여 문자열의 끝만 비교하며 반대 순서는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06134ece72c951c7d7c727c39885e4d66b957bb6" translate="yes" xml:space="preserve">
          <source>However, the second law is violated in the presence of undefined operators,</source>
          <target state="translated">그러나 정의되지 않은 연산자가 있으면 두 번째 법을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="a72bbc3e10475e3349a7633255fe25a94534717f" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent and Parallel Haskell&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="translated">그러나 두 용어는 확실히 관련이 있습니다. 여러 CPU를 사용하면 동시 스레드를 병렬로 실행할 수 있으며 이것이 바로 GHC의 SMP 병렬 처리 지원과 동일합니다. 그러나 동시성을 사용하지 않는 프로그램에서 병렬 처리를 통해 성능을 향상시킬 수도 있습니다. 이 섹션에서는 GHC를 사용하여 병렬 프로그램을 컴파일하고 실행하는 방법을 설명하고, &lt;a href=&quot;parallel#lang-parallel&quot;&gt;동시 및 병렬 Haskell&lt;/a&gt; 에서는 병렬 처리에 영향을주는 언어 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d0d7fb9afd1affd6fb2291bb8b2736b5c57061fb" translate="yes" xml:space="preserve">
          <source>However, the unrestricted use of &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; is a problem as an arbitrary module can use it to mark themselves as trusted, yet &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t offer any guarantees about the module, unlike &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. To control the use of trustworthy modules it is recommended to use the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag. This flag adds an extra requirement to the trust check for trustworthy modules. It requires that for a trustworthy modules to be considered trusted, and allowed to be used in &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future compilation against that package would fail. For a more detailed overview of this mechanism see &lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modes&lt;/a&gt;.</source>
          <target state="translated">그러나 임의 모듈이이 모듈을 사용하여 자신을 신뢰할 수있는 것으로 표시 할 수 있기 때문에 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 의 무제한 사용은 문제가되지만 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 와 달리 모듈에 대한 보증을 제공하지 않습니다 . 신뢰할 수있는 모듈의 사용을 제어하려면 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하는 것이 좋습니다 . 이 플래그는 신뢰할 수있는 모듈에 대한 신뢰 검사에 추가 요구 사항을 추가합니다. 신뢰할 수있는 모듈을 신뢰할 수있는 것으로 간주하고 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있어야합니다.코드를 컴파일하는 클라이언트 C는 코드를 컴파일하는 클라이언트 C가 신뢰할 수있는 모듈이있는 패키지를 신뢰한다고 GHC에 알려야합니다. 이것은 본질적으로 C가 말하는 방법이며,이 패키지에는 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 신뢰할 수없는 모듈이 사용할 수있는 신뢰할 수있는 모듈이 들어 있습니다 , 나는이 패키지의 저자를 신뢰하고 모듈이 안전한 API만을 노출 시킨다고 믿는다. 패키지의 신뢰는 언제든지 변경 될 수 있으므로 패키지에서 취약점이 발견되면 C는 패키지에 대한 향후 컴파일이 실패하도록 패키지를 신뢰할 수 없음으로 선언 할 수 있습니다. 이 메커니즘에 대한 자세한 내용은 &lt;a href=&quot;#safe-trust&quot;&gt;신뢰 및 안전 하스켈 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b532bdc7013089e7dc2ea095365363430246167b" translate="yes" xml:space="preserve">
          <source>However, there are a couple of problems with this approach. The first is that having two exception handlers is inefficient. However, the more serious issue is that the second exception handler will catch exceptions in the first, e.g. in the example above, if &lt;code&gt;handleArith&lt;/code&gt; throws an &lt;code&gt;IOException&lt;/code&gt; then the second exception handler will catch it.</source>
          <target state="translated">그러나이 방법에는 몇 가지 문제점이 있습니다. 첫 번째는 두 개의 예외 핸들러를 갖는 것이 비효율적이라는 것입니다. 그러나 더 심각한 문제는 두 번째 예외 핸들러가 첫 번째 예외 (예 : 위의 예)에서 예외를 포착한다는 것입니다. &lt;code&gt;handleArith&lt;/code&gt; 가 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시키면 두 번째 예외 핸들러가 예외를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="d9ee23f1fd11c8d62aeb9eeee086197709f0be7d" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 에서 항상 안전하게 호출 할 수있는 트랜잭션 변수를 작성하는 기능이 있습니다 . 참조 : &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c22293f9f5fdf9be0f89ee2fe6ac2c9f85e6c4fa" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 에서 항상 안전하게 호출 할 수있는 트랜잭션 변수를 만드는 함수가 있습니다 . 참조 : &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c11995af9963ba10b5fec5e359b15b835f98697" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 에서 항상 안전하게 호출 할 수있는 트랜잭션 변수를 작성하는 기능이 있습니다 . 참조 : &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ef09da657ffc9d4af89d0f416150551e096de936" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 에서 항상 안전하게 호출 할 수있는 트랜잭션 변수를 작성하는 기능이 있습니다 . 참조 : &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="36debdedc3fc8b9fe245012b3b2d0f8a8b3e2720" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">그러나 이것은 유닉스 이외의 일부 OS에서는 구현하기가 어렵 기 때문에 최대한의 이식성을 위해 호출 된대로 프로그램의 리프 이름 만 반환합니다. 그럼에도 플랫폼간에 약간의 차이가 있습니다. 예를 들어, Windows에서 foo로 호출 된 프로그램은 실제로 &lt;code&gt;FOO.EXE&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; 이 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="04e5a60e9a91ca4a5044b3e556c3f51ba02637a2" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">그러나 이것은 유닉스 이외의 일부 OS에서는 구현하기가 어렵 기 때문에 최대한의 이식성을 위해 호출 된대로 프로그램의 리프 이름 만 반환합니다. 그럼에도 플랫폼간에 약간의 차이가 있습니다. 예를 들어, Windows에서 foo로 호출 된 프로그램은 실제로 &lt;code&gt;FOO.EXE&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; 이 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd5fe8ac3752b514477ab6da6483511ccc949a4e" translate="yes" xml:space="preserve">
          <source>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</source>
          <target state="translated">그러나 레이아웃 대신 명시 적 세미콜론을 사용하여 완전한 정의를 한 줄에 제공해야하므로 여러 절 또는 상호 재귀 함수 그룹을 사용하여 함수를 정의 할 때 빠르게 지루합니다.</target>
        </trans-unit>
        <trans-unit id="321449b209a4a3d9b8a213d15a63e5983b737e5b" translate="yes" xml:space="preserve">
          <source>However, this restriction can be relaxed by enabling &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unlifted-newtypes&quot;&gt;section on unlifted newtypes&lt;/a&gt; details the behavior of such types.</source>
          <target state="translated">그러나이 제한은 &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; 를 활성화하여 완화 할 수 있습니다 . 해제되지 않은 새로운 유형 &lt;a href=&quot;#unlifted-newtypes&quot;&gt;에&lt;/a&gt; 대한 섹션에서는 이러한 유형의 동작을 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8c072dae816d58a4bbbf3253aaac2ff2d7bee49e" translate="yes" xml:space="preserve">
          <source>However, this would not be permitted, because &lt;code&gt;x&lt;/code&gt; is ambiguous:</source>
          <target state="translated">그러나 &lt;code&gt;x&lt;/code&gt; 가 모호 하기 때문에 이것은 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6a6176295d69c876f06979d7fd1959a45e1552" translate="yes" xml:space="preserve">
          <source>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</source>
          <target state="translated">그러나 데이터 패밀리 인스턴스의 유형 클래스 인스턴스는 다른 데이터 유형과 매우 유사하게 정의 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="67eb60c225421062cda3e126bd114e249c145db9" translate="yes" xml:space="preserve">
          <source>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</source>
          <target state="translated">그러나 데이터 유형을 결정하기 위해 인수의 유형을 유추하거나 제약 조건 솔버에 대한 선택을 연기하는 방법이 없습니다. 따라서 다음은 모호합니다.</target>
        </trans-unit>
        <trans-unit id="2d46b3249f71b533cad63e9708c9fb1563db8ccc" translate="yes" xml:space="preserve">
          <source>However, with &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; set to e.g. &lt;code&gt;1&lt;/code&gt;, it will additionally offer up a list of refinement hole fits, in this case:</source>
          <target state="translated">그러나 &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 설정 하면 다음과 같이 정제 구멍 맞춤 목록을 추가로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c1c33bc1108d9b6ddb6ca92ba69a2740518cc11" translate="yes" xml:space="preserve">
          <source>HpcHash</source>
          <target state="translated">HpcHash</target>
        </trans-unit>
        <trans-unit id="a360e1a8abea3420612de3ead3619643eba9cb5b" translate="yes" xml:space="preserve">
          <source>HpcPos</source>
          <target state="translated">HpcPos</target>
        </trans-unit>
        <trans-unit id="e4d5ebe01dfadab7c70f17122ef7cd34dd84d2c8" translate="yes" xml:space="preserve">
          <source>Html</source>
          <target state="translated">Html</target>
        </trans-unit>
        <trans-unit id="124fd6e6c83b9f6fb819bac633416da6be7be061" translate="yes" xml:space="preserve">
          <source>Html abbreviations</source>
          <target state="translated">HTML 약어</target>
        </trans-unit>
        <trans-unit id="e52dad2394901ae9e2d9331b3f2acf8d98f94c3d" translate="yes" xml:space="preserve">
          <source>Html colors</source>
          <target state="translated">HTML 색상</target>
        </trans-unit>
        <trans-unit id="61902ef6ccfb44a18ca2dc1621601009523e9eaa" translate="yes" xml:space="preserve">
          <source>HtmlAttr</source>
          <target state="translated">HtmlAttr</target>
        </trans-unit>
        <trans-unit id="1a8747bf93f58314ba9284567291634cad2df306" translate="yes" xml:space="preserve">
          <source>HtmlTable</source>
          <target state="translated">HtmlTable</target>
        </trans-unit>
        <trans-unit id="869a30d95c70a8d903e6df744e122731cf7e1681" translate="yes" xml:space="preserve">
          <source>HtmlTree</source>
          <target state="translated">HtmlTree</target>
        </trans-unit>
        <trans-unit id="2f70612bc16437d395e71287782bb6fd9cb7cf34" translate="yes" xml:space="preserve">
          <source>I can&amp;rsquo;t use</source>
          <target state="translated">나는 사용할 수 없다</target>
        </trans-unit>
        <trans-unit id="67e7f16393df9e1a3f34effee9614b452216e036" translate="yes" xml:space="preserve">
          <source>I/O error that is programmer-defined.</source>
          <target state="translated">프로그래머가 정의한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="be281ef8dae874dacda5f49b4225eb1d24483701" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재하여 조작이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="aa1a6c7e94bc5323e2b6ac2224ee418279aeb634" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 존재하지 않아 조작이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="cf116efd8157c9a3bd761c2360aee94f0bc67d1a" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used.</source>
          <target state="translated">인수 중 하나가 이미 사용중인 단일 사용 자원이므로 조작이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="cc128e1a7374671fae3700b7cd3ca03b1ae3b58e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the device is full.</source>
          <target state="translated">장치가 가득 차서 작업이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="d8f8e3fdaff7cb3366cae3acc6a3cd527d98dbd3" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the end of file has been reached.</source>
          <target state="translated">파일 끝에 도달하여 작업이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="82239ba587720ead23fb3ec489cdc8f072db7a33" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the resource vanished. See &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e0ff159cdede7a57ee03fa0daa909d8ace6979" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the resource vanished. This happens when, for example, attempting to write to a closed socket or attempting to write to a named pipe that was deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23225f523b6fe0da8418987860224d2674cecc83" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 충분한 운영 체제 권한이 없기 때문에 작업이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="4923b264f73fffadc5e3e140e95a5e90f4234f9e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation is not possible.</source>
          <target state="translated">작업이 불가능한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="9f2341b3a2667883fa17fd8660410d5080e25605" translate="yes" xml:space="preserve">
          <source>I/O errors</source>
          <target state="translated">I / O 오류</target>
        </trans-unit>
        <trans-unit id="893f42dbf3b6c3880cae0f711ab5e68ed55c84da" translate="yes" xml:space="preserve">
          <source>I/O operations required for implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">I / O 작업은 구현에 필요한 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="010704f655d5ffc0ec746349b6abc0e90227f6a7" translate="yes" xml:space="preserve">
          <source>I/O with &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">I / O와 &lt;code&gt;ByteString&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="ad04b3f0bd847573f914feec3f998fe1fbf5895a" translate="yes" xml:space="preserve">
          <source>I/O with Handles</source>
          <target state="translated">핸들이있는 I / O</target>
        </trans-unit>
        <trans-unit id="acc124dc3f9258dc88e844ea4ab0c049f8122496" translate="yes" xml:space="preserve">
          <source>I16</source>
          <target state="translated">I16</target>
        </trans-unit>
        <trans-unit id="eee5fb69722aeae0ef4402237b3281ea912a11ad" translate="yes" xml:space="preserve">
          <source>ID of group.</source>
          <target state="translated">그룹의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="34a94d7992e803328c642d1ab3fa274462915c38" translate="yes" xml:space="preserve">
          <source>ID of owner.</source>
          <target state="translated">소유자의 ID</target>
        </trans-unit>
        <trans-unit id="6fb496c44e36ef77af848cbdb3f2ef6feaf4502e" translate="yes" xml:space="preserve">
          <source>ID of the device on which this file resides.</source>
          <target state="translated">이 파일이있는 장치의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="bb2fe63e5a32cb2596d9f60d2ae271ae4d1c1787" translate="yes" xml:space="preserve">
          <source>INPUT</source>
          <target state="translated">INPUT</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="556d134b3ad4c3f832238864ee9ed1a9fff795e3" translate="yes" xml:space="preserve">
          <source>INT32</source>
          <target state="translated">INT32</target>
        </trans-unit>
        <trans-unit id="c35391cc7b82f6ccca4793a8e8e896ee6abb21d2" translate="yes" xml:space="preserve">
          <source>INT64</source>
          <target state="translated">INT64</target>
        </trans-unit>
        <trans-unit id="68e53a5693c9fc9b9b1250288b7552cd0ff0e2f9" translate="yes" xml:space="preserve">
          <source>INT_PTR</source>
          <target state="translated">INT_PTR</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="221a35a7e847cc97cca77325d3f3ad369c03402f" translate="yes" xml:space="preserve">
          <source>IO functions for serialisation</source>
          <target state="translated">직렬화를위한 IO 함수</target>
        </trans-unit>
        <trans-unit id="cc004908b1b2245fb78beda6015345ffd34734b1" translate="yes" xml:space="preserve">
          <source>IO-related Exception types and functions</source>
          <target state="translated">IO 관련 예외 유형 및 기능</target>
        </trans-unit>
        <trans-unit id="39e51b2fc5f7179682d0416f025521af63af3bff" translate="yes" xml:space="preserve">
          <source>IOArray</source>
          <target state="translated">IOArray</target>
        </trans-unit>
        <trans-unit id="c6a99f18754ec17dc03dabc42173c7669bade008" translate="yes" xml:space="preserve">
          <source>IOCallback</source>
          <target state="translated">IOCallback</target>
        </trans-unit>
        <trans-unit id="e37f3b10503e6237389797302777a6702097cc50" translate="yes" xml:space="preserve">
          <source>IODevice</source>
          <target state="translated">IODevice</target>
        </trans-unit>
        <trans-unit id="de20e3fa4c9228ace3c0f6bf748ad0bbf5c271d9" translate="yes" xml:space="preserve">
          <source>IODeviceType</source>
          <target state="translated">IODeviceType</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="08d5912d3126b1dfb78f32fc53ee4cb092bb66d6" translate="yes" xml:space="preserve">
          <source>IOErrorType</source>
          <target state="translated">IOErrorType</target>
        </trans-unit>
        <trans-unit id="319a21ad8b671794467e4935946062d4d1e04338" translate="yes" xml:space="preserve">
          <source>IOException</source>
          <target state="translated">IOException</target>
        </trans-unit>
        <trans-unit id="6eeb7a443b8d1cc8717295647ffb6fceb48316d4" translate="yes" xml:space="preserve">
          <source>IOMode</source>
          <target state="translated">IOMode</target>
        </trans-unit>
        <trans-unit id="b772fdda8de2d1e1a2fcd9af43fda137f1082681" translate="yes" xml:space="preserve">
          <source>IORef</source>
          <target state="translated">IORef</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
