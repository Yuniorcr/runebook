<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="468cdfbdf06effe43a3aa0fc4e881403e078094b" translate="yes" xml:space="preserve">
          <source>A right fold over the elements with no starting value</source>
          <target state="translated">시작 값이없는 요소를 오른쪽으로 접습니다.</target>
        </trans-unit>
        <trans-unit id="1bd8cdef3742749b47082f965a23008abf9bc15b" translate="yes" xml:space="preserve">
          <source>A rule does not need to be in the same module as (any of) the variables it mentions, though of course they need to be in scope.</source>
          <target state="translated">규칙은 언급 한 변수와 동일한 모듈에있을 필요는 없지만 물론 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4dda8ffe8bacae7a3d13b78da8fc37161b54e971" translate="yes" xml:space="preserve">
          <source>A rule may optionally have a phase-control number (see &lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;), immediately after the name of the rule. Thus:</source>
          <target state="translated">규칙은 규칙 이름 바로 다음 &lt;a href=&quot;#phase-control&quot;&gt;단계 제어&lt;/a&gt; 번호 ( 단계 제어 참조 )를 선택적으로 가질 수 있습니다 . 그러므로:</target>
        </trans-unit>
        <trans-unit id="9f50ddc31db41c043270b82360d43d4990fd88e5" translate="yes" xml:space="preserve">
          <source>A rule may optionally have a phase-control number (see &lt;a href=&quot;pragmas#phase-control&quot;&gt;Phase control&lt;/a&gt;), immediately after the name of the rule. Thus:</source>
          <target state="translated">규칙은 규칙 이름 바로 뒤에 선택적으로 단계 제어 번호 ( &lt;a href=&quot;pragmas#phase-control&quot;&gt;단계 제어&lt;/a&gt; 참조)를 가질 수 있습니다 . 그러므로:</target>
        </trans-unit>
        <trans-unit id="ba8873804ea20a68777a6a79acc2a5e0d1a22d48" translate="yes" xml:space="preserve">
          <source>A safe way to create and work with a mutable array before returning an immutable array for later perusal. This function avoids copying the array before returning it - it uses &lt;code&gt;unsafeFreeze&lt;/code&gt; internally, but this wrapper is a safe interface to that function.</source>
          <target state="translated">나중에 퍼포먼스를 위해 불변 배열을 반환하기 전에 가변 배열을 만들고 작업하는 안전한 방법입니다. 이 함수는 배열을 반환하기 전에 복사를 피합니다 &lt;code&gt;unsafeFreeze&lt;/code&gt; 내부적으로 unsafeFreeze를 사용 하지만이 래퍼는 해당 함수에 대한 안전한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8ed6207609d767c14b5aa06f9aa68c12587a18b1" translate="yes" xml:space="preserve">
          <source>A safe way to create and work with an unboxed mutable array before returning an immutable array for later perusal. This function avoids copying the array before returning it - it uses &lt;code&gt;unsafeFreeze&lt;/code&gt; internally, but this wrapper is a safe interface to that function.</source>
          <target state="translated">박스형의 가변 배열을 만들고 사용하여 나중에 퍼포먼스를 위해 불변 배열을 반환하는 안전한 방법. 이 함수는 배열을 반환하기 전에 복사를 피합니다 &lt;code&gt;unsafeFreeze&lt;/code&gt; 내부적으로 unsafeFreeze를 사용 하지만이 래퍼는 해당 함수에 대한 안전한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b9df3dc079f00f9a8e0de830c01848206acb9ca5" translate="yes" xml:space="preserve">
          <source>A sample (consisting of a list of break-down classes, e.g. cost centres, and heap residency sizes), is to be encoded in the body of one or more events.</source>
          <target state="translated">비용 센터 및 힙 상주 규모와 같은 분류 클래스 목록으로 구성된 샘플은 하나 이상의 이벤트 본문에 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="75c24f2265f3d8c4ccd393f15ae237ff3f6f2a33" translate="yes" xml:space="preserve">
          <source>A scoped type variable stands for a type &lt;em&gt;variable&lt;/em&gt;, and not for a &lt;em&gt;type&lt;/em&gt;. (This is a change from GHC&amp;rsquo;s earlier design.)</source>
          <target state="translated">범위가 지정된 타입 변수는 타입의 약자 &lt;em&gt;변수&lt;/em&gt; A에 대한, 그리고 &lt;em&gt;유형&lt;/em&gt; . (이것은 GHC의 초기 디자인에서 변경된 것입니다.)</target>
        </trans-unit>
        <trans-unit id="f9e8504d9f7ca56788ad83a6712e3deabb56b1fb" translate="yes" xml:space="preserve">
          <source>A sequence of actions produces a value only if all the actions in the sequence do. If one exits, the rest of the sequence is skipped and the composite action exits.</source>
          <target state="translated">일련의 조치는 순서의 모든 조치가 수행하는 경우에만 값을 생성합니다. 하나가 종료되면 나머지 시퀀스는 건너 뛰고 복합 조치가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="627ab33bc11dc284fde08d4bb2c60e4ca6633e05" translate="yes" xml:space="preserve">
          <source>A sequence of actions succeeds, producing a value, only if all the actions in the sequence are successful. If one fails with an error, the rest of the sequence is skipped and the composite action fails with that error.</source>
          <target state="translated">일련의 조치가 성공하여 순서의 모든 조치가 성공한 경우에만 값을 생성합니다. 오류로 실패하면 나머지 시퀀스는 건너 뛰고 복합 오류는 해당 오류로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2df1f1dd397310b516738a6b735261200af88e24" translate="yes" xml:space="preserve">
          <source>A sequence of actions terminates normally, producing a value, only if none of the actions in the sequence throws an exception. If one throws an exception, the rest of the sequence is skipped and the composite action exits with that exception.</source>
          <target state="translated">일련의 조치는 정상적으로 종료되어 순서의 조치가 예외를 처리하지 않는 경우에만 값을 생성합니다. 예외가 발생하면 나머지 시퀀스는 건너 뛰고 복합 예외는 해당 예외와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="86877c5118e45e245e3a082f5d36380aaa868a97" translate="yes" xml:space="preserve">
          <source>A sequence of non-space characters, or a sequence of arbitrary characters surrounded by quotes &lt;code&gt;&quot;....&quot;&lt;/code&gt;.</source>
          <target state="translated">비 공백 문자의 순서, 또는 따옴표로 둘러싸인 임의의 일련의 문자 &lt;code&gt;&quot;....&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76595a701ee44ea1c9f930a9c60dd85fa6bdaa4c" translate="yes" xml:space="preserve">
          <source>A sequence of strings, separated by commas. The sequence may be empty.</source>
          <target state="translated">쉼표로 구분 된 일련의 문자열. 시퀀스가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94dd7b6a2c0e4fe592c072a99a09ce1205c850da" translate="yes" xml:space="preserve">
          <source>A sequential garbage collection has been requested by a capability.</source>
          <target state="translated">기능에 의해 순차 가비지 콜렉션이 요청되었습니다.</target>
        </trans-unit>
        <trans-unit id="b9195a974dd24c0ef39d75bed4d1efb9a1d3015e" translate="yes" xml:space="preserve">
          <source>A set of integers.</source>
          <target state="translated">정수 세트.</target>
        </trans-unit>
        <trans-unit id="bb204bd8db13fe7816a94a82e9d47e0712050306" translate="yes" xml:space="preserve">
          <source>A set of signals reserved for use by the implementation. In GHC, this will normally include either &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigVTALRM&quot;&gt;sigVTALRM&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigALRM&quot;&gt;sigALRM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현에서 사용하도록 예약 된 신호 세트입니다. GHC에서는 일반적으로 &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigVTALRM&quot;&gt;sigVTALRM&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigALRM&quot;&gt;sigALRM&lt;/a&gt;&lt;/code&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a966b0c2cbc724a4e1636286c1f35ede7a08d8c" translate="yes" xml:space="preserve">
          <source>A set of values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">값 집합 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a84ea57aa89435041641005d90f97cd8afe4994e" translate="yes" xml:space="preserve">
          <source>A setEnv implementation that allows blank environment variables. Mimics the &lt;code&gt;&lt;a href=&quot;system-posix#v:Env&quot;&gt;Env&lt;/a&gt;&lt;/code&gt; module from the &lt;code&gt;unix&lt;/code&gt; package, but with support for Windows too.</source>
          <target state="translated">빈 환경 변수를 허용하는 setEnv 구현. &lt;code&gt;unix&lt;/code&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;system-posix#v:Env&quot;&gt;Env&lt;/a&gt;&lt;/code&gt; 모듈을 모방 하지만 Windows도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0e9f33b64534c5d6c799976470e6fc95c2cda254" translate="yes" xml:space="preserve">
          <source>A shared I/O port is almost the same as a &lt;code&gt;MVar#&lt;/code&gt;!). The main difference is that IOPort has no deadlock detection or deadlock breaking code that forcibly releases the lock.</source>
          <target state="translated">공유 I / O 포트는 &lt;code&gt;MVar#&lt;/code&gt; !) 와 거의 동일 합니다. 주요 차이점은 IOPort에는 강제로 잠금을 해제하는 교착 상태 감지 또는 교착 상태 차단 코드가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f4ca239f09f9ab5cacd4dc55290c45509ce3c667" translate="yes" xml:space="preserve">
          <source>A shared mutable variable (&lt;em&gt;not&lt;/em&gt; the same as a &lt;code&gt;MutVar#&lt;/code&gt;!). (Note: in a non-concurrent implementation, &lt;code&gt;(MVar# a)&lt;/code&gt; can be represented by &lt;code&gt;(MutVar# (Maybe a))&lt;/code&gt;.)</source>
          <target state="translated">공유 가능한 가변 변수 ( &lt;code&gt;MutVar#&lt;/code&gt; 와 동일 &lt;em&gt;하지 않음&lt;/em&gt; !) (참고 : 비 동시 구현에서 &lt;code&gt;(MVar# a)&lt;/code&gt; 는 &lt;code&gt;(MutVar# (Maybe a))&lt;/code&gt; 로 나타낼 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="a82158df9a5688ce51d763088d1b6426e23f9a62" translate="yes" xml:space="preserve">
          <source>A shortcut for multiple definitions which use &lt;code&gt;#const&lt;/code&gt;. Each &lt;code&gt;value&lt;/code&gt; is a name of a C integer constant, e.g. enumeration value. The name will be translated to Haskell by making each letter following an underscore uppercase, making all the rest lowercase, and removing underscores. You can supply a different translation by writing &lt;code&gt;hs_name = c_value&lt;/code&gt; instead of a &lt;code&gt;value&lt;/code&gt;, in which case &lt;code&gt;c_value&lt;/code&gt; may be an arbitrary expression. The &lt;code&gt;hs_name&lt;/code&gt; will be defined as having the specified &lt;code&gt;type&lt;/code&gt;. Its definition is the specified &lt;code&gt;constructor&lt;/code&gt; (which in fact may be an expression or be empty) applied to the appropriate integer value. You can have multiple &lt;code&gt;#enum&lt;/code&gt; definitions with the same &lt;code&gt;type&lt;/code&gt;; this construct does not emit the type definition itself.</source>
          <target state="translated">&lt;code&gt;#const&lt;/code&gt; 를 사용하는 여러 정의에 대한 바로 가기입니다 . 각 &lt;code&gt;value&lt;/code&gt; 은 C 정수 상수의 이름입니다 (예 : 열거 형 값). 이름은 각 문자를 밑줄 대문자로 만들고 나머지는 모두 소문자로 만들고 밑줄을 제거하여 Haskell로 이름을 변환합니다. 사용자가 작성하여 다른 번역을 제공 할 수 &lt;code&gt;hs_name = c_value&lt;/code&gt; (A)의 대신 &lt;code&gt;value&lt;/code&gt; 케이스되는, &lt;code&gt;c_value&lt;/code&gt; 이 임의의 표현 일 수있다. &lt;code&gt;hs_name&lt;/code&gt; 가 지정된 것으로 정의되는 &lt;code&gt;type&lt;/code&gt; . 정의는 지정된 &lt;code&gt;constructor&lt;/code&gt; (실제로 표현식이거나 비어있을 수 있음)가 적절한 정수 값에 적용됩니다. 여러 개를 가질 수 있습니다 &lt;code&gt;#enum&lt;/code&gt; 같은 &lt;code&gt;type&lt;/code&gt; #enum 정의 ; 이 구문은 형식 정의 자체를 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00e25301890375feab76786821b7d4508efb82ce" translate="yes" xml:space="preserve">
          <source>A signature file is denoted by an &lt;code&gt;hsig&lt;/code&gt; file; every required signature must have an &lt;code&gt;hsig&lt;/code&gt; file (even if it is an empty one), including required signatures inherited from dependencies. Signatures can be imported using an ordinary &lt;code&gt;import Sig&lt;/code&gt; declaration.</source>
          <target state="translated">서명 파일은 &lt;code&gt;hsig&lt;/code&gt; 파일 로 표시됩니다 . 모든 필수 서명에는 종속성에서 상속 된 필수 서명을 포함 하여 &lt;code&gt;hsig&lt;/code&gt; 파일 이 있어야 합니다 (빈 파일 인 경우에도). 서명은 일반적인 &lt;code&gt;import Sig&lt;/code&gt; 선언을 사용하여 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92355b0e296eb8f9e53318fcbdb4d680dbc31d1d" translate="yes" xml:space="preserve">
          <source>A signed integral type that can be losslessly converted to and from &lt;code&gt;Ptr&lt;/code&gt;. This type is also compatible with the C99 type &lt;code&gt;intptr_t&lt;/code&gt;, and can be marshalled to and from that type safely.</source>
          <target state="translated">&lt;code&gt;Ptr&lt;/code&gt; 과 무손실로 변환 할 수있는 부호있는 정수 유형입니다 . 이 유형은 C99 유형 &lt;code&gt;intptr_t&lt;/code&gt; 와도 호환되며 해당 유형과 안전하게 마샬링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="948520b277e60dcee21361dd65adb915f2606d36" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 을 사용하여 비슷한 배열 값 변환을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99bde5053270918eb2f3d7c1e964f644e4ce138b" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 을 사용하여 비슷한 배열 값 변환을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4de6912d1447ddb732a8d09237cfff4f57791648" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 을 사용하여 비슷한 배열 값 변환을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbbe5e3287fe101eaac49bce2bfcb028d8f2b308" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 을 사용하여 비슷한 배열 값 변환을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6c85786bd39c1497a36a8cbe06706b97c38a416" translate="yes" xml:space="preserve">
          <source>A simple choice for the type associated with flags is to define a type &lt;code&gt;Flag&lt;/code&gt; as an algebraic type representing the possible flags and their arguments:</source>
          <target state="translated">플래그와 연관된 유형에 대한 간단한 선택은 유형 &lt;code&gt;Flag&lt;/code&gt; 를 가능한 플래그 및 해당 인수를 나타내는 대수 유형으로 정의하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="385ee26bb3c563691e99d165abb3ca38a355c178" translate="yes" xml:space="preserve">
          <source>A simple day and time aggregate, where the day is of the specified parameter, and the time is a TimeOfDay. Conversion of this (as local civil time) to UTC depends on the time zone. Conversion of this (as local mean time) to UT1 depends on the longitude.</source>
          <target state="translated">일이 지정된 매개 변수이고 시간이 TimeOfDay 인 간단한 요일 및 시간 집계입니다. 현지 시간으로 UTC로 변환하는 것은 시간대에 따라 다릅니다. 이것을 (지역 평균 시간으로) UT1로 변환하는 것은 경도에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5071edc607af851a249c97dfb4d0c57e03432a4d" translate="yes" xml:space="preserve">
          <source>A simple example of the new notation is the expression</source>
          <target state="translated">새로운 표기법의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32cefd4bea4e7110a3dca7239bc47887ca83ce67" translate="yes" xml:space="preserve">
          <source>A simple pairing heap.</source>
          <target state="translated">간단한 페어링 힙.</target>
        </trans-unit>
        <trans-unit id="8ad0b83378258a314fc0adf90a8e10c9bc3f1588" translate="yes" xml:space="preserve">
          <source>A simple use of unfoldr:</source>
          <target state="translated">펼치기의 간단한 사용법 :</target>
        </trans-unit>
        <trans-unit id="a1f654f7060b7d2d650700b6c757eab119833574" translate="yes" xml:space="preserve">
          <source>A simpler version of this function is:</source>
          <target state="translated">이 기능의 간단한 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="109ec8484c225e4b238b8dbafe102ddb90cbe663" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;deriving&lt;/code&gt; clause at the end of a datatype.</source>
          <target state="translated">데이터 유형의 끝에 단일 &lt;code&gt;deriving&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="07552ccc8f83d8da8c2ff1373fe5871fc375aea0" translate="yes" xml:space="preserve">
          <source>A single Char fragment</source>
          <target state="translated">단일 Char 조각</target>
        </trans-unit>
        <trans-unit id="c8a470d3f21b5f8bd88b72ca5e212009e6a9ba92" translate="yes" xml:space="preserve">
          <source>A single data constructor.</source>
          <target state="translated">단일 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="8b90ffe9d4585beccabc5b42a63afc7e90a28d58" translate="yes" xml:space="preserve">
          <source>A single fixed-width event emitted during program start-up describing the samples that follow.</source>
          <target state="translated">프로그램 시작시 발생하는 단일 고정 폭 이벤트는 다음 샘플을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dce34a123f3c9357183ae1491a545fbaf2ea2561" translate="yes" xml:space="preserve">
          <source>A single location in the source code.</source>
          <target state="translated">소스 코드의 단일 위치</target>
        </trans-unit>
        <trans-unit id="50f411ba135dec27d6a3801b72dc1838706dca5a" translate="yes" xml:space="preserve">
          <source>A single vertex that is not in any cycle.</source>
          <target state="translated">사이클에없는 단일 정점</target>
        </trans-unit>
        <trans-unit id="97bd9aab1d447685b69723475ad0a956cc38e08e" translate="yes" xml:space="preserve">
          <source>A sink of event-log data.</source>
          <target state="translated">이벤트 로그 데이터 싱크</target>
        </trans-unit>
        <trans-unit id="80976804b592e9e2e94c0bbcedb3e158f3a504b2" translate="yes" xml:space="preserve">
          <source>A size in UTF-16 code units.</source>
          <target state="translated">UTF-16 코드 단위의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="909e2a440c7053acbcd40d2af23d2760c9d12442" translate="yes" xml:space="preserve">
          <source>A skip channel is a pair of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s. The first &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; contains the current value, and a list of semaphores that need to be notified when it changes. The second &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is a semaphore for this particular reader: it is full if there is a value in the channel that this reader has not read yet, and empty otherwise.</source>
          <target state="translated">스킵 채널은 한 쌍의 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 입니다. 첫 번째 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에는 현재 값과 변경시 알려야하는 세마포어 목록이 있습니다. 두 번째 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 는이 특정 리더의 세마포어입니다.이 리더가 아직 읽지 않은 채널에 값이 있으면 가득 차고 그렇지 않으면 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="75b2421aa3377ed4749c4916a0cb0dcfc04c0013" translate="yes" xml:space="preserve">
          <source>A slight variation on &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; that allows a value to be returned (&lt;code&gt;b&lt;/code&gt;) in addition to the modified value of the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 약간의 변동 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 값을 허용 (반환되는 &lt;code&gt;b&lt;/code&gt; 의 수정 값 이외에) &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f69c10ed60508f59cb5a529f1b359642cbe6b858" translate="yes" xml:space="preserve">
          <source>A slightly faster version of &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; that may not be safe to use with multiple threads. The unsafety arises when used like this:</source>
          <target state="translated">여러 스레드에서 사용하기에 안전하지 않을 수 있는 약간 빠른 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 버전입니다 . 안전은 다음과 같이 사용될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a46cd68f2f2846ae726246b12281b2435629226" translate="yes" xml:space="preserve">
          <source>A small example:</source>
          <target state="translated">작은 예 :</target>
        </trans-unit>
        <trans-unit id="f3fa3447a8afd4949b9c12f9f8e9147cd390aae9" translate="yes" xml:space="preserve">
          <source>A small word of warning: &lt;a href=&quot;#ghc-flag--cpp&quot;&gt;&lt;code&gt;-cpp&lt;/code&gt;&lt;/a&gt; is not friendly to &amp;ldquo;string gaps&amp;rdquo;. In other words, strings such as the following:</source>
          <target state="translated">작은 경고 단어 : &lt;a href=&quot;#ghc-flag--cpp&quot;&gt; &lt;code&gt;-cpp&lt;/code&gt; &lt;/a&gt; 는&amp;ldquo;문자열 간격&amp;rdquo;에 적합하지 않습니다. 즉, 다음과 같은 문자열 :</target>
        </trans-unit>
        <trans-unit id="b896df9db0191f80e6db640a0983ae75b9330707" translate="yes" xml:space="preserve">
          <source>A space character</source>
          <target state="translated">공백 문자</target>
        </trans-unit>
        <trans-unit id="2cf7bf5a17da5fc043fc8f14a663aecfa5439dbc" translate="yes" xml:space="preserve">
          <source>A space efficient, packed, unboxed Unicode text type.</source>
          <target state="translated">공간 효율적이고 압축 된 언 박스 유니 코드 텍스트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b320aab997efd2d7ca1e00ac225c124b5d920ec5" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="translated">공간 효율적인 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 벡터 표현으로 많은 효율적인 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="edd5ed41a7ad61d8ccb7e1f320dd68310fe46295" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="translated">많은 효율적인 작업을 지원 하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 벡터 의 공간 효율적인 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="528bfc88f2580c5e4224639fe1f9ce14d026166f" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="translated">많은 효율적인 작업을 지원 하는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 벡터 의 공간 효율적인 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="e34c30bb293046f1353d1b4c1fb7e4c15767c64f" translate="yes" xml:space="preserve">
          <source>A spanning forest of the graph, obtained from a depth-first search of the graph starting from each vertex in an unspecified order.</source>
          <target state="translated">지정되지 않은 순서로 각 정점에서 시작하는 그래프의 깊이 우선 검색에서 얻은 그래프의 스패닝 포리스트.</target>
        </trans-unit>
        <trans-unit id="4794ea6b46c0b3e368866c3f6657148757943020" translate="yes" xml:space="preserve">
          <source>A spanning forest of the part of the graph reachable from the listed vertices, obtained from a depth-first search of the graph starting at each of the listed vertices in order.</source>
          <target state="translated">나열된 각 정점에서 순서대로 시작하여 그래프의 깊이 우선 검색에서 얻은 나열된 정점에서 도달 가능한 그래프 부분의 스패닝 포리스트.</target>
        </trans-unit>
        <trans-unit id="17409cdf1a726a6b210a04d4446854b3d6bf4233" translate="yes" xml:space="preserve">
          <source>A spark has been GC&amp;rsquo;d before being evaluated.</source>
          <target state="translated">스파크는 평가되기 전에 GC 처리되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc7a9f3b3b4de7ca05232bf75a6a63a5d4979fe6" translate="yes" xml:space="preserve">
          <source>A spark has been added to the spark pool.</source>
          <target state="translated">스파크 풀에 스파크가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="20ef42be18896ca33cf39edd26afbfce8fc5c5ae" translate="yes" xml:space="preserve">
          <source>A spark has been stolen from another capability for evaluation.</source>
          <target state="translated">평가를 위해 다른 기능에서 스파크가 도난당했습니다.</target>
        </trans-unit>
        <trans-unit id="000576d9dd7d866ebbbaf02ec2da581917b4c07a" translate="yes" xml:space="preserve">
          <source>A special case of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which &lt;code&gt;&lt;a href=&quot;ghc-err#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; appears.</source>
          <target state="translated">특별한 &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . 컴파일러는이를 인식하고 &lt;code&gt;&lt;a href=&quot;ghc-err#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 상황에보다 적합한 오류 메시지를 삽입 할 것으로 예상 됩니다.</target>
        </trans-unit>
        <trans-unit id="73c8066b78af5a513799e5e6e43841a928951845" translate="yes" xml:space="preserve">
          <source>A special case of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; appears.</source>
          <target state="translated">특별한 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . 컴파일러는이를 인식하고 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 상황에보다 적합한 오류 메시지를 삽입 할 것으로 예상 됩니다.</target>
        </trans-unit>
        <trans-unit id="b61fe333d2ebb606e68ef9534fb8ee51a3dcbe6f" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; with just a computation to run afterward.</source>
          <target state="translated">나중에 실행할 계산 만있는 특수한 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="d381bfcecd222a40938da33628701d9caa7e0fc9" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 컨텍스트 0을 사용하고 일반 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 반환하는 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 의 특수 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="3551127e07d1074127cf665da3dc3de8f74d78ac" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 컨텍스트 0을 사용하고 일반 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 반환하는 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 의 특수 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7f3343104c8933573bbaff2361f546628d45e8d8" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; with just a computation to run afterward.</source>
          <target state="translated">나중에 실행할 계산 만있는 특수한 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="addf8bf904a9b53d42ba0004dc6e0c96e5f166b4" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 컨텍스트 0을 사용하고 일반 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 반환하는 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 의 특수 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="1a0c5e6176b1b7f34e452cb42488bc078090478d" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; where the value is actually a pair of the key and value passed to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPair&quot;&gt;mkWeakPair&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">값이 실제로 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPair&quot;&gt;mkWeakPair&lt;/a&gt;&lt;/code&gt; 에 전달 된 키와 값 의 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; 의 특수 버전 :</target>
        </trans-unit>
        <trans-unit id="ed256b1475f3db11a1e053e7393f2e62ac0741a5" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt;, where the key and the value are the same object:</source>
          <target state="translated">키와 값이 동일한 객체 인 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; 의 특수 버전 :</target>
        </trans-unit>
        <trans-unit id="88cbeb4d1e4332278f7efaec95990a7cd06ab5a6" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPtr&quot;&gt;mkWeakPtr&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object returned is simply thrown away (however the finalizer will be remembered by the garbage collector, and will still be run when the key becomes unreachable).</source>
          <target state="translated">반환 된 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 객체는 단순히 버려지는 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPtr&quot;&gt;mkWeakPtr&lt;/a&gt;&lt;/code&gt; 의 특수 버전입니다 (그러나 종료자는 가비지 수집기에서 기억하고 키에 도달 할 수 없을 때에도 계속 실행됩니다).</target>
        </trans-unit>
        <trans-unit id="c000f76b0d515b8c303304c303dc38592d07556a" translate="yes" xml:space="preserve">
          <source>A splice can occur in place of</source>
          <target state="translated">스플 라이스 대신에 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8347bfbd4296dc52f2f8f7af1d3b4addc2cc0243" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the expression. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;rdquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="translated">스플 라이스는 &lt;code&gt;$x&lt;/code&gt; 로 작성 됩니다. 여기서 &lt;code&gt;x&lt;/code&gt; 는 임의의 표현식입니다. &quot;$&quot;와 식 사이에는 공백이 없어야합니다. 이 &quot;$&quot;사용은 &quot;Mx&quot;가 &quot;&quot;의 의미를 재정의하는 것처럼 중위 연산자로서의 의미를 재정의합니다. &quot; 중위 연산자로. 중위 연산자를 원하면 주위에 공백을 두십시오.</target>
        </trans-unit>
        <trans-unit id="cd4cb3a4aa37b46f04784c0f6f0060998bc7f64a" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$(...)&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the identifier or parenthesis. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;ldquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="translated">스플 라이스는 &lt;code&gt;$x&lt;/code&gt; 이며 여기서 &lt;code&gt;x&lt;/code&gt; 는 식별자이거나 &lt;code&gt;$(...)&lt;/code&gt; 이며 여기서&amp;ldquo;&amp;hellip;&amp;rdquo;은 임의의 표현식입니다. &quot;$&quot;와 식별자 또는 괄호 사이에는 공백이 없어야합니다. 이 &quot;$&quot;사용은 &quot;Mx&quot;가 &quot;.&quot;의 의미를 재정의하는 것처럼 중위 연산자로서의 의미를 재정의합니다. 중위 연산자로. 중위 연산자를 원하면 주위에 공백을 두십시오.</target>
        </trans-unit>
        <trans-unit id="2fc7d08e30e7130abc877e7e166eb7f0bb2f0e91" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$(...)&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the identifier or parenthesis. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;rdquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="translated">스플 라이스는 &lt;code&gt;$x&lt;/code&gt; 로 작성 되며, 여기서 &lt;code&gt;x&lt;/code&gt; 는 식별자이거나 &lt;code&gt;$(...)&lt;/code&gt; . 여기서&amp;rdquo;...&amp;rdquo;는 임의의 표현식입니다. &amp;ldquo;$&amp;rdquo;와 식별자 또는 괄호 사이에는 공백이 없어야합니다. 이와 같이 &quot;$&quot;를 사용하면 &quot;Mx&quot;가 &quot;&quot;의 의미를 재정의하는 것처럼 삽입 연산자로서의 의미를 재정의합니다. &quot; 중위 연산자로. 삽입 연산자를 원하면 공백을 두십시오.</target>
        </trans-unit>
        <trans-unit id="029020ae6b32756dd16466eb423a1a26ab4457d6" translate="yes" xml:space="preserve">
          <source>A state monad parameterized by the type &lt;code&gt;s&lt;/code&gt; of the state to carry.</source>
          <target state="translated">상태 A는 유형에 의해 파라미터 모나드 &lt;code&gt;s&lt;/code&gt; 캐리에 대한 국가의.</target>
        </trans-unit>
        <trans-unit id="dc96818c8486fd2f0989d60f3799e6dcb782b7f0" translate="yes" xml:space="preserve">
          <source>A state transformer monad parameterized by:</source>
          <target state="translated">다음에 의해 매개 변수화 된 상태 변환기 모나드</target>
        </trans-unit>
        <trans-unit id="584d223e5ba9554539274f317131b078dc9f657c" translate="yes" xml:space="preserve">
          <source>A static form determines a value of type &lt;code&gt;StaticPtr t&lt;/code&gt;, but just like &lt;code&gt;OverloadedLists&lt;/code&gt; and &lt;code&gt;OverloadedStrings&lt;/code&gt;, this literal expression is overloaded to allow lifting a &lt;code&gt;StaticPtr&lt;/code&gt; into another type implicitly, via the &lt;code&gt;IsStatic&lt;/code&gt; class:</source>
          <target state="translated">정적 형식은 &lt;code&gt;StaticPtr t&lt;/code&gt; 유형의 값을 결정 하지만 &lt;code&gt;OverloadedLists&lt;/code&gt; 및 &lt;code&gt;OverloadedStrings&lt;/code&gt; 와 마찬가지로 &lt;code&gt;IsStatic&lt;/code&gt; 클래스 를 통해 &lt;code&gt;StaticPtr&lt;/code&gt; 을 다른 유형으로 암시 적으로 들어 올릴 수 있도록이 리터럴 표현식이 오버로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="29153c897e531a67acff58cc6b01500af3000f33" translate="yes" xml:space="preserve">
          <source>A storable array is an IO-mutable array which stores its contents in a contiguous memory block living in the C heap. Elements are stored according to the class &lt;code&gt;Storable&lt;/code&gt;. You can obtain the pointer to the array contents to manipulate elements from languages like C.</source>
          <target state="translated">저장 가능 어레이는 해당 내용을 C 힙에있는 연속 메모리 블록에 저장하는 IO 변경 가능 어레이입니다. 요소는 &lt;code&gt;Storable&lt;/code&gt; 클래스에 따라 저장됩니다 . C와 같은 언어에서 요소를 조작하기 위해 배열 내용에 대한 포인터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f5037287f3893bff45330861345a86eebed76c2" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 구성된 청크 스트림 .</target>
        </trans-unit>
        <trans-unit id="43919f0b621bd7f60ea00562492dbc3adfa8a6aa" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 구성되는 청크 스트림입니다 .</target>
        </trans-unit>
        <trans-unit id="f56c425d06d6a4abacf4b26c19f6964c1319467d" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 생성 된 청크 스트림입니다 .</target>
        </trans-unit>
        <trans-unit id="9b113394401941b6890516fb8e3af8a462d1fd40" translate="yes" xml:space="preserve">
          <source>A stream oriented decoding result.</source>
          <target state="translated">스트림 지향 디코딩 결과.</target>
        </trans-unit>
        <trans-unit id="d911f61b4fa0d9284a8e1a6f69a0f61b1e73b5e6" translate="yes" xml:space="preserve">
          <source>A strict left fold over the elements</source>
          <target state="translated">요소에 대해 엄격한 왼쪽 접기</target>
        </trans-unit>
        <trans-unit id="98cd4454f56f48afeffc70d90f58b5920ca58301" translate="yes" xml:space="preserve">
          <source>A strict pair</source>
          <target state="translated">엄격한 쌍</target>
        </trans-unit>
        <trans-unit id="6eccc911da51c833236284b3d32b3123513710ad" translate="yes" xml:space="preserve">
          <source>A strict pattern match in a bind statement prevents &lt;code&gt;ApplicativeDo&lt;/code&gt; from transforming that statement to use &lt;code&gt;Applicative&lt;/code&gt;. This is because the transformation would change the semantics by making the expression lazier.</source>
          <target state="translated">바인드 명령문에서 엄격한 패턴 일치는 &lt;code&gt;ApplicativeDo&lt;/code&gt; 가 해당 명령문을 변환하여 &lt;code&gt;Applicative&lt;/code&gt; 를 사용 하지 못하게 합니다. 변환은 표현을 더 느리게 만들어 의미를 변경하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0814095da0f374f363b2744acbf7641a2610efcb" translate="yes" xml:space="preserve">
          <source>A strict right fold over the elements</source>
          <target state="translated">요소에 대한 엄격한 오른쪽 접기</target>
        </trans-unit>
        <trans-unit id="0ec086694cd0bcf9cc7eaaf131dce1a8c3f470d3" translate="yes" xml:space="preserve">
          <source>A strict variant of foldr1</source>
          <target state="translated">foldr1의 엄격한 변형</target>
        </trans-unit>
        <trans-unit id="37c2878fde673453465a3e32200c82b9e97c2b4d" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전</target>
        </trans-unit>
        <trans-unit id="00787a530c1e072ddb6f8e17b643611bd5348b98" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 .</target>
        </trans-unit>
        <trans-unit id="00a8b3473a1ebcbcb0938b14d80dd5227345445f" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전</target>
        </trans-unit>
        <trans-unit id="d8c8ab54cce45db26e6dab71f39c06ea62ab7980" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">엄격한 버전의 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5320390dc6f10cc24227a72c79ba582ebcc655a1" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 .</target>
        </trans-unit>
        <trans-unit id="493154631c22520a575e67380475a32d6bd2b085" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전</target>
        </trans-unit>
        <trans-unit id="3fbcaceb0158cacd282ec70be5aab020df060aca" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">엄격한 버전의 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb8a26929f2fded3b180d5708141aba0e7729a4d" translate="yes" xml:space="preserve">
          <source>A strict version of foldl.</source>
          <target state="translated">foldl의 엄격한 버전.</target>
        </trans-unit>
        <trans-unit id="38c487e511f9d1d69315932a619005a1ef13ecae" translate="yes" xml:space="preserve">
          <source>A strict version of foldl1.</source>
          <target state="translated">foldl1의 엄격한 버전.</target>
        </trans-unit>
        <trans-unit id="3a7a0698bbaa3cecd2768e6bf682a107a5760347" translate="yes" xml:space="preserve">
          <source>A string &lt;code&gt;x&lt;/code&gt; is a caseless match for a string &lt;code&gt;y&lt;/code&gt; if and only if:</source>
          <target state="translated">다음 과 같은 경우에만 문자열 &lt;code&gt;x&lt;/code&gt; 는 문자열 &lt;code&gt;y&lt;/code&gt; 에 대해 대소 문자가 일치 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a89823ddb2e0acf1e32d6f1968848a1d41921ad" translate="yes" xml:space="preserve">
          <source>A string can be thrown as an error.</source>
          <target state="translated">문자열은 오류로 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6ae9c82c7d68fe5d1dffcf904a8de12b9166247" translate="yes" xml:space="preserve">
          <source>A string describing the source span enclosing the cost-centre.</source>
          <target state="translated">비용 센터를 포함하는 소스 범위를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1236c4b5dbb424adbd898df93abf13e38ab1cf45" translate="yes" xml:space="preserve">
          <source>A string to pass on standard input to the forked process.</source>
          <target state="translated">분기 된 프로세스에 표준 입력을 전달할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="624066030a645e943a5b155270eb593c7b3b17d0" translate="yes" xml:space="preserve">
          <source>A string with explicit length information in bytes instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">종료 NUL (문자열 중간에 NUL 문자 허용) 대신 명시 적 길이 정보를 바이트 단위로 갖는 문자열.</target>
        </trans-unit>
        <trans-unit id="2356ccf00398e74e586e317a2fe01305d7bf8c72" translate="yes" xml:space="preserve">
          <source>A superclass context for a class &lt;code&gt;C&lt;/code&gt; is allowed if, after expanding type synonyms to their right-hand-sides, and uses of classes (other than &lt;code&gt;C&lt;/code&gt;) to their superclasses, &lt;code&gt;C&lt;/code&gt; does not occur syntactically in the context.</source>
          <target state="translated">클래스에 대한 슈퍼 클래스 컨텍스트 &lt;code&gt;C&lt;/code&gt; 는 자신의 오른쪽 손으로 측면 타입 동의어를 확장 한 후, 경우에 허용하고 (이외의 클래스의 사용 &lt;code&gt;C&lt;/code&gt; 수퍼 클래스로는), &lt;code&gt;C&lt;/code&gt; 는 맥락에서 구문 적으로 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8df258a3806dcb111bd7b1772adfed8e5b1b40a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;, but as a function instead of an operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 의 동의어 이지만 연산자 대신 함수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b99600f4f94d4a88ef68809095d330e12de5939a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;hPut&lt;/code&gt;, for compatibility</source>
          <target state="translated">호환성을 위한 &lt;code&gt;hPut&lt;/code&gt; 의 동의어</target>
        </trans-unit>
        <trans-unit id="f7bdd4682beedebc0801ab80535b56959469b2ec" translate="yes" xml:space="preserve">
          <source>A system-dependent mode. This is also the default mode. On Unix ELF systems this embeds &lt;code id=&quot;index-1&quot;&gt;RPATH&lt;/code&gt;/&lt;code id=&quot;index-2&quot;&gt;RUNPATH&lt;/code&gt; entries into the shared library or executable. In particular it uses absolute paths to where the shared libraries for the rts and each package can be found. This means the program can immediately be run and it will be able to find the libraries it needs. However it may not be suitable for deployment if the libraries are installed in a different location on another machine.</source>
          <target state="translated">시스템 종속 모드. 이것은 또한 기본 모드입니다. Unix ELF 시스템에서는 &lt;code id=&quot;index-1&quot;&gt;RPATH&lt;/code&gt; / &lt;code id=&quot;index-2&quot;&gt;RUNPATH&lt;/code&gt; 항목을 공유 라이브러리 또는 실행 파일에 포함시킵니다. 특히 rts 및 각 패키지의 공유 라이브러리를 찾을 수있는 절대 경로를 사용합니다. 즉, 프로그램을 즉시 실행할 수 있으며 필요한 라이브러리를 찾을 수 있습니다. 그러나 라이브러리가 다른 시스템의 다른 위치에 설치된 경우 배치에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e155fb42dd454dac03073c4506c36df94ce050b3" translate="yes" xml:space="preserve">
          <source>A table of the count of edges from each node.</source>
          <target state="translated">각 노드의 간선 개수 테이블.</target>
        </trans-unit>
        <trans-unit id="e0214aac47583666947c6b02d5dbd5d0f74c69cb" translate="yes" xml:space="preserve">
          <source>A table of the count of edges into each node.</source>
          <target state="translated">각 노드의 가장자리 수 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="9e56547706c1d22e7563bc02015e6d5ea9059fce" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 두 맵에있는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="c5b40ab4ad40ca71821f774d179180ff9dbb3299" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 맵에 존재하는 키를 처리하기위한 전술 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68563c20275c3937fe80971256761864f36ba257" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 두 맵에있는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="d861ca0e3d900bc21406b6b1807bc2b2cf18dc29" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 맵에 존재하는 키를 처리하기위한 전술 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae51b27a95cdff285456cfd64fc7198ed349ffd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 두 맵에있는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="0f49a606d06085ba26fc41ac70ef7f11a81b40cb" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 맵에 존재하는 키를 처리하기위한 전술 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f35d2589fef4b7d60b15566c52bfd61bb4b033fd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 두 맵에있는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="35605a33cfca77541ce0f7a28d4adaaa7f211e60" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 맵에 존재하는 키를 처리하기위한 전술 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22ba35b272e3222b9000490c23cd7a38c265aa2c" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나의 맵에는 있지만 다른 하나의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="724f196ee83cb8f7d04ef2bfd02c2a5fc6e8942c" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 맵에는 있지만 다른 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="68f6f41d93467c8eca9791eed5e9e6b94541a4bf" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나의 맵에는 있지만 다른 하나의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="3768165dc6a607a11a4e4e49c5b342c117fa0f2f" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 맵에는 있지만 다른 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="9c0f20d68941a262026f0633a3098ddef91196da" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나의 맵에는 있지만 다른 하나의 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="e901e7cd9f4ef00918e6cc4628a80d9109d39ab6" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 맵에는 있지만 다른 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="d93c5772a7eda6b6b5cb9d8ee695cda722b263bd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나의 맵에는 있지만 다른 하나의 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="e438d5b20c4d0ae49dae9e96e6eb2bd92c80240d" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 맵에는 있지만 다른 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="c03aaf5092b4ace221cdda40d0db350523640c20" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; SimpleWhenMatched k x y z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; SimpleWhenMatched k x y z &lt;/code&gt; 유형의 전술은 &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z &lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a13beca0501a32224295f634b47d23e06f1ddb66" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; SimpleWhenMissing k x z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; Maybe z &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; SimpleWhenMissing k x z &lt;/code&gt; 유형의 전술은 &lt;code&gt; k -&amp;gt; x -&amp;gt; Maybe z &lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8ba8a10e8973c7adb58835a435c234b5058a0a41" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; WhenMatched f k x y z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z) &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; WhenMatched f k x y z &lt;/code&gt; 유형의 전술은 &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z) &lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e2a9c18a71365b1b648cf16681fd8c36a0f1c2b1" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; WhenMissing f k x z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; f (Maybe z) &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; WhenMissing f k x z &lt;/code&gt; 유형의 전술은 &lt;code&gt; k -&amp;gt; x -&amp;gt; f (Maybe z) &lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fa71c38b94fc6a846cbe5d938f6e3e23141ac8bc" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;SimpleWhenMatched x y z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SimpleWhenMatched x y z&lt;/code&gt; 유형의 전술은 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z&lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4e05a0a550e141ac884df50db0a9d4c7b208813b" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;SimpleWhenMissing x z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; Maybe z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SimpleWhenMissing x z&lt;/code&gt; 유형의 전술은 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; Maybe z&lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="788c7aaeca2fa9237bef6f30f44eda24345655ff" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;WhenMatched f x y z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WhenMatched f x y z&lt;/code&gt; 유형의 전술은 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8d8ff0b141b2eb58a8bb144bfb707f725b7e036c" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;WhenMissing f k x z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WhenMissing f k x z&lt;/code&gt; 유형의 전술은 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe z)&lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ac94aa09dce6e03f7dc40cf67060871ccd2030ef" translate="yes" xml:space="preserve">
          <source>A text format for a type</source>
          <target state="translated">유형의 텍스트 형식</target>
        </trans-unit>
        <trans-unit id="5d64a70b084ed3d99633afca034baca94024378e" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; that specifies how to transate newline characters. The &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; specifies the input and output translation separately, so that for instance you can translate &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; on input, but leave newlines as &lt;code&gt;'\n'&lt;/code&gt; on output.</source>
          <target state="translated">텍스트 모드 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에는 줄 바꿈 문자를 변환하는 방법을 지정하는 관련 &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; 가 있습니다. &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; 는 예를 들어 당신이 번역 할 수 그래서, 별도로 입력 및 출력 변환을 지정하는 &lt;code&gt;'\r\n'&lt;/code&gt; 에 &lt;code&gt;'\n'&lt;/code&gt; 입력에,하지만 같은 휴가 개행 문자 &lt;code&gt;'\n'&lt;/code&gt; 출력.</target>
        </trans-unit>
        <trans-unit id="6df45c2152a1885d718710f3f4c32cb1ceb8d125" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; that specifies how to translate newline characters. The &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; specifies the input and output translation separately, so that for instance you can translate &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; on input, but leave newlines as &lt;code&gt;'\n'&lt;/code&gt; on output.</source>
          <target state="translated">텍스트 모드 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에는 개행 문자를 변환하는 방법을 지정하는 연관된 &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; 가 있습니다. &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; 는 예를 들어 당신이 번역 할 수 그래서, 별도로 입력 및 출력 변환을 지정하는 &lt;code&gt;'\r\n'&lt;/code&gt; 에 &lt;code&gt;'\n'&lt;/code&gt; 입력에,하지만 같은 휴가 개행 문자 &lt;code&gt;'\n'&lt;/code&gt; 출력.</target>
        </trans-unit>
        <trans-unit id="e920ef23a8f0e5c9a461f6e5c3a3ecaedd1aa8f0" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;, which is used to decode bytes into Unicode characters when reading, and encode Unicode characters into bytes when writing.</source>
          <target state="translated">텍스트 모드 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에는 연관된 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 이 있으며 , 이는 읽을 때 바이트를 유니 코드 문자로 디코딩하고 쓰는 경우 유니 코드 문자를 바이트로 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afd27d79af07b06b6dd2c8c51dd15b84360a87c3" translate="yes" xml:space="preserve">
          <source>A thread has been created to perform spark evaluation.</source>
          <target state="translated">스파크 평가를 수행하기 위해 스레드가 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="513f9205785871fd0e6a34a5a8b00e27eaabc144" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of Unicode text using lists of packed arrays.</source>
          <target state="translated">묶음 배열 목록을 사용하여 시간과 공간 효율적으로 유니 코드 텍스트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="871d33c09316ac87a1774045ce6be43e65d6fbbd" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of Unicode text. Suitable for performance critical use, both in terms of large data quantities and high speed.</source>
          <target state="translated">시간과 공간 효율적으로 유니 코드 텍스트를 구현합니다. 대량의 데이터 및 고속 측면에서 성능이 중요한 용도에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="cb913ed9248b4b73bbb05825979d544eb2127ebb" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="translated">대량의 데이터 양 또는 고속 요구 사항 측면에서 고성능 사용에 적합한 압축 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 배열 목록을 사용하여 시간 및 공간 효율적인 지연 바이트 벡터 구현 . Lazy ByteStrings는 엄격한 바이트 청크의 지연 목록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="87548884e6950ce7611c58d0e6aa6d111ae018da" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="translated">대용량 데이터 또는 고속 요구 사항 측면에서 고성능 사용에 적합한 압축 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 배열 목록을 사용하여 지연 바이트 벡터를 시간 및 공간 효율적으로 구현 합니다. Lazy ByteStrings는 엄격한 바이트 청크의 lazy 목록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="24b2d7b93ba4c008451c53fe10e4e7754f0b4315" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="translated">대용량 데이터 양 또는 고속 요구 사항 측면에서 고성능 사용에 적합한 압축 된 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 배열 목록을 사용하여 지연 바이트 벡터를 시간 및 공간 효율적으로 구현 합니다. Lazy ByteStrings는 엄격한 바이트 청크의 lazy 목록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="a51040e6bbff0d1db2681967125dbcf0660a785a" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="translated">대량의 데이터 양과 고속 요구 사항 모두에서 고성능 사용에 적합한 팩형 Word8 배열을 사용하여 시간 및 공간 효율적으로 바이트 벡터를 구현합니다. 바이트 벡터는 엄격한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 바이트 배열 로 인코딩되어 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 로 유지 되며 C와 Haskell간에 약간의 노력만으로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5048b9a802cb3ce698b367ba1957e1c7c15edd" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="translated">대용량 데이터 양과 고속 요구 사항 모두에서 고성능 사용에 적합한 패킹 된 Word8 배열을 사용하여 바이트 벡터를 시간 및 공간 효율적으로 구현합니다. 바이트 벡터는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 보관 된 엄격한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 바이트 배열 로 인코딩되며 , 적은 노력으로 C와 Haskell간에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96fe69d98b9d3411409ef49b51f90af2280d646b" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="translated">대용량 데이터 양과 고속 요구 사항 모두에서 고성능 사용에 적합한 패킹 된 Word8 배열을 사용하여 바이트 벡터를 시간 및 공간 효율적으로 구현합니다. 바이트 벡터는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 보관 된 엄격한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 바이트 배열 로 인코딩되며 , 적은 노력으로 C와 Haskell간에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe6c6fa0b66fdbc97157d1012689fd665f63f77" translate="yes" xml:space="preserve">
          <source>A timeout registration cookie.</source>
          <target state="translated">타임 아웃 등록 쿠키.</target>
        </trans-unit>
        <trans-unit id="9e5d778e506d2310054d3157a8637a07f1af1107" translate="yes" xml:space="preserve">
          <source>A top-level declaration</source>
          <target state="translated">최상위 선언</target>
        </trans-unit>
        <trans-unit id="c0a632faf1705f0bf1b050442c8d1e64943fd4fa" translate="yes" xml:space="preserve">
          <source>A top-level splice can occur in place of</source>
          <target state="translated">대신 최상위 스플 라이스가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de62f1896f9b461fde0d7a734c551759e77767fa" translate="yes" xml:space="preserve">
          <source>A top-level typed expression splice can occur in place of an expression; the spliced expression must have type &lt;code&gt;Code Q a&lt;/code&gt;</source>
          <target state="translated">표현식 대신 최상위 유형 표현식 스플 라이스가 발생할 수 있습니다. 스 플라이 싱 된 표현식은 유형 &lt;code&gt;Code Q a&lt;/code&gt; 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="c16187723ff5e241fc07ce9bf83e42940dac6da5" translate="yes" xml:space="preserve">
          <source>A topological sort of the graph. The order is partially specified by the condition that a vertex &lt;em&gt;i&lt;/em&gt; precedes &lt;em&gt;j&lt;/em&gt; whenever &lt;em&gt;j&lt;/em&gt; is reachable from &lt;em&gt;i&lt;/em&gt; but not vice versa.</source>
          <target state="translated">토폴로지 종류의 그래프. 순서는 부분적 정점한다는 조건에 의해 지정된 &lt;em&gt;나&lt;/em&gt; 선행 &lt;em&gt;J을&lt;/em&gt; 마다 &lt;em&gt;J는&lt;/em&gt; 로부터 도달 &lt;em&gt;I&lt;/em&gt; 반대로 아니지만.</target>
        </trans-unit>
        <trans-unit id="4693f1c5c0fbb57b8d5c4df19d87586bf13001db" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally (namely throwing the computation the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; exception). The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">까다로운 구현 세부 사항은 &lt;code&gt;IO&lt;/code&gt; 계산 을 중단하는 방법에 대한 질문입니다 . 이 결합자는 내부적으로 비동기 예외에 의존합니다 (즉, 계산에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; 예외 발생). 이 기술은 Haskell 런타임 시스템 내부에서 실행되는 계산에 매우 잘 작동하지만 Haskell이 아닌 코드에서는 전혀 작동하지 않습니다. 예를 들어, 임의의 C 함수가 비동기 예외를 수신 할 수 없기 때문에 외부 함수 호출은이 결합 자로 시간 초과 될 수 없습니다. 때 &lt;code&gt;timeout&lt;/code&gt; 차단하는 FFI 호출을 래핑하는 데 사용되며 FFI 호출이 반환 될 때까지 시간 초과 이벤트가 전달 될 수 없으므로 결합 자의 목적이 거의 무효화됩니다. 그러나 실제로이 제한은 생각할 수있는 것보다 덜 심각합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; , Network.Socket.accept 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 과 같은 표준 I / O 함수 가 차단되는 것처럼 보이지만 실제로는 런타임 시스템이 &lt;code&gt;select(2)&lt;/code&gt; 와 같은 스케줄링 메커니즘을 사용 하여 비동기 I / O를 수행 하기 때문에 그렇지 않습니다. 이 결합기를 사용하여 표준 소켓 I / O 또는 파일 I / O를 인터럽트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c3b0573aefd9efe2af69d52343a0a530da53a04" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally (namely throwing the computation the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; exception). The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">까다로운 구현 세부 사항은 &lt;code&gt;IO&lt;/code&gt; 계산 을 중단하는 방법에 대한 질문입니다 . 이 결합자는 내부적으로 비동기 예외에 의존합니다 (즉, 계산에서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; 예외 발생). 이 기술은 Haskell 런타임 시스템 내부에서 실행되는 계산에 매우 잘 작동하지만 Haskell이 아닌 코드에서는 전혀 작동하지 않습니다. 예를 들어 외부 함수 호출은 임의의 C 함수가 비동기 예외를 수신 할 수 없기 때문에이 결합 자로 시간 초과 될 수 없습니다. 때 &lt;code&gt;timeout&lt;/code&gt; 차단하는 FFI 호출을 래핑하는 데 사용되며 FFI 호출이 반환 될 때까지 시간 초과 이벤트가 전달 될 수 없으므로 결합 자의 목적이 거의 무효화됩니다. 그러나 실제로이 제한은 생각할 수있는 것보다 덜 심각합니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; , Network.Socket.accept 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 과 같은 표준 I / O 함수 가 차단되는 것처럼 보이지만 실제로는 런타임 시스템이 &lt;code&gt;select(2)&lt;/code&gt; 와 같은 스케줄링 메커니즘을 사용 하여 비동기 I / O를 수행 하기 때문에 그렇지 않습니다. 이 결합기를 사용하여 표준 소켓 I / O 또는 파일 I / O를 인터럽트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa67008717fa4c4a4a1edf551b1dac2041a4d8c1" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally (namely throwing the computation the &lt;code&gt;&lt;a href=&quot;system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; exception). The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">까다로운 구현 세부 사항은 &lt;code&gt;IO&lt;/code&gt; 계산 을 중단하는 방법에 대한 질문입니다 . 이 결합자는 내부적으로 비동기 예외에 의존합니다 (즉, 계산에서 &lt;code&gt;&lt;a href=&quot;system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; 예외 발생). 이 기술은 Haskell 런타임 시스템 내부에서 실행되는 계산에 매우 잘 작동하지만 Haskell이 아닌 코드에서는 전혀 작동하지 않습니다. 예를 들어 외부 함수 호출은 임의의 C 함수가 비동기 예외를 수신 할 수 없기 때문에이 결합 자로 시간 초과 될 수 없습니다. 때 &lt;code&gt;timeout&lt;/code&gt; 차단하는 FFI 호출을 래핑하는 데 사용되며 FFI 호출이 반환 될 때까지 시간 초과 이벤트가 전달 될 수 없으므로 결합 자의 목적이 거의 무효화됩니다. 그러나 실제로이 제한은 생각할 수있는 것보다 덜 심각합니다. &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; , Network.Socket.accept 또는 &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 과 같은 표준 I / O 함수 가 차단되는 것처럼 보이지만 실제로는 런타임 시스템이 &lt;code&gt;select(2)&lt;/code&gt; 와 같은 스케줄링 메커니즘을 사용 하여 비동기 I / O를 수행 하기 때문에 그렇지 않습니다. 이 결합기를 사용하여 표준 소켓 I / O 또는 파일 I / O를 인터럽트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6efe802c821d7daf17899a761feb1bf7a82692b9" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">까다로운 구현 세부 사항은 &lt;code&gt;IO&lt;/code&gt; 계산 을 중단하는 방법에 대한 문제입니다 . 이 결합기는 내부적으로 비동기 예외에 의존합니다. 이 기술은 Haskell 런타임 시스템 내에서 실행되는 계산에는 매우 효과적이지만 Haskell이 아닌 코드에는 전혀 작동하지 않습니다. 예를 들어, 임의의 C 함수가 비동기 예외를 수신 할 수 없기 때문에이 결합기로 외부 함수 호출을 시간 종료 할 수 없습니다. 때 &lt;code&gt;timeout&lt;/code&gt; 블록, 제한 시간 이벤트가 거의 콤비의 목적을 부정 FFI 호출이 반환까지 전달되지 수 있다는 FFI 호출을 래핑하는 데 사용됩니다. 그러나 실제로이 제한은 소리보다 덜 심각합니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; 와 같은 표준 I / O 기능, Network.Socket.accept 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 이 차단 된 것으로 보이지만 런타임 시스템은 &lt;code&gt;select(2)&lt;/code&gt; 와 같은 스케줄링 메커니즘을 사용 하여 비동기 I / O를 수행하므로 표준 소켓 I / O를 중단 할 수 있기 때문에 실제로는 그렇지 않습니다 또는이 결합기를 사용하는 파일 I / O.</target>
        </trans-unit>
        <trans-unit id="41f5a544b2c86e8b88cd4fa644eb1707b05f6a06" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">까다로운 구현 세부 사항은 &lt;code&gt;IO&lt;/code&gt; 계산 을 중단하는 방법에 대한 문제입니다 . 이 결합기는 내부적으로 비동기 예외에 의존합니다. 이 기술은 Haskell 런타임 시스템 내에서 실행되는 계산에는 매우 효과적이지만 Haskell이 아닌 코드에는 전혀 작동하지 않습니다. 예를 들어, 임의의 C 함수가 비동기 예외를 수신 할 수 없기 때문에이 결합기로 외부 함수 호출을 시간 종료 할 수 없습니다. 때 &lt;code&gt;timeout&lt;/code&gt; 블록, 제한 시간 이벤트가 거의 콤비의 목적을 부정 FFI 호출이 반환까지 전달되지 수 있다는 FFI 호출을 래핑하는 데 사용됩니다. 그러나 실제로이 제한은 소리보다 덜 심각합니다. &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; 와 같은 표준 I / O 기능, Network.Socket.accept 또는 &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 이 차단 된 것으로 보이지만 런타임 시스템은 &lt;code&gt;select(2)&lt;/code&gt; 와 같은 스케줄링 메커니즘을 사용 하여 비동기 I / O를 수행하므로 표준 소켓 I / O를 중단 할 수 있기 때문에 실제로는 그렇지 않습니다 또는이 결합기를 사용하는 파일 I / O.</target>
        </trans-unit>
        <trans-unit id="966e03642cf0118fe092db70abdc7d1b27e6b71d" translate="yes" xml:space="preserve">
          <source>A type</source>
          <target state="translated">유형</target>
        </trans-unit>
        <trans-unit id="b12eefa8f8a22f3c9c1c70d44c19389c8c5386e5" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; if it provides an associative function (&lt;code&gt;&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;) that lets you combine any two values of type &lt;code&gt;a&lt;/code&gt; into one, and a neutral element (&lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;) such that</source>
          <target state="translated">A 형 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 가 연관 기능을 제공하는 경우 ( &lt;code&gt;&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; )가 어떤 유형의 두 값을 결합 할 것을 &lt;code&gt;a&lt;/code&gt; 하나로하고, 중립 요소 ( &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 해당) 등</target>
        </trans-unit>
        <trans-unit id="900bea671831ed1ce8158cdebd74c597c210974a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; if it provides an associative function (&lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;) that lets you combine any two values of type &lt;code&gt;a&lt;/code&gt; into one. Where being associative means that the following must always hold:</source>
          <target state="translated">A 형 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 이 연관 기능을 제공하는 경우 ( &lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; )는 타입의 두 값을 결합 할 수 있습니다 그 &lt;code&gt;a&lt;/code&gt; 하나에. 연관성이 있다는 것은 다음을 항상 유지해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c36da43acccbf65c4959f463c0fb381ab69f5fb" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;f&lt;/code&gt; is a Functor if it provides a function &lt;code&gt;fmap&lt;/code&gt; which, given any types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; lets you apply any function from &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to turn an &lt;code&gt;f a&lt;/code&gt; into an &lt;code&gt;f b&lt;/code&gt;, preserving the structure of &lt;code&gt;f&lt;/code&gt;. Furthermore &lt;code&gt;f&lt;/code&gt; needs to adhere to the following:</source>
          <target state="translated">A 형 &lt;code&gt;f&lt;/code&gt; 이 기능 제공하면 펑터이다 &lt;code&gt;fmap&lt;/code&gt; 함수 어떤 종류 주어진 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 는 사용자가 어떠한 기능을 적용 할 수 &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; 설정하는 &lt;code&gt;f a&lt;/code&gt; 에 &lt;code&gt;f b&lt;/code&gt; 의 구조 보존 &lt;code&gt;f&lt;/code&gt; . 또한 &lt;code&gt;f&lt;/code&gt; 는 다음을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8dc677defa7be455d6125e7b6e0f1fcd1c4b205" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;f&lt;/code&gt; is a Functor if it provides a function &lt;code&gt;fmap&lt;/code&gt; which, given any types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, lets you apply any function of type &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to turn an &lt;code&gt;f a&lt;/code&gt; into an &lt;code&gt;f b&lt;/code&gt;, preserving the structure of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">A 형 &lt;code&gt;f&lt;/code&gt; 이 기능 제공하면 펑터이다 &lt;code&gt;fmap&lt;/code&gt; 함수 어떤 유형에게 주어진 및 &lt;code&gt;b&lt;/code&gt; 사용하면 유형의 기능을 적용 할 수, &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; 설정하는 &lt;code&gt;f a&lt;/code&gt; 에 &lt;code&gt;f b&lt;/code&gt; 의 구조 보존 &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5b73b56591ee75fd4320cdb138584a6631c70e7" translate="yes" xml:space="preserve">
          <source>A type application.</source>
          <target state="translated">타입 어플리케이션.</target>
        </trans-unit>
        <trans-unit id="4843d11f8e6edd0b1d5c045f927fdb0d7d055f98" translate="yes" xml:space="preserve">
          <source>A type constructor or class can be any non-reserved operator. Symbols used in types are always like capitalized identifiers; they are never variables. Note that this is different from the lexical syntax of data constructors, which are required to begin with a &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">유형 생성자 또는 클래스는 예약되지 않은 연산자 일 수 있습니다. 유형에 사용 된 기호는 항상 대문자 식별자와 같습니다. 그들은 결코 변수가 아닙니다. 이것은 데이터 생성자의 어휘 구문과 다르며, &lt;code&gt;:&lt;/code&gt; 은 : 로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2957975b2e2a0d72a85cca6ba60d8dc7b412130f" translate="yes" xml:space="preserve">
          <source>A type context can include equality constraints of the form &lt;code&gt;t1 ~ t2&lt;/code&gt;, which denote that the types &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; need to be the same. In the presence of type families, whether two types are equal cannot generally be decided locally. Hence, the contexts of function signatures may include equality constraints, as in the following example:</source>
          <target state="translated">타입 컨텍스트는 &lt;code&gt;t1 ~ t2&lt;/code&gt; 형식의 등식 제약 조건을 포함 할 수 있으며 , 이는 타입 &lt;code&gt;t1&lt;/code&gt; 과 &lt;code&gt;t2&lt;/code&gt; 가 동일해야 함을 나타냅니다 . 유형 패밀리가 존재하는 경우 일반적으로 두 유형이 동일한 지 여부를 로컬에서 결정할 수 없습니다. 따라서 함수 시그니처의 컨텍스트에는 다음 예와 같이 등식 제한 조건이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb43eef001aa96d23cb8f2b1045baf5a1fc027f" translate="yes" xml:space="preserve">
          <source>A type family can also be declared with a &lt;code&gt;where&lt;/code&gt; clause, defining the full set of equations for that family. For example:</source>
          <target state="translated">유형 패밀리는 &lt;code&gt;where&lt;/code&gt; 절로 선언하여 해당 패밀리에 대한 전체 방정식 세트를 정의 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ca042aa66fa2759abc533fbf4e600be254b35ae" translate="yes" xml:space="preserve">
          <source>A type family to compute Boolean equality.</source>
          <target state="translated">부울 동등성을 계산하기위한 유형 군입니다.</target>
        </trans-unit>
        <trans-unit id="8eff1fa8083a3c76f23688ec0faf2770e8f9b619" translate="yes" xml:space="preserve">
          <source>A type is &amp;ldquo;rigid&amp;rdquo; if it is completely known to the compiler at its binding site. The easiest way to ensure that a variable a rigid type is to give it a type signature. For more precise details see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/papers/gadt/&quot;&gt;Simple unification-based type inference for GADTs&lt;/a&gt;. The criteria implemented by GHC are given in the Appendix.</source>
          <target state="translated">바인딩 사이트의 컴파일러에 완전히 알려진 유형은 &quot;견고한&quot;유형입니다. 변수에 엄격한 유형을 지정하는 가장 쉬운 방법은 유형 서명을 제공하는 것입니다. 보다 정확한 세부 사항은 &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/papers/gadt/&quot;&gt;GADT에 대한 단순 통합 기반 유형 유추를&lt;/a&gt; 참조하십시오 . GHC에 의해 구현 된 기준은 부록에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b6dc84a99a51911e396803e6f137d1ec9e7ecb5" translate="yes" xml:space="preserve">
          <source>A type or data family, with a list of its visible instances. A closed type family is returned with 0 instances.</source>
          <target state="translated">보이는 인스턴스 목록이있는 유형 또는 데이터 패밀리. 닫힌 유형 패밀리는 0 개의 인스턴스와 함께 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0a858ee617d52cf82c99429cf69589bf7daf3b44" translate="yes" xml:space="preserve">
          <source>A type or kind variable explicitly bound using &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; but not used on the left hand side will generate an error, not a warning.</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 을&lt;/a&gt; 사용하여 명시 적 으로 바인딩 되었지만 왼쪽에 사용되지 않은 유형 또는 종류 변수 는 경고가 아니라 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="000d83df44a22517780a9f759c41e9e35406572a" translate="yes" xml:space="preserve">
          <source>A type or kind variable explicitly bound using &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; but not used on the left hand side will generate an error, not a warning.</source>
          <target state="translated">&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 을&lt;/a&gt; 사용하여 명시 적 으로 바인딩 되었지만 왼쪽에서 사용되지 않는 유형 또는 종류 변수 는 경고가 아닌 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="13dc503b524051e73bf1854416495a7c476690ef" translate="yes" xml:space="preserve">
          <source>A type representing a number of UTF-16 code units.</source>
          <target state="translated">많은 UTF-16 코드 단위를 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fac7b1b31387a5dce83f6207988f33acc423d8c4" translate="yes" xml:space="preserve">
          <source>A type signature may occur in any pattern; this is a &lt;em&gt;pattern type signature&lt;/em&gt;. For example:</source>
          <target state="translated">형식 서명은 어떤 패턴으로도 발생할 수 있습니다. 이것은 &lt;em&gt;패턴 유형 서명&lt;/em&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8682a8a15f37e1952f2bed70e4a76505ad01ea0d" translate="yes" xml:space="preserve">
          <source>A type variable applied to some types:</source>
          <target state="translated">일부 유형에 적용되는 유형 변수 :</target>
        </trans-unit>
        <trans-unit id="9bfcbaf65cc2630df1737c174af7d766948febae" translate="yes" xml:space="preserve">
          <source>A type variable beginning with an underscore is not treated specially in a type or data instance declaration. For example:</source>
          <target state="translated">밑줄로 시작하는 유형 변수는 유형 또는 데이터 인스턴스 선언에서 특별히 처리되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ca958f1089d3d1582d1c30aba329c8223832dd9" translate="yes" xml:space="preserve">
          <source>A type variable.</source>
          <target state="translated">타입 변수.</target>
        </trans-unit>
        <trans-unit id="297b034e775e243ef7a125f9be96bd9336678f08" translate="yes" xml:space="preserve">
          <source>A typed expression splice can occur in place of an expression; the spliced expression must have type &lt;code&gt;Q (TExp a)&lt;/code&gt;</source>
          <target state="translated">식 대신에 형식화 된 식 스플 라이스가 발생할 수 있습니다. 스 플라이 싱 된 표현식은 유형 &lt;code&gt;Q (TExp a)&lt;/code&gt; 를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="fff5bdf005b35f179294ba275419d126af32c8a0" translate="yes" xml:space="preserve">
          <source>A typical heap object may be in one of the following four states at each point in its lifetime:</source>
          <target state="translated">일반적인 힙 객체는 수명의 각 시점에서 다음 4 가지 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e00c4c8e7f8a62193a99b6e6434c24bc66d1ce8" translate="yes" xml:space="preserve">
          <source>A typical use is to prevent resource leaks in lazy IO programs, by forcing all characters from a file to be read. For example:</source>
          <target state="translated">일반적으로 파일의 모든 문자를 읽도록하여 지연 IO 프로그램에서 리소스 누수를 방지합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb52c77586fd9d5d1d5e06c0781fa29b45252709" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;&lt;a href=&quot;control-exception#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; for recovery looks like this:</source>
          <target state="translated">복구 에 &lt;code&gt;&lt;a href=&quot;control-exception#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; 를 사용하는 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5fa8bc47ca59ba407ee77bfa4f457f11af6f63d" translate="yes" xml:space="preserve">
          <source>A unique &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; object Used when the strings are dynamically allocated, eg from binary deserialisation</source>
          <target state="translated">고유 한 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 객체 문자열이 동적으로 할당 될 때 사용됩니다 (예 : 이진 역 직렬화)</target>
        </trans-unit>
        <trans-unit id="6e0b23e86250bf5ded8e24685820d0cba5c52892" translate="yes" xml:space="preserve">
          <source>A unique identifier used to refer to the cost-centre</source>
          <target state="translated">비용 중심을 나타내는 데 사용되는 고유 식별자</target>
        </trans-unit>
        <trans-unit id="e2b058205e0073a16e899cb4a51295d96e6d2af1" translate="yes" xml:space="preserve">
          <source>A unique local name</source>
          <target state="translated">고유 한 현지 이름</target>
        </trans-unit>
        <trans-unit id="1f67274a4c72a292a8769f67401cc21d34e5f22d" translate="yes" xml:space="preserve">
          <source>A use of &lt;code&gt;MkSet&lt;/code&gt; as a constructor (e.g. in the definition of &lt;code&gt;makeSet&lt;/code&gt;) gives rise to a &lt;code&gt;(Eq a)&lt;/code&gt; constraint, as you would expect. The new feature is that pattern-matching on &lt;code&gt;MkSet&lt;/code&gt; (as in the definition of &lt;code&gt;insert&lt;/code&gt;) makes &lt;em&gt;available&lt;/em&gt; an &lt;code&gt;(Eq a)&lt;/code&gt; context. In implementation terms, the &lt;code&gt;MkSet&lt;/code&gt; constructor has a hidden field that stores the &lt;code&gt;(Eq a)&lt;/code&gt; dictionary that is passed to &lt;code&gt;MkSet&lt;/code&gt;; so when pattern-matching that dictionary becomes available for the right-hand side of the match. In the example, the equality dictionary is used to satisfy the equality constraint generated by the call to &lt;code&gt;elem&lt;/code&gt;, so that the type of &lt;code&gt;insert&lt;/code&gt; itself has no &lt;code&gt;Eq&lt;/code&gt; constraint.</source>
          <target state="translated">의 사용 &lt;code&gt;MkSet&lt;/code&gt; (의 정의에 예를 들어 생성자로 &lt;code&gt;makeSet&lt;/code&gt; 은 )는에 상승 제공 &lt;code&gt;(Eq a)&lt;/code&gt; 당신이 기대하는 것처럼, 제약. 새로운 기능은 &lt;code&gt;MkSet&lt;/code&gt; 의 패턴 일치 ( &lt;code&gt;insert&lt;/code&gt; 정의에서와 같이 )가 &lt;code&gt;(Eq a)&lt;/code&gt; 컨텍스트를 &lt;em&gt;사용할 수 있다는&lt;/em&gt; 것 입니다. 구현 용어로 &lt;code&gt;MkSet&lt;/code&gt; 생성자는 &lt;code&gt;MkSet&lt;/code&gt; 에 전달 된 &lt;code&gt;(Eq a)&lt;/code&gt; 사전을 저장하는 숨겨진 필드 를 갖습니다 . 따라서 패턴 일치시 해당 사전이 일치하는 오른쪽에 사용 가능해집니다. 이 예에서, 동등 사전은 다음에 대한 호출에 의해 생성 된 동등 제한 조건을 만족시키는 데 사용됩니다. &lt;code&gt;elem&lt;/code&gt; &lt;code&gt;insert&lt;/code&gt; 자체 의 유형에 &lt;code&gt;Eq&lt;/code&gt; 제한 조건 이 없도록 elem .</target>
        </trans-unit>
        <trans-unit id="c1353efcd4777e1aa99c83066c3c4fd8238bee7d" translate="yes" xml:space="preserve">
          <source>A useful &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;-like function for debugging purposes.</source>
          <target state="translated">디버깅 목적으로 유용한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; - like 함수입니다.</target>
        </trans-unit>
        <trans-unit id="90246cdcbf9692185ad9ba6a865f4e67d7ff859b" translate="yes" xml:space="preserve">
          <source>A useful &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;-like function for debugging purposes.</source>
          <target state="translated">디버깅 목적으로 유용한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 와 유사한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="70dab16ccb3b6a703ee5b204fc51c139f8aea1e3" translate="yes" xml:space="preserve">
          <source>A useful &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;-like function for debugging purposes.</source>
          <target state="translated">디버깅 목적으로 유용한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 와 유사한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="782053667e2306e8cf3e91531fa691fe2c43fa11" translate="yes" xml:space="preserve">
          <source>A useful combinator for embedding monadic actions into &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt;&lt;code&gt;
 myCode :: ... =&amp;gt; Code m a
 myCode = joinCode $ do
   x &amp;lt;- someSideEffect
   return (makeCodeWith x)
 &lt;/code&gt;</source>
          <target state="translated">모나드 액션을 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; &lt;code&gt; myCode :: ... =&amp;gt; Code m a myCode = joinCode $ do x &amp;lt;- someSideEffect return (makeCodeWith x) &lt;/code&gt; 에 삽입하는 데 유용한 조합기</target>
        </trans-unit>
        <trans-unit id="d824bcabbe540d6f8669abe4aa80a8124bcecbd4" translate="yes" xml:space="preserve">
          <source>A useful combinator for embedding monadic actions into &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt;&lt;code&gt;
 myCode :: ... =&amp;gt; Code m a
 myCode = joinCode $ do
   x &amp;lt;- someSideEffect
   return (makeCodeWith x)
 &lt;/code&gt;</source>
          <target state="translated">모나드 액션을 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; &lt;code&gt; myCode :: ... =&amp;gt; Code m a myCode = joinCode $ do x &amp;lt;- someSideEffect return (makeCodeWith x) &lt;/code&gt; 에 삽입하는 데 유용한 조합기</target>
        </trans-unit>
        <trans-unit id="86295d409cfd9cf7cbef34ae7b547dcc96dc0f25" translate="yes" xml:space="preserve">
          <source>A useful default. In particular:</source>
          <target state="translated">유용한 기본값입니다. 특히:</target>
        </trans-unit>
        <trans-unit id="f8c74a72bfde3e2ebcf4f91dbf953debbfc38d10" translate="yes" xml:space="preserve">
          <source>A useful idiom permitted by the above rules is as follows. If one allows overlapping instance declarations then it&amp;rsquo;s quite convenient to have a &amp;ldquo;default instance&amp;rdquo; declaration that applies if something more specific does not:</source>
          <target state="translated">위의 규칙에서 허용되는 유용한 관용구는 다음과 같습니다. 겹치는 인스턴스 선언을 허용하는 경우보다 구체적인 내용이없는 경우 적용되는&amp;ldquo;기본 인스턴스&amp;rdquo;선언을 사용하는 것이 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="a0a8e93d7731f26de07f8a99cabb013a2ca2c78f" translate="yes" xml:space="preserve">
          <source>A useful option to alert you when interfaces change is &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; option. It will run &lt;code&gt;diff&lt;/code&gt; on the changed interface file, before and after, when applicable.</source>
          <target state="translated">인터페이스 변경시 경고하는 유용한 옵션은 &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; 옵션입니다. 적용 가능한 전후에 변경된 인터페이스 파일에서 &lt;code&gt;diff&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="48bece416cc59f93fda6101dbf5899713474b8a5" translate="yes" xml:space="preserve">
          <source>A user could provide, for example, a &lt;code&gt;GSerialize UInt&lt;/code&gt; instance so that a &lt;code&gt;Serialize IntHash&lt;/code&gt; instance could be easily defined in terms of &lt;code&gt;GSerialize&lt;/code&gt;.</source>
          <target state="translated">사용자는 예를 들면, 제공 할 수 &lt;code&gt;GSerialize UInt&lt;/code&gt; 인스턴스가되도록 &lt;code&gt;Serialize IntHash&lt;/code&gt; 인스턴스 용이의 관점에서 정의 될 수 &lt;code&gt;GSerialize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5dd220d0ff116d56be2881c3c2eda319a7be24bc" translate="yes" xml:space="preserve">
          <source>A user log message (from, e.g., &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:traceEvent&quot;&gt;Control.Concurrent.traceEvent&lt;/a&gt;).</source>
          <target state="translated">사용자 로그 메시지 (예 : &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:traceEvent&quot;&gt;Control.Concurrent.traceEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1250342d5626fba6702338245b1266f9d21826be" translate="yes" xml:space="preserve">
          <source>A user log message (from, e.g., &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent#v:traceEvent&quot;&gt;Control.Concurrent.traceEvent&lt;/a&gt;).</source>
          <target state="translated">사용자 로그 메시지 (예 : &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent#v:traceEvent&quot;&gt;Control.Concurrent.traceEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab5483fab05ffacd5a3f560ae7afd7921c21d6c2" translate="yes" xml:space="preserve">
          <source>A user marker (from &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceMarker&quot;&gt;Debug.Trace.traceMarker&lt;/a&gt;).</source>
          <target state="translated">사용자 마커 ( &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceMarker&quot;&gt;Debug.Trace.traceMarker&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="18a25443692419f0097e3d6524d19af87b268dcc" translate="yes" xml:space="preserve">
          <source>A user marker (from &lt;a href=&quot;../libraries/base-4.15.0.0/debug-trace#v:traceMarker&quot;&gt;Debug.Trace.traceMarker&lt;/a&gt;).</source>
          <target state="translated">사용자 마커 ( &lt;a href=&quot;../libraries/base-4.15.0.0/debug-trace#v:traceMarker&quot;&gt;Debug.Trace.traceMarker&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4bf4989d597f060b1f221f4d9b40f8cbdd26cf10" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; is an object encapsulated together with its type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 유형의 값은 해당 유형과 함께 캡슐화 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5e578226b20de3d07741dafad66454d118f3458d" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 외부 코드에서 호출 가능한 함수에 대한 포인터입니다. 유형 &lt;code&gt;a&lt;/code&gt; 는 일반적으로 &lt;em&gt;외부 유형&lt;/em&gt; 이며, 인수가 0 개 이상인 함수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5e81410f386c89f452d754e65a825472786597c7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 다른 외부 함수에 의해 리턴되거나 다음과 같은 정적 주소 가져 오기로 가져온 외부 함수에 대한 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f136bc98f2d8137b486a143123edbe9b3241275" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">입력 값 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 객체에 대한 포인터 나 또는 유형의 하스켈 값으로부터 정렬 화 될 수 객체 배열 나타내고 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd6a3283ff99f274500f801cf1370f639df9d9c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 외부 코드에서 호출 가능한 함수에 대한 포인터입니다. 유형 &lt;code&gt;a&lt;/code&gt; 는 일반적으로 &lt;em&gt;외부 유형&lt;/em&gt; 이며, 인수가 0 개 이상인 함수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="afb41f27d10d971b0c644adebd15549eb369a006" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 다른 외부 함수에 의해 리턴되거나 다음과 같은 정적 주소 가져 오기로 가져온 외부 함수에 대한 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="239d8e1787a28722de24cac0f475ff48393d312a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">입력 값 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 객체에 대한 포인터 나 또는 유형의 하스켈 값으로부터 정렬 화 될 수 객체 배열 나타내고 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65cdd07d411abaf19b949230fd787b91d7248467" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 유형의 값은 수행 될 때 a 유형 &lt;code&gt;a&lt;/code&gt; 값을 리턴하기 전에 일부 I / O를 수행하는 계산입니다 .</target>
        </trans-unit>
        <trans-unit id="a20081f01fcf352f0cfcb6c5a5c6d192ad5b3810" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 외부 코드에서 호출 가능한 함수에 대한 포인터입니다. 유형 &lt;code&gt;a&lt;/code&gt; 는 일반적으로 &lt;em&gt;외부 유형&lt;/em&gt; 이며, 인수가 0 개 이상인 함수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6305ddbae16f3512160787cb992d3e58bee68afe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 다른 외부 함수에 의해 리턴되거나 다음과 같은 정적 주소 가져 오기로 가져온 외부 함수에 대한 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9be954ea62342aa30dc2f597f01c234102f416fd" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">입력 값 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 객체에 대한 포인터 나 또는 유형의 하스켈 값으로부터 정렬 화 될 수 객체 배열 나타내고 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90894fbb07b5d90eacb70ed7f8519e1d7af5b5d4" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 유형의 값은 수행 될 때 a 유형 &lt;code&gt;a&lt;/code&gt; 값을 리턴하기 전에 일부 I / O를 수행하는 계산입니다 .</target>
        </trans-unit>
        <trans-unit id="5f741bc04d3ebabbc8052c3e8ced2a6bbb1b0a05" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">입력 값 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 객체에 대한 포인터 나 또는 유형의 하스켈 값으로부터 정렬 화 될 수 객체 배열 나타내고 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e06d2b58f261c19e13fe9c8981e6d1218570c7c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 유형의 값은 수행 될 때 a 유형 &lt;code&gt;a&lt;/code&gt; 값을 리턴하기 전에 일부 I / O를 수행하는 계산입니다 .</target>
        </trans-unit>
        <trans-unit id="65e2250aafb04e86e024b91238925a6bb2963b39" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;StablePtr a&lt;/code&gt; is a stable pointer to a Haskell expression of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StablePtr a&lt;/code&gt; 유형의 값 은 a 유형 &lt;code&gt;a&lt;/code&gt; Haskell 표현식에 대한 안정적인 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="013a61726b4b56a72c4ddab274465f1e28f21c9f" translate="yes" xml:space="preserve">
          <source>A variable is &lt;em&gt;closed&lt;/em&gt; if and only if</source>
          <target state="translated">다음 과 같은 경우에만 변수가 &lt;em&gt;닫힙니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d0624bb33a678b07c2a300b904ae61401b2b3e3" translate="yes" xml:space="preserve">
          <source>A variable is called &lt;em&gt;dynamically bound&lt;/em&gt; when it is bound by the calling context of a function and &lt;em&gt;statically bound&lt;/em&gt; when bound by the callee&amp;rsquo;s context. In Haskell, all variables are statically bound. Dynamic binding of variables is a notion that goes back to Lisp, but was later discarded in more modern incarnations, such as Scheme. Dynamic binding can be very confusing in an untyped language, and unfortunately, typed languages, in particular Hindley-Milner typed languages like Haskell, only support static scoping of variables.</source>
          <target state="translated">변수는 함수의 호출 컨텍스트에 의해 &lt;em&gt;바인드&lt;/em&gt; 될 때 &lt;em&gt;동적으로 바인드&lt;/em&gt; 됩니다.&lt;em&gt;&lt;/em&gt; 되고 호출자의 컨텍스트에 의해 &lt;em&gt;바인드&lt;/em&gt; 될 때 &lt;em&gt;정적으로 바인드&lt;/em&gt; 됩니다. Haskell에서 모든 변수는 정적으로 바인딩됩니다. 변수의 동적 바인딩은 Lisp으로 돌아가는 개념이지만 나중에 Scheme과 같은 더 현대적인 화신에서 버려졌습니다. 동적 바인딩은 형식화되지 않은 언어에서 매우 혼동 될 수 있으며 불행히도 형식화 된 언어, 특히 Haskell과 같은 Hindley-Milner 형식의 언어는 변수의 정적 범위 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e557c6a254bde2fa9fce694bac49fbabbe6203a2" translate="yes" xml:space="preserve">
          <source>A variable is regarded as &amp;ldquo;used&amp;rdquo; if</source>
          <target state="translated">변수는&amp;ldquo;사용 된&amp;rdquo;것으로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="ef00f1720266eda76457e7e8274afd0d351d58ec" translate="yes" xml:space="preserve">
          <source>A variable-length event encoding a heap sample broken down by,</source>
          <target state="translated">힙 샘플을 인코딩하는 가변 길이 이벤트는</target>
        </trans-unit>
        <trans-unit id="b96521844e19dff99bc29450ed4b5c3e48d9657d" translate="yes" xml:space="preserve">
          <source>A variable-length packet encoding a heap profile sample broken down by,</source>
          <target state="translated">힙 프로파일 샘플을 인코딩하는 가변 길이 패킷은</target>
        </trans-unit>
        <trans-unit id="d2629ff819bfa2b3bc89a988e7b72caf2ad22ebf" translate="yes" xml:space="preserve">
          <source>A variable-length packet encoding a profile sample.</source>
          <target state="translated">프로필 샘플을 인코딩하는 가변 길이 패킷입니다.</target>
        </trans-unit>
        <trans-unit id="661a750d420cf956ff31ac1cd27a77853ed3578e" translate="yes" xml:space="preserve">
          <source>A variable-length packet produced once for each cost centre,</source>
          <target state="translated">각 코스트 센터마다 한 번씩 생산되는 가변 길이 패킷</target>
        </trans-unit>
        <trans-unit id="5d1f67f8c131ae27aed80d2e73f0a9a08edfca88" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 변형인수가 반대 .</target>
        </trans-unit>
        <trans-unit id="bdb2d179c96dfc9014b723ecd18ad20eb9df0287" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">첫 번째 계산의 반환 값이 필요하지 않은 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="f484ec182618f59bc6a03fa556e1dfe4602922b2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="1a806f7ef066f93f4459cf71c970f146b042ce14" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; that takes an exception predicate to select which exceptions are caught (c.f. &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;). If the exception does not match the predicate, it is re-thrown.</source>
          <target state="translated">발견 된 예외를 선택하기 위해 예외 술어를 사용하는 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 의 변형 (cf &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; ). 예외가 술어와 일치하지 않으면 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4650eb44df689d006c59aa8509db3ab07c1464b0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; that takes an exception predicate to select which exceptions are caught. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">예외 조건자를 사용하여 포착되는 예외를 선택하는 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 의 변형입니다 . &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="457d97e538f9f0947778be46de4c4ed029daa48c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; that takes an exception predicate to select which exceptions are caught. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">예외 조건자를 사용하여 포착되는 예외를 선택하는 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 의 변형입니다 . &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="980dc5b1188b883f4b0698253298fdcc03f22555" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-class#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-state-class#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="4ec6ceddfeaaf45a25f723cacb495b1ccc3c2250" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="d552c9d4da515c75912002c65ae5ebd55983c353" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="2be03be1f4f972f3e16388053b30f3f14523b03b" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="3d7eba7d8d00a5efd27077394673889a22d85d24" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="f8879cc31acc8932b5c49885c6d29e918117f2f5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 비 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d4bfbfcd281f231983e2d29e27a74b95a66a32" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 비 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c2bc37d962248156836e2639fc6b4dadc3fba3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; that is strict in the accumulator.</source>
          <target state="translated">누산기에 엄격한 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="18749169ab66a243e5d3ff1e282a5a0fa0dd77c7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가 없으므로 비어 있지 않은 구조에만 적용 할 수있는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="c779c916890acc8970f5fe31251b940c218fccc0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ddfd37c7061963e7b77b06bdb4fbd084e4a8097" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가 없으므로 비어 있지 않은 구조에만 적용 할 수있는 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7defbd1e72da7e4dd78ff7b670071a5b458cf24a" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9ee1d48660b932b3bb180c1aaef20eee11c73c0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">인수가 반대 인 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="d32ebdebb4f9a3837e2e7d4648c8bd7eceb6c9f2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">스택 추적을 생성하지 않는 &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="f23407f9c31b9d9550363e44222113e312af065d" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="228eb2d34fa954a72d817265f3ac30a2c4d0f77c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7861d5890086af48309a590da6181c625683ee1f" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="9f5f00d655edd846275d9f60a79ac5425b4f77f7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="01e8eb5a5f4093ff8d82e55e0f565658eec94954" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="0680130bb0f4b8f4cbc7c8b028930fd44a3af9ce" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="0ec4492419779cfaef51be94d2b8f28e80c4545f" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="491efa58eb1f11c0cb3815ae8f348ca0c034ce84" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="47d036c06686a27eae150f0188962179aa6b3b53" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="da53c6399c31d81bfdb2f650d84ca62634038b07" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="69da1307743efe2e8a8237d476b798b7d7365b9a" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="56ff224858a3dde352cfd622f8faf06fdcac9f54" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="a809c38b18d928a0f77c7c89ff90f9de166ff429" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="c8e0d10a78be7ef30c601c88335815732a957190" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="5e7511a38a7e0457f1dab5ba0b54c5cec192d597" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="73f171fdb5237d901b1c481374b6861edf14fa56" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">스택 추적을 생성하지 않는 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="47f3f2679bc0ad75bdf30646c6761ef6c4b68243" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가 없으므로 비어 있지 않은 구조에만 적용 할 수있는 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="477f918f68cdb05044cf99fdb58a555808faeff3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6911589d252df6b0d320b35e4685df9e30028055" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">첫 번째 계산의 반환 값이 필요하지 않은 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="add459265a4128073f2963ebb449fbb05ec6cb08" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 은 프로그래머에게 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 라는 증거를 제공 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="022677c1577a85e404387475e8f412822a05da7e" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString 의 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 는 빈 케이스 검사를 생략하므로 ByteString이 비어 있지 않다는 증거를 프로그래머에게 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b4ffb4fe31d0195b8acddfad454298b4604216b" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; 은 빈 케이스 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d777dc5f4859f53e852d78b2a883751d3a5e477" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; 는 빈 케이스 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e791ecae2adcb55aa4c85c7e30c588765957cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; 은 빈 케이스 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd0eca831b19e2193bae89b92f0b4e215f8baf4c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 는 프로그래머에게 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 라는 증거를 제공 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d61fdfe5cc2564d603aac91be2fa83ba8aa2a7c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 이므로 프로그래머는 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 증명을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="06fb91e894a0b25610b75a5af5b9808209630d25" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteStrings에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략하므로 프로그래머는 ByteString이 비어 있지 않다는 증거를 제공 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdce50acace32ba6eb0fe5af8f10f59503ea5260" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="416bf67712d94a4092fa1366ed0a1243511ca321" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteStrings에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="73173fcba7dc4f1755bea5939f3721c98a85b2cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; 은 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="91ba6eac709468119bb502dc4a786ac25beaa443" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 는 프로그래머가 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 증명을 제공해야 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d3b1c4fc3a142fd20dff1de407e4ac59e10a400" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 이므로 프로그래머는 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 증명을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9efa9d9e56c28930437717cb9aa4849cca73292e" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteStrings에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략하므로 프로그래머는 ByteString이 비어 있지 않다는 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="70d5fb53ef83cc099b75753728a3c1d6ef6749dd" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="296f173f8814e66ec18c8aaf3b18462a6dccf7c5" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteStrings에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a16411bd7567a88ce6dd6bd308879944efffc3c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; 은 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="51c2f33a34276ee363eda08a1559587e08e149e8" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 는 프로그래머가 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 증명을 제공해야 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="011da0f3d1d6c75639ffb6db3b663d10df8596d2" translate="yes" xml:space="preserve">
          <source>A version can be tagged with an arbitrary list of strings. The interpretation of the list of tags is entirely dependent on the entity that this version applies to.</source>
          <target state="translated">임의의 문자열 목록으로 버전에 태그를 지정할 수 있습니다. 태그 목록의 해석은이 버전이 적용되는 엔티티에 전적으로 의존합니다.</target>
        </trans-unit>
        <trans-unit id="ecaf2ca21f3f2373e5185cd515851b6e67ee803a" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">다시 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; 의 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="60ffeb4910a01e5cd6d72fcebc814ef710471656" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">재 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0b08df2ea8c4c791467734758ae49b0aa839c743" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">다시 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; 의 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ef5e78e2ce5a1352cca108846156255775dd7108" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">재 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ff76e55acfcccd02a15d736db81fe96146722925" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; 의 기능 시도는 가치 넣어 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 이 성공적으로, 또는 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="28577cb8a660e56c217a279acfd2976c3b7454ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; 의 기능 시도는 가치 넣어 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 이 성공적으로, 또는 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f86494fde7cd60fb48e1793ad1502f5eb25c2ad" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; 의 기능 시도는 가치 넣어 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 이 성공적으로, 또는 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="01dc8f0973fefa88de9a13d12ee694150980b61d" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">재 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ed2b50c296f40c959a6e33c87f8de3078552d7bb" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 함수를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 빈 없었다, 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 내용으로 가득했습니다 . 후 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 비어 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5433d7bb6120760452598bf6c542c3024a31c810" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 함수를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 빈 없었다, 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 내용으로 가득했습니다 . 후 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 비어 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbdfb47a525512aa542f96f58483e8697d0dc16" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 함수를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 빈 없었다, 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 내용으로 가득했습니다 . 후 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 비어 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e30f3fd19a32279f9ca43fcf5051a4b725b4afb0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">다시 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; 의 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2433a0ad5e90f34ad9f4bf45621e0ceb170fdea6" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">재 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4fc561502aa5288942ce875d139d9631abcf512c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; with the arguments swapped around; useful in situations where the code for the handler is shorter. For example:</source>
          <target state="translated">인수가 바뀌는 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 버전 . 핸들러 코드가 더 짧은 상황에서 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c3e44a662ef33517cd5d56bc8e42cf32ad0c3d0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; with the arguments swapped around (see &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">인수가 교체 된 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 버전 ( &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="e66efe0c3f15c8fafbf44d9ce27299363bc807ef" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; that forces the (pair) result of the function.</source>
          <target state="translated">함수의 (쌍) 결과를 강제하는 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 버전 .</target>
        </trans-unit>
        <trans-unit id="bef2aa5115f3db1a79e2efec0dfffeeae204b525" translate="yes" xml:space="preserve">
          <source>A vertical bar denotes disjunction, i.e. one of the two sides is required. A comma denotes conjunction, i.e. both sides are required. Conjunction binds stronger than disjunction.</source>
          <target state="translated">수직 막대는 분리를 나타내며, 즉 두면 중 하나가 필요합니다. 쉼표는 연결을 나타냅니다. 즉, 양쪽이 필요합니다. 연결은 분리보다 더 강력하게 결속됩니다.</target>
        </trans-unit>
        <trans-unit id="edf34a57d05a3c5d4ea50057dd0ce34f6a6b36fa" translate="yes" xml:space="preserve">
          <source>A very experimental flag that makes dictionary-valued expressions seem cheap to the optimiser.</source>
          <target state="translated">사전 값 표현을 옵티 마이저에게 저렴하게 만드는 매우 실험적인 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="7c65e4b2cb887d618e9c4063061a15033cdc0051" translate="yes" xml:space="preserve">
          <source>A violation of the &amp;ldquo;forall-or-nothing&amp;rdquo; rule looks like this:</source>
          <target state="translated">&quot;전부 또는 무관 용&quot;규칙 위반은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5feb9baead6354d4dfbb9ad7fa5678327d72c84" translate="yes" xml:space="preserve">
          <source>A visible type application is preceded with an &lt;code&gt;@&lt;/code&gt; sign. (To disambiguate the syntax, the &lt;code&gt;@&lt;/code&gt; must be preceded with a non-identifier letter, usually a space. For example, &lt;code&gt;read@Int 5&lt;/code&gt; would not parse.) It can be used whenever the full polymorphic type of the function is known. If the function is an identifier (the common case), its type is considered known only when the identifier has been given a type signature. If the identifier does not have a type signature, visible type application cannot be used.</source>
          <target state="translated">보이는 유형의 응용 프로그램 앞에는 &lt;code&gt;@&lt;/code&gt; 기호가 있습니다. 구문을 명확하게 나타내려면 &lt;code&gt;@&lt;/code&gt; 앞에 공백이 아닌 식별자 문자가 있어야합니다. 예를 들어 &lt;code&gt;read@Int 5&lt;/code&gt; 는 구문 분석하지 않습니다. 함수의 전체 다형성 유형이 알려질 때마다 사용할 수 있습니다. 함수가 식별자 (일반적인 경우) 인 경우 식별자에 형식 서명이 제공된 경우에만 해당 형식이 알려진 것으로 간주됩니다. 식별자에 형식 서명이 없으면 보이는 형식 응용 프로그램을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7aecd3b32383a90db727ba6bc951dd96bb7555b" translate="yes" xml:space="preserve">
          <source>A way of creating ByteStrings outside the IO monad. The &lt;code&gt;Int&lt;/code&gt; argument gives the final size of the ByteString.</source>
          <target state="translated">IO 모나드 외부에서 ByteString을 작성하는 방법입니다. &lt;code&gt;Int&lt;/code&gt; 인수는 ByteString의 최종 크기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ae700162fd083eb51a2e5484581b63431c6cf961" translate="yes" xml:space="preserve">
          <source>A weak pointer expresses a relationship between two objects, the &lt;em&gt;key&lt;/em&gt; and the &lt;em&gt;value&lt;/em&gt;: if the key is considered to be alive by the garbage collector, then the value is also alive. A reference from the value to the key does &lt;em&gt;not&lt;/em&gt; keep the key alive.</source>
          <target state="translated">약한 포인터는 &lt;em&gt;키&lt;/em&gt; 와 &lt;em&gt;값&lt;/em&gt; 의 두 개체 간의 관계를 나타냅니다 . 가비지 수집기가 키를 살아있는 것으로 간주하면 값도 살아 있습니다. 값에서 키로의 참조는 키를 유지 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4c0a7ed1da2479162371079b8163cabf26c83c98" translate="yes" xml:space="preserve">
          <source>A weak pointer may also have a finalizer of type &lt;code&gt;IO ()&lt;/code&gt;; if it does, then the finalizer will be run at most once, at a time after the key has become unreachable by the program (&quot;dead&quot;). The storage manager attempts to run the finalizer(s) for an object soon after the object dies, but promptness is not guaranteed.</source>
          <target state="translated">약한 포인터는 &lt;code&gt;IO ()&lt;/code&gt; 유형의 종료 자를 가질 수도 있습니다 . 만약 그렇다면, 프로그램이 키에 접근 할 수 없게 된 후 ( &quot;데드&quot;) 파이널 라이저는 최대 한 번 실행됩니다. 스토리지 관리자는 오브젝트가 종료 된 직후 오브젝트에 대한 종료자를 실행하려고하지만 프롬프트가 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a955a161a9eee216cd6b80d8d47df1c807c9be34" translate="yes" xml:space="preserve">
          <source>A weak pointer object with a key and a value. The value has type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">키와 값을 가진 약한 포인터 객체. 값의 유형은 &lt;code&gt;v&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b5c16f462f6b8ca64b6aee48fd180f321af7cba" translate="yes" xml:space="preserve">
          <source>A whole String fragment</source>
          <target state="translated">전체 문자열 조각</target>
        </trans-unit>
        <trans-unit id="1306d902863c6c0a77b6f4d1230a385868937f62" translate="yes" xml:space="preserve">
          <source>A wide character string with explicit length information in &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt;s instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">종료 NUL (문자열 중간에 NUL 문자 허용) 대신 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt; s 에 명시 적 길이 정보가있는 넓은 문자열.</target>
        </trans-unit>
        <trans-unit id="987253a26575543a06fc7e055fbc0251b63eb205" translate="yes" xml:space="preserve">
          <source>A word begins either at the start of the line or after an unescaped whitespace character.</source>
          <target state="translated">줄의 시작 부분이나 이스케이프 처리되지 않은 공백 문자 다음에 단어가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="98bca88a2b006e940b1f7f785915d961c11c9f72" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by the type &lt;code&gt;w&lt;/code&gt; of output to accumulate.</source>
          <target state="translated">출력 유형 &lt;code&gt;w&lt;/code&gt; 에 의해 매개 변수화 된 라이터 모나드 가 누적됩니다.</target>
        </trans-unit>
        <trans-unit id="07ef82639a79658d53d1fcd5bfce5876d5b9adb5" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by:</source>
          <target state="translated">다음에 의해 매개 변수화 된 작성자 모나드 :</target>
        </trans-unit>
        <trans-unit id="3f08cc0b30779a95143aa2ad65f0531b4ad12960" translate="yes" xml:space="preserve">
          <source>ACL</source>
          <target state="translated">ACL</target>
        </trans-unit>
        <trans-unit id="882edca3292f207f02c04f0e4d828075132b5c5b" translate="yes" xml:space="preserve">
          <source>ADDATTRS</source>
          <target state="translated">ADDATTRS</target>
        </trans-unit>
        <trans-unit id="d37db076be2c745cf98c9bb60cf88dbf2626e6b7" translate="yes" xml:space="preserve">
          <source>AM/PM symbols</source>
          <target state="translated">AM / PM 기호</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="e95867ec94d8c275a2d1d9afac6a1d2ffb7fd390" translate="yes" xml:space="preserve">
          <source>ASCII (Char7)</source>
          <target state="translated">ASCII (Char7)</target>
        </trans-unit>
        <trans-unit id="2f934a30b8b57fba10b2b745dc320b339724b1b7" translate="yes" xml:space="preserve">
          <source>ASCII &lt;code&gt;'0'&lt;/code&gt; through &lt;code&gt;'9'&lt;/code&gt; are all numbers:</source>
          <target state="translated">ASCII &lt;code&gt;'0'&lt;/code&gt; ~ &lt;code&gt;'9'&lt;/code&gt; 는 모두 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="cae061a530cef71c477f974034de1fd1d9b43ecb" translate="yes" xml:space="preserve">
          <source>ATOM</source>
          <target state="translated">ATOM</target>
        </trans-unit>
        <trans-unit id="09116156619580f2fa8233d5bca8cf8644f9c359" translate="yes" xml:space="preserve">
          <source>Abandon evaluation of a statement after a breakpoint</source>
          <target state="translated">중단 점 후 명령문의 포기 평가</target>
        </trans-unit>
        <trans-unit id="c38c6ea6c11538ed82fd288d53c904871944106f" translate="yes" xml:space="preserve">
          <source>Abandons the current evaluation (only available when stopped at a breakpoint).</source>
          <target state="translated">현재 평가를 중단합니다 (중단 점에서 중지 된 경우에만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="f07c8230701366b843cd68845fafa5d65a1de2d9" translate="yes" xml:space="preserve">
          <source>About validity:</source>
          <target state="translated">유효성에 관하여 :</target>
        </trans-unit>
        <trans-unit id="05edf0d68cd3c84475eb832e7d283639e6bdeca9" translate="yes" xml:space="preserve">
          <source>Above, except that if the last line of the first argument stops at least one position before the first line of the second begins, these two lines are overlapped. For example:</source>
          <target state="translated">위의 경우, 첫 번째 인수의 마지막 행이 두 번째 행의 첫 번째 행이 시작되기 전에 하나 이상의 위치를 ​​중지하면이 두 행이 겹칩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef82336eb495d4e5324f732f879ad3b7c7dd9b61" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위와 겹치지 않습니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 ID는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a7dc34cb7ea60a4e1ddaf0a591cdafbc0e403cf" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위와 겹치지 않습니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 ID는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d972269377ed5359cdd2dcc108f0e3936d78b1" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위와 겹치지 않습니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 ID는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="88874691ade84811a148df43dee3e898c7993db4" translate="yes" xml:space="preserve">
          <source>Above, without dovetailing.</source>
          <target state="translated">위의 더브 테일링없이.</target>
        </trans-unit>
        <trans-unit id="ffc84c11cb600f5730c837f24132ad44932f0e4a" translate="yes" xml:space="preserve">
          <source>Above; if there is no overlap it &quot;dovetails&quot; the two</source>
          <target state="translated">위; 겹치지 않으면 두 &quot;더브 테일&quot;</target>
        </trans-unit>
        <trans-unit id="2c7fe8b95b08b1e64796580d91044372f5603e8d" translate="yes" xml:space="preserve">
          <source>Absolute cursor movements</source>
          <target state="translated">절대 커서 이동</target>
        </trans-unit>
        <trans-unit id="44530d6a736fdaae47537dfbad7f8dda6f90c1ca" translate="yes" xml:space="preserve">
          <source>Absolute intervals</source>
          <target state="translated">절대 간격</target>
        </trans-unit>
        <trans-unit id="05675a8df55f00a801d7267f15ceae258c856842" translate="yes" xml:space="preserve">
          <source>Absolute value.</source>
          <target state="translated">절대 값.</target>
        </trans-unit>
        <trans-unit id="be11481292069bbf4e5d32f6f22e3e0ba35a6c06" translate="yes" xml:space="preserve">
          <source>AbsoluteSeek</source>
          <target state="translated">AbsoluteSeek</target>
        </trans-unit>
        <trans-unit id="d18ae99534459c5602deda227d35dbfc2f1e9957" translate="yes" xml:space="preserve">
          <source>AbsoluteTime</source>
          <target state="translated">AbsoluteTime</target>
        </trans-unit>
        <trans-unit id="434cecc208a8b4bb275114bca8d90f1c47541833" translate="yes" xml:space="preserve">
          <source>AbsoluteTime is TAI, time as measured by a clock.</source>
          <target state="translated">AbsoluteTime은 시계로 측정 한 TAI 시간입니다.</target>
        </trans-unit>
        <trans-unit id="667a8cf10407b19099b8b8a8c853533598abd554" translate="yes" xml:space="preserve">
          <source>Abstract data types can be implemented not only with data declarations, but also newtypes and type synonyms (with the restriction that a type synonym must be fully eta-reduced, e.g., &lt;code&gt;type T = ...&lt;/code&gt; to be accepted.) For example, the following are all valid implementations of the T above:</source>
          <target state="translated">추상 데이터 형식은 데이터 선언뿐만 아니라 새로운 형식 및 형식 동의어로도 구현할 수 있습니다 (예 : 형식 동의어를 완전히 정의해야한다는 제한이 있습니다 (예 : &lt;code&gt;type T = ...&lt;/code&gt; ). 예를 들어, 다음은 위 T의 모든 유효한 구현입니다.</target>
        </trans-unit>
        <trans-unit id="beb8fcf15e248371df65aec656beac0bfea7c0b8" translate="yes" xml:space="preserve">
          <source>Abstract representation of vertices.</source>
          <target state="translated">꼭짓점의 추상 표현.</target>
        </trans-unit>
        <trans-unit id="f326ddf7104d3df6fa13479c593c244c4623b73c" translate="yes" xml:space="preserve">
          <source>Abstract syntax definitions for Template Haskell.</source>
          <target state="translated">Template Haskell에 대한 추상 구문 정의.</target>
        </trans-unit>
        <trans-unit id="71b7aef56068b7e751389cca7071da4abd7a1c80" translate="yes" xml:space="preserve">
          <source>Accept leading and trailing whitespace?</source>
          <target state="translated">선행 및 후행 공백을 허용합니까?</target>
        </trans-unit>
        <trans-unit id="95d34f3b555d7e27b1e17d75f2e37485b204658e" translate="yes" xml:space="preserve">
          <source>Accept leading whitespace?</source>
          <target state="translated">선행 공백을 허용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="bc52205c7ec889cf4cba765533bcd4e5d13957bc" translate="yes" xml:space="preserve">
          <source>Acceptable data</source>
          <target state="translated">허용되는 데이터</target>
        </trans-unit>
        <trans-unit id="3a8a3f0706793232d22f7100e8ea68a2faa1f5f0" translate="yes" xml:space="preserve">
          <source>Access to GHC's call-stack simulation</source>
          <target state="translated">GHC의 콜 스택 시뮬레이션에 액세스</target>
        </trans-unit>
        <trans-unit id="4756089d5cd10709a1d37fad3e346fb021462dee" translate="yes" xml:space="preserve">
          <source>AccessMode</source>
          <target state="translated">AccessMode</target>
        </trans-unit>
        <trans-unit id="f9fce24b3c49b79586973841924c190bcf8769f7" translate="yes" xml:space="preserve">
          <source>Accessing arrays</source>
          <target state="translated">배열에 액세스</target>
        </trans-unit>
        <trans-unit id="aff0bc5a5aaa0b373eac340c6aadb774a3a23049" translate="yes" xml:space="preserve">
          <source>Accessing the pointer to the array contents</source>
          <target state="translated">배열 내용에 대한 포인터 액세스</target>
        </trans-unit>
        <trans-unit id="3efd139cf44f823a7b553a058c94da8090307f52" translate="yes" xml:space="preserve">
          <source>Accessors to GHC RTS flags. Descriptions of flags can be seen in &lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC User's Guide&lt;/a&gt;, or by running RTS help message using &lt;code&gt;+RTS --help&lt;/code&gt;.</source>
          <target state="translated">GHC RTS 플래그에 대한 접근 자 플래그에 대한 설명은 &lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC 사용자 안내서&lt;/a&gt; 또는 다음을 사용하여 RTS 도움말 메시지를 실행하여 볼 수 있습니다. &lt;code&gt;+RTS --help&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7edca54ae2bf350d49cd477266ad9dd7d55aedcd" translate="yes" xml:space="preserve">
          <source>According to [1]:</source>
          <target state="translated">[1]에 따르면 :</target>
        </trans-unit>
        <trans-unit id="2d6dfb6165d33d7dc1b66480f6a0d421d69dd337" translate="yes" xml:space="preserve">
          <source>According to the GMP documentation, the underlying function &lt;code&gt;mpz_nextprime()&lt;/code&gt; &quot;uses a probabilistic algorithm to identify primes. For practical purposes it's adequate, the chance of a composite passing will be extremely small.&quot;</source>
          <target state="translated">GMP 문서에 따르면 기본 함수 &lt;code&gt;mpz_nextprime()&lt;/code&gt; 은 확률 론적 알고리즘을 사용하여 소수를 식별합니다. 실질적인 목적을 위해 복합적인 통과 가능성은 극히 적습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="a91ad95de89488856c8210673c103c15b4491b35" translate="yes" xml:space="preserve">
          <source>According to the rules above &lt;code&gt;X&lt;/code&gt; has a CUSK. Yet, the kind of &lt;code&gt;k&lt;/code&gt; is undetermined. It is thus quantified over, giving &lt;code&gt;X&lt;/code&gt; the kind &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">위의 규칙에 따라 &lt;code&gt;X&lt;/code&gt; 에는 CUSK가 있습니다. 그러나 &lt;code&gt;k&lt;/code&gt; 의 종류 는 결정되지 않았습니다. 따라서 &lt;code&gt;X&lt;/code&gt; 가 모든 &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt; 대한 종류를 제공하여 정량화 됩니다. 프록시 k-&amp;gt; 유형 .</target>
        </trans-unit>
        <trans-unit id="3d5e0f0e68219f2793950ff4f739b0707416bc38" translate="yes" xml:space="preserve">
          <source>Accordingly, the rule for kind quantification in higher-rank contexts has changed slightly. In GHC 7, if a kind variable was mentioned for the first time in the kind of a variable bound in a non-top-level &lt;code&gt;forall&lt;/code&gt;, the kind variable was bound there, too. That is, in &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; was bound by the same &lt;code&gt;forall&lt;/code&gt; as the &lt;code&gt;a&lt;/code&gt;. In GHC 8, however, all kind variables mentioned in a type are bound at the outermost level. If you want one bound in a higher-rank &lt;code&gt;forall&lt;/code&gt;, include it explicitly.</source>
          <target state="translated">따라서, 높은 등급의 맥락에서 종류 정량화 규칙은 약간 변경되었습니다. GHC 7에서 최상위 변수가 아닌 &lt;code&gt;forall&lt;/code&gt; 에 바인딩 된 변수의 종류에서 종류 변수가 처음으로 언급 된 경우, 종류 변수도 여기에 바인딩되었습니다. ,는 것을 &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt; 상기 &lt;code&gt;k&lt;/code&gt; 동일 구속 된 &lt;code&gt;forall&lt;/code&gt; 는 AS . 그러나 GHC 8에서 한 유형에서 언급 된 모든 종류의 변수는 최 외곽 레벨에 바인딩됩니다. 당신은 더 높은 순위에 결합 된 하나의 원하는 경우 &lt;code&gt;forall&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 명시 적으로 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="1bb0023c7c1fa4cd60dd0df32c9589498220f1d0" translate="yes" xml:space="preserve">
          <source>Accordingly, the type environment seen by &lt;code&gt;reify&lt;/code&gt; includes all the top-level declarations up to the end of the immediately preceding declaration group, but no more.</source>
          <target state="translated">따라서 &lt;code&gt;reify&lt;/code&gt; 로 보는 유형 환경 에는 직전 선언 그룹의 끝까지 모든 최상위 선언이 포함되지만 더 이상 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82bedfe88009972d90237d52b7f414b23e6d5eb6" translate="yes" xml:space="preserve">
          <source>Accum</source>
          <target state="translated">Accum</target>
        </trans-unit>
        <trans-unit id="50b4f3d88aa3c9059e12c063f7c950d2f9b4b778" translate="yes" xml:space="preserve">
          <source>Accum operations</source>
          <target state="translated">누적 작업</target>
        </trans-unit>
        <trans-unit id="cd4bf7ea6fd4060189e1e1baaa24ebb42d7660ad" translate="yes" xml:space="preserve">
          <source>AccumT</source>
          <target state="translated">AccumT</target>
        </trans-unit>
        <trans-unit id="50412c7500ef5d04ef8c2e37d60a2b1db38c9207" translate="yes" xml:space="preserve">
          <source>Accumulating maps</source>
          <target state="translated">누적지도</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="6347206826a895475f5f91774a889e897ffc7d63" translate="yes" xml:space="preserve">
          <source>Action &lt;code&gt;askString&lt;/code&gt; requests user to enter a string, and passes it to the continuation. &lt;code&gt;askString&lt;/code&gt; takes as a parameter a continuation taking a string parameter, and returning &lt;code&gt;IO ()&lt;/code&gt;. Compare its signature to &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; definition.</source>
          <target state="translated">조치 &lt;code&gt;askString&lt;/code&gt; 은 사용자에게 문자열을 입력하도록 요청하고 연속으로 전달합니다. &lt;code&gt;askString&lt;/code&gt; 은 매개 변수로 문자열 매개 변수를 가져 와서 &lt;code&gt;IO ()&lt;/code&gt; 를 리턴하는 연속을 취합니다 . 서명을 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; 정의와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2f1b38e49644d95f7b46650e509c991d77060f8" translate="yes" xml:space="preserve">
          <source>Action to be executed</source>
          <target state="translated">실행할 조치</target>
        </trans-unit>
        <trans-unit id="f5278c8649d913f335c11a62f866017db4429c6b" translate="yes" xml:space="preserve">
          <source>Actions on directories</source>
          <target state="translated">디렉토리에 대한 조치</target>
        </trans-unit>
        <trans-unit id="696ed90b8efd0baea13c573b2e7c286d011d6b3c" translate="yes" xml:space="preserve">
          <source>Actions on files</source>
          <target state="translated">파일에 대한 조치</target>
        </trans-unit>
        <trans-unit id="7083b72c48cfaf651eebc9aa10754311beefc8de" translate="yes" xml:space="preserve">
          <source>Activate cross-compilation mode (see &lt;a href=&quot;#hsc2hs-cross&quot;&gt;Cross-compilation&lt;/a&gt;).</source>
          <target state="translated">크로스 컴파일 모드를 활성화합니다 ( &lt;a href=&quot;#hsc2hs-cross&quot;&gt;크로스 컴파일&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="583d9a705b86bbdfe3e1d9047b3ea1485ccadeeb" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; 경우를 제외하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를가 심볼릭 링크를 의미한다. 이 경우 심볼릭 링크 자체 의 &lt;code&gt;FileStatus&lt;/code&gt; 정보는 가리키는 파일의 정보 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d65523818024ea88107f6287927f036ddf6afd4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; 경우를 제외하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를가 심볼릭 링크를 의미한다. 이 경우 가리키는 파일 정보 대신 심볼릭 링크 자체 의 &lt;code&gt;FileStatus&lt;/code&gt; 정보가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b0cdc6afa6bf7a9a92dae50e6c59c713b9c3a94b" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; 경우를 제외하고 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를가 심볼릭 링크를 의미한다. 이 경우 가리키는 파일 정보 대신 심볼릭 링크 자체 의 &lt;code&gt;FileStatus&lt;/code&gt; 정보가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb8dd245b9cb57f179bf3b4b88042343c063795" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; 하지만 심볼릭 링크를 따르지 않는 (따라서 링크 자체에 대한 권한을 변경).</target>
        </trans-unit>
        <trans-unit id="00b98c6571c6f97fdd25d5e837fe03213c325e22" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; 경우를 제외하고 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 이 심볼릭 링크를 의미한다. 이 경우 심볼릭 링크 자체 의 &lt;code&gt;FileStatus&lt;/code&gt; 정보는 가리키는 파일의 정보 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cbcea92f66c4289d12fcd3463f6bb4e3fab3bda6" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; 하지만 심볼릭 링크를 따르지 않는 (따라서 링크 자체에 대한 권한을 변경).</target>
        </trans-unit>
        <trans-unit id="6a6c3ff29419f1c7034849f1db0a070b794f9ad2" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setFileSize&lt;/code&gt; 로 작동 하지만 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 대신 파일 설명자를 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="49be567080d7b410e84b47729961520e4de920c4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setFileSize&lt;/code&gt; 로 작동 하지만 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 대신 파일 설명자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a7abb6dfde7eef75e3008b76f458c888ddea86b0" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setFileSize&lt;/code&gt; 로 작동 하지만 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 대신 파일 설명자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d4b7078adb2d96736d050720e01d8ae82392b27c" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">역할을 &lt;code&gt;setOwnerAndGroup&lt;/code&gt; 하지만 대신 파일 디스크립터를 사용 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f40c80358e12a1e2aaf02b1148d6c20fcfd4ba45" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">역할을 &lt;code&gt;setOwnerAndGroup&lt;/code&gt; 하지만 대신 파일 디스크립터를 사용 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="5709329f4d41fd8b75411e36d0c8d0a6e2033e83" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">역할을 &lt;code&gt;setOwnerAndGroup&lt;/code&gt; 하지만 대신 파일 디스크립터를 사용 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="fce17679436ea260fadec4591a677de22164d0f8" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;hsc2hs&lt;/code&gt; does not output the Haskell file directly. It creates a C program that includes the headers, gets automatically compiled and run. That program outputs the Haskell code.</source>
          <target state="translated">실제로 &lt;code&gt;hsc2hs&lt;/code&gt; 는 Haskell 파일을 직접 출력하지 않습니다. 헤더를 포함하는 C 프로그램을 작성하고 자동으로 컴파일되어 실행됩니다. 이 프로그램은 Haskell 코드를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="4f047ea892e21f4553c30a3d6ef7ff19933e3fa6" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; handling abilities to a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 처리 기능을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bb27c3e9c12f7296abdd1656c75526ce920178b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; handling abilities to a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 처리 기능을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="282d599b16c31e26561720e6c06e8259bdd71518" translate="yes" xml:space="preserve">
          <source>Add Finalizers</source>
          <target state="translated">종료 자 추가</target>
        </trans-unit>
        <trans-unit id="d138b6ef22b1ca378b672fc1221a3aa6b42bbf3c" translate="yes" xml:space="preserve">
          <source>Add a default &lt;code&gt;error&lt;/code&gt; alternative to case expressions without a default alternative.</source>
          <target state="translated">기본 대안없이 케이스 표현식에 기본 &lt;code&gt;error&lt;/code&gt; 대안을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="eb4c8a6633849d6709d07c9f3e63104f63a51077" translate="yes" xml:space="preserve">
          <source>Add a finalizer that will run in the Q monad after the current module has been type checked. This only makes sense when run within a top-level splice.</source>
          <target state="translated">현재 모듈의 유형을 확인한 후 Q 모나드에서 실행될 종료자를 추가하십시오. 이것은 최상위 스플 라이스 내에서 실행될 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de0de177dcddf4173fd744c404b8ba61f96637ed" translate="yes" xml:space="preserve">
          <source>Add a finalizer to an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (GHC only). See &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; and &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; for more about finalizers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 마무리 기를 추가하십시오 (GHC 만 해당). &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; 및 &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; 참조 대한 자세한 를 .</target>
        </trans-unit>
        <trans-unit id="87eb63d6dca38f792891dceb6d3068ba951d4549" translate="yes" xml:space="preserve">
          <source>Add a line to the history unless it matches the previously recorded line.</source>
          <target state="translated">이전에 기록 된 라인과 일치하지 않는 한 라인을 히스토리에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="aaca03fa0d32c5a3d402a6fb5fcc0ded2bb915ec" translate="yes" xml:space="preserve">
          <source>Add a line to the history, and remove all previous entries which are the same as it.</source>
          <target state="translated">히스토리에 행을 추가하고 동일한 이전 항목을 모두 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1d7fd5dfa46b0f645d5db42f20504f6c3caf7358" translate="yes" xml:space="preserve">
          <source>Add a trailing file path separator if one is not already present.</source>
          <target state="translated">후행 파일 경로 구분 기호가 없으면 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c5f1a8ca3a641a6b0ef6dbe461171ca7f604eb5a" translate="yes" xml:space="preserve">
          <source>Add additional top-level declarations. The added declarations will be type checked along with the current declaration group.</source>
          <target state="translated">최상위 선언을 추가하십시오. 추가 된 선언은 현재 선언 그룹과 함께 유형 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="cecd1aea8fe88c39fcc8f71681a3e087791c984b" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; 에 해당하는 확장이 이미있는 경우에도 확장을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="34878ebb3f1e96601aafa913d00d7bd263cdc36c" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이미 확장이있는 경우에도 확장을 추가하십시오 ( &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 과 동일). .</target>
        </trans-unit>
        <trans-unit id="89357b09335d29d387cf17547863b974b8decc59" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; 에 해당하는 확장이 이미있는 경우에도 확장을 추가하십시오 ..</target>
        </trans-unit>
        <trans-unit id="12e0f266814b31f57d2a4d4f2e065ebded03e6c4" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이미 확장이있는 경우에도 확장을 추가하십시오 ( &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 과 동일). .</target>
        </trans-unit>
        <trans-unit id="88bd486d89c4fede722e2d2391a03c0fd1f29c23" translate="yes" xml:space="preserve">
          <source>Add entries to the Static Pointer Table</source>
          <target state="translated">정적 포인터 테이블에 항목 추가</target>
        </trans-unit>
        <trans-unit id="573b000c455e2582361374a0f2d5ce932b4443a5" translate="yes" xml:space="preserve">
          <source>Add months (clipped to last day), then add days</source>
          <target state="translated">몇 달 (마지막 날까지)을 추가 한 다음 일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="11f2dacfd6ba9147a205050f051361aedae62583" translate="yes" xml:space="preserve">
          <source>Add months (rolling over to next month), then add days</source>
          <target state="translated">월을 추가하고 (다음 달로 롤오버) 일을 추가하십시오</target>
        </trans-unit>
        <trans-unit id="b015364a9bf90321fb61c3a98f1cdc612fdf7a8d" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month clipped to the last day. For instance, 2005-01-30 + 1 month = 2005-02-28.</source>
          <target state="translated">해당 월의 마지막 날을 지난 날에 마지막 날로 클리핑하여 월을 추가하십시오. 예를 들어, 2005-01-30 + 1 개월 = 2005-02-28입니다.</target>
        </trans-unit>
        <trans-unit id="1ce9d4dd3c00c35abdeda445f12f814c42604388" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month rolling over to the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.</source>
          <target state="translated">해당 월의 마지막 날을지나 다음 달로 넘어가는 월을 추가하십시오. 예를 들어 2005-01-30 + 1 개월 = 2005-03-02입니다.</target>
        </trans-unit>
        <trans-unit id="45aa2700c673ebfa0acebc5efea925be3a17cb6f" translate="yes" xml:space="preserve">
          <source>Add one to the given number using the state monad:</source>
          <target state="translated">상태 모나드를 사용하여 주어진 숫자에 하나를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ad0277793f67d2e393175d08b52db34131c5ef10" translate="yes" xml:space="preserve">
          <source>Add signed integers reporting overflow. First member of result is the sum truncated to an &lt;code&gt;Int#&lt;/code&gt;; second member is zero if the true sum fits in an &lt;code&gt;Int#&lt;/code&gt;, nonzero if overflow occurred (the sum is either too large or too small to fit in an &lt;code&gt;Int#&lt;/code&gt;).</source>
          <target state="translated">오버플로를보고하는 부호있는 정수를 추가하십시오. 결과의 첫 번째 멤버는 &lt;code&gt;Int#&lt;/code&gt; 잘린 합계입니다 . 실제 합계가 &lt;code&gt;Int#&lt;/code&gt; 맞는 경우 두 번째 멤버는 0이고 오버플로가 발생한 경우 0이 아닙니다 (합계가 너무 크거나 너무 작아서 &lt;code&gt;Int#&lt;/code&gt; 에 맞지 않음).</target>
        </trans-unit>
        <trans-unit id="b0fcd5e56314036018a9f0cac00e78ef55a1787b" translate="yes" xml:space="preserve">
          <source>Add some helper code that starts up and shuts down the Haskell RTS:</source>
          <target state="translated">Haskell RTS를 시작하고 종료하는 도우미 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="985586c7f3031f00d6269e644d3adc10e6ea07bc" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS option when running the program to see timing stats, which will help to tell you whether your program got faster by using more CPUs or not. If the user time is greater than the elapsed time, then the program used more than one CPU. You should also run the program without &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; for comparison.</source>
          <target state="translated">프로그램을 실행할 때 &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS 옵션을 추가하여 타이밍 통계를 확인하면 더 많은 CPU를 사용하여 프로그램이 더 빨라 졌는지 여부를 알려주는 데 도움이됩니다. 사용자 시간이 경과 시간보다 큰 경우 프로그램은 둘 이상의 CPU를 사용했습니다. 또한 &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; without없이 프로그램을 실행해야합니다. 비교를 위해 .</target>
        </trans-unit>
        <trans-unit id="343b1a229f6a10110d459f27e6591278cc0810b3" translate="yes" xml:space="preserve">
          <source>Add the global package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt;&lt;code&gt;-no-global-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the global package database should be loaded.</source>
          <target state="translated">현재 스택 위에 글로벌 패키지 데이터베이스를 추가하십시오. 이 옵션은 &lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt; &lt;code&gt;-no-global-package-db&lt;/code&gt; &lt;/a&gt; 뒤에 사용 되어 글로벌 패키지 데이터베이스를로드 할 스택의 위치를 ​​지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24dc1f25cbb780084188d4ff897a81d5104622f0" translate="yes" xml:space="preserve">
          <source>Add the global package db to the stack.</source>
          <target state="translated">글로벌 패키지 db를 스택에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fe975763255492732af82ca06ecb5eda5e5fa904" translate="yes" xml:space="preserve">
          <source>Add the package database ⟨file⟩ on top of the current stack.</source>
          <target state="translated">현재 스택 위에 패키지 데이터베이스 ⟨file⟩을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6134bf2d1b2295efc8fa6b7e828ec4d22ba2e38e" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt;&lt;code&gt;-no-user-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the user&amp;rsquo;s package database should be loaded.</source>
          <target state="translated">현재 스택 위에 사용자의 패키지 데이터베이스를 추가하십시오. 이 옵션은 &lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt; &lt;code&gt;-no-user-package-db&lt;/code&gt; &lt;/a&gt; 이후에 사용할 수 있습니다 하여 스택에서 사용자 패키지 데이터베이스를로드 할 위치를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30d336c4a71c8e660819935f8d9b591c05d3839d" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package db to the stack.</source>
          <target state="translated">스택에 사용자 패키지 db를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f0c714c0819e829fa65b99edbce416f762fa1cd5" translate="yes" xml:space="preserve">
          <source>Add the user's package db to the stack.</source>
          <target state="translated">사용자의 패키지 db를 스택에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="52e83704b0c13e474a873f78d2503ff9d5058a2e" translate="yes" xml:space="preserve">
          <source>Add two &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">두 개의 추가 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="42140a41e27de0c19e086f86091f816243e8209e" translate="yes" xml:space="preserve">
          <source>Add two non-negative numbers. Errors out on overflow.</source>
          <target state="translated">음수가 아닌 두 개의 숫자를 추가하십시오. 오버플로시 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="e2856c1714aa39e0ac4378840b55f10a1492a342" translate="yes" xml:space="preserve">
          <source>Add two vectors element-wise.</source>
          <target state="translated">요소별로 두 개의 벡터를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d21ffb0b2e887326fe4eaccd172c45b78c0f6321" translate="yes" xml:space="preserve">
          <source>Add unsigned integers reporting overflow. The first element of the pair is the result. The second element is the carry flag, which is nonzero on overflow. See also &lt;code&gt;plusWord2#&lt;/code&gt;.</source>
          <target state="translated">오버 플로우를보고하는 부호없는 정수를 추가하십시오. 쌍의 첫 번째 요소가 결과입니다. 두 번째 요소는 캐리 플래그이며 오버플로시 0이 아닙니다. &lt;code&gt;plusWord2#&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4224f11c255c4982dd554902608b0a229771245f" translate="yes" xml:space="preserve">
          <source>Add unsigned integers, with the high part (carry) in the first component of the returned pair and the low part in the second component of the pair. See also &lt;code&gt;addWordC#&lt;/code&gt;.</source>
          <target state="translated">리턴 된 쌍의 첫 번째 구성 요소에 높은 부분 (이동)과 쌍의 두 번째 구성 요소에 낮은 부분이있는 부호없는 정수를 추가하십시오. &lt;code&gt;addWordC#&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7bc6acbb336def5a2fed21adc84cf2eba8c8695" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th clipped to Feb 28th if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.</source>
          <target state="translated">필요한 경우 2 월 29 일을 2 월 28 일로 클리핑하여 월과 일을 일치하는 연도를 추가하십시오. 예를 들어 2004-02-29 + 2 년 = 2006-02-28입니다.</target>
        </trans-unit>
        <trans-unit id="00a5a0f630ddf36709167f1d67babdf5ba438d3b" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th rolled over to Mar 1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.</source>
          <target state="translated">필요한 경우 2 월 29 일이 3 월 1 일로 롤오버되어 월과 일이 일치하는 연도를 추가하십시오. 예를 들어 2004-02-29 + 2 년 = 2006-03-01입니다.</target>
        </trans-unit>
        <trans-unit id="b78eacb0dc09583fbc5860e25537c0fbd17b2217" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the directory search list for &lt;code&gt;#include&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; 파일 의 디렉토리 검색 목록에 ⟨dir⟩ 추가</target>
        </trans-unit>
        <trans-unit id="3af3cf99d9bd473db5a8f166f611704c815a0e2a" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the list of directories searched for libraries</source>
          <target state="translated">라이브러리를 검색 한 디렉토리 목록에 ⟨dir⟩ 추가</target>
        </trans-unit>
        <trans-unit id="22a6f927fd045f27916f2841389ceb5619f2f520" translate="yes" xml:space="preserve">
          <source>Add ⟨file⟩ to the package db stack.</source>
          <target state="translated">패키지 DB 스택에 ⟨file⟩을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fd862d70f0a0e1b3f98b9cfd9a82f7a12719414c" translate="yes" xml:space="preserve">
          <source>Add ⟨module⟩(s) to the current target set, and perform a reload. Normally pre-compiled code for the module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the &lt;code&gt;*&lt;/code&gt; prefix forces the module to be loaded as byte-code.</source>
          <target state="translated">target 모듈⟩을 현재 대상 세트에 추가하고 다시로드를 수행하십시오. 모듈에 대해 일반적으로 사전 컴파일 된 코드는 사용 가능한 경우로드되거나 그렇지 않으면 모듈이 바이트 코드로 컴파일됩니다. &lt;code&gt;*&lt;/code&gt; 접두사를 사용하면 모듈이 바이트 코드로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c0d264184b29e5240b822c85a976bae183083b" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 앞에 &lt;code&gt;~&lt;/code&gt; 를 추가 하면 규칙적인 게으른 동작이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="320069f40befc715427528e74af5fccc8e33c273" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior. The general rule is that we add an implicit bang on the outermost pattern, unless disabled with &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 앞에 &lt;code&gt;~&lt;/code&gt; 를 추가 하면 규칙적인 게으른 동작이 나타납니다. 일반적인 규칙은 &lt;code&gt;~&lt;/code&gt; 로 비활성화하지 않는 한 가장 바깥 쪽 패턴에 암시 적 뱅을 추가하는 것입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="d83058e490d2d8e416a97aa6b2da12e694c423cc" translate="yes" xml:space="preserve">
          <source>Adding a new kind of pure computation to an applicative functor.</source>
          <target state="translated">새로운 유형의 순수한 계산을 적용 펑터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3e22ec51f6417f07ed5484e9c1f31e458834a41e" translate="yes" xml:space="preserve">
          <source>Adding a type signature dramatically changes the result! This is a rather counter-intuitive phenomenon, worth watching out for.</source>
          <target state="translated">형식 서명을 추가하면 결과가 크게 바뀝니다! 이것은 조심해야 할 반 직관적 인 현상입니다.</target>
        </trans-unit>
        <trans-unit id="d9f79758ab7e2377c37e190db1c47d9123b9b0b2" translate="yes" xml:space="preserve">
          <source>Adding the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo; turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the &amp;ldquo;-fdefer-type-errors&amp;rdquo; flag is set before loading and unset after loading if the flag has not already been set before. See &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt; for further motivation and details.</source>
          <target state="translated">옵션 &quot; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;는로드하는 동안 유형 오류를 경고로 바꿉니다. 이를 통해 일부 정의에 유형 오류가 있더라도 올바른 모듈 부분을 사용할 수 있습니다. 실제로 &quot;-fdefer-type-errors&quot;플래그는로드 전에 설정되고 플래그가 이전에 설정되지 않은 경우로드 후에 설정 해제됩니다. 추가 동기 및 세부 사항 &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;은 런타임&lt;/a&gt; 에 유형 오류 연기를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="99385bb5ea9d50b509bba76a80c6d5cf02fdad9b" translate="yes" xml:space="preserve">
          <source>Adding the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo; turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the &amp;ldquo;-fdefer-type-errors&amp;rdquo; flag is set before loading and unset after loading if the flag has not already been set before. See &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt; for further motivation and details.</source>
          <target state="translated">옵션&amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;는로드하는 동안 유형 오류를 경고로 바꿉니다. 따라서 일부 정의에 유형 오류가 있더라도 올바른 모듈 부분을 사용할 수 있습니다. 실제로, &quot;-fdefer-type-errors&quot;플래그는로드 전에 설정되고 플래그가 이미 설정되지 않은 경우로드 후에 설정 해제됩니다. 추가 동기 및 세부 사항 &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;은 런타임&lt;/a&gt; 에 유형 오류 연기를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="00f220c3a56210a9843d04890d61a40e6f8811dd" translate="yes" xml:space="preserve">
          <source>Addition of type-level naturals.</source>
          <target state="translated">타입 레벨 내츄럴 추가.</target>
        </trans-unit>
        <trans-unit id="1d55c4561961d726b476a4d113ce4ac1271e1f3d" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">추가 &lt;code&gt;Integer&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="452f31724597f25fbb7b21a77fe4b6fccc9c9f11" translate="yes" xml:space="preserve">
          <source>Additional arguments to the pre-processor can be passed in using the &lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt;&lt;code&gt;-optF ⟨option⟩&lt;/code&gt;&lt;/a&gt; option. These are fed to ⟨cmd⟩ on the command line after the three standard input and output arguments.</source>
          <target state="translated">프리 프로세서에 대한 추가 인수는 &lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt; &lt;code&gt;-optF ⟨option⟩&lt;/code&gt; &lt;/a&gt; 옵션 을 사용하여 전달할 수 있습니다 . 이들은 3 개의 표준 입력 및 출력 인수 다음에 명령 행에서 ⟨cmd⟩에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ba84f116cccb8aaddf33910d85c19273f9b5c33d" translate="yes" xml:space="preserve">
          <source>Additional conversion operations to &lt;code&gt;Integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Integer&lt;/code&gt; 추가 변환 조작</target>
        </trans-unit>
        <trans-unit id="05dd2fde350699cecd8602584538e2a5301a7997" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시퀀스를 해체하기위한 추가 기능은 통해 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cf2915563496656545c5e0888c8da42599eb5f8" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시퀀스 분해를위한 추가 기능 은 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 인스턴스를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94293acb7d800e768e0370ed3629748a97bd0b8e" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시퀀스 분해를위한 추가 기능 은 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 인스턴스를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33810ea2f256277dbeeee354b4b9748e64cd54e7" translate="yes" xml:space="preserve">
          <source>Additional generic representation type constructors</source>
          <target state="translated">추가 일반 표현 유형 생성자</target>
        </trans-unit>
        <trans-unit id="fefa8177b546e09c697ef3ccda7dfb9a8468dadd" translate="yes" xml:space="preserve">
          <source>Additional submodules</source>
          <target state="translated">추가 서브 모듈</target>
        </trans-unit>
        <trans-unit id="d5fc75cb6b2328204ad6e4f5c7b8aa1503974318" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;ghc-pkg list&lt;/code&gt; reminds you that there are broken packages and suggests &lt;code&gt;ghc-pkg check&lt;/code&gt;, which displays more information about the nature of the failure:</source>
          <target state="translated">또한 &lt;code&gt;ghc-pkg list&lt;/code&gt; 은 패키지가 손상되었음을 &lt;code&gt;ghc-pkg check&lt;/code&gt; 제안합니다 . 이는 실패의 특성에 대한 자세한 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4dc57812bc7acb080b8b1b3c9a8dc29f687921a8" translate="yes" xml:space="preserve">
          <source>Additionally, any files specified with &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; flags will be read after the standard files, allowing the use of custom .ghci files.</source>
          <target state="translated">또한 &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt; 플래그로 지정된 파일 은 표준 파일 다음에 읽혀 지므로 사용자 지정 .ghci 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8273902569bf382d8f68303982acb32861c6cbb8" translate="yes" xml:space="preserve">
          <source>Additionally, in function definitions, variables bound by matching earlier curried arguments may be used in view pattern expressions in later arguments:</source>
          <target state="translated">또한 함수 정의에서 이전 커리 인수와 일치하여 바인딩 된 변수는 다음 인수의 뷰 패턴 표현식에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd25e90c276ad8a7d25e96fdbb8ecaf1a0b665bf" translate="yes" xml:space="preserve">
          <source>Additionally, since GHC 9.0.1, combining &lt;a href=&quot;#extension-LambdaCase&quot;&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;arrows#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; allows &lt;code&gt;\case&lt;/code&gt; syntax to be used as a command in &lt;code&gt;proc&lt;/code&gt; notation:</source>
          <target state="translated">또한 GHC 9.0.1부터 &lt;a href=&quot;#extension-LambdaCase&quot;&gt; &lt;code&gt;LambdaCase&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;arrows#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; 를&lt;/a&gt; 결합 하면 &lt;code&gt;\case&lt;/code&gt; 구문을 &lt;code&gt;proc&lt;/code&gt; 표기법 의 명령으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f89673843f1be6757860a64501f5bc027e357960" translate="yes" xml:space="preserve">
          <source>Additionally, the following flags are accepted by &lt;code&gt;ghc-pkg&lt;/code&gt;:</source>
          <target state="translated">또한 다음 플래그는 &lt;code&gt;ghc-pkg&lt;/code&gt; 에 의해 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd4c0753998481c0fdb1163a5b1e4a326161eee0" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;../extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;#10826&lt;/a&gt; for details.</source>
          <target state="translated">또한 Safe Haskell 제한 사항을 우회 할 수 있으므로 &lt;a href=&quot;../extending_ghc#annotation-pragmas&quot;&gt;주석&lt;/a&gt; 사용 이 금지됩니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;# 10826&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6098dd57b05f9b5adb478e7eb1c70e1499221dae" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;#10826&lt;/a&gt; for details.</source>
          <target state="translated">또한 Safe Haskell 제한을 우회 할 수 있으므로 &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;주석&lt;/a&gt; 사용 이 금지됩니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;# 10826&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea07a4f598cd1862ca91a8d811d4455a836c0db0" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;Issue #10826&lt;/a&gt; for details.</source>
          <target state="translated">또한 Safe Haskell 제한을 우회 할 수 있으므로 &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;주석&lt;/a&gt; 사용 은 금지됩니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;문제 # 10826&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba7d071e5cf6b03c15819e3ffdf6a64a0ef17bfa" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduce memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">또한이 구현은 비트 맵을 트리의 잎에 배치합니다. 크기는 기계어 (32 또는 64 비트)의 자연스러운 크기이며 밀도가 높은 세트 (예 : 많은 값이 서로 가까이있을 가능성이있는 세트)의 메모리 풋 프린트 및 실행 시간을 크게 줄입니다. 무증상은이 최적화의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9433cfd346f8c54358a2f7edce3cb77efb148924" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduces the memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">또한이 구현은 비트 맵을 트리의 잎에 배치합니다. 크기는 기계어 (32 또는 64 비트)의 자연스러운 크기이며 밀도가 높은 세트 (예 : 많은 값이 서로 가까이있을 수있는 세트)의 메모리 풋 프린트 및 실행 시간을 크게 줄입니다. 무증상은이 최적화의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bf2d76785594ad916dd8c2e5e99f51e13db7893" translate="yes" xml:space="preserve">
          <source>Additionally, unless &lt;code&gt;-hide-all-packages&lt;/code&gt; is specified &lt;code&gt;ghc&lt;/code&gt; will also look for the package environment in the following locations:</source>
          <target state="translated">또한 &lt;code&gt;-hide-all-packages&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;ghc&lt;/code&gt; 는 다음 위치에서 패키지 환경을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2aa983ad06fdb2dac09d7b6232814da70747e9ee" translate="yes" xml:space="preserve">
          <source>Additive</source>
          <target state="translated">Additive</target>
        </trans-unit>
        <trans-unit id="e571fb2f3cd62f8043f73be079635a2b1b76993b" translate="yes" xml:space="preserve">
          <source>Additive inverse:</source>
          <target state="translated">가산 역 :</target>
        </trans-unit>
        <trans-unit id="0d42cec26dbc762aafe43e05a50f969d0b7505d7" translate="yes" xml:space="preserve">
          <source>Addr</source>
          <target state="translated">Addr</target>
        </trans-unit>
        <trans-unit id="e78f3509a8a9919b87bca8268eb67a1992a398dd" translate="yes" xml:space="preserve">
          <source>Addr#</source>
          <target state="translated">Addr#</target>
        </trans-unit>
        <trans-unit id="9693f97edb3f213e60bf04638a2964d95c0a8e70" translate="yes" xml:space="preserve">
          <source>AddrRep</source>
          <target state="translated">AddrRep</target>
        </trans-unit>
        <trans-unit id="e1bcdaba63c737122befb027c96355aebd956e8a" translate="yes" xml:space="preserve">
          <source>Address range information necessary for efficient lookup in debug information.</source>
          <target state="translated">디버그 정보를 효율적으로 조회하는 데 필요한 주소 범위 정보.</target>
        </trans-unit>
        <trans-unit id="2bea019ec2ca9ce8cba25638cef6e4ebf912a40d" translate="yes" xml:space="preserve">
          <source>Adds a core plugin to the compilation pipeline.</source>
          <target state="translated">컴파일 파이프 라인에 핵심 플러그인을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f141d838836915fbdfd335ae66e883d10b2bee58" translate="yes" xml:space="preserve">
          <source>Adds a location description and maybe a file path and file handle to an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;. If any of the file handle or file path is not given the corresponding value in the &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; remains unaltered.</source>
          <target state="translated">위치 설명과 파일 경로 및 파일 핸들을 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 에 추가 합니다. 파일 핸들 또는 파일 경로가 제공되지 않으면 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 의 해당 값 이 변경되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="14518bca79b10a8d6a6afac2dc2d74ba60c9789a" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="translated">모든 &lt;em&gt;통화 사이트에&lt;/em&gt; 자동 &lt;code&gt;SCC&lt;/code&gt; 주석을 추가합니다 . 이는 스택 추적을 생성하기 위해 프로파일 링을 사용할 때 특히 유용합니다. 자세한 내용은 &lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt; 함수 또는 &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; RTS 플래그 ( &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;해커, 디버거 및 지나치게 관심이있는 영혼에 대한 RTS 옵션&lt;/a&gt; )를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4dd58b10c5df43531b5419e150eab3428f317659" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="translated">모든 &lt;em&gt;호출 사이트에&lt;/em&gt; 자동 &lt;code&gt;SCC&lt;/code&gt; 주석을 추가합니다 . 이는 스택 추적을 생성 할 목적으로 프로파일 링을 사용할 때 특히 유용합니다. 자세한 내용은 &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt; 함수 또는 &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; RTS 플래그 ( &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;해커, 디버거 및 과도하게 관심있는 영혼을위한 RTS 옵션&lt;/a&gt; )를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77b18e119a59d882bbdff5f7cdcc19671357a56c" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.15.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="translated">모든 &lt;em&gt;호출 사이트에&lt;/em&gt; 자동 &lt;code&gt;SCC&lt;/code&gt; 주석을 추가합니다 . 이는 스택 추적을 생성하기 위해 프로파일 링을 사용할 때 특히 유용합니다. 자세한 내용은 &lt;a href=&quot;../libraries/base-4.15.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt; 함수 또는 &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; RTS 플래그 ( &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;해커, 디버거 및 과도하게 관심을 가진 영혼을위한 RTS 옵션&lt;/a&gt; )를 참조하세요.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a4fd2a08806dfb482db344074817b7f6e5c01441" translate="yes" xml:space="preserve">
          <source>Adds ⟨file⟩ to the stack of package databases. Additionally, ⟨file⟩ will also be the database modified by a &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt; or &lt;code&gt;hide&lt;/code&gt; command, unless it is overridden by a later &lt;code&gt;--package-db&lt;/code&gt;, &lt;code&gt;--user&lt;/code&gt; or &lt;code&gt;--global&lt;/code&gt; option.</source>
          <target state="translated">패키지 데이터베이스 스택에 ⟨file⟩을 추가합니다. 또한, ⟨file⟩ 또한 의해 수정 데이터베이스 될 것 &lt;code&gt;register&lt;/code&gt; , &lt;code&gt;unregister&lt;/code&gt; , &lt;code&gt;expose&lt;/code&gt; 또는 &lt;code&gt;hide&lt;/code&gt; 가 나중에 의해 대체되지 않는 한, 명령 &lt;code&gt;--package-db&lt;/code&gt; , &lt;code&gt;--user&lt;/code&gt; 또는 &lt;code&gt;--global&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6b704187610182fd9bd374b8590aaa1ef187a2e9" translate="yes" xml:space="preserve">
          <source>Adjacency list representation of a graph, mapping each vertex to its list of successors.</source>
          <target state="translated">각 정점을 후속 작업 목록에 매핑하는 그래프의 인접 목록 표시</target>
        </trans-unit>
        <trans-unit id="b54a06cdf203c292a9600afc8f4877852335267a" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array</source>
          <target state="translated">배열의 크기를 조정</target>
        </trans-unit>
        <trans-unit id="90ae8e7c61f1d870875dbba75294d0ee30d78240" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array in the given pool.</source>
          <target state="translated">주어진 풀에서 배열의 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="0f13658ace97bdbb476bffd14472478597823d14" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array including an extra position for the end marker.</source>
          <target state="translated">끝 마커의 추가 위치를 포함하여 배열의 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="8f64f3b151b220c78b035080db416951b86c9133" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array with an end marker in the given pool.</source>
          <target state="translated">주어진 풀에서 종료 마커가있는 배열의 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="22c056b1203c0d0dbe4975dcb12541b083750969" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size of the required type.</source>
          <target state="translated">풀에있는 요소의 저장 영역을 필요한 유형의 지정된 크기로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="7b78d30e021c76a4d2cd9b8d7c83d0401635e998" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size.</source>
          <target state="translated">풀에있는 요소의 저장 영역을 지정된 크기로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="483b6c748f94c6096a813d4e1202da0abec1197a" translate="yes" xml:space="preserve">
          <source>Administration: errors, locations and IO</source>
          <target state="translated">관리 : 오류, 위치 및 IO</target>
        </trans-unit>
        <trans-unit id="e796c7c730ff7dabd900a81e118126dd63495d56" translate="yes" xml:space="preserve">
          <source>Advance a pointer into an array by the given number of elements</source>
          <target state="translated">주어진 요소 수만큼 배열로 포인터를 전진</target>
        </trans-unit>
        <trans-unit id="260fc09cb1bd463d426655ad971e67b80c27f04d" translate="yes" xml:space="preserve">
          <source>Advances the given address by the given offset in bytes.</source>
          <target state="translated">주어진 오프셋만큼 바이트 단위로 주어진 주소를 전진시킵니다.</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="1f3b7ab3442ed00e15ed0541b2686cab5245f648" translate="yes" xml:space="preserve">
          <source>Advice parameter for &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; 조작에 대한 조언 매개 변수 .</target>
        </trans-unit>
        <trans-unit id="641791da837ed200728e9e50c3a7a04bddd511ba" translate="yes" xml:space="preserve">
          <source>AdviceDontNeed</source>
          <target state="translated">AdviceDontNeed</target>
        </trans-unit>
        <trans-unit id="ea4292d4f711440375ee49d21953e80b5e52f970" translate="yes" xml:space="preserve">
          <source>AdviceNoReuse</source>
          <target state="translated">AdviceNoReuse</target>
        </trans-unit>
        <trans-unit id="74d7e2511ff18bffd6e754606fb5eef4017e56ae" translate="yes" xml:space="preserve">
          <source>AdviceNormal</source>
          <target state="translated">AdviceNormal</target>
        </trans-unit>
        <trans-unit id="81df8c0f743f838767314197c10a01806cad2ee1" translate="yes" xml:space="preserve">
          <source>AdviceRandom</source>
          <target state="translated">AdviceRandom</target>
        </trans-unit>
        <trans-unit id="ccfd39209774bc0bd28a1949494a57c9a708ab38" translate="yes" xml:space="preserve">
          <source>AdviceSequential</source>
          <target state="translated">AdviceSequential</target>
        </trans-unit>
        <trans-unit id="42c90330aa2e9c8f79a56b93334f2cee6565ec83" translate="yes" xml:space="preserve">
          <source>AdviceWillNeed</source>
          <target state="translated">AdviceWillNeed</target>
        </trans-unit>
        <trans-unit id="ed7d231de2d15caa7608638f366b36b040083e12" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;ldquo;</source>
          <target state="translated">&amp;ldquo;각 클래스 제약 조건 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; &amp;rdquo;다음에&amp;ldquo;또는 각 정량화 된 제약 조건 &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt; &amp;rdquo;을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="962b02c7a62413f64f2ece2fa9269c59c618e145" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;rdquo;</source>
          <target state="translated">&quot;각 클래스 제약 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; 에 대해&quot;뒤에 &quot; 또는 각 수량화 된 제약 &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt; &quot;을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5b0f8ce28395257ee72603489cfcfd39f2ac90c3" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, the current context is set to:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 후 현재 컨텍스트는 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="07383eb16f1578a01af993380c0758317c77da4a" translate="yes" xml:space="preserve">
          <source>After analysing this declaration, GHC will discover that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; can be kind-polymorphic, with &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;c :: k2&lt;/code&gt;. We thus infer the following kind:</source>
          <target state="translated">이 선언을 분석 한 후 GHC는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; 및 &lt;code&gt;c :: k2&lt;/code&gt; 와 함께 친절한 다형성이 될 수 있음을 발견합니다 . 따라서 우리는 다음과 같은 종류를 유추합니다.</target>
        </trans-unit>
        <trans-unit id="43eb39a82773f2a643009be434c6a85d6547dd46" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 은 기본 바이트 버퍼를 원래 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 공유합니다 . 따라서 C에서 또는 poke를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 내용이 변경되어 참조 투명성 이 손상 됩니다. 공유로 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 ByteString )에도 이러한 변경 사항이 반영됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명도가 손상됩니다. 이를 피하려면 &lt;code&gt;useAsCString&lt;/code&gt; 을 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . 그러면 원래 ByteString 의 사본이 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="f34b11d2d5cf5b9fa61ceda45199281dda85ee6f" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 은 기본 바이트 버퍼를 원래 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 공유합니다 . 따라서 C에서 또는 poke를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 수정하면 ByteString 의 내용이 변경되어 참조 투명성 이 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 됩니다. 공유로 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 ByteString )에도 이러한 변경 사항이 반영됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명성이 손상됩니다. 이를 피하려면 &lt;code&gt;useAsCStringLen&lt;/code&gt; 을 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . 그러면 원래 ByteString 의 사본이 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="82a058ea48e1049a3153e84c6e2e32200ba90877" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 은 원본 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 기본 바이트 버퍼를 공유합니다 . 따라서 C에서 또는 poke를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 내용이 변경되어 참조 투명도가 깨집니다. 공유에 의해 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 것)도 이러한 변경 사항을 반영합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명성이 손상됩니다. 이를 방지하기 위해 사용 &lt;code&gt;useAsCString&lt;/code&gt; 원본의 복사본을 만들고, &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0cb3d574900104a74408c8731d7eda427531f654" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 은 원본 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 기본 바이트 버퍼를 공유합니다 . 따라서 수정 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 어느 C에서, 또는 포크를 이용하여 내용 발생할 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 참조 투명성을 깨고 변화. 공유에 의해 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 것)도 이러한 변경 사항을 반영합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명성이 손상됩니다. 이를 방지하기 위해 사용 &lt;code&gt;useAsCStringLen&lt;/code&gt; 원본의 복사본을 만들고, &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b0813da186b2fd975a2b14a0effb46982b0d9725" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;&lt;a href=&quot;data-bytestring#v:useAsCString&quot;&gt;useAsCString&lt;/a&gt;&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 은 원본 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 기본 바이트 버퍼를 공유합니다 . 따라서 C에서 또는 poke를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 내용이 변경되어 참조 투명도가 깨집니다. 공유에 의해 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 것)도 이러한 변경 사항을 반영합니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명성이 손상됩니다. 이를 방지하기 위해 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:useAsCString&quot;&gt;useAsCString&lt;/a&gt;&lt;/code&gt; 원본의 복사본을 만들고, &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="3bcf6e4ef8c43a1cd9147a5828b1a7983f16e46a" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;&lt;a href=&quot;data-bytestring#v:useAsCStringLen&quot;&gt;useAsCStringLen&lt;/a&gt;&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 은 원본 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 기본 바이트 버퍼를 공유합니다 . 따라서 수정 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 어느 C에서, 또는 포크를 이용하여 내용 발생할 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 참조 투명성을 깨고 변화. 공유에 의해 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 것)도 이러한 변경 사항을 반영합니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명성이 손상됩니다. 이를 방지하기 위해 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:useAsCStringLen&quot;&gt;useAsCStringLen&lt;/a&gt;&lt;/code&gt; 원본의 복사본을 만들고, &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="6923804e768f3da3c4e34a50b537baa1cecaa53f" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;f&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">동의어를 확장 한 후 &lt;code&gt;f&lt;/code&gt; 는 다음과 같은 합법적 (GHC) 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e94a959addb55b4d2ce5f3c538f5e0b4451a9198" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;foo&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">동의어를 확장 한 후 &lt;code&gt;foo&lt;/code&gt; 는 유효한 (GHC에서) 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="06d0d43c4a9a4534a91da534db4a4831101176f7" translate="yes" xml:space="preserve">
          <source>After expanding type synonyms, GHC does validity checking on types, looking for the following malformedness which isn&amp;rsquo;t detected simply by kind checking:</source>
          <target state="translated">형식 동의어를 확장 한 후 GHC는 형식에 대한 유효성 검사를 수행하여 단순히 종류 검사로 감지되지 않는 다음과 같은 잘못된 형식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0449647915398655b7a878613d9a9af3cfaf3fda" translate="yes" xml:space="preserve">
          <source>After running a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action there are three possibilities for what comes next:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 조치를 실행 한 후 다음에 올 가능성이 세 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4bbb708c55cef458c6b0bed0fa5801c96a405ff" translate="yes" xml:space="preserve">
          <source>After starting &lt;code&gt;remote-iserv ⟨tmp_dir⟩ ⟨port⟩&lt;/code&gt; on the target and providing it with a temporary folder (where it will copy the necessary libraries to load to) and port it will listen for the proxy to connect.</source>
          <target state="translated">대상에서 &lt;code&gt;remote-iserv ⟨tmp_dir⟩ ⟨port⟩&lt;/code&gt; 를 시작 하고 임시 폴더 (로드 할 필요한 라이브러리를 복사 할 위치)와 포트를 제공 한 후 프록시가 연결할 수 있도록 수신 대기합니다.</target>
        </trans-unit>
        <trans-unit id="8f8861d66315ce749c004b7e24b472e22e1345c7" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve finished invoking our Haskell functions, we can call &lt;code&gt;hs_exit()&lt;/code&gt;, which terminates the RTS.</source>
          <target state="translated">Haskell 함수 호출을 완료 한 후 &lt;code&gt;hs_exit()&lt;/code&gt; 호출 하면 RTS가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa08ab3cb629ae0630f4dccf9a63999f34ccc01" translate="yes" xml:space="preserve">
          <source>Again, if &lt;code&gt;C&lt;/code&gt; contains no class methods, the instance context will be redundant, so GHC will instead generate &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt;.</source>
          <target state="translated">다시 &lt;code&gt;C&lt;/code&gt; 에 클래스 메소드가 없으면 인스턴스 컨텍스트가 중복되므로 GHC는 대신 &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="80611142c1da75771c803bc1306de5dd47e954cb" translate="yes" xml:space="preserve">
          <source>Alexander Berntsen 2014</source>
          <target state="translated">알렉산더 베른 슨 2014</target>
        </trans-unit>
        <trans-unit id="0f9d329fecfee776bcba1d14e6bca4840fae8ece" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;#12717&lt;/a&gt;</source>
          <target state="translated">서명에 지정된 대수 데이터 유형은 패턴 동의어를 사용하여 구현할 수 없습니다. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;# 12717&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="70df90ba28c32aa3934681405622b497740ae050" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;Issue #12717&lt;/a&gt;</source>
          <target state="translated">서명에 지정된 대수 데이터 형식은 패턴 동의어를 사용하여 구현할 수 없습니다. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;문제 # 12717&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="a995fe628ebfb0ac7cc0c0b98a66a1d60308575a" translate="yes" xml:space="preserve">
          <source>Algebraic properties:</source>
          <target state="translated">대수 속성 :</target>
        </trans-unit>
        <trans-unit id="6437c830d041bd055bd0fc417ef4e386c80c8f74" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#ghc-flag--ddump-cmm-opt&quot;&gt;&lt;code&gt;-ddump-cmm-opt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--ddump-cmm-opt&quot;&gt; &lt;code&gt;-ddump-cmm-opt&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="00fe36cee0a001e71e45449595c2a673824d1b79" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="308d7f644aaa00a5665368fb713217dcb84b51ce" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="9cdf35744dcefb67854cfd9303dbe37b27518062" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="107c8c77b99ddea22e0d4483b070454ccd2a71ae" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="23f78602884a7b538f91b984806e37d22c871f3b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="0c1b2d82c320084f6a2ecaa9b2bb2ee948dec368" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt; 별명 .</target>
        </trans-unit>
        <trans-unit id="60cc1b8e67da53fd1ea040fa3bfb7016cc924b7f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 의 별칭 .</target>
        </trans-unit>
        <trans-unit id="dc75b7adfd72cadf1d0c28de54a66b5886fa0528" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt;. Returns True if its parameter is 1# and False if it is 0#.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt; 별명입니다 . 매개 변수가 1 #이면 True를, 0 #이면 False를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5417a2480ca72a7d0a8e8c2b271f31533da5d02" translate="yes" xml:space="preserve">
          <source>Align functions at given boundary.</source>
          <target state="translated">주어진 경계에서 기능을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="309cb56d1cbd5360ce8e4fa89688161c57474b68" translate="yes" xml:space="preserve">
          <source>Align functions to multiples of the given value. Only valid values are powers of two.</source>
          <target state="translated">주어진 값의 배수에 함수를 정렬합니다. 유효한 값만 2의 거듭 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="e59028d7705dee24116bda8c5fbd199fa57a7e8b" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; statements consume their right-hand side, or scrutiny, &lt;code&gt;Many&lt;/code&gt; times. That is, the following will not type check:</source>
          <target state="translated">모든 &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;where&lt;/code&gt; 문은 오른쪽 또는 정밀 조사를 &lt;code&gt;Many&lt;/code&gt; 번 사용합니다. 즉, 다음은 유형 검사를하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be7cbc9171e2709ef932f92879b2fa92b735095e" translate="yes" xml:space="preserve">
          <source>All are based directly on their similarly-named &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; counterparts.</source>
          <target state="translated">모두 비슷한 이름의 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; 대응을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="a6cd8f76353135f8eca4c08f035ed3722d4ad99a" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where &lt;code&gt;n&lt;/code&gt; is the number of bits in the type.</source>
          <target state="translated">모든 산술은 모듈로 2 ^ n으로 수행되며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 유형의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="5c996c3cc62dedfc6f0f7accd3202c5cbe66b76c" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where n is the number of bits in the type. One non-obvious consequence of this is that &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; raise an error on negative arguments.</source>
          <target state="translated">모든 산술은 모듈로 2 ^ n으로 수행되며, 여기서 n은 유형의 비트 수입니다. 이 중 하나가 아닌 명백한 결과는 즉 &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; 해야 &lt;em&gt;하지&lt;/em&gt; 부정적 인수에 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0cb70b7dc62c8932f9a5fdafd462f49e1a9ac846" translate="yes" xml:space="preserve">
          <source>All data that is read will be decoded as UTF-8.</source>
          <target state="translated">읽은 모든 데이터는 UTF-8로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="63944b6a06201ae38dfb9a4d0c8e79dcd222ae47" translate="yes" xml:space="preserve">
          <source>All formats</source>
          <target state="translated">모든 형식</target>
        </trans-unit>
        <trans-unit id="3da05872e313e33621f92f71c99a716c25b4c06e" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell과 외국어 사이의 모든 마샬링은 결국 Haskell 데이터 구조를 외국어의 해당 데이터 구조의 이진 표현으로 변환하거나 그 반대로 변환합니다. Haskell에서이 마샬링을 코딩하려면 구조화되지 않은 메모리 블록에 저장된 기본 데이터 유형을 조작해야합니다. &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 는 인스턴스화되는 모든 유형 (하스켈의 표준 기본 유형, 고정 크기 &lt;code&gt;Int&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ), 고정 크기 &lt;code&gt;Word&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; ) 에서 이러한 조작 을 용이하게합니다., &lt;code&gt;&lt;a href=&quot;data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 모두에서 유형 &lt;a href=&quot;foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cffe145534643d9c1142d3476b91e58e7cb0edd7" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;../base-4.13.0.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell과 외국어 사이의 모든 마샬링은 결국 Haskell 데이터 구조를 외국어의 해당 데이터 구조의 이진 표현으로 변환하거나 그 반대로 변환합니다. Haskell에서이 마샬링을 코딩하려면 구조화되지 않은 메모리 블록에 저장된 기본 데이터 유형을 조작해야합니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 는 인스턴스화되는 모든 유형 (하스켈의 표준 기본 유형, 고정 크기 &lt;code&gt;Int&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ), 고정 크기 &lt;code&gt;Word&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; ) 에서 이러한 조작 을 용이하게합니다., &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 모두에서 유형 &lt;a href=&quot;../base-4.13.0.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ce405ee1194b3ce0523423637671f91407135a7" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;../base-4.14.1.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell과 외국어 간의 모든 마샬링은 궁극적으로 Haskell 데이터 구조를 해당 외국어 데이터 구조의 이진 표현으로 변환하는 것으로 귀결됩니다. 그 반대의 경우도 마찬가지입니다. Haskell에서이 마샬링을 코딩하려면 구조화되지 않은 메모리 블록에 저장된 원시 데이터 유형을 조작해야합니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 는 Haskell의 표준 기본 유형, 고정 크기 &lt;code&gt;Int&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ), 고정 크기 &lt;code&gt;Word&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; ) 인 인스턴스화되는 모든 유형에서이 조작을 용이하게합니다., &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 모두에서 유형 &lt;a href=&quot;../base-4.14.1.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a4bb5186ba5f9598821b21b590dc381adb80441" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;../base-4.15.0.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell과 외국어 간의 모든 마샬링은 궁극적으로 Haskell 데이터 구조를 해당 외국어 데이터 구조의 이진 표현으로 변환하는 것으로 귀결됩니다. 그 반대의 경우도 마찬가지입니다. Haskell에서이 마샬링을 코딩하려면 구조화되지 않은 메모리 블록에 저장된 원시 데이터 유형을 조작해야합니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 는 인스턴스화되는 모든 유형, 즉 Haskell의 표준 기본 유형, 고정 크기 &lt;code&gt;Int&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ), 고정 크기 &lt;code&gt;Word&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; )에서이조작 을 용이하게합니다., &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 모두에서 유형 &lt;a href=&quot;../base-4.15.0.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd19ff0d458c57b97295494e47d40838d1850a87" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct &lt;em&gt;safe imports&lt;/em&gt; are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접 &lt;em&gt;안전한 수입은&lt;/em&gt; C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="1ef5ded9d2dd453646aebbde6bc1e77e258d91ac" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct imports are trusted by C</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 의 모든 직수입은 C가 신뢰합니다</target>
        </trans-unit>
        <trans-unit id="ef4a7530bfdff42a708223449593af312fe8738b" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct safe imports are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접 안전한 수입은 C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="a5408f6679dcddf6cf10903e40871b1051e396da" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct &lt;em&gt;safe imports&lt;/em&gt; are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접 &lt;em&gt;안전한 수입은&lt;/em&gt; C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="e797d2c20c300f4f341eb1a8bbafe469bcca673e" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct imports are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접적인 수입은 C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="1624840fe46a64a971c34a839de2cd6166d7cc15" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct safe imports are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접 안전한 수입은 C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="d26ff1c50009409908cc1dc4184f2fa494a5bb4b" translate="yes" xml:space="preserve">
          <source>All of M&amp;rsquo;s direct imports are trusted by C</source>
          <target state="translated">M의 모든 직수입품은 C가 신뢰합니다</target>
        </trans-unit>
        <trans-unit id="6bbff3b9a2342fa6a7328cc64d9d064b0c59177f" translate="yes" xml:space="preserve">
          <source>All of the following are permissible:</source>
          <target state="translated">다음은 모두 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="07a302413e8b75e6da91c912ef456b8df520f40e" translate="yes" xml:space="preserve">
          <source>All of the functions fail on an empty queue.</source>
          <target state="translated">빈 큐에서 모든 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="459b9c097e1f48899719948d13092addea8d683b" translate="yes" xml:space="preserve">
          <source>All of the heaps are defined to be non-empty, which speeds up the merge functions.</source>
          <target state="translated">모든 힙이 비어 있지 않은 것으로 정의되어 병합 기능의 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="a6d572146a4416cc21d822c5b9122cc28fefd404" translate="yes" xml:space="preserve">
          <source>All of the monad transformers except &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; are functors on the category of monads: in addition to defining a mapping of monads, they also define a mapping from transformations between base monads to transformations between transformed monads, called &lt;code&gt;map&lt;/code&gt;&lt;em&gt;XXX&lt;/em&gt;&lt;code&gt;T&lt;/code&gt;. Thus given a monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;, the combinator &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; constructs a monad transformation</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; 를 제외한 모든 모나드 변환기는 모나드 범주의 펑터입니다. 모나드 매핑을 정의하는 것 외에도 기본 모나드 간 변환에서 변환 된 모나드 간 변환 ( &lt;code&gt;map&lt;/code&gt; &lt;em&gt;XXX &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; )으로 의 매핑을 정의합니다 . 따라서 모나드 변환 주어진 &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; 상기 콤비 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; 는 모나드 변환을 구축</target>
        </trans-unit>
        <trans-unit id="9ff4cf753e2cbc29b4117cb6c949a3dcfef8b652" translate="yes" xml:space="preserve">
          <source>All of the single-parameter functions for decoding bytestrings encoded in one of the Unicode Transformation Formats (UTF) operate in a &lt;em&gt;strict&lt;/em&gt; mode: each will throw an exception if given invalid input.</source>
          <target state="translated">UTFF (Unicode Transformation Formats) 중 하나로 인코딩 된 바이트 스트링을 디코딩하기위한 모든 단일 매개 변수 함수는 &lt;em&gt;엄격한&lt;/em&gt; 모드 에서 작동합니다 . 유효하지 않은 입력이 있으면 각각 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1146584e3cb478bf3265f7c6f72fec49b0f80d2" translate="yes" xml:space="preserve">
          <source>All of the type variables mentioned are bound by the class declaration, and none is locally quantified. Examples:</source>
          <target state="translated">언급 된 모든 유형 변수는 클래스 선언에 의해 바인딩되며 로컬로 수량화 된 것은 없습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d683e41b047bddec21ed6f58cd355ac5da8d7ca4" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">한 줄에서 모두 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 는 무시되고 명시적인 새 줄 ( &lt;code&gt;$$&lt;/code&gt; )은 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="d04619ab3f8398e576bbe00b547d8d28a39b93a6" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">한 줄에서 모두 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 는 무시되고 명시적인 새 줄 ( &lt;code&gt;$$&lt;/code&gt; )은 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="8734d083f84649d66cdee2cb45a731a5deb1ea31" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">한 줄에서 모두 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 는 무시되고 명시적인 새 줄 ( &lt;code&gt;$$&lt;/code&gt; )은 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="1204352a7da2dcfde36198d2e6c39544ea4e7814" translate="yes" xml:space="preserve">
          <source>All other instances of &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; behave as they do for &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">다른 모든 인스턴스 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 행동하라 그들은을 위해 할로 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ccfa841ab2b631ea408bbbe074e7afe6c507835f" translate="yes" xml:space="preserve">
          <source>All other instances of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; behave as they do for &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">다른 모든 인스턴스 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 행동하라 그들은을 위해 할로 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bd92a106884eb39d74915dc625e8a2eeded96d9" translate="yes" xml:space="preserve">
          <source>All other type errors are reported immediately, and cannot be deferred; for example, an ill-kinded type signature, an instance declaration that is non-terminating or ill-formed, a type-family instance that does not obey the declared injectivity constraints, etc etc.</source>
          <target state="translated">다른 모든 유형 오류는 즉시보고되며 지연 될 수 없습니다. 예를 들어, 불친절한 유형 서명, 종결되지 않거나 잘못 구성된 인스턴스 선언, 선언 된 주 입성 제약 조건을 준수하지 않는 유형 군 인스턴스 등</target>
        </trans-unit>
        <trans-unit id="100083b95ff688c1be21a4288351839a84f80d50" translate="yes" xml:space="preserve">
          <source>All previously loaded modules, except package modules, are forgotten. The new set of modules is known as the target set. Note that &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; can be used without any arguments to unload all the currently loaded modules and bindings.</source>
          <target state="translated">패키지 모듈을 제외한 이전에로드 된 모든 모듈을 잊어 버렸습니다. 새로운 모듈 세트를 대상 세트라고합니다. 참고 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 현재로드 된 모든 모듈과 바인딩을 언로드 인수없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6827c99a0f2492e5c37fe7d9438e06c6b6af14e1" translate="yes" xml:space="preserve">
          <source>All rules are implicitly exported from the module, and are therefore in force in any module that imports the module that defined the rule, directly or indirectly. (That is, if A imports B, which imports C, then C&amp;rsquo;s rules are in force when compiling A.) The situation is very similar to that for instance declarations.</source>
          <target state="translated">모든 규칙은 모듈에서 암시 적으로 내보내 지므로 규칙을 정의한 모듈을 직접 또는 간접적으로 가져 오는 모든 모듈에서 적용됩니다. (즉, A가 C를 가져 오는 B를 가져 오면 A를 컴파일 할 때 C의 규칙이 적용됩니다.) 상황은 예를 들어 선언과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7dbe1320fffcde509144ec4167268e2f24928720" translate="yes" xml:space="preserve">
          <source>All special processing is triggered by the &lt;code&gt;#&lt;/code&gt; operator. To output a literal &lt;code&gt;#&lt;/code&gt;, write it twice: &lt;code&gt;##&lt;/code&gt;. Inside string literals and comments &lt;code&gt;#&lt;/code&gt; characters are not processed.</source>
          <target state="translated">모든 특수 처리는 &lt;code&gt;#&lt;/code&gt; 연산자 에 의해 트리거됩니다 . 리터럴 &lt;code&gt;#&lt;/code&gt; 을 출력하려면 &lt;code&gt;##&lt;/code&gt; 을 두 번 작성하십시오 . 내부 문자열 리터럴 및 주석 &lt;code&gt;#&lt;/code&gt; 문자는 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e754d606e9f071f8917ddf678a8be51138905754" translate="yes" xml:space="preserve">
          <source>All storage allocated by functions that allocate based on a &lt;em&gt;size in bytes&lt;/em&gt; must be sufficiently aligned for any of the basic foreign types that fits into the newly allocated storage. All storage allocated by functions that allocate based on a specific type must be sufficiently aligned for that type. Array allocation routines need to obey the same alignment constraints for each array element.</source>
          <target state="translated">&lt;em&gt;크기를 바이트 단위로&lt;/em&gt; 할당하는 함수에 의해 할당 된 모든 스토리지 는 새로 할당 된 스토리지에 맞는 기본 외부 유형에 맞게 충분히 정렬되어야합니다. 특정 유형을 기반으로 할당하는 기능에 의해 할당 된 모든 스토리지는 해당 유형에 맞게 충분히 정렬되어야합니다. 배열 할당 루틴은 각 배열 요소에 대해 동일한 정렬 제약 조건을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="0f41064ade872ca46f2cce357b6f0f602bb6c9f2" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt;, including a header.</source>
          <target state="translated">헤더를 포함한 모든 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8191f2288d30ed04618d8a7f6947ee07d2f827e8" translate="yes" xml:space="preserve">
          <source>All the classes &lt;code&gt;Ci&lt;/code&gt; are standard.</source>
          <target state="translated">모든 클래스 &lt;code&gt;Ci&lt;/code&gt; 는 표준입니다.</target>
        </trans-unit>
        <trans-unit id="27b13a294aaa6ffa8890f192e7f1dee01b865654" translate="yes" xml:space="preserve">
          <source>All the instance does is apply and remove the &lt;code&gt;newtype&lt;/code&gt; constructor. It is particularly galling that, since the constructor doesn&amp;rsquo;t appear at run-time, this instance declaration defines a dictionary which is &lt;em&gt;wholly equivalent&lt;/em&gt; to the &lt;code&gt;Int&lt;/code&gt; dictionary, only slower!</source>
          <target state="translated">모든 인스턴스는 &lt;code&gt;newtype&lt;/code&gt; 생성자를 적용하고 제거합니다 . 런타임에 표시되지 않습니다 생성자는이 인스턴스 선언은 사전 정의 이후 특히, 그렇게 못살게 괴롭히는됩니다 &lt;em&gt;전적으로 해당&lt;/em&gt; 받는 &lt;code&gt;Int&lt;/code&gt; 수 만 느린 사전을!</target>
        </trans-unit>
        <trans-unit id="3560dcf83b04004c14094e6b1d3cd4500f468374" translate="yes" xml:space="preserve">
          <source>All these features are described in the papers mentioned earlier.</source>
          <target state="translated">이러한 모든 기능은 앞에서 언급 한 논문에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f289fff56ff75be648fe75fd05b62eefadc5aae" translate="yes" xml:space="preserve">
          <source>All these features are enabled by default if the &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; extension is enabled. The types and more detailed examples on how to use comprehensions are explained in the previous chapters &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt; and &lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;. In general you just have to replace the type &lt;code&gt;[a]&lt;/code&gt; with the type &lt;code&gt;Monad m =&amp;gt; m a&lt;/code&gt; for monad comprehensions.</source>
          <target state="translated">&lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; &lt;/a&gt; 확장이 활성화 된 경우 이러한 모든 기능이 기본적 으로 활성화됩니다. 이해를 사용하는 방법에 대한 유형과 자세한 예는 이전 장의 &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;일반화 (SQL과 유사한) 목록 이해&lt;/a&gt; 및 &lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;병렬 목록 이해에서 설명&lt;/a&gt; 합니다. 일반적으로 모나드 이해를 위해 &lt;code&gt;[a]&lt;/code&gt; 유형을 &lt;code&gt;Monad m =&amp;gt; m a&lt;/code&gt; 유형으로 교체하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="feb134ce7e85ca12d2afc3f255be965a242a95ce" translate="yes" xml:space="preserve">
          <source>All these features are enabled by default if the &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; extension is enabled. The types and more detailed examples on how to use comprehensions are explained in the previous chapters &lt;a href=&quot;generalised_list_comprehensions#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt; and &lt;a href=&quot;parallel_list_comprehensions#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;. In general you just have to replace the type &lt;code&gt;[a]&lt;/code&gt; with the type &lt;code&gt;Monad m =&amp;gt; m a&lt;/code&gt; for monad comprehensions.</source>
          <target state="translated">이러한 모든 기능은 &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; &lt;/a&gt; 확장이 활성화 된 경우 기본적 으로 활성화됩니다. 이해를 사용하는 방법에 대한 유형과 자세한 예는 이전 장 &lt;a href=&quot;generalised_list_comprehensions#generalised-list-comprehensions&quot;&gt;일반화 (SQL 유사) 목록 이해&lt;/a&gt; 및 &lt;a href=&quot;parallel_list_comprehensions#parallel-list-comprehensions&quot;&gt;병렬 목록 이해에서 설명되었습니다&lt;/a&gt; . 일반적으로 모나드 이해를 위해 &lt;code&gt;[a]&lt;/code&gt; 유형을 &lt;code&gt;Monad m =&amp;gt; m a&lt;/code&gt; 유형으로 바꾸면 됩니다.</target>
        </trans-unit>
        <trans-unit id="f320750508ae8a4bdfcecfb3e8588bc22cc54930" translate="yes" xml:space="preserve">
          <source>All these functions evaluate the message completely before printing it; so if the message is not fully defined, none of it will be printed.</source>
          <target state="translated">이러한 모든 기능은 메시지를 인쇄하기 전에 완전히 평가합니다. 따라서 메시지가 완전히 정의되지 않으면 아무 것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e55f75e6b6187e12dad6c83393f2395b07acab0" translate="yes" xml:space="preserve">
          <source>All these primitive data types and operations are exported by the library &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-prim-0.7.0/GHC-Prim.html&quot;&gt;GHC.Prim&lt;/a&gt;. (This documentation is generated from the file &lt;code&gt;compiler/GHC/Builtin/primops.txt.pp&lt;/code&gt;.)</source>
          <target state="translated">이러한 모든 기본 데이터 유형 및 작업은 &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-prim-0.7.0/GHC-Prim.html&quot;&gt;GHC.Prim&lt;/a&gt; 라이브러리에서 내 보냅니다 . (이 문서는 &lt;code&gt;compiler/GHC/Builtin/primops.txt.pp&lt;/code&gt; 파일에서 생성되었습니다 .)</target>
        </trans-unit>
        <trans-unit id="fcd3e8296e242f3b3d9e914ad0a98eb399c9d926" translate="yes" xml:space="preserve">
          <source>All these primitive data types and operations are exported by the library &lt;code&gt;GHC.Prim&lt;/code&gt;, for which there is detailed online documentation &amp;lt;GHC.Prim.&amp;gt;. (This documentation is generated from the file &lt;code&gt;compiler/prelude/primops.txt.pp&lt;/code&gt;.)</source>
          <target state="translated">이러한 모든 기본 데이터 유형 및 작업은 &lt;code&gt;GHC.Prim&lt;/code&gt; 라이브러리에 의해 내보내지며 자세한 온라인 문서 &amp;lt;GHC.Prim.&amp;gt;이 있습니다. (이 문서는 &lt;code&gt;compiler/prelude/primops.txt.pp&lt;/code&gt; 파일에서 생성됩니다 .)</target>
        </trans-unit>
        <trans-unit id="11d822b519b4d27d4c90f7025aa2f37e057b1573" translate="yes" xml:space="preserve">
          <source>All this applies to constructors declared using the syntax of &lt;a href=&quot;#existential-with-context&quot;&gt;Existentials and type classes&lt;/a&gt;. For example, the &lt;code&gt;NumInst&lt;/code&gt; data type above could equivalently be declared like this:</source>
          <target state="translated">이 모든 것은 &lt;a href=&quot;#existential-with-context&quot;&gt;Existentials 및 type 클래스&lt;/a&gt; 의 구문을 사용하여 선언 된 생성자에 적용됩니다 . 예를 들어 위 의 &lt;code&gt;NumInst&lt;/code&gt; 데이터 형식은 다음과 같이 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd09b60db993145d9aa0ee7759554858065ea03" translate="yes" xml:space="preserve">
          <source>All this applies to constructors declared using the syntax of &lt;a href=&quot;existential_quantification#existential-with-context&quot;&gt;Existentials and type classes&lt;/a&gt;. For example, the &lt;code&gt;NumInst&lt;/code&gt; data type above could equivalently be declared like this:</source>
          <target state="translated">이 모든 것은 &lt;a href=&quot;existential_quantification#existential-with-context&quot;&gt;Existentials 및 유형 클래스&lt;/a&gt; 의 구문을 사용하여 선언 된 생성자에 적용됩니다 . 예를 들어, 위 의 &lt;code&gt;NumInst&lt;/code&gt; 데이터 유형은 다음과 같이 동등하게 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70df367f1e5c153af04770d26e6bb6e5662b24b1" translate="yes" xml:space="preserve">
          <source>All this behaviour contrasts with Haskell 98&amp;rsquo;s peculiar treatment of contexts on a data type declaration (Section 4.2.1 of the Haskell 98 Report). In Haskell 98 the definition</source>
          <target state="translated">이 모든 동작은 데이터 유형 선언 (Haskell 98 보고서의 섹션 4.2.1)에 대한 Haskell 98의 고유 한 컨텍스트 처리와 대조됩니다. Haskell 98에서 정의</target>
        </trans-unit>
        <trans-unit id="3d7f2d606f261a5fba2db68b6939910c2cd2ece4" translate="yes" xml:space="preserve">
          <source>All this looks quite promising; we have a class and a range of interesting implementations. Unfortunately, there are some serious problems with the class declaration. First, the empty function has an ambiguous type:</source>
          <target state="translated">이 모든 것이 매우 유망 해 보입니다. 우리는 클래스와 다양한 흥미로운 구현을 가지고 있습니다. 불행히도 클래스 선언에 심각한 문제가 있습니다. 먼저 빈 함수에는 모호한 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c67f8504ed498a898f1ab818b85763d53fddcf77" translate="yes" xml:space="preserve">
          <source>All three of these examples would compile without issue. On the other hand:</source>
          <target state="translated">이 세 가지 예 모두 문제없이 컴파일됩니다. 반면에 :</target>
        </trans-unit>
        <trans-unit id="9677956077fa96efb5b69b5a1ae7ad4b38e3313b" translate="yes" xml:space="preserve">
          <source>All types are classified as one of these classes: 32bit word, 64bit word, 32bit float, 64bit float, pointer.</source>
          <target state="translated">모든 유형은 32 비트 워드, 64 비트 워드, 32 비트 플로트, 64 비트 플로트, 포인터 클래스 중 하나로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="057ac441b399eb9586ae68f5c1eb9f47b4178362" translate="yes" xml:space="preserve">
          <source>All unbound identifiers are treated as typed holes, &lt;em&gt;whether or not they start with an underscore&lt;/em&gt;. The only difference is in the error message:</source>
          <target state="translated">모든 언 바운드 식별자는 &lt;em&gt;밑줄로 시작하든 아니든&lt;/em&gt; 유형이 지정된 구멍으로 처리됩니다 . 유일한 차이점은 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="fd53184b2d10dc248ec6c9e2385390b9b65b470a" translate="yes" xml:space="preserve">
          <source>AllPhases</source>
          <target state="translated">AllPhases</target>
        </trans-unit>
        <trans-unit id="86266bd7ede6bd6ba8469405abe76d387f23e4e4" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory and marshal a value into it (the combination of &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt;). The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">메모리 블록을 할당하고 값을 마샬링합니다 ( &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; 의 조합 ). 할당 된 영역의 크기 는 적절한 유형에 대한 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 인스턴스의 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 메소드에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd8c715cc3db061ff535eb5c0524be9fac0fa2b8" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory of the given number of bytes. The block of memory is sufficiently aligned for any of the basic foreign types that fits into a memory block of the allocated size.</source>
          <target state="translated">주어진 바이트 수의 메모리 블록을 할당하십시오. 메모리 블록은 할당 된 크기의 메모리 블록에 맞는 기본 외부 유형에 맞게 충분히 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="48f50994b06d1d5671f516b19482a827582f3624" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory that is sufficient to hold values of type &lt;code&gt;a&lt;/code&gt;. The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">a 유형 &lt;code&gt;a&lt;/code&gt; 값을 보유하기에 충분한 메모리 블록을 할당하십시오 . 할당 된 영역의 크기 는 적절한 유형에 대한 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 인스턴스의 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 메소드에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="945eac0de6e1530ab37e60133056c31933f7e0c0" translate="yes" xml:space="preserve">
          <source>Allocate a fresh memory pool.</source>
          <target state="translated">새로운 메모리 풀을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="bf161f8d2ef1099082c0d5528c3c029bcc71adc8" translate="yes" xml:space="preserve">
          <source>Allocate a new buffer of the given size.</source>
          <target state="translated">주어진 크기의 새 버퍼를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="797966dc728422a87321bee745962bf7b9b2105b" translate="yes" xml:space="preserve">
          <source>Allocate consecutive storage for a list of values in the given pool and marshal these values into it, terminating the end with the given marker.</source>
          <target state="translated">주어진 풀의 값 목록에 연속 스토리지를 할당하고 해당 값을 마샬링하여 지정된 마커로 끝을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="f5067d72f839d0ca801793aa2138ada31d2918c8" translate="yes" xml:space="preserve">
          <source>Allocate consecutive storage for a list of values in the given pool and marshal these values into it.</source>
          <target state="translated">주어진 풀의 값 목록에 연속 스토리지를 할당하고이 값을 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="4f94873e14ae1ca0d376362647204a8cbf513639" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">일부 메모리를 할당하고 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 반환 하십시오 . &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 폐기 하면 메모리가 자동으로 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="adc10905359d2ad848031b0da8c89829871951ed" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">일부 메모리를 할당하고 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 반환 하십시오 . &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 폐기 하면 메모리가 자동으로 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a74b5000fcb22d46c63fd1403958268121cb0e" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">일부 메모리를 할당하고 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 반환 하십시오 . &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 폐기 하면 메모리가 자동으로 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="18d53cff546da86cca443415642d6098c6313605" translate="yes" xml:space="preserve">
          <source>Allocate space for storable type in the given pool. The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">주어진 풀에 저장 가능한 유형을위한 공간을 할당하십시오. 할당 된 영역의 크기 는 적절한 유형에 대한 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 인스턴스의 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 메소드에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0faf0f0921366d35115d853c768adb58bbc217c" translate="yes" xml:space="preserve">
          <source>Allocate storage and marshal a storable value wrapped into a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">저장소를 할당하고 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 싸인 저장 가능한 값을 마샬링</target>
        </trans-unit>
        <trans-unit id="85a29b1e9713abbc38e1d1724333822128176095" translate="yes" xml:space="preserve">
          <source>Allocate storage for a value in the given pool and marshal the value into this storage.</source>
          <target state="translated">지정된 풀의 값에 스토리지를 할당하고이 스토리지에 값을 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="a751dea2f39999181b1d506f2ded5ae31093a057" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type (like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, but for multiple elements).</source>
          <target state="translated">저장 가능한 유형의 주어진 수의 요소에 대해 스토리지를 할당하십시오 ( &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 같지만 여러 요소에 대해).</target>
        </trans-unit>
        <trans-unit id="b8bd206b599ec8ecb129ced0e29abca1ece50440" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type in the pool, but leave room for an extra element to signal the end of the array.</source>
          <target state="translated">풀에 저장 가능한 유형의 지정된 수의 요소에 대해 스토리지를 할당하지만 추가 요소가 배열의 끝을 알리는 공간을 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="3c6502a8f26acdc89616720173572f6835f4395f" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type in the pool.</source>
          <target state="translated">풀에 저장 가능한 유형의 지정된 수의 요소에 대해 스토리지를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="dfb0511a4ae80d311521dfea2fd5a589ea804b6a" translate="yes" xml:space="preserve">
          <source>Allocate the given number of bytes of storage in the pool.</source>
          <target state="translated">풀에 지정된 수의 스토리지 바이트를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="74c31d0f81c37ba9952fac9ee09d5580d40e7044" translate="yes" xml:space="preserve">
          <source>Allocate the nursery from node-local memory.</source>
          <target state="translated">노드 로컬 메모리에서 보육을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="489efe43727a84928b21db7c885a4647eec79612" translate="yes" xml:space="preserve">
          <source>Allocating managed memory</source>
          <target state="translated">관리 메모리 할당</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="a371c9709f159b54fa290c4ef85af0337a88411e" translate="yes" xml:space="preserve">
          <source>Allocation accounting is accurate only to about 4Kbytes.</source>
          <target state="translated">할당 회계는 약 4Kbyte까지만 정확합니다.</target>
        </trans-unit>
        <trans-unit id="672bb521be73595aa99b0bcb407ba5c8a04ff65e" translate="yes" xml:space="preserve">
          <source>Allocation counter and limit</source>
          <target state="translated">할당 카운터 및 제한</target>
        </trans-unit>
        <trans-unit id="6be4e23bfb8b2d85b4d8e47ee554151801bbfd62" translate="yes" xml:space="preserve">
          <source>Allocation counter and limits</source>
          <target state="translated">할당 카운터 및 제한</target>
        </trans-unit>
        <trans-unit id="f863a7852bc37e781471622e1a75707f51a4b50b" translate="yes" xml:space="preserve">
          <source>Allocation counter and quota</source>
          <target state="translated">할당 카운터 및 할당량</target>
        </trans-unit>
        <trans-unit id="6714f70908a1447bb325aa721caef6aa021fb67a" translate="yes" xml:space="preserve">
          <source>AllocationLimitExceeded</source>
          <target state="translated">AllocationLimitExceeded</target>
        </trans-unit>
        <trans-unit id="78fee5f8d19c1012e15c9cb754371db736ef10f0" translate="yes" xml:space="preserve">
          <source>AllocationStrategy</source>
          <target state="translated">AllocationStrategy</target>
        </trans-unit>
        <trans-unit id="1e0ddb13f2d7482f1d9d4401e43c0f7c159e3d27" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;#&lt;/code&gt; as a postfix modifier on identifiers.</source>
          <target state="translated">식별자에 &lt;code&gt;#&lt;/code&gt; 를 접미사 수정 자로 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="487b72f96ce687ab0a0c0c91a3747ce245eb86bd" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;do&lt;/code&gt; blocks and other constructs as function arguments.</source>
          <target state="translated">허용 &lt;code&gt;do&lt;/code&gt; 함수 인수로 블록과 다른 구조를.</target>
        </trans-unit>
        <trans-unit id="f3d4d6a5ae1b8e8556bffe5a2051a8a7eeb9bcd1" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;do&lt;/code&gt; expressions, lambda expressions, etc. to be directly used as a function argument.</source>
          <target state="translated">허용 &lt;code&gt;do&lt;/code&gt; 직접 함수의 인수로서 사용되는 등의 식 람다 식.</target>
        </trans-unit>
        <trans-unit id="57b2197ae6b5696247d5182d09e77a732fad1d01" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;forall&lt;/code&gt; quantifiers in constraints.</source>
          <target state="translated">제약 조건에 모든 수량 &lt;code&gt;forall&lt;/code&gt; 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="48fb284220c7e71266222e272e89501b5da2de4e" translate="yes" xml:space="preserve">
          <source>Allow all superclass constraints, including those that may result in non-termination of the typechecker.</source>
          <target state="translated">타입 체커가 종료되지 않는 것을 포함한 모든 수퍼 클래스 제약을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="80eb231dd3933ab2efd3d5dfa5c44bae12bc9d69" translate="yes" xml:space="preserve">
          <source>Allow an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be deferred lazily. When passed an action of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;, the action will only be performed when the value of &lt;code&gt;a&lt;/code&gt; is demanded.</source>
          <target state="translated">허용 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 계산은 느리게 지연된다. 유형의 작용에 전달하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 값 때, 동작은 수행되는 &lt;code&gt;a&lt;/code&gt; 요구된다.</target>
        </trans-unit>
        <trans-unit id="7a2ecf66e99906eb20d2eca046ddaa3ae040e446" translate="yes" xml:space="preserve">
          <source>Allow an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be deferred lazily. When passed an action of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;, the action will only be performed when the value of &lt;code&gt;a&lt;/code&gt; is demanded.</source>
          <target state="translated">허용 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 계산은 느리게 지연된다. 유형의 작용에 전달하면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 값 때, 동작은 수행되는 &lt;code&gt;a&lt;/code&gt; 요구된다.</target>
        </trans-unit>
        <trans-unit id="257c67e3f1b7316fe3182000abf107e20bc8ca0d" translate="yes" xml:space="preserve">
          <source>Allow an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be deferred lazily. When passed an action of type &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;, the action will only be performed when the value of &lt;code&gt;a&lt;/code&gt; is demanded.</source>
          <target state="translated">허용 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 계산은 느리게 지연된다. 유형의 작용에 전달하면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 값 때, 동작은 수행되는 &lt;code&gt;a&lt;/code&gt; 요구된다.</target>
        </trans-unit>
        <trans-unit id="1750d76ce07b95cdb172cc776a34f360d5d4cd29" translate="yes" xml:space="preserve">
          <source>Allow asynchronous exceptions to be raised even inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, making the operation interruptible (see the discussion of &quot;Interruptible operations&quot; in &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에서도 비동기 예외가 발생하도록 허용 하여 조작을 인터럽트 가능하게하십시오 ( &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 의 &quot;인터럽터 블 조작&quot;에 대한 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="780a200a64ac9433b47b1da40e2581b24c295f40" translate="yes" xml:space="preserve">
          <source>Allow asynchronous exceptions to be raised even inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, making the operation interruptible (see the discussion of &quot;Interruptible operations&quot; in &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에서도 비동기 예외가 발생하도록 허용 하여 조작을 인터럽트 가능하게하십시오 ( &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 의 &quot;인터럽터 블 조작&quot;에 대한 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="8baf535a4dbc587a727d88078ccbc03106a8d4ba" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Foldable&lt;/code&gt; typeclass.</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; 유형 클래스에 대한 인스턴스 자동 파생을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="4f96512299d9639cbf383164f1db522bd120f323" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Functor&lt;/code&gt; typeclass.</source>
          <target state="translated">&lt;code&gt;Functor&lt;/code&gt; 타입 클래스에 대한 인스턴스의 자동 파생을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="cb4259796e51e2d950e57edd562f9cf8982dd300" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Generic&lt;/code&gt; typeclass.</source>
          <target state="translated">&lt;code&gt;Generic&lt;/code&gt; 클래스에 대한 인스턴스 자동 파생을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="a7632af3ddef7069071f3bf8a7c397be4ca59fcd" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Traversable&lt;/code&gt; typeclass.</source>
          <target state="translated">&lt;code&gt;Traversable&lt;/code&gt; 유형 클래스에 대한 인스턴스 자동 파생을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="add95d26da022101d791b89213499080da94e3a9" translate="yes" xml:space="preserve">
          <source>Allow constant folding in case expressions that scrutinise some primops: For example,</source>
          <target state="translated">일부 primops를 면밀히 조사하는 식에는 상수 접기를 허용하십시오. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="934cc159b35ac28d99ae334c8a54aa36d7a7c39a" translate="yes" xml:space="preserve">
          <source>Allow constraints to quantify over types.</source>
          <target state="translated">구속 조건이 유형에 대해 수량화되도록 허용</target>
        </trans-unit>
        <trans-unit id="2ce51b30b9da5f59ff139ceec6637a831ee564b6" translate="yes" xml:space="preserve">
          <source>Allow contexts on &lt;code&gt;data&lt;/code&gt; types.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 유형 에 대한 컨텍스트를 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eab095a3e387bb8b63300500e130636d41df289c" translate="yes" xml:space="preserve">
          <source>Allow defaulting to take place for more than just numeric classes.</source>
          <target state="translated">숫자 클래스 이상의 기본 설정을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="926119bf4ff3119fe5a37dc0cb8f3089e82d4ec6" translate="yes" xml:space="preserve">
          <source>Allow definition of empty &lt;code&gt;data&lt;/code&gt; types.</source>
          <target state="translated">빈 &lt;code&gt;data&lt;/code&gt; 형식의 정의를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="36885bc6f326d61d2bc2d18c723dc0b2ce083841" translate="yes" xml:space="preserve">
          <source>Allow definition of functions expecting implicit parameters.</source>
          <target state="translated">암시 적 매개 변수를 기대하는 함수의 정의를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8fdd0e51a265a2c590d00cb6abc3adad2684d61" translate="yes" xml:space="preserve">
          <source>Allow definition of record types with identically-named fields.</source>
          <target state="translated">동일한 이름의 필드를 가진 레코드 유형의 정의를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="726294c3f294ef13dd773189e75ae54c6d6e3bbd" translate="yes" xml:space="preserve">
          <source>Allow definition of type class instances for type synonyms.</source>
          <target state="translated">타입 동의어에 대한 타입 클래스 인스턴스의 정의를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7f2a1ee40ed67cae653a504bd6f3545fe705b983" translate="yes" xml:space="preserve">
          <source>Allow definition of type class instances with arbitrary nested types in the instance head.</source>
          <target state="translated">인스턴스 헤드에 임의의 중첩 유형이있는 유형 클래스 인스턴스를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86966622a20e13b1ac31de8f45367c263a8977cf" translate="yes" xml:space="preserve">
          <source>Allow deriving instances of standard type classes for empty data types.</source>
          <target state="translated">빈 데이터 형식에 대한 표준 형식 클래스 인스턴스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="60943beab02466a2c26e0ab7a51efa95c6e2a7fe" translate="yes" xml:space="preserve">
          <source>Allow empty case alternatives.</source>
          <target state="translated">빈 대소 문자를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="025c491c399c735d766d5a9892dd9e6ee33b7e08" translate="yes" xml:space="preserve">
          <source>Allow empty case expressions.</source>
          <target state="translated">빈 대소 문자 표현을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6c84f72d8d262e69d1f9faa234eff6fdf37f2369" translate="yes" xml:space="preserve">
          <source>Allow existentially quantified type variables in types.</source>
          <target state="translated">실재적으로 정량화 된 유형 변수를 유형에 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ab319c3adc39803249aca0e24d447b1fb428579" translate="yes" xml:space="preserve">
          <source>Allow explicit kind signatures on type variables.</source>
          <target state="translated">유형 변수에 명시 적 종류 서명을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="17fa756b705f1fa52e127048ab38d27914f60aba" translate="yes" xml:space="preserve">
          <source>Allow functional dependency annotations on type families. This allows one to define injective type families.</source>
          <target state="translated">유형 패밀리에서 기능적 종속성 주석을 허용합니다. 이를 통해 주입 유형 패밀리를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb8b184e2bcabb5b3fa790e938afe5ac1becfb4" translate="yes" xml:space="preserve">
          <source>Allow impredicative polymorphic types.</source>
          <target state="translated">즉석 다형성 유형을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="2433b80c1b9d57252941872fdc1b781f2a3699e6" translate="yes" xml:space="preserve">
          <source>Allow kind polymorphic types.</source>
          <target state="translated">종류 다형성 유형을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="cdff7073df11b6e1c05a0eceb6acaa80701d67af" translate="yes" xml:space="preserve">
          <source>Allow multiple &lt;code&gt;deriving&lt;/code&gt;, each optionally qualified with a &lt;em&gt;strategy&lt;/em&gt;.</source>
          <target state="translated">각각 선택적으로 &lt;em&gt;전략을&lt;/em&gt; 갖춘 여러 &lt;code&gt;deriving&lt;/code&gt; 허용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76ba8a634a12bd3f74b9359ac050a7de5e913037" translate="yes" xml:space="preserve">
          <source>Allow naming of wildcards (e.g. &lt;code&gt;_x&lt;/code&gt;) in type signatures.</source>
          <target state="translated">타입 시그니처 에 와일드 카드 (예 : &lt;code&gt;_x&lt;/code&gt; ) 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70463e61ddc2770c5bfd923aebb592b3ba442123" translate="yes" xml:space="preserve">
          <source>Allow nested contexts to be at the same indentation level as its enclosing context.</source>
          <target state="translated">중첩 된 컨텍스트가 둘러싸는 컨텍스트와 동일한 들여 쓰기 수준이되도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a24b90b3b696d68b4a53058736b07d9593258864" translate="yes" xml:space="preserve">
          <source>Allow other process to set Window to Foreground by using &lt;code&gt;&lt;a href=&quot;graphics-win32-window-foregroundwindow#v:setForegroundWindow&quot;&gt;setForegroundWindow&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;graphics-win32-window-foregroundwindow#v:setForegroundWindow&quot;&gt;setForegroundWindow&lt;/a&gt;&lt;/code&gt; 함수 를 사용하여 다른 프로세스가 Window를 Foreground로 설정하도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3466dbeb7cfb661d1b3d5d9ae06ef44c39d689be" translate="yes" xml:space="preserve">
          <source>Allow parallel list comprehension syntax.</source>
          <target state="translated">병렬 목록 이해 구문을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ed92111f1838c96b6c033cdfe95611654ed8c96" translate="yes" xml:space="preserve">
          <source>Allow promotion of data types to kind level.</source>
          <target state="translated">데이터 유형을 친절한 수준으로 승격시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="260dca80fe27608e688cf5033c080a2cfba5b239" translate="yes" xml:space="preserve">
          <source>Allow role annotation syntax.</source>
          <target state="translated">역할 주석 구문을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="87a0f4cf411c10836ab0efbb3303960a1c45e4a3" translate="yes" xml:space="preserve">
          <source>Allow the compiler to apply rewrite rules to the source program.</source>
          <target state="translated">컴파일러가 소스 프로그램에 다시 쓰기 규칙을 적용하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6b09bb1ac28b5b0c583dc8ebf98fba2849116608" translate="yes" xml:space="preserve">
          <source>Allow the compiler to automatically choose between identically-named record selectors based on type (if the choice is unambiguous).</source>
          <target state="translated">컴파일러가 유형에 따라 동일한 이름을 가진 레코드 선택기 중에서 자동으로 선택할 수 있도록합니다 (선택이 명확하지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="83c47b742b143b98b73e92a9a5de1c9e32c641ec" translate="yes" xml:space="preserve">
          <source>Allow the definition of pattern synonyms.</source>
          <target state="translated">패턴 동의어의 정의를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe2a8646e41c100c7ad5651319a6e065e997f85a" translate="yes" xml:space="preserve">
          <source>Allow the definition of typeclasses with more than one parameter.</source>
          <target state="translated">둘 이상의 매개 변수를 사용하여 유형 클래스를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d185ff37afe97c8a5c9c099b699c25563f19c7b7" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 계산 결과를 계산 내에서 (게으르게) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce75fe6b08dfb2e2c5aeb7a05bc37771108792fd" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation. Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 계산 결과를 계산 내에서 (게으르게) 사용할 수 있습니다. 참고이 경우 &lt;code&gt;f&lt;/code&gt; 는 엄격한, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71db9c7ef93f554ac579b40d6689938982ec9dda" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation. Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 계산 결과를 계산 내에서 (게으르게) 사용할 수 있습니다. 참고이 경우 &lt;code&gt;f&lt;/code&gt; 는 엄격한, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67e53378677db7eb448650e4848cf3af89d1c7b5" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 계산 결과를 계산 내에서 (게으르게) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a25778334adcda643e0a1777a4a1308851238bc9" translate="yes" xml:space="preserve">
          <source>Allow the use and definition of types with operator names.</source>
          <target state="translated">연산자 이름으로 유형을 사용하고 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffa6e2a8241cb1d89e5bfc36b1a5b18d2b5d635a" translate="yes" xml:space="preserve">
          <source>Allow the use of GADT syntax in data type definitions (but not GADTs themselves; for this see &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">데이터 타입 정의에서 GADT 신택스를 사용할 수 있도록 (하지만 GADTs 자체,이보기위한 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4252aea65ec49612e55dd6f6e924842c8bdd89da" translate="yes" xml:space="preserve">
          <source>Allow the use of GADT syntax in data type definitions (but not GADTs themselves; for this see &lt;a href=&quot;gadt#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">데이터 유형 정의에서 GADT 구문 사용을 허용합니다 (GADT 자체는 허용하지 않음. 이에 대해서는 &lt;a href=&quot;gadt#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="59b4b3836b0ad08f877b34af9e4fa8b8a8d4a012" translate="yes" xml:space="preserve">
          <source>Allow the use of binary notation in integer literals.</source>
          <target state="translated">정수 리터럴에서 이진 표기법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcd29c7bce33303e5d32e6ccbc57335b0acff65" translate="yes" xml:space="preserve">
          <source>Allow the use of complex constraints in class declaration contexts.</source>
          <target state="translated">클래스 선언 컨텍스트에서 복잡한 제약 조건을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="702e6903368de34c7b00d4d1faab5cc980b6ff20" translate="yes" xml:space="preserve">
          <source>Allow the use of floating-point literal syntax for integral types.</source>
          <target state="translated">정수 유형에 부동 소수점 리터럴 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2df53ac2aa65699d533256ce56f3e679075bdf" translate="yes" xml:space="preserve">
          <source>Allow the use of lambda-case syntax.</source>
          <target state="translated">lambda-case 구문 사용을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="76a7a3b4a067b229370029d02bfb2c0e97e8bc7f" translate="yes" xml:space="preserve">
          <source>Allow the use of multi-way-&lt;code&gt;if&lt;/code&gt; syntax.</source>
          <target state="translated">다 방향 &lt;code&gt;if&lt;/code&gt; 구문 사용을 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4acbbed0487deb8857b5f7e688836829f142c6f1" translate="yes" xml:space="preserve">
          <source>Allow the use of package-qualified &lt;code&gt;import&lt;/code&gt; syntax.</source>
          <target state="translated">패키지 규정 된 &lt;code&gt;import&lt;/code&gt; 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea333a314c924e9102b9616473c6ae74d1b2886" translate="yes" xml:space="preserve">
          <source>Allow the use of post-fix operators</source>
          <target state="translated">사후 수정 연산자 사용 허용</target>
        </trans-unit>
        <trans-unit id="86a9c510a8bddeadb8d33b32c38ba64ebef29791" translate="yes" xml:space="preserve">
          <source>Allow the use of qualified &lt;code&gt;do&lt;/code&gt; notation.</source>
          <target state="translated">정규화 된 &lt;code&gt;do&lt;/code&gt; 표기법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adb08d203af69b5b4cd4dd423b7318efffc8b20f" translate="yes" xml:space="preserve">
          <source>Allow the use of recursive &lt;code&gt;do&lt;/code&gt; notation.</source>
          <target state="translated">재귀의 사용을 허용 &lt;code&gt;do&lt;/code&gt; 표기법을.</target>
        </trans-unit>
        <trans-unit id="b0029babcf620375a925cb0f309e07f9eef805a4" translate="yes" xml:space="preserve">
          <source>Allow the use of stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations.</source>
          <target state="translated">독립형 &lt;code&gt;deriving&lt;/code&gt; 선언 사용을 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ffc26d958cddfc3a794521475014c76922cd906" translate="yes" xml:space="preserve">
          <source>Allow the use of standalone kind signatures.</source>
          <target state="translated">독립형 종류 서명 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="86686087092ab757a3c44071e8cdb958a2e740ab" translate="yes" xml:space="preserve">
          <source>Allow the use of tuple section syntax</source>
          <target state="translated">튜플 섹션 구문 사용 허용</target>
        </trans-unit>
        <trans-unit id="f62761563b5f41d61ca0ecbb5ad968019d4409d7" translate="yes" xml:space="preserve">
          <source>Allow the use of type application syntax.</source>
          <target state="translated">애플리케이션 구문 유형을 사용하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="5675777ef0f98250d6e550ff440d842beeff404c" translate="yes" xml:space="preserve">
          <source>Allow the use of underscores in numeric literals.</source>
          <target state="translated">숫자 리터럴에 밑줄을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eee4b36605984e0b63f2119e25dc26be8151e070" translate="yes" xml:space="preserve">
          <source>Allow the use of wildcards in record construction and pattern matching.</source>
          <target state="translated">레코드 구성 및 패턴 일치에 와일드 카드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6687c47ecd5f08e5cbe5a2d433f777d1b2ba65" translate="yes" xml:space="preserve">
          <source>Allow the user to write ambiguous types, and the type inference engine to infer them.</source>
          <target state="translated">사용자가 모호한 유형을 작성하고 유형 유추 엔진이이를 유추 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="86a368ced00c7e3c3b92de7fbdde36c04126fbd7" translate="yes" xml:space="preserve">
          <source>Allow turning known into unknown calls while performing late lambda lifting.</source>
          <target state="translated">늦은 람다 리프팅을 수행하는 동안 알려진 전화를 알 수없는 전화로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cbe6d10b7f1a1883fd95b6bb21627c693dfd0bb" translate="yes" xml:space="preserve">
          <source>Allow turning known into unknown calls while performing late lambda lifting. This is deemed non-beneficial, so it&amp;rsquo;s off by default.</source>
          <target state="translated">늦은 람다 리프팅을 수행하는 동안 알려진 전화를 알 수없는 전화로 전환 할 수 있습니다. 이것은 유익하지 않은 것으로 간주되므로 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="274c2026d3d9723dc92cd98f7d9326abfd5773f8" translate="yes" xml:space="preserve">
          <source>Allow type signatures for members in instance definitions.</source>
          <target state="translated">인스턴스 정의에서 멤버에 대한 유형 서명을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="da5bb70ccf69edfc067bb0ecac09b8b7fa946e39" translate="yes" xml:space="preserve">
          <source>Allow type signatures which appear that they would result in an unusable binding.</source>
          <target state="translated">사용 불가능한 바인딩을 초래할 것으로 보이는 유형 서명을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="7f9ebd8bc90d2c97f8f8af6055daef8a66d58b11" translate="yes" xml:space="preserve">
          <source>Allow types of arbitrary rank.</source>
          <target state="translated">임의 순위의 유형을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="72c06cac8ca4e2cc8c6349ed8e7e17158f9a5bef" translate="yes" xml:space="preserve">
          <source>Allow types of kind &lt;code&gt;Constraint&lt;/code&gt; to be used in contexts.</source>
          <target state="translated">컨텍스트 에 종류 &lt;code&gt;Constraint&lt;/code&gt; 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7e55900edd38daa3e986afd90affccc2a45f441" translate="yes" xml:space="preserve">
          <source>Allow use and definition of indexed type and data families.</source>
          <target state="translated">인덱싱 된 유형 및 데이터 제품군의 사용 및 정의를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3b140d99bb4b6d5ef2bf11c89c4fa48c5d311a8e" translate="yes" xml:space="preserve">
          <source>Allow use and definition of type classes with no parameters. This extension has been replaced by &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수가없는 유형 클래스의 사용 및 정의를 허용합니다. 이 확장은 &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6e40b71ea659cf26b3075e17e0c63e65704ae662" translate="yes" xml:space="preserve">
          <source>Allow use of &lt;code&gt;Applicative&lt;/code&gt;&lt;code&gt;do&lt;/code&gt; notation.</source>
          <target state="translated">&lt;code&gt;Applicative&lt;/code&gt; &lt;code&gt;do&lt;/code&gt; 표기법 사용을 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bed755b4d0a566202ee360d2e8141648215487c" translate="yes" xml:space="preserve">
          <source>Allow use of Generalised Algebraic Data Types (GADTs).</source>
          <target state="translated">GADT (Generalized Algebraic Data Types) 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b42306fa5c185a7862be6bb52526be30dbac6894" translate="yes" xml:space="preserve">
          <source>Allow use of any typeclass in &lt;code&gt;deriving&lt;/code&gt; clauses.</source>
          <target state="translated">절 을 &lt;code&gt;deriving&lt;/code&gt; 때 모든 유형 클래스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a457c798a55fb26f0dd47dc4032be39a59a6341" translate="yes" xml:space="preserve">
          <source>Allow use of bang pattern syntax.</source>
          <target state="translated">뱅 패턴 구문 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c23bf1d512a631794fb404638276aacd4f32df67" translate="yes" xml:space="preserve">
          <source>Allow use of functional dependencies in class declarations.</source>
          <target state="translated">클래스 선언에서 기능적 종속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d060a642a2f52d17e449b4e275108c16d94164a" translate="yes" xml:space="preserve">
          <source>Allow use of generalised list (SQL-like) comprehension syntax. This introduces the &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt; keywords.</source>
          <target state="translated">일반화 된 목록 (SQL과 유사한) 이해 구문을 사용할 수 있습니다. 이것으로 , &lt;code&gt;by&lt;/code&gt; 및 키워드 &lt;code&gt;using&lt;/code&gt; &lt;code&gt;group&lt;/code&gt; 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="6416480874a524bb16d12732baf7a1a42b48283b" translate="yes" xml:space="preserve">
          <source>Allow use of record puns.</source>
          <target state="translated">레코드 찌꺼기 사용을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="62089014435f225ba326e9329061e5e4a53f0bb5" translate="yes" xml:space="preserve">
          <source>Allow use of static pointer syntax.</source>
          <target state="translated">정적 포인터 구문 사용을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="8f3abc6ee81a5c4909fa0b404e4d5cc274c88e29" translate="yes" xml:space="preserve">
          <source>Allow use of the &lt;code&gt;forall&lt;/code&gt; keyword in places where universal quantification is implicit.</source>
          <target state="translated">보편적 인 정량이 암시되는 장소에서 &lt;code&gt;forall&lt;/code&gt; 키워드를 사용하도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f830fe1b81f5dd2916e893293dc917cf10ac1a5f" translate="yes" xml:space="preserve">
          <source>Allow use of the Haskell foreign function interface.</source>
          <target state="translated">Haskell 외부 기능 인터페이스 사용을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="d2ec09e108221e720d271bb74180facf527b037f" translate="yes" xml:space="preserve">
          <source>Allow use of view pattern syntax.</source>
          <target state="translated">뷰 패턴 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28bc70794bb29c8fd92ff3803dba6b69736ec2e" translate="yes" xml:space="preserve">
          <source>Allow users to invoke a finalizer promptly if they know that the foreign pointer is unreachable, i.e. &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:finalizeForeignPtr&quot;&gt;finalizeForeignPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자가 외부 포인터에 도달 할 수 없다는 것을 알고있는 경우 즉시 종료자를 호출 할 수 있도록합니다 (예 : &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:finalizeForeignPtr&quot;&gt;finalizeForeignPtr&lt;/a&gt;&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="d8d0040f1860796d1680868b0c0c97a27e733ecd" translate="yes" xml:space="preserve">
          <source>Allow worker-wrapper to convert a function closure into a thunk if the function does not use any of its arguments. Off by default.</source>
          <target state="translated">함수가 인수를 사용하지 않으면 worker-wrapper가 함수 클로저를 썽 크로 변환하도록 허용하십시오. 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf61d77eeec666128b4e93e100c46e62621a2b9" translate="yes" xml:space="preserve">
          <source>Allow writing floating point literals using hexadecimal notation.</source>
          <target state="translated">16 진 표기법을 사용하여 부동 소수점 리터럴을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b76e5dbcac70fa19335f3f6dd1767846c2ae45" translate="yes" xml:space="preserve">
          <source>AllowAmbiguousTypes</source>
          <target state="translated">AllowAmbiguousTypes</target>
        </trans-unit>
        <trans-unit id="f568f29db39d6daee9c168b5db2b40a0f82b6e78" translate="yes" xml:space="preserve">
          <source>Allows the definition of default method signatures in class definitions.</source>
          <target state="translated">클래스 정의에서 기본 메소드 서명을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39a8bda3c1c817a2744fbe48c428dd732e29b994" translate="yes" xml:space="preserve">
          <source>Allows the definition of further constraints on individual class methods.</source>
          <target state="translated">개별 클래스 메소드에 대한 추가 제한 조건을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="795662519537fb732dd1a2476e8a6962c0c19569" translate="yes" xml:space="preserve">
          <source>Allows the use definition of type classes with no parameters. This extension has been replaced by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수없이 유형 클래스의 사용 정의를 허용합니다. 이 확장은 &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2018e3c7850e7133b41fccedea329900b1f4d76e" translate="yes" xml:space="preserve">
          <source>Alone</source>
          <target state="translated">Alone</target>
        </trans-unit>
        <trans-unit id="ac58ae5ab26ea9f98150373e68429bafad7728e6" translate="yes" xml:space="preserve">
          <source>Along with traverseMaybeMissing, witnesses the isomorphism between &lt;code&gt;WhenMissing f k x y&lt;/code&gt; and &lt;code&gt;k -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt;.</source>
          <target state="translated">traverseMaybeMissing과 함께 &lt;code&gt;WhenMissing f k x y&lt;/code&gt; 와 &lt;code&gt;k -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt; 사이의 동형이 관찰 됩니다.</target>
        </trans-unit>
        <trans-unit id="7eaf4e6487782093547b308bb962d31222393a9b" translate="yes" xml:space="preserve">
          <source>Along with traverseMaybeMissing, witnesses the isomorphism between &lt;code&gt;WhenMissing f x y&lt;/code&gt; and &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt;.</source>
          <target state="translated">traverseMaybeMissing과 함께 &lt;code&gt;WhenMissing f x y&lt;/code&gt; 와 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt; 사이의 동형이 관찰 됩니다.</target>
        </trans-unit>
        <trans-unit id="fceb538d6e1da23d3f3babb9155dbc45ee7239e4" translate="yes" xml:space="preserve">
          <source>Along with zipWithMaybeAMatched, witnesses the isomorphism between &lt;code&gt;WhenMatched f k x y z&lt;/code&gt; and &lt;code&gt;k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">zipWithMaybeAMatched와 함께 WhenMatched &lt;code&gt;WhenMatched f k x y z&lt;/code&gt; 와 &lt;code&gt;k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; 사이의 동형이 관찰 됩니다.</target>
        </trans-unit>
        <trans-unit id="88e74dd86e7cd0c0ee3739f6c7a769d3ff6c7c44" translate="yes" xml:space="preserve">
          <source>Along with zipWithMaybeAMatched, witnesses the isomorphism between &lt;code&gt;WhenMatched f x y z&lt;/code&gt; and &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">zipWithMaybeAMatched 함께, 증인의 동형 &lt;code&gt;WhenMatched f x y z&lt;/code&gt; 및 &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ad299afbc240cf0075ef975ed7558787fe489f" translate="yes" xml:space="preserve">
          <source>AlreadyExists</source>
          <target state="translated">AlreadyExists</target>
        </trans-unit>
        <trans-unit id="630df194c5b10abfa95d9d050a3cb36c24a133d2" translate="yes" xml:space="preserve">
          <source>Also</source>
          <target state="translated">Also</target>
        </trans-unit>
        <trans-unit id="50722218b035a878cd9ffc30a73ebfebc7a35f8b" translate="yes" xml:space="preserve">
          <source>Also causes a warning to be emitted when a module is re-exported, but that module exports nothing.</source>
          <target state="translated">또한 모듈을 다시 내보낼 때 경고가 발생하지만 해당 모듈은 아무것도 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="746c9d1259ee19f74bffdc1d68a458f59b53388d" translate="yes" xml:space="preserve">
          <source>Also for newtypes, &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Enum&lt;/code&gt; are derived using the &lt;code&gt;newtype&lt;/code&gt; strategy if &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and the derivation succeeds.</source>
          <target state="translated">또한 &lt;code&gt;newtype&lt;/code&gt; 경우 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 이 활성화되고 파생이 성공하면 &lt;code&gt;Functor&lt;/code&gt; , &lt;code&gt;Foldable&lt;/code&gt; 및 &lt;code&gt;Enum&lt;/code&gt; 은 newtype 전략을 사용하여 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="9b5456c8967e8ed475ed23a6be13064c4931fe49" translate="yes" xml:space="preserve">
          <source>Also in the same way as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, when &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicilty bound in a type instance declaration.</source>
          <target state="translated">또한 같은 방법으로 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 유형 및 종류의 변수 explicilty 유형의 인스턴스 선언에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f69c8574bf36e86f8483192aacd06c285a54e8f8" translate="yes" xml:space="preserve">
          <source>Also in the same way as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, when &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicitly bound in a type instance declaration.</source>
          <target state="translated">또한 같은 방법으로 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 유형 및 종류의 변수를 명시 적으로 형의 인스턴스 선언에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cdbfaf0e12c5c669a436bbe3f3e6d1b8921e00e" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92256f9554b50ce0b2fea7c43d4cb8cc3cb75d44" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="691fd7629064f3b051f676bcbfa6149c61d9b342" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="406dc1c18625f274ff0dc94719e4b6be8d808a02" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="810701a878272ce093eceec04b908e8284d8a9c5" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d40d8b2532580731c8434c5f67b1078551988ae" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd8ee350e8fa89eeaea33735d33ccaffdcefe56b" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e30beaf60ec387590381b5355c5af1eb18030345" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aab6ba61f08a0ca3c95484013fb136c6e751322c" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4786dd3fd2bcdff58d3b26007350033e063a192" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0이 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e16b7f498e9a6b4b83f2652ce5ef38935a94752" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e9f33b522d825dd8a332d37d794d47c3815cced" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0이 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="40cdf5e6225f275daf21fe333e66b5c010a69778" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0의 존재로 인해 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b45d0d39ada80fe3208a871ffe74aeb25503276e" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0의 존재로 인해 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f433875b8e4b77573f0f23895a49894977730bb" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0이 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6e30397e70af87af894b6d2572b73af0484f5e2" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0이 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4cc23b0b0763553e0311dddd73a34a9e4dee8d5" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 연산자에 적용하기 전에 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; 를 강요하지 않기 때문입니다 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ). 이로 인해 썽크 체인 &lt;code&gt;O(n)&lt;/code&gt; 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ac14b968b5bbba0075fe9bfd17b35d0cc2b952eb" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; )를 연산자에 적용하기 전에 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ) 강제하지 않기 때문 입니다. 이로 인해 썽크 체인 \ (\ mathcal {O} (n) \) 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8ed5ac80b0447d75eb36a8e1088f826de1949152" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 연산자에 적용하기 전에 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; 를 강요하지 않기 때문입니다 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ). 이로 인해 썽크 체인 &lt;code&gt;O(n)&lt;/code&gt; 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f372abd57a7f3cac154979340cbe51baeec9bbfb" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; )를 연산자에 적용하기 전에 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ) 강제하지 않기 때문 입니다. 이로 인해 썽크 체인 \ (\ mathcal {O} (n) \) 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0312e92e764c438aa064f2113437c35a6539b369" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 연산자에 적용하기 전에 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; 를 강요하지 않기 때문입니다 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ). 이로 인해 썽크 체인 &lt;code&gt;O(n)&lt;/code&gt; 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="adb136095ed6cc375f6a3f0659e9e4fe69576dda" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; )를 연산자에 적용하기 전에 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ) 강제하지 않기 때문 입니다. 이로 인해 썽크 체인 \ (\ mathcal {O} (n) \) 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1acbfc03f5d47fca9d6b436cb055a438d6d24adc" translate="yes" xml:space="preserve">
          <source>Also note that the argument to &lt;code&gt;DEPRECATED&lt;/code&gt; and &lt;code&gt;WARNING&lt;/code&gt; can also be a list of strings, in which case the strings will be presented on separate lines in the resulting warning message,</source>
          <target state="translated">또한 &lt;code&gt;DEPRECATED&lt;/code&gt; 및 &lt;code&gt;WARNING&lt;/code&gt; 에 대한 인수 는 문자열 목록 일 수 있으며,이 경우 문자열은 결과 경고 메시지에서 별도의 줄에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa8f340d5595cab499d451cc0ad91fefbf788a96" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cde3b82cd7b9ecd782961c29d79052d748e75c8a" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="41ccfa2353a09113f0c811d9cb51cb48399720bc" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="235d629ac464213b855f299b5269fbab1821ac2a" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a09b8126190a3493d9f5d149861112b275c4a820" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="df2b6faed2041cbc5f8775d83e79ec068a616bf0" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f982812ed18e181efb5f1842c282247a56bf7ec3" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="27a6d2f2099e869b6c35b0b33e690f3dbb98988d" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="25470094bd74b3e948c7c6097cd019d5c2529be4" translate="yes" xml:space="preserve">
          <source>Also note the use of &lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; in the GHCi session above instead of &lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;. This is because &lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; gives you the type that would be inferred for a variable assigned to the expression provided (that is, the type of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;let x = &amp;lt;expr&amp;gt;&lt;/code&gt;). As we saw above with &lt;code&gt;myLength2&lt;/code&gt;, this type will have no variables available to visible type application. On the other hand, &lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; gives you the actual type of the expression provided. To illustrate this:</source>
          <target state="translated">또한 위의 GHCi 세션에서 &lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용하는 것에 유의하십시오 . 이 때문입니다 &lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; 당신에게 제공되는 표현에 할당 된 변수에 대한 추정 될 유형을 제공합니다 (즉, 유형 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;let x = &amp;lt;expr&amp;gt;&lt;/code&gt; ). &lt;code&gt;myLength2&lt;/code&gt; 에서 위에서 보았 듯이이 유형은 보이는 유형 응용 프로그램에 사용할 수있는 변수가 없습니다. 반면에 &lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 는 제공된 표현식의 실제 유형을 제공합니다. 이를 설명하기 위해 :</target>
        </trans-unit>
        <trans-unit id="220abdef84f1e02ea77807f44da3633ce41b62f6" translate="yes" xml:space="preserve">
          <source>Also note the use of &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; in the GHCi session above instead of &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;. This is because &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; gives you the type that would be inferred for a variable assigned to the expression provided (that is, the type of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;let x = &amp;lt;expr&amp;gt;&lt;/code&gt;). As we saw above with &lt;code&gt;myLength2&lt;/code&gt;, this type will have no variables available to visible type application. On the other hand, &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; gives you the actual type of the expression provided. To illustrate this:</source>
          <target state="translated">또한 위의 GHCi 세션에서 &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 . 이 때문입니다 &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; 당신에게 제공되는 표현에 할당 된 변수에 대한 추정 될 유형을 제공합니다 (즉, 유형 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;let x = &amp;lt;expr&amp;gt;&lt;/code&gt; ). 위에서 &lt;code&gt;myLength2&lt;/code&gt; 로 보았 듯이이 유형에는 보이는 유형 응용 프로그램에 사용할 수있는 변수가 없습니다. 반면에 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 는 제공된 표현식의 실제 유형을 제공합니다. 이것을 설명하려면 :</target>
        </trans-unit>
        <trans-unit id="2513c4a2bdd30848586867d45397f58c5275a1ec" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;extra-libraries&lt;/code&gt; are placed on the linker command line after the &lt;code&gt;hs-libraries&lt;/code&gt; for the same package. If your package has dependencies in the other direction (i.e. &lt;code&gt;extra-libraries&lt;/code&gt; depends on &lt;code&gt;hs-libraries&lt;/code&gt;), and the libraries are static, you might need to make two separate packages.</source>
          <target state="translated">또한 &lt;code&gt;extra-libraries&lt;/code&gt; 패키지는 동일한 패키지 의 &lt;code&gt;hs-libraries&lt;/code&gt; 다음에있는 링커 명령 줄에 배치 됩니다. 패키지가 다른 방향으로 종속성이 있고 (즉, &lt;code&gt;extra-libraries&lt;/code&gt; 는 &lt;code&gt;hs-libraries&lt;/code&gt; 에 의존 ) 라이브러리가 정적이면 두 개의 별도 패키지를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="a082bc7aa16e694d046953671bb878019d49365f" translate="yes" xml:space="preserve">
          <source>Also, note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">또한이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 종료 자 간의 종속성을 표현하는 데 사용되어서는 안됩니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 에 대한 종료자가 두 번째 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 호출 하는 경우 유일한 보장은 &lt;code&gt;F2&lt;/code&gt; 에 대한 종료자가 &lt;code&gt;F1&lt;/code&gt; 에 대한 종료 전에 시작되지 않는다는 것 입니다. 예를 들어 &lt;code&gt;F1&lt;/code&gt; 과 &lt;code&gt;F2&lt;/code&gt; 둘 다 접근 할 수없는 경우 함께 시작될 수 있으며이 경우 스케줄러가 &lt;code&gt;F2&lt;/code&gt; 에 대한 종료자를 먼저 실행하게 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3131b8ab181c5396dcc60eede1991b95828099cb" translate="yes" xml:space="preserve">
          <source>Also, note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">또한이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 종료 자 간의 종속성을 표현하는 데 사용되어서는 안됩니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 에 대한 종료자가 두 번째 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 호출 하는 경우 유일한 보장은 &lt;code&gt;F2&lt;/code&gt; 에 대한 종료자가 &lt;code&gt;F1&lt;/code&gt; 에 대한 종료 전에 시작되지 않는다는 것 입니다. 예를 들어 &lt;code&gt;F1&lt;/code&gt; 과 &lt;code&gt;F2&lt;/code&gt; 둘 다 접근 할 수없는 경우 함께 시작될 수 있으며이 경우 스케줄러가 &lt;code&gt;F2&lt;/code&gt; 에 대한 종료자를 먼저 실행하게 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9cd5abc8befc620fdf0d69370c448ed49b4a5500" translate="yes" xml:space="preserve">
          <source>Also, note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">또한이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 종료 자 간의 종속성을 표현하는 데 사용되어서는 안됩니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 에 대한 종료자가 두 번째 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 호출 하는 경우 유일한 보장은 &lt;code&gt;F2&lt;/code&gt; 에 대한 종료자가 &lt;code&gt;F1&lt;/code&gt; 에 대한 종료 전에 시작되지 않는다는 것 입니다. 예를 들어 &lt;code&gt;F1&lt;/code&gt; 과 &lt;code&gt;F2&lt;/code&gt; 둘 다 접근 할 수없는 경우 함께 시작될 수 있으며이 경우 스케줄러가 &lt;code&gt;F2&lt;/code&gt; 에 대한 종료자를 먼저 실행하게 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40984f68323bbc3a5e0662d8396443ffd212990b" translate="yes" xml:space="preserve">
          <source>Also, you may need to use the &lt;a href=&quot;#ghc-flag--rdynamic&quot;&gt;&lt;code&gt;-rdynamic&lt;/code&gt;&lt;/a&gt; flag to ensure that that symbols are not dropped from your PIE objects.</source>
          <target state="translated">또한 PIE 오브젝트에서 기호가 삭제되지 않도록 &lt;a href=&quot;#ghc-flag--rdynamic&quot;&gt; &lt;code&gt;-rdynamic&lt;/code&gt; &lt;/a&gt; 플래그 를 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e30eff925100b7c3e119ed678e39009e962455b0" translate="yes" xml:space="preserve">
          <source>Alt</source>
          <target state="translated">Alt</target>
        </trans-unit>
        <trans-unit id="e429c5fc3a2401f13f505fe2471ed35cea126252" translate="yes" xml:space="preserve">
          <source>Alternate completion to perform if the cursor is not at a quoted word</source>
          <target state="translated">커서가 인용 된 단어가 아닌 경우 수행을위한 대체 완료</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="f427a4339b88ab5730e552c0af40d96b9c132d30" translate="yes" xml:space="preserve">
          <source>AlternativeLayoutRule</source>
          <target state="translated">AlternativeLayoutRule</target>
        </trans-unit>
        <trans-unit id="a87adb1730114f941ad55c79898057fd80fd74d1" translate="yes" xml:space="preserve">
          <source>AlternativeLayoutRuleTransitional</source>
          <target state="translated">AlternativeLayoutRuleTransitional</target>
        </trans-unit>
        <trans-unit id="76d5f5130ef008f32d0f9b4ea42dc455c34353b6" translate="yes" xml:space="preserve">
          <source>Alternatively &lt;code&gt;Coll&lt;/code&gt; might be rewritten</source>
          <target state="translated">또는 &lt;code&gt;Coll&lt;/code&gt; 이 다시 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65a8212521ccdabba5ba2d4d0578992c935fe0f" translate="yes" xml:space="preserve">
          <source>Alternatively you can use &lt;a href=&quot;#ghc-flag--funbox-small-strict-fields&quot;&gt;&lt;code&gt;-funbox-small-strict-fields&lt;/code&gt;&lt;/a&gt; to only unbox strict fields which are &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">또는 &lt;a href=&quot;#ghc-flag--funbox-small-strict-fields&quot;&gt; &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; &lt;/a&gt; 를 사용하여 &quot;small&quot;인 엄격한 필드 만 개봉 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0139c0df4a42fccf86ef595e9d7e4a89d60e0341" translate="yes" xml:space="preserve">
          <source>Alternatively, core plugins can be specified with Template Haskell.</source>
          <target state="translated">또는 템플릿 Haskell을 사용하여 핵심 플러그인을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12456ce612ba3cf75605afebc2b84de246c8bd30" translate="yes" xml:space="preserve">
          <source>Alternatively, if any of the &lt;code&gt;(f e)&lt;/code&gt; ignore their second argument, the fold stops there, with the remaining elements unused. As a result, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; is well suited to define both &lt;a href=&quot;#corec&quot;&gt;corecursive&lt;/a&gt; and &lt;a href=&quot;#short&quot;&gt;short-circuit&lt;/a&gt; reductions.</source>
          <target state="translated">또는 &lt;code&gt;(f e)&lt;/code&gt; 중 하나가 두 번째 인수를 무시하면 폴드가 중지되고 나머지 요소는 사용되지 않습니다. 결과적으로 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 는 &lt;a href=&quot;#corec&quot;&gt;코어 커 시브&lt;/a&gt; 및 &lt;a href=&quot;#short&quot;&gt;단락&lt;/a&gt; 감소를 모두 정의하는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="1bde40f6b099fd2459055a9d8eec8e840639306e" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to build GHC yourself, head on over to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Building&quot;&gt;GHC Building Guide&lt;/a&gt; to find out how to get the sources, and build it on your system. Note that GHC itself is written in Haskell, so you will still need to install GHC in order to build it.</source>
          <target state="translated">또는 GHC를 직접 구축하려면 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Building&quot;&gt;GHC 빌딩 가이드&lt;/a&gt; 를 방문하여 소스를 얻는 방법을 찾아 시스템에 빌드하십시오. GHC 자체는 Haskell로 작성되었으므로 빌드하려면 GHC를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="487925a0dfe33b56fabdc308b58c83700f73524a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to build GHC yourself, head on over to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/building&quot;&gt;GHC Building Guide&lt;/a&gt; to find out how to get the sources, and build it on your system. Note that GHC itself is written in Haskell, so you will still need to install GHC in order to build it.</source>
          <target state="translated">또는 GHC를 직접 빌드하려면 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/building&quot;&gt;GHC 빌드 가이드&lt;/a&gt; 로 이동하여 소스를 얻고 시스템에서 빌드하는 방법을 찾으십시오. GHC 자체는 Haskell로 작성되었으므로 빌드하려면 GHC를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="017799e0bdc7d7426f1d60caa28c84b64a1787eb" translate="yes" xml:space="preserve">
          <source>Alternatively, one could define &lt;code&gt;foldMap&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;foldMap&lt;/code&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdb5e0c35bffdb5bac67b4158b85ee94fc664745" translate="yes" xml:space="preserve">
          <source>Alternatively, use your &lt;code id=&quot;index-14&quot;&gt;TMPDIR&lt;/code&gt; environment variable. Set it to the name of the directory where temporary files should be put. GCC and other programs will honour the &lt;code id=&quot;index-15&quot;&gt;TMPDIR&lt;/code&gt; variable as well.</source>
          <target state="translated">또는 &lt;code id=&quot;index-14&quot;&gt;TMPDIR&lt;/code&gt; 환경 변수를 사용하십시오 . 임시 파일을 넣을 디렉토리 이름으로 설정하십시오. GCC 및 기타 프로그램은 &lt;code id=&quot;index-15&quot;&gt;TMPDIR&lt;/code&gt; 변수도 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="7b0162a0bbd1d38dbdfc269cc088cc5f731a6ba2" translate="yes" xml:space="preserve">
          <source>Alternatively, you can give a type signature to the enclosing context, which GHC can &amp;ldquo;push down&amp;rdquo; to find the type for the variable:</source>
          <target state="translated">또는 GHC가 변수의 유형을 찾기 위해&amp;ldquo;푸시 다운&amp;rdquo;할 수있는 엔 클로징 컨텍스트에 유형 서명을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="369a93d4fce888d55a59c31d08c7fb3c46433a3b" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="29cf9aad2a6fbceeb5608717dde74a1b736195b5" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="c14f8d1451ab6b8eb4e7c4771d4a0ca47ed0fa3c" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="0e51576239bb4dfd89a49cde0c91b94d3c029853" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="9d4b54010820702fe99161a26c1a3fd6da57d30a" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="aabfacf44a025fa1709c2ce0bc2ca417b25be0c8" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="ad067360286354ab105001df012d810684e67e11" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="2f75950244ae1b83eb1fa765162dcee833eb2b00" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="53f69795c586d406dd4511ba9d5155c1a42f2617" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="22e9f09fd992835fa4360f80b95f40b2227ad567" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="8f38ab9e9f8dc1070a59ba1354c8cbcf7666ec61" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="7e9ddf09d766d5f9ca39130ead484571fe0feced" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="a30521846de09e3ca8cee7b96284911c314803ae" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="832b928147d026a938c7c9c4f9b77b788e8f12a1" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="b8713c63104594f55f79cca79583e8fe10117c5e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="3ba685506461100035a0dc7e24aec988f66251e4" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="e2ed5be7a335e3dba8612b72e2da7b9e639f8124" translate="yes" xml:space="preserve">
          <source>Although GHC allows the user to pass all unlifted boxed types to foreign functions, some of them are not amenable to useful work. Although &lt;code&gt;Array#&lt;/code&gt; is unlifted, the elements in its payload are lifted, and a foreign C function cannot safely force thunks. Consequently, a foreign C function may not dereference any of the addresses that comprise the payload of the &lt;code&gt;Array#&lt;/code&gt;.</source>
          <target state="translated">GHC를 사용하면 사용자가 모든 unlifted boxed 유형을 외부 함수에 전달할 수 있지만 일부는 유용한 작업에 적합하지 않습니다. 비록 &lt;code&gt;Array#&lt;/code&gt; unlifted, 그 페이로드의 요소는 해제되고, 외부 C 함수 안전하게 썽크 강제 할 수 없다. 결과적으로 외부 C 함수는 &lt;code&gt;Array#&lt;/code&gt; 의 페이로드를 구성하는 주소를 역 참조하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea6b65048b50606bfc86ae17bba6c11487ce8b27" translate="yes" xml:space="preserve">
          <source>Although all open type families are considered to have a complete user-supplied kind signature, we can relax this condition for closed type families, where we have equations on which to perform kind inference. GHC will infer kinds for the arguments and result types of a closed type family.</source>
          <target state="translated">모든 개방형 패밀리는 사용자가 제공 한 완전한 종류 서명이있는 것으로 간주되지만 폐쇄 형 패밀리에 대해서는이 조건을 완화 할 수 있습니다. GHC는 폐쇄 형 패밀리의 인수 및 결과 유형에 대한 종류를 유추합니다.</target>
        </trans-unit>
        <trans-unit id="a8ba660b18337f8755c5f957412710cfb811a48b" translate="yes" xml:space="preserve">
          <source>Although it is equivalent to running GHC twice, using &lt;code&gt;-dynamic-too&lt;/code&gt; is more efficient, because the earlier phases of the compiler up to code generation are performed just once.</source>
          <target state="translated">GHC를 두 번 실행하는 것과 동일하지만 코드 생성까지 컴파일러의 초기 단계가 한 번만 수행되므로 &lt;code&gt;-dynamic-too&lt;/code&gt; 를 사용하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="17fe55cf03ef562c44820f718c2ff2b873fd70ad" translate="yes" xml:space="preserve">
          <source>Although it is unusual, there (currently) can be &lt;em&gt;multiple&lt;/em&gt; instances for an associated family in a single instance declaration. For example, this is legitimate:</source>
          <target state="translated">드문 경우이지만 단일 인스턴스 선언에 현재 연결된 패밀리에 대해 &lt;em&gt;여러&lt;/em&gt; 인스턴스 가있을 수 있습니다 . 예를 들어, 이것은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="c0e0fc4143b94596d60f1c94c3fec1d4b047aa5e" translate="yes" xml:space="preserve">
          <source>Although names generated by &lt;code&gt;newName&lt;/code&gt; cannot &lt;em&gt;be captured&lt;/em&gt;, they can &lt;em&gt;capture&lt;/em&gt; other names. For example, this:</source>
          <target state="translated">&lt;code&gt;newName&lt;/code&gt; 으로 생성 된 이름은 &lt;em&gt;캡처&lt;/em&gt; 할 수 없지만 다른 이름을 &lt;em&gt;캡처&lt;/em&gt; 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="051c31d13e18e01e98444eb19f8ca75e805e3ed3" translate="yes" xml:space="preserve">
          <source>Although not recommended, the deprecated &lt;a href=&quot;#ghc-flag--fglasgow-exts&quot;&gt;&lt;code&gt;-fglasgow-exts&lt;/code&gt;&lt;/a&gt; flag enables a large swath of the extensions supported by GHC at once.</source>
          <target state="translated">권장되지는 않지만, 더 이상 사용되지 않는 &lt;a href=&quot;#ghc-flag--fglasgow-exts&quot;&gt; &lt;code&gt;-fglasgow-exts&lt;/code&gt; &lt;/a&gt; 플래그를 사용하면 GHC가 지원하는 확장 기능을 한 번에 대량으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fca41e21a6d4cf355148dfe827eb5a105a329d84" translate="yes" xml:space="preserve">
          <source>Although only GHC implements arrow notation directly, there is also a preprocessor (available from the &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;arrows web page&lt;/a&gt;) that translates arrow notation into Haskell 98 for use with other Haskell systems. You would still want to check arrow programs with GHC; tracing type errors in the preprocessor output is not easy. Modules intended for both GHC and the preprocessor must observe some additional restrictions:</source>
          <target state="translated">GHC만이 화살표 표기법을 직접 구현하지만, 화살표 표기법을 다른 Haskell 시스템과 함께 사용하기 위해 Haskell 98로 변환 하는 프리 프로세서도 있습니다 ( &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;화살표 웹 페이지&lt;/a&gt; 에서 사용 가능). 여전히 GHC로 화살표 프로그램을 확인하고 싶을 것입니다. 전 처리기 출력의 추적 유형 오류는 쉽지 않습니다. GHC 및 전 처리기 모두를위한 모듈은 몇 가지 추가 제한 사항을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="5452a72fe79a04ee53ca78ffa45ecae6398cb3ee" translate="yes" xml:space="preserve">
          <source>Although only GHC implements arrow notation directly, there is also a preprocessor (available from the &lt;a href=&quot;https://www.haskell.org/arrows/&quot;&gt;arrows web page&lt;/a&gt;) that translates arrow notation into Haskell 98 for use with other Haskell systems. You would still want to check arrow programs with GHC; tracing type errors in the preprocessor output is not easy. Modules intended for both GHC and the preprocessor must observe some additional restrictions:</source>
          <target state="translated">GHC만이 화살표 표기법을 직접 구현하지만 다른 Haskell 시스템에서 사용하기 위해 화살표 표기법을 Haskell 98로 변환 하는 전 처리기 ( &lt;a href=&quot;https://www.haskell.org/arrows/&quot;&gt;화살표 웹 페이지&lt;/a&gt; 에서 사용 가능 )도 있습니다. GHC로 화살표 프로그램을 확인하고 싶을 것입니다. 전 처리기 출력에서 ​​유형 오류를 추적하는 것은 쉽지 않습니다. GHC와 전 처리기 모두를위한 모듈은 몇 가지 추가 제한 사항을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="030de1c351ae0b62dc7102e4cd4c0fd4463e840e" translate="yes" xml:space="preserve">
          <source>Although quantified constraints are a little like local instance declarations, they differ in one big way: the local instances are written by the compiler, not the user, and hence cannot introduce incoherence. Consider</source>
          <target state="translated">정량화 된 제약 조건은 로컬 인스턴스 선언과 약간 비슷하지만 크게 다릅니다. 로컬 인스턴스는 사용자가 아닌 컴파일러가 작성하므로 불일치가 발생할 수 없습니다. 치다</target>
        </trans-unit>
        <trans-unit id="917df874b8dc3f0710c076dbfbabbd379b501cb5" translate="yes" xml:space="preserve">
          <source>Although the distinction between &lt;em&gt;file&lt;/em&gt; symbolic links and &lt;em&gt;directory&lt;/em&gt; symbolic links does not exist on POSIX systems, on Windows this is an intrinsic property of every symbolic link and cannot be changed without recreating the link. A file symbolic link that actually points to a directory will fail to dereference and vice versa. Moreover, creating symbolic links on Windows may require privileges unavailable to users outside the Administrators group. Portable programs that use symbolic links should take both into consideration.</source>
          <target state="translated">POSIX 시스템에는 &lt;em&gt;파일&lt;/em&gt; 심볼릭 링크와 &lt;em&gt;디렉토리&lt;/em&gt; 심볼릭 링크 의 차이점 이 없지만 Windows에서는 모든 심볼릭 링크의 고유 속성이므로 링크를 다시 만들지 않고는 변경할 수 없습니다. 실제로 디렉토리를 가리키는 파일 심볼릭 링크는 역 참조에 실패하고 그 반대도 마찬가지입니다. 또한 Windows에서 심볼릭 링크를 만들려면 관리자 그룹 외부의 사용자가 사용할 수없는 권한이 필요할 수 있습니다. 심볼릭 링크를 사용하는 이식 가능한 프로그램은 둘 다 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="99e9a14b3e8cd2cda9b0d1073e9a3e3d417a68e2" translate="yes" xml:space="preserve">
          <source>Although typechecking &lt;code&gt;T MyInt&lt;/code&gt; will terminate, GHC&amp;rsquo;s termination checker isn&amp;rsquo;t sophisticated enough to determine this, so you&amp;rsquo;ll need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; in order to use this derived instance. If you do go down this route, make sure you can convince yourself that all of the type family instances you&amp;rsquo;re deriving will eventually terminate if used!</source>
          <target state="translated">유형 검사 &lt;code&gt;T MyInt&lt;/code&gt; 가 종료되지만 GHC의 종료 검사기는이를 결정하기에 정교하지 &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 파생 인스턴스를 사용하려면 UndecidableInstances 를 활성화해야 합니다. 이 경로를 따라 가면 사용중인 모든 유형 패밀리 인스턴스가 결국 종료 될 것임을 확신 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="523b9d21632bf4280da460c9aa733a85b9bf182d" translate="yes" xml:space="preserve">
          <source>Although typechecking &lt;code&gt;T MyInt&lt;/code&gt; will terminate, GHC&amp;rsquo;s termination checker isn&amp;rsquo;t sophisticated enough to determine this, so you&amp;rsquo;ll need to enable &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; in order to use this derived instance. If you do go down this route, make sure you can convince yourself that all of the type family instances you&amp;rsquo;re deriving will eventually terminate if used!</source>
          <target state="translated">유형 검사 &lt;code&gt;T MyInt&lt;/code&gt; 가 종료되지만 GHC의 종료 검사기는이를 결정할만큼 정교하지 &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 파생 인스턴스를 사용하려면 UndecidableInstances 를 활성화해야 합니다. 이 경로를 따라가는 경우 파생하는 모든 유형 패밀리 인스턴스가 사용되면 결국 종료된다는 것을 스스로 확신 할 수 있는지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="6fee9b71141e5521bd00d271e9f736a2cbff6c7d" translate="yes" xml:space="preserve">
          <source>Although we have given only a few examples here, it should be clear that the addition of dependency information can help to make multiple parameter classes more useful in practice, avoiding ambiguity problems, and allowing more general sets of instance declarations.</source>
          <target state="translated">여기에 몇 가지 예만 제시했지만 종속성 정보를 추가하면 여러 매개 변수 클래스를 실제로 유용하게 사용하여 모호성 문제를 피하고보다 일반적인 인스턴스 선언을 허용하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34157ee16cf986f86cc94da23a34f265af1348f" translate="yes" xml:space="preserve">
          <source>Although, a data family is &lt;em&gt;introduced&lt;/em&gt; with the keyword &amp;ldquo;&lt;code&gt;data&lt;/code&gt;&amp;rdquo;, a data family &lt;em&gt;instance&lt;/em&gt; can use either &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;. For example:</source>
          <target state="translated">키워드 &quot; &lt;code&gt;data&lt;/code&gt; &quot;를 사용하여 데이터 패밀리를 &lt;em&gt;도입&lt;/em&gt; 하더라도 데이터 패밀리 &lt;em&gt;인스턴스&lt;/em&gt; 는 &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; 을 사용할 수 있습니다 . 예를 들면 다음과 같습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc69fe6d4cdd92804a7734b80adc8316333f1f44" translate="yes" xml:space="preserve">
          <source>Always fails.</source>
          <target state="translated">항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d694f7e3dcf06959f0a7fcce2057e4016e3a9632" translate="yes" xml:space="preserve">
          <source>Always write interface files</source>
          <target state="translated">항상 인터페이스 파일을 작성하십시오</target>
        </trans-unit>
        <trans-unit id="acb5edef3f602d225f892db47fe7ee1f895d055d" translate="yes" xml:space="preserve">
          <source>Always write interface files. GHC will normally write interface files automatically, but this flag is useful with &lt;a href=&quot;#ghc-flag--fno-code&quot;&gt;&lt;code&gt;-fno-code&lt;/code&gt;&lt;/a&gt;, which normally suppresses generation of interface files. This is useful if you want to type check over multiple runs of GHC without compiling dependencies.</source>
          <target state="translated">항상 인터페이스 파일을 작성하십시오. GHC는 일반적으로 인터페이스 파일을 자동으로 쓰지만,이 플래그는 &lt;a href=&quot;#ghc-flag--fno-code&quot;&gt; &lt;code&gt;-fno-code&lt;/code&gt; &lt;/a&gt; 와 함께 유용하며 일반적으로 인터페이스 파일 생성을 억제합니다. 종속성을 컴파일하지 않고 여러 GHC 실행을 통해 유형 검사를 수행하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="770876e2d8a6f234b57db2323d7a120bd5cefd2f" translate="yes" xml:space="preserve">
          <source>Ambiguity can be subtle. Consider this example which uses functional dependencies:</source>
          <target state="translated">모호성은 미묘 할 수 있습니다. 기능적 종속성을 사용하는 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3ee65b18fc60dcabb8937e100f2503fb55e37a11" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma may have a &lt;a href=&quot;#pragma-CONLIKE&quot;&gt;&lt;code&gt;CONLIKE&lt;/code&gt;&lt;/a&gt; modifier, which affects matching in &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (only). See &lt;a href=&quot;#conlike&quot;&gt;How rules interact with CONLIKE pragmas&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; 프라그가있을 수 &lt;a href=&quot;#pragma-CONLIKE&quot;&gt; &lt;code&gt;CONLIKE&lt;/code&gt; 에서&lt;/a&gt; 의 정합에 영향 개질제 &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; &lt;/a&gt; 들 (전용). &lt;a href=&quot;#conlike&quot;&gt;규칙이 CONLIKE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06cb182c0f6b04aac935f9fe503fdf7ae1bfb73a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma may have a &lt;a href=&quot;#pragma-CONLIKE&quot;&gt;&lt;code&gt;CONLIKE&lt;/code&gt;&lt;/a&gt; modifier, which affects matching in &lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (only). See &lt;a href=&quot;rewrite_rules#conlike&quot;&gt;How rules interact with CONLIKE pragmas&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; 프라그가있을 수 &lt;a href=&quot;#pragma-CONLIKE&quot;&gt; &lt;code&gt;CONLIKE&lt;/code&gt; 에서&lt;/a&gt; 의 정합에 영향 개질제 &lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; &lt;/a&gt; 들 (전용). &lt;a href=&quot;rewrite_rules#conlike&quot;&gt;규칙이 CONLIKE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d03a800321c3532f62fd50dbd5f813f55dc2c76d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma may have a &lt;code&gt;CONLIKE&lt;/code&gt; modifier, which affects matching in &lt;code&gt;RULE&lt;/code&gt;s (only). See &lt;a href=&quot;#conlike&quot;&gt;How rules interact with CONLIKE pragmas&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; 프라그가있을 수 &lt;code&gt;CONLIKE&lt;/code&gt; 에서 의 정합에 영향 개질제 &lt;code&gt;RULE&lt;/code&gt; 들 (전용). &lt;a href=&quot;#conlike&quot;&gt;규칙이 CONLIKE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de96fd13e454f7d0ced988da0b0fe6591f42a8af" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; t&lt;/code&gt; is mutable location that is either empty or contains a value of type &lt;code&gt;t&lt;/code&gt;. It has two fundamental operations: &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; which fills an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if it is empty and blocks otherwise, and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; which empties an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if it is full and blocks otherwise. They can be used in multiple different ways:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; t&lt;/code&gt; 하나 비어 있거나 타입의 값이 포함되어 가변 위치 &lt;code&gt;t&lt;/code&gt; 을 . : 그것은 두 가지 기본적인 작업이 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 채워 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 이 그렇지 않으면 빈 차단하고, 경우 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 비워 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 가 달리 완전하고 블록 인 경우를. 그들은 여러 가지 방법으로 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bfc651b7b6015a5d38e8dc9b2d2cd9a41bf19609" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (pronounced &quot;em-var&quot;) is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (발음 &quot;EM-VAR&quot;)은 동시 스레드 간의 통신에 이용되는 동기 변수이다. 비어 있거나 가득 찬 상자로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e415725c78688d42711652a7e4079f14251bb6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e750e5e924cba57bf36a0ebd4161427cec7557d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a0acc3f7eca8dfaa44c1a33f0fe4a81c5a78694" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34c3205df3a50720edd8ad6a1e53cf3a8ebdb0c5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f847ae13cb0b0976d90acd768ce3eab18b000b5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1df649f3e9608bfa59b69ce49171cbd785155b3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47281938d8ea8fab14ec059d784740642bb1fcd7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent boxed version (&lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt;) with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 은 일반적으로 등가 박스형 버전 (보다 (시간과 공간 모두의 측면에서)보다 효율적으로 될 것이다 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 동일한 요소 유형). 그러나 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 는 해당 요소 가 엄격하므로 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 에서 제공 하는 엄격하지 않은 것이 필요한 경우 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="10ab056c484cefd1634f35523d774bd2bf27bc81" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent boxed version (&lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt;) with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 은 일반적으로 등가 박스형 버전 (보다 (시간과 공간 모두의 측면에서)보다 효율적으로 될 것이다 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 동일한 요소 유형). 그러나 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 는 해당 요소 가 엄격하므로 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 에서 제공 하는 엄격하지 않은 것이 필요한 경우 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c72c0a99e8a213a03ed1ff5d7bad4f8d34a4fe41" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; instance is always required (but it can just ignore the meta-information, as is the case for &lt;code&gt;encode&lt;/code&gt; above).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 의 인스턴스는 항상 필요합니다 (그러나의 경우와 같이 단지 메타 정보를 무시할 수 &lt;code&gt;encode&lt;/code&gt; 위의).</target>
        </trans-unit>
        <trans-unit id="c6430d754f6ee1e74237537560c890d61207b930" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fec238ef2447aa47087bb9d112fb0dd69cdcd4c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (pronounced &quot;em-var&quot;) is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (발음 &quot;EM-VAR&quot;)은 동시 스레드 간의 통신에 이용되는 동기 변수이다. 비어 있거나 가득 찬 상자로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64ebf00aaf703cb98269bd37718878465c05c15" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;INLINE&lt;/code&gt; function is not worker/wrappered by strictness analysis. It&amp;rsquo;s going to be inlined wholesale instead.</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; 의 기능은 작업자 / 엄격 분석에 의해 wrappered 없습니다. 대신 도매로 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="683b56235dbe6d9de132b9c32113d5f5fe04aa0c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;InstalledPackageInfo&lt;/code&gt; has a human readable/writable syntax. The functions &lt;code&gt;parseInstalledPackageInfo&lt;/code&gt; and &lt;code&gt;showInstalledPackageInfo&lt;/code&gt; read and write this syntax respectively. Here&amp;rsquo;s an example of the &lt;code&gt;InstalledPackageInfo&lt;/code&gt; for the &lt;code&gt;unix&lt;/code&gt; package:</source>
          <target state="translated">&lt;code&gt;InstalledPackageInfo&lt;/code&gt; 은 인간 판독 / 기록 가능한 구문을 갖는다. &lt;code&gt;parseInstalledPackageInfo&lt;/code&gt; 및 &lt;code&gt;showInstalledPackageInfo&lt;/code&gt; 함수는 이 구문을 각각 읽고 씁니다. 다음 은 &lt;code&gt;unix&lt;/code&gt; 패키지를 위한 &lt;code&gt;InstalledPackageInfo&lt;/code&gt; 의 예입니다 :</target>
        </trans-unit>
        <trans-unit id="3a2c03ccefc5072e12ca70273302c1ee7ab6f1d5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;OperatorTable s u m a&lt;/code&gt; is a list of &lt;code&gt;Operator s u m a&lt;/code&gt; lists. The list is ordered in descending precedence. All operators in one list have the same precedence (but may have a different associativity).</source>
          <target state="translated">&lt;code&gt;OperatorTable s u m a&lt;/code&gt; 의 목록입니다 &lt;code&gt;Operator s u m a&lt;/code&gt; 목록. 목록은 내림차순으로 정렬됩니다. 한 목록의 모든 연산자는 우선 순위가 동일하지만 다른 연관성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9933684475c3885933d3cb45f7d700d24f1bf2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;{-# INLINABLE f #-}&lt;/code&gt; pragma on a function &lt;code&gt;f&lt;/code&gt; has the following behaviour:</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 에 대한 &lt;code&gt;{-# INLINABLE f #-}&lt;/code&gt; pragma 는 다음과 같은 동작을합니다.</target>
        </trans-unit>
        <trans-unit id="b9ded8006363b78c478c9d256d512759af3de706" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;orphan module&lt;/em&gt; orphan module contains at least one &lt;em&gt;orphan instance&lt;/em&gt; or at least one &lt;em&gt;orphan rule&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;고아 모듈&lt;/em&gt; 고아 모듈은 적어도 하나 개 포함 &lt;em&gt;고아 인스턴스&lt;/em&gt; 또는 적어도 하나의 &lt;em&gt;고아 규칙을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e3de3cb88319a179768b2746e40461a71f436143" translate="yes" xml:space="preserve">
          <source>An FFI binding to the hot key part of the Win32 API.</source>
          <target state="translated">Win32 API의 단축키 부분에 대한 FFI 바인딩.</target>
        </trans-unit>
        <trans-unit id="cbfb652fdf79531cc3d86d6d11da84e45c07abbf" translate="yes" xml:space="preserve">
          <source>An FFI binding to the system part of the Win32 API.</source>
          <target state="translated">Win32 API의 시스템 부분에 대한 FFI 바인딩</target>
        </trans-unit>
        <trans-unit id="451395d3497bffe11685a4808d989a520d0e956e" translate="yes" xml:space="preserve">
          <source>An HValueRef with a finalizer</source>
          <target state="translated">종료자가있는 HValueRef</target>
        </trans-unit>
        <trans-unit id="d2d296bd0d9d97c26c27e28a4f8f9fc312ec86a0" translate="yes" xml:space="preserve">
          <source>An I/O event.</source>
          <target state="translated">I / O 이벤트</target>
        </trans-unit>
        <trans-unit id="9d61e77c59f8de3e6e0f09bd0569bdcfd960fe05" translate="yes" xml:space="preserve">
          <source>An IO monad wrapped in &lt;code&gt;StateT&lt;/code&gt; inside of &lt;code&gt;ErrorT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;StateT&lt;/code&gt; 내부의 &lt;code&gt;ErrorT&lt;/code&gt; 래핑 된 IO 모나드 :</target>
        </trans-unit>
        <trans-unit id="7426b52720da94bc2bc36c2af36224d9d16ed966" translate="yes" xml:space="preserve">
          <source>An ML-style language usually generalises the type of any &lt;code&gt;let&lt;/code&gt;-bound or &lt;code&gt;where&lt;/code&gt;-bound variable, so that it is as polymorphic as possible. With the extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; GHC implements a slightly more conservative policy, using the following rules:</source>
          <target state="translated">ML 스타일 언어는 일반적으로 &lt;code&gt;let&lt;/code&gt; -bound 또는 &lt;code&gt;where&lt;/code&gt; -bound 변수 의 유형을 일반화하여 가능한 한 다형성이되도록합니다. 확장을 통해 &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; GHC는 다음 규칙을 사용하여 약간 더 보수적 인 정책을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9cefabc3584d4516f625a578f6ab414f96911025" translate="yes" xml:space="preserve">
          <source>An RTS debugging flag; only available if the program was linked with the &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt; option. Various values of ⟨x⟩ are provided to enable debug messages and additional runtime sanity checks in different subsystems in the RTS, for example &lt;code&gt;+RTS -Ds -RTS&lt;/code&gt; enables debug messages from the scheduler. Use &lt;code&gt;+RTS -?&lt;/code&gt; to find out which debug flags are supported.</source>
          <target state="translated">RTS 디버깅 플래그; 프로그램이 &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt; 옵션 과 링크 된 경우에만 사용 가능합니다 . RTS의 다른 서브 시스템에서 디버그 메시지 및 추가 런타임 정상 상태 점검을 가능하게하기 위해 다양한 ⟨x⟩ 값이 제공됩니다. 예를 들어 &lt;code&gt;+RTS -Ds -RTS&lt;/code&gt; 는 스케줄러의 디버그 메시지를 사용합니다. &lt;code&gt;+RTS -?&lt;/code&gt; 사용 ? 어떤 디버그 플래그가 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4e45674dc1c637028f0f01799a8815e6ecb98130" translate="yes" xml:space="preserve">
          <source>An XHTML combinator library.</source>
          <target state="translated">XHTML 결합기 라이브러리</target>
        </trans-unit>
        <trans-unit id="09858e905a1c37c93edf149194a2d9bb2ce3582b" translate="yes" xml:space="preserve">
          <source>An abstract interface to a unique symbol generator.</source>
          <target state="translated">고유 한 심볼 생성기에 대한 추상 인터페이스.</target>
        </trans-unit>
        <trans-unit id="c3d4f7cf1abe842d95a74003b96fc062bd25f990" translate="yes" xml:space="preserve">
          <source>An abstract name for an object, that supports equality and hashing.</source>
          <target state="translated">동등성과 해싱을 지원하는 객체의 추상 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c7780c030353da535248bab25cc8ad315039483b" translate="yes" xml:space="preserve">
          <source>An abstract type representing names in the syntax tree.</source>
          <target state="translated">구문 트리에서 이름을 나타내는 추상 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3739511153de0d9b79bcbb692e2cd72c742f7bd7" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 의 각 변형에 대한 값을 포함하는 추상 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="580e2ee0cc2d32003a3cd07143debcb038d87924" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 의 각 변형에 대한 값을 포함하는 추상 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="4efb40389fa8d66e189c71d212784428f0bae6b2" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 의 각 변형에 대한 값을 포함하는 추상 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="35eff700132dbe6d90bfc15821db76d5acbdf25d" translate="yes" xml:space="preserve">
          <source>An abstract unique object. Objects of type &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; may be compared for equality and ordering and hashed into &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추상적 인 독특한 객체. &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 유형의 객체는 동등성과 순서를 비교하고 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 해시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21c7f832db5783c3e7a8088c500d2962ed9384be" translate="yes" xml:space="preserve">
          <source>An accumulating function</source>
          <target state="translated">축적 기능</target>
        </trans-unit>
        <trans-unit id="b61c87037791a3b504bed8e01931aafc2fc5942c" translate="yes" xml:space="preserve">
          <source>An accumulation monad parameterized by the type &lt;code&gt;w&lt;/code&gt; of output to accumulate.</source>
          <target state="translated">누적 출력 &lt;code&gt;w&lt;/code&gt; 유형에 의해 매개 변수화 된 누적 모나드 .</target>
        </trans-unit>
        <trans-unit id="f7cc330fe5c9abb7f58e424cead33a14c496fa0c" translate="yes" xml:space="preserve">
          <source>An accumulation monad parameterized by:</source>
          <target state="translated">다음에 의해 매개 변수화 된 축적 모나드 :</target>
        </trans-unit>
        <trans-unit id="282bf0a0b47e57c828188f0a009349e911a1315e" translate="yes" xml:space="preserve">
          <source>An action which sends output to the terminal. That output may mix plain text with control characters and escape sequences, along with delays (called &quot;padding&quot;) required by some older terminals.</source>
          <target state="translated">출력을 터미널로 보내는 동작입니다. 이 출력은 일부 오래된 터미널에 필요한 지연 ( &quot;패딩&quot;)과 함께 일반 텍스트와 제어 문자 및 이스케이프 시퀀스를 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40621b0cc1f828021b505715d70a5c3153c57b8e" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#ghc-flag--ddump-ticked&quot;&gt;&lt;code&gt;-ddump-ticked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--ddump-ticked&quot;&gt; &lt;code&gt;-ddump-ticked&lt;/code&gt; &lt;/a&gt; 의 별명 .</target>
        </trans-unit>
        <trans-unit id="35feeff338058bf37c6e24f0244366473367a8b7" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;--nonmoving-gc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt; &lt;code&gt;--nonmoving-gc&lt;/code&gt; &lt;/a&gt; 의 별칭</target>
        </trans-unit>
        <trans-unit id="6cbb51b39bb5ee9826d87215f4821611643eee9b" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;debugging#ghc-flag--ddump-ticked&quot;&gt;&lt;code&gt;-ddump-ticked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-ticked&quot;&gt; &lt;code&gt;-ddump-ticked&lt;/code&gt; &lt;/a&gt; 의 별명 .</target>
        </trans-unit>
        <trans-unit id="8b292908bf0d2936fbcd16984eafba397dbc968a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="a37301a9d0fe7303c2440af029087f787465968c" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="39f245d534c3b422c9edc0bbe9598133641be7f8" translate="yes" xml:space="preserve">
          <source>An alias for modifyState for backwards compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위해 modifyState의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="99e294020522b0531d3dadc4d8bef2d2fd79bf01" translate="yes" xml:space="preserve">
          <source>An alias for putState for backwards compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위해 putState의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="709a0f933c96849749d91e33427992ea15ebf916" translate="yes" xml:space="preserve">
          <source>An allocation strategy that does not trim any of the filled buffers before converting it to a chunk</source>
          <target state="translated">채워진 버퍼를 청크로 변환하기 전에 트리밍하지 않는 할당 전략</target>
        </trans-unit>
        <trans-unit id="7cb706568d5dabeb772af56d1f92199b0a7ee949" translate="yes" xml:space="preserve">
          <source>An allocation strategy that guarantees that at least half of the allocated memory is used for live data</source>
          <target state="translated">할당 된 메모리의 절반 이상이 라이브 데이터에 사용되도록 보장하는 할당 전략</target>
        </trans-unit>
        <trans-unit id="c8a358c8e089a8a6ad543274e213736fdd805423" translate="yes" xml:space="preserve">
          <source>An alternative sort. Sorts by checking which hole fits subsume other hole fits, such that if hole fit a could be used as hole fits for hole fit b, then b appears before a in the output. It is more precise than the default sort, but also a lot slower, since a subsumption check has to be run for each pair of valid hole fits.</source>
          <target state="translated">다른 종류. 구멍 맞춤 a를 다른 구멍 맞춤으로 가정하여 정렬합니다. 예를 들어, 구멍 맞춤 a를 구멍 맞춤 b에 대한 구멍 맞춤으로 사용할 수 있으면 b가 출력에서 ​​a 앞에 나타납니다. 기본 정렬보다 더 정확하지만 각 유효한 구멍 맞춤 쌍에 대해 하위 가정 검사를 실행해야하기 때문에 속도가 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="85c8ea4d2925dfd094cde7445f68c6da3c037dbf" translate="yes" xml:space="preserve">
          <source>An ambiguous selector may be disambiguated by the type being &amp;ldquo;pushed down&amp;rdquo; to the occurrence of the selector (see &lt;a href=&quot;#higher-rank-type-inference&quot;&gt;Type inference&lt;/a&gt; for more details on what &amp;ldquo;pushed down&amp;rdquo; means). For example, the following are permitted:</source>
          <target state="translated">모호한 선택기는 선택기의 발생에 따라 &quot;푸시 다운&quot;되는 유형에 의해 명확 해 질 수 있습니다 ( &quot;푸시 다운&quot;의 의미에 대한 자세한 내용 은 &lt;a href=&quot;#higher-rank-type-inference&quot;&gt;유형 유추&lt;/a&gt; 참조 ). 예를 들어 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="530369416b52ec99a3cf0ffe2567f4c3f5a96342" translate="yes" xml:space="preserve">
          <source>An ambiguous selector may be disambiguated by the type being &amp;ldquo;pushed down&amp;rdquo; to the occurrence of the selector (see &lt;a href=&quot;rank_polymorphism#higher-rank-type-inference&quot;&gt;Type inference&lt;/a&gt; for more details on what &amp;ldquo;pushed down&amp;rdquo; means). For example, the following are permitted:</source>
          <target state="translated">모호한 선택자는 선택 자의 발생에 &quot;푸시 다운&quot;되는 유형에 의해 명확해질 수 있습니다 ( &quot;푸시 다운&quot;의 의미에 대한 자세한 내용 은 &lt;a href=&quot;rank_polymorphism#higher-rank-type-inference&quot;&gt;유형 유추&lt;/a&gt; 참조 ). 예를 들어 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb9d0b854775c17b2c5aff97ccac59e5200fac6e" translate="yes" xml:space="preserve">
          <source>An amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the length of the sequence and &lt;em&gt;i&lt;/em&gt; being the integral index used by some operations. These bounds hold even in a persistent (shared) setting.</source>
          <target state="translated">각 작업에 대해 상각 된 실행 시간이 주어지며, &lt;em&gt;n&lt;/em&gt; 은 시퀀스 길이를 나타내며 &lt;em&gt;i&lt;/em&gt; 는 일부 작업에 사용되는 정수 인덱스입니다. 이 경계는 지속적 (공유) 설정에서도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce9dd94558d3a6cb7c491d6ce3c6738daadefaa" translate="yes" xml:space="preserve">
          <source>An annotation (side-metadata) attached at a particular point in a &lt;code&gt;Doc&lt;/code&gt;. Allows carrying non-pretty-printed data around in a &lt;code&gt;Doc&lt;/code&gt; that is attached at particular points in the structure. Once the &lt;code&gt;Doc&lt;/code&gt; is render to an output type (such as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;), we can also retrieve where in the rendered document our annotations start and end (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">A의 특정 지점에 부착 된 주석 (사이드 메타) &lt;code&gt;Doc&lt;/code&gt; . 구조의 특정 지점에 첨부 된 &lt;code&gt;Doc&lt;/code&gt; 에서 인쇄되지 않은 데이터를 전달할 수 있습니다. 일단 &lt;code&gt;Doc&lt;/code&gt; 출력 유형 (예에 렌더링되는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ), 우리는 또한 어디 렌더링 된 문서에 우리의 주석 시작과 끝 (참조 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="11d313098b3ec3f985281ba5d03b5e871c638cd4" translate="yes" xml:space="preserve">
          <source>An annotation (side-metadata) attached at a particular point in a &lt;code&gt;Doc&lt;/code&gt;. Allows carrying non-pretty-printed data around in a &lt;code&gt;Doc&lt;/code&gt; that is attached at particular points in the structure. Once the &lt;code&gt;Doc&lt;/code&gt; is render to an output type (such as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;), we can also retrieve where in the rendered document our annotations start and end (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Doc&lt;/code&gt; 의 특정 지점에 첨부 된 주석 (사이드 메타 데이터) 입니다. 구조의 특정 지점에 첨부 된 &lt;code&gt;Doc&lt;/code&gt; 에서 예쁘지 않은 데이터를 전달할 수 있습니다. 일단 &lt;code&gt;Doc&lt;/code&gt; 출력 유형 (예에 렌더링되는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ), 우리는 또한 어디 렌더링 된 문서에 우리의 주석 시작과 끝 (참조 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="c22b50b6aacfdd3de4e2ab9f37143ab2eebbb870" translate="yes" xml:space="preserve">
          <source>An annotation (side-metadata) attached at a particular point in a &lt;code&gt;Doc&lt;/code&gt;. Allows carrying non-pretty-printed data around in a &lt;code&gt;Doc&lt;/code&gt; that is attached at particular points in the structure. Once the &lt;code&gt;Doc&lt;/code&gt; is render to an output type (such as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;), we can also retrieve where in the rendered document our annotations start and end (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Doc&lt;/code&gt; 의 특정 지점에 첨부 된 주석 (측면 메타 데이터) 입니다. 구조의 특정 지점에 첨부 된 &lt;code&gt;Doc&lt;/code&gt; 에서 예쁘지 않은 데이터를 운반 할 수 있습니다. 일단 &lt;code&gt;Doc&lt;/code&gt; 출력 유형 (예에 렌더링되는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ), 우리는 또한 어디 렌더링 된 문서에 우리의 주석 시작과 끝 (참조 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="a4a5bd4a90cc650cc053e5d8d2d60daef1c2e891" translate="yes" xml:space="preserve">
          <source>An applicative functor that collects a monoid (e.g. lists) of errors. A sequence of computations fails if any of its components do, but unlike monads made with &lt;code&gt;ExceptT&lt;/code&gt; from &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;, these computations continue after an error, collecting all the errors.</source>
          <target state="translated">단일 ID (예 : 목록)의 오류를 수집하는 적용 기능 기. 그 구성 요소 중 하나를 할 경우 계산의 순서는 실패하지만,로 만든 모나드는 달리 &lt;code&gt;ExceptT&lt;/code&gt; 에서 &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt; ,이 계산은 모든 오류를 수집, 오류가 발생한 후 계속합니다.</target>
        </trans-unit>
        <trans-unit id="bc070c7328fa5d3571a45acb079f74b2dde0b0b6" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">적용 가능한 버전의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf3d115218ff8bff3d10483bba1404c9ab4c403" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">적용 가능한 버전의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a468ebf5cf1c674abd871e054ea2dee404c992" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">적용 가능한 버전의 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="714a850af4acc6ad522e25162362c1e340e36f2e" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">적용 가능한 버전의 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e4069001a63b95ceb7dda105321002b8f3e3ba6" translate="yes" xml:space="preserve">
          <source>An arbitrary machine address assumed to point outside the garbage-collected heap.</source>
          <target state="translated">가비지 수집 힙 외부를 가리키는 것으로 간주되는 임의의 컴퓨터 주소입니다.</target>
        </trans-unit>
        <trans-unit id="8bf5023dfbbe40314a1c91c2950b274f9f5333cc" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식이며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f333085677822b91b2d6266691a5fadac493bad0" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type. The &lt;code&gt;IArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, so that instances specialised to certain element types can be defined.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식이며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다. &lt;code&gt;IArray&lt;/code&gt; 의 클래스는 모두를 통해 매개 변수화되어 및 &lt;code&gt;e&lt;/code&gt; 인스턴스가 정의 할 수있는 특정 요소 유형에 전문 그래서. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd0764a85da5b607f0944932a419f16b24701a2a" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식을 가지며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (종류 &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2b79318296e9a1df365be13462713df9a22390f7" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type. The &lt;code&gt;IArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, so that instances specialised to certain element types can be defined.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식을 가지며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (종류 &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다. &lt;code&gt;IArray&lt;/code&gt; 의 클래스는 모두를 통해 매개 변수화되어 및 &lt;code&gt;e&lt;/code&gt; 인스턴스가 정의 할 수있는 특정 요소 유형에 전문 그래서. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59f77e407160339257d6e7e19656f935267c2d3f" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식을 가지며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (종류 &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bbf6f68d6cac61b7ec8e86bda765cc696db93453" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type. The &lt;code&gt;IArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, so that instances specialised to certain element types can be defined.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식을 가지며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (종류 &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다. &lt;code&gt;IArray&lt;/code&gt; 의 클래스는 모두를 통해 매개 변수화되어 및 &lt;code&gt;e&lt;/code&gt; 인스턴스가 정의 할 수있는 특정 요소 유형에 전문 그래서. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e15133cd1e98c4cec2d0b6095c794ad5b60cd611" translate="yes" xml:space="preserve">
          <source>An assembly-language source file, usually produced by the compiler.</source>
          <target state="translated">일반적으로 컴파일러가 생성하는 어셈블리 언어 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="e94a0acd4447829f7e16f2e0681abc5b94e72a47" translate="yes" xml:space="preserve">
          <source>An associated type or data family declaration has a CUSK precisely if its enclosing class has a CUSK.</source>
          <target state="translated">엔 클로징 클래스에 CUSK가 있으면 연관된 유형 또는 데이터 패밀리 선언에 정확하게 CUSK가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a839446e60f1231647068f143a30b2ecfe17004" translate="yes" xml:space="preserve">
          <source>An association is a pair of the form &lt;code&gt;(i,x)&lt;/code&gt;, which defines the value of the array at index &lt;code&gt;i&lt;/code&gt; to be &lt;code&gt;x&lt;/code&gt;. The array is undefined if any index in the list is out of bounds. If any two associations in the list have the same index, the value at that index is implementation-dependent. (In GHC, the last value specified for that index is used. Other implementations will also do this for unboxed arrays, but Haskell 98 requires that for &lt;code&gt;Array&lt;/code&gt; the value at such indices is bottom.)</source>
          <target state="translated">연관 폼의 한 쌍 &lt;code&gt;(i,x)&lt;/code&gt; 인덱스 어레이 값을 정의, &lt;code&gt;i&lt;/code&gt; 될 &lt;code&gt;x&lt;/code&gt; . 목록의 인덱스가 범위를 벗어나면 배열이 정의되지 않습니다. 목록의 두 연관이 동일한 색인을 갖는 경우 해당 색인의 값은 구현에 따라 다릅니다. GHC에서는 해당 인덱스에 대해 지정된 마지막 값이 사용됩니다. 다른 구현에서도 언 박스형 배열에 대해서도이 작업을 수행하지만 Haskell 98에서는 &lt;code&gt;Array&lt;/code&gt; 에 대해 해당 인덱스의 값이 맨 아래에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3afb607a33ed15aef025831322f63f1a04d9a09d" translate="yes" xml:space="preserve">
          <source>An associative binary operation</source>
          <target state="translated">연관 이진 연산</target>
        </trans-unit>
        <trans-unit id="1147ac2d130bd449477786144a5c8a1b76f89092" translate="yes" xml:space="preserve">
          <source>An associative operation</source>
          <target state="translated">연관 연산</target>
        </trans-unit>
        <trans-unit id="8ce47487694776c0a4231b6d5c5f44ab8e16a07a" translate="yes" xml:space="preserve">
          <source>An associative operation with identity &lt;code&gt;&lt;a href=&quot;control-arrow#v:zeroArrow&quot;&gt;zeroArrow&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ID가 &lt;code&gt;&lt;a href=&quot;control-arrow#v:zeroArrow&quot;&gt;zeroArrow&lt;/a&gt;&lt;/code&gt; 인 연관 연산 .</target>
        </trans-unit>
        <trans-unit id="8f702f0949aff10d3524aea50e9531b4e09362c3" translate="yes" xml:space="preserve">
          <source>An associative operation.</source>
          <target state="translated">연관 연산.</target>
        </trans-unit>
        <trans-unit id="d3660f5f8cdd17a078c28b99ce21ad421e42c7b8" translate="yes" xml:space="preserve">
          <source>An associative operation. The default definition is</source>
          <target state="translated">연관 연산. 기본 정의는</target>
        </trans-unit>
        <trans-unit id="e8163d537de96930d1551a2bbdc32c863286eb63" translate="yes" xml:space="preserve">
          <source>An attempt was made to evaluate an element of an array that had not been initialized.</source>
          <target state="translated">초기화되지 않은 배열의 요소를 평가하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="578f42dbdd127ca4fccb4e419110bd0c78e68ac1" translate="yes" xml:space="preserve">
          <source>An attempt was made to index an array outside its declared bounds.</source>
          <target state="translated">선언 된 범위를 벗어난 배열을 색인하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="424d796a4ce39c6e1c11527f6f9821335c409254" translate="yes" xml:space="preserve">
          <source>An easy extension is to allow arbitrary contexts before the constructor. For example:</source>
          <target state="translated">쉬운 확장은 생성자 앞에 임의의 컨텍스트를 허용하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa4b3e7e1ba4fecc1be2a9b715baa31cf5742128" translate="yes" xml:space="preserve">
          <source>An edge from the first vertex to the second.</source>
          <target state="translated">첫 번째 정점에서 두 번째 정점까지의 가장자리입니다.</target>
        </trans-unit>
        <trans-unit id="37f36fd364f93ab076dac05112c547d9ca7b71a6" translate="yes" xml:space="preserve">
          <source>An edit to apply to a &lt;code&gt;&lt;a href=&quot;ghc-event-timeout#t:TimeoutQueue&quot;&gt;TimeoutQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-event-timeout#t:TimeoutQueue&quot;&gt;TimeoutQueue&lt;/a&gt;&lt;/code&gt; 에 적용 할 편집 입니다.</target>
        </trans-unit>
        <trans-unit id="4dfc37a5d88a5cef62918450d61f82ec135f66a3" translate="yes" xml:space="preserve">
          <source>An efficient deserialiser of &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 효율적인 디시리얼라이저 .</target>
        </trans-unit>
        <trans-unit id="9abf3b4b588f08354857f088c37e909380ccb8c8" translate="yes" xml:space="preserve">
          <source>An efficient get method for lazy ByteStrings. Fails if fewer than &lt;code&gt;n&lt;/code&gt; bytes are left in the input.</source>
          <target state="translated">게으른 ByteString에 대한 효율적인 get 메소드입니다. 입력에 &lt;code&gt;n&lt;/code&gt; 바이트 미만 이 남아 있으면 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="779d338d8d1396567da301a0915991a8253fcb3d" translate="yes" xml:space="preserve">
          <source>An efficient get method for strict ByteStrings. Fails if fewer than &lt;code&gt;n&lt;/code&gt; bytes are left in the input. If &lt;code&gt;n &amp;lt;= 0&lt;/code&gt; then the empty string is returned.</source>
          <target state="translated">엄격한 ByteString에 대한 효율적인 get 메소드입니다. 입력에 &lt;code&gt;n&lt;/code&gt; 바이트 미만 이 남아 있으면 실패합니다 . 경우 &lt;code&gt;n &amp;lt;= 0&lt;/code&gt; 다음 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64a0398b712134b5c921639d4662413422147955" translate="yes" xml:space="preserve">
          <source>An efficient implementation of integer sets.</source>
          <target state="translated">정수 세트의 효율적인 구현</target>
        </trans-unit>
        <trans-unit id="ed7ff4240488108e796dda83b8f8a885a21e7f97" translate="yes" xml:space="preserve">
          <source>An efficient implementation of maps from integer keys to values (dictionaries).</source>
          <target state="translated">정수 키에서 값 (사전)으로의 효율적인 매핑 구현</target>
        </trans-unit>
        <trans-unit id="300c10f93efb7d8e708d1538e08d8d7e538b4d21" translate="yes" xml:space="preserve">
          <source>An efficient implementation of ordered maps from keys to values (dictionaries).</source>
          <target state="translated">키에서 값 (사전)으로 순서화 된 맵을 효율적으로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9c17d2bea255ffe0974a30b48457084e4d307e5f" translate="yes" xml:space="preserve">
          <source>An efficient primitive to write a strict ByteString into the output buffer. It flushes the current buffer, and writes the argument into a new chunk.</source>
          <target state="translated">엄격한 ByteString을 출력 버퍼에 쓰는 효율적인 프리미티브. 현재 버퍼를 플러시하고 새로운 청크에 인수를 씁니다.</target>
        </trans-unit>
        <trans-unit id="409ad01192a6191df9780f4e796153ec80522cce" translate="yes" xml:space="preserve">
          <source>An efficient serialiser of &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 효율적인 시리얼 라이저 .</target>
        </trans-unit>
        <trans-unit id="e6015ce2daa6533d6818de8c86f4d41b485e9542" translate="yes" xml:space="preserve">
          <source>An empty document</source>
          <target state="translated">빈 문서</target>
        </trans-unit>
        <trans-unit id="ce3be77c03c4e3699f0fd72a41b3ed4e3a5f892e" translate="yes" xml:space="preserve">
          <source>An empty graph.</source>
          <target state="translated">빈 그래프.</target>
        </trans-unit>
        <trans-unit id="60a7cfffba592bf3fc0701b5fe4cb99cba424d1c" translate="yes" xml:space="preserve">
          <source>An empty immutable array.</source>
          <target state="translated">비어있는 불변 배열.</target>
        </trans-unit>
        <trans-unit id="110c4ac770ed6cac3b6a8ac6f3769b9a42dfce56" translate="yes" xml:space="preserve">
          <source>An empty piece of HTML.</source>
          <target state="translated">빈 HTML 조각.</target>
        </trans-unit>
        <trans-unit id="863735067735f8b0df4ec524f2091a6814c632b6" translate="yes" xml:space="preserve">
          <source>An encoding in which Unicode code points are translated to bytes by taking the code point modulo 256. When decoding, bytes are translated directly into the equivalent code point.</source>
          <target state="translated">코드 포인트 모듈로 256을 취함으로써 유니 코드 코드 포인트가 바이트로 변환되는 인코딩. 디코딩시 바이트는 동등한 코드 포인트로 직접 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="379731e74a8a7303ee4ec5e7849e8a388a898a4e" translate="yes" xml:space="preserve">
          <source>An equivalent form for that example, avoiding explicit &lt;code&gt;forall&lt;/code&gt; uses &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;:</source>
          <target state="translated">그 예를 들어 동등한 형태는 명시 적으로 피하는 &lt;code&gt;forall&lt;/code&gt; 사용 &lt;a href=&quot;#pattern-type-sigs&quot;&gt;패턴 유형 서명&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2317b7500211efb11dba6702f8ff358cab78a9f0" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재 하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류 .</target>
        </trans-unit>
        <trans-unit id="9c5c1ab24132ff1db5fc41f514c9dd3d02f6830b" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 존재하지 않아 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류 .</target>
        </trans-unit>
        <trans-unit id="a44dec7bdac91aad0789fdf13b8614448d0c3e1b" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작업이 불가능 하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 결과 를 반환하는 계산 은 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패 할 수 있습니다 . 경우에 따라 구현시 가능한 오류 원인을 구별하지 못할 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f839fc9cbc9a7a46f4c3ef068799b74f941ae12" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 충분한 운영 체제 권한이 없기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="353bc4608932aa64def2cb47401212891190e861" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="afac72a08e880e338eb3054c3cc4cb3b2c8d874a" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 없기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="fa08b0c059f66a3dd7b2f5959546d1e6588e7a9f" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작업이 불가능 하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 결과 를 반환하는 계산 은 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패 할 수 있습니다 . 경우에 따라 구현시 가능한 오류 원인을 구분할 수 없습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 으로 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fdd36f108f41c6140824253d332a12f73fc5123" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 수있는 운영 체제 권한이 없기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="ea03f394d021d1cd4da4e7fc5d83c7e482c79f96" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f72e0410c352366f2cdd4edcd2b3af6c0cb92e24" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 존재하지 않기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="97941a9e54766e034e75e82cc25885eff0ea6ff1" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작업이 불가능 하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 결과 를 반환하는 모든 계산 은 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패 할 수 있습니다 . 경우에 따라 구현에서 가능한 오류 원인을 구분할 수 없습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 으로 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7d948b579969e230d68945e4ae51508275ca602c" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 수있는 충분한 운영 체제 권한이 없기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="e66b1c80ba834855aae9f9d43d3592e67e98a671" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재 하여 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류 .</target>
        </trans-unit>
        <trans-unit id="84e040a37ce664544af44aa14d72c1c5b1f5fdf7" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 존재하지 않아 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류 .</target>
        </trans-unit>
        <trans-unit id="3aaf153bc2f4b4a705a6640c9e8a13f49833a532" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments is a single-use resource, which is already being used (for example, opening the same file twice for writing might give this error).</source>
          <target state="translated">인수 중 하나가 이미 사용중인 단일 자원이므로 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류입니다 (예 : 동일한 파일을 두 번 열어 쓰기 위해이 오류가 발생할 수 있음).</target>
        </trans-unit>
        <trans-unit id="fbdf1497d8ba0761ae0294d7cba12faf35e238d8" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the device is full.</source>
          <target state="translated">장치가 가득 차서 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="587d82956d47a090dc9d6a33c66777d643e7e317" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the end of file has been reached.</source>
          <target state="translated">파일 끝에 도달 하여 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="0cfca5871ab77adff3cb578bb0516ceb582413e3" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작업이 불가능 하여 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다. &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 결과 를 반환하는 계산 은 &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패 할 수 있습니다 . 경우에 따라 구현시 가능한 오류 원인을 구별하지 못할 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f1a557e45ff222ff19723cc3b00907ab8191320" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 충분한 운영 체제 권한이 없기 때문에 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="502a1695e398902350a22b419e2e0b7872570bf2" translate="yes" xml:space="preserve">
          <source>An error indicating that the operation failed because the resource vanished. See &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리소스가 사라져 작업이 실패했음을 나타내는 오류입니다. &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb8588ea4ffd2451e25b457e42e986ce533b40b9" translate="yes" xml:space="preserve">
          <source>An example from &lt;em&gt;The Craft of Functional Programming&lt;/em&gt;, Simon Thompson (&lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/sjt/&quot;&gt;http://www.cs.kent.ac.uk/people/staff/sjt/&lt;/a&gt;), Addison-Wesley 1999: &quot;Given an arbitrary tree, transform it to a tree of integers in which the original elements are replaced by natural numbers, starting from 0. The same element has to be replaced by the same number at every occurrence, and when we meet an as-yet-unvisited element we have to find a 'new' number to match it with:&quot;</source>
          <target state="translated">에서 예 &lt;em&gt;기능 프로그래밍의 공예&lt;/em&gt; , 사이먼 톰슨 ( &lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/sjt/&quot;&gt;http://www.cs.kent.ac.uk/people/staff/sjt/&lt;/a&gt; ), 애디슨 - 웨슬리 1999 : &quot;나무로 변환, 임의의 나무를 감안할 때 0부터 시작하여 원래 요소가 자연수로 대체되는 정수의 숫자입니다. 동일한 요소는 모든 경우에 같은 숫자로 대체되어야합니다. 아직 미공개 요소를 만나면 '새로운 요소'를 찾아야합니다. '와 일치하는 번호 : &quot;</target>
        </trans-unit>
        <trans-unit id="26553b69de76ef603493e22f9b56e8e8f0e7cc55" translate="yes" xml:space="preserve">
          <source>An example in which using &lt;code&gt;RULES&lt;/code&gt; for specialisation will Win Big:</source>
          <target state="translated">전문화에 &lt;code&gt;RULES&lt;/code&gt; 를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d94ee3fed69a3a2d6cbb28624b1e2c3a6d9674bc" translate="yes" xml:space="preserve">
          <source>An example is shown in the opening example, where &lt;code&gt;sortWith&lt;/code&gt; is supplied with a function that lets it find out the &lt;code&gt;sum salary&lt;/code&gt; for any item in the list comprehension it transforms.</source>
          <target state="translated">예는 시작 예제에 표시되며, &lt;code&gt;sortWith&lt;/code&gt; 에는 변환하는 목록 이해에서 모든 항목에 대한 &lt;code&gt;sum salary&lt;/code&gt; 찾을 수있는 함수가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="92f996a82b303141412a037410a747eab994f16e" translate="yes" xml:space="preserve">
          <source>An example of a pre-processor is to convert your source files to the input encoding that GHC expects, i.e. create a script &lt;code&gt;convert.sh&lt;/code&gt; containing the lines:</source>
          <target state="translated">전 처리기의 예는 소스 파일을 GHC가 기대하는 입력 인코딩으로 변환하는 것입니다. 예를 들어 다음 줄을 포함하는 &lt;code&gt;convert.sh&lt;/code&gt; 스크립트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="46db75079dc947994d3c8f73c95f7d8d5b14f912" translate="yes" xml:space="preserve">
          <source>An example of a suitable Euclidean function, for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;'s instance, is &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 의 경우에 적합한 유클리드 함수 의 예는 &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c01fc02e927a60926df24dbe6dfbd1b4746279b" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 예는 길이에 따라 문자열 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="bd7ad3a60a7ec7010ecf8274734b34b569a3aa76" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 예는 길이에 따라 문자열 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fd78ec4b25edfc34c070db47b86faa55268ea5fe" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 예는 길이에 따라 문자열 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2aef6af3f5288d7dec723009106ae656cb18d0ec" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 예는 길이에 따라 문자열 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="37825ef9057435b5d70e42055abe88a2f5caa9ef" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;Adder.dll&lt;/code&gt; from C++ is:</source>
          <target state="translated">C ++에서 &lt;code&gt;Adder.dll&lt;/code&gt; 을 사용하는 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="284aba923f06dcb4f47c7f3c609dae9afb54f97b" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;Adder.dll&lt;/code&gt; from VBA is:</source>
          <target state="translated">VBA에서 &lt;code&gt;Adder.dll&lt;/code&gt; 을 사용하는 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a2f6a683146590a81cb59662a6f31a14e0007fe" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;lookup&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;lookup&lt;/code&gt; 사용의 예 :</target>
        </trans-unit>
        <trans-unit id="62a7372438651bafa2669d1145fa021654f7a3ee" translate="yes" xml:space="preserve">
          <source>An example use of this library for a simple read-eval-print loop (REPL) is the following:</source>
          <target state="translated">간단한 REPL (read-eval-print loop)에이 라이브러리를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57f1733124f33be242778620a4eb6cdc6409382d" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 모나드 와 함께 &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; 를 사용하는 예제 :</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="381e8e3e19da9b996ca14e0adbfa4195c12da0b2" translate="yes" xml:space="preserve">
          <source>An exception thrown to a thread by &lt;code&gt;&lt;a href=&quot;system-timeout#v:timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; to interrupt a timed-out computation.</source>
          <target state="translated">시간 초과 계산을 중단하기 위해 시간 &lt;code&gt;&lt;a href=&quot;system-timeout#v:timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 에 의해 스레드에 throw되는 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="a213b0b1515044c4c78bd78637c0113c5cd8be80" translate="yes" xml:space="preserve">
          <source>An exception to be thrown.</source>
          <target state="translated">예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="fdf570a64c3420a5e9dc66825959db440f96c3c1" translate="yes" xml:space="preserve">
          <source>An exception type for representing Unicode encoding errors.</source>
          <target state="translated">유니 코드 인코딩 오류를 나타내는 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="efb9885da89ae0153ca6bd437d81d85bcf6d2a5e" translate="yes" xml:space="preserve">
          <source>An exception-safe wrapper for modifying the contents of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; will replace the original contents of the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if an exception is raised during the operation. This function is only atomic if there are no other producers for this &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 수정하기위한 예외 안전 래퍼입니다 . 마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; 이 의 원래 내용 대체 할 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 예외가 작동 중에 발생합니다. 이 함수는이 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 다른 생산자가없는 경우에만 원자 적 입니다.</target>
        </trans-unit>
        <trans-unit id="f7bad0722f6e1639c9b8bf58917fbc9a749282ca" translate="yes" xml:space="preserve">
          <source>An experimental flag to expose all unfoldings, even for very large or recursive functions. This allows for all functions to be inlined while usually GHC would avoid inlining larger functions.</source>
          <target state="translated">매우 크거나 재귀적인 함수에서도 모든 전개를 표시하는 실험용 플래그입니다. 이를 통해 모든 함수를 인라인 할 수 있지만 일반적으로 GHC는 더 큰 함수를 인라인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcc169bba3c04120ce581359b5205c6e6861fa64" translate="yes" xml:space="preserve">
          <source>An expression</source>
          <target state="translated">표현</target>
        </trans-unit>
        <trans-unit id="5b3e9db1ce65c03995d328bea346bec14a73a082" translate="yes" xml:space="preserve">
          <source>An expression that didn't typecheck during compile time was called. This is only possible with -fdefer-type-errors. The &lt;code&gt;String&lt;/code&gt; gives details about the failed type check.</source>
          <target state="translated">컴파일 시간 동안 타입 검사를하지 않은 표현식이 호출되었습니다. 이것은 -fdefer-type-errors에서만 가능합니다. &lt;code&gt;String&lt;/code&gt; 실패한 유형 검사에 대한 세부 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="23d6c8ea4520ef478bc2079b23a73769921d85ca" translate="yes" xml:space="preserve">
          <source>An expression type signature (&lt;a href=&quot;#exp-type-sigs&quot;&gt;Expression type signatures&lt;/a&gt;)</source>
          <target state="translated">표현식 유형 서명 ( &lt;a href=&quot;#exp-type-sigs&quot;&gt;표현식 유형 서명&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="befd82a9275f38fcab59cee9b3a9893ec9498cda" translate="yes" xml:space="preserve">
          <source>An expression type signature that has &lt;em&gt;explicit&lt;/em&gt; quantification (using &lt;code&gt;forall&lt;/code&gt;) brings into scope the explicitly-quantified type variables, in the annotated expression. For example:</source>
          <target state="translated">&lt;em&gt;명시 적&lt;/em&gt; 정량화 ( &lt;code&gt;forall&lt;/code&gt; 사용 ) 가있는 표현식 유형 시그니처 는 어노테이션이있는 표현식에서 명시 적으로 정량화 된 유형 변수의 범위를 가져옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b82cc29cb694eff0d6c543cfd3b0fa40875fc57b" translate="yes" xml:space="preserve">
          <source>An extended Haskell interface file, produced by the Haskell compiler.</source>
          <target state="translated">Haskell 컴파일러에 의해 생성 된 확장 된 Haskell 인터페이스 파일.</target>
        </trans-unit>
        <trans-unit id="06078bbc223f3f2c54001e817424da6925e7e456" translate="yes" xml:space="preserve">
          <source>An extra flag to pass to the C compiler.</source>
          <target state="translated">C 컴파일러에 전달할 추가 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="4ada7ba8223269b5dc2b7e6f71e6be14db026a01" translate="yes" xml:space="preserve">
          <source>An extra flag to pass to the linker.</source>
          <target state="translated">링커에 전달할 추가 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="ff063cb1c991404edd003923980f0718291bfcf8" translate="yes" xml:space="preserve">
          <source>An extra-constraints wildcard can also lead to zero extra constraints to be inferred, e.g.</source>
          <target state="translated">추가 제약 조건 와일드 카드를 사용하면 추론 할 제약이 전혀 없습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8737dcbc364a0104937da45530e573d364b0ae37" translate="yes" xml:space="preserve">
          <source>An extra-constraints wildcard shouldn&amp;rsquo;t prevent the programmer from already listing the constraints he knows or wants to annotate, e.g.</source>
          <target state="translated">제약 조건이있는 와일드 카드는 프로그래머가 자신이 알고 있거나 주석을 달고 싶은 제약 조건을 이미 나열하지 못하게해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d29ed66c17bed0542d86b370f6bc6043d2a378e4" translate="yes" xml:space="preserve">
          <source>An extremely light-weight, fast, and limited representation of a string of up to (2*WORDSIZE - 2) bits. In fact, there are two representations, misleadingly named bit queue builder and bit queue. The builder supports only &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:emptyQB&quot;&gt;emptyQB&lt;/a&gt;&lt;/code&gt;, creating an empty builder, and &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:snocQB&quot;&gt;snocQB&lt;/a&gt;&lt;/code&gt;, enqueueing a bit. The bit queue builder is then turned into a bit queue using &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:buildQ&quot;&gt;buildQ&lt;/a&gt;&lt;/code&gt;, after which bits can be removed one by one using &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:unconsQ&quot;&gt;unconsQ&lt;/a&gt;&lt;/code&gt;. If the size limit is exceeded, further operations will silently produce nonsense.</source>
          <target state="translated">최대 (2 * WORDSIZE-2) 비트의 문자열을 매우 가볍고 빠르며 제한적으로 표현합니다. 실제로 비트 큐 빌더와 비트 큐라는 두 가지 표현이 있습니다. 빌더는 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:emptyQB&quot;&gt;emptyQB&lt;/a&gt;&lt;/code&gt; 만 지원 하고 빈 빌더는 작성하고 snocQB는 비트를 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:snocQB&quot;&gt;snocQB&lt;/a&gt;&lt;/code&gt; 에 넣습니다. 비트 큐 빌더는 사용 비트 큐로 온 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:buildQ&quot;&gt;buildQ&lt;/a&gt;&lt;/code&gt; 를 비트하여 하나씩 제거 할 수있는 후 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:unconsQ&quot;&gt;unconsQ&lt;/a&gt;&lt;/code&gt; 를 . 크기 제한을 초과하면 추가 작업이 자동으로 넌센스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4a1b2653a1c9d958510f1ed844f74e8ecb8d1c49" translate="yes" xml:space="preserve">
          <source>An idiom that is common in some languages is to find the numeric offset of a character or substring, then use that number to split or trim the searched string. With a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value, this approach would require two O(n) operations: one to perform the search, and one to operate from wherever the search ended.</source>
          <target state="translated">일부 언어에서 일반적으로 사용되는 관용구는 문자 또는 하위 문자열의 숫자 오프셋을 찾은 다음 해당 숫자를 사용하여 검색된 문자열을 분할하거나 자릅니다. &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 사용하면 이 방법에는 두 가지 O (n) 작업이 필요합니다. 하나는 검색을 수행하고 다른 하나는 검색이 끝난 곳에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="67c017344c03d68395eeb6821615e8a8bfe1033a" translate="yes" xml:space="preserve">
          <source>An idle-time garbage collection has been started.</source>
          <target state="translated">유휴 시간 가비지 콜렉션이 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d426bd25abbccce84e0bdf47cb062c833bbb269" translate="yes" xml:space="preserve">
          <source>An illustrative example for these strictness properties is the implementation of Base64 decoding (&lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;http://en.wikipedia.org/wiki/Base64&lt;/a&gt;).</source>
          <target state="translated">이러한 엄격 성 속성의 예는 Base64 디코딩 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;http://en.wikipedia.org/wiki/Base64&lt;/a&gt; ) 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="dbd827594115c2bfaffbdec57e877da3c74390fc" translate="yes" xml:space="preserve">
          <source>An illustrative example for these strictness properties is the implementation of Base64 decoding (&lt;a href=&quot;https://en.wikipedia.org/wiki/Base64&quot;&gt;http://en.wikipedia.org/wiki/Base64&lt;/a&gt;).</source>
          <target state="translated">이러한 엄격 성 속성에 대한 예시적인 예는 Base64 디코딩 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Base64&quot;&gt;http://en.wikipedia.org/wiki/Base64&lt;/a&gt; ) 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="d20888eadb4852094fcef2f3603d26df3e4539de" translate="yes" xml:space="preserve">
          <source>An implementation is entitled to assume the following laws about these operations:</source>
          <target state="translated">구현시 이러한 작업에 대해 다음 법률을 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dd9779568fb3b84f00870e9c9dc5e99b34e41c6" translate="yes" xml:space="preserve">
          <source>An implementation is free to flush the buffer more frequently, but not less frequently, than specified above. The output buffer is emptied as soon as it has been written out.</source>
          <target state="translated">구현은 위에서 지정한 것보다 더 자주 버퍼를 플러시 할 수 있습니다. 출력 버퍼는 기록 되 자마자 비워집니다.</target>
        </trans-unit>
        <trans-unit id="764ec8855ef58c6a8f42aecb228f30ad41274dec" translate="yes" xml:space="preserve">
          <source>An implementation of the old &lt;code&gt;atomicModifyMutVar#&lt;/code&gt; primop in terms of the new &lt;code&gt;&lt;a href=&quot;ghc-exts#v:atomicModifyMutVar2-35-&quot;&gt;atomicModifyMutVar2#&lt;/a&gt;&lt;/code&gt; primop, for backwards compatibility. The type of this function is a bit bogus. It's best to think of it as having type</source>
          <target state="translated">이전 버전과의 호환성을 위해 새로운 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:atomicModifyMutVar2-35-&quot;&gt;atomicModifyMutVar2#&lt;/a&gt;&lt;/code&gt; primop과 관련 하여 이전 &lt;code&gt;atomicModifyMutVar#&lt;/code&gt; primop 구현 . 이 함수의 유형은 약간 가짜입니다. 유형을 갖는 것으로 생각하는 것이 가장 좋습니다</target>
        </trans-unit>
        <trans-unit id="055bfb77bc4911c1d902e9c7e877458502ecd8a2" translate="yes" xml:space="preserve">
          <source>An implicit parameter is &lt;em&gt;bound&lt;/em&gt; using the standard &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; binding forms. For example, we define the &lt;code&gt;min&lt;/code&gt; function by binding &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">암시 적 매개 변수는 표준 &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;where&lt;/code&gt; 바인딩 양식을 사용하여 &lt;em&gt;바인드&lt;/em&gt; 됩니다 . 예를 들어 &lt;code&gt;cmp&lt;/code&gt; 를 바인딩 하여 &lt;code&gt;min&lt;/code&gt; 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="83f900390293c670e8a8d65bb9afeb5cc8fcf2b6" translate="yes" xml:space="preserve">
          <source>An implicit parameter occurs in an expression using the special form &lt;code&gt;?x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is any valid identifier (e.g. &lt;code&gt;ord ?x&lt;/code&gt; is a valid expression). Use of this construct also introduces a new dynamic-binding constraint in the type of the expression. For example, the following definition shows how we can define an implicitly parameterised sort function in terms of an explicitly parameterised &lt;code&gt;sortBy&lt;/code&gt; function:</source>
          <target state="translated">암시 적 매개 변수는 특수 형식 &lt;code&gt;?x&lt;/code&gt; 사용하는 표현식에서 발생합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 유효한 식별자입니다 (예 : &lt;code&gt;ord ?x&lt;/code&gt; 는 유효한 표현식). 이 구문을 사용하면 표현식 유형에 새로운 동적 바인딩 제약 조건이 도입됩니다. 예를 들어, 다음 정의는 명시 적으로 매개 변수화 된 &lt;code&gt;sortBy&lt;/code&gt; 함수 와 관련하여 내재적으로 매개 변수화 된 정렬 함수를 정의하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="2e728fe00beb5b98842848d858c512e28ed428db" translate="yes" xml:space="preserve">
          <source>An implicit-parameter binding group must be a collection of simple bindings to implicit-style variables (no function-style bindings, and no type signatures); these bindings are neither polymorphic or recursive.</source>
          <target state="translated">내재적 매개 변수 바인딩 그룹은 내재적 스타일 변수 (함수 스타일 바인딩 및 유형 서명 없음)에 대한 단순 바인딩 콜렉션이어야합니다. 이들 결합은 다형성 또는 재귀 적이 지 않다.</target>
        </trans-unit>
        <trans-unit id="055d0a98d0fca1648c6546c9fc6ca5cb2c9b9157" translate="yes" xml:space="preserve">
          <source>An implicit-parameter type constraint differs from other type class constraints in the following way: All uses of a particular implicit parameter must have the same type. This means that the type of &lt;code&gt;(?x, ?x)&lt;/code&gt; is &lt;code&gt;(?x::a) =&amp;gt; (a,a)&lt;/code&gt;, and not &lt;code&gt;(?x::a, ?x::b) =&amp;gt; (a, b)&lt;/code&gt;, as would be the case for type class constraints.</source>
          <target state="translated">내재적 매개 변수 유형 제한 조건은 다음 방식에서 다른 유형 클래스 제한 조건과 다릅니다. 특정 내재적 매개 변수의 모든 사용은 동일한 유형을 가져야합니다. 이는 &lt;code&gt;(?x::a) =&amp;gt; (a,a)&lt;/code&gt; &lt;code&gt;(?x, ?x)&lt;/code&gt; 의 유형 이 (? x :: a &lt;code&gt;(?x::a, ?x::b) =&amp;gt; (a, b)&lt;/code&gt; 아닌 (? x :: a) =&amp;gt; (a, a)입니다. ) , 유형 클래스 제약 조건의 경우와 같습니다.</target>
        </trans-unit>
        <trans-unit id="06fa3a1fc7569e6b102829c5e3a0c13f3b3b71a7" translate="yes" xml:space="preserve">
          <source>An infinitely &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value hangs:</source>
          <target state="translated">무한 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 값이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="48ffc89b558ed7d94c8d0903a4ca6f8c47772a67" translate="yes" xml:space="preserve">
          <source>An infinitely &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value hangs:</source>
          <target state="translated">무한한 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 값은 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="41e571a04d49adc778f99f9915a653a4d8383f97" translate="yes" xml:space="preserve">
          <source>An infix synonym for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 접두사 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="676b0466c764d24182ade55c20826949e1613615" translate="yes" xml:space="preserve">
          <source>An infix synonym for &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 접두사 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="45e7ca78829cc48699173c5bd84e19553844a4fb" translate="yes" xml:space="preserve">
          <source>An initial environment.</source>
          <target state="translated">초기 환경.</target>
        </trans-unit>
        <trans-unit id="032f25891e62fb8921b2ffd173fccd585c489d81" translate="yes" xml:space="preserve">
          <source>An installed package is either &lt;em&gt;exposed&lt;/em&gt; or &lt;em&gt;hidden&lt;/em&gt; by default. Packages hidden by default are listed in parentheses (e.g. &lt;code&gt;(lang-1.0)&lt;/code&gt;), or possibly in blue if your terminal supports colour, in the output of &lt;code&gt;ghc-pkg list&lt;/code&gt;. Command-line flags, described below, allow you to expose a hidden package or hide an exposed one. Only modules from exposed packages may be imported by your Haskell code; if you try to import a module from a hidden package, GHC will emit an error message. It should be noted that a hidden package might still get linked with your program as a dependency of an exposed package, it is only restricted from direct imports.</source>
          <target state="translated">설치된 패키지는 기본적으로 &lt;em&gt;노출&lt;/em&gt; 되거나 &lt;em&gt;숨겨집니다&lt;/em&gt; . 기본적으로 숨겨진 패키지 는 &lt;code&gt;ghc-pkg list&lt;/code&gt; 출력 에서 괄호 (예 : &lt;code&gt;(lang-1.0)&lt;/code&gt; ) 또는 터미널이 색상을 지원하는 경우 파란색으로 표시 됩니다. 아래 설명 된 명령 줄 플래그를 사용하면 숨겨진 패키지를 노출하거나 노출 된 패키지를 숨길 수 있습니다. 노출 된 패키지의 모듈 만 Haskell 코드로 가져올 수 있습니다. 숨겨진 패키지에서 모듈을 가져 오려고하면 GHC에서 오류 메시지가 표시됩니다. 숨겨진 패키지는 노출 된 패키지의 종속성으로 여전히 프로그램과 연결될 수 있으며 직접 가져 오기에서만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6e9e64155c356c6955cab41597813ffebcaa65a5" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 유형에 따라 this 및 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; 또는 통합 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d84b0a9b1da15cdbb5efba9440685e88ebcccf36" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 것에 따라 this와 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; 또는 unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="771255935064afcdb9c5d67ea14ceedd0c402b64" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 방법에 따라 this 및 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; 또는 통합 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c91e8ae7413d71da86962a384a3de3aff328dd8d" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 유형에 따라 this 및 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; 또는 통합 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9505be87e1ced40bfc25bab37f391a9491bdd4ef" translate="yes" xml:space="preserve">
          <source>An instance can define either this unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 것에 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; 통합 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 또는 rotateL 과 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f6f1ff04bfa289ae107fe2cb73d2dc665d5edae" translate="yes" xml:space="preserve">
          <source>An instance can define either this unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 것에 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; 통합 된 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 또는 shiftL 과 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b91c1218cc10bd9b2d241b41fc654dedb75905ac" translate="yes" xml:space="preserve">
          <source>An instance declaration has the form</source>
          <target state="translated">인스턴스 선언의 형식은</target>
        </trans-unit>
        <trans-unit id="26c153920f2310699986516df24fc799108ac963" translate="yes" xml:space="preserve">
          <source>An instance declaration in a module &lt;code&gt;M&lt;/code&gt; is an &lt;em&gt;orphan instance&lt;/em&gt; if</source>
          <target state="translated">모듈 인스턴스에서 선언 &lt;code&gt;M&lt;/code&gt; 은 이다 &lt;em&gt;고아 인스턴스&lt;/em&gt; 경우</target>
        </trans-unit>
        <trans-unit id="0422a1c1ceadfc36e077b4145e342be0d4fe9752" translate="yes" xml:space="preserve">
          <source>An instance declaration in a module &lt;code&gt;M&lt;/code&gt; is an &lt;em&gt;orphan instance&lt;/em&gt; if orphan instance</source>
          <target state="translated">모듈 &lt;code&gt;M&lt;/code&gt; 의 인스턴스 선언 은 &lt;em&gt;고아 인스턴스 인&lt;/em&gt; 경우 고아 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="f659879efb627bdd5cecbbab282a1e9e47a6cd51" translate="yes" xml:space="preserve">
          <source>An instance declaration is &lt;em&gt;more specific&lt;/em&gt; than another iff the head of former is a substitution instance of the latter. For example (D) is &amp;ldquo;more specific&amp;rdquo; than (C) because you can get from (C) to (D) by substituting &lt;code&gt;a := Int&lt;/code&gt;.</source>
          <target state="translated">인스턴스 선언은 전자의 헤드가 후자의 대체 인스턴스 인 경우 다른 것보다 &lt;em&gt;더 구체적&lt;/em&gt; 입니다. 예를 들어 &lt;code&gt;a := Int&lt;/code&gt; 대체 하여 (C)에서 (D)로 갈 수 있기 때문에 (D)는 (C)보다&amp;ldquo;더 구체적&amp;rdquo; 입니다.</target>
        </trans-unit>
        <trans-unit id="a925b49f0219e891d285365b66dce29fa02d0e7e" translate="yes" xml:space="preserve">
          <source>An instance for an associated family can only appear as part of an instance declarations of the class in which the family was declared, just as with the equations of the methods of a class.</source>
          <target state="translated">연관된 패밀리의 인스턴스는 클래스의 메소드 방정식과 마찬가지로 패밀리가 선언 된 클래스의 인스턴스 선언의 일부로 만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6797a394b5a38cb77951470781b2ae0ce53d676c" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;incoherent&lt;/em&gt; if: it has an &lt;code&gt;INCOHERENT&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음과 같은 경우 인스턴스가 &lt;em&gt;일관성이&lt;/em&gt; 없습니다. &lt;code&gt;INCOHERENT&lt;/code&gt; pragma가 있습니다. 또는 인스턴스에 pragma가없고 &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈에 나타나는 경우 .</target>
        </trans-unit>
        <trans-unit id="0b66884ab42d5d8b014e6fc23b4324da15721d24" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;overlappable&lt;/em&gt; if: it has an &lt;code&gt;OVERLAPPABLE&lt;/code&gt; or &lt;code&gt;OVERLAPS&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt;; or if the instance is incoherent.</source>
          <target state="translated">&lt;code&gt;OVERLAPPABLE&lt;/code&gt; 또는 &lt;code&gt;OVERLAPS&lt;/code&gt; pragma 가있는 인스턴스는 &lt;em&gt;겹칠&lt;/em&gt; 수 있습니다 . 또는 인스턴스에 pragma가없고 &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈에 나타나는 경우 ; 또는 인스턴스가 일관성이없는 경우.</target>
        </trans-unit>
        <trans-unit id="c64945d958795bcda270b74e76ecf8e08588cfbe" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;overlapping&lt;/em&gt; if: it has an &lt;code&gt;OVERLAPPING&lt;/code&gt; or &lt;code&gt;OVERLAPS&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt;; or if the instance is incoherent.</source>
          <target state="translated">다음과 같은 경우 인스턴스가 &lt;em&gt;겹칩니다&lt;/em&gt; . &lt;code&gt;OVERLAPPING&lt;/code&gt; 또는 &lt;code&gt;OVERLAPS&lt;/code&gt; pragma가 있습니다. 또는 인스턴스에 pragma가없고 &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈에 나타나는 경우 ; 또는 인스턴스가 일관성이없는 경우.</target>
        </trans-unit>
        <trans-unit id="da552798a9dccf85004f0b6505ae33c512663e04" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; is provided, which implements exact equality modulo reordering of the tags in the &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; 필드 에서 태그의 정확한 동등한 모듈로 재정렬을 구현하는 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 의 인스턴스 가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="41664f4a7f5f1d180ac492e6274bf660ab0d02d1" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is also provided, which gives lexicographic ordering on the &lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt; fields (i.e. 2.1 &amp;gt; 2.0, 1.2.3 &amp;gt; 1.2.2, etc.). This is expected to be sufficient for many uses, but note that you may need to use a more specific ordering for your versioning scheme. For example, some versioning schemes may include pre-releases which have tags &lt;code&gt;&quot;pre1&quot;&lt;/code&gt;, &lt;code&gt;&quot;pre2&quot;&lt;/code&gt;, and so on, and these would need to be taken into account when determining ordering. In some cases, date ordering may be more appropriate, so the application would have to look for &lt;code&gt;date&lt;/code&gt; tags in the &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; field and compare those. The bottom line is, don't always assume that &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; and other &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; operations are the right thing for every &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt; 필드 (예 : 2.1&amp;gt; 2.0, 1.2.3&amp;gt; 1.2.2 등) 에서 사전 순서를 제공하는 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 도 제공됩니다 . 이것은 많은 용도에 충분할 것으로 예상되지만 버전 관리 체계에 대해보다 구체적인 순서를 사용해야 할 수도 있습니다. 예를 들어, 일부 버전 관리 체계에는 &lt;code&gt;&quot;pre1&quot;&lt;/code&gt; , &lt;code&gt;&quot;pre2&quot;&lt;/code&gt; 등의 태그가있는 시험판이 포함될 수 있으며 순서를 결정할 때이를 고려해야합니다. 경우에 따라 날짜 순서가 더 적절할 수 있으므로 응용 프로그램은 &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; 필드 에서 &lt;code&gt;date&lt;/code&gt; 태그를 찾아서 비교해야합니다. 결론은, 항상 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 한다고 가정하지 마십시오다른 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 작업은 모든 &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; 적합한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fdfa656ab79a71bc26c499aa546810046ca396ff" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:MonadException&quot;&gt;MonadException&lt;/a&gt;&lt;/code&gt; is generally made up of monad transformers layered on top of the IO monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:MonadException&quot;&gt;MonadException&lt;/a&gt;&lt;/code&gt; 의 인스턴스 는 일반적으로 IO 모나드 위에 계층화 된 모나드 변환기로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef31ea41a9ba018762805e0743531d210cd6284" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Stream&lt;/code&gt; has stream type &lt;code&gt;s&lt;/code&gt;, underlying monad &lt;code&gt;m&lt;/code&gt; and token type &lt;code&gt;t&lt;/code&gt; determined by the stream</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 의 인스턴스 에는 스트림 유형 &lt;code&gt;s&lt;/code&gt; , 기본 모나드 &lt;code&gt;m&lt;/code&gt; 및 토큰 유형 &lt;code&gt;t&lt;/code&gt; 가 스트림에 의해 결정됩니다</target>
        </trans-unit>
        <trans-unit id="182b96f131379637cff152270abf17ec6ecf1c40" translate="yes" xml:space="preserve">
          <source>An integer denoting the number &lt;code&gt;l&lt;/code&gt; of printed completions,</source>
          <target state="translated">인쇄 완료 수 &lt;code&gt;l&lt;/code&gt; 을 나타내는 정수</target>
        </trans-unit>
        <trans-unit id="5705ba72313d6782ee3dec31edcfe71a4e6bfe65" translate="yes" xml:space="preserve">
          <source>An integer literal &lt;code&gt;368&lt;/code&gt; means &amp;ldquo;&lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;&amp;rdquo;, rather than &amp;ldquo;&lt;code&gt;Prelude.fromInteger (368::Integer)&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">정수 리터럴 ( &lt;code&gt;368&lt;/code&gt; ) 은 &quot; &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt; &quot;가 아니라 &quot; &lt;code&gt;Prelude.fromInteger (368::Integer)&lt;/code&gt; &quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7fcfdbe8f2cac93c2ec79190607c573c3d60d86c" translate="yes" xml:space="preserve">
          <source>An intermediate result in a scan.</source>
          <target state="translated">스캔의 중간 결과.</target>
        </trans-unit>
        <trans-unit id="4fdb6e08d830a1c3979bfdc3fd7343eb5abdfb8f" translate="yes" xml:space="preserve">
          <source>An invocation of GHC takes the following form:</source>
          <target state="translated">GHC 호출은 다음 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="edb1f7c1dc03b67ee6b809077f9e5604578eb554" translate="yes" xml:space="preserve">
          <source>An llvm-intermediate-language bitcode file, usually produced by the compiler.</source>
          <target state="translated">일반적으로 컴파일러에서 생성되는 llvm-intermediate-language 비트 코드 파일입니다.</target>
        </trans-unit>
        <trans-unit id="11d0526a9a9e3e29d8774eda5075a8938912393d" translate="yes" xml:space="preserve">
          <source>An llvm-intermediate-language source file, usually produced by the compiler.</source>
          <target state="translated">일반적으로 컴파일러에서 생성되는 llvm-intermediate-language 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2e0a23e4bb2863d568c7f363da30cd3b735cae06" translate="yes" xml:space="preserve">
          <source>An object &lt;code&gt;B&lt;/code&gt; retains object &lt;code&gt;A&lt;/code&gt; if (i) &lt;code&gt;B&lt;/code&gt; is a retainer object and (ii) object &lt;code&gt;A&lt;/code&gt; can be reached by recursively following pointers starting from object &lt;code&gt;B&lt;/code&gt;, but not meeting any other retainer objects on the way. Each live object is retained by one or more retainer objects, collectively called its retainer set, or its retainer set, or its retainers.</source>
          <target state="translated">(i) &lt;code&gt;B&lt;/code&gt; 가 리테이너 객체이고 (ii) 객체 &lt;code&gt;B&lt;/code&gt; 에서 시작하는 포인터를 재귀 적으로 따라 가지만 도중에 다른 리테이너 객체를 만나지 않으면 객체 &lt;code&gt;A&lt;/code&gt; 에 도달 할 수있는 경우 객체 &lt;code&gt;B&lt;/code&gt; 는 객체 &lt;code&gt;A&lt;/code&gt; 를 유지합니다 . 각 라이브 오브젝트는 하나 이상의 리테이너 오브젝트에 의해 보유되며, 집합 적으로 보유자 세트 또는 보유자 세트 또는 보유자라고합니다.</target>
        </trans-unit>
        <trans-unit id="42910c59b4eb5fc3b9c19c32b311eab9e4bf6a36" translate="yes" xml:space="preserve">
          <source>An object file, produced by an assembler.</source>
          <target state="translated">어셈블러에서 생성 한 객체 파일입니다.</target>
        </trans-unit>
        <trans-unit id="18c88b3ac1bd46ecfef3ff8276bc55927b9a64fe" translate="yes" xml:space="preserve">
          <source>An object which is never used is said to be in the void state for its whole lifetime.</source>
          <target state="translated">사용하지 않은 물체는 전체 수명 동안 공극 상태에 있다고합니다.</target>
        </trans-unit>
        <trans-unit id="5199083ec8a4ed3cb5139c93d4aeb1ab1a44d8f3" translate="yes" xml:space="preserve">
          <source>An offset, counted in bytes.</source>
          <target state="translated">바이트 단위로 계산 된 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="4e93ce4db75561be705e22c1086fdc986365d26d" translate="yes" xml:space="preserve">
          <source>An operator version of &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 운영자 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="269ede13d98d287f0dd18a20f718823a44965f42" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;E&lt;/code&gt; character indicates an alternate formatting. Currently this only affects &lt;code&gt;%Z&lt;/code&gt; and &lt;code&gt;%z&lt;/code&gt;.</source>
          <target state="translated">선택적인 &lt;code&gt;E&lt;/code&gt; 문자는 대체 형식을 나타냅니다. 현재 이것은 &lt;code&gt;%Z&lt;/code&gt; 및 &lt;code&gt;%z&lt;/code&gt; 에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="147554bd72cb36203ba4e437f86b5856939ecef7" translate="yes" xml:space="preserve">
          <source>An optional escape character</source>
          <target state="translated">선택적 이스케이프 문자</target>
        </trans-unit>
        <trans-unit id="470bd4645aa2a37d61b6006cf88e182f77dda35b" translate="yes" xml:space="preserve">
          <source>An overloaded interface to mutable arrays. For array types which can be used with this interface, see &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;, &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt;, and &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable&lt;/a&gt;.</source>
          <target state="translated">가변 배열에 대한 오버로드 된 인터페이스. 이 인터페이스와 함께 사용할 수있는 배열 유형은 &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt; , &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt; 및 &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed76ddf939d258125a9d07e26bf81d6563190100" translate="yes" xml:space="preserve">
          <source>An overloaded interface to mutable arrays. For array types which can be used with this interface, see &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;, &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt;, and &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable&lt;/a&gt;. . Safe API only of &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt;.</source>
          <target state="translated">가변 배열에 대한 오버로드 된 인터페이스. 이 인터페이스와 함께 사용할 수있는 배열 유형은 &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt; , &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt; 및 &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable을&lt;/a&gt; 참조하십시오 . . &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray의&lt;/a&gt; 안전한 API .</target>
        </trans-unit>
        <trans-unit id="b46b21c3d0ad448b7dbfafad15287d739812f46d" translate="yes" xml:space="preserve">
          <source>An overloaded label &amp;ldquo;&lt;code&gt;#foo&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;fromLabel @&quot;foo&quot;&lt;/code&gt;&amp;rdquo;, rather than &amp;ldquo;&lt;code&gt;GHC.OverloadedLabels.fromLabel @&quot;foo&quot;&lt;/code&gt;&amp;rdquo; (see &lt;a href=&quot;#overloaded-labels&quot;&gt;Overloaded labels&lt;/a&gt;).</source>
          <target state="translated">오버로드 된 레이블 &quot; &lt;code&gt;#foo&lt;/code&gt; &quot;는 &quot; &lt;code&gt;fromLabel @&quot;foo&quot;&lt;/code&gt; &quot;가 아니라 &quot; &lt;code&gt;GHC.OverloadedLabels.fromLabel @&quot;foo&quot;&lt;/code&gt; &quot;를 의미합니다 ( &lt;a href=&quot;#overloaded-labels&quot;&gt;오버로드 된 레이블&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="13ae824d56d65e3bd4e71208269f6dcaeae34e0a" translate="yes" xml:space="preserve">
          <source>An overloaded label &amp;ldquo;&lt;code&gt;#foo&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;fromLabel @&quot;foo&quot;&lt;/code&gt;&amp;rdquo;, rather than &amp;ldquo;&lt;code&gt;GHC.OverloadedLabels.fromLabel @&quot;foo&quot;&lt;/code&gt;&amp;rdquo; (see &lt;a href=&quot;overloaded_labels#overloaded-labels&quot;&gt;Overloaded labels&lt;/a&gt;).</source>
          <target state="translated">오버로드 된 레이블 &quot; &lt;code&gt;#foo&lt;/code&gt; &quot;는 &quot; &lt;code&gt;fromLabel @&quot;foo&quot;&lt;/code&gt; &quot;가 아니라 &quot; &lt;code&gt;GHC.OverloadedLabels.fromLabel @&quot;foo&quot;&lt;/code&gt; &quot;를 의미합니다 ( &lt;a href=&quot;overloaded_labels#overloaded-labels&quot;&gt;오버로드 된 레이블&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9468ea5c26fba1b901ed7aacb46a3a82ed93f64b" translate="yes" xml:space="preserve">
          <source>An un-associated open type or data family declaration &lt;em&gt;always&lt;/em&gt; has a CUSK; un-annotated type variables default to kind &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">관련되지 않은 개방형 또는 데이터 패밀리 선언 에는 &lt;em&gt;항상&lt;/em&gt; CUSK가 있습니다. 주석이없는 유형 변수는 기본적으로 kind &lt;code&gt;Type&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="130b0c42eca7246bf15b8c958b406f7273873440" translate="yes" xml:space="preserve">
          <source>An unbounded size unsigned integer type is available with &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제한없는 크기의 부호없는 정수 유형은 &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="860459917b5a02de589e908d125eff6b77571ea2" translate="yes" xml:space="preserve">
          <source>An unboxed sum of the given reps</source>
          <target state="translated">주어진 담당자의 상자에 넣지 않은 합계</target>
        </trans-unit>
        <trans-unit id="7a6c34e18a2ffbd1385e4ed434dc780b5897e179" translate="yes" xml:space="preserve">
          <source>An unboxed tuple of the given reps</source>
          <target state="translated">주어진 담당자의 박스형 튜플</target>
        </trans-unit>
        <trans-unit id="58d8e58dbcaf88f766575185e1685146830b08ca" translate="yes" xml:space="preserve">
          <source>An unevaluated spark has been garbage collected.</source>
          <target state="translated">평가되지 않은 스파크가 가비지 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="6dc5e3262cb4421f0eecc8b241d84ce50b4e2631" translate="yes" xml:space="preserve">
          <source>An uninitialised record field was used. The &lt;code&gt;String&lt;/code&gt; gives information about the source location where the record was constructed.</source>
          <target state="translated">초기화되지 않은 레코드 필드가 사용되었습니다. &lt;code&gt;String&lt;/code&gt; 레코드가 건설 된 소스 위치에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="35d4a9def65ccb498f533dbeaee2b2071da0bbc7" translate="yes" xml:space="preserve">
          <source>An unqualified name; dynamically bound</source>
          <target state="translated">규정되지 않은 이름. 동적으로 바인딩</target>
        </trans-unit>
        <trans-unit id="dd607d2def70825ae686680e0742f5955f4c5559" translate="yes" xml:space="preserve">
          <source>An unsigned integral type that can be losslessly converted to and from &lt;code&gt;Ptr&lt;/code&gt;. This type is also compatible with the C99 type &lt;code&gt;uintptr_t&lt;/code&gt;, and can be marshalled to and from that type safely.</source>
          <target state="translated">&lt;code&gt;Ptr&lt;/code&gt; 과 무손실로 변환 할 수있는 부호없는 정수 유형입니다 . 이 유형은 C99 유형 &lt;code&gt;uintptr_t&lt;/code&gt; 와도 호환되며 해당 유형과 안전하게 마샬링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14042e31bb5752011e77595736a7c337f4b6cf90" translate="yes" xml:space="preserve">
          <source>And a response file &lt;code&gt;args.txt&lt;/code&gt;:</source>
          <target state="translated">응답 파일 &lt;code&gt;args.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cbd0ba0de747b34708a0f30527430f5a5c552189" translate="yes" xml:space="preserve">
          <source>And five warning flags:</source>
          <target state="translated">5 개의 경고 플래그 :</target>
        </trans-unit>
        <trans-unit id="bec77e7ebcf7d86b1c8bc9d49ea2a2b98175dacc" translate="yes" xml:space="preserve">
          <source>And indeed some efficiency may be gained by directly defining both, avoiding some indirection in the default definitions that express one in terms of the other. If you implement just one, likely &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; is the better choice.</source>
          <target state="translated">그리고 실제로 두 가지 모두를 직접 정의함으로써 어느 정도의 효율성을 얻을 수 있으며, 하나를 다른 용어로 표현하는 기본 정의에서 일부 간접적 인 것을 피할 수 있습니다. 하나만 구현하는 경우 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 가 더 나은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="523755b21b99024bbe43a1c9df96976e561c8e78" translate="yes" xml:space="preserve">
          <source>And inside &lt;code&gt;scheduleCallback&lt;/code&gt;, we create a callback that will in due course store the result data in the &lt;code&gt;Ptr Result&lt;/code&gt;, and then call &lt;code&gt;hs_try_putmvar()&lt;/code&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;scheduleCallback&lt;/code&gt; 내부 에서 &lt;code&gt;Ptr Result&lt;/code&gt; 에 결과 데이터를 저장할 콜백을 만든 다음 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c289bb0b2889358d5359dfed88823350fe8916e4" translate="yes" xml:space="preserve">
          <source>And multi-line spans are possible too:</source>
          <target state="translated">그리고 멀티 라인 스팬도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5e61586d1382fe8ad684bf10b7ab8931fb17aed0" translate="yes" xml:space="preserve">
          <source>And one general flag:</source>
          <target state="translated">그리고 하나의 일반적인 깃발 :</target>
        </trans-unit>
        <trans-unit id="dea1f9e397867b9cb1063d86c4c517eae2eedcd1" translate="yes" xml:space="preserve">
          <source>And read back with:</source>
          <target state="translated">그리고 다음과 같이 다시 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="fc6d8473bdc84d9a5a02e5f55e8ffba9c7a1eadb" translate="yes" xml:space="preserve">
          <source>And the program will loop at runtime. Similarly, an &lt;code&gt;Applicative&lt;/code&gt; instance like this</source>
          <target state="translated">그리고 프로그램은 런타임에 반복됩니다. 마찬가지로 이와 같은 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스</target>
        </trans-unit>
        <trans-unit id="91b7607b548e3de2b58aab9b4afde889d7ecf3e4" translate="yes" xml:space="preserve">
          <source>And three warning flags:</source>
          <target state="translated">그리고 세 가지 경고 플래그 :</target>
        </trans-unit>
        <trans-unit id="0194dd87cfa77e0f7f90bc726fd0703ab0c251ba" translate="yes" xml:space="preserve">
          <source>And we could have built an equivalent path with the following expressions:</source>
          <target state="translated">그리고 우리는 다음과 같은 식으로 동등한 경로를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04f47a0bf05c20c03ec6759fd8321b4e440f4b6" translate="yes" xml:space="preserve">
          <source>And with &lt;a href=&quot;#unboxed-sums&quot;&gt;UnboxedSums&lt;/a&gt; enabled</source>
          <target state="translated">그리고와 &lt;a href=&quot;#unboxed-sums&quot;&gt;UnboxedSums&lt;/a&gt; 가능</target>
        </trans-unit>
        <trans-unit id="ff1853f8dddb99a8c160df02448f14aeb5c7e0b7" translate="yes" xml:space="preserve">
          <source>And write a value to disk</source>
          <target state="translated">그리고 디스크에 값을 쓰십시오</target>
        </trans-unit>
        <trans-unit id="0b691ef27c0c127676c790709cff2ef33778d7eb" translate="yes" xml:space="preserve">
          <source>And you attempt to derive it using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그리고 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; 를&lt;/a&gt; 사용하여 파생 시키려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="495577bd97a225b48a7e5b45336021b982d75dbc" translate="yes" xml:space="preserve">
          <source>And you tried to derive an instance for it:</source>
          <target state="translated">그리고 당신은 그것을 위해 인스턴스를 도출하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="b8ad3365893a0b275281ec83a50665e9f2d6834f" translate="yes" xml:space="preserve">
          <source>And, among other things, lazy pattern-matching is your enemy.</source>
          <target state="translated">그리고 무엇보다도 게으른 패턴 매칭이 적입니다.</target>
        </trans-unit>
        <trans-unit id="8c4a82e242cf12aed8b85b58f58b0968fee82178" translate="yes" xml:space="preserve">
          <source>Andy Gill and Simon Marlow have written a parser-generator for Haskell, called &lt;code&gt;happy&lt;/code&gt;. &lt;code&gt;Happy&lt;/code&gt; is to Haskell what &lt;code&gt;Yacc&lt;/code&gt; is to C.</source>
          <target state="translated">Andy Gill과 Simon Marlow는 &lt;code&gt;happy&lt;/code&gt; 라는 Haskell의 파서 생성기를 작성했습니다 . &lt;code&gt;Happy&lt;/code&gt; 은 하스켈에게 &lt;code&gt;Yacc&lt;/code&gt; 가 C에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="74661a73b0dde5f32e46ef5440b8f7c212e3dd3f" translate="yes" xml:space="preserve">
          <source>AnnLookup</source>
          <target state="translated">AnnLookup</target>
        </trans-unit>
        <trans-unit id="c1da64c83c4be735ccac640316d60131dd4381db" translate="yes" xml:space="preserve">
          <source>AnnTarget</source>
          <target state="translated">AnnTarget</target>
        </trans-unit>
        <trans-unit id="f1b790e1da14310f6ece84c62bb58322fef3c9fc" translate="yes" xml:space="preserve">
          <source>AnnotDetails</source>
          <target state="translated">AnnotDetails</target>
        </trans-unit>
        <trans-unit id="bf34615f46f75f35e2f9ccc197db2f929dd6a301" translate="yes" xml:space="preserve">
          <source>AnnotStart</source>
          <target state="translated">AnnotStart</target>
        </trans-unit>
        <trans-unit id="1e19b78b16e2a7b6a1e4f80c0a4d231548b5500d" translate="yes" xml:space="preserve">
          <source>Annotate the Template Haskell expression with a type</source>
          <target state="translated">유형으로 템플릿 Haskell 표현식에 주석 달기</target>
        </trans-unit>
        <trans-unit id="665edccbf78492c3059856c8597043ed30b15ce4" translate="yes" xml:space="preserve">
          <source>Annotating documents</source>
          <target state="translated">문서 주석 달기</target>
        </trans-unit>
        <trans-unit id="0d453d564eadde058c35ace639f7bec19eccb3ee" translate="yes" xml:space="preserve">
          <source>Annotation lookup</source>
          <target state="translated">주석 조회</target>
        </trans-unit>
        <trans-unit id="11129140d62298b72f4c953d972b05a50da295ea" translate="yes" xml:space="preserve">
          <source>Annotation rendering</source>
          <target state="translated">주석 렌더링</target>
        </trans-unit>
        <trans-unit id="112cca03c76acb3cca2a892f6e3fa24c275d9756" translate="yes" xml:space="preserve">
          <source>Annotation target for reifyAnnotations</source>
          <target state="translated">reify에 대한 주석 대상</target>
        </trans-unit>
        <trans-unit id="fddbd22c104843c74d2c00f8cf2af89a7f68516f" translate="yes" xml:space="preserve">
          <source>Annotations are small pragmas that allow you to attach data to identifiers in source code, which are persisted when compiled. These pieces of data can then inspected and utilized when using GHC as a library or writing a compiler plugin.</source>
          <target state="translated">주석은 소스 코드의 식별자에 데이터를 첨부 할 수있는 작은 pragma이며 컴파일시 유지됩니다. 그런 다음 GHC를 라이브러리로 사용하거나 컴파일러 플러그인을 작성할 때 이러한 데이터를 검사하고 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b762d7dbaed9bb5ebd61e64b87ad52b2d8a6ca" translate="yes" xml:space="preserve">
          <source>Anonymous and named wildcards &lt;em&gt;can&lt;/em&gt; occur on the left hand side of a type or data instance declaration; see &lt;a href=&quot;#type-wildcards-lhs&quot;&gt;Wildcards on the LHS of data and type family instances&lt;/a&gt;.</source>
          <target state="translated">익명 및 명명 된 와일드 카드 &lt;em&gt;는&lt;/em&gt; 유형 또는 데이터 인스턴스 선언의 왼쪽에서 발생할 &lt;em&gt;수&lt;/em&gt; 있습니다. &lt;a href=&quot;#type-wildcards-lhs&quot;&gt;데이터 및 유형 패밀리 인스턴스의 LHS에&lt;/a&gt; 대한 와일드 카드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2933014e43439d1ca1dfa76d9cf24791b507ac57" translate="yes" xml:space="preserve">
          <source>Anonymous and named wildcards &lt;em&gt;can&lt;/em&gt; occur on the left hand side of a type or data instance declaration; see &lt;a href=&quot;type_families#type-wildcards-lhs&quot;&gt;Wildcards on the LHS of data and type family instances&lt;/a&gt;.</source>
          <target state="translated">익명 및 명명 된 와일드 카드 &lt;em&gt;는&lt;/em&gt; 유형 또는 데이터 인스턴스 선언의 왼쪽에 나타날 &lt;em&gt;수&lt;/em&gt; 있습니다. &lt;a href=&quot;type_families#type-wildcards-lhs&quot;&gt;데이터 및 유형 패밀리 인스턴스의 LHS에&lt;/a&gt; 대한 와일드 카드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cf2947ec117ab6af4c3e63853ae6bc974a4aab5" translate="yes" xml:space="preserve">
          <source>Anonymous wildcards are also allowed in visible type applications/ visible kind applications (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). If you want to specify only the second type argument to &lt;code&gt;wurble&lt;/code&gt;, then you can say &lt;code&gt;wurble @_ @Int&lt;/code&gt; where the first argument is a wildcard.</source>
          <target state="translated">익명의 와일드 카드는 가시적 유형 애플리케이션 / 가시적 유형 애플리케이션 ( &lt;a href=&quot;#visible-type-application&quot;&gt;가시적 유형 애플리케이션&lt;/a&gt; ) 에서도 허용됩니다 . &lt;code&gt;wurble&lt;/code&gt; 에 두 번째 유형 인수 만 지정하려면 &lt;code&gt;wurble @_ @Int&lt;/code&gt; 라고 말하면 첫 번째 인수는 와일드 카드입니다.</target>
        </trans-unit>
        <trans-unit id="760e8be8ff8aded9e397539dd6c206869559d124" translate="yes" xml:space="preserve">
          <source>Anonymous wildcards are also allowed in visible type applications/ visible kind applications (&lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). If you want to specify only the second type argument to &lt;code&gt;wurble&lt;/code&gt;, then you can say &lt;code&gt;wurble @_ @Int&lt;/code&gt; where the first argument is a wildcard.</source>
          <target state="translated">가시적 유형 애플리케이션 / 가시적 유형 애플리케이션 ( &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;가시적 유형 애플리케이션&lt;/a&gt; ) 에서도 익명 와일드 카드를 사용할 수 있습니다 . &lt;code&gt;wurble&lt;/code&gt; 에 두 번째 유형 인수 만 지정하려면 &lt;code&gt;wurble @_ @Int&lt;/code&gt; 라고 말하면됩니다. 여기서 첫 번째 인수는 와일드 카드입니다.</target>
        </trans-unit>
        <trans-unit id="b4f913427243fca5da364b9f4af093e1c132cd45" translate="yes" xml:space="preserve">
          <source>Another common question that comes up when debugging is &amp;ldquo;where did this exception come from?&amp;rdquo;. Exceptions such as those raised by &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;head []&lt;/code&gt; have no context information attached to them. Finding which particular call to &lt;code&gt;head&lt;/code&gt; in your program resulted in the error can be a painstaking process, usually involving &lt;code&gt;Debug.Trace.trace&lt;/code&gt;, or compiling with profiling and using &lt;code&gt;Debug.Trace.traceStack&lt;/code&gt; or &lt;code&gt;+RTS -xc&lt;/code&gt; (see &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">디버깅 할 때 발생하는 또 다른 일반적인 질문은 &quot;이 예외는 어디에서 왔습니까?&quot;입니다. &lt;code&gt;error&lt;/code&gt; 또는 &lt;code&gt;head []&lt;/code&gt; 로 인해 발생한 예외 는 컨텍스트 정보가 첨부되지 않습니다. 특히 전화 찾기 &lt;code&gt;head&lt;/code&gt; 프로그램에서 오류의 결과는 일반적으로 포함, 근면 한 과정이 될 수 &lt;code&gt;Debug.Trace.trace&lt;/code&gt; 을 하거나, 프로파일 링 및 사용하여 컴파일 &lt;code&gt;Debug.Trace.traceStack&lt;/code&gt; 또는 &lt;code&gt;+RTS -xc&lt;/code&gt; 를 (참조 &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8a901bb130edd93de354a92729369e7eb8a77ff7" translate="yes" xml:space="preserve">
          <source>Another common use is to ensure any exceptions hidden within lazy fields of a data structure do not leak outside the scope of the exception handler, or to force evaluation of a data structure in one thread, before passing to another thread (preventing work moving to the wrong threads).</source>
          <target state="translated">또 다른 일반적인 용도는 데이터 구조의 게으른 필드 내에 숨겨진 예외가 예외 처리기의 범위를 벗어나 누출되지 않도록하거나 다른 스레드로 전달하기 전에 한 스레드에서 데이터 구조를 강제로 평가하는 것입니다. 잘못된 스레드).</target>
        </trans-unit>
        <trans-unit id="312336ad458ea40ebadf4c791b596f396bc92d0d" translate="yes" xml:space="preserve">
          <source>Another difference between higher-rank kinds and types can be found in their treatment of inferred and user-specified type variables. Consider the following program:</source>
          <target state="translated">상위 유형과 유형의 또 다른 차이점은 유추 및 사용자 지정 유형 변수의 처리에서 찾을 수 있습니다. 다음 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="619e7f27cda3e42e4615c75dcb4975c0f4f68283" translate="yes" xml:space="preserve">
          <source>Another difficulty with the memo table is that the value of a key/value pair might itself contain a pointer to the key. So the memo table keeps the value alive, which keeps the key alive, even though there may be no other references to the key so both should die. The weak pointers in this library provide a slight generalisation of the basic weak-pointer idea, in which each weak pointer actually contains both a key and a value.</source>
          <target state="translated">메모 테이블의 또 다른 어려움은 키 / 값 쌍의 값 자체에 키에 대한 포인터가 포함될 수 있다는 것입니다. 따라서 메모 테이블은 값을 활성 상태로 유지하여 키에 대한 다른 참조가 없어도 키를 활성 상태로 유지하므로 둘 다 죽어야합니다. 이 라이브러리의 약한 포인터는 각각의 약한 포인터가 실제로 키와 값을 모두 포함하는 기본 약한 포인터 아이디어를 약간 일반화합니다.</target>
        </trans-unit>
        <trans-unit id="3139c4c3d9fe163dd31667b3304a7a4a55378c8e" translate="yes" xml:space="preserve">
          <source>Another extremely efficient way to make your program snappy is to use library code that has been Seriously Tuned By Someone Else. You &lt;em&gt;might&lt;/em&gt; be able to write a better quicksort than the one in &lt;code&gt;Data.List&lt;/code&gt;, but it will take you much longer than typing &lt;code&gt;import Data.List&lt;/code&gt;.</source>
          <target state="translated">프로그램을 간단하게 만드는 또 다른 매우 효율적인 방법은 다른 사람이 심각하게 조정 한 라이브러리 코드를 사용하는 것입니다. 당신은 &lt;em&gt;할 수&lt;/em&gt; 있는 것보다 더 나은 퀵 쓸 수 &lt;code&gt;Data.List&lt;/code&gt; 을 하지만, 타이핑보다 훨씬 더 오래 걸릴 것입니다 &lt;code&gt;import Data.List&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0192d00c4c561122179982081c286d8efe43c16b" translate="yes" xml:space="preserve">
          <source>Another form of command is a form of &lt;code&gt;do&lt;/code&gt;-notation. For example, you can write</source>
          <target state="translated">다른 형태의 명령은 &lt;code&gt;do&lt;/code&gt; - notation 의 형태입니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="ca7ae7aaeace3e8afcdea81b5fff39694bdaa3a2" translate="yes" xml:space="preserve">
          <source>Another important difference between the two types of binding is that the monadic bind (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) is &lt;em&gt;strict&lt;/em&gt; (it evaluates &lt;code&gt;e&lt;/code&gt;), whereas with the &lt;code&gt;let&lt;/code&gt; form, the expression isn&amp;rsquo;t evaluated immediately:</source>
          <target state="translated">(결합의 두 가지 사이의 또 다른 중요한 차이점은, 모나드 결합이다 &lt;code&gt;p &amp;lt;- e&lt;/code&gt; )는 &lt;em&gt;엄격한&lt;/em&gt; (그것이 평가 &lt;code&gt;e&lt;/code&gt; 에 반해) &lt;code&gt;let&lt;/code&gt; : 형태 식 즉시 평가되지</target>
        </trans-unit>
        <trans-unit id="fa6d0d044f8316bb0266e4594b9afdb9ea5faf82" translate="yes" xml:space="preserve">
          <source>Another point to bear in mind: By far the best way to improve a program&amp;rsquo;s performance &lt;em&gt;dramatically&lt;/em&gt; is to use better algorithms. Once profiling has thrown the spotlight on the guilty time-consumer(s), it may be better to re-think your program than to try all the tweaks listed below.</source>
          <target state="translated">명심해야 할 또 다른 요점 : 지금까지 프로그램 성능을 &lt;em&gt;크게&lt;/em&gt; 향상시키는 가장 좋은 방법 은 더 나은 알고리즘을 사용하는 것입니다. 프로파일 링이 유죄 타임 소비자에게 주목을 받으면 아래 나열된 모든 조정을 시도하는 것보다 프로그램을 다시 생각하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d787e6c2588a53fddf149a1d181b21e1640ac274" translate="yes" xml:space="preserve">
          <source>Another useful application is to combine &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; in order to force deep evaluation relative to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations:</source>
          <target state="translated">또 다른 유용한 응용 프로그램은 다른 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업에 비해 심도있는 평가를 수행하기 위해 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 결합 하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="748a1e04935a7f3501001c42790b9f7f7d64ce9f" translate="yes" xml:space="preserve">
          <source>Another useful application is to combine &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; in order to force deep evaluation relative to other &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations:</source>
          <target state="translated">또 다른 유용한 응용 프로그램은 다른 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업과 관련된 심층 평가를 강제하기 위해 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 결합 하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="5c2f9a75636ccb2a48b5f68cc2e6881b697e167f" translate="yes" xml:space="preserve">
          <source>Another useful application is to combine &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; in order to force deep evaluation relative to other &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations:</source>
          <target state="translated">또 다른 유용한 응용 프로그램은 다른 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업과 관련된 심층 평가를 강제하기 위해 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 결합 하는 것 입니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
