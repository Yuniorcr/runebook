<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="3da05872e313e33621f92f71c99a716c25b4c06e" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell과 외국어 사이의 모든 마샬링은 결국 Haskell 데이터 구조를 외국어의 해당 데이터 구조의 이진 표현으로 변환하거나 그 반대로 변환합니다. Haskell에서이 마샬링을 코딩하려면 구조화되지 않은 메모리 블록에 저장된 기본 데이터 유형을 조작해야합니다. &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 는 인스턴스화되는 모든 유형 (하스켈의 표준 기본 유형, 고정 크기 &lt;code&gt;Int&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ), 고정 크기 &lt;code&gt;Word&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; ) 에서 이러한 조작 을 용이하게합니다., &lt;code&gt;&lt;a href=&quot;data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 모두에서 유형 &lt;a href=&quot;foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cffe145534643d9c1142d3476b91e58e7cb0edd7" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;../base-4.13.0.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell과 외국어 사이의 모든 마샬링은 결국 Haskell 데이터 구조를 외국어의 해당 데이터 구조의 이진 표현으로 변환하거나 그 반대로 변환합니다. Haskell에서이 마샬링을 코딩하려면 구조화되지 않은 메모리 블록에 저장된 기본 데이터 유형을 조작해야합니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 는 인스턴스화되는 모든 유형 (하스켈의 표준 기본 유형, 고정 크기 &lt;code&gt;Int&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ), 고정 크기 &lt;code&gt;Word&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; ) 에서 이러한 조작 을 용이하게합니다., &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 모두에서 유형 &lt;a href=&quot;../base-4.13.0.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ce405ee1194b3ce0523423637671f91407135a7" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;../base-4.14.1.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell과 외국어 간의 모든 마샬링은 궁극적으로 Haskell 데이터 구조를 해당 외국어 데이터 구조의 이진 표현으로 변환하는 것으로 귀결됩니다. 그 반대의 경우도 마찬가지입니다. Haskell에서이 마샬링을 코딩하려면 구조화되지 않은 메모리 블록에 저장된 원시 데이터 유형을 조작해야합니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 는 Haskell의 표준 기본 유형, 고정 크기 &lt;code&gt;Int&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ), 고정 크기 &lt;code&gt;Word&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; ) 인 인스턴스화되는 모든 유형에서이 조작을 용이하게합니다., &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 모두에서 유형 &lt;a href=&quot;../base-4.14.1.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd19ff0d458c57b97295494e47d40838d1850a87" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct &lt;em&gt;safe imports&lt;/em&gt; are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접 &lt;em&gt;안전한 수입은&lt;/em&gt; C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="1ef5ded9d2dd453646aebbde6bc1e77e258d91ac" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct imports are trusted by C</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 의 모든 직수입은 C가 신뢰합니다</target>
        </trans-unit>
        <trans-unit id="ef4a7530bfdff42a708223449593af312fe8738b" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct safe imports are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접 안전한 수입은 C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="a5408f6679dcddf6cf10903e40871b1051e396da" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct &lt;em&gt;safe imports&lt;/em&gt; are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접 &lt;em&gt;안전한 수입은&lt;/em&gt; C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="e797d2c20c300f4f341eb1a8bbafe469bcca673e" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct imports are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접적인 수입은 C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="1624840fe46a64a971c34a839de2cd6166d7cc15" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct safe imports are trusted by C</source>
          <target state="translated">모든 &lt;code&gt;M&lt;/code&gt; 의 직접 안전한 수입은 C에 의해 신뢰할 수있는</target>
        </trans-unit>
        <trans-unit id="d26ff1c50009409908cc1dc4184f2fa494a5bb4b" translate="yes" xml:space="preserve">
          <source>All of M&amp;rsquo;s direct imports are trusted by C</source>
          <target state="translated">M의 모든 직수입품은 C가 신뢰합니다</target>
        </trans-unit>
        <trans-unit id="6bbff3b9a2342fa6a7328cc64d9d064b0c59177f" translate="yes" xml:space="preserve">
          <source>All of the following are permissible:</source>
          <target state="translated">다음은 모두 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="07a302413e8b75e6da91c912ef456b8df520f40e" translate="yes" xml:space="preserve">
          <source>All of the functions fail on an empty queue.</source>
          <target state="translated">빈 큐에서 모든 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="459b9c097e1f48899719948d13092addea8d683b" translate="yes" xml:space="preserve">
          <source>All of the heaps are defined to be non-empty, which speeds up the merge functions.</source>
          <target state="translated">모든 힙이 비어 있지 않은 것으로 정의되어 병합 기능의 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="a6d572146a4416cc21d822c5b9122cc28fefd404" translate="yes" xml:space="preserve">
          <source>All of the monad transformers except &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; are functors on the category of monads: in addition to defining a mapping of monads, they also define a mapping from transformations between base monads to transformations between transformed monads, called &lt;code&gt;map&lt;/code&gt;&lt;em&gt;XXX&lt;/em&gt;&lt;code&gt;T&lt;/code&gt;. Thus given a monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;, the combinator &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; constructs a monad transformation</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; 를 제외한 모든 모나드 변환기는 모나드 범주의 펑터입니다. 모나드 매핑을 정의하는 것 외에도 기본 모나드 간 변환에서 변환 된 모나드 간 변환 ( &lt;code&gt;map&lt;/code&gt; &lt;em&gt;XXX &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; )으로 의 매핑을 정의합니다 . 따라서 모나드 변환 주어진 &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; 상기 콤비 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; 는 모나드 변환을 구축</target>
        </trans-unit>
        <trans-unit id="9ff4cf753e2cbc29b4117cb6c949a3dcfef8b652" translate="yes" xml:space="preserve">
          <source>All of the single-parameter functions for decoding bytestrings encoded in one of the Unicode Transformation Formats (UTF) operate in a &lt;em&gt;strict&lt;/em&gt; mode: each will throw an exception if given invalid input.</source>
          <target state="translated">UTFF (Unicode Transformation Formats) 중 하나로 인코딩 된 바이트 스트링을 디코딩하기위한 모든 단일 매개 변수 함수는 &lt;em&gt;엄격한&lt;/em&gt; 모드 에서 작동합니다 . 유효하지 않은 입력이 있으면 각각 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1146584e3cb478bf3265f7c6f72fec49b0f80d2" translate="yes" xml:space="preserve">
          <source>All of the type variables mentioned are bound by the class declaration, and none is locally quantified. Examples:</source>
          <target state="translated">언급 된 모든 유형 변수는 클래스 선언에 의해 바인딩되며 로컬로 수량화 된 것은 없습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d683e41b047bddec21ed6f58cd355ac5da8d7ca4" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">한 줄에서 모두 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 는 무시되고 명시적인 새 줄 ( &lt;code&gt;$$&lt;/code&gt; )은 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="d04619ab3f8398e576bbe00b547d8d28a39b93a6" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">한 줄에서 모두 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 는 무시되고 명시적인 새 줄 ( &lt;code&gt;$$&lt;/code&gt; )은 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="8734d083f84649d66cdee2cb45a731a5deb1ea31" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">한 줄에서 모두 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 는 무시되고 명시적인 새 줄 ( &lt;code&gt;$$&lt;/code&gt; )은 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="9bd92a106884eb39d74915dc625e8a2eeded96d9" translate="yes" xml:space="preserve">
          <source>All other type errors are reported immediately, and cannot be deferred; for example, an ill-kinded type signature, an instance declaration that is non-terminating or ill-formed, a type-family instance that does not obey the declared injectivity constraints, etc etc.</source>
          <target state="translated">다른 모든 유형 오류는 즉시보고되며 지연 될 수 없습니다. 예를 들어, 불친절한 유형 서명, 종결되지 않거나 잘못 구성된 인스턴스 선언, 선언 된 주 입성 제약 조건을 준수하지 않는 유형 군 인스턴스 등</target>
        </trans-unit>
        <trans-unit id="100083b95ff688c1be21a4288351839a84f80d50" translate="yes" xml:space="preserve">
          <source>All previously loaded modules, except package modules, are forgotten. The new set of modules is known as the target set. Note that &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; can be used without any arguments to unload all the currently loaded modules and bindings.</source>
          <target state="translated">패키지 모듈을 제외한 이전에로드 된 모든 모듈을 잊어 버렸습니다. 새로운 모듈 세트를 대상 세트라고합니다. 참고 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 현재로드 된 모든 모듈과 바인딩을 언로드 인수없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6827c99a0f2492e5c37fe7d9438e06c6b6af14e1" translate="yes" xml:space="preserve">
          <source>All rules are implicitly exported from the module, and are therefore in force in any module that imports the module that defined the rule, directly or indirectly. (That is, if A imports B, which imports C, then C&amp;rsquo;s rules are in force when compiling A.) The situation is very similar to that for instance declarations.</source>
          <target state="translated">모든 규칙은 모듈에서 암시 적으로 내보내 지므로 규칙을 정의한 모듈을 직접 또는 간접적으로 가져 오는 모든 모듈에서 적용됩니다. (즉, A가 C를 가져 오는 B를 가져 오면 A를 컴파일 할 때 C의 규칙이 적용됩니다.) 상황은 예를 들어 선언과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7dbe1320fffcde509144ec4167268e2f24928720" translate="yes" xml:space="preserve">
          <source>All special processing is triggered by the &lt;code&gt;#&lt;/code&gt; operator. To output a literal &lt;code&gt;#&lt;/code&gt;, write it twice: &lt;code&gt;##&lt;/code&gt;. Inside string literals and comments &lt;code&gt;#&lt;/code&gt; characters are not processed.</source>
          <target state="translated">모든 특수 처리는 &lt;code&gt;#&lt;/code&gt; 연산자 에 의해 트리거됩니다 . 리터럴 &lt;code&gt;#&lt;/code&gt; 을 출력하려면 &lt;code&gt;##&lt;/code&gt; 을 두 번 작성하십시오 . 내부 문자열 리터럴 및 주석 &lt;code&gt;#&lt;/code&gt; 문자는 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e754d606e9f071f8917ddf678a8be51138905754" translate="yes" xml:space="preserve">
          <source>All storage allocated by functions that allocate based on a &lt;em&gt;size in bytes&lt;/em&gt; must be sufficiently aligned for any of the basic foreign types that fits into the newly allocated storage. All storage allocated by functions that allocate based on a specific type must be sufficiently aligned for that type. Array allocation routines need to obey the same alignment constraints for each array element.</source>
          <target state="translated">&lt;em&gt;크기를 바이트 단위로&lt;/em&gt; 할당하는 함수에 의해 할당 된 모든 스토리지 는 새로 할당 된 스토리지에 맞는 기본 외부 유형에 맞게 충분히 정렬되어야합니다. 특정 유형을 기반으로 할당하는 기능에 의해 할당 된 모든 스토리지는 해당 유형에 맞게 충분히 정렬되어야합니다. 배열 할당 루틴은 각 배열 요소에 대해 동일한 정렬 제약 조건을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="0f41064ade872ca46f2cce357b6f0f602bb6c9f2" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt;, including a header.</source>
          <target state="translated">헤더를 포함한 모든 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8191f2288d30ed04618d8a7f6947ee07d2f827e8" translate="yes" xml:space="preserve">
          <source>All the classes &lt;code&gt;Ci&lt;/code&gt; are standard.</source>
          <target state="translated">모든 클래스 &lt;code&gt;Ci&lt;/code&gt; 는 표준입니다.</target>
        </trans-unit>
        <trans-unit id="27b13a294aaa6ffa8890f192e7f1dee01b865654" translate="yes" xml:space="preserve">
          <source>All the instance does is apply and remove the &lt;code&gt;newtype&lt;/code&gt; constructor. It is particularly galling that, since the constructor doesn&amp;rsquo;t appear at run-time, this instance declaration defines a dictionary which is &lt;em&gt;wholly equivalent&lt;/em&gt; to the &lt;code&gt;Int&lt;/code&gt; dictionary, only slower!</source>
          <target state="translated">모든 인스턴스는 &lt;code&gt;newtype&lt;/code&gt; 생성자를 적용하고 제거합니다 . 런타임에 표시되지 않습니다 생성자는이 인스턴스 선언은 사전 정의 이후 특히, 그렇게 못살게 괴롭히는됩니다 &lt;em&gt;전적으로 해당&lt;/em&gt; 받는 &lt;code&gt;Int&lt;/code&gt; 수 만 느린 사전을!</target>
        </trans-unit>
        <trans-unit id="3560dcf83b04004c14094e6b1d3cd4500f468374" translate="yes" xml:space="preserve">
          <source>All these features are described in the papers mentioned earlier.</source>
          <target state="translated">이러한 모든 기능은 앞에서 언급 한 논문에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f289fff56ff75be648fe75fd05b62eefadc5aae" translate="yes" xml:space="preserve">
          <source>All these features are enabled by default if the &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; extension is enabled. The types and more detailed examples on how to use comprehensions are explained in the previous chapters &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt; and &lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;. In general you just have to replace the type &lt;code&gt;[a]&lt;/code&gt; with the type &lt;code&gt;Monad m =&amp;gt; m a&lt;/code&gt; for monad comprehensions.</source>
          <target state="translated">&lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; &lt;/a&gt; 확장이 활성화 된 경우 이러한 모든 기능이 기본적 으로 활성화됩니다. 이해를 사용하는 방법에 대한 유형과 자세한 예는 이전 장의 &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;일반화 (SQL과 유사한) 목록 이해&lt;/a&gt; 및 &lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;병렬 목록 이해에서 설명&lt;/a&gt; 합니다. 일반적으로 모나드 이해를 위해 &lt;code&gt;[a]&lt;/code&gt; 유형을 &lt;code&gt;Monad m =&amp;gt; m a&lt;/code&gt; 유형으로 교체하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="f320750508ae8a4bdfcecfb3e8588bc22cc54930" translate="yes" xml:space="preserve">
          <source>All these functions evaluate the message completely before printing it; so if the message is not fully defined, none of it will be printed.</source>
          <target state="translated">이러한 모든 기능은 메시지를 인쇄하기 전에 완전히 평가합니다. 따라서 메시지가 완전히 정의되지 않으면 아무 것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcd3e8296e242f3b3d9e914ad0a98eb399c9d926" translate="yes" xml:space="preserve">
          <source>All these primitive data types and operations are exported by the library &lt;code&gt;GHC.Prim&lt;/code&gt;, for which there is detailed online documentation &amp;lt;GHC.Prim.&amp;gt;. (This documentation is generated from the file &lt;code&gt;compiler/prelude/primops.txt.pp&lt;/code&gt;.)</source>
          <target state="translated">이러한 모든 기본 데이터 유형 및 작업은 &lt;code&gt;GHC.Prim&lt;/code&gt; 라이브러리에 의해 내보내지며 자세한 온라인 문서 &amp;lt;GHC.Prim.&amp;gt;이 있습니다. (이 문서는 &lt;code&gt;compiler/prelude/primops.txt.pp&lt;/code&gt; 파일에서 생성됩니다 .)</target>
        </trans-unit>
        <trans-unit id="11d822b519b4d27d4c90f7025aa2f37e057b1573" translate="yes" xml:space="preserve">
          <source>All this applies to constructors declared using the syntax of &lt;a href=&quot;#existential-with-context&quot;&gt;Existentials and type classes&lt;/a&gt;. For example, the &lt;code&gt;NumInst&lt;/code&gt; data type above could equivalently be declared like this:</source>
          <target state="translated">이 모든 것은 &lt;a href=&quot;#existential-with-context&quot;&gt;Existentials 및 type 클래스&lt;/a&gt; 의 구문을 사용하여 선언 된 생성자에 적용됩니다 . 예를 들어 위 의 &lt;code&gt;NumInst&lt;/code&gt; 데이터 형식은 다음과 같이 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70df367f1e5c153af04770d26e6bb6e5662b24b1" translate="yes" xml:space="preserve">
          <source>All this behaviour contrasts with Haskell 98&amp;rsquo;s peculiar treatment of contexts on a data type declaration (Section 4.2.1 of the Haskell 98 Report). In Haskell 98 the definition</source>
          <target state="translated">이 모든 동작은 데이터 유형 선언 (Haskell 98 보고서의 섹션 4.2.1)에 대한 Haskell 98의 고유 한 컨텍스트 처리와 대조됩니다. Haskell 98에서 정의</target>
        </trans-unit>
        <trans-unit id="3d7f2d606f261a5fba2db68b6939910c2cd2ece4" translate="yes" xml:space="preserve">
          <source>All this looks quite promising; we have a class and a range of interesting implementations. Unfortunately, there are some serious problems with the class declaration. First, the empty function has an ambiguous type:</source>
          <target state="translated">이 모든 것이 매우 유망 해 보입니다. 우리는 클래스와 다양한 흥미로운 구현을 가지고 있습니다. 불행히도 클래스 선언에 심각한 문제가 있습니다. 먼저 빈 함수에는 모호한 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c67f8504ed498a898f1ab818b85763d53fddcf77" translate="yes" xml:space="preserve">
          <source>All three of these examples would compile without issue. On the other hand:</source>
          <target state="translated">이 세 가지 예 모두 문제없이 컴파일됩니다. 반면에 :</target>
        </trans-unit>
        <trans-unit id="9677956077fa96efb5b69b5a1ae7ad4b38e3313b" translate="yes" xml:space="preserve">
          <source>All types are classified as one of these classes: 32bit word, 64bit word, 32bit float, 64bit float, pointer.</source>
          <target state="translated">모든 유형은 32 비트 워드, 64 비트 워드, 32 비트 플로트, 64 비트 플로트, 포인터 클래스 중 하나로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="057ac441b399eb9586ae68f5c1eb9f47b4178362" translate="yes" xml:space="preserve">
          <source>All unbound identifiers are treated as typed holes, &lt;em&gt;whether or not they start with an underscore&lt;/em&gt;. The only difference is in the error message:</source>
          <target state="translated">모든 언 바운드 식별자는 &lt;em&gt;밑줄로 시작하든 아니든&lt;/em&gt; 유형이 지정된 구멍으로 처리됩니다 . 유일한 차이점은 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="fd53184b2d10dc248ec6c9e2385390b9b65b470a" translate="yes" xml:space="preserve">
          <source>AllPhases</source>
          <target state="translated">AllPhases</target>
        </trans-unit>
        <trans-unit id="86266bd7ede6bd6ba8469405abe76d387f23e4e4" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory and marshal a value into it (the combination of &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt;). The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">메모리 블록을 할당하고 값을 마샬링합니다 ( &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; 의 조합 ). 할당 된 영역의 크기 는 적절한 유형에 대한 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 인스턴스의 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 메소드에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd8c715cc3db061ff535eb5c0524be9fac0fa2b8" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory of the given number of bytes. The block of memory is sufficiently aligned for any of the basic foreign types that fits into a memory block of the allocated size.</source>
          <target state="translated">주어진 바이트 수의 메모리 블록을 할당하십시오. 메모리 블록은 할당 된 크기의 메모리 블록에 맞는 기본 외부 유형에 맞게 충분히 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="48f50994b06d1d5671f516b19482a827582f3624" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory that is sufficient to hold values of type &lt;code&gt;a&lt;/code&gt;. The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">a 유형 &lt;code&gt;a&lt;/code&gt; 값을 보유하기에 충분한 메모리 블록을 할당하십시오 . 할당 된 영역의 크기 는 적절한 유형에 대한 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 인스턴스의 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 메소드에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="945eac0de6e1530ab37e60133056c31933f7e0c0" translate="yes" xml:space="preserve">
          <source>Allocate a fresh memory pool.</source>
          <target state="translated">새로운 메모리 풀을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="bf161f8d2ef1099082c0d5528c3c029bcc71adc8" translate="yes" xml:space="preserve">
          <source>Allocate a new buffer of the given size.</source>
          <target state="translated">주어진 크기의 새 버퍼를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="797966dc728422a87321bee745962bf7b9b2105b" translate="yes" xml:space="preserve">
          <source>Allocate consecutive storage for a list of values in the given pool and marshal these values into it, terminating the end with the given marker.</source>
          <target state="translated">주어진 풀의 값 목록에 연속 스토리지를 할당하고 해당 값을 마샬링하여 지정된 마커로 끝을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="f5067d72f839d0ca801793aa2138ada31d2918c8" translate="yes" xml:space="preserve">
          <source>Allocate consecutive storage for a list of values in the given pool and marshal these values into it.</source>
          <target state="translated">주어진 풀의 값 목록에 연속 스토리지를 할당하고이 값을 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="4f94873e14ae1ca0d376362647204a8cbf513639" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">일부 메모리를 할당하고 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 반환 하십시오 . &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 폐기 하면 메모리가 자동으로 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="adc10905359d2ad848031b0da8c89829871951ed" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">일부 메모리를 할당하고 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 반환 하십시오 . &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 폐기 하면 메모리가 자동으로 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a74b5000fcb22d46c63fd1403958268121cb0e" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">일부 메모리를 할당하고 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 반환 하십시오 . &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 폐기 하면 메모리가 자동으로 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="18d53cff546da86cca443415642d6098c6313605" translate="yes" xml:space="preserve">
          <source>Allocate space for storable type in the given pool. The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">주어진 풀에 저장 가능한 유형을위한 공간을 할당하십시오. 할당 된 영역의 크기 는 적절한 유형에 대한 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 인스턴스의 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 메소드에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0faf0f0921366d35115d853c768adb58bbc217c" translate="yes" xml:space="preserve">
          <source>Allocate storage and marshal a storable value wrapped into a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">저장소를 할당하고 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 싸인 저장 가능한 값을 마샬링</target>
        </trans-unit>
        <trans-unit id="85a29b1e9713abbc38e1d1724333822128176095" translate="yes" xml:space="preserve">
          <source>Allocate storage for a value in the given pool and marshal the value into this storage.</source>
          <target state="translated">지정된 풀의 값에 스토리지를 할당하고이 스토리지에 값을 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="a751dea2f39999181b1d506f2ded5ae31093a057" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type (like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, but for multiple elements).</source>
          <target state="translated">저장 가능한 유형의 주어진 수의 요소에 대해 스토리지를 할당하십시오 ( &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 같지만 여러 요소에 대해).</target>
        </trans-unit>
        <trans-unit id="b8bd206b599ec8ecb129ced0e29abca1ece50440" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type in the pool, but leave room for an extra element to signal the end of the array.</source>
          <target state="translated">풀에 저장 가능한 유형의 지정된 수의 요소에 대해 스토리지를 할당하지만 추가 요소가 배열의 끝을 알리는 공간을 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="3c6502a8f26acdc89616720173572f6835f4395f" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type in the pool.</source>
          <target state="translated">풀에 저장 가능한 유형의 지정된 수의 요소에 대해 스토리지를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="dfb0511a4ae80d311521dfea2fd5a589ea804b6a" translate="yes" xml:space="preserve">
          <source>Allocate the given number of bytes of storage in the pool.</source>
          <target state="translated">풀에 지정된 수의 스토리지 바이트를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="74c31d0f81c37ba9952fac9ee09d5580d40e7044" translate="yes" xml:space="preserve">
          <source>Allocate the nursery from node-local memory.</source>
          <target state="translated">노드 로컬 메모리에서 보육을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="489efe43727a84928b21db7c885a4647eec79612" translate="yes" xml:space="preserve">
          <source>Allocating managed memory</source>
          <target state="translated">관리 메모리 할당</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="a371c9709f159b54fa290c4ef85af0337a88411e" translate="yes" xml:space="preserve">
          <source>Allocation accounting is accurate only to about 4Kbytes.</source>
          <target state="translated">할당 회계는 약 4Kbyte까지만 정확합니다.</target>
        </trans-unit>
        <trans-unit id="672bb521be73595aa99b0bcb407ba5c8a04ff65e" translate="yes" xml:space="preserve">
          <source>Allocation counter and limit</source>
          <target state="translated">할당 카운터 및 제한</target>
        </trans-unit>
        <trans-unit id="6be4e23bfb8b2d85b4d8e47ee554151801bbfd62" translate="yes" xml:space="preserve">
          <source>Allocation counter and limits</source>
          <target state="translated">할당 카운터 및 제한</target>
        </trans-unit>
        <trans-unit id="f863a7852bc37e781471622e1a75707f51a4b50b" translate="yes" xml:space="preserve">
          <source>Allocation counter and quota</source>
          <target state="translated">할당 카운터 및 할당량</target>
        </trans-unit>
        <trans-unit id="6714f70908a1447bb325aa721caef6aa021fb67a" translate="yes" xml:space="preserve">
          <source>AllocationLimitExceeded</source>
          <target state="translated">AllocationLimitExceeded</target>
        </trans-unit>
        <trans-unit id="78fee5f8d19c1012e15c9cb754371db736ef10f0" translate="yes" xml:space="preserve">
          <source>AllocationStrategy</source>
          <target state="translated">AllocationStrategy</target>
        </trans-unit>
        <trans-unit id="1e0ddb13f2d7482f1d9d4401e43c0f7c159e3d27" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;#&lt;/code&gt; as a postfix modifier on identifiers.</source>
          <target state="translated">식별자에 &lt;code&gt;#&lt;/code&gt; 를 접미사 수정 자로 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="487b72f96ce687ab0a0c0c91a3747ce245eb86bd" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;do&lt;/code&gt; blocks and other constructs as function arguments.</source>
          <target state="translated">허용 &lt;code&gt;do&lt;/code&gt; 함수 인수로 블록과 다른 구조를.</target>
        </trans-unit>
        <trans-unit id="f3d4d6a5ae1b8e8556bffe5a2051a8a7eeb9bcd1" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;do&lt;/code&gt; expressions, lambda expressions, etc. to be directly used as a function argument.</source>
          <target state="translated">허용 &lt;code&gt;do&lt;/code&gt; 직접 함수의 인수로서 사용되는 등의 식 람다 식.</target>
        </trans-unit>
        <trans-unit id="57b2197ae6b5696247d5182d09e77a732fad1d01" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;forall&lt;/code&gt; quantifiers in constraints.</source>
          <target state="translated">제약 조건에 모든 수량 &lt;code&gt;forall&lt;/code&gt; 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="48fb284220c7e71266222e272e89501b5da2de4e" translate="yes" xml:space="preserve">
          <source>Allow all superclass constraints, including those that may result in non-termination of the typechecker.</source>
          <target state="translated">타입 체커가 종료되지 않는 것을 포함한 모든 수퍼 클래스 제약을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="80eb231dd3933ab2efd3d5dfa5c44bae12bc9d69" translate="yes" xml:space="preserve">
          <source>Allow an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be deferred lazily. When passed an action of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;, the action will only be performed when the value of &lt;code&gt;a&lt;/code&gt; is demanded.</source>
          <target state="translated">허용 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 계산은 느리게 지연된다. 유형의 작용에 전달하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 값 때, 동작은 수행되는 &lt;code&gt;a&lt;/code&gt; 요구된다.</target>
        </trans-unit>
        <trans-unit id="1750d76ce07b95cdb172cc776a34f360d5d4cd29" translate="yes" xml:space="preserve">
          <source>Allow asynchronous exceptions to be raised even inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, making the operation interruptible (see the discussion of &quot;Interruptible operations&quot; in &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에서도 비동기 예외가 발생하도록 허용 하여 조작을 인터럽트 가능하게하십시오 ( &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 의 &quot;인터럽터 블 조작&quot;에 대한 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="780a200a64ac9433b47b1da40e2581b24c295f40" translate="yes" xml:space="preserve">
          <source>Allow asynchronous exceptions to be raised even inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, making the operation interruptible (see the discussion of &quot;Interruptible operations&quot; in &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에서도 비동기 예외가 발생하도록 허용 하여 조작을 인터럽트 가능하게하십시오 ( &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 의 &quot;인터럽터 블 조작&quot;에 대한 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="8baf535a4dbc587a727d88078ccbc03106a8d4ba" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Foldable&lt;/code&gt; typeclass.</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; 유형 클래스에 대한 인스턴스 자동 파생을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="4f96512299d9639cbf383164f1db522bd120f323" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Functor&lt;/code&gt; typeclass.</source>
          <target state="translated">&lt;code&gt;Functor&lt;/code&gt; 타입 클래스에 대한 인스턴스의 자동 파생을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="cb4259796e51e2d950e57edd562f9cf8982dd300" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Generic&lt;/code&gt; typeclass.</source>
          <target state="translated">&lt;code&gt;Generic&lt;/code&gt; 클래스에 대한 인스턴스 자동 파생을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="a7632af3ddef7069071f3bf8a7c397be4ca59fcd" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Traversable&lt;/code&gt; typeclass.</source>
          <target state="translated">&lt;code&gt;Traversable&lt;/code&gt; 유형 클래스에 대한 인스턴스 자동 파생을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="add95d26da022101d791b89213499080da94e3a9" translate="yes" xml:space="preserve">
          <source>Allow constant folding in case expressions that scrutinise some primops: For example,</source>
          <target state="translated">일부 primops를 면밀히 조사하는 식에는 상수 접기를 허용하십시오. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="934cc159b35ac28d99ae334c8a54aa36d7a7c39a" translate="yes" xml:space="preserve">
          <source>Allow constraints to quantify over types.</source>
          <target state="translated">구속 조건이 유형에 대해 수량화되도록 허용</target>
        </trans-unit>
        <trans-unit id="2ce51b30b9da5f59ff139ceec6637a831ee564b6" translate="yes" xml:space="preserve">
          <source>Allow contexts on &lt;code&gt;data&lt;/code&gt; types.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 유형 에 대한 컨텍스트를 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eab095a3e387bb8b63300500e130636d41df289c" translate="yes" xml:space="preserve">
          <source>Allow defaulting to take place for more than just numeric classes.</source>
          <target state="translated">숫자 클래스 이상의 기본 설정을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="926119bf4ff3119fe5a37dc0cb8f3089e82d4ec6" translate="yes" xml:space="preserve">
          <source>Allow definition of empty &lt;code&gt;data&lt;/code&gt; types.</source>
          <target state="translated">빈 &lt;code&gt;data&lt;/code&gt; 형식의 정의를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="36885bc6f326d61d2bc2d18c723dc0b2ce083841" translate="yes" xml:space="preserve">
          <source>Allow definition of functions expecting implicit parameters.</source>
          <target state="translated">암시 적 매개 변수를 기대하는 함수의 정의를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8fdd0e51a265a2c590d00cb6abc3adad2684d61" translate="yes" xml:space="preserve">
          <source>Allow definition of record types with identically-named fields.</source>
          <target state="translated">동일한 이름의 필드를 가진 레코드 유형의 정의를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="726294c3f294ef13dd773189e75ae54c6d6e3bbd" translate="yes" xml:space="preserve">
          <source>Allow definition of type class instances for type synonyms.</source>
          <target state="translated">타입 동의어에 대한 타입 클래스 인스턴스의 정의를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7f2a1ee40ed67cae653a504bd6f3545fe705b983" translate="yes" xml:space="preserve">
          <source>Allow definition of type class instances with arbitrary nested types in the instance head.</source>
          <target state="translated">인스턴스 헤드에 임의의 중첩 유형이있는 유형 클래스 인스턴스를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86966622a20e13b1ac31de8f45367c263a8977cf" translate="yes" xml:space="preserve">
          <source>Allow deriving instances of standard type classes for empty data types.</source>
          <target state="translated">빈 데이터 형식에 대한 표준 형식 클래스 인스턴스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="60943beab02466a2c26e0ab7a51efa95c6e2a7fe" translate="yes" xml:space="preserve">
          <source>Allow empty case alternatives.</source>
          <target state="translated">빈 대소 문자를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="025c491c399c735d766d5a9892dd9e6ee33b7e08" translate="yes" xml:space="preserve">
          <source>Allow empty case expressions.</source>
          <target state="translated">빈 대소 문자 표현을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6c84f72d8d262e69d1f9faa234eff6fdf37f2369" translate="yes" xml:space="preserve">
          <source>Allow existentially quantified type variables in types.</source>
          <target state="translated">실재적으로 정량화 된 유형 변수를 유형에 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ab319c3adc39803249aca0e24d447b1fb428579" translate="yes" xml:space="preserve">
          <source>Allow explicit kind signatures on type variables.</source>
          <target state="translated">유형 변수에 명시 적 종류 서명을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="17fa756b705f1fa52e127048ab38d27914f60aba" translate="yes" xml:space="preserve">
          <source>Allow functional dependency annotations on type families. This allows one to define injective type families.</source>
          <target state="translated">유형 패밀리에서 기능적 종속성 주석을 허용합니다. 이를 통해 주입 유형 패밀리를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb8b184e2bcabb5b3fa790e938afe5ac1becfb4" translate="yes" xml:space="preserve">
          <source>Allow impredicative polymorphic types.</source>
          <target state="translated">즉석 다형성 유형을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="2433b80c1b9d57252941872fdc1b781f2a3699e6" translate="yes" xml:space="preserve">
          <source>Allow kind polymorphic types.</source>
          <target state="translated">종류 다형성 유형을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="cdff7073df11b6e1c05a0eceb6acaa80701d67af" translate="yes" xml:space="preserve">
          <source>Allow multiple &lt;code&gt;deriving&lt;/code&gt;, each optionally qualified with a &lt;em&gt;strategy&lt;/em&gt;.</source>
          <target state="translated">각각 선택적으로 &lt;em&gt;전략을&lt;/em&gt; 갖춘 여러 &lt;code&gt;deriving&lt;/code&gt; 허용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76ba8a634a12bd3f74b9359ac050a7de5e913037" translate="yes" xml:space="preserve">
          <source>Allow naming of wildcards (e.g. &lt;code&gt;_x&lt;/code&gt;) in type signatures.</source>
          <target state="translated">타입 시그니처 에 와일드 카드 (예 : &lt;code&gt;_x&lt;/code&gt; ) 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70463e61ddc2770c5bfd923aebb592b3ba442123" translate="yes" xml:space="preserve">
          <source>Allow nested contexts to be at the same indentation level as its enclosing context.</source>
          <target state="translated">중첩 된 컨텍스트가 둘러싸는 컨텍스트와 동일한 들여 쓰기 수준이되도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a24b90b3b696d68b4a53058736b07d9593258864" translate="yes" xml:space="preserve">
          <source>Allow other process to set Window to Foreground by using &lt;code&gt;&lt;a href=&quot;graphics-win32-window-foregroundwindow#v:setForegroundWindow&quot;&gt;setForegroundWindow&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;graphics-win32-window-foregroundwindow#v:setForegroundWindow&quot;&gt;setForegroundWindow&lt;/a&gt;&lt;/code&gt; 함수 를 사용하여 다른 프로세스가 Window를 Foreground로 설정하도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3466dbeb7cfb661d1b3d5d9ae06ef44c39d689be" translate="yes" xml:space="preserve">
          <source>Allow parallel list comprehension syntax.</source>
          <target state="translated">병렬 목록 이해 구문을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ed92111f1838c96b6c033cdfe95611654ed8c96" translate="yes" xml:space="preserve">
          <source>Allow promotion of data types to kind level.</source>
          <target state="translated">데이터 유형을 친절한 수준으로 승격시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="260dca80fe27608e688cf5033c080a2cfba5b239" translate="yes" xml:space="preserve">
          <source>Allow role annotation syntax.</source>
          <target state="translated">역할 주석 구문을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="87a0f4cf411c10836ab0efbb3303960a1c45e4a3" translate="yes" xml:space="preserve">
          <source>Allow the compiler to apply rewrite rules to the source program.</source>
          <target state="translated">컴파일러가 소스 프로그램에 다시 쓰기 규칙을 적용하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6b09bb1ac28b5b0c583dc8ebf98fba2849116608" translate="yes" xml:space="preserve">
          <source>Allow the compiler to automatically choose between identically-named record selectors based on type (if the choice is unambiguous).</source>
          <target state="translated">컴파일러가 유형에 따라 동일한 이름을 가진 레코드 선택기 중에서 자동으로 선택할 수 있도록합니다 (선택이 명확하지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="83c47b742b143b98b73e92a9a5de1c9e32c641ec" translate="yes" xml:space="preserve">
          <source>Allow the definition of pattern synonyms.</source>
          <target state="translated">패턴 동의어의 정의를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe2a8646e41c100c7ad5651319a6e065e997f85a" translate="yes" xml:space="preserve">
          <source>Allow the definition of typeclasses with more than one parameter.</source>
          <target state="translated">둘 이상의 매개 변수를 사용하여 유형 클래스를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d185ff37afe97c8a5c9c099b699c25563f19c7b7" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 계산 결과를 계산 내에서 (게으르게) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce75fe6b08dfb2e2c5aeb7a05bc37771108792fd" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation. Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 계산 결과를 계산 내에서 (게으르게) 사용할 수 있습니다. 참고이 경우 &lt;code&gt;f&lt;/code&gt; 는 엄격한, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71db9c7ef93f554ac579b40d6689938982ec9dda" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation. Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 계산 결과를 계산 내에서 (게으르게) 사용할 수 있습니다. 참고이 경우 &lt;code&gt;f&lt;/code&gt; 는 엄격한, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67e53378677db7eb448650e4848cf3af89d1c7b5" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 계산 결과를 계산 내에서 (게으르게) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a25778334adcda643e0a1777a4a1308851238bc9" translate="yes" xml:space="preserve">
          <source>Allow the use and definition of types with operator names.</source>
          <target state="translated">연산자 이름으로 유형을 사용하고 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffa6e2a8241cb1d89e5bfc36b1a5b18d2b5d635a" translate="yes" xml:space="preserve">
          <source>Allow the use of GADT syntax in data type definitions (but not GADTs themselves; for this see &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">데이터 타입 정의에서 GADT 신택스를 사용할 수 있도록 (하지만 GADTs 자체,이보기위한 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="59b4b3836b0ad08f877b34af9e4fa8b8a8d4a012" translate="yes" xml:space="preserve">
          <source>Allow the use of binary notation in integer literals.</source>
          <target state="translated">정수 리터럴에서 이진 표기법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcd29c7bce33303e5d32e6ccbc57335b0acff65" translate="yes" xml:space="preserve">
          <source>Allow the use of complex constraints in class declaration contexts.</source>
          <target state="translated">클래스 선언 컨텍스트에서 복잡한 제약 조건을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="702e6903368de34c7b00d4d1faab5cc980b6ff20" translate="yes" xml:space="preserve">
          <source>Allow the use of floating-point literal syntax for integral types.</source>
          <target state="translated">정수 유형에 부동 소수점 리터럴 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2df53ac2aa65699d533256ce56f3e679075bdf" translate="yes" xml:space="preserve">
          <source>Allow the use of lambda-case syntax.</source>
          <target state="translated">lambda-case 구문 사용을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="76a7a3b4a067b229370029d02bfb2c0e97e8bc7f" translate="yes" xml:space="preserve">
          <source>Allow the use of multi-way-&lt;code&gt;if&lt;/code&gt; syntax.</source>
          <target state="translated">다 방향 &lt;code&gt;if&lt;/code&gt; 구문 사용을 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4acbbed0487deb8857b5f7e688836829f142c6f1" translate="yes" xml:space="preserve">
          <source>Allow the use of package-qualified &lt;code&gt;import&lt;/code&gt; syntax.</source>
          <target state="translated">패키지 규정 된 &lt;code&gt;import&lt;/code&gt; 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea333a314c924e9102b9616473c6ae74d1b2886" translate="yes" xml:space="preserve">
          <source>Allow the use of post-fix operators</source>
          <target state="translated">사후 수정 연산자 사용 허용</target>
        </trans-unit>
        <trans-unit id="adb08d203af69b5b4cd4dd423b7318efffc8b20f" translate="yes" xml:space="preserve">
          <source>Allow the use of recursive &lt;code&gt;do&lt;/code&gt; notation.</source>
          <target state="translated">재귀의 사용을 허용 &lt;code&gt;do&lt;/code&gt; 표기법을.</target>
        </trans-unit>
        <trans-unit id="b0029babcf620375a925cb0f309e07f9eef805a4" translate="yes" xml:space="preserve">
          <source>Allow the use of stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations.</source>
          <target state="translated">독립형 &lt;code&gt;deriving&lt;/code&gt; 선언 사용을 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ffc26d958cddfc3a794521475014c76922cd906" translate="yes" xml:space="preserve">
          <source>Allow the use of standalone kind signatures.</source>
          <target state="translated">독립형 종류 서명 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="86686087092ab757a3c44071e8cdb958a2e740ab" translate="yes" xml:space="preserve">
          <source>Allow the use of tuple section syntax</source>
          <target state="translated">튜플 섹션 구문 사용 허용</target>
        </trans-unit>
        <trans-unit id="f62761563b5f41d61ca0ecbb5ad968019d4409d7" translate="yes" xml:space="preserve">
          <source>Allow the use of type application syntax.</source>
          <target state="translated">애플리케이션 구문 유형을 사용하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="5675777ef0f98250d6e550ff440d842beeff404c" translate="yes" xml:space="preserve">
          <source>Allow the use of underscores in numeric literals.</source>
          <target state="translated">숫자 리터럴에 밑줄을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eee4b36605984e0b63f2119e25dc26be8151e070" translate="yes" xml:space="preserve">
          <source>Allow the use of wildcards in record construction and pattern matching.</source>
          <target state="translated">레코드 구성 및 패턴 일치에 와일드 카드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6687c47ecd5f08e5cbe5a2d433f777d1b2ba65" translate="yes" xml:space="preserve">
          <source>Allow the user to write ambiguous types, and the type inference engine to infer them.</source>
          <target state="translated">사용자가 모호한 유형을 작성하고 유형 유추 엔진이이를 유추 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="86a368ced00c7e3c3b92de7fbdde36c04126fbd7" translate="yes" xml:space="preserve">
          <source>Allow turning known into unknown calls while performing late lambda lifting.</source>
          <target state="translated">늦은 람다 리프팅을 수행하는 동안 알려진 전화를 알 수없는 전화로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cbe6d10b7f1a1883fd95b6bb21627c693dfd0bb" translate="yes" xml:space="preserve">
          <source>Allow turning known into unknown calls while performing late lambda lifting. This is deemed non-beneficial, so it&amp;rsquo;s off by default.</source>
          <target state="translated">늦은 람다 리프팅을 수행하는 동안 알려진 전화를 알 수없는 전화로 전환 할 수 있습니다. 이것은 유익하지 않은 것으로 간주되므로 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="274c2026d3d9723dc92cd98f7d9326abfd5773f8" translate="yes" xml:space="preserve">
          <source>Allow type signatures for members in instance definitions.</source>
          <target state="translated">인스턴스 정의에서 멤버에 대한 유형 서명을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="da5bb70ccf69edfc067bb0ecac09b8b7fa946e39" translate="yes" xml:space="preserve">
          <source>Allow type signatures which appear that they would result in an unusable binding.</source>
          <target state="translated">사용 불가능한 바인딩을 초래할 것으로 보이는 유형 서명을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="7f9ebd8bc90d2c97f8f8af6055daef8a66d58b11" translate="yes" xml:space="preserve">
          <source>Allow types of arbitrary rank.</source>
          <target state="translated">임의 순위의 유형을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="72c06cac8ca4e2cc8c6349ed8e7e17158f9a5bef" translate="yes" xml:space="preserve">
          <source>Allow types of kind &lt;code&gt;Constraint&lt;/code&gt; to be used in contexts.</source>
          <target state="translated">컨텍스트 에 종류 &lt;code&gt;Constraint&lt;/code&gt; 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7e55900edd38daa3e986afd90affccc2a45f441" translate="yes" xml:space="preserve">
          <source>Allow use and definition of indexed type and data families.</source>
          <target state="translated">인덱싱 된 유형 및 데이터 제품군의 사용 및 정의를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6e40b71ea659cf26b3075e17e0c63e65704ae662" translate="yes" xml:space="preserve">
          <source>Allow use of &lt;code&gt;Applicative&lt;/code&gt;&lt;code&gt;do&lt;/code&gt; notation.</source>
          <target state="translated">&lt;code&gt;Applicative&lt;/code&gt; &lt;code&gt;do&lt;/code&gt; 표기법 사용을 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bed755b4d0a566202ee360d2e8141648215487c" translate="yes" xml:space="preserve">
          <source>Allow use of Generalised Algebraic Data Types (GADTs).</source>
          <target state="translated">GADT (Generalized Algebraic Data Types) 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b42306fa5c185a7862be6bb52526be30dbac6894" translate="yes" xml:space="preserve">
          <source>Allow use of any typeclass in &lt;code&gt;deriving&lt;/code&gt; clauses.</source>
          <target state="translated">절 을 &lt;code&gt;deriving&lt;/code&gt; 때 모든 유형 클래스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a457c798a55fb26f0dd47dc4032be39a59a6341" translate="yes" xml:space="preserve">
          <source>Allow use of bang pattern syntax.</source>
          <target state="translated">뱅 패턴 구문 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c23bf1d512a631794fb404638276aacd4f32df67" translate="yes" xml:space="preserve">
          <source>Allow use of functional dependencies in class declarations.</source>
          <target state="translated">클래스 선언에서 기능적 종속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d060a642a2f52d17e449b4e275108c16d94164a" translate="yes" xml:space="preserve">
          <source>Allow use of generalised list (SQL-like) comprehension syntax. This introduces the &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt; keywords.</source>
          <target state="translated">일반화 된 목록 (SQL과 유사한) 이해 구문을 사용할 수 있습니다. 이것으로 , &lt;code&gt;by&lt;/code&gt; 및 키워드 &lt;code&gt;using&lt;/code&gt; &lt;code&gt;group&lt;/code&gt; 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="6416480874a524bb16d12732baf7a1a42b48283b" translate="yes" xml:space="preserve">
          <source>Allow use of record puns.</source>
          <target state="translated">레코드 찌꺼기 사용을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="62089014435f225ba326e9329061e5e4a53f0bb5" translate="yes" xml:space="preserve">
          <source>Allow use of static pointer syntax.</source>
          <target state="translated">정적 포인터 구문 사용을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="8f3abc6ee81a5c4909fa0b404e4d5cc274c88e29" translate="yes" xml:space="preserve">
          <source>Allow use of the &lt;code&gt;forall&lt;/code&gt; keyword in places where universal quantification is implicit.</source>
          <target state="translated">보편적 인 정량이 암시되는 장소에서 &lt;code&gt;forall&lt;/code&gt; 키워드를 사용하도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f830fe1b81f5dd2916e893293dc917cf10ac1a5f" translate="yes" xml:space="preserve">
          <source>Allow use of the Haskell foreign function interface.</source>
          <target state="translated">Haskell 외부 기능 인터페이스 사용을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="d2ec09e108221e720d271bb74180facf527b037f" translate="yes" xml:space="preserve">
          <source>Allow use of view pattern syntax.</source>
          <target state="translated">뷰 패턴 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d0040f1860796d1680868b0c0c97a27e733ecd" translate="yes" xml:space="preserve">
          <source>Allow worker-wrapper to convert a function closure into a thunk if the function does not use any of its arguments. Off by default.</source>
          <target state="translated">함수가 인수를 사용하지 않으면 worker-wrapper가 함수 클로저를 썽 크로 변환하도록 허용하십시오. 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf61d77eeec666128b4e93e100c46e62621a2b9" translate="yes" xml:space="preserve">
          <source>Allow writing floating point literals using hexadecimal notation.</source>
          <target state="translated">16 진 표기법을 사용하여 부동 소수점 리터럴을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b76e5dbcac70fa19335f3f6dd1767846c2ae45" translate="yes" xml:space="preserve">
          <source>AllowAmbiguousTypes</source>
          <target state="translated">AllowAmbiguousTypes</target>
        </trans-unit>
        <trans-unit id="f568f29db39d6daee9c168b5db2b40a0f82b6e78" translate="yes" xml:space="preserve">
          <source>Allows the definition of default method signatures in class definitions.</source>
          <target state="translated">클래스 정의에서 기본 메소드 서명을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39a8bda3c1c817a2744fbe48c428dd732e29b994" translate="yes" xml:space="preserve">
          <source>Allows the definition of further constraints on individual class methods.</source>
          <target state="translated">개별 클래스 메소드에 대한 추가 제한 조건을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="795662519537fb732dd1a2476e8a6962c0c19569" translate="yes" xml:space="preserve">
          <source>Allows the use definition of type classes with no parameters. This extension has been replaced by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수없이 유형 클래스의 사용 정의를 허용합니다. 이 확장은 &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2018e3c7850e7133b41fccedea329900b1f4d76e" translate="yes" xml:space="preserve">
          <source>Alone</source>
          <target state="translated">Alone</target>
        </trans-unit>
        <trans-unit id="ac58ae5ab26ea9f98150373e68429bafad7728e6" translate="yes" xml:space="preserve">
          <source>Along with traverseMaybeMissing, witnesses the isomorphism between &lt;code&gt;WhenMissing f k x y&lt;/code&gt; and &lt;code&gt;k -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt;.</source>
          <target state="translated">traverseMaybeMissing과 함께 &lt;code&gt;WhenMissing f k x y&lt;/code&gt; 와 &lt;code&gt;k -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt; 사이의 동형이 관찰 됩니다.</target>
        </trans-unit>
        <trans-unit id="7eaf4e6487782093547b308bb962d31222393a9b" translate="yes" xml:space="preserve">
          <source>Along with traverseMaybeMissing, witnesses the isomorphism between &lt;code&gt;WhenMissing f x y&lt;/code&gt; and &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt;.</source>
          <target state="translated">traverseMaybeMissing과 함께 &lt;code&gt;WhenMissing f x y&lt;/code&gt; 와 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt; 사이의 동형이 관찰 됩니다.</target>
        </trans-unit>
        <trans-unit id="fceb538d6e1da23d3f3babb9155dbc45ee7239e4" translate="yes" xml:space="preserve">
          <source>Along with zipWithMaybeAMatched, witnesses the isomorphism between &lt;code&gt;WhenMatched f k x y z&lt;/code&gt; and &lt;code&gt;k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">zipWithMaybeAMatched와 함께 WhenMatched &lt;code&gt;WhenMatched f k x y z&lt;/code&gt; 와 &lt;code&gt;k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; 사이의 동형이 관찰 됩니다.</target>
        </trans-unit>
        <trans-unit id="88e74dd86e7cd0c0ee3739f6c7a769d3ff6c7c44" translate="yes" xml:space="preserve">
          <source>Along with zipWithMaybeAMatched, witnesses the isomorphism between &lt;code&gt;WhenMatched f x y z&lt;/code&gt; and &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">zipWithMaybeAMatched 함께, 증인의 동형 &lt;code&gt;WhenMatched f x y z&lt;/code&gt; 및 &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ad299afbc240cf0075ef975ed7558787fe489f" translate="yes" xml:space="preserve">
          <source>AlreadyExists</source>
          <target state="translated">AlreadyExists</target>
        </trans-unit>
        <trans-unit id="630df194c5b10abfa95d9d050a3cb36c24a133d2" translate="yes" xml:space="preserve">
          <source>Also</source>
          <target state="translated">Also</target>
        </trans-unit>
        <trans-unit id="50722218b035a878cd9ffc30a73ebfebc7a35f8b" translate="yes" xml:space="preserve">
          <source>Also causes a warning to be emitted when a module is re-exported, but that module exports nothing.</source>
          <target state="translated">또한 모듈을 다시 내보낼 때 경고가 발생하지만 해당 모듈은 아무것도 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="746c9d1259ee19f74bffdc1d68a458f59b53388d" translate="yes" xml:space="preserve">
          <source>Also for newtypes, &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Enum&lt;/code&gt; are derived using the &lt;code&gt;newtype&lt;/code&gt; strategy if &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and the derivation succeeds.</source>
          <target state="translated">또한 &lt;code&gt;newtype&lt;/code&gt; 경우 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 이 활성화되고 파생이 성공하면 &lt;code&gt;Functor&lt;/code&gt; , &lt;code&gt;Foldable&lt;/code&gt; 및 &lt;code&gt;Enum&lt;/code&gt; 은 newtype 전략을 사용하여 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="9b5456c8967e8ed475ed23a6be13064c4931fe49" translate="yes" xml:space="preserve">
          <source>Also in the same way as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, when &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicilty bound in a type instance declaration.</source>
          <target state="translated">또한 같은 방법으로 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 유형 및 종류의 변수 explicilty 유형의 인스턴스 선언에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cdbfaf0e12c5c669a436bbe3f3e6d1b8921e00e" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92256f9554b50ce0b2fea7c43d4cb8cc3cb75d44" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="691fd7629064f3b051f676bcbfa6149c61d9b342" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="406dc1c18625f274ff0dc94719e4b6be8d808a02" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="810701a878272ce093eceec04b908e8284d8a9c5" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d40d8b2532580731c8434c5f67b1078551988ae" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd8ee350e8fa89eeaea33735d33ccaffdcefe56b" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e30beaf60ec387590381b5355c5af1eb18030345" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스는 대체 성을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aab6ba61f08a0ca3c95484013fb136c6e751322c" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4786dd3fd2bcdff58d3b26007350033e063a192" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0이 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e16b7f498e9a6b4b83f2652ce5ef38935a94752" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e9f33b522d825dd8a332d37d794d47c3815cced" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0이 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="40cdf5e6225f275daf21fe333e66b5c010a69778" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0의 존재로 인해 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b45d0d39ada80fe3208a871ffe74aeb25503276e" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0의 존재로 인해 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f433875b8e4b77573f0f23895a49894977730bb" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0이 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6e30397e70af87af894b6d2572b73af0484f5e2" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">또한 -0이 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 추가 ID가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4cc23b0b0763553e0311dddd73a34a9e4dee8d5" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 연산자에 적용하기 전에 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; 를 강요하지 않기 때문입니다 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ). 이로 인해 썽크 체인 &lt;code&gt;O(n)&lt;/code&gt; 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8ed5ac80b0447d75eb36a8e1088f826de1949152" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 연산자에 적용하기 전에 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; 를 강요하지 않기 때문입니다 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ). 이로 인해 썽크 체인 &lt;code&gt;O(n)&lt;/code&gt; 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0312e92e764c438aa064f2113437c35a6539b369" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">또한 당신은 아마 사용하려는 경우 효율적인하려면 왼쪽 배 있습니다 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 연산자에 적용하기 전에 &quot;내부&quot;결과 (예 : 위의 예에서 &lt;code&gt;z `f` x1&lt;/code&gt; 를 강요하지 않기 때문입니다 (예 : &lt;code&gt;(`f` x2)&lt;/code&gt; ). 이로 인해 썽크 체인 &lt;code&gt;O(n)&lt;/code&gt; 요소가 길어지고 외부에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1acbfc03f5d47fca9d6b436cb055a438d6d24adc" translate="yes" xml:space="preserve">
          <source>Also note that the argument to &lt;code&gt;DEPRECATED&lt;/code&gt; and &lt;code&gt;WARNING&lt;/code&gt; can also be a list of strings, in which case the strings will be presented on separate lines in the resulting warning message,</source>
          <target state="translated">또한 &lt;code&gt;DEPRECATED&lt;/code&gt; 및 &lt;code&gt;WARNING&lt;/code&gt; 에 대한 인수 는 문자열 목록 일 수 있으며,이 경우 문자열은 결과 경고 메시지에서 별도의 줄에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa8f340d5595cab499d451cc0ad91fefbf788a96" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cde3b82cd7b9ecd782961c29d79052d748e75c8a" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="41ccfa2353a09113f0c811d9cb51cb48399720bc" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="235d629ac464213b855f299b5269fbab1821ac2a" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a09b8126190a3493d9f5d149861112b275c4a820" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="df2b6faed2041cbc5f8775d83e79ec068a616bf0" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f982812ed18e181efb5f1842c282247a56bf7ec3" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="27a6d2f2099e869b6c35b0b33e690f3dbb98988d" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">또한 동일한 이유로 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 운영자 상호 작용은 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 인스턴스에 의해 존중되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="220abdef84f1e02ea77807f44da3633ce41b62f6" translate="yes" xml:space="preserve">
          <source>Also note the use of &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; in the GHCi session above instead of &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;. This is because &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; gives you the type that would be inferred for a variable assigned to the expression provided (that is, the type of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;let x = &amp;lt;expr&amp;gt;&lt;/code&gt;). As we saw above with &lt;code&gt;myLength2&lt;/code&gt;, this type will have no variables available to visible type application. On the other hand, &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; gives you the actual type of the expression provided. To illustrate this:</source>
          <target state="translated">또한 위의 GHCi 세션에서 &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 . 이 때문입니다 &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; 당신에게 제공되는 표현에 할당 된 변수에 대한 추정 될 유형을 제공합니다 (즉, 유형 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;let x = &amp;lt;expr&amp;gt;&lt;/code&gt; ). 위에서 &lt;code&gt;myLength2&lt;/code&gt; 로 보았 듯이이 유형에는 보이는 유형 응용 프로그램에 사용할 수있는 변수가 없습니다. 반면에 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 는 제공된 표현식의 실제 유형을 제공합니다. 이것을 설명하려면 :</target>
        </trans-unit>
        <trans-unit id="2513c4a2bdd30848586867d45397f58c5275a1ec" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;extra-libraries&lt;/code&gt; are placed on the linker command line after the &lt;code&gt;hs-libraries&lt;/code&gt; for the same package. If your package has dependencies in the other direction (i.e. &lt;code&gt;extra-libraries&lt;/code&gt; depends on &lt;code&gt;hs-libraries&lt;/code&gt;), and the libraries are static, you might need to make two separate packages.</source>
          <target state="translated">또한 &lt;code&gt;extra-libraries&lt;/code&gt; 패키지는 동일한 패키지 의 &lt;code&gt;hs-libraries&lt;/code&gt; 다음에있는 링커 명령 줄에 배치 됩니다. 패키지가 다른 방향으로 종속성이 있고 (즉, &lt;code&gt;extra-libraries&lt;/code&gt; 는 &lt;code&gt;hs-libraries&lt;/code&gt; 에 의존 ) 라이브러리가 정적이면 두 개의 별도 패키지를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="40984f68323bbc3a5e0662d8396443ffd212990b" translate="yes" xml:space="preserve">
          <source>Also, you may need to use the &lt;a href=&quot;#ghc-flag--rdynamic&quot;&gt;&lt;code&gt;-rdynamic&lt;/code&gt;&lt;/a&gt; flag to ensure that that symbols are not dropped from your PIE objects.</source>
          <target state="translated">또한 PIE 오브젝트에서 기호가 삭제되지 않도록 &lt;a href=&quot;#ghc-flag--rdynamic&quot;&gt; &lt;code&gt;-rdynamic&lt;/code&gt; &lt;/a&gt; 플래그 를 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e30eff925100b7c3e119ed678e39009e962455b0" translate="yes" xml:space="preserve">
          <source>Alt</source>
          <target state="translated">Alt</target>
        </trans-unit>
        <trans-unit id="e429c5fc3a2401f13f505fe2471ed35cea126252" translate="yes" xml:space="preserve">
          <source>Alternate completion to perform if the cursor is not at a quoted word</source>
          <target state="translated">커서가 인용 된 단어가 아닌 경우 수행을위한 대체 완료</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="f427a4339b88ab5730e552c0af40d96b9c132d30" translate="yes" xml:space="preserve">
          <source>AlternativeLayoutRule</source>
          <target state="translated">AlternativeLayoutRule</target>
        </trans-unit>
        <trans-unit id="a87adb1730114f941ad55c79898057fd80fd74d1" translate="yes" xml:space="preserve">
          <source>AlternativeLayoutRuleTransitional</source>
          <target state="translated">AlternativeLayoutRuleTransitional</target>
        </trans-unit>
        <trans-unit id="76d5f5130ef008f32d0f9b4ea42dc455c34353b6" translate="yes" xml:space="preserve">
          <source>Alternatively &lt;code&gt;Coll&lt;/code&gt; might be rewritten</source>
          <target state="translated">또는 &lt;code&gt;Coll&lt;/code&gt; 이 다시 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65a8212521ccdabba5ba2d4d0578992c935fe0f" translate="yes" xml:space="preserve">
          <source>Alternatively you can use &lt;a href=&quot;#ghc-flag--funbox-small-strict-fields&quot;&gt;&lt;code&gt;-funbox-small-strict-fields&lt;/code&gt;&lt;/a&gt; to only unbox strict fields which are &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">또는 &lt;a href=&quot;#ghc-flag--funbox-small-strict-fields&quot;&gt; &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; &lt;/a&gt; 를 사용하여 &quot;small&quot;인 엄격한 필드 만 개봉 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0139c0df4a42fccf86ef595e9d7e4a89d60e0341" translate="yes" xml:space="preserve">
          <source>Alternatively, core plugins can be specified with Template Haskell.</source>
          <target state="translated">또는 템플릿 Haskell을 사용하여 핵심 플러그인을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bde40f6b099fd2459055a9d8eec8e840639306e" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to build GHC yourself, head on over to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Building&quot;&gt;GHC Building Guide&lt;/a&gt; to find out how to get the sources, and build it on your system. Note that GHC itself is written in Haskell, so you will still need to install GHC in order to build it.</source>
          <target state="translated">또는 GHC를 직접 구축하려면 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Building&quot;&gt;GHC 빌딩 가이드&lt;/a&gt; 를 방문하여 소스를 얻는 방법을 찾아 시스템에 빌드하십시오. GHC 자체는 Haskell로 작성되었으므로 빌드하려면 GHC를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="487925a0dfe33b56fabdc308b58c83700f73524a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to build GHC yourself, head on over to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/building&quot;&gt;GHC Building Guide&lt;/a&gt; to find out how to get the sources, and build it on your system. Note that GHC itself is written in Haskell, so you will still need to install GHC in order to build it.</source>
          <target state="translated">또는 GHC를 직접 빌드하려면 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/building&quot;&gt;GHC 빌드 가이드&lt;/a&gt; 로 이동하여 소스를 얻고 시스템에서 빌드하는 방법을 찾으십시오. GHC 자체는 Haskell로 작성되었으므로 빌드하려면 GHC를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="cdb5e0c35bffdb5bac67b4158b85ee94fc664745" translate="yes" xml:space="preserve">
          <source>Alternatively, use your &lt;code id=&quot;index-14&quot;&gt;TMPDIR&lt;/code&gt; environment variable. Set it to the name of the directory where temporary files should be put. GCC and other programs will honour the &lt;code id=&quot;index-15&quot;&gt;TMPDIR&lt;/code&gt; variable as well.</source>
          <target state="translated">또는 &lt;code id=&quot;index-14&quot;&gt;TMPDIR&lt;/code&gt; 환경 변수를 사용하십시오 . 임시 파일을 넣을 디렉토리 이름으로 설정하십시오. GCC 및 기타 프로그램은 &lt;code id=&quot;index-15&quot;&gt;TMPDIR&lt;/code&gt; 변수도 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="7b0162a0bbd1d38dbdfc269cc088cc5f731a6ba2" translate="yes" xml:space="preserve">
          <source>Alternatively, you can give a type signature to the enclosing context, which GHC can &amp;ldquo;push down&amp;rdquo; to find the type for the variable:</source>
          <target state="translated">또는 GHC가 변수의 유형을 찾기 위해&amp;ldquo;푸시 다운&amp;rdquo;할 수있는 엔 클로징 컨텍스트에 유형 서명을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="369a93d4fce888d55a59c31d08c7fb3c46433a3b" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="29cf9aad2a6fbceeb5608717dde74a1b736195b5" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="c14f8d1451ab6b8eb4e7c4771d4a0ca47ed0fa3c" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="aabfacf44a025fa1709c2ce0bc2ca417b25be0c8" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="53f69795c586d406dd4511ba9d5155c1a42f2617" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="7e9ddf09d766d5f9ca39130ead484571fe0feced" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="832b928147d026a938c7c9c4f9b77b788e8f12a1" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="b8713c63104594f55f79cca79583e8fe10117c5e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 이 유형의 인스턴스 유형이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; , 두 기능은 미묘하게 다르다 :</target>
        </trans-unit>
        <trans-unit id="e2ed5be7a335e3dba8612b72e2da7b9e639f8124" translate="yes" xml:space="preserve">
          <source>Although GHC allows the user to pass all unlifted boxed types to foreign functions, some of them are not amenable to useful work. Although &lt;code&gt;Array#&lt;/code&gt; is unlifted, the elements in its payload are lifted, and a foreign C function cannot safely force thunks. Consequently, a foreign C function may not dereference any of the addresses that comprise the payload of the &lt;code&gt;Array#&lt;/code&gt;.</source>
          <target state="translated">GHC를 사용하면 사용자가 모든 unlifted boxed 유형을 외부 함수에 전달할 수 있지만 일부는 유용한 작업에 적합하지 않습니다. 비록 &lt;code&gt;Array#&lt;/code&gt; unlifted, 그 페이로드의 요소는 해제되고, 외부 C 함수 안전하게 썽크 강제 할 수 없다. 결과적으로 외부 C 함수는 &lt;code&gt;Array#&lt;/code&gt; 의 페이로드를 구성하는 주소를 역 참조하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea6b65048b50606bfc86ae17bba6c11487ce8b27" translate="yes" xml:space="preserve">
          <source>Although all open type families are considered to have a complete user-supplied kind signature, we can relax this condition for closed type families, where we have equations on which to perform kind inference. GHC will infer kinds for the arguments and result types of a closed type family.</source>
          <target state="translated">모든 개방형 패밀리는 사용자가 제공 한 완전한 종류 서명이있는 것으로 간주되지만 폐쇄 형 패밀리에 대해서는이 조건을 완화 할 수 있습니다. GHC는 폐쇄 형 패밀리의 인수 및 결과 유형에 대한 종류를 유추합니다.</target>
        </trans-unit>
        <trans-unit id="a8ba660b18337f8755c5f957412710cfb811a48b" translate="yes" xml:space="preserve">
          <source>Although it is equivalent to running GHC twice, using &lt;code&gt;-dynamic-too&lt;/code&gt; is more efficient, because the earlier phases of the compiler up to code generation are performed just once.</source>
          <target state="translated">GHC를 두 번 실행하는 것과 동일하지만 코드 생성까지 컴파일러의 초기 단계가 한 번만 수행되므로 &lt;code&gt;-dynamic-too&lt;/code&gt; 를 사용하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="17fe55cf03ef562c44820f718c2ff2b873fd70ad" translate="yes" xml:space="preserve">
          <source>Although it is unusual, there (currently) can be &lt;em&gt;multiple&lt;/em&gt; instances for an associated family in a single instance declaration. For example, this is legitimate:</source>
          <target state="translated">드문 경우이지만 단일 인스턴스 선언에 현재 연결된 패밀리에 대해 &lt;em&gt;여러&lt;/em&gt; 인스턴스 가있을 수 있습니다 . 예를 들어, 이것은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="c0e0fc4143b94596d60f1c94c3fec1d4b047aa5e" translate="yes" xml:space="preserve">
          <source>Although names generated by &lt;code&gt;newName&lt;/code&gt; cannot &lt;em&gt;be captured&lt;/em&gt;, they can &lt;em&gt;capture&lt;/em&gt; other names. For example, this:</source>
          <target state="translated">&lt;code&gt;newName&lt;/code&gt; 으로 생성 된 이름은 &lt;em&gt;캡처&lt;/em&gt; 할 수 없지만 다른 이름을 &lt;em&gt;캡처&lt;/em&gt; 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="051c31d13e18e01e98444eb19f8ca75e805e3ed3" translate="yes" xml:space="preserve">
          <source>Although not recommended, the deprecated &lt;a href=&quot;#ghc-flag--fglasgow-exts&quot;&gt;&lt;code&gt;-fglasgow-exts&lt;/code&gt;&lt;/a&gt; flag enables a large swath of the extensions supported by GHC at once.</source>
          <target state="translated">권장되지는 않지만, 더 이상 사용되지 않는 &lt;a href=&quot;#ghc-flag--fglasgow-exts&quot;&gt; &lt;code&gt;-fglasgow-exts&lt;/code&gt; &lt;/a&gt; 플래그를 사용하면 GHC가 지원하는 확장 기능을 한 번에 대량으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fca41e21a6d4cf355148dfe827eb5a105a329d84" translate="yes" xml:space="preserve">
          <source>Although only GHC implements arrow notation directly, there is also a preprocessor (available from the &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;arrows web page&lt;/a&gt;) that translates arrow notation into Haskell 98 for use with other Haskell systems. You would still want to check arrow programs with GHC; tracing type errors in the preprocessor output is not easy. Modules intended for both GHC and the preprocessor must observe some additional restrictions:</source>
          <target state="translated">GHC만이 화살표 표기법을 직접 구현하지만, 화살표 표기법을 다른 Haskell 시스템과 함께 사용하기 위해 Haskell 98로 변환 하는 프리 프로세서도 있습니다 ( &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;화살표 웹 페이지&lt;/a&gt; 에서 사용 가능). 여전히 GHC로 화살표 프로그램을 확인하고 싶을 것입니다. 전 처리기 출력의 추적 유형 오류는 쉽지 않습니다. GHC 및 전 처리기 모두를위한 모듈은 몇 가지 추가 제한 사항을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="030de1c351ae0b62dc7102e4cd4c0fd4463e840e" translate="yes" xml:space="preserve">
          <source>Although quantified constraints are a little like local instance declarations, they differ in one big way: the local instances are written by the compiler, not the user, and hence cannot introduce incoherence. Consider</source>
          <target state="translated">정량화 된 제약 조건은 로컬 인스턴스 선언과 약간 비슷하지만 크게 다릅니다. 로컬 인스턴스는 사용자가 아닌 컴파일러가 작성하므로 불일치가 발생할 수 없습니다. 치다</target>
        </trans-unit>
        <trans-unit id="917df874b8dc3f0710c076dbfbabbd379b501cb5" translate="yes" xml:space="preserve">
          <source>Although the distinction between &lt;em&gt;file&lt;/em&gt; symbolic links and &lt;em&gt;directory&lt;/em&gt; symbolic links does not exist on POSIX systems, on Windows this is an intrinsic property of every symbolic link and cannot be changed without recreating the link. A file symbolic link that actually points to a directory will fail to dereference and vice versa. Moreover, creating symbolic links on Windows may require privileges unavailable to users outside the Administrators group. Portable programs that use symbolic links should take both into consideration.</source>
          <target state="translated">POSIX 시스템에는 &lt;em&gt;파일&lt;/em&gt; 심볼릭 링크와 &lt;em&gt;디렉토리&lt;/em&gt; 심볼릭 링크 의 차이점 이 없지만 Windows에서는 모든 심볼릭 링크의 고유 속성이므로 링크를 다시 만들지 않고는 변경할 수 없습니다. 실제로 디렉토리를 가리키는 파일 심볼릭 링크는 역 참조에 실패하고 그 반대도 마찬가지입니다. 또한 Windows에서 심볼릭 링크를 만들려면 관리자 그룹 외부의 사용자가 사용할 수없는 권한이 필요할 수 있습니다. 심볼릭 링크를 사용하는 이식 가능한 프로그램은 둘 다 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="99e9a14b3e8cd2cda9b0d1073e9a3e3d417a68e2" translate="yes" xml:space="preserve">
          <source>Although typechecking &lt;code&gt;T MyInt&lt;/code&gt; will terminate, GHC&amp;rsquo;s termination checker isn&amp;rsquo;t sophisticated enough to determine this, so you&amp;rsquo;ll need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; in order to use this derived instance. If you do go down this route, make sure you can convince yourself that all of the type family instances you&amp;rsquo;re deriving will eventually terminate if used!</source>
          <target state="translated">유형 검사 &lt;code&gt;T MyInt&lt;/code&gt; 가 종료되지만 GHC의 종료 검사기는이를 결정하기에 정교하지 &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 파생 인스턴스를 사용하려면 UndecidableInstances 를 활성화해야 합니다. 이 경로를 따라 가면 사용중인 모든 유형 패밀리 인스턴스가 결국 종료 될 것임을 확신 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="6fee9b71141e5521bd00d271e9f736a2cbff6c7d" translate="yes" xml:space="preserve">
          <source>Although we have given only a few examples here, it should be clear that the addition of dependency information can help to make multiple parameter classes more useful in practice, avoiding ambiguity problems, and allowing more general sets of instance declarations.</source>
          <target state="translated">여기에 몇 가지 예만 제시했지만 종속성 정보를 추가하면 여러 매개 변수 클래스를 실제로 유용하게 사용하여 모호성 문제를 피하고보다 일반적인 인스턴스 선언을 허용하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34157ee16cf986f86cc94da23a34f265af1348f" translate="yes" xml:space="preserve">
          <source>Although, a data family is &lt;em&gt;introduced&lt;/em&gt; with the keyword &amp;ldquo;&lt;code&gt;data&lt;/code&gt;&amp;rdquo;, a data family &lt;em&gt;instance&lt;/em&gt; can use either &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;. For example:</source>
          <target state="translated">키워드 &quot; &lt;code&gt;data&lt;/code&gt; &quot;를 사용하여 데이터 패밀리를 &lt;em&gt;도입&lt;/em&gt; 하더라도 데이터 패밀리 &lt;em&gt;인스턴스&lt;/em&gt; 는 &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; 을 사용할 수 있습니다 . 예를 들면 다음과 같습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc69fe6d4cdd92804a7734b80adc8316333f1f44" translate="yes" xml:space="preserve">
          <source>Always fails.</source>
          <target state="translated">항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d694f7e3dcf06959f0a7fcce2057e4016e3a9632" translate="yes" xml:space="preserve">
          <source>Always write interface files</source>
          <target state="translated">항상 인터페이스 파일을 작성하십시오</target>
        </trans-unit>
        <trans-unit id="acb5edef3f602d225f892db47fe7ee1f895d055d" translate="yes" xml:space="preserve">
          <source>Always write interface files. GHC will normally write interface files automatically, but this flag is useful with &lt;a href=&quot;#ghc-flag--fno-code&quot;&gt;&lt;code&gt;-fno-code&lt;/code&gt;&lt;/a&gt;, which normally suppresses generation of interface files. This is useful if you want to type check over multiple runs of GHC without compiling dependencies.</source>
          <target state="translated">항상 인터페이스 파일을 작성하십시오. GHC는 일반적으로 인터페이스 파일을 자동으로 쓰지만,이 플래그는 &lt;a href=&quot;#ghc-flag--fno-code&quot;&gt; &lt;code&gt;-fno-code&lt;/code&gt; &lt;/a&gt; 와 함께 유용하며 일반적으로 인터페이스 파일 생성을 억제합니다. 종속성을 컴파일하지 않고 여러 GHC 실행을 통해 유형 검사를 수행하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="770876e2d8a6f234b57db2323d7a120bd5cefd2f" translate="yes" xml:space="preserve">
          <source>Ambiguity can be subtle. Consider this example which uses functional dependencies:</source>
          <target state="translated">모호성은 미묘 할 수 있습니다. 기능적 종속성을 사용하는 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3ee65b18fc60dcabb8937e100f2503fb55e37a11" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma may have a &lt;a href=&quot;#pragma-CONLIKE&quot;&gt;&lt;code&gt;CONLIKE&lt;/code&gt;&lt;/a&gt; modifier, which affects matching in &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (only). See &lt;a href=&quot;#conlike&quot;&gt;How rules interact with CONLIKE pragmas&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; 프라그가있을 수 &lt;a href=&quot;#pragma-CONLIKE&quot;&gt; &lt;code&gt;CONLIKE&lt;/code&gt; 에서&lt;/a&gt; 의 정합에 영향 개질제 &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; &lt;/a&gt; 들 (전용). &lt;a href=&quot;#conlike&quot;&gt;규칙이 CONLIKE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d03a800321c3532f62fd50dbd5f813f55dc2c76d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma may have a &lt;code&gt;CONLIKE&lt;/code&gt; modifier, which affects matching in &lt;code&gt;RULE&lt;/code&gt;s (only). See &lt;a href=&quot;#conlike&quot;&gt;How rules interact with CONLIKE pragmas&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; 프라그가있을 수 &lt;code&gt;CONLIKE&lt;/code&gt; 에서 의 정합에 영향 개질제 &lt;code&gt;RULE&lt;/code&gt; 들 (전용). &lt;a href=&quot;#conlike&quot;&gt;규칙이 CONLIKE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de96fd13e454f7d0ced988da0b0fe6591f42a8af" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; t&lt;/code&gt; is mutable location that is either empty or contains a value of type &lt;code&gt;t&lt;/code&gt;. It has two fundamental operations: &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; which fills an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if it is empty and blocks otherwise, and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; which empties an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if it is full and blocks otherwise. They can be used in multiple different ways:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; t&lt;/code&gt; 하나 비어 있거나 타입의 값이 포함되어 가변 위치 &lt;code&gt;t&lt;/code&gt; 을 . : 그것은 두 가지 기본적인 작업이 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 채워 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 이 그렇지 않으면 빈 차단하고, 경우 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 비워 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 가 달리 완전하고 블록 인 경우를. 그들은 여러 가지 방법으로 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bfc651b7b6015a5d38e8dc9b2d2cd9a41bf19609" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (pronounced &quot;em-var&quot;) is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (발음 &quot;EM-VAR&quot;)은 동시 스레드 간의 통신에 이용되는 동기 변수이다. 비어 있거나 가득 찬 상자로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e415725c78688d42711652a7e4079f14251bb6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e750e5e924cba57bf36a0ebd4161427cec7557d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34c3205df3a50720edd8ad6a1e53cf3a8ebdb0c5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f847ae13cb0b0976d90acd768ce3eab18b000b5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47281938d8ea8fab14ec059d784740642bb1fcd7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent boxed version (&lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt;) with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 은 일반적으로 등가 박스형 버전 (보다 (시간과 공간 모두의 측면에서)보다 효율적으로 될 것이다 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 동일한 요소 유형). 그러나 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 는 해당 요소 가 엄격하므로 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 에서 제공 하는 엄격하지 않은 것이 필요한 경우 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="10ab056c484cefd1634f35523d774bd2bf27bc81" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent boxed version (&lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt;) with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 은 일반적으로 등가 박스형 버전 (보다 (시간과 공간 모두의 측면에서)보다 효율적으로 될 것이다 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 동일한 요소 유형). 그러나 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 는 해당 요소 가 엄격하므로 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 에서 제공 하는 엄격하지 않은 것이 필요한 경우 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c72c0a99e8a213a03ed1ff5d7bad4f8d34a4fe41" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; instance is always required (but it can just ignore the meta-information, as is the case for &lt;code&gt;encode&lt;/code&gt; above).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 의 인스턴스는 항상 필요합니다 (그러나의 경우와 같이 단지 메타 정보를 무시할 수 &lt;code&gt;encode&lt;/code&gt; 위의).</target>
        </trans-unit>
        <trans-unit id="c6430d754f6ee1e74237537560c890d61207b930" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 는 에서 변경 가능한, 박스, 비 엄격한 배열 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드. 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fec238ef2447aa47087bb9d112fb0dd69cdcd4c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (pronounced &quot;em-var&quot;) is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (발음 &quot;EM-VAR&quot;)은 동시 스레드 간의 통신에 이용되는 동기 변수이다. 비어 있거나 가득 찬 상자로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64ebf00aaf703cb98269bd37718878465c05c15" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;INLINE&lt;/code&gt; function is not worker/wrappered by strictness analysis. It&amp;rsquo;s going to be inlined wholesale instead.</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; 의 기능은 작업자 / 엄격 분석에 의해 wrappered 없습니다. 대신 도매로 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="683b56235dbe6d9de132b9c32113d5f5fe04aa0c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;InstalledPackageInfo&lt;/code&gt; has a human readable/writable syntax. The functions &lt;code&gt;parseInstalledPackageInfo&lt;/code&gt; and &lt;code&gt;showInstalledPackageInfo&lt;/code&gt; read and write this syntax respectively. Here&amp;rsquo;s an example of the &lt;code&gt;InstalledPackageInfo&lt;/code&gt; for the &lt;code&gt;unix&lt;/code&gt; package:</source>
          <target state="translated">&lt;code&gt;InstalledPackageInfo&lt;/code&gt; 은 인간 판독 / 기록 가능한 구문을 갖는다. &lt;code&gt;parseInstalledPackageInfo&lt;/code&gt; 및 &lt;code&gt;showInstalledPackageInfo&lt;/code&gt; 함수는 이 구문을 각각 읽고 씁니다. 다음 은 &lt;code&gt;unix&lt;/code&gt; 패키지를 위한 &lt;code&gt;InstalledPackageInfo&lt;/code&gt; 의 예입니다 :</target>
        </trans-unit>
        <trans-unit id="3a2c03ccefc5072e12ca70273302c1ee7ab6f1d5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;OperatorTable s u m a&lt;/code&gt; is a list of &lt;code&gt;Operator s u m a&lt;/code&gt; lists. The list is ordered in descending precedence. All operators in one list have the same precedence (but may have a different associativity).</source>
          <target state="translated">&lt;code&gt;OperatorTable s u m a&lt;/code&gt; 의 목록입니다 &lt;code&gt;Operator s u m a&lt;/code&gt; 목록. 목록은 내림차순으로 정렬됩니다. 한 목록의 모든 연산자는 우선 순위가 동일하지만 다른 연관성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9933684475c3885933d3cb45f7d700d24f1bf2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;{-# INLINABLE f #-}&lt;/code&gt; pragma on a function &lt;code&gt;f&lt;/code&gt; has the following behaviour:</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 에 대한 &lt;code&gt;{-# INLINABLE f #-}&lt;/code&gt; pragma 는 다음과 같은 동작을합니다.</target>
        </trans-unit>
        <trans-unit id="b9ded8006363b78c478c9d256d512759af3de706" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;orphan module&lt;/em&gt; orphan module contains at least one &lt;em&gt;orphan instance&lt;/em&gt; or at least one &lt;em&gt;orphan rule&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;고아 모듈&lt;/em&gt; 고아 모듈은 적어도 하나 개 포함 &lt;em&gt;고아 인스턴스&lt;/em&gt; 또는 적어도 하나의 &lt;em&gt;고아 규칙을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e3de3cb88319a179768b2746e40461a71f436143" translate="yes" xml:space="preserve">
          <source>An FFI binding to the hot key part of the Win32 API.</source>
          <target state="translated">Win32 API의 단축키 부분에 대한 FFI 바인딩.</target>
        </trans-unit>
        <trans-unit id="cbfb652fdf79531cc3d86d6d11da84e45c07abbf" translate="yes" xml:space="preserve">
          <source>An FFI binding to the system part of the Win32 API.</source>
          <target state="translated">Win32 API의 시스템 부분에 대한 FFI 바인딩</target>
        </trans-unit>
        <trans-unit id="451395d3497bffe11685a4808d989a520d0e956e" translate="yes" xml:space="preserve">
          <source>An HValueRef with a finalizer</source>
          <target state="translated">종료자가있는 HValueRef</target>
        </trans-unit>
        <trans-unit id="d2d296bd0d9d97c26c27e28a4f8f9fc312ec86a0" translate="yes" xml:space="preserve">
          <source>An I/O event.</source>
          <target state="translated">I / O 이벤트</target>
        </trans-unit>
        <trans-unit id="9d61e77c59f8de3e6e0f09bd0569bdcfd960fe05" translate="yes" xml:space="preserve">
          <source>An IO monad wrapped in &lt;code&gt;StateT&lt;/code&gt; inside of &lt;code&gt;ErrorT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;StateT&lt;/code&gt; 내부의 &lt;code&gt;ErrorT&lt;/code&gt; 래핑 된 IO 모나드 :</target>
        </trans-unit>
        <trans-unit id="7426b52720da94bc2bc36c2af36224d9d16ed966" translate="yes" xml:space="preserve">
          <source>An ML-style language usually generalises the type of any &lt;code&gt;let&lt;/code&gt;-bound or &lt;code&gt;where&lt;/code&gt;-bound variable, so that it is as polymorphic as possible. With the extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; GHC implements a slightly more conservative policy, using the following rules:</source>
          <target state="translated">ML 스타일 언어는 일반적으로 &lt;code&gt;let&lt;/code&gt; -bound 또는 &lt;code&gt;where&lt;/code&gt; -bound 변수 의 유형을 일반화하여 가능한 한 다형성이되도록합니다. 확장을 통해 &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; GHC는 다음 규칙을 사용하여 약간 더 보수적 인 정책을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9cefabc3584d4516f625a578f6ab414f96911025" translate="yes" xml:space="preserve">
          <source>An RTS debugging flag; only available if the program was linked with the &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt; option. Various values of ⟨x⟩ are provided to enable debug messages and additional runtime sanity checks in different subsystems in the RTS, for example &lt;code&gt;+RTS -Ds -RTS&lt;/code&gt; enables debug messages from the scheduler. Use &lt;code&gt;+RTS -?&lt;/code&gt; to find out which debug flags are supported.</source>
          <target state="translated">RTS 디버깅 플래그; 프로그램이 &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt; 옵션 과 링크 된 경우에만 사용 가능합니다 . RTS의 다른 서브 시스템에서 디버그 메시지 및 추가 런타임 정상 상태 점검을 가능하게하기 위해 다양한 ⟨x⟩ 값이 제공됩니다. 예를 들어 &lt;code&gt;+RTS -Ds -RTS&lt;/code&gt; 는 스케줄러의 디버그 메시지를 사용합니다. &lt;code&gt;+RTS -?&lt;/code&gt; 사용 ? 어떤 디버그 플래그가 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4e45674dc1c637028f0f01799a8815e6ecb98130" translate="yes" xml:space="preserve">
          <source>An XHTML combinator library.</source>
          <target state="translated">XHTML 결합기 라이브러리</target>
        </trans-unit>
        <trans-unit id="09858e905a1c37c93edf149194a2d9bb2ce3582b" translate="yes" xml:space="preserve">
          <source>An abstract interface to a unique symbol generator.</source>
          <target state="translated">고유 한 심볼 생성기에 대한 추상 인터페이스.</target>
        </trans-unit>
        <trans-unit id="c3d4f7cf1abe842d95a74003b96fc062bd25f990" translate="yes" xml:space="preserve">
          <source>An abstract name for an object, that supports equality and hashing.</source>
          <target state="translated">동등성과 해싱을 지원하는 객체의 추상 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c7780c030353da535248bab25cc8ad315039483b" translate="yes" xml:space="preserve">
          <source>An abstract type representing names in the syntax tree.</source>
          <target state="translated">구문 트리에서 이름을 나타내는 추상 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3739511153de0d9b79bcbb692e2cd72c742f7bd7" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 의 각 변형에 대한 값을 포함하는 추상 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="580e2ee0cc2d32003a3cd07143debcb038d87924" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 의 각 변형에 대한 값을 포함하는 추상 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="4efb40389fa8d66e189c71d212784428f0bae6b2" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 의 각 변형에 대한 값을 포함하는 추상 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="35eff700132dbe6d90bfc15821db76d5acbdf25d" translate="yes" xml:space="preserve">
          <source>An abstract unique object. Objects of type &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; may be compared for equality and ordering and hashed into &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추상적 인 독특한 객체. &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 유형의 객체는 동등성과 순서를 비교하고 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 해시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21c7f832db5783c3e7a8088c500d2962ed9384be" translate="yes" xml:space="preserve">
          <source>An accumulating function</source>
          <target state="translated">축적 기능</target>
        </trans-unit>
        <trans-unit id="b61c87037791a3b504bed8e01931aafc2fc5942c" translate="yes" xml:space="preserve">
          <source>An accumulation monad parameterized by the type &lt;code&gt;w&lt;/code&gt; of output to accumulate.</source>
          <target state="translated">누적 출력 &lt;code&gt;w&lt;/code&gt; 유형에 의해 매개 변수화 된 누적 모나드 .</target>
        </trans-unit>
        <trans-unit id="f7cc330fe5c9abb7f58e424cead33a14c496fa0c" translate="yes" xml:space="preserve">
          <source>An accumulation monad parameterized by:</source>
          <target state="translated">다음에 의해 매개 변수화 된 축적 모나드 :</target>
        </trans-unit>
        <trans-unit id="282bf0a0b47e57c828188f0a009349e911a1315e" translate="yes" xml:space="preserve">
          <source>An action which sends output to the terminal. That output may mix plain text with control characters and escape sequences, along with delays (called &quot;padding&quot;) required by some older terminals.</source>
          <target state="translated">출력을 터미널로 보내는 동작입니다. 이 출력은 일부 오래된 터미널에 필요한 지연 ( &quot;패딩&quot;)과 함께 일반 텍스트와 제어 문자 및 이스케이프 시퀀스를 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40621b0cc1f828021b505715d70a5c3153c57b8e" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#ghc-flag--ddump-ticked&quot;&gt;&lt;code&gt;-ddump-ticked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--ddump-ticked&quot;&gt; &lt;code&gt;-ddump-ticked&lt;/code&gt; &lt;/a&gt; 의 별명 .</target>
        </trans-unit>
        <trans-unit id="35feeff338058bf37c6e24f0244366473367a8b7" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;--nonmoving-gc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt; &lt;code&gt;--nonmoving-gc&lt;/code&gt; &lt;/a&gt; 의 별칭</target>
        </trans-unit>
        <trans-unit id="6cbb51b39bb5ee9826d87215f4821611643eee9b" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;debugging#ghc-flag--ddump-ticked&quot;&gt;&lt;code&gt;-ddump-ticked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-ticked&quot;&gt; &lt;code&gt;-ddump-ticked&lt;/code&gt; &lt;/a&gt; 의 별명 .</target>
        </trans-unit>
        <trans-unit id="8b292908bf0d2936fbcd16984eafba397dbc968a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="a37301a9d0fe7303c2440af029087f787465968c" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="39f245d534c3b422c9edc0bbe9598133641be7f8" translate="yes" xml:space="preserve">
          <source>An alias for modifyState for backwards compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위해 modifyState의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="99e294020522b0531d3dadc4d8bef2d2fd79bf01" translate="yes" xml:space="preserve">
          <source>An alias for putState for backwards compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위해 putState의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="709a0f933c96849749d91e33427992ea15ebf916" translate="yes" xml:space="preserve">
          <source>An allocation strategy that does not trim any of the filled buffers before converting it to a chunk</source>
          <target state="translated">채워진 버퍼를 청크로 변환하기 전에 트리밍하지 않는 할당 전략</target>
        </trans-unit>
        <trans-unit id="7cb706568d5dabeb772af56d1f92199b0a7ee949" translate="yes" xml:space="preserve">
          <source>An allocation strategy that guarantees that at least half of the allocated memory is used for live data</source>
          <target state="translated">할당 된 메모리의 절반 이상이 라이브 데이터에 사용되도록 보장하는 할당 전략</target>
        </trans-unit>
        <trans-unit id="c8a358c8e089a8a6ad543274e213736fdd805423" translate="yes" xml:space="preserve">
          <source>An alternative sort. Sorts by checking which hole fits subsume other hole fits, such that if hole fit a could be used as hole fits for hole fit b, then b appears before a in the output. It is more precise than the default sort, but also a lot slower, since a subsumption check has to be run for each pair of valid hole fits.</source>
          <target state="translated">다른 종류. 구멍 맞춤 a를 다른 구멍 맞춤으로 가정하여 정렬합니다. 예를 들어, 구멍 맞춤 a를 구멍 맞춤 b에 대한 구멍 맞춤으로 사용할 수 있으면 b가 출력에서 ​​a 앞에 나타납니다. 기본 정렬보다 더 정확하지만 각 유효한 구멍 맞춤 쌍에 대해 하위 가정 검사를 실행해야하기 때문에 속도가 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="85c8ea4d2925dfd094cde7445f68c6da3c037dbf" translate="yes" xml:space="preserve">
          <source>An ambiguous selector may be disambiguated by the type being &amp;ldquo;pushed down&amp;rdquo; to the occurrence of the selector (see &lt;a href=&quot;#higher-rank-type-inference&quot;&gt;Type inference&lt;/a&gt; for more details on what &amp;ldquo;pushed down&amp;rdquo; means). For example, the following are permitted:</source>
          <target state="translated">모호한 선택기는 선택기의 발생에 따라 &quot;푸시 다운&quot;되는 유형에 의해 명확 해 질 수 있습니다 ( &quot;푸시 다운&quot;의 의미에 대한 자세한 내용 은 &lt;a href=&quot;#higher-rank-type-inference&quot;&gt;유형 유추&lt;/a&gt; 참조 ). 예를 들어 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb9d0b854775c17b2c5aff97ccac59e5200fac6e" translate="yes" xml:space="preserve">
          <source>An amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the length of the sequence and &lt;em&gt;i&lt;/em&gt; being the integral index used by some operations. These bounds hold even in a persistent (shared) setting.</source>
          <target state="translated">각 작업에 대해 상각 된 실행 시간이 주어지며, &lt;em&gt;n&lt;/em&gt; 은 시퀀스 길이를 나타내며 &lt;em&gt;i&lt;/em&gt; 는 일부 작업에 사용되는 정수 인덱스입니다. 이 경계는 지속적 (공유) 설정에서도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce9dd94558d3a6cb7c491d6ce3c6738daadefaa" translate="yes" xml:space="preserve">
          <source>An annotation (side-metadata) attached at a particular point in a &lt;code&gt;Doc&lt;/code&gt;. Allows carrying non-pretty-printed data around in a &lt;code&gt;Doc&lt;/code&gt; that is attached at particular points in the structure. Once the &lt;code&gt;Doc&lt;/code&gt; is render to an output type (such as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;), we can also retrieve where in the rendered document our annotations start and end (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">A의 특정 지점에 부착 된 주석 (사이드 메타) &lt;code&gt;Doc&lt;/code&gt; . 구조의 특정 지점에 첨부 된 &lt;code&gt;Doc&lt;/code&gt; 에서 인쇄되지 않은 데이터를 전달할 수 있습니다. 일단 &lt;code&gt;Doc&lt;/code&gt; 출력 유형 (예에 렌더링되는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ), 우리는 또한 어디 렌더링 된 문서에 우리의 주석 시작과 끝 (참조 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="11d313098b3ec3f985281ba5d03b5e871c638cd4" translate="yes" xml:space="preserve">
          <source>An annotation (side-metadata) attached at a particular point in a &lt;code&gt;Doc&lt;/code&gt;. Allows carrying non-pretty-printed data around in a &lt;code&gt;Doc&lt;/code&gt; that is attached at particular points in the structure. Once the &lt;code&gt;Doc&lt;/code&gt; is render to an output type (such as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;), we can also retrieve where in the rendered document our annotations start and end (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Doc&lt;/code&gt; 의 특정 지점에 첨부 된 주석 (사이드 메타 데이터) 입니다. 구조의 특정 지점에 첨부 된 &lt;code&gt;Doc&lt;/code&gt; 에서 예쁘지 않은 데이터를 전달할 수 있습니다. 일단 &lt;code&gt;Doc&lt;/code&gt; 출력 유형 (예에 렌더링되는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ), 우리는 또한 어디 렌더링 된 문서에 우리의 주석 시작과 끝 (참조 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="a4a5bd4a90cc650cc053e5d8d2d60daef1c2e891" translate="yes" xml:space="preserve">
          <source>An applicative functor that collects a monoid (e.g. lists) of errors. A sequence of computations fails if any of its components do, but unlike monads made with &lt;code&gt;ExceptT&lt;/code&gt; from &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;, these computations continue after an error, collecting all the errors.</source>
          <target state="translated">단일 ID (예 : 목록)의 오류를 수집하는 적용 기능 기. 그 구성 요소 중 하나를 할 경우 계산의 순서는 실패하지만,로 만든 모나드는 달리 &lt;code&gt;ExceptT&lt;/code&gt; 에서 &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt; ,이 계산은 모든 오류를 수집, 오류가 발생한 후 계속합니다.</target>
        </trans-unit>
        <trans-unit id="bc070c7328fa5d3571a45acb079f74b2dde0b0b6" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">적용 가능한 버전의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf3d115218ff8bff3d10483bba1404c9ab4c403" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">적용 가능한 버전의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a468ebf5cf1c674abd871e054ea2dee404c992" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">적용 가능한 버전의 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="714a850af4acc6ad522e25162362c1e340e36f2e" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">적용 가능한 버전의 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e4069001a63b95ceb7dda105321002b8f3e3ba6" translate="yes" xml:space="preserve">
          <source>An arbitrary machine address assumed to point outside the garbage-collected heap.</source>
          <target state="translated">가비지 수집 힙 외부를 가리키는 것으로 간주되는 임의의 컴퓨터 주소입니다.</target>
        </trans-unit>
        <trans-unit id="8bf5023dfbbe40314a1c91c2950b274f9f5333cc" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식이며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f333085677822b91b2d6266691a5fadac493bad0" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type. The &lt;code&gt;IArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, so that instances specialised to certain element types can be defined.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식이며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다. &lt;code&gt;IArray&lt;/code&gt; 의 클래스는 모두를 통해 매개 변수화되어 및 &lt;code&gt;e&lt;/code&gt; 인스턴스가 정의 할 수있는 특정 요소 유형에 전문 그래서. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd0764a85da5b607f0944932a419f16b24701a2a" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식을 가지며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (종류 &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2b79318296e9a1df365be13462713df9a22390f7" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type. The &lt;code&gt;IArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, so that instances specialised to certain element types can be defined.</source>
          <target state="translated">배열 유형은 &lt;code&gt;(a i e)&lt;/code&gt; 형식을 가지며, 여기서 &lt;code&gt;a&lt;/code&gt; 는 배열 유형 생성자 (종류 &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ), &lt;code&gt;i&lt;/code&gt; 는 인덱스 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스의 멤버 ), &lt;code&gt;e&lt;/code&gt; 는 요소 유형입니다. &lt;code&gt;IArray&lt;/code&gt; 의 클래스는 모두를 통해 매개 변수화되어 및 &lt;code&gt;e&lt;/code&gt; 인스턴스가 정의 할 수있는 특정 요소 유형에 전문 그래서. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e15133cd1e98c4cec2d0b6095c794ad5b60cd611" translate="yes" xml:space="preserve">
          <source>An assembly-language source file, usually produced by the compiler.</source>
          <target state="translated">일반적으로 컴파일러가 생성하는 어셈블리 언어 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="e94a0acd4447829f7e16f2e0681abc5b94e72a47" translate="yes" xml:space="preserve">
          <source>An associated type or data family declaration has a CUSK precisely if its enclosing class has a CUSK.</source>
          <target state="translated">엔 클로징 클래스에 CUSK가 있으면 연관된 유형 또는 데이터 패밀리 선언에 정확하게 CUSK가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a839446e60f1231647068f143a30b2ecfe17004" translate="yes" xml:space="preserve">
          <source>An association is a pair of the form &lt;code&gt;(i,x)&lt;/code&gt;, which defines the value of the array at index &lt;code&gt;i&lt;/code&gt; to be &lt;code&gt;x&lt;/code&gt;. The array is undefined if any index in the list is out of bounds. If any two associations in the list have the same index, the value at that index is implementation-dependent. (In GHC, the last value specified for that index is used. Other implementations will also do this for unboxed arrays, but Haskell 98 requires that for &lt;code&gt;Array&lt;/code&gt; the value at such indices is bottom.)</source>
          <target state="translated">연관 폼의 한 쌍 &lt;code&gt;(i,x)&lt;/code&gt; 인덱스 어레이 값을 정의, &lt;code&gt;i&lt;/code&gt; 될 &lt;code&gt;x&lt;/code&gt; . 목록의 인덱스가 범위를 벗어나면 배열이 정의되지 않습니다. 목록의 두 연관이 동일한 색인을 갖는 경우 해당 색인의 값은 구현에 따라 다릅니다. GHC에서는 해당 인덱스에 대해 지정된 마지막 값이 사용됩니다. 다른 구현에서도 언 박스형 배열에 대해서도이 작업을 수행하지만 Haskell 98에서는 &lt;code&gt;Array&lt;/code&gt; 에 대해 해당 인덱스의 값이 맨 아래에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3afb607a33ed15aef025831322f63f1a04d9a09d" translate="yes" xml:space="preserve">
          <source>An associative binary operation</source>
          <target state="translated">연관 이진 연산</target>
        </trans-unit>
        <trans-unit id="1147ac2d130bd449477786144a5c8a1b76f89092" translate="yes" xml:space="preserve">
          <source>An associative operation</source>
          <target state="translated">연관 연산</target>
        </trans-unit>
        <trans-unit id="8ce47487694776c0a4231b6d5c5f44ab8e16a07a" translate="yes" xml:space="preserve">
          <source>An associative operation with identity &lt;code&gt;&lt;a href=&quot;control-arrow#v:zeroArrow&quot;&gt;zeroArrow&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ID가 &lt;code&gt;&lt;a href=&quot;control-arrow#v:zeroArrow&quot;&gt;zeroArrow&lt;/a&gt;&lt;/code&gt; 인 연관 연산 .</target>
        </trans-unit>
        <trans-unit id="8f702f0949aff10d3524aea50e9531b4e09362c3" translate="yes" xml:space="preserve">
          <source>An associative operation.</source>
          <target state="translated">연관 연산.</target>
        </trans-unit>
        <trans-unit id="d3660f5f8cdd17a078c28b99ce21ad421e42c7b8" translate="yes" xml:space="preserve">
          <source>An associative operation. The default definition is</source>
          <target state="translated">연관 연산. 기본 정의는</target>
        </trans-unit>
        <trans-unit id="e8163d537de96930d1551a2bbdc32c863286eb63" translate="yes" xml:space="preserve">
          <source>An attempt was made to evaluate an element of an array that had not been initialized.</source>
          <target state="translated">초기화되지 않은 배열의 요소를 평가하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="578f42dbdd127ca4fccb4e419110bd0c78e68ac1" translate="yes" xml:space="preserve">
          <source>An attempt was made to index an array outside its declared bounds.</source>
          <target state="translated">선언 된 범위를 벗어난 배열을 색인하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="424d796a4ce39c6e1c11527f6f9821335c409254" translate="yes" xml:space="preserve">
          <source>An easy extension is to allow arbitrary contexts before the constructor. For example:</source>
          <target state="translated">쉬운 확장은 생성자 앞에 임의의 컨텍스트를 허용하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa4b3e7e1ba4fecc1be2a9b715baa31cf5742128" translate="yes" xml:space="preserve">
          <source>An edge from the first vertex to the second.</source>
          <target state="translated">첫 번째 정점에서 두 번째 정점까지의 가장자리입니다.</target>
        </trans-unit>
        <trans-unit id="4dfc37a5d88a5cef62918450d61f82ec135f66a3" translate="yes" xml:space="preserve">
          <source>An efficient deserialiser of &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 효율적인 디시리얼라이저 .</target>
        </trans-unit>
        <trans-unit id="9abf3b4b588f08354857f088c37e909380ccb8c8" translate="yes" xml:space="preserve">
          <source>An efficient get method for lazy ByteStrings. Fails if fewer than &lt;code&gt;n&lt;/code&gt; bytes are left in the input.</source>
          <target state="translated">게으른 ByteString에 대한 효율적인 get 메소드입니다. 입력에 &lt;code&gt;n&lt;/code&gt; 바이트 미만 이 남아 있으면 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="779d338d8d1396567da301a0915991a8253fcb3d" translate="yes" xml:space="preserve">
          <source>An efficient get method for strict ByteStrings. Fails if fewer than &lt;code&gt;n&lt;/code&gt; bytes are left in the input. If &lt;code&gt;n &amp;lt;= 0&lt;/code&gt; then the empty string is returned.</source>
          <target state="translated">엄격한 ByteString에 대한 효율적인 get 메소드입니다. 입력에 &lt;code&gt;n&lt;/code&gt; 바이트 미만 이 남아 있으면 실패합니다 . 경우 &lt;code&gt;n &amp;lt;= 0&lt;/code&gt; 다음 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64a0398b712134b5c921639d4662413422147955" translate="yes" xml:space="preserve">
          <source>An efficient implementation of integer sets.</source>
          <target state="translated">정수 세트의 효율적인 구현</target>
        </trans-unit>
        <trans-unit id="ed7ff4240488108e796dda83b8f8a885a21e7f97" translate="yes" xml:space="preserve">
          <source>An efficient implementation of maps from integer keys to values (dictionaries).</source>
          <target state="translated">정수 키에서 값 (사전)으로의 효율적인 매핑 구현</target>
        </trans-unit>
        <trans-unit id="300c10f93efb7d8e708d1538e08d8d7e538b4d21" translate="yes" xml:space="preserve">
          <source>An efficient implementation of ordered maps from keys to values (dictionaries).</source>
          <target state="translated">키에서 값 (사전)으로 순서화 된 맵을 효율적으로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9c17d2bea255ffe0974a30b48457084e4d307e5f" translate="yes" xml:space="preserve">
          <source>An efficient primitive to write a strict ByteString into the output buffer. It flushes the current buffer, and writes the argument into a new chunk.</source>
          <target state="translated">엄격한 ByteString을 출력 버퍼에 쓰는 효율적인 프리미티브. 현재 버퍼를 플러시하고 새로운 청크에 인수를 씁니다.</target>
        </trans-unit>
        <trans-unit id="409ad01192a6191df9780f4e796153ec80522cce" translate="yes" xml:space="preserve">
          <source>An efficient serialiser of &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 효율적인 시리얼 라이저 .</target>
        </trans-unit>
        <trans-unit id="e6015ce2daa6533d6818de8c86f4d41b485e9542" translate="yes" xml:space="preserve">
          <source>An empty document</source>
          <target state="translated">빈 문서</target>
        </trans-unit>
        <trans-unit id="ce3be77c03c4e3699f0fd72a41b3ed4e3a5f892e" translate="yes" xml:space="preserve">
          <source>An empty graph.</source>
          <target state="translated">빈 그래프.</target>
        </trans-unit>
        <trans-unit id="60a7cfffba592bf3fc0701b5fe4cb99cba424d1c" translate="yes" xml:space="preserve">
          <source>An empty immutable array.</source>
          <target state="translated">비어있는 불변 배열.</target>
        </trans-unit>
        <trans-unit id="110c4ac770ed6cac3b6a8ac6f3769b9a42dfce56" translate="yes" xml:space="preserve">
          <source>An empty piece of HTML.</source>
          <target state="translated">빈 HTML 조각.</target>
        </trans-unit>
        <trans-unit id="863735067735f8b0df4ec524f2091a6814c632b6" translate="yes" xml:space="preserve">
          <source>An encoding in which Unicode code points are translated to bytes by taking the code point modulo 256. When decoding, bytes are translated directly into the equivalent code point.</source>
          <target state="translated">코드 포인트 모듈로 256을 취함으로써 유니 코드 코드 포인트가 바이트로 변환되는 인코딩. 디코딩시 바이트는 동등한 코드 포인트로 직접 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="379731e74a8a7303ee4ec5e7849e8a388a898a4e" translate="yes" xml:space="preserve">
          <source>An equivalent form for that example, avoiding explicit &lt;code&gt;forall&lt;/code&gt; uses &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;:</source>
          <target state="translated">그 예를 들어 동등한 형태는 명시 적으로 피하는 &lt;code&gt;forall&lt;/code&gt; 사용 &lt;a href=&quot;#pattern-type-sigs&quot;&gt;패턴 유형 서명&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2317b7500211efb11dba6702f8ff358cab78a9f0" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재 하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류 .</target>
        </trans-unit>
        <trans-unit id="9c5c1ab24132ff1db5fc41f514c9dd3d02f6830b" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 존재하지 않아 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류 .</target>
        </trans-unit>
        <trans-unit id="a44dec7bdac91aad0789fdf13b8614448d0c3e1b" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작업이 불가능 하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 결과 를 반환하는 계산 은 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패 할 수 있습니다 . 경우에 따라 구현시 가능한 오류 원인을 구별하지 못할 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f839fc9cbc9a7a46f4c3ef068799b74f941ae12" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 충분한 운영 체제 권한이 없기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="353bc4608932aa64def2cb47401212891190e861" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재하기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="afac72a08e880e338eb3054c3cc4cb3b2c8d874a" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 없기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="fa08b0c059f66a3dd7b2f5959546d1e6588e7a9f" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작업이 불가능 하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 결과 를 반환하는 계산 은 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패 할 수 있습니다 . 경우에 따라 구현시 가능한 오류 원인을 구분할 수 없습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 으로 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fdd36f108f41c6140824253d332a12f73fc5123" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 수있는 운영 체제 권한이 없기 때문에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="e66b1c80ba834855aae9f9d43d3592e67e98a671" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재 하여 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류 .</target>
        </trans-unit>
        <trans-unit id="84e040a37ce664544af44aa14d72c1c5b1f5fdf7" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 존재하지 않아 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류 .</target>
        </trans-unit>
        <trans-unit id="3aaf153bc2f4b4a705a6640c9e8a13f49833a532" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments is a single-use resource, which is already being used (for example, opening the same file twice for writing might give this error).</source>
          <target state="translated">인수 중 하나가 이미 사용중인 단일 자원이므로 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조작이 실패했음을 나타내는 오류입니다 (예 : 동일한 파일을 두 번 열어 쓰기 위해이 오류가 발생할 수 있음).</target>
        </trans-unit>
        <trans-unit id="fbdf1497d8ba0761ae0294d7cba12faf35e238d8" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the device is full.</source>
          <target state="translated">장치가 가득 차서 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="587d82956d47a090dc9d6a33c66777d643e7e317" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the end of file has been reached.</source>
          <target state="translated">파일 끝에 도달 하여 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="0cfca5871ab77adff3cb578bb0516ceb582413e3" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">작업이 불가능 하여 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다. &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 결과 를 반환하는 계산 은 &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패 할 수 있습니다 . 경우에 따라 구현시 가능한 오류 원인을 구별하지 못할 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 과 함께 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f1a557e45ff222ff19723cc3b00907ab8191320" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 충분한 운영 체제 권한이 없기 때문에 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 실패했음을 나타내는 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="cb8588ea4ffd2451e25b457e42e986ce533b40b9" translate="yes" xml:space="preserve">
          <source>An example from &lt;em&gt;The Craft of Functional Programming&lt;/em&gt;, Simon Thompson (&lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/sjt/&quot;&gt;http://www.cs.kent.ac.uk/people/staff/sjt/&lt;/a&gt;), Addison-Wesley 1999: &quot;Given an arbitrary tree, transform it to a tree of integers in which the original elements are replaced by natural numbers, starting from 0. The same element has to be replaced by the same number at every occurrence, and when we meet an as-yet-unvisited element we have to find a 'new' number to match it with:&quot;</source>
          <target state="translated">에서 예 &lt;em&gt;기능 프로그래밍의 공예&lt;/em&gt; , 사이먼 톰슨 ( &lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/sjt/&quot;&gt;http://www.cs.kent.ac.uk/people/staff/sjt/&lt;/a&gt; ), 애디슨 - 웨슬리 1999 : &quot;나무로 변환, 임의의 나무를 감안할 때 0부터 시작하여 원래 요소가 자연수로 대체되는 정수의 숫자입니다. 동일한 요소는 모든 경우에 같은 숫자로 대체되어야합니다. 아직 미공개 요소를 만나면 '새로운 요소'를 찾아야합니다. '와 일치하는 번호 : &quot;</target>
        </trans-unit>
        <trans-unit id="26553b69de76ef603493e22f9b56e8e8f0e7cc55" translate="yes" xml:space="preserve">
          <source>An example in which using &lt;code&gt;RULES&lt;/code&gt; for specialisation will Win Big:</source>
          <target state="translated">전문화에 &lt;code&gt;RULES&lt;/code&gt; 를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d94ee3fed69a3a2d6cbb28624b1e2c3a6d9674bc" translate="yes" xml:space="preserve">
          <source>An example is shown in the opening example, where &lt;code&gt;sortWith&lt;/code&gt; is supplied with a function that lets it find out the &lt;code&gt;sum salary&lt;/code&gt; for any item in the list comprehension it transforms.</source>
          <target state="translated">예는 시작 예제에 표시되며, &lt;code&gt;sortWith&lt;/code&gt; 에는 변환하는 목록 이해에서 모든 항목에 대한 &lt;code&gt;sum salary&lt;/code&gt; 찾을 수있는 함수가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="92f996a82b303141412a037410a747eab994f16e" translate="yes" xml:space="preserve">
          <source>An example of a pre-processor is to convert your source files to the input encoding that GHC expects, i.e. create a script &lt;code&gt;convert.sh&lt;/code&gt; containing the lines:</source>
          <target state="translated">전 처리기의 예는 소스 파일을 GHC가 기대하는 입력 인코딩으로 변환하는 것입니다. 예를 들어 다음 줄을 포함하는 &lt;code&gt;convert.sh&lt;/code&gt; 스크립트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="46db75079dc947994d3c8f73c95f7d8d5b14f912" translate="yes" xml:space="preserve">
          <source>An example of a suitable Euclidean function, for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;'s instance, is &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 의 경우에 적합한 유클리드 함수 의 예는 &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c01fc02e927a60926df24dbe6dfbd1b4746279b" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 예는 길이에 따라 문자열 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="bd7ad3a60a7ec7010ecf8274734b34b569a3aa76" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 예는 길이에 따라 문자열 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fd78ec4b25edfc34c070db47b86faa55268ea5fe" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 예는 길이에 따라 문자열 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2aef6af3f5288d7dec723009106ae656cb18d0ec" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 예는 길이에 따라 문자열 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="37825ef9057435b5d70e42055abe88a2f5caa9ef" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;Adder.dll&lt;/code&gt; from C++ is:</source>
          <target state="translated">C ++에서 &lt;code&gt;Adder.dll&lt;/code&gt; 을 사용하는 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="284aba923f06dcb4f47c7f3c609dae9afb54f97b" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;Adder.dll&lt;/code&gt; from VBA is:</source>
          <target state="translated">VBA에서 &lt;code&gt;Adder.dll&lt;/code&gt; 을 사용하는 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a2f6a683146590a81cb59662a6f31a14e0007fe" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;lookup&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;lookup&lt;/code&gt; 사용의 예 :</target>
        </trans-unit>
        <trans-unit id="62a7372438651bafa2669d1145fa021654f7a3ee" translate="yes" xml:space="preserve">
          <source>An example use of this library for a simple read-eval-print loop (REPL) is the following:</source>
          <target state="translated">간단한 REPL (read-eval-print loop)에이 라이브러리를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57f1733124f33be242778620a4eb6cdc6409382d" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 모나드 와 함께 &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; 를 사용하는 예제 :</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="a213b0b1515044c4c78bd78637c0113c5cd8be80" translate="yes" xml:space="preserve">
          <source>An exception to be thrown.</source>
          <target state="translated">예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="fdf570a64c3420a5e9dc66825959db440f96c3c1" translate="yes" xml:space="preserve">
          <source>An exception type for representing Unicode encoding errors.</source>
          <target state="translated">유니 코드 인코딩 오류를 나타내는 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="efb9885da89ae0153ca6bd437d81d85bcf6d2a5e" translate="yes" xml:space="preserve">
          <source>An exception-safe wrapper for modifying the contents of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; will replace the original contents of the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if an exception is raised during the operation. This function is only atomic if there are no other producers for this &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 수정하기위한 예외 안전 래퍼입니다 . 마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; 이 의 원래 내용 대체 할 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 예외가 작동 중에 발생합니다. 이 함수는이 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 다른 생산자가없는 경우에만 원자 적 입니다.</target>
        </trans-unit>
        <trans-unit id="f7bad0722f6e1639c9b8bf58917fbc9a749282ca" translate="yes" xml:space="preserve">
          <source>An experimental flag to expose all unfoldings, even for very large or recursive functions. This allows for all functions to be inlined while usually GHC would avoid inlining larger functions.</source>
          <target state="translated">매우 크거나 재귀적인 함수에서도 모든 전개를 표시하는 실험용 플래그입니다. 이를 통해 모든 함수를 인라인 할 수 있지만 일반적으로 GHC는 더 큰 함수를 인라인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcc169bba3c04120ce581359b5205c6e6861fa64" translate="yes" xml:space="preserve">
          <source>An expression</source>
          <target state="translated">표현</target>
        </trans-unit>
        <trans-unit id="5b3e9db1ce65c03995d328bea346bec14a73a082" translate="yes" xml:space="preserve">
          <source>An expression that didn't typecheck during compile time was called. This is only possible with -fdefer-type-errors. The &lt;code&gt;String&lt;/code&gt; gives details about the failed type check.</source>
          <target state="translated">컴파일 시간 동안 타입 검사를하지 않은 표현식이 호출되었습니다. 이것은 -fdefer-type-errors에서만 가능합니다. &lt;code&gt;String&lt;/code&gt; 실패한 유형 검사에 대한 세부 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="23d6c8ea4520ef478bc2079b23a73769921d85ca" translate="yes" xml:space="preserve">
          <source>An expression type signature (&lt;a href=&quot;#exp-type-sigs&quot;&gt;Expression type signatures&lt;/a&gt;)</source>
          <target state="translated">표현식 유형 서명 ( &lt;a href=&quot;#exp-type-sigs&quot;&gt;표현식 유형 서명&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="befd82a9275f38fcab59cee9b3a9893ec9498cda" translate="yes" xml:space="preserve">
          <source>An expression type signature that has &lt;em&gt;explicit&lt;/em&gt; quantification (using &lt;code&gt;forall&lt;/code&gt;) brings into scope the explicitly-quantified type variables, in the annotated expression. For example:</source>
          <target state="translated">&lt;em&gt;명시 적&lt;/em&gt; 정량화 ( &lt;code&gt;forall&lt;/code&gt; 사용 ) 가있는 표현식 유형 시그니처 는 어노테이션이있는 표현식에서 명시 적으로 정량화 된 유형 변수의 범위를 가져옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b82cc29cb694eff0d6c543cfd3b0fa40875fc57b" translate="yes" xml:space="preserve">
          <source>An extended Haskell interface file, produced by the Haskell compiler.</source>
          <target state="translated">Haskell 컴파일러에 의해 생성 된 확장 된 Haskell 인터페이스 파일.</target>
        </trans-unit>
        <trans-unit id="06078bbc223f3f2c54001e817424da6925e7e456" translate="yes" xml:space="preserve">
          <source>An extra flag to pass to the C compiler.</source>
          <target state="translated">C 컴파일러에 전달할 추가 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="4ada7ba8223269b5dc2b7e6f71e6be14db026a01" translate="yes" xml:space="preserve">
          <source>An extra flag to pass to the linker.</source>
          <target state="translated">링커에 전달할 추가 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="ff063cb1c991404edd003923980f0718291bfcf8" translate="yes" xml:space="preserve">
          <source>An extra-constraints wildcard can also lead to zero extra constraints to be inferred, e.g.</source>
          <target state="translated">추가 제약 조건 와일드 카드를 사용하면 추론 할 제약이 전혀 없습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8737dcbc364a0104937da45530e573d364b0ae37" translate="yes" xml:space="preserve">
          <source>An extra-constraints wildcard shouldn&amp;rsquo;t prevent the programmer from already listing the constraints he knows or wants to annotate, e.g.</source>
          <target state="translated">제약 조건이있는 와일드 카드는 프로그래머가 자신이 알고 있거나 주석을 달고 싶은 제약 조건을 이미 나열하지 못하게해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d29ed66c17bed0542d86b370f6bc6043d2a378e4" translate="yes" xml:space="preserve">
          <source>An extremely light-weight, fast, and limited representation of a string of up to (2*WORDSIZE - 2) bits. In fact, there are two representations, misleadingly named bit queue builder and bit queue. The builder supports only &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:emptyQB&quot;&gt;emptyQB&lt;/a&gt;&lt;/code&gt;, creating an empty builder, and &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:snocQB&quot;&gt;snocQB&lt;/a&gt;&lt;/code&gt;, enqueueing a bit. The bit queue builder is then turned into a bit queue using &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:buildQ&quot;&gt;buildQ&lt;/a&gt;&lt;/code&gt;, after which bits can be removed one by one using &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:unconsQ&quot;&gt;unconsQ&lt;/a&gt;&lt;/code&gt;. If the size limit is exceeded, further operations will silently produce nonsense.</source>
          <target state="translated">최대 (2 * WORDSIZE-2) 비트의 문자열을 매우 가볍고 빠르며 제한적으로 표현합니다. 실제로 비트 큐 빌더와 비트 큐라는 두 가지 표현이 있습니다. 빌더는 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:emptyQB&quot;&gt;emptyQB&lt;/a&gt;&lt;/code&gt; 만 지원 하고 빈 빌더는 작성하고 snocQB는 비트를 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:snocQB&quot;&gt;snocQB&lt;/a&gt;&lt;/code&gt; 에 넣습니다. 비트 큐 빌더는 사용 비트 큐로 온 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:buildQ&quot;&gt;buildQ&lt;/a&gt;&lt;/code&gt; 를 비트하여 하나씩 제거 할 수있는 후 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:unconsQ&quot;&gt;unconsQ&lt;/a&gt;&lt;/code&gt; 를 . 크기 제한을 초과하면 추가 작업이 자동으로 넌센스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4a1b2653a1c9d958510f1ed844f74e8ecb8d1c49" translate="yes" xml:space="preserve">
          <source>An idiom that is common in some languages is to find the numeric offset of a character or substring, then use that number to split or trim the searched string. With a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value, this approach would require two O(n) operations: one to perform the search, and one to operate from wherever the search ended.</source>
          <target state="translated">일부 언어에서 일반적으로 사용되는 관용구는 문자 또는 하위 문자열의 숫자 오프셋을 찾은 다음 해당 숫자를 사용하여 검색된 문자열을 분할하거나 자릅니다. &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 사용하면 이 방법에는 두 가지 O (n) 작업이 필요합니다. 하나는 검색을 수행하고 다른 하나는 검색이 끝난 곳에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="67c017344c03d68395eeb6821615e8a8bfe1033a" translate="yes" xml:space="preserve">
          <source>An idle-time garbage collection has been started.</source>
          <target state="translated">유휴 시간 가비지 콜렉션이 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d426bd25abbccce84e0bdf47cb062c833bbb269" translate="yes" xml:space="preserve">
          <source>An illustrative example for these strictness properties is the implementation of Base64 decoding (&lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;http://en.wikipedia.org/wiki/Base64&lt;/a&gt;).</source>
          <target state="translated">이러한 엄격 성 속성의 예는 Base64 디코딩 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;http://en.wikipedia.org/wiki/Base64&lt;/a&gt; ) 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="d20888eadb4852094fcef2f3603d26df3e4539de" translate="yes" xml:space="preserve">
          <source>An implementation is entitled to assume the following laws about these operations:</source>
          <target state="translated">구현시 이러한 작업에 대해 다음 법률을 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dd9779568fb3b84f00870e9c9dc5e99b34e41c6" translate="yes" xml:space="preserve">
          <source>An implementation is free to flush the buffer more frequently, but not less frequently, than specified above. The output buffer is emptied as soon as it has been written out.</source>
          <target state="translated">구현은 위에서 지정한 것보다 더 자주 버퍼를 플러시 할 수 있습니다. 출력 버퍼는 기록 되 자마자 비워집니다.</target>
        </trans-unit>
        <trans-unit id="764ec8855ef58c6a8f42aecb228f30ad41274dec" translate="yes" xml:space="preserve">
          <source>An implementation of the old &lt;code&gt;atomicModifyMutVar#&lt;/code&gt; primop in terms of the new &lt;code&gt;&lt;a href=&quot;ghc-exts#v:atomicModifyMutVar2-35-&quot;&gt;atomicModifyMutVar2#&lt;/a&gt;&lt;/code&gt; primop, for backwards compatibility. The type of this function is a bit bogus. It's best to think of it as having type</source>
          <target state="translated">이전 버전과의 호환성을 위해 새로운 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:atomicModifyMutVar2-35-&quot;&gt;atomicModifyMutVar2#&lt;/a&gt;&lt;/code&gt; primop과 관련 하여 이전 &lt;code&gt;atomicModifyMutVar#&lt;/code&gt; primop 구현 . 이 함수의 유형은 약간 가짜입니다. 유형을 갖는 것으로 생각하는 것이 가장 좋습니다</target>
        </trans-unit>
        <trans-unit id="055bfb77bc4911c1d902e9c7e877458502ecd8a2" translate="yes" xml:space="preserve">
          <source>An implicit parameter is &lt;em&gt;bound&lt;/em&gt; using the standard &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; binding forms. For example, we define the &lt;code&gt;min&lt;/code&gt; function by binding &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">암시 적 매개 변수는 표준 &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;where&lt;/code&gt; 바인딩 양식을 사용하여 &lt;em&gt;바인드&lt;/em&gt; 됩니다 . 예를 들어 &lt;code&gt;cmp&lt;/code&gt; 를 바인딩 하여 &lt;code&gt;min&lt;/code&gt; 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="83f900390293c670e8a8d65bb9afeb5cc8fcf2b6" translate="yes" xml:space="preserve">
          <source>An implicit parameter occurs in an expression using the special form &lt;code&gt;?x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is any valid identifier (e.g. &lt;code&gt;ord ?x&lt;/code&gt; is a valid expression). Use of this construct also introduces a new dynamic-binding constraint in the type of the expression. For example, the following definition shows how we can define an implicitly parameterised sort function in terms of an explicitly parameterised &lt;code&gt;sortBy&lt;/code&gt; function:</source>
          <target state="translated">암시 적 매개 변수는 특수 형식 &lt;code&gt;?x&lt;/code&gt; 사용하는 표현식에서 발생합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 유효한 식별자입니다 (예 : &lt;code&gt;ord ?x&lt;/code&gt; 는 유효한 표현식). 이 구문을 사용하면 표현식 유형에 새로운 동적 바인딩 제약 조건이 도입됩니다. 예를 들어, 다음 정의는 명시 적으로 매개 변수화 된 &lt;code&gt;sortBy&lt;/code&gt; 함수 와 관련하여 내재적으로 매개 변수화 된 정렬 함수를 정의하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="2e728fe00beb5b98842848d858c512e28ed428db" translate="yes" xml:space="preserve">
          <source>An implicit-parameter binding group must be a collection of simple bindings to implicit-style variables (no function-style bindings, and no type signatures); these bindings are neither polymorphic or recursive.</source>
          <target state="translated">내재적 매개 변수 바인딩 그룹은 내재적 스타일 변수 (함수 스타일 바인딩 및 유형 서명 없음)에 대한 단순 바인딩 콜렉션이어야합니다. 이들 결합은 다형성 또는 재귀 적이 지 않다.</target>
        </trans-unit>
        <trans-unit id="055d0a98d0fca1648c6546c9fc6ca5cb2c9b9157" translate="yes" xml:space="preserve">
          <source>An implicit-parameter type constraint differs from other type class constraints in the following way: All uses of a particular implicit parameter must have the same type. This means that the type of &lt;code&gt;(?x, ?x)&lt;/code&gt; is &lt;code&gt;(?x::a) =&amp;gt; (a,a)&lt;/code&gt;, and not &lt;code&gt;(?x::a, ?x::b) =&amp;gt; (a, b)&lt;/code&gt;, as would be the case for type class constraints.</source>
          <target state="translated">내재적 매개 변수 유형 제한 조건은 다음 방식에서 다른 유형 클래스 제한 조건과 다릅니다. 특정 내재적 매개 변수의 모든 사용은 동일한 유형을 가져야합니다. 이는 &lt;code&gt;(?x::a) =&amp;gt; (a,a)&lt;/code&gt; &lt;code&gt;(?x, ?x)&lt;/code&gt; 의 유형 이 (? x :: a &lt;code&gt;(?x::a, ?x::b) =&amp;gt; (a, b)&lt;/code&gt; 아닌 (? x :: a) =&amp;gt; (a, a)입니다. ) , 유형 클래스 제약 조건의 경우와 같습니다.</target>
        </trans-unit>
        <trans-unit id="41e571a04d49adc778f99f9915a653a4d8383f97" translate="yes" xml:space="preserve">
          <source>An infix synonym for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 접두사 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="676b0466c764d24182ade55c20826949e1613615" translate="yes" xml:space="preserve">
          <source>An infix synonym for &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 접두사 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="45e7ca78829cc48699173c5bd84e19553844a4fb" translate="yes" xml:space="preserve">
          <source>An initial environment.</source>
          <target state="translated">초기 환경.</target>
        </trans-unit>
        <trans-unit id="032f25891e62fb8921b2ffd173fccd585c489d81" translate="yes" xml:space="preserve">
          <source>An installed package is either &lt;em&gt;exposed&lt;/em&gt; or &lt;em&gt;hidden&lt;/em&gt; by default. Packages hidden by default are listed in parentheses (e.g. &lt;code&gt;(lang-1.0)&lt;/code&gt;), or possibly in blue if your terminal supports colour, in the output of &lt;code&gt;ghc-pkg list&lt;/code&gt;. Command-line flags, described below, allow you to expose a hidden package or hide an exposed one. Only modules from exposed packages may be imported by your Haskell code; if you try to import a module from a hidden package, GHC will emit an error message. It should be noted that a hidden package might still get linked with your program as a dependency of an exposed package, it is only restricted from direct imports.</source>
          <target state="translated">설치된 패키지는 기본적으로 &lt;em&gt;노출&lt;/em&gt; 되거나 &lt;em&gt;숨겨집니다&lt;/em&gt; . 기본적으로 숨겨진 패키지 는 &lt;code&gt;ghc-pkg list&lt;/code&gt; 출력 에서 괄호 (예 : &lt;code&gt;(lang-1.0)&lt;/code&gt; ) 또는 터미널이 색상을 지원하는 경우 파란색으로 표시 됩니다. 아래 설명 된 명령 줄 플래그를 사용하면 숨겨진 패키지를 노출하거나 노출 된 패키지를 숨길 수 있습니다. 노출 된 패키지의 모듈 만 Haskell 코드로 가져올 수 있습니다. 숨겨진 패키지에서 모듈을 가져 오려고하면 GHC에서 오류 메시지가 표시됩니다. 숨겨진 패키지는 노출 된 패키지의 종속성으로 여전히 프로그램과 연결될 수 있으며 직접 가져 오기에서만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6e9e64155c356c6955cab41597813ffebcaa65a5" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 유형에 따라 this 및 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; 또는 통합 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d84b0a9b1da15cdbb5efba9440685e88ebcccf36" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 것에 따라 this와 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; 또는 unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="771255935064afcdb9c5d67ea14ceedd0c402b64" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 방법에 따라 this 및 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; 또는 통합 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c91e8ae7413d71da86962a384a3de3aff328dd8d" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 유형에 따라 this 및 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; 또는 통합 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9505be87e1ced40bfc25bab37f391a9491bdd4ef" translate="yes" xml:space="preserve">
          <source>An instance can define either this unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 것에 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; 통합 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 또는 rotateL 과 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f6f1ff04bfa289ae107fe2cb73d2dc665d5edae" translate="yes" xml:space="preserve">
          <source>An instance can define either this unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">인스턴스는 해당 유형에 더 편리한 것에 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; 통합 된 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 또는 shiftL 과 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b91c1218cc10bd9b2d241b41fc654dedb75905ac" translate="yes" xml:space="preserve">
          <source>An instance declaration has the form</source>
          <target state="translated">인스턴스 선언의 형식은</target>
        </trans-unit>
        <trans-unit id="0422a1c1ceadfc36e077b4145e342be0d4fe9752" translate="yes" xml:space="preserve">
          <source>An instance declaration in a module &lt;code&gt;M&lt;/code&gt; is an &lt;em&gt;orphan instance&lt;/em&gt; if orphan instance</source>
          <target state="translated">모듈 &lt;code&gt;M&lt;/code&gt; 의 인스턴스 선언 은 &lt;em&gt;고아 인스턴스 인&lt;/em&gt; 경우 고아 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="f659879efb627bdd5cecbbab282a1e9e47a6cd51" translate="yes" xml:space="preserve">
          <source>An instance declaration is &lt;em&gt;more specific&lt;/em&gt; than another iff the head of former is a substitution instance of the latter. For example (D) is &amp;ldquo;more specific&amp;rdquo; than (C) because you can get from (C) to (D) by substituting &lt;code&gt;a := Int&lt;/code&gt;.</source>
          <target state="translated">인스턴스 선언은 전자의 헤드가 후자의 대체 인스턴스 인 경우 다른 것보다 &lt;em&gt;더 구체적&lt;/em&gt; 입니다. 예를 들어 &lt;code&gt;a := Int&lt;/code&gt; 대체 하여 (C)에서 (D)로 갈 수 있기 때문에 (D)는 (C)보다&amp;ldquo;더 구체적&amp;rdquo; 입니다.</target>
        </trans-unit>
        <trans-unit id="a925b49f0219e891d285365b66dce29fa02d0e7e" translate="yes" xml:space="preserve">
          <source>An instance for an associated family can only appear as part of an instance declarations of the class in which the family was declared, just as with the equations of the methods of a class.</source>
          <target state="translated">연관된 패밀리의 인스턴스는 클래스의 메소드 방정식과 마찬가지로 패밀리가 선언 된 클래스의 인스턴스 선언의 일부로 만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6797a394b5a38cb77951470781b2ae0ce53d676c" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;incoherent&lt;/em&gt; if: it has an &lt;code&gt;INCOHERENT&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음과 같은 경우 인스턴스가 &lt;em&gt;일관성이&lt;/em&gt; 없습니다. &lt;code&gt;INCOHERENT&lt;/code&gt; pragma가 있습니다. 또는 인스턴스에 pragma가없고 &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈에 나타나는 경우 .</target>
        </trans-unit>
        <trans-unit id="0b66884ab42d5d8b014e6fc23b4324da15721d24" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;overlappable&lt;/em&gt; if: it has an &lt;code&gt;OVERLAPPABLE&lt;/code&gt; or &lt;code&gt;OVERLAPS&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt;; or if the instance is incoherent.</source>
          <target state="translated">&lt;code&gt;OVERLAPPABLE&lt;/code&gt; 또는 &lt;code&gt;OVERLAPS&lt;/code&gt; pragma 가있는 인스턴스는 &lt;em&gt;겹칠&lt;/em&gt; 수 있습니다 . 또는 인스턴스에 pragma가없고 &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈에 나타나는 경우 ; 또는 인스턴스가 일관성이없는 경우.</target>
        </trans-unit>
        <trans-unit id="c64945d958795bcda270b74e76ecf8e08588cfbe" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;overlapping&lt;/em&gt; if: it has an &lt;code&gt;OVERLAPPING&lt;/code&gt; or &lt;code&gt;OVERLAPS&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt;; or if the instance is incoherent.</source>
          <target state="translated">다음과 같은 경우 인스턴스가 &lt;em&gt;겹칩니다&lt;/em&gt; . &lt;code&gt;OVERLAPPING&lt;/code&gt; 또는 &lt;code&gt;OVERLAPS&lt;/code&gt; pragma가 있습니다. 또는 인스턴스에 pragma가없고 &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈에 나타나는 경우 ; 또는 인스턴스가 일관성이없는 경우.</target>
        </trans-unit>
        <trans-unit id="da552798a9dccf85004f0b6505ae33c512663e04" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; is provided, which implements exact equality modulo reordering of the tags in the &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; 필드 에서 태그의 정확한 동등한 모듈로 재정렬을 구현하는 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 의 인스턴스 가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="41664f4a7f5f1d180ac492e6274bf660ab0d02d1" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is also provided, which gives lexicographic ordering on the &lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt; fields (i.e. 2.1 &amp;gt; 2.0, 1.2.3 &amp;gt; 1.2.2, etc.). This is expected to be sufficient for many uses, but note that you may need to use a more specific ordering for your versioning scheme. For example, some versioning schemes may include pre-releases which have tags &lt;code&gt;&quot;pre1&quot;&lt;/code&gt;, &lt;code&gt;&quot;pre2&quot;&lt;/code&gt;, and so on, and these would need to be taken into account when determining ordering. In some cases, date ordering may be more appropriate, so the application would have to look for &lt;code&gt;date&lt;/code&gt; tags in the &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; field and compare those. The bottom line is, don't always assume that &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; and other &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; operations are the right thing for every &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt; 필드 (예 : 2.1&amp;gt; 2.0, 1.2.3&amp;gt; 1.2.2 등) 에서 사전 순서를 제공하는 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 도 제공됩니다 . 이것은 많은 용도에 충분할 것으로 예상되지만 버전 관리 체계에 대해보다 구체적인 순서를 사용해야 할 수도 있습니다. 예를 들어, 일부 버전 관리 체계에는 &lt;code&gt;&quot;pre1&quot;&lt;/code&gt; , &lt;code&gt;&quot;pre2&quot;&lt;/code&gt; 등의 태그가있는 시험판이 포함될 수 있으며 순서를 결정할 때이를 고려해야합니다. 경우에 따라 날짜 순서가 더 적절할 수 있으므로 응용 프로그램은 &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; 필드 에서 &lt;code&gt;date&lt;/code&gt; 태그를 찾아서 비교해야합니다. 결론은, 항상 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 한다고 가정하지 마십시오다른 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 작업은 모든 &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; 적합한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fdfa656ab79a71bc26c499aa546810046ca396ff" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:MonadException&quot;&gt;MonadException&lt;/a&gt;&lt;/code&gt; is generally made up of monad transformers layered on top of the IO monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:MonadException&quot;&gt;MonadException&lt;/a&gt;&lt;/code&gt; 의 인스턴스 는 일반적으로 IO 모나드 위에 계층화 된 모나드 변환기로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef31ea41a9ba018762805e0743531d210cd6284" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Stream&lt;/code&gt; has stream type &lt;code&gt;s&lt;/code&gt;, underlying monad &lt;code&gt;m&lt;/code&gt; and token type &lt;code&gt;t&lt;/code&gt; determined by the stream</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 의 인스턴스 에는 스트림 유형 &lt;code&gt;s&lt;/code&gt; , 기본 모나드 &lt;code&gt;m&lt;/code&gt; 및 토큰 유형 &lt;code&gt;t&lt;/code&gt; 가 스트림에 의해 결정됩니다</target>
        </trans-unit>
        <trans-unit id="182b96f131379637cff152270abf17ec6ecf1c40" translate="yes" xml:space="preserve">
          <source>An integer denoting the number &lt;code&gt;l&lt;/code&gt; of printed completions,</source>
          <target state="translated">인쇄 완료 수 &lt;code&gt;l&lt;/code&gt; 을 나타내는 정수</target>
        </trans-unit>
        <trans-unit id="5705ba72313d6782ee3dec31edcfe71a4e6bfe65" translate="yes" xml:space="preserve">
          <source>An integer literal &lt;code&gt;368&lt;/code&gt; means &amp;ldquo;&lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;&amp;rdquo;, rather than &amp;ldquo;&lt;code&gt;Prelude.fromInteger (368::Integer)&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">정수 리터럴 ( &lt;code&gt;368&lt;/code&gt; ) 은 &quot; &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt; &quot;가 아니라 &quot; &lt;code&gt;Prelude.fromInteger (368::Integer)&lt;/code&gt; &quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7fcfdbe8f2cac93c2ec79190607c573c3d60d86c" translate="yes" xml:space="preserve">
          <source>An intermediate result in a scan.</source>
          <target state="translated">스캔의 중간 결과.</target>
        </trans-unit>
        <trans-unit id="4fdb6e08d830a1c3979bfdc3fd7343eb5abdfb8f" translate="yes" xml:space="preserve">
          <source>An invocation of GHC takes the following form:</source>
          <target state="translated">GHC 호출은 다음 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="edb1f7c1dc03b67ee6b809077f9e5604578eb554" translate="yes" xml:space="preserve">
          <source>An llvm-intermediate-language bitcode file, usually produced by the compiler.</source>
          <target state="translated">일반적으로 컴파일러에서 생성되는 llvm-intermediate-language 비트 코드 파일입니다.</target>
        </trans-unit>
        <trans-unit id="11d0526a9a9e3e29d8774eda5075a8938912393d" translate="yes" xml:space="preserve">
          <source>An llvm-intermediate-language source file, usually produced by the compiler.</source>
          <target state="translated">일반적으로 컴파일러에서 생성되는 llvm-intermediate-language 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2e0a23e4bb2863d568c7f363da30cd3b735cae06" translate="yes" xml:space="preserve">
          <source>An object &lt;code&gt;B&lt;/code&gt; retains object &lt;code&gt;A&lt;/code&gt; if (i) &lt;code&gt;B&lt;/code&gt; is a retainer object and (ii) object &lt;code&gt;A&lt;/code&gt; can be reached by recursively following pointers starting from object &lt;code&gt;B&lt;/code&gt;, but not meeting any other retainer objects on the way. Each live object is retained by one or more retainer objects, collectively called its retainer set, or its retainer set, or its retainers.</source>
          <target state="translated">(i) &lt;code&gt;B&lt;/code&gt; 가 리테이너 객체이고 (ii) 객체 &lt;code&gt;B&lt;/code&gt; 에서 시작하는 포인터를 재귀 적으로 따라 가지만 도중에 다른 리테이너 객체를 만나지 않으면 객체 &lt;code&gt;A&lt;/code&gt; 에 도달 할 수있는 경우 객체 &lt;code&gt;B&lt;/code&gt; 는 객체 &lt;code&gt;A&lt;/code&gt; 를 유지합니다 . 각 라이브 오브젝트는 하나 이상의 리테이너 오브젝트에 의해 보유되며, 집합 적으로 보유자 세트 또는 보유자 세트 또는 보유자라고합니다.</target>
        </trans-unit>
        <trans-unit id="42910c59b4eb5fc3b9c19c32b311eab9e4bf6a36" translate="yes" xml:space="preserve">
          <source>An object file, produced by an assembler.</source>
          <target state="translated">어셈블러에서 생성 한 객체 파일입니다.</target>
        </trans-unit>
        <trans-unit id="18c88b3ac1bd46ecfef3ff8276bc55927b9a64fe" translate="yes" xml:space="preserve">
          <source>An object which is never used is said to be in the void state for its whole lifetime.</source>
          <target state="translated">사용하지 않은 물체는 전체 수명 동안 공극 상태에 있다고합니다.</target>
        </trans-unit>
        <trans-unit id="5199083ec8a4ed3cb5139c93d4aeb1ab1a44d8f3" translate="yes" xml:space="preserve">
          <source>An offset, counted in bytes.</source>
          <target state="translated">바이트 단위로 계산 된 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="4e93ce4db75561be705e22c1086fdc986365d26d" translate="yes" xml:space="preserve">
          <source>An operator version of &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 운영자 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="269ede13d98d287f0dd18a20f718823a44965f42" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;E&lt;/code&gt; character indicates an alternate formatting. Currently this only affects &lt;code&gt;%Z&lt;/code&gt; and &lt;code&gt;%z&lt;/code&gt;.</source>
          <target state="translated">선택적인 &lt;code&gt;E&lt;/code&gt; 문자는 대체 형식을 나타냅니다. 현재 이것은 &lt;code&gt;%Z&lt;/code&gt; 및 &lt;code&gt;%z&lt;/code&gt; 에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="147554bd72cb36203ba4e437f86b5856939ecef7" translate="yes" xml:space="preserve">
          <source>An optional escape character</source>
          <target state="translated">선택적 이스케이프 문자</target>
        </trans-unit>
        <trans-unit id="470bd4645aa2a37d61b6006cf88e182f77dda35b" translate="yes" xml:space="preserve">
          <source>An overloaded interface to mutable arrays. For array types which can be used with this interface, see &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;, &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt;, and &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable&lt;/a&gt;.</source>
          <target state="translated">가변 배열에 대한 오버로드 된 인터페이스. 이 인터페이스와 함께 사용할 수있는 배열 유형은 &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt; , &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt; 및 &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed76ddf939d258125a9d07e26bf81d6563190100" translate="yes" xml:space="preserve">
          <source>An overloaded interface to mutable arrays. For array types which can be used with this interface, see &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;, &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt;, and &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable&lt;/a&gt;. . Safe API only of &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt;.</source>
          <target state="translated">가변 배열에 대한 오버로드 된 인터페이스. 이 인터페이스와 함께 사용할 수있는 배열 유형은 &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt; , &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt; 및 &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable을&lt;/a&gt; 참조하십시오 . . &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray의&lt;/a&gt; 안전한 API .</target>
        </trans-unit>
        <trans-unit id="b46b21c3d0ad448b7dbfafad15287d739812f46d" translate="yes" xml:space="preserve">
          <source>An overloaded label &amp;ldquo;&lt;code&gt;#foo&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;fromLabel @&quot;foo&quot;&lt;/code&gt;&amp;rdquo;, rather than &amp;ldquo;&lt;code&gt;GHC.OverloadedLabels.fromLabel @&quot;foo&quot;&lt;/code&gt;&amp;rdquo; (see &lt;a href=&quot;#overloaded-labels&quot;&gt;Overloaded labels&lt;/a&gt;).</source>
          <target state="translated">오버로드 된 레이블 &quot; &lt;code&gt;#foo&lt;/code&gt; &quot;는 &quot; &lt;code&gt;fromLabel @&quot;foo&quot;&lt;/code&gt; &quot;가 아니라 &quot; &lt;code&gt;GHC.OverloadedLabels.fromLabel @&quot;foo&quot;&lt;/code&gt; &quot;를 의미합니다 ( &lt;a href=&quot;#overloaded-labels&quot;&gt;오버로드 된 레이블&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9468ea5c26fba1b901ed7aacb46a3a82ed93f64b" translate="yes" xml:space="preserve">
          <source>An un-associated open type or data family declaration &lt;em&gt;always&lt;/em&gt; has a CUSK; un-annotated type variables default to kind &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">관련되지 않은 개방형 또는 데이터 패밀리 선언 에는 &lt;em&gt;항상&lt;/em&gt; CUSK가 있습니다. 주석이없는 유형 변수는 기본적으로 kind &lt;code&gt;Type&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="130b0c42eca7246bf15b8c958b406f7273873440" translate="yes" xml:space="preserve">
          <source>An unbounded size unsigned integer type is available with &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제한없는 크기의 부호없는 정수 유형은 &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="860459917b5a02de589e908d125eff6b77571ea2" translate="yes" xml:space="preserve">
          <source>An unboxed sum of the given reps</source>
          <target state="translated">주어진 담당자의 상자에 넣지 않은 합계</target>
        </trans-unit>
        <trans-unit id="7a6c34e18a2ffbd1385e4ed434dc780b5897e179" translate="yes" xml:space="preserve">
          <source>An unboxed tuple of the given reps</source>
          <target state="translated">주어진 담당자의 박스형 튜플</target>
        </trans-unit>
        <trans-unit id="58d8e58dbcaf88f766575185e1685146830b08ca" translate="yes" xml:space="preserve">
          <source>An unevaluated spark has been garbage collected.</source>
          <target state="translated">평가되지 않은 스파크가 가비지 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="6dc5e3262cb4421f0eecc8b241d84ce50b4e2631" translate="yes" xml:space="preserve">
          <source>An uninitialised record field was used. The &lt;code&gt;String&lt;/code&gt; gives information about the source location where the record was constructed.</source>
          <target state="translated">초기화되지 않은 레코드 필드가 사용되었습니다. &lt;code&gt;String&lt;/code&gt; 레코드가 건설 된 소스 위치에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="35d4a9def65ccb498f533dbeaee2b2071da0bbc7" translate="yes" xml:space="preserve">
          <source>An unqualified name; dynamically bound</source>
          <target state="translated">규정되지 않은 이름. 동적으로 바인딩</target>
        </trans-unit>
        <trans-unit id="dd607d2def70825ae686680e0742f5955f4c5559" translate="yes" xml:space="preserve">
          <source>An unsigned integral type that can be losslessly converted to and from &lt;code&gt;Ptr&lt;/code&gt;. This type is also compatible with the C99 type &lt;code&gt;uintptr_t&lt;/code&gt;, and can be marshalled to and from that type safely.</source>
          <target state="translated">&lt;code&gt;Ptr&lt;/code&gt; 과 무손실로 변환 할 수있는 부호없는 정수 유형입니다 . 이 유형은 C99 유형 &lt;code&gt;uintptr_t&lt;/code&gt; 와도 호환되며 해당 유형과 안전하게 마샬링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14042e31bb5752011e77595736a7c337f4b6cf90" translate="yes" xml:space="preserve">
          <source>And a response file &lt;code&gt;args.txt&lt;/code&gt;:</source>
          <target state="translated">응답 파일 &lt;code&gt;args.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cbd0ba0de747b34708a0f30527430f5a5c552189" translate="yes" xml:space="preserve">
          <source>And five warning flags:</source>
          <target state="translated">5 개의 경고 플래그 :</target>
        </trans-unit>
        <trans-unit id="523755b21b99024bbe43a1c9df96976e561c8e78" translate="yes" xml:space="preserve">
          <source>And inside &lt;code&gt;scheduleCallback&lt;/code&gt;, we create a callback that will in due course store the result data in the &lt;code&gt;Ptr Result&lt;/code&gt;, and then call &lt;code&gt;hs_try_putmvar()&lt;/code&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;scheduleCallback&lt;/code&gt; 내부 에서 &lt;code&gt;Ptr Result&lt;/code&gt; 에 결과 데이터를 저장할 콜백을 만든 다음 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c289bb0b2889358d5359dfed88823350fe8916e4" translate="yes" xml:space="preserve">
          <source>And multi-line spans are possible too:</source>
          <target state="translated">그리고 멀티 라인 스팬도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5e61586d1382fe8ad684bf10b7ab8931fb17aed0" translate="yes" xml:space="preserve">
          <source>And one general flag:</source>
          <target state="translated">그리고 하나의 일반적인 깃발 :</target>
        </trans-unit>
        <trans-unit id="dea1f9e397867b9cb1063d86c4c517eae2eedcd1" translate="yes" xml:space="preserve">
          <source>And read back with:</source>
          <target state="translated">그리고 다음과 같이 다시 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="fc6d8473bdc84d9a5a02e5f55e8ffba9c7a1eadb" translate="yes" xml:space="preserve">
          <source>And the program will loop at runtime. Similarly, an &lt;code&gt;Applicative&lt;/code&gt; instance like this</source>
          <target state="translated">그리고 프로그램은 런타임에 반복됩니다. 마찬가지로 이와 같은 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스</target>
        </trans-unit>
        <trans-unit id="91b7607b548e3de2b58aab9b4afde889d7ecf3e4" translate="yes" xml:space="preserve">
          <source>And three warning flags:</source>
          <target state="translated">그리고 세 가지 경고 플래그 :</target>
        </trans-unit>
        <trans-unit id="0194dd87cfa77e0f7f90bc726fd0703ab0c251ba" translate="yes" xml:space="preserve">
          <source>And we could have built an equivalent path with the following expressions:</source>
          <target state="translated">그리고 우리는 다음과 같은 식으로 동등한 경로를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04f47a0bf05c20c03ec6759fd8321b4e440f4b6" translate="yes" xml:space="preserve">
          <source>And with &lt;a href=&quot;#unboxed-sums&quot;&gt;UnboxedSums&lt;/a&gt; enabled</source>
          <target state="translated">그리고와 &lt;a href=&quot;#unboxed-sums&quot;&gt;UnboxedSums&lt;/a&gt; 가능</target>
        </trans-unit>
        <trans-unit id="ff1853f8dddb99a8c160df02448f14aeb5c7e0b7" translate="yes" xml:space="preserve">
          <source>And write a value to disk</source>
          <target state="translated">그리고 디스크에 값을 쓰십시오</target>
        </trans-unit>
        <trans-unit id="0b691ef27c0c127676c790709cff2ef33778d7eb" translate="yes" xml:space="preserve">
          <source>And you attempt to derive it using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그리고 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; 를&lt;/a&gt; 사용하여 파생 시키려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="495577bd97a225b48a7e5b45336021b982d75dbc" translate="yes" xml:space="preserve">
          <source>And you tried to derive an instance for it:</source>
          <target state="translated">그리고 당신은 그것을 위해 인스턴스를 도출하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="b8ad3365893a0b275281ec83a50665e9f2d6834f" translate="yes" xml:space="preserve">
          <source>And, among other things, lazy pattern-matching is your enemy.</source>
          <target state="translated">그리고 무엇보다도 게으른 패턴 매칭이 적입니다.</target>
        </trans-unit>
        <trans-unit id="8c4a82e242cf12aed8b85b58f58b0968fee82178" translate="yes" xml:space="preserve">
          <source>Andy Gill and Simon Marlow have written a parser-generator for Haskell, called &lt;code&gt;happy&lt;/code&gt;. &lt;code&gt;Happy&lt;/code&gt; is to Haskell what &lt;code&gt;Yacc&lt;/code&gt; is to C.</source>
          <target state="translated">Andy Gill과 Simon Marlow는 &lt;code&gt;happy&lt;/code&gt; 라는 Haskell의 파서 생성기를 작성했습니다 . &lt;code&gt;Happy&lt;/code&gt; 은 하스켈에게 &lt;code&gt;Yacc&lt;/code&gt; 가 C에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="74661a73b0dde5f32e46ef5440b8f7c212e3dd3f" translate="yes" xml:space="preserve">
          <source>AnnLookup</source>
          <target state="translated">AnnLookup</target>
        </trans-unit>
        <trans-unit id="c1da64c83c4be735ccac640316d60131dd4381db" translate="yes" xml:space="preserve">
          <source>AnnTarget</source>
          <target state="translated">AnnTarget</target>
        </trans-unit>
        <trans-unit id="f1b790e1da14310f6ece84c62bb58322fef3c9fc" translate="yes" xml:space="preserve">
          <source>AnnotDetails</source>
          <target state="translated">AnnotDetails</target>
        </trans-unit>
        <trans-unit id="bf34615f46f75f35e2f9ccc197db2f929dd6a301" translate="yes" xml:space="preserve">
          <source>AnnotStart</source>
          <target state="translated">AnnotStart</target>
        </trans-unit>
        <trans-unit id="665edccbf78492c3059856c8597043ed30b15ce4" translate="yes" xml:space="preserve">
          <source>Annotating documents</source>
          <target state="translated">문서 주석 달기</target>
        </trans-unit>
        <trans-unit id="0d453d564eadde058c35ace639f7bec19eccb3ee" translate="yes" xml:space="preserve">
          <source>Annotation lookup</source>
          <target state="translated">주석 조회</target>
        </trans-unit>
        <trans-unit id="11129140d62298b72f4c953d972b05a50da295ea" translate="yes" xml:space="preserve">
          <source>Annotation rendering</source>
          <target state="translated">주석 렌더링</target>
        </trans-unit>
        <trans-unit id="112cca03c76acb3cca2a892f6e3fa24c275d9756" translate="yes" xml:space="preserve">
          <source>Annotation target for reifyAnnotations</source>
          <target state="translated">reify에 대한 주석 대상</target>
        </trans-unit>
        <trans-unit id="fddbd22c104843c74d2c00f8cf2af89a7f68516f" translate="yes" xml:space="preserve">
          <source>Annotations are small pragmas that allow you to attach data to identifiers in source code, which are persisted when compiled. These pieces of data can then inspected and utilized when using GHC as a library or writing a compiler plugin.</source>
          <target state="translated">주석은 소스 코드의 식별자에 데이터를 첨부 할 수있는 작은 pragma이며 컴파일시 유지됩니다. 그런 다음 GHC를 라이브러리로 사용하거나 컴파일러 플러그인을 작성할 때 이러한 데이터를 검사하고 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b762d7dbaed9bb5ebd61e64b87ad52b2d8a6ca" translate="yes" xml:space="preserve">
          <source>Anonymous and named wildcards &lt;em&gt;can&lt;/em&gt; occur on the left hand side of a type or data instance declaration; see &lt;a href=&quot;#type-wildcards-lhs&quot;&gt;Wildcards on the LHS of data and type family instances&lt;/a&gt;.</source>
          <target state="translated">익명 및 명명 된 와일드 카드 &lt;em&gt;는&lt;/em&gt; 유형 또는 데이터 인스턴스 선언의 왼쪽에서 발생할 &lt;em&gt;수&lt;/em&gt; 있습니다. &lt;a href=&quot;#type-wildcards-lhs&quot;&gt;데이터 및 유형 패밀리 인스턴스의 LHS에&lt;/a&gt; 대한 와일드 카드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cf2947ec117ab6af4c3e63853ae6bc974a4aab5" translate="yes" xml:space="preserve">
          <source>Anonymous wildcards are also allowed in visible type applications/ visible kind applications (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). If you want to specify only the second type argument to &lt;code&gt;wurble&lt;/code&gt;, then you can say &lt;code&gt;wurble @_ @Int&lt;/code&gt; where the first argument is a wildcard.</source>
          <target state="translated">익명의 와일드 카드는 가시적 유형 애플리케이션 / 가시적 유형 애플리케이션 ( &lt;a href=&quot;#visible-type-application&quot;&gt;가시적 유형 애플리케이션&lt;/a&gt; ) 에서도 허용됩니다 . &lt;code&gt;wurble&lt;/code&gt; 에 두 번째 유형 인수 만 지정하려면 &lt;code&gt;wurble @_ @Int&lt;/code&gt; 라고 말하면 첫 번째 인수는 와일드 카드입니다.</target>
        </trans-unit>
        <trans-unit id="b4f913427243fca5da364b9f4af093e1c132cd45" translate="yes" xml:space="preserve">
          <source>Another common question that comes up when debugging is &amp;ldquo;where did this exception come from?&amp;rdquo;. Exceptions such as those raised by &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;head []&lt;/code&gt; have no context information attached to them. Finding which particular call to &lt;code&gt;head&lt;/code&gt; in your program resulted in the error can be a painstaking process, usually involving &lt;code&gt;Debug.Trace.trace&lt;/code&gt;, or compiling with profiling and using &lt;code&gt;Debug.Trace.traceStack&lt;/code&gt; or &lt;code&gt;+RTS -xc&lt;/code&gt; (see &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">디버깅 할 때 발생하는 또 다른 일반적인 질문은 &quot;이 예외는 어디에서 왔습니까?&quot;입니다. &lt;code&gt;error&lt;/code&gt; 또는 &lt;code&gt;head []&lt;/code&gt; 로 인해 발생한 예외 는 컨텍스트 정보가 첨부되지 않습니다. 특히 전화 찾기 &lt;code&gt;head&lt;/code&gt; 프로그램에서 오류의 결과는 일반적으로 포함, 근면 한 과정이 될 수 &lt;code&gt;Debug.Trace.trace&lt;/code&gt; 을 하거나, 프로파일 링 및 사용하여 컴파일 &lt;code&gt;Debug.Trace.traceStack&lt;/code&gt; 또는 &lt;code&gt;+RTS -xc&lt;/code&gt; 를 (참조 &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8a901bb130edd93de354a92729369e7eb8a77ff7" translate="yes" xml:space="preserve">
          <source>Another common use is to ensure any exceptions hidden within lazy fields of a data structure do not leak outside the scope of the exception handler, or to force evaluation of a data structure in one thread, before passing to another thread (preventing work moving to the wrong threads).</source>
          <target state="translated">또 다른 일반적인 용도는 데이터 구조의 게으른 필드 내에 숨겨진 예외가 예외 처리기의 범위를 벗어나 누출되지 않도록하거나 다른 스레드로 전달하기 전에 한 스레드에서 데이터 구조를 강제로 평가하는 것입니다. 잘못된 스레드).</target>
        </trans-unit>
        <trans-unit id="312336ad458ea40ebadf4c791b596f396bc92d0d" translate="yes" xml:space="preserve">
          <source>Another difference between higher-rank kinds and types can be found in their treatment of inferred and user-specified type variables. Consider the following program:</source>
          <target state="translated">상위 유형과 유형의 또 다른 차이점은 유추 및 사용자 지정 유형 변수의 처리에서 찾을 수 있습니다. 다음 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="619e7f27cda3e42e4615c75dcb4975c0f4f68283" translate="yes" xml:space="preserve">
          <source>Another difficulty with the memo table is that the value of a key/value pair might itself contain a pointer to the key. So the memo table keeps the value alive, which keeps the key alive, even though there may be no other references to the key so both should die. The weak pointers in this library provide a slight generalisation of the basic weak-pointer idea, in which each weak pointer actually contains both a key and a value.</source>
          <target state="translated">메모 테이블의 또 다른 어려움은 키 / 값 쌍의 값 자체에 키에 대한 포인터가 포함될 수 있다는 것입니다. 따라서 메모 테이블은 값을 활성 상태로 유지하여 키에 대한 다른 참조가 없어도 키를 활성 상태로 유지하므로 둘 다 죽어야합니다. 이 라이브러리의 약한 포인터는 각각의 약한 포인터가 실제로 키와 값을 모두 포함하는 기본 약한 포인터 아이디어를 약간 일반화합니다.</target>
        </trans-unit>
        <trans-unit id="3139c4c3d9fe163dd31667b3304a7a4a55378c8e" translate="yes" xml:space="preserve">
          <source>Another extremely efficient way to make your program snappy is to use library code that has been Seriously Tuned By Someone Else. You &lt;em&gt;might&lt;/em&gt; be able to write a better quicksort than the one in &lt;code&gt;Data.List&lt;/code&gt;, but it will take you much longer than typing &lt;code&gt;import Data.List&lt;/code&gt;.</source>
          <target state="translated">프로그램을 간단하게 만드는 또 다른 매우 효율적인 방법은 다른 사람이 심각하게 조정 한 라이브러리 코드를 사용하는 것입니다. 당신은 &lt;em&gt;할 수&lt;/em&gt; 있는 것보다 더 나은 퀵 쓸 수 &lt;code&gt;Data.List&lt;/code&gt; 을 하지만, 타이핑보다 훨씬 더 오래 걸릴 것입니다 &lt;code&gt;import Data.List&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0192d00c4c561122179982081c286d8efe43c16b" translate="yes" xml:space="preserve">
          <source>Another form of command is a form of &lt;code&gt;do&lt;/code&gt;-notation. For example, you can write</source>
          <target state="translated">다른 형태의 명령은 &lt;code&gt;do&lt;/code&gt; - notation 의 형태입니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="ca7ae7aaeace3e8afcdea81b5fff39694bdaa3a2" translate="yes" xml:space="preserve">
          <source>Another important difference between the two types of binding is that the monadic bind (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) is &lt;em&gt;strict&lt;/em&gt; (it evaluates &lt;code&gt;e&lt;/code&gt;), whereas with the &lt;code&gt;let&lt;/code&gt; form, the expression isn&amp;rsquo;t evaluated immediately:</source>
          <target state="translated">(결합의 두 가지 사이의 또 다른 중요한 차이점은, 모나드 결합이다 &lt;code&gt;p &amp;lt;- e&lt;/code&gt; )는 &lt;em&gt;엄격한&lt;/em&gt; (그것이 평가 &lt;code&gt;e&lt;/code&gt; 에 반해) &lt;code&gt;let&lt;/code&gt; : 형태 식 즉시 평가되지</target>
        </trans-unit>
        <trans-unit id="fa6d0d044f8316bb0266e4594b9afdb9ea5faf82" translate="yes" xml:space="preserve">
          <source>Another point to bear in mind: By far the best way to improve a program&amp;rsquo;s performance &lt;em&gt;dramatically&lt;/em&gt; is to use better algorithms. Once profiling has thrown the spotlight on the guilty time-consumer(s), it may be better to re-think your program than to try all the tweaks listed below.</source>
          <target state="translated">명심해야 할 또 다른 요점 : 지금까지 프로그램 성능을 &lt;em&gt;크게&lt;/em&gt; 향상시키는 가장 좋은 방법 은 더 나은 알고리즘을 사용하는 것입니다. 프로파일 링이 유죄 타임 소비자에게 주목을 받으면 아래 나열된 모든 조정을 시도하는 것보다 프로그램을 다시 생각하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d787e6c2588a53fddf149a1d181b21e1640ac274" translate="yes" xml:space="preserve">
          <source>Another useful application is to combine &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; in order to force deep evaluation relative to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations:</source>
          <target state="translated">또 다른 유용한 응용 프로그램은 다른 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업에 비해 심도있는 평가를 수행하기 위해 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 결합 하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="748a1e04935a7f3501001c42790b9f7f7d64ce9f" translate="yes" xml:space="preserve">
          <source>Another useful application is to combine &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; in order to force deep evaluation relative to other &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations:</source>
          <target state="translated">또 다른 유용한 응용 프로그램은 다른 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업과 관련된 심층 평가를 강제하기 위해 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 결합 하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="c16541def5ea587ac69bfcc99daad84a959043da" translate="yes" xml:space="preserve">
          <source>Another valid monoid instance of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; It is defined by multiplication and `1` as neutral element:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 또 다른 유효한 monoid 인스턴스 는 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; 입니다. 곱셈과 '1'은 중립 요소로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="988994d9ba9baaa058f970931250d478f9f37dc1" translate="yes" xml:space="preserve">
          <source>Another way of getting rid of the ambiguity at the call site is to use the &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension to specify the types. For example:</source>
          <target state="translated">호출 사이트에서 모호성을 제거하는 또 다른 방법은 &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 유형을 지정하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9ca1d00f2ba6c9bdc216ddca02e1e03260d4bda" translate="yes" xml:space="preserve">
          <source>Another way to manipulate the scope is to use the &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command, whose syntax is this:</source>
          <target state="translated">범위를 조작하는 다른 방법은 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 명령 을 사용하는 것입니다 . 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="55329b02c1416b447df48dea23b5ad00b5ee2f0a" translate="yes" xml:space="preserve">
          <source>Any -On where n &amp;gt; 2 is the same as -O2.</source>
          <target state="translated">n&amp;gt; 2는 -O2와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="aed001ecb885bcbc05312253a4102a733b569260" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 에 전달 된 모든 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 즉시 닫힌 상태에 놓입니다.</target>
        </trans-unit>
        <trans-unit id="e91b45192e9b0774cf7aefe77d4d40c0d29cd8a2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;COMPLETE&lt;/code&gt; sets of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 모든 &lt;code&gt;COMPLETE&lt;/code&gt; 세트</target>
        </trans-unit>
        <trans-unit id="5dfb3cd648c868b374f6e2677fac36fbe2978a3c" translate="yes" xml:space="preserve">
          <source>Any GHC command-line option that is designated as dynamic (see the table in &lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;), may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;. To unset an option, you can set the reverse option:</source>
          <target state="translated">동적으로 지정된 GHC 명령 행 옵션 ( &lt;a href=&quot;flags#flag-reference&quot;&gt;플래그 참조&lt;/a&gt; 의 표 참조 )은 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 을&lt;/a&gt; 사용하여 설정할 수 있습니다 . 옵션을 설정 해제하려면 reverse 옵션을 설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6f5306564b28b058683860c0dbb58f6e1ae386c4" translate="yes" xml:space="preserve">
          <source>Any I/O errors encountered while a handle is semi-closed are simply discarded.</source>
          <target state="translated">핸들이 반 닫히는 동안 발생한 모든 I / O 오류는 단순히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c84ffa38e0d42fe1e3c4aafd67e2a273e5029ca" translate="yes" xml:space="preserve">
          <source>Any arbitrary string, no interpretation or parsing is done.</source>
          <target state="translated">임의의 문자열, 해석 또는 구문 분석이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0452f2ab13ab3b0881a1a304cec756faecd5a100" translate="yes" xml:space="preserve">
          <source>Any data type that can be declared in standard Haskell 98 syntax can also be declared using GADT-style syntax. The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching. For example:</source>
          <target state="translated">표준 Haskell 98 구문으로 선언 될 수있는 모든 데이터 유형은 GADT 스타일 구문을 사용하여 선언 할 수도 있습니다. 선택은 크게 문체이지만 GADT 스타일 선언은 한 가지 중요한 점에서 다릅니다. 즉, 데이터 생성자에 대한 클래스 제약 조건을 다르게 취급합니다. 특히 생성자에 형식 클래스 컨텍스트가 제공되면 해당 컨텍스트를 패턴 일치로 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d3011ab0c7b5aa4a9a177dbc0ce024f6e055225" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">명령문의 평가 또는 실행 중에 발생하는 예외는 GHCi 명령 행 인터페이스에 의해 포착 및 인쇄됩니다 (예외에 대한 자세한 정보 는 라이브러리 문서에서 &lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d671ba93c9259d42fd317ba91ce67c391a4d8b7f" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">명령문을 평가하거나 실행하는 동안 발생하는 모든 예외는 GHCi 명령 줄 인터페이스에 의해 포착되고 인쇄됩니다 (예외에 대한 자세한 내용 은 라이브러리 설명서의 &lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb34342e0a6715040492745b6bae6bc125156350" translate="yes" xml:space="preserve">
          <source>Any expression that has both &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances may be attached to a top-level value binding using an &lt;code&gt;ANN&lt;/code&gt; pragma. In particular, this means you can use &lt;code&gt;ANN&lt;/code&gt; to annotate data constructors (e.g. &lt;code&gt;Just&lt;/code&gt;) as well as normal values (e.g. &lt;code&gt;take&lt;/code&gt;). By way of example, to annotate the function &lt;code&gt;foo&lt;/code&gt; with the annotation &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; you would do this:</source>
          <target state="translated">&lt;code&gt;Typeable&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인스턴스 가 모두있는 식은 &lt;code&gt;ANN&lt;/code&gt; pragma를 사용하여 최상위 값 바인딩에 연결될 수 있습니다 . 특히, &lt;code&gt;ANN&lt;/code&gt; 을 사용 하여 데이터 생성자 (예 : &lt;code&gt;Just&lt;/code&gt; )와 일반 값 (예 : &lt;code&gt;take&lt;/code&gt; ) 에 주석을 달 수 있습니다 . 예를 들어, 함수 &quot; &lt;code&gt;foo&lt;/code&gt; &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; 주석 &quot;Hello&quot;로 주석을 달려면 다음 과 같이 하십시오.</target>
        </trans-unit>
        <trans-unit id="01212113a76fa0770e6b80bde8974e88d8560b27" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension에&lt;/a&gt; 정의 된 &lt;code&gt;Extension&lt;/code&gt; 유형의 모든 확장을 사용할 수 있습니다. GHC는 요청 된 확장이 지원되지 않는 경우 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="b4b940cc0f6bd9befa4dc2cd571bce369cc78d6f" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension에&lt;/a&gt; 정의 된 &lt;code&gt;Extension&lt;/code&gt; 유형의 모든 확장을 사용할 수 있습니다. 요청 된 확장이 지원되지 않으면 GHC에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="45294fce8a408e067f71fcddc66e44fa9a3aa925" translate="yes" xml:space="preserve">
          <source>Any field width is followed optionally by a precision:</source>
          <target state="translated">모든 필드 너비 다음에는 선택적으로 정밀도가옵니다.</target>
        </trans-unit>
        <trans-unit id="ca99cdb1b6224c8f2acca56e49dc80e277ef33e9" translate="yes" xml:space="preserve">
          <source>Any flags are followed optionally by a field width:</source>
          <target state="translated">모든 플래그 다음에는 선택적으로 필드 너비가옵니다.</target>
        </trans-unit>
        <trans-unit id="fe6292886945b8678502b2eed862908e6596bec8" translate="yes" xml:space="preserve">
          <source>Any flags not recognized by runghc are automatically passed to GHC. If a flag is recognized by both runghc and GHC but you want to pass it to GHC then you can place it after a &lt;code&gt;--&lt;/code&gt; separator. Flags after the separator are treated as GHC only flags. Alternatively you can use the runghc option &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to pass any flag or argument directly to GHC.</source>
          <target state="translated">runghc에 의해 인식되지 않는 모든 플래그는 자동으로 GHC로 전달됩니다. runghc와 GHC에서 플래그를 인식하지만 GHC에 전달하려는 경우 &lt;code&gt;--&lt;/code&gt; 구분 기호 뒤에 배치 할 수 있습니다 . 구분 기호 뒤의 플래그는 GHC 전용 플래그로 처리됩니다. 또는 runghc 옵션 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 를 사용하여 플래그 또는 인수를 GHC에 직접 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a24acb0ed73105a63c6aa8b83c5ce57f71ebe7" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; can be made into an instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; by defining &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">임의의 인스턴스 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; 은 인스턴스로 이루어질 수 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; 정의하여 &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c46287c62f0868214d45f152801a23db51bd59d4" translate="yes" xml:space="preserve">
          <source>Any instance should be subject to the following laws:</source>
          <target state="translated">모든 경우에는 다음 법률이 적용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4adffce07a1e96f7b4aa9f3335793d174570cf6" translate="yes" xml:space="preserve">
          <source>Any modifiers found.</source>
          <target state="translated">모든 수정자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="5cecd2c65d9c46eca630a92c4797e911edc247d7" translate="yes" xml:space="preserve">
          <source>Any number of source file names or module names may be specified; GHC will figure out all the modules in the program by following the imports from these initial modules. It will then attempt to compile each module which is out of date, and finally, if there is a &lt;code&gt;Main&lt;/code&gt; module, the program will also be linked into an executable.</source>
          <target state="translated">소스 파일 이름이나 모듈 이름은 얼마든지 지정할 수 있습니다. GHC는 이러한 초기 모듈에서 가져 오기를 수행하여 프로그램의 모든 모듈을 파악합니다. 그런 다음 오래된 각 모듈을 컴파일하려고 시도하고 마지막으로 &lt;code&gt;Main&lt;/code&gt; 모듈 이 있으면 프로그램도 실행 파일에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="8a7ee0a6d4ed7c475e886db91c9ca4af5ab7c3c0" translate="yes" xml:space="preserve">
          <source>Any of the command-line options described in the rest of this chapter can be used with &lt;code&gt;--make&lt;/code&gt;, but note that any options you give on the command line will apply to all the source files compiled, so if you want any options to apply to a single source file only, you&amp;rsquo;ll need to use an &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma (see &lt;a href=&quot;#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt;).</source>
          <target state="translated">이 장의 나머지 부분에서 설명하는 명령 줄 옵션은 &lt;code&gt;--make&lt;/code&gt; 와 함께 사용할 수 있지만 명령 줄에 제공하는 모든 옵션은 컴파일 된 모든 소스 파일에 적용되므로 옵션을 적용하려면 단일 소스 파일에만 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma 를 사용해야합니다 ( &lt;a href=&quot;#source-file-options&quot;&gt;소스 파일의 명령 행 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4fcac47fb48917b29ef16b080f9169cd49dcd808" translate="yes" xml:space="preserve">
          <source>Any operation that fails because a handle is closed, also fails if a handle is semi-closed. The only exception is &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt;. A semi-closed handle becomes closed:</source>
          <target state="translated">핸들이 닫혀서 실패한 조작은 핸들이 반 닫히면 실패합니다. 유일한 예외는 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 입니다. 반 닫힘 핸들이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="74cf8930fe96c667f6ee4ecd6012b01ea066396e" translate="yes" xml:space="preserve">
          <source>Any orphan instances which are brought into scope by an import from a signature are unconditionally considered in scope, even if the eventual implementing module doesn&amp;rsquo;t actually import the same orphans.</source>
          <target state="translated">최종 구현 모듈이 실제로 동일한 고아를 가져 오지 않더라도 서명에서 가져 오면 범위로 가져 오는 모든 고아 인스턴스는 범위 내에서 무조건 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="2fbfab23f62ec3e48e80e1e5422619cb69668f7f" translate="yes" xml:space="preserve">
          <source>Any other exceptions which are not matched by the predicate are re-raised, and may be caught by an enclosing &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">술어와 일치하지 않는 다른 예외는 다시 발생하며 둘러싸는 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 등에 의해 잡힐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a712b26d1cb0416ca0ddd0555d9306a2c267be27" translate="yes" xml:space="preserve">
          <source>Any precision is followed optionally for Integral types by a width modifier; the only use of this modifier being to set the implicit size of the operand for conversion of a negative operand to unsigned:</source>
          <target state="translated">선택적으로 정수 유형의 경우 너비 수정자가 뒤에 오는 모든 정밀도가 따릅니다. 음수 피연산자를 부호없는 것으로 변환하기 위해 피연산자의 암시 적 크기를 설정하는 데이 수정 자의 유일한 사용 :</target>
        </trans-unit>
        <trans-unit id="d8c91f9f9f6e75c41b02098e931d3439ddcf440f" translate="yes" xml:space="preserve">
          <source>Any real interval contains a unique simplest rational; in particular, note that &lt;code&gt;0/1&lt;/code&gt; is the simplest rational of all.</source>
          <target state="translated">모든 실제 구간에는 고유 한 가장 간단한 합리적 요소가 포함됩니다. 특히 &lt;code&gt;0/1&lt;/code&gt; 은 가장 간단한 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="bd6fa11933cdfcdc743d92e3ae1b1b26d19d69a2" translate="yes" xml:space="preserve">
          <source>Any single-constructor data is eligible for unpacking; for example</source>
          <target state="translated">모든 단일 생성자 데이터는 포장을 풀 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a18603a852f4e4b843d8b21962152ae0dc60595e" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 를 통해 파일 디스크립터에서 차단 된 스레드는 IO 예외가 발생하여 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="769148ddf54673e79970f08b70786bcc3aab11e0" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 를 통해 파일 디스크립터에서 차단 된 스레드는 IO 예외가 발생하여 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="87c36f7b926ac2fbec6f667eb5439c00c637c3ef" translate="yes" xml:space="preserve">
          <source>Any type that you wish to throw or catch as an exception must be an instance of the &lt;code&gt;Exception&lt;/code&gt; class. The simplest case is a new exception type directly below the root:</source>
          <target state="translated">예외로 던지거나 잡으려는 모든 유형은 &lt;code&gt;Exception&lt;/code&gt; 클래스 의 인스턴스 여야합니다 . 가장 간단한 경우는 루트 바로 아래에 새로운 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b1bd8e562d1fefda868c7d1ff0cda571db4a02aa" translate="yes" xml:space="preserve">
          <source>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &amp;ldquo;to the left&amp;rdquo; in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function &lt;code&gt;clunky&lt;/code&gt; from &lt;a href=&quot;#pattern-guards&quot;&gt;Pattern guards&lt;/a&gt; can be written using view patterns as follows:</source>
          <target state="translated">⟨exp⟩의 모든 변수는 바운드 발생이지만 패턴에서 &quot;왼쪽&quot;에 바인딩 된 변수는 범위 내에 있습니다. 이 기능은 예를 들어 함수에 대한 하나의 인수가 다른 인수의 관점에서 사용될 수 있도록합니다. 예를 들어, &lt;a href=&quot;#pattern-guards&quot;&gt;패턴 가드&lt;/a&gt; 에서 &lt;code&gt;clunky&lt;/code&gt; 기능 은 다음과 같이 뷰 패턴을 사용하여 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f483f182aa56813d1000ce4df4790bcbe905f1" translate="yes" xml:space="preserve">
          <source>Any whitespace which appears outside of either of the quoting and escaping mechanisms, is interpreted as having been added by this special concatenation process to designate where the boundaries are between the original, un-concatenated list of strings. These added whitespace characters are removed from the output.</source>
          <target state="translated">인용 및 이스케이프 메커니즘 외부에 나타나는 공백은이 특수 연결 프로세스에 의해 추가되어 해석되지 않은 원래 문자열 목록 사이의 경계를 지정하는 것으로 해석됩니다. 이러한 추가 된 공백 문자는 출력에서 ​​제거됩니다.</target>
        </trans-unit>
        <trans-unit id="86fba8724925018bcafcede041fc92c898e3eb9b" translate="yes" xml:space="preserve">
          <source>AnyclassStrategy</source>
          <target state="translated">AnyclassStrategy</target>
        </trans-unit>
        <trans-unit id="2d219c6ebc1efaae092effbbdcf3fa6d485c6699" translate="yes" xml:space="preserve">
          <source>Anything else throws an exception:</source>
          <target state="translated">다른 것은 예외를 던집니다.</target>
        </trans-unit>
        <trans-unit id="036d8f7bd31769453184842860e1d5ca8c639fff" translate="yes" xml:space="preserve">
          <source>Anything which is already valid as a constraint without the flag: saturated applications to type classes, implicit parameter and equality constraints.</source>
          <target state="translated">플래그없이 제약 조건으로 이미 유효한 것 : 클래스를 입력하기위한 포화 응용 프로그램, 암시 적 매개 변수 및 동등 제약 조건.</target>
        </trans-unit>
        <trans-unit id="ad26f77e74f38dbef3399b317d10c13e53d32aa2" translate="yes" xml:space="preserve">
          <source>Anything whose form is not yet known, but the user has declared to have kind &lt;code&gt;Constraint&lt;/code&gt; (for which they need to import it from &lt;code&gt;Data.Kind&lt;/code&gt;). So for example &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; is allowed, as well as examples involving type families:</source>
          <target state="translated">양식이 아직 알려지지 않았지만 사용자가 친절한 &lt;code&gt;Constraint&lt;/code&gt; ( &lt;code&gt;Data.Kind&lt;/code&gt; 에서 가져와야 함 ) 을 갖도록 선언 했습니다 . 따라서 예를 들어 &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; 및 유형 패밀리 관련 예제가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b920fb3adf34d73af2cb7b5c93d8efbc94cd36f7" translate="yes" xml:space="preserve">
          <source>Ap</source>
          <target state="translated">Ap</target>
        </trans-unit>
        <trans-unit id="53d21ca24e640bdf8e7b761f501faaae7e4e72fb" translate="yes" xml:space="preserve">
          <source>Apart from removing intermediate data-structures, encodings can be optimized further by fine-tuning their execution parameters using the functions in &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt; and their &quot;inner loops&quot; using the functions in &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;.</source>
          <target state="translated">이 외에, 중간 데이터 구조를 제거하는, 인코딩이 미세 조정에 의해 더 최적화 할 수있는 기능을 사용하여 실행 파라미터 &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt; 의 기능을 사용하고 그들의 &quot;내부 루프&quot; &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14dc219def5159ae2ab7cfd4d71881c1c3903e70" translate="yes" xml:space="preserve">
          <source>Apart from the &lt;code&gt;:{ ... :}&lt;/code&gt; syntax for multi-line input mentioned above, GHCi also has a multiline mode, enabled by &lt;code&gt;:set +m&lt;/code&gt;, &lt;code&gt;:set +m&lt;/code&gt; in which GHCi detects automatically when the current statement is unfinished and allows further lines to be added. A multi-line input is terminated with an empty line. For example:</source>
          <target state="translated">위에서 언급 한 멀티 라인 입력에 대한 &lt;code&gt;:{ ... :}&lt;/code&gt; 구문 외에도 GHCi에는 &lt;code&gt;:set +m&lt;/code&gt; , &lt;code&gt;:set +m&lt;/code&gt; 에 의해 활성화 된 멀티 라인 모드가 있으며 , 현재 명령문이 완료되지 않은 경우 GHCi가 자동으로 감지하여 추가 할 줄. 여러 줄 입력은 빈 줄로 종료됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc4a695f02a8a53a129dcb9ace91e91ee1e7feb9" translate="yes" xml:space="preserve">
          <source>App</source>
          <target state="translated">App</target>
        </trans-unit>
        <trans-unit id="c607b075485b6dc8c400c818769a9c892ea0ffc4" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="f664580544f7f0aa77f101d16e0efbbe807fa6e5" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="e26661dc8c698ec289349a6aeecab4d0a5e5ec82" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="345b0c25bf20f673449b84d7d686b5c70bebf7c2" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="4ebc23e4c1b65a48a70d373d483fafb1ccae8ba3" translate="yes" xml:space="preserve">
          <source>Append two lists, i.e.,</source>
          <target state="translated">두 목록을 추가하십시오. 즉</target>
        </trans-unit>
        <trans-unit id="3e0bf0178a1d360f27255c9a7f025fc03359dcd5" translate="yes" xml:space="preserve">
          <source>AppendHandle</source>
          <target state="translated">AppendHandle</target>
        </trans-unit>
        <trans-unit id="374c012a038cea614a313e941a993048c6cf1210" translate="yes" xml:space="preserve">
          <source>AppendMode</source>
          <target state="translated">AppendMode</target>
        </trans-unit>
        <trans-unit id="3916a3175dfaa3fd999b22f53277fe454f6b7b38" translate="yes" xml:space="preserve">
          <source>AppendOnWrite</source>
          <target state="translated">AppendOnWrite</target>
        </trans-unit>
        <trans-unit id="dbe098d861d9a244dfef0444bcf8ab0f87546a7d" translate="yes" xml:space="preserve">
          <source>AppendSymbol</source>
          <target state="translated">AppendSymbol</target>
        </trans-unit>
        <trans-unit id="b67fd654b8abfbeb1a717ca3d11ec607e6526062" translate="yes" xml:space="preserve">
          <source>Applicability</source>
          <target state="translated">Applicability</target>
        </trans-unit>
        <trans-unit id="d311231658a1b3353cd77d4859248f1e061c4cc1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">응용 프로그램 운영자. 일반 연산자 &lt;code&gt;(f x)&lt;/code&gt; 는 &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 와 동일 하므로이 연산자는 중복 됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 오른쪽 연관 바인딩 우선 순위가 낮으므로 때때로 괄호를 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43dbefc4fd00eee5d8e84d6de5dadb9d229d56a1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">응용 프로그램 운영자. 일반 연산자 &lt;code&gt;(f x)&lt;/code&gt; 는 &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 와 동일 하므로이 연산자는 중복 됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 오른쪽 연관 바인딩 우선 순위가 낮으므로 때때로 괄호를 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f58752dc50f3a1aa349659b655c647ebed7f8f30" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">응용 프로그램 운영자. 일반 연산자 &lt;code&gt;(f x)&lt;/code&gt; 는 &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 와 동일 하므로이 연산자는 중복 됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 오른쪽 연관 바인딩 우선 순위가 낮으므로 때때로 괄호를 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4bf898ba305639dbde7f1d71fe68cf723d6796d1" translate="yes" xml:space="preserve">
          <source>Application-specific customizations to the user interface.</source>
          <target state="translated">사용자 인터페이스에 대한 응용 프로그램 별 사용자 정의</target>
        </trans-unit>
        <trans-unit id="0b8a1b21fc212c72c3e7976ca547d1f598c5e314" translate="yes" xml:space="preserve">
          <source>Applicative</source>
          <target state="translated">Applicative</target>
        </trans-unit>
        <trans-unit id="c42b346f9e6450034a0b493919801528c343e948" translate="yes" xml:space="preserve">
          <source>Applicative actions</source>
          <target state="translated">적용 조치</target>
        </trans-unit>
        <trans-unit id="98c9a7602c91954ae00f88c84bb4db90472de9d3" translate="yes" xml:space="preserve">
          <source>Applicative do-notation desugaring preserves the original semantics, provided that the &lt;code&gt;Applicative&lt;/code&gt; instance satisfies &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; and &lt;code&gt;pure = return&lt;/code&gt; (these are true of all the common monadic types). Thus, you can normally turn on &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; without fear of breaking your program. There is one pitfall to watch out for; see &lt;a href=&quot;#applicative-do-pitfall&quot;&gt;Things to watch out for&lt;/a&gt;.</source>
          <target state="translated">Applicative Do-notation Desugaring은 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스가 &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; 및 &lt;code&gt;pure = return&lt;/code&gt; 만족 하는 경우 원래 의미를 유지합니다 (이는 모든 일반적인 모나드 유형에 해당됨). 따라서 일반적으로 프로그램 중단에 대한 두려움없이 &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; 를 켤 수 있습니다 . 주의해야 할 함정이 하나 있습니다. 주의 &lt;a href=&quot;#applicative-do-pitfall&quot;&gt;사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3040a310341680e034eec3985152bc5a9e486ec2" translate="yes" xml:space="preserve">
          <source>Applicative functor formed by adding pure computations to a given applicative functor.</source>
          <target state="translated">주어진 펑션 펑터에 순수한 계산을 추가하여 형성된 펑션 펑터.</target>
        </trans-unit>
        <trans-unit id="65f268e6aa6cb1e22480a2a575f39395d4e90f10" translate="yes" xml:space="preserve">
          <source>Applicative functors</source>
          <target state="translated">적용 펑터</target>
        </trans-unit>
        <trans-unit id="e1507c25dc6a64376527010df0e4de108198887a" translate="yes" xml:space="preserve">
          <source>Applicative general combining function</source>
          <target state="translated">응용 일반 결합 기능</target>
        </trans-unit>
        <trans-unit id="ba83691e2c1dcc5de53cc3e4b25ca28fcf3f9a3b" translate="yes" xml:space="preserve">
          <source>Applicative merge tactic types</source>
          <target state="translated">적용 가능한 병합 전술 유형</target>
        </trans-unit>
        <trans-unit id="3bb211f1db0886c20dbcbe3aec098bfa4c51a870" translate="yes" xml:space="preserve">
          <source>ApplicativeDo</source>
          <target state="translated">ApplicativeDo</target>
        </trans-unit>
        <trans-unit id="a3e4a569ead07c8bc4d8de675cfd615c69dad24a" translate="yes" xml:space="preserve">
          <source>Applied</source>
          <target state="translated">Applied</target>
        </trans-unit>
        <trans-unit id="919e6fc623e0dc282b30825056bd5dda3c4e6c46" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">술어 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 되면 모두 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 모든 요소가 술어를 만족 하는지 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="637b1e1d5c8efd54c8949c6a43abe4555350a327" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">술어 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 되면 모두 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 모든 요소가 술어를 만족 하는지 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="9e82bc67b89a4b9e5b1ef1666971641ffcc4ec35" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">조건부 및 ByteString에인가 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 판별 할 경우의 요소 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 만족 술어.</target>
        </trans-unit>
        <trans-unit id="bbb6d3ed7b10d0b6c91c1b6b6102c1501910cf5b" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">조건부 및 ByteString에인가 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 판별 할 경우의 요소 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 만족 술어.</target>
        </trans-unit>
        <trans-unit id="b1b160142b2aab409abf2571e6a42ee896b8231e" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">술어 및 목록에 &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 되면 모두 목록의 모든 요소가 술어를 만족하는지 판별합니다. 결과가 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 가 되려면 목록이 유한해야합니다. &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 그러나, 결과 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 조건부 용 유한 또는 무한리스트의 인덱스에 유한 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="1bb3df1dee5942308d7549a4ff4e6623460c1a98" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">조건부 및리스트에 적용될 &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 판별 할 경우리스트의 요소를 만족 술어. 결과가 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 가되도록 하려면 목록이 유한해야합니다. &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그러나, 결과 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 조건부 용 유한 또는 무한리스트의 인덱스에 유한 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="649319403532f404d1828c385726fa18cf17318d" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">술어 및 목록에 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 되면 모두 목록의 모든 요소가 술어를 만족하는지 판별합니다. 결과가 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 가 되려면 목록이 유한해야합니다. &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 그러나, 결과 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 조건부 용 유한 또는 무한리스트의 인덱스에 유한 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="96fd46ee7a807ee87c60e5d0b9ca946dc3e911cb" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">조건부 및리스트에 적용될 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 판별 할 경우리스트의 요소를 만족 술어. 결과가 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 가되도록 하려면 목록이 유한해야합니다. &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그러나, 결과 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 조건부 용 유한 또는 무한리스트의 인덱스에 유한 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="be0613a1194858373863a5914ef44b595dda15fa" translate="yes" xml:space="preserve">
          <source>Applies a type to a function type. Returns: &lt;code&gt;Just u&lt;/code&gt; if the first argument represents a function of type &lt;code&gt;t -&amp;gt; u&lt;/code&gt; and the second argument represents a function of type &lt;code&gt;t&lt;/code&gt;. Otherwise, returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">유형을 함수 유형에 적용합니다. 반환 값 : &lt;code&gt;Just u&lt;/code&gt; 첫 번째 인수가 타입의 기능을 나타내는 경우 &lt;code&gt;t -&amp;gt; u&lt;/code&gt; 두 번째 인수가 타입의 기능을 나타내는 &lt;code&gt;t&lt;/code&gt; 을 . 그렇지 않으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fee4a02d62b3b562a9c374f2e31932813920bd3d" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;(+1)&lt;/code&gt; to a list, a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 와 목록에 &lt;code&gt;(+1)&lt;/code&gt; 을 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7560eee7a783d22baf2bd6d4444f64f9c9a496fc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; to the second element of a pair:</source>
          <target state="translated">한 쌍의 두 번째 요소 &lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="11040b63f3921092eab408bc2b85dc0c41f9e594" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">&lt;code&gt;Maybe Int&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 를 적용합니다 . &lt;code&gt;Just n&lt;/code&gt; 이 있으면 기본 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 을 표시하려고합니다 . 그러나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 이 있으면 &quot;Nothing&quot;대신 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="615a1ddaf7551b2a4174858609db8c4f030df5a1" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">&lt;code&gt;Maybe Int&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 를 적용합니다 . &lt;code&gt;Just n&lt;/code&gt; 이 있으면 기본 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 을 표시하려고합니다 . 그러나 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 이 있으면 &quot;Nothing&quot;대신 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="edd6c71ec52ff9bccf29d84188bba0b21ce69446" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6b9c8416c76cb38545167e06e3308ec9286dc30" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 참이면 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ad84cd5aa8118e1f8b36881b3b884a1d00f4857" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9745cca7883787ea648c32cd3f515d25f4cb991e" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 참이면 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="96e48ba2760c93e4e34b159d49c1dbbc56799681" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9854504f7be6e574e7bfe679f44b4ee0c6be89cc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f46147f015f62456e6f042fc1fdd0a4e456ff05" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 참이면 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d053cfa4369b1863e68c118fa964a1a17e42f125" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="21bdb9c521d1c7d41257920a997db5a1c432b4d7" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 참이면 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="83bd5f5c6340c2876e03bdf5c78f42f0045fcd17" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b00536f11c69e40c7baa6a53f5c52fe55c8806e5" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;f&lt;/code&gt;-actions in the reverse order.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 동작을 역순으로 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7fd738556716f25c4a33b181a4727d226b4c919" translate="yes" xml:space="preserve">
          <source>Apply a function to a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; token. When manually applying a function to &lt;code&gt;realWorld#&lt;/code&gt;, it is necessary to use &lt;code&gt;NOINLINE&lt;/code&gt; to prevent semantically undesirable floating. &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; is inlined, but only very late in compilation after all floating is complete.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; 토큰에 함수를 적용하십시오 . &lt;code&gt;realWorld#&lt;/code&gt; 함수를 수동으로 적용 할 때 의미 적으로 바람직하지 않은 부동을 방지 하려면 &lt;code&gt;NOINLINE&lt;/code&gt; 을 사용해야 합니다. &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; 는 인라인되지만 모든 부동이 완료된 후 컴파일에서 매우 늦습니다.</target>
        </trans-unit>
        <trans-unit id="15923e60f19aafe01135e2792144867deb99400e" translate="yes" xml:space="preserve">
          <source>Apply a function to the first element of an optional pair.</source>
          <target state="translated">옵션 쌍의 첫 번째 요소에 기능을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="a5aee8e5a78690a96a71ac571dd01657b03993bb" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the continuation passed to a CPS computation.</source>
          <target state="translated">CPS 계산에 전달 된 연속성을 변환하는 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="35e3f909c25395866110729633dad59aecf7af3c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation.</source>
          <target state="translated">연속 통과 계산 결과를 변환하는 함수를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4ff89ef704740fc048b9ba990998fdecd8670f9c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">연속 통과 계산 결과를 변환하는 함수를 적용합니다. &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 펑터를 정의하지 않기 때문에 다른 모나드 변환기에 대한 &lt;code&gt;map&lt;/code&gt; 조작 보다 유형이 제한되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4993fc434940195f4b64a80d66593316a376d43" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">연속 통과 계산 결과를 변환하는 함수를 적용합니다. &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 펑터를 정의하지 않기 때문에 다른 모나드 변환기에 대한 &lt;code&gt;map&lt;/code&gt; 조작 보다 유형이 제한되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b51211dea86c79bd6e381cda63ad155fa030e446" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation.</source>
          <target state="translated">선택 계산 결과를 변환하는 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="119d0767fcb8340ed73d84a60d5eb57b7349f3e5" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">선택 계산 결과를 변환하는 함수를 적용하십시오. &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 펑터를 정의하지 않기 때문에 다른 모나드 변환기에 대한 &lt;code&gt;map&lt;/code&gt; 조작 보다 유형이 제한되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90c1bc3308702f2e877e752823a6f576e30aa537" translate="yes" xml:space="preserve">
          <source>Apply a transformation to the other computation.</source>
          <target state="translated">다른 계산에 변환을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="6b6f2a899229fc5c6cb94a1a620e95652b86a4f6" translate="yes" xml:space="preserve">
          <source>Apply one equality to another, respectively</source>
          <target state="translated">한 평등을 다른 평등에 각각 적용</target>
        </trans-unit>
        <trans-unit id="3915aaeccbb6370f41a8ba795caff78447316b72" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;mask&lt;/code&gt; to an exception handler</source>
          <target state="translated">예외 처리기에 &lt;code&gt;mask&lt;/code&gt; 적용</target>
        </trans-unit>
        <trans-unit id="7940fbb624b272a2fc9b14574cab25dadfa00758" translate="yes" xml:space="preserve">
          <source>Applying functions of dynamic type</source>
          <target state="translated">다이나믹 타입의 기능 적용</target>
        </trans-unit>
        <trans-unit id="48a6b0961bc685e7241bda505e193149b1b6e1e7" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">임의의 정밀도 합리적인 숫자로, 두 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값 의 비율로 표시됩니다 . 유리수는 &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 연산자를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f570f682fb6c172cde8b33c6dce79b95de7ed61" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">임의의 정밀도 합리적인 숫자로, 두 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값 의 비율로 표시됩니다 . 유리수는 &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 연산자를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29a35ec82756568480404c0269911333a81119f5" translate="yes" xml:space="preserve">
          <source>Arbitrary-sized tuples</source>
          <target state="translated">임의의 크기의 튜플</target>
        </trans-unit>
        <trans-unit id="27cb7fb1af71b4cc6c9c97447cc986c742906de1" translate="yes" xml:space="preserve">
          <source>Arg</source>
          <target state="translated">Arg</target>
        </trans-unit>
        <trans-unit id="9932a4cb0405a0729daea0726dad5bca21f86edb" translate="yes" xml:space="preserve">
          <source>ArgDescr</source>
          <target state="translated">ArgDescr</target>
        </trans-unit>
        <trans-unit id="ffc2c4751c406dfe729e68e12fca79cd5235bbd5" translate="yes" xml:space="preserve">
          <source>ArgMax</source>
          <target state="translated">ArgMax</target>
        </trans-unit>
        <trans-unit id="ff6dd3f82d1ef3b64409b1d48173a3489bd3a0de" translate="yes" xml:space="preserve">
          <source>ArgMin</source>
          <target state="translated">ArgMin</target>
        </trans-unit>
        <trans-unit id="33b3818348e9a7abc5ad4f8c9119835de808618f" translate="yes" xml:space="preserve">
          <source>ArgMin, ArgMax</source>
          <target state="translated">ArgMin, ArgMax</target>
        </trans-unit>
        <trans-unit id="24257e1e26a78c97f1a7d50aeb70e00749ebb9e9" translate="yes" xml:space="preserve">
          <source>ArgOrder</source>
          <target state="translated">ArgOrder</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="6e753ec7f8245ae5fdc7a8b075baae341353e5ea" translate="yes" xml:space="preserve">
          <source>ArgumentLimit</source>
          <target state="translated">ArgumentLimit</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="41c35f0b16b9faa92a29f4ed3edbe5f0ea7a74af" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the executable</source>
          <target state="translated">실행 파일에 전달할 인수</target>
        </trans-unit>
        <trans-unit id="e1cbb100861b9948d58a53b976c856c97d398433" translate="yes" xml:space="preserve">
          <source>Arguments which look like &lt;code&gt;@foo&lt;/code&gt; will be replaced with the contents of file &lt;code&gt;foo&lt;/code&gt;. A gcc-like syntax for response files arguments is expected. This must re-constitute the argument list by doing an inverse of the escaping mechanism done by the calling-program side.</source>
          <target state="translated">&lt;code&gt;@foo&lt;/code&gt; 와 같은 인수 는 &lt;code&gt;foo&lt;/code&gt; 파일의 내용으로 대체됩니다 . 응답 파일 인수에 대한 gcc와 유사한 구문이 예상됩니다. 이것은 호출 프로그램 측이 수행하는 이스케이프 메커니즘의 역을 수행하여 인수 목록을 재구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4a70a3f41d906934cb39fa13410a07666b58dc9" translate="yes" xml:space="preserve">
          <source>ArithException</source>
          <target state="translated">ArithException</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="bb08cbe0a6134017a6f7cf472ab8010209d07a2f" translate="yes" xml:space="preserve">
          <source>Arithmetic exceptions.</source>
          <target state="translated">산술 예외.</target>
        </trans-unit>
        <trans-unit id="a9d7caa767383fc4926cd95d59576ba33ee0a3dc" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">산술 &lt;code&gt;Int&lt;/code&gt; 오버플 체크되어 &lt;code&gt;Int&lt;/code&gt; 의 모든 동작하므로, &lt;code&gt;Int&lt;/code&gt; 모듈로 2 일 &lt;sup&gt;⟨n⟩&lt;/sup&gt; ⟨n⟩는 비트의 크기 &lt;code&gt;Int&lt;/code&gt; 타입.</target>
        </trans-unit>
        <trans-unit id="202699f8498d7982cc53b20732251548a363465a" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflowoverflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">산술 &lt;code&gt;Int&lt;/code&gt; overflowoverflow위한 체크되어 &lt;code&gt;Int&lt;/code&gt; 의 모든 동작하므로, &lt;code&gt;Int&lt;/code&gt; 모듈로 2 일 &lt;sup&gt;⟨n⟩&lt;/sup&gt; ⟨n⟩는 비트의 크기 &lt;code&gt;Int&lt;/code&gt; 타입.</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">산술 연산</target>
        </trans-unit>
        <trans-unit id="3fecae258b41570e5190fa75b10edfa2c67f433e" translate="yes" xml:space="preserve">
          <source>Arithmetic shift-right operation</source>
          <target state="translated">산술 시프트 오른쪽 연산</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="a070934e81973445b297f3e432a70f43cd9eb647" translate="yes" xml:space="preserve">
          <source>Array classes</source>
          <target state="translated">배열 클래스</target>
        </trans-unit>
        <trans-unit id="1f72bc74b6f28918205f9e6e811785a34a99cae8" translate="yes" xml:space="preserve">
          <source>Array construction</source>
          <target state="translated">배열 구성</target>
        </trans-unit>
        <trans-unit id="b9be2aa72950b9c68024a84de0f4b74e90523e2c" translate="yes" xml:space="preserve">
          <source>Array in which to place the values</source>
          <target state="translated">값을 배치 할 배열</target>
        </trans-unit>
        <trans-unit id="55f55ab0f2f0b52c9ee209db3b03b78882aa29c9" translate="yes" xml:space="preserve">
          <source>Array to write from</source>
          <target state="translated">쓸 배열</target>
        </trans-unit>
        <trans-unit id="2dfdceb734024f39f314a3c0b8391586228fb921" translate="yes" xml:space="preserve">
          <source>Array#</source>
          <target state="translated">Array#</target>
        </trans-unit>
        <trans-unit id="898837d96f33bff85a3be5478164cfc6afd0eadc" translate="yes" xml:space="preserve">
          <source>ArrayArray#</source>
          <target state="translated">ArrayArray#</target>
        </trans-unit>
        <trans-unit id="592acb75a6da231d0a2a2173d588c93486db96f4" translate="yes" xml:space="preserve">
          <source>ArrayException</source>
          <target state="translated">ArrayException</target>
        </trans-unit>
        <trans-unit id="93c35e8fd0d3491f05295cbaa9fc1ec445fdc9e3" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;Storable&lt;/code&gt; things.</source>
          <target state="translated">의 배열 &lt;code&gt;Storable&lt;/code&gt; 것.</target>
        </trans-unit>
        <trans-unit id="6f11fdf73ec1f7aec4ea144e79eb109ff942b709" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements</source>
          <target state="translated">박스가없는 요소를 가진 배열</target>
        </trans-unit>
        <trans-unit id="9d7392dc546e184e07e6daaacd277a5d43a5c7da" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">박스형 요소가있는 배열. 의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 가 제공됩니다 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 특정 요소 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 등; 투시 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 전체 목록은 클래스).</target>
        </trans-unit>
        <trans-unit id="641e7befb70fe85093114258ec0852dc24a766bf" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">박싱되지 않은 요소가있는 배열. 의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 가 제공됩니다 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 특정 요소 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 등; 투시 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 전체 목록은 클래스).</target>
        </trans-unit>
        <trans-unit id="3a4758c3cc8dac2d76026d0733816741f9b21d43" translate="yes" xml:space="preserve">
          <source>Arrow</source>
          <target state="translated">Arrow</target>
        </trans-unit>
        <trans-unit id="4a7111dcaf1b4237c13ed045e218a14996e9fbe6" translate="yes" xml:space="preserve">
          <source>Arrow application</source>
          <target state="translated">화살표 응용</target>
        </trans-unit>
        <trans-unit id="e65665c0319750f55e0fe69874130a1cf6d4ed0a" translate="yes" xml:space="preserve">
          <source>Arrow keys</source>
          <target state="translated">화살표 키</target>
        </trans-unit>
        <trans-unit id="a6216e2bed8396214323ababdee0bc0041b0726d" translate="yes" xml:space="preserve">
          <source>Arrow notation (see &lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;) uses whatever &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;(|||)&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</source>
          <target state="translated">표기법 화살표 (참조 &lt;a href=&quot;#arrow-notation&quot;&gt;화살표 표기&lt;/a&gt; 대로 사용함) &lt;code&gt;arr&lt;/code&gt; , &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;app&lt;/code&gt; , &lt;code&gt;(|||)&lt;/code&gt; 및 &lt;code&gt;loop&lt;/code&gt; 기능의 범위에있다. 그러나 다른 구성과 달리 이러한 함수의 유형은 Prelude 유형과 매우 밀접하게 일치해야합니다. 세부 사항은 유동적입니다. 이것을 사용하려면 물어보십시오!</target>
        </trans-unit>
        <trans-unit id="8f1f0db1f62fbb0e92d1c7e980a5aefb808bd919" translate="yes" xml:space="preserve">
          <source>ArrowApply</source>
          <target state="translated">ArrowApply</target>
        </trans-unit>
        <trans-unit id="3c11beff8b02b8f9cbaa16ca3ab20327c65da1ba" translate="yes" xml:space="preserve">
          <source>ArrowChoice</source>
          <target state="translated">ArrowChoice</target>
        </trans-unit>
        <trans-unit id="47595fe84f8dd1e9405b5200e89860454330a77e" translate="yes" xml:space="preserve">
          <source>ArrowLoop</source>
          <target state="translated">ArrowLoop</target>
        </trans-unit>
        <trans-unit id="e45164f39602039a081dfdb414a58cdcb90fce01" translate="yes" xml:space="preserve">
          <source>ArrowMonad</source>
          <target state="translated">ArrowMonad</target>
        </trans-unit>
        <trans-unit id="31cc2db65fb67d75aaa03855c6522bc61f0c5f08" translate="yes" xml:space="preserve">
          <source>ArrowPlus</source>
          <target state="translated">ArrowPlus</target>
        </trans-unit>
        <trans-unit id="a6cef6a13748337ec64d72cbbfdef1e1d56c28ba" translate="yes" xml:space="preserve">
          <source>ArrowT</source>
          <target state="translated">ArrowT</target>
        </trans-unit>
        <trans-unit id="c5b3adde056c0b01047cb4ee63a6ade2f14b6bf6" translate="yes" xml:space="preserve">
          <source>ArrowZero</source>
          <target state="translated">ArrowZero</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="c27973de6a30851ee83300e482ede863a41f7f94" translate="yes" xml:space="preserve">
          <source>Arrows are a generalisation of monads introduced by John Hughes. For more details, see</source>
          <target state="translated">화살표는 John Hughes가 소개 한 모나드의 일반화입니다. 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="50de5e9983b77e93c151fa7abf423177ee062d7f" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 있지만, 각 단계에서의 기능 저하의 결과 엄격한.</target>
        </trans-unit>
        <trans-unit id="192565b6bc1ac3ccf6bc1023c2ebb1325b5351f9" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; 있지만, 각 단계에서의 기능 저하의 결과 엄격한.</target>
        </trans-unit>
        <trans-unit id="5af372b8d1d974d76bfe10c942fe9d73af03dd9b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;, but with the structure as the primary argument. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 하지만, 기본 인수로 구조. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa8707f2ab83f8daca8094457adcacefc1dfcf09" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; are just binary operators, one might ask what happens if the datatype has more than two constructors, or a constructor with more than two fields. The answer is simple: the operators are used several times, to combine all the constructors and fields as needed. However, users /should not rely on a specific nesting strategy/ for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; being used. The compiler is free to choose any nesting it prefers. (In practice, the current implementation tries to produce a more-or-less balanced nesting, so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 는 하나의 데이터 유형이 두 개 이상의 생성자, 또는 두 개 이상의 필드가있는 생성자가 경우 발생하는 요청할 수 있습니다, 단지 이항 연산자입니다. 답은 간단합니다. 연산자는 여러 번 사용되어 필요에 따라 모든 생성자와 필드를 결합합니다. 그러나 사용자 는 사용중인 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 에 대해 특정 중첩 전략 /에 의존해서는 안됩니다 . 컴파일러는 원하는 중첩을 자유롭게 선택할 수 있습니다. (실제로, 현재 구현에서는 다소 균형 잡힌 중첩을 생성하여 루트에서 특정 구성 요소로의 데이터 유형 구조 순회를 선형 시간이 아닌 로그로 수행 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d1abb43b60664f44000bb7f5a55f0ee83b119b80" translate="yes" xml:space="preserve">
          <source>As GHC&amp;rsquo;s compilation products don&amp;rsquo;t map perfectly onto DWARF constructs, GHC takes advantage of the extensibility of the DWARF standard to provide additional information.</source>
          <target state="translated">GHC의 컴파일 제품이 DWARF 구성에 완벽하게 매핑되지 않기 때문에 GHC는 DWARF 표준의 확장 성을 활용하여 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e35067b51e094e56d5ae4f8f876dfb483b8f92fd" translate="yes" xml:space="preserve">
          <source>As a binary semaphore &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt;, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as wait and signal.</source>
          <target state="translated">이진 세마포어로서 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt; 와, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 대기 신호있다.</target>
        </trans-unit>
        <trans-unit id="86cdad137d8956982af57685ad5fdd7f0b7b6c9c" translate="yes" xml:space="preserve">
          <source>As a consequence of the &lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;levity-polymorphic binder restriction&lt;/a&gt;, levity-polymorphic fields are disallowed in data constructors of data types declared using &lt;code&gt;data&lt;/code&gt;. However, since &lt;code&gt;newtype&lt;/code&gt; data constructor application is implemented as a coercion instead of as function application, this restriction does not apply to the field inside a &lt;code&gt;newtype&lt;/code&gt; data constructor. Thus, the type checker accepts</source>
          <target state="translated">의 결과로서 &lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;경솔 다형 바인더 제한&lt;/a&gt; , 경솔 다형 필드 데이터 유형의 데이터 생성자에서 허용되는 사용하여 선언 &lt;code&gt;data&lt;/code&gt; . 그러나 &lt;code&gt;newtype&lt;/code&gt; 데이터 생성자 응용 프로그램은 함수 응용 프로그램 대신 강제로 구현 되므로이 제한은 &lt;code&gt;newtype&lt;/code&gt; 데이터 생성자 내부의 필드에는 적용되지 않습니다 . 따라서 유형 검사기는</target>
        </trans-unit>
        <trans-unit id="e1bbfcb820033011b427f73f5d8e7b567bf9a401" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">이 법의 결과로, &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 에 대한 예 &lt;code&gt;f&lt;/code&gt; 를 만족시킬 것</target>
        </trans-unit>
        <trans-unit id="f93309e1645a680e5a41f639c6d8007d29bdfd58" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">이 법의 결과로, &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 에 대한 예 &lt;code&gt;f&lt;/code&gt; 를 만족시킬 것</target>
        </trans-unit>
        <trans-unit id="80b0e3a1e8c000dc891586ccc71861ad6328cf11" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">이 법의 결과로, &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 에 대한 예 &lt;code&gt;f&lt;/code&gt; 를 만족시킬 것</target>
        </trans-unit>
        <trans-unit id="429a16b965fd947d5a1e23ea21fc9c7acb81cf44" translate="yes" xml:space="preserve">
          <source>As a constructor</source>
          <target state="translated">생성자로서</target>
        </trans-unit>
        <trans-unit id="5d801d83cd9e0b19d834377699e0695ddc3ca42e" translate="yes" xml:space="preserve">
          <source>As a constructor with record syntax</source>
          <target state="translated">레코드 구문을 가진 생성자</target>
        </trans-unit>
        <trans-unit id="9189865da8d3692a10ab79cac723aaeb6eea7be7" translate="yes" xml:space="preserve">
          <source>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports &lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt;&lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt;&lt;/a&gt; that will warn you if you use a promoted data constructor without a preceding quote mark.</source>
          <target state="translated">편의상 GHC를 사용하면 이름이 분명 할 때 따옴표를 생략 할 수 있습니다. 그러나 우리의 경험에 따르면 따옴표는 코드를 더 쉽게 읽을 수 있고 오류가 적은 경향이 있습니다. 따라서 GHC는 &lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt; &lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt; &lt;/a&gt; 를 지원 하여 선행 인용 부호없이 승격 된 데이터 생성자를 사용하는 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="ce1486ef373f517210a834efa7f6eeb842e7f926" translate="yes" xml:space="preserve">
          <source>As a general rule, if a data type has a derived &lt;code&gt;Functor&lt;/code&gt; instance and its last type parameter occurs on the right-hand side of the data declaration, then either it must (1) occur bare (e.g., &lt;code&gt;newtype Id a = Id a&lt;/code&gt;), or (2) occur as the last argument of a type constructor (as in &lt;code&gt;Right&lt;/code&gt; above).</source>
          <target state="translated">일반적으로 데이터 유형에 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스가 있고 마지막 유형 매개 변수가 데이터 선언의 오른쪽에서 발생하는 경우 (1) 베어 발생해야합니다 (예 : &lt;code&gt;newtype Id a = Id a&lt;/code&gt; ) 또는 (2)는 형식 생성자의 마지막 인수로 발생합니다 ( &lt;code&gt;Right&lt;/code&gt; 위와 같이).</target>
        </trans-unit>
        <trans-unit id="e5b650f5b24353725153d71d0ace5287fade8a17" translate="yes" xml:space="preserve">
          <source>As a more comprehensive alternative for debugging Parsec parsers, there's also the &lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; package.</source>
          <target state="translated">Parsec 파서를 디버깅하기위한보다 포괄적 인 대안으로 &lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; 패키지도 있습니다.</target>
        </trans-unit>
        <trans-unit id="826ab8729c5c6b675ee7477d0a06b532fb5de96a" translate="yes" xml:space="preserve">
          <source>As a more substantial example of the rules in action, consider</source>
          <target state="translated">실제 규칙의보다 실질적인 예로, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8478fed6cf150b0bde8267af58280dff83b3ef83" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a frontend plugin that prints the arguments that were passed to it, and then exits.</source>
          <target state="translated">빠른 예로, 여기에 전달 된 인수를 인쇄 한 다음 종료되는 프론트 엔드 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="991de1e28384a51531170b3384f7afcc4d87ef71" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a simple plugin that just does nothing and just returns the original compilation pipeline, unmodified, and says &amp;lsquo;Hello&amp;rsquo;:</source>
          <target state="translated">간단한 예로, 여기에 아무것도하지 않고 수정되지 않은 원래 컴파일 파이프 라인을 반환하고 'Hello'라고하는 간단한 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="85bb4cc8874a7fe78368b1f43fbe3cade8bd0615" translate="yes" xml:space="preserve">
          <source>As a result of this extension, all derived instances in newtype declarations are treated uniformly (and implemented just by reusing the dictionary for the representation type), &lt;em&gt;except&lt;/em&gt;&lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Read&lt;/code&gt;, which really behave differently for the newtype and its representation.</source>
          <target state="translated">이 확장의 결과로, newtype 선언에서 파생 된 모든 인스턴스는 &lt;code&gt;Show&lt;/code&gt; 및 &lt;code&gt;Read&lt;/code&gt; 를&lt;em&gt;제외하고&lt;/em&gt; 는 newtype 및 표현에 대해 다르게 동작하는 Show 및 Read를 &lt;em&gt;제외하고&lt;/em&gt; 균일하게 처리됩니다 (그리고 표현 유형에 사전을 다시 사용하여 구현) .</target>
        </trans-unit>
        <trans-unit id="b46bedb78774bd2cc4f8ff31c4366eaf33f5bd61" translate="yes" xml:space="preserve">
          <source>As a result, it requires approximately twice as much memory as its result to construct its result. For files more than a half of available RAM in size, this may result in memory exhaustion.</source>
          <target state="translated">결과적으로 결과를 구성하려면 결과보다 약 2 배 많은 메모리가 필요합니다. 사용 가능한 RAM의 절반 이상인 파일의 경우 메모리가 소진 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e9d8d378558658c4bde3d6e6c2d01732f382a26" translate="yes" xml:space="preserve">
          <source>As a simple example of an encoding implementation, we show how to efficiently convert the following representation of mixed-data tables to an UTF-8 encoded Comma-Separated-Values (CSV) table.</source>
          <target state="translated">인코딩 구현의 간단한 예로, 다음 혼합 데이터 테이블 표현을 UTF-8로 인코딩 된 CSV (Comma-Separated-Values) 테이블로 효율적으로 변환하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ca12c18463b6879d5a860720c0092cdccee7f627" translate="yes" xml:space="preserve">
          <source>As a single extra-constraints wildcard is enough to infer any number of constraints, only one is allowed in a type signature and it should come last in the list of constraints.</source>
          <target state="translated">하나의 추가 제약 조건 와일드 카드로 여러 개의 제약 조건을 유추 할 수 있으므로 형식 서명에는 하나만 허용되며 제약 조건 목록에서 마지막에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="ba8ae9d2e67cab36cf8dbfe80e256d78b5863ef7" translate="yes" xml:space="preserve">
          <source>As a workaround, we allow to bind &lt;code&gt;(*)&lt;/code&gt; in prefix form:</source>
          <target state="translated">이 문제를 해결하기 위해 접두사 형식으로 &lt;code&gt;(*)&lt;/code&gt; 를 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b52875799ff2828c6eeb24db51f51ce6b5d35654" translate="yes" xml:space="preserve">
          <source>As always, for RTS options that take ⟨size⟩s: If the last character of ⟨size⟩ is a K or k, multiply by 1000; if an M or m, by 1,000,000; if a G or G, by 1,000,000,000. (And any wraparound in the counters is &lt;em&gt;your&lt;/em&gt; fault!)</source>
          <target state="translated">항상 그렇듯이 ⟨size⟩를 취하는 RTS 옵션의 경우 : ⟨size⟩의 마지막 문자가 K 또는 k이면 1000을 곱하십시오. M 또는 m 인 경우 1,000,000; G 또는 G 인 경우 1,000,000,000 (그리고 카운터의 모든 랩 어라운드는 &lt;em&gt;당신의&lt;/em&gt; 잘못입니다!)</target>
        </trans-unit>
        <trans-unit id="99567f4b6e834794323885b782256cd2c328ea5e" translate="yes" xml:space="preserve">
          <source>As always, type synonyms must be fully applied. You cannot, for example, write:</source>
          <target state="translated">항상 그렇듯이 유형 동의어를 완전히 적용해야합니다. 예를 들어 다음과 같이 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a64b93c54367f32283d34b8466c83c540d04226" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AS를 &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 를가 아니 어서 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 는 에서 처리 오류 무시 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 모나드에 의해 차단 될 수 없습니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 으로부터 &lt;a href=&quot;prelude&quot;&gt;서곡&lt;/a&gt; . 그러나 이것은 &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 이며 &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 함수를 사용하여 잡을 수 있습니다 . 이는 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ( &lt;a href=&quot;control-exception&quot;&gt;Control.Exception에서&lt;/a&gt; )로 추가 된 정리 계산 도 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 에서 올바르게 실행 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="7a4cafca22cd8d1a307b13e29242f4d26666e5a9" translate="yes" xml:space="preserve">
          <source>As an example of signaling an error in the error monad &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, consider a safe division function &lt;code&gt;safeDiv x y&lt;/code&gt; that returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the denominator &lt;code&gt;y&lt;/code&gt; is zero and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div`
 y)&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">오류에 오류 신호의 예 모나드으로 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; , 안전한 분할 기능을 고려 &lt;code&gt;safeDiv x y&lt;/code&gt; 반환이 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 분모 때 &lt;code&gt;y&lt;/code&gt; 는 0이고 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div` y)&lt;/code&gt; 그렇지. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c06e5fe5eaba60d194f35398d388c5324d3e8468" translate="yes" xml:space="preserve">
          <source>As an example which does &lt;em&gt;not&lt;/em&gt; work, consider</source>
          <target state="translated">작동 하지 &lt;em&gt;않는&lt;/em&gt; 예로서 , 고려하십시오</target>
        </trans-unit>
        <trans-unit id="6347b158715a28dac26c8c73ed1a2953999b56f9" translate="yes" xml:space="preserve">
          <source>As an example, consider a simple pretty-printer class &lt;code&gt;SPretty&lt;/code&gt;, which outputs pretty strings:</source>
          <target state="translated">예를 들어, 예쁜 문자열을 출력 하는 간단한 pretty-printer 클래스 &lt;code&gt;SPretty&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="522dfa47c182924ecba88bb21606211e4b6f02fd" translate="yes" xml:space="preserve">
          <source>As an example, consider the following pipeline:</source>
          <target state="translated">예를 들어 다음 파이프 라인을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="42d246ca4c667eae440bdea085741dec65a2d440" translate="yes" xml:space="preserve">
          <source>As an example, consider the type of predicate functions &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt;. One such predicate might be &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt;, which classifies integers as to whether they are negative. However, given this predicate, we can re-use it in other situations, providing we have a way to map values &lt;em&gt;to&lt;/em&gt; integers. For instance, we can use the &lt;code&gt;negative&lt;/code&gt; predicate on a person's bank balance to work out if they are currently overdrawn:</source>
          <target state="translated">예를 들어, 술어 기능의 유형을 고려 &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt; . 이러한 술어 중 하나는 &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt; 일 수 있으며, 음의 여부에 따라 정수를 분류합니다. 그러나이 술어가 주어지면 다른 상황에서 재사용하여 값 &lt;em&gt;을&lt;/em&gt; 정수 로 맵핑 할 수 있습니다 . 예를 들어, 은행 잔고에 &lt;code&gt;negative&lt;/code&gt; 술어를 사용하여 현재 초과 인출 된 경우이를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c76375fc08b8bec18373864d63325042996901b" translate="yes" xml:space="preserve">
          <source>As an example, in order to load the plugin exported by &lt;code&gt;Foo.Plugin&lt;/code&gt; in the package &lt;code&gt;foo-ghc-plugin&lt;/code&gt;, and give it the parameter &amp;ldquo;baz&amp;rdquo;, we would invoke GHC like this:</source>
          <target state="translated">예를 들어, &lt;code&gt;Foo.Plugin&lt;/code&gt; 에서 내 보낸 플러그인을 &lt;code&gt;foo-ghc-plugin&lt;/code&gt; 패키지 에로드하고 &amp;ldquo;baz&amp;rdquo;파라미터를 지정하려면 다음과 같이 GHC를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="362dc967d86ad4ea9a7d9c73fea6acc2cbd89dbf" translate="yes" xml:space="preserve">
          <source>As an example, let us look at a function &lt;code&gt;encode&lt;/code&gt; that produces a naive, but lossless bit encoding of values of various datatypes. So we are aiming to define a function</source>
          <target state="translated">예를 들어, 다양한 데이터 유형의 값에 대한 순진하지만 무손실 비트 인코딩을 생성하는 함수 &lt;code&gt;encode&lt;/code&gt; 을 살펴 보겠습니다 . 함수 정의를 목표로하고 있습니다</target>
        </trans-unit>
        <trans-unit id="33852151126c630432f1fdab8e0ba978ca5481a5" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s define an interface for a plugin system where the plugin authors are untrusted, possibly malicious third-parties. We do this by restricting the plugin interface to pure functions or to a restricted &lt;code&gt;IO&lt;/code&gt; monad that we have defined. The restricted &lt;code&gt;IO&lt;/code&gt; monad will only allow a safe subset of &lt;code&gt;IO&lt;/code&gt; actions to be executed. We define the plugin interface so that it requires the plugin module, &lt;code&gt;Danger&lt;/code&gt;, to export a single computation, &lt;code&gt;Danger.runMe&lt;/code&gt;, of type &lt;code&gt;RIO ()&lt;/code&gt;, where &lt;code&gt;RIO&lt;/code&gt; is a monad defined as follows:</source>
          <target state="translated">예를 들어, 플러그인 작성자를 신뢰할 수없는 플러그인 시스템 (악의적 인 타사)에 대한 인터페이스를 정의 해 보겠습니다. 플러그인 인터페이스를 순수 함수 또는 정의한 제한된 &lt;code&gt;IO&lt;/code&gt; 모나드 로 제한하여이를 수행합니다 . 제한된 &lt;code&gt;IO&lt;/code&gt; 모나드는 안전한 &lt;code&gt;IO&lt;/code&gt; 작업 하위 집합 만 실행할 수 있습니다. 플러그인 인터페이스 인 &lt;code&gt;Danger&lt;/code&gt; 가 &lt;code&gt;RIO ()&lt;/code&gt; 유형 의 단일 계산 &lt;code&gt;Danger.runMe&lt;/code&gt; 를 내보내 려면 플러그인 인터페이스를 정의합니다 . 여기서 &lt;code&gt;RIO&lt;/code&gt; 는 다음과 같이 정의 된 모나드입니다.</target>
        </trans-unit>
        <trans-unit id="70582809de8cd9e89c6a9bd154c02621c8e3fe1c" translate="yes" xml:space="preserve">
          <source>As an example, suppose we have following special printing module:</source>
          <target state="translated">예를 들어 다음과 같은 특수 인쇄 모듈이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6adf45b29a6631ff6d424f3a35e51b0c62f84184" translate="yes" xml:space="preserve">
          <source>As an example, suppose you read a large string, of which you need only a small portion. If you do not use &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt;, the entire original array will be kept alive in memory by the smaller string. Making a copy &quot;breaks the link&quot; to the original array, allowing it to be garbage collected if there are no other live references to it.</source>
          <target state="translated">예를 들어, 큰 문자열을 읽는데 그 중 작은 부분 만 필요하다고 가정하십시오. &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt; 를 사용하지 않으면 전체 원본 배열이 더 작은 문자열로 메모리에 유지됩니다. 복사본을 만들면 원래 배열에 대한 &quot;링크가 끊어지고&quot;다른 실제 참조가없는 경우 가비지 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d63ea3a1b75b9abed859b37118efd2bdfeda9979" translate="yes" xml:space="preserve">
          <source>As an example, this data declaration:</source>
          <target state="translated">예를 들어이 데이터 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="490082850527086dedfac3775659ee1738c0ae5d" translate="yes" xml:space="preserve">
          <source>As another example, this is the layout for the unboxed version of &lt;code&gt;Maybe a&lt;/code&gt; type, &lt;code&gt;(# (# #) | a #)&lt;/code&gt;:</source>
          <target state="translated">또 다른 예로, 이것은 박스형 버전의 &lt;code&gt;Maybe a&lt;/code&gt; 유형 &lt;code&gt;(# (# #) | a #)&lt;/code&gt; 의 레이아웃입니다 .</target>
        </trans-unit>
        <trans-unit id="18151bc795d27e140f421a3a96b2c553b0826f0d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">또 다른 예로서, 우리는 유형 고려할 수있는 &lt;code&gt;Set a&lt;/code&gt; 에 따라 데이터의 집합을 나타냅니다을 주문 의 &lt;code&gt;Ord&lt;/code&gt; 인스턴스입니다. 그것은 일반적으로 형태 보증 고려해야 할 것 동안 &lt;code&gt;a&lt;/code&gt; 역할 구상에있는 것으로, 가능성이 &lt;code&gt;newtype&lt;/code&gt; 은 하고 그것의 기본 유형이 &lt;em&gt;서로 다른&lt;/em&gt; 각각의 인코딩 된 순서, &lt;code&gt;Ord&lt;/code&gt; 인스턴스를. 이로 인해 런타임시 오작동이 발생할 수 있습니다. 따라서 &lt;code&gt;Set&lt;/code&gt; 데이터 유형 의 작성자는 해당 매개 변수가 역할 명목에 있기를 원합니다. 이것은 선언으로 이루어집니다 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e081e131ffbc4e13afc7b95b1192b51f216cb4d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">또 다른 예로서, 우리는 유형 고려할 수있는 &lt;code&gt;Set a&lt;/code&gt; 에 따라 데이터의 집합을 나타냅니다을 주문 의 &lt;code&gt;Ord&lt;/code&gt; 인스턴스입니다. 일반적으로 &lt;code&gt;a&lt;/code&gt; 를 역할 표현 으로 간주 하는 것이 형식에 안전 하지만, &lt;code&gt;newtype&lt;/code&gt; 과 기본 형식이 각각의 &lt;code&gt;Ord&lt;/code&gt; 인스턴스 에서 인코딩 된 &lt;em&gt;다른&lt;/em&gt; 순서를 가질 수 있습니다 . 이로 인해 런타임에 오작동이 발생할 수 있습니다. 따라서 &lt;code&gt;Set&lt;/code&gt; 데이터 유형 의 작성자 는 매개 변수가 역할 명목이되기를 원합니다. 이것은 선언으로 수행됩니다. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971f3c8e7fa04aa11b176990e12b0d8a905825b5" translate="yes" xml:space="preserve">
          <source>As before, only one selector function is generated here, that for &lt;code&gt;tag&lt;/code&gt;. Nevertheless, you can still use all the field names in pattern matching and record construction.</source>
          <target state="translated">이전과 마찬가지로 여기에는 &lt;code&gt;tag&lt;/code&gt; 에 대한 선택기 함수가 하나만 생성됩니다 . 그럼에도 불구하고 패턴 일치 및 레코드 구성에서 모든 필드 이름을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b294469f3600688f3c16a9375ab450bd92e329f" translate="yes" xml:space="preserve">
          <source>As before, the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag specifies that this library links against the shared library versions of the &lt;code&gt;rts&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; package. The &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; flag is required for all code that will end up in a shared library. The &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flag specifies to make a shared library rather than a program. To make this clearer we can break this down into separate compilation and link steps:</source>
          <target state="translated">이전과 같이 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 플래그는이 라이브러리가 &lt;code&gt;rts&lt;/code&gt; 및 &lt;code&gt;base&lt;/code&gt; 패키지 의 공유 라이브러리 버전과 링크되도록 지정 합니다. &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; 플래그는 공유 라이브러리에 결국 모든 코드가 필요합니다. &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; 플래그를 지정하는 공유 라이브러리가 아닌 프로그램을 확인합니다. 이를 명확하게하기 위해이를 별도의 컴파일 및 링크 단계로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7075fa9b7f0c6ece6ef586ef8232718a3c4e1adf" translate="yes" xml:space="preserve">
          <source>As channels, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as receive and send, and</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신 및 전송으로 하여 채널 로</target>
        </trans-unit>
        <trans-unit id="5f8a308216057de51dc8e2d87492c599832235ef" translate="yes" xml:space="preserve">
          <source>As described above, the way in which a file is processed by GHC depends on its suffix. This behaviour can be overridden using the &lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-x ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">위에서 설명한 것처럼 GHC에서 파일을 처리하는 방법은 접미사에 따라 다릅니다. 이 동작은 &lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-x ⟨suffix⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac41a6f7a2ba794206a1881f72e83bfc76ecc4c5" translate="yes" xml:space="preserve">
          <source>As discussed earlier, use &lt;code&gt;--&lt;/code&gt; or &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to disambiguate GHC flags when needed. For example, &lt;code&gt;-f&lt;/code&gt; is recognized by runghc, therefore to pass &lt;code&gt;-fliberate-case&lt;/code&gt; to GHC use any of the following:</source>
          <target state="translated">앞에서 설명한대로 &lt;code&gt;--&lt;/code&gt; 또는 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 를 사용하여 필요할 때 GHC 플래그를 명확하게하십시오. 예를 들어, &lt;code&gt;-f&lt;/code&gt; 는 runghc에 의해 인식되므로 &lt;code&gt;-fliberate-case&lt;/code&gt; 를 GHC 에 전달 하려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe90224af19846dad1a17ef9f898f327403d732c" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;ByteStrings&lt;/code&gt; that are slices of the original.</source>
          <target state="translated">이 라이브러리의 모든 분할 함수와 관련하여이 함수는 하위 문자열을 복사하지 않고 원본 조각 인 새 &lt;code&gt;ByteStrings&lt;/code&gt; 을 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="66418d326af7c7178dbcf345c383fa758cb34200" translate="yes" xml:space="preserve">
          <source>As for type signatures, implicit quantification happens for non-overloaded types too. So if you write this:</source>
          <target state="translated">타입 시그니처의 경우, 오버로드되지 않은 타입에 대해서도 암시 적 정량이 발생합니다. 따라서 이것을 쓰면 :</target>
        </trans-unit>
        <trans-unit id="131c4ed80f84ad7adaad005b0b251d5561f2e9bd" translate="yes" xml:space="preserve">
          <source>As iconv is missing in some minimal environments (e.g. #10298), this checks to ensure that iconv is working properly before returning the encoding, returning &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">일부 최소 환경 (예 : # 10298)에서는 iconv가 누락되므로 인코딩을 반환하기 전에 iconv가 제대로 작동하는지 확인하고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a094fb6c3fac4ea42a5b01e068a43a07a1612b8" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#define&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">적절한 &lt;code&gt;#define&lt;/code&gt; 지시문이 소스에있는 것처럼 .</target>
        </trans-unit>
        <trans-unit id="0b3a2a9b0861349d1000eb5c63f5fe83939ea7af" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#include&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">적절한 &lt;code&gt;#include&lt;/code&gt; 지시문이 소스에있는 것처럼 .</target>
        </trans-unit>
        <trans-unit id="beaf430a25d7c8a7463fc714eeb5bef652c1ca18" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2&lt;/a&gt; 의 FFI는 실제로 필요하지 않습니다. &lt;code&gt;GHC.Exts&lt;/code&gt; 에는 &lt;code&gt;ArrayArray#&lt;/code&gt; 에서 읽기위한 프리미티브가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3704be0b1f85ea495e4739ed1a37ef32e604634f" translate="yes" xml:space="preserve">
          <source>As in Haskell 98, the class hierarchy must be acyclic. However, the definition of &amp;ldquo;acyclic&amp;rdquo; involves only the superclass relationships. For example, this is okay:</source>
          <target state="translated">Haskell 98에서와 같이 클래스 계층 구조는 비 주기적이어야합니다. 그러나 &quot;비순환&quot;의 정의에는 수퍼 클래스 관계 만 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a18ecf9c948be4e27d139d19b812430b86052cfe" translate="yes" xml:space="preserve">
          <source>As in the case of existentials declared using the Haskell-98-like record syntax (&lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt;), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</source>
          <target state="translated">Haskell-98과 유사한 레코드 구문 ( &lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt; )을 사용하여 선언 된 실존의 경우와 같이 레코드 선택기 함수는 형식이 잘 지정된 선택기가있는 필드에 대해서만 생성됩니다. 다음은 GADT 스타일 구문에서 해당 섹션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e3cd19795acf719bdbdadfeb240558bb97933bfa" translate="yes" xml:space="preserve">
          <source>As kinds and types are the same, kinds can (with &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt;) contain type constraints. However, only equality constraints are supported.</source>
          <target state="translated">종류와 유형이 동일하기 때문에 종류 에는 유형 제약 조건이 포함될 수 있습니다 ( &lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; 사용&lt;/a&gt; ). 그러나 동일 제약 조건 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b688c040bfb0b19971fb0ce773edf49cba5c5c6c" translate="yes" xml:space="preserve">
          <source>As long as a type variable is constrained by one of these classes, defaulting will occur, as outlined above.</source>
          <target state="translated">유형 변수가 이러한 클래스 중 하나에 의해 제한되는 한, 위에서 설명한대로 기본값이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44161a74606a6af43d39c349f3c26f8c14875c50" translate="yes" xml:space="preserve">
          <source>As long as you are happy to only be able to link to the DLL using &lt;code&gt;GetProcAddress&lt;/code&gt; and friends, you can supply the &lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt;&lt;code&gt;-fno-shared-implib&lt;/code&gt;&lt;/a&gt; flag to disable the creation of the import library entirely.</source>
          <target state="translated">&lt;code&gt;GetProcAddress&lt;/code&gt; 및 friends를 사용하여 DLL에만 링크 할 수 있으면 가져 오기 라이브러리 작성을 완전히 사용하지 않도록 &lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt; &lt;code&gt;-fno-shared-implib&lt;/code&gt; &lt;/a&gt; 플래그를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e315249f68fda8aaff176e296d66a05a6132ca0" translate="yes" xml:space="preserve">
          <source>As mapFile, but returns ByteString</source>
          <target state="translated">mapFile과 같지만 ByteString을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a545221512e878619258ca5f17df48cfac240523" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">위에서 언급 한 바와 같이, 파생 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; GHC의 인스턴스를 구현합니다 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 . &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (및 그 사촌 인 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ) 의 기본 구현 은 단순히 후드 아래에서 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 사용 합니다. 직접 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 작성하는 경우 다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6e1afd64bce824d5669c2abf1ae7f5ca39a54331" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">위에서 언급 한 바와 같이, 파생 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; GHC의 인스턴스를 구현합니다 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 . &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (및 그 사촌 인 &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ) 의 기본 구현 은 단순히 후드 아래에서 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 사용 합니다. 직접 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 작성하는 경우 다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6a668f275f9aa656c990c93f68c69e117d56a6a9" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">위에서 언급 한 바와 같이, 파생 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; GHC의 인스턴스를 구현합니다 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 . &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (및 그 사촌 인 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ) 의 기본 구현 은 단순히 후드 아래에서 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 사용 합니다. 직접 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 작성하는 경우 다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f65b46df8fe6c264c596a4ee57c977d2fcd44935" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;, record syntax is supported. For example:</source>
          <target state="translated">&lt;a href=&quot;#gadt-style&quot;&gt;명시 적 생성자 서명으로 데이터 유형 선언&lt;/a&gt; 에서 언급 한대로 레코드 구문이 지원됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b20aa3bf540201cc843068062611e2c68e78f44" translate="yes" xml:space="preserve">
          <source>As of 1.3.5.0, the environment variable is ignored if set to a relative path, per revised XDG Base Directory Specification. See &lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;#100&lt;/a&gt;.</source>
          <target state="translated">1.3.5.0부터 수정 된 XDG 기본 디렉토리 사양에 따라 상대 경로로 설정하면 환경 변수가 무시됩니다. &lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;# 100&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="66155d480946b24160dbc04cb1009ec185e9eb15" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 로 대체되었습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d54fac1ed5477bc40ff0f48a11003303f605712" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 로 대체되었습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68bb1e4d347f7e14f0730566cfe86c41cf0cf621" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; 는 로 대체되었습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="431c3d0f7612a40f6ff5eb1278e282741242a19d" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; 는 로 대체되었습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff725c4e2000e4c32e7a70322b85a55a85f4f248" translate="yes" xml:space="preserve">
          <source>As of GHC version 6.8, we have adopted the following policy for numbering GHC versions:</source>
          <target state="translated">GHC 버전 6.8부터 GHC 버전 번호 지정에 다음 정책을 채택했습니다.</target>
        </trans-unit>
        <trans-unit id="6667e67a30d7295682c9410cb1e7f0f855d9f77a" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 4.8.0.0로, &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 은 그냥 &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; 에 전문 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="189b02d51b70039f2bb98397c33331f99f38f72e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">4.8.0.0 기준으로 &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="3ffe502c088313295fc8544881ef2e7de642be25" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0부터 &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 특화된 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="4755017eb545075e257326e642258214d89957c4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 4.8.0.0로, &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 은 그냥 &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; 에 전문 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0be1d09e17e8e02c7031393483495ad5d61f69b4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">4.8.0.0 기준으로 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="7f37649ade650085aa0f65cecdda074623b0b69e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0부터 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 특화된 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="995d3e4e58500aa9b1bd3701177a6dbe6d9b1cb8" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">4.8.0.0 기준으로 &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="0137e920b69fe62239fad821757f41940234bff2" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0부터 &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 특화된 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="63452b7c7f465acb4dded12e10643c0a80c59e1c" translate="yes" xml:space="preserve">
          <source>As of bytestring 0.9.0.3, this function is stricter than its list cousin.</source>
          <target state="translated">바이트 문자열 0.9.0.3부터이 함수는 목록 사촌보다 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="039bbe9675865514fb60ebed364f1df32b98df77" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; data structures, which have one variety of element on which an action can be performed, &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; data structures have two such varieties of elements.</source>
          <target state="translated">반대로 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 동작을 수행 할 수있는 다양한 요소 중 하나가 데이터 구조, &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; 데이터 구조는 그러한 요소의 두 종류가있다.</target>
        </trans-unit>
        <trans-unit id="1ae607bddf78967e412e95f44ed5f98b62257887" translate="yes" xml:space="preserve">
          <source>As part of the same extension, you can put kind annotations in types as well. Thus:</source>
          <target state="translated">동일한 확장의 일부로 종류에 주석을 넣을 수도 있습니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="7699c90ab29019673b3fd8db1b1767ae9771115b" translate="yes" xml:space="preserve">
          <source>As soon as GHC plus its &amp;ldquo;fellow citizens&amp;rdquo; (other processes on your machine) start using more than the &lt;em&gt;real memory&lt;/em&gt; on your machine, and the machine starts &amp;ldquo;thrashing,&amp;rdquo; &lt;em&gt;the party is over&lt;/em&gt;. Compile times will be worse than terrible! Use something like the csh builtin &lt;strong&gt;time&lt;/strong&gt; command to get a report on how many page faults you&amp;rsquo;re getting.</source>
          <target state="translated">GHC와 &quot; &lt;em&gt;중요한&lt;/em&gt; 시민&quot;(시스템의 다른 프로세스)이 시스템의 &lt;em&gt;실제 메모리&lt;/em&gt; 보다 더 많은 &lt;em&gt;메모리&lt;/em&gt; 를 사용하기 시작하면 시스템이 &quot;스 래싱&quot;을 시작 &lt;em&gt;하면 파티는 끝납니다&lt;/em&gt; . 컴파일 시간이 끔찍한 것보다 나빠질 것입니다! csh builtin &lt;strong&gt;time&lt;/strong&gt; 명령 과 같은 것을 사용하여 페이지 결함 수에 대한 보고서를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="5c65dae701ef99ffffbad1ccc118a5d026621cac" translate="yes" xml:space="preserve">
          <source>As such, &lt;code&gt;purePlugin&lt;/code&gt; is defined as a function which always returns &lt;code&gt;NoForceRecompile&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;purePlugin&lt;/code&gt; 은 항상 &lt;code&gt;NoForceRecompile&lt;/code&gt; 을 리턴하는 함수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="83c27882ec4f84c2b1c7547fee6d29bef6299680" translate="yes" xml:space="preserve">
          <source>As synchronized mutable variables,</source>
          <target state="translated">동기화 된 가변 변수로서</target>
        </trans-unit>
        <trans-unit id="8c68344402c4c848cd9948b1b997a6cdee8b6472" translate="yes" xml:space="preserve">
          <source>As text to standard output, for debugging purposes.</source>
          <target state="translated">디버깅 목적으로 텍스트를 표준 출력으로.</target>
        </trans-unit>
        <trans-unit id="181b02f4903ccd97fffcaf58addb10482aefc450" translate="yes" xml:space="preserve">
          <source>As the argument of a constructor, or type of a field, in a data type declaration. For example, any of the &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; above would be valid field type signatures.</source>
          <target state="translated">데이터 형식 선언에서 생성자 또는 필드 형식의 인수로 사용됩니다. 예를 들어, 위의 &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; 는 유효한 필드 유형 서명입니다.</target>
        </trans-unit>
        <trans-unit id="2c75efee694fce1348012a0f71a5ff8152fe1dea" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">의 이중으로 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;noneOf cs&lt;/code&gt; 성공하면 현재의 문자 &lt;em&gt;없는&lt;/em&gt; 문자의 제공된 목록에서 &lt;code&gt;cs&lt;/code&gt; . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ccb0b2bddb73f4bc8b6273e372d5253cba90fe8b" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">의 이중으로 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;noneOf cs&lt;/code&gt; 성공하면 현재의 문자 &lt;em&gt;없는&lt;/em&gt; 문자의 제공된 목록에서 &lt;code&gt;cs&lt;/code&gt; . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="595d79d9d63a7ad5c2be3b061e3dc58b00a5d260" translate="yes" xml:space="preserve">
          <source>As the type of an implicit parameter</source>
          <target state="translated">암시 적 매개 변수의 유형으로</target>
        </trans-unit>
        <trans-unit id="d153cbf6806b7b35bd0413a66f8a99b8d11cec38" translate="yes" xml:space="preserve">
          <source>As this suggests, each occurrence is replaced exactly once. So if &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;replacement&lt;/code&gt;, that occurrence will &lt;em&gt;not&lt;/em&gt; itself be replaced recursively:</source>
          <target state="translated">이것이 암시 하듯이, 각 발생은 정확히 한 번 대체됩니다. 따라서 &lt;code&gt;needle&lt;/code&gt; 이 &lt;code&gt;replacement&lt;/code&gt; 에서 발생하면 해당 발생 자체는 재귀 적으로 대체 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e53867775e4428028623be9fceee714ed0171be0" translate="yes" xml:space="preserve">
          <source>As usual, for every constructor that has a field &lt;code&gt;f&lt;/code&gt;, the type of field &lt;code&gt;f&lt;/code&gt; must be the same (modulo alpha conversion). The &lt;code&gt;Child&lt;/code&gt; constructor above shows that the signature may have a context, existentially-quantified variables, and strictness annotations, just as in the non-record case. (NB: the &amp;ldquo;type&amp;rdquo; that follows the double-colon is not really a type, because of the record syntax and strictness annotations. A &amp;ldquo;type&amp;rdquo; of this form can appear only in a constructor signature.)</source>
          <target state="translated">통상, 전계가있는 모든 생성자 &lt;code&gt;f&lt;/code&gt; , 필드의 타입 &lt;code&gt;f&lt;/code&gt; 동일해야한다 (알파 변환 모듈로). 위 의 &lt;code&gt;Child&lt;/code&gt; 생성자는 서명이 레코드가 아닌 경우와 마찬가지로 컨텍스트, 실질적으로 수량화 된 변수 및 엄격 주석을 가질 수 있음을 보여줍니다. (NB : 이중 콜론 뒤에 오는 &quot;유형&quot;은 레코드 구문 및 엄격 주석으로 인해 실제로 유형이 아닙니다.이 형식의 &quot;유형&quot;은 생성자 서명에만 나타날 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="424c7f952d5ac1aa74645c5f27a67eda13f56e6f" translate="yes" xml:space="preserve">
          <source>As usual, the meta-variables &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; etc., can be arbitrary patterns. In general, the statement &lt;code&gt;rec ss&lt;/code&gt; is desugared to the statement</source>
          <target state="translated">통상적으로, 메타-변수 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 등은 임의의 패턴 일 수있다. 일반적으로, 진술서 &lt;code&gt;rec ss&lt;/code&gt; 는 진술서 로 탈당됩니다.</target>
        </trans-unit>
        <trans-unit id="3cf1bb90d2a6c5267034d92cb3db4ce82d1bfdff" translate="yes" xml:space="preserve">
          <source>As we demonstrated earlier (&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints and inspecting variables&lt;/a&gt;), the debugger has some intelligence built-in to update the type of &lt;code&gt;f&lt;/code&gt; whenever the types of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;_result&lt;/code&gt; are discovered. So what we do in this scenario is force &lt;code&gt;x&lt;/code&gt; a bit, in order to recover both its type and the argument part of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">앞에서 설명한 것처럼 ( &lt;a href=&quot;#breakpoints&quot;&gt;브레이크 포인트 및 변수 검사&lt;/a&gt; ) 디버거에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;_result&lt;/code&gt; 유형 이 검색 될 때마다 &lt;code&gt;f&lt;/code&gt; 유형을 업데이트하기위한 일부 지능 기능이 내장 되어 있습니다 . 따라서이 시나리오에서 우리가하는 일은 그것의 타입과 &lt;code&gt;f&lt;/code&gt; 의 인수 부분을 모두 복구하기 위해 &lt;code&gt;x&lt;/code&gt; 를 조금씩하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="480449ae21e88b5153c176f83519328d5843ab58" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;re seen, arrow notation provides constructs, modelled on those for expressions, for sequencing, value recursion and conditionals. But suitable combinators, which you can define in ordinary Haskell, may also be used to build new commands out of existing ones. The basic idea is that a command defines an arrow from environments to values. These environments assign values to the free local variables of the command. Thus combinators that produce arrows from arrows may also be used to build commands from commands. For example, the &lt;code&gt;ArrowPlus&lt;/code&gt; class includes a combinator</source>
          <target state="translated">보시다시피, 화살표 표기법은 식, 시퀀싱, 값 재귀 및 조건에 대한 구문을 모델링 한 구문을 제공합니다. 그러나 일반적인 Haskell에서 정의 할 수있는 적절한 결합기를 사용하여 기존 명령으로 새 명령을 작성할 수도 있습니다. 기본 아이디어는 명령이 환경에서 값으로 화살표를 정의한다는 것입니다. 이러한 환경은 명령의 사용 가능한 로컬 변수에 값을 지정합니다. 따라서, 화살표로부터 화살표를 생성하는 콤비 네이터는 또한 커맨드로부터 커맨드를 구축하는데 사용될 수있다. 예를 들어 &lt;code&gt;ArrowPlus&lt;/code&gt; 클래스에는 결합기가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="196191205f2b62c541cf8a5ff3836b4bc01787da" translate="yes" xml:space="preserve">
          <source>As well avoid unnecessary pattern matching it also helps avoid unnecessary allocation. This applies when a argument is strict in the recursive call to itself but not on the initial entry. As strict recursive branch of the function is created similar to the above example.</source>
          <target state="translated">불필요한 패턴 일치를 피할뿐만 아니라 불필요한 할당을 피할 수 있습니다. 이는 재귀 호출 자체에서 인수가 엄격하지만 초기 항목이 아닌 경우에 적용됩니다. 함수의 엄격한 재귀 분기가 위의 예제와 유사하게 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="8c16e4471532afea529c20b4ff2e8a8a16601be0" translate="yes" xml:space="preserve">
          <source>As well in type signatures, you can also use an explicit &lt;code&gt;forall&lt;/code&gt; in an instance declaration:</source>
          <target state="translated">타입 시그니처에서도 인스턴스 선언에 명시 적 &lt;code&gt;forall&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ead26c4f8d8b65c7691881f1d8045e494c57debb" translate="yes" xml:space="preserve">
          <source>As with all known Haskell systems, GHC implements some extensions to the standard Haskell language. They can all be enabled or disabled by command line flags or language pragmas. By default GHC understands the most recent Haskell version it supports, plus a handful of extensions.</source>
          <target state="translated">모든 알려진 Haskell 시스템과 마찬가지로 GHC는 표준 Haskell 언어에 대한 일부 확장을 구현합니다. 이들은 모두 명령 행 플래그 또는 언어 pragma에 의해 활성화 또는 비활성화 될 수 있습니다. 기본적으로 GHC는 최신 Haskell 버전과 소수의 확장을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="fcd43e9a7f0adbd4e1cdcb63a469dbf86f84b840" translate="yes" xml:space="preserve">
          <source>As with ordinary variable bindings, later definitions shadow earlier ones, so you can re-enter a declaration to fix a problem with it or extend it. But there&amp;rsquo;s a gotcha: when a new type declaration shadows an older one, there might be other declarations that refer to the old type. The thing to remember is that the old type still exists, and these other declarations still refer to the old type. However, while the old and the new type have the same name, GHCi will treat them as distinct. For example:</source>
          <target state="translated">일반 변수 바인딩과 마찬가지로 이후 정의는 이전 정의를 어둡게하므로 선언을 다시 입력하여 문제를 해결하거나 확장 할 수 있습니다. 그러나 새로운 유형 선언이 이전 유형을 가리면 이전 유형을 참조하는 다른 선언이있을 수 있습니다. 기억해야 할 것은 이전 유형이 여전히 존재하고 이러한 다른 선언은 여전히 ​​이전 유형을 참조한다는 것입니다. 그러나 이전 유형과 새 유형의 이름은 동일하지만 GHCi는 해당 유형을 고유 한 것으로 취급합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="637fa52fc6437e00230d9db2fe6b3adca8d89276" translate="yes" xml:space="preserve">
          <source>As with other type signatures, you can give a single signature for several data constructors. In this example we give a single signature for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;:</source>
          <target state="translated">다른 유형 서명과 마찬가지로 여러 데이터 생성자에 단일 서명을 제공 할 수 있습니다. 이 예에서는 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 에 대한 단일 서명을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9a5d0276624512bf5b98fc03c361aa6bea31b80c" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; function, if any two associations in the list have the same index, the value at that index is implementation-dependent. (In GHC, the last value specified for that index is used. Other implementations will also do this for unboxed arrays, but Haskell 98 requires that for &lt;code&gt;Array&lt;/code&gt; the value at such indices is bottom.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 함수 와 마찬가지로 목록의 두 연관이 동일한 색인을 갖는 경우 해당 색인의 값은 구현에 따라 다릅니다. GHC에서는 해당 인덱스에 대해 지정된 마지막 값이 사용됩니다. 다른 구현에서도 언 박스형 배열에 대해서도이 작업을 수행하지만 Haskell 98에서는 &lt;code&gt;Array&lt;/code&gt; 에 대해 해당 인덱스의 값이 맨 아래에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="290e57760e517898d7b9efcc098bc5d22f645f5f" translate="yes" xml:space="preserve">
          <source>As you can guess &lt;code&gt;justOnes&lt;/code&gt; will evaluate to &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt;.</source>
          <target state="translated">당신이 추측 할 수 있듯이 &lt;code&gt;justOnes&lt;/code&gt; 는 &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="44e503436bbd1b51c2f4671a6a4bc6e7cfdbb40d" translate="yes" xml:space="preserve">
          <source>As you can see, using operators in this way is not very useful, and Haskell 98 does not even allow you to write them infix.</source>
          <target state="translated">보시다시피, 이런 식으로 연산자를 사용하는 것은 그리 유용하지 않으며 Haskell 98은 심지어 연산자를 삽입 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="67dc44d97f00c988807bcf67aa9d1c8f84fff7c6" translate="yes" xml:space="preserve">
          <source>Ascii Drawings</source>
          <target state="translated">아스키 그림</target>
        </trans-unit>
        <trans-unit id="cca21e0df87aca3b913734b67e2e333b718bae99" translate="yes" xml:space="preserve">
          <source>Ashley Yakeley &amp;lt;ashley@semantic.org&amp;gt;</source>
          <target state="translated">애슐리 야 켈리 &amp;lt;ashley@semantic.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7f327535400c99b415e9d1ddaa6d9904d1bfafa2" translate="yes" xml:space="preserve">
          <source>Ask that GHC specialize a polymorphic value to a particular type.</source>
          <target state="translated">GHC가 특정 유형에 다형성 값을 특수화하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="bc24cd3c8b6ddb112a336c5966d0506d3b2fd9ca" translate="yes" xml:space="preserve">
          <source>Assembly language (.s)</source>
          <target state="translated">조립 언어 (.s)</target>
        </trans-unit>
        <trans-unit id="d8e00d7a54a273c595978f5b3e92d75c8e0981a9" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">어설 션 오류가 발생할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; 라이브러리 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cde31a8393d46785fc228979a73996dac43391ba" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">어설 션 실패를 포착 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; 라이브러리에 대한 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="74319d6a5a4eb02ecd1401e7a9faed7d9660ea69" translate="yes" xml:space="preserve">
          <source>AssertionFailed</source>
          <target state="translated">AssertionFailed</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e8ddc914ca09e8e31648b53bc077284126a4cbdc" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">어설 션은 일반적으로 컴파일러 플래그를 사용하여 설정하거나 해제 할 수 있습니다 (GHC의 경우 &lt;code&gt;-O&lt;/code&gt; 를 사용하여 최적화를 설정하지 않거나 &lt;code&gt;-fignore-asserts&lt;/code&gt; 옵션을 지정 하지 않은 경우 일반적으로 어설 션이 설정 됨 ). 주장이 해제 될 때까지 첫 번째 인수 &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 무시되고, 두 번째 인수는 결과로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="492da7da6121915584e059d74109845fdbc2bb99" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">어설 션은 일반적으로 컴파일러 플래그를 사용하여 설정하거나 해제 할 수 있습니다 (GHC의 경우 &lt;code&gt;-O&lt;/code&gt; 를 사용하여 최적화를 설정하지 않거나 &lt;code&gt;-fignore-asserts&lt;/code&gt; 옵션을 지정 하지 않은 경우 일반적으로 어설 션이 설정 됨 ). 주장이 해제 될 때까지 첫 번째 인수 &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 무시되고, 두 번째 인수는 결과로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2a67c621ce56962ea20451247e4968660972fdfe" translate="yes" xml:space="preserve">
          <source>Assoc</source>
          <target state="translated">Assoc</target>
        </trans-unit>
        <trans-unit id="68b22545bb595a6b43f06bac583241d8e11a31a0" translate="yes" xml:space="preserve">
          <source>AssocLeft</source>
          <target state="translated">AssocLeft</target>
        </trans-unit>
        <trans-unit id="aa2f28d5f211bc5ecef78542598f880f8e318baa" translate="yes" xml:space="preserve">
          <source>AssocNone</source>
          <target state="translated">AssocNone</target>
        </trans-unit>
        <trans-unit id="56894dfcf0b1ff176191c0989a9045db04e81fe2" translate="yes" xml:space="preserve">
          <source>AssocRight</source>
          <target state="translated">AssocRight</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">관련 유형</target>
        </trans-unit>
        <trans-unit id="28d556f025319f64419ff88734b119ab1b87004b" translate="yes" xml:space="preserve">
          <source>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a &lt;code&gt;deriving&lt;/code&gt; clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;standalone deriving&lt;/code&gt;&lt;/a&gt; clause (at the top level).</source>
          <target state="translated">연관된 유형 및 데이터 인스턴스 선언은 엔 클로징 인스턴스에 지정된 컨텍스트를 상속하지 않습니다. 형식 인스턴스 선언의 경우 컨텍스트가 무엇을 의미하는지 명확하지 않습니다. 데이터 인스턴스 선언의 경우 사용자가 모든 데이터 생성자마다 컨텍스트가 반복되는 것을 원하지 않을 것입니다. 컨텍스트가 유용 할 수있는 유일한 위치 는 연관된 데이터 인스턴스 의 &lt;code&gt;deriving&lt;/code&gt; 조항에 있습니다. 그러나 여기서도 외부 인스턴스 컨텍스트의 역할은 어둡습니다. 따라서 명확성을 위해 위의 규칙을 고수합니다. 둘러싸는 인스턴스 컨텍스트는 무시됩니다. 파생 인스턴스에서 사소한 컨텍스트를 사용해야하는 경우 &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;standalone deriving&lt;/code&gt; &lt;/a&gt; 절 (최상위 수준)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="1c3f48563bf3394a3a3f951813cae0818e684494" translate="yes" xml:space="preserve">
          <source>Associativity is not used to reduce the occurrence of parentheses, although precedence may be.</source>
          <target state="translated">괄호의 발생을 줄이기 위해 연관성이 사용되지는 않지만 우선 순위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b99ff8f8291b4b50e3921986b0bce0e781dbc7e" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; to write a very simple error-reporting function that does absolutely nothing in the case of success, and outputs &quot;ERROR&quot; if any error occurred.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값이 일종의 오류를 의미 한다고 가정하면 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 를 사용 하여 성공시 전혀 아무것도하지 않는 매우 간단한 오류보고 기능을 작성하고 오류가 발생하면 &quot;ERROR&quot;를 출력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d055592ad02200007ba459bbee0ab4e26e918369" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; to write a very simple reporting function that only outputs &quot;SUCCESS&quot; when a computation has succeeded.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값이 일종의 오류를 의미 한다고 가정하면 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 를 사용 하여 계산이 성공했을 때 &quot;SUCCESS&quot;만 출력하는 매우 간단한보고 기능을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c834581788562362bcf330136a30982991522f6" translate="yes" xml:space="preserve">
          <source>Assumption: Integer is strictly positive</source>
          <target state="translated">가정 : 정수는 엄격하게 양수</target>
        </trans-unit>
        <trans-unit id="77fd17f027574bb2f7df35f4ef90ead2e9b60836" translate="yes" xml:space="preserve">
          <source>AsyncException</source>
          <target state="translated">AsyncException</target>
        </trans-unit>
        <trans-unit id="603f73055272502639dd306a8bca156dc618be89" translate="yes" xml:space="preserve">
          <source>AsyncIOAvailable</source>
          <target state="translated">AsyncIOAvailable</target>
        </trans-unit>
        <trans-unit id="e1aac0f84af1ee48fafd058955607776e453cc9b" translate="yes" xml:space="preserve">
          <source>Asynchronous Exceptions</source>
          <target state="translated">비동기 예외</target>
        </trans-unit>
        <trans-unit id="1fde34ce4b1dca7f44eebcbaf7ae6171e5ddd42a" translate="yes" xml:space="preserve">
          <source>Asynchronous exception control</source>
          <target state="translated">비동기 예외 제어</target>
        </trans-unit>
        <trans-unit id="90e8f43c2f265d7e22350697496f72118afa53f2" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions are so-called because they arise due to external influences, and can be raised at any point during execution. &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; are two examples of system-generated asynchronous exceptions.</source>
          <target state="translated">비동기 예외는 외부 영향으로 인해 발생하기 때문에 이른바 실행 중 언제라도 발생할 수 있습니다. &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; 는 시스템 생성 비동기 예외의 두 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="e9087c26270e45969905025ed0c6876268b8e459" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">마스킹 된 스레드 가 특정 방식으로 &lt;em&gt;차단&lt;/em&gt; 되면 마스킹 된 상태에서 비동기 예외가 계속 수신 될 수 있습니다 . &lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="303a11aed286b513643b565c89072a6a7aa3770b" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">마스킹 된 스레드 가 특정 방식으로 &lt;em&gt;차단&lt;/em&gt; 되는 경우 마스킹 된 상태에있는 동안 비동기 예외가 계속 수신 될 수 있습니다 . &lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c6f92d83ff3d5f34604121aadc15840ac708368" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">마스킹 된 스레드 가 특정 방식으로 &lt;em&gt;차단&lt;/em&gt; 되면 마스킹 된 상태에서 비동기 예외가 계속 수신 될 수 있습니다 . &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="631cd36315ff03e677e0243fa4a94f4335edad65" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions.</source>
          <target state="translated">비동기 예외.</target>
        </trans-unit>
        <trans-unit id="de23bf55d43f3cb1369402e7877d3faa61f2949f" translate="yes" xml:space="preserve">
          <source>At a function call, GHC takes the stack stored in the function being called (which for a top-level function will be empty), and &lt;em&gt;appends&lt;/em&gt; it to the current stack, ignoring any prefix that is identical to a prefix of the current stack.</source>
          <target state="translated">함수 호출에서 GHC는 호출되는 함수에 저장된 스택 (최상위 함수의 경우 비어 있음)을 가져 와서 현재 스택의 접두사와 동일한 접두사를 무시하고 현재 스택에 &lt;em&gt;추가&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bb19257a1286f9e500a61c5dfeacaecfe019ec79" translate="yes" xml:space="preserve">
          <source>At any time you can use the command &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt; to get a list of the modules currently loaded into GHCi:</source>
          <target state="translated">언제든지 &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 현재 GHCi에로드 된 모듈 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3461cf3addc608aea10037826585d0df504e072e" translate="yes" xml:space="preserve">
          <source>At definition site, the arity determines what inputs can be matched on:</source>
          <target state="translated">정의 사이트에서 arity는 일치 할 수있는 입력을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cc7e513d6fe875bf90b4a728f124a7f9ff012de2" translate="yes" xml:space="preserve">
          <source>At first blush, &lt;code&gt;UnEx&lt;/code&gt; seems poorly-kinded. The return kind &lt;code&gt;k&lt;/code&gt; is not mentioned in the arguments, and thus it would seem that an instance would have to return a member of &lt;code&gt;k&lt;/code&gt;&lt;em&gt;for any&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, this is not the case. The type family &lt;code&gt;UnEx&lt;/code&gt; is a kind-indexed type family. The return kind &lt;code&gt;k&lt;/code&gt; is an implicit parameter to &lt;code&gt;UnEx&lt;/code&gt;. The elaborated definitions are as follows (where implicit parameters are denoted by braces):</source>
          <target state="translated">언뜻보기에 &lt;code&gt;UnEx&lt;/code&gt; 는 좋지 않은 것 같습니다. 반환 종류 &lt;code&gt;k&lt;/code&gt; 는 인수에 언급되어 있지 않으므로 인스턴스가 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;에 대해 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 멤버를 반환해야 할 것 같습니다 . 그러나 그렇지 않습니다. 유형 군 &lt;code&gt;UnEx&lt;/code&gt; 는 종류별로 분류 된 유형 군입니다. 반환 종류 &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;UnEx&lt;/code&gt; 에 대한 암시 적 매개 변수 입니다. 정교한 정의는 다음과 같습니다 (암시 적 매개 변수는 중괄호로 표시됨).</target>
        </trans-unit>
        <trans-unit id="082a6d8510562c71bea9da704521358ac4884d2e" translate="yes" xml:space="preserve">
          <source>At least one of the classes &lt;code&gt;Ci&lt;/code&gt; is numeric.</source>
          <target state="translated">클래스 &lt;code&gt;Ci&lt;/code&gt; 중 적어도 하나 는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="da4d3ab8aa4bf1c457aa64eadbb0f7599f12c862" translate="yes" xml:space="preserve">
          <source>At least one overlapped instance, &lt;code&gt;Iy&lt;/code&gt;, is both:</source>
          <target state="translated">하나 이상의 겹친 인스턴스 &lt;code&gt;Iy&lt;/code&gt; 는 둘 다입니다.</target>
        </trans-unit>
        <trans-unit id="95b0afae80408c0a928a6ff24b58dae9588bff21" translate="yes" xml:space="preserve">
          <source>At present, &lt;code&gt;-O2&lt;/code&gt; is nearly indistinguishable from &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;-O2&lt;/code&gt; 는 &lt;code&gt;-O&lt;/code&gt; 와 거의 구별 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2d06e4b175297e1faf1e01c3741923b7d7eb11e9" translate="yes" xml:space="preserve">
          <source>At present, GHC is quite limited in its reasoning about arithmetic: it will only evaluate the arithmetic type functions and compare the results&amp;mdash; in the same way that it does for any other type function. In particular, it does not know more general facts about arithmetic, such as the commutativity and associativity of &lt;code&gt;(+)&lt;/code&gt;, for example.</source>
          <target state="translated">현재 GHC는 산술에 대한 추론이 상당히 제한되어 있습니다. 다른 유형 함수와 동일한 방식으로 산술 형식 함수 만 평가하고 결과를 비교합니다. 특히, 예를 들어 &lt;code&gt;(+)&lt;/code&gt; 의 commutativity 및 associativity와 같은 산술에 대한 더 일반적인 사실을 알지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="14a75af6823b475d201cdaf02b67cfc7b30f5d3d" translate="yes" xml:space="preserve">
          <source>At runtime, whenever a term containing a type error would need to be evaluated, the error is converted into a runtime exception of type &lt;code&gt;TypeError&lt;/code&gt;. Note that type errors are deferred as much as possible during runtime, but invalid coercions are never performed, even when they would ultimately result in a value of the correct type. For example, given the following code:</source>
          <target state="translated">런타임시, 유형 오류가 포함 된 용어를 평가해야 할 때마다 오류는 &lt;code&gt;TypeError&lt;/code&gt; 유형의 런타임 예외로 변환됩니다 . 런타임 중에는 유형 오류가 가능한 한 많이 지연되지만 결과적으로 올바른 유형의 값을 초래하더라도 유효하지 않은 강제 변환은 수행되지 않습니다. 예를 들어 다음 코드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1e7a17deca9b74f37ec0a39800ad357611600d" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt you can also enter any top-level Haskell declaration, including &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;newtype&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;instance&lt;/code&gt;, &lt;code&gt;deriving&lt;/code&gt;, and &lt;code&gt;foreign&lt;/code&gt; declarations. For example:</source>
          <target state="translated">GHCi 프롬프트에서 &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;newtype&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;instance&lt;/code&gt; , &lt;code&gt;deriving&lt;/code&gt; 및 &lt;code&gt;foreign&lt;/code&gt; 선언을 포함한 최상위 Haskell 선언을 입력 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd0949a6c29925c12d1d048d17633d245e1a3ebf" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt, or with GHC if the &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; flag is given, the types are instead resolved with the following method:</source>
          <target state="translated">GHCi 프롬프트에서 또는 &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt; 플래그가 제공되는 경우 GHC를 사용 하여 유형은 대신 다음 방법으로 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="faae2aa7c10c0885466c17a8edd2f6d0318681f4" translate="yes" xml:space="preserve">
          <source>At the end of the sample period the &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; event if emitted. This is useful to properly delimit the sampling period and to record the total time spent profiling.</source>
          <target state="translated">샘플 기간이 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; 이벤트가 발생합니다. 이는 샘플링 기간을 적절하게 구분하고 프로파일 링에 소요 된 총 시간을 기록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="af7cac97440198fcc962770e0f96df4e013c2492" translate="yes" xml:space="preserve">
          <source>At the moment, the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command doesn&amp;rsquo;t support any kind of quoting in its arguments: quotes will not be removed and cannot be used to group words together. For example, &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; will not do what you expect.</source>
          <target state="translated">현재 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 명령은 인수에서 어떤 종류의 따옴표도 지원하지 않습니다. 따옴표는 제거되지 않으며 단어를 함께 그룹화하는 데 사용할 수 없습니다. 예를 들어, &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; 는 예상 한대로 작동 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82ba5640e0de386d6cc85d3de209bb9cdb633f12" translate="yes" xml:space="preserve">
          <source>At the moment, the only way to specify a dependency on a plugin in Cabal is to put it in &lt;code&gt;build-depends&lt;/code&gt; (which uses the conventional &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flag); however, in the future there will be a separate field for specifying plugin dependencies specifically.</source>
          <target state="translated">현재 Cabal의 플러그인에 의존성을 지정하는 유일한 방법은 &lt;code&gt;build-depends&lt;/code&gt; (전통적인 &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 플래그를 사용)에 넣는 것입니다 . 그러나 앞으로는 플러그인 종속성을 구체적으로 지정하기위한 별도의 필드가있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="36f6fc6a8b5e23e239eeef3e4a0f085a44f79d37" translate="yes" xml:space="preserve">
          <source>At use sites, the arity determines if the definition can be used in a higher-rank scenario:</source>
          <target state="translated">사용 사이트에서 arity는 더 높은 순위의 시나리오에서 정의를 사용할 수 있는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7f078fc66826e48322f51a990469bfd247658746" translate="yes" xml:space="preserve">
          <source>Atomic blocks.</source>
          <target state="translated">원자 블록.</target>
        </trans-unit>
        <trans-unit id="92c10450c672866027afd2c75b1a19f1a5daa4db" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용에 함수를 원자 적으로 적용 하고 이전 값과 새 값을 반환합니다. 기능의 결과는 강요됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8c029e8fddf8615e7bdb4f7438b3feba64ae42" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is not forced. As this can lead to a memory leak, it is usually better to use &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용에 함수를 원자 적으로 적용 하고 이전 값과 새 값을 반환합니다. 기능의 결과는 강요되지 않습니다. 메모리 누수가 발생할 수 있으므로 일반적으로 &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="420f4999cbf62263237bdbe7d15cefd4576bc583" translate="yes" xml:space="preserve">
          <source>Atomically modifies the contents of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용을 원자 적으로 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="5976845b8f84b952ac2fc7192f0a75f69d2927f0" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원자 적으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cee328d42a656c88f81a24f4db1782769f19c73" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 원자 적으로 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 수신을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="be6bc09ee654abc40df66bc414fa4a9c12171cb5" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원자 적으로 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="23386c18719208e0c4d15b8720f6d737027a0291" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원자 적으로 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d13722b70b72345abf719add29b1a51d34aad57" translate="yes" xml:space="preserve">
          <source>Atomically replace the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, returning the old contents.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용을 원자 적으로 대체하여 이전 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ab5a0a6f732e3010e4b8d4b1f44a6fc68552e9b" translate="yes" xml:space="preserve">
          <source>Attach a timeout event to arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">임의의 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산에 시간 초과 이벤트를 첨부하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb303f555c293bc6ebb398fedf551b67ed2ee6e1" translate="yes" xml:space="preserve">
          <source>Attach an annotation to a document.</source>
          <target state="translated">문서에 주석을 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="83a56249e5cff48f561d2d725143f1fc2eb3228c" translate="yes" xml:space="preserve">
          <source>Attachment</source>
          <target state="translated">Attachment</target>
        </trans-unit>
        <trans-unit id="6771ade6e8965a499bc298107ffb52e9a18dd7e3" translate="yes" xml:space="preserve">
          <source>Attachments</source>
          <target state="translated">Attachments</target>
        </trans-unit>
        <trans-unit id="14c3e18c8fd88ff49a30c3e7b04045a40e92e438" translate="yes" xml:space="preserve">
          <source>Attempt to allocate a compact block with the given size (in bytes, given by the first argument). The &lt;code&gt;Addr#&lt;/code&gt; is a pointer to previous block of the compact or &lt;code&gt;nullAddr#&lt;/code&gt; to create a new compact.</source>
          <target state="translated">주어진 크기 (첫 번째 인수가 제공 한 바이트)로 컴팩트 블록을 할당하려고합니다. &lt;code&gt;Addr#&lt;/code&gt; 소형 또는 이전 블록에 대한 포인터입니다 &lt;code&gt;nullAddr#&lt;/code&gt; 새로운 소형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aa6f2a111a7ae3d1c85ad97bb0176dbe687d1c3" translate="yes" xml:space="preserve">
          <source>Attempt to convert an &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type &lt;code&gt;a&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type &lt;code&gt;b&lt;/code&gt; using the size of the types as measured by &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; methods.</source>
          <target state="translated">변환하려고 시도 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 형 &lt;code&gt;a&lt;/code&gt; 내지 An &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 타입 &lt;code&gt;b&lt;/code&gt; 를 에 의해 측정 한 종류의 사이즈 사용 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="eb6ccc5388b3a3515cdd4a9fde980934200b5b13" translate="yes" xml:space="preserve">
          <source>Attempt to ignore and recover if an illegal sequence is encountered</source>
          <target state="translated">잘못된 시퀀스가 ​​발생하면 무시하고 복구하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1dd801e8dde9f614ee3cf534bfcd9bf71825677c" translate="yes" xml:space="preserve">
          <source>Attempt to lock the semaphore without blocking. Immediately return False if it is not available.</source>
          <target state="translated">차단하지 않고 세마포어를 잠그려고합니다. 사용할 수없는 경우 즉시 False를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="5ce185b0aec3184ea8d85cd399f6b27591eecf61" translate="yes" xml:space="preserve">
          <source>Attempt to perform the given action, silencing any IO exception thrown by it.</source>
          <target state="translated">지정된 조치를 수행하여 처리 된 IO 예외를 침묵 시키십시오.</target>
        </trans-unit>
        <trans-unit id="95eba1f265744c575faabec4b145e9a698745932" translate="yes" xml:space="preserve">
          <source>Attempts to reload the current target set (see &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;) if any of the modules in the set, or any dependent module, has changed. Note that this may entail loading new modules, or dropping modules which are no longer indirectly required by the target.</source>
          <target state="translated">세트 의 모듈 또는 종속 모듈이 변경된 경우 현재 대상 세트를 다시로드하려고합니다 ( &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 참조 ). 이를 위해서는 새로운 모듈을로드하거나 대상에서 더 이상 간접적으로 요구하지 않는 모듈을 떨어 뜨릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db06067c8f8d76e8b68fa4b9186a9b50479a85d3" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the specified process. This function should not be used under normal circumstances - no guarantees are given regarding how cleanly the process is terminated. To check whether the process has indeed terminated, use &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 프로세스를 종료하려고 시도합니다. 이 기능은 정상적인 상황에서는 사용하지 않아야합니다. 프로세스가 얼마나 깨끗하게 종료되는지에 대한 보장은 없습니다. 프로세스가 실제로 종료되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="c4b6f77c88d20ca04f9a50aec205f45262f5d7ab" translate="yes" xml:space="preserve">
          <source>Attributes in XHTML Strict</source>
          <target state="translated">XHTML Strict의 속성</target>
        </trans-unit>
        <trans-unit id="16128ba0c9d08bb0dde15482b5b394897473b886" translate="yes" xml:space="preserve">
          <source>Attributes of I/O errors</source>
          <target state="translated">I / O 오류의 속성</target>
        </trans-unit>
        <trans-unit id="1360a6d5f84dba15e5314081238a2fd3066ee932" translate="yes" xml:space="preserve">
          <source>Attributes with name and value.</source>
          <target state="translated">이름과 값이있는 속성</target>
        </trans-unit>
        <trans-unit id="993065bb1a56fd21869c669ca617b04976cb0030" translate="yes" xml:space="preserve">
          <source>Author: Ben Gamari</source>
          <target state="translated">저자 : 벤 가마리</target>
        </trans-unit>
        <trans-unit id="75c4b805a306f8a99221f82ad1e776dcaee1276b" translate="yes" xml:space="preserve">
          <source>Authors importing this module are expected to track development closely.</source>
          <target state="translated">이 모듈을 가져 오는 작성자는 개발을 면밀히 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac440c0ee95ad46797ff526e4fa32c25032310cf" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all CAFs</source>
          <target state="translated">모든 CAF에 &lt;code&gt;SCC&lt;/code&gt; 를 자동 추가</target>
        </trans-unit>
        <trans-unit id="3e6d90a8087bfbc9d56637d926baaee06bb11b50" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all bindings not marked INLINE</source>
          <target state="translated">INLINE으로 표시되지 않은 모든 바인딩 에 &lt;code&gt;SCC&lt;/code&gt; \ s 자동 추가</target>
        </trans-unit>
        <trans-unit id="926781921f42c31bb0687106a4a150bb577b974e" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all call sites</source>
          <target state="translated">모든 통화 사이트에 &lt;code&gt;SCC&lt;/code&gt; 를 자동 추가</target>
        </trans-unit>
        <trans-unit id="aba3425843f29781a7a8d03a07af127ba3b7b9b2" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all exported bindings not marked INLINE</source>
          <target state="translated">INLINE으로 표시되지 않은 모든 내 보낸 바인딩 에 &lt;code&gt;SCC&lt;/code&gt; 를 자동 추가</target>
        </trans-unit>
        <trans-unit id="f39d1b641099009478c941384a7ddb92d9adc118" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all top-level bindings not marked INLINE</source>
          <target state="translated">INLINE으로 표시되지 않은 모든 최상위 바인딩 에 &lt;code&gt;SCC&lt;/code&gt; 를 자동 추가</target>
        </trans-unit>
        <trans-unit id="fc392ab09cabed566e31abcea7714e1a9fbd59f8" translate="yes" xml:space="preserve">
          <source>AutoDeriveTypeable</source>
          <target state="translated">AutoDeriveTypeable</target>
        </trans-unit>
        <trans-unit id="0f3997661b5230a1d4a29603d354a226f203caa0" translate="yes" xml:space="preserve">
          <source>Automatically enable compacting collection when the live data exceeds ⟨n⟩% of the maximum heap size (see the &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt; option). Note that the maximum heap size is unlimited by default, so this option has no effect unless the maximum heap size is set with &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">라이브 데이터가 최대 힙 크기의 ⟨n⟩ %를 초과하면 압축 수집을 자동으로 활성화합니다 ( &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt; 옵션 참조 ). 최대 힙 크기는 기본적으로 무제한이므로 최대 힙 크기가 &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt; 로 설정되어 있지 않으면이 옵션이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6deb87b596d87ecee88f79fe651652c552010dcc" translate="yes" xml:space="preserve">
          <source>Available on &lt;code&gt;base &amp;gt;=4.9&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;base &amp;gt;=4.9&lt;/code&gt; 에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="5e4e7aa329cbbf38ad0669fe65c87a2d764ac59f" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.13.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.13.0.0/prelude#t:Read&quot;&gt;Prelude를&lt;/a&gt; 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ace826e18102f6899794ad3ef89b5a4cafb9c1c" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.14.1.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.14.1.0/prelude#t:Read&quot;&gt;Prelude를&lt;/a&gt; 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca874deaab16366191c7957785eea44d50d3a744" translate="yes" xml:space="preserve">
          <source>B0</source>
          <target state="translated">B0</target>
        </trans-unit>
        <trans-unit id="8fa6afc648cb35f98b314ec87af904a1320a565f" translate="yes" xml:space="preserve">
          <source>B110</source>
          <target state="translated">B110</target>
        </trans-unit>
        <trans-unit id="69983106476a1baa3e173eb0da9525d4e05a1e94" translate="yes" xml:space="preserve">
          <source>B115200</source>
          <target state="translated">B115200</target>
        </trans-unit>
        <trans-unit id="63db1d5e1025a5dca03dde90aaee4ab1689048ef" translate="yes" xml:space="preserve">
          <source>B1200</source>
          <target state="translated">B1200</target>
        </trans-unit>
        <trans-unit id="e74b06339c34831ce0b9ab483e8c8a61a8068208" translate="yes" xml:space="preserve">
          <source>B134</source>
          <target state="translated">B134</target>
        </trans-unit>
        <trans-unit id="a9905f37be71ad27b06428c2ae3de56996c96c7e" translate="yes" xml:space="preserve">
          <source>B150</source>
          <target state="translated">B150</target>
        </trans-unit>
        <trans-unit id="966d5ab4ced9ae0785e30c1280734e03950b8b43" translate="yes" xml:space="preserve">
          <source>B1800</source>
          <target state="translated">B1800</target>
        </trans-unit>
        <trans-unit id="e535913533dad54a5814041ea8ecb91d9eeccbc1" translate="yes" xml:space="preserve">
          <source>B19200</source>
          <target state="translated">B19200</target>
        </trans-unit>
        <trans-unit id="559bc674c0bef2843ad28f3b0807a3bc8c3a905e" translate="yes" xml:space="preserve">
          <source>B200</source>
          <target state="translated">B200</target>
        </trans-unit>
        <trans-unit id="8b9d4b133283a998a17790c5482a1a7e5ea5ef89" translate="yes" xml:space="preserve">
          <source>B2400</source>
          <target state="translated">B2400</target>
        </trans-unit>
        <trans-unit id="1100370c026795a2ba481e6ed685267255662a5a" translate="yes" xml:space="preserve">
          <source>B300</source>
          <target state="translated">B300</target>
        </trans-unit>
        <trans-unit id="967e9e4821f80944c4a011159dea85581127b02d" translate="yes" xml:space="preserve">
          <source>B38400</source>
          <target state="translated">B38400</target>
        </trans-unit>
        <trans-unit id="3e5bbebbfb2d76d5eb4a77c12b899a53cb0e824b" translate="yes" xml:space="preserve">
          <source>B4800</source>
          <target state="translated">B4800</target>
        </trans-unit>
        <trans-unit id="70e67f1d5a37cf067a56baf4ce16e1420d5e3b02" translate="yes" xml:space="preserve">
          <source>B50</source>
          <target state="translated">B50</target>
        </trans-unit>
        <trans-unit id="763970e59e7e204186ab4318ebc79d0aad573df8" translate="yes" xml:space="preserve">
          <source>B57600</source>
          <target state="translated">B57600</target>
        </trans-unit>
        <trans-unit id="e41fa1e36cc5ce5485a1da88669ebf6c181b64fc" translate="yes" xml:space="preserve">
          <source>B600</source>
          <target state="translated">B600</target>
        </trans-unit>
        <trans-unit id="0a96b59160d52c4d3a94a14b630cd642e970d726" translate="yes" xml:space="preserve">
          <source>B75</source>
          <target state="translated">B75</target>
        </trans-unit>
        <trans-unit id="38ed67ee58867b1ed339e07a0a0e350aefba9899" translate="yes" xml:space="preserve">
          <source>B9600</source>
          <target state="translated">B9600</target>
        </trans-unit>
        <trans-unit id="d9004f19dea2dc973e0d147f71242cc2bebca3f3" translate="yes" xml:space="preserve">
          <source>BCO#</source>
          <target state="translated">BCO#</target>
        </trans-unit>
        <trans-unit id="d387e5e412686186588f12198f87a79c11ecf2f3" translate="yes" xml:space="preserve">
          <source>BLACK STAR</source>
          <target state="translated">검은 별</target>
        </trans-unit>
        <trans-unit id="292c7af4fff95bcd09dba6dcdd4b5f6d636b95c8" translate="yes" xml:space="preserve">
          <source>BOOL</source>
          <target state="translated">BOOL</target>
        </trans-unit>
        <trans-unit id="42c5e705983ae56cd93e4c5f6314e815eb160593" translate="yes" xml:space="preserve">
          <source>BSD-style</source>
          <target state="translated">BSD-style</target>
        </trans-unit>
        <trans-unit id="9332433de0ed1632f2bcc6d0a44e38c2f119263d" translate="yes" xml:space="preserve">
          <source>BSD-style (see LICENSE)</source>
          <target state="translated">BSD 스타일 (라이센스 참조)</target>
        </trans-unit>
        <trans-unit id="44f04e5b329f5940c142f534423ac2c4e47a1a2d" translate="yes" xml:space="preserve">
          <source>BSD-style (see the LICENSE file in the distribution)</source>
          <target state="translated">BSD 스타일 (배포판의 LICENSE 파일 참조)</target>
        </trans-unit>
        <trans-unit id="c6ca990beea2501ec303342859beced421c42eb6" translate="yes" xml:space="preserve">
          <source>BSD-style (see the LICENSE file)</source>
          <target state="translated">BSD 스타일 (LICENSE 파일 참조)</target>
        </trans-unit>
        <trans-unit id="965d82d9479d90e4c8debb630580bf0a1b1ba92f" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file LICENSE in this distribution)</source>
          <target state="translated">BSD 스타일 (이 배포판의 LICENSE 파일 참조)</target>
        </trans-unit>
        <trans-unit id="768626facad260a6f891ec7130589a5f3309d501" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file LICENSE)</source>
          <target state="translated">BSD 스타일 (라이센스 파일 참조)</target>
        </trans-unit>
        <trans-unit id="81e1671a0b4eeb6f499727101f56c68023874e7f" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file libraries/base/LICENSE)</source>
          <target state="translated">BSD 스타일 (파일 라이브러리 / base / LICENSE 참조)</target>
        </trans-unit>
        <trans-unit id="ef57f6a3a070b95b64e77f5a36de3561ef544d65" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file libraries/parsec/LICENSE)</source>
          <target state="translated">BSD 스타일 (파일 라이브러리 / parsec / LICENSE 참조)</target>
        </trans-unit>
        <trans-unit id="19a47f35c441c8dd2576f588079955402fb90b82" translate="yes" xml:space="preserve">
          <source>BSD3</source>
          <target state="translated">BSD3</target>
        </trans-unit>
        <trans-unit id="7f9c1e64342b8d68000ad605b095d79dad9a02d3" translate="yes" xml:space="preserve">
          <source>BSD3-style (see LICENSE)</source>
          <target state="translated">BSD3 스타일 (라이센스 참조)</target>
        </trans-unit>
        <trans-unit id="1d7caa593761d5e9b3a933c7c28bf276e5fe0725" translate="yes" xml:space="preserve">
          <source>BYTE</source>
          <target state="translated">BYTE</target>
        </trans-unit>
        <trans-unit id="c6d4a87dd731399addc42bfa4639f9363a8c4260" translate="yes" xml:space="preserve">
          <source>BY_HANDLE_FILE_INFORMATION</source>
          <target state="translated">BY_HANDLE_FILE_INFORMATION</target>
        </trans-unit>
        <trans-unit id="80ed9fd98b57c91f78562ce126c39ae7b67ed567" translate="yes" xml:space="preserve">
          <source>Back-quotes work as for expressions, both for type constructors and type variables; e.g. &lt;code&gt;Int `Either` Bool&lt;/code&gt;, or &lt;code&gt;Int `a` Bool&lt;/code&gt;. Similarly, parentheses work the same; e.g. &lt;code&gt;(:*:) Int Bool&lt;/code&gt;.</source>
          <target state="translated">역 따옴표는 형식 생성자와 형식 변수 모두에 대해 식과 같이 작동합니다. 예를 들어 &lt;code&gt;Int `Either` Bool&lt;/code&gt; 또는 Int`a` &lt;code&gt;Int `a` Bool&lt;/code&gt; 입니다. 마찬가지로 괄호도 동일하게 작동합니다. 예 : &lt;code&gt;(:*:) Int Bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe2ff7fc27afe7d547b5eb980ad60a5d316a61a8" translate="yes" xml:space="preserve">
          <source>Background: some systems have a Non-Uniform Memory Architecture, whereby main memory is split into banks which are &amp;ldquo;local&amp;rdquo; to specific CPU cores. Accessing local memory is faster than accessing remote memory. The OS provides APIs for allocating local memory and binding threads to particular CPU cores, so that we can ensure certain memory accesses are using local memory.</source>
          <target state="translated">배경 : 일부 시스템에는 비 균일 메모리 아키텍처가있어 주 메모리는 특정 CPU 코어에 &quot;로컬&quot;인 뱅크로 분할됩니다. 로컬 메모리에 액세스하는 것이 원격 메모리에 액세스하는 것보다 빠릅니다. OS는 로컬 메모리를 할당하고 스레드를 특정 CPU 코어에 바인딩하는 API를 제공하므로 특정 메모리 액세스가 로컬 메모리를 사용하고 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72bac718669114015a5f4f323dbfd19315cc9c1e" translate="yes" xml:space="preserve">
          <source>BackgroundWriteInterrupt</source>
          <target state="translated">BackgroundWriteInterrupt</target>
        </trans-unit>
        <trans-unit id="95e848a0c727105f2393d59e2c3843e625c17c16" translate="yes" xml:space="preserve">
          <source>Backwards</source>
          <target state="translated">Backwards</target>
        </trans-unit>
        <trans-unit id="13be7afef8413dabb18fb208bcddc8487eccc989" translate="yes" xml:space="preserve">
          <source>Bang</source>
          <target state="translated">Bang</target>
        </trans-unit>
        <trans-unit id="8c8ebd2c416a792dfc576bb10ca4e468125c1a6e" translate="yes" xml:space="preserve">
          <source>Bang patterns (&lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;) makes pattern matching and let bindings stricter.</source>
          <target state="translated">Bang 패턴 ( &lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt; )은 패턴을 일치시키고 바인딩을보다 엄격하게합니다.</target>
        </trans-unit>
        <trans-unit id="5ec90a9a17a2969ccda25430595be20a569e3fe9" translate="yes" xml:space="preserve">
          <source>Bang patterns and strict matching do not affect the type system in any way.</source>
          <target state="translated">뱅 패턴 및 엄격한 일치는 어떤 식 으로든 형식 시스템에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4331913421f3f413f4d723cb7bf92c5118afdbaf" translate="yes" xml:space="preserve">
          <source>Bang patterns work in &lt;code&gt;case&lt;/code&gt; expressions too, of course:</source>
          <target state="translated">플레이 패턴에서 일하는 &lt;code&gt;case&lt;/code&gt; 물론, 너무 표현 :</target>
        </trans-unit>
        <trans-unit id="50466cee465187abc9af9cab7155eae9f7c01b4f" translate="yes" xml:space="preserve">
          <source>BangPatterns</source>
          <target state="translated">BangPatterns</target>
        </trans-unit>
        <trans-unit id="23753b97b7d02a9e0370366e9fbeda13137a82c9" translate="yes" xml:space="preserve">
          <source>BangQ</source>
          <target state="translated">BangQ</target>
        </trans-unit>
        <trans-unit id="48d652eba9b41d0c825ca713155f565dc1ca77d2" translate="yes" xml:space="preserve">
          <source>BangType</source>
          <target state="translated">BangType</target>
        </trans-unit>
        <trans-unit id="b5159683817a7c6e14cfc2ce8186bac739ef41b1" translate="yes" xml:space="preserve">
          <source>BangTypeQ</source>
          <target state="translated">BangTypeQ</target>
        </trans-unit>
        <trans-unit id="b97a50336dc10f904675fe44fbb4e1e0f9f62610" translate="yes" xml:space="preserve">
          <source>Bart Massey &amp;lt;bart@cs.pdx.edu&amp;gt;</source>
          <target state="translated">바트 매시 &amp;lt;bart@cs.pdx.edu&amp;gt;</target>
        </trans-unit>
        <trans-unit id="15c502386eb41ec778f48f0426dd044e61902a8f" translate="yes" xml:space="preserve">
          <source>Based on the original Text.Html library by Andy Gill. See &lt;a href=&quot;http://www.cse.ogi.edu/~andy/html/intro.htm&quot;&gt;http://www.cse.ogi.edu/~andy/html/intro.htm&lt;/a&gt; for an introduction to that library.</source>
          <target state="translated">Andy Gill의 원본 Text.Html 라이브러리를 기반으로합니다. 해당 라이브러리에 대한 소개는 &lt;a href=&quot;http://www.cse.ogi.edu/~andy/html/intro.htm&quot;&gt;http://www.cse.ogi.edu/~andy/html/intro.htm&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2140f37579f36362da3719562444661d727afe4" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">기본 &lt;code&gt;Integer&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="ee73c6548371a6788caa59207b82400814c02764" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Monad&lt;/code&gt; functions</source>
          <target state="translated">기본 &lt;code&gt;Monad&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="c88db86b8d674e03dbcad77f83787a7e61a8e034" translate="yes" xml:space="preserve">
          <source>Basic Input and output</source>
          <target state="translated">기본 입출력</target>
        </trans-unit>
        <trans-unit id="f9b3e5bd963e2b38618aa474b3e7102fc295adcc" translate="yes" xml:space="preserve">
          <source>Basic UTF-8 validation and character manipulation.</source>
          <target state="translated">기본 UTF-8 유효성 검사 및 문자 조작.</target>
        </trans-unit>
        <trans-unit id="9568da19057c26bab59b9243581c623c02943b7f" translate="yes" xml:space="preserve">
          <source>Basic arrow definitions, based on</source>
          <target state="translated">기본 화살표 정의 (기준)</target>
        </trans-unit>
        <trans-unit id="6a1b59604dd8bf31bed9746b89fda90c3467c9aa" translate="yes" xml:space="preserve">
          <source>Basic concurrency operations</source>
          <target state="translated">기본 동시성 작업</target>
        </trans-unit>
        <trans-unit id="0c54046043ce73859746be9b39ba7b190dacdaf6" translate="yes" xml:space="preserve">
          <source>Basic concurrency stuff.</source>
          <target state="translated">기본 동시성</target>
        </trans-unit>
        <trans-unit id="a7e69e7791ed667a403de47b04497c349887deca" translate="yes" xml:space="preserve">
          <source>Basic data types</source>
          <target state="translated">기본 데이터 유형</target>
        </trans-unit>
        <trans-unit id="c9d432205b7dc1b2af1472a1dcd6e06b2740bef0" translate="yes" xml:space="preserve">
          <source>Basic data types and classes.</source>
          <target state="translated">기본 데이터 유형 및 클래스</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="b9548c7037e25b8bf7a7572126d2cc1b16e01f80" translate="yes" xml:space="preserve">
          <source>Basic interface</source>
          <target state="translated">기본 인터페이스</target>
        </trans-unit>
        <trans-unit id="ea133ee8187b37bb71d85236dac3108829ef4b40" translate="yes" xml:space="preserve">
          <source>Basic kinds</source>
          <target state="translated">기본 종류</target>
        </trans-unit>
        <trans-unit id="50a832ade293f6e2e4b29e68fbed8adbb4f5292b" translate="yes" xml:space="preserve">
          <source>Basic non-strict arrays.</source>
          <target state="translated">기본 엄격하지 않은 배열.</target>
        </trans-unit>
        <trans-unit id="5f012dfa959f01c06a8f22651163550a83550e42" translate="yes" xml:space="preserve">
          <source>Basic numeric class.</source>
          <target state="translated">기본 숫자 클래스.</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">기본 조작</target>
        </trans-unit>
        <trans-unit id="25c075b5afd0fa65abaa64881721f9e82dad1e33" translate="yes" xml:space="preserve">
          <source>Basic operations on type-level Booleans.</source>
          <target state="translated">타입 레벨 불리언에 대한 기본 연산.</target>
        </trans-unit>
        <trans-unit id="ce2e8249a9c31f9132666369cb296c36dc8cbe0d" translate="yes" xml:space="preserve">
          <source>Basic type classes</source>
          <target state="translated">기본 타입 클래스</target>
        </trans-unit>
        <trans-unit id="5f5e9b287612ac50252f03aed2ec4f912c26ab6b" translate="yes" xml:space="preserve">
          <source>Basic types for the implementation of IO Handles.</source>
          <target state="translated">IO 핸들 구현을위한 기본 유형.</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="57869d5cb688abb53fb6a3ccefe136c430873b62" translate="yes" xml:space="preserve">
          <source>BasicFormat</source>
          <target state="translated">BasicFormat</target>
        </trans-unit>
        <trans-unit id="edd76f36427e0be6ee4ea72fcc2b48f9dc5f829a" translate="yes" xml:space="preserve">
          <source>BaudRate</source>
          <target state="translated">BaudRate</target>
        </trans-unit>
        <trans-unit id="13b75e02d46b87821b8e6bb2e907caf22536eaeb" translate="yes" xml:space="preserve">
          <source>Be aware of that &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;ghci&lt;/code&gt; do require filenames containing spaces to be escaped using quotes:</source>
          <target state="translated">그주의 &lt;code&gt;ghc&lt;/code&gt; 및 &lt;code&gt;ghci&lt;/code&gt; 는 따옴표를 사용하여 이스케이프하는 공백이 포함 된 파일 이름을 필요로 않습니다 :</target>
        </trans-unit>
        <trans-unit id="2a750147c0b7e7b2524f6f876a3edd09786994a4" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList'에 유의하십시오. 에만 고정되지 않은에 대한 toList = 아이디 ' &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 의 이후 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 이 frozenness 정보를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="833fbd733b968c1c689e377b206c44a8ba2c1393" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList'에 유의하십시오. 에만 고정되지 않은에 대한 toList = 아이디 ' &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 의 이후 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 이 frozenness 정보를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8b4f2dc8bf0c5571de02a483e44a0efdc7eb624d" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList'에 유의하십시오. 에만 고정되지 않은에 대한 toList = 아이디 ' &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 의 이후 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 이 frozenness 정보를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4dc420edbf82aa0a2fac0909c5f04bacaae0ad94" translate="yes" xml:space="preserve">
          <source>Be careful not to recompile any packages that GHC itself depends on, as this may render the &lt;code&gt;ghc&lt;/code&gt; package itself broken, and &lt;code&gt;ghc&lt;/code&gt; cannot be simply recompiled. The only way to recover from this would be to re-install GHC.</source>
          <target state="translated">&lt;code&gt;ghc&lt;/code&gt; 패키지 자체가 손상 될 수 있으며 &lt;code&gt;ghc&lt;/code&gt; 를 단순히 재 컴파일 할 수 없으므로 GHC 자체가 의존하는 패키지를 다시 컴파일하지 않도록주의하십시오 . 이를 복구하는 유일한 방법은 GHC를 다시 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e58b8e7a7708dab3c9a2bfb9884abe1e3e42613" translate="yes" xml:space="preserve">
          <source>Be careful when using all the processors in your machine: if some of your processors are in use by other programs, this can actually harm performance rather than improve it. Asking GHC to create more capabilities than you have physical threads is almost always a bad idea.</source>
          <target state="translated">컴퓨터에서 모든 프로세서를 사용할 때는주의하십시오. 일부 프로세서가 다른 프로그램에서 사용중인 경우 성능을 향상시키기보다는 실제로 성능을 저하시킬 수 있습니다. 실제 스레드보다 더 많은 기능을 만들도록 GHC에 요청하는 것은 거의 항상 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="1e632134338b9cc24cdcec9c2ad59ac6cbe767e2" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an IORef as a counter. For example, the following will likely produce a stack overflow:</source>
          <target state="translated">경고 수 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; 가 엄격 기능이 적용되지 않습니다. 이것은 프로그램이 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; 를 여러 번 호출 하지만 그 값을 거의 사용하지 않으면 썽크가 메모리에 쌓여 공간이 누출되는 것을 의미합니다. IORef를 카운터로 사용할 때 흔히 발생하는 실수입니다. 예를 들어 다음과 같은 경우 스택 오버플로가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9146268e3a870b89574a63d603a9a4c2b804fc8e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; as a counter. For example, the following will leak memory and may produce a stack overflow:</source>
          <target state="translated">경고 수 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; 가 엄격 기능이 적용되지 않습니다. 즉, 프로그램이 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; 를 여러 번 호출 하지만 값을 거의 사용하지 않으면 썽크가 메모리에 쌓여 공간이 누출됩니다. &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 를 카운터로 사용할 때 흔히 발생하는 실수 입니다. 예를 들어, 다음은 메모리 누수로 인해 스택 오버플로가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac5eb692c23fe608a9eb6b4fa5f11c0d62b8835" translate="yes" xml:space="preserve">
          <source>Be warned, these functions can be used to construct ill-kinded type representations.</source>
          <target state="translated">이러한 함수를 사용하여 잘못된 유형 표현을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7554aac55bd08ae4a1829bdc1657e239450fe1f9" translate="yes" xml:space="preserve">
          <source>Be warned: this is an experimental facility, with fewer checks than usual. Use &lt;code&gt;-dcore-lint&lt;/code&gt; to typecheck the desugared program. If Core Lint is happy you should be all right.</source>
          <target state="translated">경고 : 이것은 평소보다 점검이 적은 실험 시설입니다. &lt;code&gt;-dcore-lint&lt;/code&gt; 를 사용하여 desugared 프로그램을 유형 검사하십시오. 코어 린트가 행복하다면 괜찮을 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdd46744a0edc96d38a6d8119838b4d615e82dd7" translate="yes" xml:space="preserve">
          <source>Bear in mind that it is also possible for the &lt;em&gt;right&lt;/em&gt;-hand side of an associated family instance to contain &lt;em&gt;kind&lt;/em&gt; parameters (by using the &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; extension). For instance, this class and instance are perfectly admissible:</source>
          <target state="translated">연관된 패밀리 인스턴스 의 &lt;em&gt;오른쪽&lt;/em&gt; 에 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 확장 을 사용하여 &lt;em&gt;종류&lt;/em&gt; 매개 변수 를 포함 할 수도 있습니다 . 예를 들어이 클래스와 인스턴스는 완벽하게 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7efc4e2f9d66a82f758a773da6630b93a7985e7a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-&lt;/code&gt; is treated specially in the Haskell grammar, &lt;code&gt;(-&lt;/code&gt;&lt;em&gt;e&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is not a section, but an application of prefix negation. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exp&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is equivalent to the disallowed section.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 는 Haskell 문법에서 특별히 취급 되기 때문에 &lt;code&gt;(-&lt;/code&gt; &lt;em&gt;-e &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 는 섹션이 아니라 접두사 부정의 적용입니다. 그러나 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exp &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 는 허용되지 않는 섹션과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c608a2b36ee0d8fe295adfc9f68da466a5a7382" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-&lt;/code&gt; is treated specially in the Haskell grammar, &lt;code&gt;(-&lt;/code&gt;&lt;em&gt;e&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is not a section, but an application of prefix negation. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exp&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is equivalent to the disallowed section.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 는 Haskell 문법에서 특별히 취급 되기 때문에 &lt;code&gt;(-&lt;/code&gt; &lt;em&gt;-e &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 는 섹션이 아니라 접두사 부정의 적용입니다. 그러나 &lt;code&gt;(&lt;a href=&quot;prelude#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exp &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 는 허용되지 않는 섹션과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b2c5ca5dad541aa7265cf458075ac55886113df" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:complete&quot;&gt;complete&lt;/a&gt;&lt;/code&gt; is the only field of &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Settings&quot;&gt;Settings&lt;/a&gt;&lt;/code&gt; depending on &lt;code&gt;m&lt;/code&gt;, the expression &lt;code&gt;defaultSettings {completionFunc = f}&lt;/code&gt; leads to a type error from being too general. This function works around that issue, and may become unnecessary if another field depending on &lt;code&gt;m&lt;/code&gt; is added.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:complete&quot;&gt;complete&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;m&lt;/code&gt; 에 따라 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Settings&quot;&gt;Settings&lt;/a&gt;&lt;/code&gt; 의 유일한 필드 이므로 , &lt;code&gt;defaultSettings {completionFunc = f}&lt;/code&gt; 식은 유형 오류가 너무 일반적이지 않습니다. 이 기능은이 문제를 해결하며 &lt;code&gt;m&lt;/code&gt; 에 따라 다른 필드 를 추가 하면 필요하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5e7e24ec7e3c0fdbaa3e27a95a2858ab8e68585" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;~&lt;/code&gt; is the more common equality relation, GHC prints out &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; unless &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is set.</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 가 더 일반적인 등식 관계 이기 때문에 &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt; 가 설정되어 있지 않으면 GHC는 &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; 를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="a7118064a4d44aa8f245264afef0d428f57c57f6" translate="yes" xml:space="preserve">
          <source>Because Haskell objects and libraries tend to be large, it can take many real seconds to slurp the bits to/from a remote filesystem.</source>
          <target state="translated">Haskell 객체와 라이브러리는 크기가 크므로 원격 파일 시스템과 비트를 교환하는 데 몇 초가 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e3d53125a21f513cc7ad6223feeb5607db810b" translate="yes" xml:space="preserve">
          <source>Because bounded primitives are the more general case, in this documentation we only refer to fixed size primitives where it matters that the resulting sequence of bytes is of a fixed length. Otherwise, we just refer to bounded size primitives.</source>
          <target state="translated">경계 프리미티브가 더 일반적인 경우이므로이 문서에서는 결과 바이트 시퀀스의 길이가 고정 길이 인 고정 크기 프리미티브 만 참조합니다. 그렇지 않으면, 우리는 경계 크기 프리미티브를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="b5fdc31bfd5809c4f1c4e511c746ab15cfe4b9d1" translate="yes" xml:space="preserve">
          <source>Because local fixity declarations are technically Haskell 98, no extension is necessary to enable them.</source>
          <target state="translated">로컬 고정 선언은 기술적으로 Haskell 98이므로이를 활성화하기 위해 확장이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de8ee7dd4338a2055669c56f86b3139945bd3682" translate="yes" xml:space="preserve">
          <source>Because of &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; is unclear name, we use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:decodeMultiByteIO&quot;&gt;decodeMultiByteIO&lt;/a&gt;&lt;/code&gt; for alias of &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 때문에 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; 가 불분명 한 이름을, 우리는 사용 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:decodeMultiByteIO&quot;&gt;decodeMultiByteIO&lt;/a&gt;&lt;/code&gt; 을 의 별칭 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fcb8636cfa970f434fa5b94db2cb53e2de61b75" translate="yes" xml:space="preserve">
          <source>Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;#12971&lt;/a&gt; for more.</source>
          <target state="translated">도구 체인 제한으로 인해 Windows에서 전체 유니 코드 경로를 지원할 수 없습니다. Windows에서는 Latin-1까지 지원합니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;# 12971&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fbf59b2f9a8d04abba49afed510bca079acda23" translate="yes" xml:space="preserve">
          <source>Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;Issue #12971&lt;/a&gt; for more.</source>
          <target state="translated">툴체인 제한으로 인해 Windows에서 전체 유니 코드 경로를 지원할 수 없습니다. Windows에서는 최대 Latin-1을 지원합니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;문제 # 12971&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1351fede99f7574d382011519c832e48e2febe1" translate="yes" xml:space="preserve">
          <source>Because of the aggressive optimization that GHC performs to the programs it compiles it is quite difficult to pin-point exactly which point in the source program a given machine instruction should be attributed to. In fact, internally GHC associates each instruction with a &lt;strong&gt;set&lt;/strong&gt; of source locations. When emitting the standard debug information used by &lt;code&gt;gdb&lt;/code&gt; and other language-agnostic debugging tools, GHC is forced to heuristically choose one location from among this set.</source>
          <target state="translated">GHC가 프로그램에 대해 수행하는 적극적인 최적화로 인해 소스 프로그램에서 주어진 머신 명령어의 정확한 포인트를 정확히 찾아내는 것은 매우 어렵습니다. 실제로 내부 GHC는 각 명령어를 소스 위치 &lt;strong&gt;세트&lt;/strong&gt; 와 연관시킵니다 . &lt;code&gt;gdb&lt;/code&gt; 및 기타 언어에 구애받지 않는 디버깅 도구에서 사용하는 표준 디버그 정보를 내보낼 때 GHC는이 세트 중에서 하나의 위치를 ​​경험적으로 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="d22c87e1c1a19e64881fa0a5c29ea8d152160afd" translate="yes" xml:space="preserve">
          <source>Because of the sad state of most UNIX linkers, the order of such options does matter. If library ⟨foo⟩ requires library ⟨bar⟩, then in general &lt;code&gt;-l ⟨foo⟩&lt;/code&gt; should come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;-l ⟨bar⟩&lt;/code&gt; on the command line.</source>
          <target state="translated">대부분의 UNIX 링커의 상태가 좋지 않기 때문에 이러한 옵션의 순서는 중요합니다. 라이브러리 ⟨foo⟩에 라이브러리 ⟨bar⟩가 필요한 경우, 일반적으로 &lt;code&gt;-l ⟨foo⟩&lt;/code&gt; 는 명령 행에서 &lt;code&gt;-l ⟨bar⟩&lt;/code&gt; &lt;em&gt;앞에&lt;/em&gt; 와야 합니다.</target>
        </trans-unit>
        <trans-unit id="aefb27d5d1f818fec24e956de3be5cc43a462d50" translate="yes" xml:space="preserve">
          <source>Because of this, unlike &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, explicit binding of type/kind variables in default declarations is not permitted by &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 때문에 &lt;a href=&quot;#assoc-inst&quot;&gt;연결된 인스턴스&lt;/a&gt; 와 달리 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 은 기본 선언에서 형식 / 종류 변수의 명시 적 바인딩을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f47acccf5b190df69b3205bc25cdf837d4bc4d64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;IArray&lt;/code&gt; interface provides operations overloaded on the type of the array, it should be possible to just change the array type being used by a program from say &lt;code&gt;Array&lt;/code&gt; to &lt;code&gt;UArray&lt;/code&gt; to get the benefits of unboxed arrays (don't forget to import &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; instead of &lt;a href=&quot;data-array&quot;&gt;Data.Array&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;IArray&lt;/code&gt; 인터페이스는 배열 유형에 오버로드 된 작업을 제공 하기 때문에 프로그램에서 사용하는 배열 유형을 &lt;code&gt;Array&lt;/code&gt; 에서 &lt;code&gt;UArray&lt;/code&gt; 로 변경하면 상자없는 배열 의 이점을 얻을 수 있습니다 ( &lt;a href=&quot;data-array-unboxed&quot;&gt;데이터&lt;/a&gt; 를 가져 오는 것을 잊지 마십시오) . Data.Array 대신 &lt;a href=&quot;data-array&quot;&gt;Array.Unboxed&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="73825efb186a67ab4235b4b330529ec46440f89c" translate="yes" xml:space="preserve">
          <source>Because the code generator must store and move arguments as well as variables, the logic above applies equally well to function arguments, which may not be levity-polymorphic.</source>
          <target state="translated">코드 생성기는 변수뿐만 아니라 인수를 저장하고 이동해야하기 때문에 위의 논리는 함수 인수에 동일하게 적용되며, 이는 유사도 다형성이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b922e23af5d396ea51043a6f5495cb7265ef575" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list, but non-strict in the values. Thus, recurrences such as the following are possible:</source>
          <target state="translated">이러한 오류에 대해 인덱스를 검사해야하므로 &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 은 bounds 인수와 연관 목록의 인덱스에서 엄격하지만 값은 엄격하지 않습니다. 따라서 다음과 같은 재발이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="744b8a2e53d06a3c0594d327e50d361273a6ea66" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list. Whether &lt;code&gt;array&lt;/code&gt; is strict or non-strict in the elements depends on the array type: &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; is a non-strict array type, but all of the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; arrays are strict. Thus in a non-strict array, recurrences such as the following are possible:</source>
          <target state="translated">이러한 오류에 대한 인덱스를 확인해야하므로 범위 인수와 연관 목록의 인덱스에서 &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 이 엄격합니다. 여부 &lt;code&gt;array&lt;/code&gt; : 요소의 엄격한 또는 비 엄격한 것은 배열 유형에 따라 &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 아닌 엄격한 배열 유형이지만, 모든 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 배열은 엄격합니다. 따라서 엄격하지 않은 배열에서는 다음과 같은 반복이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1ead8ebe60edd2b98db40ca3daeca484e250542a" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list, but non-strict in the values. Thus, recurrences such as the following are possible:</source>
          <target state="translated">이러한 오류에 대해 인덱스를 검사해야하므로 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 은 bounds 인수와 연관 목록의 인덱스에서 엄격하지만 값은 엄격하지 않습니다. 따라서 다음과 같은 재발이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3877a6244217b5631d19062ad9620975d2dde55e" translate="yes" xml:space="preserve">
          <source>Because the preprocessor targets Haskell (rather than Core), &lt;code&gt;let&lt;/code&gt;-bound variables are monomorphic.</source>
          <target state="translated">전처리 기가 Core가 아닌 Haskell을 대상으로하기 때문에 &lt;code&gt;let&lt;/code&gt; - bound 변수는 단형입니다.</target>
        </trans-unit>
        <trans-unit id="808844f69c7e9605bc105a4ad20ea2d366849e5a" translate="yes" xml:space="preserve">
          <source>Because there is no unboxed unit tuple, the following expression</source>
          <target state="translated">박스 단위의 튜플이 없기 때문에 다음 식</target>
        </trans-unit>
        <trans-unit id="76fec9d9feb8d4cfd75fa0cf83ef0298228be150" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</source>
          <target state="translated">까다로운 프로파일 링에는 GHC 내부에 대해 어느 정도 익숙해야하므로 설명서를 GHC 개발자 위키로 옮겼습니다. 틱 틱한 프로파일 링 페이지에 대한 링크가 포함 된 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Profiling&quot;&gt;프로파일 링 옵션 개요를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="50cb7c0b41fc81c206b893c65bdf7993f9032da2" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</source>
          <target state="translated">까다로운 프로파일 링을 위해서는 GHC 내부에 대한 어느 정도의 친숙 함이 필요하기 때문에 문서를 GHC 개발자 위키로 옮겼습니다. 까다로운 프로파일 링 페이지에 대한 링크가 포함 된 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;프로파일 링 옵션 개요를&lt;/a&gt; 살펴보세요 .</target>
        </trans-unit>
        <trans-unit id="f3d41195121db8c561952d390998012e5adf5323" translate="yes" xml:space="preserve">
          <source>Because unboxed types are represented without the use of pointers, we cannot store them in use a polymorphic datatype at an unboxed type. For example, the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42#&lt;/code&gt; would have to be different from the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42&lt;/code&gt;; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of &lt;code&gt;Just&lt;/code&gt; nodes (nor for any other datatype). Accordingly, the &lt;em&gt;kind&lt;/em&gt; of an unboxed type is different from the kind of a boxed type.</source>
          <target state="translated">박스형이 아닌 포인터는 포인터를 사용하지 않고 표현되기 때문에 박스형이 아닌 다형성 데이터 형을 사용하여 저장할 수 없습니다. 예를 들어, &lt;code&gt;Just&lt;/code&gt; 의 노드 &lt;code&gt;Just 42#&lt;/code&gt; 로부터 다를 할 것입니다 &lt;code&gt;Just&lt;/code&gt; 의 노드 &lt;code&gt;Just 42&lt;/code&gt; ; 전자는 정수를 직접 저장하고 후자는 포인터를 저장합니다. GHC는 현재이 다양한 &lt;code&gt;Just&lt;/code&gt; 노드를 지원하지 않습니다 (다른 데이터 유형은 아님). 따라서, &lt;em&gt;종류&lt;/em&gt; 박싱 형은 박스 타입의 종류는 다르다.</target>
        </trans-unit>
        <trans-unit id="fe6fce85b24f15b5d65932c379eeca8ae6b18466" translate="yes" xml:space="preserve">
          <source>Becomes this:</source>
          <target state="translated">이것이된다 :</target>
        </trans-unit>
        <trans-unit id="0ef17ad67edcf83107e1af3022c4061c85509f1d" translate="yes" xml:space="preserve">
          <source>Before data is written, it is first encoded as UTF-8.</source>
          <target state="translated">데이터를 쓰기 전에 먼저 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="595c4c743cb61dcc0704188c65ab1109a331f426" translate="yes" xml:space="preserve">
          <source>Before going into the Safe Haskell details, let&amp;rsquo;s point out some of the reasons this security mechanism would fail without Safe Haskell:</source>
          <target state="translated">Safe Haskell 세부 정보로 이동하기 전에 Safe Haskell없이이 보안 메커니즘이 실패하는 몇 가지 이유를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="74554fdf503e2d7e6e96019d0ebd03e229b9e50a" translate="yes" xml:space="preserve">
          <source>Before resorting to explicit unboxed types, try using strict constructor fields and &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; first (see above). That way, your code stays portable.</source>
          <target state="translated">명시 적 언 &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; 타입에 의지하기 전에 먼저 엄격한 생성자 필드와 -funbox-strict-fields를 사용 하십시오 (위 참조). 그렇게하면 코드를 이식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c505eb2064aacbd9cf542da06128d3e808f292b7" translate="yes" xml:space="preserve">
          <source>Before using the Continuation monad, be sure that you have a firm understanding of continuation-passing style and that continuations represent the best solution to your particular design problem. Many algorithms which require continuations in other languages do not require them in Haskell, due to Haskell's lazy semantics. Abuse of the Continuation monad can produce code that is impossible to understand and maintain.</source>
          <target state="translated">연속 모나드를 사용하기 전에 연속 전달 스타일에 대해 잘 알고 있고 연속이 특정 설계 문제에 대한 최상의 솔루션인지 확인하십시오. 다른 언어로 연속을 요구하는 많은 알고리즘은 Haskell의 게으른 의미로 인해 Haskell에서 필요하지 않습니다. Continuation 모나드의 남용은 이해하고 유지하기 어려운 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da8e18ee240f54f494c1090de6f01f19305fb9e" translate="yes" xml:space="preserve">
          <source>Before you get too carried away working at the lowest level (e.g., sloshing &lt;code&gt;MutableByteArray#&lt;/code&gt;s around your program), you may wish to check if there are libraries that provide a &amp;ldquo;Haskellised veneer&amp;rdquo; over the features you want. The separate &lt;a href=&quot;../libraries/index&quot;&gt;libraries documentation&lt;/a&gt; describes all the libraries that come with GHC.</source>
          <target state="translated">가장 낮은 수준 (예 : 프로그램 주변의 &lt;code&gt;MutableByteArray#&lt;/code&gt; 에서 작업을 너무 많이 수행하기 전에 원하는 기능에 대해 &quot;Haskellised veneer&quot;를 제공하는 라이브러리가 있는지 확인할 수 있습니다. 별도의 &lt;a href=&quot;../libraries/index&quot;&gt;라이브러리 설명서&lt;/a&gt; 는 GHC와 함께 제공되는 모든 라이브러리를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6e79eaaaac969988bacd211dc7719f705249b6b2" translate="yes" xml:space="preserve">
          <source>Begin or end a multi-line GHCi command block.</source>
          <target state="translated">여러 줄 GHCi 명령 블록을 시작하거나 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a603260088041becc44147197033a240091e8107" translate="yes" xml:space="preserve">
          <source>Beginning with GHC 6.12, text I/O is performed using the system or handle's current locale and line ending conventions.</source>
          <target state="translated">GHC 6.12부터 시스템 또는 핸들의 현재 로케일 및 줄 끝 규칙을 사용하여 텍스트 I / O가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f3aa22597a1e0633e605134fce9271b6f0ab9592" translate="yes" xml:space="preserve">
          <source>Beginning with GHC 7.2, it is possible to use binary serialization without writing any instance boilerplate code.</source>
          <target state="translated">GHC 7.2부터 인스턴스 상용구 코드를 작성하지 않고도 이진 직렬화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="3b615d319efe934d18d838650aea75dd222232f9" translate="yes" xml:space="preserve">
          <source>Behaviors</source>
          <target state="translated">Behaviors</target>
        </trans-unit>
        <trans-unit id="198a78dbe4628d2be1564fc1b18cd50856f7b448" translate="yes" xml:space="preserve">
          <source>Behind all these special cases there is a simple guiding principle. Consider</source>
          <target state="translated">이러한 모든 특수한 사례 뒤에는 간단한 지침 원칙이 있습니다. 치다</target>
        </trans-unit>
        <trans-unit id="9927980f0adf7f518791c8284a901dec62d24eaf" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹 의 일부인 이 경고는 기본적으로 해제되어 있지만 향후 GHC 릴리스에서 &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)의&lt;/a&gt; 일부로 켜집니다 .</target>
        </trans-unit>
        <trans-unit id="7b666df63b130afff3eedd81208b2e0a7a134951" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부 이므로이 경고는 기본적으로 해제되어 있지만 향후 GHC 릴리스에서 켜집니다.</target>
        </trans-unit>
        <trans-unit id="f03e9e7f99ad75ac4d7551b349bf9316b17b8429" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부이기 때문에이 경고는 기본적으로 꺼져 있지만 &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MFP (MonadFail Proposal)의&lt;/a&gt; 일부로 향후 GHC 릴리스에서 켜질 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e424286d0dd9624ae70bbdecffd2b0043a24233e" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부 이므로이 경고는 기본적으로 꺼져 있지만 향후 GHC 릴리스에서 켜질 것입니다.</target>
        </trans-unit>
        <trans-unit id="969fbe69d4fd12dcb8cd78548a9408fd636a4a1d" translate="yes" xml:space="preserve">
          <source>Bell alerts</source>
          <target state="translated">벨 알림</target>
        </trans-unit>
        <trans-unit id="631e6a2e29c9e7487b85c9d3fda8e1229ccc3cd2" translate="yes" xml:space="preserve">
          <source>Below is a sample output of &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음은 &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt; 의 샘플 출력입니다.</target>
        </trans-unit>
        <trans-unit id="7895436348a83297630a392863829501eafbcaec" translate="yes" xml:space="preserve">
          <source>Below is the output of the same sample using &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">아래는 &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; 을&lt;/a&gt; 사용한 동일한 샘플의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="98ad2d7635fc111746d76bbebe8290141e95c77d" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; 를 다른 사전 구현과 비교하는 벤치 마크 는 &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="accf09ba43e68b9c38f3e58c7eda4b805b21f104" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; 와 다른 사전 구현을 비교하는 벤치 마크 는 &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8166d1f6f68785d8abaf21c7a0c48450cb6c1c1e" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; 를 다른 사전 구현과 비교하는 벤치 마크 는 &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c3dee153b5361c9c8871a11980becccab3e42dc" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; 와 다른 사전 구현을 비교하는 벤치 마크 는 &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ffe14aeb84cb87ee3186a9571b06e8928ba55d3" translate="yes" xml:space="preserve">
          <source>Beside</source>
          <target state="translated">Beside</target>
        </trans-unit>
        <trans-unit id="fe92499c572ca34751830e44318f456f3cef3984" translate="yes" xml:space="preserve">
          <source>Beside, separated by space</source>
          <target state="translated">옆으로, 공간으로 구분</target>
        </trans-unit>
        <trans-unit id="788b6f6586539d7fc47b8fcc55c19730cea68d99" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 중 하나가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지 않으면 공백으로 구분됩니다 . &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 아이디가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e330d7aca54bde1e02fdeabed64fcc133a6401a" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 중 하나가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지 않으면 공백으로 구분됩니다 . &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 아이디가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e618be55395d8238a159850eddcfbe3ac7a7c273" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 중 하나가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지 않으면 공백으로 구분됩니다 . &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 아이디가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="624607c86787dd5201e891b5c7bb38bfd2a78db7" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">빗나가서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있고 ID는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d88ff324bd9ae359aacf25e29a3916a4ff7c3758" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">빗나가서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있고 ID는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d384f6b4d5525841d1e0cf79b191835355e54bd2" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">빗나가서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있고 ID는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ed1a12122824af84b077aa03948e1d13a22d0d" translate="yes" xml:space="preserve">
          <source>Besides an extra-constraints wildcard (see &lt;a href=&quot;#extra-constraints-wildcard&quot;&gt;Extra-Constraints Wildcard&lt;/a&gt;), only named wildcards can occur in the constraints, e.g. the &lt;code&gt;_x&lt;/code&gt; in &lt;code&gt;Show _x&lt;/code&gt;.</source>
          <target state="translated">여분 제약 (참조 와일드 카드 외에 &lt;a href=&quot;#extra-constraints-wildcard&quot;&gt;엑스트라 제약 와일드 카드&lt;/a&gt; ) 만라는 이름의 와일드 카드는 예를 들어, 제약 조건에서 발생할 수 &lt;code&gt;_x&lt;/code&gt; 에 &lt;code&gt;Show _x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26a472de725e2ab48d4de069fd18a472bb691f2e" translate="yes" xml:space="preserve">
          <source>Besides the stock approach to deriving instances by generating all method definitions, GHC supports two additional deriving strategies, which can derive arbitrary classes:</source>
          <target state="translated">모든 메소드 정의를 생성하여 인스턴스를 파생하는 재고 접근 방식 외에도 GHC는 임의의 클래스를 파생시킬 수있는 두 가지 추가 파생 전략을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bf2ddad2d8faffde93e2583147aba1ed84271cf8" translate="yes" xml:space="preserve">
          <source>Beware that for many monads (those for which the &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict) this instance will &lt;em&gt;not&lt;/em&gt; satisfy the right-tightening law required by the &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowLoop&quot;&gt;ArrowLoop&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">많은 모나드를위한 (그 대상이되는 것을주의 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 이 인스턴스가됩니다 작업이 엄격하다) &lt;em&gt;하지&lt;/em&gt; 에 의해 요구되는 오른쪽 조임 법률 만족 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowLoop&quot;&gt;ArrowLoop&lt;/a&gt;&lt;/code&gt; 의 클래스를.</target>
        </trans-unit>
        <trans-unit id="5d549c234ccdd45fa67e66fd17e9aa5b7f98bef5" translate="yes" xml:space="preserve">
          <source>Beware that in some cases, you may need to enable the &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension in order to use this feature. Here&amp;rsquo;s a pathological case that illustrates why this might happen:</source>
          <target state="translated">경우에 &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 기능 을 사용하려면 UndecidableInstances 확장 을 활성화해야 할 수도 있습니다. 이것이 왜 일어날 수 있는지를 보여주는 병리학 적 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="653c3c82d14b666acef082f6f19dc453202cc92e" translate="yes" xml:space="preserve">
          <source>Beware that this function allocates a new file descriptor. A consequence of this is that calling &lt;code&gt;&lt;a href=&quot;system-win32-types#v:hANDLEToHandle&quot;&gt;hANDLEToHandle&lt;/a&gt;&lt;/code&gt; on the standard Windows handles will not give you &lt;code&gt;&lt;a href=&quot;io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For example, if you run this code:</source>
          <target state="translated">이 함수는 새로운 파일 디스크립터를 할당합니다. 그 결과 표준 Windows 핸들에서 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:hANDLEToHandle&quot;&gt;hANDLEToHandle&lt;/a&gt;&lt;/code&gt; 을 호출 해도 &lt;code&gt;&lt;a href=&quot;io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 가 제공되지 않습니다 . 예를 들어이 코드를 실행하면</target>
        </trans-unit>
        <trans-unit id="2d677a45c1242d143f2da8c0235a4156fc9aed39" translate="yes" xml:space="preserve">
          <source>Bidirectional</source>
          <target state="translated">Bidirectional</target>
        </trans-unit>
        <trans-unit id="03af5d044e78c5ca2a87b11a0cd3ee30426faaa4" translate="yes" xml:space="preserve">
          <source>Bifoldable</source>
          <target state="translated">Bifoldable</target>
        </trans-unit>
        <trans-unit id="6148a7120e3e6bee1841037a0e66edba57f2b59d" translate="yes" xml:space="preserve">
          <source>Bifunctor</source>
          <target state="translated">Bifunctor</target>
        </trans-unit>
        <trans-unit id="a1ec611991374940381b1e25467f733adcf02bbc" translate="yes" xml:space="preserve">
          <source>Big-endian</source>
          <target state="translated">Big-endian</target>
        </trans-unit>
        <trans-unit id="f84c8cdd20adeb4d710d8f5e51b3ed37c2ffc31f" translate="yes" xml:space="preserve">
          <source>Big-endian decoding</source>
          <target state="translated">빅 엔디안 디코딩</target>
        </trans-unit>
        <trans-unit id="a75e84204fb542f8fffbe1d93f24c4127709d703" translate="yes" xml:space="preserve">
          <source>Big-endian primitives</source>
          <target state="translated">빅 엔디안 프리미티브</target>
        </trans-unit>
        <trans-unit id="d80f000c501b0702089f0a6d5d685b3b13d95ab4" translate="yes" xml:space="preserve">
          <source>Big-endian writes</source>
          <target state="translated">빅 엔디안 쓰기</target>
        </trans-unit>
        <trans-unit id="b092fd4b540ba704e7eab5010e33d073c85baa3e" translate="yes" xml:space="preserve">
          <source>BigEndian</source>
          <target state="translated">BigEndian</target>
        </trans-unit>
        <trans-unit id="4a103563aecb5d07999bf55551e2840da08dea6b" translate="yes" xml:space="preserve">
          <source>BigNat</source>
          <target state="translated">BigNat</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="ca596333bdb84d8c57915427010182cfc758ccf1" translate="yes" xml:space="preserve">
          <source>Binary encodings</source>
          <target state="translated">이진 인코딩</target>
        </trans-unit>
        <trans-unit id="b7a0b74a0efeea7a4ae51a1506822c7ba3cdfd5b" translate="yes" xml:space="preserve">
          <source>Binary input and output</source>
          <target state="translated">이진 입력 및 출력</target>
        </trans-unit>
        <trans-unit id="977f362d04f5411618935479aa90d3c2cbbc8fc9" translate="yes" xml:space="preserve">
          <source>Binary serialisation</source>
          <target state="translated">이진 직렬화</target>
        </trans-unit>
        <trans-unit id="e899d0e0bf36df2f1e4a7c2fa0c0833fc062acdf" translate="yes" xml:space="preserve">
          <source>Binary serialisation of Haskell values to and from lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. The Binary library provides methods for encoding Haskell values as streams of bytes directly in memory. The resulting &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; can then be written to disk, sent over the network, or further processed (for example, compressed with gzip).</source>
          <target state="translated">과 게으른에서 하스켈 값의 바이너리 직렬화 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 의. 이진 라이브러리는 Haskell 값을 바이트 스트림으로 메모리에 직접 인코딩하는 방법을 제공합니다. 그런 다음 결과 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 디스크에 쓰거나 네트워크를 통해 보내거나 추가로 처리 할 수 ​​있습니다 (예 : gzip으로 압축).</target>
        </trans-unit>
        <trans-unit id="4f05e0ce4c49719ca18e235c0a5338e6c9f82d92" translate="yes" xml:space="preserve">
          <source>Binary-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s do no newline translation at all.</source>
          <target state="translated">이진 모드 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 개행 변환을 전혀하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e65c3b7cae6dd45ee04f43d6dc7e91ad9857ed8" translate="yes" xml:space="preserve">
          <source>BinaryLiterals</source>
          <target state="translated">BinaryLiterals</target>
        </trans-unit>
        <trans-unit id="ef29ec8d1db838c8e1a48ba8918f31da08b74947" translate="yes" xml:space="preserve">
          <source>BinaryType</source>
          <target state="translated">BinaryType</target>
        </trans-unit>
        <trans-unit id="6bc6b5d113e80feddce377fd7a1ee8583e9b656f" translate="yes" xml:space="preserve">
          <source>Bind worker threads on a capability to the appropriate node.</source>
          <target state="translated">기능의 작업자 스레드를 적절한 노드에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="250887693e686f9b9bf4bfdc01f65dbe05d0a943" translate="yes" xml:space="preserve">
          <source>Binding a function to a monadic value creates a new continuation which uses the function as the continuation of the monadic computation.</source>
          <target state="translated">함수를 모나드 값에 바인딩하면 함수를 모나드 계산의 연속으로 사용하는 새로운 연속이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="df37671abb2b5d29837d448a150784288f14c591" translate="yes" xml:space="preserve">
          <source>Binding strategy:</source>
          <target state="translated">바인딩 전략 :</target>
        </trans-unit>
        <trans-unit id="f86ed004f3a732d1f540de4195d20a7e54011bbe" translate="yes" xml:space="preserve">
          <source>Bindings are translated with the &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; functions to the usual do-notation:</source>
          <target state="translated">바인딩은 함께 번역 &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; 및 &lt;code&gt;return&lt;/code&gt; 일반적인 DO-표기법 기능 :</target>
        </trans-unit>
        <trans-unit id="c5508d22bc8524cbfc21537e7df0e0da3d89023d" translate="yes" xml:space="preserve">
          <source>Bindings:</source>
          <target state="translated">Bindings:</target>
        </trans-unit>
        <trans-unit id="d77c376e13dda253679750f2f2a4005705a750a7" translate="yes" xml:space="preserve">
          <source>Binds &lt;code&gt;response&lt;/code&gt; to the result of the following &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; block, binds &lt;code&gt;exit&lt;/code&gt; to the continuation.</source>
          <target state="translated">귀속의 &lt;code&gt;response&lt;/code&gt; 은 다음의 결과에 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; 의 블록은 결합 &lt;code&gt;exit&lt;/code&gt; 계속합니다.</target>
        </trans-unit>
        <trans-unit id="2fe1387ba65691c262469ad0ad878d77f589b9fd" translate="yes" xml:space="preserve">
          <source>Biographical profiling samples start with the &lt;code&gt;EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN&lt;/code&gt; event. These events also include a timestamp which indicates when the sample was taken. This is because all these samples will appear at the end of the eventlog due to how the biographical profiling mode works. You can use the timestamp to reorder the samples relative to the other events.</source>
          <target state="translated">전기 프로파일 링 샘플은 &lt;code&gt;EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN&lt;/code&gt; 이벤트로 시작합니다 . 이러한 이벤트에는 샘플을 가져온시기를 나타내는 타임 스탬프도 포함됩니다. 이는 전기 프로파일 링 모드가 작동하는 방식으로 인해 이러한 모든 샘플이 이벤트 로그 끝에 표시되기 때문입니다. 타임 스탬프를 사용하여 다른 이벤트를 기준으로 샘플을 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd55858742523f8eb1bcf4b2ff338846c79cd3cf" translate="yes" xml:space="preserve">
          <source>Bit-operations</source>
          <target state="translated">Bit-operations</target>
        </trans-unit>
        <trans-unit id="3bb87577cfbf6b194391f9fd2449d3a6daeb5a6e" translate="yes" xml:space="preserve">
          <source>BitMap</source>
          <target state="translated">BitMap</target>
        </trans-unit>
        <trans-unit id="792ac9c6e86cf4159b4253d880e8d576591cad45" translate="yes" xml:space="preserve">
          <source>BitQueue</source>
          <target state="translated">BitQueue</target>
        </trans-unit>
        <trans-unit id="16859195f5f61ebc3eeb05fc2fd6fe7e5753102f" translate="yes" xml:space="preserve">
          <source>BitQueueB</source>
          <target state="translated">BitQueueB</target>
        </trans-unit>
        <trans-unit id="b3f2f3df0a3eb7ef036e378ae33aea93f8400b62" translate="yes" xml:space="preserve">
          <source>Bitraversable</source>
          <target state="translated">Bitraversable</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="f4eecb0837ac1302da3d67883bc955eb28db73ff" translate="yes" xml:space="preserve">
          <source>Bits are numbered from 0 with bit 0 being the least significant bit.</source>
          <target state="translated">비트는 0부터 번호가 매겨지며 비트 0은 최하위 비트입니다.</target>
        </trans-unit>
        <trans-unit id="51a3d80c1096a062a320e452d30389dbba6e7b2e" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot;</source>
          <target state="translated">비트 단위 &quot;and&quot;</target>
        </trans-unit>
        <trans-unit id="c00a3cca6e0ab63567c09149e3d79bf22145be8a" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot;.</source>
          <target state="translated">비트 단위 &quot;and&quot;.</target>
        </trans-unit>
        <trans-unit id="0762de2cf0c6e6b77d828208804bb630467f8b11" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;not&quot;, also known as the binary complement.</source>
          <target state="translated">이진 보수라고도하는 비트 단위 &quot;not&quot;.</target>
        </trans-unit>
        <trans-unit id="2ddacb26a9c51fdf4ca8a56ff66cbb76c9340f8f" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot;</source>
          <target state="translated">비트 단위 &quot;또는&quot;</target>
        </trans-unit>
        <trans-unit id="c4b3b9bbde6c754b04ce738f6f2d6bfaa36d025e" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot;.</source>
          <target state="translated">비트 단위 &quot;또는&quot;.</target>
        </trans-unit>
        <trans-unit id="06ae84f662f3c26c21557288d7b8b92876ca8dee" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot;</source>
          <target state="translated">비트 &quot;xor&quot;</target>
        </trans-unit>
        <trans-unit id="e3c7281d1f961f980af39f221c595b00177f9020" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot;.</source>
          <target state="translated">비트 단위 &quot;xor&quot;.</target>
        </trans-unit>
        <trans-unit id="1aa01b99c6c9acf5a48b2725a9ba94e0bfd7f80c" translate="yes" xml:space="preserve">
          <source>Bitwise &lt;code&gt;NOT&lt;/code&gt; operation</source>
          <target state="translated">비트 &lt;code&gt;NOT&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="683d2fe77a00a83b71f7046b5e0207bef8f8b05e" translate="yes" xml:space="preserve">
          <source>Bitwise AND operation</source>
          <target state="translated">비트 AND 연산</target>
        </trans-unit>
        <trans-unit id="812234cb7852ab2e4152ebfeecff0e34bbc8f331" translate="yes" xml:space="preserve">
          <source>Bitwise OR operation</source>
          <target state="translated">비트 OR 연산</target>
        </trans-unit>
        <trans-unit id="566da620243c869eb9093b1d9109361f7deab173" translate="yes" xml:space="preserve">
          <source>Bitwise XOR operation</source>
          <target state="translated">비트 XOR 연산</target>
        </trans-unit>
        <trans-unit id="b406fb57b29fc76f71864fbb37f0238045f84d9d" translate="yes" xml:space="preserve">
          <source>Black</source>
          <target state="translated">Black</target>
        </trans-unit>
        <trans-unit id="8f231bba8956b90d7be7998e87d3ff0f36931637" translate="yes" xml:space="preserve">
          <source>Blackholing is the act of marking a thunk (lazy computation) as being under evaluation. It is useful for three reasons: firstly it lets us detect certain kinds of infinite loop (the &lt;code&gt;NonTermination&lt;/code&gt; exception), secondly it avoids certain kinds of space leak, and thirdly it avoids repeating a computation in a parallel program, because we can tell when a computation is already in progress.</source>
          <target state="translated">블랙홀 링은 썽크 (게으른 계산)를 평가중인 것으로 표시하는 작업입니다. 세 가지 이유로 유용합니다. 첫째, 특정 종류의 무한 루프 ( &lt;code&gt;NonTermination&lt;/code&gt; 예외)를 감지 하고, 둘째로 특정 종류의 공간 누출을 피하고, 세 번째로 병렬 프로그램에서 계산을 반복하지 않습니다. 계산이 이미 진행 중입니다.</target>
        </trans-unit>
        <trans-unit id="574a76735e33bbd57fb0a916028cacc6070b3973" translate="yes" xml:space="preserve">
          <source>Block size</source>
          <target state="translated">블록 크기</target>
        </trans-unit>
        <trans-unit id="8b9a1d81d5887c9c67a6b20d2df16d43fe81caa7" translate="yes" xml:space="preserve">
          <source>Block the current thread until data can be written to the given file descriptor (GHC only).</source>
          <target state="translated">주어진 파일 디스크립터에 데이터를 쓸 수있을 때까지 현재 스레드를 차단하십시오 (GHC 만 해당).</target>
        </trans-unit>
        <trans-unit id="7065922fead5956b30a4880d4db36fbe6025cd84" translate="yes" xml:space="preserve">
          <source>Block the current thread until data is available to read on the given file descriptor (GHC only).</source>
          <target state="translated">주어진 파일 디스크립터에서 데이터를 읽을 수있을 때까지 현재 스레드를 차단하십시오 (GHC 전용).</target>
        </trans-unit>
        <trans-unit id="2032cada98db5faaa0692223c8180668544f801d" translate="yes" xml:space="preserve">
          <source>Block until input is available on specified file descriptor.</source>
          <target state="translated">지정된 파일 디스크립터에서 입력을 사용할 수있을 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="37d7b821bc5d453b65c16db21a1b548c820c28a2" translate="yes" xml:space="preserve">
          <source>Block until output is possible on specified file descriptor.</source>
          <target state="translated">지정된 파일 디스크립터에서 출력이 가능할 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="9ba5e142177e718c386fc68a7e5656d6003bdbf3" translate="yes" xml:space="preserve">
          <source>BlockArguments</source>
          <target state="translated">BlockArguments</target>
        </trans-unit>
        <trans-unit id="21ee9c95fd5afb5bc56f8da9452091ffececfb39" translate="yes" xml:space="preserve">
          <source>BlockReason</source>
          <target state="translated">BlockReason</target>
        </trans-unit>
        <trans-unit id="bc1ab004ab80487da68b0fe585fadda53b1d746e" translate="yes" xml:space="preserve">
          <source>BlockedIndefinitelyOnMVar</source>
          <target state="translated">BlockedIndefinitelyOnMVar</target>
        </trans-unit>
        <trans-unit id="69236e61bca3edecfc65ca8a204134ba0de3fd74" translate="yes" xml:space="preserve">
          <source>BlockedIndefinitelyOnSTM</source>
          <target state="translated">BlockedIndefinitelyOnSTM</target>
        </trans-unit>
        <trans-unit id="45dfab9fc5bfc0e525595e3313ce2a25dd4d7faa" translate="yes" xml:space="preserve">
          <source>BlockedOnBlackHole</source>
          <target state="translated">BlockedOnBlackHole</target>
        </trans-unit>
        <trans-unit id="93c9452da95239560e86200369ac0d634e21fb28" translate="yes" xml:space="preserve">
          <source>BlockedOnException</source>
          <target state="translated">BlockedOnException</target>
        </trans-unit>
        <trans-unit id="b61c27531d4d77cf1630fbca19ceced64a349e39" translate="yes" xml:space="preserve">
          <source>BlockedOnForeignCall</source>
          <target state="translated">BlockedOnForeignCall</target>
        </trans-unit>
        <trans-unit id="53d58631b450ca365b0ba176488a8441b143b2c2" translate="yes" xml:space="preserve">
          <source>BlockedOnMVar</source>
          <target state="translated">BlockedOnMVar</target>
        </trans-unit>
        <trans-unit id="895bd85890de6d5092a051ca56773fa4f0cd0c75" translate="yes" xml:space="preserve">
          <source>BlockedOnOther</source>
          <target state="translated">BlockedOnOther</target>
        </trans-unit>
        <trans-unit id="3804172b29d85f99db9a290a3dd685ef7d5c8d84" translate="yes" xml:space="preserve">
          <source>BlockedOnSTM</source>
          <target state="translated">BlockedOnSTM</target>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="7d44bc449c2a26374800a503f10f3d8949505f40" translate="yes" xml:space="preserve">
          <source>Blue</source>
          <target state="translated">Blue</target>
        </trans-unit>
        <trans-unit id="718a7e8a582e982e452dd5700addba4ffc1cf40d" translate="yes" xml:space="preserve">
          <source>Body</source>
          <target state="translated">Body</target>
        </trans-unit>
        <trans-unit id="0120b648baeefab9ba6ebfa6450b325f6a60cba8" translate="yes" xml:space="preserve">
          <source>BodyQ</source>
          <target state="translated">BodyQ</target>
        </trans-unit>
        <trans-unit id="daf760a167a8047cee872015a8e80002f3b67442" translate="yes" xml:space="preserve">
          <source>Bool</source>
          <target state="translated">Bool</target>
        </trans-unit>
        <trans-unit id="3f8b6ea3af3c50fa9d094ce543d63a1358584bcf" translate="yes" xml:space="preserve">
          <source>Boolean &quot;and&quot;</source>
          <target state="translated">부울 &quot;and&quot;</target>
        </trans-unit>
        <trans-unit id="69265825ad6d4c4d64bf7e08030ff39e70a968fa" translate="yes" xml:space="preserve">
          <source>Boolean &quot;not&quot;</source>
          <target state="translated">부울 &quot;not&quot;</target>
        </trans-unit>
        <trans-unit id="b22b4e8199107440fbfe7d97c6a6e57037c7151d" translate="yes" xml:space="preserve">
          <source>Boolean &quot;or&quot;</source>
          <target state="translated">부울 &quot;또는&quot;</target>
        </trans-unit>
        <trans-unit id="eb9c2517131e28267052868fb04f87dd8cb84e01" translate="yes" xml:space="preserve">
          <source>Boolean monoid under conjunction (&lt;code&gt;&lt;a href=&quot;data-bool#v:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 된 부울 모노 이드 ( &lt;code&gt;&lt;a href=&quot;data-bool#v:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c181263cf12be8452e7085b87f90b355a0cc7ef9" translate="yes" xml:space="preserve">
          <source>Boolean monoid under disjunction (&lt;code&gt;&lt;a href=&quot;data-bool#v:-124--124-&quot;&gt;||&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">분리 된 부울 모노 이드 ( &lt;code&gt;&lt;a href=&quot;data-bool#v:-124--124-&quot;&gt;||&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2732eeea43125f2e843ab5f5666a8d163b3d9289" translate="yes" xml:space="preserve">
          <source>Boolean type-level equality</source>
          <target state="translated">부울 유형 수준 평등</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="98b4ea6bcdbb948d8cbe34481cd1c0a07bd194e0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; exist to match the interface provided in the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; type class, but it is recommended to implement &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instances using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; as opposed to &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt;, since the former is more efficient than the latter. For example:</source>
          <target state="translated">두 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 는 에서 제공하는 인터페이스에 맞게 존재하는 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 유형 클래스를 있지만 구현하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; 사용하여 인스턴스 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 을 반대 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; 전자가 후자보다 더 효율적이기 때문에를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f34f496978794b63af2a314d45c261e70ec11ca" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; exist to match the interface provided in the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; type class, but it is recommended to implement &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; instances using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; as opposed to &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt;, since the former is more efficient than the latter. For example:</source>
          <target state="translated">두 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 는 에서 제공하는 인터페이스에 맞게 존재하는 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 유형 클래스를 있지만 구현하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; 사용하여 인스턴스 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 을 반대 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; 전자가 후자보다 더 효율적이기 때문에를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b731e5f2cccb2521565e021975320c572150ee8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;, and pick an arbitrary one if multiple choices are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; 둘 다 선택 가능하고 여러 선택 사항이있는 경우 임의의 것을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4d60c7bb83c292da504a6719a69ebefefdf4659e" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlapping&quot;&gt;Overlapping&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">모두 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlapping&quot;&gt;Overlapping&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b44c00c13cb83fe026cbd5b8d4d766f125c9858" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F0&lt;/code&gt; have kind &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but their arity differs.</source>
          <target state="translated">둘 다 &lt;code&gt;F1&lt;/code&gt; 과 &lt;code&gt;F0&lt;/code&gt; &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 대해 종류가 있습니다 . k-&amp;gt; 유형 이지만 배열이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c5124f48e35e2fbfeb662d20bdb90a9e2a8cb8e0" translate="yes" xml:space="preserve">
          <source>Both module &lt;code&gt;Class&lt;/code&gt; and module &lt;code&gt;Dangerous&lt;/code&gt; will compile under &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; without issue. However, in module &lt;code&gt;TCB_Runner&lt;/code&gt;, we must check if the call to &lt;code&gt;op&lt;/code&gt; in function &lt;code&gt;f&lt;/code&gt; is safe.</source>
          <target state="translated">모듈 &lt;code&gt;Class&lt;/code&gt; 와 모듈 &lt;code&gt;Dangerous&lt;/code&gt; 모두 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 없이 안전하게 컴파일됩니다 . 그러나 &lt;code&gt;TCB_Runner&lt;/code&gt; 모듈 에서 함수 &lt;code&gt;f&lt;/code&gt; 의 &lt;code&gt;op&lt;/code&gt; 호출 이 안전한지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="49ffa16e1c07272dd28d622d9dbdc1c18ed54d66" translate="yes" xml:space="preserve">
          <source>Both of these hold:</source>
          <target state="translated">이 두 가지 모두 보유 :</target>
        </trans-unit>
        <trans-unit id="2bafd70b5ada2ef0c84297ccc53777ff415bca1e" translate="yes" xml:space="preserve">
          <source>Both the type &lt;code&gt;Ex&lt;/code&gt; and the data constructor &lt;code&gt;MkEx&lt;/code&gt; get promoted, with the polymorphic kind &lt;code&gt;'MkEx :: forall k. k -&amp;gt; Ex&lt;/code&gt;. Somewhat surprisingly, you can write a type family to extract the member of a type-level existential:</source>
          <target state="translated">&lt;code&gt;Ex&lt;/code&gt; 유형 과 데이터 생성자 &lt;code&gt;MkEx&lt;/code&gt; 모두 다형성 종류 &lt;code&gt;'MkEx :: forall k. k -&amp;gt; Ex&lt;/code&gt; 승격 됩니다. k-&amp;gt; 예 . 놀랍게도, 유형 레벨 존재의 멤버를 추출하기 위해 유형 패밀리를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="361b42712506425fdcf2b1ea50a51aa8dea82ef8" translate="yes" xml:space="preserve">
          <source>Both upper- and lower-case &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'F'&lt;/code&gt; are converted as well, to &lt;code&gt;10..15&lt;/code&gt;.</source>
          <target state="translated">대문자와 소문자 &lt;code&gt;'A'&lt;/code&gt; 에서 &lt;code&gt;'F'&lt;/code&gt; &lt;code&gt;10..15&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ecb0b65529079a3af9e45a8098a612b9728453e3" translate="yes" xml:space="preserve">
          <source>BothQueues</source>
          <target state="translated">BothQueues</target>
        </trans-unit>
        <trans-unit id="403591682693529ea8d764be443089ceac85ad97" translate="yes" xml:space="preserve">
          <source>Bound Threads</source>
          <target state="translated">바운드 스레드</target>
        </trans-unit>
        <trans-unit id="60da7217d44bdc40c1eb907204fa54294872b81f" translate="yes" xml:space="preserve">
          <source>Bound threads can be created using the &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; function below. All foreign exported functions are run in a bound thread (bound to the OS thread that called the function). Also, the &lt;code&gt;main&lt;/code&gt; action of every Haskell program is run in a bound thread.</source>
          <target state="translated">바운드 스레드는 아래 의 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 만들 수 있습니다 . 외부로 내 보낸 모든 함수는 바운드 스레드 (함수를 호출 한 OS 스레드에 바운드)에서 실행됩니다. 또한 모든 Haskell 프로그램 의 &lt;code&gt;main&lt;/code&gt; 동작은 바운드 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb360f4682f39da897d5087bec41a43fcf97967" translate="yes" xml:space="preserve">
          <source>Bounded</source>
          <target state="translated">Bounded</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
