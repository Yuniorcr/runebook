<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="54d23f1b51b28443437bdea1984b504051aa0e98" translate="yes" xml:space="preserve">
          <source>O(n) Sort a ByteString efficiently, using counting sort.</source>
          <target state="translated">O (n) 카운팅 정렬을 사용하여 ByteString을 효율적으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="5276f6a20abfcdad68162965818c306dfe1fc5e9" translate="yes" xml:space="preserve">
          <source>O(n) Splits a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 구분 기호로 구분 된 구성 요소로 분할합니다 . 여기서 술어는 구분 요소에 대해 True를 반환합니다. 결과 구성 요소에는 구분 기호가 없습니다. 인접한 두 개의 구분 기호는 출력에서 ​​빈 구성 요소를 만듭니다. 예.</target>
        </trans-unit>
        <trans-unit id="d5b615abd7315879ff2b502fc191c080d2b5e7cb" translate="yes" xml:space="preserve">
          <source>O(n) Splits a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 구분 기호로 구분 된 구성 요소로 분할합니다 . 여기서 술어는 구분 요소에 대해 True를 반환합니다. 결과 구성 요소에는 구분 기호가 없습니다. 인접한 두 개의 구분 기호는 출력에서 ​​빈 구성 요소를 만듭니다. 예.</target>
        </trans-unit>
        <trans-unit id="dd28605ebd157f3a8e65b56f892bdc64f32d4010" translate="yes" xml:space="preserve">
          <source>O(n) Splits a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 구분 기호로 구분 된 구성 요소로 분할합니다 . 여기서 술어는 구분 요소에 대해 True를 반환합니다. 결과 구성 요소에는 구분 기호가 없습니다. 인접한 두 개의 구분 기호는 출력에서 ​​빈 구성 요소를 만듭니다. 예.</target>
        </trans-unit>
        <trans-unit id="f051211d534df030e6c0fe44bae67cb1a33f3fc3" translate="yes" xml:space="preserve">
          <source>O(n) Splits a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 구분 기호로 구분 된 구성 요소로 분할합니다 . 여기서 술어는 구분 요소에 대해 True를 반환합니다. 결과 구성 요소에는 구분 기호가 없습니다. 인접한 두 개의 구분 기호는 출력에서 ​​빈 구성 요소를 만듭니다. 예.</target>
        </trans-unit>
        <trans-unit id="e72b6bbcf0928556060cada219764d08ed0ef684" translate="yes" xml:space="preserve">
          <source>O(n) Splits a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구분 기호로 구분 된 구성 요소로 분할합니다 . 여기서 술어는 구분 요소에 대해 True를 반환합니다. 결과 구성 요소에는 구분 기호가 없습니다. 인접한 두 개의 구분 기호는 출력에서 ​​빈 구성 요소를 만듭니다. 예.</target>
        </trans-unit>
        <trans-unit id="c9c9c52d5507bf0a1362d9d6eb1459f8dbceee8f" translate="yes" xml:space="preserve">
          <source>O(n) Splits a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into components of length &lt;code&gt;k&lt;/code&gt;. The last element may be shorter than the other chunks, depending on the length of the input. Examples:</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 길이가 &lt;code&gt;k&lt;/code&gt; 인 구성 요소로 나눕니다 . 마지막 요소는 입력 길이에 따라 다른 청크보다 짧을 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="3db8b59b215c64e4858820ace39deb63f5ef93dc" translate="yes" xml:space="preserve">
          <source>O(n) Splits a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구분 기호로 구분 된 구성 요소로 분할합니다 . 여기서 술어는 구분 요소에 대해 True를 반환합니다. 결과 구성 요소에는 구분 기호가 없습니다. 인접한 두 개의 구분 기호는 출력에서 ​​빈 구성 요소를 만듭니다. 예.</target>
        </trans-unit>
        <trans-unit id="c403c54eaa24702629db685df74d2202ae65ae7c" translate="yes" xml:space="preserve">
          <source>O(n) Splits a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into components of length &lt;code&gt;k&lt;/code&gt;. The last element may be shorter than the other chunks, depending on the length of the input. Examples:</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 길이가 &lt;code&gt;k&lt;/code&gt; 인 구성 요소로 나눕니다 . 마지막 요소는 입력 길이에 따라 다른 청크보다 짧을 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="bc0ed6a2e5abab3c2af1fffe84e006e507b78481" translate="yes" xml:space="preserve">
          <source>O(n) Stream index (subscript) operator, starting from 0.</source>
          <target state="translated">O (n) 스트림 인덱스 (첨자) 연산자 (0부터 시작)</target>
        </trans-unit>
        <trans-unit id="abf500040205ebaec3458e20f45362c69575946d" translate="yes" xml:space="preserve">
          <source>O(n) Take a character and place it between each of the characters of a 'Stream Char'.</source>
          <target state="translated">O (n) 문자를 가져 와서 'Stream Char'의 각 문자 사이에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="ba00e0bb750076ee754340652d5421d865e398e6" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 함수는 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 쿼리 요소와 동일한 첫 번째 요소의 인덱스를 반환 하거나, 해당 요소 가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다. 이 구현은 memchr (3)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="121675d1840fbaa29d3baded683d9de7ada4553e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</target>
        </trans-unit>
        <trans-unit id="7294ce34f08b2f69290e63e44d0a2f7f0df9cf2c" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; 함수는 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 쿼리 요소와 동일한 요소의 마지막 인덱스를 반환하거나, 해당 요소 가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다. 다음과 같은 내용이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="01ad593ea875673c760705f00dd2e9f31036077b" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</target>
        </trans-unit>
        <trans-unit id="ccc1353ce0f5124b0c0af322be329b6da6b0666a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order. This implementation uses memchr(3).</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 함수 는 쿼리 요소와 동일한 모든 요소의 인덱스를 오름차순으로 반환하여 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 를 확장 합니다. 이 구현은 memchr (3)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93df213cf84b0bfc446b88725217c1f423fa166d" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 함수는 술어와 ByteString을 가져 와서 술어와 일치하는 첫 번째 요소를 리턴하거나 해당 요소가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="162cd10856e8da3dc23ae59d2fd1e75531510006" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</target>
        </trans-unit>
        <trans-unit id="e9d07b2ff242a053b7eb44f2fc5489762d714e4e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 함수는 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 및 ByteString 목록을 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 목록의 각 요소 사이에 첫 번째 인수를 산재한 후 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="d743aba28ddf40289b0f49186ab0f81a611de9f7" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수가 얻어 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 및 산재 ''의 요소 사이의 바이트 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 . Lists의 intersperse 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="176f827e8821221b5e5ce3e505b74e7017297578" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . It is analogous to the intersperse function on Lists.</target>
        </trans-unit>
        <trans-unit id="204c8f3b5bf971a266fd5d2c26559d5349e784c3" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first is a prefix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 사용하고 첫 번째가 두 번째의 접두사이면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bb28a0f8bc4d0410bd07454eb55bb93a3c192636" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first is a prefix of the second.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first is a prefix of the second.</target>
        </trans-unit>
        <trans-unit id="871f9c5f00615752cd36e68b1218a247b69131eb" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 사용하고 첫 번째는 두 번째의 접미사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="87cde1ed18f64595d44ca444a2616e7327ffe51b" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</target>
        </trans-unit>
        <trans-unit id="388dae8f9d8b26fb69cfbb7d78d16681f122959b" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a ByteString and returns the pair of ByteStrings with elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 함수는 술어에 ByteString을 사용하고 술어를 만족 시키거나 만족시키지 않는 요소가있는 ByteString 쌍을 리턴합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="2b57b2469071deaf282a837bfc802963cc1597c5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 가져 와서 두 번째 iff의 나머지 부분 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 리턴 하고 첫 번째는 접두어이고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f588b9fa31fb978c11d85f825d24a4d059923b15" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fd9dc1000a007fa9c22b27409807a7d9882fd24" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O는 (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 의 함수는 두 ByteStrings 반환됩니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 에 첫 번째로, 그렇지 않으면 그 접미사이며 IFF에 두 번째의 나머지 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8869ebcaeadfce416bbc4a772dc85ee316b0aff5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca40319b2d407b60450f114877926f6aef08263" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 함수는 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 쿼리 요소와 같은 memchr 에 의해 첫 번째 요소의 인덱스를 반환 하거나, 해당 요소 가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a623a2e7ab16687e15b7389f51430d9694a49a76" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</target>
        </trans-unit>
        <trans-unit id="b069c53a86831c1f35b201fd23f97804ba271e70" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; 함수는 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 쿼리 요소와 동일한 요소의 마지막 인덱스를 반환하거나, 해당 요소 가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다. 다음과 같은 내용이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="bcd0c8abeed2e6fe6cecb561a965ed6de29084ce" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</target>
        </trans-unit>
        <trans-unit id="109dc784a46f924102c9371c0163263be5259b44" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 함수 는 쿼리 요소와 동일한 모든 요소의 인덱스를 오름차순으로 반환하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="f15dbd18568ca22aed7b141ad4cb9a7ceeda48fd" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 함수는 술어와 ByteString을 가져 와서 술어와 일치하는 첫 번째 요소를 리턴하거나 해당 요소가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="78caed37e8b75710f6071164afd28f48c6893c53" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</target>
        </trans-unit>
        <trans-unit id="2ab21dee7ace87b1b9d574f98491108d09b49623" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 함수는 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 및 ByteString 목록을 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 목록의 각 요소 사이에 첫 번째 인수를 산재한 후 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="1997be7191b1cdb47b92b9592eb394b0e2e9f3d8" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a Char and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that Char between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수 숯불 및 소요 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 와 요소 간의 산재 ''이 숯불 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 . Lists의 intersperse 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="bf43d4fe89323cd0ec220757b72e55ae7e0dcfeb" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first is a prefix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 사용하고 첫 번째가 두 번째의 접두사이면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a0ceced28c4c7f9088f6dcc1fb8c4fbe93bf6a47" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first is a prefix of the second.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first is a prefix of the second.</target>
        </trans-unit>
        <trans-unit id="bb36530bbce5b5bf07e0e94bc65e635935afe3b9" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 사용하고 첫 번째는 두 번째의 접미사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bf935607ebfe208676cfcb72dfaeb5d753a7131d" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</target>
        </trans-unit>
        <trans-unit id="2689304446b95c07ffc19087bb94b671d87056a3" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 가져 와서 두 번째 iff의 나머지 부분 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 리턴 하고 첫 번째는 접두어이고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6a1f455049738b96828b1fab74acaaff9f560988" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91158d8244af0c5ddcf54bbc424a1f3ce8465455" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O는 (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 의 함수는 두 ByteStrings 반환됩니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 에 첫 번째로, 그렇지 않으면 그 접미사이며 IFF에 두 번째의 나머지 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7a00cf455b4aaa94ffcbf1b27f30d2d4b983381" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f8ff6cc69b22bf1456425678371604ae8bf9764" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 함수는 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 쿼리 요소와 동일한 첫 번째 요소의 인덱스를 반환 하거나, 해당 요소 가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다. 이 구현은 memchr (3)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a398352b17c6d52739d44d57e844810d9fdaa8f4" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</target>
        </trans-unit>
        <trans-unit id="0af10507b5ea81f6fcabbaeba877b14d1834c332" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; 함수는 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 쿼리 요소와 동일한 요소의 마지막 인덱스를 반환하거나, 해당 요소 가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다. 다음과 같은 내용이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="14c7bf68b17f49e8b32db0d15573be43d627b498" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</target>
        </trans-unit>
        <trans-unit id="fbcfdfda801794a07662249df86f86aa5cd0b663" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order. This implementation uses memchr(3).</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 함수 는 쿼리 요소와 동일한 모든 요소의 인덱스를 오름차순으로 반환하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 를 확장 합니다. 이 구현은 memchr (3)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="621e458fd04dd53651e92111855033d450b93228" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 함수는 술어와 ByteString을 가져 와서 술어와 일치하는 첫 번째 요소를 리턴하거나 해당 요소가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="37315a1539ac148f8b197ee303a4f06afb4f713e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</target>
        </trans-unit>
        <trans-unit id="31976f5cbdfc98ce2993d12f12e761df2fe1de07" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 함수는 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 및 ByteString 목록을 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 목록의 각 요소 사이에 첫 번째 인수를 산재한 후 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="aebda77cb9bcb702165b5d974f705234751405b9" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 사용하고 첫 번째가 두 번째의 접두사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8377f8842146cb9bdcb129fae39524350bd295ef" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</target>
        </trans-unit>
        <trans-unit id="5266ce310e43a8dcba567f8d3dcfa9331f32a63e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 사용하고 첫 번째는 두 번째의 접미사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ededa77d9c7a6776d6ecc0d36aade061de841310" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</target>
        </trans-unit>
        <trans-unit id="1df8e27dd6e4c9975b3d6d1b678e792607bef5ca" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a ByteString and returns the pair of ByteStrings with elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 함수는 술어에 ByteString을 사용하고 술어를 만족 시키거나 만족시키지 않는 요소가있는 ByteString 쌍을 리턴합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="b44a44b7bb991d29a4a3fcd4bbb247c4297ebd80" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 가져 와서 두 번째 iff의 나머지 부분 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 리턴 하고 첫 번째는 접두어이고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1df3964205eddb193d5cfd1b8c5f213312e6d32f" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18e1c4f9b5362a4eb0efebdb1d98d53cd92d25d4" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O는 (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 의 함수는 두 ByteStrings 반환됩니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 에 첫 번째로, 그렇지 않으면 그 접미사이며 IFF에 두 번째의 나머지 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0478fa49c399cf7deb0653820dcb2078ffa8c79" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db96fc5014a3b5e25cf1a26e16811daadd87dee0" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 함수는 List 'unfoldr'와 유사합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 시드 값에서 ByteString을 빌드합니다. 이 함수는 요소 반환지지 않습니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그것을 할 경우 ByteString 또는 수익을 생산 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 이 경우, &lt;code&gt;a&lt;/code&gt; ByteString에 prepending이이며, &lt;code&gt;b&lt;/code&gt; 재귀 호출의 다음 요소로 사용된다.</target>
        </trans-unit>
        <trans-unit id="ef57000706634199824077e8a68f4bb5c18e225c" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; , in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</target>
        </trans-unit>
        <trans-unit id="9f2e8576d1e158cac9c7cbea7febf733692b2170" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 함수는 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 쿼리 요소와 같은 memchr 에 의해 첫 번째 요소의 인덱스를 반환 하거나, 해당 요소 가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa1c69306c01d9d2337e3925ac50275e90ff6cc0" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</target>
        </trans-unit>
        <trans-unit id="2ec8e9f3c268a55e1a8cc1231f1eae1abb77d29a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 함수 는 쿼리 요소와 동일한 모든 요소의 인덱스를 오름차순으로 반환하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="90b21d94f3c4b1320ba1626339daeec7770ba1e2" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 함수는 술어와 ByteString을 가져 와서 술어와 일치하는 첫 번째 요소를 리턴하거나 해당 요소가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5279735e72e89d06c3a1fde73bc9f386b870f61e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</target>
        </trans-unit>
        <trans-unit id="783d0496db965e51d6cb762b18cde0603137b5c1" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 함수는 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 및 ByteString 목록을 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 목록의 각 요소 사이에 첫 번째 인수를 산재한 후 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="3dd83c62c3c268df717539e323562675cc5430f8" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a Char and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that Char between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수 숯불 및 소요 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 와 요소 간의 산재 ''이 숯불 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 . Lists의 intersperse 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="372a2b3dc42980d37508731eb80bf6db7d2199d5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 사용하고 첫 번째가 두 번째의 접두사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="91332377f7f70899a0ae41286769ec2db1c8413a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</target>
        </trans-unit>
        <trans-unit id="c394b71edebe9c2ef371ba928c756427e7aad665" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 사용하고 첫 번째는 두 번째의 접미사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e580d884d8ad04ca31c3dd1da0be9cd9d9371459" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</target>
        </trans-unit>
        <trans-unit id="da2d448e19017177a615154734c18743b68888cd" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 ByteString을 가져 와서 두 번째 iff의 나머지 부분 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 리턴 하고 첫 번째는 접두어이고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="51d95e44f921fca12780d855c9f3e162160c7c7f" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f201f1907b48b3a7cc6cc99b33ecee717dde57d" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O는 (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 의 함수는 두 ByteStrings 반환됩니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 에 첫 번째로, 그렇지 않으면 그 접미사이며 IFF에 두 번째의 나머지 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e59cfc58400ce23ac75fa42c3f44b6c1e97e7f86" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b0c4cfcabfa18f0f9d991cbd407b72c68d8fb33" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 함수는 List 'unfoldr'와 유사합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 시드 값에서 ByteString을 빌드합니다. 이 함수는 요소 반환지지 않습니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그것을 할 경우 ByteString 또는 수익을 생산 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 이 경우, &lt;code&gt;a&lt;/code&gt; ByteString에 prepending이이며, &lt;code&gt;b&lt;/code&gt; 재귀 호출의 다음 요소로 사용된다.</target>
        </trans-unit>
        <trans-unit id="21c6075e8b47b7fa1e041e7edecb7535466dea75" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; , in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</target>
        </trans-unit>
        <trans-unit id="9a79fe1dc6f18eb8f680df25925a90f02b4b12c6" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the first element matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 함수는 술어와 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 가져와 술어와 일치하는 첫 번째 요소를 반환하거나 해당 요소가없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e0b837386ac594b44e5cf6d096e613510179aab" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; satisfying the predicate. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 함수는 술어와 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 가져 와서 술어를 만족시키는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에서 첫 번째 요소의 인덱스를 리턴합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d3f4379f27a35ffcc42ed8fdb56412243f58b2" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">이 O (n)은 &lt;code&gt;&lt;a href=&quot;data-text#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 함수 얻어 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 및 목록 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 들과리스트의 각 요소의 첫번째 인수 산재 후 목록을 연결.</target>
        </trans-unit>
        <trans-unit id="e836e26f77556c0c8b0cc26ff73d34938e7b0047" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a character and places it between the characters of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수는 문자를 받아서 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 문자 사이에 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="984aa17d031ef64073f3da8a43c7bf9548dd919f" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 취하고 첫 번째가 두 번째의 접두사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21fdc0a25cfb046efd48b241930d19eb078c970" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 취하고 첫 번째가 두 번째의 접미사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3ab19dcdc36cc1c990891fc53ddbd925d7e04441" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the pair of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s with elements which do and do not satisfy the predicate, respectively; i.e.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 함수는 술어와 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 가져 와서 술어를 만족하거나 만족하지 않는 요소와 함께 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 쌍을 리턴합니다 . 즉</target>
        </trans-unit>
        <trans-unit id="0268ba154bc2df65369ee7c9f2860a69e5f12720" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; argument. Note that this function uses &lt;code&gt;&lt;a href=&quot;data-text#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, and the list version of transpose, and is thus not very efficient.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 함수는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 인수 의 행과 열을 전치합니다 . 이 함수는 &lt;code&gt;&lt;a href=&quot;data-text#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-text#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 및 transpose의 목록 버전을 사용하므로 매우 효율적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f251ba2e248e15eaccaea66658fe246c0b91a6a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:countCharI&quot;&gt;countCharI&lt;/a&gt;&lt;/code&gt; function returns the number of times the query element appears in the given stream.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:countCharI&quot;&gt;countCharI&lt;/a&gt;&lt;/code&gt; 함수는 쿼리 요소가 지정된 스트림에 나타나는 횟수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6eaaa8e81e7668e011fec45f05f761f3572874b5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findBy&quot;&gt;findBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findBy&quot;&gt;findBy&lt;/a&gt;&lt;/code&gt; 함수는 술어와 스트림을 가져 와서 술어와 일치하는 첫 번째 요소를 리턴하거나 해당 요소가 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b284a7b295ef70c67ab5d6c8855dc29d511a07b7" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 을 취하고 첫 번째가 두 번째의 접두사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="25a5607aba7f8c2bbb7401fa4d562110e6df9f7e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 함수는 술어와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 가져 와서 술어와 일치하는 첫 번째 요소를 리턴하거나 해당 요소가없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95828d7cd49664c5ab7bed1d6891046b6c1333a5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">이 O (n)은 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 함수 얻어 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 및 목록 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 들과리스트의 각 요소의 첫번째 인수 산재 후 목록을 연결.</target>
        </trans-unit>
        <trans-unit id="3cae76bc8927661b489edb3e78bf012fb490d938" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a character and places it between the characters of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수는 문자를 받아서 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 문자 사이에 배치합니다 . 융합 될 수 있습니다. 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="97bb42a55cb8c57d4f1fbc3342c90cdb42316d3c" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 취하고 첫 번째가 두 번째의 접두사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="074610c8ab674e115547afb68793bda621fadeef" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 취하고 첫 번째가 두 번째의 접미사 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="57a78956fd1a59e10ea99a16e76360b37ac4ecaa" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the pair of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s with elements which do and do not satisfy the predicate, respectively; i.e.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 함수는 술어와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 가져 와서 술어를 만족하거나 만족하지 않는 요소와 함께 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 쌍을 리턴합니다 . 즉</target>
        </trans-unit>
        <trans-unit id="6eeaa345a563e0fa2e5c1f6c8f36ad488f35a4ed" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; argument. Note that this function uses &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, and the list version of transpose, and is thus not very efficient.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 함수는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 인수 의 행과 열을 전치합니다 . 이 함수는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 및 transpose의 목록 버전을 사용하므로 매우 효율적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51ae577567561237689dc6b0d14f758718ddd181" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;count&lt;/code&gt; function returns the number of times the query element appears in the given stream.</source>
          <target state="translated">O (n) &lt;code&gt;count&lt;/code&gt; 함수는 쿼리 요소가 지정된 스트림에 나타나는 횟수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc7ee14d7eade919f222af426593eaafcbfc0185" translate="yes" xml:space="preserve">
          <source>O(n) all &lt;code&gt;p &lt;/code&gt;xs determines if all characters in the &lt;code&gt;Text&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; satisfy the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">O (n) all &lt;code&gt;p &lt;/code&gt; xs는 &lt;code&gt;Text&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 의 모든 문자 가 술어 &lt;code&gt;p&lt;/code&gt; 를 만족 하는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="79cec94da8772ae50c6e028ddd630af1260aec70" translate="yes" xml:space="preserve">
          <source>O(n) any &lt;code&gt;p &lt;/code&gt;xs determines if any character in the stream &lt;code&gt;xs&lt;/code&gt; satisfies the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">O (n) any &lt;code&gt;p &lt;/code&gt; xs는 스트림 &lt;code&gt;xs&lt;/code&gt; 의 문자 가 술어 &lt;code&gt;p&lt;/code&gt; 를 만족 하는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="9bc987e83d1621e87ef81a9eb7f6a9f52d5bf7ab" translate="yes" xml:space="preserve">
          <source>O(n) construction Use a &lt;code&gt;ByteString&lt;/code&gt; with a function requiring a &lt;code&gt;CStringLen&lt;/code&gt;. As for &lt;code&gt;useAsCString&lt;/code&gt; this function makes a copy of the original &lt;code&gt;ByteString&lt;/code&gt;. It must not be stored or used after the subcomputation finishes.</source>
          <target state="translated">O (n)이 건설 사용하십시오 &lt;code&gt;ByteString&lt;/code&gt; 필요로하는 기능을 &lt;code&gt;CStringLen&lt;/code&gt; 을 . 에 관해서는 &lt;code&gt;useAsCString&lt;/code&gt; 이 기능을 원래의 사본하게 &lt;code&gt;ByteString&lt;/code&gt; 을 . 하위 계산이 완료된 후에는 저장하거나 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3f42f538b318943c153831ed08e2685c23285c0d" translate="yes" xml:space="preserve">
          <source>O(n) construction Use a &lt;code&gt;ByteString&lt;/code&gt; with a function requiring a null-terminated &lt;code&gt;CString&lt;/code&gt;. The &lt;code&gt;CString&lt;/code&gt; is a copy and will be freed automatically; it must not be stored or used after the subcomputation finishes.</source>
          <target state="translated">O (n) 생성 null로 끝나는 &lt;code&gt;CString&lt;/code&gt; 이 필요한 함수와 함께 &lt;code&gt;ByteString&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;CString&lt;/code&gt; 을은 복사하고 자동으로 해제됩니다; 하위 계산이 완료된 후 저장하거나 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c846ca8d154a7b0a9fb00359353de049647ae99b" translate="yes" xml:space="preserve">
          <source>O(n) construction. Use a &lt;code&gt;ShortByteString&lt;/code&gt; with a function requiring a &lt;code&gt;CStringLen&lt;/code&gt;. As for &lt;code&gt;useAsCString&lt;/code&gt; this function makes a copy of the original &lt;code&gt;ShortByteString&lt;/code&gt;. It must not be stored or used after the subcomputation finishes.</source>
          <target state="translated">O (n) 구조. 용도 &lt;code&gt;ShortByteString&lt;/code&gt; 을 필요로하는 기능을 &lt;code&gt;CStringLen&lt;/code&gt; 을 . 에 관해서는 &lt;code&gt;useAsCString&lt;/code&gt; 이 기능을 원래의 사본하게 &lt;code&gt;ShortByteString&lt;/code&gt; 을 . 하위 계산이 완료된 후에는 저장하거나 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2e24f4a921886ebc8dee74e604e63c1bc88cd4f7" translate="yes" xml:space="preserve">
          <source>O(n) construction. Use a &lt;code&gt;ShortByteString&lt;/code&gt; with a function requiring a null-terminated &lt;code&gt;CString&lt;/code&gt;. The &lt;code&gt;CString&lt;/code&gt; is a copy and will be freed automatically; it must not be stored or used after the subcomputation finishes.</source>
          <target state="translated">O (n) 구조. null로 끝나는 &lt;code&gt;CString&lt;/code&gt; 이 필요한 함수와 함께 &lt;code&gt;ShortByteString&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;CString&lt;/code&gt; 을은 복사하고 자동으로 해제됩니다; 하위 계산이 완료된 후 저장하거나 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7cf753ad2eeb7c815eac4d51d25857fb8075e367" translate="yes" xml:space="preserve">
          <source>O(n) maximum returns the maximum value from a stream, which must be non-empty.</source>
          <target state="translated">O (n) 최대 값은 스트림에서 최대 값을 반환하며,이 값은 비어 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7c447d6fd523c0d0c62fdb16120768a0538cec15" translate="yes" xml:space="preserve">
          <source>O(n) minimum returns the minimum value from a &lt;code&gt;Text&lt;/code&gt;, which must be non-empty.</source>
          <target state="translated">O (n) minimum은 &lt;code&gt;Text&lt;/code&gt; 에서 최소값을 반환합니다.이 값은 비어 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8b47776ea350b828e4782c8b7d2e87c90ff26b41" translate="yes" xml:space="preserve">
          <source>O(n) stream index (subscript) operator, starting from 0.</source>
          <target state="translated">0부터 시작하는 O (n) 스트림 인덱스 (첨자) 연산자</target>
        </trans-unit>
        <trans-unit id="2a179679d6c92f2ff0a3ed59f1ae3c6c726098c1" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;. In this case, &lt;code&gt;a&lt;/code&gt; is the next &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n). 여기서 &lt;code&gt;n&lt;/code&gt; 은 결과 길이입니다. &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 기능은 목록 유사하다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 시드 값에서 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 작성 합니다. 이 함수는 요소를 가져와 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 생성이 완료되면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환하고 , 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 를 반환 합니다. 이 경우 &lt;code&gt;a&lt;/code&gt; 는 문자열에서 다음 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 이고 &lt;code&gt;b&lt;/code&gt; 는 추가 생산을위한 시드 값입니다. 융합 될 수 있습니다. 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="ff818ad54f1470dfc5f3acaa8418748ae7b95cf4" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;. In this case, &lt;code&gt;a&lt;/code&gt; is the next &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n). 여기서 &lt;code&gt;n&lt;/code&gt; 은 결과 길이입니다. &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 기능은 목록 유사하다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 시드 값에서 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 작성 합니다. 이 함수는 요소를 가져와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 생성이 완료되면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환하고 , 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 를 반환 합니다. 이 경우 &lt;code&gt;a&lt;/code&gt; 는 문자열에서 다음 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 이고 &lt;code&gt;b&lt;/code&gt; 는 추가 생산을위한 시드 값입니다. 융합 될 수 있습니다. 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0b6a73856d1308ea4b064a3d9fc6d62b223a3429" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The unfoldr function is analogous to the List &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. unfoldr builds a stream from a seed value. The function takes the element and returns Nothing if it is done producing the stream or returns Just (a,b), in which case, a is the next Char in the string, and b is the seed value for further production.</source>
          <target state="translated">O (n). 여기서 &lt;code&gt;n&lt;/code&gt; 은 결과 길이입니다. unfoldr 기능은 List &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 와 유사합니다 . unfoldr는 시드 값에서 스트림을 만듭니다. 이 함수는 스트림을 생성하거나 Just (a, b)를 반환하면 요소를 가져 와서 Nothing을 반환합니다.이 경우 a는 문자열에서 다음 Char이고 b는 추가 생성을위한 시드 값입니다.</target>
        </trans-unit>
        <trans-unit id="c03ab14925a542ebc519ea48d4a849680bd10f4a" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next byte in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O (n). 여기서 &lt;em&gt;n&lt;/em&gt; 은 결과 길이입니다. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 기능은 목록 'unfoldr'과 유사하다. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 시드 값에서 ByteString을 빌드합니다. 이 함수는 요소를 가져와 ByteString 생성을 완료하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 를 반환 하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .이 경우 &lt;code&gt;a&lt;/code&gt; 는 문자열의 다음 바이트이고 &lt;code&gt;b&lt;/code&gt; 는 추가 생성을위한 시드 값입니다.</target>
        </trans-unit>
        <trans-unit id="816ab5613d5257e41cd12eab24bceef2e1566aa0" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next byte in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; , in which case, &lt;code&gt;a&lt;/code&gt; is the next byte in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</target>
        </trans-unit>
        <trans-unit id="d0fde6970ba722285dbfb2bb86ba9ddab5e58ec9" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next character in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O (n). 여기서 &lt;em&gt;n&lt;/em&gt; 은 결과 길이입니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 기능은 목록 'unfoldr'과 유사하다. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 시드 값에서 ByteString을 빌드합니다. 이 함수는 ByteString 생성을 완료하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 를 반환하면 요소를 가져 와서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .이 경우 &lt;code&gt;a&lt;/code&gt; 는 문자열의 다음 문자이고 &lt;code&gt;b&lt;/code&gt; 는 추가 생산을위한 시드 값입니다.</target>
        </trans-unit>
        <trans-unit id="cdfbbdc5dc33e6b9add119167d0df5fbd5a5e58d" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next character in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; , in which case, &lt;code&gt;a&lt;/code&gt; is the next character in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</target>
        </trans-unit>
        <trans-unit id="ceaee61cf4c86a4cfedd55743379f704a86375c4" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 즉 , 순회 함수도 값과 연관된 키에 액세스 할 수 있다는 점을 제외하고 는 일반 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 동일하게 작동합니다. .</target>
        </trans-unit>
        <trans-unit id="a9a6e5489e15971815fbadc25cbc83a64b5a4e4e" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</target>
        </trans-unit>
        <trans-unit id="9ec18bf9617ddbc5f926dd7e90848c7b25f4cba2" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 즉 , 순회 함수도 값과 연관된 키에 액세스 할 수 있다는 점을 제외하고 는 일반 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 동일하게 작동합니다. .</target>
        </trans-unit>
        <trans-unit id="3854551c76b0975df5c831a06eac450d79a73884" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</target>
        </trans-unit>
        <trans-unit id="06a6b96e556967d134bb56ea9708d4004f451168" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 즉 , 순회 함수도 값과 연관된 키에 액세스 할 수 있다는 점을 제외하고 는 일반 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 동일하게 작동합니다. .</target>
        </trans-unit>
        <trans-unit id="bbe068fbb503e4b0b81cf66c9d125156d8ea7b1a" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</target>
        </trans-unit>
        <trans-unit id="2a28ae698d478e9723ab92a699f5a1fab2e893a9" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 처음 나타나는 제거 &lt;code&gt;x&lt;/code&gt; 의 목록 인수에서합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ccf20cdd3504967299316be3c4b583dca63bcaf2" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">의 위에). 술어 및 목록에 적용되는 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 요소의 목록을 리턴합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="d6fe1b11423245d1cb4e0bdb9854f834eff82c62" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 는 연관 목록에서 키를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="11f965321b8cf48b28368645a30a485a8fbe2bf3" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="8c55e4147006d30488e980655db22c957c6d3858" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 유사하다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 했으나 왼쪽 연속 감소 된 값의 목록을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="8cc7978dbf7398841fab5ef77987edff23cc46d3" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="3276e1977108db17ca404044fc0e4cf770d7f949" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 참고</target>
        </trans-unit>
        <trans-unit id="d4146ad1a8026cc64491869dab9073233e206c19" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="1acbc5396610d091e2bd3f021730a65076944055" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 이지만 &lt;code&gt;f&lt;/code&gt; 가 엄격하게 단조로운 경우에만 작동합니다 . 즉, 임의의 값이며, &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 경우, &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 다음 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; . &lt;em&gt;전제 조건이 점검되지 않았습니다. &lt;/em&gt;반 공식적으로, 우리는 :</target>
        </trans-unit>
        <trans-unit id="d5757263023c5cec22db23f29c037746af6d0da6" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 즉 , 순회 함수도 값과 연관된 키에 액세스 할 수 있다는 점을 제외하고 는 일반 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 동일하게 작동합니다. .</target>
        </trans-unit>
        <trans-unit id="e63a890a138b208c55c6769d80c83815c8ff5640" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">O(n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</target>
        </trans-unit>
        <trans-unit id="1cc472489dbc2ff3cc43835b13e34e467315dd41" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 이지만 &lt;code&gt;f&lt;/code&gt; 가 엄격하게 단조로운 경우에만 작동합니다 . 즉, 임의의 값이며, &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 경우, &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 다음 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; . &lt;em&gt;전제 조건이 점검되지 않았습니다. &lt;/em&gt;반 공식적으로, 우리는 :</target>
        </trans-unit>
        <trans-unit id="cea185f035e06b795818b7d4fabdc1b0fef0bf2b" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, it behaves much like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value and the values are forced before they are installed in the result map.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 즉, 그것은 많은 일반처럼 동작 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 제외 순회 기능은 또한 값과 연관된 키에 액세스 할 수 있으며 값은 결과 맵에 설치되기 전에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="7192133739e1c92cbd532c66d42709ac4c9a5de1" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, it behaves much like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value and the values are forced before they are installed in the result map.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 즉, 그것은 많은 일반처럼 동작 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 제외 횡단 기능은 값과 연관된 키에도 액세스 할 수 있으며 값은 결과 맵에 설치되기 전에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="8007dbe721f56ebc5e776bd43354f56a1b8e404f" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="46d3eacf6c15ed88627cd6de7787fa50dacce5f6" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">의 위에). 술어 및 목록에 적용되는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 요소의 목록을 리턴합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="0bf19886a76e7131793141b2d9864a2a0dbbfff4" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 유한 목록의 길이를 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 반환합니다 . 보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 결과 유형은 모든 종류의 숫자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db7f64169595886472ec744cb1bbafae98b3cf54" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 는 연관 목록에서 키를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f3ff23116ae72545d77549c1ec0fa0f5fd3e1c89" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="824f695c7c4f739b93537e96dcb9ff4e4c0a90bf" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 유사하다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 했으나 왼쪽 연속 감소 된 값의 목록을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="045e5a9f70a34641cb06644e1fa86228ab102908" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="310795a4329755dec2ed79c11b8311da1103913c" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 참고</target>
        </trans-unit>
        <trans-unit id="c6e1e31fd1fc11a0f2735b2a8cf7393a75f33e8f" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="b936791b29247c7f9b4e15048744b9cc7608afab" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 처음 나타나는 제거 &lt;code&gt;x&lt;/code&gt; 의 목록 인수에서합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9a6fcf6789e028094a541cbfbbfdfec2309d5a96" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">의 위에). 술어 및 목록에 적용되는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 요소의 목록을 리턴합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="05fbe4552475b693aab8bdf13ac7026cdbfe7ced" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 유한 목록의 길이를 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 반환합니다 . 보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 결과 유형은 모든 종류의 숫자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="254fff5a4de46ce9d178b5eff8cd85ac75de3880" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 는 연관 목록에서 키를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="48f176e190a0c5f600c3d2874157da1284586155" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="dde493ad53fbdb0bfd6f761be075cdd2f1f0c36a" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 유사하다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 했으나 왼쪽 연속 감소 된 값의 목록을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="8b28d83ba41d81f7b42565c540fb3b9c08212581" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="bc83e83adec5b4e7cc90c163f46c901f6b1fa2f7" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 참고</target>
        </trans-unit>
        <trans-unit id="573dea7ef43efaa5eecb101453bf66ef2aaa811e" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="d301cbe6e2600371f03d481dbffc35b50bec2f92" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">의 위에). 술어 및 목록에 적용되는 &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 요소의 목록을 리턴합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="dc73d88e92572b41dfdee704ea155b51c75e61b7" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 는 연관 목록에서 키를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="b743e350bfc904dbe5448ea57249e9ab73540707" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="d6a4c69de0dbafe4c5a63b928de7fd345bf43179" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 유사하다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 했으나 왼쪽 연속 감소 된 값의 목록을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="2bfac262165c91307a48da21d04f83e5bdb837ac" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="f46f289161b09cf495b972e219ff941b09fc1cc1" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 참고</target>
        </trans-unit>
        <trans-unit id="b5107a476769f8d488425004099579d97919ff1c" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="80685670a565df2994ff82358d8d9ff346ae50d8" translate="yes" xml:space="preserve">
          <source>O(n). A builder taking &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and copy it to a Builder, satisfying</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 을 가져와 빌더에 복사하여 만족하는 빌더</target>
        </trans-unit>
        <trans-unit id="70530ff33b2f16d9be90d2560f114d8dac8bfc71" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="c7380470e12e67adf60da39d725c225d497cd662" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="0bf0c60b5a6d8a2a055aaebd92dc0d1c6b5c103a" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="82457c61bd0e963eec702359fcd34f0ff32501f0" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="5a29f8d2a31048d9445b8886cc17d35b68969681" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="cc75e48d3a49b33e6f4a5c064a7700327c483fb6" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="a454f37660a51ebf61d9a9170dbc42b08c97ea8b" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="f37cf8f77f78f92b1d2b189d97d8a766dfb4b013" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="07b3e469f7af7089b4d7e6be8526028e5208ba72" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="6652cb2e4158f4edcbb03a44c914d8bbdcea8def" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="2f2d3eee8befdc90da40cb506768f425108997cf" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="fbfc0b3d401de0da22c833fd914cdf87cf3ad2ad" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="9c9b47ca6ec14a56ef0784dd784ebaba55d0ff1f" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="ea14a4b5caf215591432bbecd9c62674000ce961" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="ad005000b108f9f31078985fef50b64dda243665" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="e2e08f85d242295bd6a7359e0f4e3a1dd883998e" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="3ede2b5f5836896aa861499f8e3bf682ba69f6ec" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="83a96d043e8c0058beb4beed6a6fc723903d87e6" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="9dac0f730b434a42ae9957e2d7025be0a3627a87" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="ae0949840a8f862d0e211f4d923fc48b92807906" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="f28ab3bbfb1340b66378ee808be9d2a2987e7a8f" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="8b0acf8d5f562e1eaa30615815852e4b38d994a5" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="72f18a0b545c4ad6247523768dde2a7ce47f0810" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="b3f861bd5e903de24fdec1c75612861903c49750" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="cc72c076578869cc3de5b3d0c434dfa36f224709" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="835c9e3e5e07db560062a8c80415943a883c2334" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 . 다음 애플리케이션에서 결과를 사용하기 전에 운영자의 각 애플리케이션이 평가됩니다. 이 기능은 시작 값이 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="063cc731f27cbebf293ec9eacfc6553e106ac3a1" translate="yes" xml:space="preserve">
          <source>O(n). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">의 위에). 엄격하게 누적되는 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="dc1cd9ce113d0d3907dd9da1930ec270f5945076" translate="yes" xml:space="preserve">
          <source>O(n). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">의 위에). 엄격하게 누적되는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="85639e1d597282db08f70e9b2cb500f671d35a66" translate="yes" xml:space="preserve">
          <source>O(n). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">의 위에). 엄격하게 누적되는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="33971ce6acba8402c3758c76737e1c0b89d6c430" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Returns all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . 지도의 모든 키 / 값 쌍을 오름차순 키 순서로 반환합니다. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dfcf33bd47f25122dc59dfe1518c78eec0627929" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Returns all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . 지도의 모든 키 / 값 쌍을 오름차순 키 순서로 반환합니다. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="938ef8b59e329c83f3be432fd7651512e7c3d413" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Returns all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . 지도의 모든 키 / 값 쌍을 오름차순 키 순서로 반환합니다. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1dfa0cbbb13da3d38e8ee7d534675b7cc31c619a" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Return all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . 지도의 모든 키 / 값 쌍을 오름차순 키 순서로 반환합니다. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c1f6c65197a208e02e5f6e1c3db3c69651d3f940" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Return all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . 지도의 모든 키 / 값 쌍을 오름차순 키 순서로 반환합니다. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1916b10ea722263e2dfc142ca33d3e33943e58f3" translate="yes" xml:space="preserve">
          <source>O(n). An alias of &lt;code&gt;&lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. The elements of a set in ascending order. Subject to list fusion.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . 오름차순으로 세트의 요소. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c62ebbbdd6d3cb62f75691f5c5c1fd1fdc7d21f1" translate="yes" xml:space="preserve">
          <source>O(n). An alias of &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. The elements of a set in ascending order. Subject to list fusion.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . 오름차순으로 세트의 요소. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1986568dddd744d5fe0785ebc3f7919cddca61f4" translate="yes" xml:space="preserve">
          <source>O(n). An alias of &lt;code&gt;&lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. The elements of a set in ascending order. Subject to list fusion.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . 오름차순으로 세트의 요소. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3daacd528be89274a916e931b2d01da14ee9cdf7" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a descending list in linear time with a combining function for equal keys. &lt;em&gt;The precondition (input list is descending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 동일한 키에 대한 결합 기능을 사용하여 선형 시간으로 내림차순 목록에서 맵을 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 내림차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6daf271b34fd0ee22a7b221ce97aae9f534f7a50" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a descending list in linear time. &lt;em&gt;The precondition (input list is descending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 선형 시간으로 내림차순 목록에서 맵을 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 내림차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="729cb7b9c6526cbf116498bbd1a02e7f2fd9de41" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a descending list of distinct elements in linear time. &lt;em&gt;The precondition is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 선형 시간으로 고유 요소의 내림차순 목록에서 맵을 작성하십시오. &lt;em&gt;전제 조건이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04829e28a59536fa17ba4dd57fe84f7b01bbc53b" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a list of key/value pairs where the keys are in ascending order and all distinct. &lt;em&gt;The precondition (input list is strictly ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 키가 오름차순이고 모두 고유 한 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 엄격하게 오름차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc398f65e3d84504143cfc77896ba699dbca8682" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a list of key/value pairs where the keys are in ascending order, with a combining function on equal keys. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 동일한 키에 결합 기능을 사용하여 키가 오름차순 인 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 오름차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a000fae0b6e524a14b40c7d6b60b7b128b6dc6ca" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a list of key/value pairs where the keys are in ascending order.</source>
          <target state="translated">의 위에). 키가 오름차순 인 키 / 값 쌍 목록에서 맵을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9400af3afb5f52d7933a8fd94fe48f15d665625c" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a set of keys and a function which for each key computes its value.</source>
          <target state="translated">의 위에). 일련의 키와 각 키의 값을 계산하는 함수로 맵을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0d846e7d484766b6455d3d20fbac1d15237cbd78" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from an ascending list in linear time with a combining function for equal keys. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 동일한 키에 대한 결합 기능을 사용하여 선형 시간으로 오름차순 목록에서 맵을 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 오름차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="382dbb9f6886862ebe682148e2a1304e6e911ce0" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from an ascending list in linear time. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 선형 시간으로 오름차순 목록에서 맵을 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 오름차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9a9573ff4e725a34e321f32ef83a67f8acf6206" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from an ascending list of distinct elements in linear time. &lt;em&gt;The precondition is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 선형 시간으로 별개의 요소의 오름차순 목록에서 맵을 작성하십시오. &lt;em&gt;전제 조건이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dadd9ac678a4613069a434f429dc49502d3082e3" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from a descending list in linear time. &lt;em&gt;The precondition (input list is descending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 선형 시간으로 내림차순 목록에서 세트를 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 내림차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66e1fa93cd42026eaa1da1a002e30a7bf60afcc2" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from a descending list of distinct elements in linear time. &lt;em&gt;The precondition (input list is strictly descending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 선형 시간으로 고유 요소의 내림차순 목록에서 세트를 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 엄격하게 내림차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eee38f55e80530b1e9b1c715fe02e0a1e408a76" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from an ascending list in linear time. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 선형 시간으로 오름차순 목록에서 세트를 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 오름차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6809d6e2d235a847eb2c098caad8a6faa4a558da" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from an ascending list of distinct elements in linear time. &lt;em&gt;The precondition (input list is strictly ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 선형 시간으로 고유 요소의 오름차순 목록에서 세트를 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 엄격하게 오름차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9662193240858bcb94da0313cc5b5f335754ab0" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from an ascending list of distinct elements. &lt;em&gt;The precondition (input list is strictly ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 고유 한 요소의 오름차순 목록에서 세트를 작성하십시오. &lt;em&gt;전제 조건 (입력 목록이 엄격하게 오름차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af6905fb7dd9332dae81595f53ed13e17f3a7b3e" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from an ascending list of elements. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">의 위에). 오름차순 요소 목록에서 세트를 빌드하십시오. &lt;em&gt;전제 조건 (입력 목록이 오름차순)이 점검되지 않았습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0b8aa48e50c217480a7bac3595337f5cd713365" translate="yes" xml:space="preserve">
          <source>O(n). Cardinality of the set.</source>
          <target state="translated">의 위에). 세트의 카디널리티.</target>
        </trans-unit>
        <trans-unit id="87fc609c058362b77fb22012d92969714c9de300" translate="yes" xml:space="preserve">
          <source>O(n). Construct a new &lt;code&gt;ByteString&lt;/code&gt; from a &lt;code&gt;CString&lt;/code&gt;. The resulting &lt;code&gt;ByteString&lt;/code&gt; is an immutable copy of the original &lt;code&gt;CString&lt;/code&gt;, and is managed on the Haskell heap. The original &lt;code&gt;CString&lt;/code&gt; must be null terminated.</source>
          <target state="translated">의 위에). &lt;code&gt;CString&lt;/code&gt; 에서 새로운 &lt;code&gt;ByteString&lt;/code&gt; 을 생성합니다 . 결과 &lt;code&gt;ByteString&lt;/code&gt; 은 원래 &lt;code&gt;CString&lt;/code&gt; 의 변경 불가능한 사본이며 Haskell 힙에서 관리됩니다. 원래 &lt;code&gt;CString&lt;/code&gt; 은 null로 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3f96c04218005ba3f372a9e0681a6f7482a0605c" translate="yes" xml:space="preserve">
          <source>O(n). Construct a new &lt;code&gt;ByteString&lt;/code&gt; from a &lt;code&gt;CStringLen&lt;/code&gt;. The resulting &lt;code&gt;ByteString&lt;/code&gt; is an immutable copy of the original &lt;code&gt;CStringLen&lt;/code&gt;. The &lt;code&gt;ByteString&lt;/code&gt; is a normal Haskell value and will be managed on the Haskell heap.</source>
          <target state="translated">의 위에). 새로운 구축 &lt;code&gt;ByteString&lt;/code&gt; A로부터 &lt;code&gt;CStringLen&lt;/code&gt; 을 . 결과 &lt;code&gt;ByteString&lt;/code&gt; 은 원래 &lt;code&gt;CStringLen&lt;/code&gt; 의 변경 불가능한 사본입니다 . &lt;code&gt;ByteString&lt;/code&gt; 는 정상적인 하스켈 값이며, 하스켈 힙에서 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="3af0d34eddae2fa890c99e6e7750e36f7d028e14" translate="yes" xml:space="preserve">
          <source>O(n). Construct a new &lt;code&gt;ShortByteString&lt;/code&gt; from a &lt;code&gt;CString&lt;/code&gt;. The resulting &lt;code&gt;ShortByteString&lt;/code&gt; is an immutable copy of the original &lt;code&gt;CString&lt;/code&gt;, and is managed on the Haskell heap. The original &lt;code&gt;CString&lt;/code&gt; must be null terminated.</source>
          <target state="translated">의 위에). &lt;code&gt;CString&lt;/code&gt; 으로부터 새로운 &lt;code&gt;ShortByteString&lt;/code&gt; 를 구축합니다 . 결과 &lt;code&gt;ShortByteString&lt;/code&gt; 은 원래 &lt;code&gt;CString&lt;/code&gt; 의 변경 불가능한 사본이며 Haskell 힙에서 관리됩니다. 원래 &lt;code&gt;CString&lt;/code&gt; 은 null로 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b455d50c1fe35d365821ac00e8e7e524a5007e9b" translate="yes" xml:space="preserve">
          <source>O(n). Construct a new &lt;code&gt;ShortByteString&lt;/code&gt; from a &lt;code&gt;CStringLen&lt;/code&gt;. The resulting &lt;code&gt;ShortByteString&lt;/code&gt; is an immutable copy of the original &lt;code&gt;CStringLen&lt;/code&gt;. The &lt;code&gt;ShortByteString&lt;/code&gt; is a normal Haskell value and will be managed on the Haskell heap.</source>
          <target state="translated">의 위에). 새로운 구축 &lt;code&gt;ShortByteString&lt;/code&gt; A로부터 &lt;code&gt;CStringLen&lt;/code&gt; 을 . 결과 &lt;code&gt;ShortByteString&lt;/code&gt; 은 원래 &lt;code&gt;CStringLen&lt;/code&gt; 의 변경 불가능한 사본입니다 . &lt;code&gt;ShortByteString&lt;/code&gt; 는 정상적인 하스켈 값이며, 하스켈 힙에서 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="d605df03958840eb26896869cbad19609feb0e48" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 개종자 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c77d0c3f6baffb8d25d9ff396d4687d8b4bc2f9" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 개종자 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5dad9654275617c6c664c1a00e8b2eaaf27898" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 개종자 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 을 에 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="104b0cdf481fb213c0fbe1b1362ab69b9f4405ea" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; into a list.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 을 목록으로 변환 하십시오.</target>
        </trans-unit>
        <trans-unit id="40d1304b8827895cdf1bb4f59d8bc130273aaf23" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 개종자 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 을 에 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="297088dbf1e8c09077781d38164fb76d68843a39" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; into a list.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 을 목록으로 변환 하십시오.</target>
        </trans-unit>
        <trans-unit id="eab1e87a8573b28450f0853eebb702a97f8d52af" translate="yes" xml:space="preserve">
          <source>O(n). Convert a list into a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">의 위에). 리스트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 으로 변환</target>
        </trans-unit>
        <trans-unit id="fd464cb518575f88abc9f28748496003ac2f39b9" translate="yes" xml:space="preserve">
          <source>O(n). Convert a list into a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">의 위에). 리스트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 으로 변환</target>
        </trans-unit>
        <trans-unit id="54bf324121cf04e8bf75f5d03af99d55eba2edb1" translate="yes" xml:space="preserve">
          <source>O(n). Convert the map to a list of key/value pairs where the keys are in ascending order. Subject to list fusion.</source>
          <target state="translated">의 위에). 키가 오름차순 인 키 / 값 쌍 목록으로 맵을 변환하십시오. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b37e9319ddf52e30abb6270d730dd637ccb1a1c1" translate="yes" xml:space="preserve">
          <source>O(n). Convert the map to a list of key/value pairs where the keys are in descending order. Subject to list fusion.</source>
          <target state="translated">의 위에). 키가 내림차순 인 키 / 값 쌍 목록으로 맵을 변환하십시오. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1b9592ab7e554056e70625d0f6a1d9a4dbb98aad" translate="yes" xml:space="preserve">
          <source>O(n). Convert the map to a list of key/value pairs. Subject to list fusion.</source>
          <target state="translated">의 위에). 맵을 키 / 값 쌍의 목록으로 변환하십시오. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1f55e622796c2112ef81903eed79711372b62b24" translate="yes" xml:space="preserve">
          <source>O(n). Convert the set to a descending list of elements. Subject to list fusion.</source>
          <target state="translated">의 위에). 세트를 내림차순 요소 목록으로 변환하십시오. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d8408ba5d185cec2589d3b3222cb3b94b09b3b72" translate="yes" xml:space="preserve">
          <source>O(n). Convert the set to a list of elements. Subject to list fusion.</source>
          <target state="translated">의 위에). 세트를 요소 목록으로 변환하십시오. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="55634c24f206f4681ac932e849c1bd513d33a8be" translate="yes" xml:space="preserve">
          <source>O(n). Convert the set to an ascending list of elements. Subject to list fusion.</source>
          <target state="translated">의 위에). 집합을 오름차순 요소 목록으로 변환하십시오. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2a0fbedac005cda8da057c4c7632c26766051d62" translate="yes" xml:space="preserve">
          <source>O(n). Extract a lazy &lt;code&gt;Text&lt;/code&gt; from a &lt;code&gt;Builder&lt;/code&gt; with a default buffer size. The construction work takes place if and when the relevant part of the lazy &lt;code&gt;Text&lt;/code&gt; is demanded.</source>
          <target state="translated">의 위에). 기본 버퍼 크기 로 &lt;code&gt;Builder&lt;/code&gt; 에서 지연 &lt;code&gt;Text&lt;/code&gt; 를 추출하십시오 . 건설 작업은 게으른 &lt;code&gt;Text&lt;/code&gt; 의 관련 부분이 필요할 때 그리고 필요할 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f8f08df5754e3c864e5e5d2f3623efd7721b6fc9" translate="yes" xml:space="preserve">
          <source>O(n). Extract a lazy &lt;code&gt;Text&lt;/code&gt; from a &lt;code&gt;Builder&lt;/code&gt;, using the given size for the initial buffer. The construction work takes place if and when the relevant part of the lazy &lt;code&gt;Text&lt;/code&gt; is demanded.</source>
          <target state="translated">의 위에). 초기 버퍼에 대해 주어진 크기를 사용하여 &lt;code&gt;Builder&lt;/code&gt; 에서 지연 &lt;code&gt;Text&lt;/code&gt; 를 추출하십시오 . 건설 작업은 게으른 &lt;code&gt;Text&lt;/code&gt; 의 관련 부분이 필요할 때 그리고 필요할 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="6fe7d65969a116c9d2fcb0181118e2c835f1e1f3" translate="yes" xml:space="preserve">
          <source>O(n). Extract the last element of a list, which must be finite and non-empty.</source>
          <target state="translated">의 위에). 유한하고 비어 있지 않은 목록의 마지막 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="7241dc2b686aac0cb246206f5761f1dfbe048ba8" translate="yes" xml:space="preserve">
          <source>O(n). Filter all elements that satisfy some predicate.</source>
          <target state="translated">의 위에). 술어를 만족시키는 모든 요소를 ​​필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="3bc73542b8cc3c264a30bd7ffccf5378a38c6038" translate="yes" xml:space="preserve">
          <source>O(n). Filter all elements that satisfy the predicate.</source>
          <target state="translated">의 위에). 술어를 만족시키는 모든 요소를 ​​필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="0712ff9b4298830ef4a9f7a2fab8b0341da27545" translate="yes" xml:space="preserve">
          <source>O(n). Filter all keys/values that satisfy some predicate.</source>
          <target state="translated">의 위에). 술어를 만족시키는 모든 키 / 값을 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="9c5dcab4c81d1a0bda0edfeecc5f7bc0e4646864" translate="yes" xml:space="preserve">
          <source>O(n). Filter all keys/values that satisfy the predicate.</source>
          <target state="translated">의 위에). 술어를 만족시키는 모든 키 / 값을 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="faf50780dfd316b2b37e87515f049261caf3492b" translate="yes" xml:space="preserve">
          <source>O(n). Filter all values that satisfy some predicate.</source>
          <target state="translated">의 위에). 술어를 만족시키는 모든 값을 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="5be317c4605cb1f4dd8d41a02e5f76bff0ac97fb" translate="yes" xml:space="preserve">
          <source>O(n). Filter all values that satisfy the predicate.</source>
          <target state="translated">의 위에). 술어를 만족시키는 모든 값을 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="fd187d380259e772f7777ff3d8188b6dfe8de3a3" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 이진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 가되도록 집합의 요소를 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="9ea0999e67715a8fc28d2f325684bc33d0713301" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 가 되도록 주어진 왼쪽 연관 이항 연산자를 사용하여 집합의 요소를 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="f489c4b27b1c2cc165ef315dd05b68a6fa36505a" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 이진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 가되도록 집합의 요소를 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="331c0868ec4611fd9bf6273b75dd9ad7c2587e75" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 가 되도록 주어진 왼쪽 연관 이항 연산자를 사용하여 집합의 요소를 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="1f324b2b0f59da83f5871f1dd588fd32acd68deb" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 이진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 가되도록 집합의 요소를 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="545a2de033705986e238c1b8f2f2fdb9df74e9be" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 가 되도록 주어진 왼쪽 연관 이항 연산자를 사용하여 집합의 요소를 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="0d2891b27e5ad3bd47a68596fcfc66af3677d178" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 와 같이 주어진 오른쪽 연관 2 진 연산자를 사용하여 세트의 요소를 접으십시오 . toAscList .</target>
        </trans-unit>
        <trans-unit id="7382bb16e7085515a4ccc38c499fd2dfde669cbe" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; fz가 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 집합의 요소를 접습니다. &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed1f0fabd3931ac452c0505605247322919ef5b7" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 와 같이 주어진 오른쪽 연관 2 진 연산자를 사용하여 세트의 요소를 접으십시오 . toAscList .</target>
        </trans-unit>
        <trans-unit id="007129228d848f4965f48fcab5d362b5d9ae0645" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 집합의 요소를 접습니다. toAscList .</target>
        </trans-unit>
        <trans-unit id="1d96b1ff503ab715f860cc010d3aa443ff17d126" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 와 같이 주어진 오른쪽 연관 2 진 연산자를 사용하여 세트의 요소를 접으십시오 . toAscList .</target>
        </trans-unit>
        <trans-unit id="75f8e285802ef69b72ebbe3b22cfefc40807fb85" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; fz가 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 집합의 요소를 접습니다. &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f0c54a302b43d4378064cbb4ee3fcc46426ad6c" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator. This function is an equivalent of &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; and is present for compatibility only.</source>
          <target state="translated">의 위에). 주어진 오른쪽 연관 2 진 연산자를 사용하여 세트의 요소를 접으십시오. 이 기능은 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 와 동일 하며 호환성을 위해서만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c4a6aaccbde70c13ad3121d99c6be59257d8d3dc" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator. This function is an equivalent of &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; and is present for compatibility only.</source>
          <target state="translated">의 위에). 주어진 오른쪽 연관 2 진 연산자를 사용하여 세트의 요소를 접으십시오. 이 기능은 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 와 동일 하며 호환성을 위해서만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd7db46181441c03e9162a32dc212c95e00689f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator. This function is an equivalent of &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; and is present for compatibility only.</source>
          <target state="translated">의 위에). 주어진 오른쪽 연관 2 진 연산자를 사용하여 세트의 요소를 접으십시오. 이 기능은 &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 와 동일 하며 호환성을 위해서만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="420a91bccd693fd91224409726cfa81357c23e11" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30b65823f6675873cb1a9414c34776e278fa9db9" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\ z '(kx, x)-&amp;gt; fz'kx x) z 와 같이 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 키와 값을 접습니다 . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d15df2c03af36975fa4c874e66623b5cc569eac" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61659404d8560ff350ca75a44ee3055a27e1d4a5" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\ z '(kx, x)-&amp;gt; fz'kx x) z 와 같이 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 키와 값을 접습니다 . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c50d45667ec51cf9d881549e19a7d8d93db6f7" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46762683efed2b9d7e96625249c405fc1749f923" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\ z '(kx, x)-&amp;gt; fz'kx x) z 와 같이 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 키와 값을 접습니다 . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5314494d648fc03643b467e48fb407b70680a15d" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="680fbb405bb284e329d72efbe02d691b3d9aee3c" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\ z '(kx, x)-&amp;gt; fz'kx x) z 와 같이 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 키와 값을 접습니다 . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf75e0b5187e855d9687eb54d63a19fdac671b" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d747bcbd597f36c0149d3f3fff48554dd77a7fe" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\ z '(kx, x)-&amp;gt; fz'kx x) z 와 같이 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 키와 값을 접습니다 . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41dc7087452432576b4253c2fe034bed92265b22" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given monoid, such that</source>
          <target state="translated">의 위에). 주어진 monoid를 사용하여 맵에서 키와 값을 접습니다.</target>
        </trans-unit>
        <trans-unit id="7b147a5bbd0ab6db0d8b192fdc2c0aaade469db9" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 와 같이 주어진 오른쪽 연관 2 진 연산자를 사용하여 맵에서 키와 값을 접으십시오 . toAscList .</target>
        </trans-unit>
        <trans-unit id="d7cc847945454b47d631496ec9de07c306cdd7eb" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="bf97c889d33c15be915f227337df5ead3b5e01c2" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 와 같이 주어진 오른쪽 연관 2 진 연산자를 사용하여 맵에서 키와 값을 접으십시오 . toAscList .</target>
        </trans-unit>
        <trans-unit id="ef9be34f7e154a1d2785480f651ae379c09128a9" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="737ae284156ddd7ec85750aa648563e2353c863f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 와 같이 주어진 오른쪽 연관 2 진 연산자를 사용하여 맵에서 키와 값을 접으십시오 . toAscList .</target>
        </trans-unit>
        <trans-unit id="f61be01603ef02011f2b93061578257c8871d1b0" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="5900ffccace2bb41fa387fcfb2d2e2beffee0fd6" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 와 같이 주어진 오른쪽 연관 2 진 연산자를 사용하여 맵에서 키와 값을 접으십시오 . toAscList .</target>
        </trans-unit>
        <trans-unit id="bb6036e9ef5590d91f60e25057e704252fcebc48" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="f355e15b89571d5f94a93ce1229fe94de15d615c" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 와 같이 주어진 오른쪽 연관 2 진 연산자를 사용하여 맵에서 키와 값을 접으십시오 . toAscList .</target>
        </trans-unit>
        <trans-unit id="f06fcc3364cc6e5ca334d3a8329885dc3c163775" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵에서 키와 값을 접습니다 . toAscList .</target>
        </trans-unit>
        <trans-unit id="f679715363009cd3a06c72b3f2be25343eba4533" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵에서 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="d25bf5c08a40ae957ae20fad0de75081021f7d66" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; fz 가 되도록 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다 . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28c0cce1607c943199c39c6a1ebb1573288d1f6f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵에서 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="ad22df3262ceed93bc2c690b1dfd2b716e772de9" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; fz 가 되도록 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다 . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be2cf80125dcb52b214a5d99f4084cf0cac98388" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵에서 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="262fc31483be0a3045510d0bae0dcf1aa222026d" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; fz 가 되도록 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다 . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="718c7224ec44e223b2be3a549c64fe306e201873" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵에서 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="bc549d3da74315038bea670011313ed312e6fffb" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; fz 가 되도록 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다 . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="769390eedd60c8ae1d97c4c438bac6456a727375" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 왼쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵에서 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="b956d7520714df903ad4f075cb74eb3c00b670b4" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; fz 가 되도록 주어진 왼쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다 . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e960d57eefa58793286f14fd5f64ddf1c8bafd6" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 오른쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵의 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="bb177a593c811f121f23f142a62cc5ef7add881d" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; fz가 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다. &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d64d43d6cafe1a938edcbc4877507c4416255b" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 오른쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵의 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="73e28ceeb602cdcbd778c0763c4f6401c08e60c4" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; fz가 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다. &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b46935e9716aef69b9bad01480c973e1ac756472" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 오른쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵의 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="f5e898f6a23ed70ecf501e051dade8af6b3269d3" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; fz가 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다. &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a071bb93e5cb9cb0cc0479bfa2dbc2f564d7b16" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 오른쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵의 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="d55962360d0ec40caf1f3606fc87b1f742ecdc83" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; fz가 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다. &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17e16d6b81f14248006211f97996620166151842" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 주어진 오른쪽 연관 2 진 연산자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 가되도록 맵의 값을 접으십시오 . elems .</target>
        </trans-unit>
        <trans-unit id="d655488a73bc6f23c3c2abcdc2ffdd97fd3e836f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; fz == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; fz가 되도록 주어진 오른쪽 연관 이항 연산자를 사용하여 맵의 값을 접습니다. &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;Elems&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf01b4698c066b0b378341073e2125bf52db1134" translate="yes" xml:space="preserve">
          <source>O(n). Map a function over all values in the map.</source>
          <target state="translated">의 위에). 맵의 모든 값에 함수를 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="bbccdf89731955a9400998a6114d2837d096a981" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 키 / 값을 매핑하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 결과를 수집합니다 .</target>
        </trans-unit>
        <trans-unit id="c8230522617ab0a4acb490d8be3451e1b772afcf" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 키 / 값 매핑 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 수집 결과를 .</target>
        </trans-unit>
        <trans-unit id="a76552525b158c8f82471de156e40e2bcc3b1ce2" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 키 / 값을 매핑하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 결과를 구분하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce87fa336090794b430dffb93a1aa680a08ec249" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 키 / 값 매핑 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 분리 결과를 .</target>
        </trans-unit>
        <trans-unit id="21ef8296af9f2afa8f9a15c44e3ba51476cd14c0" translate="yes" xml:space="preserve">
          <source>O(n). Map values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 값을 매핑하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 결과를 수집합니다 .</target>
        </trans-unit>
        <trans-unit id="55c1e98a2221ffac22c5939a66b681d19acfa130" translate="yes" xml:space="preserve">
          <source>O(n). Map values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 값 매핑 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 수집 결과를 .</target>
        </trans-unit>
        <trans-unit id="14a7913e311b4b3e728eced4de41876519fbb7e7" translate="yes" xml:space="preserve">
          <source>O(n). Map values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 값을 매핑하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 결과를 구분하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9b96cb297dd47e10a91d6aeb4a32a68cf77577d" translate="yes" xml:space="preserve">
          <source>O(n). Map values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 값을 매핑하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 결과를 구분합니다 .</target>
        </trans-unit>
        <trans-unit id="7da1bbef23d470faa79587e532c71aeb2dfb06f2" translate="yes" xml:space="preserve">
          <source>O(n). Number of elements in the map.</source>
          <target state="translated">의 위에). 지도의 요소 수</target>
        </trans-unit>
        <trans-unit id="ca7813a01116d9f994a862c3f8f3c0e0a4161a02" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to a predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 술어에 따라 맵을 파티션하십시오. 첫 번째 맵은 술어를 만족시키는 모든 요소를 ​​포함하고 두 번째 맵은 술어를 실패하는 모든 요소를 ​​포함합니다. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28a12b7c2ddf73425db47b25ff0e21286cfd08de" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to a predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 술어에 따라 맵을 파티션하십시오. 첫 번째 맵은 술어를 만족시키는 모든 요소를 ​​포함하고 두 번째 맵은 술어를 실패하는 모든 요소를 ​​포함합니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5c46ac5acbc5460bd950b307564d31030391a54" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 술어에 따라 맵을 파티션하십시오. 첫 번째 맵은 술어를 만족시키는 모든 요소를 ​​포함하고 두 번째 맵은 술어를 실패하는 모든 요소를 ​​포함합니다. &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb64cc06d0fc5872d58a6d9d2df165ac0912e391" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 술어에 따라 맵을 파티션하십시오. 첫 번째 맵은 술어를 만족시키는 모든 요소를 ​​포함하고 두 번째 맵은 술어를 실패하는 모든 요소를 ​​포함합니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5902e7b9cb1e33328a5723641e3facd75d1f04e" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 술어에 따라 맵을 파티션하십시오. 첫 번째 맵은 술어를 만족시키는 모든 요소를 ​​포함하고 두 번째 맵은 술어를 실패하는 모든 요소를 ​​포함합니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e4689f50053d60e8b12bc8079d817dada74746c" translate="yes" xml:space="preserve">
          <source>O(n). Partition the set into two sets, one with all elements that satisfy the predicate and one with all elements that don't satisfy the predicate. See also &lt;code&gt;&lt;a href=&quot;data-set#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 세트를 두 가지 세트로 분할하십시오. 하나는 술어를 만족시키는 모든 요소와 하나는 술어를 만족시키지 않는 모든 요소를 ​​갖습니다. &lt;code&gt;&lt;a href=&quot;data-set#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a20953ab24f48d2ba8110890acc9412f0f62d973" translate="yes" xml:space="preserve">
          <source>O(n). Return all elements of the map in the ascending order of their keys. Subject to list fusion.</source>
          <target state="translated">의 위에). 키의 오름차순으로지도의 모든 요소를 ​​반환합니다. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8630a78da8f5c0cfe78e345d3f2e551e0b67329d" translate="yes" xml:space="preserve">
          <source>O(n). Return all keys of the map in ascending order. Subject to list fusion.</source>
          <target state="translated">의 위에). 지도의 모든 키를 오름차순으로 반환하십시오. 목록 융합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="43824a6f5c7483ca2f085a077e4596429bfc3cd1" translate="yes" xml:space="preserve">
          <source>O(n). Return all the elements of a list except the last one. The list must be non-empty.</source>
          <target state="translated">의 위에). 마지막 요소를 제외한 목록의 모든 요소를 ​​반환합니다. 이 목록은 비어 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="36a68651939ea7bf78af13ecbe22bf7688a51736" translate="yes" xml:space="preserve">
          <source>O(n). Show the tree that implements the map. The tree is shown in a compressed, hanging format.</source>
          <target state="translated">의 위에). 지도를 구현하는 트리를 표시하십시오. 트리는 압축 된 교수형 형식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4e4db00c39363393d519fb5c4366332a6fb0de88" translate="yes" xml:space="preserve">
          <source>O(n). Show the tree that implements the map. The tree is shown in a compressed, hanging format. See &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 지도를 구현하는 트리를 표시하십시오. 트리는 압축 된 교수형 형식으로 표시됩니다. &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88ce9adb9e14ba216ad42950a875bc9c14a8209f" translate="yes" xml:space="preserve">
          <source>O(n). Show the tree that implements the set. The tree is shown in a compressed, hanging format.</source>
          <target state="translated">의 위에). 세트를 구현하는 트리를 표시하십시오. 트리는 압축 된 교수형 형식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9c10017bd592438d3e62d5bc2e00b9865930af4a" translate="yes" xml:space="preserve">
          <source>O(n). Test if the internal map structure is valid.</source>
          <target state="translated">의 위에). 내부 맵 구조가 유효한지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="c0d7d3d821d1ee1593fb61d9e36825865c839d05" translate="yes" xml:space="preserve">
          <source>O(n). Test if the internal set structure is valid.</source>
          <target state="translated">의 위에). 내부 세트 구조가 유효한지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="2bd8d3ca7f264c1dfc39c248ff7bff4929785346" translate="yes" xml:space="preserve">
          <source>O(n). The</source>
          <target state="translated">의 위에). 그만큼</target>
        </trans-unit>
        <trans-unit id="5493b27f1c4b773117d6ff6c8ac89adcfcc21bb4" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 기능처럼 동작합니다 &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ,하지만 사용자가 제공하는 평등 술어를합니다.</target>
        </trans-unit>
        <trans-unit id="98032ca70b502ed7c8b616f957d53d84d7de967b" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . 특히 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 모든 유형을 반환합니다 . 그러나 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 보다 덜 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="4587623b8218c7dd5734795fb0233350ad1937cf" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 함수는 다음의 요소와 동일하다보다 작거나 제 위치에서리스트에 요소 및 목록과 인서트 요소 걸린다. 특히, 호출 전에 목록이 정렬되면 결과도 정렬됩니다. &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 비교 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ebaa6a5d93309f39c904f20878a239aa03b7857" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수는 요소리스트와 '산재'리스트의 요소 사이의 소자 걸린다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="fa50d5aae03c95132217bf805fdc774a3e03caa7" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 긴 먼저 반환에게 인수의 모든 최종 세그먼트를 작동합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ef3cd44c571d67791124813dab1fa2f48dd03156" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 기능처럼 동작합니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ,하지만 사용자가 제공하는 평등 술어를합니다.</target>
        </trans-unit>
        <trans-unit id="210217c8f0159a82488ae5aab8cb5e35cf178bf9" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . 특히 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 모든 유형을 반환합니다 . 그러나 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 보다 덜 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="5f0dc6a5ad6bfd25e9bea807673a76890fa48497" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 함수는 다음의 요소와 동일하다보다 작거나 제 위치에서리스트에 요소 및 목록과 인서트 요소 걸린다. 특히, 호출 전에 목록이 정렬되면 결과도 정렬됩니다. &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 비교 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3afabf0106af3fe4e53fef7849c2befc5d24bc8" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수는 요소리스트와 '산재'리스트의 요소 사이의 소자 걸린다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c8f7a2b4ac8edf7f65996f45e45238e7654a6a8b" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 긴 먼저 반환에게 인수의 모든 최종 세그먼트를 작동합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d2429730dc6a42eb0c6a71c287aab27365db1896" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the map. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; )은 맵 을 구현하는 트리를 나타냅니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. 경우 &lt;code&gt;wide&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bfa2e61261498c9b3a9c1d95d6d6c8c7f045984d" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the map. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ) 은지도 를 구현하는 트리를 보여줍니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. &lt;code&gt;wide&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인 경우 , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3307bd4f4ef6829ef4be8f3a64ed42b0e6348c5a" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; )은 세트를 구현하는 트리를 보여줍니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. 경우 &lt;code&gt;wide&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e19c399e5ec72b22fa5e9e212b3f04b3d856870" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; )은 집합을 구현하는 트리를 보여줍니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. &lt;code&gt;wide&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인 경우 , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="831d42878394a9a0d4ea363502b8a5dd7e6cba2e" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; )은 세트를 구현하는 트리를 보여줍니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. 경우 &lt;code&gt;wide&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="648df4fcaa104208481e88bc7693b141962f74e9" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; )은 집합을 구현하는 트리를 보여줍니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. &lt;code&gt;wide&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인 경우 , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1bf0dd685c64224551ec47eef3c51bd8a8276bcd" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt;) shows the tree that implements the map. Elements are shown using the &lt;code&gt;showElem&lt;/code&gt; function. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt; )은 맵 을 구현하는 트리를 나타냅니다. &lt;code&gt;showElem&lt;/code&gt; 함수를 사용하여 요소가 표시 됩니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. 경우 &lt;code&gt;wide&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="56f0cde755d4f17130983af6ad45b003dff4a553" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt;) shows the tree that implements the map. Elements are shown using the &lt;code&gt;showElem&lt;/code&gt; function. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt; ) 은지도 를 구현하는 트리를 보여줍니다. 요소는 &lt;code&gt;showElem&lt;/code&gt; 함수를 사용하여 표시 됩니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. &lt;code&gt;wide&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인 경우 , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7888e014ff70e7da6951568cde6d193cdf7e76d0" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;showTreeWith hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;showTreeWith hang wide map&lt;/code&gt; )은 세트를 구현하는 트리를 보여줍니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;True&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. 경우 &lt;code&gt;wide&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1a39d4aadf2415d3ca8e7782698cd0da4aaeef91" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;showTreeWith hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">의 위에). 표현식 ( &lt;code&gt;showTreeWith hang wide map&lt;/code&gt; )은 집합을 구현하는 트리를 보여줍니다. 경우 &lt;code&gt;hang&lt;/code&gt; 입니다 &lt;code&gt;True&lt;/code&gt; 하는 &lt;em&gt;매달려&lt;/em&gt; 나무는 그렇지 회전 된 트리가 표시됩니다 표시됩니다. &lt;code&gt;wide&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인 경우 , 여분의 다양한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4a3b936d7a2a3abf4106e26a74b1016792d526db" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="e30c90b941aefaaec19001464154f4f386904d0c" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="be5d31fd21e879811ff4b354fe058f2becedf771" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="45c5776f771ab7b4fe7f9402624ccc49e8f16dbf" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="7445f426a041c9fcafb5b12bd274a6d8e517ce70" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="644ee7ec96c4f77595cefdcc9ad11d6644044af7" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="29c4c7f8af356ae75f35ab782687363d88d91f89" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="efb4101740d24939f936f917a29d61d30dfd76ca" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="e568b210fbc6e98ba452c9fff80dd6215c292bad" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="b522ba3d40a23738c085941f155930d8976c8fba" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 함수 는 키를 통해 오름차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="f477880ebda2d0dec0ff396ee9f082a19a4dc9a9" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;mapAccumR&lt;/code&gt; threads an accumulating argument through the map in descending order of keys.</source>
          <target state="translated">의 위에). &lt;code&gt;mapAccumR&lt;/code&gt; 함수 는 키를 내림차순으로 맵을 통해 누적 인수를 스레드합니다.</target>
        </trans-unit>
        <trans-unit id="a53abd52488386fcd346720aa042ddcb12d8ba07" translate="yes" xml:space="preserve">
          <source>O(n). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 오버로드되지 않은 버전의 &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="defad20c6cc6143a71da5efc53c4695a5d70721a" translate="yes" xml:space="preserve">
          <source>O(n). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 위에). 오버로드되지 않은 버전의 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9619cc589ba678ece69e17342f4e0ee894c4288" translate="yes" xml:space="preserve">
          <source>O(n). The set of all keys of the map.</source>
          <target state="translated">의 위에). 지도의 모든 키 세트입니다.</target>
        </trans-unit>
        <trans-unit id="bd0e59538306ce4d2d23d102dc288ea1dea4874c" translate="yes" xml:space="preserve">
          <source>O(n). Traverse keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 키 / 값을 탐색하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 결과를 수집하십시오 .</target>
        </trans-unit>
        <trans-unit id="940f7036d1cd131308f7f749b45a120398ccb158" translate="yes" xml:space="preserve">
          <source>O(n). Traverse keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">의 위에). 키 / 값을 탐색하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 결과를 .</target>
        </trans-unit>
        <trans-unit id="dd87eb599d9b5e6d71506fd91c6fd4256d0a7111" translate="yes" xml:space="preserve">
          <source>O(n). partition the set according to some predicate.</source>
          <target state="translated">의 위에). 술어에 따라 세트를 파티션하십시오.</target>
        </trans-unit>
        <trans-unit id="a6d18da55bd04db6f9b044076b9fc0b37e85d962" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; is analogous to (:) for lists, but of different complexity, as it requires making a copy.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 은 목록의 (:)와 유사하지만 복사본을 만들어야하므로 복잡성이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e87133507bf78c9e7a16270bfef3263e3368d0ef" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; membership predicate.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 멤버 자격 조건입니다.</target>
        </trans-unit>
        <trans-unit id="fd3b0b58e2a7e1a52b5bc4c356abfb5643405318" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</source>
          <target state="translated">술어 및 ByteString에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 문자를 포함하는 ByteString을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6780da47a89a67bb9f3cf2a8d2655bfad738a16e" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the ByteString obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 ByteString 인 &lt;code&gt;f&lt;/code&gt; 각각 요소 &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="607c54f2d193454c7f49eac5713df114d2e0a454" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; returns the maximum value from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; This function will fuse. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 최대 값을 반환합니다 .이 함수는 통합됩니다. 빈 ByteString의 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="420f486298b5ea93389bc61a46e136d81c208a50" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; returns the minimum value from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; This function will fuse. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 최소값을 반환합니다 .이 함수는 통합됩니다. 빈 ByteString의 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="904125c9bd5092c22065ec505bcda6e71336cebf" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; is the inverse of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 의 역수입니다.</target>
        </trans-unit>
        <trans-unit id="aadb1f7c5dc7e9de99f1a8013f57ab676303dfcc" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n x&lt;/code&gt; is a ByteString of length &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; the value of every element. The following holds:</source>
          <target state="translated">O (n)의 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n x&lt;/code&gt; 길이 ByteString 인 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;x&lt;/code&gt; 각 요소의 값. 다음과 같은 내용이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="994f3cbfc5291a1e3c33531cf7ff5c9675e44117" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; efficiently returns the elements of &lt;code&gt;xs&lt;/code&gt; in reverse order.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 는 &lt;code&gt;xs&lt;/code&gt; 의 요소를 역순 으로 효율적으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6b03bb07227481e418e2cb9f9128b364e6ce78ac" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; transforms a list of pairs of bytes into a pair of ByteStrings. Note that this performs two &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 은 바이트 쌍 목록을 ByteString 쌍으로 변환합니다. 이 작업 은 두 가지 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="e084291cb5bb6d7c40375664b0d9ba69b4daa281" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two ByteStrings and returns a list of corresponding pairs of bytes. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 ByteString을 가져와 해당 바이트 쌍의 목록을 반환합니다. 하나의 입력 ByteString이 짧으면 더 긴 ByteString의 초과 요소가 삭제됩니다. 이는 한 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 작업 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="897f57bc1efb2a7b246b139b7d17f9f8b7289669" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; is analogous to (:) for lists, but of different complexity, as it requires a memcpy.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 은 목록의 경우 (:)와 유사하지만 memcpy가 필요하므로 복잡성이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8e061223a14e5f7b418f9492129f20987fd40f17" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; membership predicate. This implementation uses &lt;code&gt;memchr(3)&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 멤버 자격 조건입니다. 이 구현은 &lt;code&gt;memchr(3)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8a9c3cdee5acc43da1a053ba8975941b35050215" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</source>
          <target state="translated">술어 및 ByteString에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 문자를 포함하는 ByteString을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3366778fe3aa7fdde841f790f970185cb85baec8" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the ByteString obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;</source>
          <target state="translated">이 O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 ByteString 인 &lt;code&gt;f&lt;/code&gt; 각각 요소 &lt;code&gt;xs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a87438b3c1567d01fa16af6be1c70eb11f879c41" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; is the inverse of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 의 역수입니다.</target>
        </trans-unit>
        <trans-unit id="e50638915a675c05dec99d62a49a89f284909123" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n x&lt;/code&gt; is a ByteString of length &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; the value of every element. The following holds:</source>
          <target state="translated">O (n)의 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n x&lt;/code&gt; 길이 ByteString 인 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;x&lt;/code&gt; 각 요소의 값. 다음과 같은 내용이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc7b4001e51ca96d33790d4fa04c8097941e947" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; efficiently returns the elements of &lt;code&gt;xs&lt;/code&gt; in reverse order.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 는 &lt;code&gt;xs&lt;/code&gt; 의 요소를 역순 으로 효율적으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c49843235184b635597fc6bc634328f58d39343f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two ByteStrings and returns a list of corresponding pairs of Chars. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations, and so space usage may be large for multi-megabyte ByteStrings</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 ByteString을 가져와 해당하는 Char 쌍 목록을 반환합니다. 하나의 입력 ByteString이 짧으면 더 긴 ByteString의 초과 요소가 삭제됩니다. 이는 한 쌍의 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 작업에 해당하므로 멀티 메가 바이트 ByteString의 경우 공간 사용량이 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be1ae7748e6f0f64f8d41767e7d09afa52892d1d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; membership predicate.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 멤버 자격 조건입니다.</target>
        </trans-unit>
        <trans-unit id="e83bf67f47bcd12cb10b1c88852ce603cef046e6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</source>
          <target state="translated">술어 및 ByteString에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 문자를 포함하는 ByteString을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="594f41e365f4c84a617876e5d010b0f3bf6c029f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the ByteString obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 ByteString 인 &lt;code&gt;f&lt;/code&gt; 각각 요소 &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637cb1e10be19103636ce06997ee5ab857d94fe8" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; returns the maximum value from a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (N)가 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; (A)로부터 반환하는 최대 값 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c7604309eb5230fdf9522bd24f18245bf75a51f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; returns the minimum value from a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 최소값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f6ee8aeb4568fc4aa387603741be339ec3cac76" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; is the inverse of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 의 역수입니다.</target>
        </trans-unit>
        <trans-unit id="813ee49a0e4d52fdb3ae8304d21d3ac2df4dcbc8" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:replicate&quot;&gt;replicate&lt;/a&gt; n x&lt;/code&gt; is a ByteString of length &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; the value of every element.</source>
          <target state="translated">O (n)이 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:replicate&quot;&gt;replicate&lt;/a&gt; n x&lt;/code&gt; 길이 ByteString 인 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;x&lt;/code&gt; 각 요소의 값.</target>
        </trans-unit>
        <trans-unit id="0e0dc3ba246d837d3a9b010550f249679050f953" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; returns the elements of &lt;code&gt;xs&lt;/code&gt; in reverse order.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 요소 반환 &lt;code&gt;xs&lt;/code&gt; 역순으로한다.</target>
        </trans-unit>
        <trans-unit id="9202ad8e3b4632caa08f6f34bfd27121728ab275" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; transforms a list of pairs of bytes into a pair of ByteStrings. Note that this performs two &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 은 바이트 쌍 목록을 ByteString 쌍으로 변환합니다. 이 작업 은 두 가지 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="5a9da1672e7f1b5b674d8afdd2354b04ab7243f5" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two ByteStrings and returns a list of corresponding pairs of bytes. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 ByteString을 가져와 해당 바이트 쌍의 목록을 반환합니다. 하나의 입력 ByteString이 짧으면 더 긴 ByteString의 초과 요소가 삭제됩니다. 이는 한 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 작업 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c42bf137e10bf436f58e738df9dc0464ac9bd42a" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; membership predicate. This implementation uses &lt;code&gt;memchr(3)&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 멤버 자격 조건입니다. 이 구현은 &lt;code&gt;memchr(3)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="91c53f865408d000f101db6acde868e970f9c430" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</source>
          <target state="translated">술어 및 ByteString에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 문자를 포함하는 ByteString을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b8ba031b9efd1026d26f073281d08fc3e760438e" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the ByteString obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;</source>
          <target state="translated">이 O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 ByteString 인 &lt;code&gt;f&lt;/code&gt; 각각 요소 &lt;code&gt;xs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7aa51e2a6c207eddcadb3119c3b5db7b3f75278" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; is the inverse of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 의 역수입니다.</target>
        </trans-unit>
        <trans-unit id="e8ebd28624996cb8f5222d45ff82209729d29cac" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:replicate&quot;&gt;replicate&lt;/a&gt; n x&lt;/code&gt; is a ByteString of length &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; the value of every element.</source>
          <target state="translated">O (n)이 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:replicate&quot;&gt;replicate&lt;/a&gt; n x&lt;/code&gt; 길이 ByteString 인 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;x&lt;/code&gt; 각 요소의 값.</target>
        </trans-unit>
        <trans-unit id="0c9ad4f094aa254f69c6092bea03e198e42c0f2e" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; returns the elements of &lt;code&gt;xs&lt;/code&gt; in reverse order.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 요소 반환 &lt;code&gt;xs&lt;/code&gt; 역순으로한다.</target>
        </trans-unit>
        <trans-unit id="1025a51d54a7b411e304766783043b2c8c9ebe8c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two ByteStrings and returns a list of corresponding pairs of Chars. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations, and so space usage may be large for multi-megabyte ByteStrings</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 ByteString을 가져와 해당하는 Char 쌍 목록을 반환합니다. 하나의 입력 ByteString이 짧으면 더 긴 ByteString의 초과 요소가 삭제됩니다. 이는 한 쌍의 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 작업에 해당하므로 멀티 메가 바이트 ByteString의 경우 공간 사용량이 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="507dcd4c5ffbdf85b7afecdfbd6ffb348b3f2a12" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0. Subject to fusion.</source>
          <target state="translated">O (n) 0부터 시작하는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 인덱스 (첨자) 연산자. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c7f6fabdbf2741f226cec77b19c2ed76fa0d43" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; determines whether all characters in the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; satisfy the predicate &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 의 모든 문자 가 술어 &lt;code&gt;p&lt;/code&gt; 를 만족시키는 지 여부를 결정합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eba5fc089d3982c308520a95c1f77dd2130c7b0" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; determines whether any character in the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; satisfies the predicate &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 의 문자 가 술어 &lt;code&gt;p&lt;/code&gt; 를 만족시키는 지 여부를 결정합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f81c7ff9cb185390d27d39f40c6e350881c76f10" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:break&quot;&gt;break&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;data-text#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt;, but the prefix returned is over elements that fail the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:break&quot;&gt;break&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-text#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt; 과 비슷하지만 반환되는 접두사는 술어 &lt;code&gt;p&lt;/code&gt; 에 실패한 요소 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a401e4a49118c11b4758cd5236552b720cf3223" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the suffix of the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; characters, or the empty &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is greater than the length of the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 적용된 O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 은 첫 &lt;code&gt;n&lt;/code&gt; 문자 다음에 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 접미사를 반환 하거나 &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 길이보다 큰 경우 빈 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 반환 합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62638e9e2515ce80c16e9bbd4d722902b80a7bde" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the substring remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from both the beginning and end of &lt;code&gt;t&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-text#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 술어 만족 문자 삭제 이후 남은 문자열을 반환 &lt;code&gt;p&lt;/code&gt; 의 시작과 끝 모두로부터 &lt;code&gt;t&lt;/code&gt; 를 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50b676b0a4a9eff6b367ed39fc8ad50da4c80c8d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropEnd&quot;&gt;dropEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping &lt;code&gt;n&lt;/code&gt; characters from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O (n)이 &lt;code&gt;&lt;a href=&quot;data-text#v:dropEnd&quot;&gt;dropEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 은 삭제 후 남아있는 접두사 반환 &lt;code&gt;n&lt;/code&gt; 의 끝에서 문자 &lt;code&gt;t&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="80990f9067babc8c1a96660ef6ad72b05b11abd6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropWhile&quot;&gt;dropWhile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the suffix remaining after &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text#v:dropWhile&quot;&gt;dropWhile&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 의 복귀 후 남아 접미사 &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 를 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e6c16939d4c355b6e4010f481ae78113c01265d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-text#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 술어 만족 문자 삭제 이후 남은 반환 프리픽스 &lt;code&gt;p&lt;/code&gt; 의 단부로부터 &lt;code&gt;t&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="fba89c9273cb01a6feeeb52ba105e8c263324589" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; containing those characters that satisfy the predicate.</source>
          <target state="translated">술어 및 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어 를 만족하는 해당 문자를 포함 하는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="36718733e2bd35c6068adc8721e8015ecae35c23" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, applied to a binary operator, a starting value (typically the left-identity of the operator), and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, reduces the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; using the binary operator, from left to right. Subject to fusion.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 이진 연산자 시작 값 (전형적으로 운전자의 왼쪽 아이덴티티)와,인가, &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 감소 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 왼쪽에서 오른쪽으로 이진 연산자를 사용. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e93d3274aad02da381d77d8727f4a8d9bec1df6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, applied to a binary operator, a starting value (typically the right-identity of the operator), and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, reduces the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; using the binary operator, from right to left. Subject to fusion.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 이진 연산자 시작 값 (전형적으로 운전자의 오른쪽 아이덴티티)와,인가, &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 감소 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 오른쪽에서 왼쪽으로, 이진 연산자를 사용한다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53340410ef80985b02395b3f73c6037ec5158b5a" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O (n)의 &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 은 IS &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 함으로써 얻어지는 &lt;code&gt;f&lt;/code&gt; 각각 요소 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3392997e6a37b5ea492369dbab6c9d285c75f9bb" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; returns the maximum value from a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에서 최대 값을 반환합니다.이 값은 비어 있지 않아야합니다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0d5d05610018479cf03a721cc8f0d3b278d43cc" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; returns the minimum value from a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에서 최소값을 반환합니다.이 값은 비어 있지 않아야합니다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce440d86acb7656e3a075deae33e810590daf9ef" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 비슷 &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 있지만 복귀 왼쪽 연속 감소 된 값의리스트. 융합 될 수 있습니다. 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="1602e01d9551438052ee00621c4ff0186d8aa39b" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 . 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0b02a62da4052d8e51d2387f68f561b76b8e2e71" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 의 이중 오른쪽은 왼쪽이다 &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="dd59edc8b679e21a5fc719bf31908c07caed4a38" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 . 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="793a30afbe1bb62bb4bbc71da7c935274e7fdd02" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and text &lt;code&gt;t&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;t&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;, and whose second is the remainder of the list.</source>
          <target state="translated">술어 &lt;code&gt;p&lt;/code&gt; 및 텍스트 &lt;code&gt;t&lt;/code&gt; 에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt; 은 첫 번째 요소가 &lt;code&gt;p&lt;/code&gt; 를 만족하는 요소 중 &lt;code&gt;t&lt;/code&gt; 의 가장 긴 접두사 (비어있을 수 있음) 이고 두 번째는 목록의 나머지 쌍인 쌍을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e876383d6fe4d4cf57cb2e995578fddd8df3eb2e" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n t&lt;/code&gt; returns a pair whose first element is a prefix of &lt;code&gt;t&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, and whose second is the remainder of the string. It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt; n t, &lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt; n t)&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n t&lt;/code&gt; 는 첫 번째 요소가 길이 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;t&lt;/code&gt; 접두사 이고 두 번째는 문자열의 나머지 부분 인 쌍을 반환 합니다. 동일합니다 &lt;code&gt;(&lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt; n t, &lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt; n t)&lt;/code&gt; &lt;a href=&quot;data-text#v:take&quot;&gt;소요&lt;/a&gt; , NT &lt;a href=&quot;data-text#v:drop&quot;&gt;드롭&lt;/a&gt; NT) .</target>
        </trans-unit>
        <trans-unit id="724c5a910dc02d1935ca3c0e9f3d61da582138ff" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the prefix of the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; itself if &lt;code&gt;n&lt;/code&gt; is greater than the length of the Text. Subject to fusion.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 하는인가 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 접두사의 반환 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 길이 &lt;code&gt;n&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 경우 자체 &lt;code&gt;n&lt;/code&gt; 텍스트의 길이보다한다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e63ef89c44ffb426bb835c53ad49105c6cc4f6c3" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:takeEnd&quot;&gt;takeEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the suffix remaining after taking &lt;code&gt;n&lt;/code&gt; characters from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O (n)이 &lt;code&gt;&lt;a href=&quot;data-text#v:takeEnd&quot;&gt;takeEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 복용 후 남은 접미사 반환 &lt;code&gt;n&lt;/code&gt; 의 끝에서 문자 &lt;code&gt;t&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e92dcc54a916468d23b42ca137f26aeb26550c73" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest prefix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt; 는 , 술어에 적용 &lt;code&gt;p&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 만족의 그 요소의 (하늘의) 가장 긴 접두사 반환 &lt;code&gt;p&lt;/code&gt; . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa1f8a3e08b881dfc79f5d52ff65332b0fa61cd" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest suffix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Examples:</source>
          <target state="translated">술어 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 적용된 O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;p&lt;/code&gt; 를 만족하는 요소의 가장 긴 접미사 (비어있을 수 있음)를 반환합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="ad3be8f0faa9bd5d4aa2e5d20f35304c380828e9" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns a list of corresponding pairs of bytes. If one input &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is short, excess elements of the longer &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-text#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 가져와 해당 바이트 쌍의 목록을 반환합니다. 하나의 입력 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 가 짧으면 더 긴 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 초과 요소 가 삭제됩니다. 이는 한 &lt;code&gt;&lt;a href=&quot;data-text#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 작업 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="af939213fd5b0f6bd31b51acd6695dbeb5ffdb19" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-text#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 튜플 링 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;data-text#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다. 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="da4aeeaabfc5ed693c1e151384a746ca87c72217" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:drop&quot;&gt;drop&lt;/a&gt; n&lt;/code&gt;, applied to a stream, returns the suffix of the stream after the first &lt;code&gt;n&lt;/code&gt; characters, or the empty stream if &lt;code&gt;n&lt;/code&gt; is greater than the length of the stream.</source>
          <target state="translated">스트림에 적용된 O (n) &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:drop&quot;&gt;drop&lt;/a&gt; n&lt;/code&gt; 은 첫 &lt;code&gt;n&lt;/code&gt; 문자 뒤의 스트림 접미사 또는 &lt;code&gt;n&lt;/code&gt; 이 스트림 길이보다 큰 경우 빈 스트림을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9fa687005bdc593df76bb72517e1b521d29d2d20" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the stream membership predicate.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 은 스트림 멤버 자격 조건입니다.</target>
        </trans-unit>
        <trans-unit id="2b77afc64a7bb85e8690139a4da22ea45eedc543" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a stream, returns a stream containing those characters that satisfy the predicate.</source>
          <target state="translated">술어와 스트림에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어를 만족시키는 문자를 포함하는 스트림을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0f5ad5c44e1631f865afdc5530f0bd7da572556c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f &lt;/code&gt;xs is the Stream Char obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">O (n)의 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f &lt;/code&gt; XS 스트림 숯불을 적용하여 얻어진다 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21beeb85fff56f2a29dc2595d7cacf25e1f49ff2" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:take&quot;&gt;take&lt;/a&gt; n&lt;/code&gt;, applied to a stream, returns the prefix of the stream of length &lt;code&gt;n&lt;/code&gt;, or the stream itself if &lt;code&gt;n&lt;/code&gt; is greater than the length of the stream.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:take&quot;&gt;take&lt;/a&gt; n&lt;/code&gt; , 스트림에 적용 길이 스트림의 프리픽스 반환 &lt;code&gt;n&lt;/code&gt; 있으면, 스트림 자체가 &lt;code&gt;n&lt;/code&gt; 스트림의 길이보다한다.</target>
        </trans-unit>
        <trans-unit id="8963168f0bc112575b88fa986522b23655ce5f29" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0. Subject to fusion.</source>
          <target state="translated">O (n) 0부터 시작하는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 인덱스 (첨자) 연산자. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52001832e9a111e63388c13d8c78741fd22c16dc" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; determines whether all characters in the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; satisfy the predicate &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 의 모든 문자 가 술어 &lt;code&gt;p&lt;/code&gt; 를 만족시키는 지 여부를 결정합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80deb53f3ff5102554537a88ab56ecdbe9919f6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; determines whether any character in the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; satisfies the predicate &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 의 문자 가 술어 &lt;code&gt;p&lt;/code&gt; 를 만족시키는 지 여부를 결정합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="843af696b2b94016c6c577af94d3025d3394bc28" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:break&quot;&gt;break&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt;, but the prefix returned is over elements that fail the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:break&quot;&gt;break&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt; 과 비슷하지만 반환되는 접두사는 술어 &lt;code&gt;p&lt;/code&gt; 에 실패한 요소 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8015cbe0acbd22d830807b751205bb9541efeb95" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the suffix of the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; characters, or the empty &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is greater than the length of the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 적용된 O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 은 첫 &lt;code&gt;n&lt;/code&gt; 문자 다음에 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 접미사를 반환 하거나 &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 길이보다 큰 경우 빈 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 반환 합니다 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="803c2a3577d64fc8b7b535621c173f7322d98ae4" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the substring remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from both the beginning and end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 술어 만족 문자 삭제 이후 남은 문자열을 반환 &lt;code&gt;p&lt;/code&gt; 의 시작과 끝 모두로부터 &lt;code&gt;t&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="8b8335a4c8467eeeadac078c96149b316651e93c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropEnd&quot;&gt;dropEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping &lt;code&gt;n&lt;/code&gt; characters from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O (n)이 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropEnd&quot;&gt;dropEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 은 삭제 후 남아있는 접두사 반환 &lt;code&gt;n&lt;/code&gt; 의 끝에서 문자 &lt;code&gt;t&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d9a32767a767b136763342cc8fed3626bdf438b4" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropWhile&quot;&gt;dropWhile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the suffix remaining after &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropWhile&quot;&gt;dropWhile&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 의 복귀 후 남아 접미사 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 를 . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b4db52cdaace3419e13833e1e5f48543f35232" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 술어 만족 문자 삭제 이후 남은 반환 프리픽스 &lt;code&gt;p&lt;/code&gt; 의 단부로부터 &lt;code&gt;t&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="71d3f9fc45ab8bc303bb4565aef5df7a8ab861d7" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; containing those characters that satisfy the predicate.</source>
          <target state="translated">술어 및 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 술어 를 만족하는 해당 문자를 포함 하는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="84c8b4d29979d85554d7904ebbaab64e20a7bd42" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, applied to a binary operator, a starting value (typically the left-identity of the operator), and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, reduces the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; using the binary operator, from left to right. Subject to fusion.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 이진 연산자 시작 값 (전형적으로 운전자의 왼쪽 아이덴티티)와,인가, &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 감소 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 왼쪽에서 오른쪽으로 이진 연산자를 사용. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32828db51b3f1d98312c38de9aa152cd0b245c37" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, applied to a binary operator, a starting value (typically the right-identity of the operator), and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, reduces the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; using the binary operator, from right to left. Subject to fusion.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 이진 연산자 시작 값 (전형적으로 운전자의 오른쪽 아이덴티티)와,인가, &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 감소 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 오른쪽에서 왼쪽으로, 이진 연산자를 사용한다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9547085ec7aae34af4b82fa0951d92170eb8a3d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;t&lt;/code&gt;. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n)의 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 은 IS &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 함으로써 얻어지는 &lt;code&gt;f&lt;/code&gt; 각각 요소 &lt;code&gt;t&lt;/code&gt; . 융합 될 수 있습니다. 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="275d34f83778a74e1a4c86f88fdbe41d09ac601c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; returns the maximum value from a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에서 최대 값을 반환합니다.이 값은 비어 있지 않아야합니다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab0542c71645f606c2c21ed062d6c45d54fd679" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; returns the minimum value from a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에서 최소값을 반환합니다.이 값은 비어 있지 않아야합니다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c2f9f716605703cc16d79787eb6433b44544b74" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the elements of &lt;code&gt;t&lt;/code&gt; in reverse order.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 에 되돌 요소 &lt;code&gt;t&lt;/code&gt; 역순으로한다.</target>
        </trans-unit>
        <trans-unit id="290e19543b06aa470e6e00fa1777da74ca666bcb" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 비슷 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 있지만 복귀 왼쪽 연속 감소 된 값의리스트. 융합 될 수 있습니다. 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="bfbae6d3a43ef1d2a9cfee5b582edbbb5f448c1d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 . 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="752730ad120352a67964470bec9296c38933d9a6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 의 이중 오른쪽은 왼쪽이다 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="defff53dbc7d598b9a15f139c156778912a78cf7" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 . 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="ec22df8af2b3913cd31c2ff7b32450ee597a62ce" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and text &lt;code&gt;t&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;t&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;, and whose second is the remainder of the list.</source>
          <target state="translated">술어 &lt;code&gt;p&lt;/code&gt; 및 텍스트 &lt;code&gt;t&lt;/code&gt; 에 적용되는 O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt; 은 첫 번째 요소가 &lt;code&gt;p&lt;/code&gt; 를 만족하는 요소 중 &lt;code&gt;t&lt;/code&gt; 의 가장 긴 접두사 (비어있을 수 있음) 이고 두 번째는 목록의 나머지 쌍인 쌍을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ed213541644726c53144685282a501ecf21fc2ba" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n t&lt;/code&gt; returns a pair whose first element is a prefix of &lt;code&gt;t&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, and whose second is the remainder of the string. It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt; n t, &lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt; n t)&lt;/code&gt;.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n t&lt;/code&gt; 는 첫 번째 요소가 길이 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;t&lt;/code&gt; 접두사 이고 두 번째는 문자열의 나머지 부분 인 쌍을 반환 합니다. 동일합니다 &lt;code&gt;(&lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt; n t, &lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt; n t)&lt;/code&gt; &lt;a href=&quot;data-text-lazy#v:take&quot;&gt;소요&lt;/a&gt; , NT &lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;드롭&lt;/a&gt; NT) .</target>
        </trans-unit>
        <trans-unit id="2a4e6688874ddaf9782c32f74b5af00856d6162c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the prefix of the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; itself if &lt;code&gt;n&lt;/code&gt; is greater than the length of the Text. Subject to fusion.</source>
          <target state="translated">O (n)은 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 하는인가 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 접두사의 반환 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 길이 &lt;code&gt;n&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 경우 자체 &lt;code&gt;n&lt;/code&gt; 텍스트의 길이보다한다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fafb109ed736e9539678dc223045f998ecc60586" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeEnd&quot;&gt;takeEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the suffix remaining after taking &lt;code&gt;n&lt;/code&gt; characters from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O (n)이 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeEnd&quot;&gt;takeEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 복용 후 남은 접미사 반환 &lt;code&gt;n&lt;/code&gt; 의 끝에서 문자 &lt;code&gt;t&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="48231e4265962339b40bf2779c38705e16bb89c6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest prefix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O (N) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt; 는 , 술어에 적용 &lt;code&gt;p&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 만족의 그 요소의 (하늘의) 가장 긴 접두사 반환 &lt;code&gt;p&lt;/code&gt; . 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fbcec5531082dc0f76c85517fe246d924a8b4d5" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest suffix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Examples:</source>
          <target state="translated">술어 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 적용된 O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;p&lt;/code&gt; 를 만족하는 요소의 가장 긴 접미사 (비어있을 수 있음)를 반환합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="b425ee4e8c05b3cda0ff6d30f9b09d52f8c568cc" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns a list of corresponding pairs of bytes. If one input &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is short, excess elements of the longer &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 가져와 해당 바이트 쌍의 목록을 반환합니다. 하나의 입력 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 가 짧으면 더 긴 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 초과 요소 가 삭제됩니다. 이는 한 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 작업 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1581c28e8613b72990177d99cabcdaa4473b802f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. Performs replacement on invalid scalar values.</source>
          <target state="translated">O (n) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 튜플 링 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다. 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="064939379eae2c6be3abdbb7b12833cf140eacf3" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="e8edcb9f3b9ce9874d0f50df16eaf453e97b5522" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="1d21400b6e833afb6bf8143413e415596fc7e8c2" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="10c506dbf93fa334d9a419951daf58b88553c5ad" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="f834fc8764b608e3a2c7e67729ea839011b86b0d" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="55b64ce77eb583b2a8d7e0008229894a3efce603" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="ef55ea6e8a459abefacb74a290038f5ce0831ec8" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-set#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; is the set obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). &lt;code&gt;&lt;a href=&quot;data-set#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 요소에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 집합 입니다.</target>
        </trans-unit>
        <trans-unit id="e21338981ac62324a8ffb888033d85823da92462" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). 결합 기능을 사용하여 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b4ee600b68a1b413680c347347b72d52a62b248" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscListWithKey&quot;&gt;fromAscListWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). 결합 기능을 사용하여 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscListWithKey&quot;&gt;fromAscListWithKey&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2b6445f60417018f5403793c1dd9664c415e81b" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). 결합 기능을 사용하여 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54ee44c25d5df18f80f0b752d11418a6db2d26b9" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscListWithKey&quot;&gt;fromAscListWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n * log n). 결합 기능을 사용하여 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscListWithKey&quot;&gt;fromAscListWithKey&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1342a9ab083de169557710a30b3fad7ae6c99e26" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscList&quot;&gt;fromAscList&lt;/a&gt;&lt;/code&gt;. If the list contains more than one value for the same key, the last value for the key is retained.</source>
          <target state="translated">O (n * log n). 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscList&quot;&gt;fromAscList&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 . 목록에 동일한 키에 대한 둘 이상의 값이 포함 된 경우 키의 마지막 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="02e2cd705835954197360bd74e3af96c7c963564" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscList&quot;&gt;fromAscList&lt;/a&gt;&lt;/code&gt;. If the list contains more than one value for the same key, the last value for the key is retained.</source>
          <target state="translated">O (n * log n). 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscList&quot;&gt;fromAscList&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 . 목록에 동일한 키에 대한 둘 이상의 값이 포함 된 경우 키의 마지막 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b1bd3b225b2e28c124d8bb6bccbf13d7c9843e1d" translate="yes" xml:space="preserve">
          <source>O(n*log n). Create a set from a list of elements.</source>
          <target state="translated">O (n * log n). 요소 목록에서 세트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cf816e1e72765d7793512d1bd9c75675ccb813e8" translate="yes" xml:space="preserve">
          <source>O(n*m)&lt;code&gt;&lt;a href=&quot;data-text#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; consisting of the input &lt;code&gt;t&lt;/code&gt; repeated &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">O (n * m) &lt;code&gt;&lt;a href=&quot;data-text#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;n&lt;/code&gt; 번 반복 된 입력 &lt;code&gt;t&lt;/code&gt; 로 구성된 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="496aa72cda3836a07a9a2fe26ce5be56819c8747" translate="yes" xml:space="preserve">
          <source>O(n*m)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; consisting of the input &lt;code&gt;t&lt;/code&gt; repeated &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">O (n * m) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;n&lt;/code&gt; 번 반복 된 입력 &lt;code&gt;t&lt;/code&gt; 로 구성된 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b88b501d9cd1a51f539e06a9f8b52a7518aed37" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="c825c89428e8aaee3dd58c3c0ed678ebb02559f4" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 이지만 &lt;code&gt;f&lt;/code&gt; 가 엄격하게 단조로운 경우에만 작동합니다 . 즉, 임의의 값이며, &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 경우, &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 다음 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; . &lt;em&gt;전제 조건이 점검되지 않았습니다. &lt;/em&gt;반 공식적으로, 우리는 :</target>
        </trans-unit>
        <trans-unit id="99b60a72b8c0e9adf3019aa8dfa7569bd4a92c32" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="c969970b95ecd5a60d39d789b9e1e9987b1bb4dd" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="41ebfbb8f2b447294a3e1e314695a58f6931431c" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 이지만 &lt;code&gt;f&lt;/code&gt; 가 엄격하게 단조로운 경우에만 작동합니다 . 즉, 임의의 값이며, &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 경우, &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 다음 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; . &lt;em&gt;전제 조건이 점검되지 않았습니다. &lt;/em&gt;반 공식적으로, 우리는 :</target>
        </trans-unit>
        <trans-unit id="1f74203ecf6c5e6aa71439f7d49b6b4738761859" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 키에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 맵 입니다.</target>
        </trans-unit>
        <trans-unit id="e8c92eb26aefeaf7f5adf2cafbf52ebcc77c3862" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 이지만 &lt;code&gt;f&lt;/code&gt; 가 엄격하게 단조로운 경우에만 작동합니다 . 즉, 임의의 값이며, &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 경우, &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 다음 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; . &lt;em&gt;전제 조건이 점검되지 않았습니다. &lt;/em&gt;반 공식적으로, 우리는 :</target>
        </trans-unit>
        <trans-unit id="9100fd3a27e166f348e6cd61f6a291f6e0417995" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intset#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; is the set obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intset#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 요소에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 집합 입니다.</target>
        </trans-unit>
        <trans-unit id="d205ac9d99bcd11ba10bdf3d053d0d44937ca6ca" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; is the set obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 각 요소에 &lt;code&gt;f&lt;/code&gt; 를 적용하여 얻은 집합 입니다.</target>
        </trans-unit>
        <trans-unit id="d619d90fc5b48cf5af644e6dcbb4f68f4674b874" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Build a map from a list of key/value pairs with a combining function. See also fromAscListWithKey'.</source>
          <target state="translated">O (n * 분 (n, W)). 결합 기능을 사용하여 키 / 값 쌍 목록에서 맵을 작성하십시오. fromAscListWithKey '도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a2422ae977d3f41d77926cd0791db18ae04e3ec" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). 결합 기능을 사용하여 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5049b4311dd1d4031e503c8eb3922c754e897945" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). 결합 기능을 사용하여 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bea1f51f900a25425eba0fd0046a89d1236cf0a" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n * 분 (n, W)). 결합 기능을 사용하여 키 / 값 쌍 목록에서 맵을 작성하십시오. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5e34b3e78c63542e8bb8d0adde3243e4615d23d" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a map from a list of key/value pairs.</source>
          <target state="translated">O (n * 분 (n, W)). 키 / 값 쌍 목록에서 맵을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b7a6efb65f9b82dfbe8c913159082518b7d595ff" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a set from a list of integers.</source>
          <target state="translated">O (n * 분 (n, W)). 정수 목록에서 세트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b9feaf7c13d0928ac7999068f93fb53410e85f11" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). The set of all keys of the map.</source>
          <target state="translated">O (n * 분 (n, W)). 지도의 모든 키 세트입니다.</target>
        </trans-unit>
        <trans-unit id="36e608696cdf9e28e6a2b62b32b357e3d0dad570" translate="yes" xml:space="preserve">
          <source>O(n+m) Find all non-overlapping instances of &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt;. Each element of the returned list consists of a pair:</source>
          <target state="translated">O (n + m) &lt;code&gt;haystack&lt;/code&gt; 에서 겹치지 않는 &lt;code&gt;needle&lt;/code&gt; 인스턴스를 모두 찾습니다 . 리턴 된 목록의 각 요소는 쌍으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b44547ebca41c66fe9bd023df1af24399976630d" translate="yes" xml:space="preserve">
          <source>O(n+m) Find the first instance of &lt;code&gt;needle&lt;/code&gt; (which must be non-&lt;code&gt;&lt;a href=&quot;data-text#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;) in &lt;code&gt;haystack&lt;/code&gt;. The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; before &lt;code&gt;needle&lt;/code&gt; is matched. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, starting with the match.</source>
          <target state="translated">O (n + m) &lt;code&gt;haystack&lt;/code&gt; 에서 &lt;code&gt;needle&lt;/code&gt; 의 첫 번째 인스턴스 ( &lt;code&gt;&lt;a href=&quot;data-text#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; 이 아니 어야 함 )를 찾습니다 . 반환 된 튜플의 첫 번째 요소는 &lt;code&gt;needle&lt;/code&gt; 이 일치 하기 전에 &lt;code&gt;haystack&lt;/code&gt; 의 접두사입니다 . 두 번째는 일치로 시작 하는 나머지 &lt;code&gt;haystack&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65c9466c31e6549336e0668edfa4ccca44c0acb5" translate="yes" xml:space="preserve">
          <source>O(n+m) Find the first instance of &lt;code&gt;needle&lt;/code&gt; (which must be non-&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;) in &lt;code&gt;haystack&lt;/code&gt;. The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; before &lt;code&gt;needle&lt;/code&gt; is matched. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, starting with the match.</source>
          <target state="translated">O (n + m) &lt;code&gt;haystack&lt;/code&gt; 에서 &lt;code&gt;needle&lt;/code&gt; 의 첫 번째 인스턴스 ( &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; 이 아니 어야 함 )를 찾습니다 . 반환 된 튜플의 첫 번째 요소는 &lt;code&gt;needle&lt;/code&gt; 이 일치 하기 전에 &lt;code&gt;haystack&lt;/code&gt; 의 접두사입니다 . 두 번째는 일치로 시작 하는 나머지 &lt;code&gt;haystack&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a5717f7a8e94cdda15365780f80755eeaf720de" translate="yes" xml:space="preserve">
          <source>O(n+m) Find the offsets of all non-overlapping indices of &lt;code&gt;needle&lt;/code&gt; within &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">O (n + m) &lt;code&gt;haystack&lt;/code&gt; 내 에서 &lt;code&gt;needle&lt;/code&gt; 겹치지 않는 모든 인덱스의 오프셋을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="cf145a14b4d45ba3bdedb33baa39b464e5635f5b" translate="yes" xml:space="preserve">
          <source>O(n+m) Find the offsets of all non-overlapping indices of &lt;code&gt;needle&lt;/code&gt; within &lt;code&gt;haystack&lt;/code&gt;. The offsets returned represent uncorrected indices in the low-level &quot;needle&quot; array, to which its offset must be added.</source>
          <target state="translated">O (n + m) &lt;code&gt;haystack&lt;/code&gt; 내 에서 &lt;code&gt;needle&lt;/code&gt; 겹치지 않는 모든 인덱스의 오프셋을 찾습니다 . 반환 된 오프셋은 오프셋을 추가해야하는 낮은 수준의 &quot;바늘&quot;배열에서 수정되지 않은 인덱스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e3c9d725275f03324a3b2fdda6f1f233ef3169f0" translate="yes" xml:space="preserve">
          <source>O(n+m) Similar to &lt;code&gt;&lt;a href=&quot;data-text#v:breakOn&quot;&gt;breakOn&lt;/a&gt;&lt;/code&gt;, but searches from the end of the string.</source>
          <target state="translated">O (n + m) &lt;code&gt;&lt;a href=&quot;data-text#v:breakOn&quot;&gt;breakOn&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 문자열 끝에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="1175fd5285a043c9a711ebebaffc18e9667d9a54" translate="yes" xml:space="preserve">
          <source>O(n+m) Similar to &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOn&quot;&gt;breakOn&lt;/a&gt;&lt;/code&gt;, but searches from the end of the string.</source>
          <target state="translated">O (n + m) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOn&quot;&gt;breakOn&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 문자열 끝에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="c9a3b9a9ca60934ef751e0d1700fb0db56e70fe4" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text#v:count&quot;&gt;count&lt;/a&gt;&lt;/code&gt; function returns the number of times the query string appears in the given &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. An empty query string is invalid, and will cause an error to be raised.</source>
          <target state="translated">O (n + m) &lt;code&gt;&lt;a href=&quot;data-text#v:count&quot;&gt;count&lt;/a&gt;&lt;/code&gt; 함수는 쿼리 문자열이 지정된 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 나타나는 횟수를 반환합니다 . 빈 쿼리 문자열이 유효하지 않아 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc07bd53a44d4b9fca8e25e271227f0696b1c205" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">O (n + m) &lt;code&gt;&lt;a href=&quot;data-text#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 취하고 첫 번째가 전체적으로 그리고 그대로 두 번째 내의 아무 곳에 나 포함되어 있으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="31e6cd194953d70c5fa065b8183d9f30516b0948" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:count&quot;&gt;count&lt;/a&gt;&lt;/code&gt; function returns the number of times the query string appears in the given &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. An empty query string is invalid, and will cause an error to be raised.</source>
          <target state="translated">O (n + m) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:count&quot;&gt;count&lt;/a&gt;&lt;/code&gt; 함수는 쿼리 문자열이 지정된 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 나타나는 횟수를 반환합니다 . 빈 쿼리 문자열이 유효하지 않아 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="13382ca7340a8eaf3a939b2a1ed948b0dcfdc7f0" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">O (n + m) &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 취하고 첫 번째가 전체적으로 그리고 그대로 두 번째 내의 아무 곳에 나 포함되어 있으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2167067fadd513712bc42846c5d961980cc14b15" translate="yes" xml:space="preserve">
          <source>O(n+m). A high-performance universal combining function. Using &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, all combining functions can be defined without any loss of efficiency (with exception of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, where sharing of some nodes is lost with &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 고성능 범용 결합 기능. 사용 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 을 모두 결합 기능 (의 제외 효율의 손실없이 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 일부 노드의 공유가와 손실, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0a7b74bed8767dfd4c8cbfc6c23cdee7572f0523" translate="yes" xml:space="preserve">
          <source>O(n+m). A high-performance universal combining function. Using &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, all combining functions can be defined without any loss of efficiency (with exception of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, where sharing of some nodes is lost with &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 고성능 범용 결합 기능. 사용 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 을 모두 결합 기능 (의 제외 효율의 손실없이 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 일부 노드의 공유가와 손실, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5a51f66550cd6721cfbc2055ced63ae8b5b721b" translate="yes" xml:space="preserve">
          <source>O(n+m). A high-performance universal combining function. Using &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, all combining functions can be defined without any loss of efficiency (with exception of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, where sharing of some nodes is lost with &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 고성능 범용 결합 기능. 사용 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 을 모두 결합 기능 (의 제외 효율의 손실없이 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 일부 노드의 공유가와 손실, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2c9d53c1a61505c507a77f11e744f10ac5321fd" translate="yes" xml:space="preserve">
          <source>O(n+m). An unsafe general combining function.</source>
          <target state="translated">O (n + m). 안전하지 않은 일반 결합 기능.</target>
        </trans-unit>
        <trans-unit id="04c17b4d406e8e7f791bcdc5e7bbabd3bda36558" translate="yes" xml:space="preserve">
          <source>O(n+m). An unsafe universal combining function.</source>
          <target state="translated">O (n + m). 안전하지 않은 범용 결합 기능.</target>
        </trans-unit>
        <trans-unit id="6904fa4f9eeb478245da7ef5b29f442d3a069927" translate="yes" xml:space="preserve">
          <source>O(n+m). Check whether the key sets of two maps are disjoint (i.e. their &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; is empty).</source>
          <target state="translated">O (n + m). 두 맵의 키 세트가 분리되어 있는지 확인하십시오 (즉, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 가 비어 있음).</target>
        </trans-unit>
        <trans-unit id="fe24974c1f1cf88414158604450576321622c099" translate="yes" xml:space="preserve">
          <source>O(n+m). Check whether the key sets of two maps are disjoint (i.e. their &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; is empty).</source>
          <target state="translated">O (n + m). 두 맵의 키 세트가 분리되어 있는지 확인하십시오 (즉, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 가 비어 있음).</target>
        </trans-unit>
        <trans-unit id="a401abee7ced03111b359144c8a12d3572504805" translate="yes" xml:space="preserve">
          <source>O(n+m). Check whether the key sets of two maps are disjoint (i.e. their &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; is empty).</source>
          <target state="translated">O (n + m). 두 맵의 키 세트가 분리되어 있는지 확인하십시오 (즉, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 가 비어 있음).</target>
        </trans-unit>
        <trans-unit id="6d12ca25c9eb6961c2321d4afa8587c92934e2fb" translate="yes" xml:space="preserve">
          <source>O(n+m). Check whether two sets are disjoint (i.e. their intersection is empty).</source>
          <target state="translated">O (n + m). 두 세트가 분리되어 있는지 확인하십시오 (예 : 교차점이 비어 있음).</target>
        </trans-unit>
        <trans-unit id="c04ab65196d99d47289a58d92620f68e15fbe411" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference between two maps (based on keys).</source>
          <target state="translated">O (n + m). 두지도의 차이점 (키 기준)</target>
        </trans-unit>
        <trans-unit id="2b175850b2b4c7b73920a2bd09ee395823dfe991" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference between two sets.</source>
          <target state="translated">O (n + m). 두 세트의 차이점.</target>
        </trans-unit>
        <trans-unit id="642024d6eebec205fb5e23871df26affc526f51e" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function.</source>
          <target state="translated">O (n + m). 결합 기능의 차이점.</target>
        </trans-unit>
        <trans-unit id="e82cae1cbcc151c7d43da06a29f3d4c4dd638d8d" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O (n + m). 결합 기능과의 차이점. 두 개의 동일한 키가 발견되면 결합 기능이 키와 두 값에 모두 적용됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 하면 요소가 삭제됩니다 (적절한 설정 차이). ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; )를 반환 하면 요소가 새로운 값 &lt;code&gt;y&lt;/code&gt; 로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="d78a59691af3a1f463fcc648f48e7aa9af5140a2" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O (n + m). 결합 기능과의 차이. 두 개의 동일한 키가 발견되면 결합 기능이 키와 두 값 모두에 적용됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 하면 요소가 삭제됩니다 (적절한 집합 차이). ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; )를 반환 하면 요소가 새 값 &lt;code&gt;y&lt;/code&gt; 로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a8defb5abb9dc37227acdef0ddf8e9086576b96" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the values of these keys. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O (n + m). 결합 기능과의 차이점. 두 개의 동일한 키가 있으면 결합 기능이이 키의 값에 적용됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 하면 요소가 삭제됩니다 (적절한 설정 차이). ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; )를 반환 하면 요소가 새로운 값 &lt;code&gt;y&lt;/code&gt; 로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b9232eb6da84be956de3d86b2f9a3596b670d07" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the values of these keys. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O (n + m). 결합 기능과의 차이. 두 개의 동일한 키가 발견되면 이러한 키의 값에 결합 기능이 적용됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 하면 요소가 삭제됩니다 (적절한 집합 차이). ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; )를 반환 하면 요소가 새 값 &lt;code&gt;y&lt;/code&gt; 로 업데이트됩니다. .</target>
        </trans-unit>
        <trans-unit id="1893b5539e545690e9ffd683494151968ad95c91" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). ( &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ) 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0bcad9d148cb43a988e5d81559c7f98bfd4f571" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). ( &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ) 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="259d7f16c8ef5c42b712b6bd1b6d835707d3fc6f" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). ( &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ) 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa500881115a261c32e171d67351b5d2ec39a167" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 모든 키없는 동일 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="086a4885e056a23c714c075d705073db4b763166" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 모든 키없는 동일 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다. .</target>
        </trans-unit>
        <trans-unit id="c3f52f4b27c74c68545875153116cd3df8e8618e" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 모든 키없는 동일 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="15f91d0ab0f998067f2adeb93623344211d85bda" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 모든 키없는 동일 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다. .</target>
        </trans-unit>
        <trans-unit id="d36e66134f49baa74c16748aa4fb1bc2f1b590a7" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 모든 키없는 동일 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="e04f7f18a1ae2e5b701ed54d8ae7d55bbc518436" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). 이것이 적절한 서브맵입니까? (즉, 서브맵이지만 같지 않음). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 모든 키없는 동일 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다. .</target>
        </trans-unit>
        <trans-unit id="4a631953f81d0e447c8fdc69cf069142667e281d" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper subset? (ie. a subset but not equal).</source>
          <target state="translated">O (n + m). 이것이 적절한 하위 집합입니까? (즉, 서브 세트이지만 동일하지는 않음).</target>
        </trans-unit>
        <trans-unit id="eebc330ada31dc89576a052f1291e0814e19b344" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a submap? Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 서브맵입니까? ( &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ) 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="77cf7a69469399af955924e2279784b9e2604e7f" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a submap? Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 서브맵입니까? ( &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ) 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="4431560a42f73900705f2d8f975011e0f9131735" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a submap? Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 서브맵입니까? ( &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ) 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="95f1327cbb34c7f0d462f61ec2eb2bdb693eb58b" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a subset? &lt;code&gt;(s1 `isSubsetOf` s2)&lt;/code&gt; tells whether &lt;code&gt;s1&lt;/code&gt; is a subset of &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">O (n + m). 이것이 하위 집합입니까? &lt;code&gt;(s1 `isSubsetOf` s2)&lt;/code&gt; 는 &lt;code&gt;s1&lt;/code&gt; 이 &lt;code&gt;s2&lt;/code&gt; 의 부분 집합 인지 여부를 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="853dab43bcbe16991732c6d4b28495ea5732e019" translate="yes" xml:space="preserve">
          <source>O(n+m). Remove all the keys in a given set from a map.</source>
          <target state="translated">O (n + m). 주어진 세트의 모든 키를 맵에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c1b95d70a81d94d1b2f2943a9a8a879ae12ca499" translate="yes" xml:space="preserve">
          <source>O(n+m). See &lt;code&gt;&lt;a href=&quot;data-intset#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n + m). &lt;code&gt;&lt;a href=&quot;data-intset#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c0c033e78b5f044fb2891d9b4979b5fb0a3e771" translate="yes" xml:space="preserve">
          <source>O(n+m). See &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O (n + m). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aabc7bfe4185073a15a5de307d4e92518cd380a6" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) intersection of two maps (based on keys).</source>
          <target state="translated">O (n + m). 두지도의 (왼쪽 바이어스) 교차점 (키 기준).</target>
        </trans-unit>
        <trans-unit id="06961d5d1ab5fa2c8570a9d85046d4a05dc7eb63" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 두 맵의 (왼쪽 바이어스) 연합입니다. 중복 키가 발생할 때 첫 번째 맵을 선호합니다 (즉, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8af9eb1020703ed741e76dfbd54678ef12ddfe5" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 두 맵의 (왼쪽 편향) 합집합입니다. 중복 키가 발견되면 첫 번째 맵을 선호합니다. 즉 ( &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bafc90ea33c8a530d3beef31c5367384af63f7c0" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 두 맵의 (왼쪽 바이어스) 연합입니다. 중복 키가 발생할 때 첫 번째 맵을 선호합니다 (즉, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="06cca18a9ea62d448cb2ae8ce6046a32a6eeb7e5" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 두 맵의 (왼쪽 편향) 합집합입니다. 중복 키가 발견되면 첫 번째 맵을 선호합니다. 즉 ( &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4ad0a244b4a8b2f49ef3d414deb4d187f9a6cc2" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 두 맵의 (왼쪽 바이어스) 연합입니다. 중복 키가 발생할 때 첫 번째 맵을 선호합니다 (즉, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31e89469c4001a829fde3233e342d7e9eec1929b" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O (n + m). 두 맵의 (왼쪽 편향) 합집합입니다. 중복 키가 발견되면 첫 번째 맵을 선호합니다. 즉 ( &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc2918486dc9d1b3d88c95caecdcf91f0062806a" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 모든 키 경우 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="0a51544441efda5b774bf5ba7135522fa07aeb34" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 모든 키 경우 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다. .</target>
        </trans-unit>
        <trans-unit id="c682f84ef41f26c41a860753eec9a7c1df03b072" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 모든 키 경우 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d46f07e5f2d5ba28c84ab4450e5f9330078bcc3c" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 모든 키 경우 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다. .</target>
        </trans-unit>
        <trans-unit id="28c133c2820ef14ec3aca95b5da1617ff047b0eb" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 모든 키 경우 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3c133848b5c3643fa590368299465506d198f3bc" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O (n + m). (식 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; )를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 모든 키 경우 &lt;code&gt;m1&lt;/code&gt; 에 &lt;code&gt;m2&lt;/code&gt; 시기 및 &lt;code&gt;f&lt;/code&gt; 를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 자신의 각각의 값에 적용 할 때. 예를 들어 다음 표현식은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 입니다. .</target>
        </trans-unit>
        <trans-unit id="0f82649fd48787dfa3f6fb48e8009b24ac636f79" translate="yes" xml:space="preserve">
          <source>O(n+m). The intersection of two sets.</source>
          <target state="translated">O (n + m). 두 세트의 교차점.</target>
        </trans-unit>
        <trans-unit id="9cc718bb4770b7a90006261329b003135139c8ad" translate="yes" xml:space="preserve">
          <source>O(n+m). The intersection with a combining function.</source>
          <target state="translated">O (n + m). 결합 기능과의 교차점.</target>
        </trans-unit>
        <trans-unit id="890f8c2b1acfa581b0c7f7e114b78e7d23366ee0" translate="yes" xml:space="preserve">
          <source>O(n+m). The restriction of a map to the keys in a set.</source>
          <target state="translated">O (n + m). 세트의 키에 대한 맵 제한.</target>
        </trans-unit>
        <trans-unit id="5016a3d0debf2b50c789dd9e1a7b6671faab6a15" translate="yes" xml:space="preserve">
          <source>O(n+m). The union of two sets.</source>
          <target state="translated">O (n + m). 두 세트의 합집합</target>
        </trans-unit>
        <trans-unit id="fd2cc7317cafb69298079beaf97e19917cd839b3" translate="yes" xml:space="preserve">
          <source>O(n+m). The union with a combining function.</source>
          <target state="translated">O (n + m). 결합 기능과의 결합</target>
        </trans-unit>
        <trans-unit id="7d7e0023469558d3f70102c921ee4c3a9e3395fd" translate="yes" xml:space="preserve">
          <source>O(n/c) Append a byte to the end of a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 끝에 바이트를 추가</target>
        </trans-unit>
        <trans-unit id="6cc37b0e22800234ef3f07b1490484598d0573ab" translate="yes" xml:space="preserve">
          <source>O(n/c) Append two ByteStrings</source>
          <target state="translated">O (n / c) 두 개의 ByteString 추가</target>
        </trans-unit>
        <trans-unit id="2d16b77d7608c5b05bf8bdfa8224cce8737fe128" translate="yes" xml:space="preserve">
          <source>O(n/c) Appends one &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to another. Subject to fusion.</source>
          <target state="translated">O (n / c) 한 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 다른 텍스트 에 추가합니다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83e9729beee8e50770bb2d1f1ad5ed715db824b2" translate="yes" xml:space="preserve">
          <source>O(n/c) Extract the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a ByteString, returning Nothing if it is empty.</source>
          <target state="translated">O (n / c) ByteString 의 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 를 추출하여 비어 있으면 Nothing을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d9647ec0d877c0b2b247e8f277a0813bb9fa700" translate="yes" xml:space="preserve">
          <source>O(n/c) Extract the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a ByteString, returning Nothing if it is empty.</source>
          <target state="translated">O (n / c) ByteString 의 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 를 추출하여 비어 있으면 Nothing을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9b60c39448cd17dc08f0f768a3a97ebd3de0381d" translate="yes" xml:space="preserve">
          <source>O(n/c) Extract the last element of a ByteString, which must be finite and non-empty.</source>
          <target state="translated">O (n / c) 유한하고 비어 있지 않은 ByteString의 마지막 요소를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="37b6278fe47a64e98a0bf8147cadf1bb592f7472" translate="yes" xml:space="preserve">
          <source>O(n/c) Return all the elements of a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; except the last one.</source>
          <target state="translated">O (n / c) 마지막을 제외한 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 모든 요소를 ​​반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6a2b4a041ecc6ab0616448e8c20b0c5a37880038" translate="yes" xml:space="preserve">
          <source>O(n/c) Return all the elements of a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; except the last one.</source>
          <target state="translated">O (n / c) 마지막을 제외한 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 모든 요소를 ​​반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0e3ad70873ec194a1a39a69714dd21042af5e5ad" translate="yes" xml:space="preserve">
          <source>O(n/c) Returns all but the last character of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 마지막 문자를 제외한 모든 문자를 반환하며 , 비어 있지 않아야합니다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27f439a72af29ea013e45190eb466312a751e58a" translate="yes" xml:space="preserve">
          <source>O(n/c) Returns the &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if empty.</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 를 반환 하거나 비어 있으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e459c0133a7fa1d77589eafc5ac9befb3f26dfe" translate="yes" xml:space="preserve">
          <source>O(n/c) Returns the last character of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 마지막 문자를 반환하며 , 비어 있지 않아야합니다. 융합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b739d6be59fd1e3bd8ffa28a8cf4f0e86b46fcc" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; returns the suffix of &lt;code&gt;xs&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; elements, or &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 는 첫 번째 &lt;code&gt;n&lt;/code&gt; 요소 다음 의 &lt;code&gt;xs&lt;/code&gt; 접미사를 반환 하거나 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs 인 경우 &lt;code&gt;[]&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3230bf165ab4f88bcfb24f3948a318fab7ae358c" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 는 ByteString의 길이를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f33a588e4903fd21668a1f7077c81aabda2ed64" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 는 ByteString의 길이를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="279a301156ba949c3ca05606b442b0fe4820bb23" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; is equivalent to &lt;code&gt;(&lt;a href=&quot;data-bytestring-lazy#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-lazy#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt;.</source>
          <target state="translated">O는 (N / C) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 와 동등하다 &lt;code&gt;(&lt;a href=&quot;data-bytestring-lazy#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-lazy#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="098f5344db1894ea2ce7cb94140d79449edea1d5" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a ByteString &lt;code&gt;xs&lt;/code&gt;, returns the prefix of &lt;code&gt;xs&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;xs&lt;/code&gt; itself if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O (n / c) 는 ByteString &lt;code&gt;xs&lt;/code&gt; 에 적용되는 &lt;code&gt;n&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; , 길이 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;xs&lt;/code&gt; 접두사를 반환 하거나 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs 인 경우 &lt;code&gt;xs&lt;/code&gt; 자체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f36361a6522b2ae73d9a8f3d84f7bfb6f86caa03" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; returns the suffix of &lt;code&gt;xs&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; elements, or &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 는 첫 번째 &lt;code&gt;n&lt;/code&gt; 요소 다음 의 &lt;code&gt;xs&lt;/code&gt; 접미사를 반환 하거나 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs 인 경우 &lt;code&gt;[]&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="dca9d892c44a82be4d56f29a65e495be62351350" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 는 ByteString의 길이를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="033d5573aff7a09739e31b4140066fa4a57ad5ae" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O (n / c) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 는 ByteString의 길이를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5306bdfe59376f62c270fc886b633e2f6e1dcd87" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; is equivalent to &lt;code&gt;(&lt;a href=&quot;data-bytestring-lazy-char8#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-lazy-char8#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt;.</source>
          <target state="translated">O는 (N / C) &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 와 동등하다 &lt;code&gt;(&lt;a href=&quot;data-bytestring-lazy-char8#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-lazy-char8#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c57cb3fd24a15391e066d7bb4903681e1cc442e" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a ByteString &lt;code&gt;xs&lt;/code&gt;, returns the prefix of &lt;code&gt;xs&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;xs&lt;/code&gt; itself if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O (n / c) 는 ByteString &lt;code&gt;xs&lt;/code&gt; 에 적용되는 &lt;code&gt;n&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; , 길이 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;xs&lt;/code&gt; 접두사를 반환 하거나 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs 인 경우 &lt;code&gt;xs&lt;/code&gt; 자체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7fef8912f31d84073770a6dedf25eb44f12874e5" translate="yes" xml:space="preserve">
          <source>O(n^2). The &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">O (n ^ 2). &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수는 목록에서 중복 요소를 제거합니다. 특히 각 요소의 첫 번째 항목 만 유지합니다. &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 라는 이름 은 '에센스'를 의미합니다. 이것은 &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="92f2f94e099bb7227cfcc768bf47b8c9015c9ce7" translate="yes" xml:space="preserve">
          <source>O(n^2). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">O (n ^ 2). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수는 목록에서 중복 요소를 제거합니다. 특히 각 요소의 첫 번째 항목 만 유지합니다. &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 라는 이름 은 '에센스'를 의미합니다. 이것은 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="a61ad319127b680ea53570fe744c01d959f80faf" translate="yes" xml:space="preserve">
          <source>OSVERSIONINFOEX</source>
          <target state="translated">OSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="9beeba965ae8dfbfff40f9bb14dd3916873ca225" translate="yes" xml:space="preserve">
          <source>O_APPEND</source>
          <target state="translated">O_APPEND</target>
        </trans-unit>
        <trans-unit id="1d359ddeab5bd0bfc7e36286fbd4b017c0306eca" translate="yes" xml:space="preserve">
          <source>O_EXCL</source>
          <target state="translated">O_EXCL</target>
        </trans-unit>
        <trans-unit id="5cb2bdb342c206ea5f6f844817a04b4faff12dc1" translate="yes" xml:space="preserve">
          <source>O_NOCTTY</source>
          <target state="translated">O_NOCTTY</target>
        </trans-unit>
        <trans-unit id="4c2fbe88ccc156499e1adb5569ddb4a71e2a0944" translate="yes" xml:space="preserve">
          <source>O_NONBLOCK</source>
          <target state="translated">O_NONBLOCK</target>
        </trans-unit>
        <trans-unit id="2ee322829f78f74d8bacf972b329ca8066c9a6c7" translate="yes" xml:space="preserve">
          <source>O_SYNC</source>
          <target state="translated">O_SYNC</target>
        </trans-unit>
        <trans-unit id="ce320f21777d59129eeca3fbf91595d9a215b3b0" translate="yes" xml:space="preserve">
          <source>O_TRUNC</source>
          <target state="translated">O_TRUNC</target>
        </trans-unit>
        <trans-unit id="fa81ee290b985173ab2f672fb935281b2d2e6c39" translate="yes" xml:space="preserve">
          <source>Object (.o)</source>
          <target state="translated">객체 (.o)</target>
        </trans-unit>
        <trans-unit id="6b2f496323a4895019ec0a9b369fe04ec7ca98eb" translate="yes" xml:space="preserve">
          <source>Object files linked into shared objects must be compiled with &lt;a href=&quot;#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt;</source>
          <target state="translated">공유 객체에 링크 된 객체 파일은 &lt;a href=&quot;#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; 으로 컴파일해야합니다 ( &lt;a href=&quot;#options-codegen&quot;&gt;코드 생성에 영향을주는 옵션&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="47de13ee5612750157967f1515fc00db4a7c92bd" translate="yes" xml:space="preserve">
          <source>Objective C</source>
          <target state="translated">목표 C</target>
        </trans-unit>
        <trans-unit id="706f81efadad70c24efce57ea6d4e51ec7d7b3af" translate="yes" xml:space="preserve">
          <source>Objective C++</source>
          <target state="translated">목표 C ++</target>
        </trans-unit>
        <trans-unit id="007aa0511eafaf62149d25010b14a8bb508fb130" translate="yes" xml:space="preserve">
          <source>Observe a type representation for the type of a value.</source>
          <target state="translated">값의 유형에 대한 유형 표현을 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="cd150df10728118f52cdf23f860179c0fad85301" translate="yes" xml:space="preserve">
          <source>Observe the &lt;code&gt;&lt;a href=&quot;ghc-fingerprint-type#t:Fingerprint&quot;&gt;Fingerprint&lt;/a&gt;&lt;/code&gt; of a type representation</source>
          <target state="translated">유형 표현 의 &lt;code&gt;&lt;a href=&quot;ghc-fingerprint-type#t:Fingerprint&quot;&gt;Fingerprint&lt;/a&gt;&lt;/code&gt; 을 관찰하십시오</target>
        </trans-unit>
        <trans-unit id="409bd195ee5312c03c5d82bb0a53f65357224327" translate="yes" xml:space="preserve">
          <source>Observe the argument types of a type representation</source>
          <target state="translated">유형 표현의 인수 유형을 관찰하십시오</target>
        </trans-unit>
        <trans-unit id="b4b8289ec30f6e1a557ff9064f1f6b20543a7105" translate="yes" xml:space="preserve">
          <source>Observe the kind of a type.</source>
          <target state="translated">유형의 종류를 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="053b657569ecb7e098a31a03ae84e78b99ac515b" translate="yes" xml:space="preserve">
          <source>Observe the type constructor of a quantified type representation.</source>
          <target state="translated">정량화 된 유형 표현의 유형 생성자를 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="a2ccc102a2dfd9eb15f652450214c5947ce98f64" translate="yes" xml:space="preserve">
          <source>Observe the type constructor of a type representation</source>
          <target state="translated">타입 표현의 타입 생성자를 관찰</target>
        </trans-unit>
        <trans-unit id="0618a214d16e39be75c6315a11d086a7dcbea1b6" translate="yes" xml:space="preserve">
          <source>Observers</source>
          <target state="translated">Observers</target>
        </trans-unit>
        <trans-unit id="39a3a78d27464eeb6b4e25918dbf5c9b44c8072a" translate="yes" xml:space="preserve">
          <source>Observing type representations</source>
          <target state="translated">타입 표현 관찰</target>
        </trans-unit>
        <trans-unit id="bde229174b59bd1c95b5316149d2ce6a8e8efb33" translate="yes" xml:space="preserve">
          <source>Obsolete helpers</source>
          <target state="translated">사용되지 않는 도우미</target>
        </trans-unit>
        <trans-unit id="0fb9100499fe89a0975e82b1a3a8f4e9d2fd735d" translate="yes" xml:space="preserve">
          <source>Obtain a temporary file path with the given suffix. The compiler will delete this file after compilation.</source>
          <target state="translated">주어진 접미사가있는 임시 파일 경로를 얻습니다. 컴파일러는 컴파일 후이 파일을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="08504fa744e6ae985fd5e1d3159ba4d86ca141de" translate="yes" xml:space="preserve">
          <source>Obtain the Haskell value referenced by a stable pointer, i.e., the same value that was passed to the corresponding call to &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:newStablePtr&quot;&gt;newStablePtr&lt;/a&gt;&lt;/code&gt;. If the argument to &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; has already been freed using &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;, the behaviour of &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">안정적인 포인터, 즉 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:newStablePtr&quot;&gt;newStablePtr&lt;/a&gt;&lt;/code&gt; 에 대한 해당 호출에 전달 된 동일한 값으로 참조 된 Haskell 값을 가져옵니다 . 의 인수 경우 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 이 이미 사용 해제 된 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; 을 의 행동 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="700d14839cf29e3aa8bb6f2235b72aaad3a7ed94" translate="yes" xml:space="preserve">
          <source>Obtain the Haskell value referenced by a stable pointer, i.e., the same value that was passed to the corresponding call to &lt;code&gt;&lt;a href=&quot;ghc-stable#v:newStablePtr&quot;&gt;newStablePtr&lt;/a&gt;&lt;/code&gt;. If the argument to &lt;code&gt;&lt;a href=&quot;ghc-stable#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; has already been freed using &lt;code&gt;&lt;a href=&quot;ghc-stable#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;, the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-stable#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">안정적인 포인터, 즉 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:newStablePtr&quot;&gt;newStablePtr&lt;/a&gt;&lt;/code&gt; 에 대한 해당 호출에 전달 된 동일한 값으로 참조 된 Haskell 값을 가져옵니다 . 의 인수 경우 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 이 이미 사용 해제 된 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; 을 의 행동 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2440e4e145be4eb215fcb093e788fb9960299cd" translate="yes" xml:space="preserve">
          <source>Obtain the current working directory as an absolute path.</source>
          <target state="translated">현재 작업 디렉토리를 절대 경로로 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="c1dd9feacb8ad914196a33496bfe7966a0a186c8" translate="yes" xml:space="preserve">
          <source>Obtain the path to a special directory for storing user-specific application data (traditional Unix location). Newer applications may prefer the the XDG-conformant location provided by &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; (&lt;a href=&quot;https://github.com/haskell/directory/issues/6#issuecomment-96521020&quot;&gt;migration guide&lt;/a&gt;).</source>
          <target state="translated">사용자 별 응용 프로그램 데이터 (전통적인 Unix 위치)를 저장하기위한 특수 디렉토리의 경로를 얻습니다. 최신 애플리케이션은 &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; ( &lt;a href=&quot;https://github.com/haskell/directory/issues/6#issuecomment-96521020&quot;&gt;마이그레이션 안내서&lt;/a&gt; )가 제공하는 XDG 호환 위치를 선호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c48b83679543b94189e3b3857193ee60a82c74c" translate="yes" xml:space="preserve">
          <source>Obtain the paths to special directories for storing user-specific application data, configuration, and cache files, conforming to the &lt;a href=&quot;http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG Base Directory Specification&lt;/a&gt;. Compared with &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt;, this function provides a more fine-grained hierarchy as well as greater flexibility for the user.</source>
          <target state="translated">&lt;a href=&quot;http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG 기본 디렉토리 스펙에&lt;/a&gt; 따라 사용자 별 애플리케이션 데이터, 구성 및 캐시 파일을 저장하기위한 특수 디렉토리에 대한 경로를 확보하십시오 . &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; 와 비교할 때이 함수는보다 세분화 된 계층 구조를 제공하고 사용자에게 더 큰 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9ca83079153a8ef840b63ce27bb2fb8a367d26e7" translate="yes" xml:space="preserve">
          <source>Obtain the size of a file in bytes.</source>
          <target state="translated">파일 크기를 바이트 단위로 구하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe9c6afc02350dde6bce9905666a177cb7718a2" translate="yes" xml:space="preserve">
          <source>Obtain the time at which the file or directory was last accessed.</source>
          <target state="translated">파일 또는 디렉토리에 마지막으로 액세스 한 시간을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="fe02e9af07ca18b2e182f9029db868dc37a5029e" translate="yes" xml:space="preserve">
          <source>Obtain the time at which the file or directory was last modified.</source>
          <target state="translated">파일 또는 디렉토리가 마지막으로 수정 된 시간을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="ff7dba47666639f94394aa3dd0febd37e4ecc275" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">로부터 획득 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="8d89b30a22ab542b2220d609d797437caf3a9581" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad의 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 에서 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="442dc1559deffb0ef963faf7fa54adec4e60807c" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">로부터 획득 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="808af45a8c161f66c05c30204ffc7b09a12d4c71" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/template-haskell-2.15.0.0/Language-Haskell-TH-Lib.html#v:thisModule&quot;&gt;thisModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/template-haskell-2.15.0.0/Language-Haskell-TH-Lib.html#v:thisModule&quot;&gt;thisModule&lt;/a&gt;&lt;/code&gt; 에서 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="d46cc88ad2b7ebeb92e27c492df182c9102b8ed0" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad의 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 에서 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="f7e2e85147570bbfd1afb948ab5b789d3478fe86" translate="yes" xml:space="preserve">
          <source>Obtaining file status</source>
          <target state="translated">파일 상태 얻기</target>
        </trans-unit>
        <trans-unit id="e3870373daca7d25421aaf721af5436c7f6ea920" translate="yes" xml:space="preserve">
          <source>Obtaining the constructor from a given datum. For proper terms, this is meant to be the top-level constructor. Primitive datatypes are here viewed as potentially infinite sets of values (i.e., constructors).</source>
          <target state="translated">지정된 데이텀에서 생성자를 가져옵니다. 적절한 용어로, 이것은 최상위 생성자입니다. 기본 데이터 유형은 잠재적으로 무한한 값 세트 (즉, 생성자)로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1f8c61df2bac9fbfd23bad2f0e9746f16edb8aa7" translate="yes" xml:space="preserve">
          <source>OccName</source>
          <target state="translated">OccName</target>
        </trans-unit>
        <trans-unit id="a8ecac7d31bbf740edf1b0b3ea851c89f44a5d30" translate="yes" xml:space="preserve">
          <source>Occasionally &lt;strong&gt;gv&lt;/strong&gt; will choke as it tries to read an incomplete copy of &lt;code&gt;FOO.ps&lt;/code&gt; (because &lt;strong&gt;hp2ps&lt;/strong&gt; is still running as an update occurs). A slightly more complicated script works around this problem, by using the fact that sending a SIGHUP to gv will cause it to re-read its input file:</source>
          <target state="translated">때때로 &lt;strong&gt;gv&lt;/strong&gt; 는 불완전한 &lt;code&gt;FOO.ps&lt;/code&gt; 복사본을 읽으려고 할 때 질식합니다 ( &lt;strong&gt;hp2ps&lt;/strong&gt; 가 업데이트가 진행되는 동안 여전히 실행 중이기 때문에 ). SIGHUP을 gv로 보내면 입력 파일을 다시 읽을 수 있다는 사실을 사용하여 약간 더 복잡한 스크립트가이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="7d892360b7aa6e79ccbbb2db9552ec0912fed1fe" translate="yes" xml:space="preserve">
          <source>Octal and hexadecimal numerics are not recognized as a single token</source>
          <target state="translated">8 진수 및 16 진수는 단일 토큰으로 인식되지 않습니다</target>
        </trans-unit>
        <trans-unit id="31ef00312f2e1ee7506655b11623866b09a38490" translate="yes" xml:space="preserve">
          <source>OddParity</source>
          <target state="translated">OddParity</target>
        </trans-unit>
        <trans-unit id="14ad9c3a886a6706b68193db972d3c2fd0f4dd48" translate="yes" xml:space="preserve">
          <source>Oddly enough, people really do use this option! Our pal in Durham (England), Paul Callaghan, writes: &amp;ldquo;Some people here use it for a variety of purposes&amp;mdash;honestly!&amp;mdash;e.g., confirmation that the code/machine is doing something, infinite loop detection, gauging cost of recently added code. Certain people can even tell what stage [the program] is in by the beep pattern. But the major use is for annoying others in the same office&amp;hellip;&amp;rdquo;</source>
          <target state="translated">이상하게도 사람들은 실제로이 옵션을 사용합니다! Paul Callaghan의 Durham (영국)에있는 우리 친구는 이렇게 말합니다.&amp;ldquo;여기서는 코드 / 기계가 무언가를하고 있다는 확인, 무한 루프 감지, 최근 추가 된 코드의 측정 비용과 같은 다양한 목적으로 정직하게 사용합니다. . 어떤 사람들은 경고음 패턴에 의해 어떤 프로그램이 어떤 단계에 있는지 알 수 있습니다. 그러나 주요 용도는 같은 사무실에서 다른 사람들을 성가 시게하는 것입니다&amp;hellip;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0c0b0b1a2080b74e19b756494638ec92162f2758" translate="yes" xml:space="preserve">
          <source>Odds and ends, mostly functions for reading and showing &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;-like kind of values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 와 끝. 대부분 RealFloat 와 같은 종류의 값 을 읽고 표시하는 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="fb4aa7843d0c5581b08750305cac08a18952a151" translate="yes" xml:space="preserve">
          <source>Of course when running another interactive program in the console then we want to let that program handle Ctl-C. Under Unix however, Ctl-C sends &lt;code&gt;SIGINT&lt;/code&gt; to every process using the console. The standard solution is that while running an interactive program, ignore &lt;code&gt;SIGINT&lt;/code&gt; in the parent, and let it be handled in the child process. If that process then terminates due to the &lt;code&gt;SIGINT&lt;/code&gt; signal, then at that point treat it as if we had recieved the &lt;code&gt;SIGINT&lt;/code&gt; ourselves and begin an orderly shutdown.</source>
          <target state="translated">물론 콘솔에서 다른 대화식 프로그램을 실행할 때 해당 프로그램이 Ctl-C를 처리하도록하려고합니다. 그러나 Unix에서는 Ctl-C 가 콘솔을 사용하여 모든 프로세스에 &lt;code&gt;SIGINT&lt;/code&gt; 를 보냅니다 . 표준 솔루션은 대화식 프로그램을 실행하는 동안 상위에서 &lt;code&gt;SIGINT&lt;/code&gt; 를 무시 하고 하위 프로세스에서 처리되도록하는 것입니다. 그 과정은 다음에 의한 종료되면 &lt;code&gt;SIGINT&lt;/code&gt; 의 우리가 받았다 것처럼 그 시점 치료 그것을 다음, 신호 &lt;code&gt;SIGINT&lt;/code&gt; 에게 자신을하고 순서대로 종료를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="13cbc7281dc8f2ba063030a73854a759868eae8d" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;UndecidableInstances&lt;/code&gt; lifts the Paterson Conditions, as now.</source>
          <target state="translated">물론, &lt;code&gt;UndecidableInstances&lt;/code&gt; 는 지금과 같이 패터슨 조건을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="bd80101b7867bda9e4de541e2013550d0cd09fca" translate="yes" xml:space="preserve">
          <source>Of course, if you have foreign calls in your program then all bets are off, because you can trash the heap, the stack, or whatever.</source>
          <target state="translated">물론, 프로그램에 외화 호출이 있으면 힙, 스택 등을 휴지통에 버릴 수 있기 때문에 모든 베팅이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="a37fd12339c76f03254c6a2485812a618d645f86" translate="yes" xml:space="preserve">
          <source>Of course, in this particular situation you can do even better:</source>
          <target state="translated">물론이 특별한 상황에서 더 잘 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="959274964b08ed6b64f4a784f4ffb9f800fb0e15" translate="yes" xml:space="preserve">
          <source>Of course, you can also bind normal non-IO expressions using the &lt;code&gt;let&lt;/code&gt;-statement:</source>
          <target state="translated">물론 &lt;code&gt;let&lt;/code&gt; -statement를 사용하여 일반 비 IO 표현식을 바인딩 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b1e2c81f99bb1db90306be62673e1a90e706694" translate="yes" xml:space="preserve">
          <source>Of the form &lt;code&gt;TYPE r&lt;/code&gt; for some &lt;code&gt;r&lt;/code&gt; (see &lt;a href=&quot;#runtime-rep&quot;&gt;Levity polymorphism&lt;/a&gt;). For example:</source>
          <target state="translated">일부 &lt;code&gt;r&lt;/code&gt; 의 경우 &lt;code&gt;TYPE r&lt;/code&gt; 형식 ( &lt;a href=&quot;#runtime-rep&quot;&gt;Levity 다형성&lt;/a&gt; 참조) ). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="ea2c1b968cb14580f767587f854d5b3baa84a1fa" translate="yes" xml:space="preserve">
          <source>Offset into first</source>
          <target state="translated">처음으로 오프셋</target>
        </trans-unit>
        <trans-unit id="5c4232ca426c972654e6acef0e24307e9bf01cdb" translate="yes" xml:space="preserve">
          <source>Offset into second</source>
          <target state="translated">두 번째로 오프셋</target>
        </trans-unit>
        <trans-unit id="f8e5c2c7cae1141a37276f0a36a8a63d24f1a869" translate="yes" xml:space="preserve">
          <source>Often a particular data structure is being retained by a chain of unevaluated closures, only the nearest of which will be reported by retainer profiling - for example &lt;code&gt;A&lt;/code&gt; retains &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; retains &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; retains a large structure. There might be a large number of &lt;code&gt;B&lt;/code&gt;s but only a single &lt;code&gt;A&lt;/code&gt;, so &lt;code&gt;A&lt;/code&gt; is really the one we&amp;rsquo;re interested in eliminating. However, retainer profiling will in this case report &lt;code&gt;B&lt;/code&gt; as the retainer of the large structure. To move further up the chain of retainers, we can ask for another retainer profile but this time restrict the profile to &lt;code&gt;B&lt;/code&gt; objects, so we get a profile of the retainers of &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">종종 특정 데이터 구조는 고정 프로파일로보고한다 만 가까운있는 미 평가 클로저의 체인에 의해 유지되고있다 - 예를 위해 &lt;code&gt;A&lt;/code&gt; 유지 &lt;code&gt;B&lt;/code&gt; 를 , &lt;code&gt;B&lt;/code&gt; 는 유지 &lt;code&gt;C&lt;/code&gt; 를 , 그리고 &lt;code&gt;C&lt;/code&gt; 가 큰 구조를 유지한다. 다수의 &lt;code&gt;B&lt;/code&gt; 가있을 수 있지만 단일 &lt;code&gt;A&lt;/code&gt; 만 있을 수 있으므로 &lt;code&gt;A&lt;/code&gt; 는 실제로 우리가 제거하고자하는 것입니다. 그러나이 경우 리테이너 프로파일 링은 &lt;code&gt;B&lt;/code&gt; 를 대형 구조의 리테이너로 보고 합니다. 리테이너 체인 위로 더 이동하려면 다른 리테이너 프로필을 요청할 수 있지만 이번에는 프로필을 &lt;code&gt;B&lt;/code&gt; 로 제한합니다. &lt;code&gt;B&lt;/code&gt; 의 리테이너 프로파일을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="69167169d72ddc29203b8842fec5ca3158c37c4a" translate="yes" xml:space="preserve">
          <source>Old API kept to avoid breaking clients</source>
          <target state="translated">이전 API는 클라이언트 중단을 피하기 위해 유지</target>
        </trans-unit>
        <trans-unit id="9ce5a70368f8243b3801e08794befe07bb9b0130" translate="yes" xml:space="preserve">
          <source>Old deprecated functions</source>
          <target state="translated">더 이상 사용되지 않는 이전 함수</target>
        </trans-unit>
        <trans-unit id="199b0ae233b01261174a40c433e452bd8e11764e" translate="yes" xml:space="preserve">
          <source>Old path</source>
          <target state="translated">오래된 길</target>
        </trans-unit>
        <trans-unit id="9b285d963737095a360d0a661d0df2fea803a4ac" translate="yes" xml:space="preserve">
          <source>Omit code generation</source>
          <target state="translated">코드 생성 생략</target>
        </trans-unit>
        <trans-unit id="06b348347f0fc6282795f8b8662b8c726c982724" translate="yes" xml:space="preserve">
          <source>Omit code generation (and all later phases) altogether. This is useful if you&amp;rsquo;re only interested in type checking code.</source>
          <target state="translated">코드 생성 (및 모든 이후 단계)을 모두 생략하십시오. 유형 검사 코드에만 관심이있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="143759d6a82a6e782ba8b006ab52848e42762c71" translate="yes" xml:space="preserve">
          <source>Omit heap checks when no allocation is being performed.</source>
          <target state="translated">할당이 수행되지 않을 때 힙 검사를 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="7e25f9708b019df5d840bb95bec43db511395b29" translate="yes" xml:space="preserve">
          <source>Omits the link step. This option can be used with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; to avoid the automatic linking that takes place if the program contains a &lt;code&gt;Main&lt;/code&gt; module.</source>
          <target state="translated">링크 단계를 생략합니다. 이 옵션을 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 프로그램에 &lt;code&gt;Main&lt;/code&gt; 모듈이 포함 된 경우 자동 연결이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60e957e3d9a735dd58ec78b95add59bf7dee68af" translate="yes" xml:space="preserve">
          <source>Omitting &lt;code&gt;-N⟨x⟩&lt;/code&gt; entirely means &lt;code&gt;-N1&lt;/code&gt;.</source>
          <target state="translated">생략 &lt;code&gt;-N⟨x⟩&lt;/code&gt; 는 완전히 의미 &lt;code&gt;-N1&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="852085b8a1ca62c46bfcfacdf985dc281e39d842" translate="yes" xml:space="preserve">
          <source>Omitting generic instances</source>
          <target state="translated">일반 인스턴스 생략</target>
        </trans-unit>
        <trans-unit id="02a33c2d0537913c5f5350486a8c3f93ad4f4e57" translate="yes" xml:space="preserve">
          <source>Omitting ⟨x⟩, i.e. &lt;code&gt;+RTS -N -RTS&lt;/code&gt;, lets the runtime choose the value of ⟨x⟩ itself based on how many processors are in your machine.</source>
          <target state="translated">⟨x⟩ (예 : &lt;code&gt;+RTS -N -RTS&lt;/code&gt; )를 생략 하면 런타임은 머신에있는 프로세서 수에 따라 ⟨x⟩ 자체의 값을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d76fc4eb3563c85ec6bb33fc1966e50eaee83c" translate="yes" xml:space="preserve">
          <source>On 32-bit x86 platforms when using the native code generator, the &lt;a href=&quot;using-optimisation#ghc-flag--fexcess-precision&quot;&gt;&lt;code&gt;-fexcess-precision&lt;/code&gt;&lt;/a&gt; option is always on. This means that floating-point calculations are non-deterministic, because depending on how the program is compiled (optimisation settings, for example), certain calculations might be done at 80-bit precision instead of the intended 32-bit or 64-bit precision. Floating-point results may differ when optimisation is turned on. In the worst case, referential transparency is violated, because for example &lt;code&gt;let x = E1 in E2&lt;/code&gt; can evaluate to a different value than &lt;code&gt;E2[E1/x]&lt;/code&gt;.</source>
          <target state="translated">원시 코드 생성기를 사용할 때 32 비트 x86 플랫폼에서 &lt;a href=&quot;using-optimisation#ghc-flag--fexcess-precision&quot;&gt; &lt;code&gt;-fexcess-precision&lt;/code&gt; &lt;/a&gt; 옵션은 항상 켜져 있습니다. 즉, 부동 소수점 계산은 프로그램이 컴파일되는 방법 (예 : 최적화 설정)에 따라 의도 된 32 비트 또는 64 비트 정밀도 대신 80 비트 정밀도로 수행 될 수 있으므로 결정적이지 않습니다. . 최적화가 켜져 있으면 부동 소수점 결과가 다를 수 있습니다. 최악의 경우, 참조 투명도는 위반됩니다. 예를 들어 &lt;code&gt;let x = E1 in E2&lt;/code&gt; 이 &lt;code&gt;E2[E1/x]&lt;/code&gt; 와 다른 값으로 평가 될 수 있기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="1391cbd23623d8953378e909f91a6612b37b28fe" translate="yes" xml:space="preserve">
          <source>On 64-bit machines, the RTS needs to allocate memory in the low 2Gb of the address space. Support for this across different operating systems is patchy, and sometimes fails. This option is there to give the RTS a hint about where it should be able to allocate memory in the low 2Gb of the address space. For example, &lt;code&gt;+RTS -xm20000000 -RTS&lt;/code&gt; would hint that the RTS should allocate starting at the 0.5Gb mark. The default is to use the OS&amp;rsquo;s built-in support for allocating memory in the low 2Gb if available (e.g. &lt;code&gt;mmap&lt;/code&gt; with &lt;code&gt;MAP_32BIT&lt;/code&gt; on Linux), or otherwise &lt;code&gt;-xm40000000&lt;/code&gt;.</source>
          <target state="translated">64 비트 시스템에서 RTS는 주소 공간의 낮은 2Gb에 메모리를 할당해야합니다. 여러 운영 체제에서이 기능에 대한 지원이 불완전하며 때때로 실패합니다. 이 옵션은 RTS에게 주소 공간의 낮은 2Gb에서 메모리를 할당 할 수있는 위치에 대한 힌트를 제공합니다. 예를 들어 &lt;code&gt;+RTS -xm20000000 -RTS&lt;/code&gt; 는 RTS가 0.5Gb 표시에서 시작해야 함을 암시합니다. 기본 내장 지원 낮은 기가 바이트의 메모리를 할당하는 OS를 사용하는 것입니다 (예를 들어, 사용 가능한 경우 &lt;code&gt;mmap&lt;/code&gt; 에 와 &lt;code&gt;MAP_32BIT&lt;/code&gt; 리눅스), 또는 기타 &lt;code&gt;-xm40000000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097883c1f4907fb1b521ee5631f70e7ddf86398d" translate="yes" xml:space="preserve">
          <source>On 64-bit machines, the runtime linker usually needs to map object code into the low 2Gb of the address space, due to the x86_64 small memory model where most symbol references are 32 bits. The problem is that this 2Gb of address space can fill up, especially if you&amp;rsquo;re loading a very large number of object files into GHCi.</source>
          <target state="translated">64 비트 컴퓨터에서 런타임 링커는 대부분의 기호 참조가 32 비트 인 x86_64 소형 메모리 모델로 인해 일반적으로 개체 코드를 주소 공간의 낮은 2Gb로 매핑해야합니다. 문제는이 2Gb의 주소 공간이 채워질 수 있다는 것입니다. 특히 GHCi에 매우 많은 수의 개체 파일을로드하는 경우 더욱 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="56b14479147dc851f7df3c7d9e83023d77f4f785" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X, dynamic libraries are stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the ultimate install path of the library file. Any libraries or executables that subsequently link against it will pick up that path as their runtime search location for it. By default, ghc sets the install name to the location where the library is built. This option allows you to override it with the specified file path. (It passes &lt;code&gt;-install_name&lt;/code&gt; to Apple&amp;rsquo;s linker.) Ignored on other platforms.</source>
          <target state="translated">Darwin / OS X에서 동적 라이브러리는 빌드시 라이브러리 파일의 최종 설치 경로 인&amp;ldquo;설치 이름&amp;rdquo;으로 스탬프 처리됩니다. 이후에 링크되는 라이브러리 또는 실행 파일은 해당 경로를 런타임 검색 위치로 선택합니다. 기본적으로 ghc는 설치 이름을 라이브러리가 구축 된 위치로 설정합니다. 이 옵션을 사용하면 지정된 파일 경로로 대체 할 수 있습니다. ( &lt;code&gt;-install_name&lt;/code&gt; 을 Apple의 링커로 전달합니다 .) 다른 플랫폼에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c502a4721745da19ad3306edaec1023d6b7312d6" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, add ⟨dir⟩ to the list of directories searched for frameworks. This option corresponds to the &lt;code&gt;-F&lt;/code&gt; option for Apple&amp;rsquo;s Linker.</source>
          <target state="translated">Darwin / OS X / iOS에서만 프레임 워크를 검색 한 디렉토리 목록에 ⟨dir⟩을 추가하십시오. 이 옵션 은 Apple 링커 의 &lt;code&gt;-F&lt;/code&gt; 옵션에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="f8f858556433cf6929170371cf16d1d28b70f4f0" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, add ⟨dir⟩ to the list of directories searched for frameworks. This option corresponds to the &lt;code&gt;-F&lt;/code&gt; option for Apple's Linker.</source>
          <target state="translated">Darwin / OS X / iOS에서만 프레임 워크를 검색 한 디렉토리 목록에 ⟨dir⟩을 추가합니다. 이 옵션 은 Apple Linker 의 &lt;code&gt;-F&lt;/code&gt; 옵션에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="836aeb62038416ab5d18c1c4cccc6b7891cf00da" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the &lt;code&gt;-framework&lt;/code&gt; option for Apple&amp;rsquo;s Linker.</source>
          <target state="translated">Darwin / OS X / iOS에서만 ⟨name⟩ 프레임 워크에 링크하십시오. 이 옵션 은 Apple 링커 의 &lt;code&gt;-framework&lt;/code&gt; 옵션에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="0d2f8a49d8d4c58193d7bce9934ad90451e92201" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the &lt;code&gt;-framework&lt;/code&gt; option for Apple&amp;rsquo;s Linker. Please note that frameworks and packages are two different things - frameworks don&amp;rsquo;t contain any Haskell code. Rather, they are Apple&amp;rsquo;s way of packaging shared libraries. To link to Apple&amp;rsquo;s &amp;ldquo;Carbon&amp;rdquo; API, for example, you&amp;rsquo;d use &lt;code&gt;-framework Carbon&lt;/code&gt;.</source>
          <target state="translated">Darwin / OS X / iOS에서만 ⟨name⟩ 프레임 워크에 링크하십시오. 이 옵션 은 Apple 링커 의 &lt;code&gt;-framework&lt;/code&gt; 옵션에 해당합니다 . 프레임 워크와 패키지는 서로 다른 두 가지입니다. 프레임 워크에는 Haskell 코드가 포함되어 있지 않습니다. 오히려 공유 라이브러리를 패키징하는 Apple의 방식입니다. 예를 들어 Apple의 &quot;Carbon&quot;API에 연결하려면 &lt;code&gt;-framework Carbon&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cccac3a36668d1fdad31c6e062fb07a44e28644" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the &lt;code&gt;-framework&lt;/code&gt; option for Apple's Linker.</source>
          <target state="translated">Darwin / OS X / iOS에서만 프레임 워크 ⟨name⟩에 링크하십시오. 이 옵션 은 Apple Linker 의 &lt;code&gt;-framework&lt;/code&gt; 옵션에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="c57aabecc887720cc819888b560ff938ff24a471" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, prepend the directory ⟨dir⟩ to the framework directories path. This option corresponds to the &lt;code&gt;-F&lt;/code&gt; option for Apple&amp;rsquo;s Linker (&lt;code&gt;-F&lt;/code&gt; already means something else for GHC).</source>
          <target state="translated">Darwin / OS X / iOS에서만 ⟨dir⟩ 디렉토리를 프레임 워크 디렉토리 경로 앞에 추가하십시오. 이 옵션 은 Apple 링커 의 &lt;code&gt;-F&lt;/code&gt; 옵션에 해당합니다 ( &lt;code&gt;-F&lt;/code&gt; 는 이미 GHC의 다른 것을 의미 함).</target>
        </trans-unit>
        <trans-unit id="f6e8ba5a3fab15f9e41a75f470422c219a534bb8" translate="yes" xml:space="preserve">
          <source>On GHC, the runtime will ensure that any Haskell thread will only see &quot;its own&quot; &lt;code&gt;errno&lt;/code&gt;, by saving and restoring the value when Haskell threads are scheduled across OS threads.</source>
          <target state="translated">GHC에서 런타임은 Haskell 스레드가 OS 스레드에서 스케줄 될 때 값을 저장하고 복원하여 Haskell 스레드가 &quot;자체&quot; &lt;code&gt;errno&lt;/code&gt; 만 볼 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="c71882ba581cd6bc6d41d871050d79d61de4659e" translate="yes" xml:space="preserve">
          <source>On Linux, MADV_FREE is newer and faster because it can avoid zeroing pages if they are re-used by the process later (see &lt;code&gt;man 2 madvise&lt;/code&gt;), but for the trade-off that memory inspection tools like &lt;code&gt;top&lt;/code&gt; will not immediately reflect the freeing in their display of resident memory (RSS column): Only under memory pressure will Linux actually remove the freed pages from the process and update its RSS statistics. Until then, the pages show up as &lt;code&gt;LazyFree&lt;/code&gt; in &lt;code&gt;/proc/PID/smaps&lt;/code&gt; (see &lt;code&gt;man 5 proc&lt;/code&gt;).</source>
          <target state="translated">Linux에서 MADV_FREE는 나중에 프로세스에 의해 재사용되는 경우 페이지를 0으로 만드는 것을 피할 수 있기 때문에 더 새롭고 빠르지 만 ( &lt;code&gt;man 2 madvise&lt;/code&gt; 참조 ), &lt;code&gt;top&lt;/code&gt; 과 같은 메모리 검사 도구 가 즉시 해제를 반영하지는 않습니다. 상주 메모리 표시 (RSS 열) : 메모리 부족 상태에서만 Linux는 실제로 프로세스에서 해제 된 페이지를 제거하고 RSS 통계를 업데이트합니다. 그때까지 페이지는 &lt;code&gt;/proc/PID/smaps&lt;/code&gt; 에서 &lt;code&gt;LazyFree&lt;/code&gt; 로 표시됩니다 ( &lt;code&gt;man 5 proc&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="40cc400d7871c058aaff05bc589d341778622e21" translate="yes" xml:space="preserve">
          <source>On POSIX platforms these two new handles will always be Nothing</source>
          <target state="translated">POSIX 플랫폼에서이 두 개의 새로운 핸들은 항상 아무것도 아닙니다</target>
        </trans-unit>
        <trans-unit id="078d3ef4757340184bdc802a0b2704173202e340" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this is equivalent to &lt;code&gt;stat&lt;/code&gt; followed by &lt;code&gt;chmod&lt;/code&gt;.</source>
          <target state="translated">POSIX 시스템에서 이는 &lt;code&gt;stat&lt;/code&gt; 다음에 &lt;code&gt;chmod&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e5150091903944c9e80b85e4f5491e74472f81c1" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this returns the result of &lt;code&gt;access&lt;/code&gt;.</source>
          <target state="translated">POSIX 시스템에서는 &lt;code&gt;access&lt;/code&gt; 결과를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0e1256ac8aafae1c7e4adb4ddae8c68c82e5af71" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this sets the &lt;em&gt;owner&lt;/em&gt; permissions.</source>
          <target state="translated">POSIX 시스템에서 이것은 &lt;em&gt;소유자&lt;/em&gt; 권한을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="15a6eb7d1aee9c1397492586a65a460c544dbaea" translate="yes" xml:space="preserve">
          <source>On POSIX, equivalent to &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:simplifyPosix&quot;&gt;simplifyPosix&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX에서는 &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:simplifyPosix&quot;&gt;simplifyPosix&lt;/a&gt;&lt;/code&gt; Posix와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a057a4f6c4818787b76f3467f2b22b0d6a9e3b6d" translate="yes" xml:space="preserve">
          <source>On POSIX-compatible platforms GHC&amp;rsquo;s runtime system (when built with &lt;code&gt;libdw&lt;/code&gt; support) will produce a stack trace on &lt;code&gt;stderr&lt;/code&gt; when a &lt;code&gt;SIGQUIT&lt;/code&gt; signal is received (on many systems this signal can be sent using</source>
          <target state="translated">POSIX 호환 플랫폼에서 GHC의 런타임 시스템 ( &lt;code&gt;libdw&lt;/code&gt; 지원으로 빌드 된 경우)은 &lt;code&gt;SIGQUIT&lt;/code&gt; 신호가 수신 될 때 &lt;code&gt;stderr&lt;/code&gt; 에 스택 추적을 생성합니다 (많은 시스템에서이 신호는</target>
        </trans-unit>
        <trans-unit id="6c168ab7b60c55fc5b0097e465ca6c5d25010787" translate="yes" xml:space="preserve">
          <source>On POSIX-compatible platforms GHC&amp;rsquo;s runtime system (when built with &lt;code&gt;libdw&lt;/code&gt; support) will produce a stack trace on &lt;code&gt;stderr&lt;/code&gt; when a &lt;code&gt;SIGQUIT&lt;/code&gt; signal is received (on many systems this signal can be sent using &lt;code&gt;Ctrl-\&lt;/code&gt;). For instance (using the same &lt;code&gt;fib.hs&lt;/code&gt; as above),</source>
          <target state="translated">POSIX 호환 플랫폼에서 GHC의 런타임 시스템 ( &lt;code&gt;libdw&lt;/code&gt; 지원으로 구축 된 경우)은 &lt;code&gt;SIGQUIT&lt;/code&gt; 신호가 수신 될 때 &lt;code&gt;stderr&lt;/code&gt; 에서 스택 추적을 생성합니다 (많은 시스템에서이 신호는 &lt;code&gt;Ctrl-\&lt;/code&gt; 를 사용하여 전송 될 수 있음 ). 예를 들어 ( 위와 같은 &lt;code&gt;fib.hs&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="0422707a616b81e28b0b133b6079462f1cb7aac1" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; sends the process the SIGTERM signal. On Windows systems, if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; function is called to kill all processes associated with the job and passing the exit code of 1 to each of them. Otherwise if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; function is called, passing an exit code of 1.</source>
          <target state="translated">Unix 시스템에서 &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; 는 프로세스에 SIGTERM 신호를 보냅니다. Windows 시스템에서 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인 경우 작업과 연관된 모든 프로세스를 종료하고 종료 코드 1을 각 프로세스에 전달하기 위해 Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; 함수가 호출됩니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이면 종료 코드 1을 전달 하여 Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="26000ccdb50e03ab1029e35d0df1776d18e9ab0e" translate="yes" xml:space="preserve">
          <source>On Unix systems, it sends the group the SIGINT signal.</source>
          <target state="translated">Unix 시스템에서는 그룹에 SIGINT 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c6d0966027827b87508cf93ba9e2a42091942bf2" translate="yes" xml:space="preserve">
          <source>On Unix systems, see &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for the meaning of exit codes when the process died as the result of a signal.</source>
          <target state="translated">Unix 시스템 에서 프로세스가 신호의 결과로 종료 된 경우 종료 코드의 의미는 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09629c83332620e6e6759db7b31141b99ca9c762" translate="yes" xml:space="preserve">
          <source>On Unix there are two mechanisms. Shared libraries can be installed into standard locations that the dynamic linker knows about. For example &lt;code&gt;/usr/lib&lt;/code&gt; or &lt;code&gt;/usr/local/lib&lt;/code&gt; on most systems. The other mechanism is to use a &amp;ldquo;runtime path&amp;rdquo; or &amp;ldquo;rpath&amp;rdquo; embedded into programs and libraries themselves. These paths can either be absolute paths or on at least Linux and Solaris they can be paths relative to the program or library itself. In principle this makes it possible to construct fully relocatable sets of programs and libraries.</source>
          <target state="translated">유닉스에는 두 가지 메커니즘이 있습니다. 동적 라이브러리가 알고있는 표준 위치에 공유 라이브러리를 설치할 수 있습니다. 예를 들어 대부분의 시스템에서 &lt;code&gt;/usr/lib&lt;/code&gt; 또는 &lt;code&gt;/usr/local/lib&lt;/code&gt; 입니다. 다른 메커니즘은 프로그램 및 라이브러리 자체에 포함 된 &quot;런타임 경로&quot;또는 &quot;rpath&quot;를 사용하는 것입니다. 이러한 경로는 절대 경로이거나 최소한 Linux 및 Solaris에서 프로그램 또는 라이브러리 자체에 대한 경로 일 수 있습니다. 원칙적으로 이것은 재배치 가능한 프로그램 및 라이브러리 세트를 구성 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1aa9bf14869ffa0729b113a2919b90d3a99f83ea" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getHomeDirectory&quot;&gt;getHomeDirectory&lt;/a&gt;&lt;/code&gt; behaves as follows:</source>
          <target state="translated">유닉스에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:getHomeDirectory&quot;&gt;getHomeDirectory&lt;/a&gt;&lt;/code&gt; 는 다음과 같이 동작합니다 :</target>
        </trans-unit>
        <trans-unit id="dbda9eb325b9c89423ab40811c09f445058a091b" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getTemporaryDirectory&quot;&gt;getTemporaryDirectory&lt;/a&gt;&lt;/code&gt; returns the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable or &quot;/tmp&quot; if the variable isn't defined. On Windows, the function checks for the existence of environment variables in the following order and uses the first path found:</source>
          <target state="translated">Unix에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:getTemporaryDirectory&quot;&gt;getTemporaryDirectory&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수 또는 변수가 정의되지 않은 경우 &quot;/ tmp&quot; 의 값을 리턴합니다 . Windows에서 함수는 다음 순서로 환경 변수가 있는지 확인하고 발견 된 첫 번째 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="db73ed697e88171697c761e2de6ba9e3b2fdb8f6" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getUserDocumentsDirectory&quot;&gt;getUserDocumentsDirectory&lt;/a&gt;&lt;/code&gt; returns the value of the &lt;code&gt;HOME&lt;/code&gt; environment variable. On Windows, the system is queried for a suitable path; a typical path might be &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/Documents&lt;/code&gt;.</source>
          <target state="translated">Unix에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:getUserDocumentsDirectory&quot;&gt;getUserDocumentsDirectory&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;HOME&lt;/code&gt; 환경 변수 의 값을 리턴합니다 . Windows에서 시스템은 적절한 경로를 조회합니다. 일반적인 경로는 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/Documents&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6aec3d6d90c1ca53af23e974fd0a1470d206561" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, permissions, access time, and modification time are preserved. If possible, the owner and group are also preserved. Note that the very act of copying can change the access time of the source file, hence the access times of the two files may differ after the operation completes.</source>
          <target state="translated">유닉스 계열 시스템에서는 권한, 액세스 시간 및 수정 시간이 유지됩니다. 가능하면 소유자와 그룹도 보존됩니다. 복사 작업으로 인해 소스 파일의 액세스 시간이 변경 될 수 있으므로 작업이 완료된 후 두 파일의 액세스 시간이 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f67f27323ff913fec8fc3bce6fba0553de49353" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, the path is &lt;code&gt;~/.&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">유닉스 계열 시스템에서 경로는 &lt;code&gt;~/.&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2acf1d643c18794b5ab0d3288014560943c06f0b" translate="yes" xml:space="preserve">
          <source>On Unix: &lt;code&gt;$HOME/.ghc/ghci.conf&lt;/code&gt;</source>
          <target state="translated">유닉스에서 : &lt;code&gt;$HOME/.ghc/ghci.conf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="686bba75bbf12a7e94f3f601b8b2b6f1c767e5b6" translate="yes" xml:space="preserve">
          <source>On Win32 platforms, &lt;code&gt;renameDirectory&lt;/code&gt; fails if the &lt;em&gt;new&lt;/em&gt; directory already exists.</source>
          <target state="translated">Win32 플랫폼 에서 &lt;em&gt;새&lt;/em&gt; 디렉토리가 이미 존재 하면 &lt;code&gt;renameDirectory&lt;/code&gt; 가 실패 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4cf66c11f13f8d5cfb30fa66ff975ad9d16e7224" translate="yes" xml:space="preserve">
          <source>On Windows XP or earlier systems, junction expansion is not performed due to their lack of &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt;.</source>
          <target state="translated">Windows XP 이하 시스템에서는 &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; 이 없어 접합 확장이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e2645284c47be98a8acf2a83e433b0e66594a2f2" translate="yes" xml:space="preserve">
          <source>On Windows a second wait method can be used to block for event completion. This requires two handles. A process job handle and a events handle to monitor.</source>
          <target state="translated">Windows에서는 두 번째 대기 방법을 사용하여 이벤트 완료를 차단할 수 있습니다. 두 개의 핸들이 필요합니다. 프로세스 작업 핸들 및 모니터링 할 이벤트 핸들.</target>
        </trans-unit>
        <trans-unit id="9658f389cd47e6221668fd22bc06e990b9d9dd68" translate="yes" xml:space="preserve">
          <source>On Windows hs_init treats argv as UTF8-encoded. Passing other encodings might lead to unexpected results. Passing NULL as argv is valid but can lead to &amp;lt;unknown&amp;gt; showing up in error messages instead of the name of the executable.</source>
          <target state="translated">Windows에서 hs_init는 argv를 UTF8로 인코딩 된 것으로 취급합니다. 다른 인코딩을 전달하면 예기치 않은 결과가 발생할 수 있습니다. argv가 유효하지만 NULL을 전달하면 실행 파일 이름 대신 &amp;lt;unknown&amp;gt;이 오류 메시지에 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4698d639ab062d2aed61863bbaa5096920591d6" translate="yes" xml:space="preserve">
          <source>On Windows systems this flag indicates that we should wait for the entire process tree to finish before unblocking. On POSIX systems this flag is ignored. See $exec-on-windows for details.</source>
          <target state="translated">Windows 시스템에서이 플래그는 차단을 해제하기 전에 전체 프로세스 트리가 완료 될 때까지 기다려야 함을 나타냅니다. POSIX 시스템에서이 플래그는 무시됩니다. 자세한 내용은 $ exec-on-windows를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="45e04fe208e77db2f230b90c671409e216534e94" translate="yes" xml:space="preserve">
          <source>On Windows systems, it generates a CTRL_BREAK_EVENT and will only work for processes created using &lt;code&gt;createProcess&lt;/code&gt; and setting the &lt;code&gt;&lt;a href=&quot;system-process#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; flag</source>
          <target state="translated">Windows 시스템에서는 CTRL_BREAK_EVENT를 생성하며 &lt;code&gt;createProcess&lt;/code&gt; 를 사용하여 작성된 프로세스 및 &lt;code&gt;&lt;a href=&quot;system-process#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; 플래그를 설정하는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d883d2ded3f33c4ac5277dea1b34c15e47204a0e" translate="yes" xml:space="preserve">
          <source>On Windows systems, it generates a CTRL_BREAK_EVENT and will only work for processes created using &lt;code&gt;createProcess&lt;/code&gt; and setting the &lt;code&gt;&lt;a href=&quot;system-process-internals#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; flag</source>
          <target state="translated">Windows 시스템에서는 CTRL_BREAK_EVENT를 생성하며 &lt;code&gt;createProcess&lt;/code&gt; 를 사용하여 작성된 프로세스 및 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; 플래그를 설정하는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1311c5b9754526fe0793423a543b261c1854ae36" translate="yes" xml:space="preserve">
          <source>On Windows systems, this calls &lt;code&gt;DeviceIoControl&lt;/code&gt; with &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt;. In addition to symbolic links, the function also works on junction points. On POSIX systems, this calls &lt;code&gt;readlink&lt;/code&gt;.</source>
          <target state="translated">Windows 시스템에서는 &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt; 를 사용 하여 &lt;code&gt;DeviceIoControl&lt;/code&gt; 을 호출합니다 . 심볼릭 링크 외에도이 기능은 접합점에서도 작동합니다. POSIX 시스템에서는 &lt;code&gt;readlink&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f1567544926c7445013dc0be717298582cb416b6" translate="yes" xml:space="preserve">
          <source>On Windows this has no effect.</source>
          <target state="translated">Windows에서는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f02d4da8e0b35ffd3d2c36f1392b357f6c5f8d8" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; passes the command to the Windows command interpreter (&lt;code&gt;CMD.EXE&lt;/code&gt; or &lt;code&gt;COMMAND.COM&lt;/code&gt;), hence Unixy shell tricks will not work.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 은 Windows 명령 인터프리터 ( &lt;code&gt;CMD.EXE&lt;/code&gt; 또는 &lt;code&gt;COMMAND.COM&lt;/code&gt; )로 명령을 전달 하므로 Unixy 쉘 트릭은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48c350060f4cd8913452b9533ace5233eb42f47d" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; usually map to the same directory unless overridden.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; 는 대체되지 않는 한 일반적으로 동일한 디렉토리에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b2c2a5d7334002daf6e872673bc987f5bdaaf260" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; usually map to the same list of directories unless overridden.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; 는 대체되지 않는 한 일반적으로 동일한 디렉토리 목록에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8b25994ba9790bb8044b9cc7287876fc972fce5c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; calls the Win32 function &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa365527.aspx&quot;&gt;SearchPath&lt;/a&gt;&lt;/code&gt;, which may search other places before checking the directories in the &lt;code&gt;PATH&lt;/code&gt; environment variable. Where it actually searches depends on registry settings, but notably includes the directory containing the current executable.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 은 Win32 함수 &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa365527.aspx&quot;&gt;SearchPath&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 에서 디렉토리를 확인하기 전에 다른 위치를 검색 할 수 있습니다 . 실제로 검색하는 위치는 레지스트리 설정에 따라 다르지만 특히 현재 실행 파일이 들어있는 디렉토리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dca5f3e83bb026318939bea1cd25a1940f11ff0f" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; passes the command to the Windows command interpreter (&lt;code&gt;CMD.EXE&lt;/code&gt; or &lt;code&gt;COMMAND.COM&lt;/code&gt;), hence Unixy shell tricks will not work.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 은 Windows 명령 인터프리터 ( &lt;code&gt;CMD.EXE&lt;/code&gt; 또는 &lt;code&gt;COMMAND.COM&lt;/code&gt; )로 명령을 전달 하므로 Unixy 쉘 트릭은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8886822cdea6ae2e0b2d173208997d3a1f79f72" translate="yes" xml:space="preserve">
          <source>On Windows, GHC normally generates a manifest file when linking a binary. The manifest is placed in the file &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; where ⟨prog.exe⟩ is the name of the executable. The manifest file currently serves just one purpose: it disables the &amp;ldquo;installer detection&amp;rdquo; in Windows Vista that attempts to elevate privileges for executables with certain names (e.g. names containing &amp;ldquo;install&amp;rdquo;, &amp;ldquo;setup&amp;rdquo; or &amp;ldquo;patch&amp;rdquo;). Without the manifest file to turn off installer detection, attempting to run an executable that Windows deems to be an installer will return a permission error code to the invoker. Depending on the invoker, the result might be a dialog box asking the user for elevated permissions, or it might simply be a permission denied error.</source>
          <target state="translated">Windows에서 GHC는 일반적으로 바이너리를 연결할 때 매니페스트 파일을 생성합니다. 매니페스트는 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; 파일에 있습니다. 여기서 ⟨prog.exe⟩는 실행 파일의 이름입니다. 매니페스트 파일은 현재 한 가지 용도로만 사용됩니다. Windows Vista에서 특정 이름 (예 : &quot;설치&quot;, &quot;설정&quot;또는 &quot;패치&quot;가 포함 된 이름)을 가진 실행 파일에 대한 권한을 상승시키려는 &quot;설치 프로그램 검색&quot;을 비활성화합니다. 설치 프로그램 검색을 해제하는 매니페스트 파일이없는 경우 Windows에서 설치 프로그램으로 간주하는 실행 파일을 실행하려고하면 호출자에게 권한 오류 코드가 반환됩니다. 호출자에 따라 결과는 사용자에게 상승 된 권한을 요청하는 대화 상자이거나 단순히 권한 거부 오류 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df3c28898ffda6729df899cf284892444c82605a" translate="yes" xml:space="preserve">
          <source>On Windows, GHC normally generates a manifestmanifest file when linking a binary. The manifest is placed in the file &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; where ⟨prog.exe⟩ is the name of the executable. The manifest file currently serves just one purpose: it disables the &amp;ldquo;installer detection&amp;rdquo; in Windows Vista that attempts to elevate privileges for executables with certain names (e.g. names containing &amp;ldquo;install&amp;rdquo;, &amp;ldquo;setup&amp;rdquo; or &amp;ldquo;patch&amp;rdquo;). Without the manifest file to turn off installer detection, attempting to run an executable that Windows deems to be an installer will return a permission error code to the invoker. Depending on the invoker, the result might be a dialog box asking the user for elevated permissions, or it might simply be a permission denied error.</source>
          <target state="translated">Windows에서 GHC는 일반적으로 바이너리를 연결할 때 manifestmanifest 파일을 생성합니다. 매니페스트는 파일 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; 위치합니다. 여기서 ⟨prog.exe⟩는 실행 파일의 이름입니다. 매니페스트 파일은 현재 한 가지 목적으로 만 사용됩니다. Windows Vista에서는 특정 이름 (예 : &quot;install&quot;, &quot;setup&quot;또는 &quot;patch&quot;가 포함 된 이름)을 가진 실행 파일에 대한 권한을 높이려고하는 &quot;설치 프로그램 검색&quot;을 비활성화합니다. 설치 프로그램 검색을 해제 할 매니페스트 파일이 없으면 Windows가 설치 프로그램 인 것으로 간주되는 실행 파일을 실행하려고하면 호출자에게 권한 오류 코드가 반환됩니다. 호출자에 따라 결과에 상승 된 권한을 요청하는 대화 상자가 표시되거나 권한 거부 오류 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3857f1cd71ad0bc38aa45f3e4c0b66be30d8d39f" translate="yes" xml:space="preserve">
          <source>On Windows, from [1]: &quot;If a file name begins with only a disk designator but not the backslash after the colon, it is interpreted as a relative path to the current directory on the drive with the specified letter.&quot; The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">Windows의 경우 [1] : &quot;파일 이름이 디스크 지정 자로 만 시작하지만 콜론 뒤의 백 슬래시가 아닌 경우 지정된 문자를 사용하여 드라이브의 현재 디렉토리에 대한 상대 경로로 해석됩니다.&quot; &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 현재 동작은 이러한 형식을 결합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00fab97cf532bb811e9f99b70b73e208825c5f0f" translate="yes" xml:space="preserve">
          <source>On Windows, from [1]: &quot;If a file name begins with only a disk designator but not the backslash after the colon, it is interpreted as a relative path to the current directory on the drive with the specified letter.&quot; The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">Windows의 경우 [1] : &quot;파일 이름이 디스크 지정 자로 만 시작하지만 콜론 뒤의 백 슬래시가 아닌 경우 지정된 문자를 사용하여 드라이브의 현재 디렉토리에 대한 상대 경로로 해석됩니다.&quot; &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 현재 동작은 이러한 형식을 결합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a1fc027f89a30d75d09af18559914b65d210c7f" translate="yes" xml:space="preserve">
          <source>On Windows, if a filepath starts with a single slash, it is relative to the root of the current drive. In [1], this is (confusingly) referred to as an absolute path. The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">Windows에서 파일 경로가 단일 슬래시로 시작하는 경우 현재 드라이브의 루트에 상대적입니다. [1]에서 이것은 (혼란스럽게) 절대 경로라고합니다. &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 현재 동작은 이러한 형식을 결합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c91c78ad4fae4d53474ef709fdcd0ed43c7ee0a9" translate="yes" xml:space="preserve">
          <source>On Windows, if a filepath starts with a single slash, it is relative to the root of the current drive. In [1], this is (confusingly) referred to as an absolute path. The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">Windows에서 파일 경로가 단일 슬래시로 시작하는 경우 현재 드라이브의 루트에 상대적입니다. [1]에서 이것은 (혼란스럽게) 절대 경로라고합니다. &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 현재 동작은 이러한 형식을 결합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4d3e5aee2864678aaa60dea89f1461abcedaa812" translate="yes" xml:space="preserve">
          <source>On Windows, it behaves like the Win32 function &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363851.aspx&quot;&gt;CopyFile&lt;/a&gt;, which copies various kinds of metadata including file attributes and security resource properties.</source>
          <target state="translated">Windows에서는 파일 특성 및 보안 자원 특성을 포함하여 다양한 메타 데이터를 복사 하는 Win32 함수 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363851.aspx&quot;&gt;CopyFile&lt;/a&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="abd019f889227ae682d9d79f35737ff6a44be1e1" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; permission corresponds to the &quot;read-only&quot; attribute. The &lt;code&gt;&lt;a href=&quot;system-directory#v:executable&quot;&gt;executable&lt;/a&gt;&lt;/code&gt; permission is set if the file extension is of an executable file type. The &lt;code&gt;&lt;a href=&quot;system-directory#v:readable&quot;&gt;readable&lt;/a&gt;&lt;/code&gt; permission is always set.</source>
          <target state="translated">Windows에서 &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; 권한은 &quot;읽기 전용&quot;속성에 해당합니다. &lt;code&gt;&lt;a href=&quot;system-directory#v:executable&quot;&gt;executable&lt;/a&gt;&lt;/code&gt; 파일 확장명이 실행 파일 형식 인 경우 권한이 설정됩니다. &lt;code&gt;&lt;a href=&quot;system-directory#v:readable&quot;&gt;readable&lt;/a&gt;&lt;/code&gt; 권한이 항상 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a82573349a58df428e5cf8f04f5449302de59c8f" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;^Z&lt;/code&gt; character is interpreted as an end-of-file character, so if you read a file containing this character the file will appear to end just before it. To avoid this, use &lt;code&gt;IOExts.openFileEx&lt;/code&gt; to open a file in binary (untranslated) mode or change an already opened file handle into binary mode using &lt;code&gt;IOExts.hSetBinaryMode&lt;/code&gt;. The &lt;code&gt;IOExts&lt;/code&gt; module is part of the &lt;code&gt;lang&lt;/code&gt; package.</source>
          <target state="translated">Windows에서 &lt;code&gt;^Z&lt;/code&gt; 문자는 파일 끝 문자로 해석 되므로이 문자가 포함 된 파일을 읽으면 파일이 바로 앞에있는 것으로 나타납니다. 이를 방지하려면 &lt;code&gt;IOExts.openFileEx&lt;/code&gt; 를 사용하여 파일을 2 진 (번역되지 않은) 모드로 열거 나 이미 열린 파일 핸들을 &lt;code&gt;IOExts.hSetBinaryMode&lt;/code&gt; 를 사용하여 2 진 모드로 변경 하십시오 . &lt;code&gt;IOExts&lt;/code&gt; 의 모듈의 일부 &lt;code&gt;lang&lt;/code&gt; 패키지.</target>
        </trans-unit>
        <trans-unit id="f4e0faedb7eb77e9f9303b4aee6bff531c17eba6" translate="yes" xml:space="preserve">
          <source>On Windows, the function is implemented using &lt;code&gt;CreateSymbolicLink&lt;/code&gt; with &lt;code&gt;SYMBOLIC_LINK_FLAG_DIRECTORY&lt;/code&gt;. Since 1.3.3.0, the &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; flag is also included if supported by the operating system. On POSIX, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:createFileLink&quot;&gt;createFileLink&lt;/a&gt;&lt;/code&gt; and is therefore atomic.</source>
          <target state="translated">Windows &lt;code&gt;SYMBOLIC_LINK_FLAG_DIRECTORY&lt;/code&gt; 기능은 SYMBOLIC_LINK_FLAG_DIRECTORY 와 함께 &lt;code&gt;CreateSymbolicLink&lt;/code&gt; 를 사용하여 구현됩니다 . 1.3.3.0부터 운영 체제에서 지원하는 경우 &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; 플래그도 포함됩니다. POSIX에서 이것은 &lt;code&gt;&lt;a href=&quot;system-directory#v:createFileLink&quot;&gt;createFileLink&lt;/a&gt;&lt;/code&gt; 의 별명 이므로 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="a5bae1c687cf11ec3ed5ad2f9f8ff005ae0b6dfc" translate="yes" xml:space="preserve">
          <source>On Windows, the function is implemented using &lt;code&gt;CreateSymbolicLink&lt;/code&gt;. Since 1.3.3.0, the &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; flag is included if supported by the operating system. On POSIX, the function uses &lt;code&gt;symlink&lt;/code&gt; and is therefore atomic.</source>
          <target state="translated">Windows에서 함수는 &lt;code&gt;CreateSymbolicLink&lt;/code&gt; 를 사용하여 구현됩니다 . 1.3.3.0부터 운영 체제에서 지원하는 경우 &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; 플래그가 포함됩니다. POSIX에서 함수는 &lt;code&gt;symlink&lt;/code&gt; 를 사용 하므로 원자 적입니다.</target>
        </trans-unit>
        <trans-unit id="e855d866abccd89156106ea9ff5c5937f3c49ead" translate="yes" xml:space="preserve">
          <source>On Windows, the operation fails if &lt;em&gt;dir&lt;/em&gt; is a directory symbolic link.</source>
          <target state="translated">Windows에서 &lt;em&gt;dir&lt;/em&gt; 이 디렉토리 기호 링크 인 경우 조작이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="e44cd211b73577bb580283a31fe9e11ec9d0f8fb" translate="yes" xml:space="preserve">
          <source>On Windows, the path is &lt;code&gt;%APPDATA%/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt;)</source>
          <target state="translated">Windows에서 경로는 &lt;code&gt;%APPDATA%/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f11f1f05f568d29a8830243c65984fa477970a3c" translate="yes" xml:space="preserve">
          <source>On Windows, the system is queried for a suitable path; a typical path might be &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 시스템은 적절한 경로를 조회합니다. 일반적인 경로는 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d3e77adec84060bc903e2e912e15d0de80cff520" translate="yes" xml:space="preserve">
          <source>On Windows, there&amp;rsquo;s a GNU ld/BFD bug whereby it emits bogus PE object files that have more than 0xffff relocations. When GHCi tries to load a package affected by this bug, you get an error message of the form</source>
          <target state="translated">Windows에는 GNU ld / BFD 버그가있어 0xffff 재배치 이상의 가짜 PE 개체 파일을 생성합니다. GHCi가이 버그의 영향을받는 패키지를로드하려고하면 다음과 같은 형식의 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="85e22f23309dbf90a94129f8db64b297cbb2f916" translate="yes" xml:space="preserve">
          <source>On Windows, this &lt;em&gt;only returns the first ocurrence&lt;/em&gt;, if any. Its behavior is therefore equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;em&gt;첫 번째 발생 만 리턴합니다 (있는&lt;/em&gt; 경우). 따라서 동작은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="da36f078a8e10da6023ea1ab8024e74f1183e975" translate="yes" xml:space="preserve">
          <source>On Windows, this checks for &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt;. In addition to symbolic links, the function also returns true on junction points. On POSIX systems, this checks for &lt;code&gt;S_IFLNK&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; 를 확인합니다 . 심볼릭 링크 외에도이 함수는 접합점에서 true를 반환합니다. POSIX 시스템에서는 &lt;code&gt;S_IFLNK&lt;/code&gt; 를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="52cfb4329fc32c0d833a61183ba7721cc4129515" translate="yes" xml:space="preserve">
          <source>On Windows, this copies only the read-only attribute.</source>
          <target state="translated">Windows에서는 읽기 전용 속성 만 복사합니다.</target>
        </trans-unit>
        <trans-unit id="ed105f70828ccfdebad6090636cb8dc84666d5c9" translate="yes" xml:space="preserve">
          <source>On Windows, this encoding *should not* be used if possible because the use of code pages is deprecated: Strings should be retrieved via the &quot;wide&quot; W-family of UTF-16 APIs instead</source>
          <target state="translated">Windows에서는 코드 페이지 사용이 더 이상 사용되지 않으므로 가능한 경우이 인코딩을 사용해서는 안됩니다 * : 대신 &quot;와이드&quot;W 계열 UTF-16 API를 통해 문자열을 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac2cd505b24931f86258fdc4d09b1d6d6f31c478" translate="yes" xml:space="preserve">
          <source>On Windows, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectory&quot;&gt;removeDirectory&lt;/a&gt;&lt;/code&gt;. On POSIX systems, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 이는 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectory&quot;&gt;removeDirectory&lt;/a&gt;&lt;/code&gt; 의 별명입니다 . POSIX 시스템에서 이는 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="721f4605ef1d86ca2dde42c37a045d3e3a154879" translate="yes" xml:space="preserve">
          <source>On Windows, this is only capable of changing the &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; permission, which corresponds to the &quot;read-only&quot; attribute. Changing the other permissions has no effect.</source>
          <target state="translated">Windows에서는 &quot;읽기 전용&quot;속성에 해당하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; 권한 만 변경할 수 있습니다. 다른 권한을 변경해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b5fedbf70c277d93381f0f283d73b921d80d6e3" translate="yes" xml:space="preserve">
          <source>On Windows, you can access supported code pages with the prefix &lt;code&gt;CP&lt;/code&gt;; for example, &lt;code&gt;&quot;CP1250&quot;&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;code&gt;CP&lt;/code&gt; 접두어를 사용하여 지원되는 코드 페이지에 액세스 할 수 있습니다 . 예를 들어 &lt;code&gt;&quot;CP1250&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcbabe85dcb1f0f6be8be76732501ee39274fba1" translate="yes" xml:space="preserve">
          <source>On a 64-bit platform it is not always possible to acquire the top 64 bits of the result. Therefore, a recommended implementation is to take the absolute value of both operands, and return 0 iff bits[63:31] of them are zero, since that means that their magnitudes fit within 31 bits, so the magnitude of the product must fit into 62 bits.</source>
          <target state="translated">64 비트 플랫폼에서 결과의 상위 64 비트를 항상 획득 할 수있는 것은 아닙니다. 따라서 권장되는 구현은 두 피연산자의 절대 값을 가져오고 0 iff 비트 [63:31]를 0으로 리턴하는 것입니다. 즉, 크기가 31 비트 내에 들어가므로 제품의 크기가 62 비트</target>
        </trans-unit>
        <trans-unit id="ca55a4a165c97ee87021e748a5999af653eb1351" translate="yes" xml:space="preserve">
          <source>On a Core2 Duo 2.20GHz on a 32-bit Linux, the above code takes 1ms to generate the 22'500 bytes long lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Looking again at the definitions above, we see that we took care to avoid intermediate data structures, as otherwise we would sacrifice performance. For example, the following (arguably simpler) definition of &lt;code&gt;renderRow&lt;/code&gt; is about 20% slower.</source>
          <target state="translated">32 비트 Linux의 Core2 Duo 2.20GHz에서 위의 코드는 22'500 바이트 길이의 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성하는 데 1ms가 걸립니다 . 위의 정의를 다시 살펴보면 중간 데이터 구조를 피하기 위해주의를 기울였습니다. 그렇지 않으면 성능이 저하됩니다. 예를 들어, 다음의 &lt;code&gt;renderRow&lt;/code&gt; 정의는 20 % 정도 느립니다.</target>
        </trans-unit>
        <trans-unit id="c8a5a9af1eb8c360fd6ffff320585505f281c939" translate="yes" xml:space="preserve">
          <source>On both reading and writing, the platform's native newline conversion is performed.</source>
          <target state="translated">읽기와 쓰기 모두에서 플랫폼의 기본 개행 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="584fe990b6c406c5750b476c119e0a10d54a8c7d" translate="yes" xml:space="preserve">
          <source>On most UNIX platforms it is also possible to build executables that can be &lt;code&gt;dlopen&lt;/code&gt;&amp;lsquo;d like shared libraries using the &lt;a href=&quot;phases#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt; flag during linking.</source>
          <target state="translated">대부분의 UNIX 플랫폼에서는 링크하는 동안 &lt;a href=&quot;phases#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 공유 라이브러리처럼 &lt;code&gt;dlopen&lt;/code&gt; 할 수있는 실행 파일을 빌드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43e3fc1e854dceae3b55c658433a092145204e78" translate="yes" xml:space="preserve">
          <source>On most UNIX platforms it is also possible to build executables that can be &lt;code&gt;dlopen&lt;/code&gt;&amp;rsquo;d like shared libraries using the &lt;a href=&quot;phases#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt; flag during linking.</source>
          <target state="translated">대부분의 UNIX 플랫폼에서는 링크 중에 &lt;a href=&quot;phases#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 공유 라이브러리와 같은 &lt;code&gt;dlopen&lt;/code&gt; 이 될 수있는 실행 파일을 빌드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e3ecb7f7003c5f8586cd3273747fd5240fdd03f" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, the behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; using the search directories from the &lt;code&gt;PATH&lt;/code&gt; environment variable. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows 이외의 플랫폼에서 동작은 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 의 검색 디렉토리를 사용하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 의 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fb6c020bc093fa27959e91b43bb2cec678d112f" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, the behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the search directories from the &lt;code&gt;PATH&lt;/code&gt; environment variable and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows 이외의 플랫폼에서 동작은 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 의 검색 디렉토리를 사용하고 각 파일에서 실행 권한을 테스트 하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 와 같습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8188af56fd6edcf23beb2e9dcf2382a4e4902ffd" translate="yes" xml:space="preserve">
          <source>On program termination, the standard &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; are flushed automatically; any other buffered &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s need to be flushed manually, otherwise the buffered data will be discarded.</source>
          <target state="translated">프로그램 종료시 표준 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; s &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 가 자동으로 플러시됩니다. 버퍼링 된 다른 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 수동으로 플러시해야합니다. 그렇지 않으면 버퍼링 된 데이터가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b458bc64e60c4d81db682d145a7fc32242bb3944" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">일부 호스트 (예 : SuSe 및 Ubuntu Linux) 에서 매크로 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; 를 설정하지 않으면 &lt;code&gt;RTLD_NEXT&lt;/code&gt; (및 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; )가 표시되지 않습니다 . 이 매크로를 정의하고 싶지 않기 때문에 &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 플래그 가 사용 가능한지 확인할 수 있습니다. 이상적으로는 &lt;code&gt;#ifdef&lt;/code&gt; 만큼 효율적으로 컴파일러에 의해 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe7652641a4b092db3389c67281410748d6204c1" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">일부 호스트 (예 : SuSe 및 Ubuntu Linux) 에서 매크로 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; 를 설정하지 않으면 &lt;code&gt;RTLD_NEXT&lt;/code&gt; (및 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; )가 표시되지 않습니다 . 이 매크로를 정의하고 싶지 않기 때문에 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 플래그 가 사용 가능한지 확인할 수 있습니다. 이상적으로는 &lt;code&gt;#ifdef&lt;/code&gt; 만큼 효율적으로 컴파일러에 의해 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c440936ef0fa8d5c9fb4a5252385fb1aecb976b4" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">일부 호스트 (예 : SuSe 및 Ubuntu Linux) 에서 매크로 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; 를 설정하지 않으면 &lt;code&gt;RTLD_NEXT&lt;/code&gt; (및 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; )가 표시되지 않습니다 . 이 매크로를 정의하고 싶지 않기 때문에 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 플래그 가 사용 가능한지 확인할 수 있습니다. 이상적으로는 &lt;code&gt;#ifdef&lt;/code&gt; 만큼 효율적으로 컴파일러에 의해 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="15cb1a56421815ce54b1980f31648be5dff8f144" translate="yes" xml:space="preserve">
          <source>On some platforms GHC supports building Haskell code into shared libraries. Shared libraries are also sometimes known as dynamic libraries, in particular on Windows they are referred to as dynamic link libraries (DLLs).</source>
          <target state="translated">일부 플랫폼에서 GHC는 공유 라이브러리에 Haskell 코드 작성을 지원합니다. 공유 라이브러리는 동적 라이브러리라고도하며, 특히 Windows에서는 동적 링크 라이브러리 (DLL)라고합니다.</target>
        </trans-unit>
        <trans-unit id="0d36502b7263f0b4485c96cc36bc155187135ea3" translate="yes" xml:space="preserve">
          <source>On some platforms where PIC is always the case, e.g. x86_64 MacOS X, this flag is enabled by default.</source>
          <target state="translated">PIC가 항상 적용되는 일부 플랫폼 (예 : x86_64 MacOS X)에서는이 플래그가 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="8eb8ce4db21a6bb265eeec2e7b65240ba8199bdd" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;.dll&lt;/code&gt;-style shared libraries, the actual library loaded will be &lt;code&gt;lib.dll&lt;/code&gt;, &lt;code&gt;liblib.dll&lt;/code&gt;. GHCi also has full support for import libraries, either Microsoft style &lt;code&gt;.lib&lt;/code&gt;, or GNU GCC style &lt;code&gt;.a&lt;/code&gt; and &lt;code&gt;.dll.a&lt;/code&gt; libraries. If you have an import library it is advisable to always specify the import libary instead of the &lt;code&gt;.dll&lt;/code&gt;. e.g. use &lt;code&gt;-lgcc` instead of
``-llibgcc_s_seh-1&lt;/code&gt;. Again, GHCi will signal an error if it can&amp;rsquo;t find the library.</source>
          <target state="translated">&lt;code&gt;.dll&lt;/code&gt; 스타일 공유 라이브러리가있는 시스템에서 로드 된 실제 라이브러리는 &lt;code&gt;lib.dll&lt;/code&gt; , &lt;code&gt;liblib.dll&lt;/code&gt; 입니다. GHCi는 또한 가져 오기 라이브러리 (Microsoft 스타일 &lt;code&gt;.lib&lt;/code&gt; 또는 GNU GCC 스타일 &lt;code&gt;.a&lt;/code&gt; 및 &lt;code&gt;.dll.a&lt;/code&gt; 라이브러리) 를 완벽하게 지원합니다 . 가져 오기 라이브러리가있는 경우 항상 &lt;code&gt;.dll&lt;/code&gt; 대신 가져 오기 라이브러리를 지정하는 것이 좋습니다 . 예를 들어 &lt;code&gt;-lgcc` instead of ``-llibgcc_s_seh-1&lt;/code&gt; 사용 하십시오 . 다시 말하지만, GHCi는 라이브러리를 찾을 수 없으면 오류를 알립니다.</target>
        </trans-unit>
        <trans-unit id="79878901a3ff26ad9bef6e39ce6be8f5fbd886f1" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;.so&lt;/code&gt;-style shared libraries, the actual library loaded will the &lt;code&gt;liblib.so&lt;/code&gt;. GHCi searches the following places for libraries, in this order:</source>
          <target state="translated">&lt;code&gt;.so&lt;/code&gt; 스타일 공유 라이브러리가있는 시스템에서 로드 된 실제 라이브러리는 &lt;code&gt;liblib.so&lt;/code&gt; 입니다. GHCi는 다음 위치에서 라이브러리를 순서대로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="0fdf7f76740d047b5e3edd87cc87a6a11d2158f4" translate="yes" xml:space="preserve">
          <source>On the World-Wide Web, there are several URLs of likely interest:</source>
          <target state="translated">월드 와이드 웹에는 다음과 같은 몇 가지 URL이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05a6ef32800b6777916856b927d4f8bd9b77ba3" translate="yes" xml:space="preserve">
          <source>On the left or right (see &lt;code&gt;f4&lt;/code&gt;, for example) of a function arrow</source>
          <target state="translated">기능 화살표 의 왼쪽 또는 오른쪽 ( 예 : &lt;code&gt;f4&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="4f305cc5e3cb7028da9ff3cbac52003a8cb62b20" translate="yes" xml:space="preserve">
          <source>On the other hand, a derived &lt;code&gt;Functor&lt;/code&gt; instances for the &lt;code&gt;CovFun&lt;/code&gt;s are within the realm of possibility:</source>
          <target state="translated">반면 &lt;code&gt;CovFun&lt;/code&gt; 의 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스 는 가능한 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0c7bdbeeec14950364d5eba585fee5f46490af7" translate="yes" xml:space="preserve">
          <source>On the other hand, function &lt;code&gt;g&lt;/code&gt; works fine, because matching against &lt;code&gt;P2&lt;/code&gt; (which wraps the GADT &lt;code&gt;S&lt;/code&gt;) provides the local equality &lt;code&gt;(a~Bool)&lt;/code&gt;. If you were to give an explicit pattern signature &lt;code&gt;P2 :: Bool -&amp;gt; S Bool&lt;/code&gt;, then &lt;code&gt;P2&lt;/code&gt; would become less polymorphic, and would behave exactly like &lt;code&gt;P1&lt;/code&gt; so that &lt;code&gt;g&lt;/code&gt; would then be rejected.</source>
          <target state="translated">반면 &lt;code&gt;P2&lt;/code&gt; (GADT &lt;code&gt;S&lt;/code&gt; 를 감싸는 )에 대한 일치는 로컬 평등 &lt;code&gt;(a~Bool)&lt;/code&gt; 제공 하기 때문에 함수 &lt;code&gt;g&lt;/code&gt; 는 제대로 작동합니다 . 명시 적 패턴 시그니처 &lt;code&gt;P2 :: Bool -&amp;gt; S Bool&lt;/code&gt; 을 제공하면 &lt;code&gt;P2&lt;/code&gt; 가 덜 다형성이되고 &lt;code&gt;P1&lt;/code&gt; 과 똑같이 동작 하여 &lt;code&gt;g&lt;/code&gt; 가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="1c549059d60fda45dc8528cd8c34dd2387420acc" translate="yes" xml:space="preserve">
          <source>On the other hand, type families are exempt from this rule:</source>
          <target state="translated">반면에 유형 계열은이 규칙에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="42d363a29721400db631067ea9cb7bd7ce4d4eea" translate="yes" xml:space="preserve">
          <source>On this score, GHC usually does pretty well, especially if you &amp;ldquo;allow&amp;rdquo; it to be off by one or two. In the case of an instance or class declaration, the line number may only point you to the declaration, not to a specific method.</source>
          <target state="translated">이 점수에서 GHC는 일반적으로 아주 잘 작동합니다. 특히 한두 가지씩&amp;ldquo;허용&amp;rdquo;할 경우 더욱 그렇습니다. 인스턴스 또는 클래스 선언의 경우 행 번호는 특정 메소드가 아니라 선언만을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ea755dd39d492e55b9e34b0a111d2cfb8276cb3" translate="yes" xml:space="preserve">
          <source>On transcoding errors, an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; exception is thrown. You can use the API in &lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding&lt;/a&gt; if you need more control over error handling or transcoding.</source>
          <target state="translated">트랜스 코딩 오류에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 예외가 발생합니다. 오류 처리 또는 코드 변환에 대한 추가 제어가 필요한 경우 &lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding&lt;/a&gt; 에서 API를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56b1aac7c401101a39c4f55a428919092262060c" translate="yes" xml:space="preserve">
          <source>OnDecodeError</source>
          <target state="translated">OnDecodeError</target>
        </trans-unit>
        <trans-unit id="6f666943e43935b64269246162dcf5a1465ea5ff" translate="yes" xml:space="preserve">
          <source>OnEncodeError</source>
          <target state="translated">OnEncodeError</target>
        </trans-unit>
        <trans-unit id="1ec9c77019b9c571c284d11d62850d0be7f7d725" translate="yes" xml:space="preserve">
          <source>OnError</source>
          <target state="translated">OnError</target>
        </trans-unit>
        <trans-unit id="ed0ab25823975d83734fae1b6bd16e05190469eb" translate="yes" xml:space="preserve">
          <source>Once EOF is encountered, the Handle is closed.</source>
          <target state="translated">EOF가 발생하면 핸들이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="60e264a17495d5948da3fde8b611b62bef7e4a18" translate="yes" xml:space="preserve">
          <source>Once a semi-closed handle becomes closed, the contents of the associated list becomes fixed. The contents of this final list is only partially specified: it will contain at least all the items of the stream that were evaluated prior to the handle becoming closed.</source>
          <target state="translated">반 닫힌 핸들이 닫히면 관련 목록의 내용이 고정됩니다. 이 최종 목록의 내용은 부분적으로 만 지정됩니다. 핸들이 닫히기 전에 평가 된 스트림의 모든 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6cef81242bdb3dd15794848f47ffe89e35f13fea" translate="yes" xml:space="preserve">
          <source>Once again, the profiling facilities (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;) are the basic tool for demystifying the space behaviour of your program.</source>
          <target state="translated">다시 한 번, 프로파일 링 기능 ( &lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링&lt;/a&gt; )은 프로그램의 공간 동작을 이해하기위한 기본 도구입니다.</target>
        </trans-unit>
        <trans-unit id="315e28f14a5749001346c76c600fc06cf79ac069" translate="yes" xml:space="preserve">
          <source>Once the user declares type family to be injective GHC must verify that this declaration is correct, i.e., that type family equations don&amp;rsquo;t violate the injectivity annotation. A general idea is that if at least one equation (bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and (5) below) violates the injectivity annotation then a type family is not injective in a way the user claims and an error is reported. In the bullets below &lt;em&gt;RHS&lt;/em&gt; refers to the right-hand side of the type family equation being checked for injectivity. &lt;em&gt;LHS&lt;/em&gt; refers to the arguments of that type family equation. Below are the rules followed when checking injectivity of a type family:</source>
          <target state="translated">사용자가 타입 패밀리를 주입 형으로 선언하면 GHC는이 선언이 올바른지 확인해야합니다. 즉, 타입 패밀리 방정식이 주입 형 주석을 위반하지 않는지 확인해야합니다. 일반적인 아이디어는 적어도 하나의 방정식 (아래 글 머리 기호 (1), (2) 및 (3)) 또는 한 쌍의 방정식 (아래 글 머리 기호 (4) 및 (5))이 주 입성 주석을 위반하는 경우 유형 패밀리는 다음과 같습니다. 사용자가 주장하는 방식으로 주입되지 않고 오류가보고됩니다. 아래 글 머리 기호에서 &lt;em&gt;RHS&lt;/em&gt; 는 주 입성을 확인하는 유형 패밀리 방정식의 오른쪽을 나타냅니다. &lt;em&gt;LHS&lt;/em&gt; 는 해당 유형 패밀리 방정식의 인수를 나타냅니다. 다음은 유형 패밀리의 주 입성을 확인할 때 따르는 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="ffc00d55d5cade6b9732f3047fd68f9150e53462" translate="yes" xml:space="preserve">
          <source>Once the user declares type family to be injective GHC must verify that this declaration is correct, ie. type family equations don&amp;rsquo;t violate the injectivity annotation. A general idea is that if at least one equation (bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and (5) below) violates the injectivity annotation then a type family is not injective in a way user claims and an error is reported. In the bullets below &lt;em&gt;RHS&lt;/em&gt; refers to the right-hand side of the type family equation being checked for injectivity. &lt;em&gt;LHS&lt;/em&gt; refers to the arguments of that type family equation. Below are the rules followed when checking injectivity of a type family:</source>
          <target state="translated">사용자가 타입 패밀리를 인젝 티브로 선언하면 GHC는이 선언이 올바른지 확인해야합니다. 타입 패밀리 방정식은 주입 주석을 위반하지 않습니다. 일반적인 아이디어는 적어도 하나의 방정식 (아래의 (1), (2) 및 (3)) 또는 한 쌍의 방정식 (아래의 (4) 및 (5))이 주입 주석을 위반하면 유형 군이 사용자가 주장하는 방식으로 주입하지 않고 오류가보고됩니다. 아래의 글 머리 기호에서 &lt;em&gt;RHS&lt;/em&gt; 는 주사율을 검사 할 유형 패밀리 방정식의 오른쪽을 나타냅니다. &lt;em&gt;LHS&lt;/em&gt; 는 해당 유형 패밀리 방정식의 인수를 나타냅니다. 다음은 유형 군의 주사율을 확인할 때 따라야 할 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="c50b67bca5fb4c6603a23fdfb82c3d73e171c099" translate="yes" xml:space="preserve">
          <source>Once you have a library of GHCi macros, you may want to source them from separate files, or you may want to source your &lt;code&gt;.ghci&lt;/code&gt; file into your running GHCi session while debugging it</source>
          <target state="translated">GHCi 매크로 라이브러리가 있으면 별도의 파일에서 소스를 제공하거나 디버깅하는 동안 실행중인 GHCi 세션에 &lt;code&gt;.ghci&lt;/code&gt; 파일 을 소스로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e7e950f611ffeefb5dc8da946a455d9ce68ff45" translate="yes" xml:space="preserve">
          <source>Once you know the producer or the type of the heap in the drag or void states, the next step is usually to find the retainer(s):</source>
          <target state="translated">드래그 또는 빈 상태에서 생산자 또는 힙 유형을 알면 다음 단계는 일반적으로 리테이너를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="68e926d9c748359a8152a413a626288e329b3079" translate="yes" xml:space="preserve">
          <source>One can then use functions from &lt;code&gt;GHC.Stack&lt;/code&gt; to inspect or pretty print (as is done in &lt;code&gt;f&lt;/code&gt; below) the call stack.</source>
          <target state="translated">그런 다음 &lt;code&gt;GHC.Stack&lt;/code&gt; 의 기능을 사용 하여 호출 스택 을 검사하거나 인쇄 할 수 있습니다 ( 아래 &lt;code&gt;f&lt;/code&gt; 에서 수행됨 ).</target>
        </trans-unit>
        <trans-unit id="4023758f19beece83257d349668ba73b4a5f55d3" translate="yes" xml:space="preserve">
          <source>One can think of this instance being implemented with the same code as the &lt;code&gt;Num Int&lt;/code&gt; instance, but with &lt;code&gt;Dollars&lt;/code&gt; and &lt;code&gt;getDollars&lt;/code&gt; added wherever necessary in order to make it typecheck. (In practice, GHC uses a somewhat different approach to code generation. See the &lt;a href=&quot;#precise-gnd-specification&quot;&gt;A more precise specification&lt;/a&gt; section below for more details.)</source>
          <target state="translated">이 인스턴스가 &lt;code&gt;Num Int&lt;/code&gt; 인스턴스 와 동일한 코드로 구현되었다고 생각할 수 있지만 , &lt;code&gt;getDollars&lt;/code&gt; 를 위해 필요한 곳에 &lt;code&gt;Dollars&lt;/code&gt; 와 getDollars가 추가되었습니다. (실제로 GHC는 약간 다른 코드 생성 방식을 사용합니다. 자세한 내용은 아래 &lt;a href=&quot;#precise-gnd-specification&quot;&gt;의 더 정확한 사양&lt;/a&gt; 섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="9743b7636df84ead47845f240cbbd477f19f70e0" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; to avoid pattern matching when combined with a function that (safely) works on lists:</source>
          <target state="translated">리스트에서 (안전하게) 작동하는 함수와 결합 될 때 패턴 일치를 피하기 위해 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ec55bf61d8ab5d04d04ebcb2ee2159a392ea14e" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; to avoid pattern matching when combined with a function that (safely) works on lists:</source>
          <target state="translated">리스트에서 (안전하게) 작동하는 함수와 결합 될 때 패턴 일치를 피하기 위해 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3d9ffa5463e1c26285c5e33a8e8a9504fd92ef8" translate="yes" xml:space="preserve">
          <source>One can write data types with no constructors using the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;-XEmptyDataDecls&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), which is on by default in Haskell 2010. What is not on by default is the ability to derive type class instances for these types. This ability is enabled through use of the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag. For instance, this lets one write:</source>
          <target state="translated">Haskell 2010에서는 기본적으로 켜져 있는 &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;-XEmptyDataDecls&lt;/code&gt; &lt;/a&gt; 플래그 ( &lt;a href=&quot;#nullary-types&quot;&gt;생성자가없는 데이터 유형&lt;/a&gt; 참조)를 사용하여 생성자가없는 데이터 유형을 작성할 수 있습니다 . 기본적으로 설정되지 않은 것은 이러한 유형에 대한 유형 클래스 인스턴스를 파생시키는 기능입니다. 이 기능은 &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 사용 가능합니다 . 예를 들어 다음과 같이 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7322eb1a388043bfc4b465ffeaf47b177b19e690" translate="yes" xml:space="preserve">
          <source>One can write data types with no constructors using the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), which is on by default in Haskell 2010. What is not on by default is the ability to derive type class instances for these types. This ability is enabled through use of the &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag. For instance, this lets one write:</source>
          <target state="translated">Haskell 2010에서 기본적으로 설정되어 있는 &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt; 플래그 ( &lt;a href=&quot;#nullary-types&quot;&gt;생성자가없는 데이터 형식&lt;/a&gt; 참조)를 사용하여 생성자가없는 데이터 형식을 작성할 수 있습니다 . 기본적으로 설정되지 않은 것은 이러한 형식에 대한 형식 클래스 인스턴스를 파생하는 기능입니다. 이 기능은 &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 활성화됩니다 . 예를 들어 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d496c6b9647ae6150efda24096b39fcf9eb1a86" translate="yes" xml:space="preserve">
          <source>One consequence of the way that GHCi follows dependencies to find modules to load is that every module must have a source file. The only exception to the rule is modules that come from a package, including the &lt;code&gt;Prelude&lt;/code&gt; and standard libraries such as &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt;. If you attempt to load a module for which GHCi can&amp;rsquo;t find a source file, even if there are object and interface files for the module, you&amp;rsquo;ll get an error message.</source>
          <target state="translated">GHCi가로드 할 모듈을 찾기 위해 종속성을 따르는 방식의 한 가지 결과는 모든 모듈에 소스 파일이 있어야한다는 것입니다. 규칙의 유일한 예외는 &lt;code&gt;Prelude&lt;/code&gt; 및 &lt;code&gt;IO&lt;/code&gt; 및 &lt;code&gt;Complex&lt;/code&gt; 와 같은 표준 라이브러리를 포함하여 패키지에서 제공되는 모듈입니다 . GHCi가 소스 파일을 찾을 수없는 모듈을로드하려고하면 모듈에 대한 객체 및 인터페이스 파일이 있어도 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5483c77e4f829cc17d6601c4ac4404068ce5302b" translate="yes" xml:space="preserve">
          <source>One could either pick the &lt;code&gt;DeriveAnyClass&lt;/code&gt; approach to deriving &lt;code&gt;C&lt;/code&gt; or the &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; approach to deriving &lt;code&gt;C&lt;/code&gt;, both of which would be equally as valid. GHC defaults to favoring &lt;code&gt;DeriveAnyClass&lt;/code&gt; in such a dispute, but this is not a satisfying solution, since that leaves users unable to use both language extensions in a single module.</source>
          <target state="translated">하나는 중 하나를 선택할 수 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 의 유도에 접근 &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 의 유도에 접근 &lt;code&gt;C&lt;/code&gt; 를 동등하게 유효한 것으로 될 것이다 둘을. GHC는 기본적으로 이러한 분쟁에서 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 를 선호 하지만 사용자가 단일 모듈에서 두 가지 언어 확장을 사용할 수 없기 때문에 만족스러운 해결책이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="07da619a058ee72f68e35cbedda9fed2d2008eeb" translate="yes" xml:space="preserve">
          <source>One day in &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; 에서 하루 .</target>
        </trans-unit>
        <trans-unit id="3d64ec6630f50a5fa3cc17dae6e273e1017ecb35" translate="yes" xml:space="preserve">
          <source>One equation of a type family instance or closed type family. The arguments are the left-hand-side type and the right-hand-side result.</source>
          <target state="translated">유형 패밀리 인스턴스 또는 닫힌 유형 패밀리의 하나의 방정식. 인수는 왼쪽 유형과 오른쪽 결과입니다.</target>
        </trans-unit>
        <trans-unit id="8ad7e9507f922f5c3971e0839b353cb5b01d4c7f" translate="yes" xml:space="preserve">
          <source>One final note: the &lt;code&gt;aaaa&lt;/code&gt;&lt;code&gt;bbbb&lt;/code&gt; example may not work too well on GHC (see Scheduling, above), due to the locking on a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. Only one thread may hold the lock on a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; at any one time, so if a reschedule happens while a thread is holding the lock, the other thread won't be able to run. The upshot is that the switch from &lt;code&gt;aaaa&lt;/code&gt; to &lt;code&gt;bbbbb&lt;/code&gt; happens infrequently. It can be improved by lowering the reschedule tick period. We also have a patch that causes a reschedule whenever a thread waiting on a lock is woken up, but haven't found it to be useful for anything other than this example :-)</source>
          <target state="translated">마지막 참고 사항 : &lt;code&gt;aaaa&lt;/code&gt; &lt;code&gt;bbbb&lt;/code&gt; 예제는 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 잠금으로 인해 GHC에서 너무 잘 작동하지 않을 수 있습니다 (위의 일정 참조) . 하나 개의 쓰레드가의 잠금 보유 할 수 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 일정 조정이 스레드가 잠금을 보유하는 동안, 다른 스레드를 실행할 수 없습니다 발생 그렇다면, 한 번에. 결론은 &lt;code&gt;aaaa&lt;/code&gt; 에서 &lt;code&gt;bbbbb&lt;/code&gt; 로의 전환이 드물게 발생 한다는 것입니다 . 일정 변경 시간을 줄임으로써 개선 할 수 있습니다. 또한 잠금 대기중인 스레드가 깨어날 때마다 일정을 변경하는 패치가 있지만이 예제 이외의 다른 용도로는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cca5d9a52684589d02fe67865e293c54351f48de" translate="yes" xml:space="preserve">
          <source>One of the motivating examples was the ability to register compiler hooks from a plugin. For example, one might want to modify the way Template Haskell code is executed. This is achievable by updating the &lt;code&gt;hooks&lt;/code&gt; field of the &lt;code&gt;DynFlags&lt;/code&gt; type, recording our custom &amp;ldquo;meta hook&amp;rdquo; in the right place. A simple application of this idea can be seen below:</source>
          <target state="translated">동기를 부여하는 예 중 하나는 플러그인에서 컴파일러 후크를 등록하는 기능이었습니다. 예를 들어 Template Haskell 코드가 실행되는 방식을 수정하고자 할 수 있습니다. 이는 &lt;code&gt;DynFlags&lt;/code&gt; 유형 의 &lt;code&gt;hooks&lt;/code&gt; 필드를 업데이트하여 사용자 정의 &quot;메타 후크&quot;를 올바른 위치에 기록함으로써 가능합니다. 이 아이디어의 간단한 적용은 아래에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ea55d691054154f178c4188946d4c03f7e9c26" translate="yes" xml:space="preserve">
          <source>One of these new quantified constraints can appear anywhere that any other constraint can, not just in instance declarations. Notably, it can appear in a type signature for a value binding, data constructor, or expression. For example</source>
          <target state="translated">이러한 새로운 정량화 된 제약 조건 중 하나는 인스턴스 선언뿐만 아니라 다른 제약 조건이 가능한 모든 위치에 나타날 수 있습니다. 특히 값 바인딩, 데이터 생성자 또는 식에 대한 형식 서명으로 나타날 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="61fc274a467ee7617c4b73c08349e4d3c37da810" translate="yes" xml:space="preserve">
          <source>One or more.</source>
          <target state="translated">하나 이상.</target>
        </trans-unit>
        <trans-unit id="4b9e1cd86b2ee828fde7016484a1c36fb1da2c89" translate="yes" xml:space="preserve">
          <source>One or none.</source>
          <target state="translated">하나도 아니고</target>
        </trans-unit>
        <trans-unit id="2e17f5233f1634abadabdb2fd410bbc1afa1bc70" translate="yes" xml:space="preserve">
          <source>One simplification allowed by combining types and kinds is that the type of &lt;code&gt;Type&lt;/code&gt; is just &lt;code&gt;Type&lt;/code&gt;. It is true that the &lt;code&gt;Type :: Type&lt;/code&gt; axiom can lead to non-termination, but this is not a problem in GHC, as we already have other means of non-terminating programs in both types and expressions. This decision (among many, many others) &lt;em&gt;does&lt;/em&gt; mean that despite the expressiveness of GHC&amp;rsquo;s type system, a &amp;ldquo;proof&amp;rdquo; you write in Haskell is not an irrefutable mathematical proof. GHC promises only partial correctness, that if your programs compile and run to completion, their results indeed have the types assigned. It makes no claim about programs that do not finish in a finite amount of time.</source>
          <target state="translated">유형과 종류를 결합하여 허용되는 한 가지 단순화는 유형의 &lt;code&gt;Type&lt;/code&gt; 이 단지 &lt;code&gt;Type&lt;/code&gt; 입니다. 사실이다 &lt;code&gt;Type :: Type&lt;/code&gt; 공리가 아닌 종료 될 수 있지만, 우리는 이미 형식과 표현 모두 종료되지 않는 프로그램의 다른 수단을 가지고이, GHC에서 문제가되지 않습니다. 이 결정 (많은 다른 많은 것 중에서도) &lt;em&gt;은&lt;/em&gt; GHC 유형 시스템의 표현성에도 불구하고 하스켈에서 작성하는&amp;ldquo;증거&amp;rdquo;는 반박 할 수없는 수학적 증거가 아님을 의미합니다. GHC는 부분적으로 만 정확성을 약속합니다. 프로그램이 컴파일되고 완료되면 결과에 실제로 유형이 지정됩니다. 유한 한 시간 안에 끝나지 않는 프로그램에 대해서는 주장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04e45da5d15f7b84f75303b148b0c58446719a7a" translate="yes" xml:space="preserve">
          <source>One solution would be to represent an occurrence of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; with 'Rec0 Int' instead. With this approach, however, the programmer has no way of knowing whether the &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is actually an &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; in disguise.</source>
          <target state="translated">한 가지 해결책은 대신 'Rec0 Int'를 사용하여 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 의 발생을 나타내는 것입니다. 그러나이 방법을 사용하면 프로그래머는 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가 실제로 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 인지를 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="71086252ab12cdaa049eefe6701cf95f5fcaa5cf" translate="yes" xml:space="preserve">
          <source>One stylistic reason for wanting to write a type signature is simple documentation. Another is that you may want to bring scoped type variables into scope. For example:</source>
          <target state="translated">형식 서명을 작성하려는 스타일 중 하나는 간단한 문서입니다. 또 다른 방법은 범위가 지정된 유형 변수를 범위로 가져올 수 있다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45133c20fc7ccdca10220b7b14632f7d9475ba07" translate="yes" xml:space="preserve">
          <source>One time when &lt;code&gt;Float&lt;/code&gt; might be a good idea is if you have a &lt;em&gt;lot&lt;/em&gt; of them, say a giant array of &lt;code&gt;Float&lt;/code&gt;s. They take up half the space in the heap compared to &lt;code&gt;Doubles&lt;/code&gt;. However, this isn&amp;rsquo;t true on a 64-bit machine.</source>
          <target state="translated">한 시간 &lt;code&gt;Float&lt;/code&gt; 좋은 생각이 될 수도 당신이있는 경우입니다 &lt;em&gt;많은&lt;/em&gt; 이들의를,의 거대한 배열 말 &lt;code&gt;Float&lt;/code&gt; 들. 그들은 &lt;code&gt;Doubles&lt;/code&gt; 에 비해 힙 공간의 절반을 차지합니다 . 그러나 64 비트 시스템에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a12bfceb7507e74d1f52bf5268e41928d787ee56" translate="yes" xml:space="preserve">
          <source>One way out is to define an extended &lt;code&gt;assert&lt;/code&gt; function which also takes a descriptive string to include in the error message and perhaps combine this with the use of a pre-processor which inserts the source location where &lt;code&gt;assert&lt;/code&gt; was used.</source>
          <target state="translated">한 가지 방법 은 오류 메시지에 포함 할 설명 문자열 을 사용하는 확장 된 &lt;code&gt;assert&lt;/code&gt; 함수 를 정의하고 이를 &lt;code&gt;assert&lt;/code&gt; 가 사용 된 소스 위치를 삽입하는 전 처리기의 사용과 결합하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fc58693ff257f4600136a2111c4960ba6926b129" translate="yes" xml:space="preserve">
          <source>One way to do this is to create a &lt;code&gt;foreign export&lt;/code&gt; that will do whatever needs to be done to wake up the Haskell thread - perhaps &lt;code&gt;putMVar&lt;/code&gt; - and then call this from our C callback. There are a couple of problems with this:</source>
          <target state="translated">이를 수행하는 한 가지 방법 은 Haskell 스레드 (아마 &lt;code&gt;putMVar&lt;/code&gt; ) 를 깨우기 위해 수행해야하는 모든 작업을 수행 하는 &lt;code&gt;foreign export&lt;/code&gt; 를 생성 한 다음 C 콜백에서 호출하는 것입니다. 이것에는 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="896496c9fe69e79ba2c5e72301d3696844b503d6" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;INLINABLE&lt;/code&gt; is in conjunction with the special function &lt;code&gt;inline&lt;/code&gt; (&lt;a href=&quot;#special-ids&quot;&gt;Special built-in functions&lt;/a&gt;). The call &lt;code&gt;inline f&lt;/code&gt; tries very hard to inline &lt;code&gt;f&lt;/code&gt;. To make sure that &lt;code&gt;f&lt;/code&gt; can be inlined, it is a good idea to mark the definition of &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, so that GHC guarantees to expose an unfolding regardless of how big it is. Moreover, by annotating &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, you ensure that &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s original RHS is inlined, rather than whatever random optimised version of &lt;code&gt;f&lt;/code&gt; GHC&amp;rsquo;s optimiser has produced.</source>
          <target state="translated">&lt;code&gt;INLINABLE&lt;/code&gt; 을 사용하는 한 가지 방법 은 특수 함수 &lt;code&gt;inline&lt;/code&gt; ( &lt;a href=&quot;#special-ids&quot;&gt;특수 내장 함수&lt;/a&gt; ) 과 함께 사용하는 것 입니다 . 콜 &lt;code&gt;inline f&lt;/code&gt; 인라인에 열심히하려고 &lt;code&gt;f&lt;/code&gt; . 있는지 확인하기 위해 &lt;code&gt;f&lt;/code&gt; 는 인라인 할 수 있습니다,의 정의를 표시하는 좋은 아이디어입니다 &lt;code&gt;f&lt;/code&gt; 로 &lt;code&gt;INLINABLE&lt;/code&gt; 을 GHC는 그것이 얼마나 큰 상관없이 전개 노출 보장 그래서. 또한, &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;INLINABLE&lt;/code&gt; 로 주석 을 달면 임의의 최적화 된 &lt;code&gt;f&lt;/code&gt; GHC 옵티 마이저 버전이 아닌 &lt;code&gt;f&lt;/code&gt; 의 원래 RHS가 인라인 되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="e1ca150617a20c94c6d991df08ea7fec8c13f698" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;INLINABLE&lt;/code&gt; is in conjunction with the special function &lt;code&gt;inline&lt;/code&gt; (&lt;a href=&quot;#special-ids&quot;&gt;Special built-in functions&lt;/a&gt;). The call &lt;code&gt;inline f&lt;/code&gt; tries very hard to inline &lt;code&gt;f&lt;/code&gt;. To make sure that &lt;code&gt;f&lt;/code&gt; can be inlined, it is a good idea to mark the definition of &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, so that GHC guarantees to expose an unfolding regardless of how big it is. Moreover, by annotating &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, you ensure that &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s original RHS is inlined, rather than whatever random optimised version of &lt;code&gt;f&lt;/code&gt; GHC&amp;rsquo;s optimiser has produced.</source>
          <target state="translated">&lt;code&gt;INLINABLE&lt;/code&gt; 을 사용하는 한 가지 방법 은 특수 함수 &lt;code&gt;inline&lt;/code&gt; ( &lt;a href=&quot;#special-ids&quot;&gt;특수 내장 함수&lt;/a&gt; ) 과 함께 사용하는 것 입니다 . 콜 &lt;code&gt;inline f&lt;/code&gt; 인라인에 열심히하려고 &lt;code&gt;f&lt;/code&gt; . 있는지 확인하기 위해 &lt;code&gt;f&lt;/code&gt; 는 인라인 할 수 있습니다,의 정의를 표시하는 좋은 아이디어입니다 &lt;code&gt;f&lt;/code&gt; 로 &lt;code&gt;INLINABLE&lt;/code&gt; 을 GHC는 그것이 얼마나 큰 상관없이 전개 노출 보장 그래서. 또한 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;INLINABLE&lt;/code&gt; 로 주석 처리 하면 &lt;code&gt;f&lt;/code&gt; GHC 옵티마이 저의 임의 최적화 버전이 아닌 &lt;code&gt;f&lt;/code&gt; 의 원래 RHS가 인라인 되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dba5747f4551a506f4292cb3c2030f7b24af891" translate="yes" xml:space="preserve">
          <source>One way to use this flag is to set a breakpoint on &lt;code&gt;LongGCSync()&lt;/code&gt; in the debugger, and find the thread that is delaying the sync. You probably want to use &lt;a href=&quot;debug-info#ghc-flag--g&quot;&gt;&lt;code&gt;-g&lt;/code&gt;&lt;/a&gt; to provide more info to the debugger.</source>
          <target state="translated">이 플래그를 사용하는 한 가지 방법 은 디버거에서 &lt;code&gt;LongGCSync()&lt;/code&gt; 에 중단 점을 설정 하고 동기화를 지연시키는 스레드를 찾는 것입니다. 디버거에 더 많은 정보를 제공 하기 위해 &lt;a href=&quot;debug-info#ghc-flag--g&quot;&gt; &lt;code&gt;-g&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2c680b63b6bef62589b5937a565537e66960d46" translate="yes" xml:space="preserve">
          <source>One workaround is to use the &lt;a href=&quot;using#ghc-flag--msse2&quot;&gt;&lt;code&gt;-msse2&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;using#options-platform&quot;&gt;Platform-specific Flags&lt;/a&gt;), which generates code to use the SSE2 instruction set instead of the x87 instruction set. SSE2 code uses the correct precision for all floating-point operations, and so gives deterministic results. However, note that this only works with processors that support SSE2 (Intel Pentium 4 or AMD Athlon 64 and later), which is why the option is not enabled by default. The libraries that come with GHC are probably built without this option, unless you built GHC yourself.</source>
          <target state="translated">한 가지 해결 방법은 &lt;a href=&quot;using#ghc-flag--msse2&quot;&gt; &lt;code&gt;-msse2&lt;/code&gt; &lt;/a&gt; 명령어 세트 대신 SSE2 명령어 세트를 사용하는 코드를 생성 하는 -msse2 옵션 ( &lt;a href=&quot;using#options-platform&quot;&gt;플랫폼 별 플래그&lt;/a&gt; 참조 )을 사용하는 것입니다. SSE2 코드는 모든 부동 소수점 연산에 올바른 정밀도를 사용하므로 결정적인 결과를 제공합니다. 그러나 이는 SSE2 (Intel Pentium 4 또는 AMD Athlon 64 이상)를 지원하는 프로세서에서만 작동하므로이 옵션은 기본적으로 활성화되어 있지 않습니다. GHC와 함께 제공되는 라이브러리는 GHC를 직접 빌드하지 않는 한이 옵션없이 빌드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dfc86abc6a3fb1a97eebda069c8175f292ebd73" translate="yes" xml:space="preserve">
          <source>OneLineGCStats</source>
          <target state="translated">OneLineGCStats</target>
        </trans-unit>
        <trans-unit id="927d5cf27de83f9a93bc0c43d5e9992d0e575568" translate="yes" xml:space="preserve">
          <source>OneLineMode</source>
          <target state="translated">OneLineMode</target>
        </trans-unit>
        <trans-unit id="293e0ad51fda89c714a301db9fbb3d1d9e6c34d7" translate="yes" xml:space="preserve">
          <source>OneShot</source>
          <target state="translated">OneShot</target>
        </trans-unit>
        <trans-unit id="92340949cbfd5f6b38df2be19df951ad335baa8c" translate="yes" xml:space="preserve">
          <source>Only &lt;em&gt;dynamic&lt;/em&gt; flags can be used in an &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma (see &lt;a href=&quot;#mode-dynamic-flags&quot;&gt;Dynamic and Mode options&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma 에는 &lt;em&gt;동적&lt;/em&gt; 플래그 만 사용할 수 있습니다 ( &lt;a href=&quot;#mode-dynamic-flags&quot;&gt;동적 및 모드 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5805ff05f15235a01101ac5b0cf4fe9284ddd19e" translate="yes" xml:space="preserve">
          <source>Only a subset of &lt;code&gt;.hsc&lt;/code&gt; syntax is supported by &lt;code&gt;--cross-compile&lt;/code&gt;. The following are unsupported:</source>
          <target state="translated">&lt;code&gt;--cross-compile&lt;/code&gt; 은 &lt;code&gt;.hsc&lt;/code&gt; 구문 의 하위 집합 만 지원합니다 . 다음은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0c7ea9b4b424e7701e19b198d45f22f5ddc88ca" translate="yes" xml:space="preserve">
          <source>Only defined for &lt;code&gt;base-4.7.0.0&lt;/code&gt; and later</source>
          <target state="translated">만에 정의 된 &lt;code&gt;base-4.7.0.0&lt;/code&gt; 이상</target>
        </trans-unit>
        <trans-unit id="4a596037bffe0627dd076aba851bf6d728006681" translate="yes" xml:space="preserve">
          <source>Only defined when &lt;code&gt;-fllvm&lt;/code&gt; is specified. When GHC is using version &lt;code&gt;x.y.z&lt;/code&gt; of LLVM, the value of &lt;code&gt;__GLASGOW_HASKELL_LLVM__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example when using version 3.7 of LLVM, &lt;code&gt;__GLASGOW_HASKELL_LLVM__==307&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;-fllvm&lt;/code&gt; 이 지정된 경우에만 정의됩니다 . GHC가 LLVM의 버전 &lt;code&gt;x.y.z&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;__GLASGOW_HASKELL_LLVM__&lt;/code&gt; 의 값은 정수 ⟨xyy⟩입니다 (⟨y⟩가 한 자리이면 앞에 0이 추가되므로 예를 들어 LLVM의 버전 3.7을 사용할 때 &lt;code&gt;__GLASGOW_HASKELL_LLVM__==307&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="77501c9a6b02892b95f0d3d080f47d0f67625a4e" translate="yes" xml:space="preserve">
          <source>Only defined when &lt;code&gt;-parallel&lt;/code&gt; is in use! This symbol is defined when pre-processing Haskell (input) and pre-processing C (GHC output).</source>
          <target state="translated">&lt;code&gt;-parallel&lt;/code&gt; 을 사용중인 경우에만 정의됩니다 ! 이 기호는 전처리 Haskell (입력) 및 전처리 C (GHC 출력)시 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7ff1cf96778de3d5827e74815c075270e8782040" translate="yes" xml:space="preserve">
          <source>Only one of the two class parameters is a parameter to the data family. Hence, the following instance declaration is invalid:</source>
          <target state="translated">두 클래스 매개 변수 중 하나만 데이터 패밀리에 대한 매개 변수입니다. 따라서 다음 인스턴스 선언이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2721baf97a0c4efdd138d61549b8c89209e4143c" translate="yes" xml:space="preserve">
          <source>Only the instance head counts. In the example above, it is not good enough for &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s declaration to be in module &lt;code&gt;A&lt;/code&gt;; it must be the declaration of &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">인스턴스 헤드 만 계산됩니다. 위의 예에서 &lt;code&gt;C&lt;/code&gt; 의 선언이 모듈 &lt;code&gt;A&lt;/code&gt; 에있는 것만으로는 충분하지 않습니다 . 반드시 &lt;code&gt;D&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 선언이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c3f07cc6d0c90bb9379747728c0148950cf6bc3" translate="yes" xml:space="preserve">
          <source>Only the instance head counts. In the example above, it is not good enough for &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s declaration to be in module &lt;code&gt;A&lt;/code&gt;; it must be the declaration of &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">인스턴스 헤드 만 계산됩니다. 위의 예에서 &lt;code&gt;C&lt;/code&gt; 의 선언이 모듈 &lt;code&gt;A&lt;/code&gt; 에 있으면 충분하지 않습니다 . &lt;code&gt;D&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 의 선언이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e7998f0bdcbff51167fe5e1c42e1067cc0272867" translate="yes" xml:space="preserve">
          <source>Only the outer constructor is taken into consideration:</source>
          <target state="translated">외부 생성자 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="868f341dfb14a799178bbe260757188c4e090543" translate="yes" xml:space="preserve">
          <source>Only used internally</source>
          <target state="translated">내부에서만 사용</target>
        </trans-unit>
        <trans-unit id="1e5c03c4ca5dbc17c5a6129ff8dbe16f01a71ebd" translate="yes" xml:space="preserve">
          <source>Op</source>
          <target state="translated">Op</target>
        </trans-unit>
        <trans-unit id="c637aebe3a2825fb1f2be997a9434f3ce48a4b93" translate="yes" xml:space="preserve">
          <source>Opaque</source>
          <target state="translated">Opaque</target>
        </trans-unit>
        <trans-unit id="ab610cf3766e2ab5ebbdef1c372c6423bceb9405" translate="yes" xml:space="preserve">
          <source>Open a file and make an &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; for it. Truncates the file to zero size when the &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일을 열고 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; 를 만드 십시오. &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 일 때 파일을 0 크기 로 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="fb658d04e484f6ef351935e7a9b766b60debe2d4" translate="yes" xml:space="preserve">
          <source>Open a named semaphore with the given name, flags, mode, and initial value.</source>
          <target state="translated">주어진 이름, 플래그, 모드 및 초기 값으로 명명 된 세마포어를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="f57c4790f7f34a8ca95eceb331923fb2088fdde1" translate="yes" xml:space="preserve">
          <source>Open a shared memory object with the given name, flags, and mode.</source>
          <target state="translated">지정된 이름, 플래그 및 모드로 공유 메모리 객체를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a4120aa06412e5adc4c600815d8ebb61aa98d422" translate="yes" xml:space="preserve">
          <source>Open and optionally create this file. See &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; for information on how to use the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 파일을 열고 선택적으로 작성하십시오. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; 유형 을 사용하는 방법에 대한 정보는 &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea860b430753ad4955968e34ae243867a6c5fb04" translate="yes" xml:space="preserve">
          <source>Open and optionally create this file. See &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; for information on how to use the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 파일을 열고 선택적으로 만듭니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; 유형 을 사용하는 방법에 대한 정보는 &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="316640348a429645fef91dfb05b3196eb965850e" translate="yes" xml:space="preserve">
          <source>Open indexed type families are introduced by a signature, such as</source>
          <target state="translated">개방형 인덱스 유형 패밀리는 다음과 같은 서명으로 소개됩니다.</target>
        </trans-unit>
        <trans-unit id="62d19b763ce96acde6de1a0a0a137c190e97e371" translate="yes" xml:space="preserve">
          <source>Open type and data family declarations are exactly as in Haskell.</source>
          <target state="translated">개방형 및 데이터 패밀리 선언은 Haskell과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="345592cb9cc814b84d928db32f524bd68b8e8665" translate="yes" xml:space="preserve">
          <source>OpenExtHandle</source>
          <target state="translated">OpenExtHandle</target>
        </trans-unit>
        <trans-unit id="be4ef35b845f3f8742151ba042e927f175f32d3d" translate="yes" xml:space="preserve">
          <source>OpenFileFlags</source>
          <target state="translated">OpenFileFlags</target>
        </trans-unit>
        <trans-unit id="d4c5cbf148e8ab067ee8fcd91a86a68f327e2c93" translate="yes" xml:space="preserve">
          <source>OpenFileLimit</source>
          <target state="translated">OpenFileLimit</target>
        </trans-unit>
        <trans-unit id="b2a5470d265ed406614e0d033c4ebe86bf811418" translate="yes" xml:space="preserve">
          <source>OpenHandle</source>
          <target state="translated">OpenHandle</target>
        </trans-unit>
        <trans-unit id="f3dd14171959950898b3fb604b356ae109b6e608" translate="yes" xml:space="preserve">
          <source>OpenMode</source>
          <target state="translated">OpenMode</target>
        </trans-unit>
        <trans-unit id="528d57c38374a655a269ff7a2796f6152cc2b011" translate="yes" xml:space="preserve">
          <source>OpenPunctuation</source>
          <target state="translated">OpenPunctuation</target>
        </trans-unit>
        <trans-unit id="389682fb06c2c4c783f2fcf52cb3f6b658b5e3d8" translate="yes" xml:space="preserve">
          <source>OpenSemFlags</source>
          <target state="translated">OpenSemFlags</target>
        </trans-unit>
        <trans-unit id="8b0c300483c96f9ee4308ab45551ff569e61bab4" translate="yes" xml:space="preserve">
          <source>Opening and closing files</source>
          <target state="translated">파일 열기 및 닫기</target>
        </trans-unit>
        <trans-unit id="a535bff5bb480bbb6c0b709154409086b9fa6c12" translate="yes" xml:space="preserve">
          <source>Opening files</source>
          <target state="translated">파일 열기</target>
        </trans-unit>
        <trans-unit id="3ffea85c4926df7fcf793cfa4d81139f2c8578a1" translate="yes" xml:space="preserve">
          <source>Opens an editor to edit the file ⟨file⟩, or the most recently loaded module if ⟨file⟩ is omitted. If there were errors during the last loading, the cursor will be positioned at the line of the first error. The editor to invoke is taken from the &lt;code id=&quot;index-24&quot;&gt;EDITOR&lt;/code&gt; environment variable, or a default editor on your system if &lt;code id=&quot;index-25&quot;&gt;EDITOR&lt;/code&gt; is not set. You can change the editor using &lt;a href=&quot;#ghci-cmd-:set%20editor&quot;&gt;&lt;code&gt;:set editor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">⟨file⟨ 파일 또는 ⟨file⟨이 생략 된 경우 가장 최근에로드 된 모듈을 편집하기 위해 편집기를 엽니 다. 마지막로드 중 오류가 발생한 경우 커서는 첫 번째 오류 행에 위치합니다. 호출 할 편집기는 &lt;code id=&quot;index-24&quot;&gt;EDITOR&lt;/code&gt; 환경 변수 또는 &lt;code id=&quot;index-25&quot;&gt;EDITOR&lt;/code&gt; 가 설정되지 않은 경우 시스템의 기본 편집기에서 가져옵니다 . &lt;a href=&quot;#ghci-cmd-:set%20editor&quot;&gt; &lt;code&gt;:set editor&lt;/code&gt; 를&lt;/a&gt; 사용하여 편집기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab766ba42381e7e73d60b327225011551bd62285" translate="yes" xml:space="preserve">
          <source>Opens an existing file and creates mapping object to it.</source>
          <target state="translated">기존 파일을 열고 이에 대한 매핑 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b2e30baf3d135ff701a189f664d0aa02d8bc535e" translate="yes" xml:space="preserve">
          <source>Operate on the current user&amp;rsquo;s local package database. This flag affects the &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt;, and &lt;code&gt;hide&lt;/code&gt; commands.</source>
          <target state="translated">현재 사용자의 로컬 패키지 데이터베이스에서 작동하십시오. 이 플래그는 &lt;code&gt;register&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;unregister&lt;/code&gt; , &lt;code&gt;expose&lt;/code&gt; 및 &lt;code&gt;hide&lt;/code&gt; 명령에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="083cd84d11675eeddb18e443e875f6b6a3d95c50" translate="yes" xml:space="preserve">
          <source>Operate on the global package database (this is the default). This flag affects the &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt;, and &lt;code&gt;hide&lt;/code&gt; commands.</source>
          <target state="translated">글로벌 패키지 데이터베이스에서 작동합니다 (기본값). 이 플래그는 &lt;code&gt;register&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;unregister&lt;/code&gt; , &lt;code&gt;expose&lt;/code&gt; 및 &lt;code&gt;hide&lt;/code&gt; 명령에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="bf70e187ccc63f90f3e1fb5ec071ddb81220b4ff" translate="yes" xml:space="preserve">
          <source>Operating on the raw buffer as a Ptr</source>
          <target state="translated">원시 버퍼에서 Ptr로 작동</target>
        </trans-unit>
        <trans-unit id="212e24ce1fc682d740e1dca655f0849d8ec6b1da" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation (&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;).</source>
          <target state="translated">작업 설명에는 Big-O 표기법 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt; ) 의 작업 시간 복잡성이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30b4c034f9dfce3148616876e4eb785c3c71ce25" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;. Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">작업 설명에는 Big-O 표기법 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation)&lt;/a&gt; 의 작업 시간 복잡성이 포함되어 있습니다 . 많은 작업이 최악의 경우 O (min (n, W))의 복잡성을 갖습니다. 이는 최대 &lt;em&gt;W를&lt;/em&gt; 가진 요소 수에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수로 작업이 선형화 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="cc94aba5ba9874c8ccd3a8b0bd8fc45a51ca4e90" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;. Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">작업 주석에는 Big-O 표기법 &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt; 의 작업 시간 복잡성이 포함 됩니다. 많은 작업은 최악의 경우 복잡성이 O (min (n, W))입니다. 이는 연산이 최대 &lt;em&gt;W&lt;/em&gt; 인 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수인 요소 수에서 선형이 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1956fb1b777c2f5cb51b9aa2d865337af0a8590e" translate="yes" xml:space="preserve">
          <source>Operationally, in a dictionary-passing implementation, the constructors &lt;code&gt;Baz1&lt;/code&gt; and &lt;code&gt;Baz2&lt;/code&gt; must store the dictionaries for &lt;code&gt;Eq&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt; respectively, and extract it on pattern matching.</source>
          <target state="translated">작동 방식으로, 사전 전달 구현에서 생성자 &lt;code&gt;Baz1&lt;/code&gt; 및 &lt;code&gt;Baz2&lt;/code&gt; 는 각각 &lt;code&gt;Eq&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; 에 대한 사전을 저장하고 패턴 일치에서 추출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="010424427c51ae459956824d4f41c5856a7d7600" translate="yes" xml:space="preserve">
          <source>Operations for composing transactions: &lt;code&gt;retry&lt;/code&gt;, and &lt;code&gt;orElse&lt;/code&gt;.</source>
          <target state="translated">: 구성 거래를위한 작업 &lt;code&gt;retry&lt;/code&gt; 및 &lt;code&gt;orElse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64c6bfa202489b3690a8497e85422b7af3c47ee6" translate="yes" xml:space="preserve">
          <source>Operations for creating and interacting with sub-processes.</source>
          <target state="translated">하위 프로세스를 만들고 상호 작용하는 작업</target>
        </trans-unit>
        <trans-unit id="63e9af41f1576e5aa52ffaa696122d209a87d569" translate="yes" xml:space="preserve">
          <source>Operations for injecting values of arbitrary type into a dynamically typed value, Dynamic, are provided, together with operations for converting dynamic values into a concrete (monomorphic) type.</source>
          <target state="translated">동적 유형을 구체적인 유형 (모노 타입)으로 변환하는 작업과 함께 임의 유형의 값을 동적 유형 값인 Dynamic에 주입하는 작업이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa672f70c432a2f16141a0afca1b4ff49e644e5" translate="yes" xml:space="preserve">
          <source>Operations on &lt;code&gt;Float&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt; numbers are &lt;em&gt;unchecked&lt;/em&gt; for overflow, underflow, and other sad occurrences. (note, however, that some architectures trap floating-point overflow and loss-of-precision and report a floating-point exception, probably terminating the program)</source>
          <target state="translated">에 운영 &lt;code&gt;Float&lt;/code&gt; 와 &lt;code&gt;Double&lt;/code&gt; 번호는 &lt;em&gt;선택하지 않은&lt;/em&gt; 오버 플로우, 언더 플로우, 그리고 다른 슬픈 발생합니다. (그러나 일부 아키텍처는 부동 소수점 오버플로 및 정밀도 손실을 포착하고 부동 소수점 예외를보고하며 아마도 프로그램을 종료한다는 점에 유의하십시오)</target>
        </trans-unit>
        <trans-unit id="70b889a0601ca0e0323fbe3001c86239d52c2976" translate="yes" xml:space="preserve">
          <source>Operations on handles</source>
          <target state="translated">핸들 조작</target>
        </trans-unit>
        <trans-unit id="251fdb8c40a857d5de5aef3683ba18da16bd56ad" translate="yes" xml:space="preserve">
          <source>Operations on lists.</source>
          <target state="translated">목록 작업.</target>
        </trans-unit>
        <trans-unit id="a187376dc1defee65e37c92ba05a3b6fa77db72f" translate="yes" xml:space="preserve">
          <source>Operations whose result would be negative &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;
 (&lt;a href=&quot;control-exception#v:Underflow&quot;&gt;Underflow&lt;/a&gt; :: &lt;a href=&quot;control-exception#v:ArithException&quot;&gt;ArithException&lt;/a&gt;)&lt;/code&gt;,</source>
          <target state="translated">그 결과 작업은 음수가 될 것입니다 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt; (&lt;a href=&quot;control-exception#v:Underflow&quot;&gt;Underflow&lt;/a&gt; :: &lt;a href=&quot;control-exception#v:ArithException&quot;&gt;ArithException&lt;/a&gt;)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="d4f31eb6a5e978c610c6b257f8e92dc5ac9b8f36" translate="yes" xml:space="preserve">
          <source>Operator symbols become type &lt;em&gt;constructors&lt;/em&gt; rather than type &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">연산자 기호 는 형식 &lt;em&gt;변수가&lt;/em&gt; 아닌 형식 &lt;em&gt;생성자&lt;/em&gt; 가 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df4aab8de9b7c877a7baeb4198669b3c5323bb26" translate="yes" xml:space="preserve">
          <source>Operator symbols in types can be written infix, both in definitions and uses. For example:</source>
          <target state="translated">유형의 연산자 기호는 정의와 용도 모두에서 접두사로 쓸 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="deefc1ebb8a6a9e9d71ba863ed305fcb6f2e73df" translate="yes" xml:space="preserve">
          <source>OperatorTable</source>
          <target state="translated">OperatorTable</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e8b0a981c3293cd72332580a9bfaa03f3df518cf" translate="yes" xml:space="preserve">
          <source>OptDescr</source>
          <target state="translated">OptDescr</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="b293465e066906a2876636d4afb03e8ac6cf2ddc" translate="yes" xml:space="preserve">
          <source>Optional environment (otherwise inherit from the current process)</source>
          <target state="translated">선택적 환경 (그렇지 않으면 현재 프로세스에서 상 속됨)</target>
        </trans-unit>
        <trans-unit id="dd55d6c6a66ab5ddbc36d53946c786320ec3587d" translate="yes" xml:space="preserve">
          <source>Optional environment (otherwise inherit)</source>
          <target state="translated">선택적 환경 (그렇지 않으면 상속)</target>
        </trans-unit>
        <trans-unit id="0f14588d7b9710ada9394bfeaff05157c6f2476d" translate="yes" xml:space="preserve">
          <source>Optional path to the working directory</source>
          <target state="translated">작업 디렉토리에 대한 선택적 경로</target>
        </trans-unit>
        <trans-unit id="d91392285a0151b95f54b71ab44e6f6e738b5437" translate="yes" xml:space="preserve">
          <source>Optional path to the working directory for the new process</source>
          <target state="translated">새 프로세스의 작업 디렉토리에 대한 선택적 경로</target>
        </trans-unit>
        <trans-unit id="f439f2ba967862c2d5e67c16eed9a8d3ce132e3a" translate="yes" xml:space="preserve">
          <source>Optionally, the program may be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;. This provides two benefits:</source>
          <target state="translated">선택적으로 프로그램은 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 옵션 과 연결될 수 있습니다 (연결에 &lt;a href=&quot;phases#options-linker&quot;&gt;영향을주는 옵션&lt;/a&gt; 참조) . 두 가지 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="150df3ba8f1d25b3d2442fb251bd0b8739a08f6c" translate="yes" xml:space="preserve">
          <source>Options can be forced through to a particular compilation phase, using the following flags:</source>
          <target state="translated">다음 플래그를 사용하여 옵션을 특정 컴파일 단계로 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07de4eb670ca9b55e22ab8e74a884db849e506ae" translate="yes" xml:space="preserve">
          <source>Options may also be modified from within GHCi, using the &lt;a href=&quot;ghci#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 GHCi 내에서 옵션을 수정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbc525524ba745988196c2cf239dca851f2646d3" translate="yes" xml:space="preserve">
          <source>Or I could define a simple way to invoke &amp;ldquo;&lt;code&gt;ghc --make Main&lt;/code&gt;&amp;rdquo; in the current directory:</source>
          <target state="translated">또는 현재 디렉토리에서 &quot; &lt;code&gt;ghc --make Main&lt;/code&gt; &quot; 을 호출하는 간단한 방법을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed5f6d189422866d42c01faf2773a8db4acd9c2a" translate="yes" xml:space="preserve">
          <source>Or even simpler using applicative style:</source>
          <target state="translated">또는 적용 스타일을 사용하여 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c3af411739703165e3837288b0679427c0978621" translate="yes" xml:space="preserve">
          <source>Or in a standalone deriving declaration</source>
          <target state="translated">또는 독립형 파생 선언에서</target>
        </trans-unit>
        <trans-unit id="9e0ef2f0808aa7783d6cf8e9c6f90e88d912e8e1" translate="yes" xml:space="preserve">
          <source>Or using guards:</source>
          <target state="translated">또는 경비원 사용하기 :</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="2813ca76372ef7834dbf7b83dd19ec3f7be3b60a" translate="yes" xml:space="preserve">
          <source>Ord</source>
          <target state="translated">Ord</target>
        </trans-unit>
        <trans-unit id="f5167f3705089803c8512ac674241dfd7724cb93" translate="yes" xml:space="preserve">
          <source>Ord1</source>
          <target state="translated">Ord1</target>
        </trans-unit>
        <trans-unit id="a846bf09723a1322f808ad711f192bb56fbfbec4" translate="yes" xml:space="preserve">
          <source>Ord2</source>
          <target state="translated">Ord2</target>
        </trans-unit>
        <trans-unit id="f67c47b80d23bf9aafb12517fa70e43e75dc9ce1" translate="yes" xml:space="preserve">
          <source>Ordered ByteStrings</source>
          <target state="translated">정렬 된 바이트 문자열</target>
        </trans-unit>
        <trans-unit id="6b5d4e1e91de3c24915fa410d3ac4a21868bffb0" translate="yes" xml:space="preserve">
          <source>Ordered list</source>
          <target state="translated">주문 된 목록</target>
        </trans-unit>
        <trans-unit id="9bed071603b37f170248ba8799e9c1e267fbd2f5" translate="yes" xml:space="preserve">
          <source>Ordered lists</source>
          <target state="translated">주문 된 목록</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="5ee1f118f806c2954ead1243461f8f5c2a0d2524" translate="yes" xml:space="preserve">
          <source>Ordering of &lt;code&gt;-l&lt;/code&gt; options matters: a library should be mentioned &lt;em&gt;before&lt;/em&gt; the libraries it depends on (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; 옵션의 순서가 중요합니다. 라이브러리는 종속 된 라이브러리 &lt;em&gt;보다 먼저&lt;/em&gt; 언급 &lt;em&gt;해야&lt;/em&gt; 합니다 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="026197d403291a7a7c724e41228f7b3923b83a89" translate="yes" xml:space="preserve">
          <source>Orderings</source>
          <target state="translated">Orderings</target>
        </trans-unit>
        <trans-unit id="4cd6b596de672da2114ba27b5d0928eebf93910e" translate="yes" xml:space="preserve">
          <source>Ordinary inlining happens at the same time as rule rewriting, which may lead to unexpected results. Consider this (artificial) example</source>
          <target state="translated">규칙 재 작성과 동시에 일반 인라이닝이 발생하여 예기치 않은 결과가 발생할 수 있습니다. 이 (인공적인) 예를 고려하십시오</target>
        </trans-unit>
        <trans-unit id="04b00cb26f97f959a02aa6ce19955a72b8bd0a5f" translate="yes" xml:space="preserve">
          <source>Ordinary single-threaded Haskell programs will not benefit from enabling SMP parallelism alone: you must expose parallelism to the compiler. One way to do so is forking threads using Concurrent Haskell (&lt;a href=&quot;#concurrent-haskell&quot;&gt;Concurrent Haskell&lt;/a&gt;), but the simplest mechanism for extracting parallelism from pure code is to use the &lt;code&gt;par&lt;/code&gt; combinator, which is closely related to (and often used with) &lt;code&gt;seq&lt;/code&gt;. Both of these are available from the &lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;parallel library&lt;/a&gt;:</source>
          <target state="translated">일반적인 단일 스레드 Haskell 프로그램은 SMP 병렬 처리만으로는 이점을 얻지 못합니다. 컴파일러에 병렬 처리를 노출해야합니다. 이를 수행하는 한 가지 방법은 Concurrent Haskell ( &lt;a href=&quot;#concurrent-haskell&quot;&gt;Concurrent Haskell&lt;/a&gt; )을 사용하여 스레드를 분기하는 것입니다 . 그러나 순수 코드에서 병렬 처리를 추출하는 가장 간단한 메커니즘은 &lt;code&gt;seq&lt;/code&gt; 와 밀접한 관련이 있고 종종 사용되는 &lt;code&gt;par&lt;/code&gt; combinator 를 사용하는 것 입니다. 둘 다 &lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;병렬 라이브러리&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9e54f5fa5a278d112dceef67452d2651ffb1f7b" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts. Lazy variant by Duncan Coutts and Don Stewart.</source>
          <target state="translated">Bryan O'Sullivan의 원래 GHC 구현. Simon Marlow의 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 를 사용하도록 다시 작성되었습니다 . 조각을 지원 하고 David Roundy의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 사용하도록 다시 작성되었습니다 . Don Stewart와 Duncan Coutts가 다시 작성하고 확장했습니다. Duncan Coutts와 Don Stewart의 게으른 변형.</target>
        </trans-unit>
        <trans-unit id="93598ac808fb05625f35e4f620de0f0e53817bdf" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts.</source>
          <target state="translated">Bryan O'Sullivan의 원래 GHC 구현. Simon Marlow의 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 를 사용하도록 다시 작성되었습니다 . 조각을 지원 하고 David Roundy의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 사용하도록 다시 작성되었습니다 . Don Stewart와 Duncan Coutts가 다시 작성하고 확장했습니다.</target>
        </trans-unit>
        <trans-unit id="cb8e5613ec2d48a74c172ac7aa02cac4bef17d2b" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts. Lazy variant by Duncan Coutts and Don Stewart.</source>
          <target state="translated">Bryan O'Sullivan의 원래 GHC 구현. Simon Marlow가 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 를 사용하도록 재 작성했습니다 . 슬라이스를 지원 하고 David Roundy의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 사용하도록 재 작성되었습니다 . 다시 작성하고 Don Stewart와 Duncan Coutts가 확장했습니다. Duncan Coutts와 Don Stewart의 게으른 변종.</target>
        </trans-unit>
        <trans-unit id="74c96e5b47a54e6acfda288d441c2ec8fe32131b" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts.</source>
          <target state="translated">Bryan O'Sullivan의 원래 GHC 구현. Simon Marlow가 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 를 사용하도록 재 작성했습니다 . 슬라이스를 지원 하고 David Roundy의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 사용하도록 재 작성되었습니다 . 다시 작성하고 Don Stewart와 Duncan Coutts가 확장했습니다.</target>
        </trans-unit>
        <trans-unit id="1b9ce637b76a3e86159754092a5bff05de23030c" translate="yes" xml:space="preserve">
          <source>Originally designed by John Hughes's and Simon Peyton Jones's.</source>
          <target state="translated">원래 John Hughes와 Simon Peyton Jones가 설계했습니다.</target>
        </trans-unit>
        <trans-unit id="e0d11db984918c900a2e7615ec383a5f3eade238" translate="yes" xml:space="preserve">
          <source>Orphan instances</source>
          <target state="translated">고아 인스턴스</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="5ad09dd090c8718838113f73d1171adb4a590c71" translate="yes" xml:space="preserve">
          <source>Other &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; operations clash with &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; or &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions however, so they should be imported &lt;code&gt;qualified&lt;/code&gt; with a different alias e.g.</source>
          <target state="translated">그러나 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 작업은 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; 또는 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 함수 와 충돌 하므로 다른 별칭으로 &lt;code&gt;qualified&lt;/code&gt; 해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="97d83121e95b29befe338184898beb90ca66afb8" translate="yes" xml:space="preserve">
          <source>Other &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; operations clash with &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; or &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions however, so they should be imported &lt;code&gt;qualified&lt;/code&gt; with a different alias e.g.</source>
          <target state="translated">그러나 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 작업은 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; 또는 &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; 함수 와 충돌 하므로 다른 별칭으로 &lt;code&gt;qualified&lt;/code&gt; 되어야합니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="d7d5fbcca333f989fd2b0f0cf8199618b39f1bd3" translate="yes" xml:space="preserve">
          <source>Other Haskell systems do not currently support multiple operating system threads.</source>
          <target state="translated">다른 Haskell 시스템은 현재 여러 운영 체제 스레드를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="778e98a9766b655c4f188fb5d617327629ecdb0a" translate="yes" xml:space="preserve">
          <source>Other applications like the graphical Concurrent Haskell Debugger (&lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt;) may choose to overload &lt;code&gt;&lt;a href=&quot;ghc-conc#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; for their purposes as well.</source>
          <target state="translated">그래픽 Concurrent Haskell Debugger ( &lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt; ) 와 같은 다른 응용 프로그램 은 용도에 따라 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; 를 오버로드하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9086a30a19ab20bd7cd31262ef8e704a3c0e4890" translate="yes" xml:space="preserve">
          <source>Other applications like the graphical Concurrent Haskell Debugger (&lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt;) may choose to overload &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; for their purposes as well.</source>
          <target state="translated">그래픽 Concurrent Haskell Debugger ( &lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt; ) 와 같은 다른 응용 프로그램 은 용도에 따라 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; 를 오버로드하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31deb74a58fba669a7c2cb31b6bed8515ab85d00" translate="yes" xml:space="preserve">
          <source>Other combinators</source>
          <target state="translated">다른 조합기</target>
        </trans-unit>
        <trans-unit id="f717c91b4ff7b4e9135a9458b2f8146b78bb74a3" translate="yes" xml:space="preserve">
          <source>Other operations</source>
          <target state="translated">다른 작업</target>
        </trans-unit>
        <trans-unit id="82169c7fc5215cf20135048050c38ee826497c85" translate="yes" xml:space="preserve">
          <source>Other operations such as &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:quotBigNat&quot;&gt;quotBigNat&lt;/a&gt;&lt;/code&gt; may return &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;&lt;/code&gt; as well as a dummy/place-holder value instead of &lt;code&gt;undefined&lt;/code&gt; since we can't throw exceptions. But that behaviour should not be relied upon.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:quotBigNat&quot;&gt;quotBigNat&lt;/a&gt;&lt;/code&gt; 과 같은 다른 연산은 예외 를 던질 수 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;undefined&lt;/code&gt; 대신 더미 / 자리 표시 자 값을 반환 할 수 있습니다. 그러나 그 행동에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9047c6f96c316a252e973efb632599db44d02ce4" translate="yes" xml:space="preserve">
          <source>Other special syntax: sequences of characters that have a different meaning when this particular option is turned on.</source>
          <target state="translated">다른 특수 구문 :이 특정 옵션이 켜져있을 때 다른 의미를 갖는 문자 시퀀스.</target>
        </trans-unit>
        <trans-unit id="91b29ffa8ce218d650e0c973969ab7a599e5a143" translate="yes" xml:space="preserve">
          <source>Other stuff</source>
          <target state="translated">다른 것들</target>
        </trans-unit>
        <trans-unit id="4b372c318a0ac15f1e50d7fd1a01e206248a8e63" translate="yes" xml:space="preserve">
          <source>Other than these two caveats, users can always expect that a finalizer will be run after its weak pointer's object becomes unreachable. However, the second caveat means that users need to trust that all of their transitive dependencies do not throw exceptions in finalizers, since any finalizers can end up queued together.</source>
          <target state="translated">이 두 가지 경고 이외에, 사용자는 항상 약한 포인터의 객체에 도달 할 수없는 후에 파이널 라이저가 실행될 것이라고 기대할 수 있습니다. 그러나 두 번째 경고는 사용자가 모든 전이 종속성이 종료 자에서 예외를 throw하지 않는다는 것을 신뢰해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8c5befcc2e0951ae7c577c186d5015110ab50c93" translate="yes" xml:space="preserve">
          <source>Other types</source>
          <target state="translated">다른 유형</target>
        </trans-unit>
        <trans-unit id="c871109d68307ac18e84ee307aacea963e4970b3" translate="yes" xml:space="preserve">
          <source>Other uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are undefined. In particular, you should not use &lt;code&gt;unsafeCoerce#&lt;/code&gt; to cast a T to an algebraic data type D, unless T is also an algebraic data type. For example, do not cast &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; to &lt;code&gt;Bool&lt;/code&gt;, even if you later cast that &lt;code&gt;Bool&lt;/code&gt; back to &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; before applying it. The reasons have to do with GHC's internal representation details (for the cognoscenti, data values can be entered but function closures cannot). If you want a safe type to cast things to, use &lt;code&gt;Any&lt;/code&gt;, which is not an algebraic data type.</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; 의 다른 용도 는 정의되어 있지 않습니다. 특히 T가 대수 데이터 형식 이 아닌 경우 &lt;code&gt;unsafeCoerce#&lt;/code&gt; 을 사용 하여 T를 대수 데이터 형식 D로 캐스팅 해서는 안됩니다 . 예를 들어 나중에 적용하기 전에 해당 &lt;code&gt;Bool&lt;/code&gt; 을 &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; 로 캐스트하더라도 &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; 를 &lt;code&gt;Bool&lt;/code&gt; 로 캐스트하지 마십시오 . 그 이유는 GHC의 내부 표현 세부 사항과 관련이 있습니다 (공감력의 경우 데이터 값을 입력 할 수는 있지만 함수 클로저는 불가능합니다). 안전한 유형으로 물건을 캐스팅 하려면 대수 데이터 유형이 아닌 &lt;code&gt;Any&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cca89d1c6f9e6b7edb2c91666360061ed277fff" translate="yes" xml:space="preserve">
          <source>OtherError</source>
          <target state="translated">OtherError</target>
        </trans-unit>
        <trans-unit id="b004f25ba2f862ca69a0ad498024ce48dcec48b4" translate="yes" xml:space="preserve">
          <source>OtherLetter</source>
          <target state="translated">OtherLetter</target>
        </trans-unit>
        <trans-unit id="79976ff76f967e06eb59c60ae5e3d4d8d8f1dea8" translate="yes" xml:space="preserve">
          <source>OtherNumber</source>
          <target state="translated">OtherNumber</target>
        </trans-unit>
        <trans-unit id="2fe5dcff8470fff0318c0b5bff7bb23017100fe8" translate="yes" xml:space="preserve">
          <source>OtherPunctuation</source>
          <target state="translated">OtherPunctuation</target>
        </trans-unit>
        <trans-unit id="7d352f6a13bd8fb7c6cafa22cba1529a45d2c13e" translate="yes" xml:space="preserve">
          <source>OtherSymbol</source>
          <target state="translated">OtherSymbol</target>
        </trans-unit>
        <trans-unit id="a8f27da35e68a9f7a5a97f1703ac92769848a8d4" translate="yes" xml:space="preserve">
          <source>Others have execute permission.</source>
          <target state="translated">다른 사람에게는 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b5a656b29825a9211b83ccae7336ee695ce161" translate="yes" xml:space="preserve">
          <source>Others have read permission.</source>
          <target state="translated">다른 사람들에게는 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25f01ea5949b3e11544a08901cd4fc6b386f3f43" translate="yes" xml:space="preserve">
          <source>Others have read, write and execute permission.</source>
          <target state="translated">다른 사람들은 읽기, 쓰기 및 실행 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0d4f6a481380e178acd3897e6a60f3ade59b6a" translate="yes" xml:space="preserve">
          <source>Others have write permission.</source>
          <target state="translated">다른 사람들은 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49385a99644f84243228dd0e51c68c048e901bf5" translate="yes" xml:space="preserve">
          <source>Otherwise GHC will solve the &lt;code&gt;HasCallStack&lt;/code&gt; constraint for the singleton &lt;code&gt;CallStack&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">그렇지 않으면 GHC는 현재 콜 사이트 만 포함 하는 싱글 톤 &lt;code&gt;CallStack&lt;/code&gt; 에 대한 &lt;code&gt;HasCallStack&lt;/code&gt; 제약 조건을 해결합니다 .</target>
        </trans-unit>
        <trans-unit id="73b9866b09caa352e14869afa4a22348cbf03067" translate="yes" xml:space="preserve">
          <source>Otherwise there is exactly one non-incoherent candidate; call it the &amp;ldquo;prime candidate&amp;rdquo;.</source>
          <target state="translated">그렇지 않으면 정확히 하나의 비 일관성 후보가 있습니다. 그것을 &quot;프라임 후보&quot;라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="fb76a4f7af9550821f6b9b31e5732f8573d196f6" translate="yes" xml:space="preserve">
          <source>Otherwise uses home directory returned by &lt;code&gt;getpwuid_r&lt;/code&gt; using the UID of the current proccesses user. This basically reads the &lt;em&gt;etc&lt;/em&gt;passwd file. An empty home directory field is considered valid.</source>
          <target state="translated">그렇지 않으면 현재 프로세스 사용자의 UID를 사용하여 &lt;code&gt;getpwuid_r&lt;/code&gt; 에 의해 리턴 된 홈 디렉토리를 사용합니다. 기본적으로 &lt;em&gt;etc&lt;/em&gt; passwd 파일을 읽습니다 . 빈 홈 디렉토리 필드는 유효한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="165546d2f6cedba70f1aef6539fe75331eec72db" translate="yes" xml:space="preserve">
          <source>Otherwise, in the common case of a simple type error such as typing &lt;code&gt;reverse True&lt;/code&gt; at the prompt, you would get a warning and then an immediately-following type error when the expression is evaluated.</source>
          <target state="translated">그렇지 않으면 프롬프트에서 &lt;code&gt;reverse True&lt;/code&gt; 를 입력하는 것과 같은 간단한 유형 오류의 일반적인 경우 에는 표현식을 평가할 때 경고가 표시되고 바로 다음 유형 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9328699bfa5be08b83f54b0c37225de2cd8e0bd2" translate="yes" xml:space="preserve">
          <source>Otherwise, it behaves like &lt;code&gt;ghc-pkg list&lt;/code&gt;, including options.</source>
          <target state="translated">그렇지 않으면 옵션을 포함하여 &lt;code&gt;ghc-pkg list&lt;/code&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="122c01da0c009875e86f7f7f7990dd90b8f65d05" translate="yes" xml:space="preserve">
          <source>Out of scope term variables</source>
          <target state="translated">범위를 벗어난 용어 변수</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="dcd804196c4ab4c07a7fb9d32d6dd85f499cdd67" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is executed directly on the buffer of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. If the buffer is too small (or not present), then it is replaced with a large enough buffer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 출력하십시오 . &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 버퍼에 직접 실행 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . 버퍼가 너무 작거나 존재하지 않으면 충분히 큰 버퍼로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="ce49a024c5b74db9ad28503714f87c2bd1cb09a1" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is executed directly on the buffer of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. If the buffer is too small (or not present), then it is replaced with a large enough buffer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 출력합니다 . &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 버퍼에 직접 실행 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . 버퍼가 너무 작거나없는 경우 충분히 큰 버퍼로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="faccf69b130383a7a701fa6e58ffeb062f573f54" translate="yes" xml:space="preserve">
          <source>Output errors in reverse order</source>
          <target state="translated">역순으로 출력 오류</target>
        </trans-unit>
        <trans-unit id="5218d9a3d99e1852dea200794dafd520fce146d7" translate="yes" xml:space="preserve">
          <source>Output full span in error messages</source>
          <target state="translated">오류 메시지에서 출력 전체 범위</target>
        </trans-unit>
        <trans-unit id="364167f7b761668d223893cadae4f828c7c2fa44" translate="yes" xml:space="preserve">
          <source>Output functions</source>
          <target state="translated">출력 기능</target>
        </trans-unit>
        <trans-unit id="fbd84c24ac8d22f5181f1bc88f9671c4344d5b53" translate="yes" xml:space="preserve">
          <source>Output is returned strictly, so this is not suitable for launching processes that require interaction over the standard file streams.</source>
          <target state="translated">출력이 엄격하게 리턴되므로 표준 파일 스트림을 통한 상호 작용이 필요한 프로세스를 시작하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d56117c403f664c3e1ed706f67f62dcab08add06" translate="yes" xml:space="preserve">
          <source>Output preprocessor dependencies. This only has an effect when the CPP language extension is enabled. These dependencies are files included with the &lt;code&gt;#include&lt;/code&gt; preprocessor directive (as well as transitive includes) and implicitly included files such as standard c preprocessor headers and a GHC version header. One exception to this is that GHC generates a temporary header file (during compilation) containing package version macros. As this is only a temporary file that GHC will always generate, it is not output as a dependency.</source>
          <target state="translated">출력 전 처리기 종속성. 이것은 CPP 언어 확장이 활성화 된 경우에만 효과가 있습니다. 이러한 종속성은 &lt;code&gt;#include&lt;/code&gt; 전 처리기 지시문 (및 전이 포함)에 포함 된 파일과 표준 c 전 처리기 헤더 및 GHC 버전 헤더와 같은 암시 적으로 포함 된 파일입니다. 이에 대한 한 가지 예외는 GHC가 패키지 버전 매크로를 포함하는 임시 헤더 파일 (컴파일 중)을 생성한다는 것입니다. 이것은 GHC가 항상 생성 할 임시 파일 일 뿐이므로 종속성으로 출력되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e103798c3274cee279fa6992b0f5932f325fa5ac" translate="yes" xml:space="preserve">
          <source>Output the &lt;code&gt;ghc-pkg&lt;/code&gt; version number.</source>
          <target state="translated">&lt;code&gt;ghc-pkg&lt;/code&gt; 버전 번호를 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec3a20e9b85c9c73b5f9e136d68ee50ad77983fe" translate="yes" xml:space="preserve">
          <source>Output the HTML without adding newlines or spaces within the markup. This should be the most time and space efficient way to render HTML, though the ouput is quite unreadable.</source>
          <target state="translated">마크 업 내에 줄 바꿈이나 공백을 추가하지 않고 HTML을 출력하십시오. 출력을 읽을 수는 없지만 HTML을 렌더링하는 가장 시간과 공간 효율적인 방법이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed8e0c3be25bb282bdb7ed21575be0568a2ea8ce" translate="yes" xml:space="preserve">
          <source>Output version information and exit successfully.</source>
          <target state="translated">버전 정보를 출력하고 성공적으로 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="d76b710eda6d9732ae60ae3688eb9124d03137ca" translate="yes" xml:space="preserve">
          <source>OutputCap</source>
          <target state="translated">OutputCap</target>
        </trans-unit>
        <trans-unit id="3210573c1fb5e651cb8a6253bec6053d0ba32e16" translate="yes" xml:space="preserve">
          <source>OutputQueue</source>
          <target state="translated">OutputQueue</target>
        </trans-unit>
        <trans-unit id="1478d601c03c445a904d445d7c3e8cec48d16838" translate="yes" xml:space="preserve">
          <source>OutputUnderflow</source>
          <target state="translated">OutputUnderflow</target>
        </trans-unit>
        <trans-unit id="2bbfd1ba36d0c76586f52911ecb048b6eac561d8" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="3921704966c02cc64ce4b5f314c1cf70c103f53f" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="fdabf64a0b25e97a2bcdfbcbab9832f9fb21a8e2" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="ce4268dda332085e9857fd93d80106998f5a9cf6" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="d2be19b4f59c90e2b571c4c57a78af1c21f19989" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 . 청크는 한 번에 하나씩 작성됩니다. 다른 스레드는 쓰기 사이 에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 쓸 수 있으므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 만으로는 동시 쓰기에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b18f35ca8a8c8c01b6e67812f93b06a07030750" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 . 청크는 한 번에 하나씩 기록됩니다. 다른 스레드는 쓰기 사이 에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 쓸 수 있으므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 만으로는 동시 쓰기에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4f34b67d163777be1cfe43137e0b8aa27949758" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 . 청크는 한 번에 하나씩 작성됩니다. 다른 스레드는 쓰기 사이 에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 쓸 수 있으므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 만으로는 동시 쓰기에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92437970ef11779b851993774cf3f2a23f482a62" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 출력합니다 . 청크는 한 번에 하나씩 기록됩니다. 다른 스레드는 쓰기 사이 에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 쓸 수 있으므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 만으로는 동시 쓰기에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="437c6c5b9e71301759333f52e620b482f7d4e6a3" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요소 내부에 들여 쓰기로 들여 쓰기 된 HTML을 출력합니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e9342f2cf13303d6a47b5d18b92f9cf13b2e5169" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요소 내부에 들여 쓰기로 들여 쓰기 된 HTML을 출력합니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="19430befa515c2d9064f3110f0aa35abc26dd1f3" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요소 내부에 들여 쓰기로 들여 쓰기 된 HTML을 출력합니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="582cb8658b32442aec042d63a5cfab472fe58413" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML. Because space matters in HTML, the output is quite messy.</source>
          <target state="translated">들여 쓰기 된 HTML을 출력합니다. HTML에서는 공간이 중요하기 때문에 출력이 매우 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="b7f803909184a1a75bdfd2d4f7c735bb61a3e949" translate="yes" xml:space="preserve">
          <source>Outputs indented XHTML. Because space matters in HTML, the output is quite messy.</source>
          <target state="translated">들여 쓰기 된 XHTML을 출력합니다. HTML에서는 공간이 중요하기 때문에 출력이 매우 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="eb7db7a58078fc2825bd0a031efa804f437af7c6" translate="yes" xml:space="preserve">
          <source>Outputs the command-line syntax.</source>
          <target state="translated">명령 줄 구문을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="7119c6e28cbbe42a656bd510a3c7d9802856a05d" translate="yes" xml:space="preserve">
          <source>Outputting text</source>
          <target state="translated">텍스트 출력</target>
        </trans-unit>
        <trans-unit id="4da7bc9200c71949eae8135d4a25bb5b299cf7cc" translate="yes" xml:space="preserve">
          <source>Overflow</source>
          <target state="translated">Overflow</target>
        </trans-unit>
        <trans-unit id="86b5bfa21ad7befe5b7734642489ec9bc1748da2" translate="yes" xml:space="preserve">
          <source>Overlap</source>
          <target state="translated">Overlap</target>
        </trans-unit>
        <trans-unit id="2e8a35cfdb5657a597ecf6c9392cc4a625880c7a" translate="yes" xml:space="preserve">
          <source>Overlappable</source>
          <target state="translated">Overlappable</target>
        </trans-unit>
        <trans-unit id="4595ccd7bc9e0af583db794795f5853d40095221" translate="yes" xml:space="preserve">
          <source>Overlapping</source>
          <target state="translated">Overlapping</target>
        </trans-unit>
        <trans-unit id="66015fffae6c6a9653fc601aa127c669c9f7f142" translate="yes" xml:space="preserve">
          <source>Overlapping instances must be used with care. They can give rise to incoherence (i.e. different instance choices are made in different parts of the program) even without &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;. Consider:</source>
          <target state="translated">겹치는 인스턴스는주의해서 사용해야합니다. &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt; 없이도 일관성이 없어 질 수 있습니다 (즉, 프로그램의 다른 부분에서 다른 인스턴스 선택이 수행됨) . 치다:</target>
        </trans-unit>
        <trans-unit id="d1523bffa7a001e9a35e090d7fb6d2c81a06dbc6" translate="yes" xml:space="preserve">
          <source>OverlappingInstances</source>
          <target state="translated">OverlappingInstances</target>
        </trans-unit>
        <trans-unit id="a8f9e73a31d1ecafa5203f5b5c4b88f1a16e5e78" translate="yes" xml:space="preserve">
          <source>Overlaps</source>
          <target state="translated">Overlaps</target>
        </trans-unit>
        <trans-unit id="33bfb3c6026c4b45ecc7feb8aafe2ca9f3b3173c" translate="yes" xml:space="preserve">
          <source>Overlays are an experimental feature of HPC, a textual description of coverage. hpc draft is used to generate a draft overlay from a .tix file, and hpc overlay generates a .tix files from an overlay.</source>
          <target state="translated">오버레이는 적용 범위에 대한 텍스트 설명 인 HPC의 실험 기능입니다. hpc draft는 .tix 파일에서 초안 오버레이를 생성하는 데 사용되며 hpc overlay는 오버레이에서 .tix 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a8b4cac7022105ed5d28059687f452f232ee8a94" translate="yes" xml:space="preserve">
          <source>Overloaded functions are not your friend:</source>
          <target state="translated">과부하 된 기능은 친구가 아닙니다 :</target>
        </trans-unit>
        <trans-unit id="97176dd8fcd9d1389997c9bc3e797197c3840bf4" translate="yes" xml:space="preserve">
          <source>Overloaded lists</source>
          <target state="translated">오버로드 된 목록</target>
        </trans-unit>
        <trans-unit id="e8bd3aa687e1a738e55c3636a509b286641773a4" translate="yes" xml:space="preserve">
          <source>Overloaded mutable array interface</source>
          <target state="translated">오버로드 된 가변 배열 인터페이스</target>
        </trans-unit>
        <trans-unit id="e60511daee4f7111180ca7e032a2951fd849e4ee" translate="yes" xml:space="preserve">
          <source>Overloaded string literals</source>
          <target state="translated">오버로드 된 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="d6d7cf52e6ad94223f1634444b6ca253e18d7307" translate="yes" xml:space="preserve">
          <source>OverloadedLabels</source>
          <target state="translated">OverloadedLabels</target>
        </trans-unit>
        <trans-unit id="bfc0c0637f5d2341f692e6b4349a28ae53c2ed8b" translate="yes" xml:space="preserve">
          <source>OverloadedLists</source>
          <target state="translated">OverloadedLists</target>
        </trans-unit>
        <trans-unit id="21198418d476e74157738de8ed502c9d0fdf2bb9" translate="yes" xml:space="preserve">
          <source>OverloadedStrings</source>
          <target state="translated">OverloadedStrings</target>
        </trans-unit>
        <trans-unit id="f8883c62e6c0e5fff7f6dbed0dfb6ac51a5a5e1f" translate="yes" xml:space="preserve">
          <source>Override default behaviour for source files</source>
          <target state="translated">소스 파일의 기본 동작 무시</target>
        </trans-unit>
        <trans-unit id="6d84840c6065dcaf391a05992267b78411ef4230" translate="yes" xml:space="preserve">
          <source>Owing to the vagaries of DLL linking, these hooks don&amp;rsquo;t work under Windows when the program is built dynamically.</source>
          <target state="translated">DLL 연결의 차이로 인해 프로그램이 동적으로 빌드되면 Windows에서 이러한 후크가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32e42d7cf1d8ef849a65b5a64f751115cac94630" translate="yes" xml:space="preserve">
          <source>Owner has execute permission.</source>
          <target state="translated">소유자에게 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3602226bffa2bf2cc1004ff7d38eed8270dc876b" translate="yes" xml:space="preserve">
          <source>Owner has read permission.</source>
          <target state="translated">소유자에게 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="77086e57cff582a02a6797d6af8ebc3a53898204" translate="yes" xml:space="preserve">
          <source>Owner has read, write and execute permission.</source>
          <target state="translated">소유자가 읽기, 쓰기 및 실행 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7347b7f7b6214962e6cdded97a0459692c3eb4cb" translate="yes" xml:space="preserve">
          <source>Owner has write permission.</source>
          <target state="translated">소유자에게 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f821171aa7e9231ae6975fc208a27c4266781f" translate="yes" xml:space="preserve">
          <source>Owner, group and others have read and write permission.</source>
          <target state="translated">소유자, 그룹 및 기타 사람들은 읽기 및 쓰기 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e523f78f39ca6a4d4e48aaa4794b482ae4b16989" translate="yes" xml:space="preserve">
          <source>Owner, group and others have read, write and execute permission.</source>
          <target state="translated">소유자, 그룹 및 기타 사람들은 읽기, 쓰기 및 실행 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="804c55046a7d6c2cc06d260ab90e0d6beedbce3b" translate="yes" xml:space="preserve">
          <source>P's complete type is of the following form</source>
          <target state="translated">P의 완전한 유형은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="b38cb0ee15cbdc945a4dd5af71e0ea5ff7337a56" translate="yes" xml:space="preserve">
          <source>PACL</source>
          <target state="translated">PACL</target>
        </trans-unit>
        <trans-unit id="048499ce23d04eb40ace8750a382f648336913e9" translate="yes" xml:space="preserve">
          <source>PAINTSTRUCT</source>
          <target state="translated">PAINTSTRUCT</target>
        </trans-unit>
        <trans-unit id="ad09b4bfdbe4d101135fff62d526064595a08512" translate="yes" xml:space="preserve">
          <source>PHANDLE</source>
          <target state="translated">PHANDLE</target>
        </trans-unit>
        <trans-unit id="1dd2c6c79f5967008b3710173dafb5d91bf6f2af" translate="yes" xml:space="preserve">
          <source>PHANDLER_ROUTINE</source>
          <target state="translated">PHANDLER_ROUTINE</target>
        </trans-unit>
        <trans-unit id="7e7f65d76167ed1ddaafc5081c1471db12872a25" translate="yes" xml:space="preserve">
          <source>PHARDWAREINPUT</source>
          <target state="translated">PHARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="85e8f21e7df070dfbfb33b827711de398d912fd4" translate="yes" xml:space="preserve">
          <source>PINPUT</source>
          <target state="translated">PINPUT</target>
        </trans-unit>
        <trans-unit id="0b9ca3c7e43bcb3e5b2891c4396b2710f3cbde31" translate="yes" xml:space="preserve">
          <source>PKEY</source>
          <target state="translated">PKEY</target>
        </trans-unit>
        <trans-unit id="1820a15854141d70e90716d788ea58c3c229d171" translate="yes" xml:space="preserve">
          <source>PMOUSEINPUT</source>
          <target state="translated">PMOUSEINPUT</target>
        </trans-unit>
        <trans-unit id="aa6c6e71142e2a18efab6e799dedaa71f848c830" translate="yes" xml:space="preserve">
          <source>POSIX IO support. These types and functions correspond to the unix functions open(2), close(2), etc. For more portable functions which are more like fopen(3) and friends from stdio.h, see &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt;.</source>
          <target state="translated">POSIX IO 지원. 이러한 유형과 함수는 open (2), close (2) 등의 유닉스 함수에 해당합니다. fopen (3) 및 stdio.h의 친구와 같은보다 이식 가능한 함수는 &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="977519e345c48d6b762f0fe7418ce9a32ef4bccc" translate="yes" xml:space="preserve">
          <source>POSIX IO support. These types and functions correspond to the unix functions open(2), close(2), etc. For more portable functions which are more like fopen(3) and friends from stdio.h, see &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt;.</source>
          <target state="translated">POSIX IO 지원. 이러한 유형과 함수는 unix 함수 open (2), close (2) 등에 해당합니다. fopen (3) 및 stdio.h의 친구와 유사한 더 이식 가능한 함수에 대해서는 &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="079d0f57f2334c2adbdc7591a011db4dd709359a" translate="yes" xml:space="preserve">
          <source>POSIX Terminal support</source>
          <target state="translated">POSIX 터미널 지원</target>
        </trans-unit>
        <trans-unit id="22aca2377521adf00292736ce43c51b0c7e32ea3" translate="yes" xml:space="preserve">
          <source>POSIX Time support</source>
          <target state="translated">POSIX 시간 지원</target>
        </trans-unit>
        <trans-unit id="292baf4f2f262bc63b703e55a72343bbb3636618" translate="yes" xml:space="preserve">
          <source>POSIX data types</source>
          <target state="translated">POSIX 데이터 유형</target>
        </trans-unit>
        <trans-unit id="318e90ecf5469e2adbc593a53864478fbcf3bad5" translate="yes" xml:space="preserve">
          <source>POSIX data types: Haskell equivalents of the types defined by the &lt;code&gt;&amp;lt;sys/types.h&amp;gt;&lt;/code&gt; C header on a POSIX system.</source>
          <target state="translated">POSIX 데이터 유형 : POSIX 시스템 의 &lt;code&gt;&amp;lt;sys/types.h&amp;gt;&lt;/code&gt; C 헤더에 의해 정의 된 유형과 동일한 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="bb81ead9bcb349c7209884ed07f7695a7f46f32c" translate="yes" xml:space="preserve">
          <source>POSIX defines operations to get information, such as owner, permissions, size and access times, about a file. This information is represented by the &lt;code&gt;&lt;a href=&quot;system-posix-files#t:FileStatus&quot;&gt;FileStatus&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">POSIX는 파일에 대한 소유자, 권한, 크기 및 액세스 시간과 같은 정보를 가져 오는 작업을 정의합니다. 이 정보는 &lt;code&gt;&lt;a href=&quot;system-posix-files#t:FileStatus&quot;&gt;FileStatus&lt;/a&gt;&lt;/code&gt; 유형으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a83136c082ba1746dcd67b3e4264fcabc3118b4" translate="yes" xml:space="preserve">
          <source>POSIX defines operations to get information, such as owner, permissions, size and access times, about a file. This information is represented by the &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#t:FileStatus&quot;&gt;FileStatus&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">POSIX는 파일에 대한 소유자, 권한, 크기 및 액세스 시간과 같은 정보를 가져 오는 작업을 정의합니다. 이 정보는 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#t:FileStatus&quot;&gt;FileStatus&lt;/a&gt;&lt;/code&gt; 유형으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2247d636852d4974c20bc81cef3eee8f8693cb1" translate="yes" xml:space="preserve">
          <source>POSIX environment support</source>
          <target state="translated">POSIX 환경 지원</target>
        </trans-unit>
        <trans-unit id="77ab5f467c12abe5e944670123be671c69f9c1ad" translate="yes" xml:space="preserve">
          <source>POSIX error support</source>
          <target state="translated">POSIX 오류 지원</target>
        </trans-unit>
        <trans-unit id="577fae15c03302f9533fba712b949371600860a0" translate="yes" xml:space="preserve">
          <source>POSIX file control support</source>
          <target state="translated">POSIX 파일 제어 지원</target>
        </trans-unit>
        <trans-unit id="441cd303356e44c35c8b81962cf0dd9d836ac5e9" translate="yes" xml:space="preserve">
          <source>POSIX miscellaneous stuff, mostly from unistd.h</source>
          <target state="translated">대부분 unistd.h에서 POSIX 기타 물건</target>
        </trans-unit>
        <trans-unit id="0f6ec8374b30a1b5c96490a77a0ceae4de07fc7d" translate="yes" xml:space="preserve">
          <source>POSIX named semaphore support.</source>
          <target state="translated">POSIX라는 세마포어 지원.</target>
        </trans-unit>
        <trans-unit id="08bafc86e53a454435af5c1c18fc679a44dc565c" translate="yes" xml:space="preserve">
          <source>POSIX process support. See also the System.Cmd and System.Process modules in the process package.</source>
          <target state="translated">POSIX 프로세스 지원. 프로세스 패키지의 System.Cmd 및 System.Process 모듈도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="654e2e0f35661132458d5d0822add53293643b2a" translate="yes" xml:space="preserve">
          <source>POSIX resource support</source>
          <target state="translated">POSIX 자원 지원</target>
        </trans-unit>
        <trans-unit id="ebcc5225834879beb7456c935b043f8860521e53" translate="yes" xml:space="preserve">
          <source>POSIX shared memory support.</source>
          <target state="translated">POSIX 공유 메모리 지원.</target>
        </trans-unit>
        <trans-unit id="45920651e67f5412a47b9d8f7bc47165c18613b2" translate="yes" xml:space="preserve">
          <source>POSIX signal support</source>
          <target state="translated">POSIX 신호 지원</target>
        </trans-unit>
        <trans-unit id="4502a50a73e2d715093b7326bc2eb514a0e679e0" translate="yes" xml:space="preserve">
          <source>POSIX temporary file and directory creation functions.</source>
          <target state="translated">POSIX 임시 파일 및 디렉토리 생성 기능.</target>
        </trans-unit>
        <trans-unit id="3fab173d191fed500e90a6dee632c803a84facb1" translate="yes" xml:space="preserve">
          <source>POSIX time is the nominal time since 1970-01-01 00:00 UTC</source>
          <target state="translated">POSIX 시간은 1970-01-01 00:00 UTC 이후의 공칭 시간입니다.</target>
        </trans-unit>
        <trans-unit id="58f93d74398f0946ad737dd9368214ee4e669e99" translate="yes" xml:space="preserve">
          <source>POSIX time, if you need to deal with timestamps and the like. Most people won't need this module.</source>
          <target state="translated">POSIX 시간, 타임 스탬프 등을 처리해야하는 경우. 대부분의 사람들은이 모듈이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b94c2396f7667c2847b93362ca54298f2a041bb0" translate="yes" xml:space="preserve">
          <source>POSIX user/group support</source>
          <target state="translated">POSIX 사용자 / 그룹 지원</target>
        </trans-unit>
        <trans-unit id="1432f73e88b32fcc9fcbc2fc9541f54571421a18" translate="yes" xml:space="preserve">
          <source>POSIX: either file or directory link; Windows: file link</source>
          <target state="translated">POSIX : 파일 또는 디렉토리 링크; Windows : 파일 링크</target>
        </trans-unit>
        <trans-unit id="c5f7093efb2198f16b7b44117d72ea5f7c731b36" translate="yes" xml:space="preserve">
          <source>POSIXTime</source>
          <target state="translated">POSIXTime</target>
        </trans-unit>
        <trans-unit id="6fa84fb314e576ad58ab64235ec9f5692ff698e9" translate="yes" xml:space="preserve">
          <source>POSVERSIONINFOEX</source>
          <target state="translated">POSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="bb2083b91dbcda1acd7b19d79a3721e0e2c32aa6" translate="yes" xml:space="preserve">
          <source>PROPORTION</source>
          <target state="translated">PROPORTION</target>
        </trans-unit>
        <trans-unit id="48a6bb377c2d242262af4edce1280a39ef449e2a" translate="yes" xml:space="preserve">
          <source>PSID</source>
          <target state="translated">PSID</target>
        </trans-unit>
        <trans-unit id="3051dda3f76f70a2a56f76bf7a6055149e32138b" translate="yes" xml:space="preserve">
          <source>PUCHAR</source>
          <target state="translated">PUCHAR</target>
        </trans-unit>
        <trans-unit id="8baf870b616352faf6c7c0ecdaf54c8968a6fcff" translate="yes" xml:space="preserve">
          <source>Pack the elements of an unboxed tuple into a vector.</source>
          <target state="translated">박스형 튜플의 요소를 벡터로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="f1a7e630429c6941a869ac578c4e8fd6c98967d0" translate="yes" xml:space="preserve">
          <source>Package &lt;code&gt;P&lt;/code&gt; is trusted by C</source>
          <target state="translated">패키지 &lt;code&gt;P&lt;/code&gt; 는 C가 신뢰합니다</target>
        </trans-unit>
        <trans-unit id="632c494fdb55eaa49a7e790eda0b61cb93138010" translate="yes" xml:space="preserve">
          <source>Package environments can be modified by further command line arguments; for example, if you specify &lt;code&gt;-package foo&lt;/code&gt; on the command line, then package ⟨foo⟩ will be visible even if it&amp;rsquo;s not listed in the currently active package environment.</source>
          <target state="translated">추가 명령 행 인수로 패키지 환경을 수정할 수 있습니다. 예를 들어, 명령 행에 &lt;code&gt;-package foo&lt;/code&gt; 를 지정 하면 현재 활성화 된 패키지 환경에 나열되어 있지 않아도 패키지 listedfoo⟩가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="909c5fa9bb52d913940480e63569e9457c322a40" translate="yes" xml:space="preserve">
          <source>Package imports with thinning/renaming do not hide other versions of the package: e.g. if containers-0.9 is already exposed, &lt;code&gt;-package &quot;containers-0.8 (Data.List as ListV8)&quot;&lt;/code&gt; will only add an additional binding to the environment. Similarly, &lt;code&gt;-package &quot;base (Data.Bool as Bool)&quot; -package &quot;base (Data.List as List)&quot;&lt;/code&gt; is equivalent to &lt;code&gt;-package &quot;base (Data.Bool as Bool, Data.List as List)&quot;&lt;/code&gt;. Literal names must refer to modules defined by the original package, so for example &lt;code&gt;-package &quot;base (Data.Bool as Bool, Bool as Baz)&quot;&lt;/code&gt; is invalid unless there was a &lt;code&gt;Bool&lt;/code&gt; module defined in the original package. Hiding a package also clears all of its renamings.</source>
          <target state="translated">씨닝 / 이름 변경 기능이있는 패키지 가져 오기는 다른 버전의 패키지를 숨기지 않습니다. 예를 들어 컨테이너 &lt;code&gt;-package &quot;containers-0.8 (Data.List as ListV8)&quot;&lt;/code&gt; 가 이미 노출 된 경우 -package &quot;containers-0.8 (Data.List as ListV8)&quot; 은 환경에 추가 바인딩 만 추가합니다. 마찬가지로 &lt;code&gt;-package &quot;base (Data.Bool as Bool)&quot; -package &quot;base (Data.List as List)&quot;&lt;/code&gt; 는 &lt;code&gt;-package &quot;base (Data.Bool as Bool, Data.List as List)&quot;&lt;/code&gt; . 리터럴 이름은 원래 패키지에 의해 정의 된 모듈을 참조해야하므로 예를 들어 원래 패키지 에 &lt;code&gt;Bool&lt;/code&gt; 모듈이 정의되어 있지 않으면 &lt;code&gt;-package &quot;base (Data.Bool as Bool, Bool as Baz)&quot;&lt;/code&gt; 는 유효하지 않습니다 . 패키지를 숨기면 모든 이름 변경이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="5c9811b51086b6dfb42e84534c5b2b28e924b044" translate="yes" xml:space="preserve">
          <source>Package key of the package where the static pointer is defined</source>
          <target state="translated">정적 포인터가 정의 된 패키지의 패키지 키</target>
        </trans-unit>
        <trans-unit id="2218a05564cb586c32edc345988a8e44eb09178b" translate="yes" xml:space="preserve">
          <source>PackageImports</source>
          <target state="translated">PackageImports</target>
        </trans-unit>
        <trans-unit id="bd3f84301261878bbaaa34010d966279bf40adc1" translate="yes" xml:space="preserve">
          <source>Packed, unboxed, heap-resident arrays. Suitable for performance critical use, both in terms of large data quantities and high speed.</source>
          <target state="translated">팩형, 박스형, 힙 상주 형 어레이. 대량의 데이터 및 고속 측면에서 성능이 중요한 용도에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f01120d5c963de430516067cfc099589e4545ca8" translate="yes" xml:space="preserve">
          <source>Packing &lt;code&gt;CString&lt;/code&gt;s and pointers</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 및 포인터 패킹</target>
        </trans-unit>
        <trans-unit id="285f956c0084bc89a501b362eed07b802bf41e30" translate="yes" xml:space="preserve">
          <source>Packing CStrings and pointers</source>
          <target state="translated">CStrings 및 포인터 패킹</target>
        </trans-unit>
        <trans-unit id="a0c8d65ca6bc539ca2a1b96b6e86e38a5baa9898" translate="yes" xml:space="preserve">
          <source>PageMode</source>
          <target state="translated">PageMode</target>
        </trans-unit>
        <trans-unit id="7bf87bd02ae06b49144154cc04ef67e79107b5b6" translate="yes" xml:space="preserve">
          <source>PairS</source>
          <target state="translated">PairS</target>
        </trans-unit>
        <trans-unit id="a0ef17e085dcffd83b4ea0ed40152454a057e949" translate="yes" xml:space="preserve">
          <source>Pairs of format characters and the corresponding part of the input.</source>
          <target state="translated">형식 문자 쌍과 입력의 해당 부분.</target>
        </trans-unit>
        <trans-unit id="fa734be254acf2623327f645a9dcb22bb473a95a" translate="yes" xml:space="preserve">
          <source>Par1</source>
          <target state="translated">Par1</target>
        </trans-unit>
        <trans-unit id="5ef24093c55e5f8c5a103b53816f97bf24faf823" translate="yes" xml:space="preserve">
          <source>ParFlags</source>
          <target state="translated">ParFlags</target>
        </trans-unit>
        <trans-unit id="c48f526b9da677a33e39fdcf90d9349b58ca51c9" translate="yes" xml:space="preserve">
          <source>ParagraphSeparator</source>
          <target state="translated">ParagraphSeparator</target>
        </trans-unit>
        <trans-unit id="9588a94b078f52bbf1493d6bc87cb1b2c5cf0b63" translate="yes" xml:space="preserve">
          <source>Parallel list comprehensions are a natural extension to list comprehensions. List comprehensions can be thought of as a nice syntax for writing maps and filters. Parallel comprehensions extend this to include the &lt;code&gt;zipWith&lt;/code&gt; family.</source>
          <target state="translated">병렬 목록 이해는 이해를 나열하기위한 자연스러운 확장입니다. 리스트 이해는 맵과 필터를 작성하기위한 좋은 구문으로 생각할 수 있습니다. 병렬 이해는 &lt;code&gt;zipWith&lt;/code&gt; 제품군 을 포함하도록이를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="d2e51df32c5b57a230767d0f2b8d7fdcefacc103" translate="yes" xml:space="preserve">
          <source>Parallel statements (as with &lt;a href=&quot;#extension-ParallelListComp&quot;&gt;&lt;code&gt;ParallelListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">병렬 명령문 ( &lt;a href=&quot;#extension-ParallelListComp&quot;&gt; &lt;code&gt;ParallelListComp&lt;/code&gt; &lt;/a&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="fea4bc6e4f648852182893a472b471676de0d12f" translate="yes" xml:space="preserve">
          <source>Parallel statements are translated using the &lt;code&gt;mzip&lt;/code&gt; function, which requires a &lt;code&gt;MonadZip&lt;/code&gt; instance defined in &lt;a href=&quot;../libraries/base-4.13.0.0/control-monad-zip&quot;&gt;Control.Monad.Zip&lt;/a&gt;:</source>
          <target state="translated">병렬 명령문은 &lt;code&gt;mzip&lt;/code&gt; 함수를 사용하여 변환 되며 &lt;a href=&quot;../libraries/base-4.13.0.0/control-monad-zip&quot;&gt;Control.Monad.Zip에&lt;/a&gt; 정의 된 &lt;code&gt;MonadZip&lt;/code&gt; 인스턴스 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8ae51b740caaf8903073ae521aa80b2a759b050a" translate="yes" xml:space="preserve">
          <source>Parallel statements are translated using the &lt;code&gt;mzip&lt;/code&gt; function, which requires a &lt;code&gt;MonadZip&lt;/code&gt; instance defined in &lt;a href=&quot;../libraries/base-4.14.1.0/control-monad-zip&quot;&gt;Control.Monad.Zip&lt;/a&gt;:</source>
          <target state="translated">병렬 문은 &lt;code&gt;mzip&lt;/code&gt; 함수를 사용하여 번역 되며 &lt;a href=&quot;../libraries/base-4.14.1.0/control-monad-zip&quot;&gt;Control.Monad.Zip에&lt;/a&gt; 정의 된 &lt;code&gt;MonadZip&lt;/code&gt; 인스턴스 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b857f551749600d7503643d97e6a057f00f03140" translate="yes" xml:space="preserve">
          <source>ParallelArrays</source>
          <target state="translated">ParallelArrays</target>
        </trans-unit>
        <trans-unit id="69e4ffd2f4416a199955cb75660e245acf30a524" translate="yes" xml:space="preserve">
          <source>ParallelListComp</source>
          <target state="translated">ParallelListComp</target>
        </trans-unit>
        <trans-unit id="26eaabc74e0ecdfad0e89f8cdfa1c0968e3e9ed4" translate="yes" xml:space="preserve">
          <source>Parameterizable list monad, with an inner monad.</source>
          <target state="translated">내부 모나드가있는 파라미터 목록 모나드.</target>
        </trans-unit>
        <trans-unit id="02627bceb378089ccc20d97b38e35aa601c5dccf" translate="yes" xml:space="preserve">
          <source>Parameters can also be given explicit kind signatures if needed. We call the number of parameters in a type family declaration, the family&amp;rsquo;s arity, and all applications of a type family must be fully saturated with respect to that arity. This requirement is unlike ordinary type synonyms and it implies that the kind of a type family is not sufficient to determine a family&amp;rsquo;s arity, and hence in general, also insufficient to determine whether a type family application is well formed. As an example, consider the following declaration:</source>
          <target state="translated">필요한 경우 매개 변수에 명시 적 종류 서명을 부여 할 수도 있습니다. 유형 패밀리 선언, 패밀리의 특성 및 유형 패밀리의 모든 응용 프로그램은 해당 특성과 관련하여 완전히 포화되어야합니다. 이 요구 사항은 일반적인 유형 동의어와 다르며 유형 패밀리의 종류가 패밀리의 특성을 결정하기에 충분하지 않으므로 일반적으로 유형 패밀리 응용 프로그램이 제대로 구성되어 있는지 여부를 판단하기에는 불충분합니다. 예를 들어, 다음 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0a9ec76bad7b4461d4a1d8543c0eaec740e99cd7" translate="yes" xml:space="preserve">
          <source>Parameters concerning context switching</source>
          <target state="translated">컨텍스트 전환에 관한 파라미터</target>
        </trans-unit>
        <trans-unit id="cf4b1fc0bf92b4cc879c4bcbd45ef9ceab45e50c" translate="yes" xml:space="preserve">
          <source>Parameters of the cost-center profiler</source>
          <target state="translated">코스트 센터 프로파일 러의 매개 변수</target>
        </trans-unit>
        <trans-unit id="5457041fcc4bc9dce847560d14805ad2049bc05f" translate="yes" xml:space="preserve">
          <source>Parameters of the garbage collector.</source>
          <target state="translated">가비지 수집기의 매개 변수</target>
        </trans-unit>
        <trans-unit id="f5c5e2b2e3b21a175ea9ad3d8e177b1de7b7db91" translate="yes" xml:space="preserve">
          <source>Parameters of the runtime system</source>
          <target state="translated">런타임 시스템의 매개 변수</target>
        </trans-unit>
        <trans-unit id="070eab54f987bb88657d5187688919e26117fb36" translate="yes" xml:space="preserve">
          <source>Parameters pertaining to event tracing</source>
          <target state="translated">이벤트 추적과 관련된 매개 변수</target>
        </trans-unit>
        <trans-unit id="4c7921cf2c489ab76d8375681841d6fd080e0971" translate="yes" xml:space="preserve">
          <source>Parameters pertaining to parallelism</source>
          <target state="translated">병렬 처리와 관련된 매개 변수</target>
        </trans-unit>
        <trans-unit id="d33eae1bb8afa3f42df28e6f633413293fbaba1b" translate="yes" xml:space="preserve">
          <source>Parameters pertaining to the cost-center profiler.</source>
          <target state="translated">코스트 센터 프로파일 러와 관련된 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c4c7a142cf5276b1d4ff46847b29bfe9297aa11a" translate="yes" xml:space="preserve">
          <source>Parameters pertaining to ticky-ticky profiler</source>
          <target state="translated">틱 틱틱 프로파일 러와 관련된 매개 변수</target>
        </trans-unit>
        <trans-unit id="23d692f07a3fb646a8e54fcd2dc724f4ea2ed2c6" translate="yes" xml:space="preserve">
          <source>Parent</source>
          <target state="translated">Parent</target>
        </trans-unit>
        <trans-unit id="955199855b34047564f59f6340738ac93b4a24c6" translate="yes" xml:space="preserve">
          <source>Parent window, used for modal logon dialog</source>
          <target state="translated">모달 로그온 대화 상자에 사용되는 부모 창</target>
        </trans-unit>
        <trans-unit id="dcdb885a7f7995a4ae5f7735e2dbf7dd0df6c82b" translate="yes" xml:space="preserve">
          <source>ParentName</source>
          <target state="translated">ParentName</target>
        </trans-unit>
        <trans-unit id="fc2a5e24ef9b291c16b2d7d017af998e3868317a" translate="yes" xml:space="preserve">
          <source>Parenthesize an value if the boolean is true.</source>
          <target state="translated">부울이 참이면 값을 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="f6fdd858f972c18cfc63e77f0f9f6ec35b5f5477" translate="yes" xml:space="preserve">
          <source>Parse a single lexeme</source>
          <target state="translated">하나의 exeme 구문 분석</target>
        </trans-unit>
        <trans-unit id="7d1ffbe57b690c268aa7d881a60c206e50319514" translate="yes" xml:space="preserve">
          <source>Parse a string using the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance. Succeeds if there is exactly one valid result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용하여 문자열을 구문 분석하십시오 . 정확히 하나의 유효한 결과가 있으면 성공합니다.</target>
        </trans-unit>
        <trans-unit id="0be062266a17add68a7b668ce79822b3887a5efd" translate="yes" xml:space="preserve">
          <source>Parse a string using the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance. Succeeds if there is exactly one valid result. A &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value indicates a parse error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용하여 문자열을 구문 분석하십시오 . 정확히 하나의 유효한 결과가 있으면 성공합니다. &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값은 구문 분석 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89b7b9c3cafacbc3fbfa8f182d03db0eb57615a7" translate="yes" xml:space="preserve">
          <source>Parse a time value given a format string. Fails if the input could not be parsed using the given format. See &lt;code&gt;&lt;a href=&quot;data-time-format#v:parseTimeM&quot;&gt;parseTimeM&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">지정된 형식 문자열로 시간 값을 구문 분석하십시오. 주어진 형식을 사용하여 입력을 구문 분석 할 수 없으면 실패합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;data-time-format#v:parseTimeM&quot;&gt;parseTimeM&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
