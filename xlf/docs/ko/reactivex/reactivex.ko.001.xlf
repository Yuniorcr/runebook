<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="reactivex">
    <body>
      <group id="reactivex">
        <trans-unit id="8bb1a4880b71bbf96c77904b471633be02e4f575" translate="yes" xml:space="preserve">
          <source>&amp;copy; ReactiveX contributors</source>
          <target state="translated">&amp;copy; ReactiveX 기고자</target>
        </trans-unit>
        <trans-unit id="ada27a33bf9c68fb3cbac205322beb072f9bf4a3" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectConcat&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;concatMap&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;selectConcat&lt;/code&gt; &amp;rdquo;은 &lt;code&gt;concatMap&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="7f33193ba4ed9e4a70c0886da9f44ed6474f4347" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectConcatObserver&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;concatMapObserver&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;selectConcatObserver&lt;/code&gt; &amp;rdquo;는 &lt;code&gt;concatMapObserver&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="011bbafe1b211deabe6d4d163f504bc37bba4438" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectMany&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMap&lt;/code&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;selectMany&lt;/code&gt; 는 &quot;의 별칭입니다 &lt;code&gt;flatMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652d537945ac6e2a2be380a114ed6b84ec433624" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectManyObserver&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMapObserver&lt;/code&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;selectManyObserver&lt;/code&gt; 는 &quot;의 별칭입니다 &lt;code&gt;flatMapObserver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8858fe29d08b4ac07353302ff7337adc9c17e17e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectSwitch&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMapLatest&lt;/code&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;selectSwitch&lt;/code&gt; 는 &quot;의 별칭입니다 &lt;code&gt;flatMapLatest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a182db8bfa5293706ee292aab892f1c223187092" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Hot&amp;rdquo; and &amp;ldquo;Cold&amp;rdquo; Observables</source>
          <target state="translated">&quot;핫&quot;및 &quot;콜드&quot;옵저버 블</target>
        </trans-unit>
        <trans-unit id="628e3c0ed13b486bb51f51ba494993cd92feca15" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;The Observable Contract,&amp;rdquo; which you may see referenced in various places in source documentation and in the pages on this site, is an attempt at a formal definition of an Observable, based originally on the 2010 document &lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;&lt;/a&gt; from Microsoft that described its Rx.NET implementation of ReactiveX.</source>
          <target state="translated">소스 문서와이 사이트의 페이지에서 다양한 위치에서 참조 할 수있는 &quot;관찰 가능한 계약&quot;은 원래 2010 문서 &lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;&lt;cite&gt;Rx 디자인 지침&lt;/cite&gt;&lt;/a&gt; 을 기반으로 Observable을 공식적으로 정의하려는 시도입니다. ReactiveX의 Rx.NET 구현.</target>
        </trans-unit>
        <trans-unit id="3064f51b892e08b0c317bd603ed6b1c5496873e8" translate="yes" xml:space="preserve">
          <source>(If, on the other hand, you want to append a sequence of items to the end of those normally emitted by an Observable, you want the &lt;a href=&quot;concat&quot;&gt;Concat&lt;/a&gt; operator.)</source>
          <target state="translated">반면에 Observable이 일반적으로 방출하는 항목 끝에 일련의 항목을 추가하려는 경우 &lt;a href=&quot;concat&quot;&gt;Concat&lt;/a&gt; 연산자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="33d18aff50d4af9918043a17429ab9d8422faab7" translate="yes" xml:space="preserve">
          <source>(optional) a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; or an Observable:</source>
          <target state="translated">(선택 사항) &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 또는 Observable :</target>
        </trans-unit>
        <trans-unit id="10a49259eb5c4104d411ab272baaefc70db9d42e" translate="yes" xml:space="preserve">
          <source>(required) a function that accepts an item from the source Observable and returns its key</source>
          <target state="translated">(필수) 소스 Observable에서 항목을 받아서 키를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="472fde8dfbd26d60ec634739e7c5baef720d6a9e" translate="yes" xml:space="preserve">
          <source>(required) a function that returns an Observable, the emissions from which trigger the termination of any open Observables</source>
          <target state="translated">(필수) Observable을 반환하는 함수, 열려있는 Observable의 종료를 트리거하는 배출</target>
        </trans-unit>
        <trans-unit id="8ec0db89f0508beecc88e44a4f261c96a84f7a76" translate="yes" xml:space="preserve">
          <source>), you only use two methods to subscribe:</source>
          <target state="translated">) 구독시 두 가지 방법 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="d2f39249308876151e8d9b31ac981ad614b505db" translate="yes" xml:space="preserve">
          <source>. An Observable</source>
          <target state="translated">. 관찰 할 수있는</target>
        </trans-unit>
        <trans-unit id="b1ac4cc21e92b26c247d2d196cac30ab387310d2" translate="yes" xml:space="preserve">
          <source>. Then that observer reacts to whatever item or sequence of items the Observable</source>
          <target state="translated">. 그런 다음 관찰자는 관찰 가능한 항목 또는 항목 시퀀스에 반응합니다.</target>
        </trans-unit>
        <trans-unit id="51fe6dc75cfc49521ecb18667ffda03016ec73bf" translate="yes" xml:space="preserve">
          <source>. This pattern facilitates concurrent operations because it does not need to block while waiting for the Observable to emit objects, but instead it creates a sentry in the form of an observer that stands ready to react appropriately at whatever future time the Observable does so.</source>
          <target state="translated">. 이 패턴은 Observable이 객체를 방출하기를 기다리는 동안 차단할 필요가 없기 때문에 동시 작업을 용이하게합니다. 대신 Observable이 수행 할 때마다 적절히 반응 할 준비가 된 관찰자의 형태로 보초를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="b3bae60012f7a78cc91257251e629489a51994ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;filtering-observables#wiki-first-and-takefirst&quot;&gt;&lt;code&gt;first( )&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;filtering-observables#wiki-take&quot;&gt;&lt;code&gt;take(1)&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;observable-utility-operators#wiki-single-and-singleordefault&quot;&gt;&lt;code&gt;single( )&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;filtering-observables#wiki-first-and-takefirst&quot;&gt; &lt;code&gt;first( )&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;filtering-observables#wiki-take&quot;&gt; &lt;code&gt;take(1)&lt;/code&gt; &lt;/a&gt; 로 정의됩니다 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;observable-utility-operators#wiki-single-and-singleordefault&quot;&gt; &lt;code&gt;single( )&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59266734c85708062c27299be8478b239f26b4ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;filtering-observables#wiki-ignoreelements&quot;&gt;&lt;code&gt;ignoreElements( )&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;filtering-observables#wiki-filter&quot;&gt;&lt;code&gt;filter(alwaysFalse( ))&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;filtering-observables#wiki-ignoreelements&quot;&gt; &lt;code&gt;ignoreElements( )&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;filtering-observables#wiki-filter&quot;&gt; &lt;code&gt;filter(alwaysFalse( ))&lt;/code&gt; &lt;/a&gt; 로 정의됩니다</target>
        </trans-unit>
        <trans-unit id="4667e98d48cafefe965c6cfbbf931c271b1e90b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Pitfalls of Operator Implementations (part 1)&lt;/a&gt; and &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;&lt;/a&gt;D&amp;aacute;vid Karnok 의 운영자 구현의 함정 (1 부) 및 &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(2 부)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e206efd342d6f311e4eaf22aa1dad1f1c530786a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;Advanced RxJava: Subject&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;고급 RxJava :&lt;/a&gt; D&amp;aacute;vid Karnok의 주제</target>
        </trans-unit>
        <trans-unit id="47f33eda1a69dd738f1849ddb4b492a4b2e5509d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Advanced Reactive Java: SubscribeOn and ObserveOn&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;고급 반응성 Java :&lt;/a&gt; D&amp;aacute;vid Karnok의 SubscribeOn 및 ObserveOn</target>
        </trans-unit>
        <trans-unit id="e230c3946af5006280175d640abe4d4a13419ba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/&quot;&gt;&lt;cite&gt;Grokking RxJava&lt;/cite&gt;: Operator, Operator&lt;/a&gt; by Dan Lew</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/&quot;&gt;&lt;cite&gt;Grokking RxJava&lt;/cite&gt; : 운영자, 운영자&lt;/a&gt; Dan Lew</target>
        </trans-unit>
        <trans-unit id="d3d0073935807280d0be6f71fbb272c064199c60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/&quot;&gt;Loading data from multiple sources with RxJava&lt;/a&gt; by Dan Lew (example using Concat and First)</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/&quot;&gt;&lt;/a&gt;Dan Lew의 RxJava 를 사용하여 여러 소스에서 데이터로드 (Concat 및 First를 사용하는 예)</target>
        </trans-unit>
        <trans-unit id="88b0f482a744066f1f064e5f01147915d1aa0700" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/&quot;&gt;Deferring Observable code until subscription in RxJava&lt;/a&gt; by Dan Lew</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/&quot;&gt;&lt;/a&gt;Dan Lew 가 RxJava에서 구독 할 때까지 관찰 가능한 코드 연기</target>
        </trans-unit>
        <trans-unit id="f1ca84472fb7904b99b27002018564cb5a4547cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.joanzapata.com/experimentation-with-rx/&quot;&gt;Experimentation with RxJava&lt;/a&gt; by Joan Zapata</source>
          <target state="translated">&lt;a href=&quot;http://blog.joanzapata.com/experimentation-with-rx/&quot;&gt;&lt;/a&gt;Joan Zapata의 RxJava 실험</target>
        </trans-unit>
        <trans-unit id="c03861d52c0ac7e93ae1206503fa91b22d7f7e21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/&quot;&gt;&lt;cite&gt;Wedding Party&lt;/cite&gt;: Share, Publish, Refcount, and All That Jazz&lt;/a&gt; by Kaushik Gopal</source>
          <target state="translated">&lt;a href=&quot;http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/&quot;&gt;&lt;cite&gt;웨딩 파티&lt;/cite&gt; :&lt;/a&gt; Kaushik Gopal의 공유, 게시, 환불 및 모든 재즈</target>
        </trans-unit>
        <trans-unit id="5ce980c6203942d6328150d8b1c308fa22c0eaa5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blogs.microsoft.co.il/iblogger/2015/08/11/animations-of-rx-operators-groupby/&quot;&gt;Animations of Rx operators: GroupBy&lt;/a&gt; by Tamir Dresher</source>
          <target state="translated">&lt;a href=&quot;http://blogs.microsoft.co.il/iblogger/2015/08/11/animations-of-rx-operators-groupby/&quot;&gt;Rx 연산자의 애니메이션 :&lt;/a&gt; Tamir Dresher의 GroupBy</target>
        </trans-unit>
        <trans-unit id="fbfa59fd65771d372675362d61976b92c09f6c20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx&quot;&gt;To Use or Not to Use Subject&lt;/a&gt; from</source>
          <target state="translated">&lt;a href=&quot;http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx&quot;&gt;사용하거나 사용하지 않을 주제로&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="759d49d6a27ee607b3399f224c41924b74508d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.couchbase.com/developer/java-2.0/observables.html&quot;&gt;&lt;cite&gt;Mastering observables&lt;/cite&gt;&lt;/a&gt; (from the Couchbase Server documentation)</source>
          <target state="translated">&lt;a href=&quot;http://docs.couchbase.com/developer/java-2.0/observables.html&quot;&gt;&lt;cite&gt;관찰 가능 항목 마스터 링&lt;/cite&gt;&lt;/a&gt; (Couchbase 서버 설명서에서)</target>
        </trans-unit>
        <trans-unit id="896a64d54c6458d527ffcfd1ff702993ee89e715" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Triangular_number&quot;&gt;triangular numbers&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Triangular_number&quot;&gt;삼각수&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0cf025e741372bc56b5fa846f8b8c00cb06df70f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&quot;&gt;RxJava Observable transformation: concatMap() vs. flatMap()&lt;/a&gt; by Fernando Cejas</source>
          <target state="translated">&lt;a href=&quot;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&quot;&gt;RxJava Observable 변환 :&lt;/a&gt; Fernando Cejas의 concatMap () vs flatMap ()</target>
        </trans-unit>
        <trans-unit id="28d3f563e622ffc28d2ef40034bcd9d4f00ca617" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://java.dzone.com/articles/async-abstractios-using-rx&quot;&gt;Async Abstractions using rx-java&lt;/a&gt; by Biju Kunjummen,</source>
          <target state="translated">&lt;a href=&quot;http://java.dzone.com/articles/async-abstractios-using-rx&quot;&gt;&lt;/a&gt;Biju Kunjummen의 rx-java 를 사용한 비동기 추상화 ,</target>
        </trans-unit>
        <trans-unit id="8a54c1db4af03308f492e88a17125cdba0d0c092" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jschneider.io/2014/11/26/Recursive-Observables-with-Rx-Java.html&quot;&gt;&lt;cite&gt;Recursive Observables with RxJava&lt;/cite&gt;&lt;/a&gt; by Jon Schneider</source>
          <target state="translated">&lt;a href=&quot;http://jschneider.io/2014/11/26/Recursive-Observables-with-Rx-Java.html&quot;&gt;&lt;cite&gt;&lt;/cite&gt;&lt;/a&gt;Jon Schneider의&lt;cite&gt; RxJava&lt;/cite&gt; 를&lt;cite&gt; 사용한 재귀 적 관찰 가능&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="16022b407d5c10a64a78eb6bcb293d94191d92c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedulePeriodically(rx.functions.Action0,%20long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;Another &lt;code&gt;Scheduler&lt;/code&gt; method&lt;/a&gt; allows you to schedule an action to take place at regular intervals. The following example schedules &lt;code&gt;someAction&lt;/code&gt; to be performed on &lt;code&gt;someScheduler&lt;/code&gt; after 500ms have passed, and then every 250ms thereafter:</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedulePeriodically(rx.functions.Action0,%20long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;다른 &lt;code&gt;Scheduler&lt;/code&gt; 방법을&lt;/a&gt; 사용하면 정기적으로 작업이 수행되도록 예약 할 수 있습니다. 다음 예제 일정을 &lt;code&gt;someAction&lt;/code&gt; 을 수행 할 &lt;code&gt;someScheduler&lt;/code&gt; 250ms마다 그 후에 다음은 500ms가 지난 후, 및 :</target>
        </trans-unit>
        <trans-unit id="a37f7ccc01d776219ff3c86d486170b61368bb91" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html&quot;&gt;The &lt;code&gt;TestScheduler&lt;/code&gt;&lt;/a&gt; allows you to exercise fine-tuned manual control over how the Scheduler&amp;rsquo;s clock behaves. This can be useful for testing interactions that depend on precise arrangements of actions in time. This Scheduler has three additional methods:</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html&quot;&gt; &lt;code&gt;TestScheduler&lt;/code&gt; 는&lt;/a&gt; 어떻게 스케줄러의 클럭 동작합니다을 미세 조정 수동 제어를 행사할 수 있습니다. 이는 시간의 정확한 조치 배열에 의존하는 상호 작용을 테스트하는 데 유용 할 수 있습니다. 이 스케줄러에는 세 가지 추가 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b99f29bcb2b76c81e30b2a8987e758a20001805" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: Understanding observeOn() and subscribeOn()&lt;/a&gt; by Thomas Nield</source>
          <target state="translated">&lt;a href=&quot;http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava :&lt;/a&gt; Thomas Nield의 observeOn () 및 subscribeOn () 이해</target>
        </trans-unit>
        <trans-unit id="d5434e93f83f2e22d891275d0648442c8413f6ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;&lt;cite&gt;RxJava Threading Examples&lt;/cite&gt;&lt;/a&gt; by Graham Lea</source>
          <target state="translated">&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;&lt;cite&gt;&lt;/cite&gt;&lt;/a&gt;Graham Lea의&lt;cite&gt; RxJava 스레딩 예제&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="1d280bc18cadf90c9c47536bb1dda083a732e6f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examlpes&lt;/a&gt; by Graham Lea</source>
          <target state="translated">&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;&lt;/a&gt;Graham Lea의 RxJava 스레딩 검사</target>
        </trans-unit>
        <trans-unit id="74f17e88de08b7b705152e13a4c7159ebecfb889" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html&quot;&gt;Aligning packets with JSON documents&lt;/a&gt; with the &lt;code&gt;split&lt;/code&gt; operator</source>
          <target state="translated">&lt;a href=&quot;http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html&quot;&gt;&lt;/a&gt; &lt;code&gt;split&lt;/code&gt; 연산자를 사용하여 JSON 문서 와 패킷 정렬</target>
        </trans-unit>
        <trans-unit id="8f646afbe00e0bfa7ba10a96b4ffa0e66bb17b8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Implementing Your Own Observable Operators&lt;/a&gt; (in RxJS) by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;&lt;/a&gt;Dennis Stoyanov의 RxJS에서 자체 관찰 가능한 연산자 구현</target>
        </trans-unit>
        <trans-unit id="8de4cdb66506641a1d2be3db34ce3c18d520fb41" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Using Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;&lt;/a&gt;Dennis Stoyanov의 스케줄러 사용</target>
        </trans-unit>
        <trans-unit id="704f937aee915cf54084238d4d732aaafe152536" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Using Subjects&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;&lt;/a&gt;Dennis Stoyanov의 주제 사용</target>
        </trans-unit>
        <trans-unit id="4848d0a67536767bfc3a46b25a389c6c12411971" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt;&lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt;&lt;/a&gt; from Dennis Stoyanov&amp;rsquo;s RxJS book</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt; &lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt; &lt;/a&gt;Dennis Stoyanov의 RxJS 서적에서 Rx.helpers.pluck (속성)</target>
        </trans-unit>
        <trans-unit id="4d3ad2689ab54eb0e90eeaa55c13b2942af325ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Observable object&lt;/a&gt; (RxJS) by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;&lt;/a&gt;Dennis Stoyanov의 관찰 가능한 객체 (RxJS)</target>
        </trans-unit>
        <trans-unit id="05fc805666c7d298737b623ab15f7e3dc904dae7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;&lt;/a&gt;Dennis Stoyanov의 스케줄러</target>
        </trans-unit>
        <trans-unit id="3189bb2a65685a675d2fc7b27dec30afc63ad7c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;Which Operator do I use?&lt;/a&gt; by Dennis Stoyanov (a similar decision tree, specific to RxJS operators)</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;어떤 연산자를 사용합니까? &lt;/a&gt;Dennis Stoyanov (RxJS 운영자와 유사한 의사 결정 트리)</target>
        </trans-unit>
        <trans-unit id="ce8e12a5cf50d130360fa140e3c6026b7357fde7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html&quot;&gt;Turning a callback into an Rx Observable&lt;/a&gt; by @afterecho</source>
          <target state="translated">&lt;a href=&quot;https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html&quot;&gt;&lt;/a&gt;@afterecho에 의해 콜백을 Rx Observable 로 바꾸기</target>
        </trans-unit>
        <trans-unit id="d451c54e66d39cc9799f024ed509b3bc96bce3c7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Pitfalls of Operator Implementations (part 1)&lt;/a&gt; and &lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90c5beaed2cc1c90c5fe7861f00e4aad4f4a6d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;Advanced RxJava: Subject&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf363991e89c8a0e87e6dfba9b6738ed9428569" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Advanced Reactive Java: SubscribeOn and ObserveOn&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93a2223081711dc6a16e0d515e0ae72c9ea57ff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/lessons/javascript-introducing-the-observable&quot;&gt;Introducing the Observable&lt;/a&gt; by Jafar Husain (JavaScript Video Tutorial)</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/lessons/javascript-introducing-the-observable&quot;&gt;&lt;/a&gt;Jafar Husain 의 Observable 소개 (JavaScript 비디오 자습서)</target>
        </trans-unit>
        <trans-unit id="334e700ad37dedaa75e68b424f31c8fa60b1fb0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/lessons/javascript-using-the-map-method-with-observable&quot;&gt;Using the map method with Observable&lt;/a&gt; by Jafar Husain (JavaScript Video Tutorial)</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/lessons/javascript-using-the-map-method-with-observable&quot;&gt;&lt;/a&gt;Jafar Husain의 Observable과 함께 맵 방법 사용 (JavaScript 비디오 자습서)</target>
        </trans-unit>
        <trans-unit id="cf0782f3a6b69844aa73c07760234981973bbc5f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_number&quot;&gt;triangular numbers&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b97a092a417ac6514a68c890f6e9a31313afc87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877&quot;&gt;&lt;cite&gt;2 minute introduction to Rx&lt;/cite&gt;&lt;/a&gt; by Andre Staltz (&amp;ldquo;Think of an Observable as an asynchronous immutable array.&amp;rdquo;)</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877&quot;&gt;&lt;cite&gt;&lt;/cite&gt;&lt;/a&gt;Andre Staltz의&lt;cite&gt; Rx 소개 2 분&lt;/cite&gt; (&amp;ldquo;비동기 불변의 배열로 Observable을 생각하십시오.&amp;rdquo;)</target>
        </trans-unit>
        <trans-unit id="f57e3b7ba34ac94a726bbf8003c34e5a0fd3f3d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015&quot;&gt;Testing Reactive Applications&lt;/a&gt; by Ben Christensen</source>
          <target state="translated">&lt;a href=&quot;https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015&quot;&gt;&lt;/a&gt;Ben Christensen의 반응 형 응용 프로그램 테스트</target>
        </trans-unit>
        <trans-unit id="c038a5a05f5d042c0ec78b36075a87e20bcb7315" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: Understanding observeOn() and subscribeOn()&lt;/a&gt; by Thomas Nield</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b94d44ddd170ba627080334d6de635cf9dee2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Implementing Your Own Observable Operators&lt;/a&gt; (in RxJS) by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fe549f38289b6afce34aa2e3fca82da4136bd8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Using Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6d766df35d7fb238b4d6047220476f351b1b95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Using Subjects&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640a5616bb195204bbe098f76af869fe354cb507" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt;&lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt;&lt;/a&gt; from Dennis Stoyanov&amp;rsquo;s RxJS book</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d252ced924a06312f6659b0016eb34bf29753054" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Observable object&lt;/a&gt; (RxJS) by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89bc9845079206996bf7fc699562b453e2b49b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c215d1c35116530a5569ecbd77ec8011180980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;Which Operator do I use?&lt;/a&gt; by Dennis Stoyanov (a similar decision tree, specific to RxJS operators)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64d773c526ed13fecf935007c5b8b42451946ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mathematical-and-aggregate-operators#wiki-reduce&quot;&gt;&lt;code&gt;reduce(a)&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;transforming-observables#wiki-scan&quot;&gt;&lt;code&gt;scan(a)&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;filtering-observables#wiki-last&quot;&gt;&lt;code&gt;last( )&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;mathematical-and-aggregate-operators#wiki-reduce&quot;&gt; &lt;code&gt;reduce(a)&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;transforming-observables#wiki-scan&quot;&gt; &lt;code&gt;scan(a)&lt;/code&gt; &lt;/a&gt; 로 정의됩니다 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;filtering-observables#wiki-last&quot;&gt; &lt;code&gt;last( )&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aedba0e61fd807ab73f1bcd257861ff700c36541" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/all&quot;&gt;&lt;code&gt;All&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether all items emitted by an Observable meet some criteria</source>
          <target state="translated">&lt;a href=&quot;operators/all&quot;&gt; &lt;code&gt;All&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 방출 한 모든 항목이 일부 기준을 충족하는지 확인</target>
        </trans-unit>
        <trans-unit id="cf4af39a8182c43692831b7f5254a2e5a28ab5e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/amb&quot;&gt;&lt;code&gt;Amb&lt;/code&gt;&lt;/a&gt; &amp;mdash; given two or more source Observables, emit all of the items from only the first of these Observables to emit an item</source>
          <target state="translated">&lt;a href=&quot;operators/amb&quot;&gt; &lt;code&gt;Amb&lt;/code&gt; &lt;/a&gt; &amp;mdash; 두 개 이상의 소스 Observable이 제공된 경우이 Observable 중 첫 번째 항목에서만 모든 항목을 방출하여 항목을 방출합니다</target>
        </trans-unit>
        <trans-unit id="6abf056e15446abb733a1356236897d0eb88fbc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/and-then-when&quot;&gt;&lt;code&gt;And&lt;/code&gt;/&lt;code&gt;Then&lt;/code&gt;/&lt;code&gt;When&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine sets of items emitted by two or more Observables by means of &lt;code&gt;Pattern&lt;/code&gt; and &lt;code&gt;Plan&lt;/code&gt; intermediaries</source>
          <target state="translated">&lt;a href=&quot;operators/and-then-when&quot;&gt; &lt;code&gt;And&lt;/code&gt; / &lt;code&gt;Then&lt;/code&gt; / &lt;code&gt;When&lt;/code&gt; &lt;/a&gt; &amp;mdash; &lt;code&gt;Pattern&lt;/code&gt; 및 &lt;code&gt;Plan&lt;/code&gt; 중개자를통해 둘 이상의 Observable이 방출 한 항목 세트를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="5ebf0c5f54c5bec720782a934c3ac450d6d61240" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/average&quot;&gt;&lt;code&gt;Average&lt;/code&gt;&lt;/a&gt; &amp;mdash; calculates the average of numbers emitted by an Observable and emits this average</source>
          <target state="translated">&lt;a href=&quot;operators/average&quot;&gt; &lt;code&gt;Average&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 방출 한 수의 평균을 계산하고이 평균을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="e5b94b62bcc7c953efa686abfda740c404bb41fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/backpressure&quot;&gt;&lt;strong&gt;backpressure operators&lt;/strong&gt;&lt;/a&gt; &amp;mdash; strategies for coping with Observables that produce items more rapidly than their observers consume them</source>
          <target state="translated">&lt;a href=&quot;operators/backpressure&quot;&gt;&lt;strong&gt;역압 연산자&lt;/strong&gt;&lt;/a&gt; &amp;mdash; 관찰자가 소비하는 것보다 더 빠르게 항목을 생성하는 Observable에 대처하기위한 전략</target>
        </trans-unit>
        <trans-unit id="f4188b6a7d79bcd68189ca1745286160ac1b4b8b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; &amp;mdash; periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</source>
          <target state="translated">&lt;a href=&quot;operators/buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable에서 주기적으로 항목을 수집하고 한 번에 하나씩 방출하지 않고 이러한 번들을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="af1e7131303f464e9943733bedda780f33c1a666" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/catch&quot;&gt;&lt;code&gt;Catch&lt;/code&gt;&lt;/a&gt; &amp;mdash; recover from an &lt;code&gt;onError&lt;/code&gt; notification by continuing the sequence without error</source>
          <target state="translated">&lt;a href=&quot;operators/catch&quot;&gt; &lt;code&gt;Catch&lt;/code&gt; &lt;/a&gt; &amp;mdash;오류없이 시퀀스를 계속하여 &lt;code&gt;onError&lt;/code&gt; 알림에서 복구</target>
        </trans-unit>
        <trans-unit id="7da57d968e0e4216a34863a171db7ab41b9812ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/combinelatest&quot;&gt;&lt;code&gt;CombineLatest&lt;/code&gt;&lt;/a&gt; &amp;mdash; when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</source>
          <target state="translated">&lt;a href=&quot;operators/combinelatest&quot;&gt; &lt;code&gt;CombineLatest&lt;/code&gt; -&lt;/a&gt; 아이템이 두 개의 Observable 중 하나에 의해 방출 될 때, 지정된 기능을 통해 각 Observable에 의해 방출 된 최신 아이템을 결합하고이 함수의 결과에 따라 아이템을 방출합니다</target>
        </trans-unit>
        <trans-unit id="b5080500198e0f8811c8452bb3beb14dec470f66" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/concat&quot;&gt;&lt;code&gt;Concat&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit the emissions from two or more Observables without interleaving them</source>
          <target state="translated">&lt;a href=&quot;operators/concat&quot;&gt; &lt;code&gt;Concat&lt;/code&gt; &lt;/a&gt; &amp;mdash; 둘 이상의 Observable에서 방출을 방출하지 않고 방출</target>
        </trans-unit>
        <trans-unit id="56ae6daf6671ffcf155c2fa5c4d803d4f7af8682" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/connect&quot;&gt;&lt;code&gt;Connect&lt;/code&gt;&lt;/a&gt; &amp;mdash; instruct a connectable Observable to begin emitting items to its subscribers</source>
          <target state="translated">&lt;a href=&quot;operators/connect&quot;&gt; &lt;code&gt;Connect&lt;/code&gt; &lt;/a&gt; &amp;mdash; 연결 가능한 Observable이 구독자에게 항목을 내보내도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="55e31fa5a564732c4705e3cfc70e314969dc504c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/contains&quot;&gt;&lt;code&gt;Contains&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether an Observable emits a particular item or not</source>
          <target state="translated">&lt;a href=&quot;operators/contains&quot;&gt; &lt;code&gt;Contains&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 특정 항목을 방출하는지 여부를 결정합니다</target>
        </trans-unit>
        <trans-unit id="7bd2683bd64c47ab143020ad6a8b004e6473f895" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/count&quot;&gt;&lt;code&gt;Count&lt;/code&gt;&lt;/a&gt; &amp;mdash; count the number of items emitted by the source Observable and emit only this value</source>
          <target state="translated">&lt;a href=&quot;operators/count&quot;&gt; &lt;code&gt;Count&lt;/code&gt; &lt;/a&gt; &amp;mdash; 소스 Observable에서 방출 한 항목 수를 계산하고이 값만 방출합니다.</target>
        </trans-unit>
        <trans-unit id="b703b9011ffb0e21799b507e8d5b7991453ff2f5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/create&quot;&gt;&lt;code&gt;Create&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable from scratch by calling observer methods programmatically</source>
          <target state="translated">&lt;a href=&quot;operators/create&quot;&gt; &lt;code&gt;Create&lt;/code&gt; &lt;/a&gt; &amp;mdash; 옵저버 메서드를 프로그래밍 방식으로 호출하여 Observable을 처음부터 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d520a5275eeadd415b96286025e57173c2f421ef" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/debounce&quot;&gt;&lt;code&gt;Debounce&lt;/code&gt;&lt;/a&gt; &amp;mdash; only emit an item from an Observable if a particular timespan has passed without it emitting another item</source>
          <target state="translated">&lt;a href=&quot;operators/debounce&quot;&gt; &lt;code&gt;Debounce&lt;/code&gt; &lt;/a&gt; &amp;mdash; 특정 항목이 다른 항목을 방출하지 않고 경과 한 경우에만 Observable에서 항목을 방출합니다</target>
        </trans-unit>
        <trans-unit id="bcbedf41620fc26c55f3a79460e1936597cd6376" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/defaultifempty&quot;&gt;&lt;code&gt;DefaultIfEmpty&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit items from the source Observable, or a default item if the source Observable emits nothing</source>
          <target state="translated">&lt;a href=&quot;operators/defaultifempty&quot;&gt; &lt;code&gt;DefaultIfEmpty&lt;/code&gt; &lt;/a&gt; &amp;mdash; 소스 Observable에서 항목을 내보내거나 소스 Observable에서 아무것도 방출하지 않으면 기본 항목</target>
        </trans-unit>
        <trans-unit id="1ead6b29bf678adce5dda8d26b2b84e8a029610e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/defer&quot;&gt;&lt;code&gt;Defer&lt;/code&gt;&lt;/a&gt; &amp;mdash; do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</source>
          <target state="translated">&lt;a href=&quot;operators/defer&quot;&gt; &lt;code&gt;Defer&lt;/code&gt; &lt;/a&gt; &amp;mdash; 관찰자가 구독 할 때까지 Observable을 작성하지 말고 각 관찰자에 대해 새로운 Observable을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c877468ebfffede1767292c312dce60b414b3e7e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/delay&quot;&gt;&lt;code&gt;Delay&lt;/code&gt;&lt;/a&gt; &amp;mdash; shift the emissions from an Observable forward in time by a particular amount</source>
          <target state="translated">&lt;a href=&quot;operators/delay&quot;&gt; &lt;code&gt;Delay&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable에서 배출량을 특정 시간만큼 앞으로 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="cfd3bc1c02474c98160f5c3daaaf519e81d28a2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/distinct&quot;&gt;&lt;code&gt;Distinct&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress duplicate items emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/distinct&quot;&gt; &lt;code&gt;Distinct&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 생성 한 중복 항목 억제</target>
        </trans-unit>
        <trans-unit id="a0bcec9b0ef7199fdfb5d4143f346557af694831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/do&quot;&gt;&lt;code&gt;Do&lt;/code&gt;&lt;/a&gt; &amp;mdash; register an action to take upon a variety of Observable lifecycle events</source>
          <target state="translated">&lt;a href=&quot;operators/do&quot;&gt; &lt;code&gt;Do&lt;/code&gt; &lt;/a&gt; - 관찰 가능한 라이프 사이클의 다양한 이벤트에 수행 할 작업을 등록</target>
        </trans-unit>
        <trans-unit id="d78138361fd31ace0165e9d2c41fa553949f98a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/elementat&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only item</source>
          <target state="translated">&lt;a href=&quot;operators/elementat&quot;&gt; &lt;code&gt;ElementAt&lt;/code&gt; &lt;/a&gt; &amp;mdash; 항목 만 방출</target>
        </trans-unit>
        <trans-unit id="b8ea48737e4cf7e24239f531b16f54742f291f19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/empty-never-throw&quot;&gt;&lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Never&lt;/code&gt;/&lt;code&gt;Throw&lt;/code&gt;&lt;/a&gt; &amp;mdash; create Observables that have very precise and limited behavior</source>
          <target state="translated">&lt;a href=&quot;operators/empty-never-throw&quot;&gt; &lt;code&gt;Empty&lt;/code&gt; / &lt;code&gt;Never&lt;/code&gt; / &lt;code&gt;Throw&lt;/code&gt; &lt;/a&gt; &amp;mdash; 매우 정확하고 제한된 동작을 갖는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="39d35f0e202be5da8bca269f843088bbc301dc44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only those items from an Observable that pass a predicate test</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/a&gt; &amp;mdash; 조건 자 테스트를 통과 한 Observable에서 해당 항목 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6e10a2781542f87afbf33eb4a144578a352afb60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; (RxScala version of &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; (RxScala 버전의&lt;strong&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="9af7efb0e5277caa8bcb4ca047ec46c742ccb1fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; (alternate name of &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; (&lt;strong&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/strong&gt; 이름 변경)</target>
        </trans-unit>
        <trans-unit id="59b1e5aa586c9c45e855a67c901087f73288790f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/first&quot;&gt;&lt;code&gt;First&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the first item, or the first item that meets a condition, from an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/first&quot;&gt; &lt;code&gt;First&lt;/code&gt; &lt;/a&gt; -Observable에서 첫 번째 항목 또는 조건을 충족하는 첫 번째 항목 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0333194f18a33a7a679904ac05075d80fb58292e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/first&quot;&gt;&lt;code&gt;Next&lt;/code&gt;&lt;/a&gt; (BlockingObservable version)</source>
          <target state="translated">&lt;a href=&quot;operators/first&quot;&gt; &lt;code&gt;Next&lt;/code&gt; &lt;/a&gt; (BlockingObservable 버전)</target>
        </trans-unit>
        <trans-unit id="5e51f771a5f9140c8f1c5f545f5f8d7fa162868d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/flatmap&quot;&gt;&lt;code&gt;FlatMap&lt;/code&gt;&lt;/a&gt; &amp;mdash; transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</source>
          <target state="translated">&lt;a href=&quot;operators/flatmap&quot;&gt; &lt;code&gt;FlatMap&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 배출 한 항목을 Observables로 변환 한 다음 배출물을 단일 Observable로 병합합니다</target>
        </trans-unit>
        <trans-unit id="71f2ef1fb92d5f7acf826243fcc2a2bbb36aecb1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert some other object or data structure into an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; &amp;mdash; 다른 객체 또는 데이터 구조를 Observable로 변환</target>
        </trans-unit>
        <trans-unit id="c784fcd85d0d9eee95eec8546747974634737771" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/groupby&quot;&gt;&lt;code&gt;GroupBy&lt;/code&gt;&lt;/a&gt; &amp;mdash; divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key</source>
          <target state="translated">&lt;a href=&quot;operators/groupby&quot;&gt; &lt;code&gt;GroupBy&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable을 원래 Observable과 다른 항목 그룹을 방출하는 Observable 세트로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="961f7bdad0209a178b650ec75f14ba3dbab617cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/ignoreelements&quot;&gt;&lt;code&gt;IgnoreElements&lt;/code&gt;&lt;/a&gt; &amp;mdash; do not emit any items from an Observable but mirror its termination notification</source>
          <target state="translated">&lt;a href=&quot;operators/ignoreelements&quot;&gt; &lt;code&gt;IgnoreElements&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable에서 항목을 내 보내지 않지만 종료 알림을 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="a7a0c12a44344d7075bd1bab89a82bb9105a316b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a sequence of integers spaced by a particular time interval</source>
          <target state="translated">&lt;a href=&quot;operators/interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; &amp;mdash; 특정 시간 간격으로 간격이 지정된 정수 시퀀스를 방출하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="82c0927b758a710d223a235baa006d1ad82eacf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/join&quot;&gt;&lt;code&gt;Join&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</source>
          <target state="translated">&lt;a href=&quot;operators/join&quot;&gt; &lt;code&gt;Join&lt;/code&gt; &lt;/a&gt; &amp;mdash; 한 Observable의 항목이 다른 Observable이 방출 한 항목에 따라 정의 된 시간 창 동안 방출 될 때마다 두 개의 Observable이 방출 한 항목을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="f789526a11cbf951f3017cad8bb11a7e4f2ae5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/just&quot;&gt;&lt;code&gt;Just&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an object or a set of objects into an Observable that emits that or those objects</source>
          <target state="translated">&lt;a href=&quot;operators/just&quot;&gt; &lt;code&gt;Just&lt;/code&gt; &lt;/a&gt; &amp;mdash; 객체 또는 객체 세트를 Observable로 변환하여 객체 또는 객체를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="f24150c757b2d9fe51daa5b9af6362ed547f642d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/last&quot;&gt;&lt;code&gt;Last&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the last item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/last&quot;&gt; &lt;code&gt;Last&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 마지막으로 방출 한 항목 만 방출합니다</target>
        </trans-unit>
        <trans-unit id="3cfa4568e3237e07a49192561a240de86776b19c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/last&quot;&gt;&lt;code&gt;takeRight&lt;/code&gt;&lt;/a&gt; (see also: &lt;a href=&quot;operators/takelast&quot;&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/last&quot;&gt; &lt;code&gt;takeRight&lt;/code&gt; &lt;/a&gt; (참조 :&lt;a href=&quot;operators/takelast&quot;&gt; &lt;code&gt;TakeLast&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6273a6a4cb7f838288a2e07ef52f0d3d06baaf4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &amp;mdash; transform the items emitted by an Observable by applying a function to each item</source>
          <target state="translated">&lt;a href=&quot;operators/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; &amp;mdash; 각 항목에 함수를 적용하여 Observable에서 방출 한 항목을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9b1ea99f33b2d42aa36a7fc325095d80ff73e6e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/map&quot;&gt;&lt;code&gt;Select&lt;/code&gt;&lt;/a&gt; (alternate name of &lt;strong&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/map&quot;&gt; &lt;code&gt;Select&lt;/code&gt; &lt;/a&gt; (의 대체 이름&lt;strong&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="cce6754f280c0d41eb1e96d9819d872ea7cbb479" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/materialize-dematerialize&quot;&gt;&lt;code&gt;Materialize&lt;/code&gt;/&lt;code&gt;Dematerialize&lt;/code&gt;&lt;/a&gt; &amp;mdash; represent both the items emitted and the notifications sent as emitted items, or reverse this process</source>
          <target state="translated">&lt;a href=&quot;operators/materialize-dematerialize&quot;&gt; &lt;code&gt;Materialize&lt;/code&gt; / 구체화 해제 &lt;code&gt;Dematerialize&lt;/code&gt; &lt;/a&gt; &amp;mdash; 방출 된 항목과 방출 된 항목으로 전송 된 알림을 모두 나타내 거나이 프로세스를 취소합니다</target>
        </trans-unit>
        <trans-unit id="e43ea78d80899fb195485fd3038b95794736c693" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/max&quot;&gt;&lt;code&gt;Max&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine, and emit, the maximum-valued item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/max&quot;&gt; &lt;code&gt;Max&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 방출 한 최대 값 항목을 결정하고 방출합니다.</target>
        </trans-unit>
        <trans-unit id="896d525218ff0dfffdd195a9e6eee022104a5cda" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/merge&quot;&gt;&lt;code&gt;Merge&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine multiple Observables into one by merging their emissions</source>
          <target state="translated">&lt;a href=&quot;operators/merge&quot;&gt; &lt;code&gt;Merge&lt;/code&gt; &lt;/a&gt; &amp;mdash; 배출물을 병합하여 여러 Observable을 하나로 결합</target>
        </trans-unit>
        <trans-unit id="0f540a11749020205078336f04e2c0c14a5a0beb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/min&quot;&gt;&lt;code&gt;Min&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine, and emit, the minimum-valued item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/min&quot;&gt; &lt;code&gt;Min&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 방출 한 최소값 항목을 결정하고 방출합니다.</target>
        </trans-unit>
        <trans-unit id="78c97bac5d1832ec1abde2e15368384c4243e8cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/observeon&quot;&gt;&lt;code&gt;ObserveOn&lt;/code&gt;&lt;/a&gt; &amp;mdash; specify the scheduler on which an observer will observe this Observable</source>
          <target state="translated">&lt;a href=&quot;operators/observeon&quot;&gt; &lt;code&gt;ObserveOn&lt;/code&gt; &lt;/a&gt; &amp;mdash; 관찰자가이 Observable을 관찰 할 스케줄러를 지정합니다</target>
        </trans-unit>
        <trans-unit id="58e4de04374963ac6f0703deddf542b57beab534" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/publish&quot;&gt;&lt;code&gt;Publish&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an ordinary Observable into a connectable Observable</source>
          <target state="translated">&lt;a href=&quot;operators/publish&quot;&gt; &lt;code&gt;Publish&lt;/code&gt; &lt;/a&gt; &amp;mdash; 일반 Observable을 연결 가능한 Observable로 변환</target>
        </trans-unit>
        <trans-unit id="6d19d53dfbba576a9be303d133898023ec0f1468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a range of sequential integers</source>
          <target state="translated">&lt;a href=&quot;operators/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; &amp;mdash; 순차 정수 범위를 방출하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="220d9225db54aea0568c311fb54c1b1af2b03d83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/reduce&quot;&gt;&lt;code&gt;Reduce&lt;/code&gt;&lt;/a&gt; &amp;mdash; apply a function to each item emitted by an Observable, sequentially, and emit the final value</source>
          <target state="translated">&lt;a href=&quot;operators/reduce&quot;&gt; &lt;code&gt;Reduce&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable에서 방출 된 각 항목에 기능을 순차적으로 적용하고 최종 값을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="f2ebff59c0c373b115b3a5c2d65e3f91e16e588e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/refcount&quot;&gt;&lt;code&gt;RefCount&lt;/code&gt;&lt;/a&gt; &amp;mdash; make a Connectable Observable behave like an ordinary Observable</source>
          <target state="translated">&lt;a href=&quot;operators/refcount&quot;&gt; &lt;code&gt;RefCount&lt;/code&gt; &lt;/a&gt; &amp;mdash; Connectable Observable을 일반 Observable처럼 동작하게합니다.</target>
        </trans-unit>
        <trans-unit id="e6ec521fdbc793707013621bfc8fb2ba153a0cd8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/repeat&quot;&gt;&lt;code&gt;Repeat&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a particular item or sequence of items repeatedly</source>
          <target state="translated">&lt;a href=&quot;operators/repeat&quot;&gt; &lt;code&gt;Repeat&lt;/code&gt; &lt;/a&gt; &amp;mdash; 특정 항목이나 항목 시퀀스를 반복적으로 방출하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2804cd9e5f0367f7c9558927abf3a72ef9c06ac4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/replay&quot;&gt;&lt;code&gt;Replay&lt;/code&gt;&lt;/a&gt; &amp;mdash; ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</source>
          <target state="translated">&lt;a href=&quot;operators/replay&quot;&gt; &lt;code&gt;Replay&lt;/code&gt; &lt;/a&gt; -Observable이 항목을 방출하기 시작한 후에 구독하더라도 모든 관찰자가 동일한 시퀀스의 방출 된 항목을 볼 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="00ec748f863300265c910192f8f5af498feb4f55" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/retry&quot;&gt;&lt;code&gt;Retry&lt;/code&gt;&lt;/a&gt; &amp;mdash; if a source Observable sends an &lt;code&gt;onError&lt;/code&gt; notification, resubscribe to it in the hopes that it will complete without error</source>
          <target state="translated">&lt;a href=&quot;operators/retry&quot;&gt; &lt;code&gt;Retry&lt;/code&gt; &lt;/a&gt; &amp;mdash; 소스 Observable이 &lt;code&gt;onError&lt;/code&gt; 알림을보내는 경우오류없이 완료 될 수 있도록 다시 구독합니다.</target>
        </trans-unit>
        <trans-unit id="fe03930f3581f4dad5c8a3922092b89e1191d93d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sample&quot;&gt;&lt;code&gt;Sample&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit the most recent item emitted by an Observable within periodic time intervals</source>
          <target state="translated">&lt;a href=&quot;operators/sample&quot;&gt; &lt;code&gt;Sample&lt;/code&gt; &lt;/a&gt; &amp;mdash; 정기적으로 Observable이 방출 한 가장 최근 항목을 방출합니다</target>
        </trans-unit>
        <trans-unit id="d75c698d2f0fe31254942270f4f860c2edd619a3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/scan&quot;&gt;&lt;code&gt;Scan&lt;/code&gt;&lt;/a&gt; &amp;mdash; apply a function to each item emitted by an Observable, sequentially, and emit each successive value</source>
          <target state="translated">&lt;a href=&quot;operators/scan&quot;&gt; &lt;code&gt;Scan&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable에서 방출 된 각 항목에 기능을 순차적으로 적용하고 각 연속 값을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="eb4dcaeae3f881353f0198da0ed07774810c96e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sequenceequal&quot;&gt;&lt;code&gt;SequenceEqual&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether two Observables emit the same sequence of items</source>
          <target state="translated">&lt;a href=&quot;operators/sequenceequal&quot;&gt; &lt;code&gt;SequenceEqual&lt;/code&gt; &lt;/a&gt; &amp;mdash; 두 개의 Observable이 동일한 항목 시퀀스를 방출하는지 확인</target>
        </trans-unit>
        <trans-unit id="ca9082009ddd16283a5a15007359dd764bf941bf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/serialize&quot;&gt;&lt;code&gt;Serialize&lt;/code&gt;&lt;/a&gt; &amp;mdash; force an Observable to make serialized calls and to be well-behaved</source>
          <target state="translated">&lt;a href=&quot;operators/serialize&quot;&gt; &lt;code&gt;Serialize&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 직렬화 된 호출을 수행하고 올바르게 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="3c5b3dde082c7f134651c5c0ee0f77c10d8849f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skip&quot;&gt;&lt;code&gt;Skip&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress the first</source>
          <target state="translated">&lt;a href=&quot;operators/skip&quot;&gt; &lt;code&gt;Skip&lt;/code&gt; &lt;/a&gt; &amp;mdash; 첫 번째 억제</target>
        </trans-unit>
        <trans-unit id="57c550f6342285873d1251001f507a49dd499b9a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skiplast&quot;&gt;&lt;code&gt;SkipLast&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress the last</source>
          <target state="translated">&lt;a href=&quot;operators/skiplast&quot;&gt; &lt;code&gt;SkipLast&lt;/code&gt; &lt;/a&gt; &amp;mdash; 마지막을 억제</target>
        </trans-unit>
        <trans-unit id="e4091fcbf30f6cac5a853be94132763f8026869c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skipuntil&quot;&gt;&lt;code&gt;SkipUntil&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable until a second Observable emits an item</source>
          <target state="translated">&lt;a href=&quot;operators/skipuntil&quot;&gt; &lt;code&gt;SkipUntil&lt;/code&gt; &lt;/a&gt; &amp;mdash; 두 번째 Observable이 항목을 방출 할 때까지 Observable이 방출 한 항목을 버립니다.</target>
        </trans-unit>
        <trans-unit id="7a2508b5d42729a80bcadabbd948ac432565126f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skipwhile&quot;&gt;&lt;code&gt;SkipWhile&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">&lt;a href=&quot;operators/skipwhile&quot;&gt; &lt;code&gt;SkipWhile&lt;/code&gt; &lt;/a&gt; &amp;mdash; 지정된 조건이 거짓이 될 때까지 Observable이 방출 한 항목을 버립니다.</target>
        </trans-unit>
        <trans-unit id="715557b9c7b5c8b25056c589cc3f188f11be2cc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/start&quot;&gt;&lt;code&gt;Start&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits the return value of a function</source>
          <target state="translated">&lt;a href=&quot;operators/start&quot;&gt; &lt;code&gt;Start&lt;/code&gt; &lt;/a&gt; &amp;mdash; 함수의 반환 값을 방출하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8a16879f166f96ec4f6c887a4b17c95425000b2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/startwith&quot;&gt;&lt;code&gt;StartWith&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit a specified sequence of items before beginning to emit the items from the source Observable</source>
          <target state="translated">&lt;a href=&quot;operators/startwith&quot;&gt; &lt;code&gt;StartWith&lt;/code&gt; &lt;/a&gt; &amp;mdash; 소스 Observable에서 항목을 방출하기 전에 지정된 항목 시퀀스를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="d0ff74e8a6826625e34447a02f61eea2babf5abb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribe&quot;&gt;&lt;code&gt;Subscribe&lt;/code&gt;&lt;/a&gt; &amp;mdash; operate upon the emissions and notifications from an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/subscribe&quot;&gt; &lt;code&gt;Subscribe&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable의 배출 및 알림에 따라 작동</target>
        </trans-unit>
        <trans-unit id="1b8c65f3783b491e2da19c9577fc47f408f83f9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribe&quot;&gt;The &lt;code&gt;Subscribe&lt;/code&gt; method&lt;/a&gt; is how you connect an observer to an Observable. Your observer implements some subset of the following methods:</source>
          <target state="translated">&lt;a href=&quot;operators/subscribe&quot;&gt;은 &lt;code&gt;Subscribe&lt;/code&gt; 방법은&lt;/a&gt; 당신이 관찰 가능한에 관찰자를 연결하는 방법입니다. 관찰자는 다음 방법 중 일부를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="20bd35f3cd630e6729cd59d5f5871941dbba7336" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribeon&quot;&gt;&lt;code&gt;SubscribeOn&lt;/code&gt;&lt;/a&gt; &amp;mdash; specify the scheduler an Observable should use when it is subscribed to</source>
          <target state="translated">&lt;a href=&quot;operators/subscribeon&quot;&gt; &lt;code&gt;SubscribeOn&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 구독 할 때 사용해야하는 스케줄러를 지정합니다</target>
        </trans-unit>
        <trans-unit id="f2c9b8fa32c3e32960d4065945b8d21ee9ae586d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sum&quot;&gt;&lt;code&gt;Sum&lt;/code&gt;&lt;/a&gt; &amp;mdash; calculate the sum of numbers emitted by an Observable and emit this sum</source>
          <target state="translated">&lt;a href=&quot;operators/sum&quot;&gt; &lt;code&gt;Sum&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable에서 방출 한 숫자의 합계를 계산하고이 합계를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fff5479ffc0e2648d627b6a506e5a3ac0a369e95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sum&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; (string)</source>
          <target state="translated">&lt;a href=&quot;operators/sum&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; (문자열)</target>
        </trans-unit>
        <trans-unit id="12270334cc52f8a9daf70d2dd8a4a15c526d5d82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/switch&quot;&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</source>
          <target state="translated">&lt;a href=&quot;operators/switch&quot;&gt; &lt;code&gt;Switch&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable을 방출하는 Observable을 단일 Observable로 변환하여 가장 최근에 방출 된 Observable이 방출 한 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="18cfa275521a80308ec35ddf6041423b53915ce9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/switch&quot;&gt;&lt;code&gt;latest&lt;/code&gt;&lt;/a&gt; (Rx.rb version of &lt;strong&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/switch&quot;&gt; &lt;code&gt;latest&lt;/code&gt; &lt;/a&gt; (Rx.rb 버전의&lt;strong&gt; &lt;code&gt;Switch&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="c512d0a45fbef14a0ca00b1ba15611f0f470c5fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/take&quot;&gt;&lt;code&gt;Take&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the first</source>
          <target state="translated">&lt;a href=&quot;operators/take&quot;&gt; &lt;code&gt;Take&lt;/code&gt; &lt;/a&gt; &amp;mdash; 첫 번째 만 방출</target>
        </trans-unit>
        <trans-unit id="2f2c659ea7a1fbd932f5dfd6f64cbda8bd8e8b88" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takelast&quot;&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the last</source>
          <target state="translated">&lt;a href=&quot;operators/takelast&quot;&gt; &lt;code&gt;TakeLast&lt;/code&gt; &lt;/a&gt; &amp;mdash; 마지막 만 방출</target>
        </trans-unit>
        <trans-unit id="40a4532cb238dde4e68093af52658f5445b11adf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takeuntil&quot;&gt;&lt;code&gt;TakeUntil&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable after a second Observable emits an item or terminates</source>
          <target state="translated">&lt;a href=&quot;operators/takeuntil&quot;&gt; &lt;code&gt;TakeUntil&lt;/code&gt; &lt;/a&gt; &amp;mdash; 두 번째 Observable이 항목을 방출하거나 종료 한 후 Observable이 방출 한 항목을 버립니다.</target>
        </trans-unit>
        <trans-unit id="92a388db3da085f5150944c06f479a2f12efe907" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takewhile&quot;&gt;&lt;code&gt;TakeWhile&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable after a specified condition becomes false</source>
          <target state="translated">&lt;a href=&quot;operators/takewhile&quot;&gt; &lt;code&gt;TakeWhile&lt;/code&gt; &lt;/a&gt; &amp;mdash; 지정된 조건이 false가 된 후 Observable이 방출 한 항목을 버립니다.</target>
        </trans-unit>
        <trans-unit id="90712fbd60a57bf67f06b86afd680c3c52c8c0e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timeinterval&quot;&gt;&lt;code&gt;TimeInterval&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</source>
          <target state="translated">&lt;a href=&quot;operators/timeinterval&quot;&gt; &lt;code&gt;TimeInterval&lt;/code&gt; &lt;/a&gt; &amp;mdash; 아이템을 방출하는 Observable을 배출물 사이의 경과 시간을 나타내는 것으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="56fae76408c63619174d789717205ca81e57c61d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timeout&quot;&gt;&lt;code&gt;Timeout&lt;/code&gt;&lt;/a&gt; &amp;mdash; mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</source>
          <target state="translated">&lt;a href=&quot;operators/timeout&quot;&gt; &lt;code&gt;Timeout&lt;/code&gt; &lt;/a&gt; &amp;mdash; 소스 Observable을 미러링하지만 특정 항목이 방출 된 항목없이 경과하면 오류 알림을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="17b4d7785cee0739e289b4511c57a47b43fb0a69" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timer&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a single item after a given delay</source>
          <target state="translated">&lt;a href=&quot;operators/timer&quot;&gt; &lt;code&gt;Timer&lt;/code&gt; &lt;/a&gt; &amp;mdash; 주어진 지연 후 단일 항목을 방출하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8153fd468994e7f23f93090e11c64478da3a861a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; &amp;mdash; attach a timestamp to each item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/timestamp&quot;&gt; &lt;code&gt;Timestamp&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable이 방출 한 각 항목에 타임 스탬프를 첨부합니다</target>
        </trans-unit>
        <trans-unit id="08036d386b50af7605f69d72032e90ec9b7ae3be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/to&quot;&gt;&lt;code&gt;To&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable into another object or data structure</source>
          <target state="translated">&lt;a href=&quot;operators/to&quot;&gt; &lt;code&gt;To&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable을 다른 객체 또는 데이터 구조로 변환</target>
        </trans-unit>
        <trans-unit id="a27441bb348b701709f46ba2a9e1fd000edbe104" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/using&quot;&gt;&lt;code&gt;Using&lt;/code&gt;&lt;/a&gt; &amp;mdash; create a disposable resource that has the same lifespan as the Observable</source>
          <target state="translated">&lt;a href=&quot;operators/using&quot;&gt; &lt;code&gt;Using&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable과 수명이 동일한 일회용 자원을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4e7798a9984bb26f086d17dce14b65fb99ceeb7d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; &amp;mdash; periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</source>
          <target state="translated">&lt;a href=&quot;operators/window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt; &amp;mdash; Observable에서 Observable 창으로 항목을 주기적으로 세분화하고 한 번에 하나씩 방출하지 않고 이러한 창을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c5cf183eb5d366413ed5d5c204d8b7fa6f3b0e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;Zip&lt;/code&gt; &lt;/a&gt; &amp;mdash; 지정된 기능을 통해 여러 Observable의 배출물을 결합하고이 기능의 결과에 따라 각 조합에 대해 단일 항목을 방출합니다</target>
        </trans-unit>
        <trans-unit id="1d6d8e38830f49548b2c4afc11148786a0b1e918" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; (RxClojure version of &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; (RxClojure 버전의&lt;strong&gt; &lt;code&gt;Zip&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="79293a7f079b9373f12db529fcf04630f0840459" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;mapCat&lt;/code&gt;&lt;/a&gt; (RxClojure version of &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;mapCat&lt;/code&gt; &lt;/a&gt; (RxClojure 버전의&lt;strong&gt; &lt;code&gt;Zip&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="bc842fac1c68ceb5773485119db93147ac0c6b6e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;single&quot;&gt;&lt;tt&gt;Single&lt;/tt&gt;&lt;/a&gt; &amp;mdash; a specialized version of an Observable that emits only a single item</source>
          <target state="translated">&lt;a href=&quot;single&quot;&gt;&lt;tt&gt;단일&lt;/tt&gt;&lt;/a&gt; -단일 항목 만 방출하는 특수한 버전의 Observable</target>
        </trans-unit>
        <trans-unit id="84438b704c9fca4e5527512cd5c27340544d75ab" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Buffer &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 버퍼-단순</target>
        </trans-unit>
        <trans-unit id="8e3999cc1a087194796f932be496866a6f0182c3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: CombineLatest</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : CombineLatest</target>
        </trans-unit>
        <trans-unit id="9dfeeecdc7b7288e5ea70c6c892c1d944664cf48" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: CombineLatest &amp;mdash; Parallel Execution</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : CombineLatest &amp;mdash; 병렬 실행</target>
        </trans-unit>
        <trans-unit id="f6b4feb080d4814c3633843d31049b4ae614c799" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Concat &amp;mdash; cold observable</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : Concat-냉간 관측 가능</target>
        </trans-unit>
        <trans-unit id="c0e2ed6732260c865ef6eccba85b4ddc0466e81a" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Concat &amp;mdash; hot observable</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : Concat &amp;mdash; 고온 관찰 가능</target>
        </trans-unit>
        <trans-unit id="7f1e8f5e8387df20c1e2eec385011ae6468129f3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Delay &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 지연 &amp;mdash; 단순</target>
        </trans-unit>
        <trans-unit id="e9cd41c26800564ad47aa6441382096c455b8e77" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Generate</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 생성</target>
        </trans-unit>
        <trans-unit id="b9ed1f3ab8250846a6b02df43301b10c649c335e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: GroupJoin &amp;mdash; Joins two streams by matching by one of their attributes</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : GroupJoin &amp;mdash; 속성 중 하나를 일치시켜 두 스트림을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="f4a401a286d1a0539e3f17195639b2743803c2c5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: ISubject&amp;lt;T&amp;gt; and ISubject&amp;lt;T1,T2&amp;gt;</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : ISubject &amp;lt;T&amp;gt; 및 ISubject &amp;lt;T1, T2&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4497c7c8e023a9337eb5395666b4310b2d91e7e8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Interval &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 간격 &amp;mdash; 단순</target>
        </trans-unit>
        <trans-unit id="a953c40a21409172145703f425a7a60796dd5e88" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Interval &amp;mdash; With TimeInterval()</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 간격 &amp;mdash; With TimeInterval ()</target>
        </trans-unit>
        <trans-unit id="65190ea0c6ca0b42f3664eb352fbfe370afd6443" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Merge</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 병합</target>
        </trans-unit>
        <trans-unit id="38e8128889f9b5776897d04d41bfbd2cef9c6fde" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Observation Operators</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 관찰 연산자</target>
        </trans-unit>
        <trans-unit id="49730b290b423f322940dab1ff7061f932845d63" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Observing the Passing of Time</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 시간의 경과를 관찰</target>
        </trans-unit>
        <trans-unit id="bdfc989ca6ffd7c7cbf77916f7081d7bbbcf3c03" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Publish &amp;mdash; Sharing a subscription with multiple Observers</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Publish &amp;mdash; 여러 관찰자와 구독 공유</target>
        </trans-unit>
        <trans-unit id="82e1b94cb3df3df1bc50246ed5e11b9d9a413f3e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Range</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 범위</target>
        </trans-unit>
        <trans-unit id="fd72099514d7ac2d1520ae4b1cd03541ecb3d75b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Sample &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 샘플-단순</target>
        </trans-unit>
        <trans-unit id="9d5982dbcf362e5fe59b0b1a74ae7c356eb14b62" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Select &amp;mdash; Indexed</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 선택 &amp;mdash; 인덱싱</target>
        </trans-unit>
        <trans-unit id="758e63347c494706666595c451133580e55bb6b1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Start &amp;mdash; Run Code Asynchronously</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : 시작 &amp;mdash; 코드를 비동기 적으로 실행</target>
        </trans-unit>
        <trans-unit id="c2323d4a4016773c83f1325ef75d2d80d33e98d7" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Throttle &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 스로틀-단순</target>
        </trans-unit>
        <trans-unit id="d228cb755846dd4e2bab50fb5eab415316bfec1c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timeout &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 타임 아웃 &amp;mdash; 단순</target>
        </trans-unit>
        <trans-unit id="002c8dac44d68094923f2810a86c6d928664e2f1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timer &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 타이머 &amp;mdash; 단순</target>
        </trans-unit>
        <trans-unit id="8cb1c8d362fc1bea83ee3e202602ece035e7c32e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timestamp</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="6ee1829693fce377b6ff46cbe5704191231dfef0" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Window</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : 윈도우</target>
        </trans-unit>
        <trans-unit id="7e1cda1b914a8d023f1dc4d23b17ff394f90c636" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Zip</source>
          <target state="translated">&lt;cite&gt;101 Rx 샘플&lt;/cite&gt; : Zip</target>
        </trans-unit>
        <trans-unit id="a4bda5dfe90db399b7c4b0b87d01c88b07162ee5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;DebounceBuffer: Use publish(), debounce() and buffer() together to capture bursts of events.&lt;/cite&gt; by Ben Christensen</source>
          <target state="translated">&lt;cite&gt;DebounceBuffer : publish (), debounce () 및 buffer ()를 함께 사용하여 버스트 이벤트를 캡처하십시오. &lt;/cite&gt;벤 크리스텐슨</target>
        </trans-unit>
        <trans-unit id="a2c0ae8f6836ea32e237cbdd5a36d5da68d09d69" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;DebouncedBuffer With RxJava&lt;/cite&gt; by Gopal Kaushik</source>
          <target state="translated">&lt;cite&gt;&lt;/cite&gt;Gopal Kaushik의 &lt;cite&gt;RxJava&lt;/cite&gt; 로 &lt;cite&gt;DebouncedBuffer&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="eda16f284575e40f90ac1dc6981b546622a0c621" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Aggregate</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 집계</target>
        </trans-unit>
        <trans-unit id="29247369a4b0d247d97753a93d41653acdcc1b2c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: All</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 모두</target>
        </trans-unit>
        <trans-unit id="93019059f558486ba0ef91989fbb8dc88733b68e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: And-Then-When</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : And-Then-When</target>
        </trans-unit>
        <trans-unit id="dc360128e41bbeba319356f06f179ae8502f246c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: AsyncSubject</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : AsyncSubject</target>
        </trans-unit>
        <trans-unit id="035b87099a1834a0e066b29f62655685da21f8a6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: BehaviorSubject</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="8bc61a26f41cc061366ee6101362cf6f70d41f1b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Buffer</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 버퍼</target>
        </trans-unit>
        <trans-unit id="5b117e897e1a17fe032c5af3a2ce613ff6014d11" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Buffer revisited</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 버퍼 재검토</target>
        </trans-unit>
        <trans-unit id="ab41ea4f239b99143925cd4be6c94ac1e3cfefa7" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Cast and OfType</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : Cast and OfType</target>
        </trans-unit>
        <trans-unit id="dd718e0e229c64fe1688ec231dd8353c9a412db9" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Catch</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 캐치</target>
        </trans-unit>
        <trans-unit id="b321cc1c9b76079278935ccb62bff36d39200bc5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: CombineLatest</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : CombineLatest</target>
        </trans-unit>
        <trans-unit id="116fa0f10acbbeea88e8d3059138b6ffe66c5444" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Concat</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : Concat</target>
        </trans-unit>
        <trans-unit id="1528f7d4c47527e0e461233c282602ab6d7c644e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Contains</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 포함</target>
        </trans-unit>
        <trans-unit id="3cbe58edf946b3f8dfb0bb7c462598c80afc1e93" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Count</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 카운트</target>
        </trans-unit>
        <trans-unit id="c35d04abcc5dd65704022c34cf83804415cc2818" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Create</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 만들기</target>
        </trans-unit>
        <trans-unit id="c1fd0c382a8358907465f71dddc50255a92ecd52" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: DefaultIfEmpty</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : DefaultIfEmpty</target>
        </trans-unit>
        <trans-unit id="b0b4c1fb3d3566c798e145f7923dc2a08228d7a6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Delay</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 지연</target>
        </trans-unit>
        <trans-unit id="b54a5e164dffee3139f0b8af5169e80489a8e13b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Distinct and DistinctUntilChanged</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 구별 및 구별</target>
        </trans-unit>
        <trans-unit id="777d04576f3bc70403fbe3a7bb1a9372ec841588" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Do</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : Do</target>
        </trans-unit>
        <trans-unit id="8eb3452c0d7a0dadb569326b2e61144cf85c9fd3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ElementAt and ElementAtUntilChanged</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : ElementAt 및 ElementAtUntilChanged</target>
        </trans-unit>
        <trans-unit id="102fcee9f7ec081921ab59ef89ed1c5e6b30e5de" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Finally</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 마지막으로</target>
        </trans-unit>
        <trans-unit id="23ea11e182295d6ed28a6220510e239e26b5282e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: First</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 첫 번째</target>
        </trans-unit>
        <trans-unit id="c115a63e4865e74a4f8c5c291e91b00b3a150355" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Generate</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 생성</target>
        </trans-unit>
        <trans-unit id="60542fbfdcd01dc53807bc0478ce040a8e2f6f10" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: GroupBy</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : GroupBy</target>
        </trans-unit>
        <trans-unit id="540568cfdc74e1f0a4c7b8678fd0356e93246f46" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: GroupJoin</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : GroupJoin</target>
        </trans-unit>
        <trans-unit id="6339c110750aea5eb774297c37884bfcde2b0f79" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IObservable</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : IObservable</target>
        </trans-unit>
        <trans-unit id="c3d98673531f7a8b8b3f9e8256945795eeabd6f8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IObserver</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : IObserver</target>
        </trans-unit>
        <trans-unit id="fd627340831e496d98293a5f69462983384dde95" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IgnoreElements</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : IgnoreElements</target>
        </trans-unit>
        <trans-unit id="62256229d5203f226886b8e64e6ea284cf6957eb" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Interval</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 간격</target>
        </trans-unit>
        <trans-unit id="0c4474d3483ee629a00095c34b8d299693d81065" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Join</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 가입</target>
        </trans-unit>
        <trans-unit id="87545688a3ea5ebc6e25e2842e72c8dd9c5d1e62" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Last</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 마지막</target>
        </trans-unit>
        <trans-unit id="0de669709c1879b9f542aa4f94c433bcc8290782" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Leaving the monad</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 모나드 떠나기</target>
        </trans-unit>
        <trans-unit id="1ec1f4dfc1029c5aa7773b137724641aade3c9a3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Materialize and Dematerialize</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 구체화 및 구체화 해제</target>
        </trans-unit>
        <trans-unit id="b04f7fc5eb7b8ba52c2a9a92360ca02e81cf40ad" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Merge</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 병합</target>
        </trans-unit>
        <trans-unit id="fa7869d155329c64ed405fc5786876dad056073d" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Min, Max, Sum, and Average</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : Min, Max, Sum 및 Average</target>
        </trans-unit>
        <trans-unit id="d365b1eb7a9536f57568dab1fe5dd916f25bda8d" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Publish &amp;amp; Connect</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 게시 및 연결</target>
        </trans-unit>
        <trans-unit id="e878ce5258868ac3eb4fdf5d6843d2c8b3a76f7b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Range</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 범위</target>
        </trans-unit>
        <trans-unit id="c1cf07af2c8eace50997f716a98f99e4c0971f00" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: RefCount</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : RefCount</target>
        </trans-unit>
        <trans-unit id="084764999a741c143088232da1c0321b35e44092" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Repeat</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 반복</target>
        </trans-unit>
        <trans-unit id="26de299ed749b577f696b62b39924a8a9e30ef6b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Replay</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 재생</target>
        </trans-unit>
        <trans-unit id="c06a12ff37836439265ffeb4d10fc8154fcfaa4f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ReplaySubject</source>
          <target state="translated">&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ReplaySubject</target>
        </trans-unit>
        <trans-unit id="b30bd9ac68d920b64f5efe285e03d588837291f5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Retry</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 재시도</target>
        </trans-unit>
        <trans-unit id="54854f0097fa9244f288e39b24e48e27f8b83e4b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Return</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 리턴</target>
        </trans-unit>
        <trans-unit id="79e2be634bb26a274d4fdf88c706025ebeaa2d11" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Sample</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 샘플</target>
        </trans-unit>
        <trans-unit id="1e1001379cadd511d49b86bafe6e12c95acd7607" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Scan</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 스캔</target>
        </trans-unit>
        <trans-unit id="dc0d36e7e05dd4add274fb3feede439a3a19fa5b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Scheduling and Threading</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 스케줄링 및 스레딩</target>
        </trans-unit>
        <trans-unit id="d7dab96b686167a434b97d22488b8cb79d6c5417" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Select</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 선택</target>
        </trans-unit>
        <trans-unit id="477286cb919491f0f63e72a8903656eb7a6282c1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SelectMany</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : SelectMany</target>
        </trans-unit>
        <trans-unit id="ee1800b1d9f701e32bfd1c70be2fcb64008e74f8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SequenceEqual</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : SequenceEqual</target>
        </trans-unit>
        <trans-unit id="ed818ec833039363080c9f8f4e89173be2b16966" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Simple Factory Methods</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 간단한 팩토리 메소드</target>
        </trans-unit>
        <trans-unit id="fd00bb3e997d8645bdf8fe33420a70c94cda4c6e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Single</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 단일</target>
        </trans-unit>
        <trans-unit id="b745a93a790b9dad2a52091e6386fcbbc51de6ee" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Skip and Take</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="1443306acabe169cf8f390ed1c3f8bbc6913bfee" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipLast and TakeLast</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : SkipLast 및 TakeLast</target>
        </trans-unit>
        <trans-unit id="5cfe8d6a7fee34f4bb8d00922555c4a8c705669f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipUntil and TakeUntil</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : SkipUntil 및 TakeUntil</target>
        </trans-unit>
        <trans-unit id="b6650c255e70bfd3620e12c3cc72fedf90eadf2e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipWhile and TakeWhile</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : SkipWhile 및 TakeWhile</target>
        </trans-unit>
        <trans-unit id="8cc66b563aabc4fbedb00d8119ba74bacef0ab41" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: StartWith</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : StartWith</target>
        </trans-unit>
        <trans-unit id="9086b49d24c6b80e0f6a79b601213b2ce91d13b5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Subject</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 주제</target>
        </trans-unit>
        <trans-unit id="9a983fed5c5e768256355b29f51e96fa5bbb549e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SubscribeOn and ObserveOn</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : SubscribeOn 및 ObserveOn</target>
        </trans-unit>
        <trans-unit id="83b0d127d96097cab2795ab626cee0a49915b626" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Switch</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 스위치</target>
        </trans-unit>
        <trans-unit id="598171f79ea0f898758ff883e3ad03569f596954" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Throttle</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 스로틀</target>
        </trans-unit>
        <trans-unit id="c2b85e9531a48451320c69fba5b56201a54cdb7f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timeout</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 타임 아웃</target>
        </trans-unit>
        <trans-unit id="e98b8b62bdf570f0a4177044a6de1ba2c46e8d5c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timer</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 타이머</target>
        </trans-unit>
        <trans-unit id="7aaa2e22718c5ee322409e5e0fbbf4c9fbefbd6c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timestamp and TimeInterval</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 타임 스탬프 및 TimeInterval</target>
        </trans-unit>
        <trans-unit id="8b1306a6995c5be8256f3ea632e95419c48355f6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Using</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 사용</target>
        </trans-unit>
        <trans-unit id="82e2eaaf295a67907acba8525225401373b5b6e8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Where</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 어디서</target>
        </trans-unit>
        <trans-unit id="88acce28317e2934f05b0089a12e44c31a31df21" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Window</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : 창</target>
        </trans-unit>
        <trans-unit id="311056bb87e8631686c9a13f7a9aa24b48a750b3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Zip</source>
          <target state="translated">&lt;cite&gt;Rx 소개&lt;/cite&gt; : Zip</target>
        </trans-unit>
        <trans-unit id="6c9f75058fd74c2e40d3fbad984b2426f71c5f1b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Microsoft Developer Network&lt;/cite&gt;: &amp;ldquo;What does the new ManySelect operator do?&amp;rdquo;</source>
          <target state="translated">&lt;cite&gt;Microsoft Developer Network&lt;/cite&gt; :&amp;ldquo;새로운 ManySelect 연산자는 무엇을합니까?&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a2513d452931404692c534110e17b00bb086db47" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;Rx 설계 지침&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="f16b13d1d2d48a4ab59af38cc3f2786f48280ae9" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop: Schedulers&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;Rx 워크숍 : 스케줄러&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="69b16a529d6fb7f077c4e534c2ba8a41a8b5195c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop&lt;/cite&gt;: Introduction</source>
          <target state="translated">&lt;cite&gt;Rx 워크숍&lt;/cite&gt; : 소개</target>
        </trans-unit>
        <trans-unit id="5e372f7712619b05579788c28d99a8619d24c02b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop&lt;/cite&gt;: Schedulers</source>
          <target state="translated">&lt;cite&gt;Rx Workshop&lt;/cite&gt; : 스케줄러</target>
        </trans-unit>
        <trans-unit id="5060b2e8a80327e13489eab521802fc2c1470513" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;RxJS Design Guidelines&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;RxJS 설계 지침&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="84472df2bda697a25594c7286ae6152a2914a3d3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;RxJava Threading Examples&lt;/cite&gt; by Graham Lea</source>
          <target state="translated">&lt;cite&gt;&lt;/cite&gt;Graham Lea의 &lt;cite&gt;RxJava 스레딩 예제&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="3c89a5198e1f457a5def50b38dd05269b98b494b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;StackOverflow&lt;/cite&gt;: What is a &amp;ldquo;Scheduler&amp;rdquo; in RxJS</source>
          <target state="translated">&lt;cite&gt;StackOverflow&lt;/cite&gt; : RxJS의 &quot;스케줄러&quot;란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="99ad2748ced1a268c1da5ba38bef169ec3221a63" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;ad-hockery&lt;/cite&gt;: Simple Background Polling with RxJava</source>
          <target state="translated">&lt;cite&gt;ad-hockery&lt;/cite&gt; : &lt;cite&gt;RxJava를 사용한&lt;/cite&gt; 간단한 백그라운드 폴링</target>
        </trans-unit>
        <trans-unit id="fdc895a0d19a290d9d7e1ce1ff10f8f31be62c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt;. This behaves similarly to &lt;code&gt;stopAndWait&lt;/code&gt; but has an internal buffer of</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; . 이것은 &lt;code&gt;stopAndWait&lt;/code&gt; 과 유사하게 작동 하지만 내부 버퍼는</target>
        </trans-unit>
        <trans-unit id="ee8c7fe962e91ed4b8f8c0b825242e59e8443a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;All&lt;/code&gt;, &lt;code&gt;Amb&lt;/code&gt;, &lt;code&gt;Contains&lt;/code&gt;, &lt;code&gt;DefaultIfEmpty&lt;/code&gt;, &lt;code&gt;SequenceEqual&lt;/code&gt;, &lt;code&gt;SkipUntil&lt;/code&gt;, &lt;code&gt;SkipWhile&lt;/code&gt;, &lt;code&gt;TakeUntil&lt;/code&gt;, and &lt;code&gt;TakeWhile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;All&lt;/code&gt; , &lt;code&gt;Amb&lt;/code&gt; , &lt;code&gt;Contains&lt;/code&gt; , &lt;code&gt;DefaultIfEmpty&lt;/code&gt; , &lt;code&gt;SequenceEqual&lt;/code&gt; , &lt;code&gt;SkipUntil&lt;/code&gt; , &lt;code&gt;SkipWhile&lt;/code&gt; , &lt;code&gt;TakeUntil&lt;/code&gt; 및 &lt;code&gt;TakeWhile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6d4b2413273db5421b89d5d4bf5bbc759de0ea7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;And&lt;/code&gt;/&lt;code&gt;Then&lt;/code&gt;/&lt;code&gt;When&lt;/code&gt;, &lt;code&gt;CombineLatest&lt;/code&gt;, &lt;code&gt;Join&lt;/code&gt;, &lt;code&gt;Merge&lt;/code&gt;, &lt;code&gt;StartWith&lt;/code&gt;, &lt;code&gt;Switch&lt;/code&gt;, and &lt;code&gt;Zip&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;And&lt;/code&gt; / &lt;code&gt;Then&lt;/code&gt; / &lt;code&gt;When&lt;/code&gt; , &lt;code&gt;CombineLatest&lt;/code&gt; , &lt;code&gt;Join&lt;/code&gt; , &lt;code&gt;Merge&lt;/code&gt; , &lt;code&gt;StartWith&lt;/code&gt; , &lt;code&gt;Switch&lt;/code&gt; 및 &lt;code&gt;Zip&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7126635798dce02399a0d9194f6641dfa46c0068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Average&lt;/code&gt;, &lt;code&gt;Concat&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;, &lt;code&gt;Max&lt;/code&gt;, &lt;code&gt;Min&lt;/code&gt;, &lt;code&gt;Reduce&lt;/code&gt;, and &lt;code&gt;Sum&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Average&lt;/code&gt; , &lt;code&gt;Concat&lt;/code&gt; , &lt;code&gt;Count&lt;/code&gt; , &lt;code&gt;Max&lt;/code&gt; , &lt;code&gt;Min&lt;/code&gt; , &lt;code&gt;Reduce&lt;/code&gt; 및 &lt;code&gt;Sum&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c5c2eccca242affd9bbd13eb09e3476a9ed7742" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BlockingObservable.forEach&lt;/code&gt; takes a single function as its parameter, and this function behaves much like an &lt;code&gt;onNext&lt;/code&gt; function in the subscription to an ordinary Observable. The &lt;code&gt;forEach&lt;/code&gt; operator itself blocks until the &lt;code&gt;BlockingObservable&lt;/code&gt; completes, and it is by unblocking, rather than by calling a callback function, that it indicates that it is complete. If it encounters an error it will throw a &lt;code&gt;RuntimeException&lt;/code&gt; (rather than calling an analogue to the &lt;code&gt;onError&lt;/code&gt; callback).</source>
          <target state="translated">&lt;code&gt;BlockingObservable.forEach&lt;/code&gt; 는 단일 함수를 매개 변수로 사용 &lt;code&gt;onNext&lt;/code&gt; 함수는 일반 Observable 구독시 onNext 함수 와 매우 유사하게 작동 합니다. &lt;code&gt;forEach&lt;/code&gt; 까지 운전자는 자신 블록 &lt;code&gt;BlockingObservable&lt;/code&gt; 완료하며 차단 해제함으로써,보다 그것이 완료되었음을 나타내는 것으로, 콜백 함수를 호출한다. 오류가 발생 하면 &lt;code&gt;onError&lt;/code&gt; 콜백에 대한 아날로그를 호출하는 대신 &lt;code&gt;RuntimeException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="9fbef09e1b4ea0717efe751ffcefe7699946c25c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;BufferOpenings&lt;/code&gt;, that emits &lt;code&gt;TBufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new &lt;code&gt;IList&lt;/code&gt; to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;TBufferOpening&lt;/code&gt; object into the &lt;code&gt;bufferClosingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;Buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it closes the &lt;code&gt;IList&lt;/code&gt; and emits it as its own emission.</source>
          <target state="translated">&lt;code&gt;Buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; 피 감시, 모니터링 &lt;code&gt;BufferOpenings&lt;/code&gt; 을 방출한다 해당, &lt;code&gt;TBufferOpening&lt;/code&gt; 개체. 이러한 방출 된 항목을 관찰 할 때마다 소스 Observable에서 방출 된 항목을 수집하기 위해 새 &lt;code&gt;IList&lt;/code&gt; 를 작성 하고 &lt;code&gt;TBufferOpening&lt;/code&gt; 오브젝트를 &lt;code&gt;bufferClosingSelector&lt;/code&gt; 함수 로 전달합니다 . 이 함수는 Observable을 반환합니다. &lt;code&gt;Buffer&lt;/code&gt; 는 Observable을 모니터링하고, 방출 된 항목을 감지하면 &lt;code&gt;IList&lt;/code&gt; 를 닫고 자체 방출로 방출합니다.</target>
        </trans-unit>
        <trans-unit id="17d76f7cc4ba89864f1b43d8207b52f2436f06ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;IList&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;IList&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;Buffer(count)&lt;/code&gt; 는 &lt;code&gt;IList&lt;/code&gt; 형식으로 겹치지 않는 버퍼를 방출합니다 . 각각의 버퍼 는 소스 Observable의 최대 &lt;code&gt;count&lt;/code&gt; 항목을 포함합니다 (최종 방출 된 &lt;code&gt;IList&lt;/code&gt; 는 &lt;code&gt;count&lt;/code&gt; 항목 보다 적을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="7081d72299cbb568724327709a714b40f340cd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;IList&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;Buffer(count, skip)&lt;/code&gt; 는 소스 Observable에서 첫 번째로 방출 된 항목으로 시작하여 그 이후의 모든 &lt;code&gt;skip&lt;/code&gt; 항목으로 시작하여 새 버퍼를 작성하고 각 버퍼를 &lt;code&gt;count&lt;/code&gt; 항목 (초기 항목 및 후속 항목 &lt;code&gt;count-1&lt;/code&gt; 으로 채 웁니다 . 이 버퍼를 &lt;code&gt;IList&lt;/code&gt; 로 방출합니다 . &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;skip&lt;/code&gt; 값에 따라 이러한 버퍼가 겹치거나 (여러 버퍼에 동일한 항목이 포함될 수 있음) 간격이있을 수 있습니다 (소스 Observable에서 생성 한 항목이 버퍼에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="0da2abc6a4d49055692e67ed62d86fc2cb0e1e82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan)&lt;/code&gt; emits a new &lt;code&gt;IList&lt;/code&gt; of items periodically, every &lt;code&gt;timeSpan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first list, since the subscription to the source Observable. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan)&lt;/code&gt; 새로운 발광 &lt;code&gt;IList&lt;/code&gt; 에 주기적으로 모든 항목을 &lt;code&gt;timeSpan&lt;/code&gt; 관찰 가능한 소스에 가입 이후 처음리스트의 경우 이전 번들이 출사 또는 이후 관찰 가능한 소스에 의해 방출 된 모든 아이템들을 포함하는 시간의 양. &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 버전의 연산자 버전도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe0db02107ba69f00dfab9f9466aa0e853bf477c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan, count)&lt;/code&gt; emits a new &lt;code&gt;IList&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timeSpan&lt;/code&gt; has elapsed since its last list emission, it emits a list of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan, count)&lt;/code&gt; 는 소스 Observable이 방출 한 모든 &lt;code&gt;count&lt;/code&gt; 항목에 대해 새로운 &lt;code&gt;IList&lt;/code&gt; 항목을 생성 하거나, 마지막 목록 방출 이후 &lt;code&gt;timeSpan&lt;/code&gt; 이 경과 한 경우 해당 Observable이 해당 범위에서 방출 한 많은 항목의 목록을 생성합니다. 이 수가 &lt;code&gt;count&lt;/code&gt; 보다 적더라도 . &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 버전의 연산자 버전도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b47fc6baedd7b73f21f5f4d7959f2aa975a8452" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan, timeShift)&lt;/code&gt; creates a new &lt;code&gt;IList&lt;/code&gt; of items every &lt;code&gt;timeShift&lt;/code&gt; period of time, and fills this list with every item emitted by the source Observable from that time until &lt;code&gt;timeSpan&lt;/code&gt; time has passed since the list&amp;rsquo;s creation, before emitting this &lt;code&gt;IList&lt;/code&gt; as its own emission. If &lt;code&gt;timeSpan&lt;/code&gt; is longer than &lt;code&gt;timeShift&lt;/code&gt;, the emitted lists will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan, timeShift)&lt;/code&gt; 새로 작성 &lt;code&gt;IList&lt;/code&gt; 의 항목마다 &lt;code&gt;timeShift&lt;/code&gt; 시간 기간 때까지 시간에서 관찰 가능한 소스에 의해 방출 된 모든 항목이리스트를 채우는 &lt;code&gt;timeSpan&lt;/code&gt; 시간 목록의 생성 이후 경과이 방출 전에 &lt;code&gt;IList&lt;/code&gt; 자체로서 방사. 경우 &lt;code&gt;timeSpan&lt;/code&gt; 더 이상보다 &lt;code&gt;timeShift&lt;/code&gt; , 방출 된 목록은 중복 기간을 나타냅니다 그들은 중복 항목을 포함 할 수 있도록. &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 버전의 연산자 버전도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dabc780819d59525df52a91f7676a389f3e0f2a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer&lt;/code&gt;, &lt;code&gt;FlatMap&lt;/code&gt;, &lt;code&gt;GroupBy&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Scan&lt;/code&gt;, and &lt;code&gt;Window&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Buffer&lt;/code&gt; , &lt;code&gt;FlatMap&lt;/code&gt; , &lt;code&gt;GroupBy&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Scan&lt;/code&gt; 및 &lt;code&gt;Window&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36249d8634975dadb84d72123168f8247b877485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Catch&lt;/code&gt; and &lt;code&gt;Retry&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Catch&lt;/code&gt; 및 &lt;code&gt;Retry&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e1e26c0b89264fa68e936ea021b56c4aec1f096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Connect&lt;/code&gt;, &lt;code&gt;Publish&lt;/code&gt;, &lt;code&gt;RefCount&lt;/code&gt;, and &lt;code&gt;Replay&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Connect&lt;/code&gt; , &lt;code&gt;Publish&lt;/code&gt; , &lt;code&gt;RefCount&lt;/code&gt; 및 &lt;code&gt;Replay&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2352bf3b7789aa73de64405f99b50a6b876dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Defer&lt;/code&gt;, &lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Never&lt;/code&gt;/&lt;code&gt;Throw&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt;, &lt;code&gt;Interval&lt;/code&gt;, &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;Repeat&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt;, and &lt;code&gt;Timer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Create&lt;/code&gt; , &lt;code&gt;Defer&lt;/code&gt; , &lt;code&gt;Empty&lt;/code&gt; / &lt;code&gt;Never&lt;/code&gt; / &lt;code&gt;Throw&lt;/code&gt; , &lt;code&gt;From&lt;/code&gt; , &lt;code&gt;Interval&lt;/code&gt; , &lt;code&gt;Just&lt;/code&gt; , &lt;code&gt;Range&lt;/code&gt; , &lt;code&gt;Repeat&lt;/code&gt; , &lt;code&gt;Start&lt;/code&gt; 및 &lt;code&gt;Timer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af0cc0f15199ef85fbb9ecd6605602fd48b0e87a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Debounce&lt;/code&gt;, &lt;code&gt;Distinct&lt;/code&gt;, &lt;code&gt;ElementAt&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;, &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;IgnoreElements&lt;/code&gt;, &lt;code&gt;Last&lt;/code&gt;, &lt;code&gt;Sample&lt;/code&gt;, &lt;code&gt;Skip&lt;/code&gt;, &lt;code&gt;SkipLast&lt;/code&gt;, &lt;code&gt;Take&lt;/code&gt;, and &lt;code&gt;TakeLast&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Debounce&lt;/code&gt; , &lt;code&gt;Distinct&lt;/code&gt; , &lt;code&gt;ElementAt&lt;/code&gt; , &lt;code&gt;Filter&lt;/code&gt; , &lt;code&gt;First&lt;/code&gt; , &lt;code&gt;IgnoreElements&lt;/code&gt; , &lt;code&gt;Last&lt;/code&gt; , &lt;code&gt;Sample&lt;/code&gt; , &lt;code&gt;Skip&lt;/code&gt; , &lt;code&gt;SkipLast&lt;/code&gt; , &lt;code&gt;Take&lt;/code&gt; 및 &lt;code&gt;TakeLast&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a5f8d43efabcb2ababea7b078ba251a574b59be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Delay&lt;/code&gt;, &lt;code&gt;Do&lt;/code&gt;, &lt;code&gt;Materialize&lt;/code&gt;/&lt;code&gt;Dematerialize&lt;/code&gt;, &lt;code&gt;ObserveOn&lt;/code&gt;, &lt;code&gt;Serialize&lt;/code&gt;, &lt;code&gt;Subscribe&lt;/code&gt;, &lt;code&gt;SubscribeOn&lt;/code&gt;, &lt;code&gt;TimeInterval&lt;/code&gt;, &lt;code&gt;Timeout&lt;/code&gt;, &lt;code&gt;Timestamp&lt;/code&gt;, and &lt;code&gt;Using&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Delay&lt;/code&gt; , &lt;code&gt;Do&lt;/code&gt; , &lt;code&gt;Materialize&lt;/code&gt; / &lt;code&gt;Dematerialize&lt;/code&gt; , &lt;code&gt;ObserveOn&lt;/code&gt; , &lt;code&gt;Serialize&lt;/code&gt; , &lt;code&gt;Subscribe&lt;/code&gt; , &lt;code&gt;SubscribeOn&lt;/code&gt; , &lt;code&gt;TimeInterval&lt;/code&gt; 이 , &lt;code&gt;Timeout&lt;/code&gt; , &lt;code&gt;Timestamp&lt;/code&gt; 및 &lt;code&gt;Using&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1b4675304049fa90cdf432a831ba6b5c8ac581b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PublishSubject&lt;/code&gt; emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.</source>
          <target state="translated">&lt;code&gt;PublishSubject&lt;/code&gt; 는 구독 시간 이후 소스 Observable에서 방출 한 항목 만 관찰자에게 방출합니다.</target>
        </trans-unit>
        <trans-unit id="95c856f5db49856ca93f078770fa39860cfdd2e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReplaySubject&lt;/code&gt; emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.</source>
          <target state="translated">&lt;code&gt;ReplaySubject&lt;/code&gt; 는 옵저버가 구독하는시기와 상관없이 소스 옵저버 블이 방출 한 모든 항목을 옵저버에게 방출합니다.</target>
        </trans-unit>
        <trans-unit id="3d6e191c77e6cb37262a32efe110a3b46253be77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e2656e1a12907334ba6ba9dbb22e19905e2e0d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a145b69fbb341823a7e2b8ac1730617d11c3e2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="652dd811848564f467f4c6881792205b07b1ddcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;average&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;average&lt;/code&gt; 은 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a5d83aa14e9a24c0de81cecf086101bb52aa929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(boundary)&lt;/code&gt; monitors an Observable, &lt;code&gt;boundary&lt;/code&gt;. Each time that Observable emits an item, it creates a new &lt;code&gt;List&lt;/code&gt; to begin collecting items emitted by the source Observable and emits the previous &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buffer(boundary)&lt;/code&gt; 는 Observable, &lt;code&gt;boundary&lt;/code&gt; 를 모니터링합니다 . Observable이 항목을 방출 할 때마다 소스 Observable이 방출 한 항목을 수집하기 위해 새 &lt;code&gt;List&lt;/code&gt; 를 작성 하고 이전 &lt;code&gt;List&lt;/code&gt; 를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="697675068739693864b5220ff9294b45d325c570" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(boundary&lt;/code&gt;[&lt;code&gt;, initialCapacity&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(boundary&lt;/code&gt; [ &lt;code&gt;, initialCapacity&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41bbfe617dacf8cd6bfdd7ec53d1681abb55514b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferBoundaries)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferBoundaries&lt;/code&gt;. Each time that Observable emits an item, it creates a new collection to begin collecting items emitted by the source Observable and emits the previous collection.</source>
          <target state="translated">&lt;code&gt;buffer(bufferBoundaries)&lt;/code&gt; 는 Observable, &lt;code&gt;bufferBoundaries&lt;/code&gt; 를 모니터링합니다 . Observable이 항목을 방출 할 때마다 소스 Observable이 방출 한 항목을 수집하기 위해 새 콜렉션을 작성하고 이전 콜렉션을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="5308080ad587c5e4577043e64860d26d587755fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferOpenings&lt;/code&gt;, that emits &lt;code&gt;BufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new &lt;code&gt;List&lt;/code&gt; to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;bufferOpenings&lt;/code&gt; Observable into the &lt;code&gt;closingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it closes the &lt;code&gt;List&lt;/code&gt; and emits it as its own emission.</source>
          <target state="translated">&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; 는 &lt;code&gt;BufferOpening&lt;/code&gt; 객체 를 방출 하는 Observable, &lt;code&gt;bufferOpenings&lt;/code&gt; 를 모니터링 합니다. 이러한 방출 된 항목을 관찰 할 때마다 소스 Observable이 방출 한 항목을 수집하기 위해 새 &lt;code&gt;List&lt;/code&gt; 를 작성 하고 &lt;code&gt;bufferOpenings&lt;/code&gt; Observable을 &lt;code&gt;closingSelector&lt;/code&gt; 함수 에 전달 합니다. 이 함수는 Observable을 반환합니다. &lt;code&gt;buffer&lt;/code&gt; 는 Observable을 모니터하고 그것으로부터 방출 된 아이템을 검출 할 때, &lt;code&gt;List&lt;/code&gt; 를 닫고 그것을 자체 방출로서 방출합니다.</target>
        </trans-unit>
        <trans-unit id="2570789cc0e868e96a6ac6bd1dc1fbc11fe2d472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferOpenings&lt;/code&gt;, that emits &lt;code&gt;BufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new collection to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;bufferOpenings&lt;/code&gt; Observable into the &lt;code&gt;bufferClosingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it emits the current collection and begins a new one.</source>
          <target state="translated">&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; 는 &lt;code&gt;BufferOpening&lt;/code&gt; 객체 를 방출 하는 Observable, &lt;code&gt;bufferOpenings&lt;/code&gt; 를 모니터링 합니다. 이러한 방출 된 항목을 관찰 할 때마다 소스 Observable에서 방출 된 항목을 수집하기 위해 새 콜렉션을 작성하고 &lt;code&gt;bufferOpenings&lt;/code&gt; Observable을 &lt;code&gt;bufferClosingSelector&lt;/code&gt; 함수 로 전달합니다 . 이 함수는 Observable을 반환합니다. &lt;code&gt;buffer&lt;/code&gt; 는 Observable을 모니터링하고 해당 항목에서 방출 된 항목을 발견하면 현재 콜렉션을 방출하고 새로운 콜렉션을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a6fe61d7081d96d83ff99876095e8a6fd192610b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(buffer_openings=boundaryObservable)&lt;/code&gt; monitors an Observable, &lt;code&gt;buffer_openings&lt;/code&gt;. Each time that Observable emits an item, it creates a new array to begin collecting items emitted by the source Observable and emits the previous array.</source>
          <target state="translated">&lt;code&gt;buffer(buffer_openings=boundaryObservable)&lt;/code&gt; 는 Observable, &lt;code&gt;buffer_openings&lt;/code&gt; 를 모니터링합니다 . Observable이 항목을 방출 할 때마다 소스 Observable이 방출 한 항목을 수집하기 위해 새 배열을 작성하고 이전 배열을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="863a8824c4e8d667b06cdd3b24a0e6ddd6012b66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(closing_selector=closingSelector)&lt;/code&gt; begins collecting items emitted by the source Observable immediately upon subscription, and also calls the &lt;code&gt;closing_selector&lt;/code&gt; function to generate a second Observable. It monitors this new Observable and, when it completes or emits an item, it emits the current array, begins a new array to collect items from the source Observable, and calls &lt;code&gt;closing_selector&lt;/code&gt; again to generate a new Observable to monitor in order to determine when to emit the new array. It repeats this process until the source Observable terminates, whereupon it emits the final array.</source>
          <target state="translated">&lt;code&gt;buffer(closing_selector=closingSelector)&lt;/code&gt; 는 구독 즉시 소스 Observable이 방출 한 항목을 수집하기 시작하고 , 두 번째 Observable을 생성하기 위해 &lt;code&gt;closing_selector&lt;/code&gt; 함수를 호출합니다 . 이 새로운 Observable을 모니터링하고, 항목을 완료하거나 방출 할 때 현재 배열을 방출하고, 소스 Observable에서 항목을 수집하기 위해 새 배열을 시작한 다음, 모니터링 할 새 Observable을 생성하기 위해 &lt;code&gt;closing_selector&lt;/code&gt; 다시 호출 하여시기를 결정합니다. 새로운 배열을 내 보냅니다. 소스 Observable이 종료 될 때까지이 프로세스를 반복하여 최종 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bd4258a2e6df22ec7068de8e9b1e62f83c9e1a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(closing_selector=openingSelector,&amp;nbsp;buffer_closing_selector=closingSelector)&lt;/code&gt; begins by calling &lt;code&gt;closing_selector&lt;/code&gt; to get an Observable. It monitors this Observable, and, whenever it emits an item, &lt;code&gt;buffer&lt;/code&gt; creates a new array, begins to collect items subsequently emitted by the source Observable into this array, and calls &lt;code&gt;buffer_closing_selector&lt;/code&gt; to get a new Observable to govern the closing of that array. When this new Observable emits an item or terminates, &lt;code&gt;buffer&lt;/code&gt; closes and emits the array that the Observable governs.</source>
          <target state="translated">&lt;code&gt;buffer(closing_selector=openingSelector,&amp;nbsp;buffer_closing_selector=closingSelector)&lt;/code&gt; 는 Observable을 얻기 위해 &lt;code&gt;closing_selector&lt;/code&gt; 를 호출 하여 시작합니다 . 이 Observable을 모니터링하고, 항목을 방출 할 때마다 &lt;code&gt;buffer&lt;/code&gt; 가 새 배열을 작성하고 소스 Observable이이 배열로 이후에 방출 한 항목을 수집하기 시작한 다음 해당 배열의 닫기를 제어하기 위해 새로운 Observable을 얻기 위해 &lt;code&gt;buffer_closing_selector&lt;/code&gt; 를 호출합니다 . 이 새로운 Observable이 항목을 내보내거나 종료하면 &lt;code&gt;buffer&lt;/code&gt; 는 Observable이 관리하는 배열을 닫고 방출합니다.</target>
        </trans-unit>
        <trans-unit id="46e14b0f10edb4752edcbe58757c5d212bbc1279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;List&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;List&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer(count)&lt;/code&gt; 는 &lt;code&gt;List&lt;/code&gt; 의 형태로 겹치지 않는 버퍼를 방출합니다 . 각 버퍼 는 소스 Observable의 최대 &lt;code&gt;count&lt;/code&gt; 항목을 포함합니다 (최종 방출 &lt;code&gt;List&lt;/code&gt; 은 &lt;code&gt;count&lt;/code&gt; 항목 보다 적을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="2056abba30f4856c7d26994b3b4bbf8b8a30285a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;vector&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;vector&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer(count)&lt;/code&gt; 는 &lt;code&gt;vector&lt;/code&gt; s 형식으로 겹치지 않는 버퍼를 방출합니다 . 각 버퍼 에는 소스 Observable의 &lt;code&gt;count&lt;/code&gt; 항목이 최대로 포함됩니다 (최종 방출 &lt;code&gt;vector&lt;/code&gt; 는 &lt;code&gt;count&lt;/code&gt; 항목 보다 적을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="2ee3ca99f3c9242184fe103637a7205a45e39454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;List&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer(count, skip)&lt;/code&gt; 는 소스 Observable에서 첫 번째로 방출 된 항목으로 시작하여 그 이후의 모든 &lt;code&gt;skip&lt;/code&gt; 항목으로 시작하여 새 버퍼를 작성하고 각 버퍼를 &lt;code&gt;count&lt;/code&gt; 항목 (초기 항목 및 &lt;code&gt;count-1&lt;/code&gt; 후속 항목)으로 채 웁니다 . 이 버퍼를 &lt;code&gt;List&lt;/code&gt; 로 방출합니다 . &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;skip&lt;/code&gt; 값에 따라 이러한 버퍼가 겹치거나 (여러 버퍼에 동일한 항목이 포함될 수 있음) 간격이있을 수 있습니다 (소스 Observable에서 생성 한 항목이 버퍼에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="c22dda51013aba339b4f5301fae6b2e4da5eccb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;vector&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer(count, skip)&lt;/code&gt; 는 소스 Observable에서 첫 번째로 방출 된 항목으로 시작하여 그 이후의 모든 &lt;code&gt;skip&lt;/code&gt; 항목 으로 새 버퍼를 작성하고 각 버퍼를 &lt;code&gt;count&lt;/code&gt; 항목으로 시작합니다 (초기 항목 및 후속 항목 &lt;code&gt;count-1&lt;/code&gt; . 이 버퍼를 &lt;code&gt;vector&lt;/code&gt; 로 방출합니다 . &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;skip&lt;/code&gt; 값에 따라 이러한 버퍼가 겹치거나 (여러 버퍼에 동일한 항목이 포함될 수 있음) 간격이있을 수 있습니다 (소스 Observable에서 생성 한 항목이 버퍼에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="583f8a99c7e6fa0453a17cde605fa702f865a085" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fa2109d7bb913a1ea95726f4100c1cebac8aa2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit, count&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit, count&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="491a83da4e4bb96760c09269a5758b2ad4a9dafe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64fa6aff05106cdc04eb3c628a3821de1a4df244" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift, unit)&lt;/code&gt; creates a new &lt;code&gt;List&lt;/code&gt; of items every &lt;code&gt;timeshift&lt;/code&gt; period of time, and fills this bundle with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; time has passed since the bundle&amp;rsquo;s creation, before emitting this &lt;code&gt;List&lt;/code&gt; as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift, unit)&lt;/code&gt; 새로운 생성 &lt;code&gt;List&lt;/code&gt; 항목마다 &lt;code&gt;timeshift&lt;/code&gt; 시간 기간 때까지 시간에서 관찰 가능한 소스에 의해 방출 된 모든 항목이 번들을 채우는 &lt;code&gt;timespan&lt;/code&gt; 의 시간이 방출되기 전에, 번들의 생성 이후 경과 &lt;code&gt;List&lt;/code&gt; 등을 자체 배출. 경우 &lt;code&gt;timespan&lt;/code&gt; 더 이상보다 &lt;code&gt;timeshift&lt;/code&gt; , 방출 된 번들은 중복 기간을 나타냅니다 그들은 중복 항목을 포함 할 수 있도록. &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 운영자 변형 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;computation&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c4b98a3f859f7bbc620366a633025b1515dde55a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift=timeshift)&lt;/code&gt; creates a new array of items every &lt;code&gt;timeshift&lt;/code&gt; milliseconds, and fills this array with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; milliseconds have passed since the array&amp;rsquo;s creation, before emitting this array as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift=timeshift)&lt;/code&gt; 는 &lt;code&gt;timeshift&lt;/code&gt; 밀리 초 마다 새로운 아이템 배열을 생성하고,이 어레이를 자신의 것으로 생성하기 전에 어레이 생성 이후 &lt;code&gt;timespan&lt;/code&gt; 밀리 초가 지나갈 때까지 그 시점부터 Observable 소스가 방출 한 모든 아이템으로이 어레이를 채 웁니다. 방사. 경우 &lt;code&gt;timespan&lt;/code&gt; 더 이상보다 &lt;code&gt;timeshift&lt;/code&gt; , 방출 어레이는 중복 기간을 나타냅니다 그들은 중복 항목을 포함 할 수 있도록. &lt;code&gt;scheduler&lt;/code&gt; 매개 변수를 사용하여이를 사용하여 시간 범위를 제어하는 이 운영자 버전의 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0533305f953f0a309e5df453b9e133d20568e589" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; Scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; 새로운 발광 &lt;code&gt;List&lt;/code&gt; 주기적으로 모든 항목을 &lt;code&gt;timespan&lt;/code&gt; 관찰 가능한 소스에 가입하기 때문에, 제 다발의 경우 이전 번들이 출사 또는 이후 관찰 가능한 소스에 의해 방출 된 모든 항목을 포함하는 시간의 양 . &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 운영자 변형 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;computation&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e360891f0984ef4090aa7ada4740dcbb4f704617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; 새로운 발광 &lt;code&gt;List&lt;/code&gt; 주기적으로 모든 항목을 &lt;code&gt;timespan&lt;/code&gt; 관찰 가능한 소스에 가입하기 때문에, 제 다발의 경우 이전 번들이 출사 또는 이후 관찰 가능한 소스에 의해 방출 된 모든 항목을 포함하는 시간의 양 . &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 운영자 변형 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;computation&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8371395551452bb18051c520c2f4b5a089268672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit, count)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit, count)&lt;/code&gt; 는 소스 Observable이 방출 한 모든 &lt;code&gt;count&lt;/code&gt; 항목에 대해 새로운 항목 &lt;code&gt;List&lt;/code&gt; 을 생성 하거나, 마지막 번들 방출 이후 &lt;code&gt;timespan&lt;/code&gt; 경과가 경과 한 경우 소스 Observable이 방출 한 많은 항목의 번들을 방출합니다. &lt;code&gt;count&lt;/code&gt; 보다 작은 경우에도 해당 범위 . &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 운영자 변형 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;computation&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="065b6459d070388eac1369f1d551fcb749fb19e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c3817e4bc1a4a104318a507d1f1df1dcce46ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 에는 다음 배포판 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f240d669d61624f913fe346aa844fe8dd4cbf0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount(count)&lt;/code&gt; emits non-overlapping buffers, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted buffer may contain fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;bufferWithCount(count)&lt;/code&gt; 겹치지 않는 버퍼를 방출합니다. 각 버퍼에는 소스 Observable의 최대 &lt;code&gt;count&lt;/code&gt; 항목 이 포함됩니다 (최종 방출 버퍼에는 &lt;code&gt;count&lt;/code&gt; 보다 적은 항목 이 포함될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="29a77fe8590e836748bec1afceb482424cc55b73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and a new one for every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones, emitting each buffer when it is complete. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;bufferWithCount(count, skip)&lt;/code&gt; 는 소스 Observable에서 첫 번째로 방출 된 항목으로 시작하여 새 버퍼를 생성하고 그 이후에는 모든 &lt;code&gt;skip&lt;/code&gt; 항목에 대해 새 버퍼를 작성하고 각 버퍼를 &lt;code&gt;count&lt;/code&gt; 항목으로 채 웁니다 ( 초기 항목 및 &lt;code&gt;count-1&lt;/code&gt; 후속 항목). 완료되면 각 버퍼. &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;skip&lt;/code&gt; 값에 따라 이러한 버퍼가 겹치거나 (여러 버퍼에 동일한 항목이 포함될 수 있음) 간격이있을 수 있습니다 (소스 Observable에서 생성 한 항목이 버퍼에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="4d936831debc89a8b2338b3a3007dc091decf55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithCount&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="725109d45ba1846de8a6b8392b6391092d1a98ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime(timeSpan)&lt;/code&gt; emits a new collection of items periodically, every &lt;code&gt;timeSpan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTime(timeSpan)&lt;/code&gt; 주기적 항목의 새로운 집합을 방출 모든 &lt;code&gt;timeSpan&lt;/code&gt; 관찰 가능한 소스로 구독 보낸 제 다발의 경우 이전 번들이 출사 또는 이후 관찰 가능한 소스에 의해 방출 된 모든 항목을 포함 밀리. &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 운영자 변형 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6826b6f33554f8fb1de2ebf021c2cadcb4cd9c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime(timeSpan, timeShift)&lt;/code&gt; creates a new collection of items every &lt;code&gt;timeShift&lt;/code&gt; milliseconds, and fills this bundle with every item emitted by the source Observable from that time until &lt;code&gt;timeSpan&lt;/code&gt; milliseconds has passed since the collection&amp;rsquo;s creation, before emitting this collection as its own emission. If &lt;code&gt;timeSpan&lt;/code&gt; is longer than &lt;code&gt;timeShift&lt;/code&gt;, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTime(timeSpan, timeShift)&lt;/code&gt; 는 매 &lt;code&gt;timeShift&lt;/code&gt; 밀리 초 마다 새로운 항목 컬렉션을 생성 하고이 번들을 컬렉션이 생성 된 이후부터 해당 컬렉션을 자체 방출로 방출하기 전에 해당 시점부터 &lt;code&gt;timeSpan&lt;/code&gt; 밀리 초가 지나갈 때까지 소스 Observable이 방출 한 모든 항목으로 채 웁니다 . 경우 &lt;code&gt;timeSpan&lt;/code&gt; 더 이상보다 &lt;code&gt;timeShift&lt;/code&gt; , 방출 된 번들은 중복 기간을 나타냅니다 그들은 중복 항목을 포함 할 수 있도록. &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 운영자 변형 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="65d0e7bcf4ac65e74eca9ba20646e209c2c82ff0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime&lt;/code&gt; and &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithTime&lt;/code&gt; 및 &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5725f9a1a6a7c85dc4d290333be130a63966d6a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime&lt;/code&gt; and &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; require one of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithTime&lt;/code&gt; 및 &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; 에는 다음 분배 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="29da60953849f79c94578371fc21981b0e02a7a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTimeOrCount(timeSpan, count)&lt;/code&gt; emits a new collection of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timeSpan&lt;/code&gt; milliseconds have elapsed since its last collection emission, it emits a collection of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTimeOrCount(timeSpan, count)&lt;/code&gt; 는 소스 Observable이 방출 한 모든 &lt;code&gt;count&lt;/code&gt; 항목에 대해 새 항목 콜렉션을 생성 하거나, 마지막 콜렉션 방출 이후 &lt;code&gt;timeSpan&lt;/code&gt; 밀리 초가 경과 한 경우 , 해당 소스 Observable이 해당 항목에서 방출 한 많은 항목의 콜렉션을 방출합니다. &lt;code&gt;count&lt;/code&gt; 보다 작은 경우에도 span . &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 운영자 변형 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="aa343001bbb40cc3e8b3cc541b1d7a9764e511ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_count(count)&lt;/code&gt; emits non-overlapping buffers in the form of arrays, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted array may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer_with_count(count)&lt;/code&gt; 는 배열 형태로 겹치지 않는 버퍼를 방출합니다. 각 버퍼에는 소스 Observable의 &lt;code&gt;count&lt;/code&gt; 항목이 최대로 포함됩니다 (최종 방출 배열은 &lt;code&gt;count&lt;/code&gt; 항목 보다 적을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="b64633ff8b9b99511e1f91464f9c7b8f23d5b394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_count(count, skip=skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as arrays. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer_with_count(count, skip=skip)&lt;/code&gt; 는 소스 Observable에서 첫 번째로 방출 된 항목부터 시작하여 그 이후의 모든 &lt;code&gt;skip&lt;/code&gt; 항목으로 시작하여 새 버퍼를 작성하고 각 버퍼를 &lt;code&gt;count&lt;/code&gt; 항목으로 시작합니다 (초기 항목 및 후속 항목 &lt;code&gt;count-1&lt;/code&gt; . 이 버퍼를 배열로 내 보냅니다. &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;skip&lt;/code&gt; 값에 따라 이러한 버퍼가 겹치거나 (여러 버퍼에 동일한 항목이 포함될 수 있음) 간격이있을 수 있습니다 (소스 Observable에서 생성 한 항목이 버퍼에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="da6265be2e09c0f88dba2c30d63bf9e68b96a9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emits a new array of items periodically, every &lt;code&gt;timespan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable.</source>
          <target state="translated">&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; 은 이전 번들 방출 이후 또는 첫 번째 번들의 경우 소스 Observable에 가입 ​​한 이후 소스 Observable이 방출 한 모든 항목을 포함하는 모든 &lt;code&gt;timespan&lt;/code&gt; 밀리 초 )마다 주기적으로 새 항목 배열을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="2c21c1882f580b27cb8db9eac720ea9eaf14d8e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emits a new array of items periodically, every &lt;code&gt;timespan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; 은 이전 번들 방출 이후 또는 첫 번째 번들의 경우 소스 Observable에 가입 ​​한 이후 소스 Observable이 방출 한 모든 항목을 포함하는 모든 &lt;code&gt;timespan&lt;/code&gt; 밀리 초 )마다 주기적으로 새 항목 배열을 방출합니다. &lt;code&gt;scheduler&lt;/code&gt; 매개 변수를 사용하여이를 사용하여 시간 범위를 제어하는 이 운영자 버전의 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dedb9b5d750555c146f9ea815130104bd7cdac7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time_or_count(timespan, count)&lt;/code&gt; emits a new array of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; milliseconds have elapsed since its last bundle emission, it emits an array of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer_with_time_or_count(timespan, count)&lt;/code&gt; 는 소스 Observable이 방출 한 모든 &lt;code&gt;count&lt;/code&gt; 항목에 대해 새로운 항목 배열을 방출하거나, 마지막 번들 방출 이후 &lt;code&gt;timespan&lt;/code&gt; 밀리 초가 경과 한 경우 , 소스 Observable이 방출 한 많은 항목의 배열을 방출합니다. &lt;code&gt;count&lt;/code&gt; 보다 작은 경우에도 span . &lt;code&gt;scheduler&lt;/code&gt; 매개 변수를 사용하여이를 사용하여 시간 범위를 제어하는 이 운영자 버전의 버전도 있습니다 . 기본적으로이 변형은 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c8efbc0dfab77384e5695e0391a88f43d1c0aa03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;switchCase&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; / &lt;code&gt;switchCase&lt;/code&gt; 는 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ab85f941795ebebc7621966c024835b3854ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eada5ba41149936eb42223cb804a2da3d2fb07e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collect&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e34bcdea7b0a4428fe34327e1ecd484b3e7fa08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concatAll&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 및 &lt;code&gt;concatAll&lt;/code&gt; 은 다음 각 배포판에 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc4f8fb42b68e7c7b7e5316591de9ce7532f3f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; takes a variable number of Observables (or Promises) as parameters (or a single array of Observables or Promises), and concatenates them in the order they appear in the parameter list (or array). It exists as both an Observable prototype method and as an instance method.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 은 가변 개수의 Observable (또는 Promises)을 매개 변수 (또는 단일 Observables 또는 Promises의 배열)로 취하여 매개 변수 목록 (또는 배열)에 나타나는 순서대로 연결합니다. Observable 프로토 타입 방법과 인스턴스 방법으로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8a05f7b7657968ed6c712decc49d7b955c8b6966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatAll&lt;/code&gt; is an instance method that operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.</source>
          <target state="translated">&lt;code&gt;concatAll&lt;/code&gt; 은 Observable of Observable에서 작동하는 인스턴스 메소드로, 각 Observable을 방출 순서대로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="e66c4829b49a33917cc27c0640b2259d52e1e55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatAll&lt;/code&gt; operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.</source>
          <target state="translated">&lt;code&gt;concatAll&lt;/code&gt; 은 Observable of Observable에서 작동하며, 각 Observable을 방출 순서대로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="c0409c43e5cc9d6d379c8bea27199652abd6f255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concatMap&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d029702d3e9b15b15c6b4d30027e9cc6d70b4e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatMapObserver&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concatMapObserver&lt;/code&gt; 는 다음 각 배포판에 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb35a6a3b4f9a20c3186e62ff7a21cb33bee0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; is found in the following packages:</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 는 다음 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9640f1d7fa4ad35d3539ac1d849fef7fe71caa33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; requires one of the following packages:</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 에는 다음 패키지 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c5e5e027558b94847fe199fe7233b289d43c3988" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contains&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;contains&lt;/code&gt; 은 다음 분포에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f02a10531ba2d78eaba589a48c7af53fab6e76c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; is part of the following packages:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 는 다음 패키지의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="0fcbf042928888fd25281733fb74efa8027c00f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; requires one of any of the following packages:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 에는 다음 패키지 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8a6fbc195a31b898bd2620e8000a89499dcc9336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9606d8bf5fdf3394981d341c49d099b55449f265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; 는 다음 배포판에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fb2205ee6a769cc0527dc0468e5653d34418731" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounce&lt;/code&gt; and &lt;code&gt;debounceWithSelector&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 및 &lt;code&gt;debounceWithSelector&lt;/code&gt; 는 다음 각 배포판에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6ec38915190181a63aae2734403ec6811aa79ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultIfEmpty&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;defaultIfEmpty&lt;/code&gt; 는 다음 각 분배에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0501ae0183e1bc12b30af5067f70d83fa221b7e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; does not by default operate on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1c4d06d8cc0b00cad69791240d6a9faa69aef0a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; 는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0453f1952ccc6ca5fae76fdaa5a6430077591489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delay&lt;/code&gt;, &lt;code&gt;delaySubscription&lt;/code&gt;, and &lt;code&gt;delayWithSelector&lt;/code&gt; require &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.lite.compat.js&lt;/code&gt; and are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;delay&lt;/code&gt; , &lt;code&gt;delaySubscription&lt;/code&gt; 및 &lt;code&gt;delayWithSelector&lt;/code&gt; 가 필요 &lt;code&gt;rx.lite.js&lt;/code&gt; 또는 &lt;code&gt;rx.lite.compat.js&lt;/code&gt; 을 다음의 각 분포에서 발견된다 :</target>
        </trans-unit>
        <trans-unit id="a42e6eae40facebfc9412f8cd67d437d4ba55fa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delaySubscription&lt;/code&gt; is similar to &lt;code&gt;delay&lt;/code&gt; but rather than timeshifting the emissions from the source Observable, it timeshifts the moment of subscription to that Observable. You pass to this operator a time value (either a &lt;code&gt;Number&lt;/code&gt;, in which case this sets the number of milliseconds of delay, or a &lt;code&gt;Date&lt;/code&gt;, in which case this sets an absolute future time at which &lt;code&gt;delaySubscription&lt;/code&gt; will trigger the subscription). You may optionally pass a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, which &lt;code&gt;delaySubscription&lt;/code&gt; will use to govern the delay period or trigger time.</source>
          <target state="translated">&lt;code&gt;delaySubscription&lt;/code&gt; 은 &lt;code&gt;delay&lt;/code&gt; 과 유사 하지만 소스 Observable의 방출을 시간 이동 시키는 것이 아니라 해당 Observable에 가입하는 순간을 시간 이동시킵니다. 이 조작에 시간 값 (하나 패스 &lt;code&gt;Number&lt;/code&gt; 있으며,이 경우에 이러한 세트 지연 밀리 초, 또는 수 &lt;code&gt;Date&lt;/code&gt; ,이 경우에이 설정되는 절대 미래 시간 &lt;code&gt;delaySubscription&lt;/code&gt; 는 구독을 트리거한다). 선택적으로 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 를 두 번째 매개 변수로 전달할 수 있습니다. &lt;code&gt;delaySubscription&lt;/code&gt; 은 지연 기간 또는 트리거 시간을 제어하는 ​​데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e7adbe72591784b4a714d2eb115365bb13e4cea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delayWithSelector&lt;/code&gt; is like &lt;code&gt;delay&lt;/code&gt; but does not use a constant delay duration (or absolute time), but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">&lt;code&gt;delayWithSelector&lt;/code&gt; 는 &lt;code&gt;delay&lt;/code&gt; 과 유사 하지만 일정한 지연 시간 (또는 절대 시간)을 사용하지 않지만 소스 Observable의 각 항목을 Observable을 반환하는 함수로 전달한 다음 해당 Observable을 모니터링하여 항목별로 지연 시간을 설정합니다. 이러한 Observable이 완료되면 &lt;code&gt;delay&lt;/code&gt; 의해 반환 된 Observable 이 관련 항목을 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="85526d492d5d878f590368951b13d664cbf0ab56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d70c73d8be9dbb0a7ddccccd361323bf2f38ab4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; 는 다음 각 분포에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="2ca4c8f4b2a43c908128d7d73fdfa0aeec78bd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; reverses this process: converting the emitted &lt;code&gt;Notification&lt;/code&gt; objects from the source Observable into notifications from the resulting Observable.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; 는 소스 Observable에서 생성 된 &lt;code&gt;Notification&lt;/code&gt; 객체를 결과 Observable의 알림으로 변환하는이 프로세스를 반대로 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="df41a1151275a1c436292bf439c78eb32a392ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; reverses this process: converting the emitted &lt;code&gt;Notification&lt;/code&gt; objects from the source Observable into notifications from the resulting Observable. The following example dematerializes the materialized Observable from the previous section:</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; 는 소스 Observable에서 생성 된 &lt;code&gt;Notification&lt;/code&gt; 객체를 결과 Observable의 알림으로 변환하는이 프로세스를 반대로 수행합니다 . 다음 예제는 이전 섹션에서 구체화 된 Observable을 구체화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="575b0cbaa7c437c082382619ee3d2b599c5d8aa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinct&lt;/code&gt; and &lt;code&gt;distinctUntilChanged&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; 및 &lt;code&gt;distinctUntilChanged&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f65514f172ddc744697e1b142c1194449befad2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinct&lt;/code&gt; and &lt;code&gt;distinctUntilChanged&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; 및 &lt;code&gt;distinctUntilChanged&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="01a0882d7b2db85098410d045d7dff19792f7aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt;, &lt;code&gt;doOnNext&lt;/code&gt;/&lt;code&gt;tapOnNext&lt;/code&gt;, &lt;code&gt;doOnError&lt;/code&gt;/&lt;code&gt;tapOnError&lt;/code&gt;, &lt;code&gt;doOnCompleted&lt;/code&gt;/&lt;code&gt;tapOnCompleted&lt;/code&gt;, and &lt;code&gt;finally&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; , &lt;code&gt;doOnNext&lt;/code&gt; / &lt;code&gt;tapOnNext&lt;/code&gt; , &lt;code&gt;doOnError&lt;/code&gt; / &lt;code&gt;tapOnError&lt;/code&gt; , &lt;code&gt;doOnCompleted&lt;/code&gt; / &lt;code&gt;tapOnCompleted&lt;/code&gt; 그리고 &lt;code&gt;finally&lt;/code&gt; 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba28eb2a98755e124f1d52b5b9dcc8bd04262dc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;doWhile&lt;/code&gt; is found in each of the following distributions.</source>
          <target state="translated">&lt;code&gt;doWhile&lt;/code&gt; 은 다음의 각 분포에서 발견된다.</target>
        </trans-unit>
        <trans-unit id="8aee9c417fde4cd2d46ade859aa7f69f1f2a52e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; and &lt;code&gt;elementAtOrDefault&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; 및 &lt;code&gt;elementAtOrDefault&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0e41302836be86491f3b9837b34145fcc104fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26d85c47be76d2b86ddbf1d36c82dae7e0563118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;empty&lt;/code&gt; 다음 분포에서 비어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1144ef5b59f5d111eb78cf1787143dd56d384a19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;every&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;every&lt;/code&gt; 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3575ee1fc6c15b236ec3868735424258902118a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c7c4225690df0f39e51c9f6112ab29eac89a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; 에는 다음 배포판 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2cd400c1c5833ab09d2d1362e8821a842f57ba3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 및 &lt;code&gt;where&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4160a64d95ca2627e911591e307254638dca079" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3b415955a2aa1c5cbed5857327ffa9aa9dba51fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finallyDo&lt;/code&gt; is deprecated since RxJava 1.1.1, in favor of &lt;code&gt;doAfterTerminate&lt;/code&gt; with the same behavior.</source>
          <target state="translated">&lt;code&gt;finallyDo&lt;/code&gt; 는 RxJava 1.1.1부터 더 이상 사용되지 않으며 동일한 동작 으로 &lt;code&gt;doAfterTerminate&lt;/code&gt; 를 선호 합니다.</target>
        </trans-unit>
        <trans-unit id="df5fe9a72c0b449743099df91b382964ece8478c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt;, &lt;code&gt;findIndex&lt;/code&gt;, and &lt;code&gt;first&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; , &lt;code&gt;findIndex&lt;/code&gt; 및 &lt;code&gt;first&lt;/code&gt; 는 다음 각 분포에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="9f9e2cc1497254c384bab408eec27fc4e6d63a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findIndex&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;findIndex&lt;/code&gt; 는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2968359c689419c3b851f5749fe9db70e799191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;singleOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; , &lt;code&gt;single&lt;/code&gt; , &lt;code&gt;singleOrDefault&lt;/code&gt; 및 &lt;code&gt;takeFirst&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dc69e12ef4eb80735da7a8ffa7381624d352d14e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;firstOrDefault&lt;/code&gt; also has a variant to which you can pass a predicate function, so that its Observable will emit the first item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;, or the default item if no items emitted by the source Observable pass the predicate.</source>
          <target state="translated">&lt;code&gt;firstOrDefault&lt;/code&gt; 는 또한 술어 함수를 전달할 수있는 변형을 가지므로, Observable은 술어가 &lt;code&gt;true&lt;/code&gt; 로 평가하는 소스 Observable에서 첫 번째 항목을 방출 하거나, 소스 Observable에서 방출 된 항목이 술어를 전달하지 않으면 기본 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="06f0ceae9a2712cef444daa2be24a1a18e0220a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a73ed2b1d04a2afe67083d006a5767d38008225d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; 은 사용자가 제공하는 함수가 소스 Observables에서 Observables, Promises 또는 Array로 항목을 변환하는 경우에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e5e16d10a285700e7dab486c58a155a35a9ce31e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapLatest&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMapLatest&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c825a3961cc54c6c6ef805e3fd98b58b8f603ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapObserver&lt;/code&gt; creates (and flattens) a new Observable for each item &lt;em&gt;and notification&lt;/em&gt; from the source Observable. It accepts a different transformation function to respond to &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt; notifications and to return an Observable for each.</source>
          <target state="translated">&lt;code&gt;flatMapObserver&lt;/code&gt; 는 각 항목에 대한 새로운 Observable을 생성 (및 평탄화) 하고 소스 Observable에서 &lt;em&gt;알림&lt;/em&gt; 을 보냅니다 . &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; 및 &lt;code&gt;onCompleted&lt;/code&gt; 알림 에 응답하고 각각에 대해 Observable을 반환하기 위해 다른 변환 함수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="f51b699df8e1441a48690c6b1971732a8b76801f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapObserver&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMapObserver&lt;/code&gt; 는 다음 각 배포판에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef78b641e6d3a740830c8f89647cba368bc89806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatten&lt;/code&gt; takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence. A variant of this operator allows you to pass in an &lt;code&gt;Int&lt;/code&gt; indicating the maximum number of these emitted Observables you want &lt;code&gt;flatten&lt;/code&gt; to try to be subscribed to at any time. It it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;flatten&lt;/code&gt; 은 Observable을 방출하는 Observable을 매개 변수로 사용합니다. 각 Observable에서 방출되는 항목을 병합하여 고유 한 단일 Observable 시퀀스를 만듭니다. 이 연산자의 변형을 사용하면 &lt;code&gt;flatten&lt;/code&gt; 등록 하려는 방출 된 Observable의 최대 수를 나타내는 &lt;code&gt;Int&lt;/code&gt; 를 언제든지 구독 할 수 있습니다. 그것은 그것이 최대 가입 수를 명중, 그것은 이미 가입-에 Observables은 문제 중 하나 때까지 관찰 가능한 소스에 의해 방출되는 다른 Observables은 가입을 자제한다 &lt;code&gt;onCompleted&lt;/code&gt; 통지.</target>
        </trans-unit>
        <trans-unit id="f490d9df4739ffcbdfd79e77f05c1a12ad66261d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flattenDelayError&lt;/code&gt; is similar to &lt;code&gt;flatten&lt;/code&gt; except that it will always emit all items from all of the emitted Observables even if one or more of those Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification before the other Observables have finished emitting items.</source>
          <target state="translated">&lt;code&gt;flattenDelayError&lt;/code&gt; 는 다른 Observable이 항목을 내보내기 전에 하나 이상의 해당 Observable이 &lt;code&gt;onError&lt;/code&gt; 알림으로 종료 되더라도 항상 방출 된 모든 Observable에서 모든 항목을 방출한다는 점을 제외 하면 &lt;code&gt;flatten&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="a0c2292ff2aabdc802f42755a7f15ac367b4fbc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; 은 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e1a4342d8e23599b8291e0535a43c3e1c8b990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, however you can pass the variant that converts a Future a Scheduler as an optional second parameter, and it will use that Scheduler to govern the Future.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않지만 Future a Scheduler를 선택적 두 번째 매개 변수로 변환하는 변형을 전달할 수 있으며 해당 스케줄러를 사용하여 Future를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="5df439cbc86cf0b9ba3bedfa57ed66e6100a4072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 은 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65f1e48b7bb0d9d9d719896dcd792a4cfc83fec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromCallback&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromCallback&lt;/code&gt; 은 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a72db4b80dc8bad54f16580c97b432c8b2daadb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; 는 다음 분배에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07265cef8fee5d99da56092ca85c52c79f93584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromNodeCallback&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromNodeCallback&lt;/code&gt; 은 다음 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2ed748a3852498d48388eaf367201f153d93fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromPromise&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromPromise&lt;/code&gt; 는 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c3520858faf7a23e64e6c3d2f6e3307fbd26f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; 는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0afae411108bbc561cc1122700b256b35c45fbaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; is found in the following distribution:</source>
          <target state="translated">&lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; 은 다음 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52da1d549ee7151f9db69e4a561c0990d7a46355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generateWithRelativeTime&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;generateWithRelativeTime&lt;/code&gt; 은 다음 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a23135807c49156cdc8b6752177c1f0c084e2c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupBy&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;groupBy&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="91ad833301d1835f103f1baa096fee152ae86986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupBy&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;groupBy&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e3a79fda5beb1254249bb177d0da34e38313a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupByUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;groupByUntil&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0893202a0ecab0d0f8ea3b772158225e7098703c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupJoin&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;groupJoin&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f5d0735a424248247ad9aae5cc496d8ece526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 다음 분포에서 발견되는 경우 :</target>
        </trans-unit>
        <trans-unit id="477fd73d586b9fcbec825cd0ec0de785a84f39a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignoreElements&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ignoreElements&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="69048ec3ceda893dbaff054dda9cc09355fcca6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignoreElements&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;ignoreElements&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faf6f3923e8284b46d6b215d9e7373efbab268c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indexOf&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;indexOf&lt;/code&gt; 는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fccd0f02c09cee4ec7aa4d5fa8f66c339d4d6f8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interleave*&lt;/code&gt; is similar but operates on an Observable of Observables.</source>
          <target state="translated">&lt;code&gt;interleave*&lt;/code&gt; 는 비슷하지만 Observable of Observable에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7b50914802b5744bb9a29e53495e66d8ae29742e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interleave&lt;/code&gt; is like &lt;code&gt;merge&lt;/code&gt;, but more deliberate about how it interleaves the items from the source Observables: the resulting Observable emits the first item emitted by the first source Observable, then the first item emitted by the second source Observable, and so forth, and having reached the last source Observable, then emits the second item emitted by the first source Observable, the second item emitted by the second source Observable, and so forth, until all of the source Observables terminate.</source>
          <target state="translated">&lt;code&gt;interleave&lt;/code&gt; 는 &lt;code&gt;merge&lt;/code&gt; 와 비슷하지만 소스 Observables에서 항목을 인터리브하는 방법에 대해 더 신중합니다. 마지막 소스 Observable에 도달 한 다음 모든 소스 Observable이 종료 될 때까지 첫 번째 소스 Observable이 방출 한 두 번째 항목, 두 번째 소스 Observable이 방출 한 두 번째 항목 등을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="7264e5224d0efb5bbea1588870c9d1c16097664b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; 은 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f6fbc36a92a3bb6ea90875470f4264e24b6511f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There are also variants that allow you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; 은 기본적으로 &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동합니다 . 스케줄러를 매개 변수로 전달하여 스케줄러를 설정할 수있는 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4788908a9674cee42b2359c4082011fd9d64a96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; operates by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can optionally pass in a different Scheduler as a second parameter, and &lt;code&gt;interval&lt;/code&gt; will operate on that Scheduler instead.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; 은 기본적으로 &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하거나 선택적으로 다른 스케줄러를 두 번째 매개 변수로 전달할 수 있으며 &lt;code&gt;interval&lt;/code&gt; 대신 해당 스케줄러에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="45aed2147ce95798c6a80412108c06c33d406eaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isEmpty&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;isEmpty&lt;/code&gt; 는 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="396a69205a9eb0971c9c7f55db588708f79c4271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; and &lt;code&gt;groupJoin&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; 및 &lt;code&gt;groupJoin&lt;/code&gt; 은 다음 각 배포판에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0266ff7e3c64a16c14367e7d9c449c8da592883a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; 기본적으로 join 은 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1a69e5a2478476a9c491318f02a1ebcb2c00072d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jortSort&lt;/code&gt; and &lt;code&gt;jortSortUntil&lt;/code&gt; are found in the following distribution:</source>
          <target state="translated">&lt;code&gt;jortSort&lt;/code&gt; 및 &lt;code&gt;jortSortUntil&lt;/code&gt; 은 다음 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a9b0c411484d69c52e4c13d11908433ad2a8d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;just&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;just&lt;/code&gt; 기본적으로하지 않습니다 어떤 특정한에서 작동 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34d74f67c03c213281eab1d7970a0f0aa9fb5f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; 및 &lt;code&gt;lastOrDefault&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4a533c3a569a685efc0f2ff08c697bf6945290e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; 은 다음 각 분포에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="a7a36090f51769beb59adcc22b7e8c1ea2e87040" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastOrDefault&lt;/code&gt; also has a variant to which you can pass a predicate function, so that its Observable will emit the last item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;, or the default item if no items emitted by the source Observable pass the predicate.</source>
          <target state="translated">&lt;code&gt;lastOrDefault&lt;/code&gt; 는 또한 술어 함수를 전달할 수있는 변형을 가지므로, Observable은 술어가 &lt;code&gt;true&lt;/code&gt; 로 평가하는 소스 Observable에서 마지막 항목을 방출하거나, 소스 Observable이 방출 한 항목이 술어를 전달하지 않으면 기본 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="7aacfc7731f6c17a90c6eb8a8408b8626b6b4c65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; internally transforms each item emitted by the source Observable into an Observable that emits that item and all items subsequently emitted by the source Observable, in the same order. So, for example, it internally transforms an Observable that emits the numbers 1,2,3 into three Observables: one that emits 1,2,3, one that emits 2,3, and one that emits 3.</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; 는 소스 Observable에 의해 방출 된 각 항목을 해당 항목과 그 이후에 소스 Observable에 의해 방출 된 모든 항목을 동일한 순서로 방출하는 Observable로 내부적으로 변환합니다. 예를 들어, 1,2,3을 방출하는 Observable을 내부적으로 3 개의 Observable로 변환합니다 : 1,2,3을 방출하는 것, 2,3을 방출하는 것, 3을 방출하는 것.</target>
        </trans-unit>
        <trans-unit id="852bf5291fc644db30f6e600aef002fc5fd9aca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09057d142824186fbe022f1998c81ae84e72dcae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; 는 다음 배포판 중 하나를 필요로합니다.</target>
        </trans-unit>
        <trans-unit id="5e1e17116f83269cfcbfba129278c4ac51598937" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt;/&lt;code&gt;select&lt;/code&gt; and &lt;code&gt;pluck&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; / &lt;code&gt;select&lt;/code&gt; 및 &lt;code&gt;pluck&lt;/code&gt; 은 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48520b92abdd1b6f13c2e1a944c18d0136643e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;materialize&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;materialize&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="03109dd70ccd2d5f3ce0b4ab597c88f2b1775f8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&lt;/code&gt; and &lt;code&gt;maxBy&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 및 &lt;code&gt;maxBy&lt;/code&gt; 는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="177fec1f130af6e4eaca7a4228a28a204b1d0476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxBy&lt;/code&gt; emits a list. If more than one item has the maximum key value, each such item will be represented in the list.</source>
          <target state="translated">&lt;code&gt;maxBy&lt;/code&gt; 는 목록을 내 보냅니다 . 둘 이상의 항목에 최대 키 값이 있으면 이러한 각 항목이 목록에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="027592fb8ecb9365d5e058e59e73870c0dd9b14f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge*&lt;/code&gt; converts an Observable that emits Observables into a single Observable that emits all of the items emitted by all of the emitted Observables.</source>
          <target state="translated">&lt;code&gt;merge*&lt;/code&gt; 는 Observable을 방출하는 Observable을 하나의 Observable로 변환하여 방출 된 모든 Observable이 방출하는 모든 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="d15ed57f77ad2ac1e3613ef0567150f3e1436e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge-delay-error*&lt;/code&gt; is a similarly-modified version of &lt;code&gt;merge*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge-delay-error*&lt;/code&gt; 는 비슷하게 수정 된 &lt;code&gt;merge*&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="e67f6049e6dc049459c7c289d724002ca5233350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge-delay-error&lt;/code&gt; is like &lt;code&gt;merge&lt;/code&gt;, but will emit all items from all of the merged Observables even if one or more of those Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification while emissions are still pending.</source>
          <target state="translated">&lt;code&gt;merge-delay-error&lt;/code&gt; 는 &lt;code&gt;merge&lt;/code&gt; 와 비슷하지만 배출이 아직 보류 중일 때 하나 이상의 해당 Observable이 &lt;code&gt;onError&lt;/code&gt; 알림으로 종료 되더라도 병합 된 모든 Observable에서 모든 항목을 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="ee7977d5c910e7ed3bb342e6e05eb0de4027e714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; converts two or more Observables into a single Observable that emits all of the items emitted by all of those Observables.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 는 둘 이상의 Observable을 단일 Observable로 변환하여 해당 Observable이 모두 방출하는 모든 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="9b76e9c0a1d27549afef80505e42f88c49ea336f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; merges a second Observable into the one it is operating on to create a new merged Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 는 새로운 Observable을 만들기 위해 운영중인 것과 Observable을 합칩니다.</target>
        </trans-unit>
        <trans-unit id="d6eb56447889e6eff2f5548660c3d51a27016c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; takes a second Observable as a parameter and merges that Observable with the one the &lt;code&gt;merge&lt;/code&gt; operator is applied to in order to create a new output Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 는 두 번째 Observable을 매개 변수로 가져 와서 Observable을 &lt;code&gt;merge&lt;/code&gt; 연산자가 적용되는 Observable과 병합 하여 새로운 출력 Observable을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="614290ed812f3587868cc3180159ce55ec920f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 는 Observable을 방출하는 Observable을 매개 변수로 사용합니다. 각 Observable에서 방출되는 항목을 병합하여 고유 한 단일 Observable 시퀀스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bf87e244577c5c553ce2ac58ddee944690c8ba13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; 은 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0395844b120445f674db48bf21d82e4cc405b67e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; is like this second variant of &lt;code&gt;merge&lt;/code&gt; except that it does not allow you to set this maximum subscription count. It only takes the single parameter of an Observable of Observables.</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; 은이 최대 가입 수를 설정할 수 없다는 점을 제외하면 이 두 번째 &lt;code&gt;merge&lt;/code&gt; 변형과 같습니다 . Observable of Observables의 단일 매개 변수 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e97640809c79f9e4649a2564f86200103b701783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; behaves much like &lt;code&gt;merge&lt;/code&gt;. The exception is when one of the Observables being merged terminates with an &lt;code&gt;onError&lt;/code&gt; notification. If this happens with &lt;code&gt;merge&lt;/code&gt;, the merged Observable will immediately issue an &lt;code&gt;onError&lt;/code&gt; notification and terminate. &lt;code&gt;mergeDelayError&lt;/code&gt;, on the other hand, will hold off on reporting the error until it has given any other non-error-producing Observables that it is merging a chance to finish emitting their items, and it will emit those itself, and will only terminate with an &lt;code&gt;onError&lt;/code&gt; notification when all of the other merged Observables have finished.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; 는 &lt;code&gt;merge&lt;/code&gt; 와 매우 유사하게 동작 합니다. 병합되는 Observable 중 하나가 &lt;code&gt;onError&lt;/code&gt; 알림으로 종료되는 경우는 예외입니다 . &lt;code&gt;merge&lt;/code&gt; 가 발생하면 병합 된 Observable은 즉시 &lt;code&gt;onError&lt;/code&gt; 알림을 발행 하고 종료합니다. &lt;code&gt;mergeDelayError&lt;/code&gt; 는 오류가 발생하지 않는 다른 Observables에 아이템 방출이 완료 될 기회를 제공 할 때까지 오류보고를 보류하고 자체적으로 방출하며 종료됩니다. &lt;code&gt;onError&lt;/code&gt; 다른 모든 Observables은이 완료 합병 통지.</target>
        </trans-unit>
        <trans-unit id="a167493a245b87e171e08f6f02fdf1ad8bc9e2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; has fewer variants. You cannot pass it an Iterable or Array of Observables, but you can pass it an Observable that emits Observables or between one and nine individual Observables as parameters. There is not an instance method version of &lt;code&gt;mergeDelayError&lt;/code&gt; as there is for &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; 는 변형이 적습니다. Iterable 또는 Array of Observables는 전달할 수 없지만 Observable을 방출하는 Observable 또는 매개 변수로 1-9 개의 개별 Observable을 전달할 수 있습니다. &lt;code&gt;merge&lt;/code&gt; 에 대한 것과 같이 &lt;code&gt;mergeDelayError&lt;/code&gt; 의 인스턴스 메소드 버전이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f0cfd0dcaa2b00079a42cbbc16dfd8134a7228f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; 는 다음 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df4328bd8b1f65ea0f113efcd6669bdfaa33239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; is similar to &lt;code&gt;merge&lt;/code&gt; except that it will always emit all items from both Observables even if one of the Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification before the other Observable has finished emitting items.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; 는 다른 Observable이 항목 방출을 마치기 전에 Observable 중 하나가 &lt;code&gt;onError&lt;/code&gt; 알림으로 종료 되더라도 항상 두 Observables에서 모든 항목을 방출한다는 점을 제외 하면 &lt;code&gt;merge&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="b82f40498bf692a5a78433f62179f34c2ce3ab0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_all&lt;/code&gt; and its alias &lt;code&gt;merge_observable&lt;/code&gt; take as their single parameter an Observable that emits Observables. They merge the emissions of all of these Observables to create their own Observable.</source>
          <target state="translated">&lt;code&gt;merge_all&lt;/code&gt; 및 별명 &lt;code&gt;merge_observable&lt;/code&gt; 은 Observable을 방출하는 Observable을 단일 매개 변수로 사용합니다. 그들은 모든 Observable의 배출물을 병합하여 자체 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bf6c5d2e202b7b40759b72a1934f54b5e9a83c2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_all&lt;/code&gt; is like &lt;code&gt;merge_concurrent(1)&lt;/code&gt;. It subscribes to each emitted Observable one at a time, mirroring its emissions as its own, and waiting to subscribe to the next Observable until the present one terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification. In this respect it is more like a Concat variant.</source>
          <target state="translated">&lt;code&gt;merge_all&lt;/code&gt; 은 &lt;code&gt;merge_concurrent(1)&lt;/code&gt; 과 같습니다 . 배출 된 각 Observable을 한 번에 하나씩 구독하여 자체 방출을 미러링하고 현재 Observable이 &lt;code&gt;onCompleted&lt;/code&gt; 알림으로 종료 될 때까지 다음 Observable을 구독합니다 . 이와 관련하여 Concat 변형과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="b9b205f7b96cb7796621bb13f277b683df3a9c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_concurrent&lt;/code&gt; operates on an Observable that emits Observables, merging the emissions from each of these Observables into its own emissions. You can optionally pass it an integer parameter indicating how many of these emitted Observables &lt;code&gt;merge_concurrent&lt;/code&gt; should try to subscribe to concurrently. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification. The default is 1, which makes it equivalent to &lt;code&gt;merge_all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge_concurrent&lt;/code&gt; 는 Observable을 방출하는 Observable에서 작동하며 이러한 Observable 각각의 배출을 자체 배출로 병합합니다. 선택적으로이 방출 된 Observable 중 얼마나 많은지를 &lt;code&gt;merge_concurrent&lt;/code&gt; 가 동시에 구독하려고 시도 하는지 나타내는 정수 매개 변수를 전달할 수 있습니다 . 이 최대 가입 수에 도달하면 이미 가입 한 Observables 중 하나가 &lt;code&gt;onCompleted&lt;/code&gt; 알림을 발행 할 때까지 소스 Observable이 방출 한 다른 Observable을 구독하지 않습니다 . 기본값은 1이며 &lt;code&gt;merge_all&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bd6a4567c47afea1f9ff91a96e2a66d903320fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; and &lt;code&gt;minBy&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;minBy&lt;/code&gt; 는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe33d78b21d502ce077f3e6214cf1f1e0a7a2b32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minBy&lt;/code&gt; emits a list. If more than one item has the minimum key value, each such item will be represented in the list.</source>
          <target state="translated">&lt;code&gt;minBy&lt;/code&gt; 는 목록을 내 보냅니다 . 둘 이상의 항목에 최소 키 값이 있으면 이러한 각 항목이 목록에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f478b05a123aaaa05e677793d3fd97a7fc5e6e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 다음 배포판에서는 찾을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1d1866924109e9670646683e6e6766eb97e7a636" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observeOn&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;observeOn&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14dc5b4b8485471c8c4af3ad8e073920b5b1958d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; 분포는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79a718b7958aac2f3f301ac09717b03f007e843a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ofType&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ofType&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="897f67f71a1a6044cc793578bc84958ce3a7edc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureBuffer&lt;/code&gt; maintains a buffer of all unobserved emissions from the source Observable and emits them to downstream observers according to the requests they generate.</source>
          <target state="translated">&lt;code&gt;onBackpressureBuffer&lt;/code&gt; 는 Observable 소스에서 관찰되지 않은 모든 방출의 버퍼를 유지하고 생성 된 요청에 따라 다운 스트림 관찰자에게 방출합니다.</target>
        </trans-unit>
        <trans-unit id="cae0fdf6c6ae888dae1f1dca903ede5835c8e193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureDrop&lt;/code&gt; drops emissions from the source Observable unless there is a pending request from a downstream observer, in which case it will emit enough items to fulfill the request.</source>
          <target state="translated">&lt;code&gt;onBackpressureDrop&lt;/code&gt; 은 다운 스트림 옵저버의 보류중인 요청이없는 경우 소스 Observable에서 방출을 떨어 뜨립니다.이 경우 요청을 이행하기에 충분한 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="8dad14f2756c6a7c1c084ae4a7d8630d2936a429" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureLatest&lt;/code&gt; (new in RxJava 1.1) holds on to the most-recently emitted item from the source Observable and immediately emits that item to its observer upon request. It drops any other items that it observes between requests from its observer.</source>
          <target state="translated">&lt;code&gt;onBackpressureLatest&lt;/code&gt; (RxJava 1.1의 새로운 기능)는 소스 Observable에서 가장 최근에 방출 된 항목을 유지하고 요청에 따라 즉시 해당 항목을 관찰자에게 방출합니다. 관찰자의 요청 사이에 관찰되는 다른 항목을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="dcb4b05219c46f2a0b6b1c9f6f952ca7e8293a54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorFlatMap&lt;/code&gt; handles a special case: a source Observable that is noncompliant with &lt;a href=&quot;../contract&quot;&gt;the Observable contract&lt;/a&gt; in such a way that it may interleave &lt;code&gt;onError&lt;/code&gt; notifications with its emissions without terminating. This operator allows you to replace those &lt;code&gt;onError&lt;/code&gt; notifications with the emissions of an Observable of your choosing without unsubscribing from the source, so that any future items emitted from the source will be passed along to observers as though the sequence had not been interrupted with an &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;onErrorFlatMap&lt;/code&gt; 은 특별한 경우 &lt;a href=&quot;../contract&quot;&gt;, 즉 Observable 계약&lt;/a&gt; 을 준수하지 않는 소스 Observable을 처리하여 &lt;code&gt;onError&lt;/code&gt; 알림을 종료하지 않고 방출과 함께 인터리브 할 수 있도록합니다 . 이 연산자를 사용하면 소스에서 구독을 취소하지 않고도 해당 &lt;code&gt;onError&lt;/code&gt; 알림을 선택한 Observable의 방출 로 대체 할 수 있으므로 소스에서 방출 된 모든 미래 항목이 시퀀스가 &lt;code&gt;onError&lt;/code&gt; 로 중단되지 않은 것처럼 관찰자에게 전달됩니다. 공고.</target>
        </trans-unit>
        <trans-unit id="2b872759b6ef289a58cf969ce8164979b4a51e72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 는 다음 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ce8ec757b038f51c2a32661634197b973e09f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; 및 &lt;code&gt;onError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd7ec9d67ac28a19f77f9e07b0ebd85713ac02e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; 및 &lt;code&gt;onCompleted&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e4196398c53c4e2d07989c689f8952690797af5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; 은 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c770e3f67c8bd25718da8165ccdb6ade967737f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition-all&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;step&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;step&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;n&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;step&amp;nbsp;=&amp;nbsp;n&lt;/code&gt; (which is the default if you omit the &lt;code&gt;step&lt;/code&gt; parameter) then the window size is the same as the step size and there will be a one-to-one correspondence between the items emitted by the source Observable and the items emitted by the collection of window Observables. If &lt;code&gt;step&amp;nbsp;&amp;lt;&amp;nbsp;n&lt;/code&gt; the windows will overlap by &lt;code&gt;n&amp;nbsp;&amp;minus;&amp;nbsp;step&lt;/code&gt; items; if &lt;code&gt;step&amp;nbsp;&amp;gt;&amp;nbsp;n&lt;/code&gt; the windows will drop &lt;code&gt;step&amp;nbsp;&amp;minus;&amp;nbsp;n&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">&lt;code&gt;partition-all&lt;/code&gt; 은 첫 번째 창을 즉시 엽니 다. 소스 Observable의 모든 &lt;code&gt;step&lt;/code&gt; 항목으로 시작하는 새 창을 엽니 다 (예를 들어, &lt;code&gt;step&lt;/code&gt; 가 3이면 매 3 번째 항목으로 시작하는 새 창을 엽니 다). 해당 창에서 &lt;code&gt;n&lt;/code&gt; 개의 항목 을 방출 했거나 소스 Observable에서 &lt;code&gt;onCompleted&lt;/code&gt; 또는 &lt;code&gt;onError&lt;/code&gt; 알림을 수신하면 각 창을 닫습니다 . 만약 &lt;code&gt;step&amp;nbsp;=&amp;nbsp;n&lt;/code&gt; (는 생략하면 기본값 인 &lt;code&gt;step&lt;/code&gt; 변수)을 다음 윈도우 크기는 스텝 크기와 동일하고 방출 관찰 가능한 소스에 의해 방출 된 항목 및 항목들 사이에 일대일 대응이있을 것 창 Observables의 컬렉션으로. 만약 &lt;code&gt;step&amp;nbsp;&amp;lt;&amp;nbsp;n&lt;/code&gt; 창은 &lt;code&gt;n&amp;nbsp;&amp;minus;&amp;nbsp;step&lt;/code&gt; 항목 만큼 겹쳐 질 것이다 ; 경우 &lt;code&gt;step&amp;nbsp;&amp;gt;&amp;nbsp;n&lt;/code&gt; 창문이 떨어질 것 &lt;code&gt;step&amp;nbsp;&amp;minus;&amp;nbsp;n&lt;/code&gt; 마다 창 사이에 관찰 가능한 소스에서 항목을.</target>
        </trans-unit>
        <trans-unit id="f84833cea1699df3f9c2492c38f87c6af17d1f1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but there is a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않지만 스케줄러를 매개 변수로 전달하여 스케줄러를 설정할 수있는 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eafc670c3b2d8e5043fd46a8907dcc34eb1f5b13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517b7b00820d459d58d54fad2526893d4209d655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; operates by default on the &lt;code&gt;currentThread&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but there is a variant that allows you to set the Scheduler by passing one in as the optional third parameter.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 는 &lt;code&gt;currentThread&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; 에서 기본적으로 작동 하지만 스케줄러를 선택적 세 번째 매개 변수로 전달하여 스케줄러를 설정할 수있는 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a05f7cc6a3cc8526b6a38205df25a5634604f34d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6d54f7eb381b9a648070132276d93e7ee0df8d0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; 는 다음 각 분포에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="657f9e448cd627b5f491b7783525a31edf1ce8b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; 에는 다음 배포판 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0129da905d929db4ea918fd5191306e7b396dbfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refCount&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;refCount&lt;/code&gt; 는 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d8010dd75a4a1c1c6ac0ecdc7cdf94b599657a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; 다음 분포에서 반복 이 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="0999f08cc9f2ca4d3eeb983282250b4bcab5e4a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat&lt;/code&gt; operates by default on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There is also a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; 기본적으로 &lt;code&gt;trampoline&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 반복이 작동합니다 . 스케줄러를 매개 변수로 전달하여 스케줄러를 설정할 수있는 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="161c846b7dafa9a83956414dd4c228d2f2b26cde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeatWhen&lt;/code&gt; operates by default on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There is also a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;repeatWhen&lt;/code&gt; 는 기본적으로 &lt;code&gt;trampoline&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동합니다 . 스케줄러를 매개 변수로 전달하여 스케줄러를 설정할 수있는 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b5f2f16447f11ba64e3a948984ca696d80d8a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replay&lt;/code&gt; and &lt;code&gt;shareReplay&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;replay&lt;/code&gt; 및 &lt;code&gt;shareReplay&lt;/code&gt; 재생 은 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00fe8d32c6838f3365164673884bc9df59b8c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; by default operates on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 기본적으로 재 시도 는 &lt;code&gt;trampoline&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="76be19f4fc07a54681d48e171bccef56c65fb404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 는 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd834c8bce0a7dab20890b38a2731341bb7b199" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single argument, a count of the number of times it should try resubscribing to the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 는 단일 인수를 취하는데, 오류가 발생했을 때 소스 Observable에 재가입을 시도해야하는 횟수입니다. 이 수를 초과하면 &lt;code&gt;retry&lt;/code&gt; 는 재가입을 시도하지 않고 대신 &lt;code&gt;onError&lt;/code&gt; 알림을 옵저버에게 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="46ac3633b230eaa4da4ae659b81b5fd1fd01a960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 는 단일 선택적 매개 변수를 취하는데, 오류가 발생할 때 소스 Observable을 다시 구독하고 미러링하려고 시도한 횟수입니다. 이 수를 초과하면 &lt;code&gt;retry&lt;/code&gt; 는 재가입을 시도하지 않고 대신 &lt;code&gt;onError&lt;/code&gt; 알림을 옵저버에게 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="78968626021de35abce2defdd55ea6bc88f55708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers. If you omit this parameter, &lt;code&gt;retry&lt;/code&gt; will attempt to resubscribe and mirror indefinitely, no matter how many &lt;code&gt;onError&lt;/code&gt; notifications it receives.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 는 단일 선택적 매개 변수를 취하는데, 오류가 발생했을 때 소스 Observable을 다시 구독하고 미러링하려고 시도한 횟수입니다. 이 수를 초과하면 &lt;code&gt;retry&lt;/code&gt; 는 재가입을 시도하지 않고 대신 &lt;code&gt;onError&lt;/code&gt; 알림을 옵저버에게 전달합니다 . 이 매개 변수를 생략하면, 수신 된 &lt;code&gt;onError&lt;/code&gt; 알림의 수에 관계없이 &lt;code&gt;retry&lt;/code&gt; 는 무한정 재가입 및 미러링을 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="7e3bb930ea61541d82eaef3c327715478723458b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retryInfinitely&lt;/code&gt;, on the other hand, will attempt to resubscribe to and mirror the source Observable indefinitely, no matter how many &lt;code&gt;onError&lt;/code&gt; notifications it receives.</source>
          <target state="translated">&lt;code&gt;retryInfinitely&lt;/code&gt; 는 얼마나 많은 &lt;code&gt;onError&lt;/code&gt; 알림을 받더라도 소스 Observable을 무제한으로 다시 구독하고 미러링하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="eaab55adc8c8a728f1f75c3bb1edfb90ef94d65c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retryWhen&lt;/code&gt; by default operates on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, and there is also a version that accepts a Scheduler as a parameter.</source>
          <target state="translated">&lt;code&gt;retryWhen&lt;/code&gt; 기본적으로 &lt;code&gt;trampoline&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하며 스케줄러를 매개 변수로 승인하는 버전도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4120f82ca0762ba3c67980e47fd96b3d4ff4e869" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;/&lt;code&gt;just&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; / &lt;code&gt;just&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6865b6419ccb621e514ec4fb6db7f12fbeb36594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;/&lt;code&gt;just&lt;/code&gt; operates by default on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can also pass in a Scheduler of your choosing as an optional second parameter, in which case it will operate on that Scheduler instead.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; / &lt;code&gt;just&lt;/code&gt; 온 기본적으로 작동 &lt;code&gt;immediate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; ,하지만 당신은 대신 스케줄러 것을에서 작동하는 경우에 선택적인 두 번째 매개 변수로 사용자가 선택한 스케줄러에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b4047a0ea36585603f6ec748627509f0b4a9855" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.async.compat.js&lt;/code&gt; (requires &lt;code&gt;rx.binding.js&lt;/code&gt; and either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.async.compat.js&lt;/code&gt; ( &lt;code&gt;rx.binding.js&lt;/code&gt; 및 &lt;code&gt;rx.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="99d0dd6df299ad0b8c56978d03652785c9ad339a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.async.js&lt;/code&gt; (requires &lt;code&gt;rx.binding.js&lt;/code&gt; and either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.async.js&lt;/code&gt; ( &lt;code&gt;rx.binding.js&lt;/code&gt; 및 &lt;code&gt;rx.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="39644825f66c15f5ee185ab93766411f09e927f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; ( &lt;code&gt;rx.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="a93ed12dffc1802ecae7f2aae2ec6a8f70ebd5be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; ( &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; 또는 &lt;code&gt;rx.lite.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="8b53d4d110e21e5825ad980e2a5e7cb13d935856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; ( &lt;code&gt;rx.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="be2cc3de70d097deb29bf9d0c5b850ca4930bbc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires either &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; ( &lt;code&gt;rx.lite.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="2357fcc02566cafce52d99070b5f15ba04fcac3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.experimental.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.experimental.js&lt;/code&gt; ( &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; 또는 &lt;code&gt;rx.lite.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="b80c6ea09cb52e61d700bbdb778801b2438d5986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.experimental.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.experimental.js&lt;/code&gt; ( &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; 또는 &lt;code&gt;rx.lite.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="6cc8c4efacdb08ca9c78c34c4d28e124e3430c88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; ( &lt;code&gt;rx.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="9e6345f31b107cb0269a8802101482908e912220" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; ( &lt;code&gt;rx.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="0a2f74b508eb1599da60aa8c859b12c78401a19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; 이 필요 &lt;code&gt;rx.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="55ebf3cb3c682607b13423bb830edbe481a23fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.timejs&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.timejs&lt;/code&gt; ( &lt;code&gt;rx.js&lt;/code&gt; 또는 &lt;code&gt;rx.compat.js&lt;/code&gt; 필요 )</target>
        </trans-unit>
        <trans-unit id="fc4cf9e648d81d20eae0105dc67ee6d7971f1afe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sample&lt;/code&gt; and &lt;code&gt;throttleFirst&lt;/code&gt; operate by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. They are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;sample&lt;/code&gt; 및 &lt;code&gt;throttleFirst&lt;/code&gt; 는 기본적으로 &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동합니다 . 그것들은 다음의 각 배포판에서 찾을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9642d89ad52f3aff730c9fe3b50d35f97e92dedf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scan&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;scan&lt;/code&gt; 은 다음 각 분포에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="becbe9059426bc4fdaba799ee68f66c3ae0ff3d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d1811fd6d4b8cc5e673ff4d9dd6085e1bd30090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; 에는 다음 분배 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b8c4ac4b83afedf5680116e88c507a16fc48b2f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; and &lt;code&gt;shareValue&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; 및 &lt;code&gt;shareValue&lt;/code&gt; 는 다음 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a461966af16fa4245c4bf73e1a8c7b411d6636cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;single&lt;/code&gt; also has a version that accepts a predicate, and emits the sole item emitted by the source Observable that matches that predicate, or notifies of an exception if exactly one such item does not match.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; 에는 술어를 허용하는 버전이 있으며 소스 Observable에서 방출 한 유일한 술어를 해당 술어와 일치 시키거나 해당 항목 중 하나가 정확히 일치하지 않으면 예외를 통지합니다.</target>
        </trans-unit>
        <trans-unit id="bb3c85771d4d9bde7a35c9a62319373f3d8d96cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;single&lt;/code&gt; also has a version that accepts a predicate, and returns the sole item emitted by the source Observable that matches that predicate, or throws an exception if exactly one such item does not match.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; 에는 술어를 허용하는 버전이 있으며 해당 Obdicateable과 일치하는 소스 Observable에서 생성 한 유일한 항목을 반환하거나 해당 항목 중 하나가 정확히 일치하지 않으면 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d6b89edd7f0936e1694c251ce2e83ac36b9534cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skip&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; 은 다음 각 분포에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="7842b740b14a1bb4f092eb32d23be6838b6de48c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLast&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipLast&lt;/code&gt; 는 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd24cf6d6309824f9efd2307264bd0c82d87abd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLastWithTime&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional second parameter.</source>
          <target state="translated">&lt;code&gt;skipLastWithTime&lt;/code&gt; 은 기본적으로 &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하지만 선택적인 두 번째 매개 변수로 선택한 스케줄러를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b0ea964517cee199a2e9698d0f8b9b282d1a2d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLastWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipLastWithTime&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f855d9577dee628df260ad5b16cd6e2f479e252e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntil&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;skipUntil&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0efb342bef695a8ba90ab5c3a186c1d1e80d96db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipUntil&lt;/code&gt; 은 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0054a1a7c41a519ebdff4961eb2a9c6387f209df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntilWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipUntilWithTime&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aedae37e764a8cae3228eb19bf3866cfec747304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipWhile&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;skipWhile&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3d271030a25e4748daf89de63d1f23c0bf647fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipWhile&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipWhile&lt;/code&gt; 은 다음 배포판 각각에 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d8fb08b646ff0db07c057e6b35171eb8becd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sliding(timespan,timeshift,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding(timespan,timeshift,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6b6f01fe681143dafffd2ce2f286570c01a2fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sliding(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="340607a150f05545c373687c169c0693f97e838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;Seq&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;slidingBuffer(count, skip)&lt;/code&gt; 는 소스 Observable에서 첫 번째로 방출 된 항목으로 시작하여 그 이후의 모든 &lt;code&gt;skip&lt;/code&gt; 항목으로 시작하여 새 버퍼를 작성하고 각 버퍼를 &lt;code&gt;count&lt;/code&gt; 항목 (초기 항목 및 &lt;code&gt;count-1&lt;/code&gt; 후속 항목)으로 채 웁니다 . 이 버퍼를 &lt;code&gt;Seq&lt;/code&gt; 로 방출합니다 . &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;skip&lt;/code&gt; 값에 따라 이러한 버퍼가 겹치거나 (여러 버퍼에 동일한 항목이 포함될 수 있음) 간격이있을 수 있습니다 (소스 Observable에서 생성 한 항목이 버퍼에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="e800efd9702220c22509e95b689d97ed23b2e491" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(openings,closings)&lt;/code&gt; monitors the &lt;code&gt;openings&lt;/code&gt; Observable, and, whenever it emits an &lt;code&gt;Opening&lt;/code&gt; item, &lt;code&gt;slidingBuffer&lt;/code&gt; creates a new &lt;code&gt;Seq&lt;/code&gt;, begins to collect items subsequently emitted by the source Observable into this buffer, and calls &lt;code&gt;closings&lt;/code&gt; to get a new Observable to govern the closing of that buffer. When this new Observable emits an item or terminates, &lt;code&gt;slidingBuffer&lt;/code&gt; closes and emits the &lt;code&gt;Seq&lt;/code&gt;that the Observable governs.</source>
          <target state="translated">&lt;code&gt;slidingBuffer(openings,closings)&lt;/code&gt; 는 &lt;code&gt;openings&lt;/code&gt; Observable을 모니터링 하고, &lt;code&gt;Opening&lt;/code&gt; 항목을 방출 할 때마다 &lt;code&gt;slidingBuffer&lt;/code&gt; 는 새로운 &lt;code&gt;Seq&lt;/code&gt; 을 생성 하고 소스 Observable이이 버퍼로 배출 한 항목을 수집하기 시작 하고 새 Observable을 관리하기 위해 &lt;code&gt;closings&lt;/code&gt; 를 호출합니다. 그 버퍼의 닫힘 이 새로운 Observable이 아이템을 방출하거나 종료 할 때 &lt;code&gt;slidingBuffer&lt;/code&gt; 는 Observable이 관장하는 &lt;code&gt;Seq&lt;/code&gt; 를 닫고 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="3a2d8b32d98cd2d85f509ed919d5b6fe0c839176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(timespan, timeshift)&lt;/code&gt; creates a new &lt;code&gt;Seq&lt;/code&gt; of items every &lt;code&gt;timeshift&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;), and fills this buffer with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; (also a &lt;code&gt;Duration&lt;/code&gt;) has passed since the buffer&amp;rsquo;s creation, before emitting this &lt;code&gt;Seq&lt;/code&gt; as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;slidingBuffer(timespan, timeshift)&lt;/code&gt; 새로운 생성 &lt;code&gt;Seq&lt;/code&gt; 항목마다 &lt;code&gt;timeshift&lt;/code&gt; (A &lt;code&gt;Duration&lt;/code&gt; )과까지 시간에서 관찰 가능한 소스에 의해 방출 된 모든 항목이 버퍼 채우는 &lt;code&gt;timespan&lt;/code&gt; (도 &lt;code&gt;Duration&lt;/code&gt; ) 버퍼의 생성 경과하여 발광 전 이 &lt;code&gt;Seq&lt;/code&gt; 는 자체 방출입니다. 경우 &lt;code&gt;timespan&lt;/code&gt; 더 이상보다 &lt;code&gt;timeshift&lt;/code&gt; , 방출 어레이는 중복 기간을 나타냅니다 그들은 중복 항목을 포함 할 수 있도록. &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 사용하고이를 사용하여 시간 범위를 제어하는 이 운영자 변형 버전도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24dd0a01354cced0a2acf0aa8063d70ee7f154a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 는 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed91665030b67875ffc98a470567ddb8eb0537e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startAsync&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;startAsync&lt;/code&gt; 는 다음 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7557812c5d12bce96afff2c6f2acef59e4f6bf67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startWith&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;startWith&lt;/code&gt; 는 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21a9ba7e0e5a1992b4c0bbcf9fa451a208dde737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeOn&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;subscribeOn&lt;/code&gt; 은 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e82eb96c199934418a5718cf08684f1241d7a926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;sum&lt;/code&gt; 은 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70375bcfc9c823861ed0e18d51cf92d8acf08eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 는 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1afa68f56894c76f703ac9f3769b28164434fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 는 다음 각 분포에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="7a4525d7b7fbc759ff9dd8eb06674f4280a9073b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLast&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; 는 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2941ac03f0842c43596c3b89634f04257ea7c68b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBuffer&lt;/code&gt; also has its duration-based variant, &lt;code&gt;takeLastBufferWithTime&lt;/code&gt;, which is similar to &lt;code&gt;takeLastWithTime&lt;/code&gt; except that it emits its items not individually but collected into a single array of items that is emitted as a single item.</source>
          <target state="translated">&lt;code&gt;takeLastBuffer&lt;/code&gt; 는 또한 시간 기반 변형 갖는다 &lt;code&gt;takeLastBufferWithTime&lt;/code&gt; 유사 &lt;code&gt;takeLastWithTime&lt;/code&gt; 그것의 개별적 아이템되지 않지만 단품으로 출사 항목 단일 배열로 수집을 방출하는 것을 제외한다.</target>
        </trans-unit>
        <trans-unit id="fc5a21060536e4921b09043d6957f61a67e85859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBuffer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastBuffer&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d02450ab9c999ca1cdd1497e8d7bf3269e1ad1a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBufferWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastBufferWithTime&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b665df985a737dfb05ba93333df8ea966170a9ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastWithTime&lt;/code&gt; by default operates the timer on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; and emits items on the &lt;code&gt;currentThread&lt;/code&gt; Scheduler, but you may also pass in Schedulers of your choosing to override these, as an optional second and third parameters, respectively.</source>
          <target state="translated">&lt;code&gt;takeLastWithTime&lt;/code&gt; 은 기본적으로 &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 타이머를 작동하고 &lt;code&gt;currentThread&lt;/code&gt; 스케줄러에서 항목을 내보내 지만, 선택적인 두 번째 및 세 번째 매개 변수로이를 재정의하도록 선택한 스케줄러를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="14da141683decf3ce03f63343d83fd24c709bfb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastWithTime&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20c87a0557376049c73e16b9f4ff3c38215594a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="37d6c84288e3575f42359e8018cdff6b7b45d977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9042095065b7d2b25a7d1e092da6338622f2d9fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntilWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeUntilWithTime&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb79aed0b0d7386fc7de8e365183d8e2e8e7ca97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3df06abff8c84fc5b0f1f4a67410984a32d92db1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; 은 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a8ebe39bb4a1d479f5ac26c962f779363985e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttleFirst&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">&lt;code&gt;throttleFirst&lt;/code&gt; 는 기본적으로 &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지만 선택적으로 세 번째 매개 변수로 선택한 스케줄러를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e58e7fab93ffb2601599bf75a4c5989ad7f8b9cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throw&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 다음 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12fb397d3568ae4d036414110394066d39b1ed4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; by default operates on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; 기본적으로 timeInterval 은 &lt;code&gt;immediate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하지만 스케줄러를 매개 변수로 전달하여 스케줄러를 지정할 수있는 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="757c130c5ec90e41b55716e7d8ceb364f6a8e288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; 은 기본적으로 &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하지만 스케줄러를 매개 변수로 전달하여 스케줄러를 지정할 수있는 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="71b3b52092b0ce3ee3f4d96c9a24a943c2d938d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b213b55f226a478725826835dafe9681d5f8644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;timeoutWithSelector&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 및 &lt;code&gt;timeoutWithSelector&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce975a53ac15047ca82f47b9d9d146a0d85da69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeoutWithSelector&lt;/code&gt; does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an &lt;code&gt;onError&lt;/code&gt; notification (&amp;ldquo;&lt;code&gt;Error: Timeout&lt;/code&gt;&amp;rdquo;) from the Observable &lt;code&gt;timeoutWithSelector&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;timeoutWithSelector&lt;/code&gt; 는 일정한 시간 초과 기간을 사용하지 않지만 소스 Observable의 각 항목을 Observable을 반환하는 함수로 전달한 다음 해당 Observable을 모니터링하여 항목별로 시간 초과 기간을 설정합니다. 소스 Observable이 다른 항목을 방출하기 전에 이러한 Observable이 완료되면 이는 시간 종료 조건으로 간주 되며 Observable &lt;code&gt;timeoutWithSelector&lt;/code&gt; 리턴 에서 &lt;code&gt;onError&lt;/code&gt; 알림 (&amp;ldquo; &lt;code&gt;Error: Timeout&lt;/code&gt; &amp;rdquo;)을 트리거 합니다.</target>
        </trans-unit>
        <trans-unit id="73773bfa5b563e9eba5535983817af426985e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can override this by passing in a Scheduler as a final parameter.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 는 기본적으로 &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하거나 스케줄러를 최종 매개 변수로 전달하여이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cbc3a49fd6d590f7657eb64c4bf3aee582bf2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can override this by passing in a Scheduler as a final parameter.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 는 기본적으로 &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하거나 스케줄러를 최종 매개 변수로 전달하여이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166b0d0c1925597895a20348e99d636f269ba52f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6994ab170fc57b3c6ae8b13a3eb78514353eada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; returns an Observable that emits a single number zero after a delay period you specify.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 는 지정한 지연 기간 후에 단일 숫자 0을 방출하는 Observable을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d152bee231bbb8e03f92f397a5f47c8bc06dd80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; by default operates on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; but also has a variant that allows you to choose the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 기본적으로 타임 스탬프 는 &lt;code&gt;immediate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하지만 스케줄러를 매개 변수로 전달하여 스케줄러를 선택할 수있는 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c4b64c965f491d895a7583ac5fd6181c6b636c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 는 기본적으로 타임 &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하지만 스케줄러를 매개 변수로 전달하여 스케줄러를 지정할 수있는 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="44cd8475782d97de9ca5e1e58e9b309ed7b54305" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c19fb0c2dc91fdd7ff204e2e2b3dde5ed1cea6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toArray&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toArray&lt;/code&gt; 는 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2436f143a44933d4ae386a7d36228fa95d3b9e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toAsync&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;toAsync&lt;/code&gt; 는 다음 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bf929490433a6f89a9386a35013a74f1cafb6c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toList&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toList&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="480dfc94c15fb8040d8e100d3fa4d5194e955fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMap&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toMap&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f3c39b03d1c2b125af83fb8e2d096e30c15ec785" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toMap&lt;/code&gt; 은 다음 각 분포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9c9dc84a67060553324ea4b1a5883b58175151" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMultiMap&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toMultiMap&lt;/code&gt; 은 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ea2ad74dcc9fb9b4b1703685d68edf066c0841f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toSet&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toSet&lt;/code&gt; 은 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec7965f3d811250e08e8d9ceb0744100f593b518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toSortedList&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toSortedList&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="46584cfb17a9dfd026e64a70ece0028c2345433e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumbling(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tumbling(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="946b7fdda870bee85c6810d8f4b8baea15808387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumbling(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tumbling(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="114b0ca34209466be8813d092973923f1b9b4190" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(boundary)&lt;/code&gt; monitors an Observable, &lt;code&gt;boundary&lt;/code&gt;. Each time that Observable emits an item, it creates a new &lt;code&gt;Seq&lt;/code&gt; to begin collecting items emitted by the source Observable and emits the previous &lt;code&gt;Seq&lt;/code&gt;. This variant of the operator has an optional second parameter, &lt;code&gt;initialCapacity&lt;/code&gt; with which you can indicate the expected size of these buffers so as to make memory allocation more efficient.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(boundary)&lt;/code&gt; 는 Observable, &lt;code&gt;boundary&lt;/code&gt; 를 모니터링합니다 . Observable이 항목을 방출 할 때마다 소스 Observable이 방출 한 항목을 수집하기 위해 새 &lt;code&gt;Seq&lt;/code&gt; 을 작성 하고 이전 &lt;code&gt;Seq&lt;/code&gt; 를 방출합니다 . 이 연산자의 변형은 선택적 두 번째 매개 변수 인 &lt;code&gt;initialCapacity&lt;/code&gt; 를 사용하여 메모리 할당을보다 효율적으로하기 위해 이러한 버퍼의 예상 크기를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d46125dcac2cbaa797114df6c032348ed56b10dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;Seq&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted buffer may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(count)&lt;/code&gt; 형태의 비 중첩 버퍼 방출 &lt;code&gt;Seq&lt;/code&gt; 대부분에 포함 된 각각의 S, &lt;code&gt;count&lt;/code&gt; (최종 출사 버퍼보다 적게 가질 수도 관찰 가능한 소스로부터 항목 &lt;code&gt;count&lt;/code&gt; 항목).</target>
        </trans-unit>
        <trans-unit id="bfd1e55878e9963160e69e3e46fbcc3ba5b0c630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(timespan)&lt;/code&gt; emits a new &lt;code&gt;Seq&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;), containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. This variant of the operator has an optional second parameter, &lt;code&gt;scheduler&lt;/code&gt;, with which you can set the &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; that you want to govern the timespan calculation.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(timespan)&lt;/code&gt; 은 이전 번들 방출 이후 또는 첫 번째 번들의 경우 소스 Observable에 가입 ​​한 이후 소스 Observable에서 방출 한 모든 항목을 포함하는 모든 &lt;code&gt;timespan&lt;/code&gt; ( &lt;code&gt;Duration&lt;/code&gt; ) 마다 주기적으로 새 항목 &lt;code&gt;Seq&lt;/code&gt; 을 방출합니다. 이 연산자의 변형에는 선택적 두 번째 매개 변수 인 &lt;code&gt;scheduler&lt;/code&gt; 가 있으며,이를 통해 시간 범위 계산을 제어하려는 &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b21cd4f65fc506789ef4e59831405d1e22f95404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(timespan, count)&lt;/code&gt; emits a new &lt;code&gt;Seq&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;) has elapsed since its last bundle emission, it emits a &lt;code&gt;Seq&lt;/code&gt; containing however many items the source Observable emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. This variant of the operator has an optional third parameter, &lt;code&gt;scheduler&lt;/code&gt;, with which you can set the &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; that you want to govern the timespan calculation.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(timespan, count)&lt;/code&gt; 는 소스 Observable이 방출 한 모든 &lt;code&gt;count&lt;/code&gt; 항목에 대해 새로운 &lt;code&gt;Seq&lt;/code&gt; 항목을 방출하거나, 마지막 번들 방출 이후에 &lt;code&gt;Duration&lt;/code&gt; &lt;code&gt;timespan&lt;/code&gt; ( Duration )이 경과 한 경우 소스 Observable이 방출 한 많은 항목을 포함 하는 &lt;code&gt;Seq&lt;/code&gt; 를 방출합니다. 그 기간에,이보다 적은 경우에도 &lt;code&gt;count&lt;/code&gt; . 이 연산자의 변형에는 선택적 세 번째 매개 변수 인 &lt;code&gt;scheduler&lt;/code&gt; 가 있으며,이를 통해 시간 범위 계산을 제어 할 &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3dbb96ec506e9ea7b859c90a031a511f04f5a25b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 기본적으로 사용 은 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="67fe99075e97e899a8a29e4d7d6bbf8bc6656d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 은 다음 각 배포판에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9180af64681c5e6bbe87c5747504627d06e37279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; is found in the &lt;code&gt;rx.experimental.js&lt;/code&gt; distribution. It requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 에서 발견된다 &lt;code&gt;rx.experimental.js&lt;/code&gt; 유통. 다음 배포판 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="33cff6c004ac3784284d1aafacb977d88056d9a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, timeshift, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, timeshift, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa5feef256593decbc4e3c0668b5c74c2b7542ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, unit, count&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, unit, count&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88858274463fe4c29e450ff892be4ab3cdd04ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8df2411d37d8d9a19673d8cc2fca09e073fe8588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTime(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTime(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0082a3e53e214cc5277d43c253721adf6ffebe46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTime(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTime(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afd4e92b2e4ccb74b8e4469f1bd7c11303336a25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTimeOrCount(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTimeOrCount(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ba9f5753ce09bb018d7eea164bf09706e308337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTimeOrCount&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;windowWithTimeOrCount&lt;/code&gt; 는 첫 번째 창을 즉시 엽니 다. 현재 열린 창을 닫고 &lt;code&gt;timespan&lt;/code&gt; 밀리 초) (선택적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 측정 ) 또는 현재 열려있는 창에서 &lt;code&gt;count&lt;/code&gt; 항목 을 방출 할 때마다 다른 창을 엽니 다 . 또한 소스 Observable로부터 &lt;code&gt;onCompleted&lt;/code&gt; 또는 &lt;code&gt;onError&lt;/code&gt; 알림을 수신하면 현재 열려있는 창을 닫습니다 . &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; 는 집단 배출이 소스 Observable의 배출과 일대일로 대응하는 일련의 겹치지 않는 창을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="fd00380205a686ee17604d17356c523c0e72c3a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(period, skip&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(period, skip&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db0580b8d43ac68544b774f2554c7d3ba35e259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(period&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(period&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82e83f25479adacc961806d24bc915b042ddee0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fee332926b0d48f2889ec46f5f950b3c4e76d18c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89d3d2c45562db6fe6c52b9d1508809b4531e5ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count(period, count&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count(period, count&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f76e50530b051a16903cb3a749bbf3d0ebcbc93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="641566bee8a202a27ae03c144854e648d69bf89d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;period&lt;/code&gt; of time (optionally computed by a given Coordination) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count&lt;/code&gt; 는 첫 번째 창을 즉시 엽니 다. 현재 열려있는 창을 닫고 매 &lt;code&gt;period&lt;/code&gt; 마다 (선택적으로 지정된 조정에 의해 계산 됨) 또는 현재 열려있는 창에서 &lt;code&gt;count&lt;/code&gt; 항목 을 방출 할 때마다 다른 창을 엽니 다 . 또한 소스 Observable로부터 &lt;code&gt;onCompleted&lt;/code&gt; 또는 &lt;code&gt;onError&lt;/code&gt; 알림을 수신하면 현재 열려있는 창을 닫습니다 . &lt;code&gt;window_with_time_or_count&lt;/code&gt; 는 집단 배출이 소스 Observable의 배출과 일대일로 대응하는 일련의 겹치지 않는 창을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="58c4c18c7ec6364acc53cb5fe05e73f534b19a73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count&lt;/code&gt; 는 첫 번째 창을 즉시 엽니 다. 현재 열린 창을 닫고 &lt;code&gt;timespan&lt;/code&gt; 밀리 초) (선택적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 측정 ) 또는 현재 열려있는 창에서 &lt;code&gt;count&lt;/code&gt; 항목 을 방출 할 때마다 다른 창을 엽니 다 . 또한 소스 Observable로부터 &lt;code&gt;onCompleted&lt;/code&gt; 또는 &lt;code&gt;onError&lt;/code&gt; 알림을 수신하면 현재 열려있는 창을 닫습니다 . &lt;code&gt;window_with_time_or_count&lt;/code&gt; 는 집단 배출이 소스 Observable의 배출과 일대일로 대응하는 일련의 겹치지 않는 창을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="dc83188733343337e00c5f1f317f3281f7cb8498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; accepts a variable number of Observables or Promises as parameters, followed by a function that accepts one item emitted by each of those Observables or resolved by those Promises as input and produces a single item to be emitted by the resulting Observable.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 은 가변 개수의 Observables 또는 Promises를 매개 변수로 승인 한 다음 각 해당 Observable이 방출하거나 해당 Promises가 입력으로 분석 한 하나의 항목을 승인하고 결과 Observable이 방출 할 단일 항목을 생성하는 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="36e1debe572209b748af04eb0b1aaf0617354592" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;zipWith&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 및 &lt;code&gt;zipWith&lt;/code&gt; 는 기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4541e5aef8fc275a2be0435a981bbc433ea604d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zipArray&lt;/code&gt; accepts a variable number of Observables as parameters and returns an Observable that emits arrays, each one containing the</source>
          <target state="translated">&lt;code&gt;zipArray&lt;/code&gt; 는 가변 개수의 Observable을 매개 변수로 받아들이고 각각을 포함하는 배열을 방출하는 Observable을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73c6161ea024bd469cc2d9d1691023d9244d7b73" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; item from each source Observable.</source>
          <target state="translated">&lt;sup&gt;일&lt;/sup&gt; 관찰 가능한 각 소스에서 항목을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2e3866d4dc2075c3f5d0d914e8fb5c6c5cf655d6" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; item that it expected.</source>
          <target state="translated">&lt;sup&gt;일&lt;/sup&gt; 이 예상 있다는 항목입니다.</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="5a9ea636768e98730048d960cb7b94ce27c67345" translate="yes" xml:space="preserve">
          <source>A Decision Tree of Observable Operators</source>
          <target state="translated">관찰 가능한 연산자의 의사 결정 트리</target>
        </trans-unit>
        <trans-unit id="2b08c72f6a37159d94745e3d486d34e86abda5ad" translate="yes" xml:space="preserve">
          <source>A Single is something like an Observable, but instead of emitting a series of values &amp;mdash; anywhere from none at all to an infinite number &amp;mdash; it always either emits one value or an error notification.</source>
          <target state="translated">Single은 Observable과 비슷하지만, 아무 것도없는 곳에서 무한한 곳으로 일련의 값을 내보내는 대신 항상 하나의 값이나 오류 알림을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ab0a565fcadf77db3f8a879c0832ebb221aa9780" translate="yes" xml:space="preserve">
          <source>A Single will call only one of these methods, and will only call it once. Upon calling either method, the Single terminates and the subscription to it ends.</source>
          <target state="translated">Single은 이러한 메소드 중 하나만 호출하고 한 번만 호출합니다. 두 메소드 중 하나를 호출하면 Single이 종료되고 구독이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="59605fccb31cb127c02c09296155efa5fe013b9c" translate="yes" xml:space="preserve">
          <source>A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.</source>
          <target state="translated">주제는 관찰자와 관찰자 역할을하는 ReactiveX의 일부 구현에서 사용할 수있는 일종의 브리지 또는 프록시입니다. 관찰자이므로 하나 이상의 Observable을 구독 할 수 있으며 Observable이므로 관찰하여 항목을 취소하여 전달할 수 있으며 새 항목을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5115867d3f9ec7f7973522f38b1446136baf293" translate="yes" xml:space="preserve">
          <source>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;em&gt;in turn&lt;/em&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</source>
          <target state="translated">관찰 가능한 사업자의 체인은 체인 유래 원래 관찰 가능한 독립적으로 동작하지 않지만, 작동 &lt;em&gt;차례로&lt;/em&gt; 체인 직전의 오퍼레이터에 의해 생성 된 관찰에서 각각 동작한다.</target>
        </trans-unit>
        <trans-unit id="4aa1692172bf25b6129069ba0c0eaa218eb4bcab" translate="yes" xml:space="preserve">
          <source>A more complete &lt;code&gt;subscribe&lt;/code&gt; call example looks like this:</source>
          <target state="translated">보다 완전한 &lt;code&gt;subscribe&lt;/code&gt; 호출 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0af329e9352bf7003c7730a1fbf549f05c11689" translate="yes" xml:space="preserve">
          <source>A related operator, IsEmpty returns an Observable that emits &lt;code&gt;true&lt;/code&gt; if and only if the source Observable completes without emitting any items. It emits &lt;code&gt;false&lt;/code&gt; if the source Observable emits an item.</source>
          <target state="translated">관련 연산자 인 IsEmpty는 소스 Observable이 항목을 내 보내지 않고 완료된 경우에만 &lt;code&gt;true&lt;/code&gt; 를 방출하는 Observable을 반환 합니다. 그것은 방출 &lt;code&gt;false&lt;/code&gt; 소스 관찰 가능한 방출하는 항목의 경우.</target>
        </trans-unit>
        <trans-unit id="3bd6fdbcf4ffd98efa9870facaa7222cee24194a" translate="yes" xml:space="preserve">
          <source>A second possibility is to use the &lt;code&gt;windowed(&lt;/code&gt;</source>
          <target state="translated">두 번째 가능성은 &lt;code&gt;windowed(&lt;/code&gt; 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="470bb39ca8f873b411a9bf2795442d8e2de5abb2" translate="yes" xml:space="preserve">
          <source>A second variant of &lt;code&gt;forkJoin&lt;/code&gt; exists as a prototype function, and you call it on an instance of one source Observable, passing it another source Observable as a parameter. As a second parameter, you pass it a function that combines the final item emitted by the two source Observables into the sole item to be emitted by the resulting Observable.</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; 의 두 번째 변형은 프로토 타입 함수로 존재하며 한 소스 Observable의 인스턴스에서 호출하여 다른 소스 Observable을 매개 변수로 전달합니다. 두 번째 매개 변수로, 두 개의 소스 Observable이 생성 한 최종 항목을 결과 Observable이 생성하는 유일한 항목으로 결합하는 함수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="80636dd32da61a598e55857994e632bbd4be9e7d" translate="yes" xml:space="preserve">
          <source>A second variant of &lt;code&gt;timeout&lt;/code&gt; differs from the first in that instead of issuing an error notification in case of a timeout condition, it instead immediately switches to a backup Observable that you specify.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 의 두 번째 변형은 시간 초과 조건의 경우 오류 알림을 발행하는 대신 사용자가 지정한 백업 Observable로 즉시 전환한다는 점에서 첫 번째 변형과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1014e078d9399bc4430b8c0f57f75f79b89ad343" translate="yes" xml:space="preserve">
          <source>A second version of this operator was released in RxGroovy 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt;.</source>
          <target state="translated">이 연산자의 두 번째 버전은 RxGroovy 1.1에서 릴리스되었습니다. 결과 Observable 시퀀스를 종료하기 위해 두 번째 Observable이 아닌 소스 Observable이 방출 한 항목을 평가하는 술어 함수를 사용합니다. 이러한 방식으로 &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt; 과 유사한 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a3a7d4a46c5c7bc15a9d7db1fc1edb5b764d3a73" translate="yes" xml:space="preserve">
          <source>A second version of this operator was released in RxJava 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt;.</source>
          <target state="translated">이 연산자의 두 번째 버전은 RxJava 1.1에서 릴리스되었습니다. 결과 Observable 시퀀스를 종료하기 위해 두 번째 Observable이 아닌 소스 Observable이 방출 한 항목을 평가하는 술어 함수를 사용합니다. 이러한 방식으로 &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt; 과 유사한 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="bdc9c3e84a8e5b9e18d52bf83f76d74a848d15d8" translate="yes" xml:space="preserve">
          <source>A similar operator is &lt;code&gt;ofObjectChanges&lt;/code&gt;. It returns an Observable that emits any changes made to a particular object, as reported by its &lt;code&gt;Object.observe&lt;/code&gt; method. It is also found only in the &lt;code&gt;rx.all.js&lt;/code&gt; distribution.</source>
          <target state="translated">비슷한 연산자는 &lt;code&gt;ofObjectChanges&lt;/code&gt; 입니다. &lt;code&gt;Object.observe&lt;/code&gt; 메소드에 의해보고 된대로 특정 오브젝트에 대한 변경 사항을 내보내는 Observable을 리턴합니다 . &lt;code&gt;rx.all.js&lt;/code&gt; 배포판 에서도 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d9b3babb124228b9672822ea408e026abe9f755" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;retry&lt;/code&gt; takes a predicate function as a parameter. You write this function to accept two arguments: an Int count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the &lt;code&gt;onError&lt;/code&gt; notification. This function returns a Boolean to indicate whether or not &lt;code&gt;retry&lt;/code&gt; should resubscribe to and mirror the source Observable. If it does not, then &lt;code&gt;retry&lt;/code&gt; passes the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 의 세 번째 변형은 조건 자 함수를 매개 변수로 사용합니다. 이 함수를 작성하여 지금까지 발생한 재시도 횟수의 Int 수와 &lt;code&gt;onError&lt;/code&gt; 알림 을 발생시킨 오류를 나타내는 Throwable을 사용할 수 있습니다. 이 함수는 부울을 반환하여 &lt;code&gt;retry&lt;/code&gt; 를 통해 소스 Observable을 다시 구독하고 미러링해야하는지 여부를 나타냅니다 . 그렇지 않은 경우 &lt;code&gt;retry&lt;/code&gt; 하면 최신 &lt;code&gt;onError&lt;/code&gt; 알림을 관찰자에게 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="c9c9ea5b2183ed2e503c70773c2a45edce947b6d" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;retry&lt;/code&gt; takes a predicate function as a parameter. You write this function to accept two arguments: an Integer count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the &lt;code&gt;onError&lt;/code&gt; notification. This function returns a Boolean to indicate whether or not &lt;code&gt;retry&lt;/code&gt; should resubscribe to and mirror the source Observable. If it does not, then &lt;code&gt;retry&lt;/code&gt; passes the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 의 세 번째 변형은 조건 자 함수를 매개 변수로 사용합니다. 이 함수를 작성하여 지금까지 발생한 재시도 횟수의 정수와 &lt;code&gt;onError&lt;/code&gt; 알림 을 발생시킨 오류를 나타내는 Throwable을 사용할 수 있습니다. 이 함수는 부울을 반환하여 &lt;code&gt;retry&lt;/code&gt; 를 통해 소스 Observable을 다시 구독하고 미러링해야하는지 여부를 나타냅니다 . 그렇지 않은 경우 &lt;code&gt;retry&lt;/code&gt; 하면 최신 &lt;code&gt;onError&lt;/code&gt; 알림을 관찰자에게 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="59dc0040b390fb0df014aee4d31dbc580181dd4c" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;timeout&lt;/code&gt; does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an &lt;code&gt;onError&lt;/code&gt; notification (&amp;ldquo;&lt;code&gt;TimeoutException&lt;/code&gt;&amp;rdquo;) from the Observable &lt;code&gt;timeout&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 의 세 번째 변형은 일정한 시간 초과 기간을 사용하지 않지만 소스 Observable의 각 항목을 Observable을 반환하는 함수로 전달한 다음 해당 Observable을 모니터링하여 항목 별 시간 초과 기간을 설정합니다. 소스 Observable이 다른 항목을 방출하기 전에 이러한 Observable이 완료되면 이는 시간 초과 조건으로 간주 되며 Observable &lt;code&gt;timeout&lt;/code&gt; 반환 에서 &lt;code&gt;onError&lt;/code&gt; 알림 (&amp;ldquo; &lt;code&gt;TimeoutException&lt;/code&gt; &amp;rdquo;)을 트리거 합니다.</target>
        </trans-unit>
        <trans-unit id="e63b86ec2cc6e89e587945cf3c2a65042288e202" translate="yes" xml:space="preserve">
          <source>A toolbox of useful Operators for working with Observables</source>
          <target state="translated">Observable 작업에 유용한 연산자의 도구 상자</target>
        </trans-unit>
        <trans-unit id="12bf70fec688d32e9df77570a93f7d9de2beb9f6" translate="yes" xml:space="preserve">
          <source>A typical implementation of the Subscribe operator may accept one to three methods (which then constitute the observer), or it may accept an object (sometimes called an &lt;code&gt;Observer&lt;/code&gt; or &lt;code&gt;Subscriber&lt;/code&gt;) that implements the interface which includes those three methods:</source>
          <target state="translated">Subscribe 연산자의 일반적인 구현은 1 ~ 3 개의 메서드 (관찰자를 구성)를 받아들이 거나 다음 세 가지 메서드를 포함하는 인터페이스를 구현 하는 객체 (때로는 &lt;code&gt;Observer&lt;/code&gt; 또는 &lt;code&gt;Subscriber&lt;/code&gt; 라고도 함)를 받아 들일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="326f047b7addbda19eb8d949bed620511187ece5" translate="yes" xml:space="preserve">
          <source>A variant of distinct that only compares emitted items from the source Observable against their immediate predecessors in order to determine whether or not they are distinct.</source>
          <target state="translated">구별 여부를 결정하기 위해 소스 Observable에서 방출 된 항목과 직계 선행 작업을 비교하는 구별의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="628cd375e74040d3f1575481baed0a36bf589549" translate="yes" xml:space="preserve">
          <source>A variant of this operator &lt;code&gt;merge(maxConcurrent:)&lt;/code&gt; allows you to pass in an &lt;code&gt;Int&lt;/code&gt; indicating the maximum number of these emitted Observables you want &lt;code&gt;merge&lt;/code&gt; to try to be subscribed to at any time. If it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">이 연산자 &lt;code&gt;merge(maxConcurrent:)&lt;/code&gt; 의 변형을 사용하면 언제든지 &lt;code&gt;merge&lt;/code&gt; 하려고하는 방출 된 Observable의 최대 수를 나타내는 &lt;code&gt;Int&lt;/code&gt; 를 전달할 수 있습니다 . 이 최대 구독 수에 도달하면 이미 구독 한 대상 중 하나가 &lt;code&gt;onCompleted&lt;/code&gt; 알림을 발행 할 때까지 소스 Observable이 방출 한 다른 Observable을 구독하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d35ccc7301b7ce4feccd9c396c10c5d8cca3b515" translate="yes" xml:space="preserve">
          <source>A variant of this operator, called &lt;code&gt;ofWithScheduler&lt;/code&gt; takes a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as its first parameter, and operates the resulting Observable on this Scheduler.</source>
          <target state="translated">호출이 연산자의 변형 &lt;code&gt;ofWithScheduler&lt;/code&gt; 는 얻어 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 첫번째 파라미터로,이 스케줄러에 관찰 가능한 결과를 동작한다.</target>
        </trans-unit>
        <trans-unit id="c0925a0e0dd3f224e5197c574ea37e59cffa4f0d" translate="yes" xml:space="preserve">
          <source>A version of the timeout operator allows you to switch to a backup Single rather than sending an error notification if the timeout expires:</source>
          <target state="translated">타임 아웃 연산자의 버전을 사용하면 타임 아웃이 만료되면 오류 알림을 보내지 않고 백업 싱글로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c20b67a1841fd8175f5bbf824b5bd0534f744a" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in RxGroovy 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an &lt;code&gt;Action&lt;/code&gt; that &lt;code&gt;onBackpressureBuffer&lt;/code&gt; will call if the buffer is overrun.</source>
          <target state="translated">RxGroovy 1.1에 도입 된이 연산자의 버전을 사용하면 버퍼 용량을 설정할 수 있습니다. 이 연산자를 적용하면이 버퍼가 오버런 된 경우 결과 Observable이 오류와 함께 종료됩니다. 동일한 릴리스 동안 소개 두 번째 버전은, 당신이 설정할 수 있습니다 &lt;code&gt;Action&lt;/code&gt; 것을 &lt;code&gt;onBackpressureBuffer&lt;/code&gt; 은 버퍼가 오버런 경우 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f994ec3ff86b720b838d74d54795039e7a5aa034" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in RxJava 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an &lt;code&gt;Action&lt;/code&gt; that &lt;code&gt;onBackpressureBuffer&lt;/code&gt; will call if the buffer is overrun.</source>
          <target state="translated">RxJava 1.1에 도입 된이 연산자의 버전을 사용하면 버퍼 용량을 설정할 수 있습니다. 이 연산자를 적용하면이 버퍼가 오버런 된 경우 결과 Observable이 오류와 함께 종료됩니다. 동일한 릴리스 동안 소개 두 번째 버전은, 당신이 설정할 수 있습니다 &lt;code&gt;Action&lt;/code&gt; 것을 &lt;code&gt;onBackpressureBuffer&lt;/code&gt; 은 버퍼가 오버런 경우 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="17462ee811b15366ad770504e8600c231368974f" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in the 1.1 release notifies you, by means of an &lt;code&gt;Action&lt;/code&gt; you pass as a parameter, when an item has been dropped and which item was dropped.</source>
          <target state="translated">1.1 릴리스에서 소개 된이 연산자의 버전은 항목이 삭제되고 삭제 된 항목을 매개 변수로 전달 하는 &lt;code&gt;Action&lt;/code&gt; 를 통해 사용자에게 알립니다 .</target>
        </trans-unit>
        <trans-unit id="850d4acf22d3a4e1c03049abdf78b9a93ef3eccf" translate="yes" xml:space="preserve">
          <source>A version of this variant of the operator (still in Beta as of this writing) takes an additional &lt;code&gt;int&lt;/code&gt; parameter. This parameter sets the maximum number of concurrent subscriptions that &lt;code&gt;flatMap&lt;/code&gt; will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.</source>
          <target state="translated">이 연산자의 변형 버전 (이 글을 쓰는 시점에서 베타 버전)은 추가 &lt;code&gt;int&lt;/code&gt; 매개 변수를 사용합니다. 이 매개 변수는 &lt;code&gt;flatMap&lt;/code&gt; 이 소스 Observable이 방출 한 항목이 맵핑하는 Observable에 대해 시도 할 최대 동시 구독 수를 설정합니다 . 이 최대 수에 도달하면 해당 Observable 중 하나가 다른 하나를 구독하기 전에 종료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="6cf0103a4b2b868a1a60d776479c80ac940f5052" translate="yes" xml:space="preserve">
          <source>A well-formed finite Observable must attempt to call either the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method exactly once or its &lt;code&gt;onError&lt;/code&gt; method exactly once, and must not thereafter attempt to call any of the observer&amp;rsquo;s other methods.</source>
          <target state="translated">올바른 형식의 유한 Observable은 관찰자의 &lt;code&gt;onCompleted&lt;/code&gt; 메소드를 정확히 한 번만 호출하거나 &lt;code&gt;onError&lt;/code&gt; 메소드를 정확하게 한 번 호출하려고 시도한 후에 관찰자의 다른 메소드를 호출하려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="653657e1f29569ba5423fd7a08a85817bf13a50d" translate="yes" xml:space="preserve">
          <source>A well-formed, finite Observable will invoke its observer&amp;rsquo;s &lt;code&gt;onNext&lt;/code&gt; method zero or more times, and then will invoke either the &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; method exactly once. The Materialize operator converts this series of invocations &amp;mdash; both the original &lt;code&gt;onNext&lt;/code&gt; notifications and the terminal &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification &amp;mdash; into a series of &lt;em&gt;items&lt;/em&gt; emitted by an Observable.</source>
          <target state="translated">올바르게 구성된 유한 Observable은 관찰자의 &lt;code&gt;onNext&lt;/code&gt; 메소드를 0 번 이상 호출 한 다음 &lt;code&gt;onCompleted&lt;/code&gt; 또는 &lt;code&gt;onError&lt;/code&gt; 메소드를 정확히 한 번만 호출합니다 . Materialize 연산자는 원래 &lt;code&gt;onNext&lt;/code&gt; 알림과 터미널 &lt;code&gt;onCompleted&lt;/code&gt; 또는 &lt;code&gt;onError&lt;/code&gt; 알림 모두와 같은 일련의 호출을 Observable이 생성 한 일련의 &lt;em&gt;항목&lt;/em&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="805825d0f7d22f43a512c60285f688fee71614c5" translate="yes" xml:space="preserve">
          <source>Advanced RxJava: Schedulers (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;part 1&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;part 2&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;part 3&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;part 4&lt;/a&gt;) by D&amp;aacute;vid Karnok</source>
          <target state="translated">고급 RxJava : 스케줄러 ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;1 부&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;2 부&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;3 부&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;4 부&lt;/a&gt; ) D&amp;aacute;vid Karnok</target>
        </trans-unit>
        <trans-unit id="2da723bb85690e2a91f692590ad213ef381dda90" translate="yes" xml:space="preserve">
          <source>Advanced RxJava: Schedulers (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;part 1&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;part 2&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;part 3&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;part 4&lt;/a&gt;) by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf48d7677040c3e9d2bf95bb0839fd2703291b5" translate="yes" xml:space="preserve">
          <source>Alias for Map</source>
          <target state="translated">지도 별명</target>
        </trans-unit>
        <trans-unit id="4ba6cd005270d28a5da0365e14fbe1da3cdff860" translate="yes" xml:space="preserve">
          <source>Alias for filter</source>
          <target state="translated">필터 별명</target>
        </trans-unit>
        <trans-unit id="2c0fb5d23e5194856f864607d264c2dcc4f20d1e" translate="yes" xml:space="preserve">
          <source>Alias for flatMap</source>
          <target state="translated">flatMap의 별명</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c80ac46ff1f8aeeb94f7a8999a13b0a1e6062b2c" translate="yes" xml:space="preserve">
          <source>Also in the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxGroovy core there is a specialty mapping operator called &lt;code&gt;byLine&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.</source>
          <target state="translated">또한에서 &lt;code&gt;StringObservable&lt;/code&gt; RxGroovy 코어의 일부가 아닌 클래스라는 특수 매핑 오퍼레이터가 &lt;code&gt;byLine&lt;/code&gt; 해당 변환 피 감시하는 텍스트를 방출 라인 즉,은 줄까지 관찰 가능한 소스로부터 문자열을 버퍼링하여 관찰 가능한로 방출한다 문자열 사료는 그들 중 하나에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="9b4f6274689c272bebb2b489085539520b4a1e6a" translate="yes" xml:space="preserve">
          <source>Also in the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxJava core there is a specialty mapping operator called &lt;code&gt;byLine&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.</source>
          <target state="translated">또한에서 &lt;code&gt;StringObservable&lt;/code&gt; RxJava 코어의 일부가 아닌 클래스라는 특수 매핑 오퍼레이터가 &lt;code&gt;byLine&lt;/code&gt; 해당 변환 피 감시하는 텍스트를 방출 라인 즉,은 줄까지 관찰 가능한 소스로부터 문자열을 버퍼링하여 관찰 가능한로 방출한다 문자열 사료는 그들 중 하나에서 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="9dd5794be8096ff7869d94f283eedcf7b7672bb9" translate="yes" xml:space="preserve">
          <source>Amb</source>
          <target state="translated">Amb</target>
        </trans-unit>
        <trans-unit id="851ac2f8e49b2f26ad526a214ceca7b96c49f162" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AsyncSubject&lt;/code&gt; emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes. (If the source Observable does not emit any values, the &lt;code&gt;AsyncSubject&lt;/code&gt; also completes without emitting any values.)</source>
          <target state="translated">&lt;code&gt;AsyncSubject&lt;/code&gt; 는 소스 피 감시에 의해 방출 된 최종 값 (그리고 마지막 값)을 방출하고, 그 후에 만 관찰 가능한 소스 완료한다. 소스 Observable이 값을 생성하지 않으면 &lt;code&gt;AsyncSubject&lt;/code&gt; 도 값을 생성하지 않고 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="7cd649dc1e5fe644141b9e448ab2c1ac4a152926" translate="yes" xml:space="preserve">
          <source>An Alphabetical List of Observable Operators</source>
          <target state="translated">관측 가능한 연산자의 알파벳순 목록</target>
        </trans-unit>
        <trans-unit id="2839cacd293e99aa08485d95a5eaad72408dc3f8" translate="yes" xml:space="preserve">
          <source>An Observable calls this method after it has called &lt;code&gt;onNext&lt;/code&gt; for the final time, if it has not encountered any errors.</source>
          <target state="translated">Observable은 오류가 발생하지 않은 경우 &lt;code&gt;onNext&lt;/code&gt; 를 마지막으로 호출 한 후이 메소드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="2ea9db047d5da0996289f4901a31c06634ef96eb" translate="yes" xml:space="preserve">
          <source>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. It will not make further calls to &lt;code&gt;onNext&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;. The &lt;code&gt;onError&lt;/code&gt; method takes as its parameter an indication of what caused the error.</source>
          <target state="translated">Observable은이 메소드를 호출하여 예상 데이터를 생성하지 못했거나 다른 오류가 발생했음을 나타냅니다. &lt;code&gt;onNext&lt;/code&gt; 또는 &lt;code&gt;onCompleted&lt;/code&gt; 를 더 이상 호출하지 않습니다 . &lt;code&gt;onError&lt;/code&gt; 방법은 매개 변수로 오류의 원인의 표시 걸린다.</target>
        </trans-unit>
        <trans-unit id="42c53d34a4f49cf4f5df1fa4953366bbd8ebe91d" translate="yes" xml:space="preserve">
          <source>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. This stops the Observable and it will not make further calls to &lt;code&gt;onNext&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;. The &lt;code&gt;onError&lt;/code&gt; method takes as its parameter an indication of what caused the error (sometimes an object like an Exception or Throwable, other times a simple string, depending on the implementation).</source>
          <target state="translated">Observable은이 메소드를 호출하여 예상 데이터를 생성하지 못했거나 다른 오류가 발생했음을 나타냅니다. 이렇게하면 Observable이 중지되고 &lt;code&gt;onNext&lt;/code&gt; 또는 &lt;code&gt;onCompleted&lt;/code&gt; 를 더 이상 호출하지 않습니다 . &lt;code&gt;onError&lt;/code&gt; 방법은 매개 변수로 (구현에 따라, 때때로 또는 예외의 Throwable 같은 목적, 다른 시간 단순한 문자열)에게 에러의 원인의 표시 걸린다.</target>
        </trans-unit>
        <trans-unit id="74d2f09477c8a4f1394bf039fd16d24d7fa53421" translate="yes" xml:space="preserve">
          <source>An Observable calls this method whenever the Observable emits an item. This method takes as a parameter the item emitted by the Observable.</source>
          <target state="translated">Observable은 Observable이 항목을 방출 할 때마다이 메소드를 호출합니다. 이 메소드는 Observable이 방출 한 항목을 매개 변수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="16a9dcd358629f823cb0ef4d649474083b6c5bb3" translate="yes" xml:space="preserve">
          <source>An Observable communicates with its observers with the following</source>
          <target state="translated">Observable은 다음과 같이 관찰자와 통신합니다.</target>
        </trans-unit>
        <trans-unit id="6a76c3a98e43666ea0eb0740c08e3a7cbd79ab65" translate="yes" xml:space="preserve">
          <source>An Observable is called a &amp;ldquo;cold&amp;rdquo; Observable if it does not begin to emit items until an observer has subscribed to it; an Observable is called a &amp;ldquo;hot&amp;rdquo; Observable if it may begin emitting items at any time, and a subscriber may begin observing the sequence of emitted items at some point after its commencement, missing out on any items emitted previously to the time of the subscription.</source>
          <target state="translated">옵저버 블은 관찰자가 구독 할 때까지 아이템을 방출하지 않으면 &quot;콜드&quot;옵저버 블이라고합니다. Observable은 언제라도 항목을 방출하기 시작할 수있는 경우 &quot;핫&quot;Observable이라고하며, 구독자는 시작 후 특정 시점에 방출 된 항목의 순서를 관찰하기 시작할 수 있으며, 구독 시간 이전에 방출 된 항목은 누락됩니다. .</target>
        </trans-unit>
        <trans-unit id="d7bf7c542baf1867dd7cef5a402b7db67b5190bd" translate="yes" xml:space="preserve">
          <source>An Observable is the asynchronous/push &lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&amp;ldquo;dual&amp;rdquo;&lt;/a&gt; to the synchronous/pull Iterable</source>
          <target state="translated">Observable은 동기 / 풀 Iterable에 대한 비동기 / 푸시 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&quot;이중&quot;입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb13486a1c65cc1a873f5114a61e7ce2d85fd09a" translate="yes" xml:space="preserve">
          <source>An Observable is the asynchronous/push &lt;a href=&quot;https://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&amp;ldquo;dual&amp;rdquo;&lt;/a&gt; to the synchronous/pull Iterable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbafffea1979fbff2b9d19c9947eecf861d10073" translate="yes" xml:space="preserve">
          <source>An Observable may begin issuing notifications to an observer immediately after the Observable receives a Subscribe notification from the observer.</source>
          <target state="translated">Observable은 Observable이 옵저버로부터 구독 알림을 수신 한 직후 옵저버에게 알림을 발행하기 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c3d8f2d0e01af84eba974448d28b40c4172a8e" translate="yes" xml:space="preserve">
          <source>An Observable may emit no items at all. An Observable may also never terminate with either an OnCompleted or an OnError notification. That is to say that it is proper for an Observable to issue no notifications, to issue only an OnCompleted or an OnError notification, or to issue only OnNext notifications.</source>
          <target state="translated">Observable은 아이템을 전혀 방출하지 않을 수 있습니다. Observable은 OnCompleted 또는 OnError 알림으로 종료되지 않을 수도 있습니다. 즉, Observable이 알림을 발행하지 않거나 OnCompleted 또는 OnError 알림 만 발행하거나 OnNext 알림 만 발행하는 것이 적절합니다.</target>
        </trans-unit>
        <trans-unit id="cf2b11572810d9a5ac8311dae558136ea173beb4" translate="yes" xml:space="preserve">
          <source>An Observable may make zero or more OnNext notifications, each representing a single emitted item, and it may then follow those emission notifications by either an OnCompleted or an OnError notification, but not both. Upon issuing an OnCompleted or OnError notification, it may not thereafter issue any further notifications.</source>
          <target state="translated">Observable은 각각 하나의 방출 항목을 나타내는 OnNext 알림을 0 개 이상 만들 수 있으며 OnCompleted 또는 OnError 알림 중 하나를 통해 이러한 알림을 따를 수 있습니다. OnCompleted 또는 OnError 알림을 발행 한 후에는 더 이상 알림을 발행하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="645e6d39de346178f5938830b549355de0e6e3e5" translate="yes" xml:space="preserve">
          <source>An Observable that does not implement backpressure should respond to a Request notification from an observer by issuing an OnError notification that indicates that backpressure is not supported.</source>
          <target state="translated">배압을 구현하지 않는 Observable은 배압이 지원되지 않음을 나타내는 OnError 알림을 발행하여 관찰자의 요청 알림에 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="689703d4ac79bcdd377cfb6c92ab325f0021d3b4" translate="yes" xml:space="preserve">
          <source>An OnError notification must contain the cause of the error (that is to say, it is invalid to call OnError with a &lt;code&gt;null&lt;/code&gt; value).</source>
          <target state="translated">OnError 알림에는 오류의 원인이 포함되어야합니다 (즉, &lt;code&gt;null&lt;/code&gt; 값으로 OnError를 호출 할 수 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="0ff87217adf75afaa1c6885b1ac6c1d5742a3cbd" translate="yes" xml:space="preserve">
          <source>An advantage of this approach is that when you have a bunch of tasks that are not dependent on each other, you can start them all at the same time rather than waiting for each one to finish before starting the next one &amp;mdash; that way, your entire bundle of tasks only takes as long to complete as the longest task in the bundle.</source>
          <target state="translated">이 방법의 장점은 서로 의존하지 않는 많은 작업이있을 때 다음 작업을 시작하기 전에 각 작업이 완료되기를 기다리는 대신 전체 작업을 동시에 시작할 수 있다는 것입니다. 작업 번들은 번들에서 가장 긴 작업만큼 완료하는 데 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="d85814a55f42e0261226556859d609d250a378ba" translate="yes" xml:space="preserve">
          <source>An even simpler operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (also not part of the standard RxGroovy set of operators) is &lt;code&gt;ifThen&lt;/code&gt;. This operator checks a condition and then either mirrors the source Observable or an empty Observable depending on the result.</source>
          <target state="translated">선택적 &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; 패키지의 표준 연산자 (표준 RxGroovy 연산자 세트의 일부가 &lt;code&gt;ifThen&lt;/code&gt; )는 ifThen 입니다. 이 연산자는 조건을 확인한 다음 결과에 따라 소스 Observable 또는 비어있는 Observable을 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="0f829bc7f8186b73be4fd6d24d31abb651902daa" translate="yes" xml:space="preserve">
          <source>An observer communicates with its Observable by means of the following notifications:</source>
          <target state="translated">관찰자는 다음 알림을 통해 Observable과 통신합니다.</target>
        </trans-unit>
        <trans-unit id="6c74c14e78b3bf3709270805f239144c3e35aa94" translate="yes" xml:space="preserve">
          <source>An optional third parameter (named &lt;code&gt;defaultValue&lt;/code&gt;) allows you to choose an item that &lt;code&gt;first&lt;/code&gt; will emit if the source Observable does not emit any items (or if it does not emit the</source>
          <target state="translated">선택적인 세 번째 매개 변수 ( &lt;code&gt;defaultValue&lt;/code&gt; )를 사용하면 소스 Observable이 항목을 방출하지 않거나 방출하지 않는 경우 가장 &lt;code&gt;first&lt;/code&gt; 방출 할 항목을 선택할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e16bafd99d71f935206c53ee2503366667c35c3c" translate="yes" xml:space="preserve">
          <source>And importantly: with ReactiveX you can later change your mind, and radically change the underlying nature of your Observable implementation, without breaking the consumers of your Observable.</source>
          <target state="translated">또한 ReactiveX를 사용하면 나중에 Observable의 소비자를 방해하지 않으면 서 마음을 바꾸고 Observable 구현의 기본 특성을 근본적으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="214cbe57ae28db943c3ec9b46b47b3101daf0c7b" translate="yes" xml:space="preserve">
          <source>And that variant also has a cousin that will switch to a specified backup Observable rather than emitting an error upon hitting a timeout condition.</source>
          <target state="translated">또한 해당 변형에는 시간 초과 조건에 도달 할 때 오류가 발생하지 않고 지정된 백업 Observable로 전환되는 사촌이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd733cd8e342ef935e8375aac0d129d8c255f6b" translate="yes" xml:space="preserve">
          <source>And there is a variant of &lt;code&gt;delaySubscription&lt;/code&gt; that uses an Observable (returned by a function you supply) rather than a fixed duration in order to set the subscription delay.</source>
          <target state="translated">구독 지연을 설정하기 위해 고정 지속 시간이 아닌 Observable (제공 한 함수로 반환)을 사용하는 &lt;code&gt;delaySubscription&lt;/code&gt; 의 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ee68728e1626f87277753fcdb831fc09c7b3d5" translate="yes" xml:space="preserve">
          <source>And there is also a verion of &lt;code&gt;singleOrDefault&lt;/code&gt; that takes a predicate function and emits the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and makes an error notification if multiple items match.</source>
          <target state="translated">또한 술어 함수를 가져 &lt;code&gt;singleOrDefault&lt;/code&gt; 해당 술어와 일치하는 소스 Observable에서 유일한 항목을 내보내는 singleOrDefault 의 버전 도 있습니다. 그러한 항목이 일치하지 않으면 기본 항목; 여러 항목이 일치하면 오류 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f667a90816681f20bf11089e389629e58978843f" translate="yes" xml:space="preserve">
          <source>And there is also a verion of &lt;code&gt;singleOrDefault&lt;/code&gt; that takes a predicate function and returns the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and throws an error if multiple items match.</source>
          <target state="translated">또한 술어 함수를 사용하고 해당 술어와 일치하는 소스 Observable에서 유일한 항목을 리턴하는 &lt;code&gt;singleOrDefault&lt;/code&gt; 버전 도 있습니다. 그러한 항목이 일치하지 않으면 기본 항목; 여러 항목이 일치하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="10883d7bc99bd25d1b6cd9f78cf866a8856bbf98" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;first&lt;/code&gt;, there is a &lt;code&gt;firstOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and retrieves the first item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 와 마찬가지로 술어 함수를 인수로 사용하고 해당 술어를 만족시키는 &lt;code&gt;BlockingObservable&lt;/code&gt; 소스에서 첫 번째 항목을 검색 하거나 만족하는 항목이 생성되지 않은 경우 기본 항목을 검색 하는 &lt;code&gt;firstOrDefault&lt;/code&gt; 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b61cf36b9bbc9f1f59d3790764d487afdbb2624c" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;first&lt;/code&gt;, there is a &lt;code&gt;firstOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and returns the first item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 와 마찬가지로 술어 함수를 인수로 사용하고 해당 술어를 만족하는 &lt;code&gt;BlockingObservable&lt;/code&gt; 소스에서 첫 번째 항목을 리턴 하거나 만족하는 항목이 생성되지 않은 경우 기본 항목을 리턴 하는 &lt;code&gt;firstOrDefault&lt;/code&gt; 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d569317120812ad4b1a0a46c5a1a37fce2c43e2" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;last&lt;/code&gt;, there is a &lt;code&gt;lastOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and retrieves the last item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">그리고 &lt;code&gt;last&lt;/code&gt; 와 마찬가지로 술어 함수를 인수로 사용하고 해당 술어를 만족시키는 &lt;code&gt;BlockingObservable&lt;/code&gt; 소스에서 마지막 항목을 검색 하거나 만족하는 항목이 생성되지 않은 경우 기본 항목을 검색 하는 &lt;code&gt;lastOrDefault&lt;/code&gt; 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8251dbbd4d407b2ba611d6bab161e9f49c31af8d" translate="yes" xml:space="preserve">
          <source>And/Then/When</source>
          <target state="translated">And/Then/When</target>
        </trans-unit>
        <trans-unit id="5e3f7fc4502eaa43261cf03af6ffe0dd602b81e7" translate="yes" xml:space="preserve">
          <source>Another variant allows you to instruct &lt;code&gt;timeout&lt;/code&gt; to switch to a backup Observable that you specify, rather than terminating with an error, if the timeout condition is triggered. To use this variant, pass the backup Observable (or &lt;code&gt;Promise&lt;/code&gt;) as the second parameter to &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">또 다른 변형은 지시 할 수 있도록 &lt;code&gt;timeout&lt;/code&gt; 시간 제한 조건이 트리거되는 경우, 오히려 오류와 함께 종료보다 지정한 백업 관찰 가능한에 스위치를. 이 변형을 사용하려면 백업 Observable (또는 &lt;code&gt;Promise&lt;/code&gt; )을 두 번째 매개 변수로 &lt;code&gt;timeout&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0a94542011650405c857cbde913a1b92445107e" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;Retry&lt;/code&gt; takes a single parameter: a count of the number of &lt;code&gt;onError&lt;/code&gt; notification it should be willing to accept before it too fails and passes the &lt;code&gt;onError&lt;/code&gt; to its observers. For example, &lt;code&gt;Retry(2)&lt;/code&gt; means that &lt;code&gt;Retry&lt;/code&gt; will resubscribe to and mirror the source Observable the first time it receives an &lt;code&gt;onError&lt;/code&gt; notification, but will terminate with an error the second time this happens.</source>
          <target state="translated">&lt;code&gt;Retry&lt;/code&gt; 의 또 다른 변형은 단일 매개 변수를 사용합니다. &lt;code&gt;onError&lt;/code&gt; 알림의 수는 실패하기 전에 수락해야하며 &lt;code&gt;onError&lt;/code&gt; 를 관찰자에게 전달합니다 . 예를 들어 &lt;code&gt;Retry(2)&lt;/code&gt; 는 &lt;code&gt;onError&lt;/code&gt; 알림을 처음 수신 할 때 &lt;code&gt;Retry&lt;/code&gt; 가 소스 Observable 을 다시 구독하고 미러링 하지만 두 번째 발생하면 오류와 함께 종료 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="02efaeb4d2bdd19b23fcdfa7078d0965b0543f39" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;delay&lt;/code&gt; does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits a item or completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">&lt;code&gt;delay&lt;/code&gt; 또 다른 변형은 일정한 지연 시간을 사용하지 않지만 소스 Observable의 각 항목을 Observable을 반환하는 함수로 전달한 다음 해당 Observable을 모니터링하여 항목별로 지연 시간을 설정합니다. 이러한 Observable이 항목을 방출하거나 완료하면 &lt;code&gt;delay&lt;/code&gt; 의해 리턴 된 Observable 은 연관된 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="f2cb02c7b8b0dc8585c179d8f7a980076f44300b" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;delay&lt;/code&gt; does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits an item or completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">&lt;code&gt;delay&lt;/code&gt; 또 다른 변형은 일정한 지연 시간을 사용하지 않지만 소스 Observable의 각 항목을 Observable을 반환하는 함수로 전달한 다음 해당 Observable을 모니터링하여 항목별로 지연 시간을 설정합니다. 이러한 Observable이 항목을 방출하거나 완료하면 &lt;code&gt;delay&lt;/code&gt; 의해 리턴 된 Observable 은 연관된 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="18e4f38385f3555737f4cc37f65db6f2b2cb3f98" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;retry&lt;/code&gt; takes a single parameter: a count of the number of &lt;code&gt;onError&lt;/code&gt; notification it should be willing to accept before it too fails and passes the &lt;code&gt;onError&lt;/code&gt; to its observers. For example, &lt;code&gt;retry(2)&lt;/code&gt; means that &lt;code&gt;retry&lt;/code&gt; will resubscribe to and mirror the source Observable the first time it receives an &lt;code&gt;onError&lt;/code&gt; notification, but will terminate with an error the second time this happens.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 또 다른 변형은 단일 매개 변수를 사용합니다. &lt;code&gt;onError&lt;/code&gt; 알림의 수는 실패하기 전에 수락해야하며 &lt;code&gt;onError&lt;/code&gt; 를 관찰자에게 전달합니다 . 예를 들어, &lt;code&gt;retry(2)&lt;/code&gt; 는 &lt;code&gt;onError&lt;/code&gt; 알림을 처음 수신 할 때 &lt;code&gt;retry&lt;/code&gt; 하여 소스 Observable 을 다시 구독하고 미러링 하지만이 경우 두 번째 오류로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="53a31e30b7b7961ac8ac1fd52bd1e592dd652cbb" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;retry&lt;/code&gt; takes a single parameter: a count of the number of times it should try to resubscribe to the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe again and will instead pass the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; 다른 변형은 단일 매개 변수를 사용합니다. 오류가 발생했을 때 소스 Observable에 재 구독해야하는 횟수입니다. 이 수를 초과하면 &lt;code&gt;retry&lt;/code&gt; 하면 다시 구독을 시도하지 않고 대신 최신 &lt;code&gt;onError&lt;/code&gt; 알림을 관찰자에게 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="180c4e210c4586ad6515a4efe0a7bfdaf14fb209" translate="yes" xml:space="preserve">
          <source>Another version combines items from the source Observable with the Observable triggered by those source items, and emits these combinations.</source>
          <target state="translated">다른 버전은 소스 Observable의 항목을 해당 소스 항목에 의해 트리거 된 Observable과 결합하여 이러한 조합을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="9c3e74fdeb39fa8f79f8b41f914729603db3668b" translate="yes" xml:space="preserve">
          <source>Another version of &lt;code&gt;flatMap&lt;/code&gt; creates (and flattens) a new Observable for each item &lt;em&gt;and notification&lt;/em&gt; from the source Observable.</source>
          <target state="translated">다른 버전의 &lt;code&gt;flatMap&lt;/code&gt; 은 각 항목에 대해 새로운 Observable을 생성 (및 평탄화) 하고 소스 Observable로부터의 &lt;em&gt;알림&lt;/em&gt; 을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="416f48df8cc3910b8bb048511d0a6e4801002873" translate="yes" xml:space="preserve">
          <source>Another version of &lt;code&gt;groupBy&lt;/code&gt; allows you to pass in a transformative function that changes the elements before they are emitted by the resulting &lt;code&gt;GroupedObservable&lt;/code&gt;s.</source>
          <target state="translated">다른 버전의 &lt;code&gt;groupBy&lt;/code&gt; 를 사용하면 결과 &lt;code&gt;GroupedObservable&lt;/code&gt; 에 의해 요소가 방출되기 전에 요소를 변경하는 변환 함수를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cbe5dee754659834a3070a07a4de32cd17c626d" translate="yes" xml:space="preserve">
          <source>Another version takes two or more Singles and merges them into an Observable that emits the items emitted by the source Singles (in an arbitrary order):</source>
          <target state="translated">다른 버전은 둘 이상의 싱글을 가져 와서 소스 싱글이 방출하는 항목을 임의 순서로 방출하는 Observable로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="5fc07229ca716771de12a56cf5816c03a72ab3bb" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.</source>
          <target state="translated">관찰 가능 시퀀스에 누산기 함수를 적용하고 각 중간 결과를 반환합니다. 선택적 시드 값은 초기 누산기 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e968236df359a0c3a3b48d1101e20c7334bc87e3" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.</source>
          <target state="translated">관찰 가능 시퀀스에 누산기 함수를 적용하여 집계 결과를 결과 시퀀스의 단일 요소로 반환합니다. 지정된 시드 값이 초기 누산기 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6482ebf54fcf3fef454ac6beb793ddcb408e9393" translate="yes" xml:space="preserve">
          <source>As an alternative to using &lt;code&gt;request&lt;/code&gt; to pull items from a &lt;code&gt;ControlledObservable&lt;/code&gt;, you may apply the &lt;code&gt;stopAndWait&lt;/code&gt; operator to it. This operator will request a new item from the Observable each time its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt; routine receives the latest item.</source>
          <target state="translated">&lt;code&gt;ControlledObservable&lt;/code&gt; 에서 항목을 가져 오기 위해 &lt;code&gt;request&lt;/code&gt; 을 사용하는 대신 &lt;code&gt;stopAndWait&lt;/code&gt; 연산자를 적용 할 수 있습니다 . 이 운영자는 관찰자의 &lt;code&gt;onNext&lt;/code&gt; 루틴이 최신 항목을 수신 할 때마다 Observable에 새 항목을 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="3e2402a383d153594ac341c580a389f352b429f3" translate="yes" xml:space="preserve">
          <source>As shown in the above diagram, an &lt;code&gt;onError&lt;/code&gt; notification from any of the source Observables will immediately be passed through to observers and will terminate the merged Observable.</source>
          <target state="translated">위의 다이어그램에 표시된 것처럼 소스 Observables의 &lt;code&gt;onError&lt;/code&gt; 알림은 즉시 옵저버에게 전달되고 병합 된 Observable을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="2944d9f0e54e8337eac2b3e9e3efb8980e22c066" translate="yes" xml:space="preserve">
          <source>As shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use &lt;em&gt;below&lt;/em&gt; where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</source>
          <target state="translated">이 그림에서 볼 수 있듯이 SubscribeOn 연산자는 해당 연산자가 호출되는 연산자 체인의 지점에 관계없이 Observable이 작동하기 시작할 스레드를 지정합니다. ObserveOn, 다른 한편으로는, 관찰가 사용할 스레드에 영향을 &lt;em&gt;아래&lt;/em&gt; 어디에 운영자 나타납니다. 이러한 이유로, Observable 연산자 체인 중 여러 지점에서 ObserveOn을 여러 번 호출하여 해당 연산자 중 특정 스레드가 작동하는 스레드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90336d424ebddac61136082a2c6d772454fe8231" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;distinct&lt;/code&gt;, there is also a version of &lt;code&gt;distinctUntilChanged&lt;/code&gt; that accepts a key selector function and that uses the resulting key to determine whether or not two adjacently-emitted items are distinct.</source>
          <target state="translated">와 같이 &lt;code&gt;distinct&lt;/code&gt; 존재 버전도 &lt;code&gt;distinctUntilChanged&lt;/code&gt; 키 선택기 기능을 허용하고, 두 인접-출사 항목 별개 여부를 판정하기 위해 생성 된 키를 사용한다.</target>
        </trans-unit>
        <trans-unit id="ea92b7b4b8b9fa35e6026e8b95b2e25ebb1fc5c4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;firstOrDefault&lt;/code&gt; there is also a &lt;code&gt;singleOrDefault&lt;/code&gt; that emits a default item if the source Observable is empty, although it will still notify of an error if the source Observable emits more than one item.</source>
          <target state="translated">&lt;code&gt;firstOrDefault&lt;/code&gt; 와 마찬가지로 소스 Observable이 비어 있으면 기본 항목을 내보내는 &lt;code&gt;singleOrDefault&lt;/code&gt; 도 있지만 소스 Observable이 둘 이상의 항목을 내보내 더라도 오류를 계속 알립니다.</target>
        </trans-unit>
        <trans-unit id="d92ac954f9b7869499152c6f9dac87389cc9d017" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;firstOrDefault&lt;/code&gt; there is also a &lt;code&gt;singleOrDefault&lt;/code&gt; that returns a default item if the source Observable is empty, although it will still throw an error if the source Observable emits more than one item.</source>
          <target state="translated">&lt;code&gt;firstOrDefault&lt;/code&gt; 와 마찬가지로 소스 Observable이 비어 있으면 기본 항목을 반환 하는 &lt;code&gt;singleOrDefault&lt;/code&gt; 도 있습니다. 그러나 소스 Observable이 둘 이상의 항목을 방출하면 여전히 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9dca8bd3303f27dee6fa18df112035b5a22c5486" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;concatMap&lt;/code&gt; works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;flatMap&lt;/code&gt; , &lt;code&gt;concatMap&lt;/code&gt; 은 단지뿐만 아니라 기능을 사용하면 Observables은에 소스 Observables은에서 변환 항목을 제공, 약속에, 또는 배열로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c6e9229a21e2a7672f82daa0c3b3a03f4a076628" translate="yes" xml:space="preserve">
          <source>As with the filtering operators, the &lt;code&gt;first&lt;/code&gt; method of &lt;code&gt;BlockingObservable&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; if there is no first element in the source &lt;code&gt;BlockingObservable&lt;/code&gt;. To return a default item instead in such cases, use the &lt;code&gt;firstOrDefault&lt;/code&gt; method.</source>
          <target state="translated">필터링하는 작업자와 같이, &lt;code&gt;first&lt;/code&gt; 의 방법 &lt;code&gt;BlockingObservable&lt;/code&gt; 는 던져 것 &lt;code&gt;NoSuchElementException&lt;/code&gt; 소스에는 첫 번째 요소가 존재하지 않는 경우 &lt;code&gt;BlockingObservable&lt;/code&gt; 이 . 이러한 경우 대신 기본 항목을 반환하려면 &lt;code&gt;firstOrDefault&lt;/code&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3967a0eb108ca47a2858158ed9dfb9574c5f8ca" translate="yes" xml:space="preserve">
          <source>As with the filtering operators, the &lt;code&gt;last&lt;/code&gt; method of &lt;code&gt;BlockingObservable&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; if there is no last element in the source &lt;code&gt;BlockingObservable&lt;/code&gt;. To return a default item instead in such cases, use the &lt;code&gt;lastOrDefault&lt;/code&gt; method.</source>
          <target state="translated">필터링하는 사업자와 마찬가지로, &lt;code&gt;last&lt;/code&gt; 방법 &lt;code&gt;BlockingObservable&lt;/code&gt; 는 던져 것입니다 &lt;code&gt;NoSuchElementException&lt;/code&gt; 소스에는 마지막 요소가없는 경우 &lt;code&gt;BlockingObservable&lt;/code&gt; 가 . 이러한 경우 대신 기본 항목을 반환하려면 &lt;code&gt;lastOrDefault&lt;/code&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fcf5a04971327e7fdf42936464bd21e8b771ab5" translate="yes" xml:space="preserve">
          <source>Aside from passing these Schedulers in to RxJava Observable operators, you can also use them to schedule your own work on Subscriptions. The following example uses &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0)&quot;&gt;the &lt;code&gt;schedule&lt;/code&gt; method&lt;/a&gt; of &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html&quot;&gt;the &lt;code&gt;Scheduler.Worker&lt;/code&gt; class&lt;/a&gt; to schedule work on the &lt;code&gt;newThread&lt;/code&gt; Scheduler:</source>
          <target state="translated">이 스케줄러를 RxJava Observable 연산자로 전달하는 것 외에도이 스케줄러를 사용하여 서브 스크립 션에 대한 작업을 예약 할 수도 있습니다. 다음 예는 사용 &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0)&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; 방법 의 &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html&quot;&gt; &lt;code&gt;Scheduler.Worker&lt;/code&gt; 의&lt;/a&gt; 클래스 상의 일정 작업에 &lt;code&gt;newThread&lt;/code&gt; 스케줄러 :</target>
        </trans-unit>
        <trans-unit id="81a3a332582f8b7c97ecac0a351df1689bfb7637" translate="yes" xml:space="preserve">
          <source>AsyncSubject</source>
          <target state="translated">AsyncSubject</target>
        </trans-unit>
        <trans-unit id="4cd01c057417c6358415753c1e3270378ba8ff9e" translate="yes" xml:space="preserve">
          <source>At any time after it receives an OnSubscribe notification, an observer may issue a Request notification to the Observable it has subscribed to. This notification requests a particular number of items. The Observable responds to such a Request by emitting no more items to the observer than the number of items the observer requests. However the Observable may, in addition, issue an OnCompleted or OnError notification, and it may even issue such a notification before the observer requests any items at all.</source>
          <target state="translated">OnSubscribe 알림을받은 후 언제든지 관찰자는 구독 한 Observable에 요청 알림을 발행 할 수 있습니다. 이 알림은 특정 개수의 항목을 요청합니다. Observable은 옵저버가 요청한 아이템 수보다 더 많은 아이템을 옵저버에게 내보냄으로써 그러한 요청에 응답합니다. 그러나 Observable은 또한 OnCompleted 또는 OnError 알림을 발행 할 수 있으며 관찰자가 항목을 전혀 요청하기 전에 이러한 알림을 발행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a7c2b7fecd45fc8d48965e405aa02103af88d8a" translate="yes" xml:space="preserve">
          <source>Attach the observer to that Observable by</source>
          <target state="translated">관찰자를 그 관찰자에 의해</target>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bfded4a21da8efbb2fa839d4b2207399ba6ad7be" translate="yes" xml:space="preserve">
          <source>Backpressure</source>
          <target state="translated">Backpressure</target>
        </trans-unit>
        <trans-unit id="35262f52104832142bf6755bccc1f3e12433d190" translate="yes" xml:space="preserve">
          <source>Backpressure Operators</source>
          <target state="translated">배압 연산자</target>
        </trans-unit>
        <trans-unit id="d2eb3d3593072fa90c30c72ab2ea8bae6bdb0314" translate="yes" xml:space="preserve">
          <source>Backpressure is optional; not all ReactiveX implementations include backpressure, and in those that do, not all Observables or operators honor backpressure. An Observable &lt;em&gt;may&lt;/em&gt; implement backpressure if it detects that its observer implements</source>
          <target state="translated">배압은 선택 사항입니다. 모든 ReactiveX 구현에 배압이 포함되는 것은 아니며, 그렇지 않은 경우 모든 Observable 또는 운영자가 배압을 존중하지는 않습니다. Observable &lt;em&gt;은&lt;/em&gt; 관찰자가 구현 한 것을 감지하면 배압을 구현할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c17bead9671f0fa78aeae30852ed269b9a2823ed" translate="yes" xml:space="preserve">
          <source>Backpressure-related Operators</source>
          <target state="translated">배압 관련 연산자</target>
        </trans-unit>
        <trans-unit id="430ace144fb8a573f293eacace0939475b0d212a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onErrorFlatMap&lt;/code&gt; is designed to work with pathological source Observables that do not terminate after issuing an error, it is mostly useful in debugging/testing scenarios.</source>
          <target state="translated">&lt;code&gt;onErrorFlatMap&lt;/code&gt; 은 오류 발생 후 종료되지 않는 병적 소스 Observable과 함께 작동하도록 설계 되었기 때문에 디버깅 / 테스트 시나리오에서 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fd066d9d682432c2ab720b8c76cae63bcdae1811" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;runAsync&lt;/code&gt; immediately invokes the &lt;code&gt;Action&lt;/code&gt; and begins emitting the items (that is, it produces a &lt;em&gt;hot&lt;/em&gt; Observable), it is possible that some items may be lost in the interval between when you establish the &lt;code&gt;StoppableObservable&lt;/code&gt; with this operator and when your &lt;code&gt;Observer&lt;/code&gt; is ready to receive items. If this is a problem, you can use the variant of &lt;code&gt;runAsync&lt;/code&gt; that also accepts a &lt;code&gt;Subject&lt;/code&gt; and pass a &lt;code&gt;ReplaySubject&lt;/code&gt; with which you can retrieve the otherwise-missing items.</source>
          <target state="translated">&lt;code&gt;runAsync&lt;/code&gt; 가 즉시 &lt;code&gt;Action&lt;/code&gt; 호출하고 항목 방출을 시작 하기 때문에 (즉, &lt;em&gt;Hot&lt;/em&gt; Observable을 생성 함 ) 이 연산자로 &lt;code&gt;StoppableObservable&lt;/code&gt; 을 설정하는 시점과 &lt;code&gt;Observer&lt;/code&gt; 가 준비 할 때 사이의 간격에서 일부 항목이 유실 될 수 있습니다. 품목을 받으십시오. 이 문제가 경우의 변형 사용할 수 있습니다 &lt;code&gt;runAsync&lt;/code&gt; 도 받아 &lt;code&gt;Subject&lt;/code&gt; 하고 통과 &lt;code&gt;ReplaySubject&lt;/code&gt; 당신이 그렇지 않으면-누락 된 항목을 검색 할 수있는합니다.</target>
        </trans-unit>
        <trans-unit id="580926df80f2bb9b9ffac06756ddd1d4eed2fe8f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;runAsync&lt;/code&gt; immediately invokes the &lt;code&gt;Action&lt;/code&gt; and begins emitting the items, it is possible that some items may be lost in the interval between when you establish the &lt;code&gt;StoppableObservable&lt;/code&gt; with this method and when your &lt;code&gt;Observer&lt;/code&gt; is ready to receive items. If this is a problem, you can use the variant of &lt;code&gt;runAsync&lt;/code&gt; that also accepts a &lt;a href=&quot;../subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; and pass a &lt;code&gt;ReplaySubject&lt;/code&gt; with which you can retrieve the otherwise-missing items.</source>
          <target state="translated">때문에 &lt;code&gt;runAsync&lt;/code&gt; 가 즉시 호출 &lt;code&gt;Action&lt;/code&gt; 하고 항목을 방출 시작, 일부 항목은 사용자가 설정할 때 사이의 간격에서 손실 될 수 있습니다 가능성이 &lt;code&gt;StoppableObservable&lt;/code&gt; 를 이 방법과 시점과 &lt;code&gt;Observer&lt;/code&gt; 항목을 수신 할 준비가 된 것입니다. 이 문제가 경우의 변형 사용할 수 있습니다 &lt;code&gt;runAsync&lt;/code&gt; 도 받아 &lt;a href=&quot;../subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; 하고 통과 &lt;code&gt;ReplaySubject&lt;/code&gt; 당신이 그렇지 않으면-누락 된 항목을 검색 할 수있는합니다.</target>
        </trans-unit>
        <trans-unit id="45d4b461dae7aa4c7f69430372ef95db326bbe71" translate="yes" xml:space="preserve">
          <source>Because a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is &amp;ldquo;cold&amp;rdquo; &amp;mdash; that is, if it waits for a subscription before it begins to emit items). This can have the effect of making the resulting Subject a &amp;ldquo;hot&amp;rdquo; Observable variant of the original &amp;ldquo;cold&amp;rdquo; Observable.</source>
          <target state="translated">주제는 Observable을 구독하기 때문에 Observable이 항목 방출을 시작하도록 트리거합니다 (Observable이 &quot;콜드&quot;인 경우, 즉 항목을 보내기 전에 구독을 기다리는 경우). 결과로 생성 된 피사체를 원래의 &quot;감기&quot;관찰 가능의 &quot;핫&quot;관찰 가능 변형으로 만드는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea3c830df555c58d5b9d3068d47dee7f418f5fe" translate="yes" xml:space="preserve">
          <source>Because it is possible that more than one of the merged Observables encountered an error, &lt;code&gt;mergeDelayError&lt;/code&gt; may pass information about &lt;em&gt;multiple&lt;/em&gt; errors in the &lt;code&gt;onError&lt;/code&gt; notification (it will never invoke the observer&amp;rsquo;s &lt;code&gt;onError&lt;/code&gt; method more than once). For this reason, if you want to know the nature of these errors, you should write your observers&amp;rsquo; &lt;code&gt;onError&lt;/code&gt; methods so that they accept a parameter of the class &lt;code&gt;CompositeException&lt;/code&gt;.</source>
          <target state="translated">병합 된 Observable에서 둘 이상의 오류가 발생 &lt;code&gt;mergeDelayError&lt;/code&gt; 수 있으므로 mergeDelayError 는 &lt;code&gt;onError&lt;/code&gt; 알림 에서 &lt;em&gt;여러&lt;/em&gt; 오류에 대한 정보를 전달할 수 있습니다 (관찰자의 &lt;code&gt;onError&lt;/code&gt; 메소드를 두 번 이상 호출하지는 않습니다 ). 따라서 이러한 오류의 특성을 알고 싶다면 옵저버의 &lt;code&gt;onError&lt;/code&gt; 메소드를 작성하여 &lt;code&gt;CompositeException&lt;/code&gt; 클래스의 매개 변수를 승인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="40504d93089e459126b9f714fa64da0432bf9cb2" translate="yes" xml:space="preserve">
          <source>Before an Observable terminates it must first issue either an OnCompleted or OnError notification to all of the observers that are subscribed to it.</source>
          <target state="translated">Observable이 종료되기 전에 먼저 구독 한 모든 옵저버에게 OnCompleted 또는 OnError 알림을 발행해야합니다.</target>
        </trans-unit>
        <trans-unit id="368c978e94ba7ae5d0f5a362fef744af7dd7667e" translate="yes" xml:space="preserve">
          <source>BehaviorSubject</source>
          <target state="translated">BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="c7edc1ce6b23272555c0452f3036c8ab489ea4bc" translate="yes" xml:space="preserve">
          <source>Buffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making them more manageable. You could, for example, close and emit a buffer of items from a bursty Observable periodically, at a regular interval of time.</source>
          <target state="translated">버퍼는 여러 항목의 시퀀스를 더 적은 수의 항목 버퍼로 줄여서 관리하기가 더 쉽습니다. 예를 들어, 정기적으로 버스트 Observable에서 정기적으로 항목 버퍼를 닫고 방출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d726676ef856039a619e5c8fc3b22b65bd1d7d3f" translate="yes" xml:space="preserve">
          <source>But as with Futures, while callbacks are easy to use with a single level of asynchronous execution, &lt;a href=&quot;https://gist.github.com/4677544&quot;&gt;with nested composition they become unwieldy&lt;/a&gt;.</source>
          <target state="translated">그러나 Future와 마찬가지로 콜백은 단일 레벨의 비동기 실행으로 사용하기 쉽고 &lt;a href=&quot;https://gist.github.com/4677544&quot;&gt;중첩 된 컴포지션으로 다루기가 어려워&lt;/a&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="3806ea89275a484caaeb8fb736ffc6a0c360406a" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;delay&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;delay&lt;/code&gt;</source>
          <target state="translated">기본적으로이 &lt;code&gt;delay&lt;/code&gt; 변형은 &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하지만 &lt;code&gt;delay&lt;/code&gt; 대한 선택적 세 번째 매개 변수로 전달하여 다른 스케줄러를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853cd838d6aa239dfebc6fe472f15b378a7e9fd0" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;timeout&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">기본적으로이 &lt;code&gt;timeout&lt;/code&gt; 변형은 &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하지만 &lt;code&gt;timeout&lt;/code&gt; 선택적 세 번째 매개 변수로 전달하여 다른 스케줄러를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c7c6971a230126aa6e972a720f0bb289a01e7e" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;timeout&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">기본적으로이 &lt;code&gt;timeout&lt;/code&gt; 변형은 &lt;code&gt;computation&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 에서 작동 하지만 &lt;code&gt;timeout&lt;/code&gt; 선택적 세 번째 매개 변수로 전달하여 다른 스케줄러를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b5e38e8783b4ae293ff3a5deb6299790a6fded1" translate="yes" xml:space="preserve">
          <source>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its &lt;code&gt;Subscribe&lt;/code&gt; method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</source>
          <target state="translated">기본적으로 Observable과 적용되는 연산자 체인은 작업을 수행하고 &lt;code&gt;Subscribe&lt;/code&gt; 메서드가 호출 되는 동일한 스레드에서 관찰자에게 알립니다 . SubscribeOn 연산자는 Observable이 작동해야하는 다른 스케줄러를 지정하여이 동작을 변경합니다. ObserveOn 연산자는 Observable이 관찰자에게 알림을 보내는 데 사용할 다른 스케줄러를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="349ec7cf4de33246924ed8834527eb97fcddde0c" translate="yes" xml:space="preserve">
          <source>By the terms of &lt;a href=&quot;contract&quot;&gt;the Observable contract&lt;/a&gt;, it may call &lt;code&gt;onNext&lt;/code&gt; zero or more times, and then may follow those calls with a call to either &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; but not both, which will be its last call. By convention, in this document, calls to &lt;code&gt;onNext&lt;/code&gt; are usually called &amp;ldquo;emissions&amp;rdquo; of items, whereas calls to &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; are called &amp;ldquo;notifications.&amp;rdquo;</source>
          <target state="translated">의 규정에 의해 &lt;a href=&quot;contract&quot;&gt;관찰 계약&lt;/a&gt; , 그것은 호출 할 수 &lt;code&gt;onNext&lt;/code&gt; 중 하나를 호출하는 전화를 따를 수 후 0 번 이상, 그리고 &lt;code&gt;onCompleted&lt;/code&gt; 또는 &lt;code&gt;onError&lt;/code&gt; 마지막으로 호출 될 것입니다 있지만 둘. 이 문서에서는 일반적으로 &lt;code&gt;onNext&lt;/code&gt; 에 대한 호출을 일반적으로 항목의 &quot;방출&quot;이라고하며 &lt;code&gt;onCompleted&lt;/code&gt; 또는 &lt;code&gt;onError&lt;/code&gt; 에 대한 호출을 &quot;알림&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="ad7f884b18f0e71ef27dcc9eb107c69b22184b8e" translate="yes" xml:space="preserve">
          <source>Bypasses a specified number of elements at the end of an observable sequence. This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.</source>
          <target state="translated">관찰 가능 시퀀스의 끝에 지정된 수의 요소를 무시합니다. 이 연산자는 첫 번째 'count'요소를 저장하기에 충분한 길이의 큐를 누적합니다. 더 많은 요소가 수신되면 큐의 앞쪽에서 요소가 가져 와서 결과 시퀀스에서 생성됩니다. 이로 인해 요소가 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="56a26a63bf2967d76012cc29baf8e343e4f53b12" translate="yes" xml:space="preserve">
          <source>Bypasses a specified number of elements in an observable sequence and then returns the remaining elements. Transform the items emitted by an Observable into Observables, and mirror those items emitted by the most-recently transformed Observable. The flatMapLatest operator is similar to the flatMap and concatMap methods described above, however, rather than emitting all of the items emitted by all of the Observables that the operator generates by transforming items from the source Observable, flatMapLatest instead emits items from each such transformed Observable only until the next such Observable is emitted, then it ignores the previous one and begins emitting items emitted by the new one.</source>
          <target state="translated">관찰 가능한 시퀀스에서 지정된 수의 요소를 무시한 다음 나머지 요소를 반환합니다. Observable이 방출 한 항목을 Observables로 변환하고 가장 최근에 변환 된 Observable이 방출 한 항목을 미러링합니다. flatMapLatest 연산자는 위에서 설명한 flatMap 및 concatMap 메소드와 유사하지만 소스 Observable에서 항목을 변환하여 연산자가 생성 한 모든 Observable에서 방출되는 모든 항목을 내보내는 대신 flatMapLatest는 변환 된 각각의 이러한 Observable에서 항목을 방출합니다. 다음에 그러한 Observable이 방출 될 때까지만 이전의 것을 무시하고 새로운 것에 의해 방출 된 아이템을 방출하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="49745efca49c630e89bcd950cbd9b790a40a26ec" translate="yes" xml:space="preserve">
          <source>Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.</source>
          <target state="translated">지정된 조건이 true이면 관찰 가능한 순서로 요소를 무시한 다음 나머지 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5074688d8a8d1a7a2f2146111a01a2d5efa03be4" translate="yes" xml:space="preserve">
          <source>Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.</source>
          <target state="translated">지정된 조건이 true이면 관찰 가능한 순서로 요소를 무시한 다음 나머지 요소를 반환합니다. 요소의 인덱스는 술어 함수의 논리에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="78dc0e523eb5336a4517027ee20f8ce8c1283c64" translate="yes" xml:space="preserve">
          <source>Call a &lt;code&gt;ConnectableObservable&lt;/code&gt;&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; method to instruct it to begin emitting the items from its underlying Observable to its Subscribers.</source>
          <target state="translated">&lt;code&gt;ConnectableObservable&lt;/code&gt; 의 &lt;code&gt;connect&lt;/code&gt; 메소드를 호출하여 기본 Observable에서 구독자에게 항목을 내보내도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="c805453a51ab6e5402991a6b7905abbb82969b88" translate="yes" xml:space="preserve">
          <source>Call a method.</source>
          <target state="translated">메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="846a84e9501ad053efd6f0622ac43a7f2f1a41f9" translate="yes" xml:space="preserve">
          <source>Callbacks Have Their Own Problems</source>
          <target state="translated">콜백에는 자체 문제가 있습니다</target>
        </trans-unit>
        <trans-unit id="5d0513dc45b99b203cc47abe5101858366b0aaa9" translate="yes" xml:space="preserve">
          <source>Callbacks solve the problem of premature blocking on &lt;code&gt;Future.get()&lt;/code&gt; by not allowing anything to block. They are naturally efficient because they execute when the response is ready.</source>
          <target state="translated">콜백은 차단할 수 &lt;code&gt;Future.get()&lt;/code&gt; 하여 Future.get () 에서 조기 차단 문제를 해결합니다 . 응답이 준비되면 실행되기 때문에 자연스럽게 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="fadfad0ea9282bb47746b81a6a4235042d5882c1" translate="yes" xml:space="preserve">
          <source>Canonical, core operator names are in &lt;strong&gt;boldface&lt;/strong&gt;. Other entries represent language-specific variants of these operators or specialty operators outside of the main ReactiveX core set of operators.</source>
          <target state="translated">정식 핵심 연산자 이름은 &lt;strong&gt;굵게 표시&lt;/strong&gt; 됩니다. 다른 항목은 주요 ReactiveX 핵심 연산자 집합 외부의 이러한 연산자 또는 특수 연산자의 언어 별 변형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="e6f5247c2c2f3a3279ed51693bfefd3a423b8bf0" translate="yes" xml:space="preserve">
          <source>Chaining Operators</source>
          <target state="translated">체인 연산자</target>
        </trans-unit>
        <trans-unit id="902bd9921de41f5d7e6b42366eb8310a65a2c945" translate="yes" xml:space="preserve">
          <source>Chaining Your Custom Operators with Standard RxJava Operators</source>
          <target state="translated">표준 RxJava 연산자와 사용자 지정 연산자 연결</target>
        </trans-unit>
        <trans-unit id="d75951d379af65c103f979b689d8cd3675b822a8" translate="yes" xml:space="preserve">
          <source>Checking or Setting Unsubscribed Status</source>
          <target state="translated">수신 거부 상태 확인 또는 설정</target>
        </trans-unit>
        <trans-unit id="4fe96207c9c96f4636acc27e3c848d00d3a71f54" translate="yes" xml:space="preserve">
          <source>Cold Observables are ideal for the reactive pull model of backpressure implemented by some implementations of ReactiveX (which is described elsewhere). Hot Observables typically do not cope well with a reactive pull model, and are better candidates for other flow control strategies, such as the use of the operators described on this page, or operators like &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt;, &lt;a href=&quot;sample&quot;&gt;Sample&lt;/a&gt;, &lt;a href=&quot;debounce&quot;&gt;Debounce&lt;/a&gt;, or &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt;.</source>
          <target state="translated">콜드 옵저버 블은 ReactiveX의 일부 구현 (다른 곳에서 설명)으로 구현 된 역압의 반응성 풀 모델에 이상적입니다. 핫 옵저버 블은 일반적으로 반응 형 풀 모델에 잘 맞지 않으며이 페이지에 설명 된 연산자 또는 &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt; , &lt;a href=&quot;sample&quot;&gt;Sample&lt;/a&gt; , &lt;a href=&quot;debounce&quot;&gt;Debounce&lt;/a&gt; 또는 &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt; 와 같은 연산자의 사용과 같은 다른 흐름 제어 전략에 더 적합한 후보입니다 .</target>
        </trans-unit>
        <trans-unit id="8a4a4428705e4ab030e6ba205ec9858d5968be1b" translate="yes" xml:space="preserve">
          <source>Combine an Observable together with another Observable by merging their emissions into a single Observable.</source>
          <target state="translated">배출물을 단일 Observable에 병합하여 Observable과 다른 Observable을 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="6eaeb8e90e404219d2475ade2286223421965733" translate="yes" xml:space="preserve">
          <source>CombineLatest</source>
          <target state="translated">CombineLatest</target>
        </trans-unit>
        <trans-unit id="6c3a08025c1d0f1b566061e55f26255f61bfc3ba" translate="yes" xml:space="preserve">
          <source>Combining</source>
          <target state="translated">Combining</target>
        </trans-unit>
        <trans-unit id="88d3a1111da9d1eda1c639562973e23995473442" translate="yes" xml:space="preserve">
          <source>Combining Observables</source>
          <target state="translated">옵저버 블 결합</target>
        </trans-unit>
        <trans-unit id="5747c92bf0fa0eeb7e1e03446b2293ecf1be9ebd" translate="yes" xml:space="preserve">
          <source>Composition via Observable Operators</source>
          <target state="translated">관찰 가능한 연산자를 통한 구성</target>
        </trans-unit>
        <trans-unit id="ae5c874513b4df302338425830ff176188a2f641" translate="yes" xml:space="preserve">
          <source>Composition via Single Operators</source>
          <target state="translated">단일 연산자를 통한 구성</target>
        </trans-unit>
        <trans-unit id="3304bad3c3afa5d187ab48d870d028da8b016b08" translate="yes" xml:space="preserve">
          <source>Computes the average of an observable sequence of values.</source>
          <target state="translated">관찰 가능한 값 시퀀스의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="086146e076b0941ac82db3612259103a8c72834b" translate="yes" xml:space="preserve">
          <source>Computes the sum of a sequence of values</source>
          <target state="translated">일련의 값의 합을 계산합니다</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="af22bc2cd4677bc8c0a76b729fa90aba7f0a85a8" translate="yes" xml:space="preserve">
          <source>Concat waits to subscribe to each additional Observable that you pass to it until the previous Observable completes. Note that because of this, if you try to concatenate a &amp;ldquo;hot&amp;rdquo; Observable, that is, one that begins emitting items immediately and before it is subscribed to, Concat will not see, and therefore will not emit, any items that Observable emits before all previous Observables complete and Concat subscribes to the &amp;ldquo;hot&amp;rdquo; Observable.</source>
          <target state="translated">Concat은 이전 Observable이 완료 될 때까지 전달한 추가 Observable을 구독합니다. 이로 인해 &quot;핫&quot;옵저버 블을 연결하려고하면 (즉, 구독하기 직전에 항목을 방출하기 시작하는), Concat은 Observable이 이전에 방출 한 항목을 보지 못하므로 방출하지 않습니다. 모든 이전 Observable이 완료되고 Concat은&amp;ldquo;hot&amp;rdquo;Observable을 구독합니다.</target>
        </trans-unit>
        <trans-unit id="31a49591ac407c790c483a17d515d9fb2a8a38be" translate="yes" xml:space="preserve">
          <source>ConcatMap</source>
          <target state="translated">ConcatMap</target>
        </trans-unit>
        <trans-unit id="7d817faef75bfe91293d3714de7420c6573f23e2" translate="yes" xml:space="preserve">
          <source>Concatenate an observable sequence onto the end of the source observable.</source>
          <target state="translated">관찰 가능 시퀀스를 소스 관찰 가능 오브젝트의 끝에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="105eca8e21d6f9c476cc3a553058b085eb5233eb" translate="yes" xml:space="preserve">
          <source>Concatenates a sequence of observable sequences into a single observable sequence.</source>
          <target state="translated">관찰 가능 시퀀스 시퀀스를 단일 관찰 가능 시퀀스로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="769151df54c355c60c55756c44028ce4f3ae5d6a" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean</source>
          <target state="translated">조건부 및 부울</target>
        </trans-unit>
        <trans-unit id="9b047f76f02c3292f835923209499db8eb35fdb8" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean Operators</source>
          <target state="translated">조건부 및 부울 연산자</target>
        </trans-unit>
        <trans-unit id="b65463cb6a42a17de514acc4659f7fd331e0876a" translate="yes" xml:space="preserve">
          <source>Connect</source>
          <target state="translated">Connect</target>
        </trans-unit>
        <trans-unit id="1f7db7f19ce7165e91e31ee1d9b3ccf7f4d5ddb2" translate="yes" xml:space="preserve">
          <source>Connectable</source>
          <target state="translated">Connectable</target>
        </trans-unit>
        <trans-unit id="7b18cca5708f430e8e5e76af7d6ca811b7d401af" translate="yes" xml:space="preserve">
          <source>Connectable Observable Operators</source>
          <target state="translated">연결 가능한 관찰 가능 연산자</target>
        </trans-unit>
        <trans-unit id="33e15d008d511f3101566a2e25203ef2a3f605a0" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">Contains</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="0815d31f649e51c84f54caac71abf843ed3f8bb3" translate="yes" xml:space="preserve">
          <source>Continues an observable sequence that is terminated by an exception with the next observable sequence.</source>
          <target state="translated">다음 관찰 가능 시퀀스와 함께 예외로 종료되는 관찰 가능 시퀀스를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="6e687c89a4954fc6df4498ea2002f2818d836141" translate="yes" xml:space="preserve">
          <source>Converting Observables</source>
          <target state="translated">옵저버 블 변환</target>
        </trans-unit>
        <trans-unit id="a54800ec0ba74d95f4ae763fd411edb7cb335d1b" translate="yes" xml:space="preserve">
          <source>Converts a promise into an observable</source>
          <target state="translated">약속을 관찰 가능으로 변환</target>
        </trans-unit>
        <trans-unit id="f6fd01b29250836779bf34c8cd915aff0e9c6ef1" translate="yes" xml:space="preserve">
          <source>Converts an Iterator into an observable sequence</source>
          <target state="translated">반복자를 관찰 가능한 시퀀스로 변환</target>
        </trans-unit>
        <trans-unit id="ff785cfdb5ffb690f81079fc7680305d01077af0" translate="yes" xml:space="preserve">
          <source>Converts an array to an observable sequence</source>
          <target state="translated">배열을 관찰 가능한 시퀀스로 변환</target>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="6e157c5da4410b7e9de85f5c93026b9176e69064" translate="yes" xml:space="preserve">
          <source>Create</source>
          <target state="translated">Create</target>
        </trans-unit>
        <trans-unit id="3017d922d76f674ffb9131a65a9d9805b40b649a" translate="yes" xml:space="preserve">
          <source>Creates an observable sequence containing a single element which is an array containing all the elements of the source sequence.</source>
          <target state="translated">소스 시퀀스의 모든 요소를 ​​포함하는 배열 인 단일 요소를 포함하는 관찰 가능 시퀀스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ba20da44f8a1b3b058041022a942932e59185655" translate="yes" xml:space="preserve">
          <source>Creates an observable sequence from a specified subscribeAction callable implementation.</source>
          <target state="translated">지정된 subscribeAction 호출 가능 구현에서 관찰 가능 시퀀스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="92bf119aef55197510b4be1bbec7191fb09b536e" translate="yes" xml:space="preserve">
          <source>Creating</source>
          <target state="translated">Creating</target>
        </trans-unit>
        <trans-unit id="6ad6131d04bc2f8da39dba3829954ab817589a3f" translate="yes" xml:space="preserve">
          <source>Creating Observables</source>
          <target state="translated">Observable 생성</target>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="7cb67bc80f28063e0c70dca78f5ac1f7a7e27b33" translate="yes" xml:space="preserve">
          <source>DZone</source>
          <target state="translated">DZone</target>
        </trans-unit>
        <trans-unit id="9d15bbaea70fed040952f827d04bf23d37deee20" translate="yes" xml:space="preserve">
          <source>Dave Sexton&amp;rsquo;s blog</source>
          <target state="translated">데이브 섹스 턴의 블로그</target>
        </trans-unit>
        <trans-unit id="ba25d0847d81dc2070dc7517ad59c0bcd4bf477c" translate="yes" xml:space="preserve">
          <source>Debounce</source>
          <target state="translated">Debounce</target>
        </trans-unit>
        <trans-unit id="7ee8d644320fde72f64c3c02faecdd18b75c6696" translate="yes" xml:space="preserve">
          <source>Default Schedulers for RxGroovy Observable Operators</source>
          <target state="translated">RxGroovy Observable Operators 기본 스케줄러</target>
        </trans-unit>
        <trans-unit id="1b9dcde6cb5b0bfc6c5ca51b240a6adb12ef894c" translate="yes" xml:space="preserve">
          <source>Default Schedulers for RxJava 1.x Observable Operators</source>
          <target state="translated">RxJava 1.x 관찰 가능 연산자의 기본 스케줄러</target>
        </trans-unit>
        <trans-unit id="123deaeef87eca8cb2b99f856d5107f914acdc3a" translate="yes" xml:space="preserve">
          <source>DefaultIfEmpty</source>
          <target state="translated">DefaultIfEmpty</target>
        </trans-unit>
        <trans-unit id="c4357816d34305505b749a4ff11d936352064da0" translate="yes" xml:space="preserve">
          <source>Defer</source>
          <target state="translated">Defer</target>
        </trans-unit>
        <trans-unit id="530d7bc391670a9d12abc2c95fba599d8d6a4fa3" translate="yes" xml:space="preserve">
          <source>Define a method that does something useful with the return value from the asynchronous call; this method is part of the</source>
          <target state="translated">비동기 호출의 리턴 값으로 유용한 기능을 수행하는 메소드를 정의하십시오. 이 방법은</target>
        </trans-unit>
        <trans-unit id="c776a2467c885ed63c4827a40f24318ee838b755" translate="yes" xml:space="preserve">
          <source>Define the asynchronous call itself as an</source>
          <target state="translated">비동기 호출 자체를</target>
        </trans-unit>
        <trans-unit id="1d05798be1bf5aad240451b19cea28a1042183aa" translate="yes" xml:space="preserve">
          <source>Define your operator as a public class that implements the &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html&quot;&gt;&lt;code&gt;Operator&lt;/code&gt;&lt;/a&gt; interface, like so:</source>
          <target state="translated">운영자를 &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html&quot;&gt; &lt;code&gt;Operator&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 공용 클래스로 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4c200bb0d1f7ba2b7c3e166470a4cb39be0daab" translate="yes" xml:space="preserve">
          <source>Delay</source>
          <target state="translated">Delay</target>
        </trans-unit>
        <trans-unit id="24eb06fa1daed4a5e60d45a988c3f8068a35cdf2" translate="yes" xml:space="preserve">
          <source>DelaySubscription</source>
          <target state="translated">DelaySubscription</target>
        </trans-unit>
        <trans-unit id="17582fe13ad63f1268f0a279d97ba7524dcb4b53" translate="yes" xml:space="preserve">
          <source>Delayed and Periodic Schedulers</source>
          <target state="translated">지연 및 주기적 스케줄러</target>
        </trans-unit>
        <trans-unit id="b9573648319d57f22c34e294a58048517caa06a5" translate="yes" xml:space="preserve">
          <source>Dematerialize</source>
          <target state="translated">Dematerialize</target>
        </trans-unit>
        <trans-unit id="8a57a3d654adf9c3caf76455456be92d962c8113" translate="yes" xml:space="preserve">
          <source>Dematerializes the explicit notification values of an observable sequence as implicit notifications.</source>
          <target state="translated">관찰 가능 시퀀스의 명시 적 알림 값을 암시 적 알림으로 비 물질화합니다.</target>
        </trans-unit>
        <trans-unit id="4faf2e90a3c1b400f4ee9d8c8176a362bc102d3a" translate="yes" xml:space="preserve">
          <source>Distinct</source>
          <target state="translated">Distinct</target>
        </trans-unit>
        <trans-unit id="1fa9ca2d50e91f64ba10b23625a789d1d514ba76" translate="yes" xml:space="preserve">
          <source>DistinctUntilChanged</source>
          <target state="translated">DistinctUntilChanged</target>
        </trans-unit>
        <trans-unit id="22bdf47be3fd0a53ecdf5d6edbde0a2c6b97f0e0" translate="yes" xml:space="preserve">
          <source>Do</source>
          <target state="translated">Do</target>
        </trans-unit>
        <trans-unit id="990799e2354088401f54e49252cb9cd2887b10be" translate="yes" xml:space="preserve">
          <source>Do not block within your operator.</source>
          <target state="translated">작업자를 막지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bde4f7dc6a6a9b2fc7ddc5c5285b6941c477da41" translate="yes" xml:space="preserve">
          <source>Each element of the array is produced as an emission. The difference between this method and &lt;code&gt;Observable.just&lt;/code&gt; is that the latter emits the whole array as one emission.</source>
          <target state="translated">어레이의 각 요소는 방출로 생성됩니다. 이 방법과 &lt;code&gt;Observable.just&lt;/code&gt; 의 차이점 은 후자가 전체 배열을 하나의 방출로 방출한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a91a226ecfae7f33d903980a454ab6aaa9b48e8" translate="yes" xml:space="preserve">
          <source>Each language-specific implementation of ReactiveX has its own naming quirks. There is no canonical naming standard, though there are many commonalities between implementations.</source>
          <target state="translated">ReactiveX의 각 언어 별 구현에는 고유 한 명명 문제가 있습니다. 구현간에 공통점이 많지만 표준 명명 표준은 없습니다.</target>
        </trans-unit>
        <trans-unit id="cef6d442e8c8b1f7447957e1c9784e5f4cc239dc" translate="yes" xml:space="preserve">
          <source>Each language-specific implementation of ReactiveX implements a set of operators. Although there is much overlap between implementations, there are also some operators that are only implemented in certain implementations. Also, each implementation tends to name its operators to resemble those of similar methods that are already familiar from other contexts in that language.</source>
          <target state="translated">ReactiveX의 각 언어 별 구현은 일련의 연산자를 구현합니다. 구현 간에는 겹치는 부분이 많지만 특정 구현에서만 구현되는 일부 연산자도 있습니다. 또한 각 구현은 해당 언어의 다른 컨텍스트에서 이미 익숙한 유사한 메소드의 메소드와 유사하게 연산자의 이름을 지정하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b41b061bd9083507610ef2dcf5baaac02b4db60a" translate="yes" xml:space="preserve">
          <source>ElementAt</source>
          <target state="translated">ElementAt</target>
        </trans-unit>
        <trans-unit id="5c002992eecc90de6e3515445216429d901f6529" translate="yes" xml:space="preserve">
          <source>Emit only those items from an Observable that pass a predicate test.</source>
          <target state="translated">술어 테스트를 통과 한 Observable 항목 만 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="3159fe421b3221381b3c778dc1c3c26e4540be37" translate="yes" xml:space="preserve">
          <source>Empty</source>
          <target state="translated">Empty</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="b8a2a7f6e5c6d27ddebfed1897c207d4db559890" translate="yes" xml:space="preserve">
          <source>Error Handling Operators</source>
          <target state="translated">오류 처리 연산자</target>
        </trans-unit>
        <trans-unit id="9c83f123791849e254666f68cc88dae689457e0d" translate="yes" xml:space="preserve">
          <source>Errors the observable sequence if no item is emitted in the specified time. When a timeout occurs, this operator errors with an instance of Rx\Exception\TimeoutException</source>
          <target state="translated">지정된 시간에 항목이 방출되지 않으면 관찰 가능한 시퀀스를 오류로 만듭니다. 시간 초과가 발생하면이 연산자는 Rx \ Exception \ TimeoutException 인스턴스에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c51d8ac13956137d7379dd1c673b6057e36f8fc" translate="yes" xml:space="preserve">
          <source>Establishing Observers</source>
          <target state="translated">관찰자 설정</target>
        </trans-unit>
        <trans-unit id="ec7a78ddd1e28dabdd3fb142de5c9c3d0907593c" translate="yes" xml:space="preserve">
          <source>Example code showing how similar high-order functions can be applied to an Iterable and an Observable</source>
          <target state="translated">Iterable 및 Observable에 유사한 고차 함수를 적용하는 방법을 보여주는 예제 코드</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="9075edca21736af901d2add18e4d9491f2452b4d" translate="yes" xml:space="preserve">
          <source>Filtering</source>
          <target state="translated">Filtering</target>
        </trans-unit>
        <trans-unit id="b3d1e836b8c9937992dbfac26e772ac39afe998a" translate="yes" xml:space="preserve">
          <source>Filtering Observables</source>
          <target state="translated">관찰 대상 필터링</target>
        </trans-unit>
        <trans-unit id="8978f6a09cf524ab9596b508a2479904c83591c3" translate="yes" xml:space="preserve">
          <source>Finally, there is an alphabetical list of most of the operators available in the many language-specific implementations of ReactiveX. These link to the page that documents the core operator that most closely resembles the language-specific operator (so, for instance, the Rx.NET &amp;ldquo;SelectMany&amp;rdquo; operator links to the documentation of the FlatMap ReactiveX operator, of which &amp;ldquo;SelectMany&amp;rdquo; is the Rx.NET implementation).</source>
          <target state="translated">마지막으로, 많은 언어 별 ReactiveX 구현에서 사용할 수있는 대부분의 연산자가 알파벳순으로 나열되어 있습니다. 이 링크는 언어 별 연산자와 가장 유사한 핵심 연산자를 설명하는 페이지 링크입니다 (예 : Rx.NET &quot;SelectMany&quot;연산자는 FlatMap ReactiveX 연산자의 문서에 연결됩니다. &quot;SelectMany&quot;는 Rx.NET 구현).</target>
        </trans-unit>
        <trans-unit id="9f2160fad1531c502a9ce03c129b6f655416e93f" translate="yes" xml:space="preserve">
          <source>Finally, you can pass it an object that implements either of the &lt;code&gt;Observer&lt;/code&gt; or &lt;code&gt;Subscriber&lt;/code&gt; interfaces. The &lt;code&gt;Observer&lt;/code&gt; interface consists of the three previously-described &amp;ldquo;&lt;code&gt;on&lt;/code&gt;&amp;rdquo; methods. The &lt;code&gt;Subscriber&lt;/code&gt; interface implements these also, and adds a number of additional methods that facilitate reactive pull backpressure and that permit the Subscriber to unsubscribe to an Observable before it completes.</source>
          <target state="translated">마지막으로 &lt;code&gt;Observer&lt;/code&gt; 또는 &lt;code&gt;Subscriber&lt;/code&gt; 인터페이스 를 구현하는 객체를 전달할 수 있습니다. &lt;code&gt;Observer&lt;/code&gt; 인터페이스는 &quot;이전에 설명 된 세 가지 구성 &lt;code&gt;on&lt;/code&gt; 방법&quot;. &lt;code&gt;Subscriber&lt;/code&gt; 인터페이스 구현이 또한 반응성 풀 배압을 용이하게하고이 완료되기 전에 가입자가 피 감시를 거부 할 수 있도록하는 추가 방법들을 추가한다.</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="c5bda5b47fc05cd947485d9dcbc97c118c87af17" translate="yes" xml:space="preserve">
          <source>FlatMap</source>
          <target state="translated">FlatMap</target>
        </trans-unit>
        <trans-unit id="273946dd5d2d1288f9b2aafed80ce36284371ce6" translate="yes" xml:space="preserve">
          <source>For example there is the &lt;code&gt;on&lt;i&gt;Event&lt;/i&gt;&lt;/code&gt; naming pattern (e.g. &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onCompleted&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;). In some contexts such names would indicate methods by means of which event handlers are &lt;em&gt;registered&lt;/em&gt;. In ReactiveX, however, they name the event handlers themselves.</source>
          <target state="translated">예를 들어 &lt;code&gt;on&lt;i&gt;Event&lt;/i&gt;&lt;/code&gt; 명명 패턴이 있습니다 (예 : &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onCompleted&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; ). 일부 상황에서 이러한 이름은 어떤 이벤트 핸들러가 &lt;em&gt;등록&lt;/em&gt; 되는지를 통해 메소드를 나타냅니다 . 그러나 ReactiveX에서는 이벤트 핸들러 자체의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="217442e28d51221a4fdad0309844d07ab64be02a" translate="yes" xml:space="preserve">
          <source>For example, imagine using the &lt;a href=&quot;zip&quot;&gt;Zip&lt;/a&gt; operator to zip together two infinite Observables, one of which emits items twice as frequently as the other. A naive implementation of the operator would have to maintain an ever-expanding buffer of items emitted by the faster Observable to eventually combine with items emitted by the slower one. This could cause ReactiveX to seize an unwieldy amount of system resources.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;zip&quot;&gt;Zip&lt;/a&gt; 연산자를 사용하여 두 개의 무한한 Observable을 함께 압축하면 하나는 다른 것보다 두 배나 자주 항목을 방출합니다. 운영자의 순진한 구현은 더 빠른 Observable에 의해 방출되는 항목의 버퍼를 계속 유지하여 더 느린 항목에 의해 방출 된 항목과 결합해야합니다. 이로 인해 ReactiveX가 다루기 어려운 시스템 리소스를 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c04f7c1d2fb4ddd89c1509683905da7e098003b" translate="yes" xml:space="preserve">
          <source>For example, the following code merges the &lt;code&gt;odds&lt;/code&gt; and &lt;code&gt;evens&lt;/code&gt; into a single Observable. (The &lt;code&gt;subscribeOn&lt;/code&gt; operator makes &lt;code&gt;odds&lt;/code&gt; operate on a different thread from &lt;code&gt;evens&lt;/code&gt; so that the two Observables may both emit items at the same time, to demonstrate how Merge may interleave these items.)</source>
          <target state="translated">예를 들어 다음 코드는 &lt;code&gt;odds&lt;/code&gt; 과 &lt;code&gt;evens&lt;/code&gt; 를 단일 Observable로 병합합니다 . 합니다 ( &lt;code&gt;subscribeOn&lt;/code&gt; 의 오퍼레이터하게 &lt;code&gt;odds&lt;/code&gt; 에서 다른 스레드에서 동작 &lt;code&gt;evens&lt;/code&gt; 두 Observables은 동시에 두 발광 항목 병합 이러한 항목 인터리브 수있는 방법을 보여주기 위해 수 있도록).</target>
        </trans-unit>
        <trans-unit id="dc05c0ee12f75173f33b61a359852128b084b9e1" translate="yes" xml:space="preserve">
          <source>For example, the following code takes a list of unsorted integers, converts it into an Observable, then converts that Observable into one that emits the original list in sorted form as a single item:</source>
          <target state="translated">예를 들어, 다음 코드는 정렬되지 않은 정수 목록을 가져 와서 Observable로 변환 한 다음 해당 Observable을 원래 목록을 정렬 된 형태로 단일 항목으로 내보내는 것으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fbbdfcad6b5a5793860447cf0201a70bee8a2b57" translate="yes" xml:space="preserve">
          <source>For example, the following code uses &lt;code&gt;reduce&lt;/code&gt; to compute, and then emit as an Observable, the sum of the numbers emitted by the source Observable:</source>
          <target state="translated">예를 들어 다음 코드는 &lt;code&gt;reduce&lt;/code&gt; 를 사용하여 소스 Observable이 방출 한 숫자의 합을 계산 한 다음 Observable로 방출합니다.</target>
        </trans-unit>
        <trans-unit id="875655c8a87dcab782ffad12361168b23205728f" translate="yes" xml:space="preserve">
          <source>For example, the following rather pointless code takes a list of integers, converts it into an Observable, then converts that Observable into one that emits the original list as a single item:</source>
          <target state="translated">예를 들어, 다음과 같은 무의미한 코드는 정수 목록을 가져 와서 Observable로 변환 한 다음 Observable을 원래 목록을 단일 항목으로 내보내는 것으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b4afe05eb65cfed34c46b0c5cfa9d72af6ef87ec" translate="yes" xml:space="preserve">
          <source>For the special case of &lt;code&gt;take(0)&lt;/code&gt; you can also pass as a second parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;take&lt;/code&gt; will use to immediately schedule a call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;take(0)&lt;/code&gt; 의 특수한 경우 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러&lt;/a&gt; 가 &lt;code&gt;onCompleted&lt;/code&gt; 에 대한 호출을 즉시 예약하는 &lt;code&gt;take&lt;/code&gt; 사용할 두 번째 매개 변수로 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e288d7fa19e1bf4757ab1d8f5269ca19ed723b7" translate="yes" xml:space="preserve">
          <source>For this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (</source>
          <target state="translated">이러한 이유로 Observable ()의 알림에 응답하는 데 사용하는 세 가지 방법으로 Single을 구독하는 대신 (</target>
        </trans-unit>
        <trans-unit id="2737986da43814cbc95d7c442ca5b8a689aa03a4" translate="yes" xml:space="preserve">
          <source>For this reason, most ReactiveX implementations have methods that allow you to convert certain language-specific objects and data structures into Observables.</source>
          <target state="translated">이러한 이유로 대부분의 ReactiveX 구현에는 특정 언어 별 객체 및 데이터 구조를 Observables로 변환 할 수있는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="392276019fcc1d5272942bce719b6342fcb81e7b" translate="yes" xml:space="preserve">
          <source>From the Observer&amp;rsquo;s point of view, it doesn&amp;rsquo;t matter!</source>
          <target state="translated">관찰자의 관점에서는 중요하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="42428a2d2e461a43cab074a94ea7b862a5694eb9" translate="yes" xml:space="preserve">
          <source>Furthermore, some of these names have different implications in other contexts, or seem awkward in the idiom of a particular implementing language.</source>
          <target state="translated">더욱이 이러한 이름 중 일부는 다른 상황에서 다른 의미를 갖거나 특정 구현 언어의 관용구에서 어색해 보입니다.</target>
        </trans-unit>
        <trans-unit id="1d3db6203d1cee531e933dc661377957741fd7c7" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.</source>
          <target state="translated">지정된 스케줄러를 사용하여 옵저버 메시지를 발송하여 지정된 범위 내에서 관찰 가능한 정수의 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="92d0f29396a5c34e31ebc967172deef307fe570f" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence that repeats the given element the specified number of times.</source>
          <target state="translated">지정된 요소를 지정된 횟수만큼 반복하는 관찰 가능한 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7b53270ad371697bc1e589de2e23706a1f6bcaa9" translate="yes" xml:space="preserve">
          <source>Go on with your business; whenever the call returns, the observer&amp;rsquo;s method will begin to operate on its return value or values &amp;mdash; the</source>
          <target state="translated">당신의 사업을 계속하십시오; 호출이 반환 될 때마다 옵저버의 메소드는 반환 값 또는 값에서 작동하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="63718ab0ad2dfd113729e407e5fdf344eb231fd5" translate="yes" xml:space="preserve">
          <source>GroupBy</source>
          <target state="translated">GroupBy</target>
        </trans-unit>
        <trans-unit id="5b580ccc31ee66edb3fbe2b6a9872b6baf3565df" translate="yes" xml:space="preserve">
          <source>Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.</source>
          <target state="translated">지정된 키 선택기 함수 및 비교기에 따라 관찰 가능 시퀀스의 요소를 그룹화하고 지정된 함수를 사용하여 결과 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="ec80db1447579253ebd9672ba573bfff5db58f5b" translate="yes" xml:space="preserve">
          <source>Here is an example that provides its own sorting function: in this case, one that sorts numbers according to how close they are to the number 5.</source>
          <target state="translated">다음은 자체 정렬 기능을 제공하는 예입니다.이 경우 숫자 5와 얼마나 가까운 지에 따라 숫자를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="ed3a2bd6db43943919933044f161c73f3f3b3390" translate="yes" xml:space="preserve">
          <source>Hides the identity of an observable sequence.</source>
          <target state="translated">관찰 가능 시퀀스의 ID를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="1f4a28cce6229ef2c4b35941085f06d550791705" translate="yes" xml:space="preserve">
          <source>How is this Observable implemented?</source>
          <target state="translated">이 Observable은 어떻게 구현됩니까?</target>
        </trans-unit>
        <trans-unit id="85f43fbd596793edf6bbe3749bc8742ef91cfde4" translate="yes" xml:space="preserve">
          <source>However, if the source Observable terminates with an error, the &lt;code&gt;BehaviorSubject&lt;/code&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">그러나 소스 Observable이 오류와 함께 종료되면 &lt;code&gt;BehaviorSubject&lt;/code&gt; 는 후속 옵저버에게 항목을 내 보내지 않지만 단순히 소스 Observable의 오류 알림을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="77b8c0a40d90b726e62fff83e0e5d057ad8f6562" translate="yes" xml:space="preserve">
          <source>I want an Observable that does not start emitting items to subscribers until asked</source>
          <target state="translated">요청 될 때까지 구독자에게 항목을 내 보내지 않는 Observable을 원합니다</target>
        </trans-unit>
        <trans-unit id="96e0c99e2ca6299088acf813f3684ac6db4f290d" translate="yes" xml:space="preserve">
          <source>I want an Observable that will notify observers of an error</source>
          <target state="translated">관찰자에게 오류를 알리는 Observable을 원합니다.</target>
        </trans-unit>
        <trans-unit id="93ac8f52c641ecf8295c3126651b68566f69ca55" translate="yes" xml:space="preserve">
          <source>I want an Observable to invoke a particular action when certain events occur</source>
          <target state="translated">특정 이벤트가 발생할 때 Observable이 특정 작업을 호출하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="71de0f2184ab945ae7071514e5714fa44c58f556" translate="yes" xml:space="preserve">
          <source>I want an Observable to recover gracefully</source>
          <target state="translated">Observable이 정상적으로 복구되기를 원합니다</target>
        </trans-unit>
        <trans-unit id="bf4218745ff4559c04307408b48fa3c0d95b2e3c" translate="yes" xml:space="preserve">
          <source>I want an operator to operate on a particular &lt;a href=&quot;http://reactivex.io/scheduler.html&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">운영자가 특정 &lt;a href=&quot;http://reactivex.io/scheduler.html&quot;&gt;스케줄러&lt;/a&gt; 에서 작동하기를 원합니다</target>
        </trans-unit>
        <trans-unit id="8bcee030a9b0fc7754e86e874779c1dd0d6fbcf4" translate="yes" xml:space="preserve">
          <source>I want to collect items from an Observable and reemit them as buffers of items</source>
          <target state="translated">Observable에서 아이템을 수집하고 아이템의 버퍼로 다시 내보내고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="9da6c79bd44786fa9d805be97358190877889323" translate="yes" xml:space="preserve">
          <source>I want to convert the entire sequence of items emitted by an Observable into some other data structure</source>
          <target state="translated">Observable이 방출 한 전체 항목 시퀀스를 다른 데이터 구조로 변환하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="99621e91d6f81783ccbca5febefcff99798c51ba" translate="yes" xml:space="preserve">
          <source>I want to create a new Observable</source>
          <target state="translated">새로운 Observable을 만들고 싶습니다</target>
        </trans-unit>
        <trans-unit id="e95392e6ebe4cd2b8d976a6b5dc15ebcc8652c19" translate="yes" xml:space="preserve">
          <source>I want to create a resource that has the same lifespan as the Observable</source>
          <target state="translated">Observable과 동일한 수명을 가진 리소스를 만들고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="e1e5a804f40a4ae53ad6d865409b7eb39972641d" translate="yes" xml:space="preserve">
          <source>I want to create an Observable by combining other Observables</source>
          <target state="translated">다른 Observable을 결합하여 Observable을 만들고 싶습니다</target>
        </trans-unit>
        <trans-unit id="bba42083fc42c06c02ced02fc27975097eda340f" translate="yes" xml:space="preserve">
          <source>I want to emit the items from an Observable after transforming them</source>
          <target state="translated">Observable에서 아이템을 변환 한 후 방출하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="678a797d3d44a8e136336de41859f44d87ea12d0" translate="yes" xml:space="preserve">
          <source>I want to evaluate the entire sequence of items emitted by an Observable</source>
          <target state="translated">Observable이 방출하는 전체 항목 시퀀스를 평가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="342d9df0dc00c6409e061ccbe8bd7a43ec0f1e2f" translate="yes" xml:space="preserve">
          <source>I want to ignore all items emitted by an Observable and only pass along its completed/error notification</source>
          <target state="translated">Observable이 방출 한 모든 항목을 무시하고 완료 / 오류 알림 만 전달하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ac1e59137d512a13724ce068546bdef43aa1b2cf" translate="yes" xml:space="preserve">
          <source>I want to mirror an Observable but prefix items to its sequence</source>
          <target state="translated">Observable이지만 접두사 항목을 시퀀스에 미러링하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="7bdd0d540cc5c4d1feeab4c1bf757d0bb5b1651e" translate="yes" xml:space="preserve">
          <source>I want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item</source>
          <target state="translated">나는 Observables가 아이템을 방출하는 최초의 Observable 컬렉션이라는 조건에서만 Observable에서 아이템을 다시 내보내고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="afea5ad42757cc0909b83ee4ce1bb6c62bd02f89" translate="yes" xml:space="preserve">
          <source>I want to reemit only certain items from an Observable</source>
          <target state="translated">Observable에서 특정 항목 만 다시 내보내고 싶습니다</target>
        </trans-unit>
        <trans-unit id="55e5e42e408215716d6b5f291913c77f52df5dd6" translate="yes" xml:space="preserve">
          <source>I want to retrieve a particular item emitted by an Observable:</source>
          <target state="translated">Observable이 방출하는 특정 항목을 검색하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="386e533e7f72fc5f43c8113497f862fc5eede916" translate="yes" xml:space="preserve">
          <source>I want to shift the items emitted by an Observable forward in time before reemitting them</source>
          <target state="translated">Observable이 방출 한 아이템을 제때에 옮기고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="86a6925e0701483bb01af42b8def481ec4f9b265" translate="yes" xml:space="preserve">
          <source>I want to split one Observable into multiple Observables</source>
          <target state="translated">하나의 Observable을 여러 Observable로 분할하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="51428b8b50c14765922c8b036cca4988742e7efd" translate="yes" xml:space="preserve">
          <source>I want to subscribe to an Observable and receive a &lt;code&gt;Future&lt;/code&gt; that blocks until the Observable completes</source>
          <target state="translated">Observable에 가입 하고 Observable이 완료 될 때까지 차단 되는 &lt;code&gt;Future&lt;/code&gt; 를 받고 싶습니다</target>
        </trans-unit>
        <trans-unit id="1e67d5551cb9e7fce5308aac618b27ccc290f104" translate="yes" xml:space="preserve">
          <source>I want to transform items &lt;em&gt;and&lt;/em&gt; notifications from an Observable into items and reemit them</source>
          <target state="translated">Observable에서 항목 &lt;em&gt;과&lt;/em&gt; 알림을 항목으로 변환 하고 다시 내보내고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="caced85795e91d7af9dfe4ed9e1f46fd5fea7321" translate="yes" xml:space="preserve">
          <source>If a second observer subscribes to an Observable that is already emitting items to a first observer, it is up to the Observable whether it will thenceforth emit the same items to each observer, or whether it will replay the complete sequence of items from the beginning to the second observer, or whether it will emit a wholly different sequence of items to the second observer. There is no general guarantee that two observers of the same Observable will see the same sequence of items.</source>
          <target state="translated">두 번째 옵저버가 이미 첫 번째 옵저버에게 항목을 방출하는 Observable을 구독하는 경우 각 옵저버에게 동일한 항목을 방출 할 것인지 또는 처음부터 끝까지 전체 항목을 재생할지 여부는 Observable에 달려 있습니다. 제 2 관찰자, 또는 제 2 관찰자에게 완전히 다른 순서의 아이템을 방출 할 것인지의 여부. 동일한 Observable의 두 관찰자가 동일한 순서의 항목을 볼 것이라는 일반적인 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0ef7637d7666db7b1cac27130564f15f9858d6b" translate="yes" xml:space="preserve">
          <source>If an Observable has not issued an OnCompleted or OnError notification, an observer may consider it to be still active (even if it is not currently emitting items) and may issue it notifications (such as an Unsubscribe or Request notification). When an Observable does issue an OnCompleted or OnError notification, the Observable may release its resources and terminate, and its observers should not attempt to communicate with it any further.</source>
          <target state="translated">Observable이 OnCompleted 또는 OnError 알림을 발행하지 않은 경우 옵저버는 여전히 활성 상태 인 것으로 간주하여 (현재 항목을 내 보내지 않더라도) 알림을 발행 할 수 있습니다 (예 : 구독 취소 또는 요청 알림). Observable이 OnCompleted 또는 OnError 알림을 발행하면 Observable은 자원을 해제하고 종료 할 수 있으며 관찰자는 더 이상 통신을 시도하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ec7b046dde03b5ea699c95f5183b34be3f0cf4c2" translate="yes" xml:space="preserve">
          <source>If an Observable implements backpressure and its observer employs backpressure, the Observable will not begin to emit items to the observer immediately upon subscription. Instead, it will issue an OnSubscribe notification to the observer.</source>
          <target state="translated">Observable이 배압을 구현하고 Observable이 배압을 사용하는 경우 Observable은 구독 즉시 아이템을 관찰자에게 방출하지 않습니다. 대신 관찰자에게 OnSubscribe 알림을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="733ae6509dbabf4aba675cc3ed47501f58834086" translate="yes" xml:space="preserve">
          <source>If any of the individual Observables passed into &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;mergeAll&lt;/code&gt; terminates with an &lt;code&gt;onError&lt;/code&gt; notification, the resulting Observable will immediately terminate with an &lt;code&gt;onError&lt;/code&gt; notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use &lt;code&gt;mergeDelayError&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 또는 &lt;code&gt;mergeAll&lt;/code&gt; 에 전달 된 개별 Observable 이 &lt;code&gt;onError&lt;/code&gt; 알림으로 종료 되면 결과 Observable은 즉시 &lt;code&gt;onError&lt;/code&gt; 알림으로 종료됩니다 . 오류를보고하기 전에 나머지 오류없는 Observable의 결과를 계속 내보내는 병합을 선호하려면 &lt;code&gt;mergeDelayError&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dcd3e9e82373d3dfce17c1d4311251fdd13222d5" translate="yes" xml:space="preserve">
          <source>If any of the individual Observables passed into &lt;code&gt;merge&lt;/code&gt; terminates with an &lt;code&gt;onError&lt;/code&gt; notification, the Observable produced by &lt;code&gt;merge&lt;/code&gt; itself will immediately terminate with an &lt;code&gt;onError&lt;/code&gt; notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use &lt;code&gt;mergeDelayError&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 전달 된 개별 Observable 중 하나 가 &lt;code&gt;onError&lt;/code&gt; 알림으로 종료되면 &lt;code&gt;merge&lt;/code&gt; 자체로 생성 된 Observable 은 즉시 &lt;code&gt;onError&lt;/code&gt; 알림으로 종료됩니다 . 오류를보고하기 전에 나머지 오류없는 Observable의 결과를 계속 내보내는 병합을 선호하려면 &lt;code&gt;mergeDelayError&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6d250294c4e6c5532d682c6ee0dcbdc73daefb50" translate="yes" xml:space="preserve">
          <source>If instead you want the Observable to emit a default value in such a case, you can pass a second parameter (named &lt;code&gt;defaultValue&lt;/code&gt;) to &lt;code&gt;last&lt;/code&gt;:</source>
          <target state="translated">이러한 경우에 Observable이 기본값 을 생성하도록하려면 &lt;code&gt;defaultValue&lt;/code&gt; 라는 두 번째 매개 변수 를 &lt;code&gt;last&lt;/code&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72eba74aab57235e91614104d881cad347d5f3c6" translate="yes" xml:space="preserve">
          <source>If the Observable produces more items than the observer requests, it is up to the Observable whether it will discard the excess items, store them to emit at a later time, or use some other strategy to deal with the overflow.</source>
          <target state="translated">Observable이 옵저버 요청보다 많은 항목을 생성하는 경우 초과 항목을 버리고 나중에 저장하기 위해 저장하거나 오버플로를 처리하기 위해 다른 전략을 사용할지 여부는 Observable에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="574236c3473cbd9e1a8324c3c8b4368c27b83052" translate="yes" xml:space="preserve">
          <source>If the predicate function returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; will increment the tally of items that it will report when the source Observable completes. If you want to count &lt;em&gt;all&lt;/em&gt; of the items emitted by the source Observable, simply pass &lt;code&gt;count&lt;/code&gt; a predicate that always returns &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">술어 함수가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 &lt;code&gt;count&lt;/code&gt; 는 소스 Observable이 완료 될 때보고 할 항목의 집계를 증가시킵니다. 소스 Observable이 생성 한 &lt;em&gt;모든&lt;/em&gt; 항목 을 계산 하려면 항상 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 술어를 &lt;code&gt;count&lt;/code&gt; 로 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="8eef9a5d07bff0abbbfddd99e1e6d78b055ea35c" translate="yes" xml:space="preserve">
          <source>If the source Observable emits no items (or no items that match the predicate), &lt;code&gt;first&lt;/code&gt; will terminate with a &amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo; &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">소스 Observable에서 항목이 없거나 항목과 일치하는 항목이 없으면 &lt;code&gt;first&lt;/code&gt; &quot; &lt;code&gt;Sequence contains no elements.&lt;/code&gt; &quot;로 종료됩니다 . &amp;rdquo; &lt;code&gt;onError&lt;/code&gt; 알림.</target>
        </trans-unit>
        <trans-unit id="9453ca79c20e7c3d4fd2ab97401f3e8fafa02aee" translate="yes" xml:space="preserve">
          <source>If the source Observable emits no items (or no items that match the predicate), &lt;code&gt;last&lt;/code&gt; will terminate with a &amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo; &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">소스 Observable에서 항목이 없거나 항목과 일치하는 항목이 없으면 &lt;code&gt;last&lt;/code&gt; 에 &quot; &lt;code&gt;Sequence contains no elements.&lt;/code&gt; &quot;로 종료됩니다 . &amp;rdquo; &lt;code&gt;onError&lt;/code&gt; 알림.</target>
        </trans-unit>
        <trans-unit id="aa8c354d5fd059c1f261a3b43af7ba6bf089e618" translate="yes" xml:space="preserve">
          <source>If the source Observable invokes &lt;code&gt;onCompleted&lt;/code&gt; before emitting any items, the Observable returned by &lt;code&gt;toList&lt;/code&gt; will emit an empty list before invoking &lt;code&gt;onCompleted&lt;/code&gt;. If the source Observable invokes &lt;code&gt;onError&lt;/code&gt;, the Observable returned by &lt;code&gt;toList&lt;/code&gt; will immediately invoke the &lt;code&gt;onError&lt;/code&gt; methods of its observers.</source>
          <target state="translated">소스 관찰 가능한 원용이 경우 &lt;code&gt;onCompleted&lt;/code&gt; 모든 항목을 방출하기 전에,에 의해 반환 관찰 &lt;code&gt;toList&lt;/code&gt; 는 호출하기 전에 빈 목록을 방출합니다 &lt;code&gt;onCompleted&lt;/code&gt; . 소스 Observable이 &lt;code&gt;onError&lt;/code&gt; 를 호출하면 &lt;code&gt;toList&lt;/code&gt; 에 의해 리턴 된 Observable 은 해당 옵저버 의 &lt;code&gt;onError&lt;/code&gt; 메소드를 즉시 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ecb1875188746c3fc8a2a22c90eacf4a3b187726" translate="yes" xml:space="preserve">
          <source>If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.</source>
          <target state="translated">소스 Observable이 비어 있으면 true를 방출하는 Observable을 리턴하고 그렇지 않으면 false를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="2e65b113c5ab2efc19f456b3ae0c066cd172ca0d" translate="yes" xml:space="preserve">
          <source>If the source Observable terminates with an error, Count will pass this error notification along without emitting an item first. If the source Observable does not terminate at all, Count will neither emit an item nor terminate.</source>
          <target state="translated">소스 Observable이 오류와 함께 종료되면 Count는 항목을 먼저 내 보내지 않고이 오류 알림을 전달합니다. 소스 Observable이 전혀 종료되지 않으면 Count는 항목을 내보내거나 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f688a0570f5d1b8ac889532c92767877018306e3" translate="yes" xml:space="preserve">
          <source>If the source Observable terminates with an error, the &lt;code&gt;PublishSubject&lt;/code&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">소스 Observable이 오류와 함께 종료되면 &lt;code&gt;PublishSubject&lt;/code&gt; 는 후속 옵저버에게 항목을 내 보내지 않지만 단순히 소스 Observable의 오류 알림을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9bb4470ea625098ffc957da0e83887d5445085ec" translate="yes" xml:space="preserve">
          <source>If there is no element in the source sequence with the index value you specify, &lt;code&gt;elementAt&lt;/code&gt; will issue an &lt;code&gt;onError&lt;/code&gt; notification: &amp;ldquo;&lt;code&gt;Argument out of range&lt;/code&gt;&amp;rdquo;</source>
          <target state="translated">지정한 색인 값을 가진 소스 시퀀스에 요소가없는 경우 &lt;code&gt;elementAt&lt;/code&gt; 는 &lt;code&gt;onError&lt;/code&gt; 알림 을 발행합니다 . &quot; &lt;code&gt;Argument out of range&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="0e894ab20d3a46c26c42e98c6dfcddf872f60c1f" translate="yes" xml:space="preserve">
          <source>If you apply the Replay operator to an Observable before you convert it into a connectable Observable, the resulting connectable Observable will always emit the same complete sequence to any future observers, even those observers that subscribe after the connectable Observable has begun to emit items to other subscribed observers.</source>
          <target state="translated">연결 가능 Observable로 변환하기 전에 Replay 연산자를 Observable에 적용하면 연결 가능한 Observable은 연결 가능한 Observable을 구독 한 후에도 다른 Observable로 항목을 방출하기 시작한 이후의 모든 옵저버에게 항상 동일한 시퀀스를 생성합니다. 구독자.</target>
        </trans-unit>
        <trans-unit id="3097ba365bdc02567dbcce3f4aa13b9f891570a9" translate="yes" xml:space="preserve">
          <source>If you are only interested in the first item emitted by an Observable, or the first item that meets some criteria, you can filter the Observable with the First operator.</source>
          <target state="translated">Observable에서 방출 된 첫 번째 항목 또는 일부 기준을 충족하는 첫 번째 항목에만 관심이있는 경우 First 연산자로 Observable을 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c46bce5c8de030e8f87b590429e41a9b0aa7c5" translate="yes" xml:space="preserve">
          <source>If you are only interested in the last item emitted by an Observable, or the last item that meets some criteria, you can filter the Observable with the Last operator.</source>
          <target state="translated">Observable이 방출 한 마지막 항목 또는 일부 기준을 충족하는 마지막 항목에만 관심이있는 경우 Last 연산자를 사용하여 Observable을 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cde6dfb819e5be751bb6438b8bc1e8380bd27d52" translate="yes" xml:space="preserve">
          <source>If you are unable to guarantee that your operator conforms to the above two tenets, you can add the &lt;a href=&quot;observable-utility-operators#serialize&quot;&gt;&lt;code&gt;serialize( )&lt;/code&gt;&lt;/a&gt; operator to it to force the correct behavior.</source>
          <target state="translated">연산자가 위의 두 가지 원칙을 준수한다고 보장 할 수없는 경우 &lt;a href=&quot;observable-utility-operators#serialize&quot;&gt; &lt;code&gt;serialize( )&lt;/code&gt; &lt;/a&gt; 연산자를 추가 하여 올바른 동작을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cb580494f8e2917761a21353dfc55e61852dd40" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;pause&lt;/code&gt; method of a &lt;code&gt;PausableObservable&lt;/code&gt; created with the &lt;code&gt;pausable&lt;/code&gt; operator, it will drop (ignore) any items emitted by the underlying source Observable until such time as you call its &lt;code&gt;resume&lt;/code&gt; method, whereupon it will continue to pass along emitted items to its observers.</source>
          <target state="translated">당신이 호출 할 경우 &lt;code&gt;pause&lt;/code&gt; (A)의 방법 &lt;code&gt;PausableObservable&lt;/code&gt; 이 로 만든 &lt;code&gt;pausable&lt;/code&gt; 연산자, 당신은 전화로 때까지 관찰 가능한 기본 소스에 의해 방출 된 항목 삭제 (무시)한다 &lt;code&gt;resume&lt;/code&gt; 가에 방출 항목을 함께 전달하는 것 그러자 방법을, 그 관찰자.</target>
        </trans-unit>
        <trans-unit id="0ebf1e42c4df41cf02c078fef78bef390ab290dc" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;pause&lt;/code&gt; method of a &lt;code&gt;PausableObservable&lt;/code&gt; created with the &lt;code&gt;pausableBuffered&lt;/code&gt; operator, it will buffer any items emitted by the underlying source Observable until such time as you call its &lt;code&gt;resume&lt;/code&gt; method, whereupon it will emit those buffered items and then continue to pass along any additional emitted items to its observers.</source>
          <target state="translated">사용자가 호출하는 경우 &lt;code&gt;pause&lt;/code&gt; (A)의 방법 &lt;code&gt;PausableObservable&lt;/code&gt; 가 로 작성된 &lt;code&gt;pausableBuffered&lt;/code&gt; 연산자, 당신이 전화로 될 때까지 관찰 가능한 기본 소스에 의해 방출 된 항목 버퍼링한다 &lt;code&gt;resume&lt;/code&gt; 가 어떤 전달해 후 계속 그 버퍼링 항목을 방출 할 것이다 가는데, 방법 관찰자에게 추가 방출 품목.</target>
        </trans-unit>
        <trans-unit id="0c2ab002bb963be41d5c16f8da5e55d6b8a3fce9" translate="yes" xml:space="preserve">
          <source>If you do not care about the items being emitted by an Observable, but you do want to be notified when it completes or when it terminates with an error, you can apply the &lt;code&gt;ignoreElements&lt;/code&gt; operator to the Observable, which will ensure that it will never call its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt; handlers.</source>
          <target state="translated">Observable이 방출하는 항목은 신경 쓰지 않지만 완료 될 때 또는 오류와 함께 종료 될 때 알림을 &lt;code&gt;ignoreElements&lt;/code&gt; 연산자를 Observable에 적용하여 호출하지 않도록합니다. 관찰자의 &lt;code&gt;onNext&lt;/code&gt; 핸들러.</target>
        </trans-unit>
        <trans-unit id="1d22ca088df792825f2a6dd1d5192358b2d0b360" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window&lt;/code&gt; uses the &lt;code&gt;computation&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">스케줄러를 지정하지 않으면이 &lt;code&gt;window&lt;/code&gt; 변형은 기본적으로 타이머에 대해 &lt;code&gt;computation&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="100e150c378c4889cd317549f1e83b99541904e3" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;windowWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">스케줄러를 지정하지 않으면이 &lt;code&gt;windowWithTime&lt;/code&gt; 변형은 기본적으로 타이머에 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="888dd3de98d14ac68c9106daa319827d52cfb772" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">스케줄러를 지정하지 않으면이 &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; 변형은 기본적으로 타이머에 대해 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b2211604bc2e7c059844a1087c3b24f75a19cf04" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window_with_time&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">스케줄러를 지정하지 않으면이 &lt;code&gt;window_with_time&lt;/code&gt; 변형은 기본적으로 타이머에 대해 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c494ea4ea43f0b89b77c160f3bc5c87d3d7f3fd4" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window_with_time_or_count&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">스케줄러를 지정하지 않으면 &lt;code&gt;window_with_time_or_count&lt;/code&gt; 의이 변형은 기본적으로 타이머에 대해 &lt;code&gt;timeout&lt;/code&gt; 스케줄러를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d565ade5214a4fb6f8454dd74c4548834ae2dc50" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;Subject&lt;/code&gt; and you want to pass it along to some other agent without exposing its &lt;code&gt;Subscriber&lt;/code&gt; interface, you can mask it by calling its &lt;code&gt;asObservable&lt;/code&gt; method, which will return the Subject as a pure &lt;code&gt;Observable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 있고 &lt;code&gt;Subscriber&lt;/code&gt; 인터페이스 를 노출시키지 않고 다른 에이전트에게 전달하려는 경우 &lt;code&gt;asObservable&lt;/code&gt; 메소드 를 호출하여이를 숨기면 주제가 순수한 &lt;code&gt;Observable&lt;/code&gt; 로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="f599ae77d4264a95da87490e66763c1573b59a6f" translate="yes" xml:space="preserve">
          <source>If you pass an Enumerable or Observable of Observables, you have the option of also passing in an integer indicating the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Enumerable 또는 Observable of Observables를 전달하는 경우 동시에 구독하려고하는 해당 Observable의 최대 수를 나타내는 정수를 전달할 수도 있습니다. 이 최대 가입 수에 도달하면 이미 가입 한 Observables 중 하나가 &lt;code&gt;onCompleted&lt;/code&gt; 알림을 발행 할 때까지 소스 Observable이 방출 한 다른 Observable을 구독하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="57eb4e1625176691f9e6cc11d8fa0b29717c9f7b" translate="yes" xml:space="preserve">
          <source>If you pass in a negative index value, &lt;code&gt;elementAt&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.</source>
          <target state="translated">음수 인덱스 값을 전달하면 &lt;code&gt;elementAt&lt;/code&gt; 가 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="bd08e0ec3efa5ea25eaca8fcf04453442b6d2375" translate="yes" xml:space="preserve">
          <source>If you pass in a negative index value, or if the source Observable emits fewer than &lt;code&gt;&lt;i&gt;index
       value&lt;/i&gt;&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; items, &lt;code&gt;elementAt&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.</source>
          <target state="translated">음수 인덱스 값을 전달하거나 소스 Observable이 &lt;code&gt;&lt;i&gt;index value&lt;/i&gt;&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 보다 적은 항목을 방출 하면 &lt;code&gt;elementAt&lt;/code&gt; 는 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2bb67bd2fcbd71bad891a7d78a921dd997297707" translate="yes" xml:space="preserve">
          <source>If you pass in an Observable of Observables, you have the option of also passing in a value indicating to &lt;code&gt;merge&lt;/code&gt; the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Observable of Observables를 전달하는 경우 동시에 구독하도록 시도해야하는 Observable의 최대 수 를 &lt;code&gt;merge&lt;/code&gt; 하도록 표시하는 값을 전달할 수도 있습니다. 이 최대 가입 수에 도달하면 이미 가입 한 Observables 중 하나가 &lt;code&gt;onCompleted&lt;/code&gt; 알림을 발행 할 때까지 소스 Observable이 방출 한 다른 Observable을 구독하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eb5aeff66e4f4beed635dbbd159c10910227639f" translate="yes" xml:space="preserve">
          <source>If you pass it no parameters, it will trigger a subscription to the underlying Observable, but will ignore its emissions and notifications. This will activate a cold Observable.</source>
          <target state="translated">매개 변수를 전달하지 않으면 기본 Observable에 대한 구독이 트리거되지만 배출 및 알림은 무시합니다. 콜드 옵저버 블이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="cc00be547db596f59e064ee2c08761c5578d5d79" translate="yes" xml:space="preserve">
          <source>If you unsubscribe from one of the &lt;code&gt;GroupedObservable&lt;/code&gt;s, or if an operator like &lt;code&gt;take&lt;/code&gt; that you apply to the &lt;code&gt;GroupedObservable&lt;/code&gt; unsubscribes from it, that &lt;code&gt;GroupedObservable&lt;/code&gt; will be terminated. If the source Observable later emits an item whose key matches the &lt;code&gt;GroupedObservable&lt;/code&gt; that was terminated in this way, &lt;code&gt;groupBy&lt;/code&gt; will create and emit a &lt;em&gt;new&lt;/em&gt;&lt;code&gt;GroupedObservable&lt;/code&gt; to match the key. In other words, unsubscribing from a &lt;code&gt;GroupedObservable&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; cause &lt;code&gt;groupBy&lt;/code&gt; to swallow items from its group. For example, see the following code:</source>
          <target state="translated">당신이 중 하나를 취소하는 경우 &lt;code&gt;GroupedObservable&lt;/code&gt; 의 경우, 또는 같은 연산자 &lt;code&gt;take&lt;/code&gt; 당신이 적용된다는 &lt;code&gt;GroupedObservable&lt;/code&gt; 것을, 그것에서 구독 취소 &lt;code&gt;GroupedObservable&lt;/code&gt; 가 종료됩니다. 소스 관찰 가능한 나중에이 방출 그의 키과 정합 항목 경우 &lt;code&gt;GroupedObservable&lt;/code&gt; 이 방법으로 종료되었습니다, &lt;code&gt;groupBy&lt;/code&gt; 생성하고 방출 할 &lt;em&gt;새로운 &lt;/em&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; 을 키와 일치 할 수 있습니다. 즉, 구독 취소 &lt;code&gt;GroupedObservable&lt;/code&gt; 하는 것 &lt;em&gt;없는&lt;/em&gt; 원인 &lt;code&gt;groupBy&lt;/code&gt; 그 그룹에서 항목을 삼킬 수 있습니다. 예를 들어 다음 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f27ee58c426e22c185bfcc111ee4433c42e68d05" translate="yes" xml:space="preserve">
          <source>If you unsubscribe from one of the &lt;code&gt;GroupedObservable&lt;/code&gt;s, that &lt;code&gt;GroupedObservable&lt;/code&gt; will be terminated. If the source Observable later emits an item whose key matches the &lt;code&gt;GroupedObservable&lt;/code&gt; that was terminated in this way, &lt;code&gt;groupBy&lt;/code&gt; will create and emit a new &lt;code&gt;GroupedObservable&lt;/code&gt; to match the key.</source>
          <target state="translated">&lt;code&gt;GroupedObservable&lt;/code&gt; 중 하나에서 구독을 취소하면 해당 &lt;code&gt;GroupedObservable&lt;/code&gt; 이 종료됩니다. 소스 관찰 가능한 나중에이 방출 그의 키과 정합 항목 경우 &lt;code&gt;GroupedObservable&lt;/code&gt; 이 방법으로 종료되었습니다, &lt;code&gt;groupBy&lt;/code&gt; 만들고 새로운 방출합니다 &lt;code&gt;GroupedObservable&lt;/code&gt; 을 키와 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54bb9339c9f0a6407d30c5087cb9c774545f641e" translate="yes" xml:space="preserve">
          <source>If you use a &lt;code&gt;ReplaySubject&lt;/code&gt; as an observer, take care not to call its &lt;code&gt;onNext&lt;/code&gt; method (or its other &lt;code&gt;on&lt;/code&gt; methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates &lt;a href=&quot;contract&quot;&gt;the Observable contract&lt;/a&gt; and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;ReplaySubject&lt;/code&gt; 를 관찰자로, 돌봐는 전화하지 &lt;code&gt;onNext&lt;/code&gt; 방법 (또는 다른 &lt;code&gt;on&lt;/code&gt; 이 위반하는 일치 (비 연속) 호출로 이어질 수 있기 때문에, 여러 스레드에서 방법을) &lt;a href=&quot;contract&quot;&gt;관찰 계약을&lt;/a&gt; 하고 모호성을 만듭니다 어떤 항목 또는 알림을 먼저 재생해야하는지에 대한 결과 주제에서</target>
        </trans-unit>
        <trans-unit id="ee0d3520b5f3d10a48dc017e12fbce21ddb7dc02" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;take(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator (or its synonym, &lt;code&gt;limit(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt;) on an Observable, and that Observable emits fewer than</source>
          <target state="translated">Observable 에서 &lt;code&gt;take(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; 연산자 (또는 동의어, &lt;code&gt;limit(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; )를 사용하고 Observable이</target>
        </trans-unit>
        <trans-unit id="cb665f0140ca7cfd676978a94899df0df149f98a" translate="yes" xml:space="preserve">
          <source>If you want an Observable to emit a specific sequence of items before it begins emitting the items normally expected from it, apply the StartWith operator to it.</source>
          <target state="translated">Observable이 정상적으로 예상되는 항목을 보내기 전에 특정 항목 시퀀스를 내보내려면 StartWith 연산자를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="ed9b26cc4846dd7ff3a51b44674d518103045141" translate="yes" xml:space="preserve">
          <source>If you want to convert an Observable that may emit multiple items into a &lt;code&gt;Future&lt;/code&gt;, try something like this: &lt;code&gt;myObservable.toList().toBlocking().toFuture()&lt;/code&gt;.</source>
          <target state="translated">여러 항목을 &lt;code&gt;Future&lt;/code&gt; 로 내보낼 수있는 Observable을 변환하려면 &lt;code&gt;myObservable.toList().toBlocking().toFuture()&lt;/code&gt; 와 같이 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="126fda7bd3aebaa0b8ff116732464d2b0b7d7b8b" translate="yes" xml:space="preserve">
          <source>If you want to implement your own operator, see &lt;a href=&quot;implement-operator&quot;&gt;Implementing Your Own Operators&lt;/a&gt;.</source>
          <target state="translated">자체 운영자를 구현하려면 자신의 운영자 &lt;a href=&quot;implement-operator&quot;&gt;구현을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f09f724f096a4aeef1d6681ca23a57c6938f183" translate="yes" xml:space="preserve">
          <source>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular</source>
          <target state="translated">멀티 스레딩을 일련의 Observable 연산자에 도입하려는 경우 해당 연산자 (또는 특정 Observable)가 특정 장치에서 작동하도록 지시하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf253b6526751dab305e3b5af636233ab2cfc540" translate="yes" xml:space="preserve">
          <source>If your operator is designed to &lt;em&gt;originate&lt;/em&gt; an Observable, rather than to transform or react to a source Observable, use the &lt;a href=&quot;operators/create&quot;&gt;&lt;code&gt;create( )&lt;/code&gt;&lt;/a&gt; method rather than trying to implement &lt;code&gt;Observable&lt;/code&gt; manually. Otherwise, follow the instructions below.</source>
          <target state="translated">연산자가 소스 Observable을 변환하거나 반응하지 않고 Observable 을 &lt;em&gt;시작&lt;/em&gt; 하도록 설계된 경우 &lt;code&gt;Observable&lt;/code&gt; 을 수동으로 구현하지 않고 &lt;a href=&quot;operators/create&quot;&gt; &lt;code&gt;create( )&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 . 그렇지 않으면 아래 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="1a4b5013699939e2ed2c63f5435fe7f247de7353" translate="yes" xml:space="preserve">
          <source>If your operator uses functions or lambdas that are passed in as parameters (predicates, for instance), note that these may be sources of exceptions, and be prepared to catch these and notify subscribers via &lt;code&gt;onError( )&lt;/code&gt; calls.</source>
          <target state="translated">연산자가 매개 변수 (예 : 술어)로 전달 된 함수 또는 람다를 사용하는 경우 예외의 원인이 될 수 있으며 &lt;code&gt;onError( )&lt;/code&gt; 호출을 통해이를 알리고 구독자에게 알리도록 준비하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d10a49a1c9f362ffcdd30bcc2d70e20ca8a33fb" translate="yes" xml:space="preserve">
          <source>IgnoreElements</source>
          <target state="translated">IgnoreElements</target>
        </trans-unit>
        <trans-unit id="6e3bf6a26e7b015407f7e23c30d9aad02237ac19" translate="yes" xml:space="preserve">
          <source>Implementing Your Operator</source>
          <target state="translated">운영자 구현</target>
        </trans-unit>
        <trans-unit id="080201a38e03e3f517b6f68adc6f2cdb032d6de9" translate="yes" xml:space="preserve">
          <source>Implementing Your Own Operators</source>
          <target state="translated">자신의 연산자 구현</target>
        </trans-unit>
        <trans-unit id="d9746961ed48f27eba42c580dc7c910e85405477" translate="yes" xml:space="preserve">
          <source>In ReactiveX an</source>
          <target state="translated">ReactiveX에서</target>
        </trans-unit>
        <trans-unit id="e07101b5e398b22985de43fce99e80ccc71f4b18" translate="yes" xml:space="preserve">
          <source>In ReactiveX it is not difficult to get into a situation in which an Observable is emitting items more rapidly than an operator or observer can consume them. This presents the problem of what to do with such a growing backlog of unconsumed items.</source>
          <target state="translated">ReactiveX에서 Observable이 작업 자나 관찰자가 소비 할 수있는 것보다 더 빠르게 항목을 방출하는 상황에 들어가는 것은 어렵지 않습니다. 이는 소비되지 않은 품목에 대한 백 로그가 증가함에 따라 수행 할 작업의 문제점을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4d88767b8ff979df7115dbd13cc1795448ccafca" translate="yes" xml:space="preserve">
          <source>In Rx.NET the Observable this operator creates emits an Integer value, but there is also a &lt;code&gt;LongCount&lt;/code&gt; whose Observable emits a Long value. With both variants, you can either pass the source Observable in to the operator as a parameter or you can call the operator as an instance method of the source Observable (in which case you omit the parameter).</source>
          <target state="translated">Rx.NET에서 Observable은이 연산자를 생성하면 정수 값을 생성하지만 Observable이 Long 값을 생성 하는 &lt;code&gt;LongCount&lt;/code&gt; 도 있습니다 . 두 가지 변형을 모두 사용하면 소스 Observable을 매개 변수로 연산자에 전달하거나 소스 Observable의 인스턴스 메소드로 연산자를 호출 할 수 있습니다 (이 경우 매개 변수를 생략 함).</target>
        </trans-unit>
        <trans-unit id="082753d6aa99a3e49c22beaa10c53f7d50ccf53c" translate="yes" xml:space="preserve">
          <source>In Rx.NET there are several variants of Buffer. For each variety you can either pass in the source Observable as the first parameter, or you can call it as an instance method of the source Observable (in which case you can omit that parameter):</source>
          <target state="translated">Rx.NET에는 Buffer의 여러 변형이 있습니다. 각 버라이어티에 대해 소스 Observable을 첫 번째 매개 변수로 전달하거나 소스 Observable의 인스턴스 메소드로 호출 할 수 있습니다 (이 경우 해당 매개 변수를 생략 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="866459115059c570312783d7d933eb56a2044752" translate="yes" xml:space="preserve">
          <source>In Rx.rb you have the option to pass &lt;code&gt;count&lt;/code&gt; a predicate that takes an item emitted by the source Observable as a parameter. If you do so, &lt;code&gt;count&lt;/code&gt; will emit a count only of those items from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;. Otherwise it will emit a count of all items emitted by the source Observable.</source>
          <target state="translated">Rx.rb에서 당신은 통과 할 수있는 옵션이 &lt;code&gt;count&lt;/code&gt; 매개 변수로 관찰 가능한 소스에 의해 방출되는 항목을 취하는 술어를. 그렇게하면 &lt;code&gt;count&lt;/code&gt; 는 술어가 &lt;code&gt;true&lt;/code&gt; 로 평가하는 소스 Observable에서 해당 항목의 수만 방출 합니다 . 그렇지 않으면 소스 Observable이 방출 한 모든 항목의 수를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="174c58d2e87272ea8e66142ea84c078a35283c3e" translate="yes" xml:space="preserve">
          <source>In Rx.rb, &lt;code&gt;on_error_resume_next&lt;/code&gt; inherits the misleading nomenclature from Rx.NET in that it concatenates the second Observable sequence to the source sequence whether that source sequence terminates normally or with an error.</source>
          <target state="translated">Rx.rb에서 &lt;code&gt;on_error_resume_next&lt;/code&gt; 는 소스 시퀀스가 ​​정상적으로 종료되는지 오류인지에 관계없이 두 번째 Observable 시퀀스를 소스 시퀀스에 연결한다는 점에서 Rx.NET의 잘못된 명명법을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="3dc1fcc902763003b44007791de3712de7a57a0c" translate="yes" xml:space="preserve">
          <source>In Rx.rb, the &lt;code&gt;concat&lt;/code&gt; operator operates on two Observables as an instance operator, or on an array of Observables as a class method.</source>
          <target state="translated">Rx.rb에서 &lt;code&gt;concat&lt;/code&gt; 연산자는 두 개의 Observable에서 인스턴스 연산자로 작동하거나 Observable의 배열에서 클래스 메서드로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c3abf8fb4fa82e726050a8136a37f39dd9dbaf32" translate="yes" xml:space="preserve">
          <source>In RxClojure &lt;code&gt;concat&lt;/code&gt; concatenates some number of individual Observables together in the order in which they are given.</source>
          <target state="translated">RxClojure에서 &lt;code&gt;concat&lt;/code&gt; 은 몇 개의 개별 Observable을 주어진 순서대로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="bc54b08c66d20cbbb553766813dfa06d5c1e25ba" translate="yes" xml:space="preserve">
          <source>In RxClojure there are six operators of concern here:</source>
          <target state="translated">RxClojure에는 다음과 같은 6 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="659fe011d5c89b01a2304a5c8e2bb81d2ad313c9" translate="yes" xml:space="preserve">
          <source>In RxGroovy the operator is called &lt;code&gt;count&lt;/code&gt; and the Observable it creates emits an Integer value. There is also a &lt;code&gt;countLong&lt;/code&gt; whose Observable emits a Long value.</source>
          <target state="translated">RxGroovy에서 연산자는 &lt;code&gt;count&lt;/code&gt; 라고 하며 Observable은 Integer 값을 생성합니다. Observable이 Long 값을 방출하는 &lt;code&gt;countLong&lt;/code&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d76cd52669eae9e069058fa6344e3c8d433d43c8" translate="yes" xml:space="preserve">
          <source>In RxGroovy there are several variants of Buffer:</source>
          <target state="translated">RxGroovy에는 Buffer의 여러 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="03bd02f7f4db8f2104aaf4dd90fc1dad471cf32a" translate="yes" xml:space="preserve">
          <source>In RxGroovy there is a variety of the &lt;code&gt;replay&lt;/code&gt; operator that returns a connectable Observable. You must &lt;a href=&quot;publish&quot;&gt;Publish&lt;/a&gt; this connectable Observable before observers can subscribe to it, and then &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; to it in order to observe its emissions.</source>
          <target state="translated">RxGroovy에는 연결 가능한 Observable을 반환하는 다양한 &lt;code&gt;replay&lt;/code&gt; 연산자가 있습니다. 당신은해야한다 &lt;a href=&quot;publish&quot;&gt;게시&lt;/a&gt; 관찰자가 가입 한 다음하기 전에이 연결 가능한 관찰 가능한을 &lt;a href=&quot;connect&quot;&gt;연결&lt;/a&gt; 배출량을 관찰하기 위해 그것.</target>
        </trans-unit>
        <trans-unit id="4db754926010b838dcaf35e54ecc9e4308fc9f4d" translate="yes" xml:space="preserve">
          <source>In RxGroovy there is also a version of the &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; operator that converts a &lt;code&gt;Future&lt;/code&gt; into an Observable, and in this way resembles the Start operator.</source>
          <target state="translated">RxGroovy에는 &lt;code&gt;Future&lt;/code&gt; 를 Observable로 변환하는 &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; 연산자 버전도 있으며 , 이런 식으로 Start 연산자와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7572e0a31faefbf7ff70dca0814645c09d2770c6" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;doWhile&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;doWhile&lt;/code&gt; checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">RxGroovy에서 &lt;code&gt;doWhile&lt;/code&gt; 은 표준 연산자 세트의 일부가 아니지만 선택적 &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; 패키지의 일부입니다. &lt;code&gt;doWhile&lt;/code&gt; 은 소스 시퀀스를 반복 할 때마다 조건을 확인하고 해당 조건이 true 인 경우에만 조건을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="3aa8ae88df582d489c98f809e108617b6f090787" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;materialize&lt;/code&gt; transforms the notifications from the source Observable into &lt;code&gt;Notification&lt;/code&gt; objects and emits them as the emissions from the Observable it returns. For example:</source>
          <target state="translated">RxGroovy에서 &lt;code&gt;materialize&lt;/code&gt; 는 소스 Observable의 &lt;code&gt;Notification&lt;/code&gt; 을 Notification 객체 로 변환하고 반환되는 Observable의 배출량으로 방출합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="237f50a50a7216fd4056fb13f9fb3ed56266ba27" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;whileDo&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;whileDo&lt;/code&gt; checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">RxGroovy에서 &lt;code&gt;whileDo&lt;/code&gt; 는 표준 연산자 세트의 일부는 아니지만 선택적 &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; 패키지의 일부입니다. &lt;code&gt;whileDo&lt;/code&gt; 는 소스 시퀀스가 ​​반복 될 때마다 조건을 확인하고 해당 조건이 참인 경우에만 반복합니다.</target>
        </trans-unit>
        <trans-unit id="dc4459eb5576a0985852d40aad97090be35fe7fe" translate="yes" xml:space="preserve">
          <source>In RxGroovy, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; interface. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">RxGroovy에서 &lt;code&gt;connect&lt;/code&gt; 연산자는 &lt;code&gt;ConnectableObservable&lt;/code&gt; 인터페이스 의 방법입니다 . &lt;code&gt;publish&lt;/code&gt; 연산자를 사용하여 일반 Observable을 &lt;code&gt;ConnectableObservable&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0218c1d751cc26a5e8cbb187a070d185be55fd96" translate="yes" xml:space="preserve">
          <source>In RxGroovy, the &lt;code&gt;from&lt;/code&gt; operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.</source>
          <target state="translated">RxGroovy에서 &lt;code&gt;from&lt;/code&gt; 연산자는 Future, Iterable 또는 Array를 변환 할 수 있습니다. Iterable 또는 Array의 경우 결과 Observable은 Iterable 또는 Array에 포함 된 각 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="077b76d936cc54a4fbdf52bb6a3d71bca4542ef9" translate="yes" xml:space="preserve">
          <source>In RxGroovy, these are not part of the core ReactiveX implementation, but are found as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;then&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; in the &lt;code&gt;rxjava-joins&lt;/code&gt; module.</source>
          <target state="translated">RxGroovy, 이러한 핵심 ReactiveX 구현의 일부가 아니지만으로 발견 &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;then&lt;/code&gt; , 그리고 &lt;code&gt;when&lt;/code&gt; 에 &lt;code&gt;rxjava-joins&lt;/code&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="98c6ab7a826f68ee896f9e7bbec6a50b13018591" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this filtering operator is implemented as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt;.</source>
          <target state="translated">RxGroovy에서이 필터링 연산자는 &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; 및 &lt;code&gt;takeFirst&lt;/code&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="29837dbff839813080383499d8c69a5c010c8559" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this filtering operator is implemented as &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt;.</source>
          <target state="translated">RxGroovy에서이 필터링 연산자는 &lt;code&gt;last&lt;/code&gt; 및 &lt;code&gt;lastOrDefault&lt;/code&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="524670218e1528528dc3e43a23a6e9ec903626f3" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">RxGroovy에서이 연산자는 &lt;code&gt;skip&lt;/code&gt; 으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8a0032a96a9e999b2568c2953d3e8ba98be07a8" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">RxGroovy에서이 연산자는 &lt;code&gt;skipUntil&lt;/code&gt; 으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ab9e4908bb4235f47b80c1c77b023791f672cb3" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">RxGroovy에서이 연산자는 &lt;code&gt;take&lt;/code&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="5071f8b712a1a2faafa543e15f33108e9b05eb0e" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;takeUntil&lt;/code&gt;. Note that the second Observable can cause &lt;code&gt;takeUntil&lt;/code&gt; to quit emitting items either by emitting an item or by issuing an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">RxGroovy에서이 연산자는 &lt;code&gt;takeUntil&lt;/code&gt; 으로 구현됩니다 . 두 번째 Observable은 항목을 &lt;code&gt;takeUntil&lt;/code&gt; 거나 &lt;code&gt;onError&lt;/code&gt; 또는 &lt;code&gt;onCompleted&lt;/code&gt; 알림 을 발행하여 takeUntil 이 항목 방출을 종료하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da02f4576a4b5a5747703904db2371ebcf038e26" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;averageDouble&lt;/code&gt;, &lt;code&gt;averageFloat&lt;/code&gt;, &lt;code&gt;averageInteger&lt;/code&gt;, and &lt;code&gt;averageLong&lt;/code&gt;. The following example shows how these operators work:</source>
          <target state="translated">RxGroovy에서이 연산자는 ReactiveX 코어에 없지만 독특한 &lt;code&gt;rxjava-math&lt;/code&gt; 모듈 의 일부입니다.이 모듈은 &lt;code&gt;averageDouble&lt;/code&gt; , &lt;code&gt;averageFloat&lt;/code&gt; , &lt;code&gt;averageInteger&lt;/code&gt; 및 &lt;code&gt;averageLong&lt;/code&gt; 의 네 가지 유형별 연산자로 구현됩니다 . 다음 예제는 이러한 연산자의 작동 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="badd3303a8eb778bfc48d7a87db09f83d8fb14fa" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;sumDouble&lt;/code&gt;, &lt;code&gt;sumFloat&lt;/code&gt;, &lt;code&gt;sumInteger&lt;/code&gt;, and &lt;code&gt;sumLong&lt;/code&gt;. The following example shows how these operators work:</source>
          <target state="translated">RxGroovy에서이 연산자는 ReactiveX 코어에 없지만 고유 한 &lt;code&gt;rxjava-math&lt;/code&gt; 모듈 의 일부이며 &lt;code&gt;sumDouble&lt;/code&gt; , &lt;code&gt;sumFloat&lt;/code&gt; , &lt;code&gt;sumInteger&lt;/code&gt; 및 &lt;code&gt;sumLong&lt;/code&gt; 의 네 가지 유형별 연산자로 구현됩니다 . 다음 예제는 이러한 연산자의 작동 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c07cae2ff645e10f1475b173e92b2e4d1731fbd8" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module.</source>
          <target state="translated">RxGroovy에서이 연산자는 ReactiveX 코어에 없지만 고유 한 &lt;code&gt;rxjava-math&lt;/code&gt; 모듈의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="39f81aa6294cb9c74bcf4eb9eeea361e7952d8bb" translate="yes" xml:space="preserve">
          <source>In RxJS the operator &lt;code&gt;count&lt;/code&gt; counts the number of items in the source Observable that satisfy a specified predicate. That predicate takes the form of a function that takes three parameters:</source>
          <target state="translated">RxJS에서 연산자 &lt;code&gt;count&lt;/code&gt; 는 지정된 술어를 만족하는 소스 Observable의 항목 수를 계산합니다. 이 술어는 세 가지 매개 변수를 취하는 함수 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="089ff40ee2d57ffddd76d98e11442fdb0f93e79e" translate="yes" xml:space="preserve">
          <source>In RxJS there are two versions of the &lt;code&gt;timer&lt;/code&gt; operator.</source>
          <target state="translated">RxJS에는 두 가지 버전의 &lt;code&gt;timer&lt;/code&gt; 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="546ed95cf4899b2546736d0dc77f0000eca5cc15" translate="yes" xml:space="preserve">
          <source>In RxJS you can set the per-item delay in two ways: by passing a number of milliseconds into the &lt;code&gt;delay&lt;/code&gt; operator (which will delay each emission by that amount of time), or by passing in a &lt;code&gt;Date&lt;/code&gt; object (which will delay the beginning of the sequence of emissions until that absolute point in time).</source>
          <target state="translated">RxJS에서 당신은 두 가지 방법으로 항목 당 지연 시간을 설정할 수 있습니다 다음에 밀리 초 수를 전달하여 &lt;code&gt;delay&lt;/code&gt; (시간의 양에 의해 각각의 방출을 지연됩니다) 연산자, 또는 전달하여 &lt;code&gt;Date&lt;/code&gt; 시작을 지연 할 (객체 그 절대 시점까지 배출 순서의).</target>
        </trans-unit>
        <trans-unit id="a91657e27431e8473a66e219d9cffa8076861683" translate="yes" xml:space="preserve">
          <source>In RxJS you obtain Schedulers from the &lt;code&gt;Rx.Scheduler&lt;/code&gt; object or as independently-implemented objects. The following table shows the varieties of Scheduler that are available to you in RxJS:.</source>
          <target state="translated">RxJS에서 당신은에서 스케줄러를 얻기 &lt;code&gt;Rx.Scheduler&lt;/code&gt; 의 객체 또는 독립적으로 구현 객체. 다음 표는 RxJS에서 사용할 수있는 다양한 스케줄러를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="59380515fb1764dd57d6d356f045c860c3897dad" translate="yes" xml:space="preserve">
          <source>In RxJS, &lt;code&gt;sequenceEqual&lt;/code&gt; is a method of a particular Observable instance, so you pass it exactly one other Observable to compare the instance to. You can optionally pass a second parameter: a function that accepts two items and returns &lt;code&gt;true&lt;/code&gt; if they are equal according to a standard of your choosing. &lt;code&gt;sequenceEqual&lt;/code&gt; returns an Observable that will emit a &lt;code&gt;true&lt;/code&gt; if the two Observables emit the same set of items in the same order before completing, or a &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">RxJS에서 &lt;code&gt;sequenceEqual&lt;/code&gt; 은 특정 Observable 인스턴스의 메소드이므로 인스턴스를 비교하기 위해 정확히 다른 Observable을 전달합니다. 선택적으로 두 번째 매개 변수를 전달할 수 있습니다. 두 항목을 허용하고 선택한 표준에 따라 동일한 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 함수입니다 . &lt;code&gt;sequenceEqual&lt;/code&gt; 는 방출 것이라는 관측 가능한 반환 &lt;code&gt;true&lt;/code&gt; 두 Observables은이 완료하기 전에 같은 순서로 항목의 동일한 세트를 방출, 또는 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="e39fb67c9a541a9b33aa36d76685b7973746c9cf" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; prototype. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">RxJS에서 &lt;code&gt;connect&lt;/code&gt; 연산자는 &lt;code&gt;ConnectableObservable&lt;/code&gt; 프로토 타입 의 방법입니다 . &lt;code&gt;publish&lt;/code&gt; 연산자를 사용하여 일반 Observable을 &lt;code&gt;ConnectableObservable&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d1dad5015733748479ef787bfb5054f381799c6" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;distinct&lt;/code&gt; operator has two optional parameters:</source>
          <target state="translated">RxJS에서 &lt;code&gt;distinct&lt;/code&gt; 연산자에는 두 가지 선택적 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="60aeaf00dfd42ac1f2aa979d31edd932b2e05c96" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;from&lt;/code&gt; operator converts an array-like or iterable object into an Observable that emits the items in that array or iterable. A String, in this context, is treated as an array of characters.</source>
          <target state="translated">RxJS에서 &lt;code&gt;from&lt;/code&gt; 연산자는 배열 유사 또는 반복 가능 오브젝트를 해당 배열 또는 반복 가능 항목을 방출하는 Observable로 변환합니다. 이 문맥에서 문자열은 문자 배열로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="32f572fa2a9a0912cc3687d3d2b76c82ee440842" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;publish&lt;/code&gt; operator takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the returned &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">RxJS에서 &lt;code&gt;publish&lt;/code&gt; 연산자는 함수를 매개 변수로 사용합니다. 이 함수는 소스 Observable에서 방출 된 항목을 매개 변수로 가져와 리턴 된 &lt;code&gt;ConnectableObservable&lt;/code&gt; 에 의해 그 위치에서 방출 될 항목을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="220a1ea76599fe696f6ff55d0b0240936d7391d9" translate="yes" xml:space="preserve">
          <source>In RxJS, you can subscribe to an Observable in two ways:</source>
          <target state="translated">RxJS에서 두 가지 방법으로 Observable을 구독 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0434c25ac778b06dc0f0e430a507026d4ffcd13" translate="yes" xml:space="preserve">
          <source>In RxJava the operator is called &lt;code&gt;count&lt;/code&gt; and the Observable it creates emits an Integer value. There is also a &lt;code&gt;countLong&lt;/code&gt; whose Observable emits a Long value.</source>
          <target state="translated">RxJava에서 연산자는 &lt;code&gt;count&lt;/code&gt; 라고 하며 Observable 은 생성자 가 정수 값을 생성합니다. Observable이 Long 값을 방출하는 &lt;code&gt;countLong&lt;/code&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4d2614f2ccefc9538a2a5b53a4e9f2384b8a21" translate="yes" xml:space="preserve">
          <source>In RxJava there are several variants of Buffer:</source>
          <target state="translated">RxJava에는 Buffer의 여러 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5324a1b154d0b35b0430e397999d44bbb2293830" translate="yes" xml:space="preserve">
          <source>In RxJava there is a variety of the &lt;code&gt;replay&lt;/code&gt; operator that returns a connectable Observable. You must &lt;a href=&quot;publish&quot;&gt;Publish&lt;/a&gt; this connectable Observable before observers can subscribe to it, and then &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; to it in order to observe its emissions.</source>
          <target state="translated">RxJava에는 연결 가능한 Observable을 반환하는 다양한 &lt;code&gt;replay&lt;/code&gt; 연산자가 있습니다. 당신은해야한다 &lt;a href=&quot;publish&quot;&gt;게시&lt;/a&gt; 관찰자가 가입 한 다음하기 전에이 연결 가능한 관찰 가능한을 &lt;a href=&quot;connect&quot;&gt;연결&lt;/a&gt; 배출량을 관찰하기 위해 그것.</target>
        </trans-unit>
        <trans-unit id="fa9a02b1a23712e12eaf9bf38e6513173d05aad6" translate="yes" xml:space="preserve">
          <source>In RxJava there is also a version of the &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; operator that converts a &lt;code&gt;Future&lt;/code&gt; into an Observable, and in this way resembles the Start operator.</source>
          <target state="translated">RxJava에는 &lt;code&gt;Future&lt;/code&gt; 를 Observable로 변환하는 &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; 연산자 버전도 있으며 , 이런 식으로 Start 연산자와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d66e9a41859140e63d2a513b65a3eb33c3064950" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;doWhile&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;doWhile&lt;/code&gt; checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">RxJava에서 &lt;code&gt;doWhile&lt;/code&gt; 은 표준 연산자 세트의 일부가 아니지만 선택적 &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; 패키지의 일부입니다. &lt;code&gt;doWhile&lt;/code&gt; 은 소스 시퀀스를 반복 할 때마다 조건을 확인하고 해당 조건이 true 인 경우에만 조건을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="278ec5920441fdbb971e38eb40408f25e66352a0" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;materialize&lt;/code&gt; transforms the notifications from the source Observable into &lt;code&gt;Notification&lt;/code&gt; objects and emits them as the emissions from the Observable it returns.</source>
          <target state="translated">RxJava에서 &lt;code&gt;materialize&lt;/code&gt; 는 소스 Observable의 &lt;code&gt;Notification&lt;/code&gt; 을 Notification 객체 로 변환하고 반환 된 Observable의 배출로 방출합니다.</target>
        </trans-unit>
        <trans-unit id="b9040120474fb9e9d6678ef11c5d331e3831055d" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;whileDo&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;whileDo&lt;/code&gt; checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">RxJava에서 &lt;code&gt;whileDo&lt;/code&gt; 는 표준 연산자 세트의 일부는 아니지만 선택적 &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; 패키지의 일부입니다. &lt;code&gt;whileDo&lt;/code&gt; 는 소스 시퀀스가 ​​반복 될 때마다 조건을 확인하고 해당 조건이 참인 경우에만 반복합니다.</target>
        </trans-unit>
        <trans-unit id="7cda80172d796ec17e6de8b0b3fb7df8961f5322" translate="yes" xml:space="preserve">
          <source>In RxJava, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; interface. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">RxJava에서 &lt;code&gt;connect&lt;/code&gt; 연산자는 &lt;code&gt;ConnectableObservable&lt;/code&gt; 인터페이스 의 메소드입니다 . &lt;code&gt;publish&lt;/code&gt; 연산자를 사용하여 일반 Observable을 &lt;code&gt;ConnectableObservable&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d915aa8a6371b24d546a898d5927650d68298d10" translate="yes" xml:space="preserve">
          <source>In RxJava, the &lt;code&gt;from&lt;/code&gt; operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.</source>
          <target state="translated">RxJava에서 &lt;code&gt;from&lt;/code&gt; 연산자는 Future, Iterable 또는 Array를 변환 할 수 있습니다. Iterable 또는 Array의 경우 결과 Observable은 Iterable 또는 Array에 포함 된 각 항목을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="8aa6f776ef4b58ae93606199eab5d7aae9f12a1b" translate="yes" xml:space="preserve">
          <source>In RxJava, this filtering operator is implemented as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt;.</source>
          <target state="translated">RxJava에서이 필터링 연산자는 &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; 및 &lt;code&gt;takeFirst&lt;/code&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a4f120274458ea753c59c58263b7e7f5ac97cf7" translate="yes" xml:space="preserve">
          <source>In RxJava, this filtering operator is implemented as &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt;.</source>
          <target state="translated">RxJava에서이 필터링 연산자는 &lt;code&gt;last&lt;/code&gt; 및 &lt;code&gt;lastOrDefault&lt;/code&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="7aaf45cbe7681d9fc78492e0e1abae440e60cdd8" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">RxJava에서이 연산자는 &lt;code&gt;skip&lt;/code&gt; 으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad7d874d083f1f23b84c1a24058def9a12d847a5" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">RxJava에서이 연산자는 &lt;code&gt;skipUntil&lt;/code&gt; 으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0df78c0cd8e0c04b88996b41f57536868e395ae" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">RxJava에서이 연산자는 &lt;code&gt;take&lt;/code&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9c04fd97bf99939674e16f0e2e06fb85b1f5316" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;takeUntil&lt;/code&gt;. Note that the second Observable can cause &lt;code&gt;takeUntil&lt;/code&gt; to quit emitting items either by emitting an item or by issuing an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">RxJava에서이 연산자는 &lt;code&gt;takeUntil&lt;/code&gt; 으로 구현됩니다 . 두 번째 Observable은 항목을 &lt;code&gt;takeUntil&lt;/code&gt; 거나 &lt;code&gt;onError&lt;/code&gt; 또는 &lt;code&gt;onCompleted&lt;/code&gt; 알림 을 발행하여 takeUntil 이 항목 방출을 종료하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cafebc8da2c395e45b748adaf4d16e424147df6" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module.</source>
          <target state="translated">RxJava에서이 연산자는 ReactiveX 코어에 없지만 고유 한 &lt;code&gt;rxjava-math&lt;/code&gt; 모듈의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="aa451d401756cfb43e0af09e28153a9dcf363ef1" translate="yes" xml:space="preserve">
          <source>In RxJs the &lt;code&gt;replay&lt;/code&gt; operator takes four optional parameters and returns an ordinary Observable:</source>
          <target state="translated">RxJ에서 &lt;code&gt;replay&lt;/code&gt; 연산자는 네 가지 선택적 매개 변수를 사용하여 일반 Observable을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5f6338e063dd1fe484cfc1e5f6bdc92e7874c61" translate="yes" xml:space="preserve">
          <source>In RxKotlin there are several variants of Buffer:</source>
          <target state="translated">RxKotlin에는 몇 가지 Buffer 변형이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="09f9d22e6333dc41077c541c793d2b34999696d3" translate="yes" xml:space="preserve">
          <source>In RxPY &lt;code&gt;concat&lt;/code&gt; takes a variable number of Observables as parameters (or an array of Observables), and concatenates them in the order they appear in the parameter list (or array).</source>
          <target state="translated">RxPY에서 &lt;code&gt;concat&lt;/code&gt; 은 가변 개수의 Observable을 매개 변수 (또는 Observables의 배열)로 취하여 매개 변수 목록 (또는 배열)에 나타나는 순서대로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="e73aa488412dc01ff1bb9df22470c5c2d99a3e49" translate="yes" xml:space="preserve">
          <source>In RxPY you have the option to pass &lt;code&gt;count&lt;/code&gt; a predicate that takes an item emitted by the source Observable as a parameter. If you do so, &lt;code&gt;count&lt;/code&gt; will emit a count only of those items from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;. Otherwise, it will emit a count of all items emitted by the source Observable.</source>
          <target state="translated">RxPY 에는 소스 Observable이 생성 한 항목을 매개 변수로 취하는 술어를 &lt;code&gt;count&lt;/code&gt; 하는 옵션이 있습니다. 그렇게하면 &lt;code&gt;count&lt;/code&gt; 는 술어가 &lt;code&gt;true&lt;/code&gt; 로 평가하는 소스 Observable에서 해당 항목의 수만 방출 합니다 . 그렇지 않으면 소스 Observable이 방출 한 모든 항목의 수를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="0b529c9a0dc4b531af4b60f80f6f0cf3876ca4b7" translate="yes" xml:space="preserve">
          <source>In RxScala the operator &lt;code&gt;count&lt;/code&gt; counts the number of items in the source Observable that satisfy a specified predicate. That predicate accepts an emitted item as a parameter and returns a Boolean. &lt;code&gt;count&lt;/code&gt; will emit a count of all items for which this predicate returned &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">RxScala에서 연산자 &lt;code&gt;count&lt;/code&gt; 는 지정된 조건 자를 만족하는 소스 Observable의 항목 수를 계산합니다. 이 술어는 방출 된 항목을 매개 변수로 승인하고 부울을 리턴합니다. &lt;code&gt;count&lt;/code&gt; 는이 술어가 &lt;code&gt;true&lt;/code&gt; 를 리턴 한 모든 항목의 수 를 방출 합니다 .</target>
        </trans-unit>
        <trans-unit id="16ec499010df4b2455c2dfd317e76e966b3946e5" translate="yes" xml:space="preserve">
          <source>In Swift, this is implemented using the &lt;code&gt;Observable.from&lt;/code&gt; class method.</source>
          <target state="translated">Swift에서 이것은 &lt;code&gt;Observable.from&lt;/code&gt; 클래스 메소드를 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="138a5f790b58f03a816d8788ec73857af8ed119a" translate="yes" xml:space="preserve">
          <source>In Swift, this is implemented using the &lt;code&gt;Observable.just&lt;/code&gt; class method.</source>
          <target state="translated">Swift에서 이것은 &lt;code&gt;Observable.just&lt;/code&gt; 클래스 메소드를 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e45263cc87b0ac4023f88773e7a4a3cd1488684" translate="yes" xml:space="preserve">
          <source>In addition, in the &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, you have available to you the following operators that convert actions, callables, functions, and runnables into Observables that emit the results of those things:</source>
          <target state="translated">또한 &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; 패키지에서 조치, 호출 가능, 함수 및 실행 가능 항목을 결과를내는 Observables로 변환하는 다음 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c705eb2803752c9ee28584efe3fc60abb165fff0" translate="yes" xml:space="preserve">
          <source>In an ordinary method call &amp;mdash; that is, &lt;em&gt;not&lt;/em&gt; the sort of asynchronous, parallel calls typical in ReactiveX &amp;mdash; the flow is something like this:</source>
          <target state="translated">ReactiveX에서 일반적인 비동기식 병렬 호출이 &lt;em&gt;아닌&lt;/em&gt; 일반적인 메소드 호출 에서 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70afa1a17dffe1d75fa8ae4871f89baf7ba04903" translate="yes" xml:space="preserve">
          <source>In general, notify subscribers of error conditions immediately, rather than making an effort to emit more items first.</source>
          <target state="translated">일반적으로 더 많은 항목을 먼저 내보내려고하기보다는 가입자에게 오류 조건을 즉시 알리십시오.</target>
        </trans-unit>
        <trans-unit id="b51d0ee6ef32193720cf5577081be13382e0461c" translate="yes" xml:space="preserve">
          <source>In many ReactiveX implementations there is a second operator, MergeDelayError, that changes this behavior &amp;mdash; reserving &lt;code&gt;onError&lt;/code&gt; notifications until all of the merged Observables complete and only then passing it along to the observers:</source>
          <target state="translated">많은 ReactiveX 구현에는이 동작을 변경하는 두 번째 연산자 인 MergeDelayError 가 있습니다. 병합 된 모든 Observable이 완료 될 때까지 &lt;code&gt;onError&lt;/code&gt; 알림을 예약 한 다음 관찰자에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="df1c152b88bf70837256cdf207124847c96b400f" translate="yes" xml:space="preserve">
          <source>In many software programming tasks, you more or less expect that the instructions you write will execute and complete incrementally, one-at-a-time, in order as you have written them. But in ReactiveX, many instructions may execute in parallel and their results are later captured, in arbitrary order, by &amp;ldquo;observers.&amp;rdquo; Rather than &lt;em&gt;calling&lt;/em&gt; a method, you define a mechanism for retrieving and transforming the data, in the form of an &amp;ldquo;Observable,&amp;rdquo; and then &lt;em&gt;subscribe&lt;/em&gt; an observer to it, at which point the previously-defined mechanism fires into action with the observer standing sentry to capture and respond to its emissions whenever they are ready.</source>
          <target state="translated">많은 소프트웨어 프로그래밍 작업에서, 작성하는 명령이 사용자가 작성한 순서대로 한 번에 하나씩 증분 실행되고 완료 될 것으로 기대합니다. 그러나 ReactiveX에서는 많은 명령이 병렬로 실행될 수 있으며 그 결과는 나중에 &quot;관찰자&quot;에 의해 임의의 순서로 캡처됩니다. 메소드를 &lt;em&gt;호출&lt;/em&gt; 하는 대신 , &quot;Observable&quot;형식으로 데이터를 검색하고 변환하기위한 메커니즘을 정의한 다음 옵저버를 &lt;em&gt;구독하십시오&lt;/em&gt; .이 시점에서 이전에 정의 된 메커니즘이 옵저버 스탠딩 센트리와 함께 작동합니다. 준비가 될 때마다 배출물을 포착하고 이에 대응합니다.</target>
        </trans-unit>
        <trans-unit id="af1cde5def7e314848c7b5ea89de136a83b3d54d" translate="yes" xml:space="preserve">
          <source>In other documents and other contexts, what we are calling an &amp;ldquo;observer&amp;rdquo; is sometimes called a &amp;ldquo;subscriber,&amp;rdquo; &amp;ldquo;watcher,&amp;rdquo; or &amp;ldquo;reactor.&amp;rdquo; This model in general is often referred to as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&amp;ldquo;reactor pattern&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">다른 문서 및 기타 상황에서 우리가 &quot;관찰자&quot;라고 부르는 것을 때때로 &quot;구독자&quot;, &quot;감시자&quot;또는 &quot;반응기&quot;라고합니다. 이 모델은 일반적으로 종종 &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&quot;리액터 패턴&quot;이라고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0a661195d6805be9c148ca5aaa5480f83dbbbe3f" translate="yes" xml:space="preserve">
          <source>In other documents and other contexts, what we are calling an &amp;ldquo;observer&amp;rdquo; is sometimes called a &amp;ldquo;subscriber,&amp;rdquo; &amp;ldquo;watcher,&amp;rdquo; or &amp;ldquo;reactor.&amp;rdquo; This model in general is often referred to as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&amp;ldquo;reactor pattern&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c110d63fdae361275771c2c4e8b7c4bd49374d1" translate="yes" xml:space="preserve">
          <source>In several of the language-specific implementations there is also an operator that does &lt;em&gt;not&lt;/em&gt; interleave the emissions from the transformed Observables, but instead emits these emissions in strict order, often called ConcatMap or something similar.</source>
          <target state="translated">일부 언어 별 구현에는 변환 된 Observable에서 방출을 인터리브 하지 &lt;em&gt;않고&lt;/em&gt; 종종 ConcatMap 또는 이와 유사한 것으로 불리는 엄격한 순서로 이러한 방출을 방출 하는 연산자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93bfb63abe1513baa690460365bb2e32de9329bf" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations there is also a ConcatMap operator (a.k.a. &lt;code&gt;concat_all&lt;/code&gt;, &lt;code&gt;concat_map&lt;/code&gt;, &lt;code&gt;concatMapObserver&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;forIn&lt;/code&gt;/&lt;code&gt;for_in&lt;/code&gt;, &lt;code&gt;mapcat&lt;/code&gt;, &lt;code&gt;selectConcat&lt;/code&gt;, or &lt;code&gt;selectConcatObserver&lt;/code&gt;) that transforms the items emitted by a source Observable into corresponding Observables and then concatenates the items emitted by each of these Observables in the order in which they are observed and transformed.</source>
          <target state="translated">일부 ReactiveX 구현에는 ConcatMap 연산자 (일명 &lt;code&gt;concat_all&lt;/code&gt; , &lt;code&gt;concat_map&lt;/code&gt; , &lt;code&gt;concatMapObserver&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;forIn&lt;/code&gt; / &lt;code&gt;for_in&lt;/code&gt; , &lt;code&gt;mapcat&lt;/code&gt; , &lt;code&gt;selectConcat&lt;/code&gt; 또는 &lt;code&gt;selectConcatObserver&lt;/code&gt; )가 있으며, 이는 소스 Observable에서 방출 된 항목을 해당 Observables로 변환 한 다음 방출되는 항목을 연결합니다. 이 Observable 각각은 관찰 및 변환되는 순서대로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="49d6b73f37ee57d71fdff6d16884e54ade3b0ef5" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, there is a specialized observer interface, &lt;code&gt;Subscriber&lt;/code&gt;, that implements an &lt;code&gt;unsubscribe&lt;/code&gt; method. You can call this method to indicate that the Subscriber is no longer interested in any of the Observables it is currently subscribed to. Those Observables can then (if they have no other interested observers) choose to stop generating new items to emit.</source>
          <target state="translated">일부 ReactiveX 구현에는 &lt;code&gt;unsubscribe&lt;/code&gt; 메소드 를 구현하는 특수 옵저버 인터페이스 인 &lt;code&gt;Subscriber&lt;/code&gt; 가 있습니다. 이 메소드를 호출하여 구독자가 더 이상 현재 구독중인 Observable에 관심이 없음을 표시 할 수 있습니다. 그러면 Observable은 (관심있는 관찰자가없는 경우) 방출 할 새 항목 생성을 중지하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2949e25812bc031cf61fa47668bcad6970f74f74" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, there is an operator called something like &amp;ldquo;OnErrorResumeNext&amp;rdquo; that behaves like a Catch variant: specifically reacting to an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. In others, there is an operator with that name that behaves more like a Concat variant: performing the concatenation operation regardless of whether the source Observable terminates normally or with an error. This is unfortunate and confusing, but something we have to live with.</source>
          <target state="translated">일부 ReactiveX 구현에는 Catch 변형처럼 동작하는 &quot;OnErrorResumeNext&quot;와 같은 연산자가 있습니다. 특히 소스 Observable 의 &lt;code&gt;onError&lt;/code&gt; 알림에 반응합니다 . 다른 경우에는 해당 이름을 가진 연산자가 Concat 변형과 유사하게 작동합니다. 소스 Observable이 정상적으로 종료되는지 오류인지에 관계없이 연결 작업을 수행합니다. 이것은 불행하고 혼란 스럽지만 우리가 살아야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="feb01da6c51b0285d3263e371d3483d2cae53174" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, your operator may need to be sensitive to that implementation&amp;rsquo;s &amp;ldquo;backpressure&amp;rdquo; strategies. (See, for example: &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Pitfalls of Operator Implementations (part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.)</source>
          <target state="translated">일부 ReactiveX 구현에서 운영자는 해당 구현의 &quot;배압&quot;전략에 민감해야 할 수도 있습니다. (예 : D&amp;aacute;vid Karnok &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;의 운영자 구현의 함정 (2 부&lt;/a&gt; ) 참조)</target>
        </trans-unit>
        <trans-unit id="d86788d80735e9747737d806466553a36e139407" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, your operator may need to be sensitive to that implementation&amp;rsquo;s &amp;ldquo;backpressure&amp;rdquo; strategies. (See, for example: &lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Pitfalls of Operator Implementations (part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d968bca48f34a1b9d629e8c8e5bc7f1f9e7409" translate="yes" xml:space="preserve">
          <source>In some circumstances, waiting until the last minute (that is, until subscription time) to generate the Observable can ensure that this Observable contains the freshest data.</source>
          <target state="translated">경우에 따라 Observable을 생성하기 위해 마지막 순간까지 (즉, 구독 시간까지) 기다리는 경우이 Observable에 최신 데이터가 포함되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d97597b94f7d0965b9edaef42c16ac57210f4bf" translate="yes" xml:space="preserve">
          <source>In some implementations of ReactiveX, there is also an operator that converts an Observable into a &amp;ldquo;Blocking&amp;rdquo; Observable. A Blocking Observable extends the ordinary Observable by providing a set of methods, operating on the items emitted by the Observable, that block. Some of the To operators are in this Blocking Observable set of extended operations.</source>
          <target state="translated">ReactiveX의 일부 구현에는 Observable을 &quot;Blocking&quot;Observable로 변환하는 연산자도 있습니다. 블로킹 옵저버 블은 옵저버 블이 방출 한 항목에 대해 작동하는 일련의 방법을 제공하여 일반 옵저버 블을 확장합니다. 일부 To 연산자는이 Blocking Observable 확장 작업 세트에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8063bc63842afdac26b9e318a09b125cd96bc99" translate="yes" xml:space="preserve">
          <source>In some implementations of ReactiveX, there is also something called a &amp;ldquo;Connectable&amp;rdquo; Observable. Such an Observable does not begin emitting items until its &lt;a href=&quot;operators/connect&quot;&gt;Connect&lt;/a&gt; method is called, whether or not any observers have subscribed to it.</source>
          <target state="translated">ReactiveX의 일부 구현에는 &quot;Connectable&quot;Observable이라는 것도 있습니다. 이러한 Observable은 옵저버가 구독했는지 여부에 관계없이 &lt;a href=&quot;operators/connect&quot;&gt;Connect&lt;/a&gt; 메서드가 호출 될 때까지 항목을 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="037dec5a983c9517e8c8c6b9e8942bbe78e32581" translate="yes" xml:space="preserve">
          <source>In some implementations there are variants that allow you to adjust the criteria by which two items are considered &amp;ldquo;distinct.&amp;rdquo; In some, there is a variant of the operator that only compares an item against its immediate predecessor for distinctness, thereby filtering only &lt;em&gt;consecutive&lt;/em&gt; duplicate items from the sequence.</source>
          <target state="translated">일부 구현에는 두 항목이 &quot;고유 한&quot;것으로 간주되는 기준을 조정할 수있는 변형이 있습니다. 일부 항목에는 항목의 직계 선행 항목과의 구별 만 비교하여 항목에서 &lt;em&gt;연속적인&lt;/em&gt; 중복 항목 만 필터링하는 연산자의 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd136608bd7e489e77433f289366dd451d69a68" translate="yes" xml:space="preserve">
          <source>In some implementations there is also a Single operator. It behaves similarly to First except that it waits until the source Observable terminates in order to guarantee that it only emits a single item (otherwise, rather than emitting that item, it terminates with an error). You can use this to not only take the first item from the source Observable but to also guarantee that there was only one item.</source>
          <target state="translated">일부 구현에는 단일 연산자도 있습니다. 소스 Observable이 종료 될 때까지 기다렸다는 점을 제외하고는 First와 유사하게 작동합니다 (단, 해당 항목을 내 보내지 않고 오류로 종료 함). 이를 사용하여 소스 Observable에서 첫 번째 항목을 가져올뿐만 아니라 하나의 항목 만 있음을 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0dc45fcc76d537e1792d8725c9220fda83cacf" translate="yes" xml:space="preserve">
          <source>In some implementations there is also an UnsubscribeOn operator.</source>
          <target state="translated">일부 구현에는 UnsubscribeOn 연산자도 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e47960cd978595f0079e3a0166c1245438c4c9" translate="yes" xml:space="preserve">
          <source>In some implementations, &lt;code&gt;First&lt;/code&gt; is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item at such time as the source Observable emits that item. In those implementations, if you instead want a filtering operator, you may have better luck with &lt;a href=&quot;take&quot;&gt;&lt;code&gt;Take(1)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;elementat&quot;&gt;&lt;code&gt;ElementAt(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 구현에서, &lt;code&gt;First&lt;/code&gt; 는 Observable을 반환하는 필터링 연산자로 구현되지 않지만 소스 Observable이 해당 항목을 방출 할 때 특정 항목을 반환하는 차단 함수로 구현됩니다. 이러한 구현에서 대신 필터링 연산자를 원하면 &lt;a href=&quot;take&quot;&gt; &lt;code&gt;Take(1)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;elementat&quot;&gt; &lt;code&gt;ElementAt(0)&lt;/code&gt; &lt;/a&gt; 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4334a2a1ddeb5e11e72e20d2fc45eef1bd9c0c63" translate="yes" xml:space="preserve">
          <source>In some implementations, &lt;code&gt;Last&lt;/code&gt; is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item when the source Observable terminates. In those implementations, if you instead want a filtering operator, you may have better luck with &lt;a href=&quot;take&quot;&gt;&lt;code&gt;TakeLast(1)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 구현에서 &lt;code&gt;Last&lt;/code&gt; 는 Observable을 반환하는 필터링 연산자로 구현되지 않지만 소스 Observable이 종료 될 때 특정 항목을 반환하는 차단 함수로 구현됩니다. 이러한 구현에서 대신 필터링 연산자를 &lt;a href=&quot;take&quot;&gt; &lt;code&gt;TakeLast(1)&lt;/code&gt; &lt;/a&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6a21a2695ee7461574576b39692f2c5743113615" translate="yes" xml:space="preserve">
          <source>In some implementations, there is also a ThrottleFirst operator that is similar, but emits not the most-recently emitted item in the sample period, but the &lt;em&gt;first&lt;/em&gt; item that was emitted during that period.</source>
          <target state="translated">일부 구현에서, 비슷한 ThrottleFirst 연산자가 있지만 샘플 기간에서 가장 최근에 방출 된 항목이 아니라 해당 기간 동안 가장 &lt;em&gt;먼저&lt;/em&gt; 방출 된 항목이 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="a6343b30db7af9b5aa728419488dd86296f2eea2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxGroovy core there is also a specialty mapping operator, &lt;code&gt;encode&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.</source>
          <target state="translated">에서 &lt;code&gt;StringObservable&lt;/code&gt; RxGroovy 코어의 일부가 아닌 클래스도 전문 맵핑 연산자가 &lt;code&gt;encode&lt;/code&gt; , 그 변환 피 감시 감시 오브젝트로 방출한다 문자열을 방출이 바이트 배열한다는 것을 그 원래의 문자열의 멀티 바이트 문자에 대하여 문자 경계.</target>
        </trans-unit>
        <trans-unit id="978e2cb0f06af222730ceae268a71aa2cf8778d0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxJava core there is also a specialty mapping operator, &lt;code&gt;encode&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.</source>
          <target state="translated">에서 &lt;code&gt;StringObservable&lt;/code&gt; RxJava 코어의 일부가 아닌 클래스도 전문 맵핑 연산자가 &lt;code&gt;encode&lt;/code&gt; , 피 감시하는 변환이 피 감시에 방출한다 문자열이 배열 바이트를 방출하는 원래의 문자열의 멀티 바이트 문자에 대하여 문자 경계.</target>
        </trans-unit>
        <trans-unit id="2c205481240cf9f67657691f8018f19dd3c8c2fa" translate="yes" xml:space="preserve">
          <source>In the above code, the source Observable emits the sequence &lt;code&gt;{ 1 2 3 4 5 }&lt;/code&gt;. When it emits the first item in this sequence, the &lt;code&gt;groupBy&lt;/code&gt; operator creates and emits a &lt;code&gt;GroupedObservable&lt;/code&gt; with the key of &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;flatMap&lt;/code&gt; operator applies the &lt;code&gt;take(1)&lt;/code&gt; operator to that &lt;code&gt;GroupedObservable&lt;/code&gt;, which gives it the item (&lt;code&gt;1&lt;/code&gt;) that it emits and that also unsubscribes from the &lt;code&gt;GroupedObservable&lt;/code&gt;, which is terminated. When the source Observable emits the second item in its sequence, the &lt;code&gt;groupBy&lt;/code&gt; operator creates and emits a &lt;em&gt;second&lt;/em&gt;&lt;code&gt;GroupedObservable&lt;/code&gt; with the same key (&lt;code&gt;0&lt;/code&gt;) to replace the one that was terminated. &lt;code&gt;flatMap&lt;/code&gt; again applies &lt;code&gt;take(1)&lt;/code&gt; to this new &lt;code&gt;GroupedObservable&lt;/code&gt; to retrieve the new item to emit (&lt;code&gt;2&lt;/code&gt;) and to unsubscribe from and terminate the &lt;code&gt;GroupedObservable&lt;/code&gt;, and this process repeats for the remaining items in the source sequence.</source>
          <target state="translated">위의 코드에서 소스 Observable은 &lt;code&gt;{ 1 2 3 4 5 }&lt;/code&gt; 시퀀스를 생성 합니다. 이 순서에서 첫 번째 항목을 내 &lt;code&gt;groupBy&lt;/code&gt; 연산자 는 &lt;code&gt;0&lt;/code&gt; 키를 사용하여 &lt;code&gt;GroupedObservable&lt;/code&gt; 을 만들고 방출합니다 . &lt;code&gt;flatMap&lt;/code&gt; 의 운영자가 적용되는 &lt;code&gt;take(1)&lt;/code&gt; 것과 연산자 &lt;code&gt;GroupedObservable&lt;/code&gt; 그것을 항목 (부여 &lt;code&gt;1&lt;/code&gt; 가 방출하고 또한로부터 구독이 취소 있음) &lt;code&gt;GroupedObservable&lt;/code&gt; 종료된다. 소스 Observable이 순서대로 두 번째 항목을 방출하면 &lt;code&gt;groupBy&lt;/code&gt; 연산자 는 동일한 키를 사용하여 &lt;em&gt;두 번째 &lt;/em&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; 을 생성하고 방출합니다 (&lt;em&gt;&lt;/em&gt; &lt;code&gt;0&lt;/code&gt; ) 종료 된 것을 대체합니다. &lt;code&gt;flatMap&lt;/code&gt; 가 다시 적용되는 &lt;code&gt;take(1)&lt;/code&gt; 이 새로 &lt;code&gt;GroupedObservable&lt;/code&gt; 가 발광 (에 새로운 아이템을 검색하기 위해 &lt;code&gt;2&lt;/code&gt; )로부터 취소하고 종료 &lt;code&gt;GroupedObservable&lt;/code&gt; 을 하고 소스 시퀀스의 나머지 항목에 대해이 과정을 반복.</target>
        </trans-unit>
        <trans-unit id="3a01097bd263f962d72c9a363627040454cd407d" translate="yes" xml:space="preserve">
          <source>In the asynchronous model the flow goes more like this:</source>
          <target state="translated">비동기 모델에서 흐름은 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="9b52ecbc0dd6f70ce33a2a266322bee10c5b7034" translate="yes" xml:space="preserve">
          <source>In the case of Action, the process is similar, but there is no return value. In this case, the Observable created by this operator will emit a &lt;code&gt;null&lt;/code&gt; before terminating.</source>
          <target state="translated">Action의 경우 프로세스는 비슷하지만 반환 값이 없습니다. 이 경우이 연산자로 작성된 Observable은 종료하기 전에 &lt;code&gt;null&lt;/code&gt; 을 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="6fae0c623313d6102a6c3767b510998af08ec342" translate="yes" xml:space="preserve">
          <source>In the case of a Future, it will emit the single result of the &lt;code&gt;get&lt;/code&gt; call. You may optionally pass the version of &lt;code&gt;from&lt;/code&gt; that accepts a future two additional parameters indicating a timeout span and the units of time that span is denominated in. The resulting Observable will terminate with an error if that span of time passes before the Future responds with a value.</source>
          <target state="translated">Future의 경우 &lt;code&gt;get&lt;/code&gt; call 의 단일 결과를 내 보냅니다 . 선택적 으로 이후의 시간 초과 범위와 범위가 표시되는 시간 단위를 나타내는 두 개의 추가 매개 변수를 허용하는 &lt;code&gt;from&lt;/code&gt; 버전을 전달할 수 있습니다 . 미래가 응답하기 전에 해당 시간 범위가 경과하면 결과 Observable은 오류와 함께 종료됩니다. 값.</target>
        </trans-unit>
        <trans-unit id="f0dcc4a6d4282af18fc9e92a4494b472d3679b88" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;join&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.</source>
          <target state="translated">고유 한 &lt;code&gt;StringObservable&lt;/code&gt; 클래스 (기본적으로 RxGroovy의 일부가 아님)에는 문자열 시퀀스를 방출하는 Observable을 Observable로 변환하여 각 문자열의 연결을 나타내는 단일 문자열을 방출하는 Observable로 변환하는 &lt;code&gt;join&lt;/code&gt; 연산자 도 있습니다 ( 문자열로 구분됨) 당신의 선택의.</target>
        </trans-unit>
        <trans-unit id="0af1cd94fd507d9f3d910ef5d0527af5287336a9" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;split&lt;/code&gt; operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.</source>
          <target state="translated">고유 한 &lt;code&gt;StringObservable&lt;/code&gt; 클래스 (기본적으로 RxGroovy의 일부는 아님)에는 Observable of Strings를 소스 시퀀스를 스트림으로 취급하고 지정된 정규식 경계로 분할하는 Observable of Strings로 변환하는 &lt;code&gt;split&lt;/code&gt; 연산자 도 있습니다 . 이 분할의 결과.</target>
        </trans-unit>
        <trans-unit id="eb5fda7ff19786c8da468ff346658e01540bcd69" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;stringConcat&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.</source>
          <target state="translated">고유 한 &lt;code&gt;StringObservable&lt;/code&gt; 클래스 (기본적으로 RxGroovy의 일부는 아님)에는 문자열 시퀀스를 방출하는 Observable을 Observable로 변환하여 모두 연결을 나타내는 단일 문자열을 방출하는 &lt;code&gt;stringConcat&lt;/code&gt; 연산자 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7212957ad6271a30e781217f05729777cde9078" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;join&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.</source>
          <target state="translated">고유 한 &lt;code&gt;StringObservable&lt;/code&gt; 클래스 (기본적으로 RxJava의 일부는 아님)에는 문자열 시퀀스를 생성하는 Observable을 Observable로 변환하는 &lt;code&gt;join&lt;/code&gt; 연산자 도 있습니다. 이는 문자열로 구분 된 각 문자열의 연결을 나타내는 단일 문자열을 생성하는 Observable로 변환됩니다. 당신의 선택의.</target>
        </trans-unit>
        <trans-unit id="dbcfee3dbda596d98d950905c64f0d80750c8c34" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;split&lt;/code&gt; operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.</source>
          <target state="translated">고유 한 &lt;code&gt;StringObservable&lt;/code&gt; 클래스 (기본적으로 RxJava의 일부는 아님)에는 Observable of Strings를 소스 시퀀스를 스트림으로 취급하고 지정된 정규식 경계로 분할하는 Observable of Strings로 변환하는 &lt;code&gt;split&lt;/code&gt; 연산자 도 있습니다 . 이 분할의 결과.</target>
        </trans-unit>
        <trans-unit id="80fab375b638934674bb3b50669b96064b97edfb" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;stringConcat&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.</source>
          <target state="translated">고유 한 &lt;code&gt;StringObservable&lt;/code&gt; 클래스 (기본적으로 RxJava의 일부는 아님)에는 문자열 시퀀스를 방출하는 Observable을 Observable로 변환하여 Observable로 변환하는 &lt;code&gt;stringConcat&lt;/code&gt; 연산자 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4360fc13798a2ced2520c5e5f6f7e632c555c696" translate="yes" xml:space="preserve">
          <source>In the separate &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, which is not included by default with RxGroovy, there is also a &lt;code&gt;runAsync&lt;/code&gt; function. Pass &lt;code&gt;runAsync&lt;/code&gt; an &lt;code&gt;Action&lt;/code&gt; and a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;, and it will return a &lt;code&gt;StoppableObservable&lt;/code&gt; that uses the specified &lt;code&gt;Action&lt;/code&gt; to generate items that it emits.</source>
          <target state="translated">&lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; 에 기본적으로 포함되어 있지 않은 별도의 RxJavaAsyncUtil 패키지에는 &lt;code&gt;runAsync&lt;/code&gt; 함수도 있습니다. 패스 &lt;code&gt;runAsync&lt;/code&gt; &lt;code&gt;Action&lt;/code&gt; 과 &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; , 그리고 그것은 반환 &lt;code&gt;StoppableObservable&lt;/code&gt; 지정된 사용 &lt;code&gt;Action&lt;/code&gt; 가 방출한다는 항목을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85226d29791a941dfdc4a830caf1c1b4e7fa5b2f" translate="yes" xml:space="preserve">
          <source>In the separate &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, which is not included by default with RxJava, there is also a &lt;code&gt;runAsync&lt;/code&gt; function. Pass &lt;code&gt;runAsync&lt;/code&gt; an &lt;code&gt;Action&lt;/code&gt; and a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;, and it will return a &lt;code&gt;StoppableObservable&lt;/code&gt; that uses the specified &lt;code&gt;Action&lt;/code&gt; to generate items that it emits.</source>
          <target state="translated">&lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; 에 기본적으로 포함되어 있지 않은 별도의 RxJavaAsyncUtil 패키지에는 &lt;code&gt;runAsync&lt;/code&gt; 함수도 있습니다. 패스 &lt;code&gt;runAsync&lt;/code&gt; &lt;code&gt;Action&lt;/code&gt; 과 &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; , 그리고 그것은 반환 &lt;code&gt;StoppableObservable&lt;/code&gt; 지정된 사용 &lt;code&gt;Action&lt;/code&gt; 가 방출한다는 항목을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c13cd89c3c45da83ad846b47b1bedfc77c6fafa" translate="yes" xml:space="preserve">
          <source>In this way you can include a &lt;code&gt;Future&lt;/code&gt; that returns an Observable in a cascade of Observables as a peer to other Observables.</source>
          <target state="translated">이러한 방식으로 , Observable의 캐스케이드에서 Observable을 다른 Observable의 피어로 반환하는 &lt;code&gt;Future&lt;/code&gt; 를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4249028943582ec355115c174d01896c5b993590" translate="yes" xml:space="preserve">
          <source>In this way, each item emitted by the resulting Observable is a function of the corresponding item in the source Observable and all of the items emitted by the source Observable after it.</source>
          <target state="translated">이러한 방식으로 결과 Observable이 생성 한 각 항목은 소스 Observable의 해당 항목과 그 이후에 소스 Observable이 생성 한 모든 항목의 기능입니다.</target>
        </trans-unit>
        <trans-unit id="72cba1d7a40bef7433b1f435b701d906c44bcbac" translate="yes" xml:space="preserve">
          <source>Instead of passing multiple Observables (up to nine) into &lt;code&gt;merge&lt;/code&gt;, you could also pass in a &lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt; (or other Iterable) of Observables, an Array of Observables, or even an Observable that emits Observables, and &lt;code&gt;merge&lt;/code&gt; will merge their output into the output of a single Observable:</source>
          <target state="translated">여러 Observables (최대 9 개)를 &lt;code&gt;merge&lt;/code&gt; 에 전달하는 대신, Observables 의 &lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt; (또는 다른 Iterable), Observables 배열 또는 Observable을 방출하는 Observable을 전달할 수 있으며 &lt;code&gt;merge&lt;/code&gt; 은 출력을 병합합니다. 단일 Observable의 출력 :</target>
        </trans-unit>
        <trans-unit id="011efcd591019b5969a332a24dff728a8107dbe2" translate="yes" xml:space="preserve">
          <source>Interval</source>
          <target state="translated">Interval</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="21bcc15c6b9dfe99deeeef31607f80ad9a914de1" translate="yes" xml:space="preserve">
          <source>Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence. This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline. When using do, it is important to note that the Observer may receive additional events after a stream has completed or errored (such as when using a repeat or resubscribing). If you are using an Observable that extends the AbstractObservable, you will not receive these events. For this special case, use the DoObserver. doOnNext, doOnError, and doOnCompleted uses the DoObserver internally and will receive these additional events.</source>
          <target state="translated">관찰 가능 시퀀스의 각 요소에 대한 동작을 호출하고 관찰 가능 시퀀스의 정상적이거나 예외적 인 종료시 동작을 호출합니다. 이 방법은 메시지 스트림을 가로 채서 파이프 라인에서 메시지에 대한 임의의 조치를 실행함으로써 쿼리 동작의 디버깅, 로깅 등을 위해 사용될 수 있습니다. do를 사용할 때, Observer는 스트림이 완료되거나 오류가 발생한 후 (예 : 반복 또는 재 구독을 사용하는 경우) 추가 이벤트를 수신 할 수 있습니다. AbstractObservable을 확장하는 Observable을 사용하는 경우 이러한 이벤트가 수신되지 않습니다. 이 특별한 경우에는 DoObserver를 사용하십시오. doOnNext, doOnError 및 doOnCompleted는 DoObserver를 내부적으로 사용하며 이러한 추가 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="7d0b0f09c8bd2482d8e9bdd538591ca34488ba8f" translate="yes" xml:space="preserve">
          <source>Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.</source>
          <target state="translated">지정된 스케줄러에서 지정된 함수를 비동기식으로 호출하고 관찰 가능한 시퀀스를 통해 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="002b9d3672a67b31dde384d5c82b77b20d5c5873" translate="yes" xml:space="preserve">
          <source>IsEmpty</source>
          <target state="translated">IsEmpty</target>
        </trans-unit>
        <trans-unit id="e9a2dbf8c765801c6abecc06d035b1c259eda973" translate="yes" xml:space="preserve">
          <source>It decides whether to resubscribe and remirror the source Observable by passing that Observable&amp;rsquo;s termination notifications (error or completed) to a notification handler as &lt;code&gt;void&lt;/code&gt; emissions. This notification handler acts as an Observable operator, taking an Observable that emits these &lt;code&gt;void&lt;/code&gt; notifications as input, and returning an Observable that emits &lt;code&gt;void&lt;/code&gt; items (meaning, resubscribe and mirror the source Observable) or terminates (meaning, terminate the sequence emitted by &lt;code&gt;repeatWhen&lt;/code&gt;).</source>
          <target state="translated">Observable의 종료 알림 (오류 또는 완료된)을 &lt;code&gt;void&lt;/code&gt; 처리기로 알림 처리기에 전달하여 소스 Observable을 다시 구독 및 리머 링할지 여부를 결정합니다 . 이 알림 핸들러는 Observable 연산자로 작동하여 이러한 &lt;code&gt;void&lt;/code&gt; 알림을 입력으로 방출하는 Observable을 가져 와서 &lt;code&gt;void&lt;/code&gt; 항목 을 방출하는 Observable을 리턴 (소스 Observable을 의미, 재 구독 및 미러링)하거나 종료 ( &lt;code&gt;repeatWhen&lt;/code&gt; 때 생성 된 시퀀스 종료 ) .</target>
        </trans-unit>
        <trans-unit id="b05b47ee27b95bf575e3effc01ae6ec08f9813b1" translate="yes" xml:space="preserve">
          <source>It does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">기본적으로 특정 &lt;a href=&quot;../scheduler&quot;&gt;스케줄러에서는&lt;/a&gt; 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2649f51f97bc1799c96a9e6cbbf8c69285c15c00" translate="yes" xml:space="preserve">
          <source>It does not have the variant that uses the emissions from a second Observable to regulate the sampling periodicity.</source>
          <target state="translated">샘플링주기를 조절하기 위해 두 번째 Observable의 방출을 사용하는 변형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="db3a19396735f14c2206b8954fc9b9b7c96aadb3" translate="yes" xml:space="preserve">
          <source>It extends &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the observer pattern&lt;/a&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</source>
          <target state="translated">데이터 및 / 또는 이벤트 시퀀스를 지원 &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;하도록 옵저버 패턴&lt;/a&gt; 을 확장 하고, 로우 레벨 스레딩, 동기화, 스레드 안전성, 동시 데이터 구조 및 비-레벨 스레딩과 같은 문제를 추상화하면서 시퀀스를 선언적으로 구성 할 수있는 연산자를 추가합니다. I / O 차단</target>
        </trans-unit>
        <trans-unit id="26cfd44aee2d1282f7da2850ed9a6868a5ea9b7a" translate="yes" xml:space="preserve">
          <source>It extends &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the observer pattern&lt;/a&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39092222be5c5128f83455e200a511d51d81a068" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a&gt; (or impossible, since latencies of each request vary at runtime). This &lt;a href=&quot;http://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;can be done&lt;/a&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;code&gt;Future.get()&lt;/code&gt;, which eliminates the benefit of asynchronous execution.</source>
          <target state="translated">&lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;선물을 사용하여 조건부 비동기 실행 흐름을 최적으로 구성하는&lt;/a&gt; 것은 어렵습니다 (또는 각 요청의 대기 시간은 런타임에 따라 다르므로 불가능합니다). 이 &lt;a href=&quot;http://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;수행 할 수 있습니다&lt;/a&gt; 물론,하지만 빠르게 복잡해진다 (따라서 오류가 발생하기 쉬운)에 또는 조기에 차단 &lt;code&gt;Future.get()&lt;/code&gt; 비동기 실행의 이익을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="891f0aee785e089e9cb621d4692d8eb9f94a2f80" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a&gt; (or impossible, since latencies of each request vary at runtime). This &lt;a href=&quot;https://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;can be done&lt;/a&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;code&gt;Future.get()&lt;/code&gt;, which eliminates the benefit of asynchronous execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f071bee56464f0e79be82a201585f9d5ef9e78d" translate="yes" xml:space="preserve">
          <source>It is a bad idea to use &lt;code&gt;reduce&lt;/code&gt; to collect emitted items into a mutable data structure. Instead, use &lt;code&gt;collect&lt;/code&gt; for that purpose.</source>
          <target state="translated">방출 된 항목을 변경 가능한 데이터 구조로 수집 하기 위해 &lt;code&gt;reduce&lt;/code&gt; 를 사용하는 것은 좋지 않습니다 . 대신, 그 목적으로 &lt;code&gt;collect&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="18385c80df1400f4f48ad03f26fe11b4b8b04677" translate="yes" xml:space="preserve">
          <source>It is good practice to check the observer&amp;rsquo;s &lt;code&gt;isUnsubscribed&lt;/code&gt; state from within the function you pass to &lt;code&gt;create&lt;/code&gt; so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; 한 함수 내에서 관찰자의 &lt;code&gt;isUnsubscribed&lt;/code&gt; 상태 를 확인하여 관심있는 관찰자가 더 이상 없을 때 Observable이 항목 방출 또는 값 비싼 계산을 중지 할 수 있도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f7151837303b01430de52221292363b8696a1db7" translate="yes" xml:space="preserve">
          <source>It is good practice to check the observer&amp;rsquo;s &lt;code&gt;isUnsubscribed&lt;/code&gt; state so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.</source>
          <target state="translated">관찰자가 &lt;code&gt;isUnsubscribed&lt;/code&gt; 상태 를 점검하여 관심있는 관찰자가 더 이상 없을 때 Observable이 항목 방출 또는 값 비싼 계산을 중지 할 수 있도록하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9807d8fc75f41fdce45545c5c2eab52b2cde18ce" translate="yes" xml:space="preserve">
          <source>It is possible for an Observable to invoke its observers&amp;rsquo; methods asynchronously, perhaps from different threads. This could make such an Observable violate &lt;a href=&quot;../contract&quot;&gt;the Observable contract&lt;/a&gt;, in that it might try to send an &lt;code&gt;OnCompleted&lt;/code&gt; or &lt;code&gt;OnError&lt;/code&gt; notification before one of its &lt;code&gt;OnNext&lt;/code&gt; notifications, or it might make an &lt;code&gt;OnNext&lt;/code&gt; notification from two different threads concurrently. You can force such an Observable to be well-behaved and synchronous by applying the Serialize operator to it.</source>
          <target state="translated">Observable이 다른 스레드에서 옵저버의 메소드를 비동기식으로 호출 할 수 있습니다. 이렇게 &lt;a href=&quot;../contract&quot;&gt;하면 해당 Observable&lt;/a&gt; 이 &lt;code&gt;OnNext&lt;/code&gt; 알림 중 하나 전에 &lt;code&gt;OnCompleted&lt;/code&gt; 또는 &lt;code&gt;OnError&lt;/code&gt; 알림 을 보내려고 시도 하거나 두 개의 다른 스레드에서 동시에 &lt;code&gt;OnNext&lt;/code&gt; 알림을 만들 수 있기 때문에 Observable 계약을 위반 하게 할 수 있습니다 . Serialize 연산자를 적용하여 이러한 Observable을 올바르게 작동하고 동 기적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eff2d2cefa3f5847f61455d90784355746d0b04" translate="yes" xml:space="preserve">
          <source>It is sometimes called &amp;ldquo;functional reactive programming&amp;rdquo; but this is a misnomer. ReactiveX may be functional, and it may be reactive, but &amp;ldquo;functional reactive programming&amp;rdquo; is a different animal. One main point of difference is that functional reactive programming operates on values that change &lt;em&gt;continuously&lt;/em&gt; over time, while ReactiveX operates on &lt;em&gt;discrete&lt;/em&gt; values that are emitted over time. (See &lt;a href=&quot;https://github.com/conal/essence-and-origins-of-frp&quot;&gt;Conal Elliott&amp;rsquo;s work for more-precise information on functional reactive programming&lt;/a&gt;.)</source>
          <target state="translated">&quot;기능적 리 액티브 프로그래밍&quot;이라고도하지만 이것은 잘못된 이름입니다. ReactiveX는 기능적 일 수도 있고 반응적일 수도 있지만&amp;ldquo;기능적 반응성 프로그래밍&amp;rdquo;은 다른 동물입니다. 차이점 중 하나는 기능적 반응성 프로그래밍 이 시간이 지남에 따라 &lt;em&gt;지속적으로&lt;/em&gt; 변하는 값에 대해 작동하는 반면 ReactiveX는 시간이 지남에 따라 방출되는 &lt;em&gt;개별&lt;/em&gt; 값에 대해 작동 한다는 것입니다. &lt;a href=&quot;https://github.com/conal/essence-and-origins-of-frp&quot;&gt;기능적 반응성 프로그래밍에 대한보다 정확한 정보는 Conal Elliott의 작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fdbf510bdf3d816e45ee8d48f0cc1228dc05a4a9" translate="yes" xml:space="preserve">
          <source>It is usually best that you compose new operators by combining existing ones, to the extent that this is possible, rather than reinventing the wheel. RxJava itself does this with some of its standard operators, for example:</source>
          <target state="translated">일반적으로 바퀴를 재발 명하기보다는 가능한 한 기존 연산자를 조합하여 새 연산자를 작성하는 것이 가장 좋습니다. RxJava 자체는 다음과 같은 표준 연산자로이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="89174431a1a966b8fb514184bda6c8efce66dfd4" translate="yes" xml:space="preserve">
          <source>It may call a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onNext( )&lt;/code&gt;&lt;/a&gt; method any number of times, but these calls must be non-overlapping.</source>
          <target state="translated">구독자의 &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onNext( )&lt;/code&gt; &lt;/a&gt; 메소드를 여러 번 호출 할 수 있지만 이러한 호출은 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f1823f48cd27350e850e10e37c5ce6fe62ec4444" translate="yes" xml:space="preserve">
          <source>It may call either a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onCompleted( )&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onError( )&lt;/code&gt;&lt;/a&gt; method, but not both, exactly once, and it may not subsequently call a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onNext( )&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">구독자의 &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onCompleted( )&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onError( )&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있지만 정확히 한 번만 호출 할 수는 없으며 구독자의 &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onNext( )&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2f070c7f11576ed486233e35474ddda41c4700b8" translate="yes" xml:space="preserve">
          <source>It requires one of the following distributions:</source>
          <target state="translated">다음 배포판 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ca33803823f2ece4ecb5834672e63305ef95cfe5" translate="yes" xml:space="preserve">
          <source>It requires one of the following packages:</source>
          <target state="translated">다음 패키지 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="94d3d61d261c2ecef4925faed7443e2f2b6b049b" translate="yes" xml:space="preserve">
          <source>It requires one of the following:</source>
          <target state="translated">다음 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="595e4e764020b5cf5ee3bcbb8f01313e97b8eb51" translate="yes" xml:space="preserve">
          <source>It will also emit this same final value to any subsequent observers. However, if the source Observable terminates with an error, the &lt;code&gt;AsyncSubject&lt;/code&gt; will not emit any items, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">또한 후속 관찰자에게 동일한 최종 값을 내 보냅니다. 그러나 소스 Observable이 오류와 함께 종료되면 &lt;code&gt;AsyncSubject&lt;/code&gt; 는 항목을 내 보내지 않지만 단순히 소스 Observable의 오류 알림을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="34f02c71d6fa00b4deeade3bfbabd8b4f0199f33" translate="yes" xml:space="preserve">
          <source>Iterable (pull)</source>
          <target state="translated">반복 가능 (풀)</target>
        </trans-unit>
        <trans-unit id="77c1c3007f7e0cc78d64781295922fced377fcae" translate="yes" xml:space="preserve">
          <source>Iterables, for example, can be thought of as a sort of synchronous Observable; Futures, as a sort of Observable that always emits only a single item. By explicitly converting such objects to Observables, you allow them to interact as peers with other Observables.</source>
          <target state="translated">예를 들어, 이터 러블은 일종의 동기식 Observable로 생각할 수 있습니다. 선물은 항상 하나의 항목 만 방출하는 일종의 Observable입니다. 이러한 객체를 Observables로 명시 적으로 변환하면 다른 Observable과 피어로 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4315de8eb96f9d5efab572bae1c956c26e04d48" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#all(io.reactivex.functions.Predicate)&quot;&gt;&lt;code&gt;all(Predicate)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#all(io.reactivex.functions.Predicate)&quot;&gt; &lt;code&gt;all(Predicate)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c2d2bb807348c5a5bb2c5970e7049467cbc2bc0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#amb(java.lang.Iterable)&quot;&gt;&lt;code&gt;amb(Iterable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#amb(java.lang.Iterable)&quot;&gt; &lt;code&gt;amb(Iterable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46d652bb88043ecd2f247b688bb25aba237a1670" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#ambWith(io.reactivex.ObservableSource)&quot;&gt;&lt;code&gt;ambWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#ambWith(io.reactivex.ObservableSource)&quot;&gt; &lt;code&gt;ambWith(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79801e93b31ea69def0891c5ca351103123a0395" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#empty()&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#empty()&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d612270b0b6dae224275e36de2f214e983b9162a" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.lang.Throwable)&quot;&gt;&lt;code&gt;error(Throwable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.lang.Throwable)&quot;&gt; &lt;code&gt;error(Throwable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="739b3189dd25d213d0efe5f2677878877c3bb018" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.util.concurrent.Callable)&quot;&gt;&lt;code&gt;error(Callable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.util.concurrent.Callable)&quot;&gt; &lt;code&gt;error(Callable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00d7842c837d4d62344821564ad93d023e2720cb" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#never()&quot;&gt;&lt;code&gt;never()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#never()&quot;&gt; &lt;code&gt;never()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8d8819c38a240885157cbd94598334402e3674d" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1)&quot;&gt;&lt;code&gt;all(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1)&quot;&gt; &lt;code&gt;all(Func1)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6e16a78f86bba91a61a8a39b0bee1639141b4a0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable)&quot;&gt;&lt;code&gt;amb(Iterable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable)&quot;&gt; &lt;code&gt;amb(Iterable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb914eb34da607efe1851c51fece981b8a5d93ad" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)&quot;&gt;&lt;code&gt;amb(Observable,Observable)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observable parameters)</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)&quot;&gt; &lt;code&gt;amb(Observable,Observable)&lt;/code&gt; &lt;/a&gt; (최대 9 개의 관찰 가능한 매개 변수를 사용하는 버전도 있음)</target>
        </trans-unit>
        <trans-unit id="6fa8dcea2523bcdb9be5374ff461051895601ef9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable)&quot;&gt;&lt;code&gt;ambWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable)&quot;&gt; &lt;code&gt;ambWith(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ac6f58e233b25dd5d275d2b6dbbeb82402fadfd" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)&quot;&gt;&lt;code&gt;buffer(int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)&quot;&gt; &lt;code&gt;buffer(int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f4da8ad769c45ae36504e5e4b7db9678f04beed" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)&quot;&gt;&lt;code&gt;buffer(int,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)&quot;&gt; &lt;code&gt;buffer(int,int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c3114cc9509b09ba21be9976417c1d41b12b542" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f079df920af6fbe33cc7438b0af7d1b861068b58" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7f01ab7dca8a888386fa5570d9f0b2e382b0f4a" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,int,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,int,Scheduler)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a169daeda654c4fee9bff30b2d8a9d0424179071" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,Scheduler)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b62647dc23afa8babf67cfbc877e420f4ebb819" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;buffer(long,long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;buffer(long,long,TimeUnit)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a877f462a5deb198dfc0204b93c36359d93eae06" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,long,TimeUnit,Scheduler)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="86d0c1c1c839634afc3f6c3c4a219ba201e6a4f2" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)&quot;&gt;&lt;code&gt;buffer(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)&quot;&gt; &lt;code&gt;buffer(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="507fd0d63c19e5259957c06f2c5e974b2361ac5e" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)&quot;&gt;&lt;code&gt;buffer(Observable,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)&quot;&gt; &lt;code&gt;buffer(Observable,int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19480f4a8a048d195247eca7c8ae389d06924f5d" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)&quot;&gt;&lt;code&gt;buffer(Observable,Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)&quot;&gt; &lt;code&gt;buffer(Observable,Func1)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24c5bc0bbf6f71e96eeb78bdbb7b8d2effc287b6" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)&quot;&gt;&lt;code&gt;buffer(Func0)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)&quot;&gt; &lt;code&gt;buffer(Func0)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4208c1d7ad4205ea40fa25a698af88ff2e762b45" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class)&quot;&gt;&lt;code&gt;cast(Class)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class)&quot;&gt; &lt;code&gt;cast(Class)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef3db7ed2c0b62e5c36cbfc3fa2ca492c81d1a49" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2)&quot;&gt;&lt;code&gt;collect(Func0,Action2)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2)&quot;&gt; &lt;code&gt;collect(Func0,Action2)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa67b873ecab3613f6b64ce78a0bdc32e5926fa9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN)&quot;&gt;&lt;code&gt;combineLatest(List,FuncN)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN)&quot;&gt; &lt;code&gt;combineLatest(List,FuncN)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec7df6aac2f2e3c95a112f207b4dbda0f7a7d0c6" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)&quot;&gt;&lt;code&gt;combineLatest(Observable,Observable,Func2)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observables)</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)&quot;&gt; &lt;code&gt;combineLatest(Observable,Observable,Func2)&lt;/code&gt; &lt;/a&gt; (최대 9 개의 Observable을 갖는 버전도 있습니다)</target>
        </trans-unit>
        <trans-unit id="065654bfbdd9b9bee866590ec170ff626ea47e08" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable)&quot;&gt;&lt;code&gt;concat(Observable&amp;lt;Observable&amp;gt;)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable)&quot;&gt; &lt;code&gt;concat(Observable&amp;lt;Observable&amp;gt;)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5260958a449491f7610db2dc9bb82bc9b45e109" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)&quot;&gt;&lt;code&gt;concat(Observable,Observable)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observables)</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)&quot;&gt; &lt;code&gt;concat(Observable,Observable)&lt;/code&gt; &lt;/a&gt; (최대 9 개의 Observable을 갖는 버전도 있음)</target>
        </trans-unit>
        <trans-unit id="50e62fe96dcbddd17b24ab4cd101fe1c35a3d6df" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)&quot;&gt;&lt;code&gt;concatMap(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)&quot;&gt; &lt;code&gt;concatMap(Func1)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7f8062d4eceee18625891f695512adafea0ce1b" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable)&quot;&gt;&lt;code&gt;concatWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable)&quot;&gt; &lt;code&gt;concatWith(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af422290d005f62aabe996a727d72476d3979818" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object)&quot;&gt;&lt;code&gt;contains(Object)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object)&quot;&gt; &lt;code&gt;contains(Object)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70bacf76ad19d833c6f617bc4a72f0211c2df6b9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#count()&quot;&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#count()&quot;&gt; &lt;code&gt;count()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0135bdfd6a0be2f5741df4e612e42cc09264016" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong()&quot;&gt;&lt;code&gt;countLong()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong()&quot;&gt; &lt;code&gt;countLong()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6913a045e4bd9b5ec923b8deed52b537c92fcf3" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe)&quot;&gt;&lt;code&gt;create(OnSubscribe)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe)&quot;&gt; &lt;code&gt;create(OnSubscribe)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd4e32a121d2f3b9718d60b90e2a55ca637ed7d5" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1)&quot;&gt;&lt;code&gt;debounce(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1)&quot;&gt; &lt;code&gt;debounce(Func1)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14e04e6e0b8a579ec0455332f25d673a969ebe63" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T)&quot;&gt;&lt;code&gt;defaultIfEmpty(T)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T)&quot;&gt; &lt;code&gt;defaultIfEmpty(T)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3665f849f7caae696ee21ed577b42416b67b5e53" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0)&quot;&gt;&lt;code&gt;defer()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">자바 독 : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0)&quot;&gt; &lt;code&gt;defer()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f24e91a0b092b6e002922bb2340a890ca0edec33" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;delay(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;delay(long,TimeUnit)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef2b29abfc91519e0f51d0c4dd0da82457c7399e" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
