<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="docker">
    <body>
      <group id="docker">
        <trans-unit id="10cc55b4e5a8d47bdbcdbe70d599e97ab931b718" translate="yes" xml:space="preserve">
          <source>Expose ports without publishing them to the host machine - they&amp;rsquo;ll only be accessible to linked services. Only the internal port can be specified.</source>
          <target state="translated">호스트 컴퓨터에 포트를 게시하지 않고 포트를 노출합니다. 링크 된 서비스에만 액세스 할 수 있습니다. 내부 포트만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e767ce644c04911f18c98b70d31d374b9eb56cd3" translate="yes" xml:space="preserve">
          <source>Expose ports.</source>
          <target state="translated">포트를 노출하십시오.</target>
        </trans-unit>
        <trans-unit id="1619f9c5566c78e1d11c4ff900380478003ac635" translate="yes" xml:space="preserve">
          <source>Expose ports. Either specify both ports (&lt;code&gt;HOST:CONTAINER&lt;/code&gt;), or just the container port (an ephemeral host port is chosen).</source>
          <target state="translated">포트를 노출하십시오. 두 포트 ( &lt;code&gt;HOST:CONTAINER&lt;/code&gt; ) 또는 컨테이너 포트만 지정하십시오 (일시적인 호스트 포트가 선택됨).</target>
        </trans-unit>
        <trans-unit id="1fbc71f7387278269f1d957e28390616407593f9" translate="yes" xml:space="preserve">
          <source>Exposed port number, such as &lt;code&gt;DB_PORT_5432_TCP_PORT=5432&lt;/code&gt;</source>
          <target state="translated">노출 된 포트 번호 (예 : &lt;code&gt;DB_PORT_5432_TCP_PORT=5432&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d62bff054d1ae4b7900a38f3e9ee0b3444fd521c" translate="yes" xml:space="preserve">
          <source>Exposed ports.</source>
          <target state="translated">노출 된 포트.</target>
        </trans-unit>
        <trans-unit id="3105862e09650234250b61444f5ddb0b9b8b7c98" translate="yes" xml:space="preserve">
          <source>Exposes WordPress on port 30000 of the host machine, so that you can access it from external hosts. You can expose port 80 instead if you do not have a web server running on port 80 of the host machine.</source>
          <target state="translated">외부 호스트에서 액세스 할 수 있도록 호스트 시스템의 포트 30000에 WordPress를 노출시킵니다. 호스트 시스템의 포트 80에서 웹 서버를 실행하지 않는 경우 포트 80을 대신 노출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c7c7ba02689bdfe8fac698936944594767c963" translate="yes" xml:space="preserve">
          <source>Express dependency between services, Service dependencies cause the following behaviors:</source>
          <target state="translated">서비스 간 Express 종속성, 서비스 종속성은 다음과 같은 동작을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="68a134f7e49c8860c88eb0b67bcd14cb443270ec" translate="yes" xml:space="preserve">
          <source>Express dependency between services, which has two effects:</source>
          <target state="translated">서비스 간 특급 의존성 : 두 가지 영향</target>
        </trans-unit>
        <trans-unit id="e64ffe047868ebb24ac6b257af5f051e7f6caf40" translate="yes" xml:space="preserve">
          <source>Extend another service, in the current file or another, optionally overriding configuration.</source>
          <target state="translated">현재 파일 또는 다른 선택적으로 구성을 대체하는 다른 서비스를 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="161d32faaff143d7590da9bcd1ca3c7b7b4bee8d" translate="yes" xml:space="preserve">
          <source>Extended description</source>
          <target state="translated">자세한 설명</target>
        </trans-unit>
        <trans-unit id="9102b67eb74161bf5739f97d399e8cca8296b36a" translate="yes" xml:space="preserve">
          <source>Extending an entire Compose file by &lt;a href=&quot;index#multiple-compose-files&quot;&gt;using multiple Compose files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;index#multiple-compose-files&quot;&gt;여러 개의 작성 파일&lt;/a&gt; 을 사용하여 전체 작성 파일 확장</target>
        </trans-unit>
        <trans-unit id="6c0b262b322484366b736a907cf2b63e2f1189c3" translate="yes" xml:space="preserve">
          <source>Extending an individual service is useful when you have multiple services that have a common configuration. The example below is a Compose app with two services: a web application and a queue worker. Both services use the same codebase and share many configuration options.</source>
          <target state="translated">개별 서비스를 확장하면 공통 구성을 가진 여러 서비스가있는 경우 유용합니다. 아래 예제는 웹 애플리케이션과 큐 워커라는 두 가지 서비스가있는 Compose 앱입니다. 두 서비스 모두 동일한 코드베이스를 사용하며 많은 구성 옵션을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="45f90ec3f1e60b8d22f7d8e0320fec2e1c4925a4" translate="yes" xml:space="preserve">
          <source>Extending individual services with &lt;a href=&quot;index#extending-services&quot;&gt;the &lt;code&gt;extends&lt;/code&gt; field&lt;/a&gt; (for Compose file versions up to 2.1)</source>
          <target state="translated">개별 서비스를 확장 &lt;a href=&quot;index#extending-services&quot;&gt;하는 &lt;code&gt;extends&lt;/code&gt; 필드&lt;/a&gt; (2.1까지 작성 파일 버전)</target>
        </trans-unit>
        <trans-unit id="fea7d09b0172e42db8b4095d4228b89a2dc7a781" translate="yes" xml:space="preserve">
          <source>Extending services</source>
          <target state="translated">서비스 확장</target>
        </trans-unit>
        <trans-unit id="b8911778c9fba90f4c057ef35b96269e91c23ac5" translate="yes" xml:space="preserve">
          <source>Extension fields</source>
          <target state="translated">확장 필드</target>
        </trans-unit>
        <trans-unit id="25ef7b426747adfde8e7cee3a78fcaf439560176" translate="yes" xml:space="preserve">
          <source>External components, such as cloud load balancers, can access the service on the PublishedPort of any node in the cluster whether or not the node is currently running the task for the service. All nodes in the swarm route ingress connections to a running task instance.</source>
          <target state="translated">클라우드로드 밸런서와 같은 외부 구성 요소는 노드가 현재 서비스 작업을 실행 중인지 여부에 관계없이 클러스터에있는 모든 노드의 PublishedPort에서 서비스에 액세스 할 수 있습니다. swarm route의 모든 노드는 실행중인 작업 인스턴스에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="88a26707fe24cd98fc98c5ab675aa6efa0354e81" translate="yes" xml:space="preserve">
          <source>External implementation features</source>
          <target state="translated">외부 구현 기능</target>
        </trans-unit>
        <trans-unit id="2df7c6ad0c1d697b076b44b742ad83a265e266ec" translate="yes" xml:space="preserve">
          <source>External volumes are always created with docker stack deploy</source>
          <target state="translated">외부 볼륨은 항상 docker stack deploy로 생성됩니다</target>
        </trans-unit>
        <trans-unit id="15168c1fc7995a3bda7e8147826c809d91841678" translate="yes" xml:space="preserve">
          <source>External volumes that do not exist &lt;em&gt;are created&lt;/em&gt; if you use &lt;a href=&quot;#deploy&quot;&gt;docker stack deploy&lt;/a&gt; to launch the app in &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm mode&lt;/a&gt; (instead of &lt;a href=&quot;../reference/up/index&quot;&gt;docker compose up&lt;/a&gt;). In swarm mode, a volume is automatically created when it is defined by a service. As service tasks are scheduled on new nodes, &lt;a href=&quot;https://github.com/docker/swarmkit/blob/master/README/&quot;&gt;swarmkit&lt;/a&gt; creates the volume on the local node. To learn more, see &lt;a href=&quot;https://github.com/moby/moby/issues/29976&quot;&gt;moby/moby#29976&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#deploy&quot;&gt;docker stack deploy&lt;/a&gt; 를 사용하여 &lt;a href=&quot;../reference/up/index&quot;&gt;docker compose up&lt;/a&gt; 대신 &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm 모드&lt;/a&gt; 에서 앱을 시작 하면 존재하지 않는 외부 볼륨 &lt;em&gt;이 생성&lt;/em&gt; 됩니다 . 스웜 모드에서는 서비스가 볼륨을 정의 할 때 볼륨이 자동으로 생성됩니다. 서비스 작업이 새 노드에서 예약되면 &lt;a href=&quot;https://github.com/docker/swarmkit/blob/master/README/&quot;&gt;swarmkit&lt;/a&gt; 은 로컬 노드에 볼륨을 만듭니다. 자세한 내용은 &lt;a href=&quot;https://github.com/moby/moby/issues/29976&quot;&gt;moby / moby # 29976를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69a9dac6efea62707611763428619cdecc46fa49" translate="yes" xml:space="preserve">
          <source>FOWNER</source>
          <target state="translated">FOWNER</target>
        </trans-unit>
        <trans-unit id="8e7f00cffd27676bd86f7a41b4fecf304cf6d5a6" translate="yes" xml:space="preserve">
          <source>FROM</source>
          <target state="translated">FROM</target>
        </trans-unit>
        <trans-unit id="7b817867f7950dd64ffa6bb8b39b3a24e057710f" translate="yes" xml:space="preserve">
          <source>FSETID</source>
          <target state="translated">FSETID</target>
        </trans-unit>
        <trans-unit id="0950f1a60851cc92b56c7a7fbcd6fcf8bf42bed9" translate="yes" xml:space="preserve">
          <source>Failure rate to tolerate during a rollback</source>
          <target state="translated">롤백 중 허용되는 실패율</target>
        </trans-unit>
        <trans-unit id="3f228debbb439b7b1f8c1b5f1e2fafb87ab5778e" translate="yes" xml:space="preserve">
          <source>Failure rate to tolerate during a rollback (default 0)</source>
          <target state="translated">롤백 중 허용되는 실패율 (기본값 0)</target>
        </trans-unit>
        <trans-unit id="1ee75a5d4048975d35f9a0da09c9bc2e67401147" translate="yes" xml:space="preserve">
          <source>Failure rate to tolerate during an update</source>
          <target state="translated">업데이트 중 허용되는 실패율</target>
        </trans-unit>
        <trans-unit id="8e41dafe24b8e98505b8b2f5f08ed3b3dee52413" translate="yes" xml:space="preserve">
          <source>Failure rate to tolerate during an update (default 0)</source>
          <target state="translated">업데이트 중 허용되는 실패율 (기본값 0)</target>
        </trans-unit>
        <trans-unit id="ca27a0bac93ec2d83df6d32cae9fd11cbaa465aa" translate="yes" xml:space="preserve">
          <source>Fault Tolerance</source>
          <target state="translated">결함 허용</target>
        </trans-unit>
        <trans-unit id="dc6720ec19a045ad4a41542f0a1931e0dd8a15c7" translate="yes" xml:space="preserve">
          <source>Feature Deprecation Policy</source>
          <target state="translated">기능 지원 중단 정책</target>
        </trans-unit>
        <trans-unit id="5a6ace8a0d67202b6a12d2b8687690b1324abee4" translate="yes" xml:space="preserve">
          <source>Feature highlights</source>
          <target state="translated">주요 특징</target>
        </trans-unit>
        <trans-unit id="3286949be5f9c0e2f39ddf6e437d797d23e49cbd" translate="yes" xml:space="preserve">
          <source>Feature options</source>
          <target state="translated">기능 옵션</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="bc5fc74a0c921be17dde1b381a9a43609da45dab" translate="yes" xml:space="preserve">
          <source>Fedora</source>
          <target state="translated">Fedora</target>
        </trans-unit>
        <trans-unit id="db28646201232a1d472af5ee747adae8ccf3c157" translate="yes" xml:space="preserve">
          <source>Fetch the logs of a container</source>
          <target state="translated">컨테이너의 로그를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="eb5b38f5a58944684e8d2dc83a9cb9e1f17f669c" translate="yes" xml:space="preserve">
          <source>Fetch the logs of a service or task</source>
          <target state="translated">서비스 또는 작업의 로그를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="479d806c144be804128caa2e2a55d68248c3013b" translate="yes" xml:space="preserve">
          <source>File mode of the tmpfs in octal. (e.g.</source>
          <target state="translated">8 진으로 된 tmpfs의 파일 모드. (예 :</target>
        </trans-unit>
        <trans-unit id="410867a8d746780656c7afa6302f50564b7bca8f" translate="yes" xml:space="preserve">
          <source>Files and state on disk</source>
          <target state="translated">디스크의 파일 및 상태</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="d600800f7900f101638275541b8da4023176f070" translate="yes" xml:space="preserve">
          <source>Filter by exit signal</source>
          <target state="translated">종료 신호로 필터링</target>
        </trans-unit>
        <trans-unit id="77b6f6141940aa9f15c840f98693412c7ae70370" translate="yes" xml:space="preserve">
          <source>Filter events by criteria</source>
          <target state="translated">기준에 따라 이벤트 필터링</target>
        </trans-unit>
        <trans-unit id="ab731432fea41b3e082bc35806547ae3a28f48e9" translate="yes" xml:space="preserve">
          <source>Filter events by time</source>
          <target state="translated">시간별로 이벤트 필터링</target>
        </trans-unit>
        <trans-unit id="640790603f3ecbc2b0f007b68bb2a4fdc6962815" translate="yes" xml:space="preserve">
          <source>Filter images by reference</source>
          <target state="translated">참조로 이미지 필터링</target>
        </trans-unit>
        <trans-unit id="7e2bcaa91ef285441340e377f905181d36b6a42b" translate="yes" xml:space="preserve">
          <source>Filter images by time</source>
          <target state="translated">시간별로 이미지 필터링</target>
        </trans-unit>
        <trans-unit id="7f74589fe05009f7909335b66ed93724d1a2e2a2" translate="yes" xml:space="preserve">
          <source>Filter output based on conditions provided</source>
          <target state="translated">제공된 조건에 따라 필터 출력</target>
        </trans-unit>
        <trans-unit id="9075edca21736af901d2add18e4d9491f2452b4d" translate="yes" xml:space="preserve">
          <source>Filtering</source>
          <target state="translated">Filtering</target>
        </trans-unit>
        <trans-unit id="02ad80c98c2aba9c2c0ee285bbacb832e17e3f0f" translate="yes" xml:space="preserve">
          <source>Filtering on both &lt;code&gt;key&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;value&lt;/code&gt; of the label, produces the expected result:</source>
          <target state="translated">레이블의 &lt;code&gt;key&lt;/code&gt; &lt;em&gt;와 &lt;/em&gt; &lt;code&gt;value&lt;/code&gt; 을 모두 필터링 하면 예상되는 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a57c0d9cff01bc0bf8dfb239e93f01b4c27ed679" translate="yes" xml:space="preserve">
          <source>Filtering with &lt;code&gt;before&lt;/code&gt; would give:</source>
          <target state="translated">&lt;code&gt;before&lt;/code&gt; 로 필터링 하면 다음이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5d693a3237875e523ade80913305f07c0d600fb0" translate="yes" xml:space="preserve">
          <source>Filtering with &lt;code&gt;reference&lt;/code&gt; would give:</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; 필터링 하면 다음이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6c44fdb5c3ad6e5bdf8193c70970138671389714" translate="yes" xml:space="preserve">
          <source>Filtering with &lt;code&gt;since&lt;/code&gt; would give:</source>
          <target state="translated">&lt;code&gt;since&lt;/code&gt; 필터링 하면 다음이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d414611e6289ed9a2a817ad183fa014b4147455d" translate="yes" xml:space="preserve">
          <source>Filtering with multiple &lt;code&gt;reference&lt;/code&gt; would give, either match A or B:</source>
          <target state="translated">다중 &lt;code&gt;reference&lt;/code&gt; 필터링하면 A 또는 B와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="69612f321e27e4f832f808b875cc54c3521ece6c" translate="yes" xml:space="preserve">
          <source>Filters containers based on their healthcheck status. One of &lt;code&gt;starting&lt;/code&gt;, &lt;code&gt;healthy&lt;/code&gt;, &lt;code&gt;unhealthy&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">상태 점검 상태에 따라 컨테이너를 필터링합니다. 하나의 &lt;code&gt;starting&lt;/code&gt; , &lt;code&gt;healthy&lt;/code&gt; , &lt;code&gt;unhealthy&lt;/code&gt; 또는 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5795d795526f86884093e8a90467b50876d23df7" translate="yes" xml:space="preserve">
          <source>Filters containers created before or after a given container ID or name</source>
          <target state="translated">지정된 컨테이너 ID 또는 이름 전후에 만들어진 컨테이너를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="6026deb4aa5a2a3c02af920eab62a65264cf103a" translate="yes" xml:space="preserve">
          <source>Filters containers that are a &amp;ldquo;task&amp;rdquo; for a service. Boolean option (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">서비스의 &quot;작업&quot;인 컨테이너를 필터링합니다. 부울 옵션 ( &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1c4bb21ae08095d6170daee2f696815adb874d44" translate="yes" xml:space="preserve">
          <source>Filters containers which publish or expose a given port. Expressed as &lt;code&gt;&amp;lt;port&amp;gt;[/&amp;lt;proto&amp;gt;]&lt;/code&gt; or &lt;code&gt;&amp;lt;startport-endport&amp;gt;/[&amp;lt;proto&amp;gt;]&lt;/code&gt;</source>
          <target state="translated">주어진 포트를 게시하거나 노출하는 컨테이너를 필터링합니다. 표현 &lt;code&gt;&amp;lt;port&amp;gt;[/&amp;lt;proto&amp;gt;]&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;startport-endport&amp;gt;/[&amp;lt;proto&amp;gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0e450b88d7c72346fd6945f7a9d5986312ba3d0" translate="yes" xml:space="preserve">
          <source>Filters containers which share a given image as an ancestor. Expressed as &lt;code&gt;&amp;lt;image-name&amp;gt;[:&amp;lt;tag&amp;gt;]&lt;/code&gt;, &lt;code&gt;&amp;lt;image id&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;image@digest&amp;gt;&lt;/code&gt;</source>
          <target state="translated">주어진 이미지를 조상으로 공유하는 컨테이너를 필터링합니다. 표현 &lt;code&gt;&amp;lt;image-name&amp;gt;[:&amp;lt;tag&amp;gt;]&lt;/code&gt; , &lt;code&gt;&amp;lt;image id&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;image@digest&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2d898f3ce102a6810216628ad5970d15ace76a5" translate="yes" xml:space="preserve">
          <source>Filters running containers connected to a given network.</source>
          <target state="translated">주어진 네트워크에 연결된 컨테이너를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c06fd49fa5a6a64634581e170d14f4d1c398e58d" translate="yes" xml:space="preserve">
          <source>Filters running containers which have mounted a given volume or bind mount.</source>
          <target state="translated">주어진 볼륨 또는 바인드 마운트를 마운트 한 컨테이너를 실행하는 필터.</target>
        </trans-unit>
        <trans-unit id="c431796ca420e6a7c02b2e3f9abb01b4d1c23648" translate="yes" xml:space="preserve">
          <source>Finally when signing an image, we will need to export the passphrase of the signing key. This was created when the key was loaded into the local Docker trust store with &lt;code&gt;$ docker trust key load&lt;/code&gt;.</source>
          <target state="translated">마지막으로 이미지에 서명 할 때 서명 키의 암호를 내 보내야합니다. 이것은 키가 &lt;code&gt;$ docker trust key load&lt;/code&gt; 로 로컬 Docker trust store에로드 될 때 만들어졌습니다 .</target>
        </trans-unit>
        <trans-unit id="b5dc1b015f206ca7874975675ea63a51bfd5d822" translate="yes" xml:space="preserve">
          <source>Finally you will need to add the private key into your local Docker trust store.</source>
          <target state="translated">마지막으로 개인 키를 로컬 Docker 신뢰 저장소에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="f818536ddbf306feb6891aa3cd76c54f3943496c" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;docker-compose.yml&lt;/code&gt; is where the magic happens. This file describes the services that comprise your app (a database and a web app), how to get each one&amp;rsquo;s Docker image (the database just runs on a pre-made PostgreSQL image, and the web app is built from the current directory), and the configuration needed to link them together and expose the web app&amp;rsquo;s port.</source>
          <target state="translated">마지막으로 &lt;code&gt;docker-compose.yml&lt;/code&gt; 은 마법이 일어나는 곳입니다. 이 파일은 앱 (데이터베이스 및 웹 앱)을 구성하는 서비스, 각각의 Docker 이미지 (데이터베이스는 사전 작성된 PostgreSQL 이미지에서 실행되고 웹 앱은 현재 디렉토리에서 빌드 됨)를 얻는 방법, 이들을 서로 연결하고 웹앱의 포트를 노출하는 데 필요한 구성.</target>
        </trans-unit>
        <trans-unit id="3544a0d9931c381ceaeadc392fc38ea2810a717c" translate="yes" xml:space="preserve">
          <source>Finally, Notary server notifies the client that their upload was successful.</source>
          <target state="translated">마지막으로, Notary 서버는 클라이언트에게 업로드가 완료되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="d6aadd0ba1a57fa7d54146f69c2f64d3e67b3482" translate="yes" xml:space="preserve">
          <source>Finally, clean up after your test by stopping and removing the container, and then removing the image.</source>
          <target state="translated">마지막으로 테스트 후 컨테이너를 중지하고 제거한 다음 이미지를 제거하여 청소하십시오.</target>
        </trans-unit>
        <trans-unit id="9714faaa10a31f5be73dee9d0070895cfb69f68e" translate="yes" xml:space="preserve">
          <source>Finally, if you run Docker on a server, it is recommended to run exclusively Docker on the server, and move all other services within containers controlled by Docker. Of course, it is fine to keep your favorite admin tools (probably at least an SSH server), as well as existing monitoring/supervision processes, such as NRPE and collectd.</source>
          <target state="translated">마지막으로 서버에서 Docker를 실행하는 경우 서버에서 Docker 만 독점적으로 실행하고 Docker가 제어하는 ​​컨테이너 내에서 다른 모든 서비스를 이동하는 것이 좋습니다. 물론 NRPE 및 수집과 같은 기존 모니터링 / 감시 프로세스뿐만 아니라 즐겨 사용하는 관리 도구 (최소한 SSH 서버)를 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2217e3e4a858c8204ac82dc889b9cc7dd620b363" translate="yes" xml:space="preserve">
          <source>Finally, in Docker 17.04 and higher, &lt;code&gt;--rollback&lt;/code&gt; cannot be used in conjunction with other flags to &lt;code&gt;docker service update&lt;/code&gt;.</source>
          <target state="translated">마지막으로 Docker 17.04 이상에서 &lt;code&gt;--rollback&lt;/code&gt; 을 다른 플래그와 함께 사용하여 &lt;code&gt;docker service update&lt;/code&gt; 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f57448584f9cc43f455aa0aab1881c0872662120" translate="yes" xml:space="preserve">
          <source>Finally, to help with automation, you can have Docker write the container ID out to a file of your choosing. This is similar to how some programs might write out their process ID to a file (you&amp;rsquo;ve seen them as PID files):</source>
          <target state="translated">마지막으로 자동화를 돕기 위해 Docker가 컨테이너 ID를 선택한 파일에 쓰도록 할 수 있습니다. 이것은 일부 프로그램이 프로세스 ID를 파일에 쓰는 방법과 비슷합니다 (PID 파일로 보았습니다).</target>
        </trans-unit>
        <trans-unit id="6906b86088888eb8546af8d0118fdab3cf4f7372" translate="yes" xml:space="preserve">
          <source>Finally, we will use the delegation private key to sign a particular tag and push it up to the registry.</source>
          <target state="translated">마지막으로 위임 개인 키를 사용하여 특정 태그에 서명하고 레지스트리로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="92fc4acade75b1ccbb1b5a96a8ff65d3f6b10c06" translate="yes" xml:space="preserve">
          <source>Finally, you may want to specify which files to include in the context, rather than which to exclude. To achieve this, specify &lt;code&gt;*&lt;/code&gt; as the first pattern, followed by one or more &lt;code&gt;!&lt;/code&gt; exception patterns.</source>
          <target state="translated">마지막으로, 제외 할 파일이 아닌 컨텍스트에 포함 할 파일을 지정할 수 있습니다. 이를 달성하려면 &lt;code&gt;*&lt;/code&gt; 를 첫 번째 패턴으로 지정한 다음 하나 이상을 지정하십시오 &lt;code&gt;!&lt;/code&gt; 예외 패턴.</target>
        </trans-unit>
        <trans-unit id="259d31bb34b3c0a0e077c6d33ffc28ed89e63128" translate="yes" xml:space="preserve">
          <source>Finally, you need to &lt;code&gt;push&lt;/code&gt; your manifest list to the desired registry. Below are descriptions of these three commands, and an example putting them all together.</source>
          <target state="translated">마지막으로 매니페스트 목록을 원하는 레지스트리 로 &lt;code&gt;push&lt;/code&gt; 해야합니다 . 아래는이 세 가지 명령에 대한 설명과이를 모두 합한 예입니다.</target>
        </trans-unit>
        <trans-unit id="8fd935241a1ccd2211b04f0321e48886e426412e" translate="yes" xml:space="preserve">
          <source>Finally, you need to create the database. In another terminal, run:</source>
          <target state="translated">마지막으로 데이터베이스를 작성해야합니다. 다른 터미널에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="83d85ce55eb317788dc65fb1efb8f89244e4307b" translate="yes" xml:space="preserve">
          <source>Find a specific port mapping</source>
          <target state="translated">특정 포트 매핑 찾기</target>
        </trans-unit>
        <trans-unit id="13fa60c3b3e08672f84a5135a4ac7e2623136ff9" translate="yes" xml:space="preserve">
          <source>Find network plugins</source>
          <target state="translated">네트워크 플러그인 찾기</target>
        </trans-unit>
        <trans-unit id="5cee6e7e616c938639b70650e8245a62a7a5cf68" translate="yes" xml:space="preserve">
          <source>Find the &lt;a href=&quot;https://docs.docker.com/install/#supported-platforms&quot;&gt;install instructions&lt;/a&gt; for Docker Engine --- Community on the platform of your choice.</source>
          <target state="translated">선택한 플랫폼에서 Docker Engine --- Community 의 &lt;a href=&quot;https://docs.docker.com/install/#supported-platforms&quot;&gt;설치 지시 사항&lt;/a&gt; 을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="52d5fc6e2545bef3fd448493145258f54498b4a1" translate="yes" xml:space="preserve">
          <source>Find the number of tasks running as part of a service</source>
          <target state="translated">서비스의 일부로 실행중인 작업 수 찾기</target>
        </trans-unit>
        <trans-unit id="d05317fb15464e667ff061aad99a88d79458897a" translate="yes" xml:space="preserve">
          <source>Finding a plugin</source>
          <target state="translated">플러그인 찾기</target>
        </trans-unit>
        <trans-unit id="414493a61bfe6a3e1bca2041f8b189cda955841f" translate="yes" xml:space="preserve">
          <source>Fine-tune bandwidth allocation by device. Each item in the list must have two keys:</source>
          <target state="translated">장치별로 대역폭 할당을 미세 조정하십시오. 목록의 각 항목에는 두 개의 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9f93fcd65aed246f6b56aaeb31480a9272b15cd5" translate="yes" xml:space="preserve">
          <source>First of all, &lt;strong&gt;only trusted users should be allowed to control your Docker daemon&lt;/strong&gt;. This is a direct consequence of some powerful Docker features. Specifically, Docker allows you to share a directory between the Docker host and a guest container; and it allows you to do so without limiting the access rights of the container. This means that you can start a container where the &lt;code&gt;/host&lt;/code&gt; directory is the &lt;code&gt;/&lt;/code&gt; directory on your host; and the container can alter your host filesystem without any restriction. This is similar to how virtualization systems allow filesystem resource sharing. Nothing prevents you from sharing your root filesystem (or even your root block device) with a virtual machine.</source>
          <target state="translated">우선, &lt;strong&gt;신뢰할 수있는 사용자 만 Docker 데몬을 제어 할 수 있어야합니다&lt;/strong&gt; . 이것은 일부 강력한 Docker 기능의 직접적인 결과입니다. 특히, Docker를 사용하면 Docker 호스트와 게스트 컨테이너간에 디렉토리를 공유 할 수 있습니다. 컨테이너의 액세스 권한을 제한하지 않고 그렇게 할 수 있습니다. 이는 &lt;code&gt;/host&lt;/code&gt; 디렉토리가 호스트 의 &lt;code&gt;/&lt;/code&gt; 디렉토리 인 컨테이너를 시작할 수 있음을 의미합니다 . 컨테이너는 제한없이 호스트 파일 시스템을 변경할 수 있습니다. 이것은 가상화 시스템이 파일 시스템 리소스 공유를 허용하는 방법과 유사합니다. 루트 파일 시스템 (또는 루트 블록 장치)을 가상 시스템과 공유 할 수있는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d14a9370ad1103e2d07dacfa097736d6eeb238b2" translate="yes" xml:space="preserve">
          <source>First save the new image by finding the container ID (using &lt;a href=&quot;../ps/index&quot;&gt;&lt;code&gt;docker ps&lt;/code&gt;&lt;/a&gt;) and then committing it to a new image name. Note that only &lt;code&gt;a-z0-9-_.&lt;/code&gt; are allowed when naming images:</source>
          <target state="translated">먼저 컨테이너 ID를 찾고 ( &lt;a href=&quot;../ps/index&quot;&gt; &lt;code&gt;docker ps&lt;/code&gt; 사용&lt;/a&gt; ) 새 이미지 이름으로 커밋 하여 새 이미지를 저장하십시오 . 참고 만 &lt;code&gt;a-z0-9-_.&lt;/code&gt; 이미지 이름을 지정할 때 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="04448eeef6a550c82cc0fd8f35aecc69667b1679" translate="yes" xml:space="preserve">
          <source>First we will add the delegation private key to the local Docker trust repository. (By default this is stored in &lt;code&gt;~/.docker/trust/&lt;/code&gt;). If you are generating delegation keys with &lt;code&gt;$ docker trust key generate&lt;/code&gt;, the private key is automatically added to the local trust store. If you are importing a separate key, such as one from a UCP Client Bundle you will need to use the &lt;code&gt;$ docker trust key load&lt;/code&gt; command.</source>
          <target state="translated">먼저 위임 개인 키를 로컬 Docker 신뢰 저장소에 추가합니다. (기본적으로 &lt;code&gt;~/.docker/trust/&lt;/code&gt; 저장됩니다 ). &lt;code&gt;$ docker trust key generate&lt;/code&gt; 로 위임 키를 생성 하는 경우 개인 키가 로컬 신뢰 저장소에 자동으로 추가됩니다. UCP 클라이언트 번들과 같은 별도의 키를 가져 오는 경우 &lt;code&gt;$ docker trust key load&lt;/code&gt; 명령 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9247ff9257fd2f1f65e6eb48b10cd8bb50d8471d" translate="yes" xml:space="preserve">
          <source>First, Compose builds the image for the &lt;code&gt;web&lt;/code&gt; service using the &lt;code&gt;Dockerfile&lt;/code&gt;. Then it runs &lt;code&gt;rails new&lt;/code&gt; inside a new container, using that image. Once it&amp;rsquo;s done, you should have generated a fresh app.</source>
          <target state="translated">먼저 Compose 는 &lt;code&gt;Dockerfile&lt;/code&gt; 을 사용하여 &lt;code&gt;web&lt;/code&gt; 서비스 의 이미지를 빌드합니다 . 그런 다음 해당 이미지를 사용하여 새 컨테이너 내부에서 &lt;code&gt;rails new&lt;/code&gt; 실행 합니다. 완료되면 새로운 앱을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4c3ab04bf48fb4e40c7ba46df68ccf37baeb93c" translate="yes" xml:space="preserve">
          <source>First, create an overlay network on a manager node the docker network create command:</source>
          <target state="translated">먼저, docker network create 명령을 관리자 노드에 오버레이 네트워크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c83fc5ec66c9c65162a4a8fbbbc2c9e5f9e915ee" translate="yes" xml:space="preserve">
          <source>First, create overlay network on a manager node using the &lt;code&gt;docker network create&lt;/code&gt; command with the &lt;code&gt;--driver overlay&lt;/code&gt; flag.</source>
          <target state="translated">먼저 &lt;code&gt;--driver overlay&lt;/code&gt; 플래그 와 함께 &lt;code&gt;docker network create&lt;/code&gt; 명령을 사용하여 관리자 노드에 오버레이 네트워크를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f046ebcba9b52f3dd3b664bb50e9e065aab6e275" translate="yes" xml:space="preserve">
          <source>First, find the ID of the &lt;code&gt;mysql&lt;/code&gt; container task.</source>
          <target state="translated">먼저, &lt;code&gt;mysql&lt;/code&gt; 컨테이너 작업 의 ID를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="54ee5e8ff32c0596a1928a8bd873c17a5f190256" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s create some volumes to illustrate this;</source>
          <target state="translated">먼저 이것을 설명하기 위해 볼륨을 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="0fc3c85159e1cda9d6d8437732629919da8e860c" translate="yes" xml:space="preserve">
          <source>First, on the &lt;strong&gt;Docker daemon&amp;rsquo;s host machine&lt;/strong&gt;, generate CA private and public keys:</source>
          <target state="translated">먼저 &lt;strong&gt;Docker 데몬의 호스트 시스템&lt;/strong&gt; 에서 CA 개인 및 공개 키를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="444f7cb18e4c5861ad31efb8a57c41fd23d5bacb" translate="yes" xml:space="preserve">
          <source>First, quickly create a virtual switch for your virtual machines (VMs) to share, so they can connect to each other.</source>
          <target state="translated">먼저 VM (가상 머신)이 공유 할 가상 스위치를 신속하게 생성하여 서로 연결할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="96cbae3e155f1d9161fc02945d0af79b89bc3d66" translate="yes" xml:space="preserve">
          <source>First, specify the arguments in your Dockerfile:</source>
          <target state="translated">먼저 Dockerfile에서 인수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="862b2f12afc91efbeca488ea0d1e8410e3ebe571" translate="yes" xml:space="preserve">
          <source>First, start a container.</source>
          <target state="translated">먼저 컨테이너를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="7a45b5f00da3de07aa5ff907babcdec7174735ed" translate="yes" xml:space="preserve">
          <source>First, the command passed by &lt;code&gt;run&lt;/code&gt; overrides the command defined in the service configuration. For example, if the &lt;code&gt;web&lt;/code&gt; service configuration is started with &lt;code&gt;bash&lt;/code&gt;, then &lt;code&gt;docker-compose run web python app.py&lt;/code&gt; overrides it with &lt;code&gt;python app.py&lt;/code&gt;.</source>
          <target state="translated">먼저 &lt;code&gt;run&lt;/code&gt; 에 의해 전달 된 명령이 서비스 구성에 정의 된 명령보다 우선합니다. 예를 들어, &lt;code&gt;web&lt;/code&gt; 서비스 구성이 시작됩니다 &lt;code&gt;bash&lt;/code&gt; 는 다음 &lt;code&gt;docker-compose run web python app.py&lt;/code&gt; 와 무시를 &lt;code&gt;python app.py&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="5934c9bc41702137908811ade80842e4a75fd7e5" translate="yes" xml:space="preserve">
          <source>Flexible: Even the most complex applications can be containerized.</source>
          <target state="translated">유연성 : 가장 복잡한 응용 프로그램도 컨테이너화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="930f69b51fd17123cc140776719e699727398f20" translate="yes" xml:space="preserve">
          <source>Flocker plugin</source>
          <target state="translated">플로 커 플러그인</target>
        </trans-unit>
        <trans-unit id="fcc6594bb0b92c4eb7e3a8e3e7dc4f65990189e5" translate="yes" xml:space="preserve">
          <source>Fluentd logging driver for Docker. Writes log messages to &lt;code&gt;fluentd&lt;/code&gt; (forward input).</source>
          <target state="translated">Docker 용 Fluentd 로깅 드라이버. 로그 메시지를 &lt;code&gt;fluentd&lt;/code&gt; (정방향 입력)에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="c415de307b5b66bc1d7410ab29dc16cd1007efd3" translate="yes" xml:space="preserve">
          <source>Follow along with this example to create a Dockerized &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;Amazon Web Services (AWS)&lt;/a&gt; EC2 instance.</source>
          <target state="translated">이 예제와 함께 &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;AWS (&lt;/a&gt; Dockerized Amazon Web Services) EC2 인스턴스를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="02c70a70472cc26b862c39358f0a40d7c3cc1dc3" translate="yes" xml:space="preserve">
          <source>Follow along with this example to create a Dockerized &lt;a href=&quot;https://digitalocean.com&quot;&gt;DigitalOcean&lt;/a&gt; Droplet (cloud host).</source>
          <target state="translated">이 예제와 함께 Dockerized &lt;a href=&quot;https://digitalocean.com&quot;&gt;DigitalOcean&lt;/a&gt; Droplet (클라우드 호스트)을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="50e557ca59ee1c15418cfad996f28c84fcc2e59e" translate="yes" xml:space="preserve">
          <source>Follow log output</source>
          <target state="translated">로그 출력 따르기</target>
        </trans-unit>
        <trans-unit id="a2a986220319ce46e96db408ea8a7aa7ebae81cb" translate="yes" xml:space="preserve">
          <source>Follow the &lt;a href=&quot;https://docs.docker.com/ee&quot;&gt;instructions to install Docker Enterprise on your own host&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/ee&quot;&gt;지침에&lt;/a&gt; 따라 Docker Enterprise를 자신의 호스트에 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="7491d11292ea61353bb977068a2d14f20b4e1925" translate="yes" xml:space="preserve">
          <source>Follow the instructions below to install Compose on Mac, Windows, Windows Server 2016, or Linux systems, or find out about alternatives like using the &lt;code&gt;pip&lt;/code&gt; Python package manager or installing Compose as a container.</source>
          <target state="translated">아래 지침에 따라 Mac, Windows, Windows Server 2016 또는 Linux 시스템에 Compose를 설치하거나 &lt;code&gt;pip&lt;/code&gt; Python 패키지 관리자 사용 또는 컨테이너로 Compose 설치 와 같은 대안에 대해 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="1c87591d1c74e455474e0d27e9b59e8200e1175a" translate="yes" xml:space="preserve">
          <source>Follow the instructions in the plugin&amp;rsquo;s documentation.</source>
          <target state="translated">플러그인 설명서의 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="8cd709b42b8b24dbbf2eecf73d92670b739574f7" translate="yes" xml:space="preserve">
          <source>Follow these instructions if you are running the Docker daemon and client directly on Microsoft Windows Server with &lt;a href=&quot;https://docs.docker.com/install/windows/docker-ee/&quot;&gt;Docker Engine - Enterprise&lt;/a&gt;, and want to install Docker Compose.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/install/windows/docker-ee/&quot;&gt;Docker Engine-Enterprise가&lt;/a&gt; 설치된 Microsoft Windows Server에서 Docker 데몬 및 클라이언트를 직접 실행하고 Docker Compose를 설치하려면 다음 지시 사항을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="38f6bae8156c03d163a5ae6b34a1c27cc9994cd1" translate="yes" xml:space="preserve">
          <source>Following is a sample &lt;code&gt;config.json&lt;/code&gt; file:</source>
          <target state="translated">다음은 샘플 &lt;code&gt;config.json&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2ccfdb35cd2c70fc2e2c954da1e73f673bc44961" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1 files&lt;/a&gt;, both named volumes and container volumes use the specified driver.</source>
          <target state="translated">들어 &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;버전 1 개 파일&lt;/a&gt; , 이름 볼륨과 용기 볼륨 모두 지정된 드라이버를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6aeb3988c30c40f245ce885ddbb2d8ffdec3c689" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://github.com/docker/labs/blob/master/README/&quot;&gt;Docker Labs&lt;/a&gt; tutorials on networking, start with &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/README/&quot;&gt;Designing Scalable, Portable Docker Container Networks&lt;/a&gt;</source>
          <target state="translated">네트워킹에 대한 &lt;a href=&quot;https://github.com/docker/labs/blob/master/README/&quot;&gt;Docker Labs&lt;/a&gt; 자습서의 경우 &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/README/&quot;&gt;확장 가능한 휴대용 Docker 컨테이너 네트워크 디자인으로&lt;/a&gt; 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="707347c8c03a4f73500708e4156a0e7959e515f2" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;alpine&lt;/code&gt;, the following dependency packages are needed: &lt;code&gt;py-pip&lt;/code&gt;, &lt;code&gt;python-dev&lt;/code&gt;, &lt;code&gt;libffi-dev&lt;/code&gt;, &lt;code&gt;openssl-dev&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;libc-dev&lt;/code&gt;, and &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;alpine&lt;/code&gt; , 다음과 같은 의존성 패키지가 필요하다 : &lt;code&gt;py-pip&lt;/code&gt; , &lt;code&gt;python-dev&lt;/code&gt; , &lt;code&gt;libffi-dev&lt;/code&gt; , &lt;code&gt;openssl-dev&lt;/code&gt; , &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;libc-dev&lt;/code&gt; , 및 &lt;code&gt;make&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25cd7558fc1eb89ad48721ecba5e2b80b4b94b1f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;cmd.exe&lt;/code&gt;:</source>
          <target state="translated">의 경우 &lt;code&gt;cmd.exe&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="cc8ec8aab7cf095cf0579846c7e7e6468215e121" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;nproc&lt;/code&gt; usage</source>
          <target state="translated">들어 &lt;code&gt;nproc&lt;/code&gt; 에 사용</target>
        </trans-unit>
        <trans-unit id="e612c0940787b80000ce35849581da833855ddfb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;overlay&lt;/code&gt; networks or custom plugins that support multi-host connectivity, containers connected to the same multi-host network but launched from different Engines can also communicate in this way.</source>
          <target state="translated">들어 &lt;code&gt;overlay&lt;/code&gt; 멀티 호스트 접속을 지원하는 네트워크 또는 사용자 플러그인 다른 엔진에서 동일한 멀티 호스트 네트워크에 연결되지만 발사 용기는 또한 이러한 방식으로 통신 할 수있다.</target>
        </trans-unit>
        <trans-unit id="cfdbd6b18e68b8c72413226ed965f8182655d20b" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;global services&lt;/strong&gt;, the swarm runs one task for the service on every available node in the cluster.</source>
          <target state="translated">들어 &lt;strong&gt;글로벌 서비스&lt;/strong&gt; , 떼는 클러스터에서 사용할 수있는 모든 노드에 서비스에 대한 하나의 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="fb0fd0140da0a27d3976dba20b66f605cfb23f71" translate="yes" xml:space="preserve">
          <source>For AWS EC2, this command creates an instance called &amp;ldquo;aws-sandbox&amp;rdquo;:</source>
          <target state="translated">AWS EC2의 경우이 명령은&amp;ldquo;aws-sandbox&amp;rdquo;라는 인스턴스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="447cacaf9b16fc4c7f5e6ca9f806f31c719b0973" translate="yes" xml:space="preserve">
          <source>For DCT the name of the second delegation, in the below example &lt;code&gt;jeff&lt;/code&gt;, is there to help you keep track of the owner of the keys. In more advanced use cases of Notary additional delegations are used for hierarchy.</source>
          <target state="translated">DCT의 경우 아래 예 &lt;code&gt;jeff&lt;/code&gt; 에서 두 번째 위임의 이름은 키 소유자를 추적하는 데 도움이됩니다. Notary의 고급 사용 사례에서는 계층에 추가 위임이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8940a70f822bcb03782618de91f324cb90d20601" translate="yes" xml:space="preserve">
          <source>For DigitalOcean, this command creates a Droplet (cloud host) called &amp;ldquo;docker-sandbox&amp;rdquo;.</source>
          <target state="translated">DigitalOcean의 경우이 명령은 &quot;docker-sandbox&quot;라는 드롭 릿 (클라우드 호스트)을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c485fcd62e167979ddb95eaee13ff6a2a364df2c" translate="yes" xml:space="preserve">
          <source>For IPv6 use the &lt;code&gt;-6&lt;/code&gt; flag instead of the &lt;code&gt;-4&lt;/code&gt; flag. For other network devices, replace &lt;code&gt;eth0&lt;/code&gt; with the correct device name (for example &lt;code&gt;docker0&lt;/code&gt; for the bridge device).</source>
          <target state="translated">IPv6의 사용 &lt;code&gt;-6&lt;/code&gt; 의 대신 플래그를 &lt;code&gt;-4&lt;/code&gt; 플래그. 다른 네트워크 장치의 경우 &lt;code&gt;eth0&lt;/code&gt; 을 올바른 장치 이름으로 바꾸십시오 (예 : 브리지 장치의 &lt;code&gt;docker0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ee6dfc4ad5c5ab997d84f93afddd72ecb7a3a7d4" translate="yes" xml:space="preserve">
          <source>For PowerShell:</source>
          <target state="translated">PowerShell의 경우 :</target>
        </trans-unit>
        <trans-unit id="1b25a772948c6c56539966318b1a20ad70311f9c" translate="yes" xml:space="preserve">
          <source>For Windows, the format of the string passed to the &lt;code&gt;--device&lt;/code&gt; option is in the form of &lt;code&gt;--device=&amp;lt;IdType&amp;gt;/&amp;lt;Id&amp;gt;&lt;/code&gt;. Beginning with Windows Server 2019 and Windows 10 October 2018 Update, Windows only supports an IdType of &lt;code&gt;class&lt;/code&gt; and the Id as a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/install/overview-of-device-interface-classes&quot;&gt;device interface class GUID&lt;/a&gt;. Refer to the table defined in the &lt;a href=&quot;https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/hardware-devices-in-containers&quot;&gt;Windows container docs&lt;/a&gt; for a list of container-supported device interface class GUIDs.</source>
          <target state="translated">Windows의 경우 &lt;code&gt;--device&lt;/code&gt; 옵션에 전달 된 문자열 형식은 &lt;code&gt;--device=&amp;lt;IdType&amp;gt;/&amp;lt;Id&amp;gt;&lt;/code&gt; 형식 입니다. Windows Server 2019 및 Windows 10 2018 년 10 월 업데이트부터 Windows는 IdType &lt;code&gt;class&lt;/code&gt; 와 Id를 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/install/overview-of-device-interface-classes&quot;&gt;장치 인터페이스 클래스 GUID&lt;/a&gt; 로만 지원합니다 . 컨테이너 지원 장치 인터페이스 클래스 GUID 목록은 &lt;a href=&quot;https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/hardware-devices-in-containers&quot;&gt;Windows 컨테이너 문서&lt;/a&gt; 에 정의 된 표를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc9462e52246f5281496d962fc8b90628772ef20" translate="yes" xml:space="preserve">
          <source>For a complete list of &lt;code&gt;docker-machine&lt;/code&gt; subcommands, see the &lt;a href=&quot;../reference/help/index&quot;&gt;Docker Machine subcommand reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker-machine&lt;/code&gt; 하위 명령 의 전체 목록은 &lt;a href=&quot;../reference/help/index&quot;&gt;Docker Machine 하위 명령 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf6a74624e619431401ab6d507c88398d72715e" translate="yes" xml:space="preserve">
          <source>For a full explanation of Compose&amp;rsquo;s use of Docker networking features and all network driver options, see the &lt;a href=&quot;../networking/index&quot;&gt;Networking guide&lt;/a&gt;.</source>
          <target state="translated">Compose의 Docker 네트워킹 기능 및 모든 네트워크 드라이버 옵션 사용에 대한 전체 설명은 &lt;a href=&quot;../networking/index&quot;&gt;네트워킹 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="356d0c9cd338533c7b0340d2989710578bfa324f" translate="yes" xml:space="preserve">
          <source>For a full list of drivers that work with &lt;code&gt;docker-machine create&lt;/code&gt; and information on how to use them, see &lt;a href=&quot;../../drivers/index&quot;&gt;Machine drivers&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker-machine create&lt;/code&gt; 와 함께 작동하는 전체 드라이버 목록 및 사용 방법에 대한 정보는 &lt;a href=&quot;../../drivers/index&quot;&gt;머신 드라이버를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcc3765e5b6cbccc69b945d121e72879678bd785" translate="yes" xml:space="preserve">
          <source>For a full list of the flags/settings available and their defaults, see the output of &lt;code&gt;docker-machine create -h&lt;/code&gt; at the command line, the &lt;a href=&quot;../reference/create/index&quot;&gt;create&lt;/a&gt; command in the Machine &lt;a href=&quot;../reference/index&quot;&gt;command line reference&lt;/a&gt;, and &lt;a href=&quot;../drivers/os-base/index&quot;&gt;driver options and operating system defaults&lt;/a&gt; in the Machine driver reference.</source>
          <target state="translated">플래그 / 사용 가능한 설정 및 기본값의 전체 목록의 출력을 참조 &lt;code&gt;docker-machine create -h&lt;/code&gt; (가), 명령 줄에서 &lt;a href=&quot;../reference/create/index&quot;&gt;생성&lt;/a&gt; 머신에서 명령을 &lt;a href=&quot;../reference/index&quot;&gt;명령 줄 참조&lt;/a&gt; 및 &lt;a href=&quot;../drivers/os-base/index&quot;&gt;드라이버 옵션과 운영 시스템 기본값을&lt;/a&gt; 기계 드라이버 참고.</target>
        </trans-unit>
        <trans-unit id="02bf6fa6bb3e32c4f9bb0834d4a8ed5d2922eb8a" translate="yes" xml:space="preserve">
          <source>For a more interesting test, run a Dockerized webserver on your new machine.</source>
          <target state="translated">보다 흥미로운 테스트를 위해 새 컴퓨터에서 Dockerized 웹 서버를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3e4f0e2d2909b9c3de7a0591599d13dbe7d88823" translate="yes" xml:space="preserve">
          <source>For a replicated service, you specify the number of identical tasks you want to run. For example, you decide to deploy an HTTP service with three replicas, each serving the same content.</source>
          <target state="translated">복제 된 서비스의 경우 실행할 동일한 작업 수를 지정합니다. 예를 들어 각각 동일한 콘텐츠를 제공하는 3 개의 복제본이있는 HTTP 서비스를 배포하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="9f50231702efc7479af395282f05f7bd91cdff89" translate="yes" xml:space="preserve">
          <source>For a step-by-step guide on using Machine to create Docker hosts on Digital Ocean, see the &lt;a href=&quot;../examples/ocean/index&quot;&gt;DigitalOcean Example&lt;/a&gt;.</source>
          <target state="translated">Machine을 사용하여 Digital Ocean에서 Docker 호스트를 작성하는 방법에 대한 단계별 안내서는 &lt;a href=&quot;../examples/ocean/index&quot;&gt;DigitalOcean 예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c1f040e62ba21f3108502b13d5895d0b02b9f7c" translate="yes" xml:space="preserve">
          <source>For a step-by-step guide on using Machine to create Dockerized AWS instances, see the &lt;a href=&quot;../examples/aws/index&quot;&gt;Amazon Web Services (AWS) example&lt;/a&gt;.</source>
          <target state="translated">Machine을 사용하여 Dockerized AWS 인스턴스를 생성하는 단계별 지침은 &lt;a href=&quot;../examples/aws/index&quot;&gt;Amazon Web Services (AWS) 예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5af28b648ec0036ec492c739939181d43deb2459" translate="yes" xml:space="preserve">
          <source>For a working example of how to build and use an &lt;code&gt;overlay&lt;/code&gt; network with a service in swarm mode, see the Docker Labs tutorial on &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/A3-overlay-networking/&quot;&gt;Overlay networking and service discovery&lt;/a&gt;.</source>
          <target state="translated">스웜 모드에서 서비스로 &lt;code&gt;overlay&lt;/code&gt; 네트워크 를 구축하고 사용하는 방법에 대한 실제 예는 &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/A3-overlay-networking/&quot;&gt;오버레이 네트워킹 및 서비스 검색&lt;/a&gt; 에 대한 Docker Labs 자습서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ae0bd335974b03456db03f08f9550d51014c762" translate="yes" xml:space="preserve">
          <source>For additional information on working with labels, see &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;&lt;em&gt;Labels - custom metadata in Docker&lt;/em&gt;&lt;/a&gt; in the Docker User Guide.</source>
          <target state="translated">레이블 작업에 대한 추가 정보 는 Docker 사용 설명서의 Docker &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;&lt;em&gt;에서 레이블-사용자 정의 메타 데이터를&lt;/em&gt;&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="164e065852bf7edd5e3976e6f1e47ad1a0fa77b8" translate="yes" xml:space="preserve">
          <source>For all other images, the image name as displayed on Docker Hub, prefixed by &lt;code&gt;docker.io&lt;/code&gt;.</source>
          <target state="translated">다른 모든 이미지의 경우 &lt;code&gt;docker.io&lt;/code&gt; 접두사가 Docker Hub에 표시되는 이미지 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="698142429b77e3b1b97abb32d5eb1fc84336ce60" translate="yes" xml:space="preserve">
          <source>For an example of using the &lt;code&gt;-f&lt;/code&gt; option at the command line, suppose you are running the &lt;a href=&quot;../../rails/index&quot;&gt;Compose Rails sample&lt;/a&gt;, and have a &lt;code&gt;docker-compose.yml&lt;/code&gt; file in a directory called &lt;code&gt;sandbox/rails&lt;/code&gt;. You can use a command like &lt;a href=&quot;../pull/index&quot;&gt;docker-compose pull&lt;/a&gt; to get the postgres image for the &lt;code&gt;db&lt;/code&gt; service from anywhere by using the &lt;code&gt;-f&lt;/code&gt; flag as follows: &lt;code&gt;docker-compose -f ~/sandbox/rails/docker-compose.yml pull db&lt;/code&gt;</source>
          <target state="translated">사용하는 예를 들어 &lt;code&gt;-f&lt;/code&gt; 명령 줄에서 옵션을, 당신은 실행한다고 가정 &lt;a href=&quot;../../rails/index&quot;&gt;작성 레일 샘플을&lt;/a&gt; 하고있는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 라는 디렉토리에 파일 &lt;code&gt;sandbox/rails&lt;/code&gt; . 당신은 같은 명령을 사용하여 &lt;a href=&quot;../pull/index&quot;&gt;고정 표시기-작성 풀&lt;/a&gt; 에 대한 포스트 그레스 이미지를 얻기 위해 &lt;code&gt;db&lt;/code&gt; 사용하여 어디서나 서비스를 &lt;code&gt;-f&lt;/code&gt; 다음과 같이 플래그를 &lt;code&gt;docker-compose -f ~/sandbox/rails/docker-compose.yml pull db&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="224d353aeaa4adc0517d4f2094e35f8b314e8fc9" translate="yes" xml:space="preserve">
          <source>For an in-depth look at how it works under the hood, see the networking concepts lab on the &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/concepts/06-overlay-networks/&quot;&gt;Overlay Driver Network Architecture&lt;/a&gt;.</source>
          <target state="translated">어떻게 작동하는지 자세히 살펴 보려면 &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/concepts/06-overlay-networks/&quot;&gt;오버레이 드라이버 네트워크 아키텍처&lt;/a&gt; 의 네트워킹 개념 연구소를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5431c67341cea28238f50ac412688afe75c321ba" translate="yes" xml:space="preserve">
          <source>For an overview of swarm mode, see &lt;a href=&quot;../key-concepts/index&quot;&gt;Swarm mode key concepts&lt;/a&gt;. For an overview of how services work, see &lt;a href=&quot;../how-swarm-mode-works/services/index&quot;&gt;How services work&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../key-concepts/index&quot;&gt;스웜 모드에&lt;/a&gt; 대한 개요는 스웜 모드 키 개념을 참조하십시오 . 서비스의 작동 방식에 대한 개요를 참조하십시오 &lt;a href=&quot;../how-swarm-mode-works/services/index&quot;&gt;어떻게 서비스 작업&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5086222cf1ea0d4859abd639635eb2ac4e721eb0" translate="yes" xml:space="preserve">
          <source>For any Linux template, you may use the shorter name composed only of the name and version, as shown below.</source>
          <target state="translated">Linux 템플릿의 경우 아래와 같이 이름과 버전으로 만 구성된 짧은 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09bb43634e55c77ed5d3514650cc2104c13ce495" translate="yes" xml:space="preserve">
          <source>For best performance and portability, you should avoid writing important data directly into a container&amp;rsquo;s writable layer, instead using data volumes or bind mounts. This principle also applies to services.</source>
          <target state="translated">최상의 성능과 이식성을 위해서는 데이터 볼륨 또는 바인드 마운트를 사용하는 대신 중요한 데이터를 컨테이너의 쓰기 가능한 계층에 직접 쓰지 않아야합니다. 이 원칙은 서비스에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f99f0d1d6beb7ad4c1c3cc69c002d37520afd0e8" translate="yes" xml:space="preserve">
          <source>For best performance the metadata should be on a different spindle than the data, or even better on an SSD.</source>
          <target state="translated">최상의 성능을 위해서는 메타 데이터가 데이터와 다른 스핀들에 있거나 SSD에 더 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7ee7b77d4a0882f4ac1e7f7c9672ec1fbda8947" translate="yes" xml:space="preserve">
          <source>For client authentication, create a client key and certificate signing request:</source>
          <target state="translated">클라이언트 인증을 위해 클라이언트 키 및 인증서 서명 요청을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4ff88ff5c7d8c60731ee07fbca64ee8ce3a62b02" translate="yes" xml:space="preserve">
          <source>For commands that can potentially hijack the HTTP connection (&lt;code&gt;HTTP Upgrade&lt;/code&gt;), such as &lt;code&gt;exec&lt;/code&gt;, the authorization plugin is only called for the initial HTTP requests. Once the plugin approves the command, authorization is not applied to the rest of the flow. Specifically, the streaming data is not passed to the authorization plugins. For commands that return chunked HTTP response, such as &lt;code&gt;logs&lt;/code&gt; and &lt;code&gt;events&lt;/code&gt;, only the HTTP request is sent to the authorization plugins.</source>
          <target state="translated">&lt;code&gt;exec&lt;/code&gt; 와 같은 HTTP 연결 ( &lt;code&gt;HTTP Upgrade&lt;/code&gt; )을 잠재적으로 납치 할 수있는 명령의 경우, 인증 플러그인은 초기 HTTP 요청에 대해서만 호출됩니다. 플러그인이 명령을 승인하면 권한 부여가 나머지 플로우에 적용되지 않습니다. 특히 스트리밍 데이터는 인증 플러그인으로 전달되지 않습니다. &lt;code&gt;logs&lt;/code&gt; 및 &lt;code&gt;events&lt;/code&gt; 와 같이 청크 된 HTTP 응답을 리턴하는 명령의 경우 HTTP 요청 만 권한 부여 플러그인으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="34abd2d11ef46ad10e7a3110f03bd013efc9c7a8" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;docker-machine&lt;/code&gt; uses sensible defaults for choosing settings such as the image that the server is based on, but you override the defaults using the respective flags, such as &lt;code&gt;--digitalocean-image&lt;/code&gt;. This is useful if, for example, you want to create a cloud server with a lot of memory and CPUs, rather than the default behavior of creating smaller servers.</source>
          <target state="translated">편의상 &lt;code&gt;docker-machine&lt;/code&gt; 은 서버가 기반으로하는 이미지와 같은 설정을 선택하기 위해 합리적인 기본값을 사용하지만 &lt;code&gt;--digitalocean-image&lt;/code&gt; 와 같은 각 플래그를 사용하여 기본값을 재정의합니다 . 예를 들어 작은 서버를 만드는 기본 동작이 아니라 많은 메모리와 CPU가있는 클라우드 서버를 만들려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="286a0c806fd0ce791b00259f7039fdf6c314a01f" translate="yes" xml:space="preserve">
          <source>For detailed information about using secrets, refer to &lt;a href=&quot;../../../swarm/secrets/index&quot;&gt;manage sensitive data with Docker secrets&lt;/a&gt;.</source>
          <target state="translated">비밀 사용에 대한 자세한 정보는 &lt;a href=&quot;../../../swarm/secrets/index&quot;&gt;Docker 비밀&lt;/a&gt; 을 사용하여 민감한 데이터 관리를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="694a779b492c9ba00e460b86a750a2409471112a" translate="yes" xml:space="preserve">
          <source>For detailed information on using &lt;code&gt;ARG&lt;/code&gt; and &lt;code&gt;ENV&lt;/code&gt; instructions, see the &lt;a href=&quot;../../builder/index&quot;&gt;Dockerfile reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ARG&lt;/code&gt; 및 &lt;code&gt;ENV&lt;/code&gt; 명령어 사용에 대한 자세한 내용 은 &lt;a href=&quot;../../builder/index&quot;&gt;Dockerfile 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7bb720cd93e7fcd6976fa80a2516f2894912a1" translate="yes" xml:space="preserve">
          <source>For details about how to use this feature, as well as limitations, see &lt;a href=&quot;../../../security/userns-remap/index&quot;&gt;Isolate containers with a user namespace&lt;/a&gt;.</source>
          <target state="translated">이 기능을 사용하는 방법과 제한 사항에 대한 자세한 내용은 &lt;a href=&quot;../../../security/userns-remap/index&quot;&gt;사용자 네임 스페이스로 컨테이너 격리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d4504d3de98560555b28bad9d66cc9b3ce944b6" translate="yes" xml:space="preserve">
          <source>For details on using production-oriented features, see &lt;a href=&quot;production/index&quot;&gt;compose in production&lt;/a&gt; in this documentation.</source>
          <target state="translated">프로덕션 지향 기능 사용에 대한 자세한 내용 은이 설명서의 &lt;a href=&quot;production/index&quot;&gt;프로덕션 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8c68aee3378ec50eb6e45cf815b4943b0b39db5" translate="yes" xml:space="preserve">
          <source>For details on versions and how to upgrade, see &lt;a href=&quot;index#versioning&quot;&gt;Versioning&lt;/a&gt; and &lt;a href=&quot;index#upgrading&quot;&gt;Upgrading&lt;/a&gt;.</source>
          <target state="translated">버전 및 업그레이드 방법에 대한 자세한 내용은 버전 &lt;a href=&quot;index#versioning&quot;&gt;관리&lt;/a&gt; 및 &lt;a href=&quot;index#upgrading&quot;&gt;업그레이드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aee748905971e1f678b317265cdc67e48045bc8f" translate="yes" xml:space="preserve">
          <source>For each machine you create, the Docker host address is the IP address of the Linux VM. This address is assigned by the &lt;code&gt;docker-machine create&lt;/code&gt; subcommand. You use the &lt;code&gt;docker-machine ls&lt;/code&gt; command to list the machines you have created. The &lt;code&gt;docker-machine ip &amp;lt;machine-name&amp;gt;&lt;/code&gt; command returns a specific host&amp;rsquo;s IP address.</source>
          <target state="translated">생성하는 각 시스템에서 Docker 호스트 주소는 Linux VM의 IP 주소입니다. 이 주소는 &lt;code&gt;docker-machine create&lt;/code&gt; 하위 명령 에 의해 지정됩니다 . &lt;code&gt;docker-machine ls&lt;/code&gt; 명령을 사용하여 생성 한 시스템을 나열합니다. 그만큼 &lt;code&gt;docker-machine ip &amp;lt;machine-name&amp;gt;&lt;/code&gt; 명령은 특정 호스트의 IP 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9459d6465fc0bc6c90c4ecd0a5c4ade3ca2315d2" translate="yes" xml:space="preserve">
          <source>For each replica of the service, the engine requests a volume named &amp;ldquo;my-volume&amp;rdquo; from the default (&amp;ldquo;local&amp;rdquo;) volume driver where the task is deployed. If the volume does not exist, the engine creates a new volume and applies the &amp;ldquo;color&amp;rdquo; and &amp;ldquo;shape&amp;rdquo; labels.</source>
          <target state="translated">서비스의 각 복제본에 대해 엔진은 작업이 배포 된 기본 ( &quot;로컬&quot;) 볼륨 드라이버에서 &quot;my-volume&quot;이라는 볼륨을 요청합니다. 볼륨이 없으면 엔진이 새 볼륨을 만들고 &quot;색상&quot;및 &quot;모양&quot;레이블을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="6e99fb7a7d1989586946c5082ec1ad05e014504f" translate="yes" xml:space="preserve">
          <source>For easy reference, the following list of environment variables are supported by the &lt;code&gt;docker&lt;/code&gt; command line:</source>
          <target state="translated">쉽게 참조 할 수 있도록 다음 환경 변수 목록이 &lt;code&gt;docker&lt;/code&gt; 명령 줄 .</target>
        </trans-unit>
        <trans-unit id="154414a87ee244ef3429961a073b1623eb7c45b7" translate="yes" xml:space="preserve">
          <source>For example to leave the swarm on a worker node:</source>
          <target state="translated">예를 들어 작업자 노드에 무리를 두려면 :</target>
        </trans-unit>
        <trans-unit id="188857146aed5513efbd5f9711e7ae4b5ab3b893" translate="yes" xml:space="preserve">
          <source>For example use &lt;code&gt;[&quot;program&quot;, &quot;arg1&quot;, &quot;arg2&quot;]&lt;/code&gt; not &lt;code&gt;&quot;program arg1 arg2&quot;&lt;/code&gt;. Using the string form causes Docker to run your process using &lt;code&gt;bash&lt;/code&gt; which doesn&amp;rsquo;t handle signals properly. Compose always uses the JSON form, so don&amp;rsquo;t worry if you override the command or entrypoint in your Compose file.</source>
          <target state="translated">예를 들어 &lt;code&gt;&quot;program arg1 arg2&quot;&lt;/code&gt; 가 아닌 &lt;code&gt;[&quot;program&quot;, &quot;arg1&quot;, &quot;arg2&quot;]&lt;/code&gt; . 문자열 형식을 사용하면 Docker가 &lt;code&gt;bash&lt;/code&gt; 를 사용하여 프로세스를 실행합니다. 신호를 올바르게 처리하지 않는 를 . Compose는 항상 JSON 형식을 사용하므로 Compose 파일에서 명령 또는 진입 점을 재정의하더라도 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fa18ec8ff6a597055736afdbee7a3f7b840a1c4b" translate="yes" xml:space="preserve">
          <source>For example you might add something like this:</source>
          <target state="translated">예를 들어 다음과 같이 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3735a5efd056df9559b5bf23dc89b47698731804" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;http://localhost/VolumeDriver.List&lt;/code&gt;</source>
          <target state="translated">예를 들면 다음과 &lt;code&gt;http://localhost/VolumeDriver.List&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9410afdbe46f29ed657ee0ba67d7c3831be8bd8" translate="yes" xml:space="preserve">
          <source>For example, a service set up with &lt;code&gt;--update-parallelism 1 --rollback-parallelism 3&lt;/code&gt; will update one task at a time during a normal update, but during a rollback, 3 tasks at a time will get rolled back. These rollback parameters are respected both during automatic rollbacks and for rollbacks initiated manually using &lt;code&gt;--rollback&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;--update-parallelism 1 --rollback-parallelism 3&lt;/code&gt; 으로 설정된 서비스 는 일반 업데이트 중에 한 번에 하나의 작업을 업데이트하지만 롤백 중에 한 번에 3 개의 작업이 롤백됩니다. 이러한 롤백 매개 변수는 자동 롤백 &lt;code&gt;--rollback&lt;/code&gt; 사용하여 수동으로 시작된 롤백 모두에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="929473a1e11e684957acdb996cfd5c41a1d6f4e7" translate="yes" xml:space="preserve">
          <source>For example, changes to environment variables (which are added after a container is built, but before the container&amp;rsquo;s command is executed) are not updated after restarting.</source>
          <target state="translated">예를 들어, 컨테이너가 빌드 된 후 추가되었지만 컨테이너 명령이 실행되기 전에 추가되는 환경 변수의 변경 사항은 재시작 후에 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1addd6c46201ea5dd56ae7ab185929e68ef8b8f5" translate="yes" xml:space="preserve">
          <source>For example, consider a system with more than three cores. If you start one container &lt;code&gt;{C0}&lt;/code&gt; with &lt;code&gt;-c=512&lt;/code&gt; running one process, and another container &lt;code&gt;{C1}&lt;/code&gt; with &lt;code&gt;-c=1024&lt;/code&gt; running two processes, this can result in the following division of CPU shares:</source>
          <target state="translated">예를 들어 코어가 3 개 이상인 시스템을 생각해보십시오. 하나 개 컨테이너 시작하면 &lt;code&gt;{C0}&lt;/code&gt; 와 &lt;code&gt;-c=512&lt;/code&gt; 은 하나 개의 프로세스를 실행하고, 다른 용기 &lt;code&gt;{C1}&lt;/code&gt; 을 가진 &lt;code&gt;-c=1024&lt;/code&gt; 두 프로세스를 실행하는,이 CPU 공유 다음 분할 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="b2f3cbb7504b8388489227a083e3a11eb5b07b7b" translate="yes" xml:space="preserve">
          <source>For example, consider building the following Dockerfile using &lt;code&gt;--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com&lt;/code&gt;</source>
          <target state="translated">예를 들어 &lt;code&gt;--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com&lt;/code&gt; 을 사용하여 다음 Dockerfile을 빌드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="43683586fd5aff33c8a74fbd57d5c4419f621a16" translate="yes" xml:space="preserve">
          <source>For example, consider these two Dockerfile:</source>
          <target state="translated">예를 들어 다음 두 Dockerfile을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f761d448faf51e489efbfa56295f1ebeb5b7f92c" translate="yes" xml:space="preserve">
          <source>For example, consider this command line:</source>
          <target state="translated">예를 들어, 다음 명령 행을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="81991816c7fa2f977dec203299f1f126cac01a7b" translate="yes" xml:space="preserve">
          <source>For example, consider three containers, one has a cpu-share of 1024 and two others have a cpu-share setting of 512. When processes in all three containers attempt to use 100% of CPU, the first container would receive 50% of the total CPU time. If you add a fourth container with a cpu-share of 1024, the first container only gets 33% of the CPU. The remaining containers receive 16.5%, 16.5% and 33% of the CPU.</source>
          <target state="translated">예를 들어, 3 개의 컨테이너 (하나는 cpu-share가 1024이고 다른 하나는 cpu-share 설정이 512 임)를 고려하십시오. 3 개의 컨테이너 모두에서 프로세스가 CPU의 100 %를 사용하려고하면 첫 번째 컨테이너는 총 CPU 시간. cpu-share가 1024 인 네 번째 컨테이너를 추가하면 첫 번째 컨테이너는 CPU의 33 % 만 가져옵니다. 나머지 컨테이너는 CPU의 16.5 %, 16.5 % 및 33 %를받습니다.</target>
        </trans-unit>
        <trans-unit id="ccf7c444c5d5fb56703ebae64f23ac3f420d9384" translate="yes" xml:space="preserve">
          <source>For example, given the following secret:</source>
          <target state="translated">예를 들어 다음과 같은 비밀이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ed8a037ceec4b25d45ed1622fee4828caf43586" translate="yes" xml:space="preserve">
          <source>For example, given the following service;</source>
          <target state="translated">예를 들어 다음과 같은 서비스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="93cc8290a129b890f3a56506769758068c2fbc7a" translate="yes" xml:space="preserve">
          <source>For example, if the default &lt;code&gt;10.0.0.0/8&lt;/code&gt; range conflicts with already allocated address space in your network, then it is desirable to ensure that networks use a different range without requiring Swarm users to specify each subnet with the &lt;code&gt;--subnet&lt;/code&gt; command.</source>
          <target state="translated">예를 들어, 기본 &lt;code&gt;10.0.0.0/8&lt;/code&gt; 범위가 네트워크에서 이미 할당 된 주소 공간과 충돌하는 경우 Swarm 사용자가 &lt;code&gt;--subnet&lt;/code&gt; 명령으로 각 서브넷을 지정하지 않아도 네트워크가 다른 범위를 사용하도록하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="67f4e51d0c6823f5aedc08a121fe12672dd94886" translate="yes" xml:space="preserve">
          <source>For example, if the machine uses Ubuntu as the underlying operating system, it runs a command similar to &lt;code&gt;sudo apt-get upgrade docker-engine&lt;/code&gt;, because Machine expects Ubuntu machines it manages to use this package. As another example, if the machine uses boot2docker for its OS, this command downloads the latest boot2docker ISO and replace the machine&amp;rsquo;s existing ISO with the latest.</source>
          <target state="translated">예를 들어, 머신이 Ubuntu를 기본 운영 체제로 사용하는 경우 Machine은이 패키지를 사용하는 데 필요한 Ubuntu 머신을 예상하므로 &lt;code&gt;sudo apt-get upgrade docker-engine&lt;/code&gt; 과 유사한 명령을 실행 합니다. 다른 예로, 시스템에서 OS에 boot2docker를 사용하는 경우이 명령은 최신 boot2docker ISO를 다운로드하고 시스템의 기존 ISO를 최신으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="9ce66046739189038b749374187942548cab0c80" translate="yes" xml:space="preserve">
          <source>For example, if the original service defines &lt;code&gt;image: webapp&lt;/code&gt; and the local service defines &lt;code&gt;build: .&lt;/code&gt; then the resulting service has a &lt;code&gt;build: .&lt;/code&gt; and no &lt;code&gt;image&lt;/code&gt; option.</source>
          <target state="translated">예를 들어, 원래 서비스가 &lt;code&gt;image: webapp&lt;/code&gt; 정의하고 로컬 서비스가 &lt;code&gt;build: .&lt;/code&gt; 정의 하는 경우 결과 서비스에는 &lt;code&gt;build: .&lt;/code&gt; &lt;code&gt;image&lt;/code&gt; 옵션이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="99ffaa981af0eedeb459ed96a813a331a5ce2ad6" translate="yes" xml:space="preserve">
          <source>For example, if you follow along with the &lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index&quot;&gt;Swarm mode tutorial&lt;/a&gt; which asks you to create &lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index#three-networked-host-machines&quot;&gt;three networked host machines&lt;/a&gt;, you can create these swarm nodes: &lt;code&gt;manager1&lt;/code&gt;, &lt;code&gt;worker1&lt;/code&gt;, &lt;code&gt;worker2&lt;/code&gt;.</source>
          <target state="translated">당신이 함께 따르는 경우 예를 들어, &lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index&quot;&gt;떼 모드 튜토리얼&lt;/a&gt; 작성을 요청 &lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index#three-networked-host-machines&quot;&gt;세 가지 네트워크 호스트 시스템을&lt;/a&gt; , 당신은이 무리 노드를 만들 수 있습니다 : &lt;code&gt;manager1&lt;/code&gt; , &lt;code&gt;worker1&lt;/code&gt; 에 , &lt;code&gt;worker2&lt;/code&gt; 에를 .</target>
        </trans-unit>
        <trans-unit id="3fd5c1d51615687547df73c7d631a0f825cbaa1b" translate="yes" xml:space="preserve">
          <source>For example, if you named your directory &lt;code&gt;my_wordpress&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 디렉토리라는 이름의 경우 &lt;code&gt;my_wordpress&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="cacd1f4811295ea25a505e6c624c7745bd5b0a2b" translate="yes" xml:space="preserve">
          <source>For example, if you started a container with this command:</source>
          <target state="translated">예를 들어,이 명령으로 컨테이너를 시작한 경우 :</target>
        </trans-unit>
        <trans-unit id="4f3baa4c96da7d1ddf4e2dda43da2a91693162ab" translate="yes" xml:space="preserve">
          <source>For example, if your image is a reusable Python application builder, it will require application source code to be added in a particular directory, and it might require a build script to be called &lt;em&gt;after&lt;/em&gt; that. You can&amp;rsquo;t just call &lt;code&gt;ADD&lt;/code&gt; and &lt;code&gt;RUN&lt;/code&gt; now, because you don&amp;rsquo;t yet have access to the application source code, and it will be different for each application build. You could simply provide application developers with a boilerplate &lt;code&gt;Dockerfile&lt;/code&gt; to copy-paste into their application, but that is inefficient, error-prone and difficult to update because it mixes with application-specific code.</source>
          <target state="translated">예를 들어, 이미지가 재사용 가능한 Python 애플리케이션 빌더 인 경우 특정 디렉토리에 애플리케이션 소스 코드를 추가해야하며 그 &lt;em&gt;후에&lt;/em&gt; 빌드 스크립트를 호출해야 할 수도 있습니다 . 아직 애플리케이션 소스 코드에 액세스 할 수 없으므로 &lt;code&gt;ADD&lt;/code&gt; 및 &lt;code&gt;RUN&lt;/code&gt; 을 호출 할 수 없으며 애플리케이션 빌드마다 다릅니다. 응용 프로그램 개발자에게 응용 프로그램 에 복사하여 붙여 넣을 수 있는 상용구 &lt;code&gt;Dockerfile&lt;/code&gt; 을 제공 할 수 있지만 비효율적이고 오류가 발생하기 쉽고 응용 프로그램 별 코드와 혼합되어 업데이트하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="90a78c6a0dbbdde9d0e73df87b9e7224f895a446" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to load balance between three instances of an HTTP listener. The diagram below shows an HTTP listener service with three replicas. Each of the three instances of the listener is a task in the swarm.</source>
          <target state="translated">예를 들어, HTTP 리스너의 세 인스턴스간에로드 밸런싱을 원한다고 가정하십시오. 아래 다이어그램은 세 개의 복제본이있는 HTTP 리스너 서비스를 보여줍니다. 리스너의 세 가지 인스턴스 각각은 떼의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="f4dbfcff4a6bfe3bc8857e222af481a54046eb19" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to transfer your local directory &lt;code&gt;/Users/&amp;lt;username&amp;gt;/webapp&lt;/code&gt; to a remote machine and bind mount it into a container on the remote host. If the remote user is &lt;code&gt;ubuntu&lt;/code&gt;, use a command like this:</source>
          <target state="translated">예를 들어, 로컬 디렉토리 &lt;code&gt;/Users/&amp;lt;username&amp;gt;/webapp&lt;/code&gt; 을 원격 시스템으로 전송하고이를 원격 호스트의 컨테이너에 바인드 마운트한다고 가정하십시오. 원격 사용자가 &lt;code&gt;ubuntu&lt;/code&gt; 인 경우 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9caa53b34eb8308759c049e6a67f51ff797e27f2" translate="yes" xml:space="preserve">
          <source>For example, in a swarm with &lt;em&gt;5 nodes&lt;/em&gt;, if you lose &lt;em&gt;3 nodes&lt;/em&gt;, you don&amp;rsquo;t have a quorum. Therefore you can&amp;rsquo;t add or remove nodes until you recover one of the unavailable manager nodes or recover the swarm with disaster recovery commands. See &lt;a href=&quot;#recover-from-disaster&quot;&gt;Recover from disaster&lt;/a&gt;.</source>
          <target state="translated">예를 들어, &lt;em&gt;5 개의 노드&lt;/em&gt; 가있는 떼에서 &lt;em&gt;3 개의 노드&lt;/em&gt; 를 잃으면 쿼럼이 없습니다. 따라서 사용 불가능한 관리자 노드 중 하나를 복구하거나 재해 복구 명령으로 떼를 복구 할 때까지 노드를 추가하거나 제거 할 수 없습니다. &lt;a href=&quot;#recover-from-disaster&quot;&gt;재해 복구를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0296843ec1d5473f3328a00514f701c45812e695" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say that you wanted to run a single Notary server instance:</source>
          <target state="translated">예를 들어, 단일 Notary 서버 인스턴스를 실행하려고한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a97c89090dfbc9c2483eeb05a62998440629aefd" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s use &lt;code&gt;-o&lt;/code&gt; or &lt;code&gt;--opt&lt;/code&gt; options to specify an IP address binding when publishing ports:</source>
          <target state="translated">예를 들어, 포트를 게시 할 때 &lt;code&gt;-o&lt;/code&gt; 또는 &lt;code&gt;--opt&lt;/code&gt; 옵션을 사용하여 IP 주소 바인딩을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="12b205b313c8275a5b70e2be24a07f291d7fc3a1" translate="yes" xml:space="preserve">
          <source>For example, run this command to use a directory called &lt;code&gt;docker&lt;/code&gt; in the branch &lt;code&gt;container&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 분기 &lt;code&gt;container&lt;/code&gt; 에서 &lt;code&gt;docker&lt;/code&gt; 라는 디렉토리를 사용하려면이 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="17873e64711d815edf10b0b4d913508a569f8359" translate="yes" xml:space="preserve">
          <source>For example, running &lt;code&gt;docker run -d&lt;/code&gt; will set the value to &lt;code&gt;true&lt;/code&gt;, so your container &lt;strong&gt;will&lt;/strong&gt; run in &amp;ldquo;detached&amp;rdquo; mode, in the background.</source>
          <target state="translated">예를 들어, &lt;code&gt;docker run -d&lt;/code&gt; 를 실행 하면 값이 &lt;code&gt;true&lt;/code&gt; 로 설정되어 컨테이너 &lt;strong&gt;가&lt;/strong&gt; 백그라운드에서 &quot;분리&quot;모드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="297eaf0cc9729550e3b8b00ac959910e971a9c91" translate="yes" xml:space="preserve">
          <source>For example, suppose you have this &lt;code&gt;docker-compose.yml&lt;/code&gt; file from the &lt;a href=&quot;../../rails/index&quot;&gt;Quickstart: Compose and Rails&lt;/a&gt; sample.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;../../rails/index&quot;&gt;빠른 시작 : 작성 및 레일&lt;/a&gt; 샘플의 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일 이 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6185be54f486cceec56c79779506f262c4df4b5" translate="yes" xml:space="preserve">
          <source>For example, suppose your app is in a directory called &lt;code&gt;myapp&lt;/code&gt;, and your &lt;code&gt;docker-compose.yml&lt;/code&gt; looks like this:</source>
          <target state="translated">예를 들어 앱이 &lt;code&gt;myapp&lt;/code&gt; 디렉토리에 있고 &lt;code&gt;docker-compose.yml&lt;/code&gt; 이 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0f36b49dbbf1a5b76e12f4f660c13eeb2bdd76ee" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;../envvars/index#compose_file&quot;&gt;COMPOSE_FILE environment variable&lt;/a&gt; relates to the &lt;code&gt;-f&lt;/code&gt; flag, and &lt;a href=&quot;../envvars/index#compose_project_name&quot;&gt;COMPOSE_PROJECT_NAME environment variable&lt;/a&gt; relates to the &lt;code&gt;-p&lt;/code&gt; flag.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;../envvars/index#compose_file&quot;&gt;COMPOSE_FILE 환경 변수&lt;/a&gt; 는 &lt;code&gt;-f&lt;/code&gt; 플래그와 관련되고 &lt;a href=&quot;../envvars/index#compose_project_name&quot;&gt;COMPOSE_PROJECT_NAME 환경 변수&lt;/a&gt; 는 &lt;code&gt;-p&lt;/code&gt; 플래그 와 관련됩니다 .</target>
        </trans-unit>
        <trans-unit id="236773d8dda420fa66146304077c9e4dda4417b6" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;flocker&lt;/code&gt; plugin might create a UNIX socket at &lt;code&gt;/run/docker/plugins/flocker.sock&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;flocker&lt;/code&gt; 의 플러그인에서 UNIX 소켓을 만들 수 있습니다 &lt;code&gt;/run/docker/plugins/flocker.sock&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b4e3b6190b64b0e1f69a644d1dc881d630f60683" translate="yes" xml:space="preserve">
          <source>For example, the configuration above specifies the default password alias to be &lt;code&gt;passwordalias1&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 위의 구성은 기본 비밀번호 별명을 passwordalias1로 지정 &lt;code&gt;passwordalias1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cac30fc9c71aba134ae70a8a8bd8074aa2fe7aa5" translate="yes" xml:space="preserve">
          <source>For example, the following command publishes port 80 in the nginx container to port 8080 for any node in the swarm:</source>
          <target state="translated">예를 들어 다음 명령은 swgin의 모든 노드에 대해 nginx 컨테이너의 포트 80을 포트 8080에 게시합니다.</target>
        </trans-unit>
        <trans-unit id="9ae86335c1bfeb27534084781c305b2b21baa1c1" translate="yes" xml:space="preserve">
          <source>For example, the following creates a &lt;code&gt;tmpfs&lt;/code&gt; volume called &lt;code&gt;foo&lt;/code&gt; with a size of 100 megabyte and &lt;code&gt;uid&lt;/code&gt; of 1000.</source>
          <target state="translated">예를 들어, 다음은 크기가 100MB이고 &lt;code&gt;uid&lt;/code&gt; 가 1000 인 &lt;code&gt;foo&lt;/code&gt; 라는 &lt;code&gt;tmpfs&lt;/code&gt; 볼륨을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ad4d0c24124b21bd2a1d07a5093bd86963e3a363" translate="yes" xml:space="preserve">
          <source>For example, the following limits tasks for the redis service to nodes where the node type label equals queue:</source>
          <target state="translated">예를 들어, 다음은 redis 서비스에 대한 작업을 노드 유형 레이블이 대기열과 같은 노드로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="9c87de7737e213ff0ae2b5afab0c3c574ca391e0" translate="yes" xml:space="preserve">
          <source>For example, the following will start nginx with its default content, listening on port 80:</source>
          <target state="translated">예를 들어, 다음은 기본 컨텐츠로 nginx를 시작하고 포트 80에서 수신 대기합니다.</target>
        </trans-unit>
        <trans-unit id="3dab00e0e39b837859de1b519f5dc22305231205" translate="yes" xml:space="preserve">
          <source>For example, to add a &lt;code&gt;type&lt;/code&gt; label to identify nodes where the scheduler should deploy message queue service tasks:</source>
          <target state="translated">예를 들어, 스케줄러가 메시지 큐 서비스 태스크를 배치해야하는 노드를 식별하기 위해 &lt;code&gt;type&lt;/code&gt; 레이블 을 추가 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="deb6b1dc72c1c6cf36c3bea5d09aab1e5584b6f7" translate="yes" xml:space="preserve">
          <source>For example, to change a manager node to &lt;code&gt;Drain&lt;/code&gt; availability:</source>
          <target state="translated">예를 들어,에 관리자 노드 변경 &lt;code&gt;Drain&lt;/code&gt; 가용성 :</target>
        </trans-unit>
        <trans-unit id="c07e894b09764511a69589296e6c36e7c5070d46" translate="yes" xml:space="preserve">
          <source>For example, to check every five minutes or so that a web-server is able to serve the site&amp;rsquo;s main page within three seconds:</source>
          <target state="translated">예를 들어, 웹 서버가 3 초 이내에 사이트의 기본 페이지를 제공 할 수 있도록 5 분마다 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="dbaac476e081b5f78a913c84fad2d379db534393" translate="yes" xml:space="preserve">
          <source>For example, to connect using OpenSSL:</source>
          <target state="translated">예를 들어 OpenSSL을 사용하여 연결하려면</target>
        </trans-unit>
        <trans-unit id="ca16e922069fc63da9a1fde9da1dbd1fe6b86f91" translate="yes" xml:space="preserve">
          <source>For example, to create an instance from the latest Ubuntu 16 LTS image, specify &lt;code&gt;https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/family/ubuntu-1604-lts&lt;/code&gt;.</source>
          <target state="translated">예를 들어 최신 Ubuntu 16 LTS 이미지에서 인스턴스를 만들려면 &lt;code&gt;https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/family/ubuntu-1604-lts&lt;/code&gt; 를 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd7cd8af0ea65c62a417b6317fa1839fc5be13ac" translate="yes" xml:space="preserve">
          <source>For example, to list all images in the &amp;ldquo;java&amp;rdquo; repository, run this command :</source>
          <target state="translated">예를 들어, &quot;java&quot;저장소의 모든 이미지를 나열하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f4db7861ce1d3fb8918f7977c719cb59be568c67" translate="yes" xml:space="preserve">
          <source>For example, to use &lt;code&gt;wait-for-it.sh&lt;/code&gt; or &lt;code&gt;wait-for&lt;/code&gt; to wrap your service&amp;rsquo;s command:</source>
          <target state="translated">예를 들어, &lt;code&gt;wait-for-it.sh&lt;/code&gt; 또는 &lt;code&gt;wait-for&lt;/code&gt; 를 사용하여 서비스 명령을 랩핑하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d2623db0d0e2d09f8a17269bbb968dea5e914431" translate="yes" xml:space="preserve">
          <source>For example, when a container exits, its associated thin device is removed. If that device has leaked into some other mount namespace and can&amp;rsquo;t be removed, the container exit still succeeds and this option causes the system to schedule the device for deferred removal. It does not wait in a loop trying to remove a busy device.</source>
          <target state="translated">예를 들어, 컨테이너가 종료되면 연관된 얇은 장치가 제거됩니다. 해당 장치가 다른 마운트 네임 스페이스로 누출되어 제거 할 수없는 경우 컨테이너 종료는 여전히 성공하며이 옵션으로 인해 시스템이 지연된 제거를 위해 장치를 예약합니다. 사용중인 장치를 제거하려고 루프를 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20609fc6f521d91e7d34b7cc3171302ab5bea485" translate="yes" xml:space="preserve">
          <source>For example, when running this command on Mac 10.13.2, place the completion script in &lt;code&gt;/usr/local/etc/bash_completion.d/&lt;/code&gt;.</source>
          <target state="translated">예를 들어, Mac 10.13.2에서이 명령을 실행할 때 완료 스크립트를 &lt;code&gt;/usr/local/etc/bash_completion.d/&lt;/code&gt; 에 두십시오 .</target>
        </trans-unit>
        <trans-unit id="7e36a0467a1f46422bc62de5d3f37912a4051ced" translate="yes" xml:space="preserve">
          <source>For example, with DCT enabled a &lt;code&gt;docker pull someimage:latest&lt;/code&gt; only succeeds if &lt;code&gt;someimage:latest&lt;/code&gt; is signed. However, an operation with an explicit content hash always succeeds as long as the hash exists:</source>
          <target state="translated">예를 들어, DCT가 활성화 된 경우 &lt;code&gt;docker pull someimage:latest&lt;/code&gt; &lt;code&gt;someimage:latest&lt;/code&gt; 는 someimage : latest 가 서명 된 경우에만 성공합니다 . 그러나 명시 적 컨텐츠 해시가있는 조작은 항상 해시가 존재하는 한 성공합니다.</target>
        </trans-unit>
        <trans-unit id="db0942a188496bc0871a311383cc4e4b29b2fff4" translate="yes" xml:space="preserve">
          <source>For example, you can set:</source>
          <target state="translated">예를 들어 다음을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44379329a386f8515196e574d47d30bdca5373d2" translate="yes" xml:space="preserve">
          <source>For example, you can specify either &lt;code&gt;/foo&lt;/code&gt; or &lt;code&gt;foo&lt;/code&gt; for a &lt;code&gt;host-src&lt;/code&gt; value. If you supply the &lt;code&gt;/foo&lt;/code&gt; value, Docker creates a bind mount. If you supply the &lt;code&gt;foo&lt;/code&gt; specification, Docker creates a named volume.</source>
          <target state="translated">예를 들어 &lt;code&gt;host-src&lt;/code&gt; 값으로 &lt;code&gt;/foo&lt;/code&gt; 또는 &lt;code&gt;foo&lt;/code&gt; 를 지정할 수 있습니다 . 당신이 제공하는 경우 &lt;code&gt;/foo&lt;/code&gt; 는의 값을 고정 표시기 바인드 마운트 만듭니다. &lt;code&gt;foo&lt;/code&gt; 사양 을 제공하면 Docker는 명명 된 볼륨을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62884713c46b5d6247319e2bb37008efbf289db1" translate="yes" xml:space="preserve">
          <source>For full Kubernetes Integration</source>
          <target state="translated">전체 Kubernetes 통합</target>
        </trans-unit>
        <trans-unit id="d5366cba2c8355a098d3bb1b98810ef287dc0d86" translate="yes" xml:space="preserve">
          <source>For full details of the network configuration options available, see the following references:</source>
          <target state="translated">사용 가능한 네트워크 구성 옵션에 대한 자세한 내용은 다음 참조를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea39178cf82e6f8359776ff35ccf95f1466ca5e1" translate="yes" xml:space="preserve">
          <source>For full specific configuration information, see the configuration files for the Notary &lt;a href=&quot;../server-config/index&quot;&gt;server&lt;/a&gt; or &lt;a href=&quot;../signer-config/index&quot;&gt;signer&lt;/a&gt;.</source>
          <target state="translated">전체 특정 구성 정보는 Notary &lt;a href=&quot;../server-config/index&quot;&gt;서버&lt;/a&gt; 또는 &lt;a href=&quot;../signer-config/index&quot;&gt;서명자&lt;/a&gt; 의 구성 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="713751e2adddd25f8b0c472c5310ea15ed5e767a" translate="yes" xml:space="preserve">
          <source>For in-depth information about volumes, refer to &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;manage data in containers&lt;/a&gt;</source>
          <target state="translated">볼륨에 대한 자세한 정보 &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;는 컨테이너의 데이터 관리를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b28c0f92ae03372b2ccefbf1c96430d92320886e" translate="yes" xml:space="preserve">
          <source>For information about how to create an authorization plugin, see &lt;a href=&quot;../../../extend/plugins_authorization/index&quot;&gt;authorization plugin&lt;/a&gt; section in the Docker extend section of this documentation.</source>
          <target state="translated">인증 플러그인을 작성하는 방법에 대한 정보 는이 문서의 Docker 확장 섹션에서 &lt;a href=&quot;../../../extend/plugins_authorization/index&quot;&gt;인증 플러그인&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="76211605a0a0c6ec24d5b566af61764b6f4add38" translate="yes" xml:space="preserve">
          <source>For information about maintaining a quorum and disaster recovery, refer to the &lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm administration guide&lt;/a&gt;.</source>
          <target state="translated">쿼럼 및 재해 복구 유지 관리에 대한 자세한 내용은 &lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm 관리 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="150b94c4964196da1cd7cfaf1b9a970f38966263" translate="yes" xml:space="preserve">
          <source>For information about the legacy plugin system available in Docker Engine 1.12 and earlier, see &lt;a href=&quot;legacy_plugins/index&quot;&gt;Understand legacy Docker Engine plugins&lt;/a&gt;.</source>
          <target state="translated">Docker Engine 1.12 및 이전 버전에서 사용 가능한 레거시 플러그인 시스템에 대한 정보는 &lt;a href=&quot;legacy_plugins/index&quot;&gt;레거시 Docker 엔진 플러그인 이해를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51e4c9ca46c388ac786568ecee3b5d8825b52360" translate="yes" xml:space="preserve">
          <source>For information on connecting a container to a network, see the &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&amp;ldquo;&lt;em&gt;Docker network overview&lt;/em&gt;&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">컨테이너를 네트워크에 연결하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&amp;ldquo; &lt;em&gt;Docker 네트워크 개요&lt;/em&gt; &amp;rdquo;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82d698c77013162ff08eb58d4f59087a71fbaf03" translate="yes" xml:space="preserve">
          <source>For instance, if you wanted to override the storage URL of the Notary server configuration:</source>
          <target state="translated">예를 들어, Notary 서버 구성의 스토리지 URL을 대체하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="29602251a011cb230da3e546ff699c26cee82685" translate="yes" xml:space="preserve">
          <source>For interacting with the network stack, instead of using &lt;code&gt;--privileged&lt;/code&gt; they should use &lt;code&gt;--cap-add=NET_ADMIN&lt;/code&gt; to modify the network interfaces.</source>
          <target state="translated">네트워크 스택과 상호 작용, 대신에 사용하기 위해 &lt;code&gt;--privileged&lt;/code&gt; 그들이 사용한다 &lt;code&gt;--cap-add=NET_ADMIN&lt;/code&gt; 네트워크 인터페이스를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f48e10fad25c7d1d56dfd91b749873d9a11df4a" translate="yes" xml:space="preserve">
          <source>For interactive processes (like a shell), you must use &lt;code&gt;-i -t&lt;/code&gt; together in order to allocate a tty for the container process. &lt;code&gt;-i -t&lt;/code&gt; is often written &lt;code&gt;-it&lt;/code&gt; as you&amp;rsquo;ll see in later examples. Specifying &lt;code&gt;-t&lt;/code&gt; is forbidden when the client is receiving its standard input from a pipe, as in:</source>
          <target state="translated">쉘과 같은 대화식 프로세스의 경우 컨테이너 프로세스에 tty를 할당 하려면 &lt;code&gt;-i -t&lt;/code&gt; 를 함께 사용해야 합니다. &lt;code&gt;-i -t&lt;/code&gt; 는 종종 작성 &lt;code&gt;-it&lt;/code&gt; 나중에 예에서 볼 수있다. 클라이언트가 파이프에서 표준 입력을 수신 할 때 다음과 같이 &lt;code&gt;-t&lt;/code&gt; 를 지정하는 것은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="19f5fd22c7c5ad54b6fa1edeaffe520af48ab5f3" translate="yes" xml:space="preserve">
          <source>For machines other than &lt;code&gt;default&lt;/code&gt;, and commands other than those listed above, you must always specify the name explicitly as an argument.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 이외의 머신 및 위에 나열된 머신 이외의 명령의 경우 항상 이름을 인수로 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd3268db578d58ee0de7ce51652a0f5e6a13f533" translate="yes" xml:space="preserve">
          <source>For master builds and nightly feature releases refer to the description in &lt;a href=&quot;https://github.com/moby/buildkit/blob/master/README/&quot;&gt;the source repository&lt;/a&gt;.</source>
          <target state="translated">마스터 빌드 및 야간 기능 릴리스에 &lt;a href=&quot;https://github.com/moby/buildkit/blob/master/README/&quot;&gt;대해서는 소스 저장소&lt;/a&gt; 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0b8a5e74f32e400ed8611cf5a56c405023c97c2" translate="yes" xml:space="preserve">
          <source>For more detail about swarm managers and administering a swarm, see &lt;a href=&quot;../admin_guide/index&quot;&gt;Administer and maintain a swarm of Docker Engines&lt;/a&gt;.</source>
          <target state="translated">스웜 관리자 및 스웜 관리에 대한 자세한 내용은 &lt;a href=&quot;../admin_guide/index&quot;&gt;Docker Engine 스웜 관리 및 유지 관리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="134c4195deaf16fa4afe60d19497958bd97f48c1" translate="yes" xml:space="preserve">
          <source>For more detailed documentation about how to deploy Notary Server, see the &lt;a href=&quot;../../../../notary/running_a_service/index&quot;&gt;instructions to run a Notary service&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/theupdateframework/notary&quot;&gt;the Notary repository&lt;/a&gt; for more information.</source>
          <target state="translated">Notary Server를 배포하는 방법에 대한 자세한 내용 &lt;a href=&quot;https://github.com/theupdateframework/notary&quot;&gt;은 Notary 저장소&lt;/a&gt; 뿐만 아니라 &lt;a href=&quot;../../../../notary/running_a_service/index&quot;&gt;Notary 서비스 실행 지침을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b30c9a2e4a09e6f66ccfb38de04c2abb1c6cd1ca" translate="yes" xml:space="preserve">
          <source>For more detailed information about how to use notary outside of the Docker Content Trust use cases, refer to the Notary CLI documentation &lt;a href=&quot;https://github.com/theupdateframework/notary/blob/master/docs/command_reference/&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Docker Content Trust 사용 사례 외부에서 공증인을 사용하는 방법에 대한 자세한 정보는 공증인 CLI 문서를 참조 &lt;a href=&quot;https://github.com/theupdateframework/notary/blob/master/docs/command_reference/&quot;&gt;하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34b0237bd57dcea366952be6342f40204d71828c" translate="yes" xml:space="preserve">
          <source>For more details about image tag resolution, see &lt;a href=&quot;#specify-the-image-version-the-service-should-use&quot;&gt;Specify the image version the service should use&lt;/a&gt;.</source>
          <target state="translated">이미지 태그 해상도에 대한 자세한 내용은 &lt;a href=&quot;#specify-the-image-version-the-service-should-use&quot;&gt;서비스에서 사용해야하는 이미지 버전 지정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c2220c6d906eac94e4990dfc6192b5a0530d0f6" translate="yes" xml:space="preserve">
          <source>For more information about bind propagation, see the &lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt&quot;&gt;Linux kernel documentation for shared subtree&lt;/a&gt;.</source>
          <target state="translated">바인드 전파에 대한 자세한 정보는 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt&quot;&gt;공유 서브 트리에 대한 Linux 커널 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54b72b23989ff742f32784ce9fa32d4045faf424" translate="yes" xml:space="preserve">
          <source>For more information about different Docker Enterprise license types visit https://www.docker.com/licenses</source>
          <target state="translated">다양한 Docker Enterprise 라이센스 유형에 대한 자세한 내용은 https://www.docker.com/licenses를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="163d01a43b8e15f4f16909e5fa7ea056432b9d16" translate="yes" xml:space="preserve">
          <source>For more information about images, layers, and the content-addressable store, refer to &lt;a href=&quot;https://docs.docker.com/storage/storagedriver&quot;&gt;understand images, containers, and storage drivers&lt;/a&gt;.</source>
          <target state="translated">이미지, 레이어 및 컨텐츠 주소 지정 가능 저장소에 대한 자세한 정보는 이미지 &lt;a href=&quot;https://docs.docker.com/storage/storagedriver&quot;&gt;, 컨테이너 및 스토리지 드라이버 이해를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca8bfe82f612148bd629c13ee21d41ccbdf4e2f" translate="yes" xml:space="preserve">
          <source>For more information about installing Docker or &lt;code&gt;sudo&lt;/code&gt; configuration, refer to the &lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;installation&lt;/a&gt; instructions for your operating system.</source>
          <target state="translated">Docker 또는 &lt;code&gt;sudo&lt;/code&gt; 구성 설치에 대한 자세한 정보는 운영 체제 의 &lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;설치&lt;/a&gt; 지시 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ed4ff4d7b46567091de3a223f0ee0e2f538d82d" translate="yes" xml:space="preserve">
          <source>For more information about labels, refer to &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;apply custom metadata&lt;/a&gt;.</source>
          <target state="translated">레이블에 대한 자세한 정보는 &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;사용자 정의 메타 데이터 적용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25e34ad8487594394f5ece7c14ddc89ecb38552d" translate="yes" xml:space="preserve">
          <source>For more information about named volumes, see &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;Data Volumes&lt;/a&gt;.</source>
          <target state="translated">명명 된 볼륨에 대한 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;데이터 볼륨을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03a45d6fe2bf7af80fd96d02c68acaf012abec50" translate="yes" xml:space="preserve">
          <source>For more information about selecting and configuring logging drivers, refer to &lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;Configure logging drivers&lt;/a&gt;.</source>
          <target state="translated">로깅 드라이버 선택 및 구성에 대한 자세한 정보는 로깅 드라이버 &lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc8fdcbc11fbf20d689346ce17623c4db599f8cd" translate="yes" xml:space="preserve">
          <source>For more information about selecting and configuring logging drivers, refer to &lt;a href=&quot;https://docs.docker.com/config/containers/logging/configure/&quot;&gt;Configure logging drivers&lt;/a&gt;.</source>
          <target state="translated">로깅 드라이버 선택 및 구성에 대한 자세한 정보는 로깅 드라이버 &lt;a href=&quot;https://docs.docker.com/config/containers/logging/configure/&quot;&gt;구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2b2956e44cdcc786cd2c54702b01eb0a12185c9" translate="yes" xml:space="preserve">
          <source>For more information about the Compose file, see the &lt;a href=&quot;compose-file/index&quot;&gt;Compose file reference&lt;/a&gt;.</source>
          <target state="translated">작성 파일에 대한 자세한 정보는 &lt;a href=&quot;compose-file/index&quot;&gt;작성 파일 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9d53ab6fabb14595d4358e40785585a79adb1ce" translate="yes" xml:space="preserve">
          <source>For more information and resources, visit &lt;a href=&quot;https://docs.docker.com/opensource&quot;&gt;our help page&lt;/a&gt;.</source>
          <target state="translated">자세한 정보와 자료는 &lt;a href=&quot;https://docs.docker.com/opensource&quot;&gt;도움말 페이지를&lt;/a&gt; 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="af00edf9585c9e9c647d4a7f140d2a889676e716" translate="yes" xml:space="preserve">
          <source>For more information and resources, visit the &lt;a href=&quot;https://docs.docker.com/opensource&quot;&gt;Getting Help project page&lt;/a&gt;.</source>
          <target state="translated">자세한 정보와 리소스를 보려면 &lt;a href=&quot;https://docs.docker.com/opensource&quot;&gt;도움말 얻기 프로젝트 페이지를&lt;/a&gt; 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4b204aa89e744ecce7c53f675ec1b36ef051a9e" translate="yes" xml:space="preserve">
          <source>For more information on configs, see &lt;a href=&quot;../../engine/swarm/configs/index&quot;&gt;configs&lt;/a&gt;.</source>
          <target state="translated">CONFIGS에 대한 자세한 내용은 &lt;a href=&quot;../../engine/swarm/configs/index&quot;&gt;CONFIGS을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9226fb6709780377051ee0ef78785ad9d7e3485d" translate="yes" xml:space="preserve">
          <source>For more information on configuring Docker Content Trust Signature Verificiation, go to &lt;a href=&quot;../trust/content_trust/index&quot;&gt;Content trust in Docker&lt;/a&gt;.</source>
          <target state="translated">도커 컨텐츠 신뢰 서명 Verificiation을 구성하는 방법에 대한 자세한 내용은 이동 &lt;a href=&quot;../trust/content_trust/index&quot;&gt;도커의 내용 신뢰&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8cf03f019ce23577ddec42e109abde3bb6a6d4e" translate="yes" xml:space="preserve">
          <source>For more information on constraints, refer to the &lt;code&gt;docker service create&lt;/code&gt;&lt;a href=&quot;../../reference/commandline/service_create/index&quot;&gt;CLI reference&lt;/a&gt;.</source>
          <target state="translated">제한 조건에 대한 자세한 정보는 &lt;code&gt;docker service create&lt;/code&gt; &lt;a href=&quot;../../reference/commandline/service_create/index&quot;&gt;CLI reference를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b07196d6d5b559b457b5886fee3d0998b43732b" translate="yes" xml:space="preserve">
          <source>For more information on how publishing ports works, see &lt;a href=&quot;#publish-ports&quot;&gt;publish ports&lt;/a&gt;.</source>
          <target state="translated">어떻게 게시 포트의 작동에 대한 자세한 내용은 &lt;a href=&quot;#publish-ports&quot;&gt;포트를 게시&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67e085bf46dc5fc5519747f667353d4093decedb" translate="yes" xml:space="preserve">
          <source>For more information on how to create data volumes and the use of volume drivers, see &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;Use volumes&lt;/a&gt;.</source>
          <target state="translated">데이터 볼륨을 작성하는 방법과 볼륨 드라이버 사용에 대한 자세한 정보는 볼륨 사용을 참조 &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14665ae278648b3b2a8e6c22584f8e466bcb77c9" translate="yes" xml:space="preserve">
          <source>For more information on how to write Dockerfiles, see the &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker user guide&lt;/a&gt; and the &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile reference&lt;/a&gt;.</source>
          <target state="translated">Dockerfile 작성 방법에 대한 자세한 정보는 &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker 사용자 안내서&lt;/a&gt; 및 &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="580e352f4fee900b98b9b0153f6ef8135654e219" translate="yes" xml:space="preserve">
          <source>For more information on joining a manager node to a swarm, refer to &lt;a href=&quot;../join-nodes/index&quot;&gt;Join nodes to a swarm&lt;/a&gt;.</source>
          <target state="translated">떼에 관리자 노드를 가입에 대한 자세한 내용을 참조 &lt;a href=&quot;../join-nodes/index&quot;&gt;떼에 노드를 가입&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a40d49d3f5ee7312495a34d145fbffef34a195f4" translate="yes" xml:space="preserve">
          <source>For more information on overlay networking and service discovery, refer to &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Attach services to an overlay network&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker swarm mode overlay network security model&lt;/a&gt;.</source>
          <target state="translated">오버레이 네트워킹 및 서비스 발견에 대한 자세한 정보는 오버레이 네트워크에 서비스 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;첨부&lt;/a&gt; 및 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker swarm 모드 오버레이 네트워크 보안 모델을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28fb44e7b42617f37524d51315f58a226b620824" translate="yes" xml:space="preserve">
          <source>For more information on secrets, see &lt;a href=&quot;../../engine/swarm/secrets/index&quot;&gt;secrets&lt;/a&gt;.</source>
          <target state="translated">비밀에 대한 자세한 내용은 &lt;a href=&quot;../../engine/swarm/secrets/index&quot;&gt;비밀을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8fdd03484f4c1f12e8b30bff6aeb11dad6801da" translate="yes" xml:space="preserve">
          <source>For more information on swarm administration refer to the &lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm administration guide&lt;/a&gt;.</source>
          <target state="translated">swarm 관리에 대한 자세한 내용은 &lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm 관리 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="559e4b57ccf6139096cf34f9a5cde88d91a26161" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../compose-file/index#variable-substitution&quot;&gt;Variable substitution&lt;/a&gt; section in the Compose file reference.</source>
          <target state="translated">자세한 정보 는 파일 작성 참조의 &lt;a href=&quot;../compose-file/index#variable-substitution&quot;&gt;변수 대체&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8835d197ca0f0b5e45bb83fcc1597e7703a11106" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt&quot;&gt;CFS documentation on bandwidth limiting&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt&quot;&gt;은 대역폭 제한에&lt;/a&gt; 대한 CFS 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f2c8a684147f911b3b8f0c4a85548b408dcb738" translate="yes" xml:space="preserve">
          <source>For more on &lt;code&gt;extends&lt;/code&gt;, see the &lt;a href=&quot;../../extends/index#extending-services&quot;&gt;the extends documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 에 대한 자세한 내용 &lt;a href=&quot;../../extends/index#extending-services&quot;&gt;은 확장 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="271a8641a024a42a950327ed78bedf5647fa3569" translate="yes" xml:space="preserve">
          <source>For most use cases, multi-stage builds are a better alternative, as they give more fine-grained control over your build, and can take advantage of future optimizations in the builder. Refer to the &lt;a href=&quot;https://docs.docker.com/develop/develop-images/multistage-build/&quot;&gt;use multi-stage builds&lt;/a&gt; section in the userguide for more information.</source>
          <target state="translated">대부분의 사용 사례에서 다단계 빌드는 빌드를보다 세밀하게 제어하고 빌더에서 향후 최적화를 활용할 수 있으므로 더 나은 대안입니다. 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/develop/develop-images/multistage-build/&quot;&gt;사용 설명서의 다단계 빌드 사용&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b0d16b1fba86dedb1acc7c4f1ad72e57ee711bd" translate="yes" xml:space="preserve">
          <source>For non-interactive scriptable deployments, download your license from https://hub.docker.com/ then specify the file with the &amp;lsquo;--license&amp;rsquo; flag.</source>
          <target state="translated">비 대화식 스크립트 가능 배포의 경우 https://hub.docker.com/에서 라이센스를 다운로드 한 다음 '--license'플래그로 파일을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="60a96dc8277b211e383d9bc9390440d2cfc2930c" translate="yes" xml:space="preserve">
          <source>For now, however, if you want to create &lt;em&gt;multiple&lt;/em&gt; local machines, you still need Docker Machine to create and manage machines for multi-node experimentation. Both Docker Desktop for Mac and Docker Desktop for Windows include the newest version of Docker Machine, so when you install either of these, you get &lt;code&gt;docker-machine&lt;/code&gt;.</source>
          <target state="translated">그러나 지금은 &lt;em&gt;여러&lt;/em&gt; 로컬 머신 을 생성 &lt;em&gt;하려면&lt;/em&gt; 멀티 노드 실험을위한 머신을 생성하고 관리하려면 여전히 Docker Machine이 필요합니다. Mac 용 Docker Desktop과 Windows 용 Docker Desktop에는 최신 버전의 Docker Machine이 포함되어 있으므로 둘 중 하나를 설치하면 &lt;code&gt;docker-machine&lt;/code&gt; 이 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="c95e03d75f152dabaf7a06018ed438672c440840" translate="yes" xml:space="preserve">
          <source>For official images (identifiable by the &amp;ldquo;Official Image&amp;rdquo; moniker), the image name as displayed on Docker Hub, prefixed with &lt;code&gt;docker.io/library/&lt;/code&gt;. For example, if you would normally type &lt;code&gt;docker pull ubuntu&lt;/code&gt; you must enter &lt;code&gt;notary {cmd} docker.io/library/ubuntu&lt;/code&gt;.</source>
          <target state="translated">공식 이미지 ( &quot;공식 이미지&quot;모니 &lt;code&gt;docker.io/library/&lt;/code&gt; 식별 가능)의 경우 이미지 이름은 docker.io/library/ 접두사가 Docker Hub에 표시됩니다 . 예를 들어, 일반적으로 &lt;code&gt;docker pull ubuntu&lt;/code&gt; 를 입력하려면 &lt;code&gt;notary {cmd} docker.io/library/ubuntu&lt;/code&gt; 입력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dab95a5874153c9e1a31615cb63e34d284d71754" translate="yes" xml:space="preserve">
          <source>For our example, the commands are:</source>
          <target state="translated">이 예에서 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2f05049fcc859cd3e98045f52b1fdfe4fb64443" translate="yes" xml:space="preserve">
          <source>For single-value options like &lt;code&gt;image&lt;/code&gt;, &lt;code&gt;command&lt;/code&gt; or &lt;code&gt;mem_limit&lt;/code&gt;, the new value replaces the old value.</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; , &lt;code&gt;command&lt;/code&gt; 또는 &lt;code&gt;mem_limit&lt;/code&gt; 와 같은 단일 값 옵션의 경우 새 값이 이전 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="1d0a2cb815145a86f819db52409f285ede37c561" translate="yes" xml:space="preserve">
          <source>For systems that have recent aufs version (i.e., &lt;code&gt;dirperm1&lt;/code&gt; mount option can be set), docker will attempt to fix the issue automatically by mounting the layers with &lt;code&gt;dirperm1&lt;/code&gt; option. More details on &lt;code&gt;dirperm1&lt;/code&gt; option can be found at &lt;a href=&quot;https://github.com/sfjro/aufs3-linux/tree/aufs3.18/Documentation/filesystems/aufs&quot;&gt;&lt;code&gt;aufs&lt;/code&gt; man page&lt;/a&gt;</source>
          <target state="translated">최근 aufs 버전이있는 시스템 (예 : &lt;code&gt;dirperm1&lt;/code&gt; 마운트 옵션을 설정할 수 있음)의 경우, docker는 &lt;code&gt;dirperm1&lt;/code&gt; 옵션으로 레이어를 마운트하여 문제를 자동으로 해결하려고 시도합니다 . &lt;code&gt;dirperm1&lt;/code&gt; 옵션 에 대한 자세한 내용 은 &lt;a href=&quot;https://github.com/sfjro/aufs3-linux/tree/aufs3.18/Documentation/filesystems/aufs&quot;&gt; &lt;code&gt;aufs&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c7aceccd97e71a3bff5b3e627905c415a89ae3d7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;targets/releases&lt;/code&gt; delegation role to sign content, the delegation user must possess the private key corresponding to this public key. This command restricts this delegation to only publish content under pathnames prefixed by &lt;code&gt;delegation/path&lt;/code&gt;. With the given path of &amp;ldquo;delegation/path&amp;rdquo;, the &lt;code&gt;targets/releases&lt;/code&gt; role could sign paths like &amp;ldquo;delegation/path/content.txt&amp;rdquo;, &amp;ldquo;delegation/path_file.txt&amp;rdquo; and &amp;ldquo;delegation/path.txt&amp;rdquo;. You can add more paths in a comma-separated list under &lt;code&gt;--paths&lt;/code&gt;, or pass the &lt;code&gt;--all-paths&lt;/code&gt; flag to allow this delegation to publish content under any pathname.</source>
          <target state="translated">를 들어 &lt;code&gt;targets/releases&lt;/code&gt; 기호 콘텐츠에 위임 역할 위임 사용자는이 공개 키에 해당하는 개인 키를 가지고 있어야합니다. 이 명령은이 위임이 &lt;code&gt;delegation/path&lt;/code&gt; 접두사가 붙은 경로 이름으로 만 컨텐츠를 공개하도록 제한 합니다 . 지정된 &quot;delegation / path&quot;경로를 사용하여 &lt;code&gt;targets/releases&lt;/code&gt; 역할은 &quot;delegation / path / content.txt&quot;, &quot;delegation / path_file.txt&quot;및 &quot;delegation / path.txt&quot;와 같은 경로에 서명 할 수 있습니다. &lt;code&gt;--paths&lt;/code&gt; 아래에 쉼표로 구분 된 목록에 더 많은 경로를 추가 하거나 &lt;code&gt;--all-paths&lt;/code&gt; 플래그를 전달 하여이 위임이 임의의 경로 이름으로 컨텐츠를 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbb8305cc3ce54466b6cd1be8dd158891b03417c" translate="yes" xml:space="preserve">
          <source>For the &lt;strong&gt;multi-value options&lt;/strong&gt;&lt;code&gt;ports&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt;, &lt;code&gt;external_links&lt;/code&gt;, &lt;code&gt;dns&lt;/code&gt;, &lt;code&gt;dns_search&lt;/code&gt;, and &lt;code&gt;tmpfs&lt;/code&gt;, Compose concatenates both sets of values:</source>
          <target state="translated">들어 &lt;strong&gt;다치 옵션 &lt;/strong&gt; &lt;code&gt;ports&lt;/code&gt; , &lt;code&gt;expose&lt;/code&gt; , &lt;code&gt;external_links&lt;/code&gt; , &lt;code&gt;dns&lt;/code&gt; , &lt;code&gt;dns_search&lt;/code&gt; 과 &lt;code&gt;tmpfs&lt;/code&gt; 작성하고이 두 값을 연결 세트 :</target>
        </trans-unit>
        <trans-unit id="8ba6752ae0cdb31055e57ee9cc71aa5ba9ea1e74" translate="yes" xml:space="preserve">
          <source>For the full set of available filters and expressions, see the &lt;a href=&quot;https://docs.docker.com/swarm/scheduler/filter/&quot;&gt;Swarm documentation&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 전체 필터 및 표현식 세트는 &lt;a href=&quot;https://docs.docker.com/swarm/scheduler/filter/&quot;&gt;Swarm 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9b4e65b35dc4516d408559cc11873bc95a94870" translate="yes" xml:space="preserve">
          <source>For the most part, you can pick out any field from the JSON in a fairly straightforward manner.</source>
          <target state="translated">대부분의 경우 JSON에서 모든 필드를 매우 간단하게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e24d434df7abbdbed1bca87fd765086211b5d01" translate="yes" xml:space="preserve">
          <source>For the most predictable behavior, ensure that all swarm nodes are running Docker 17.06 or higher.</source>
          <target state="translated">가장 예측 가능한 동작을 위해서는 모든 swarm 노드가 Docker 17.06 이상을 실행 중인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="956ac3d1457dc4bde02561b8bd56392a8dc0e498" translate="yes" xml:space="preserve">
          <source>For this example, the new Droplet is called &lt;code&gt;docker-sandbox&lt;/code&gt;:</source>
          <target state="translated">이 예제에서 새 Droplet은 &lt;code&gt;docker-sandbox&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="22bf5428ece73f9832bec22b26627f5c6b56b8ef" translate="yes" xml:space="preserve">
          <source>For this example, we created a virtual switch called &lt;code&gt;Primary Virtual Switch&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 &lt;code&gt;Primary Virtual Switch&lt;/code&gt; 라는 가상 스위치를 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="8dd8cffcef825b05c408e06792aa76d4b2327a6e" translate="yes" xml:space="preserve">
          <source>For this project, you need to create a Dockerfile, a Python dependencies file, and a &lt;code&gt;docker-compose.yml&lt;/code&gt; file. (You can use either a &lt;code&gt;.yml&lt;/code&gt; or &lt;code&gt;.yaml&lt;/code&gt; extension for this file.)</source>
          <target state="translated">이 프로젝트의 경우 Dockerfile, Python 종속성 파일 및 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일 을 작성해야 합니다. ( 이 파일에 &lt;code&gt;.yml&lt;/code&gt; 또는 &lt;code&gt;.yaml&lt;/code&gt; 확장자를 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="89b34d7c236301a269209483a9512bf580d0c296" translate="yes" xml:space="preserve">
          <source>For this reason, consider defining an additional Compose file, say &lt;code&gt;production.yml&lt;/code&gt;, which specifies production-appropriate configuration. This configuration file only needs to include the changes you&amp;rsquo;d like to make from the original Compose file. The additional Compose file can be applied over the original &lt;code&gt;docker-compose.yml&lt;/code&gt; to create a new configuration.</source>
          <target state="translated">이러한 이유로 프로덕션에 적합한 구성을 지정 하는 추가 작성 파일 (예 : &lt;code&gt;production.yml&lt;/code&gt; )을 정의하십시오. 이 구성 파일에는 원본 작성 파일에서 변경 한 내용 만 포함하면됩니다. 추가 구성 파일을 원래 &lt;code&gt;docker-compose.yml&lt;/code&gt; 에 적용 하여 새 구성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be658f3b92588270cc15de4c1aeeba172066cb0" translate="yes" xml:space="preserve">
          <source>For this reason, the REST API endpoint (used by the Docker CLI to communicate with the Docker daemon) changed in Docker 0.5.2, and now uses a UNIX socket instead of a TCP socket bound on 127.0.0.1 (the latter being prone to cross-site request forgery attacks if you happen to run Docker directly on your local machine, outside of a VM). You can then use traditional UNIX permission checks to limit access to the control socket.</source>
          <target state="translated">이러한 이유로 Docker CLI가 Docker 데몬과 통신하기 위해 사용하는 REST API 엔드 포인트는 Docker 0.5.2에서 변경되었으며 이제 127.0.0.1에 바인드 된 TCP 소켓 대신 UNIX 소켓을 사용합니다 (후자는 경향이 있습니다). VM 외부의 로컬 컴퓨터에서 Docker를 직접 실행하는 경우 사이트 간 요청 위조 공격) 그런 다음 일반적인 UNIX 권한 검사를 사용하여 제어 소켓에 대한 액세스를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55c0512227499e363436d77d61306954ff75b779" translate="yes" xml:space="preserve">
          <source>For version 2.0 of the format, &lt;code&gt;external&lt;/code&gt; cannot be used in conjunction with other network configuration keys (&lt;code&gt;driver&lt;/code&gt;, &lt;code&gt;driver_opts&lt;/code&gt;, &lt;code&gt;ipam&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;). This limitation no longer exists for &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;version 2.1&lt;/a&gt; and above.</source>
          <target state="translated">형식 2.0 버전의 경우 &lt;code&gt;external&lt;/code&gt; 은 다른 네트워크 구성 키 ( &lt;code&gt;driver&lt;/code&gt; , &lt;code&gt;driver_opts&lt;/code&gt; , &lt;code&gt;ipam&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; ) 와 함께 사용할 수 없습니다 . 이 제한 사항은 더 이상 &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;버전 2.1&lt;/a&gt; 이상에 존재하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b6db84ed69cd13af32c06719b1991abd5aa784e9" translate="yes" xml:space="preserve">
          <source>For version 2.0 of the format, &lt;code&gt;external&lt;/code&gt; cannot be used in conjunction with other volume configuration keys (&lt;code&gt;driver&lt;/code&gt;, &lt;code&gt;driver_opts&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;). This limitation no longer exists for &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;version 2.1&lt;/a&gt; and above.</source>
          <target state="translated">형식 2.0 버전의 경우 &lt;code&gt;external&lt;/code&gt; 을 다른 볼륨 구성 키 ( &lt;code&gt;driver&lt;/code&gt; , &lt;code&gt;driver_opts&lt;/code&gt; , &lt;code&gt;labels&lt;/code&gt; ) 와 함께 사용할 수 없습니다 . 이 제한 사항은 더 이상 &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;버전 2.1&lt;/a&gt; 이상에 존재하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="616c013d120401b89c42a71cc8808b7fd3df4d25" translate="yes" xml:space="preserve">
          <source>For version 3.3 and below of the format, &lt;code&gt;external&lt;/code&gt; cannot be used in conjunction with other network configuration keys (&lt;code&gt;driver&lt;/code&gt;, &lt;code&gt;driver_opts&lt;/code&gt;, &lt;code&gt;ipam&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;). This limitation no longer exists for &lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;version 3.4&lt;/a&gt; and above.</source>
          <target state="translated">버전 3.3 이하의 형식에서는 &lt;code&gt;external&lt;/code&gt; 을 다른 네트워크 구성 키 ( &lt;code&gt;driver&lt;/code&gt; , &lt;code&gt;driver_opts&lt;/code&gt; , &lt;code&gt;ipam&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; ) 와 함께 사용할 수 없습니다 . &lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;버전 3.4&lt;/a&gt; 이상에는이 제한이 더 이상 존재하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bf18270bcb0b883b053dc1c60baf663bb0b8c272" translate="yes" xml:space="preserve">
          <source>For version 3.3 and below of the format, &lt;code&gt;external&lt;/code&gt; cannot be used in conjunction with other volume configuration keys (&lt;code&gt;driver&lt;/code&gt;, &lt;code&gt;driver_opts&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;). This limitation no longer exists for &lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;version 3.4&lt;/a&gt; and above.</source>
          <target state="translated">버전 3.3 이하의 형식에서는 &lt;code&gt;external&lt;/code&gt; 을 다른 볼륨 구성 키 ( &lt;code&gt;driver&lt;/code&gt; , &lt;code&gt;driver_opts&lt;/code&gt; , &lt;code&gt;labels&lt;/code&gt; ) 와 함께 사용할 수 없습니다 . &lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;버전 3.4&lt;/a&gt; 이상에는이 제한이 더 이상 존재하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f9afee299aba0d401e62065d746fcc356f416236" translate="yes" xml:space="preserve">
          <source>Force create a new cluster from current state</source>
          <target state="translated">현재 상태에서 새 클러스터 생성</target>
        </trans-unit>
        <trans-unit id="ffe69cc485ff658043cc42f4902c04e7a8d6b09f" translate="yes" xml:space="preserve">
          <source>Force removal of the image</source>
          <target state="translated">이미지 강제 제거</target>
        </trans-unit>
        <trans-unit id="229c55dfaca028bf7cfef7dc627152c2af359ede" translate="yes" xml:space="preserve">
          <source>Force remove a node from the swarm</source>
          <target state="translated">떼에서 강제로 노드를 제거</target>
        </trans-unit>
        <trans-unit id="406db54e3abff369fddfe503307a2a70d5f41bc8" translate="yes" xml:space="preserve">
          <source>Force the container to disconnect from a network</source>
          <target state="translated">컨테이너를 네트워크에서 강제로 연결 해제</target>
        </trans-unit>
        <trans-unit id="6680f7a8870252cbed4ec8ea429862849a3f871d" translate="yes" xml:space="preserve">
          <source>Force the disable of an active plugin</source>
          <target state="translated">활성화 된 플러그인 비활성화</target>
        </trans-unit>
        <trans-unit id="8a33555a38c511700b5d1ae3ae93e29f1b9f5499" translate="yes" xml:space="preserve">
          <source>Force the removal of a context in use</source>
          <target state="translated">사용중인 컨텍스트 제거</target>
        </trans-unit>
        <trans-unit id="62b45047a99ee6674e7e008d270166ad1c348276" translate="yes" xml:space="preserve">
          <source>Force the removal of a running container (uses SIGKILL)</source>
          <target state="translated">실행중인 컨테이너를 강제로 제거 (SIGKILL 사용)</target>
        </trans-unit>
        <trans-unit id="c0d61bd04c5fbbee83f15b02f2d884e770b15063" translate="yes" xml:space="preserve">
          <source>Force the removal of an active plugin</source>
          <target state="translated">활성화 된 플러그인 제거</target>
        </trans-unit>
        <trans-unit id="d2243470861089be803d922e7a30924401a391a7" translate="yes" xml:space="preserve">
          <source>Force the removal of one or more volumes</source>
          <target state="translated">하나 이상의 볼륨을 강제로 제거</target>
        </trans-unit>
        <trans-unit id="f312de45e6a40e2de073bf378473cc1a2369216b" translate="yes" xml:space="preserve">
          <source>Force the swarm to rebalance</source>
          <target state="translated">무리를 다시 균형을 잡으십시오</target>
        </trans-unit>
        <trans-unit id="c06e3ec6ba4d32c91dd87af847fef4fb84ee70f2" translate="yes" xml:space="preserve">
          <source>Force this node to leave the swarm, ignoring warnings</source>
          <target state="translated">경고를 무시하고이 노드가 무리를 떠나도록합니다.</target>
        </trans-unit>
        <trans-unit id="a85f94902a59f50f2a418ff47b6306ba4fdda829" translate="yes" xml:space="preserve">
          <source>Force update even if no changes require it</source>
          <target state="translated">변경이 필요없는 경우에도 강제 업데이트</target>
        </trans-unit>
        <trans-unit id="f01410523237ffac132845ad9d10538c42f94789" translate="yes" xml:space="preserve">
          <source>Force-remove a running container</source>
          <target state="translated">실행중인 컨테이너 강제 제거</target>
        </trans-unit>
        <trans-unit id="8dcc686dfba68c99f8e7cb9d3fb72b82a6c9b888" translate="yes" xml:space="preserve">
          <source>Forces running containers to stop by sending a &lt;code&gt;SIGKILL&lt;/code&gt; signal. Optionally the signal can be passed, for example:</source>
          <target state="translated">&lt;code&gt;SIGKILL&lt;/code&gt; 신호 를 보내 컨테이너 실행을 강제로 중지합니다 . 선택적으로 신호는 다음과 같이 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a20ef13144cabfd7237a24ab82c637e82ce623" translate="yes" xml:space="preserve">
          <source>Forcibly remove a node</source>
          <target state="translated">강제로 노드 제거</target>
        </trans-unit>
        <trans-unit id="8352d19d209922284236d3551ee7aed0aa67a969" translate="yes" xml:space="preserve">
          <source>Forcibly remove an inaccessible node from a swarm</source>
          <target state="translated">무리에서 액세스 할 수없는 노드를 강제로 제거</target>
        </trans-unit>
        <trans-unit id="f7745efdedae8430f407638389ab56b4f858eeed" translate="yes" xml:space="preserve">
          <source>Foreground</source>
          <target state="translated">Foreground</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="49408c5ca514b719eac953a6bbd84a077d01680d" translate="yes" xml:space="preserve">
          <source>Format as JSON</source>
          <target state="translated">JSON 형식</target>
        </trans-unit>
        <trans-unit id="39d2e03f2e26543021089a14d2cd71f93bc839e6" translate="yes" xml:space="preserve">
          <source>Format the output</source>
          <target state="translated">출력 형식</target>
        </trans-unit>
        <trans-unit id="6454bbbd2b93e7a470ed8675888bbcd47205f0ed" translate="yes" xml:space="preserve">
          <source>Format the output using the given Go template</source>
          <target state="translated">주어진 Go 템플리트를 사용하여 출력 형식화</target>
        </trans-unit>
        <trans-unit id="841f832857c780b47f478b4f21d34d8995af64b8" translate="yes" xml:space="preserve">
          <source>Formatting</source>
          <target state="translated">Formatting</target>
        </trans-unit>
        <trans-unit id="29527e1c376ee4bcbb6714965180b18b1e1cb7a0" translate="yes" xml:space="preserve">
          <source>Formatting the output</source>
          <target state="translated">출력 형식</target>
        </trans-unit>
        <trans-unit id="467a77b7c1a6472ed6e13990989aae65ac956726" translate="yes" xml:space="preserve">
          <source>Fortunately when using the &lt;code&gt;$ docker trust&lt;/code&gt; commands, we will automatically initialize a repository, manage the repository keys, and add a collaborator&amp;rsquo;s key to the &lt;code&gt;targets/releases&lt;/code&gt; delegation via &lt;code&gt;docker trust signer add&lt;/code&gt;.</source>
          <target state="translated">다행히도 &lt;code&gt;$ docker trust&lt;/code&gt; 명령을 사용하면 자동으로 저장소를 초기화하고 저장소 키를 관리하며 &lt;code&gt;docker trust signer add&lt;/code&gt; 를 통해 &lt;code&gt;targets/releases&lt;/code&gt; 위임에 공동 작업자 키를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="38268fd8dbb017ec4ab6dcdbb25a7c1ed13c58c3" translate="yes" xml:space="preserve">
          <source>Four of the Dockerfile commands cannot be overridden at runtime: &lt;code&gt;FROM&lt;/code&gt;, &lt;code&gt;MAINTAINER&lt;/code&gt;, &lt;code&gt;RUN&lt;/code&gt;, and &lt;code&gt;ADD&lt;/code&gt;. Everything else has a corresponding override in &lt;code&gt;docker run&lt;/code&gt;. We&amp;rsquo;ll go through what the developer might have set in each Dockerfile instruction and how the operator can override that setting.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; , &lt;code&gt;MAINTAINER&lt;/code&gt; , &lt;code&gt;RUN&lt;/code&gt; 및 &lt;code&gt;ADD&lt;/code&gt; 라는 런타임시 Dockerfile 명령 중 4 개를 재정의 할 수 없습니다 . 다른 모든 것은 &lt;code&gt;docker run&lt;/code&gt; 에서 해당 재정의를 갖습니다 . 각 Dockerfile 명령어에서 개발자가 설정 한 내용과 운영자가 해당 설정을 재정의하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="af90cef80988974dd76636b3adb5f472768f785d" translate="yes" xml:space="preserve">
          <source>Frequently asked questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="ec047a56e845558e1731ee061b01073cfea2ff68" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;docker-compose&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;code&gt;docker-compose&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fd8289350ea17783bc93c61db927437efc2687bf" translate="yes" xml:space="preserve">
          <source>From here you can do everything you learned about in parts 2 and 3.</source>
          <target state="translated">여기에서 2 부와 3 부에서 배운 모든 것을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449ab4f3925ece4db8a57b83c0e94335be023995" translate="yes" xml:space="preserve">
          <source>From here you can do everything you learned about in previous parts of the tutorial.</source>
          <target state="translated">여기에서 튜토리얼의 이전 부분에서 배운 모든 것을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0194b18f2f7b4432a9a2e687308c6ced82ae4647" translate="yes" xml:space="preserve">
          <source>From now on, you can use &lt;code&gt;docker run&lt;/code&gt; and run your app on any machine with this command:</source>
          <target state="translated">이제부터는 다음 명령으로 &lt;code&gt;docker run&lt;/code&gt; 을 사용 하여 모든 컴퓨터에서 앱을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="956ff8343ab67909410600a26d5f109cd95d93e4" translate="yes" xml:space="preserve">
          <source>From the AWS menus, select &lt;strong&gt;Services&lt;/strong&gt; &amp;gt; &lt;strong&gt;IAM&lt;/strong&gt; to get started.</source>
          <target state="translated">AWS 메뉴에서 &lt;strong&gt;서비스&lt;/strong&gt; &amp;gt; &lt;strong&gt;IAM&lt;/strong&gt; 을 선택 하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="90f1b6a32d15eb97fb6e5cff6efefde16b6400eb" translate="yes" xml:space="preserve">
          <source>From the command line, run &lt;code&gt;docker node inspect &amp;lt;id-node&amp;gt;&lt;/code&gt; to query the nodes. For instance, to query the reachability of the node as a manager:</source>
          <target state="translated">명령 행에서 &lt;code&gt;docker node inspect &amp;lt;id-node&amp;gt;&lt;/code&gt; 를 실행 하여 노드를 조회하십시오. 예를 들어 관리자로서 노드의 연결 가능성을 쿼리하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="967bcd5ce7159e40d77a43ef0368fcade23d1d92" translate="yes" xml:space="preserve">
          <source>From this point on, all new node certificates issued are signed with the new root CA, and do not contain any intermediates.</source>
          <target state="translated">이때부터 발급 된 모든 새 노드 인증서는 새 루트 CA로 서명되며 중간체는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="335f3b4a3d405e2d4b01be74e8d2f61edc6550a7" translate="yes" xml:space="preserve">
          <source>From those commands, we can see that &lt;code&gt;manager1&lt;/code&gt; is both at the status &lt;code&gt;reachable&lt;/code&gt; as a manager and &lt;code&gt;ready&lt;/code&gt; as a worker.</source>
          <target state="translated">이러한 명령에서 &lt;code&gt;manager1&lt;/code&gt; 이 관리자로서 &lt;code&gt;reachable&lt;/code&gt; 있는 상태에 있고 작업자로서 &lt;code&gt;ready&lt;/code&gt; 을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b85f5d1178a131088a76c1a36179562d8bca8da4" translate="yes" xml:space="preserve">
          <source>From your project directory, start up your application by running &lt;code&gt;docker-compose up&lt;/code&gt;.</source>
          <target state="translated">프로젝트 디렉토리에서 &lt;code&gt;docker-compose up&lt;/code&gt; 을 실행하여 애플리케이션을 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="732528e9391666886858509f010a261f26833e5b" translate="yes" xml:space="preserve">
          <source>From your project directory, type &lt;code&gt;docker-compose up&lt;/code&gt; to build the app with the updated Compose file, and run it.</source>
          <target state="translated">프로젝트 디렉토리에서 &lt;code&gt;docker-compose up&lt;/code&gt; 을 입력 하여 업데이트 된 Compose 파일로 앱을 빌드하고 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="40f85c660757f599cc1b255f437d1323982d5c39" translate="yes" xml:space="preserve">
          <source>Full URL, such as &lt;code&gt;DB_PORT=tcp://172.17.0.5:5432&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DB_PORT=tcp://172.17.0.5:5432&lt;/code&gt; 와 같은 전체 URL</target>
        </trans-unit>
        <trans-unit id="ef73c5354384685e9eaf339df1c2a8360e8241f1" translate="yes" xml:space="preserve">
          <source>Full URL, such as &lt;code&gt;DB_PORT_5432_TCP=tcp://172.17.0.5:5432&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DB_PORT_5432_TCP=tcp://172.17.0.5:5432&lt;/code&gt; 와 같은 전체 URL</target>
        </trans-unit>
        <trans-unit id="f7ddbd43e90b6f2dd187621985159b4e46678677" translate="yes" xml:space="preserve">
          <source>Full container capabilities (--privileged)</source>
          <target state="translated">완전한 컨테이너 기능 (-권한)</target>
        </trans-unit>
        <trans-unit id="9dc31143091e9ea6de501377e88db64cf87122c9" translate="yes" xml:space="preserve">
          <source>Full detail on these flags, the problems they solve, and their &lt;code&gt;docker run&lt;/code&gt; counterparts is in the Docker Desktop for Mac topic &lt;a href=&quot;https://docs.docker.com/docker-for-mac/osxfs-caching/&quot;&gt;Performance tuning for volume mounts (shared filesystems)&lt;/a&gt;.</source>
          <target state="translated">이 플래그, 그들이 해결하는 문제 및 그들의 &lt;code&gt;docker run&lt;/code&gt; 대응에 대한 자세한 내용은 Docker Desktop for Mac 주제 &lt;a href=&quot;https://docs.docker.com/docker-for-mac/osxfs-caching/&quot;&gt;볼륨 마운트 (공유 파일 시스템) 튜닝에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeb692087d629b32f2f1820369d9756d60c5cba8" translate="yes" xml:space="preserve">
          <source>Full name</source>
          <target state="translated">성명</target>
        </trans-unit>
        <trans-unit id="14b79e642439f31013446b809db6f1eabf68edf5" translate="yes" xml:space="preserve">
          <source>Fully qualified container name, such as &lt;code&gt;DB_1_NAME=/myapp_web_1/myapp_db_1&lt;/code&gt;</source>
          <target state="translated">정규화 된 컨테이너 이름 (예 : &lt;code&gt;DB_1_NAME=/myapp_web_1/myapp_db_1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="1bcb44f5d1ee1783c081e60efc3a940a8a5f4405" translate="yes" xml:space="preserve">
          <source>Further reference information is available on the &lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;capabilities(7) - Linux man page&lt;/a&gt;</source>
          <target state="translated">추가 참조 정보는 &lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;기능 (7)-Linux 매뉴얼 페이지에서 볼 수 있습니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8232f5f709f3c8d7a2b6a65fd4572436973477a0" translate="yes" xml:space="preserve">
          <source>Fuxi Volume Plugin</source>
          <target state="translated">푸시 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="400df617426074f7a1d3e72230098eda5c8df643" translate="yes" xml:space="preserve">
          <source>GPU devices to add to the container (&amp;lsquo;all&amp;rsquo; to pass all GPUs)</source>
          <target state="translated">컨테이너에 추가 할 GPU 장치 (모든 GPU를 전달하는 '모두')</target>
        </trans-unit>
        <trans-unit id="8fccc069576bf17f5e7e17b4b3c176d69ed30562" translate="yes" xml:space="preserve">
          <source>General form</source>
          <target state="translated">일반적인 형태</target>
        </trans-unit>
        <trans-unit id="6fbf147c71a40b7a7ce191e58e7241180d751550" translate="yes" xml:space="preserve">
          <source>Generally, you do not need to force the swarm to rebalance its tasks. When you add a new node to a swarm, or a node reconnects to the swarm after a period of unavailability, the swarm does not automatically give a workload to the idle node. This is a design decision. If the swarm periodically shifted tasks to different nodes for the sake of balance, the clients using those tasks would be disrupted. The goal is to avoid disrupting running services for the sake of balance across the swarm. When new tasks start, or when a node with running tasks becomes unavailable, those tasks are given to less busy nodes. The goal is eventual balance, with minimal disruption to the end user.</source>
          <target state="translated">일반적으로, 떼가 강제로 작업의 균형을 다시 잡을 필요는 없습니다. 사용할 수없는 기간 후에 새 노드를 웜에 추가하거나 노드를 웜에 다시 연결하면 웜은 자동으로 유휴 노드에 작업 부하를 제공하지 않습니다. 이것은 디자인 결정입니다. 무리가 주기적으로 작업을 다른 노드로 이동하면 해당 작업을 사용하는 클라이언트가 중단됩니다. 목표는 떼를 가로 지르는 균형을 위해 서비스 실행을 방해하지 않는 것입니다. 새 작업이 시작되거나 실행중인 작업이있는 노드를 사용할 수 없게되면 사용량이 적은 노드에 해당 작업이 제공됩니다. 목표는 최종 사용자에 대한 중단을 최소화하면서 최종 균형을 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="644d86c2b8f866c04433746baa7e8b0f2cba8f64" translate="yes" xml:space="preserve">
          <source>Generate a CSR using the root key.</source>
          <target state="translated">루트 키를 사용하여 CSR을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="e967d39d65ee77d3f7ba72d1e9081eabff69dc92" translate="yes" xml:space="preserve">
          <source>Generate a Distributed Application Bundle (DAB) from the Compose file.</source>
          <target state="translated">작성 파일에서 DAB (Distributed Application Bundle)를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="5a0ec17a13466e19309645b5110deac758728d83" translate="yes" xml:space="preserve">
          <source>Generate a random alphanumeric password for MySQL and store it as a Docker secret with the name &lt;code&gt;mysql_password&lt;/code&gt; using the &lt;code&gt;docker secret create&lt;/code&gt; command. To make the password shorter or longer, adjust the last argument of the &lt;code&gt;openssl&lt;/code&gt; command. This is just one way to create a relatively random password. You can use another command to generate the password if you choose.</source>
          <target state="translated">MySQL의 임의 영숫자 비밀번호를 생성 하고 &lt;code&gt;docker secret create&lt;/code&gt; 명령을 사용하여 이름이 &lt;code&gt;mysql_password&lt;/code&gt; 인 Docker 비밀로 저장하십시오 . 비밀번호를 더 짧게 또는 더 길게 만들려면 &lt;code&gt;openssl&lt;/code&gt; 명령 의 마지막 인수를 조정하십시오 . 이것은 비교적 임의의 비밀번호를 작성하는 한 가지 방법입니다. 원하는 경우 다른 명령을 사용하여 비밀번호를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67855c41928429f4f9eb74522862e8bc3b7720f0" translate="yes" xml:space="preserve">
          <source>Generate a root CA and TLS certificate and key for your site. For production sites, you may want to use a service such as &lt;code&gt;Let&amp;rsquo;s Encrypt&lt;/code&gt; to generate the TLS certificate and key, but this example uses command-line tools. This step is a little complicated, but is only a set-up step so that you have something to store as a Docker secret. If you want to skip these sub-steps, you can &lt;a href=&quot;https://letsencrypt.org/getting-started/&quot;&gt;use Let&amp;rsquo;s Encrypt&lt;/a&gt; to generate the site key and certificate, name the files &lt;code&gt;site.key&lt;/code&gt; and &lt;code&gt;site.crt&lt;/code&gt;, and skip to &lt;a href=&quot;#configure-the-nginx-container&quot;&gt;Configure the Nginx container&lt;/a&gt;.</source>
          <target state="translated">사이트에 대한 루트 CA 및 TLS 인증서와 키를 생성하십시오. 프로덕션 사이트의 경우 &lt;code&gt;Let&amp;rsquo;s Encrypt&lt;/code&gt; 와 같은 서비스를 사용 하여 TLS 인증서 및 키를 생성 할 수 있지만이 예에서는 명령 줄 도구를 사용합니다. 이 단계는 약간 복잡하지만 설정 단계이므로 Docker 비밀로 저장할 항목이 있습니다. 이 하위 단계를 건너 뛰려면 &lt;a href=&quot;https://letsencrypt.org/getting-started/&quot;&gt;Let 's Encrypt&lt;/a&gt; 를 사용하여 사이트 키와 인증서를 생성하고 파일 이름을 &lt;code&gt;site.key&lt;/code&gt; 및 &lt;code&gt;site.crt&lt;/code&gt; 로 지정한&lt;a href=&quot;#configure-the-nginx-container&quot;&gt;다음 Nginx 컨테이너 구성으로&lt;/a&gt; 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78ae4050a21f6a62216c3c2650fbe099edc0e506" translate="yes" xml:space="preserve">
          <source>Generate a root key.</source>
          <target state="translated">루트 키를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="aa53b2e1470d57aa6cdfcac43ec91067a9ed4acb" translate="yes" xml:space="preserve">
          <source>Generate a second secret for the MySQL &lt;code&gt;root&lt;/code&gt; user. This secret isn&amp;rsquo;t shared with the WordPress service created later. It&amp;rsquo;s only needed to bootstrap the &lt;code&gt;mysql&lt;/code&gt; service.</source>
          <target state="translated">MySQL &lt;code&gt;root&lt;/code&gt; 사용자를 위한 두 번째 비밀을 생성하십시오 . 이 비밀은 나중에 만든 WordPress 서비스와 공유되지 않습니다. &lt;code&gt;mysql&lt;/code&gt; 서비스 를 부트 스트랩하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="873c47c8e4481c69e4dbcd631ac3b4d5df889a50" translate="yes" xml:space="preserve">
          <source>Generate a set of certificates (usually with the default, self-signed CA) and configure the daemon to accept connections over TLS.</source>
          <target state="translated">인증서 세트 (일반적으로 자체 서명 된 기본 CA 사용)를 생성하고 TLS를 통한 연결을 허용하도록 데몬을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="48a0cb942ac8b81b9b804324cc06ed025190d3f5" translate="yes" xml:space="preserve">
          <source>Generate and load a signing key-pair</source>
          <target state="translated">서명 키 쌍 생성 및로드</target>
        </trans-unit>
        <trans-unit id="7c272260b375e1ccab2d817d2cd35ee28b31a83e" translate="yes" xml:space="preserve">
          <source>Generate the site certificate</source>
          <target state="translated">사이트 인증서 생성</target>
        </trans-unit>
        <trans-unit id="b3d3a62176dbe0c3246ec4b2d1ced8127390badd" translate="yes" xml:space="preserve">
          <source>Generate the site certificate and sign it with the site key.</source>
          <target state="translated">사이트 인증서를 생성하고 사이트 키로 서명하십시오.</target>
        </trans-unit>
        <trans-unit id="b7fd4895a32470e25e3802e5c3139cbd4b19b392" translate="yes" xml:space="preserve">
          <source>Generate the site key.</source>
          <target state="translated">사이트 키를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3e9beae38e2b0f5611eb0548d6198f83dccdb896" translate="yes" xml:space="preserve">
          <source>Generate your own TLS certificate and key as &lt;code&gt;server.crt&lt;/code&gt; and &lt;code&gt;server.key&lt;/code&gt;, and put them in the directory &lt;code&gt;/tmp/server-configdir&lt;/code&gt;.</source>
          <target state="translated">TLS 인증서 및 키를 &lt;code&gt;server.crt&lt;/code&gt; 및 &lt;code&gt;server.key&lt;/code&gt; 로 생성하여 &lt;code&gt;/tmp/server-configdir&lt;/code&gt; 디렉토리에 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6d4b70624c8f8cb1840cb126b8471f29fbb6e94" translate="yes" xml:space="preserve">
          <source>Generic strings or binary content (up to 500 kb in size)</source>
          <target state="translated">일반 문자열 또는 이진 콘텐츠 (최대 500kb 크기)</target>
        </trans-unit>
        <trans-unit id="84aa5e8b4b4496a613e746991ecd541d212717fe" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt; as described in &lt;a href=&quot;../part3/index#prerequisites&quot;&gt;Part 3 prerequisites&lt;/a&gt;.</source>
          <target state="translated">가져 &lt;a href=&quot;../../compose/index&quot;&gt;도커 작성을&lt;/a&gt; 에 설명 된대로 &lt;a href=&quot;../part3/index#prerequisites&quot;&gt;제 3 부 전제 조건&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4c96200d0014e5447cd05ad327821572f12996d" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt;. On &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; it&amp;rsquo;s pre-installed, so you&amp;rsquo;re good-to-go. On Linux systems you need to &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;install it directly&lt;/a&gt;. On pre Windows 10 systems &lt;em&gt;without Hyper-V&lt;/em&gt;, use &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;.</source>
          <target state="translated">가져 &lt;a href=&quot;../../compose/index&quot;&gt;도커 작성을&lt;/a&gt; . 에 &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Mac 용 도커 데스크톱&lt;/a&gt; 및 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows 용 도커 데스크톱&lt;/a&gt; 그것은 당신이 그렇게있는 거 잘 - 투 - 이동, 미리 설치합니다. Linux 시스템 &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;에서는 직접 설치해야합니다&lt;/a&gt; . &lt;em&gt;Hyper-V가없는&lt;/em&gt; Windows 10 이전 시스템 에서는 &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e92e57538757fb219c9b7b5b310c2c4df25876b3" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt; as described in &lt;a href=&quot;../part4/index#prerequisites&quot;&gt;Part 4 prerequisites&lt;/a&gt;.</source>
          <target state="translated">가져 &lt;a href=&quot;../../machine/overview/index&quot;&gt;도커 기계&lt;/a&gt; 에 설명 된대로 &lt;a href=&quot;../part4/index#prerequisites&quot;&gt;4 부 전제 조건&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d848914b918a40e284f9a6c187a2f7524984ea72" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt;, which is pre-installed with &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt;, but on Linux systems you need to &lt;a href=&quot;../../machine/install-machine/index#installing-machine-directly&quot;&gt;install it directly&lt;/a&gt;. On pre Windows 10 systems &lt;em&gt;without Hyper-V&lt;/em&gt;, as well as Windows 10 Home, use &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;.</source>
          <target state="translated">가져 &lt;a href=&quot;../../machine/overview/index&quot;&gt;도커 기계&lt;/a&gt; 에 사전 설치되어, &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Mac 용 도커 데스크톱&lt;/a&gt; 및 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows 용 도커 데스크톱을&lt;/a&gt; 하지만, 리눅스 시스템에서 당신이 할 필요가 &lt;a href=&quot;../../machine/install-machine/index#installing-machine-directly&quot;&gt;직접 설치합니다&lt;/a&gt; . Windows 10 Home뿐만 아니라 &lt;em&gt;Hyper-V가없는&lt;/em&gt; Windows 10 이전 시스템 에서는 &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7044ca924f3af77aea0fd427f6d2cd3e3eb6163e" translate="yes" xml:space="preserve">
          <source>Get Docker Desktop for Mac</source>
          <target state="translated">Mac 용 Docker Desktop 가져 오기</target>
        </trans-unit>
        <trans-unit id="36ad2afd445c27d250be201f5062f127fe72e320" translate="yes" xml:space="preserve">
          <source>Get Docker Desktop for Windows</source>
          <target state="translated">Windows 용 Docker Desktop 가져 오기</target>
        </trans-unit>
        <trans-unit id="bd2cb051773a703fdbabd8c09f218722870e6d61" translate="yes" xml:space="preserve">
          <source>Get Started</source>
          <target state="translated">시작하다</target>
        </trans-unit>
        <trans-unit id="e186d37ba9bba6bfe1735621fecd43b938379a65" translate="yes" xml:space="preserve">
          <source>Get Started, Part 1: Orientation and setup</source>
          <target state="translated">시작하기, 1 부 : 방향 및 설정</target>
        </trans-unit>
        <trans-unit id="e04cbebaf151dd7c1cc89c21c716d0a01144a5ff" translate="yes" xml:space="preserve">
          <source>Get Started, Part 2: Containers</source>
          <target state="translated">시작하기, Part 2 : 컨테이너</target>
        </trans-unit>
        <trans-unit id="c37a2f65b8f99944cd4afc0f292a8281f1add106" translate="yes" xml:space="preserve">
          <source>Get Started, Part 3: Services</source>
          <target state="translated">시작하기, 3 부 : 서비스</target>
        </trans-unit>
        <trans-unit id="9a3bb4baee10d77712235d6acac26914abbbb6b5" translate="yes" xml:space="preserve">
          <source>Get Started, Part 4: Swarms</source>
          <target state="translated">시작하기, 4 부 : 무리</target>
        </trans-unit>
        <trans-unit id="ae746fa3b4aa275a285783491df8edc3a0912cd7" translate="yes" xml:space="preserve">
          <source>Get Started, Part 5: Stacks</source>
          <target state="translated">시작하기, 5 부 : 스택</target>
        </trans-unit>
        <trans-unit id="4eaade9a3a677a9fbd6e1e6ac364a767b93d4bc9" translate="yes" xml:space="preserve">
          <source>Get Started, Part 6: Deploy your app</source>
          <target state="translated">시작하기, 6 부 : 앱 배포</target>
        </trans-unit>
        <trans-unit id="3ede1568d144c700c3e012f506b9d3877efd990d" translate="yes" xml:space="preserve">
          <source>Get a subsection in JSON format</source>
          <target state="translated">JSON 형식의 하위 섹션 가져 오기</target>
        </trans-unit>
        <trans-unit id="5210929c766ff01492bc1f70a359c42c26050ae4" translate="yes" xml:space="preserve">
          <source>Get an instance&amp;rsquo;s IP address</source>
          <target state="translated">인스턴스의 IP 주소 얻기</target>
        </trans-unit>
        <trans-unit id="4c53bc79a4a51c1e5bcbef9d31e14a94056a69d2" translate="yes" xml:space="preserve">
          <source>Get an instance&amp;rsquo;s MAC address</source>
          <target state="translated">인스턴스의 MAC 주소를 얻습니다</target>
        </trans-unit>
        <trans-unit id="e7d4d639dd0346ed0aec37d0b1168d53212a7422" translate="yes" xml:space="preserve">
          <source>Get an instance&amp;rsquo;s image name</source>
          <target state="translated">인스턴스의 이미지 이름을 얻습니다</target>
        </trans-unit>
        <trans-unit id="b9df4a142391513af1cda904bbcc28118ddc05d9" translate="yes" xml:space="preserve">
          <source>Get an instance&amp;rsquo;s log path</source>
          <target state="translated">인스턴스의 로그 경로 가져 오기</target>
        </trans-unit>
        <trans-unit id="a9fd4f840853dcaff47bd510d3bb693667e5c3a3" translate="yes" xml:space="preserve">
          <source>Get details about signatures for a single image tag</source>
          <target state="translated">단일 이미지 태그의 서명에 대한 세부 정보 얻기</target>
        </trans-unit>
        <trans-unit id="6ef476727ae5e958231f09957404ec41c8f74005" translate="yes" xml:space="preserve">
          <source>Get details about signatures for all image tags in a repository</source>
          <target state="translated">저장소에있는 모든 이미지 태그의 서명에 대한 세부 사항 가져 오기</target>
        </trans-unit>
        <trans-unit id="14402f077a13563c33e5022ae8ca14df73a44f18" translate="yes" xml:space="preserve">
          <source>Get details about signatures for multiple images</source>
          <target state="translated">여러 이미지의 서명에 대한 세부 정보 얻기</target>
        </trans-unit>
        <trans-unit id="5d7815759af07d1298af6588ab012f3ed2fac980" translate="yes" xml:space="preserve">
          <source>Get info about &lt;code&gt;volume_name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;volume_name&lt;/code&gt; 에 대한 정보를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="2a19131a48eb6dc17715d33d02e0cc5e8ddec8fd" translate="yes" xml:space="preserve">
          <source>Get low-level details about signatures for a single image tag</source>
          <target state="translated">단일 이미지 태그의 서명에 대한 상세 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="db1ec7a2845e2244df7d5d19d2567d486f85e13f" translate="yes" xml:space="preserve">
          <source>Get real time events from the server</source>
          <target state="translated">서버에서 실시간 이벤트 가져 오기</target>
        </trans-unit>
        <trans-unit id="7a7297b58ab1de2b76a9103dc28b7229a37b8298" translate="yes" xml:space="preserve">
          <source>Get started walkthrough</source>
          <target state="translated">연습 시작</target>
        </trans-unit>
        <trans-unit id="1e84ef7f57886512afa70721896cc6c72b9a8842" translate="yes" xml:space="preserve">
          <source>Get started with Django</source>
          <target state="translated">장고 시작하기</target>
        </trans-unit>
        <trans-unit id="b8f7d03be1c8fadeb4ffa872f1ab303d57e50bdc" translate="yes" xml:space="preserve">
          <source>Get started with Docker</source>
          <target state="translated">Docker 시작하기</target>
        </trans-unit>
        <trans-unit id="c21a67cc0c7acb6f66cc7a8afec9533ad681810a" translate="yes" xml:space="preserve">
          <source>Get started with Docker Compose</source>
          <target state="translated">Docker Compose 시작하기</target>
        </trans-unit>
        <trans-unit id="9c94e0f27a1e8c04eacacb0138b7680805b450ca" translate="yes" xml:space="preserve">
          <source>Get started with Docker Machine and a local VM</source>
          <target state="translated">Docker Machine 및 로컬 VM 시작</target>
        </trans-unit>
        <trans-unit id="0fd9d044ce1c76035c145f8b9255d6bb92d070b8" translate="yes" xml:space="preserve">
          <source>Get started with Docker Notary</source>
          <target state="translated">Docker Notary 시작하기</target>
        </trans-unit>
        <trans-unit id="66e6c54220742cc2f3ece588945898ae0d67d90d" translate="yes" xml:space="preserve">
          <source>Get started with Rails</source>
          <target state="translated">Rails 시작하기</target>
        </trans-unit>
        <trans-unit id="8ec8e9931375e581eed537fe9a88b69298c9782a" translate="yes" xml:space="preserve">
          <source>Get started with WordPress</source>
          <target state="translated">워드 프레스 시작하기</target>
        </trans-unit>
        <trans-unit id="3e060140b673839d23631cc2a74cb3ad3892c240" translate="yes" xml:space="preserve">
          <source>Get started with the &lt;a href=&quot;../swarm-tutorial/index&quot;&gt;swarm mode tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../swarm-tutorial/index&quot;&gt;swarm mode tutorial을&lt;/a&gt; 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="f05a5ddd29eaada4bfe751d1bfb1f7f04e84d3f1" translate="yes" xml:space="preserve">
          <source>Get started with the &lt;a href=&quot;swarm-tutorial/index&quot;&gt;Swarm mode tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;swarm-tutorial/index&quot;&gt;Swarm 모드 자습서를&lt;/a&gt; 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c59991c96ccca837a3fa93098b52499f69d90fa" translate="yes" xml:space="preserve">
          <source>Get the ID of the &lt;code&gt;redis&lt;/code&gt; service task container using &lt;code&gt;docker ps&lt;/code&gt; , so that you can use &lt;code&gt;docker container exec&lt;/code&gt; to connect to the container and read the contents of the secret data file, which defaults to being readable by all and has the same name as the name of the secret. The first command below illustrates how to find the container ID, and the second and third commands use shell completion to do this automatically.</source>
          <target state="translated">&lt;code&gt;docker ps&lt;/code&gt; 를 사용하여 &lt;code&gt;redis&lt;/code&gt; 서비스 작업 컨테이너 의 ID를 가져옵니다 . 따라서 &lt;code&gt;docker container exec&lt;/code&gt; 를 사용하여 컨테이너에 연결하고 비밀 데이터 파일의 내용을 읽을 수 있습니다. 기본적으로 모든 사람이 읽을 수 있으며 비밀의 이름. 아래의 첫 번째 명령은 컨테이너 ID를 찾는 방법을 보여 주며 두 번째 및 세 번째 명령은 셸 완성을 사용하여 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="94f0a3ca30c26a09921bd85ca1284f4f9722c0b4" translate="yes" xml:space="preserve">
          <source>Get the ID of the &lt;code&gt;redis&lt;/code&gt; service task container using &lt;code&gt;docker ps&lt;/code&gt;, so that you can use &lt;code&gt;docker container exec&lt;/code&gt; to connect to the container and read the contents of the config data file, which defaults to being readable by all and has the same name as the name of the config. The first command below illustrates how to find the container ID, and the second and third commands use shell completion to do this automatically.</source>
          <target state="translated">&lt;code&gt;docker ps&lt;/code&gt; 를 사용하여 &lt;code&gt;redis&lt;/code&gt; 서비스 작업 컨테이너 의 ID를 가져 오면 &lt;code&gt;docker container exec&lt;/code&gt; 를 사용하여 컨테이너에 연결하고 구성 데이터 파일의 내용을 읽을 수 있습니다. 이는 기본적으로 모두 읽을 수 있으며 구성 이름 아래의 첫 번째 명령은 컨테이너 ID를 찾는 방법을 보여 주며 두 번째 및 세 번째 명령은 셸 완성을 사용하여 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ef0832bef0f49e9019bc95e4605edeb6f049037d" translate="yes" xml:space="preserve">
          <source>Get the IP address of one or more machines.</source>
          <target state="translated">하나 이상의 컴퓨터의 IP 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="18eae5bee6ace7ee65360105354f98fba9cfdce8" translate="yes" xml:space="preserve">
          <source>Get the URL of a host</source>
          <target state="translated">호스트의 URL을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="d1188ef91b1987164fb8cd0052b601fc35081294" translate="yes" xml:space="preserve">
          <source>Get the environment commands for your new VM.</source>
          <target state="translated">새 VM에 대한 환경 명령을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2ad4f5d16a2a7ce9e6d16e7fe9e74aa9dcb32c78" translate="yes" xml:space="preserve">
          <source>Get the exit code of the container&amp;rsquo;s command</source>
          <target state="translated">컨테이너 명령의 종료 코드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8615625f97a0b98819c91a9b2eca4df0a06f1db4" translate="yes" xml:space="preserve">
          <source>Get the host IP address.</source>
          <target state="translated">호스트 IP 주소를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="02e2509bb867a569bd388729cd7fed146708cacb" translate="yes" xml:space="preserve">
          <source>Get the list of capabilities the driver supports.</source>
          <target state="translated">드라이버가 지원하는 기능 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ae90d7ce668b1b8a66a8433bc9835d268c6c4614" translate="yes" xml:space="preserve">
          <source>Get the list of volumes registered with the plugin.</source>
          <target state="translated">플러그인에 등록 된 볼륨 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="898005b1d4ad39e7ac43ddb5fe734cfecec3d162" translate="yes" xml:space="preserve">
          <source>Get the server version</source>
          <target state="translated">서버 버전 받기</target>
        </trans-unit>
        <trans-unit id="5482546719a2f8ff5f248751115473d3e74aec3a" translate="yes" xml:space="preserve">
          <source>Get the service ID for the one service in our application:</source>
          <target state="translated">애플리케이션에서 하나의 서비스에 대한 서비스 ID를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="f472550d578ffa0c776aa16121f1cc9378b1bfda" translate="yes" xml:space="preserve">
          <source>Get your API key and API secret key from &lt;a href=&quot;https://portal.exoscale.com/account/api&quot;&gt;API details&lt;/a&gt; and pass them to &lt;code&gt;machine create&lt;/code&gt; with the &lt;code&gt;--exoscale-api-key&lt;/code&gt; and &lt;code&gt;--exoscale-api-secret-key&lt;/code&gt; options.</source>
          <target state="translated">에서 API 키와 API 비밀 키를 가져 오기 &lt;a href=&quot;https://portal.exoscale.com/account/api&quot;&gt;API 세부 사항&lt;/a&gt; 과에 전달할 &lt;code&gt;machine create&lt;/code&gt; 와 &lt;code&gt;--exoscale-api-key&lt;/code&gt; 와 &lt;code&gt;--exoscale-api-secret-key&lt;/code&gt; 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="060f712c74598ce01e86d56802d9344d8ed68bb7" translate="yes" xml:space="preserve">
          <source>Getting help</source>
          <target state="translated">도움을 받다</target>
        </trans-unit>
        <trans-unit id="5fee613895554a60e080e31e897ab64e340c7caa" translate="yes" xml:space="preserve">
          <source>Getting started with swarm mode</source>
          <target state="translated">스웜 모드 시작하기</target>
        </trans-unit>
        <trans-unit id="3725e116ef7699c247070b569d34e054ac77520a" translate="yes" xml:space="preserve">
          <source>Git URLs accept context configuration in their fragment section, separated by a colon &lt;code&gt;:&lt;/code&gt;. The first part represents the reference that Git will check out, and can be either a branch, a tag, or a remote reference. The second part represents a subdirectory inside the repository that will be used as a build context.</source>
          <target state="translated">망할 놈의 URL은 콜론으로 구분 자신의 단편 섹션에서 상황에 맞는 구성을 수락 &lt;code&gt;:&lt;/code&gt; . 첫 번째 부분은 Git이 체크 아웃 할 참조를 나타내며 분기, 태그 또는 원격 참조 일 수 있습니다. 두 번째 부분은 빌드 컨텍스트로 사용될 저장소 내의 서브 디렉토리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d038357ab3d653647d06a0792a301d7cb2c13e16" translate="yes" xml:space="preserve">
          <source>Git repositories</source>
          <target state="translated">힘내 리포지토리</target>
        </trans-unit>
        <trans-unit id="b870f36e8909aee8a17fc389e13325ffe873b477" translate="yes" xml:space="preserve">
          <source>Give a service access to volumes or bind mounts</source>
          <target state="translated">서비스에 볼륨 또는 바인드 마운트에 대한 액세스 권한 부여</target>
        </trans-unit>
        <trans-unit id="e6989574f6df79f1942a08bba1b3af685ec95e1f" translate="yes" xml:space="preserve">
          <source>Give extended privileges to the command</source>
          <target state="translated">명령에 확장 권한을 부여하십시오</target>
        </trans-unit>
        <trans-unit id="7433491d9f3abb149ebda0f079424ca0a931a71b" translate="yes" xml:space="preserve">
          <source>Give extended privileges to this container</source>
          <target state="translated">이 컨테이너에 확장 권한을 부여하십시오</target>
        </trans-unit>
        <trans-unit id="a75a3b80364714530a385b4524745d7238ef1701" translate="yes" xml:space="preserve">
          <source>Give it the name &lt;code&gt;myswitch&lt;/code&gt;, and check the box to share your host machine&amp;rsquo;s active network adapter</source>
          <target state="translated">이름을 &lt;code&gt;myswitch&lt;/code&gt; 로 지정하고 호스트 시스템의 활성 네트워크 어댑터를 공유하려면 상자를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="3a9862caca630b85a692de1def5ee3b57f18015d" translate="yes" xml:space="preserve">
          <source>Give the token a descriptive name, make sure the &lt;strong&gt;Write (Optional)&lt;/strong&gt; checkbox is checked, and click &lt;strong&gt;Generate Token&lt;/strong&gt;.</source>
          <target state="translated">토큰에 설명적인 이름을 지정하고 &lt;strong&gt;쓰기 (선택 사항)&lt;/strong&gt; 확인란이 선택되어 있는지 확인한 후 &lt;strong&gt;토큰 생성을&lt;/strong&gt; 클릭 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="876588c1e5c87839f4b0e02744134f58dd07b63b" translate="yes" xml:space="preserve">
          <source>Give your environment a quick test run to make sure you&amp;rsquo;re all set up:</source>
          <target state="translated">환경을 빠르게 테스트하여 모든 준비가 완료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9d73af8828b766ef32cac0eb25567d1e9ba116f1" translate="yes" xml:space="preserve">
          <source>Given an image:</source>
          <target state="translated">주어진 이미지 :</target>
        </trans-unit>
        <trans-unit id="bee67862de9af89f58518498619f0ef459e35039" translate="yes" xml:space="preserve">
          <source>Globbing Syntax</source>
          <target state="translated">글 로빙 구문</target>
        </trans-unit>
        <trans-unit id="51665287f81ffa4c55e53b82d779749b7e127ae8" translate="yes" xml:space="preserve">
          <source>GlusterFS plugin</source>
          <target state="translated">GlusterFS 플러그인</target>
        </trans-unit>
        <trans-unit id="0673ed540071b11968320d37b65ee20232768f15" translate="yes" xml:space="preserve">
          <source>Go ahead and write a blog post or two and install a WordPress plugin or theme to verify that WordPress is fully operational and its state is saved across service restarts.</source>
          <target state="translated">계속해서 블로그 게시물을 작성하거나 WordPress 플러그인 또는 테마를 설치하여 WordPress가 완전히 작동하고 서비스 재시작시 상태가 저장되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3b12ed14419e3065935d1ed30aac79858640ed96" translate="yes" xml:space="preserve">
          <source>Go back to your &lt;code&gt;trustsandbox&lt;/code&gt; terminal.</source>
          <target state="translated">&lt;code&gt;trustsandbox&lt;/code&gt; 터미널로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="79f8215efb8d16aacf1e0a78c75b8fc26310ab18" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;http://localhost:8080&quot;&gt;localhost:8080&lt;/a&gt; to access your app in a web browser.</source>
          <target state="translated">웹 브라우저에서 앱에 액세스 하려면 &lt;a href=&quot;http://localhost:8080&quot;&gt;localhost : 8080&lt;/a&gt; 으로 이동 하십시오.</target>
        </trans-unit>
        <trans-unit id="54b8eba47fb94e0ff52889824712c3de0abeef79" translate="yes" xml:space="preserve">
          <source>Go to &lt;strong&gt;Services -&amp;gt; VPC -&amp;gt; Subnets&lt;/strong&gt;. Examine the &lt;em&gt;Availability Zone&lt;/em&gt; column to verify that zone &lt;code&gt;a&lt;/code&gt; exists and matches your VPC ID. For example, &lt;code&gt;us-east1-a&lt;/code&gt; is in the &lt;code&gt;a&lt;/code&gt; availability zone. If the &lt;code&gt;a&lt;/code&gt; zone is not present, you can create a new subnet in that zone or specify a different zone when you create the machine.</source>
          <target state="translated">로 이동 &lt;strong&gt;서비스 -&amp;gt; VPC -&amp;gt; 서브넷&lt;/strong&gt; . &lt;em&gt;가용 영역&lt;/em&gt; 열을 검사하여 영역 &lt;code&gt;a&lt;/code&gt; 가 존재하고 VPC ID와 일치 하는지 확인 하십시오. 예를 들어, &lt;code&gt;us-east1-a&lt;/code&gt; 에 가용성 영역. 는 IF &lt;code&gt;a&lt;/code&gt; 영역이 존재하지 않는, 그 영역에서 새 서브넷을 만들거나 기계를 만들 때 다른 영역을 지정합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb92c8eea2f5637483684d9bc86d74a3c03ab9f4" translate="yes" xml:space="preserve">
          <source>Go to &lt;strong&gt;Services -&amp;gt; VPC -&amp;gt; Your VPCs&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;서비스-&amp;gt; VPC-&amp;gt; VPC로&lt;/strong&gt; 이동 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="25b3f789dd5db1aa2a5f2957dc9fbac20e1090ee" translate="yes" xml:space="preserve">
          <source>Go to that URL in a web browser to see the display content served up on a web page.</source>
          <target state="translated">웹 페이지에서 제공되는 디스플레이 컨텐츠를 보려면 웹 브라우저에서 해당 URL로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="3dd09d5fb018bca9576f60e0dc9a8d8f40a80350" translate="yes" xml:space="preserve">
          <source>Go to the AWS EC2 Dashboard to view the new instance.</source>
          <target state="translated">새 인스턴스를 보려면 AWS EC2 대시 보드로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="040e3056c8cf0dc8fa50e5ec069563aff7a9edac" translate="yes" xml:space="preserve">
          <source>Go to the DigitalOcean administrator console and click &lt;strong&gt;API&lt;/strong&gt; in the header.</source>
          <target state="translated">DigitalOcean 관리자 콘솔로 이동 하여 헤더에서 &lt;strong&gt;API&lt;/strong&gt; 를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="b009f6740b84b84125c84faf77194c54c608c7fa" translate="yes" xml:space="preserve">
          <source>Go to the DigitalOcean console to view the new Droplet.</source>
          <target state="translated">새로운 Droplet을 보려면 DigitalOcean 콘솔로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="13de1abe2b3daaf07f706ccac14f86e87ef9fb92" translate="yes" xml:space="preserve">
          <source>Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="translated">Go의 &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;텍스트 / 템플릿&lt;/a&gt; 패키지는 형식의 모든 세부 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="64dba342f6f438adc0ed8471f6544dba7deb8072" translate="yes" xml:space="preserve">
          <source>Go&amp;rsquo;s &lt;a href=&quot;https://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d44810feafd2c523c653a0858f6ce81d6535da" translate="yes" xml:space="preserve">
          <source>Good places to start working with Docker Machine and swarm mode are these tutorials:</source>
          <target state="translated">Docker Machine 및 swarm 모드 작업을 시작하기에 좋은 장소는 다음 자습서입니다.</target>
        </trans-unit>
        <trans-unit id="d1f877ebab5e3608eee1d8de6deec710e65ac7e2" translate="yes" xml:space="preserve">
          <source>Google Compute Engine</source>
          <target state="translated">구글 컴퓨팅 엔진</target>
        </trans-unit>
        <trans-unit id="f66442be901b04e358fdfdd60b4ff5628affd7df" translate="yes" xml:space="preserve">
          <source>Google Compute Engine supports &lt;a href=&quot;https://cloud.google.com/compute/docs/images#image_families&quot;&gt;image families&lt;/a&gt;. An image family is like an image alias that always points to the latest image in the family. To create an instance from an image family, set &lt;code&gt;--google-machine-image&lt;/code&gt; to the family&amp;rsquo;s URL.</source>
          <target state="translated">Google Compute Engine은 &lt;a href=&quot;https://cloud.google.com/compute/docs/images#image_families&quot;&gt;이미지 제품군을&lt;/a&gt; 지원합니다 . 이미지 패밀리는 항상 패밀리의 최신 이미지를 가리키는 이미지 별명과 같습니다. 이미지 제품군에서 인스턴스를 만들려면 &lt;code&gt;--google-machine-image&lt;/code&gt; 를 제품군의 URL로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4066ae2506fa1adfdab8e5053cdca853bfac7c3b" translate="yes" xml:space="preserve">
          <source>Got a &amp;ldquo;Permission denied&amp;rdquo; error?</source>
          <target state="translated">&quot;권한 거부&quot;오류가 발생 했습니까?</target>
        </trans-unit>
        <trans-unit id="8fd864633a25913d297702dc3500c831db931438" translate="yes" xml:space="preserve">
          <source>Grab (copy to clipboard) the generated big long hex string and store it somewhere safe.</source>
          <target state="translated">생성 된 큰 긴 16 진 문자열을 잡고 (클립 보드로 복사) 안전한 곳에 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="fd9b17c8439254dd265aae1ceffe1ae2a6ef5481" translate="yes" xml:space="preserve">
          <source>Grab your subscription ID from the portal, then run &lt;code&gt;docker-machine create&lt;/code&gt; with these details:</source>
          <target state="translated">포털에서 구독 ID를 가져온 후 다음 세부 사항으로 &lt;code&gt;docker-machine create&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="9616efbfa90ef0c39003a46389ac5c069696f704" translate="yes" xml:space="preserve">
          <source>Grant a service access to secrets</source>
          <target state="translated">비밀에 대한 서비스 액세스 권한 부여</target>
        </trans-unit>
        <trans-unit id="ecfac8e8a28f05ddc0d3b89986dc4ef8512223f2" translate="yes" xml:space="preserve">
          <source>Grant access to configs on a per-service basis using the per-service &lt;code&gt;configs&lt;/code&gt; configuration. Two different syntax variants are supported.</source>
          <target state="translated">서비스 별 &lt;code&gt;configs&lt;/code&gt; 구성을 사용하여 서비스별로 구성에 대한 액세스 권한을 부여하십시오 . 서로 다른 두 가지 구문 변형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b8b79a06a8546379b7fbe5f7a4c7db669716bce5" translate="yes" xml:space="preserve">
          <source>Grant access to secrets on a per-service basis using the per-service &lt;code&gt;secrets&lt;/code&gt; configuration. Two different syntax variants are supported.</source>
          <target state="translated">서비스 별 &lt;code&gt;secrets&lt;/code&gt; 구성을 사용하여 서비스별로 비밀에 대한 액세스 권한을 부여하십시오 . 서로 다른 두 가지 구문 변형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d0231b9eadfacd6a247112b37639e1fa32145988" translate="yes" xml:space="preserve">
          <source>Grant all permissions necessary to run the plugin</source>
          <target state="translated">플러그인 실행에 필요한 모든 권한 부여</target>
        </trans-unit>
        <trans-unit id="2bcc14f36a87e86c092e1201e7bf7f29a6d21399" translate="yes" xml:space="preserve">
          <source>Graylog Extended Log Format (GELF) logging driver for Docker. Writes log messages to a GELF endpoint likeGraylog or Logstash.</source>
          <target state="translated">Docker 용 Graylog 확장 로그 형식 (GELF) 로깅 드라이버. Graylog 또는 Logstash와 같은 GELF 엔드 포인트에 로그 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bb63d1f28fe86f7128721a1b7924f1deaa9aee49" translate="yes" xml:space="preserve">
          <source>Great for modern cloud-based apps, such as web apps, IoT apps, and mobile backends</source>
          <target state="translated">웹 앱, IoT 앱 및 모바일 백엔드와 같은 최신 클라우드 기반 앱에 적합</target>
        </trans-unit>
        <trans-unit id="5b710e16770052f7ebcf2f41f0cf17bdc1c752a6" translate="yes" xml:space="preserve">
          <source>HBM plugin</source>
          <target state="translated">HBM 플러그인</target>
        </trans-unit>
        <trans-unit id="db6e7e402e1777867190b31a1ec0305a7cf5621e" translate="yes" xml:space="preserve">
          <source>HEALTHCHECK</source>
          <target state="translated">HEALTHCHECK</target>
        </trans-unit>
        <trans-unit id="02336c6e968613f3651f7a0b0e98956801ec5ab3" translate="yes" xml:space="preserve">
          <source>HPE 3Par Volume Plugin</source>
          <target state="translated">HPE 3Par 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="a9c2fd09a4d24e664f72626ea645e59cbde69cb7" translate="yes" xml:space="preserve">
          <source>HTTP client timeout (in seconds)</source>
          <target state="translated">HTTP 클라이언트 시간 초과 (초)</target>
        </trans-unit>
        <trans-unit id="cc5eaf888d33fcb382633877f14e39b9070734c2" translate="yes" xml:space="preserve">
          <source>Handling transient errors</source>
          <target state="translated">일시적인 오류 처리</target>
        </trans-unit>
        <trans-unit id="21e5415e1df07bb12a6bc3ab9d69a439dc136160" translate="yes" xml:space="preserve">
          <source>Handshake API</source>
          <target state="translated">핸드 셰이크 API</target>
        </trans-unit>
        <trans-unit id="fe37da07f8dfc25e0b6cf2fd7d1c842f4a7b7c32" translate="yes" xml:space="preserve">
          <source>Hardware storage and signing</source>
          <target state="translated">하드웨어 저장 및 서명</target>
        </trans-unit>
        <trans-unit id="c1ed7863787063f12356455a8184b2640dd2fdac" translate="yes" xml:space="preserve">
          <source>Has access to the &lt;code&gt;mysql_password&lt;/code&gt; secret, but specifies a different target file name within the container. The WordPress container uses the mount point &lt;code&gt;/run/secrets/wp_db_password&lt;/code&gt;. Also specifies that the secret is not group-or-world-readable, by setting the mode to &lt;code&gt;0400&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mysql_password&lt;/code&gt; 시크릿에 액세스 할 수 있지만 컨테이너 내에서 다른 대상 파일 이름을 지정합니다. WordPress 컨테이너는 마운트 지점 &lt;code&gt;/run/secrets/wp_db_password&lt;/code&gt; 를 사용 합니다. 모드를 &lt;code&gt;0400&lt;/code&gt; 으로 설정하여 비밀을 그룹 또는 세계가 읽을 수 없도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="ef1491a3661644508c36b0d7d23c4ff24e15cf51" translate="yes" xml:space="preserve">
          <source>Have &lt;a href=&quot;../part5/index#persist-the-data&quot;&gt;the final version of &lt;code&gt;docker-compose.yml&lt;/code&gt; from Part 5&lt;/a&gt; handy.</source>
          <target state="translated">이 &lt;a href=&quot;../part5/index#persist-the-data&quot;&gt;최종 버전 &lt;code&gt;docker-compose.yml&lt;/code&gt; 5 부에서&lt;/a&gt; 편리합니다.</target>
        </trans-unit>
        <trans-unit id="09bc4722141b1ec5aedc45a2ea415bfe8090e584" translate="yes" xml:space="preserve">
          <source>Have Docker Desktop for Windows installed, and running (which requires that virtualization and Hyper-V are enabled, as described in &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/#what-to-know-before-you-install&quot;&gt;What to know before you install Docker Desktop for Windows&lt;/a&gt;).</source>
          <target state="translated">Windows 용 Docker Desktop이 설치되어 실행 중이 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/#what-to-know-before-you-install&quot;&gt;어야합니다 (Windows 용 Docker Desktop을 설치하기 전에 알아야 할 사항에&lt;/a&gt; 설명 된대로 가상화 및 Hyper-V가 활성화 되어 있어야 함 ).</target>
        </trans-unit>
        <trans-unit id="1e0b821dc3a915c2e03d05bf64e70f05852e72e6" translate="yes" xml:space="preserve">
          <source>Have a copy of your &lt;code&gt;docker-compose.yml&lt;/code&gt; from &lt;a href=&quot;../part3/index&quot;&gt;Part 3&lt;/a&gt; handy.</source>
          <target state="translated">당신의 사본이 &lt;code&gt;docker-compose.yml&lt;/code&gt; 에서 &lt;a href=&quot;../part3/index&quot;&gt;3 부&lt;/a&gt; 편리합니다.</target>
        </trans-unit>
        <trans-unit id="a3386285efc1ceef0ecd4c7ada2a8943827bc33e" translate="yes" xml:space="preserve">
          <source>Have the swarm you created in &lt;a href=&quot;../part4/index&quot;&gt;part 4&lt;/a&gt; running and ready. Run &lt;code&gt;docker-machine ssh myvm1 &quot;docker node ls&quot;&lt;/code&gt; to verify this. If the swarm is up, both nodes report a &lt;code&gt;ready&lt;/code&gt; status. If not, reinitialize the swarm and join the worker as described in &lt;a href=&quot;../part4/index#set-up-your-swarm&quot;&gt;Set up your swarm&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../part4/index&quot;&gt;파트 4&lt;/a&gt; 에서 생성 한 떼를 실행하고 준비하십시오. 실행 &lt;code&gt;docker-machine ssh myvm1 &quot;docker node ls&quot;&lt;/code&gt; 이 문제를 확인합니다. 떼가 가동되면 두 노드 모두 &lt;code&gt;ready&lt;/code&gt; 상태를 보고합니다 . 그렇지 않은 경우 떼를 다시 초기화하고 떼 &lt;a href=&quot;../part4/index#set-up-your-swarm&quot;&gt;설정에&lt;/a&gt; 설명 된대로 작업자를 가입시킵니다 .</target>
        </trans-unit>
        <trans-unit id="16de27768464485eca7baed4ed024a40e4ed787e" translate="yes" xml:space="preserve">
          <source>Having any &lt;code&gt;ARG&lt;/code&gt; or &lt;code&gt;ENV&lt;/code&gt; setting in a &lt;code&gt;Dockerfile&lt;/code&gt; evaluates only if there is no Docker Compose entry for &lt;code&gt;environment&lt;/code&gt; or &lt;code&gt;env_file&lt;/code&gt;.</source>
          <target state="translated">어떤 갖는 &lt;code&gt;ARG&lt;/code&gt; 또는 &lt;code&gt;ENV&lt;/code&gt; A의 설정 &lt;code&gt;Dockerfile&lt;/code&gt; 하기 위한 도커 작성 항목이없는 경우에만 평가 &lt;code&gt;environment&lt;/code&gt; 또는 &lt;code&gt;env_file&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="e5a5f296b206a755b62b27b85d208214380bf627" translate="yes" xml:space="preserve">
          <source>Having connectivity trouble?</source>
          <target state="translated">연결에 문제가 있습니까?</target>
        </trans-unit>
        <trans-unit id="d57a6933acab2779afec570c23520aa17940df95" translate="yes" xml:space="preserve">
          <source>Having the same consistent state across the cluster means that in case of a failure, any Manager node can pick up the tasks and restore the services to a stable state. For example, if the &lt;em&gt;Leader Manager&lt;/em&gt; which is responsible for scheduling tasks in the cluster dies unexpectedly, any other Manager can pick up the task of scheduling and re-balance tasks to match the desired state.</source>
          <target state="translated">클러스터에서 동일한 일관된 상태를 유지한다는 것은 장애 발생시 모든 Manager 노드가 작업을 선택하고 서비스를 안정적인 상태로 복원 할 수 있음을 의미합니다. 예를 들어, 클러스터에서 작업 예약을 담당 하는 &lt;em&gt;Leader Manager&lt;/em&gt; 가 예기치 않게 종료되면 다른 Manager는 원하는 작업을 예약하고 원하는 상태에 맞게 작업의 균형을 다시 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b57f072d4b8b2bf99c146fe81fa8cd33dff3e09" translate="yes" xml:space="preserve">
          <source>Having trouble using SSH? Try the --native-ssh flag</source>
          <target state="translated">SSH 사용에 문제가 있습니까? --native-ssh 플래그를 사용해보십시오</target>
        </trans-unit>
        <trans-unit id="04d6aa94bf3279a3d0ee296b36a0bb5fad58fc11" translate="yes" xml:space="preserve">
          <source>Here are some commands you might like to run to interact with your swarm and your VMs a bit:</source>
          <target state="translated">swarm 및 VM과 약간의 상호 작용을 위해 실행하려는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99bdcb1c2c5082b6ede9f467943ce98e43bf378b" translate="yes" xml:space="preserve">
          <source>Here are some helpful tips for debugging any problems you might be facing with regard to AppArmor.</source>
          <target state="translated">다음은 AppArmor와 관련하여 발생할 수있는 문제를 디버깅하는 데 유용한 팁입니다.</target>
        </trans-unit>
        <trans-unit id="ecddffb4f5e497bb8fa8e8bdeb858734eab7004a" translate="yes" xml:space="preserve">
          <source>Here in part 4, you deploy this application onto a cluster, running it on multiple machines. Multi-container, multi-machine applications are made possible by joining multiple machines into a &amp;ldquo;Dockerized&amp;rdquo; cluster called a &lt;strong&gt;swarm&lt;/strong&gt;.</source>
          <target state="translated">4 부에서는이 애플리케이션을 클러스터에 배치하여 여러 머신에서 실행합니다. 여러 컨테이너를 여러 시스템을 &lt;strong&gt;swarm&lt;/strong&gt; 이라는 &quot;Dockerized&quot;클러스터에 결합하여 다중 컨테이너, 다중 컴퓨터 응용 프로그램을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f31addec83c21d2834a75989acd2414d04370d1" translate="yes" xml:space="preserve">
          <source>Here in part 5, you reach the top of the hierarchy of distributed applications: the &lt;strong&gt;stack&lt;/strong&gt;. A stack is a group of interrelated services that share dependencies, and can be orchestrated and scaled together. A single stack is capable of defining and coordinating the functionality of an entire application (though very complex applications may want to use multiple stacks).</source>
          <target state="translated">여기서 5 부에서는 분산 응용 프로그램 계층의 최상위 인 &lt;strong&gt;스택에&lt;/strong&gt; 도달합니다 . 스택은 종속성을 공유하는 상호 관련 서비스 그룹으로, 조정 및 조정이 가능합니다. 단일 스택은 전체 애플리케이션의 기능을 정의하고 조정할 수 있습니다 (매우 복잡한 애플리케이션은 여러 스택을 사용하려고 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="012876a7a340ca5b1afd429e1c0d91eaaa304fa2" translate="yes" xml:space="preserve">
          <source>Here is a full client configuration file example; click on the top level JSON keys to learn more about the configuration section corresponding to that key:</source>
          <target state="translated">다음은 전체 클라이언트 구성 파일 예제입니다. 해당 키에 해당하는 구성 섹션에 대해 자세히 알아 보려면 최상위 JSON 키를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="7934cb19c3918e889329f53cbcc4539c9b7c291a" translate="yes" xml:space="preserve">
          <source>Here is a full server configuration file example; click on the top level JSON keys to learn more about the configuration section corresponding to that key:</source>
          <target state="translated">다음은 전체 서버 구성 파일 예입니다. 해당 키에 해당하는 구성 섹션에 대해 자세히 알아 보려면 최상위 JSON 키를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="55d8059b2e57140a42b334f50b3fb6a67d4378ec" translate="yes" xml:space="preserve">
          <source>Here is a full signer configuration file example; click on the top level JSON keys to learn more about the configuration section corresponding to that key:</source>
          <target state="translated">다음은 전체 서명자 구성 파일 예제입니다. 해당 키에 해당하는 구성 섹션에 대해 자세히 알아 보려면 최상위 JSON 키를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="8ce4b802d27a7e720ff6deb8c501f5315a463f6f" translate="yes" xml:space="preserve">
          <source>Here is a list of the basic Docker commands from this page, and some related ones if you&amp;rsquo;d like to explore a bit before moving on.</source>
          <target state="translated">다음은이 페이지의 기본 Docker 명령 목록이며 계속 진행하기 전에 조금 살펴보고 싶은 경우 관련 명령입니다.</target>
        </trans-unit>
        <trans-unit id="55d655a73f06dc16bfa0632865a0f7f4ca1ede65" translate="yes" xml:space="preserve">
          <source>Here is a sample output for a daemon running on Ubuntu, using the overlay2 storage driver and a node that is part of a 2-node swarm:</source>
          <target state="translated">다음은 overlay2 스토리지 드라이버와 2 노드 떼의 일부인 노드를 사용하여 Ubuntu에서 실행되는 데몬의 샘플 출력입니다.</target>
        </trans-unit>
        <trans-unit id="c7954b0b151787613d58a34b0f9121b912e05bce" translate="yes" xml:space="preserve">
          <source>Here is a sample output for a daemon running on Windows Server 2016:</source>
          <target state="translated">다음은 Windows Server 2016에서 실행되는 데몬의 샘플 출력입니다.</target>
        </trans-unit>
        <trans-unit id="a88898c895e3ac08ecadb06044441ba61348ddbb" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;.dockerignore&lt;/code&gt; file:</source>
          <target state="translated">다음은 &lt;code&gt;.dockerignore&lt;/code&gt; 파일 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="e80d52c3843802fe7c42f5ca5d0541ca26a799b9" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;docker-compose.yml&lt;/code&gt; file that limits logging storage:</source>
          <target state="translated">로깅 스토리지를 제한 하는 예제 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일 은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="36f479adec57c169b9c647520b4926c021878e9a" translate="yes" xml:space="preserve">
          <source>Here is an example of configuring a volume as &lt;code&gt;cached&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;cached&lt;/code&gt; 볼륨을 구성하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="97c9fbd96289421ab6c378891585175e8eef8be6" translate="yes" xml:space="preserve">
          <source>Here is an example of creating a &lt;code&gt;manager1&lt;/code&gt; node:</source>
          <target state="translated">다음은 &lt;code&gt;manager1&lt;/code&gt; 노드 를 작성하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c27899e953e5b2b7255f045440c0637ca0d1aa6d" translate="yes" xml:space="preserve">
          <source>Here is an example of creating and pushing a manifest list using a known insecure registry.</source>
          <target state="translated">다음은 알려진 안전하지 않은 레지스트리를 사용하여 목록 목록을 작성하고 푸시하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="440cdc7d803e0dbcc357b3a5ea19529abda92541" translate="yes" xml:space="preserve">
          <source>Here is an example of how to generate a 2048-bit RSA portion key (all RSA keys must be at least 2048 bits):</source>
          <target state="translated">다음은 2048 비트 RSA 부분 키를 생성하는 방법의 예입니다 (모든 RSA 키는 2048 비트 이상이어야 함).</target>
        </trans-unit>
        <trans-unit id="7bdc9c848647047ed7d2d7fe3829138207944b6d" translate="yes" xml:space="preserve">
          <source>Here is an example of inspecting an image&amp;rsquo;s manifest with the &lt;code&gt;--verbose&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;--verbose&lt;/code&gt; 플래그를 사용하여 이미지의 매니페스트를 검사하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="07b65c9fe6375351015090eff736c93b63dfe1d1" translate="yes" xml:space="preserve">
          <source>Here is an example of the first case, where a full rebuild is not necessary. Suppose you simply want to change the exposed port on the local host from &lt;code&gt;3000&lt;/code&gt; in our first example to &lt;code&gt;3001&lt;/code&gt;. Make the change to the Compose file to expose port &lt;code&gt;3000&lt;/code&gt; on the container through a new port, &lt;code&gt;3001&lt;/code&gt;, on the host, and save the changes:</source>
          <target state="translated">다음은 전체 재 구축이 필요하지 않은 첫 번째 사례의 예입니다. 첫 번째 예에서 로컬 호스트의 노출 된 포트를 &lt;code&gt;3000&lt;/code&gt; 에서 &lt;code&gt;3001&lt;/code&gt; 로 변경하려고한다고 가정하십시오 . 호스트 의 새 포트 &lt;code&gt;3001&lt;/code&gt; 을 통해 컨테이너의 포트 &lt;code&gt;3000&lt;/code&gt; 을 표시하도록 작성 파일을 변경하고 변경 사항을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="ba49f2c3f1ffc16ecc6a245d0c7583bd659e9a54" translate="yes" xml:space="preserve">
          <source>Here is an example of the output from that command:</source>
          <target state="translated">다음은 해당 명령의 출력 예입니다.</target>
        </trans-unit>
        <trans-unit id="15e6025132f0a4c10041c40737ddd97da5df8e13" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;--virtualbox&lt;/code&gt; driver to create a machine called &lt;code&gt;dev&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;--virtualbox&lt;/code&gt; 드라이버를 사용하여 &lt;code&gt;dev&lt;/code&gt; 라는 컴퓨터를 만드는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="16ff1673f1641d410d645595aa0d45e0c6dd1b56" translate="yes" xml:space="preserve">
          <source>Here is example output from this command.</source>
          <target state="translated">다음은이 명령의 출력 예입니다.</target>
        </trans-unit>
        <trans-unit id="07491c58f4f5a3d57e439662e68c3f55bb138fe4" translate="yes" xml:space="preserve">
          <source>Here is the format of the &lt;code&gt;Dockerfile&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 의 형식은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="28728080a5c2f890168c2dd98c7d9c9dc1d05f8b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;https://asciinema.org/a/113837&quot;&gt;a terminal recording of what was covered on this page&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://asciinema.org/a/113837&quot;&gt;이 페이지에서 다룬 내용에 대한 터미널 기록은&lt;/a&gt; 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1f9da5fe71bd0e7e3e60320defdd3e7fbd6b80a2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;https://asciinema.org/a/113840&quot;&gt;a terminal recording of what was covered on this page&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://asciinema.org/a/113840&quot;&gt;이 페이지에서 다룬 내용에 대한 터미널 기록은&lt;/a&gt; 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="68f60b76e8ebccba5af3938d805eebbe4d0bdb2a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;https://asciinema.org/a/b5gai4rnflh7r0kie01fx6lip&quot;&gt;a terminal recording of what was covered on this page&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://asciinema.org/a/b5gai4rnflh7r0kie01fx6lip&quot;&gt;이 페이지에서 다룬 내용에 대한 터미널 기록은&lt;/a&gt; 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="477271c960ec6590e2772889f54a644af11ed2d0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;https://asciinema.org/a/blkah0l4ds33tbe06y4vkme6g&quot;&gt;a terminal recording of what was covered on this page&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://asciinema.org/a/blkah0l4ds33tbe06y4vkme6g&quot;&gt;이 페이지에서 다룬 내용에 대한 터미널 기록은&lt;/a&gt; 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4a60aafb81a33956550e5d8d73932c7430212d91" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example Compose file defining two custom networks. The &lt;code&gt;proxy&lt;/code&gt; service is isolated from the &lt;code&gt;db&lt;/code&gt; service, because they do not share a network in common - only &lt;code&gt;app&lt;/code&gt; can talk to both.</source>
          <target state="translated">다음은 두 개의 사용자 지정 네트워크를 정의하는 작성 파일의 예입니다. &lt;code&gt;proxy&lt;/code&gt; 서비스는 분리되어 &lt;code&gt;db&lt;/code&gt; 공통점에서 네트워크를 공유하지 않기 때문에, 서비스 - 전용 &lt;code&gt;app&lt;/code&gt; 모두 이야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b112f5a190b366e38d7518baface6ac108a698" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a repo with two signed tags:</source>
          <target state="translated">다음은 서명 된 태그가 두 개인 리포지토리의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e2055f6e0255723780176607bb54b568a2b8ae05" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a two-service setup where a database&amp;rsquo;s data directory is shared with another service as a volume so that it can be periodically backed up:</source>
          <target state="translated">다음은 데이터베이스의 데이터 디렉토리가 다른 서비스와 볼륨으로 공유되어 주기적으로 백업 될 수있는 2 서비스 설정의 예입니다.</target>
        </trans-unit>
        <trans-unit id="88cdc476f3ab52131bfc40dc323a544001123d41" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of using data volumes to share the same data between two CouchDB containers. This could be used for hot upgrades, testing different versions of CouchDB on the same data, etc.</source>
          <target state="translated">다음은 데이터 볼륨을 사용하여 두 CouchDB 컨테이너간에 동일한 데이터를 공유하는 예입니다. 이것은 동일한 데이터에서 다른 버전의 CouchDB를 테스트하는 등 핫 업그레이드에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91af00fc7f9bb0964c71855a22e172d5935505c2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example with signers that are set up by &lt;code&gt;docker trust&lt;/code&gt; commands:</source>
          <target state="translated">다음은 &lt;code&gt;docker trust&lt;/code&gt; 명령으로 설정된 서명자가있는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="2b711022bbdbc55a24bd7712dcd9c1fcf0e90f44" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how it works:</source>
          <target state="translated">작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c740cebd896921b48b41c78db03f5bfa8b754c71" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the full example:</source>
          <target state="translated">전체 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0356d78302bb6e8fb66ba78e3020e8d16c17a79" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;-r&lt;/code&gt; specifies to rotate the key to the remote server.</source>
          <target state="translated">여기서 &lt;code&gt;-r&lt;/code&gt; 은 키를 원격 서버로 회전하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ffcadc3bbf92f4882971ddc3bc8286e63dfa62c0" translate="yes" xml:space="preserve">
          <source>High Availability</source>
          <target state="translated">고 가용성</target>
        </trans-unit>
        <trans-unit id="439b7c90c9fd4f767dce7203b0635ac42a29567a" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;CTRL+C&lt;/code&gt; in your terminal to quit.</source>
          <target state="translated">히트 &lt;code&gt;CTRL+C&lt;/code&gt; 를 종료 할 터미널에서.</target>
        </trans-unit>
        <trans-unit id="45edd6c820ea8184641be8c6ffc7e7caedb6173c" translate="yes" xml:space="preserve">
          <source>Horcrux Volume Plugin</source>
          <target state="translated">Horcrux 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="aab5eacb530c0786c019f614828a16641a102a70" translate="yes" xml:space="preserve">
          <source>Host bind mounts are non-portable. When you use bind mounts, there is no guarantee that your application runs the same way in development as it does in production.</source>
          <target state="translated">호스트 바인드 마운트는 이식 가능하지 않습니다. 바인드 마운트를 사용하는 경우 프로덕션 환경에서와 동일한 방식으로 응용 프로그램이 개발 환경에서 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="65b2efc41c178618f0bedf23b641c9bcd4c97e2f" translate="yes" xml:space="preserve">
          <source>Host ports and recreating containers</source>
          <target state="translated">호스트 포트 및 컨테이너 재 작성</target>
        </trans-unit>
        <trans-unit id="202ec01f09c75399a78fe08e42800dd93f90bf36" translate="yes" xml:space="preserve">
          <source>HostConfig at API container start</source>
          <target state="translated">API 컨테이너 시작시 HostConfig</target>
        </trans-unit>
        <trans-unit id="637c0912bb07b11e14917a5bfeb1d184bd8ea510" translate="yes" xml:space="preserve">
          <source>Hot logging level reload</source>
          <target state="translated">핫 로깅 레벨 재로드</target>
        </trans-unit>
        <trans-unit id="ba1466699cbc973dbd34eef9e410b3dda260263c" translate="yes" xml:space="preserve">
          <source>How Docker manages configs</source>
          <target state="translated">Docker가 구성을 관리하는 방법</target>
        </trans-unit>
        <trans-unit id="82832431047da672c6b6e0aa4d743553961bb2b1" translate="yes" xml:space="preserve">
          <source>How Docker manages secrets</source>
          <target state="translated">Docker가 비밀을 관리하는 방법</target>
        </trans-unit>
        <trans-unit id="a66c84947c8ea28fef0c53be09e5627880874eaf" translate="yes" xml:space="preserve">
          <source>How do I run multiple copies of a Compose file on the same host?</source>
          <target state="translated">동일한 호스트에서 작성 파일의 여러 사본을 어떻게 실행합니까?</target>
        </trans-unit>
        <trans-unit id="2a163afa82fce4e6845c7906e025d68a0819e056" translate="yes" xml:space="preserve">
          <source>How mature is the code providing kernel namespaces and private networking? Kernel namespaces were introduced &lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;between kernel version 2.6.15 and 2.6.26&lt;/a&gt;. This means that since July 2008 (date of the 2.6.26 release ), namespace code has been exercised and scrutinized on a large number of production systems. And there is more: the design and inspiration for the namespaces code are even older. Namespaces are actually an effort to reimplement the features of &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenVZ&quot;&gt;OpenVZ&lt;/a&gt; in such a way that they could be merged within the mainstream kernel. And OpenVZ was initially released in 2005, so both the design and the implementation are pretty mature.</source>
          <target state="translated">커널 네임 스페이스와 개인 네트워킹을 제공하는 코드는 얼마나 성숙합니까? 커널 네임 스페이스는 &lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;커널 버전 2.6.15와 2.6.26 사이&lt;/a&gt; 에 도입되었습니다 . 이는 2008 년 7 월 (2.6.26 릴리스 날짜) 이후로 많은 프로덕션 시스템에서 네임 스페이스 코드가 실행되고 조사되었음을 의미합니다. 네임 스페이스 코드의 디자인과 영감은 훨씬 더 오래되었습니다. 네임 스페이스는 실제로 주류 커널 내에서 병합 될 수있는 방식으로 &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenVZ&quot;&gt;OpenVZ&lt;/a&gt; 의 기능을 다시 구현하려는 노력 입니다. OpenVZ는 2005 년에 처음 출시되었으므로 디자인과 구현이 매우 성숙합니다.</target>
        </trans-unit>
        <trans-unit id="e3030e1443369c6c421a05c5ea6b89daa4a3a7c5" translate="yes" xml:space="preserve">
          <source>How mature is the code providing kernel namespaces and private networking? Kernel namespaces were introduced &lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;between kernel version 2.6.15 and 2.6.26&lt;/a&gt;. This means that since July 2008 (date of the 2.6.26 release ), namespace code has been exercised and scrutinized on a large number of production systems. And there is more: the design and inspiration for the namespaces code are even older. Namespaces are actually an effort to reimplement the features of &lt;a href=&quot;https://en.wikipedia.org/wiki/OpenVZ&quot;&gt;OpenVZ&lt;/a&gt; in such a way that they could be merged within the mainstream kernel. And OpenVZ was initially released in 2005, so both the design and the implementation are pretty mature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0410c708959e6513925e2de7870312841cd6bec" translate="yes" xml:space="preserve">
          <source>How nodes work</source>
          <target state="translated">노드 작동 방식</target>
        </trans-unit>
        <trans-unit id="6291a053d3406b54b13841d59fd826501416c55e" translate="yes" xml:space="preserve">
          <source>How services work</source>
          <target state="translated">서비스 작동 방식</target>
        </trans-unit>
        <trans-unit id="0da23ab51d1ab4795ada6410016178cdc8d9b403" translate="yes" xml:space="preserve">
          <source>How to uninstall Docker Machine</source>
          <target state="translated">Docker Machine을 제거하는 방법</target>
        </trans-unit>
        <trans-unit id="91a1b2d44e6a1c5cd7f6b181aab446904c968360" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm mode&lt;/a&gt;, multi-service applications, and stack files now are fully supported. A stack file is a particular type of &lt;a href=&quot;../compose-file/index&quot;&gt;version 3 Compose file&lt;/a&gt;.</source>
          <target state="translated">그러나 이제 &lt;a href=&quot;../../engine/swarm/index&quot;&gt;스웜 모드&lt;/a&gt; , 다중 서비스 응용 프로그램 및 스택 파일이 완전히 지원됩니다. 스택 파일은 특정 유형의 &lt;a href=&quot;../compose-file/index&quot;&gt;버전 3 작성 파일&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f031193f26ac36c74309aafa88704d719da2d6a2" translate="yes" xml:space="preserve">
          <source>However, because manager nodes use the Raft consensus algorithm to replicate data in a consistent way, they are sensitive to resource starvation. You should isolate managers in your swarm from processes that might block swarm operations like swarm heartbeat or leader elections.</source>
          <target state="translated">그러나 관리자 노드는 Raft 합의 알고리즘을 사용하여 데이터를 일관된 방식으로 복제하기 때문에 리소스 부족에 민감합니다. 웜 하트 비트 또는 리더 선거와 같은 웜 작업을 차단할 수있는 프로세스에서 웜의 관리자를 격리해야합니다.</target>
        </trans-unit>
        <trans-unit id="65f57200d36e66f38c273cd3e7dfb95bb769adb2" translate="yes" xml:space="preserve">
          <source>However, for running in production, or if you just want to change those defaults on your development service, you probably want to change those defaults.</source>
          <target state="translated">그러나 프로덕션 환경에서 실행하거나 개발 서비스에서 해당 기본값을 변경하려는 경우 해당 기본값을 변경하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf5f2495bfd743aa602c4d8b96ea00eaa76401d" translate="yes" xml:space="preserve">
          <source>However, for startup Compose does not wait until a container is &amp;ldquo;ready&amp;rdquo; (whatever that means for your particular application) - only until it&amp;rsquo;s running. There&amp;rsquo;s a good reason for this.</source>
          <target state="translated">그러나 시작의 경우 Compose는 컨테이너가 &quot;준비&quot;될 때까지 (특정 응용 프로그램에 해당하는 것이 무엇이든) 실행될 때까지 기다리지 않습니다. 그럴만한 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3acecaa92b2ee43a0aae52eae9ef58017b4cbe5" translate="yes" xml:space="preserve">
          <source>However, if other tags are signed in the same image repository, &lt;code&gt;docker trust inspect&lt;/code&gt; reports relevant key information.</source>
          <target state="translated">그러나 다른 태그가 동일한 이미지 저장소에 서명 된 경우 &lt;code&gt;docker trust inspect&lt;/code&gt; 는 관련 키 정보를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ffd46b81539b05de9e468c84ce0730ab95bead1b" translate="yes" xml:space="preserve">
          <source>However, if other tags are signed in the same image repository, &lt;code&gt;docker trust inspect&lt;/code&gt; reports relevant key information:</source>
          <target state="translated">그러나 다른 태그가 동일한 이미지 저장소에 서명 된 경우 &lt;code&gt;docker trust inspect&lt;/code&gt; 는 관련 주요 정보를보고합니다.</target>
        </trans-unit>
        <trans-unit id="36b5325b0b79825559cbaba4eae7c2e81dc22ec3" translate="yes" xml:space="preserve">
          <source>However, if you are using negative filtering (testing for the absence of a label or that a label does &lt;em&gt;not&lt;/em&gt; have a specific value), this type of filter does not work with &lt;code&gt;docker image ls&lt;/code&gt; so you cannot easily predict which images will be removed. In addition, the confirmation prompt for &lt;code&gt;docker image prune&lt;/code&gt; always warns that &lt;em&gt;all&lt;/em&gt; dangling images will be removed, even if you are using &lt;code&gt;--filter&lt;/code&gt;.</source>
          <target state="translated">당신이 부정적인 필터링을 사용하는 경우에는, (레이블의 부재를 테스트 또는 레이블 않는 것을 &lt;em&gt;하지&lt;/em&gt; 특정 값이),이 유형의 필터하지 작동합니까 &lt;code&gt;docker image ls&lt;/code&gt; 쉽게 이미지가 제거 될 예측할 수 있습니다. 또한, 대한 프롬프트 확인 &lt;code&gt;docker image prune&lt;/code&gt; 항상 있다고 경고 &lt;em&gt;모든&lt;/em&gt; 당신이 사용하는 경우에도, 매달려 이미지가 제거됩니다 &lt;code&gt;--filter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7918f5f0803cd2dd0e7752acbc665e08d43c2f36" translate="yes" xml:space="preserve">
          <source>However, these variables are deprecated. Use the link alias as a hostname instead.</source>
          <target state="translated">그러나 이러한 변수는 더 이상 사용되지 않습니다. 대신 링크 별명을 호스트 이름으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="595b50fb2c3c9212f857e0d0b03e5d84a085bdda" translate="yes" xml:space="preserve">
          <source>Hyper-V hypervisor partition-based isolation.</source>
          <target state="translated">Hyper-V 하이퍼 바이저 파티션 기반 격리.</target>
        </trans-unit>
        <trans-unit id="f70b5ee8b2d415c8f83b1e349fd88c40cc89ed4e" translate="yes" xml:space="preserve">
          <source>Hyper-V is automatically enabled on a Docker Desktop for Windows installation. To enable it manually, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install&quot;&gt;instructions on how to manually enable Hyper-V&lt;/a&gt; on the Microsoft developer network.</source>
          <target state="translated">Windows 용 Docker Desktop에서 Hyper-V가 자동으로 활성화됩니다. &lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install&quot;&gt;수동으로 활성화&lt;/a&gt; 하려면 Microsoft 개발자 네트워크에서 Hyper-V를 수동으로 활성화하는 방법에 대한 지침을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68be18322743fdfe7d234e19622a97818ba2c275" translate="yes" xml:space="preserve">
          <source>Hyper-V must be enabled on your desktop system. Docker Desktop for Windows automatically enables it upon install. See this article on the Microsoft developer network for instructions on &lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install&quot;&gt;how to manually enable Hyper-V&lt;/a&gt;.</source>
          <target state="translated">데스크톱 시스템에서 Hyper-V를 활성화해야합니다. Windows 용 Docker Desktop은 설치시 자동으로 활성화합니다. &lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install&quot;&gt;Hyper-V를 수동으로 활성화하는 방법에&lt;/a&gt; 대한 지침은 Microsoft 개발자 네트워크에서이 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88edcc7de591a470124110111dd4fb258aa34a34" translate="yes" xml:space="preserve">
          <source>IBM Softlayer</source>
          <target state="translated">IBM 소프트 레이어</target>
        </trans-unit>
        <trans-unit id="89f89c02cf47e091e726a4e07b88af0966806897" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="translated">ID</target>
        </trans-unit>
        <trans-unit id="15f654452ba0090d5084013c5bcdcd77b073d552" translate="yes" xml:space="preserve">
          <source>IP Address Management Driver</source>
          <target state="translated">IP 주소 관리 드라이버</target>
        </trans-unit>
        <trans-unit id="04c575095a62156da6b1482b6bf8cba07499f354" translate="yes" xml:space="preserve">
          <source>IP addresses for Docker hosts</source>
          <target state="translated">Docker 호스트의 IP 주소</target>
        </trans-unit>
        <trans-unit id="22c6927c6d183895d00724c44e309703e9489733" translate="yes" xml:space="preserve">
          <source>IP masquerading uses address translation to allow containers without a public IP to talk to other machines on the Internet. This may interfere with some network topologies and can be disabled with &lt;code&gt;--ip-masq=false&lt;/code&gt;.</source>
          <target state="translated">IP 마스커레이딩은 주소 변환을 사용하여 공용 IP가없는 컨테이너가 인터넷의 다른 컴퓨터와 통신 할 수 있도록합니다. 이는 일부 네트워크 토폴로지를 방해 할 수 있으며 &lt;code&gt;--ip-masq=false&lt;/code&gt; 로 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e54cdc837e27a9ef9c7a5786aea030d66d36400" translate="yes" xml:space="preserve">
          <source>IPC (POSIX/SysV IPC) namespace provides separation of named shared memory segments, semaphores and message queues.</source>
          <target state="translated">IPC (POSIX / SysV IPC) 네임 스페이스는 명명 된 공유 메모리 세그먼트, 세마포어 및 메시지 큐를 분리합니다.</target>
        </trans-unit>
        <trans-unit id="40c52666d9f14f9e76af9336197b6876ad55d7b8" translate="yes" xml:space="preserve">
          <source>IPC mode to use</source>
          <target state="translated">사용할 IPC 모드</target>
        </trans-unit>
        <trans-unit id="2466e4de9366459f1331b52a642d6ff263d0437d" translate="yes" xml:space="preserve">
          <source>IPC settings (--ipc)</source>
          <target state="translated">IPC 설정 (--ipc)</target>
        </trans-unit>
        <trans-unit id="db90c7915f34637cc857a2e9c9b0df6e4d64dbea" translate="yes" xml:space="preserve">
          <source>IPC_LOCK</source>
          <target state="translated">IPC_LOCK</target>
        </trans-unit>
        <trans-unit id="f8cd9718aae3aaf817ce7ef407d4f6fa26b3272c" translate="yes" xml:space="preserve">
          <source>IPC_OWNER</source>
          <target state="translated">IPC_OWNER</target>
        </trans-unit>
        <trans-unit id="a413137c336fa9cfc5fb63763ee442f635878b04" translate="yes" xml:space="preserve">
          <source>IPFS Volume Plugin</source>
          <target state="translated">IPFS 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="a97c06de54b1c0355f7b7726d09fc57553ddd3e5" translate="yes" xml:space="preserve">
          <source>IPv4 address (e.g., 172.30.100.104)</source>
          <target state="translated">IPv4 주소 (예 : 172.30.100.104)</target>
        </trans-unit>
        <trans-unit id="06218b3580cfdd3af453d7fa1c82258d46390c37" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 Gateway for the master subnet</source>
          <target state="translated">마스터 서브넷의 IPv4 또는 IPv6 게이트웨이</target>
        </trans-unit>
        <trans-unit id="eda5197799acfaeecf77176298726e1ca2e7fcf9" translate="yes" xml:space="preserve">
          <source>IPv6 address (e.g., 2001:db8::33)</source>
          <target state="translated">IPv6 주소 (예 : 2001 : db8 :: 33)</target>
        </trans-unit>
        <trans-unit id="f8bd55f1886f390e745c1924f86128a5e48c2dd2" translate="yes" xml:space="preserve">
          <source>Ideally a manifest list is created from images that are identical in function for different os/arch combinations. For this reason, manifest lists are often referred to as &amp;ldquo;multi-arch images&amp;rdquo;. However, a user could create a manifest list that points to two images -- one for windows on amd64, and one for darwin on amd64.</source>
          <target state="translated">이상적으로 매니페스트 목록은 다른 os / arch 조합에 대해 기능이 동일한 이미지에서 생성됩니다. 이러한 이유로 매니페스트 목록을 종종 &quot;다중 아치 이미지&quot;라고합니다. 그러나 사용자는 amd64의 Windows 용 이미지와 amd64의 darwin 용 이미지 두 개를 가리키는 매니페스트 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f0960fef5b7b3091f4e195e2ac4ecc847605a55" translate="yes" xml:space="preserve">
          <source>Identifier type</source>
          <target state="translated">식별자 유형</target>
        </trans-unit>
        <trans-unit id="6b0887047e138c19fdbe87a5581ec8aecbc24b22" translate="yes" xml:space="preserve">
          <source>Identify the trust server.</source>
          <target state="translated">트러스트 서버를 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="32f7d9150b37267443b1177b2ee3eb025b104ee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; does not end with a trailing slash, it will be considered a regular file and the contents of &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; will be written at &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 슬래시로 끝나지 않습니다, 그것은 일반 파일로 간주되고의 내용을 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 에 기록됩니다 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="539c64406ae2fa496fee2c6f29de9649edbfe14a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, it is created along with all missing directories in its path.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 존재하지 않는, 그것은 경로에 누락 된 모든 디렉토리와 함께 생성된다.</target>
        </trans-unit>
        <trans-unit id="842bab613fc35508eb6b7dcb914be5e7c0d18054" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a &lt;em&gt;local&lt;/em&gt; tar archive in a recognized compression format (identity, gzip, bzip2 or xz) then it is unpacked as a directory. Resources from &lt;em&gt;remote&lt;/em&gt; URLs are &lt;strong&gt;not&lt;/strong&gt; decompressed. When a directory is copied or unpacked, it has the same behavior as &lt;code&gt;tar -x&lt;/code&gt;, the result is the union of:</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; A는 &lt;em&gt;현지&lt;/em&gt; 인정 압축 포맷 (정체성, GZIP, 레스 햇의 bzip2 또는 XZ)에서 tar 아카이브는 다음 디렉토리로 압축을 푼입니다. &lt;em&gt;원격&lt;/em&gt; URL의 리소스는 압축 해제 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 디렉토리를 복사하거나 압축을 풀면 &lt;code&gt;tar -x&lt;/code&gt; 와 동일한 동작을 하며 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e8767479a2d5e29954fe45ee7268f41c06c1f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a URL and &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; does end with a trailing slash, then the filename is inferred from the URL and the file is downloaded to &lt;code&gt;&amp;lt;dest&amp;gt;/&amp;lt;filename&amp;gt;&lt;/code&gt;. For instance, &lt;code&gt;ADD http://example.com/foobar /&lt;/code&gt; would create the file &lt;code&gt;/foobar&lt;/code&gt;. The URL must have a nontrivial path so that an appropriate filename can be discovered in this case (&lt;code&gt;http://example.com&lt;/code&gt; will not work).</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 된 URL과 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 후행 슬래시 수행 끝에, 다음 파일 이름은 URL에서 유추하고 파일을 다운로드하는 것입니다 &lt;code&gt;&amp;lt;dest&amp;gt;/&amp;lt;filename&amp;gt;&lt;/code&gt; . 예를 들어, &lt;code&gt;ADD http://example.com/foobar /&lt;/code&gt; 하면 &lt;code&gt;/foobar&lt;/code&gt; 파일이 작성됩니다 . 이 경우 적절한 파일 이름을 찾을 수 있도록 URL에 중요한 경로가 없어야합니다 ( &lt;code&gt;http://example.com&lt;/code&gt; 은 작동하지 않음).</target>
        </trans-unit>
        <trans-unit id="676a783f898e1a6f6cffc90f4643e2cf72864126" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a URL and &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; does not end with a trailing slash, then a file is downloaded from the URL and copied to &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 된 URL과 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 슬래시로 끝나지 않고, 다음 파일이 URL에서 다운로드하고 복사 한 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68fbdc021c183db50cecc0b5ee1e55448c29a2b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a directory, the entire contents of the directory are copied, including filesystem metadata.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 디렉토리 인 디렉토리의 전체 내용은 파일 시스템의 메타 데이터를 포함, 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="dd5913665cd74adbf26bf555efa691c526c29cf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is any other kind of file, it is copied individually along with its metadata. In this case, if &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; ends with a trailing slash &lt;code&gt;/&lt;/code&gt;, it will be considered a directory and the contents of &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; will be written at &lt;code&gt;&amp;lt;dest&amp;gt;/base(&amp;lt;src&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 파일의 모든 다른 종류의, 그것은 개별적으로 메타 데이터와 함께 복사됩니다. 이 경우, &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 슬래시와 단부 &lt;code&gt;/&lt;/code&gt; , 그것이 디렉토리 간주되며 내용 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 에 기록 될 &lt;code&gt;&amp;lt;dest&amp;gt;/base(&amp;lt;src&amp;gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39f9a5c964a89ebecc93c25ead12f621739da34f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;/dev&lt;/code&gt; is bind mounted from the host, and allowAllDevices is set to true, the plugin will have &lt;code&gt;rwm&lt;/code&gt; access to all devices on the host.</source>
          <target state="translated">경우 &lt;code&gt;/dev&lt;/code&gt; 바인드가 호스트에서 마운트이며, allowAllDevices가 true로 설정되어있는 플러그인이있을 것이다 &lt;code&gt;rwm&lt;/code&gt; 호스트에있는 모든 장치에 대한 액세스를.</target>
        </trans-unit>
        <trans-unit id="21ab4b19972f6f8674f90605d1f4f77ad0a9a4ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SIGINT&lt;/code&gt; or &lt;code&gt;SIGTERM&lt;/code&gt; is sent again during this shutdown phase, the running containers are killed, and the exit code is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SIGINT&lt;/code&gt; 또는 &lt;code&gt;SIGTERM&lt;/code&gt; 이 이 종료 단계에서 다시 전송됩니다, 실행중인 컨테이너는 살해되고, 종료 코드는 &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc71b0837f7450d286a62fbc12b4d86d0fea73a9" translate="yes" xml:space="preserve">
          <source>If Compose detects containers that were created without labels, it refuses to run, so that you don&amp;rsquo;t end up with two sets of them. If you want to keep using your existing containers (for example, because they have data volumes you want to preserve), you can use Compose 1.5.x to migrate them with the following command:</source>
          <target state="translated">Compose가 레이블없이 작성된 컨테이너를 감지하면 실행을 거부하므로 두 세트로 끝나지 않습니다. 기존 컨테이너를 계속 사용하려면 (예 : 보존하려는 데이터 볼륨이 있기 때문에) Compose 1.5.x를 사용하여 다음 명령으로 컨테이너를 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55ee9fd8da42bd7283fda32df5a05d6fbb30bffe" translate="yes" xml:space="preserve">
          <source>If IPv6 addressing is desired, the &lt;code&gt;enable_ipv6&lt;/code&gt; option must be set, and you must use a &lt;a href=&quot;compose-file-v2/index#ipv4_address-ipv6_address&quot;&gt;version 2.x Compose file&lt;/a&gt;. &lt;em&gt;IPv6 options do not currently work in swarm mode&lt;/em&gt;.</source>
          <target state="translated">IPv6 주소 지정이 필요한 경우 &lt;code&gt;enable_ipv6&lt;/code&gt; 옵션을 설정해야하며 &lt;a href=&quot;compose-file-v2/index#ipv4_address-ipv6_address&quot;&gt;버전 2.x Compose 파일을&lt;/a&gt; 사용해야 합니다 . &lt;em&gt;IPv6 옵션은 현재 swarm 모드에서 작동하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7f38117e34f41a3067a78a850264efe0aa2d80f6" translate="yes" xml:space="preserve">
          <source>If TLS is enabled in the &lt;a href=&quot;../../security/https/index&quot;&gt;Docker daemon&lt;/a&gt;, the default user authorization flow extracts the user details from the certificate subject name. That is, the &lt;code&gt;User&lt;/code&gt; field is set to the client certificate subject common name, and the &lt;code&gt;AuthenticationMethod&lt;/code&gt; field is set to &lt;code&gt;TLS&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../security/https/index&quot;&gt;Docker 데몬&lt;/a&gt; 에서 TLS가 사용 가능한 경우 기본 사용자 권한 부여 플로우는 인증서 주제 이름에서 사용자 세부 사항을 추출합니다. 즉, &lt;code&gt;User&lt;/code&gt; 필드는 클라이언트 인증서 주제 공통 이름 으로 설정되고 &lt;code&gt;AuthenticationMethod&lt;/code&gt; 필드는 &lt;code&gt;TLS&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e0b2df7e0eb39fb3e67b2d9f59f42df4b471eff" translate="yes" xml:space="preserve">
          <source>If a Notary Service credential compromise is detected, the credentials should be changed immediately.</source>
          <target state="translated">공증 서비스 자격 증명 손상이 감지되면 자격 증명을 즉시 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="2dc924422d6a619159d4fa3918f749f84c306533" translate="yes" xml:space="preserve">
          <source>If a client has previously interacted with any trusted collection or has its trust pinned to a specific certificate for the collections, the client immediately detects that the content is malicious and doesn&amp;rsquo;t trust any root, targets, or (maybe) snapshot metadata for these collections.</source>
          <target state="translated">클라이언트가 이전에 신뢰할 수있는 컬렉션과 상호 작용했거나 해당 컬렉션에 대한 특정 인증서에 신뢰가 고정 된 경우 클라이언트는 즉시 콘텐츠가 악성임을 감지하고 해당 루트에 대한 루트, 대상 또는 (아마도) 스냅 샷 메타 데이터를 신뢰하지 않습니다 컬렉션.</target>
        </trans-unit>
        <trans-unit id="958f6438da6fac57a98fe1351e6c13626b7de485" translate="yes" xml:space="preserve">
          <source>If a container is connected to the default bridge network and &lt;code&gt;linked&lt;/code&gt; with other containers, then the container&amp;rsquo;s &lt;code&gt;/etc/hosts&lt;/code&gt; file is updated with the linked container&amp;rsquo;s name.</source>
          <target state="translated">컨테이너가 기본 브리지 네트워크에 &lt;code&gt;linked&lt;/code&gt; 있고 다른 컨테이너 와 연결된 경우 컨테이너의 &lt;code&gt;/etc/hosts&lt;/code&gt; 파일이 연결된 컨테이너 이름으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="cc481d3e0b487db2dad396d771bfb9dd61d5c716" translate="yes" xml:space="preserve">
          <source>If a container is successfully restarted (the container is started and runs for at least 10 seconds), the delay is reset to its default value of 100 ms.</source>
          <target state="translated">컨테이너가 성공적으로 다시 시작되면 (컨테이너가 시작되고 10 초 이상 실행 됨) 지연이 기본값 인 100ms로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5b87282e47d2db54f156eb0641057812050eafcb" translate="yes" xml:space="preserve">
          <source>If a custom security group is provided, you need to ensure that you allow TCP ports 22 and 2376 in an ingress rule.</source>
          <target state="translated">사용자 정의 보안 그룹이 제공되는 경우 수신 규칙에서 TCP 포트 22 및 2376을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0a8f48be6c5b9f7f419d0c2cec86d941da1cf53" translate="yes" xml:space="preserve">
          <source>If a delegations key compromise is detected, a higher level key holder must rotate the compromised key, and push a clean set of targets using the new key.</source>
          <target state="translated">위임 키 손상이 감지되면 높은 수준의 키 보유자가 손상된 키를 회전시키고 새 키를 사용하여 깨끗한 대상 집합을 밀어야합니다.</target>
        </trans-unit>
        <trans-unit id="40dd2361b48af7312e2fe0534a5234e800014638" translate="yes" xml:space="preserve">
          <source>If a format (&lt;code&gt;--format&lt;/code&gt;) is specified, the given template will be executed instead of the default format. Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="translated">형식 ( &lt;code&gt;--format&lt;/code&gt; )을 지정하면 기본 형식 대신 지정된 템플릿이 실행됩니다. Go의 &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;텍스트 / 템플릿&lt;/a&gt; 패키지는 형식의 모든 세부 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="18c922bdabb6c6deeae6774997741b592f60f72a" translate="yes" xml:space="preserve">
          <source>If a format (&lt;code&gt;--format&lt;/code&gt;) is specified, the given template will be executed instead of the default format. Go&amp;rsquo;s &lt;a href=&quot;https://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487c4f331d466fc16d579615fbad20b745753f79" translate="yes" xml:space="preserve">
          <source>If a format is set to &lt;code&gt;{{json .}}&lt;/code&gt;, the events are streamed as valid JSON Lines. For information about JSON Lines, please refer to http://jsonlines.org/ .</source>
          <target state="translated">형식이 &lt;code&gt;{{json .}}&lt;/code&gt; 으로 설정되면 이벤트는 유효한 JSON 라인으로 스트리밍됩니다. JSON 라인에 대한 정보는 http://jsonlines.org/를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71d8c1cb064775a9013fe862de96838a016bb606" translate="yes" xml:space="preserve">
          <source>If a format is specified, the given template will be executed instead of the default format. Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="translated">형식을 지정하면 기본 형식 대신 지정된 템플릿이 실행됩니다. Go의 &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;텍스트 / 템플릿&lt;/a&gt; 패키지는 형식의 모든 세부 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e131798140f11669373234966760fc1a7065d45f" translate="yes" xml:space="preserve">
          <source>If a format is specified, the given template will be executed instead of the default format. Go&amp;rsquo;s &lt;a href=&quot;https://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c55183650774a4ecefb1c40fed2abaf16add49" translate="yes" xml:space="preserve">
          <source>If a line in &lt;code&gt;.dockerignore&lt;/code&gt; file starts with &lt;code&gt;#&lt;/code&gt; in column 1, then this line is considered as a comment and is ignored before interpreted by the CLI.</source>
          <target state="translated">&lt;code&gt;.dockerignore&lt;/code&gt; 파일 의 행 이 열 1에서 &lt;code&gt;#&lt;/code&gt; 으로 시작 하면이 행은 주석으로 간주되며 CLI에서 해석하기 전에 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="54e21b50df62b95252efcce599fdf69f105434a6" translate="yes" xml:space="preserve">
          <source>If a node loses connectivity to the swarm while it is running a task container with access to a config, the task container still has access to its configs, but cannot receive updates until the node reconnects to the swarm.</source>
          <target state="translated">구성에 대한 액세스 권한이있는 작업 컨테이너를 실행하는 동안 노드가 떼에 대한 연결을 끊어도 작업 컨테이너는 해당 구성에 계속 액세스 할 수 있지만 노드가 swarm에 다시 연결될 때까지 업데이트를받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ac17d39a56beb6186317486915d97fa2c26ee39" translate="yes" xml:space="preserve">
          <source>If a node loses connectivity to the swarm while it is running a task container with access to a secret, the task container still has access to its secrets, but cannot receive updates until the node reconnects to the swarm.</source>
          <target state="translated">비밀에 대한 액세스 권한이있는 작업 컨테이너를 실행하는 동안 노드가 웜에 대한 연결을 끊어도 작업 컨테이너는 여전히 비밀에 액세스 할 수 있지만 노드가 웜에 다시 연결될 때까지 업데이트를받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03b148c22460ef1c7f5b46f6fe96bcc3c84e13b1" translate="yes" xml:space="preserve">
          <source>If a plugin registers itself as a &lt;code&gt;VolumeDriver&lt;/code&gt; when activated, it must provide the Docker Daemon with writeable paths on the host filesystem. The Docker daemon provides these paths to containers to consume. The Docker daemon makes the volumes available by bind-mounting the provided paths into the containers.</source>
          <target state="translated">플러그인이 활성화 될 때 자체를 &lt;code&gt;VolumeDriver&lt;/code&gt; 로 등록하는 경우 호스트 파일 시스템에서 쓰기 가능한 경로를 Docker 데몬에 제공해야합니다. Docker 데몬은 컨테이너가 소비 할 경로를 제공합니다. Docker 데몬은 제공된 경로를 컨테이너에 바인드 마운트하여 볼륨을 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="e4d2844c14128a66cb08799d9e8b6017777b2e75" translate="yes" xml:space="preserve">
          <source>If a publisher loses keys it means losing the ability to sign trusted content for your repositories. If you lose a key, contact &lt;a href=&quot;https://support.docker.com&quot;&gt;Docker Support&lt;/a&gt; (support@docker.com) to reset the repository state.</source>
          <target state="translated">게시자가 키를 잃어버린 경우 리포지토리에 신뢰할 수있는 콘텐츠에 서명 할 수 없게됩니다. 키를 분실 한 경우 &lt;a href=&quot;https://support.docker.com&quot;&gt;Docker 지원&lt;/a&gt; (support@docker.com)에 문의 하여 리포지토리 상태를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="76f78e0f52bfb00cb03583664930b4d480ba9cd5" translate="yes" xml:space="preserve">
          <source>If a root key compromise is detected, the root key holder should contact whomever runs the notary service to manually reverse any malicious changes to the repository, and immediately rotate the root key. This creates a fork of the repository history, and thus break existing clients who have downloaded any of the malicious changes.</source>
          <target state="translated">루트 키 손상이 감지되면 루트 키 보유자는 공증 서비스를 실행하는 사람에게 연락하여 악의적 인 변경 사항을 수동으로 리포지토리로 되돌리고 즉시 루트 키를 교체해야합니다. 이렇게하면 리포지토리 기록이 생성되어 악의적 인 변경 사항을 다운로드 한 기존 클라이언트가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="a6644eb87a16aa8db9221ace3f57c60c6904dd8b" translate="yes" xml:space="preserve">
          <source>If a service has multiple dependencies of the type which force co-scheduling (see &lt;a href=&quot;index#automatic-scheduling&quot;&gt;Automatic scheduling&lt;/a&gt; below), it&amp;rsquo;s possible that Swarm schedules the dependencies on different nodes, making the dependent service impossible to schedule. For example, here &lt;code&gt;foo&lt;/code&gt; needs to be co-scheduled with &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;:</source>
          <target state="translated">서비스에 동시 예약을 강제 실행하는 유형의 다중 종속성이있는 경우 (아래 &lt;a href=&quot;index#automatic-scheduling&quot;&gt;자동 예약&lt;/a&gt; 참조) Swarm이 다른 노드에 대한 종속성을 예약하여 종속 서비스를 예약 할 수 없게 할 수 있습니다. 예를 들어, &lt;code&gt;foo&lt;/code&gt; 는 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 와 함께 예약해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="376a37c7adc3ab400b1f3f65c1a6690c0e4c03f1" translate="yes" xml:space="preserve">
          <source>If a service is defined in both files, Compose merges the configurations using the rules described in &lt;a href=&quot;index#adding-and-overriding-configuration&quot;&gt;Adding and overriding configuration&lt;/a&gt;.</source>
          <target state="translated">서비스가 두 파일에 모두 정의되어 있으면 Compose는 구성 &lt;a href=&quot;index#adding-and-overriding-configuration&quot;&gt;추가 및 재정의에&lt;/a&gt; 설명 된 규칙을 사용하여 구성을 병합합니다 .</target>
        </trans-unit>
        <trans-unit id="6099f2a4dd0f6fdd3a9bbc004b0285256c90b3cf" translate="yes" xml:space="preserve">
          <source>If a service maps a port from the host, such as &lt;code&gt;80:8000&lt;/code&gt;, then you may get an error like this when running &lt;code&gt;docker-compose up&lt;/code&gt; on it after the first time:</source>
          <target state="translated">서비스가 호스트에서 포트를 매핑하면 (예 : &lt;code&gt;80:8000&lt;/code&gt; ) , &lt;code&gt;docker-compose up&lt;/code&gt; 을 처음 실행하면 다음과 같은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3990084cc7182339b9a2473de7de5ca3c9e8658c" translate="yes" xml:space="preserve">
          <source>If a single run of the check takes longer than &lt;strong&gt;timeout&lt;/strong&gt; seconds then the check is considered to have failed.</source>
          <target state="translated">한 번의 검사 실행이 &lt;strong&gt;시간 초과&lt;/strong&gt; 보다 오래 걸리면 검사가 실패한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="608702a6ea7cd900b0782dfacb3f22957fc109ad" translate="yes" xml:space="preserve">
          <source>If a targets key compromise is detected, the root key holder must rotate the compromised key and push a clean set of targets using the new key.</source>
          <target state="translated">대상 키 손상이 감지되면 루트 키 홀더는 손상된 키를 회전시키고 새 키를 사용하여 깨끗한 대상 세트를 밀어야합니다.</target>
        </trans-unit>
        <trans-unit id="9901dad8394b5a040a5a7cd1546f7a1f1770b99e" translate="yes" xml:space="preserve">
          <source>If a token was checked-in by accident into a version control system, group chat or accidentally printed to your logs.</source>
          <target state="translated">버전 관리 시스템에 실수로 토큰을 체크인 한 경우 그룹 채팅 또는 실수로 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ef241f654d5c1b09ad10dbd0f85fd55773719fa9" translate="yes" xml:space="preserve">
          <source>If a volume with the same &lt;code&gt;&amp;lt;VOLUME-NAME&amp;gt;&lt;/code&gt; does not exist when a task is scheduled to a particular host, then one is created. The default volume driver is &lt;code&gt;local&lt;/code&gt;. To use a different volume driver with this create-on-demand pattern, specify the driver and its options with the &lt;code&gt;--mount&lt;/code&gt; flag:</source>
          <target state="translated">작업이 특정 호스트에 예약 될 때 &lt;code&gt;&amp;lt;VOLUME-NAME&amp;gt;&lt;/code&gt; 이 동일한 볼륨이 존재하지 않으면 볼륨 이 생성됩니다. 기본 볼륨 드라이버는 &lt;code&gt;local&lt;/code&gt; 입니다. 이 주문형 패턴으로 다른 볼륨 드라이버를 사용하려면 &lt;code&gt;--mount&lt;/code&gt; 플래그를 사용하여 드라이버 및 해당 옵션을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="33708efe6037ab9ca2d0d413d5338889db7f1675" translate="yes" xml:space="preserve">
          <source>If a worker has cached the image at that digest, it uses it.</source>
          <target state="translated">작업자가 해당 다이제스트에서 이미지를 캐시 한 경우이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="16e254d3a8f6affc68684678a115b11f1bb06e7d" translate="yes" xml:space="preserve">
          <source>If all nodes are paused or drained, and you create a service, it is pending until a node becomes available. In reality, the first node to become available gets all of the tasks, so this is not a good thing to do in a production environment.</source>
          <target state="translated">모든 노드가 일시 정지 또는 비워지고 서비스를 작성하는 경우, 노드가 사용 가능해질 때까지 보류됩니다. 실제로 사용 가능한 첫 번째 노드는 모든 작업을 수행하므로 프로덕션 환경에서 수행하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="902335c4935811672530d990a1096f1c52965aa1" translate="yes" xml:space="preserve">
          <source>If all&amp;rsquo;s well, you should see some PostgreSQL output.</source>
          <target state="translated">모두 잘되면 PostgreSQL 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d405d70232bbffced55d081500e6d4a1a81006bb" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ARG&lt;/code&gt; instruction has a default value and if there is no value passed at build-time, the builder uses the default.</source>
          <target state="translated">경우 &lt;code&gt;ARG&lt;/code&gt; 의 명령은 디폴트 값을 가지고 있으며, 빌드 시간에 전달 된 값이없는 경우, 빌더는 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="31d608998308b4be4e37b0a1659b00d89675969a" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ENV&lt;/code&gt; instruction overrides an &lt;code&gt;ARG&lt;/code&gt; instruction of the same name, like this Dockerfile:</source>
          <target state="translated">&lt;code&gt;ENV&lt;/code&gt; 명령어 가이 Dockerfile과 같은 동일한 이름 의 &lt;code&gt;ARG&lt;/code&gt; 명령어를 재정의하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5278b18308afcca20a2cfcf8059783f3ac6ee68b" translate="yes" xml:space="preserve">
          <source>If an environment variable is not set, Compose substitutes with an empty string. In the example above, if &lt;code&gt;POSTGRES_VERSION&lt;/code&gt; is not set, the value for the &lt;code&gt;image&lt;/code&gt; option is &lt;code&gt;postgres:&lt;/code&gt;.</source>
          <target state="translated">환경 변수가 설정되지 않은 경우 작성은 빈 문자열로 대체됩니다. 위의 예에서 &lt;code&gt;POSTGRES_VERSION&lt;/code&gt; 이 설정되지 않은 경우 &lt;code&gt;image&lt;/code&gt; 옵션 의 값 은 &lt;code&gt;postgres:&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d888acaaa172f25a3daa439d41320a4d085913d" translate="yes" xml:space="preserve">
          <source>If an insecure registry is not marked as insecure, &lt;code&gt;docker pull&lt;/code&gt;, &lt;code&gt;docker push&lt;/code&gt;, and &lt;code&gt;docker search&lt;/code&gt; will result in an error message prompting the user to either secure or pass the &lt;code&gt;--insecure-registry&lt;/code&gt; flag to the Docker daemon as described above.</source>
          <target state="translated">안전하지 않은 레지스트리가 안전하지 않은 것으로 표시되지 않은 경우, &lt;code&gt;docker pull&lt;/code&gt; , &lt;code&gt;docker push&lt;/code&gt; 및 &lt;code&gt;docker search&lt;/code&gt; 는 위에 설명 된대로 &lt;code&gt;--insecure-registry&lt;/code&gt; 플래그를 Docker 데몬에 보호하거나 전달하라는 오류 메시지 를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b8f06048ef8f8f3fced14b778636758b15cdaf4e" translate="yes" xml:space="preserve">
          <source>If any containers have connections open to the old container, they are closed. It is a container&amp;rsquo;s responsibility to detect this condition, look up the name again and reconnect.</source>
          <target state="translated">컨테이너가 기존 컨테이너에 연결되어 있으면 닫힙니다. 이 상태를 감지하고 이름을 다시 찾은 후 다시 연결하는 것은 컨테이너의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="0dc41fbba4aa693362d15a7cd0a5de64fe05eea4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;REPOSITORY&lt;/code&gt; and &lt;code&gt;TAG&lt;/code&gt; are provided, only images matching that repository and tag are listed. To find all local images in the &amp;ldquo;java&amp;rdquo; repository with tag &amp;ldquo;8&amp;rdquo; you can use:</source>
          <target state="translated">두 경우 &lt;code&gt;REPOSITORY&lt;/code&gt; 및 &lt;code&gt;TAG&lt;/code&gt; 가 제공되며, 그 저장소 및 태그와 일치하는 이미지 만 나열됩니다. 태그가 &quot;8&quot;인 &quot;java&quot;저장소에서 모든 로컬 이미지를 찾으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccfa385733386f0362f253596255d2d504026d71" translate="yes" xml:space="preserve">
          <source>If content trust is enabled, building from a Dockerfile that relies on tag without trust data, causes the build command to fail:</source>
          <target state="translated">컨텐츠 신뢰가 사용 가능한 경우, 신뢰 데이터없이 태그를 사용하는 Dockerfile에서 빌드하면 빌드 명령이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="15d88cd2e2cfbae36ef86df565e1fccaeaab04bf" translate="yes" xml:space="preserve">
          <source>If everything is right, the history will look like this:</source>
          <target state="translated">모든 것이 옳다면 역사는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f42c0af159969ed997a859094792bbd64095de3" translate="yes" xml:space="preserve">
          <source>If found, the client sends its client certificate, so you just need to drop your keys into &lt;code&gt;~/.docker/{ca,cert,key}.pem&lt;/code&gt;. Alternatively, if you want to store your keys in another location, you can specify that location using the environment variable &lt;code&gt;DOCKER_CERT_PATH&lt;/code&gt;.</source>
          <target state="translated">발견되면 클라이언트가 클라이언트 인증서를 전송하므로 키를 &lt;code&gt;~/.docker/{ca,cert,key}.pem&lt;/code&gt; 에 놓기 만하면 됩니다. 또는 키를 다른 위치에 저장하려면 환경 변수 &lt;code&gt;DOCKER_CERT_PATH&lt;/code&gt; 를 사용하여 해당 위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c68dc9e61c5f03e5bd182827f73ae2c853f4c07e" translate="yes" xml:space="preserve">
          <source>If it returns output (as shown in the example), you can unset the &lt;code&gt;DOCKER&lt;/code&gt; environment variables.</source>
          <target state="translated">출력을 리턴하면 (예에 표시된대로) &lt;code&gt;DOCKER&lt;/code&gt; 환경 변수를 설정 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac295be2e8836bffa5d1f1b4a2fb09bfe0957ca1" translate="yes" xml:space="preserve">
          <source>If it succeeds, the task is deployed using the new image.</source>
          <target state="translated">성공하면 새 이미지를 사용하여 작업이 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="bb66a42fd0ba778cf797db4088ad6a6e96d94872" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; resources are specified, either directly or due to the use of a wildcard, then &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; must be a directory, and it must end with a slash &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">직접 또는 와일드 카드 사용으로 인해 여러 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 자원이 지정된 경우 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 는 디렉토리 여야하며 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="69cb0f2fd38008980f6c51ae91637ef40d6297fe" translate="yes" xml:space="preserve">
          <source>If needed, re-run &lt;code&gt;docker-machine env myvm1&lt;/code&gt;, then run the given command to configure the shell.</source>
          <target state="translated">필요한 경우 &lt;code&gt;docker-machine env myvm1&lt;/code&gt; 을 다시 실행 한 다음 제공된 명령을 실행하여 셸을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="e2e822076c2e78f6af58688901f2dd81c990be42" translate="yes" xml:space="preserve">
          <source>If neither restarting or rebooting work, you should add another manager node or promote a worker to be a manager node. You also need to cleanly remove the failed node entry from the manager set with &lt;code&gt;docker node demote &amp;lt;NODE&amp;gt;&lt;/code&gt; and &lt;code&gt;docker node rm &amp;lt;id-node&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">다시 시작하거나 재부팅하지 않으면 다른 관리자 노드를 추가하거나 작업자를 관리자 노드로 승격시켜야합니다. 또한 &lt;code&gt;docker node demote &amp;lt;NODE&amp;gt;&lt;/code&gt; 및 &lt;code&gt;docker node rm &amp;lt;id-node&amp;gt;&lt;/code&gt; 로 설정된 관리자 세트에서 실패한 노드 항목을 완전히 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="06294af90a6964b5850c8b34e73545cd272de1ca" translate="yes" xml:space="preserve">
          <source>If no root key is found, an initial &lt;code&gt;root&lt;/code&gt; key is generated. This key is used as the default root of trust for all your trusted collections.</source>
          <target state="translated">루트 키가 없으면 초기 &lt;code&gt;root&lt;/code&gt; 키가 생성됩니다. 이 키는 모든 신뢰할 수있는 컬렉션의 기본 신뢰 루트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8d5cd38adf1ef06df818390df35318f6418a795" translate="yes" xml:space="preserve">
          <source>If no tag is specified, &lt;code&gt;docker trust inspect&lt;/code&gt; will report details for all signed tags in the repository:</source>
          <target state="translated">태그를 지정하지 않으면 &lt;code&gt;docker trust inspect&lt;/code&gt; 는 저장소의 모든 서명 된 태그에 대한 세부 정보를보고합니다.</target>
        </trans-unit>
        <trans-unit id="e8fea6c7b10dd295c1bebb32a0d3b431e6a1dcce" translate="yes" xml:space="preserve">
          <source>If not set, the config has world-readable permissions (mode &lt;code&gt;0444&lt;/code&gt;), unless a &lt;code&gt;umask&lt;/code&gt; is set within the container, in which case the mode is impacted by that &lt;code&gt;umask&lt;/code&gt; value.</source>
          <target state="translated">설정되지 않은 경우 컨테이너 내에 &lt;code&gt;umask&lt;/code&gt; 가 설정되어 있지 않으면 구성에 세계가 읽을 수있는 권한 (모드 &lt;code&gt;0444&lt;/code&gt; )이 있으며이 경우 해당 &lt;code&gt;umask&lt;/code&gt; 값에 의해 모드가 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="943228594ed55248c4b71cd64c967d55a755b19c" translate="yes" xml:space="preserve">
          <source>If not set, the config is owned by the user running the container command (often &lt;code&gt;root&lt;/code&gt;) and that user&amp;rsquo;s default group (also often &lt;code&gt;root&lt;/code&gt;).</source>
          <target state="translated">설정하지 않으면 컨테이너 명령을 실행하는 사용자 (보통 &lt;code&gt;root&lt;/code&gt; )와 해당 사용자의 기본 그룹 (또는 종종 &lt;code&gt;root&lt;/code&gt; ) 이 구성을 소유합니다 .</target>
        </trans-unit>
        <trans-unit id="361398126c8fd9c9da72ac45e2af5408180a3490" translate="yes" xml:space="preserve">
          <source>If not specified, daemon default is used, which can either be &lt;code&gt;&quot;private&quot;&lt;/code&gt; or &lt;code&gt;&quot;shareable&quot;&lt;/code&gt;, depending on the daemon version and configuration.</source>
          <target state="translated">지정하지 않으면 디먼 기본값이 사용되며, 이는 디먼 버전 및 구성에 따라 &lt;code&gt;&quot;private&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;shareable&quot;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6379eb5f491e40aedc8ee9cd7121ef31da6a4602" translate="yes" xml:space="preserve">
          <source>If not, it attempts to pull the image from Docker Hub or the private registry.</source>
          <target state="translated">그렇지 않은 경우 Docker Hub 또는 개인 레지스트리에서 이미지를 가져 오려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="574d2c7e970354e0b528941c7c6c3448f43116d3" translate="yes" xml:space="preserve">
          <source>If nothing matches &lt;code&gt;REPOSITORY[:TAG]&lt;/code&gt;, the list is empty.</source>
          <target state="translated">&lt;code&gt;REPOSITORY[:TAG]&lt;/code&gt; 와 일치하는 것이 없으면 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f9c4f5716c8f0b9a0826b05b709119047005df5" translate="yes" xml:space="preserve">
          <source>If provided, the passphrase in &lt;code&gt;NOTARY_DELEGATION_PASSPHRASE&lt;/code&gt; is tried for all delegation roles that notary attempts to sign with.</source>
          <target state="translated">제공되는 경우 &lt;code&gt;NOTARY_DELEGATION_PASSPHRASE&lt;/code&gt; 의 비밀번호 문구는 공증인이 서명하려는 모든 위임 역할에 대해 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="93f9f6e8ab74c84887b3f6ad6d9c36d2c0f5ffcb" translate="yes" xml:space="preserve">
          <source>If set to &amp;ldquo;host&amp;rdquo;, the service&amp;rsquo;s PID mode is the host PID mode. This turns on sharing between container and the host operating system the PID address space. Containers launched with this flag can access and manipulate other containers in the bare-metal machine&amp;rsquo;s namespace and vice versa.</source>
          <target state="translated">&quot;host&quot;로 설정된 경우 서비스의 PID 모드는 호스트 PID 모드입니다. 그러면 컨테이너와 호스트 운영 체제 사이의 PID 주소 공간이 공유됩니다. 이 플래그로 시작된 컨테이너는 베어 메탈 머신 네임 스페이스의 다른 컨테이너에 액세스하고 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31e6a352d11c3660036440f88e8fd8af134491f9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, specifies that this network has been created outside of Compose. &lt;code&gt;docker-compose up&lt;/code&gt; does not attempt to create it, and raises an error if it doesn&amp;rsquo;t exist.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정된 경우이 네트워크가 작성 외부에서 작성되도록 지정합니다. &lt;code&gt;docker-compose up&lt;/code&gt; 은 그것을 만들려고 시도하지 않으며 존재하지 않으면 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b5d2cc629754c5b0991a8a4e6abb36e43b71f11f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, specifies that this volume has been created outside of Compose. &lt;code&gt;docker-compose up&lt;/code&gt; does not attempt to create it, and raises an error if it doesn&amp;rsquo;t exist.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정된 경우이 볼륨이 작성 외부에서 작성되도록 지정합니다. &lt;code&gt;docker-compose up&lt;/code&gt; 은 그것을 만들려고 시도하지 않으며 존재하지 않으면 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="27afc180ac268dc4c7f82d663fcb8fa8637ba398" translate="yes" xml:space="preserve">
          <source>If set to one of the following forms: &lt;code&gt;container:&amp;lt;container_name&amp;gt;&lt;/code&gt;, &lt;code&gt;service:&amp;lt;service_name&amp;gt;&lt;/code&gt;, the service shares the PID address space of the designated container or service.</source>
          <target state="translated">&lt;code&gt;container:&amp;lt;container_name&amp;gt;&lt;/code&gt; , &lt;code&gt;service:&amp;lt;service_name&amp;gt;&lt;/code&gt; 형식 중 하나로 설정된 경우 서비스 는 지정된 컨테이너 또는 서비스의 PID 주소 공간을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="9c8669c257f24ea3701376fc32af25ca6e4f8b82" translate="yes" xml:space="preserve">
          <source>If set, Compose doesn&amp;rsquo;t attempt to use the Docker CLI for interactive &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; operations. This option is not available on Windows where the CLI is required for the aforementioned operations. Supported: &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; to enable, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; to disable.</source>
          <target state="translated">설정된 경우 Compose는 대화식 &lt;code&gt;run&lt;/code&gt; 및 &lt;code&gt;exec&lt;/code&gt; 조작에 Docker CLI를 사용하지 않습니다 . 위에서 언급 한 작업에 CLI가 필요한 Windows에서는이 옵션을 사용할 수 없습니다. 지원 : &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; ( 활성화), &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 비활성화</target>
        </trans-unit>
        <trans-unit id="3fb0e20762f663c8c2a52ef125542e3c4d114cc3" translate="yes" xml:space="preserve">
          <source>If set, Compose doesn&amp;rsquo;t try to detect orphaned containers for the project. Supported values: &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; to enable, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; to disable.</source>
          <target state="translated">설정된 경우 Compose는 프로젝트에 대해 고아 컨테이너를 감지하지 않습니다. 지원되는 값 : &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; ( 활성화), &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; ( 비활성화)</target>
        </trans-unit>
        <trans-unit id="60f1a5f22617601a56fd78c878c5cab8b3ca1e41" translate="yes" xml:space="preserve">
          <source>If set, the value of the &lt;code&gt;COMPOSE_FILE&lt;/code&gt; environment variable is separated using this character as path separator.</source>
          <target state="translated">설정되면 &lt;code&gt;COMPOSE_FILE&lt;/code&gt; 의 값 환경 변수 이 문자를 경로 구분 기호로 사용하여 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="26d05f0ca329019f28ea462e991664250a2b4d49" translate="yes" xml:space="preserve">
          <source>If set, volume declarations using the &lt;a href=&quot;../../compose-file/index#short-syntax-3&quot;&gt;short syntax&lt;/a&gt; are parsed assuming the host path is a Windows path, even if Compose is running on a UNIX-based system. Supported values: &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; to enable, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; to disable.</source>
          <target state="translated">설정된 경우, Compose가 UNIX 기반 시스템에서 실행중인 경우에도 호스트 경로가 Windows 경로 인 것으로 가정 하여 &lt;a href=&quot;../../compose-file/index#short-syntax-3&quot;&gt;짧은 구문을&lt;/a&gt; 사용한 볼륨 선언 이 구문 분석됩니다. 지원되는 값 : &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; ( 활성화), &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 비활성화)</target>
        </trans-unit>
        <trans-unit id="642073a364b487f16e5b836c817fa43dac64dbef" translate="yes" xml:space="preserve">
          <source>If setting up a new metadata pool it is required to be valid. This can be achieved by zeroing the first 4k to indicate empty metadata, like this:</source>
          <target state="translated">새 메타 데이터 풀을 설정하는 경우 유효해야합니다. 빈 메타 데이터를 표시하기 위해 처음 4k를 0으로 설정하면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="ba33702319ae67d8459c2191d11e049a070daa2b" translate="yes" xml:space="preserve">
          <source>If signers are set up for the repository via other &lt;code&gt;docker trust&lt;/code&gt; commands, &lt;code&gt;docker trust inspect --pretty&lt;/code&gt; displays them appropriately as a &lt;code&gt;SIGNER&lt;/code&gt; and specify their &lt;code&gt;KEYS&lt;/code&gt;:</source>
          <target state="translated">다른 &lt;code&gt;docker trust&lt;/code&gt; 명령을 통해 저장소에 서명자를 설정 한 경우 &lt;code&gt;docker trust inspect --pretty&lt;/code&gt; 는이를 &lt;code&gt;SIGNER&lt;/code&gt; 로 적절하게 표시 하고 &lt;code&gt;KEYS&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="cf23c672e9834372301980726caab060ddf3802e" translate="yes" xml:space="preserve">
          <source>If signers are set up for the repository via other &lt;code&gt;docker trust&lt;/code&gt; commands, &lt;code&gt;docker trust inspect&lt;/code&gt; includes a &lt;code&gt;Signers&lt;/code&gt; key:</source>
          <target state="translated">다른 &lt;code&gt;docker trust&lt;/code&gt; 명령을 통해 저장소에 서명자가 설정된 경우 &lt;code&gt;docker trust inspect&lt;/code&gt; 는 &lt;code&gt;Signers&lt;/code&gt; 포함합니다. 키를 .</target>
        </trans-unit>
        <trans-unit id="c99e35f88e0e97e0ebfc5b5198ef8926e586ccf0" translate="yes" xml:space="preserve">
          <source>If specified, the container&amp;rsquo;s IP address(es) is reapplied when a stopped container is restarted. If the IP address is no longer available, the container fails to start. One way to guarantee that the IP address is available is to specify an &lt;code&gt;--ip-range&lt;/code&gt; when creating the network, and choose the static IP address(es) from outside that range. This ensures that the IP address is not given to another container while this container is not on the network.</source>
          <target state="translated">지정된 경우, 컨테이너의 IP 주소는 중지 된 컨테이너가 다시 시작될 때 다시 적용됩니다. IP 주소를 더 이상 사용할 수 없으면 컨테이너가 시작되지 않습니다. IP 주소를 사용할 수있게하는 한 가지 방법 은 네트워크를 만들 때 &lt;code&gt;--ip-range&lt;/code&gt; 를 지정하고 해당 범위 밖의 고정 IP 주소를 선택하는 것입니다. 이렇게하면이 컨테이너가 네트워크에없는 동안 다른 컨테이너에 IP 주소가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b5d91aed249dd90a975d6b2dca97ecb662b9564" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--from&lt;/code&gt; option is not set, the &lt;code&gt;context&lt;/code&gt; is created from the current context:</source>
          <target state="translated">경우 &lt;code&gt;--from&lt;/code&gt; 옵션이 설정되지는 &lt;code&gt;context&lt;/code&gt; 현재 컨텍스트에서 생성된다 :</target>
        </trans-unit>
        <trans-unit id="50feb85ec15e4b4841b20845a25e796f15df4796" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;docker-compose.admin.yml&lt;/code&gt; also specifies this same service, any matching fields override the previous file. New values, add to the &lt;code&gt;webapp&lt;/code&gt; service configuration.</source>
          <target state="translated">는 IF &lt;code&gt;docker-compose.admin.yml&lt;/code&gt; 이 같은 서비스를 지정, 일치하는 필드는 이전 파일을 대체합니다. 새로운 가치, &lt;code&gt;webapp&lt;/code&gt; 추가 서비스 구성에 .</target>
        </trans-unit>
        <trans-unit id="c57ad52626f359e86954ef954b54e345873f00c4" translate="yes" xml:space="preserve">
          <source>If the Docker client loses connection to the daemon, the build is canceled. This happens if you interrupt the Docker client with &lt;code&gt;CTRL-c&lt;/code&gt; or if the Docker client is killed for any reason. If the build initiated a pull which is still running at the time the build is cancelled, the pull is cancelled as well.</source>
          <target state="translated">Docker 클라이언트가 데몬과의 연결이 끊어지면 빌드가 취소됩니다. 이것은 &lt;code&gt;CTRL-c&lt;/code&gt; 로 Docker 클라이언트를 중단 하거나 어떤 이유로 Docker 클라이언트가 종료 된 경우에 발생합니다. 빌드가 취소 될 때 여전히 실행중인 풀이 빌드를 시작한 경우 풀도 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="043583671601827650f4753f2a28b684229184af" translate="yes" xml:space="preserve">
          <source>If the Docker registry is accessed without a port number, do not add the port to the directory name. The following shows the configuration for a registry on default port 443 which is accessed with &lt;code&gt;docker login my-https.registry.example.com&lt;/code&gt;:</source>
          <target state="translated">포트 번호없이 Docker 레지스트리에 액세스 한 경우 디렉토리 이름에 포트를 추가하지 마십시오. 다음은 &lt;code&gt;docker login my-https.registry.example.com&lt;/code&gt; 으로 액세스하는 기본 포트 443의 레지스트리 구성을 보여줍니다. .</target>
        </trans-unit>
        <trans-unit id="6191bb5e8b32d7faf4a8ec632cd4e8e1705b4c02" translate="yes" xml:space="preserve">
          <source>If the Notary Service holds the snapshot key and the attacker has Notary Service write credentials, then they don&amp;rsquo;t even need to rotate the snapshot and timestamp keys because the server generates and signs the snapshot and timestamp for them.</source>
          <target state="translated">Notary Service가 스냅 샷 키를 보유하고 공격자가 Notary Service 쓰기 자격 증명을 보유한 경우 서버는 스냅 샷 및 타임 스탬프 키를 생성하고 서명하기 때문에 스냅 샷 및 타임 스탬프 키를 교체 할 필요도 없습니다.</target>
        </trans-unit>
        <trans-unit id="03f399b6688da34579573adbec2b835addc65e11" translate="yes" xml:space="preserve">
          <source>If the Notary Service holds the snapshot key and the attacker has Notary Service write credentials, then they have effective access to the snapshot and timestamp keys because the server generates and signs the snapshot and timestamp for them.</source>
          <target state="translated">Notary Service가 스냅 샷 키를 보유하고 공격자가 Notary Service 쓰기 자격 증명을 보유한 경우 서버는 스냅 샷 및 타임 스탬프 키를 생성하고 서명하기 때문에 스냅 샷 및 타임 스탬프 키에 효과적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4257c08e5248fc41e0fbc8a7c816ac7d608a5b39" translate="yes" xml:space="preserve">
          <source>If the cgroup has a leading forward slash (&lt;code&gt;/&lt;/code&gt;), the cgroup is created under the root cgroup, otherwise the cgroup is created under the daemon cgroup.</source>
          <target state="translated">cgroup에 선행 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 가 있으면 cgroup은 루트 cgroup 아래에 생성되고, 그렇지 않으면 cgroup은 데몬 cgroup 아래에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="af1a51f61d7c7a37fd7b366aa2d9bd99ada47879" translate="yes" xml:space="preserve">
          <source>If the container is paused, then the &lt;code&gt;docker exec&lt;/code&gt; command will fail with an error:</source>
          <target state="translated">컨테이너가 일시 중지되면 &lt;code&gt;docker exec&lt;/code&gt; 명령이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3b90bec9155bf0c25d791130f89e4be981a2caa9" translate="yes" xml:space="preserve">
          <source>If the container root filesystem does not contain either &lt;code&gt;/etc/passwd&lt;/code&gt; or &lt;code&gt;/etc/group&lt;/code&gt; files and either user or group names are used in the &lt;code&gt;--chown&lt;/code&gt; flag, the build will fail on the &lt;code&gt;ADD&lt;/code&gt; operation. Using numeric IDs requires no lookup and will not depend on container root filesystem content.</source>
          <target state="translated">컨테이너 루트 파일 시스템에 &lt;code&gt;/etc/passwd&lt;/code&gt; 또는 &lt;code&gt;/etc/group&lt;/code&gt; 파일이 &lt;code&gt;--chown&lt;/code&gt; 플래그 에 사용자 또는 그룹 이름이 사용 되면 &lt;code&gt;ADD&lt;/code&gt; 에서 빌드가 실패합니다. 작업 합니다. 숫자 ID를 사용하면 조회 할 필요가 없으며 컨테이너 루트 파일 시스템 내용에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8da81ab61b28765867b27b661e7b4cf2c0bddf0" translate="yes" xml:space="preserve">
          <source>If the container root filesystem does not contain either &lt;code&gt;/etc/passwd&lt;/code&gt; or &lt;code&gt;/etc/group&lt;/code&gt; files and either user or group names are used in the &lt;code&gt;--chown&lt;/code&gt; flag, the build will fail on the &lt;code&gt;COPY&lt;/code&gt; operation. Using numeric IDs requires no lookup and will not depend on container root filesystem content.</source>
          <target state="translated">컨테이너 루트 파일 시스템에 &lt;code&gt;/etc/passwd&lt;/code&gt; 또는 &lt;code&gt;/etc/group&lt;/code&gt; 파일이 &lt;code&gt;--chown&lt;/code&gt; 플래그 에 사용자 또는 그룹 이름이 사용 되면 빌드가 &lt;code&gt;COPY&lt;/code&gt; 작업 에서 실패 합니다. 숫자 ID를 사용하면 조회 할 필요가 없으며 컨테이너 루트 파일 시스템 내용에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d562a7b1b2ff9e69b8c91dbd7ea3c09ebce3ae07" translate="yes" xml:space="preserve">
          <source>If the engine supports specifying the flag multiple times (such as with &lt;code&gt;--label&lt;/code&gt;), then so does Docker Machine.</source>
          <target state="translated">엔진이 플래그 지정을 여러 번 지원하는 경우 (예 : &lt;code&gt;--label&lt;/code&gt; ) Docker Machine도 .</target>
        </trans-unit>
        <trans-unit id="634cbc14ab8d2aec5cde851919c7e0c8562c31c4" translate="yes" xml:space="preserve">
          <source>If the image also specifies an &lt;code&gt;ENTRYPOINT&lt;/code&gt; then the &lt;code&gt;CMD&lt;/code&gt; or &lt;code&gt;COMMAND&lt;/code&gt; get appended as arguments to the &lt;code&gt;ENTRYPOINT&lt;/code&gt;.</source>
          <target state="translated">이미지가 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 도 지정 하면 &lt;code&gt;CMD&lt;/code&gt; 또는 &lt;code&gt;COMMAND&lt;/code&gt; 가 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 에 인수로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="571755bcdbafceef7bf0a51b6220a2627d4f14c7" translate="yes" xml:space="preserve">
          <source>If the image does not exist, Compose attempts to pull it, unless you have also specified &lt;a href=&quot;#build&quot;&gt;build&lt;/a&gt;, in which case it builds it using the specified options and tags it with the specified tag.</source>
          <target state="translated">이미지가 존재하지 않으면, &lt;a href=&quot;#build&quot;&gt;build&lt;/a&gt; 또한 지정하지 않은 경우 작성은 이미지를 가져 오려고 시도합니다 .이 경우 지정된 옵션을 사용하여 이미지를 빌드하고 지정된 태그로 태그를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6d58f64ad6105ef8db49b74720f9e99b8b2eb3e9" translate="yes" xml:space="preserve">
          <source>If the image isn&amp;rsquo;t available locally on the machine, Docker pulls it from the repository.</source>
          <target state="translated">머신에서 이미지를 로컬에서 사용할 수 없으면 Docker는 이미지를 저장소에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="decabeb30cd7d6ef37278274d96d3f3fdcb25cf8" translate="yes" xml:space="preserve">
          <source>If the image tag is unsigned or unavailable, &lt;code&gt;docker trust inspect&lt;/code&gt; does not display any signed tags.</source>
          <target state="translated">이미지 태그가 서명되지 않았거나 사용할 수없는 경우 &lt;code&gt;docker trust inspect&lt;/code&gt; 는 서명 된 태그를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3985aee8718b743490633c3f5ad2096220a1525" translate="yes" xml:space="preserve">
          <source>If the key has not been rotated since the node left the swarm, and you have a quorum of functional manager nodes in the swarm, you can view the current unlock key using &lt;code&gt;docker swarm unlock-key&lt;/code&gt; without any arguments.</source>
          <target state="translated">노드가 떼를 떠난 후 키가 회전하지 않고 떼에 쿼럼 기능 관리자 노드가있는 경우 &lt;code&gt;docker swarm unlock-key&lt;/code&gt; 를 사용하여 현재 잠금 해제 키를 볼 수 있습니다 경우 인수없이 를 .</target>
        </trans-unit>
        <trans-unit id="dbb038331d8b58a9714f0b2bda53a83abd4d0047" translate="yes" xml:space="preserve">
          <source>If the key was rotated after the swarm node became unavailable and you do not have a record of the previous key, you may need to force the manager to leave the swarm and join it back to the swarm as a new manager.</source>
          <target state="translated">웜 노드를 사용할 수 없게 된 후 키가 회전하고 이전 키에 대한 기록이없는 경우 관리자가 웜을 떠나 새로운 관리자로 웜에 다시 가입시켜야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db6af6006d76b0437331098b0756917b989a0208" translate="yes" xml:space="preserve">
          <source>If the manager can&amp;rsquo;t resolve the tag to a digest, each worker node is responsible for resolving the tag to a digest, and different nodes may use different versions of the image. If this happens, a warning like the following is logged, substituting the placeholders for real information.</source>
          <target state="translated">관리자가 태그를 다이제스트로 해석 할 수없는 경우 각 작업자 노드는 태그를 다이제스트로 해석하고 각기 다른 노드가 다른 버전의 이미지를 사용할 수 있습니다. 이 경우 자리 표시자를 실제 정보로 대체하여 다음과 같은 경고가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="468445e93ed0c767355a5be37ae6d3fda16fef16" translate="yes" xml:space="preserve">
          <source>If the manager cannot resolve the tag</source>
          <target state="translated">관리자가 태그를 확인할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="b046edcb738984fa1d710f1c6d4a01f505bc10fb" translate="yes" xml:space="preserve">
          <source>If the manager resolves the tag</source>
          <target state="translated">관리자가 태그를 확인한 경우</target>
        </trans-unit>
        <trans-unit id="beb9b7081961ba6e8dca2731f78147273a49bd94" translate="yes" xml:space="preserve">
          <source>If the node is a manager node, you receive a warning about maintaining the quorum. To override the warning, pass the &lt;code&gt;--force&lt;/code&gt; flag. If the last manager node leaves the swarm, the swarm becomes unavailable requiring you to take disaster recovery measures.</source>
          <target state="translated">노드가 관리자 노드 인 경우 쿼럼 유지 관리에 대한 경고가 표시됩니다. 경고를 무시하려면 &lt;code&gt;--force&lt;/code&gt; 를 전달하십시오. 플래그를 . 마지막 관리자 노드가 떼에서 나가면 떼를 사용할 수 없게되어 재해 복구 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="20ee3168f225e373e1092f1ce803e4420cb4e017" translate="yes" xml:space="preserve">
          <source>If the node is a manager, it will listen for inbound swarm manager traffic on this address. The default is to listen on 0.0.0.0:2377. It is also possible to specify a network interface to listen on that interface&amp;rsquo;s address; for example &lt;code&gt;--listen-addr eth0:2377&lt;/code&gt;.</source>
          <target state="translated">노드가 관리자 인 경우이 주소에서 인바운드 떼 관리자 트래픽을 수신합니다. 기본값은 0.0.0.0:2377에서 청취하는 것입니다. 해당 인터페이스의 주소를 수신 할 네트워크 인터페이스를 지정할 수도 있습니다. 예를 들어 &lt;code&gt;--listen-addr eth0:2377&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3a865e82fafc81c2b06c1df5e4c276e52a047e0" translate="yes" xml:space="preserve">
          <source>If the nodes in one category (for example, those with &lt;code&gt;node.labels.datacenter=south&lt;/code&gt;) can&amp;rsquo;t handle their fair share of tasks due to constraints or resource limitations, the extra tasks will be assigned to other nodes instead, if possible.</source>
          <target state="translated">한 범주의 노드 (예 : &lt;code&gt;node.labels.datacenter=south&lt;/code&gt; 가 있는 노드 )가 제한 또는 자원 제한으로 인해 공정한 작업 공유를 처리 할 수없는 경우 가능한 경우 추가 작업이 다른 노드에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="413e472cafcc6a59ed4fce1cb2d79a12cc00f095" translate="yes" xml:space="preserve">
          <source>If the operator uses &lt;code&gt;--link&lt;/code&gt; when starting a new client container in the default bridge network, then the client container can access the exposed port via a private networking interface. If &lt;code&gt;--link&lt;/code&gt; is used when starting a container in a user-defined network as described in &lt;a href=&quot;https://docs.docker.com/network/&quot;&gt;&lt;em&gt;Networking overview&lt;/em&gt;&lt;/a&gt;, it will provide a named alias for the container being linked to.</source>
          <target state="translated">기본 브리지 네트워크에서 새 클라이언트 컨테이너를 시작할 때 운영자가 &lt;code&gt;--link&lt;/code&gt; 를 사용 하면 클라이언트 컨테이너는 개인 네트워킹 인터페이스를 통해 노출 된 포트에 액세스 할 수 있습니다. 경우 &lt;code&gt;--link&lt;/code&gt; 는 사용자 정의 네트워크에서 컨테이너를 시작할 때 사용에 기재된 &lt;a href=&quot;https://docs.docker.com/network/&quot;&gt;&lt;em&gt;네트워킹 개요&lt;/em&gt;&lt;/a&gt; , 상기 컨테이너의라는 별칭으로 연결되어 제공된다.</target>
        </trans-unit>
        <trans-unit id="cf7efce6af80c4b5053d44e97a1a9971912df7d7" translate="yes" xml:space="preserve">
          <source>If the plugin has a built-in shell, then exec into the plugin can be done as follows:</source>
          <target state="translated">플러그인에 내장 쉘이있는 경우 플러그인에 대한 exec는 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98485c3a9ea9fde530de08d918711046c8203a0" translate="yes" xml:space="preserve">
          <source>If the process encounters an error, the exit code for this command is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">프로세스에 오류가 발생하면이 명령의 종료 코드는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a8a9c15eee7b39cbcd99cc9466a5940c1d9bd0b" translate="yes" xml:space="preserve">
          <source>If the process is interrupted using &lt;code&gt;SIGINT&lt;/code&gt; (&lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;C&lt;/code&gt;) or &lt;code&gt;SIGTERM&lt;/code&gt;, the containers are stopped, and the exit code is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SIGINT&lt;/code&gt; ( &lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;C&lt;/code&gt; ) 또는 &lt;code&gt;SIGTERM&lt;/code&gt; 을 사용하여 프로세스가 인터럽트 되면 컨테이너가 중지되고 종료 코드는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d69806468c37d699f0ed9f5ae33c57e2ac750dd0" translate="yes" xml:space="preserve">
          <source>If the registry you are using still supports v2 schema 1, urge their administrators to move to v2 schema 2.</source>
          <target state="translated">사용중인 레지스트리가 여전히 v2 스키마 1을 지원하는 경우 관리자에게 v2 스키마 2로 이동하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="20ea9233d7262932644088fcc2d90071eb652706" translate="yes" xml:space="preserve">
          <source>If the secret being stored is an identity token, the Username should be set to &lt;code&gt;&amp;lt;token&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">저장되는 비밀이 아이디 토큰 인 경우, 사용자 이름은 &lt;code&gt;&amp;lt;token&amp;gt;&lt;/code&gt; 으로 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f915a53650a9d6786e217f25d7489e1d5cff7f9" translate="yes" xml:space="preserve">
          <source>If the service is &lt;code&gt;replicated&lt;/code&gt; (which is the default), specify the number of containers that should be running at any given time.</source>
          <target state="translated">서비스가 &lt;code&gt;replicated&lt;/code&gt; 되는 경우 (기본값) 주어진 시간에 실행해야하는 컨테이너 수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="d9ad0bdc1589b59691e1de2ad9fdcffd04093115" translate="yes" xml:space="preserve">
          <source>If the swarm has auto-lock enabled, you need the unlock key to restore the swarm from backup. Retrieve the unlock key if necessary and store it in a safe location. If you are unsure, read &lt;a href=&quot;../swarm_manager_locking/index&quot;&gt;Lock your swarm to protect its encryption key&lt;/a&gt;.</source>
          <target state="translated">떼가 자동 잠금을 활성화 한 경우 백업에서 떼를 복원하려면 잠금 해제 키가 필요합니다. 필요한 경우 잠금 해제 키를 검색하여 안전한 위치에 보관하십시오. 확실하지 않은 경우, &lt;a href=&quot;../swarm_manager_locking/index&quot;&gt;암호화 키 보호를 위해 웜 잠금을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f53e0f70e917747f13b79b13405dca39e580b35" translate="yes" xml:space="preserve">
          <source>If the swarm loses the quorum of managers, the swarm cannot perform management tasks. If your swarm has multiple managers, always have more than two. To maintain quorum, a majority of managers must be available. An odd number of managers is recommended, because the next even number does not make the quorum easier to keep. For instance, whether you have 3 or 4 managers, you can still only lose 1 manager and maintain the quorum. If you have 5 or 6 managers, you can still only lose two.</source>
          <target state="translated">떼가 관리자 정족수를 잃으면 떼가 관리 작업을 수행 할 수 없습니다. 떼에 여러 명의 관리자가있는 경우 항상 두 명 이상이 있어야합니다. 쿼럼을 유지하려면 대부분의 관리자가 있어야합니다. 다음 짝수로 인해 쿼럼을 유지하기가 쉽지 않기 때문에 홀수의 관리자가 권장됩니다. 예를 들어 관리자가 3 명이든 4 명이든 상관없이 여전히 관리자 1 명만 잃고 쿼럼을 유지할 수 있습니다. 관리자가 5 명 또는 6 명인 경우 여전히 2 명만 잃을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="104a7751ceb099a3fc5d1bf05063331b574cd635" translate="yes" xml:space="preserve">
          <source>If the swarm manager can resolve the image tag to a digest, it instructs the worker nodes to redeploy the tasks and use the image at that digest.</source>
          <target state="translated">스웜 관리자가 이미지 태그를 다이제스트로 해석 할 수 있으면 작업자 노드가 작업을 재배치하고 해당 다이제스트에서 이미지를 사용하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="3e8ab3bccd74e356b2c88b63b82013b532259485" translate="yes" xml:space="preserve">
          <source>If the swarm manager cannot resolve the image to a digest, all is not lost:</source>
          <target state="translated">스웜 관리자가 이미지를 다이제스트로 해석 할 수없는 경우 모두 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59175b569b0c00b695ba3ed4dc983b6f22432393" translate="yes" xml:space="preserve">
          <source>If the update to a task returns &lt;code&gt;RUNNING&lt;/code&gt;, wait for the specified delay period then start the next task.</source>
          <target state="translated">작업 업데이트가 &lt;code&gt;RUNNING&lt;/code&gt; 을 반환 하면 지정된 지연 시간 동안 기다렸다가 다음 작업을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="e42f655d55fd8f27ac14326adae883c07ad49ffa" translate="yes" xml:space="preserve">
          <source>If the user specifies arguments to &lt;code&gt;docker run&lt;/code&gt; then they will override the default specified in &lt;code&gt;CMD&lt;/code&gt;.</source>
          <target state="translated">사용자가 &lt;code&gt;docker run&lt;/code&gt; 에 인수를 지정하면 &lt;code&gt;CMD&lt;/code&gt; 에 지정된 기본값을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="3a0fa08791c4ed71d96ae65d080bc1fca90ffcbb" translate="yes" xml:space="preserve">
          <source>If the whole swarm restarts and every manager node subsequently gets a new IP address, there is no way for any node to contact an existing manager. Therefore the swarm is hung while nodes try to contact one another at their old IP addresses.</source>
          <target state="translated">전체 떼가 다시 시작되고 이후에 모든 관리자 노드가 새 IP 주소를 얻는 경우, 어떤 노드도 기존 관리자에게 연락 할 방법이 없습니다. 따라서 노드가 이전 IP 주소에서 서로 연락을 시도하는 동안 스웜이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="11afd127e56ec4de2ecaa8df449f90768de1ad58" translate="yes" xml:space="preserve">
          <source>If the worker does not have a locally cached image that resolves to the tag, the worker tries to connect to Docker Hub or the private registry to pull the image at that tag.</source>
          <target state="translated">작업자에게 태그로 확인되는 로컬로 캐시 된 이미지가없는 경우 작업자는 Docker Hub 또는 개인 레지스트리에 연결하여 해당 태그에서 이미지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7eda8315deede58edfc04db3ee3ff1846e345f08" translate="yes" xml:space="preserve">
          <source>If the worker fails to pull the image, the service fails to deploy on that worker node. Docker tries again to deploy the task, possibly on a different worker node.</source>
          <target state="translated">작업자가 이미지를 가져 오지 못하면 해당 작업자 노드에 서비스를 배포하지 못합니다. Docker는 다른 작업자 노드에 작업을 다시 배포하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="1cf8720af15c4dd5395e98f1478e68f1a22a721e" translate="yes" xml:space="preserve">
          <source>If the worker has a locally cached image that resolves to that tag, it uses that image.</source>
          <target state="translated">작업자가 해당 태그로 확인되는 로컬로 캐시 된 이미지가있는 경우 해당 이미지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a700feb94e4d44aff3ca6a45186d8d0be2928174" translate="yes" xml:space="preserve">
          <source>If there are any locations on the Docker host where the unprivileged user needs to write, adjust the permissions of those locations accordingly. This is also true if you want to use the &lt;code&gt;dockremap&lt;/code&gt; user automatically created by Docker, but you can&amp;rsquo;t modify the permissions until after configuring and restarting Docker.</source>
          <target state="translated">권한이없는 사용자가 작성해야하는 Docker 호스트의 위치가 있으면 해당 위치의 권한을 적절히 조정하십시오. Docker에서 자동으로 생성 한 &lt;code&gt;dockremap&lt;/code&gt; 사용자 를 사용하려는 경우에도 마찬가지 이지만 Docker를 구성하고 다시 시작한 후에 만 ​​권한을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="137bf323437a336771da1464ec409f43d5b3d1fb" translate="yes" xml:space="preserve">
          <source>If there are existing containers for a service, and the service&amp;rsquo;s configuration or image was changed after the container&amp;rsquo;s creation, &lt;code&gt;docker-compose up&lt;/code&gt; picks up the changes by stopping and recreating the containers (preserving mounted volumes). To prevent Compose from picking up changes, use the &lt;code&gt;--no-recreate&lt;/code&gt; flag.</source>
          <target state="translated">서비스에 대한 기존 컨테이너가 있고 컨테이너 작성 후 서비스 구성 또는 이미지가 변경된 경우, &lt;code&gt;docker-compose up&lt;/code&gt; 은 컨테이너를 중지하고 다시 작성하여 마운트 된 볼륨을 보존하여 변경 사항을 선택합니다. 작성이 변경 사항을 선택하지 못하게하려면 &lt;code&gt;--no-recreate&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b731e337d8fb79e4597e6541561c2a17cb1dcfd5" translate="yes" xml:space="preserve">
          <source>If there is 1 CPU, this means the container can get 50% CPU worth of run-time every 50ms.</source>
          <target state="translated">CPU가 1 개인 경우 컨테이너가 50ms마다 50 %의 CPU 런타임을 얻을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="45fbc0f76411f03550dc584b50cd862e77dac1b7" translate="yes" xml:space="preserve">
          <source>If there were an error, and the task were failing and repeatedly restarting, you would see something like this:</source>
          <target state="translated">오류가 발생하여 작업이 실패하고 반복적으로 다시 시작되면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9d87a2a6bf2721cd09647c9a549a04fdc51e8fa0" translate="yes" xml:space="preserve">
          <source>If these entries are not present, edit the files as the &lt;code&gt;root&lt;/code&gt; user and assign a starting UID and GID that is the highest-assigned one plus the offset (in this case, &lt;code&gt;65536&lt;/code&gt;). Be careful not to allow any overlap in the ranges.</source>
          <target state="translated">이러한 항목이 없으면 파일을 &lt;code&gt;root&lt;/code&gt; 사용자 로 편집하고 가장 높은 할당 된 시작 UID 및 GID에 오프셋 (이 경우 &lt;code&gt;65536&lt;/code&gt; )을 지정하십시오. 범위가 겹치지 않도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="019b14090f82f15c5d4dbf548d346a54c93dd3cd" translate="yes" xml:space="preserve">
          <source>If this configuration is used, then you must:</source>
          <target state="translated">이 구성을 사용하는 경우 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="cac9b5138f725d0e9bccf38b6bcdf704d82edd6c" translate="yes" xml:space="preserve">
          <source>If this fails, the task fails to deploy and the manager tries again to deploy the task, possibly on a different worker node.</source>
          <target state="translated">이 작업이 실패하면 작업을 배포하지 못하고 관리자가 다른 작업자 노드에 작업을 다시 배포하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2de7e729b64965f889109416d4b4b89af8489a06" translate="yes" xml:space="preserve">
          <source>If this option is specified for a process-isolated Windows container, &lt;em&gt;all&lt;/em&gt; devices that implement the requested device interface class GUID are made available in the container. For example, the command below makes all COM ports on the host visible in the container.</source>
          <target state="translated">프로세스 분리 Windows 컨테이너에이 옵션을 지정 하면 요청 된 디바이스 인터페이스 클래스 GUID를 구현하는 &lt;em&gt;모든&lt;/em&gt; 디바이스를 컨테이너에서 사용할 수 있습니다. 예를 들어 아래 명령은 호스트의 모든 COM 포트를 컨테이너에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d21f7d19e853785232042ade6085fb86e0e14022" translate="yes" xml:space="preserve">
          <source>If this pre-create check succeeds, Docker Machine proceeds with the creation as normal. If the pre-create check fails, the Docker Machine process exits with status code 3 to indicate that the source of the non-zero exit was the pre-create check failing.</source>
          <target state="translated">이 사전 작성 검사에 성공하면 Docker Machine은 정상적으로 작성을 진행합니다. 사전 작성 검사에 실패하면 Docker Machine 프로세스는 상태 코드 3으로 종료하여 0이 아닌 종료의 소스가 사전 작성 검사 실패임을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b90ca4905dea53f80682cc379b25bc967338bee0" translate="yes" xml:space="preserve">
          <source>If this succeeds, the worker uses that image.</source>
          <target state="translated">이것이 성공하면 작업자는 해당 이미지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="57510aa5121fe69b3cc9e692c7654854a9b92548" translate="yes" xml:space="preserve">
          <source>If token authentication is enabled on Notary server, then any connecting client that does not have a token is redirected to the authorization server.</source>
          <target state="translated">Notary 서버에서 토큰 인증이 활성화 된 경우 토큰이없는 연결 클라이언트는 권한 부여 서버로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="540577427f10f2fea72c03e4415b50271633cd0c" translate="yes" xml:space="preserve">
          <source>If unspecified, Compose will use the &lt;code&gt;isolation&lt;/code&gt; value found in the service&amp;rsquo;s definition to determine the value to use for builds.</source>
          <target state="translated">지정되지 않은 경우 작성은 서비스 정의에 있는 &lt;code&gt;isolation&lt;/code&gt; 값을 사용하여 빌드에 사용할 값을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="737a1ade049048b73795f4638e3f21b6bdf6c4a9" translate="yes" xml:space="preserve">
          <source>If used as part of the v2 plugin architecture, mountpoints that are part of paths returned by the plugin must be mounted under the directory specified by &lt;code&gt;PropagatedMount&lt;/code&gt; in the plugin configuration (&lt;a href=&quot;https://github.com/docker/docker/pull/26398&quot;&gt;#26398&lt;/a&gt;)</source>
          <target state="translated">v2 플러그인 아키텍처의 일부로 사용되는 경우 플러그인이 리턴 한 경로의 일부인 마운트 포인트 는 플러그인 구성에서 &lt;code&gt;PropagatedMount&lt;/code&gt; 에 의해 지정된 디렉토리 아래에 마운트되어야 합니다 ( &lt;a href=&quot;https://github.com/docker/docker/pull/26398&quot;&gt;# 26398&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f0cfd912ab9f8c53f497a1c10f8752140c7cd467" translate="yes" xml:space="preserve">
          <source>If using a block device for device mapper storage, ideally both &lt;code&gt;datadev&lt;/code&gt; and &lt;code&gt;metadatadev&lt;/code&gt; should be specified to completely avoid using the loopback device.</source>
          <target state="translated">장치 맵퍼 ​​스토리지에 블록 장치를 사용하는 경우 루프백 장치 사용을 완전히 피하기 위해 &lt;code&gt;datadev&lt;/code&gt; 와 &lt;code&gt;metadatadev&lt;/code&gt; 를 모두 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a005a48609dee87fd1dac3f89c36d0b71d857336" translate="yes" xml:space="preserve">
          <source>If using a block device for device mapper storage, it is best to use &lt;code&gt;lvm&lt;/code&gt; to create and manage the thin-pool volume. This volume is then handed to Docker to exclusively create snapshot volumes needed for images and containers.</source>
          <target state="translated">장치 매퍼 스토리지에 블록 장치를 사용하는 경우 &lt;code&gt;lvm&lt;/code&gt; 을 사용하여 씬 풀 볼륨을 생성하고 관리하는 것이 가장 좋습니다 . 그런 다음이 볼륨은 Docker로 전달되어 이미지 및 컨테이너에 필요한 스냅 샷 볼륨을 독점적으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94974b330b42ea12c95b5566fd428cdad93c5877" translate="yes" xml:space="preserve">
          <source>If using your own notary server and a self-signed certificate or an internal Certificate Authority, you need to place the certificate at &lt;code&gt;tls/&amp;lt;registry_url&amp;gt;/ca.crt&lt;/code&gt; in your docker config directory.</source>
          <target state="translated">자체의 공증 서버와 자체 서명 된 인증서 또는 내부 인증 기관을 사용하는 경우, 인증서를 docker config 디렉토리의 &lt;code&gt;tls/&amp;lt;registry_url&amp;gt;/ca.crt&lt;/code&gt; 에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6678911fc6f942d17377f016af8b8f040144de38" translate="yes" xml:space="preserve">
          <source>If you access a node which is not running a service task, the service does not listen on that port. It is possible that nothing is listening, or that a completely different application is listening.</source>
          <target state="translated">서비스 작업을 실행하지 않는 노드에 액세스하면 해당 포트에서 서비스가 수신되지 않습니다. 아무것도 듣고 있지 않거나 완전히 다른 응용 프로그램이 듣고있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbe59e89976ce47b62a926fbbd03c97f550e518c" translate="yes" xml:space="preserve">
          <source>If you are able, modify the application that you&amp;rsquo;re running to add an explicit signal handler for &lt;code&gt;SIGTERM&lt;/code&gt;.</source>
          <target state="translated">가능한 경우 &lt;code&gt;SIGTERM&lt;/code&gt; 에 대한 명시 적 신호 핸들러를 추가하도록 실행중인 애플리케이션을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5395a9bdbe764ed617462377a3719244cd4d2f3c" translate="yes" xml:space="preserve">
          <source>If you are behind an HTTP proxy server, for example in corporate settings, before open a connect to registry, you may need to configure the Docker daemon&amp;rsquo;s proxy settings, using the &lt;code&gt;HTTP_PROXY&lt;/code&gt;, &lt;code&gt;HTTPS_PROXY&lt;/code&gt;, and &lt;code&gt;NO_PROXY&lt;/code&gt; environment variables. To set these environment variables on a host using &lt;code&gt;systemd&lt;/code&gt;, refer to the &lt;a href=&quot;https://docs.docker.com/config/daemon#http-proxy&quot;&gt;control and configure Docker with systemd&lt;/a&gt; for variables configuration.</source>
          <target state="translated">회사 설정 등의 HTTP 프록시 서버 뒤에있는 경우 레지스트리에 연결하기 전에 &lt;code&gt;HTTP_PROXY&lt;/code&gt; , &lt;code&gt;HTTPS_PROXY&lt;/code&gt; 를 사용하여 Docker 데몬의 프록시 설정을 구성해야 할 수 있습니다 , 그리고 &lt;code&gt;NO_PROXY&lt;/code&gt; 의 환경 변수를. &lt;code&gt;systemd&lt;/code&gt; 를 사용하여 호스트에서 이러한 환경 변수를 설정하려면 변수 구성에 대해 systemd를 사용 하여 &lt;a href=&quot;https://docs.docker.com/config/daemon#http-proxy&quot;&gt;제어 및 구성 Docker를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81bfc0806cc220d9b3fae0277d21e98e02a1e7d0" translate="yes" xml:space="preserve">
          <source>If you are brand new to Docker, see &lt;a href=&quot;../../index&quot;&gt;About Docker Engine&lt;/a&gt;.</source>
          <target state="translated">Docker를 처음 사용하는 경우 &lt;a href=&quot;../../index&quot;&gt;Docker 엔진 정보를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="629ced47685bfe41121a79b42c51c35b0edcae80" translate="yes" xml:space="preserve">
          <source>If you are currently logged in, run &lt;code&gt;docker logout&lt;/code&gt; to remove the credentials from the default store.</source>
          <target state="translated">현재 로그인 한 경우 &lt;code&gt;docker logout&lt;/code&gt; 을 실행 하여 기본 저장소에서 신임 정보를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0c8d16c604c6fd8e11bdb9a12ec19bbda7aa8576" translate="yes" xml:space="preserve">
          <source>If you are currently logged in, run &lt;code&gt;docker logout&lt;/code&gt; to remove the credentials from the file and run &lt;code&gt;docker login&lt;/code&gt; again.</source>
          <target state="translated">현재 로그인 한 경우 다음을 실행하십시오. &lt;code&gt;docker logout&lt;/code&gt; 을 을 실행하여 파일에서 자격 증명을 제거하고 &lt;code&gt;docker login&lt;/code&gt; 을 다시 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="8db4fb8e8d6388d60300491c603f17b30db108a7" translate="yes" xml:space="preserve">
          <source>If you are finished using a host for the time being, you can stop it with &lt;code&gt;docker-machine stop&lt;/code&gt; and later start it again with &lt;code&gt;docker-machine start&lt;/code&gt;.</source>
          <target state="translated">당분간 호스트 사용을 마치면 &lt;code&gt;docker-machine stop&lt;/code&gt; 으로 호스트를 중지 할 수 있습니다 나중에 다시 시작할 수 있습니다 &lt;code&gt;docker-machine start&lt;/code&gt; 로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91e229fd9d790c65ecc4af56e7cc67bf2ac8787b" translate="yes" xml:space="preserve">
          <source>If you are having problems with Docker after loading a plugin, ask the authors of the plugin for help. The Docker team may not be able to assist you.</source>
          <target state="translated">플러그인을로드 한 후 Docker에 문제가있는 경우 플러그인 작성자에게 도움을 요청하십시오. Docker 팀이 지원하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb8508ccbd8b2e9b8654e670245fe6b98375ea1" translate="yes" xml:space="preserve">
          <source>If you are interested in writing a plugin for Docker, or seeing how they work under the hood, see the &lt;a href=&quot;../plugin_api/index&quot;&gt;docker plugins reference&lt;/a&gt;.</source>
          <target state="translated">Docker 용 플러그인을 작성하거나 후드에서 작동하는 방식을 확인하려면 &lt;a href=&quot;../plugin_api/index&quot;&gt; docker plugins 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91e910a080c7afa02fe688d8641ca23bf75ab2a5" translate="yes" xml:space="preserve">
          <source>If you are just getting started with Docker and want to learn the best way to deploy multi-service applications, a good place to start is the &lt;a href=&quot;../../get-started/index&quot;&gt;Get Started walkthrough&lt;/a&gt;. This shows you how to define a service configuration in a Compose file, deploy the app, and use the relevant tools and commands.</source>
          <target state="translated">Docker를 시작하고 멀티 서비스 응용 프로그램을 배포하는 가장 좋은 방법을 배우고 싶다면 시작하기 좋은 곳은 &lt;a href=&quot;../../get-started/index&quot;&gt; 시작하기 연습 하십시오.&lt;/a&gt; . 작성 파일에서 서비스 구성을 정의하고, 앱을 배포하고, 관련 도구 및 명령을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2838bc8eaec18e388ed0ec70489c362f2bf9fc03" translate="yes" xml:space="preserve">
          <source>If you are just using trust out-of-the-box you only need your Docker Engine client and access to the Docker Hub. The sandbox mimics a production trust environment, and sets up these additional components.</source>
          <target state="translated">즉시 사용 가능한 신뢰를 사용하는 경우 Docker Engine 클라이언트와 Docker Hub에 대한 액세스 만 필요합니다. 샌드 박스는 프로덕션 트러스트 환경을 모방하여 이러한 추가 구성 요소를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="449bd5b09cd68c9348c0aee8d36b5bc15bd61f2a" translate="yes" xml:space="preserve">
          <source>If you are looking to configure a service&amp;rsquo;s restart policy, please refer to &lt;a href=&quot;../../compose-file/index#restart&quot;&gt;restart&lt;/a&gt; in Compose file v3 and &lt;a href=&quot;../../compose-file/compose-file-v2/index#restart&quot;&gt;restart&lt;/a&gt; in Compose v2. Note that if you are &lt;a href=&quot;../../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt;, you should use &lt;a href=&quot;../../compose-file/index#restart&quot;&gt;restart_policy&lt;/a&gt;, instead.</source>
          <target state="translated">서비스의 재시작 정책을 구성하려면 Compose file v3에서 &lt;a href=&quot;../../compose-file/compose-file-v2/index#restart&quot;&gt;재시작&lt;/a&gt; 및 Compose v2에서 &lt;a href=&quot;../../compose-file/index#restart&quot;&gt;재시작&lt;/a&gt; 을 참조하십시오 . 당신이 경우 참고 &lt;a href=&quot;../../../engine/reference/commandline/stack_deploy/index&quot;&gt;떼 모드에서 스택을 배포&lt;/a&gt; , 사용한다 &lt;a href=&quot;../../compose-file/index#restart&quot;&gt;restart_policy을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="4d7706ffb54bbd50f08337edc7055ec69a597e42" translate="yes" xml:space="preserve">
          <source>If you are not already an AWS user, sign up for &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;AWS&lt;/a&gt; to create an account and get root access to EC2 cloud computers.</source>
          <target state="translated">이미 AWS 사용자가 아닌 경우, 가입 &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;AWS&lt;/a&gt; 계정을 만들고 EC2 클라우드 컴퓨터에 대한 루트 액세스 권한을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f605e0935104fbb038aef428a6e8bdecfb4e8f0c" translate="yes" xml:space="preserve">
          <source>If you are not using virtualenv,</source>
          <target state="translated">virtualenv를 사용하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="e426a03f3dc82b81b2c16ad7783f7dcb49a06804" translate="yes" xml:space="preserve">
          <source>If you are on Windows and using either PowerShell or &lt;code&gt;cmd.exe&lt;/code&gt;, &lt;code&gt;docker-machine env&lt;/code&gt; Docker Machine should now detect your shell automatically. If the automatic detection does not work, you can still override it using the &lt;code&gt;--shell&lt;/code&gt; flag for &lt;code&gt;docker-machine env&lt;/code&gt;.</source>
          <target state="translated">Windows에서 파워 쉘 또는 중 하나를 사용하는 경우 &lt;code&gt;cmd.exe&lt;/code&gt; 를을 , &lt;code&gt;docker-machine env&lt;/code&gt; 도커 기계는 자동으로 쉘을 감지합니다. 자동 감지가 작동하지 않으면 &lt;code&gt;docker-machine env&lt;/code&gt; 에 &lt;code&gt;--shell&lt;/code&gt; 플래그를 사용하여이를 자동으로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e8b7a8c3077ea87de3300f6715a2c92023fe18a" translate="yes" xml:space="preserve">
          <source>If you are running &lt;strong&gt;Linux&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Linux를&lt;/strong&gt; 실행중인 경우&lt;strong&gt;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d1a38d6f4970e1e63cbcfa5bc29abcd4e590868a" translate="yes" xml:space="preserve">
          <source>If you are running &lt;strong&gt;Windows&lt;/strong&gt; with &lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git BASH&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git BASH를 사용&lt;/a&gt; 하여 &lt;strong&gt;Windows&lt;/strong&gt; 를 실행중인 경우 :</target>
        </trans-unit>
        <trans-unit id="60b7b84c6c5a44b9bfed2910401774f57a8578b3" translate="yes" xml:space="preserve">
          <source>If you are running &lt;strong&gt;macOS&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;macOS를&lt;/strong&gt; 실행중인 경우&lt;strong&gt;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="274bac5ac8b6e1a7be863beec0e78914f6ca4a33" translate="yes" xml:space="preserve">
          <source>If you are running Docker Desktop for Mac, you can run Docker commands to talk to the Docker Engine installed with that app.</source>
          <target state="translated">Mac 용 Docker Desktop을 실행중인 경우 Docker 명령을 실행하여 해당 앱과 함께 설치된 Docker Engine과 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1271a500104947b8c2ef7bbb21aa561d333e172e" translate="yes" xml:space="preserve">
          <source>If you are running Docker on Linux, the files &lt;code&gt;django-admin&lt;/code&gt; created are owned by root. This happens because the container runs as the root user. Change the ownership of the new files.</source>
          <target state="translated">Linux에서 Docker를 실행중인 경우, &lt;code&gt;django-admin&lt;/code&gt; 작성 파일 은 root가 소유합니다. 컨테이너가 루트 사용자로 실행되기 때문입니다. 새 파일의 소유권을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9bd0326f049b25cac67f5b05f08d6ad832c995e3" translate="yes" xml:space="preserve">
          <source>If you are running Docker on Linux, the files &lt;code&gt;rails new&lt;/code&gt; created are owned by root. This happens because the container runs as the root user. If this is the case, change the ownership of the new files.</source>
          <target state="translated">Linux에서 Docker를 실행하는 경우 파일이 &lt;code&gt;rails new&lt;/code&gt; 통과합니다 작성된 은 루트가 소유합니다. 컨테이너가 루트 사용자로 실행되기 때문입니다. 이 경우 새 파일의 소유권을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="aef42acffcb02495ac96edeead57452e94f34c7d" translate="yes" xml:space="preserve">
          <source>If you are running Docker on Mac or Windows, you should already have ownership of all files, including those generated by &lt;code&gt;django-admin&lt;/code&gt;. List the files just to verify this.</source>
          <target state="translated">Mac 또는 Windows에서 Docker를 실행중인 경우 &lt;code&gt;django-admin&lt;/code&gt; 에 의해 생성 된 파일을 포함하여 모든 파일의 소유권이 이미 있어야합니다. 합니다. 이를 확인하기 위해 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="61e1a755b7476e63784d2625ca4a5b782443c09a" translate="yes" xml:space="preserve">
          <source>If you are running Docker on Mac or Windows, you should already have ownership of all files, including those generated by &lt;code&gt;rails new&lt;/code&gt;.</source>
          <target state="translated">Mac 또는 Windows에서 Docker를 실행중인 경우, &lt;code&gt;rails new&lt;/code&gt; 생성 된 파일을 포함하여 모든 파일의 소유권이 이미 있어야합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="8060ae59ed75e0b362e43211d5ff52833f627276" translate="yes" xml:space="preserve">
          <source>If you are running a prometheus server you can add this address to your scrape configs to have prometheus collect metrics on Docker. For more information on prometheus you can view the website &lt;a href=&quot;https://prometheus.io/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">prometheus 서버를 실행중인 경우이 주소를 스크랩 구성에 추가하여 prometheus가 Docker에서 메트릭을 수집하도록 할 수 있습니다. prometheus에 대한 자세한 내용은 &lt;a href=&quot;https://prometheus.io/&quot;&gt;여기&lt;/a&gt; 웹 사이트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c984f811e26f09cdccdcc96301034bacc8fd0dd1" translate="yes" xml:space="preserve">
          <source>If you are running the Docker daemon and client directly on Microsoft Windows Server, follow the instructions in the Windows Server tab.</source>
          <target state="translated">Microsoft Windows Server에서 Docker 데몬 및 클라이언트를 직접 실행중인 경우 Windows Server 탭의 지시 사항을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="9ea989c2545d0bda4cacb3881da917239a9b56de" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;../../machine/index&quot;&gt;Docker Machine&lt;/a&gt;, you can run the command &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; to get the machine address, and then open &lt;code&gt;http://MACHINE_VM_IP:8000&lt;/code&gt; in a web browser.</source>
          <target state="translated">&lt;a href=&quot;../../machine/index&quot;&gt;Docker Machine을&lt;/a&gt; 사용하는 경우 &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; 명령을 실행하여 시스템 주소를 얻은 다음 웹 브라우저에서 &lt;code&gt;http://MACHINE_VM_IP:8000&lt;/code&gt; 을 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bf06f0e609f54cfdf0286937b4230a68a242b14" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt;, then &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; returns the Docker host IP address, to which you can append the port (&lt;code&gt;&amp;lt;Docker-Host-IP&amp;gt;:3000&lt;/code&gt;).</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine을&lt;/a&gt; , 다음 &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; 당신이 (포트를 추가 할 수있는 할 수있는 부두 노동자 호스트의 IP 주소를 반환 &lt;code&gt;&amp;lt;Docker-Host-IP&amp;gt;:3000&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="65f1943dd64b104ca00b2f5f7af5815488299136" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;fish&lt;/code&gt; and the &lt;code&gt;SHELL&lt;/code&gt; environment variable is correctly set to the path where &lt;code&gt;fish&lt;/code&gt; is located, &lt;code&gt;docker-machine env name&lt;/code&gt; prints out the values in the format which &lt;code&gt;fish&lt;/code&gt; expects:</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;fish&lt;/code&gt; 와 &lt;code&gt;SHELL&lt;/code&gt; 환경 변수를 제대로 곳의 경로로 설정되어 &lt;code&gt;fish&lt;/code&gt; 위치하고 있으며, &lt;code&gt;docker-machine env name&lt;/code&gt; 있는 형식의 값에서 인쇄 &lt;code&gt;fish&lt;/code&gt; 예상하는 :</target>
        </trans-unit>
        <trans-unit id="a0c6d522e29f05efde106f3729ac8ef710dafe89" translate="yes" xml:space="preserve">
          <source>If you are using DTR and would like to work with a remote UCP&amp;rsquo;s signing policy, you must &lt;a href=&quot;https://docs.docker.com/ee/dtr/user/manage-images/sign-images/trust-with-remote-ucp/#registering-dtr-with-a-remote-universal-control-plane&quot;&gt;register your DTR instance with that remote UCP&lt;/a&gt;. See &lt;a href=&quot;https://docs.docker.com/ee/dtr/user/manage-images/sign-images/trust-with-remote-ucp/&quot;&gt;Using Docker Content Trust with a Remote UCP Cluster&lt;/a&gt; for more details.</source>
          <target state="translated">DTR을 사용하고 있고 원격 UCP 서명 정책을 사용하려면 다음을 수행해야합니다. &lt;a href=&quot;https://docs.docker.com/ee/dtr/user/manage-images/sign-images/trust-with-remote-ucp/#registering-dtr-with-a-remote-universal-control-plane&quot;&gt; 해당 원격 UCP에 DTR 인스턴스를 등록&lt;/a&gt; . &lt;a href=&quot;https://docs.docker.com/ee/dtr/user/manage-images/sign-images/trust-with-remote-ucp/&quot;&gt;원격 UCP 클러스터에서 Docker Content Trust 사용을&lt;/a&gt; 참조하십시오. 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f23e83ee2a1be50e774f6a894aabfcf72356f986" translate="yes" xml:space="preserve">
          <source>If you are using Docker Desktop for Mac</source>
          <target state="translated">Mac 용 Docker Desktop을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="4aeb34bddb4bdeb5566474748c20ff61616a94a7" translate="yes" xml:space="preserve">
          <source>If you are using Docker Desktop for Mac or Docker Desktop for Windows, you can use &lt;code&gt;http://localhost&lt;/code&gt; as the IP address, and open &lt;code&gt;http://localhost:8000&lt;/code&gt; in a web browser.</source>
          <target state="translated">Mac 용 Docker Desktop 또는 Windows 용 Docker Desktop을 사용하는 경우 &lt;code&gt;http://localhost&lt;/code&gt; 를 를 IP 주소로 사용하고 &lt;code&gt;http://localhost:8000&lt;/code&gt; 을 열 수 있습니다 . 로 사용하고 웹 브라우저에서 을 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d7766addc8a1d4fe2974745ee773f217c8cf25d" translate="yes" xml:space="preserve">
          <source>If you are using Docker Desktop for Windows</source>
          <target state="translated">Windows 용 Docker Desktop을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="0fe9adb6aa496fdf96f55cf7560ac6d40c6b9d1a" translate="yes" xml:space="preserve">
          <source>If you are using Docker Machine, you can get the manager IP with either &lt;code&gt;docker-machine ls&lt;/code&gt; or &lt;code&gt;docker-machine ip &amp;lt;MACHINE-NAME&amp;gt;&lt;/code&gt; &amp;mdash; for example, &lt;code&gt;docker-machine ip manager1&lt;/code&gt;.</source>
          <target state="translated">Docker Machine을 사용하는 경우 &lt;code&gt;docker-machine ls&lt;/code&gt; 또는 &lt;code&gt;docker-machine ip &amp;lt;MACHINE-NAME&amp;gt;&lt;/code&gt; ( 예 : &lt;code&gt;docker-machine ip manager1&lt;/code&gt; )을 사용 하여 관리자 IP를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc6b921149bdbc488eafbd24a5c9d241fbc76133" translate="yes" xml:space="preserve">
          <source>If you are using Docker Toolbox</source>
          <target state="translated">Docker Toolbox를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="b3d6b6012d17b1e4a8c151c621e2da2363ed6a50" translate="yes" xml:space="preserve">
          <source>If you are using Docker Toolbox on a Windows system that has Hyper-V but cannot run Docker Desktop for Windows (for example Windows 8 Pro), you must use the &lt;code&gt;hyperv&lt;/code&gt; driver to create local machines. (See the &lt;a href=&quot;../drivers/hyper-v/index&quot;&gt;Docker Machine driver for Microsoft Hyper-V&lt;/a&gt;.)</source>
          <target state="translated">Hyper-V가 있지만 Windows 용 Docker Desktop (예 : Windows 8 Pro)을 실행할 수없는 Windows 시스템에서 Docker Toolbox를 사용하는 경우 로컬 시스템을 작성 하려면 &lt;code&gt;hyperv&lt;/code&gt; 드라이버를 사용해야합니다 . ( &lt;a href=&quot;../drivers/hyper-v/index&quot;&gt;Microsoft Hyper-V 용 Docker Machine 드라이버를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6f6dc0518260229841fc1884f8e46539accf8f0d" translate="yes" xml:space="preserve">
          <source>If you are using Docker Toolbox on either Mac or an older version Windows system (without Hyper-V), use the &lt;code&gt;virtualbox&lt;/code&gt; driver to create a local machine based on Oracle &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;VirtualBox&lt;/a&gt;. (See the &lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;Docker Machine driver for Oracle VirtualBox&lt;/a&gt;.)</source>
          <target state="translated">Mac 또는 이전 버전의 Windows 시스템 (Hyper-V없이)에서 Docker Toolbox를 사용하는 경우 &lt;code&gt;virtualbox&lt;/code&gt; 드라이버를 사용하여 Oracle &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;VirtualBox&lt;/a&gt; 기반 로컬 시스템을 작성하십시오 . ( &lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;Oracle VirtualBox 용 Docker Machine 드라이버를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8443d422f46f76025ba1855c3719e721e90a26fa" translate="yes" xml:space="preserve">
          <source>If you are using Linux based physical computers or cloud-provided computers as hosts, simply follow the &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;Linux install instructions&lt;/a&gt; for your platform. Spin up the three machines, and you are ready. You can test both single-node and multi-node swarm scenarios on Linux machines.</source>
          <target state="translated">Linux 기반 실제 컴퓨터 또는 클라우드 제공 컴퓨터를 호스트로 &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;사용하는&lt;/a&gt; 경우 플랫폼에 대한 Linux 설치 지시 사항 을 따르십시오 . 세 대의 기계를 돌리면 준비가 된 것입니다. Linux 시스템에서 단일 노드 및 다중 노드 스웜 시나리오를 모두 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1822fdef618139232f9ae99448fdb174ae6c0c5b" translate="yes" xml:space="preserve">
          <source>If you are using Oracle VirtualBox on an older Windows OS, you might encounter an issue with shared folders as described in this &lt;a href=&quot;https://www.virtualbox.org/ticket/14920&quot;&gt;VB trouble ticket&lt;/a&gt;. Newer Windows systems meet the requirements for &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; and do not need VirtualBox.</source>
          <target state="translated">이전 Windows OS에서 Oracle VirtualBox를 사용하는 경우이 &lt;a href=&quot;https://www.virtualbox.org/ticket/14920&quot;&gt;VB 문제 티켓에&lt;/a&gt; 설명 된대로 공유 폴더에 문제가 발생할 수 있습니다 . 최신 Windows 시스템은 Windows 용 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/&quot;&gt;Docker Desktop&lt;/a&gt; 요구 사항을 충족하며 VirtualBox가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12a835c73806df72a6cb71d1319e8057784da3d6" translate="yes" xml:space="preserve">
          <source>If you are using Toolbox on Mac, Toolbox on older Windows systems without Hyper-V, or Docker Desktop for Mac, use &lt;code&gt;virtualbox&lt;/code&gt; as the driver, as shown in this example. (The Docker Machine VirtualBox driver reference is &lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;here&lt;/a&gt;.) (See &lt;a href=&quot;index#prerequisite-information&quot;&gt;prerequisites&lt;/a&gt; above to learn more.)</source>
          <target state="translated">Mac에서 Toolbox, Hyper-V가없는 이전 Windows 시스템의 Toolbox 또는 Mac 용 Docker Desktop을 사용 하는 경우이 예와 같이 &lt;code&gt;virtualbox&lt;/code&gt; 를 드라이버로 사용 하십시오. Docker Machine VirtualBox 드라이버 참조는 &lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;여기에 있습니다&lt;/a&gt; . 자세한 내용은 위의 &lt;a href=&quot;index#prerequisite-information&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9b0b1517866a9c5a82dae561f05848a752afef3" translate="yes" xml:space="preserve">
          <source>If you are using positive filtering (testing for the existence of a label or that a label has a specific value), you can use &lt;code&gt;docker image ls&lt;/code&gt; with the same filtering syntax to see which images match your filter.</source>
          <target state="translated">포지티브 필터링을 사용하는 경우 (레이블이 있는지 테스트하거나 레이블에 특정 값 이 있는지 확인) 동일한 필터링 구문으로 &lt;code&gt;docker image ls&lt;/code&gt; 를 사용하여 어떤 이미지가 필터와 일치하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e2bb35a43dba1912b56c6273200de74c793ab0" translate="yes" xml:space="preserve">
          <source>If you are using the &amp;ldquo;external&amp;rdquo; SSH type as detailed in the next section, you can include additional arguments to pass through to the &lt;code&gt;ssh&lt;/code&gt; binary in the generated command (unless they conflict with any of the default arguments for the command generated by Docker Machine). For instance, the following command forwards port 8080 from the &lt;code&gt;default&lt;/code&gt; machine to &lt;code&gt;localhost&lt;/code&gt; on your host computer:</source>
          <target state="translated">다음 섹션에 설명 된대로 &quot;외부&quot;SSH 유형을 사용하는 경우 생성 된 명령에서 &lt;code&gt;ssh&lt;/code&gt; 바이너리 로 전달할 추가 인수를 포함 할 수 있습니다 (Docker Machine이 생성 한 명령의 기본 인수와 충돌하지 않는 한) ). 예를 들어 다음 명령은 &lt;code&gt;default&lt;/code&gt; 컴퓨터에서 호스트 컴퓨터의 &lt;code&gt;localhost&lt;/code&gt; 호스트로 포트 8080을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="78cacb8f0970af90e5fbc8587816471552f94dd7" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;code&gt;dockremap&lt;/code&gt; user, verify that Docker created it using the &lt;code&gt;id&lt;/code&gt; command.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;dockremap&lt;/code&gt; 의 사용자를 도커를 사용하여 만든 확인 &lt;code&gt;id&lt;/code&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b2b29c737f9d8243c7788a4630f669d6ca78eedb" translate="yes" xml:space="preserve">
          <source>If you are using the Nano &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows Container&lt;/a&gt; and have not updated to the Windows Creator Update there is a bug affecting how &lt;a href=&quot;https://github.com/Microsoft/Virtualization-Documentation/issues/181#issuecomment-252671828&quot;&gt;Windows 10 talks to Containers via &amp;ldquo;NAT&amp;rdquo;&lt;/a&gt; (Network Address Translation). You must hit the IP of the container directly. You can get the IP address of your container with the following steps:</source>
          <target state="translated">Nano &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows 컨테이너를&lt;/a&gt; 사용 중이고 Windows Creator 업데이트로 업데이트하지 않은 경우 &lt;a href=&quot;https://github.com/Microsoft/Virtualization-Documentation/issues/181#issuecomment-252671828&quot;&gt;Windows 10이 &quot;NAT&quot;&lt;/a&gt; (네트워크 주소 변환) 를 통해 컨테이너와 통신 하는 방식에 영향을주는 버그가 있습니다. 컨테이너의 IP를 직접 쳐야합니다. 다음 단계에 따라 컨테이너의 IP 주소를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7697703344b8bfa4e06ceffe254b759b152c711" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t still running the &lt;code&gt;redis&lt;/code&gt; service from the &lt;a href=&quot;../rolling-update/index&quot;&gt;rolling update&lt;/a&gt; tutorial, start it now:</source>
          <target state="translated">&lt;a href=&quot;../rolling-update/index&quot;&gt;롤링 업데이트&lt;/a&gt; 자습서 에서 여전히 &lt;code&gt;redis&lt;/code&gt; 서비스를 실행하지 않는 경우 지금 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="368583aa359f85c71d7ef552cb2bba7c470d7c55" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t sure where to begin, see &lt;a href=&quot;../../get-started/index&quot;&gt;Get Started with Docker&lt;/a&gt;, which guides you through a brief end-to-end tutorial on Docker.</source>
          <target state="translated">어디서부터 시작해야할지 확실하지 않은 경우 &lt;a href=&quot;../../get-started/index&quot;&gt;Docker 시작하기를&lt;/a&gt; 참조 하십시오 .이 도움말은 Docker에 대한 간단한 종단 간 자습서를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="677e084a7f52453cacbe4581900a8bed6dde6744" translate="yes" xml:space="preserve">
          <source>If you bind mount a host path into your service&amp;rsquo;s containers, the path must exist on every swarm node. The Docker swarm mode scheduler can schedule containers on any machine that meets resource availability requirements and satisfies all constraints and placement preferences you specify.</source>
          <target state="translated">호스트 경로를 서비스 컨테이너에 바인드 할 경우 경로는 모든 스웜 노드에 존재해야합니다. Docker swarm 모드 스케줄러는 자원 가용성 요구 사항을 충족하고 지정한 모든 제한 조건 및 배치 환경 설정을 만족하는 모든 시스템에서 컨테이너를 스케줄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6deebe1e2047fa17ca4d7d8b24584b16cafcd5" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t modify the application, wrap the application in a lightweight init system (like &lt;a href=&quot;http://skarnet.org/software/s6/&quot;&gt;s6&lt;/a&gt;) or a signal proxy (like &lt;a href=&quot;https://github.com/Yelp/dumb-init&quot;&gt;dumb-init&lt;/a&gt; or &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;tini&lt;/a&gt;). Either of these wrappers take care of handling &lt;code&gt;SIGTERM&lt;/code&gt; properly.</source>
          <target state="translated">응용 프로그램을 수정할 수 없으면 응용 프로그램을 경량 init 시스템 (예 : &lt;a href=&quot;http://skarnet.org/software/s6/&quot;&gt;s6&lt;/a&gt; ) 또는 신호 프록시 ( &lt;a href=&quot;https://github.com/Yelp/dumb-init&quot;&gt;dumb-init&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;tini 등&lt;/a&gt; )로 래핑 하십시오. 이 래퍼 중 하나가 &lt;code&gt;SIGTERM&lt;/code&gt; 을 올바르게 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="02c4e70f5a3eb75d17adc426b1ff53b0d5f52c8e" translate="yes" xml:space="preserve">
          <source>If you change a service&amp;rsquo;s Dockerfile or the contents of its build directory, run &lt;code&gt;docker-compose build&lt;/code&gt; to rebuild it.</source>
          <target state="translated">서비스의 Dockerfile 또는 해당 빌드 디렉토리의 내용을 변경하는 경우 &lt;code&gt;docker-compose build&lt;/code&gt; 를 실행 하여 다시 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="f8b12dcc3d165b1ceb7248d071ff3c281634c921" translate="yes" xml:space="preserve">
          <source>If you change the parent image for a provider, you may also need to change the SSH user. For example, the default Red Hat AMI on EC2 expects the SSH user to be &lt;code&gt;ec2-user&lt;/code&gt;, so you need to specify this with &lt;code&gt;--amazonec2-ssh-user ec2-user&lt;/code&gt;.</source>
          <target state="translated">제공자의 상위 이미지를 변경하면 SSH 사용자도 변경해야합니다. 예를 들어 EC2의 기본 Red Hat AMI는 SSH 사용자가 &lt;code&gt;ec2-user&lt;/code&gt; 일 것으로 예상 하므로 &lt;code&gt;--amazonec2-ssh-user ec2-user&lt;/code&gt; 로이 를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4ae5a54c0c585b0a1692438e48f55bed24f9e64d" translate="yes" xml:space="preserve">
          <source>If you create a host with Docker Machine, but remove it through the cloud provider console, Machine loses track of the server status. Use the &lt;code&gt;docker-machine rm&lt;/code&gt; command for hosts you create with &lt;code&gt;docker-machine create&lt;/code&gt;.</source>
          <target state="translated">Docker Machine으로 호스트를 작성하지만 클라우드 제공자 콘솔을 통해 호스트를 제거하면 Machine은 서버 상태를 추적하지 않습니다. 사용 &lt;code&gt;docker-machine rm&lt;/code&gt; 당신이 만들 호스트에 대한 명령을 &lt;code&gt;docker-machine create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddb8f8f01a1f039f50afb43e83a32148b908250" translate="yes" xml:space="preserve">
          <source>If you define both links and &lt;a href=&quot;#networks&quot;&gt;networks&lt;/a&gt;, services with links between them must share at least one network in common to communicate.</source>
          <target state="translated">링크와 &lt;a href=&quot;#networks&quot;&gt;네트워크를&lt;/a&gt; 모두 정의하는 경우 링크가있는 서비스는 통신하기 위해 공통으로 하나 이상의 네트워크를 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e4476a0e97f80119a8fa4e29728f09d4d507972" translate="yes" xml:space="preserve">
          <source>If you develop a container that can be deployed as a service and requires sensitive data, such as a credential, as an environment variable, consider adapting your image to take advantage of Docker secrets. One way to do this is to ensure that each parameter you pass to the image when creating the container can also be read from a file.</source>
          <target state="translated">서비스로 배포 할 수 있고 환경 변수로 자격 증명과 같은 민감한 데이터가 필요한 컨테이너를 개발하는 경우 Docker 비밀을 활용하도록 이미지를 조정하는 것이 좋습니다. 이를 수행하는 한 가지 방법은 컨테이너를 작성할 때 이미지에 전달하는 각 매개 변수를 파일에서 읽을 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="575871ae346b7ca4b69480dc45ec836ca0a477cf" translate="yes" xml:space="preserve">
          <source>If you do block IO in the two containers at the same time, by, for example:</source>
          <target state="translated">두 컨테이너에서 동시에 IO를 차단하는 경우 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad68409f5cc1b6d48388836f2da83fbcbce47bfc" translate="yes" xml:space="preserve">
          <source>If you do not export this variable in self-hosted environments, you may see errors such as:</source>
          <target state="translated">자체 호스팅 환경에서이 변수를 내 보내지 않으면 다음과 같은 오류가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c0870c394081af7e96cfb9ed1a8f8118d90581" translate="yes" xml:space="preserve">
          <source>If you do not log in, you will see:</source>
          <target state="translated">로그인하지 않으면 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e759bd57a5d5499c4aeaa122b36fe9453f06c102" translate="yes" xml:space="preserve">
          <source>If you do not specify &lt;code&gt;-a&lt;/code&gt; then Docker will &lt;a href=&quot;https://github.com/docker/docker/blob/4118e0c9eebda2412a09ae66e90c34b85fae3275/runconfig/opts/parse.go#L267&quot;&gt;attach to both stdout and stderr &lt;/a&gt;. You can specify to which of the three standard streams (&lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, &lt;code&gt;STDERR&lt;/code&gt;) you&amp;rsquo;d like to connect instead, as in:</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; 를 지정하지 않으면 Docker는 &lt;a href=&quot;https://github.com/docker/docker/blob/4118e0c9eebda2412a09ae66e90c34b85fae3275/runconfig/opts/parse.go#L267&quot;&gt;stdout 및 stderr 모두에 연결합니다&lt;/a&gt; . 다음과 같이 세 개의 표준 스트림 ( &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;STDERR&lt;/code&gt; ) 중 연결하려는 표준 스트림을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="476784f24aefd123d2cb435131f1cf88ecf21040" translate="yes" xml:space="preserve">
          <source>If you do not use a host path, you may specify a &lt;code&gt;volume_driver&lt;/code&gt;.</source>
          <target state="translated">호스트 경로를 사용하지 않으면 &lt;code&gt;volume_driver&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2269d1903015b14c57c7a26494021cc386473ebd" translate="yes" xml:space="preserve">
          <source>If you do not want the &lt;code&gt;run&lt;/code&gt; command to start linked containers, use the &lt;code&gt;--no-deps&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 명령으로 연결된 컨테이너를 시작 하지 않으려면 &lt;code&gt;--no-deps&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d287d7c9376af746a858827f8d67d9315d68426a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t &lt;a href=&quot;#formatting&quot;&gt;specify a format string using &lt;code&gt;--format&lt;/code&gt;&lt;/a&gt;, the following columns are shown.</source>
          <target state="translated">&lt;a href=&quot;#formatting&quot;&gt; &lt;code&gt;--format&lt;/code&gt; 을&lt;/a&gt; 사용하여 형식 문자열을 지정 하지 않으면 다음 열이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="97c3b203c765b267f7eceec41a1189986ca17c67" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a Docker account, sign up for one at &lt;a href=&quot;https://hub.docker.com&quot;&gt;hub.docker.com&lt;/a&gt;. Make note of your username.</source>
          <target state="translated">Docker 계정이없는 경우 &lt;a href=&quot;https://hub.docker.com&quot;&gt;hub.docker.com&lt;/a&gt; 에서 하나를 등록하십시오 . 사용자 이름을 기록해 두십시오.</target>
        </trans-unit>
        <trans-unit id="e1f8511b6607846f2f14740a4b7e2cebbfecee87" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a credentials file, you can use the flags &lt;code&gt;--amazonec2-access-key&lt;/code&gt; and &lt;code&gt;--amazonec2-secret-key&lt;/code&gt; on the command line:</source>
          <target state="translated">자격 증명 파일이없는 경우 명령 줄에서 &lt;code&gt;--amazonec2-access-key&lt;/code&gt; 및 &lt;code&gt;--amazonec2-secret-key&lt;/code&gt; 플래그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="186a5d7235f15d036cee477654f5d9ca373a8af2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have the command available, you can run the following command on a manager node to retrieve the join command for a worker:</source>
          <target state="translated">사용 가능한 명령이없는 경우 관리자 노드에서 다음 명령을 실행하여 작업자에 대한 join 명령을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7a5196a1d87d7c58d0e216e7c0f9dc1737deed" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t see your question here, feel free to drop by &lt;code&gt;#docker-compose&lt;/code&gt; on freenode IRC and ask the community.</source>
          <target state="translated">여기에 질문이 없다면, freenode IRC에서 &lt;code&gt;#docker-compose&lt;/code&gt; 를 이용하여 커뮤니티에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="90f9cf27e5ec7a779ebedfcb606fe402ca756713" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a &lt;code&gt;tag&lt;/code&gt;, the &lt;code&gt;latest&lt;/code&gt; tag is used. For example, to filter for containers that use the latest &lt;code&gt;ubuntu&lt;/code&gt; image:</source>
          <target state="translated">당신은 지정하지 않은 경우 &lt;code&gt;tag&lt;/code&gt; 의 &lt;code&gt;latest&lt;/code&gt; 태그가 사용됩니다. 예를 들어 최신 &lt;code&gt;ubuntu&lt;/code&gt; 이미지 를 사용하는 컨테이너를 필터링하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e2db7766d9aa0955958ff142a92f9d3065e673c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a version at all, by convention the image&amp;rsquo;s &lt;code&gt;latest&lt;/code&gt; tag is resolved to a digest. Workers use the image at this digest when creating the service task.</source>
          <target state="translated">버전을 전혀 지정하지 않으면 규칙에 따라 이미지의 &lt;code&gt;latest&lt;/code&gt; 태그가 요약으로 분석됩니다. 서비스 작업을 생성 할 때 작업자는이 요약에서 이미지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b9f94a0c049d039b02da59313a42d240802217fd" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify an advertise address, Docker checks if the system has a single IP address. If so, Docker uses the IP address with the listening port &lt;code&gt;2377&lt;/code&gt; by default. If the system has multiple IP addresses, you must specify the correct &lt;code&gt;--advertise-addr&lt;/code&gt; to enable inter-manager communication and overlay networking:</source>
          <target state="translated">광고 주소를 지정하지 않으면 Docker는 시스템에 단일 IP 주소가 있는지 확인합니다. 그렇다면 Docker는 기본적으로 청취 포트 &lt;code&gt;2377&lt;/code&gt; 의 IP 주소를 사용합니다 . 시스템에 여러 IP 주소가있는 경우 관리자 간 통신 및 오버레이 네트워킹을 활성화 하려면 올바른 &lt;code&gt;--advertise-addr&lt;/code&gt; 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3aef570b6454b7ea0e31c6e16f44892153fe92d2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to have complete two-way authentication, you can run Docker in various other modes by mixing the flags.</source>
          <target state="translated">완전한 양방향 인증을 원하지 않으면 플래그를 혼합하여 다양한 다른 모드에서 Docker를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e1a12a4cf16290ef09f612e3eaf11afdf8d41ce" translate="yes" xml:space="preserve">
          <source>If you enable user namespaces on the daemon, all containers are started with user namespaces enabled by default. In some situations, such as privileged containers, you may need to disable user namespaces for a specific container. See &lt;a href=&quot;#user-namespace-known-restrictions&quot;&gt;user namespace known limitations&lt;/a&gt; for some of these limitations.</source>
          <target state="translated">데몬에서 사용자 네임 스페이스를 활성화하면 모든 컨테이너는 기본적으로 활성화 된 사용자 네임 스페이스로 시작됩니다. 권한있는 컨테이너와 같은 일부 상황에서는 특정 컨테이너에 대한 사용자 네임 스페이스를 비활성화해야 할 수도 있습니다. 이러한 제한 중 일부는 &lt;a href=&quot;#user-namespace-known-restrictions&quot;&gt;사용자 네임 스페이스의 알려진 제한 사항&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31d701341bbccced849a07cc643cb47aefef082b" translate="yes" xml:space="preserve">
          <source>If you encounter any troubles, activate the debug mode with &lt;code&gt;docker-machine --debug create ...&lt;/code&gt;.</source>
          <target state="translated">문제가 발생하면 &lt;code&gt;docker-machine --debug create ...&lt;/code&gt; 로 디버그 모드를 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="112b7f8b8599cb8cc231efdf128113ada642d6dc" translate="yes" xml:space="preserve">
          <source>If you expect to run multiple service tasks on each node (such as when you have 5 nodes but run 10 replicas), you cannot specify a static target port. Either allow Docker to assign a random high-numbered port (by leaving off the &lt;code&gt;published&lt;/code&gt;), or ensure that only a single instance of the service runs on a given node, by using a global service rather than a replicated one, or by using placement constraints.</source>
          <target state="translated">각 노드에서 여러 서비스 작업을 실행하려는 경우 (예 : 5 개의 노드가 있지만 10 개의 복제본을 실행하는 경우) 정적 대상 포트를 지정할 수 없습니다. Docker가 임의의 높은 번호의 포트를 할당하거나 ( &lt;code&gt;published&lt;/code&gt; 상태로 두지 않음 ) 복제 된 인스턴스가 아닌 글로벌 서비스를 사용하거나 배치를 사용하여 지정된 노드에서 서비스의 단일 인스턴스 만 실행되도록합니다. 제약.</target>
        </trans-unit>
        <trans-unit id="0a7daaab452426ed2cf511180ebc213bd02bd56f" translate="yes" xml:space="preserve">
          <source>If you forget and use a single dollar sign (&lt;code&gt;$&lt;/code&gt;), Compose interprets the value as an environment variable and warns you:</source>
          <target state="translated">단일 달러 기호 ( &lt;code&gt;$&lt;/code&gt; ) 를 잊어 버린 경우 Compose는 값을 환경 변수로 해석하고 다음을 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5a0595a7809e4ba754d3137ba4f6017c2b6339eb" translate="yes" xml:space="preserve">
          <source>If you forget to add &lt;code&gt;exec&lt;/code&gt; to the beginning of your &lt;code&gt;ENTRYPOINT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ENTRYPOINT&lt;/code&gt; 의 시작 부분에 &lt;code&gt;exec&lt;/code&gt; 를 추가 하지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="fdabe86ef88a25b0fef6bce2a5c26f06f91591bb" translate="yes" xml:space="preserve">
          <source>If you get a &amp;ldquo;Permission denied&amp;rdquo; error using either of the above methods, you probably do not have the proper permissions to remove &lt;code&gt;docker-compose&lt;/code&gt;. To force the removal, prepend &lt;code&gt;sudo&lt;/code&gt; to either of the above commands and run again.</source>
          <target state="translated">위의 방법 중 하나를 사용하여 &quot;권한 거부&quot;오류가 발생하면 &lt;code&gt;docker-compose&lt;/code&gt; 를 제거 할 수있는 적절한 권한이 없을 것입니다 . 강제로 제거하려면 위 명령 중 하나에 &lt;code&gt;sudo&lt;/code&gt; 를 추가 하고 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ec431f0597a613ee0d286ae44f8214fdcb018868" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;package.json&lt;/code&gt; entry for &lt;code&gt;script:start&lt;/code&gt; like &lt;code&gt;NODE_ENV=test node server.js&lt;/code&gt;, then this overrules any setting in your &lt;code&gt;docker-compose.yml&lt;/code&gt; file.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;package.json&lt;/code&gt; 의 진입 &lt;code&gt;script:start&lt;/code&gt; 처럼 &lt;code&gt;NODE_ENV=test node server.js&lt;/code&gt; 다음이 당신의 모든 설정에 우선, &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="b8c6561ca760c20f5dcb12a3fc439c1eedd35e1f" translate="yes" xml:space="preserve">
          <source>If you have an Amazon account, you can use it as your root user account.</source>
          <target state="translated">Amazon 계정이 있으면 루트 사용자 계정으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9580378ea68280b6d09c17970d8810b86a9bec8" translate="yes" xml:space="preserve">
          <source>If you have enabled authentication for your notary server, or are using DTR, you will need to log in before you can push data to the notary server.</source>
          <target state="translated">공증 서버에 대한 인증을 활성화했거나 DTR을 사용중인 경우, 공증 서버로 데이터를 푸시하기 전에 로그인해야합니다.</target>
        </trans-unit>
        <trans-unit id="df676371c5819ad05d694e0dbbb415d9904e6ae0" translate="yes" xml:space="preserve">
          <source>If you have not already done so, initialize or join the swarm.</source>
          <target state="translated">아직 그렇게하지 않은 경우 떼를 초기화하거나 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="4e30bacce350f0e702c08acd910918c385b995e2" translate="yes" xml:space="preserve">
          <source>If you have not done so already, go to &lt;a href=&quot;https://digitalocean.com&quot;&gt;DigitalOcean&lt;/a&gt;, create an account, and log in.</source>
          <target state="translated">아직 수행하지 않은 경우 &lt;a href=&quot;https://digitalocean.com&quot;&gt;DigitalOcean으로&lt;/a&gt; 이동 하여 계정을 작성한 후 로그인하십시오.</target>
        </trans-unit>
        <trans-unit id="1d7fa2fe87a8040f995c006f37eda109d7f982bf" translate="yes" xml:space="preserve">
          <source>If you have problems installing with &lt;code&gt;curl&lt;/code&gt;, see &lt;a href=&quot;index#alternative-install-options&quot;&gt;Alternative Install Options&lt;/a&gt; tab above.</source>
          <target state="translated">&lt;code&gt;curl&lt;/code&gt; 설치에 문제가있는 경우 위의 &lt;a href=&quot;index#alternative-install-options&quot;&gt;대체 설치 옵션&lt;/a&gt; 탭을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0d30bbe3e73c97a181f9b5fb530d8bc16648ce5" translate="yes" xml:space="preserve">
          <source>If you have set the &lt;code&gt;--exec-opt isolation=hyperv&lt;/code&gt; option on the Docker &lt;code&gt;daemon&lt;/code&gt;, or are running against a Windows client-based daemon, these commands are equivalent and result in &lt;code&gt;hyperv&lt;/code&gt; isolation:</source>
          <target state="translated">Docker &lt;code&gt;daemon&lt;/code&gt; 에서 &lt;code&gt;--exec-opt isolation=hyperv&lt;/code&gt; 옵션을 설정 했거나 Windows 클라이언트 기반 데몬에 대해 실행중인 &lt;code&gt;hyperv&lt;/code&gt; 명령은 동일하며 hyperv 격리가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="27bc0ab6e19cfb93bab11e15f49e5ec527f5e9d4" translate="yes" xml:space="preserve">
          <source>If you have specified a Compose file with &lt;code&gt;docker-compose -f FILE&lt;/code&gt;, paths in &lt;code&gt;env_file&lt;/code&gt; are relative to the directory that file is in.</source>
          <target state="translated">&lt;code&gt;docker-compose -f FILE&lt;/code&gt; 을 사용하여 작성 파일을 지정한 경우 &lt;code&gt;env_file&lt;/code&gt; 의 경로는 파일이있는 디렉토리를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="4c624b96392eed6cb4a25b48781b927859504beb" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, open a terminal and ssh into the machine where you run your manager node. For example, the tutorial uses a machine named &lt;code&gt;manager1&lt;/code&gt;.</source>
          <target state="translated">아직 터미널을 열지 않은 경우 관리자 노드를 실행하는 시스템으로 터미널을 열고 ssh하십시오. 예를 들어, 학습서는 이름이 &lt;code&gt;manager1&lt;/code&gt; 인 기계를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="73230dff0e33a8a35566ac878466b9d94eaacf09" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, read through the &lt;a href=&quot;../../index&quot;&gt;swarm mode overview&lt;/a&gt; and &lt;a href=&quot;../../key-concepts/index&quot;&gt;key concepts&lt;/a&gt;.</source>
          <target state="translated">아직 &lt;a href=&quot;../../index&quot;&gt;swarm 모드 개요&lt;/a&gt; 및 &lt;a href=&quot;../../key-concepts/index&quot;&gt;주요 개념을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="1c35ab7ea35c78a523d674b84dfd6863dfd1809a" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, read through the &lt;a href=&quot;../key-concepts/index&quot;&gt;swarm mode key concepts&lt;/a&gt; and try the &lt;a href=&quot;../swarm-tutorial/index&quot;&gt;swarm mode tutorial&lt;/a&gt;.</source>
          <target state="translated">아직 &lt;a href=&quot;../key-concepts/index&quot;&gt;swarm 모드 핵심 개념을&lt;/a&gt; 읽고 &lt;a href=&quot;../swarm-tutorial/index&quot;&gt;swarm 모드 자습서를&lt;/a&gt; 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="44b3c07612b11f7dd33d17db452912ab881d8624" translate="yes" xml:space="preserve">
          <source>If you initialising a repository at the same time as adding a Delegation public key, then you will need to use the local Notary Canonical Root Key&amp;rsquo;s passphrase to create the repositories trust data. If the repository has already been initiated then you only need the repositories passphrase.</source>
          <target state="translated">위임 공개 키를 추가하는 것과 동시에 리포지토리를 초기화하는 경우 로컬 Notary Canonical Root Key의 암호를 사용하여 리포지토리 트러스트 데이터를 만들어야합니다. 리포지토리가 이미 시작된 경우 리포지토리 암호 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e63158a6521adef6c04e67e8f222344084eed92b" translate="yes" xml:space="preserve">
          <source>If you lose access to a worker node or need to shut it down because it has been compromised or is not behaving as expected, you can use the &lt;code&gt;--force&lt;/code&gt; option. This may cause transient errors or interruptions, depending on the type of task being run on the node.</source>
          <target state="translated">작업자 노드에 대한 액세스 권한이 손실되거나 노드가 손상되었거나 예상대로 작동하지 않아 종료해야하는 경우 &lt;code&gt;--force&lt;/code&gt; 옵션을 사용할 수 있습니다 . 노드에서 실행중인 작업 유형에 따라 일시적인 오류나 중단이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6a010aba3052de923dc1a0812631822b83748e" translate="yes" xml:space="preserve">
          <source>If you lose the quorum of managers, you cannot administer the swarm. If you have lost the quorum and you attempt to perform any management operation on the swarm, an error occurs:</source>
          <target state="translated">관리자 정족수를 잃으면 떼를 관리 할 수 ​​없습니다. 쿼럼을 잃어 버렸고 떼에서 관리 작업을 수행하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2c3618312f0fb948df52713298290856e3c5f9bf" translate="yes" xml:space="preserve">
          <source>If you make a configuration change to a service and run &lt;code&gt;docker-compose up&lt;/code&gt; to update it, the old container is removed and the new one joins the network under a different IP address but the same name. Running containers can look up that name and connect to the new address, but the old address stops working.</source>
          <target state="translated">서비스의 구성을 변경하고 &lt;code&gt;docker-compose up&lt;/code&gt; 을 실행 하여 업데이트하면 이전 컨테이너가 제거되고 새 컨테이너는 다른 IP 주소이지만 동일한 이름으로 네트워크에 연결됩니다. 실행중인 컨테이너는 해당 이름을 찾아 새 주소에 연결할 수 있지만 이전 주소는 작동을 멈 춥니 다.</target>
        </trans-unit>
        <trans-unit id="28ca5338e03516d6e85957114569eb9edfecb11f" translate="yes" xml:space="preserve">
          <source>If you make changes to the Gemfile or the Compose file to try out some different configurations, you need to rebuild. Some changes require only &lt;code&gt;docker-compose up --build&lt;/code&gt;, but a full rebuild requires a re-run of &lt;code&gt;docker-compose run web bundle install&lt;/code&gt; to sync changes in the &lt;code&gt;Gemfile.lock&lt;/code&gt; to the host, followed by &lt;code&gt;docker-compose up --build&lt;/code&gt;.</source>
          <target state="translated">다른 구성을 시도하기 위해 Gemfile 또는 Compose 파일을 변경하는 경우 다시 빌드해야합니다. 일부 변경 사항은 &lt;code&gt;docker-compose up --build&lt;/code&gt; 만 필요 하지만 전체 재구성에는 &lt;code&gt;Gemfile.lock&lt;/code&gt; 의 변경 사항을 호스트 에 동기화 &lt;code&gt;docker-compose run web bundle install&lt;/code&gt; 를 다시 실행 한 다음 &lt;code&gt;docker-compose up --build&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="511372394806f22d5d413a6d63dab33b33733ec8" translate="yes" xml:space="preserve">
          <source>If you make changes to your &lt;code&gt;docker-compose.yml&lt;/code&gt; configuration these changes are not reflected after running this command.</source>
          <target state="translated">당신이 당신을 변경 한 경우 &lt;code&gt;docker-compose.yml&lt;/code&gt; 구성을 이러한 변화는이 명령을 실행 한 후 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e1b2d3b6e0287ec3840f8f5d7b6ca6f47e3145b" translate="yes" xml:space="preserve">
          <source>If you monitor the DigitalOcean console while you run these commands, notice that it updates first to reflect that the Droplet was stopped, and then removed.</source>
          <target state="translated">이러한 명령을 실행하는 동안 DigitalOcean 콘솔을 모니터하면, Droplet이 중지 된 후 제거 된 것을 반영하여 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d3500e3f935d0491451fee9be69722afb640b71d" translate="yes" xml:space="preserve">
          <source>If you need Docker to be reachable through the network in a safe manner, you can enable TLS by specifying the &lt;code&gt;tlsverify&lt;/code&gt; flag and pointing Docker&amp;rsquo;s &lt;code&gt;tlscacert&lt;/code&gt; flag to a trusted CA certificate.</source>
          <target state="translated">네트워크를 통해 안전한 방식으로 Docker에 연결할 수 있어야하는 경우 &lt;code&gt;tlsverify&lt;/code&gt; 플래그 를 지정하고 Docker의 &lt;code&gt;tlscacert&lt;/code&gt; 플래그를 신뢰할 수있는 CA 인증서 로 지정하여 TLS를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee0da37c49a203be0b0c00544fccf8f34e920f37" translate="yes" xml:space="preserve">
          <source>If you need to access the Docker daemon remotely, you need to enable the &lt;code&gt;tcp&lt;/code&gt; Socket. Beware that the default setup provides un-encrypted and un-authenticated direct access to the Docker daemon - and should be secured either using the &lt;a href=&quot;../../../security/https/index&quot;&gt;built in HTTPS encrypted socket&lt;/a&gt;, or by putting a secure web proxy in front of it. You can listen on port &lt;code&gt;2375&lt;/code&gt; on all network interfaces with &lt;code&gt;-H tcp://0.0.0.0:2375&lt;/code&gt;, or on a particular network interface using its IP address: &lt;code&gt;-H tcp://192.168.59.103:2375&lt;/code&gt;. It is conventional to use port &lt;code&gt;2375&lt;/code&gt; for un-encrypted, and port &lt;code&gt;2376&lt;/code&gt; for encrypted communication with the daemon.</source>
          <target state="translated">Docker 데몬에 원격으로 액세스해야하는 경우 &lt;code&gt;tcp&lt;/code&gt; 소켓 을 활성화해야합니다 . 기본 설정은 Docker 데몬에 대한 암호화되지 않은 인증되지 않은 직접 액세스를 제공하며 &lt;a href=&quot;../../../security/https/index&quot;&gt;내장 HTTPS 암호화 소켓&lt;/a&gt; 을 사용하거나 보안 웹 프록시를 앞에 두어야 합니다. &lt;code&gt;-H tcp://0.0.0.0:2375&lt;/code&gt; 를 사용하는 모든 네트워크 인터페이스 또는 IP 주소를 사용하는 특정 네트워크 인터페이스 ( &lt;code&gt;-H tcp://192.168.59.103:2375&lt;/code&gt; ) 에서 포트 &lt;code&gt;2375&lt;/code&gt; 를 청취 할 수 있습니다 . 암호화되지 않은 경우 포트 &lt;code&gt;2375&lt;/code&gt; 를 사용 하고 데몬과의 암호화 된 통신에는 포트 &lt;code&gt;2376&lt;/code&gt; 을 사용하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="0952059872af3e935d42cc7f6dac3f46092b7fcf" translate="yes" xml:space="preserve">
          <source>If you need to check which profiles are loaded, you can use &lt;code&gt;aa-status&lt;/code&gt;. The output looks like:</source>
          <target state="translated">로드 된 프로파일을 확인해야하는 경우 &lt;code&gt;aa-status&lt;/code&gt; 를 사용할 수 있습니다 . 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4889f2d00afd68bf034d55d016d0f18c450fd83" translate="yes" xml:space="preserve">
          <source>If you need to manually generate a private key (either RSA or ECDSA) and a x509 certificate containing the public key, you can use local tools like openssl or cfssl along with a local or company-wide Certificate Authority.</source>
          <target state="translated">개인 키 (RSA 또는 ECDSA)와 공개 키를 포함하는 x509 인증서를 수동으로 생성해야하는 경우 로컬 또는 회사 차원의 인증 기관과 함께 openssl 또는 cfssl과 같은 로컬 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4f9f9f0f0838499c343537a3127971e2ad0133a" translate="yes" xml:space="preserve">
          <source>If you need to override this behaviour then you may do so by adding an &lt;code&gt;ARG&lt;/code&gt; statement in the Dockerfile as follows:</source>
          <target state="translated">이 동작을 재정의해야하는 경우 Dockerfile에 다음과 같이 &lt;code&gt;ARG&lt;/code&gt; 문 을 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="e46494b98ed899c05feff50f24f4bdea68dd67d3" translate="yes" xml:space="preserve">
          <source>If you need to remove a delegation, including the contributor keys that are attached to the &lt;code&gt;targets/releases&lt;/code&gt; role, you can use the &lt;code&gt;$ docker trust signer remove&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;targets/releases&lt;/code&gt; 역할에 첨부 된 컨트 리뷰 터 키를 포함하여 위임을 제거해야하는 경우 &lt;code&gt;$ docker trust signer remove&lt;/code&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a6f513d5288ddf988469918598793e3c364b229" translate="yes" xml:space="preserve">
          <source>If you need to write a starter script for a single executable, you can ensure that the final executable receives the Unix signals by using &lt;code&gt;exec&lt;/code&gt; and &lt;code&gt;gosu&lt;/code&gt; commands:</source>
          <target state="translated">단일 실행 파일에 대한 시작 스크립트를 작성해야하는 경우 &lt;code&gt;exec&lt;/code&gt; 및 &lt;code&gt;gosu&lt;/code&gt; 명령 을 사용하여 최종 실행 파일이 Unix 신호를 수신하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37902edb8f1e3a55f58f04264d82136215da07c2" translate="yes" xml:space="preserve">
          <source>If you omit the &lt;code&gt;--gateway&lt;/code&gt; flag the Engine selects one for you from inside a preferred pool. For &lt;code&gt;overlay&lt;/code&gt; networks and for network driver plugins that support it you can create multiple subnetworks. This example uses two &lt;code&gt;/25&lt;/code&gt; subnet mask to adhere to the current guidance of not having more than 256 IPs in a single overlay network. Each of the subnetworks has 126 usable addresses.</source>
          <target state="translated">&lt;code&gt;--gateway&lt;/code&gt; 플래그 를 생략하면 엔진이 선호하는 풀 내부에서 엔진을 선택합니다. 대한 &lt;code&gt;overlay&lt;/code&gt; 네트워크와 여러 개의 서브 네트워크를 만들 수 있습니다를 지원하는 네트워크 드라이버 플러그인합니다. 이 예에서는 두 개의 &lt;code&gt;/25&lt;/code&gt; 서브넷 마스크를 사용 하여 단일 오버레이 네트워크에 256 개 이상의 IP가없는 현재 지침을 준수합니다. 각 서브 네트워크에는 126 개의 사용 가능한 주소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3b78ea5d40070d80f18e7eaf1af0573a49695aa" translate="yes" xml:space="preserve">
          <source>If you omit the &lt;code&gt;file&lt;/code&gt; Compose looks for the service configuration in the current file. The &lt;code&gt;file&lt;/code&gt; value can be an absolute or relative path. If you specify a relative path, Compose treats it as relative to the location of the current file.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 을 생략하면 작성은 현재 파일에서 서비스 구성을 찾습니다. &lt;code&gt;file&lt;/code&gt; 값은 절대 또는 상대 경로 일 수있다. 상대 경로를 지정하면 Compose는 현재 파일의 위치를 ​​기준으로 경로를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="80d2e44c1f141d5064daaf1f38a829370fdbe955" translate="yes" xml:space="preserve">
          <source>If you pass an URL to a remote tarball, the URL itself is sent to the daemon:</source>
          <target state="translated">URL을 원격 타르볼로 전달하면 URL 자체가 데몬으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="3f9c6ae5da03730139ef24fe6677ab9ed991de3e" translate="yes" xml:space="preserve">
          <source>If you plan on creating an overlay network with encryption (&lt;code&gt;--opt encrypted&lt;/code&gt;), you also need to ensure &lt;strong&gt;ip protocol 50&lt;/strong&gt; (&lt;strong&gt;ESP&lt;/strong&gt;) traffic is allowed.</source>
          <target state="translated">암호화 ( &lt;code&gt;--opt encrypted&lt;/code&gt; )를 사용하여 오버레이 네트워크를 만들 계획 인 경우 &lt;strong&gt;ip 프로토콜 50&lt;/strong&gt; ( &lt;strong&gt;ESP&lt;/strong&gt; ) 트래픽이 허용 되는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="72b7ff831e71e67c0ef2cd48dded3a0b6f723cfe" translate="yes" xml:space="preserve">
          <source>If you request a field which is itself a structure containing other fields, by default you get a Go-style dump of the inner values. Docker adds a template function, &lt;code&gt;json&lt;/code&gt;, which can be applied to get results in JSON format.</source>
          <target state="translated">다른 필드를 포함하는 구조 인 필드를 요청하면 기본적으로 내부 값의 Go 스타일 덤프가 표시됩니다. Docker는 JSON 형식의 결과를 얻기 위해 적용 할 수 있는 템플릿 함수 &lt;code&gt;json&lt;/code&gt; 을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="04c8c8edebe5a6d5ad0d9b5e6df328d8f16759ea" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;docker-compose pull ServiceName&lt;/code&gt; in the same directory as the &lt;code&gt;docker-compose.yml&lt;/code&gt; file that defines the service, Docker pulls the associated image. For example, to call the &lt;code&gt;postgres&lt;/code&gt; image configured as the &lt;code&gt;db&lt;/code&gt; service in our example, you would run &lt;code&gt;docker-compose pull db&lt;/code&gt;.</source>
          <target state="translated">서비스를 정의하는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일 과 동일한 디렉토리에서 &lt;code&gt;docker-compose pull ServiceName&lt;/code&gt; 을 실행하면 Docker는 관련 이미지를 가져옵니다. 예를 들어,이 예 에서 &lt;code&gt;db&lt;/code&gt; 서비스 로 구성된 &lt;code&gt;postgres&lt;/code&gt; 이미지 를 호출하려면 &lt;code&gt;docker-compose pull db&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="0c1744d53e996e2ed00f0ad0c01a9c200f6d0c7a" translate="yes" xml:space="preserve">
          <source>If you run into problems running with this set, resolve the mismatch through upgrade and remove this setting to see if your problems resolve before notifying support.</source>
          <target state="translated">이 세트로 실행하는 데 문제가 발생하면 업그레이드를 통해 불일치를 해결하고이 설정을 제거하여 지원 부서에 알리기 전에 문제가 해결되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="eae463513aaad946db39f2c9729b2d814bc44de9" translate="yes" xml:space="preserve">
          <source>If you run this image with &lt;code&gt;docker run -it --rm -p 80:80 --name test apache&lt;/code&gt;, you can then examine the container&amp;rsquo;s processes with &lt;code&gt;docker exec&lt;/code&gt;, or &lt;code&gt;docker top&lt;/code&gt;, and then ask the script to stop Apache:</source>
          <target state="translated">&lt;code&gt;docker run -it --rm -p 80:80 --name test apache&lt;/code&gt; 로이 이미지를 실행하면 &lt;code&gt;docker exec&lt;/code&gt; 또는 &lt;code&gt;docker top&lt;/code&gt; 을 사용하여 컨테이너 프로세스를 검사 한 다음 스크립트에서 Apache 중지를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28cee36c61bf81b77eafafafc0dd47c3cb44ed47" translate="yes" xml:space="preserve">
          <source>If you set your keys in a credentials file, the command looks like this to create an instance called &lt;code&gt;aws-sandbox&lt;/code&gt;:</source>
          <target state="translated">자격 증명 파일에 키를 설정하면 명령은 다음과 같이 &lt;code&gt;aws-sandbox&lt;/code&gt; 라는 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="33f3e6ba427995546432a7456f18192fd3154cf4" translate="yes" xml:space="preserve">
          <source>If you shut down your local host, Docker machines stops running. You can check the status of machines by running &lt;code&gt;docker-machine ls&lt;/code&gt;.</source>
          <target state="translated">로컬 호스트를 종료하면 Docker 시스템이 실행을 중지합니다. &lt;code&gt;docker-machine ls&lt;/code&gt; 를 실행하여 시스템 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d3a58afc4d0f71b9cc36db8de8b193e432fbef4" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;--build-arg CONT_IMG_VER=&amp;lt;value&amp;gt;&lt;/code&gt; on the command line, in both cases, the specification on line 2 does not cause a cache miss; line 3 does cause a cache miss.&lt;code&gt;ARG CONT_IMG_VER&lt;/code&gt; causes the RUN line to be identified as the same as running &lt;code&gt;CONT_IMG_VER=&amp;lt;value&amp;gt;&lt;/code&gt; echo hello, so if the &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; changes, we get a cache miss.</source>
          <target state="translated">명령 행에 &lt;code&gt;--build-arg CONT_IMG_VER=&amp;lt;value&amp;gt;&lt;/code&gt; 를 지정하면 두 경우 모두 2 행의 스펙으로 인해 캐시 누락이 발생하지 않습니다. 3 행은 캐시 누락을 유발합니다. &lt;code&gt;ARG CONT_IMG_VER&lt;/code&gt; 는 RUN 라인을 &lt;code&gt;CONT_IMG_VER=&amp;lt;value&amp;gt;&lt;/code&gt; echo hello 실행과 동일하게 식별 하므로 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 가 변경되면 캐시 누락이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="887a493d0d4adc3a79b34b457f70f96427965e72" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;image&lt;/code&gt; as well as &lt;code&gt;build&lt;/code&gt;, then Compose names the built image with the &lt;code&gt;webapp&lt;/code&gt; and optional &lt;code&gt;tag&lt;/code&gt; specified in &lt;code&gt;image&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;build&lt;/code&gt; 뿐만 아니라 &lt;code&gt;image&lt;/code&gt; 를 지정하면 Compose 는 &lt;code&gt;image&lt;/code&gt; 에 지정된 &lt;code&gt;webapp&lt;/code&gt; 및 선택적 &lt;code&gt;tag&lt;/code&gt; 사용하여 빌드 된 이미지의 이름을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="341f514d36fea43ff37252e0fd12a051d52dcadb" translate="yes" xml:space="preserve">
          <source>If you specify a digest directly, that exact version of the image is always used when creating service tasks.</source>
          <target state="translated">다이제스트를 직접 지정하면 서비스 작업을 생성 할 때 이미지의 정확한 버전이 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3670337c1c9de65875fff0b01b7b13a573d236c8" translate="yes" xml:space="preserve">
          <source>If you specify a security group yourself using the &lt;code&gt;--amazonec2-security-group&lt;/code&gt; flag, the above ports are checked and opened and the security group is modified. If you want more ports to be opened such as application-specific ports, use the AWS console and modify the configuration manually.</source>
          <target state="translated">&lt;code&gt;--amazonec2-security-group&lt;/code&gt; 플래그를 사용하여 보안 그룹을 직접 지정 하면 위의 포트가 확인되고 열리고 보안 그룹이 수정됩니다. 애플리케이션 별 포트와 같은 추가 포트를 열려면 AWS 콘솔을 사용하여 구성을 수동으로 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5e45001f7a36598c1d53c1876f4f1b110474cb06" translate="yes" xml:space="preserve">
          <source>If you specify a tag, the manager (or the Docker client, if you use &lt;a href=&quot;#image_resolution_with_trust&quot;&gt;content trust&lt;/a&gt;) resolves that tag to a digest. When the request to create a container task is received on a worker node, the worker node only sees the digest, not the tag.</source>
          <target state="translated">태그를 지정하면 관리자 (또는 &lt;a href=&quot;#image_resolution_with_trust&quot;&gt;content trust&lt;/a&gt; 를 사용하는 경우 Docker 클라이언트 )가 해당 태그를 요약으로 해석합니다. 컨테이너 작업 생성 요청이 작업자 노드에서 수신되면 작업자 노드는 태그가 아닌 다이제스트 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="930b62bcf49a620028d7a59cbaf58ea4644319dc" translate="yes" xml:space="preserve">
          <source>If you specify a volume name already in use on the current driver, Docker assumes you want to re-use the existing volume and does not return an error.</source>
          <target state="translated">현재 드라이버에서 이미 사용중인 볼륨 이름을 지정하면 Docker는 기존 볼륨을 재사용한다고 가정하고 오류를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edd4c4b0fee15867f7087395bf8551465100eb52" translate="yes" xml:space="preserve">
          <source>If you specify both the &lt;code&gt;--blkio-weight&lt;/code&gt; and &lt;code&gt;--blkio-weight-device&lt;/code&gt;, Docker uses the &lt;code&gt;--blkio-weight&lt;/code&gt; as the default weight and uses &lt;code&gt;--blkio-weight-device&lt;/code&gt; to override this default with a new value on a specific device. The following example uses a default weight of &lt;code&gt;300&lt;/code&gt; and overrides this default on &lt;code&gt;/dev/sda&lt;/code&gt; setting that weight to &lt;code&gt;200&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--blkio-weight&lt;/code&gt; 및 &lt;code&gt;--blkio-weight-device&lt;/code&gt; 를 모두 지정하면 Docker는 &lt;code&gt;--blkio-weight&lt;/code&gt; 를 기본 가중치로 사용하고 &lt;code&gt;--blkio-weight-device&lt;/code&gt; 를 사용 하여이 기본값을 새 값으로 재정의합니다. 특정 장치. 다음 예제는 기본 가중치 &lt;code&gt;300&lt;/code&gt; 을 사용 하고이 기본값을 &lt;code&gt;/dev/sda&lt;/code&gt; 해당 가중치를 &lt;code&gt;200&lt;/code&gt; 으로 설정하는 / dev / sda .</target>
        </trans-unit>
        <trans-unit id="614a578114b6456d9f0a31d2f74942edf0974d59" translate="yes" xml:space="preserve">
          <source>If you specify multiple placement constraints, the service only deploys onto nodes where they are all met. The following example limits the service to run on all nodes where &lt;code&gt;region&lt;/code&gt; is set to &lt;code&gt;east&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; is not set to &lt;code&gt;devel&lt;/code&gt;:</source>
          <target state="translated">여러 배치 제약 조건을 지정하면 서비스는 모두 충족되는 노드에만 배포됩니다. 다음 예제 는 &lt;code&gt;region&lt;/code&gt; 이 &lt;code&gt;east&lt;/code&gt; 로 설정 되고 &lt;code&gt;type&lt;/code&gt; 이 있는 모든 노드에서 서비스가 실행되도록 제한합니다. 이 &lt;code&gt;devel&lt;/code&gt; 로 설정되지 않은 .</target>
        </trans-unit>
        <trans-unit id="5e051a2c523e346652be2d5b22f78a45fda86437" translate="yes" xml:space="preserve">
          <source>If you start a service configured with links, the &lt;code&gt;run&lt;/code&gt; command first checks to see if the linked service is running and starts the service if it is stopped. Once all the linked services are running, the &lt;code&gt;run&lt;/code&gt; executes the command you passed it. For example, you could run:</source>
          <target state="translated">링크로 구성된 서비스를 시작하면 &lt;code&gt;run&lt;/code&gt; 명령은 먼저 연결된 서비스가 실행 중인지 확인하고 중지 된 경우 서비스를 시작합니다. 연결된 모든 서비스가 실행되면 &lt;code&gt;run&lt;/code&gt; 은 전달한 명령을 실행합니다. 예를 들어 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548ff65d7de1b9416c2fab31f2dbee3f95246fe4" translate="yes" xml:space="preserve">
          <source>If you started Compose with &lt;code&gt;docker-compose up -d&lt;/code&gt;, stop your services once you&amp;rsquo;ve finished with them:</source>
          <target state="translated">작성을 시작한 경우 &lt;code&gt;docker-compose up -d&lt;/code&gt; 후에는 서비스를 완료 한 후 서비스를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="54aec9e0cdd1af1102ea068ee0d556ebc297c3b1" translate="yes" xml:space="preserve">
          <source>If you started a container &lt;em&gt;without&lt;/em&gt; kernel memory initialized:</source>
          <target state="translated">컨테이너를 시작한 경우 &lt;em&gt;&lt;/em&gt;커널 메모리를 초기화 &lt;em&gt;하지 않고&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="3a617207bbfb87e88a7e7dc4e126d89443b7f883" translate="yes" xml:space="preserve">
          <source>If you suspect a node has been compromised.</source>
          <target state="translated">노드가 손상되었다고 의심되는 경우</target>
        </trans-unit>
        <trans-unit id="4747b67dbe25187ec1f8c0d6004f265b17d1c307" translate="yes" xml:space="preserve">
          <source>If you then run &lt;code&gt;docker stop test&lt;/code&gt;, the container will not exit cleanly - the &lt;code&gt;stop&lt;/code&gt; command will be forced to send a &lt;code&gt;SIGKILL&lt;/code&gt; after the timeout:</source>
          <target state="translated">&lt;code&gt;docker stop test&lt;/code&gt; 를 실행 하면 컨테이너가 깨끗하게 종료되지 않습니다 . 시간 초과 후 &lt;code&gt;stop&lt;/code&gt; 명령이 &lt;code&gt;SIGKILL&lt;/code&gt; 을 보내도록 강제 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2be24690a58b8fe24bc3f68ad3567ddb397b5306" translate="yes" xml:space="preserve">
          <source>If you think of ways to make docker more secure, we welcome feature requests, pull requests, or comments on the Docker community forums.</source>
          <target state="translated">docker를 더 안전하게 만드는 방법을 생각하면 Docker 커뮤니티 포럼에 대한 기능 요청, 풀 요청 또는 의견을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="b7293b3c64e7be83a8f14e7372c74e792d623182" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;STDIN&lt;/code&gt; or specify a &lt;code&gt;URL&lt;/code&gt; pointing to a plain text file, the system places the contents into a file called &lt;code&gt;Dockerfile&lt;/code&gt;, and any &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;--file&lt;/code&gt; option is ignored. In this scenario, there is no context.</source>
          <target state="translated">&lt;code&gt;STDIN&lt;/code&gt; 을 사용 하거나 일반 텍스트 파일을 가리키는 &lt;code&gt;URL&lt;/code&gt; 을 지정 하면 시스템은 &lt;code&gt;Dockerfile&lt;/code&gt; 이라는 파일 과 &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;--file&lt;/code&gt; 에 내용을 배치합니다 옵션은 무시됩니다. 이 시나리오에는 컨텍스트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9eb7b35a504e0f0dd9a4abf4884c903eb6746ca7" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;docker-compose&lt;/code&gt; on a Windows machine, see &lt;a href=&quot;reference/envvars/index&quot;&gt;Environment variables&lt;/a&gt; and adjust the necessary environment variables for your specific needs.</source>
          <target state="translated">Windows 시스템에서 &lt;code&gt;docker-compose&lt;/code&gt; 를 사용하는 경우 &lt;a href=&quot;reference/envvars/index&quot;&gt;환경 변수를&lt;/a&gt; 참조하십시오. 및 사용자의 특정 요구에 필요한 환경 변수를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="75e617e850a3096c417d8e61aa4696d14a5295e5" translate="yes" xml:space="preserve">
          <source>If you use an earlier version and you want to achieve an even balance of load across workers and don&amp;rsquo;t mind disrupting running tasks, you can force your swarm to re-balance by temporarily scaling the service upward. Use &lt;code&gt;docker service inspect --pretty &amp;lt;servicename&amp;gt;&lt;/code&gt; to see the configured scale of a service. When you use &lt;code&gt;docker service scale&lt;/code&gt;, the nodes with the lowest number of tasks are targeted to receive the new workloads. There may be multiple under-loaded nodes in your swarm. You may need to scale the service up by modest increments a few times to achieve the balance you want across all the nodes.</source>
          <target state="translated">이전 버전을 사용하고 작업자 전체에 고른로드 밸런싱을 달성하고 실행중인 작업을 방해하지 않으려는 경우 서비스를 일시적으로 확장하여 웜의 균형을 재조정 할 수 있습니다. 사용 &lt;code&gt;docker service inspect --pretty &amp;lt;servicename&amp;gt;&lt;/code&gt; 서비스의 구성 비율을 볼 수 있습니다. &lt;code&gt;docker service scale&lt;/code&gt; 을 사용 하면 가장 적은 수의 작업을 가진 노드가 새 작업 부하를 수신하도록 지정됩니다. swarm에 여러 개의 언더로드 노드가있을 수 있습니다. 모든 노드에서 원하는 균형을 달성하기 위해 서비스를 약간 씩 증가 시켜서 확장해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e56ea2ca6b9bf3849cbf0d1b9b8e9b44642aaf" translate="yes" xml:space="preserve">
          <source>If you use auto-lock, &lt;a href=&quot;../swarm_manager_locking/index#rotate-the-unlock-key&quot;&gt;rotate the unlock key&lt;/a&gt;.</source>
          <target state="translated">자동 잠금을 사용하는 경우 &lt;a href=&quot;../swarm_manager_locking/index#rotate-the-unlock-key&quot;&gt;잠금 해제 키를 돌리십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0264413744ae9e53ed10203da5499c89a9b6294c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;--ipc=host&lt;/code&gt; option these sysctls will not be allowed.</source>
          <target state="translated">&lt;code&gt;--ipc=host&lt;/code&gt; 옵션 을 사용하면 이러한 sysctls 가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="997ccd099af214abbdd622b7c0f39a22547f246d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;--network=host&lt;/code&gt; option using these sysctls will not be allowed.</source>
          <target state="translated">&lt;code&gt;--network=host&lt;/code&gt; 를 사용하는 경우 이 sysctls을 사용하는 옵션은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70622e333eb0d1040a0a670c89eb21690b028401" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-f&lt;/code&gt; flag and specify the image&amp;rsquo;s short or long ID, then this command untags and removes all images that match the specified ID.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;-f&lt;/code&gt; 플래그를 이미지의 짧거나 긴 ID를 지정,이 명령 untags와는 지정된 ID와 일치하는 모든 이미지를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="cd29cfd1504c5f60a8482a78dd665d9e2d2d9aef" translate="yes" xml:space="preserve">
          <source>If you use the &lt;em&gt;shell&lt;/em&gt; form of the &lt;code&gt;CMD&lt;/code&gt;, then the &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; will execute in &lt;code&gt;/bin/sh -c&lt;/code&gt;:</source>
          <target state="translated">당신이 사용하는 경우 &lt;em&gt;쉘&lt;/em&gt; 의 형태 &lt;code&gt;CMD&lt;/code&gt; 를 , 다음 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 에서 실행됩니다 &lt;code&gt;/bin/sh -c&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="777d76024619b3f7dd68426f5da7d500e35414fa" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;code&gt;--amazonec2-private-address-only&lt;/code&gt;, ensure that you can access the new instance from within the internal network of the VPC, such as a corporate VPN to the VPC, a VPN instance inside the VPC, or using &lt;code&gt;docker-machine&lt;/code&gt; from an instance within your VPC.</source>
          <target state="translated">&lt;code&gt;--amazonec2-private-address-only&lt;/code&gt; 플래그를 사용하는 경우 회사 VPN과 같은 VPC의 내부 네트워크, VPC 내부의 VPN 인스턴스 또는 다음을 사용하여 새 인스턴스에 액세스 할 수 있어야합니다. VPC 내의 인스턴스에서 &lt;code&gt;docker-machine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="013d73bf841a122d76ef95c3d526a1f09b09728b" translate="yes" xml:space="preserve">
          <source>If you used the Quickstart Terminal to launch your first machine and set your terminal environment to point to it, a default machine was automatically created. If so, you can still follow along with these steps, but create another machine and name it something other than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">빠른 시작 터미널을 사용하여 첫 번째 시스템을 시작하고 터미널 환경이이를 가리 키도록 설정 한 경우 기본 시스템이 자동으로 작성되었습니다. 그렇다면 여전히이 단계를 수행 할 수 있지만 다른 시스템을 작성하고 이름을 &lt;code&gt;default&lt;/code&gt; 이외의 이름으로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9ebbfba82709e03e0f17a935545ed76e0bd05e6" translate="yes" xml:space="preserve">
          <source>If you want a subset of information formatted as JSON, you can use the &lt;code&gt;json&lt;/code&gt; function in the template.</source>
          <target state="translated">JSON으로 형식화 된 정보의 서브 세트를 원하는 경우 템플리트에서 &lt;code&gt;json&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70ef8feb9b5d6ec959a2197807358b1514287cd4" translate="yes" xml:space="preserve">
          <source>If you want a tighter security policy on the processes within a container, you can specify an alternate type for the container. You could run a container that is only allowed to listen on Apache ports by executing the following command:</source>
          <target state="translated">컨테이너 내의 프로세스에 대한 보안 정책을 강화하려는 경우 컨테이너의 대체 유형을 지정할 수 있습니다. 다음 명령을 실행하여 Apache 포트에서만 청취 할 수있는 컨테이너를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13b4928118fe5b9ef966a4cd387a9bc9d55dfc24" translate="yes" xml:space="preserve">
          <source>If you want more detailed information about a container&amp;rsquo;s resource usage, use the &lt;code&gt;/containers/(id)/stats&lt;/code&gt; API endpoint.</source>
          <target state="translated">컨테이너의 자원 사용량에 대한 자세한 정보를 원하면 &lt;code&gt;/containers/(id)/stats&lt;/code&gt; API 엔드 포인트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1275908d2bcf4a67b48de95532a331ea43b5de3c" translate="yes" xml:space="preserve">
          <source>If you want only Docker Machine, you can install the Machine binaries directly by following the instructions in the next section. You can find the latest versions of the binaries on the &lt;a href=&quot;https://github.com/docker/machine/releases/&quot;&gt;docker/machine release page&lt;/a&gt; on GitHub.</source>
          <target state="translated">Docker Machine 만 원하는 경우 다음 섹션의 지시 사항에 따라 Machine 바이너리를 직접 설치할 수 있습니다. GitHub 의 &lt;a href=&quot;https://github.com/docker/machine/releases/&quot;&gt;docker / machine release 페이지&lt;/a&gt; 에서 최신 바이너리 버전을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e40792fd5ab1489918de4d5d202a0a7b0470269e" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;run your&lt;/strong&gt;&lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;&lt;strong&gt;without a shell&lt;/strong&gt; then you must express the command as a JSON array and give the full path to the executable. &lt;strong&gt;This array form is the preferred format of &lt;code&gt;CMD&lt;/code&gt;.&lt;/strong&gt; Any additional parameters must be individually expressed as strings in the array:</source>
          <target state="translated">&lt;strong&gt;쉘없이 &lt;/strong&gt; &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 를 &lt;strong&gt;실행&lt;/strong&gt; 하려면 명령을 JSON 배열로 표시하고 실행 파일의 전체 경로를 제공해야합니다. &lt;strong&gt;이 배열 형식은 선호하는 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;CMD&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 형식입니다 &lt;/strong&gt;&lt;strong&gt;. &lt;/strong&gt;추가 매개 변수는 배열에서 개별적으로 문자열로 표시되어야합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fb90e9cb29a23cc953dc488821a5bdbad00a6aa" translate="yes" xml:space="preserve">
          <source>If you want to add a container to a network after the container is already running, use the &lt;code&gt;docker network connect&lt;/code&gt; subcommand.</source>
          <target state="translated">컨테이너가 이미 실행 된 후 컨테이너를 네트워크에 추가하려면 &lt;code&gt;docker network connect&lt;/code&gt; 하위 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3331f3c98821ffa4887a7f53d6dc95bc2286283a" translate="yes" xml:space="preserve">
          <source>If you want to add a running container to a network use the &lt;code&gt;docker network connect&lt;/code&gt; subcommand.</source>
          <target state="translated">실행중인 컨테이너를 네트워크에 추가하려면 &lt;code&gt;docker network connect&lt;/code&gt; 하위 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c566b0f2732a4d6b4d596fa74fb317a05efaa1f7" translate="yes" xml:space="preserve">
          <source>If you want to force Compose to stop and recreate all containers, use the &lt;code&gt;--force-recreate&lt;/code&gt; flag.</source>
          <target state="translated">Compose가 모든 컨테이너를 중지하고 다시 작성하도록하려면 &lt;code&gt;--force-recreate&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ac9a1ff015b17bde34c342af0fdee4edd4f9254" translate="yes" xml:space="preserve">
          <source>If you want to limit access to a specific device or devices you can use the &lt;code&gt;--device&lt;/code&gt; flag. It allows you to specify one or more devices that will be accessible within the container.</source>
          <target state="translated">특정 장치에 대한 액세스를 제한하려면 &lt;code&gt;--device&lt;/code&gt; 플래그를 사용할 수 있습니다 . 컨테이너 내에서 액세스 할 수있는 하나 이상의 장치를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3d3fdf24df6634b0cf82de870cb32fc4946531" translate="yes" xml:space="preserve">
          <source>If you want to login to a self-hosted registry you can specify this by adding the server name.</source>
          <target state="translated">자체 호스팅 레지스트리에 로그인하려는 경우 서버 이름을 추가하여이를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e7cd13feebe3d871e5a68aedb6b04e20260dd8b" translate="yes" xml:space="preserve">
          <source>If you want to prevent your container processes from gaining additional privileges, you can execute the following command:</source>
          <target state="translated">컨테이너 프로세스가 추가 권한을 얻지 못하게하려면 다음 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91f7098f0b180451930bcd4f5883fc9b6433f05e" translate="yes" xml:space="preserve">
          <source>If you want to remove the container after running while overriding the container&amp;rsquo;s restart policy, use the &lt;code&gt;--rm&lt;/code&gt; flag:</source>
          <target state="translated">컨테이너의 재시작 정책을 재정의하는 동안 실행 후 컨테이너를 제거하려면 &lt;code&gt;--rm&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4f2d3f2b064e6d64494989c37653ef8f8e6ea1d" translate="yes" xml:space="preserve">
          <source>If you want to run your services in the background, you can pass the &lt;code&gt;-d&lt;/code&gt; flag (for &amp;ldquo;detached&amp;rdquo; mode) to &lt;code&gt;docker-compose up&lt;/code&gt; and use &lt;code&gt;docker-compose ps&lt;/code&gt; to see what is currently running:</source>
          <target state="translated">백그라운드에서 서비스를 실행하려면 &lt;code&gt;-d&lt;/code&gt; 플래그 (&amp;ldquo;분리&amp;rdquo;모드)를 &lt;code&gt;docker-compose up&lt;/code&gt; 으로 전달 하고 &lt;code&gt;docker-compose ps&lt;/code&gt; 를 사용 하여 현재 실행중인 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0686c0bfe4c28fe49ac3e946e0f175adf773873d" translate="yes" xml:space="preserve">
          <source>If you want to secure your Docker client connections by default, you can move the files to the &lt;code&gt;.docker&lt;/code&gt; directory in your home directory --- and set the &lt;code&gt;DOCKER_HOST&lt;/code&gt; and &lt;code&gt;DOCKER_TLS_VERIFY&lt;/code&gt; variables as well (instead of passing &lt;code&gt;-H=tcp://$HOST:2376&lt;/code&gt; and &lt;code&gt;--tlsverify&lt;/code&gt; on every call).</source>
          <target state="translated">Docker 클라이언트 연결을 기본적으로 보호하려면 파일을 홈 디렉토리 의 &lt;code&gt;.docker&lt;/code&gt; 디렉토리 로 이동 하고 &lt;code&gt;DOCKER_TLS_VERIFY&lt;/code&gt; &lt;code&gt;-H=tcp://$HOST:2376&lt;/code&gt; 를 전달하는 대신 &lt;code&gt;DOCKER_HOST&lt;/code&gt; 및 DOCKER_TLS_VERIFY 변수를 설정할 수도 있습니다 HOST : 2376 및 &lt;code&gt;--tlsverify&lt;/code&gt; 는 모든 통화에서).</target>
        </trans-unit>
        <trans-unit id="99795c4741a4661849c9d9f7fb1d8920ca13c9f8" translate="yes" xml:space="preserve">
          <source>If you want to see the containers running on other nodes, ssh into those nodes and run the &lt;code&gt;docker ps&lt;/code&gt; command.</source>
          <target state="translated">다른 노드에서 실행중인 컨테이너를 보려면 해당 노드로 ssh하고 &lt;code&gt;docker ps&lt;/code&gt; 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="12c4b708603275450b96c270f02bb26e17619c5a" translate="yes" xml:space="preserve">
          <source>If you want to start over, you can run &lt;code&gt;docker swarm leave&lt;/code&gt; from each node.</source>
          <target state="translated">다시 시작하려면 각 노드에서 &lt;code&gt;docker swarm leave&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5deade7031a312eca3e9e800aeae9a04688963a" translate="yes" xml:space="preserve">
          <source>If you want to try the running all of these examples again or just want to clean up after running through them, use these commands to remove the WordPress service, the MySQL container, the &lt;code&gt;mydata&lt;/code&gt; and &lt;code&gt;wpdata&lt;/code&gt; volumes, and the Docker secrets.</source>
          <target state="translated">이 예제를 모두 다시 실행하거나 예제를 실행 한 후 정리하려면이 명령을 사용하여 WordPress 서비스, MySQL 컨테이너, &lt;code&gt;mydata&lt;/code&gt; 및 &lt;code&gt;wpdata&lt;/code&gt; 볼륨 및 Docker 비밀을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9e6549a64f297be7133c3e8c6911217713e4fe78" translate="yes" xml:space="preserve">
          <source>If you want to use Compose to scale the service in question to multiple nodes, build the image, push it to a registry such as Docker Hub, and reference it from &lt;code&gt;docker-compose.yml&lt;/code&gt;:</source>
          <target state="translated">작성을 사용하여 문제의 서비스를 여러 노드로 확장하려면 이미지를 빌드하고 Docker Hub와 같은 레지스트리로 푸시 한 다음 &lt;code&gt;docker-compose.yml&lt;/code&gt; 에서 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0dbc37ce1e54d924397277626efa3a3e1ee8ce5" translate="yes" xml:space="preserve">
          <source>If you want to use Notary in production</source>
          <target state="translated">프로덕션에서 Notary를 사용하려는 경우</target>
        </trans-unit>
        <trans-unit id="b6c743b521003fe6450220c17814e043461401ca" translate="yes" xml:space="preserve">
          <source>If you want to use a particular network on a common build, use [network] as mentioned in the second yaml file example.</source>
          <target state="translated">공통 빌드에서 특정 네트워크를 사용하려면 두 번째 yaml 파일 예제에서 언급 한대로 [network]를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18b0d4859119a15b2634e361b32880b6fe4b5774" translate="yes" xml:space="preserve">
          <source>If you want to use the &lt;code&gt;dockremap&lt;/code&gt; user automatically created by Docker, check for the &lt;code&gt;dockremap&lt;/code&gt; entry in these files &lt;strong&gt;after&lt;/strong&gt; configuring and restarting Docker.</source>
          <target state="translated">Docker가 자동으로 작성한 &lt;code&gt;dockremap&lt;/code&gt; 사용자 를 사용하려면 Docker &lt;strong&gt;를&lt;/strong&gt; 구성하고 다시 시작한 &lt;strong&gt;후&lt;/strong&gt; 이러한 파일에서 &lt;code&gt;dockremap&lt;/code&gt; 항목을 확인하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="851692af5ab779dce736b1e35716b7b87c43cd77" translate="yes" xml:space="preserve">
          <source>If you want your containers to join a pre-existing network, use the &lt;a href=&quot;../compose-file/compose-file-v2/index#network-configuration-reference&quot;&gt;&lt;code&gt;external&lt;/code&gt; option&lt;/a&gt;:</source>
          <target state="translated">컨테이너가 기존 네트워크에 연결되도록하려면 &lt;a href=&quot;../compose-file/compose-file-v2/index#network-configuration-reference&quot;&gt; &lt;code&gt;external&lt;/code&gt; 옵션을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eab86fabcc4fef062db463f637d704d679fe3936" translate="yes" xml:space="preserve">
          <source>If you want your data to persist, use a named volume and a volume driver that is multi-host aware, so that the data is accessible from any node. Or, set constraints on the service so that its tasks are deployed on a node that has the volume present.</source>
          <target state="translated">데이터를 유지하려면 이름이 지정된 볼륨과 멀티 호스트를 인식하는 볼륨 드라이버를 사용하여 모든 노드에서 데이터에 액세스 할 수 있도록하십시오. 또는 서비스가 볼륨이있는 노드에 배치되도록 서비스에 대한 제한 조건을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7fa55b3aa9ac2103a3831eae6e8432beb1b778c4" translate="yes" xml:space="preserve">
          <source>If you want, you can configure an override the Docker key sequence for detach. This is useful if the Docker default sequence conflicts with key sequence you use for other applications. There are two ways to define your own detach key sequence, as a per-container override or as a configuration property on your entire configuration.</source>
          <target state="translated">원하는 경우 분리를 위해 Docker 키 시퀀스 대체를 구성 할 수 있습니다. Docker 기본 시퀀스가 ​​다른 응용 프로그램에 사용하는 키 시퀀스와 충돌하는 경우에 유용합니다. 컨테이너 별 재정의 또는 전체 구성의 구성 속성으로 고유 한 분리 키 시퀀스를 정의하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcc920d2c2a3e4bebc47347df902beccde2a488b" translate="yes" xml:space="preserve">
          <source>If you were using Boot2Docker previously, you have a pre-existing Docker &lt;code&gt;boot2docker-vm&lt;/code&gt; VM on your local system. To allow Docker Machine to manage this older VM, you must migrate it.</source>
          <target state="translated">이전에 Boot2Docker를 사용하고 있었다면 로컬 시스템에 기존 Docker &lt;code&gt;boot2docker-vm&lt;/code&gt; VM이 있습니다. Docker Machine이이 이전 VM을 관리 할 수있게하려면 마이그레이션해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3dfd411d61369127faae4769ebf726d5f0ceca7" translate="yes" xml:space="preserve">
          <source>If you wish to guarantee that no new nodes can join the swarm.</source>
          <target state="translated">새로운 노드가 swarm에 가입 할 수 없도록 보장하려면.</target>
        </trans-unit>
        <trans-unit id="c3a1e979301a98137ace82569a8c1995b08bc57b" translate="yes" xml:space="preserve">
          <source>If you wish to keep the intermediate containers after the build is complete, you must use &lt;code&gt;--rm=false&lt;/code&gt;. This does not affect the build cache.</source>
          <target state="translated">빌드가 완료된 후 중간 컨테이너를 유지하려면 &lt;code&gt;--rm=false&lt;/code&gt; 를 사용해야합니다 . 빌드 캐시에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c8e6d2e43d4ec934e9a71f8979894e15d9e31b3" translate="yes" xml:space="preserve">
          <source>If you work primarily on an older Mac or Windows laptop or desktop that doesn&amp;rsquo;t meet the requirements for the new &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; apps, then you need Docker Machine to run Docker Engine locally. Installing Docker Machine on a Mac or Windows box with the &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt; installer provisions a local virtual machine with Docker Engine, gives you the ability to connect it, and run &lt;code&gt;docker&lt;/code&gt; commands.</source>
          <target state="translated">새에 대한 요구 사항에 부합하지 않는 구형 맥 또는 Windows 노트북이나 데스크탑에서 주로 작업하는 경우 &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Mac 용 도커 데스크톱&lt;/a&gt; 및 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;윈도우에 대한 도커 데스크톱&lt;/a&gt; 응용 프로그램을, 당신은 로컬 도커 엔진을 실행하는 도커 기계가 필요합니다. &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt; 설치 프로그램 을 사용하여 Mac 또는 Windows 상자에 Docker Machine을 설치하면 Docker Engine을 사용하여 로컬 가상 머신을 프로비저닝하고이를 연결하고 &lt;code&gt;docker&lt;/code&gt; 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d61d3c4fa6722d423ec51c89dd750d869f3766" translate="yes" xml:space="preserve">
          <source>If you would like your container to run the same executable every time, then you should consider using &lt;code&gt;ENTRYPOINT&lt;/code&gt; in combination with &lt;code&gt;CMD&lt;/code&gt;. See &lt;a href=&quot;#entrypoint&quot;&gt;&lt;em&gt;ENTRYPOINT&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">컨테이너가 매번 동일한 실행 파일을 실행하도록하려면 &lt;code&gt;CMD&lt;/code&gt; 와 함께 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 사용을 고려해야 합니다. &lt;a href=&quot;#entrypoint&quot;&gt;&lt;em&gt;ENTRYPOINT를&lt;/em&gt;&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="919a1468547e5d70eacc73229fb5d38975122b53" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in trying out a pre-release build, you can download release candidates from the &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;Compose repository release page on GitHub&lt;/a&gt;. Follow the instructions from the link, which involves running the &lt;code&gt;curl&lt;/code&gt; command in your terminal to download the binaries.</source>
          <target state="translated">시험판 빌드를 시험해보고 싶다면 &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;GitHub&lt;/a&gt; 의 Compose repository release 페이지 에서 릴리스 후보를 다운로드 할 수 있습니다 . 터미널에서 &lt;code&gt;curl&lt;/code&gt; 명령을 실행 하여 바이너리를 다운로드하는 링크의 지침을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="1de9f71035aa6b3a6d873d465e98b447596b90d1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not sure how to configure these options, it is best to not specify configuration at all. Docker Machine chooses sensible defaults for you and you don&amp;rsquo;t need to worry about it.</source>
          <target state="translated">이러한 옵션을 구성하는 방법을 잘 모를 경우 구성을 전혀 지정하지 않는 것이 가장 좋습니다. Docker Machine은 합리적인 기본값을 선택하므로 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba85e897e59a86ff010c2d5eee9824d8a85c2fdf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Mac or Windows, download the &amp;ldquo;Beta channel&amp;rdquo; version of &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; or &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; to install it. If you&amp;rsquo;re on Linux, follow the instructions in the &lt;a href=&quot;https://github.com/docker/cli/blob/master/experimental/README/&quot;&gt;experimental build README&lt;/a&gt;.</source>
          <target state="translated">Mac 또는 Windows를 사용하는 경우 Mac &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;용 &lt;/a&gt;&lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop&lt;/a&gt; 또는 Windows 용 Docker Desktop 의 &quot;베타 채널&quot;버전을 다운로드하여 설치하십시오. Linux를 사용하는 경우 &lt;a href=&quot;https://github.com/docker/cli/blob/master/experimental/README/&quot;&gt;실험 빌드 README&lt;/a&gt; 의 지시 사항을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="af3af77f760852207a6a858ff4f4128dcf670f5a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re upgrading from Compose 1.2 or earlier, remove or migrate your existing containers after upgrading Compose. This is because, as of version 1.3, Compose uses Docker labels to keep track of containers, and your containers need to be recreated to add the labels.</source>
          <target state="translated">Compose 1.2 이하에서 업그레이드하는 경우 Compose를 업그레이드 한 후 기존 컨테이너를 제거하거나 마이그레이션하십시오. 버전 1.3부터 ​​Compose는 Docker 레이블을 사용하여 컨테이너를 추적하고 레이블을 추가하려면 컨테이너를 다시 작성해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dbce20f8109461e5d572204e84cc2b1ba6e268d6" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;net: &quot;container:[container name/id]&quot;&lt;/code&gt;, the value does not need to change.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;net: &quot;container:[container name/id]&quot;&lt;/code&gt; , 값은 변경이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c4daaf98bd39ce011096ded8af74fa7bc193821" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;net: &quot;container:[service name]&quot;&lt;/code&gt;, you must now use &lt;code&gt;network_mode: &quot;service:[service name]&quot;&lt;/code&gt; instead.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;net: &quot;container:[service name]&quot;&lt;/code&gt; , 당신은 지금 사용해야합니다 &lt;code&gt;network_mode: &quot;service:[service name]&quot;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="43285ecd2a59b909da1eba3a10034e2fbcce52a8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Docker Machine on a Mac or Windows, use &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; to get the IP address of your Docker host. Then, open &lt;code&gt;http://MACHINE_VM_IP:5000&lt;/code&gt; in a browser.</source>
          <target state="translated">Mac 또는 Windows에서 Docker Machine을 사용하는 경우 &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; 을 사용 하여 Docker 호스트의 IP 주소를 가져 오십시오. 그런 다음 브라우저에서 &lt;code&gt;http://MACHINE_VM_IP:5000&lt;/code&gt; 을여십시오 .</target>
        </trans-unit>
        <trans-unit id="5f8ee6625cf8ed3846405d3a5331b054555b441c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Docker natively on Linux, Docker Desktop for Mac, or Docker Desktop for Windows, then the web app should now be listening on port 5000 on your Docker daemon host. Point your web browser to http://localhost:5000 to find the &lt;code&gt;Hello World&lt;/code&gt; message. If this doesn&amp;rsquo;t resolve, you can also try http://127.0.0.1:5000.</source>
          <target state="translated">Linux, Mac 용 Docker Desktop 또는 Windows 용 Docker Desktop에서 Docker를 기본적으로 사용하는 경우 이제 웹 앱이 Docker 데몬 호스트의 포트 5000에서 수신 대기해야합니다. &lt;code&gt;Hello World&lt;/code&gt; 메시지 를 찾으려면 웹 브라우저를 http : // localhost : 5000으로 지정하십시오 . 그래도 해결되지 않으면 http://127.0.0.1:5000을 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="0ede5175ab39a5c7ce4a42b5d15e2d9359188a81" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the &lt;a href=&quot;compose-versioning/index#version-2&quot;&gt;version 2 or above file format&lt;/a&gt;, the externally-created containers must be connected to at least one of the same networks as the service that is linking to them. &lt;a href=&quot;compose-file-v2/index#links&quot;&gt;Links&lt;/a&gt; are a legacy option. We recommend using &lt;a href=&quot;#networks&quot;&gt;networks&lt;/a&gt; instead.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;compose-versioning/index#version-2&quot;&gt;버전 2 위의 파일 형식을&lt;/a&gt; , 외부에서 만든 용기는 그 (것)들에 연결하고 서비스와 같은 네트워크 중 적어도 하나에 연결되어 있어야합니다. &lt;a href=&quot;compose-file-v2/index#links&quot;&gt;링크&lt;/a&gt; 는 레거시 옵션입니다. 대신 &lt;a href=&quot;#networks&quot;&gt;네트워크&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="80d5a17957dd9f04233a5c250192b2fd1ba876f1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using version 1 along with &lt;code&gt;links&lt;/code&gt;, your app works, but Swarm schedules all containers on one host, because links between containers do not work across hosts with the old networking system.</source>
          <target state="translated">&lt;code&gt;links&lt;/code&gt; 와 함께 버전 1을 사용하는 경우 앱이 작동하지만 Swarm은 이전 네트워킹 시스템이있는 호스트에서 컨테이너 간 링크가 작동하지 않기 때문에 하나의 호스트에서 모든 컨테이너를 예약합니다.</target>
        </trans-unit>
        <trans-unit id="c031e9ba1e317901c6af28db65fb30143ae99b9a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using version 2, your app should work with no changes:</source>
          <target state="translated">버전 2를 사용하는 경우 앱이 변경없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="accee6497f208c5dc8cc9601dfbf48fe08a59bef" translate="yes" xml:space="preserve">
          <source>If your certificates have expired, you&amp;rsquo;ll need to regenerate the client certs as well using the &lt;code&gt;--client-certs&lt;/code&gt; option:</source>
          <target state="translated">인증서가 만료 된 경우 &lt;code&gt;--client-certs&lt;/code&gt; 옵션을 사용하여 클라이언트 인증서를 다시 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="115365c9fe93dca9d6875524fe9a71b13dffeef5" translate="yes" xml:space="preserve">
          <source>If your configuration is split between multiple Compose files, e.g. a base configuration and environment-specific overrides, you can provide multiple &lt;code&gt;--compose-file&lt;/code&gt; flags.</source>
          <target state="translated">구성이 여러 Compose 파일 (예 : 기본 구성 및 환경 별 재정의)로 분할 된 경우 여러 &lt;code&gt;--compose-file&lt;/code&gt; 플래그를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96ec1ed8dcbcadaa8e8703d203d779700bff0e02" translate="yes" xml:space="preserve">
          <source>If your distribution comes with security model templates for Docker containers, you can use them out of the box. For instance, we ship a template that works with AppArmor and Red Hat comes with SELinux policies for Docker. These templates provide an extra safety net (even though it overlaps greatly with capabilities).</source>
          <target state="translated">배포판에 Docker 컨테이너 용 보안 모델 템플릿이 제공되는 경우 즉시 사용할 수 있습니다. 예를 들어, AppArmor와 함께 작동하는 템플릿을 제공하고 Red Hat은 Docker에 대한 SELinux 정책을 제공합니다. 이러한 템플릿은 기능과 크게 겹치더라도 추가적인 안전망을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aa822e7d5535d48d2169291150c8f0e3165fd360" translate="yes" xml:space="preserve">
          <source>If your engine is unable to communicate to the registry, we can enable DCT to trust cached signature data. This is done through the &lt;code&gt;allow-expired-cached-trust-data&lt;/code&gt; variable.</source>
          <target state="translated">엔진이 레지스트리와 통신 할 수없는 경우 DCT가 캐시 된 서명 데이터를 신뢰하도록 할 수 있습니다. 이는 &lt;code&gt;allow-expired-cached-trust-data&lt;/code&gt; 변수를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c78340b12209a3bf2e4298771efc2a4a59f1096" translate="yes" xml:space="preserve">
          <source>If your image is available on a private registry which requires login, use the &lt;code&gt;--with-registry-auth&lt;/code&gt; flag with &lt;code&gt;docker service create&lt;/code&gt;, after logging in. If your image is stored on &lt;code&gt;registry.example.com&lt;/code&gt;, which is a private registry, use a command like the following:</source>
          <target state="translated">로그인이 필요한 개인 레지스트리에서 이미지를 사용할 수있는 경우 로그인 후 &lt;code&gt;docker service create&lt;/code&gt; 와 함께 &lt;code&gt;--with-registry-auth&lt;/code&gt; 플래그를 사용 하십시오. 이미지가 개인 레지스트리 인 &lt;code&gt;registry.example.com&lt;/code&gt; 에 저장된 경우 , 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9d281bdfd7e129dcc755be1f72a3743ece6a5415" translate="yes" xml:space="preserve">
          <source>If your operating system does not enable certain capabilities, you may see warnings such as one of the following, when you run &lt;code&gt;docker info&lt;/code&gt;:</source>
          <target state="translated">운영 체제에서 특정 기능을 사용하지 않으면 &lt;code&gt;docker info&lt;/code&gt; 를 실행할 때 다음 중 하나와 같은 경고가 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="caee0b8b9ff6969622d524645376851d425c1409" translate="yes" xml:space="preserve">
          <source>If your project is outside of the &lt;code&gt;Users&lt;/code&gt; directory (&lt;code&gt;cd ~&lt;/code&gt;), then you need to share the drive or location of the Dockerfile and volume you are using. If you get runtime errors indicating an application file is not found, a volume mount is denied, or a service cannot start, try enabling file or drive sharing. Volume mounting requires shared drives for projects that live outside of &lt;code&gt;C:\Users&lt;/code&gt; (Windows) or &lt;code&gt;/Users&lt;/code&gt; (Mac), and is required for &lt;em&gt;any&lt;/em&gt; project on Docker Desktop for Windows that uses &lt;a href=&quot;https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers-beta-feature&quot;&gt;Linux containers&lt;/a&gt;. For more information, see &lt;a href=&quot;https://docs.docker.com/docker-for-windows/#shared-drives&quot;&gt;Shared Drives&lt;/a&gt; on Docker Desktop for Windows, &lt;a href=&quot;https://docs.docker.com/docker-for-mac/#file-sharing&quot;&gt;File sharing&lt;/a&gt; on Docker for Mac, and the general examples on how to &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;Manage data in containers&lt;/a&gt;.</source>
          <target state="translated">프로젝트가 &lt;code&gt;Users&lt;/code&gt; 디렉토리 ( &lt;code&gt;cd ~&lt;/code&gt; ) 외부에있는 경우 사용중인 Dockerfile 및 볼륨의 드라이브 또는 위치를 공유해야합니다. 응용 프로그램 파일을 찾을 수 없거나 볼륨 마운트가 거부되었거나 서비스를 시작할 수 없다는 런타임 오류가 발생하면 파일 또는 드라이브 공유를 활성화하십시오. 볼륨 라이브 이외의 것을 프로젝트에 드라이브를 공유 필요 탑재 &lt;code&gt;C:\Users&lt;/code&gt; (Windows) 또는 &lt;code&gt;/Users&lt;/code&gt; (맥), 그리고이 필요 &lt;em&gt;어떤&lt;/em&gt; 사용하는 Windows 용 도커 바탕 화면에서 프로젝트 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers-beta-feature&quot;&gt;리눅스 용기&lt;/a&gt; . 자세한 정보 는 Windows 용 Docker Desktop의 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/#shared-drives&quot;&gt;공유 드라이브&lt;/a&gt; , &lt;a href=&quot;https://docs.docker.com/docker-for-mac/#file-sharing&quot;&gt;파일 공유&lt;/a&gt; 를 참조하십시오.Mac 용 Docker 및 &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;컨테이너에서 데이터&lt;/a&gt; 를 관리 하는 방법에 대한 일반적인 예 .</target>
        </trans-unit>
        <trans-unit id="826899ca2686e2a0798d17f8e23a5a226f714554" translate="yes" xml:space="preserve">
          <source>If your service attempts to use more memory than the swarm node has available, you may experience an Out Of Memory Exception (OOME) and a container, or the Docker daemon, might be killed by the kernel OOM killer. To prevent this from happening, ensure that your application runs on hosts with adequate memory and see &lt;a href=&quot;https://docs.docker.com/config/containers#understand-the-risks-of-running-out-of-memory&quot;&gt;Understand the risks of running out of memory&lt;/a&gt;.</source>
          <target state="translated">서비스에서 swarm 노드가 사용할 수있는 것보다 많은 메모리를 사용하려고하면 메모리 부족 예외 (OOME)가 발생하고 컨테이너 또는 Docker 데몬이 커널 OOM 킬러에 의해 종료 될 수 있습니다. 이러한 상황이 발생하지 않도록하려면 메모리가 충분한 호스트에서 응용 프로그램을 실행하고 메모리 부족 &lt;a href=&quot;https://docs.docker.com/config/containers#understand-the-risks-of-running-out-of-memory&quot;&gt;위험 이해를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4772e0d7e0ed2d3fe6baf4dd95ed90fccd20b8da" translate="yes" xml:space="preserve">
          <source>If your services or containers attempt to use more memory than the system has available, you may experience an Out Of Memory Exception (OOME) and a container, or the Docker daemon, might be killed by the kernel OOM killer. To prevent this from happening, ensure that your application runs on hosts with adequate memory and see &lt;a href=&quot;https://docs.docker.com/config/containers#understand-the-risks-of-running-out-of-memory&quot;&gt;Understand the risks of running out of memory&lt;/a&gt;.</source>
          <target state="translated">서비스 나 컨테이너가 시스템에서 사용할 수있는 것보다 많은 메모리를 사용하려고하면 메모리 부족 예외 (OOME)가 발생하고 컨테이너 또는 Docker 데몬이 커널 OOM 킬러에 의해 종료 될 수 있습니다. 이러한 상황이 발생하지 않도록하려면 메모리가 충분한 호스트에서 응용 프로그램을 실행하고 메모리 부족 &lt;a href=&quot;https://docs.docker.com/config/containers#understand-the-risks-of-running-out-of-memory&quot;&gt;위험 이해를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="402a915739c0383de60afadf15db2a2629ff47d7" translate="yes" xml:space="preserve">
          <source>If your swarm service relies on one or more &lt;a href=&quot;../../extend/plugin_api/index&quot;&gt;plugins&lt;/a&gt;, these plugins need to be available on every node where the service could potentially be deployed. You can manually install the plugin on each node or script the installation. In Docker 17.07 and higher, you can also deploy the plugin in a similar way as a global service using the Docker API, by specifying a &lt;code&gt;PluginSpec&lt;/code&gt; instead of a &lt;code&gt;ContainerSpec&lt;/code&gt;.</source>
          <target state="translated">swarm 서비스가 하나 이상의 &lt;a href=&quot;../../extend/plugin_api/index&quot;&gt;플러그인&lt;/a&gt; 에 의존 하는 경우 서비스를 배치 할 수있는 모든 노드에서 이러한 플러그인을 사용할 수 있어야합니다. 각 노드에 플러그인을 수동으로 설치하거나 설치를 스크립트 할 수 있습니다. Docker 17.07 이상에서는 &lt;code&gt;ContainerSpec&lt;/code&gt; 대신 &lt;code&gt;PluginSpec&lt;/code&gt; 을 지정하여 Docker API를 사용하여 글로벌 서비스와 유사한 방식으로 플러그인을 배치 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90f1811c30ff4805d621b4791c8107d9e5e7f201" translate="yes" xml:space="preserve">
          <source>If your system doesn&amp;rsquo;t have support for &lt;code&gt;dirperm1&lt;/code&gt;, the issue describes a workaround.</source>
          <target state="translated">시스템에서 &lt;code&gt;dirperm1&lt;/code&gt; 을 지원하지 않는 경우이 문제는 해결 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="239760bef63476e8180ba21228a84305307aaeb5" translate="yes" xml:space="preserve">
          <source>If, at any time during the update, a task returns &lt;code&gt;FAILED&lt;/code&gt;, pause the update.</source>
          <target state="translated">업데이트 중 언제라도 작업이 &lt;code&gt;FAILED&lt;/code&gt; 를 반환 하면 업데이트를 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="1e65bb4eca2d3c71529c96890a4b735eb7dafeac" translate="yes" xml:space="preserve">
          <source>Ignored.</source>
          <target state="translated">Ignored.</target>
        </trans-unit>
        <trans-unit id="331f1d7091668de6721fd50ce74e69d189f066e0" translate="yes" xml:space="preserve">
          <source>Image (required) &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">이미지 (필수) &lt;code&gt;string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c93001a35ed219979d993baeb27888011162e925" translate="yes" xml:space="preserve">
          <source>Image ID</source>
          <target state="translated">이미지 ID</target>
        </trans-unit>
        <trans-unit id="0fd3d8c671f22aaf256379f3be9a7b0ccf6b2e91" translate="yes" xml:space="preserve">
          <source>Image Name</source>
          <target state="translated">이미지 이름</target>
        </trans-unit>
        <trans-unit id="a022baad71e528f98ec2d3ffbf64a4c9176358e7" translate="yes" xml:space="preserve">
          <source>Image consumers can enable DCT to ensure that images they use were signed. If a consumer enables DCT, they can only pull, run, or build with trusted images. Enabling DCT is a bit like applying a &amp;ldquo;filter&amp;rdquo; to your registry. Consumers &amp;ldquo;see&amp;rdquo; only signed image tags and the less desirable, unsigned image tags are &amp;ldquo;invisible&amp;rdquo; to them.</source>
          <target state="translated">이미지 소비자는 DCT를 사용하여 자신이 사용하는 이미지가 서명되었는지 확인할 수 있습니다. 소비자가 DCT를 활성화하면 신뢰할 수있는 이미지 만 가져 와서 실행하거나 빌드 할 수 있습니다. DCT 활성화는 레지스트리에 &quot;필터&quot;를 적용하는 것과 비슷합니다. 소비자는 서명 된 이미지 태그 만 &quot;보&quot;고 덜 바람직하고 서명되지 않은 이미지 태그는 &quot;보이지 않습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="fa16e8da25fa7178f0acfa55db5c1c871c3155ac" translate="yes" xml:space="preserve">
          <source>Image description</source>
          <target state="translated">이미지 설명</target>
        </trans-unit>
        <trans-unit id="2bfe7f4e2544f5a0cf8d4697281f70cc40a8dfc1" translate="yes" xml:space="preserve">
          <source>Image digest</source>
          <target state="translated">이미지 다이제스트</target>
        </trans-unit>
        <trans-unit id="25e58e59af4c723934aead1624c4bfa9c35f8b22" translate="yes" xml:space="preserve">
          <source>Image disk size</source>
          <target state="translated">이미지 디스크 크기</target>
        </trans-unit>
        <trans-unit id="212a9200cdec31540b62a52e7c5956a40c149448" translate="yes" xml:space="preserve">
          <source>Image repository</source>
          <target state="translated">이미지 저장소</target>
        </trans-unit>
        <trans-unit id="8888020bb69e3dd54934b4fc64f75c443dc19755" translate="yes" xml:space="preserve">
          <source>Image tag</source>
          <target state="translated">이미지 태그</target>
        </trans-unit>
        <trans-unit id="ca662c89b95ffdff7c161301523b9ef21e3c1bd0" translate="yes" xml:space="preserve">
          <source>Image tags and DCT</source>
          <target state="translated">이미지 태그 및 DCT</target>
        </trans-unit>
        <trans-unit id="1d828fd92bb02d0c07163ca93574414854eb0065" translate="yes" xml:space="preserve">
          <source>Image template name</source>
          <target state="translated">이미지 템플릿 이름</target>
        </trans-unit>
        <trans-unit id="c86c4f797e197f8d5e2ccf8953f76421e1c60e43" translate="yes" xml:space="preserve">
          <source>Image[:tag]</source>
          <target state="translated">Image[:tag]</target>
        </trans-unit>
        <trans-unit id="34c3ec4679bd678d1b10a72deb1b7ecf57727c10" translate="yes" xml:space="preserve">
          <source>Image[@digest]</source>
          <target state="translated">Image[@digest]</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="23847f66fa7574788037843db8acd02a0cd22feb" translate="yes" xml:space="preserve">
          <source>Images and containers</source>
          <target state="translated">이미지와 컨테이너</target>
        </trans-unit>
        <trans-unit id="b175d4ac3b36d06fdf12a9dde9f428047c335e70" translate="yes" xml:space="preserve">
          <source>Images must have digests stored, which requires interaction with a Docker registry. If digests aren&amp;rsquo;t stored for all images, you can fetch them with &lt;code&gt;docker-compose pull&lt;/code&gt; or &lt;code&gt;docker-compose push&lt;/code&gt;. To push images automatically when bundling, pass &lt;code&gt;--push-images&lt;/code&gt;. Only services with a &lt;code&gt;build&lt;/code&gt; option specified have their images pushed.</source>
          <target state="translated">이미지에는 다이제스트가 저장되어 있어야하며 Docker 레지스트리와 상호 작용해야합니다. 모든 이미지에 다이제스트가 저장되지 않은 경우 &lt;code&gt;docker-compose pull&lt;/code&gt; 또는 &lt;code&gt;docker-compose push&lt;/code&gt; 로 이미지를 가져올 수 있습니다 . 번들링 할 때 이미지를 자동으로 푸시하려면 &lt;code&gt;--push-images&lt;/code&gt; 를 전달 하십시오 . &lt;code&gt;build&lt;/code&gt; 옵션이 지정된 서비스 만 이미지를 푸시했습니다.</target>
        </trans-unit>
        <trans-unit id="eb068f5848f7d2ec1cea267d2ff67b5bbc9782ea" translate="yes" xml:space="preserve">
          <source>Images that use the v2 or later format have a content-addressable identifier called a &lt;code&gt;digest&lt;/code&gt;. As long as the input used to generate the image is unchanged, the digest value is predictable. To list image digest values, use the &lt;code&gt;--digests&lt;/code&gt; flag:</source>
          <target state="translated">v2 이상 형식을 사용하는 이미지에는 &lt;code&gt;digest&lt;/code&gt; 라고하는 컨텐츠 주소 지정 가능한 식별자가 있습니다. 이미지를 생성하는 데 사용 된 입력이 변경되지 않는 한 다이제스트 값을 예측할 수 있습니다. 이미지 요약 값을 나열하려면 &lt;code&gt;--digests&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ccbfaed9a04d9f81720c71308ffbefc15ade787" translate="yes" xml:space="preserve">
          <source>Images to consider as cache sources</source>
          <target state="translated">캐시 소스로 간주 할 이미지</target>
        </trans-unit>
        <trans-unit id="1e6915883b06acaf7dfd14fe8cec6a54c82b5bb1" translate="yes" xml:space="preserve">
          <source>Images using the v2 or later image format have a content-addressable identifier called a digest. As long as the input used to generate the image is unchanged, the digest value is predictable and referenceable.</source>
          <target state="translated">v2 이상의 이미지 형식을 사용하는 이미지에는 다이제스트라고하는 콘텐츠 주소 지정 가능한 식별자가 있습니다. 이미지를 생성하는 데 사용 된 입력이 변경되지 않는 한 다이제스트 값을 예측하고 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88da112012b0c6519d012c8f722e82f59491898b" translate="yes" xml:space="preserve">
          <source>Imagine that you have a 10-node swarm, and you deploy an Nginx service running three tasks on a 10-node swarm:</source>
          <target state="translated">10 노드 떼가 있고 10 노드 떼에서 세 가지 작업을 실행하는 Nginx 서비스를 배포한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="725bbbea09ecf62953c9e0fe4109b91cdf779ec0" translate="yes" xml:space="preserve">
          <source>Immediately restart containers if one fails.</source>
          <target state="translated">컨테이너가 실패하면 즉시 컨테이너를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="476a64df8f5696ecbb97f330bc0fcc59db153f7e" translate="yes" xml:space="preserve">
          <source>Impact on build caching</source>
          <target state="translated">빌드 캐싱에 미치는 영향</target>
        </trans-unit>
        <trans-unit id="a77bf51bf2cd35ab35589a4c8125a485391ad650" translate="yes" xml:space="preserve">
          <source>Import a context from a tar or zip file</source>
          <target state="translated">tar 또는 zip 파일에서 컨텍스트 가져 오기</target>
        </trans-unit>
        <trans-unit id="59ac246eedb955d8cbd8eaa42c83d9a91ef3eee4" translate="yes" xml:space="preserve">
          <source>Import from a local directory</source>
          <target state="translated">로컬 디렉토리에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="b14e2df39550357f9f9caaece37378fbe0eab5df" translate="yes" xml:space="preserve">
          <source>Import from a local directory with new configurations</source>
          <target state="translated">새로운 구성으로 로컬 디렉토리에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="af751c541d65e2f9288561c4f6af0588b30ff7da" translate="yes" xml:space="preserve">
          <source>Import from a local file</source>
          <target state="translated">로컬 파일에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="8088418b6e9230a6b6c875afc4dda0c0839043f7" translate="yes" xml:space="preserve">
          <source>Import from a remote location</source>
          <target state="translated">원격 위치에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="bb50b41244a26144f7c36378564b7d9d89ac76b3" translate="yes" xml:space="preserve">
          <source>Import the contents from a tarball to create a filesystem image</source>
          <target state="translated">tarball에서 컨텐츠를 가져 와서 파일 시스템 이미지 작성</target>
        </trans-unit>
        <trans-unit id="917c4e43ed77c48dc0fc6453012e3392ae9ed2ea" translate="yes" xml:space="preserve">
          <source>Import to docker from a local archive.</source>
          <target state="translated">로컬 아카이브에서 docker로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="245228a97fb3f0dfeb918b70053769a53c34bb54" translate="yes" xml:space="preserve">
          <source>Import to docker via pipe and &lt;code&gt;STDIN&lt;/code&gt;.</source>
          <target state="translated">파이프 및 &lt;code&gt;STDIN&lt;/code&gt; 을 통해 도커로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="f1c1df799aebcc10b5c07ddec95aac1c19effe22" translate="yes" xml:space="preserve">
          <source>Import with a commit message.</source>
          <target state="translated">커밋 메시지와 함께 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="17a3ca00a774965f843a5871b72dca117f794a31" translate="yes" xml:space="preserve">
          <source>Imports a context previously exported with &lt;code&gt;docker context export&lt;/code&gt;. To import from stdin, use a hyphen (&lt;code&gt;-&lt;/code&gt;) as filename.</source>
          <target state="translated">&lt;code&gt;docker context export&lt;/code&gt; 로 이전에 내 보낸 컨텍스트를 가져 옵니다 . stdin에서 가져 오려면 파일 이름으로 하이픈 ( &lt;code&gt;-&lt;/code&gt; )을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e768cac2146e2098c1afd513559f7160e33f66a6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1 file format&lt;/a&gt;, &lt;code&gt;build&lt;/code&gt; is different in two ways:</source>
          <target state="translated">에서 &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;버전 1 파일 형식&lt;/a&gt; , &lt;code&gt;build&lt;/code&gt; 두 가지 방법으로 다르다 :</target>
        </trans-unit>
        <trans-unit id="44d884285fe257a1ad94785af65b08ca526d7a7d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1&lt;/a&gt;, you can use container names without marking them as such:</source>
          <target state="translated">&lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;버전 1&lt;/a&gt; 에서는 컨테이너 이름을 다음과 같이 표시하지 않고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d2c106f68ac42ca15c268dc9fe930562c886993" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../https/index&quot;&gt;Running Docker with HTTPS&lt;/a&gt;, you learned that, by default, Docker runs via a non-networked Unix socket and TLS must be enabled in order to have the Docker client and the daemon communicate securely over HTTPS. TLS ensures authenticity of the registry endpoint and that traffic to/from registry is encrypted.</source>
          <target state="translated">에서 &lt;a href=&quot;../https/index&quot;&gt;HTTPS로 도커 실행&lt;/a&gt; , 당신이 배운 기본적으로 도커는 네트워크에 연결되지 않은 유닉스 소켓을 통해 실행하고 TLS는 도커 클라이언트를 위해 사용 가능해야하며 데몬은 HTTPS를 통해 안전하게 통신. TLS는 레지스트리 엔드 포인트의 신뢰성을 보장하고 레지스트리를 오가는 트래픽이 암호화되도록합니다.</target>
        </trans-unit>
        <trans-unit id="cebc4c46df5f015f8475209378cd9a380c12b921" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../part3/index&quot;&gt;part 3&lt;/a&gt;, you took an app you wrote in &lt;a href=&quot;../part2/index&quot;&gt;part 2&lt;/a&gt;, and defined how it should run in production by turning it into a service, scaling it up 5x in the process.</source>
          <target state="translated">&lt;a href=&quot;../part3/index&quot;&gt;3 부&lt;/a&gt; 에서는 &lt;a href=&quot;../part2/index&quot;&gt;2 부&lt;/a&gt; 에서 작성한 앱을 가져 와서 서비스로 전환하여 프로세스에서 5 배로 확장하여 프로덕션에서 어떻게 실행해야하는지 정의했습니다.</target>
        </trans-unit>
        <trans-unit id="ef4d413ec0e89fa3b52adf430f0bcec3dde1939b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../part4/index&quot;&gt;part 4&lt;/a&gt;, you learned how to set up a swarm, which is a cluster of machines running Docker, and deployed an application to it, with containers running in concert on multiple machines.</source>
          <target state="translated">&lt;a href=&quot;../part4/index&quot;&gt;Part 4&lt;/a&gt; 에서는 Docker를 실행하는 머신 클러스터 인 swarm을 설정하고 컨테이너를 여러 머신에서 함께 실행하여 애플리케이션을 배치하는 방법을 학습했습니다.</target>
        </trans-unit>
        <trans-unit id="44904e78e7d1d56ea6f2891b11cae1785aa0aef2" translate="yes" xml:space="preserve">
          <source>In Compose file format 3.x, you can optionally set the &lt;code&gt;attachable&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">파일 형식 3.x 작성에서 선택적으로 &lt;code&gt;attachable&lt;/code&gt; 특성을 &lt;code&gt;false&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb4906830491dcb2e177349cb0dd91e5a7651470" translate="yes" xml:space="preserve">
          <source>In Docker 1.13 and higher, the Raft logs used by swarm managers are encrypted on disk by default. This at-rest encryption protects your service&amp;rsquo;s configuration and data from attackers who gain access to the encrypted Raft logs. One of the reasons this feature was introduced was in support of the new &lt;a href=&quot;../secrets/index&quot;&gt;Docker secrets&lt;/a&gt; feature.</source>
          <target state="translated">Docker 1.13 이상에서 swarm 관리자가 사용하는 Raft 로그는 기본적으로 디스크에서 암호화됩니다. 이 미사용 암호화는 암호화 된 Raft 로그에 액세스하는 공격자로부터 서비스 구성 및 데이터를 보호합니다. 이 기능이 소개 된 이유 중 하나는 새로운 &lt;a href=&quot;../secrets/index&quot;&gt;Docker 비밀&lt;/a&gt; 기능 을 지원하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b5d038a6967c5b86f1a5e5d0d90d098a759d1ac7" translate="yes" xml:space="preserve">
          <source>In Docker 1.13 and higher, you can use the &lt;code&gt;--force&lt;/code&gt; or &lt;code&gt;-f&lt;/code&gt; flag with the &lt;code&gt;docker service update&lt;/code&gt; command to force the service to redistribute its tasks across the available worker nodes. This causes the service tasks to restart. Client applications may be disrupted. If you have configured it, your service uses a &lt;a href=&quot;../swarm-tutorial/rolling-update/index&quot;&gt;rolling update&lt;/a&gt;.</source>
          <target state="translated">Docker 1.13 이상에서는 &lt;code&gt;docker service update&lt;/code&gt; 명령 과 함께 &lt;code&gt;--force&lt;/code&gt; 또는 &lt;code&gt;-f&lt;/code&gt; 플래그를 사용하여 서비스 가 사용 가능한 작업자 노드에 작업을 다시 배포 하도록 할 수 있습니다. 서비스 작업이 다시 시작됩니다. 클라이언트 응용 프로그램이 중단되었을 수 있습니다. 구성한 경우 서비스는 &lt;a href=&quot;../swarm-tutorial/rolling-update/index&quot;&gt;지속적 업데이트를&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0bed4dbfffbdc2ad1e77dd3c05f72b79671ebf29" translate="yes" xml:space="preserve">
          <source>In Docker 17.04 and higher, you can configure a service to roll back automatically if a service update fails to deploy. See &lt;a href=&quot;#automatically-roll-back-if-an-update-fails&quot;&gt;Automatically roll back if an update fails&lt;/a&gt;.</source>
          <target state="translated">Docker 17.04 이상에서 서비스 업데이트가 배포되지 않으면 서비스가 자동으로 롤백되도록 구성 할 수 있습니다. &lt;a href=&quot;#automatically-roll-back-if-an-update-fails&quot;&gt;업데이트가 실패하면 자동 롤백을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c368bba16615dcbbc6ff7260156db7367b0127e5" translate="yes" xml:space="preserve">
          <source>In Docker 17.05 and earlier, secrets are always located within the &lt;code&gt;/run/secrets/&lt;/code&gt; directory. Docker 17.06 and higher allow you to specify a custom location for a secret within the container. The two examples below illustrate the difference. The older version of this command requires you to create a symbolic link to the true location of the &lt;code&gt;site.conf&lt;/code&gt; file so that Nginx can read it, but the newer version does not require this. The older example is preserved so that you can see the difference.</source>
          <target state="translated">Docker 17.05 및 이전 버전에서 비밀은 항상 &lt;code&gt;/run/secrets/&lt;/code&gt; 디렉토리에 있습니다. Docker 17.06 이상에서는 컨테이너 내 비밀의 사용자 지정 위치를 지정할 수 있습니다. 아래의 두 가지 예는 차이점을 보여줍니다. 이 명령의 이전 버전에서는 Nginx가 읽을 수 있도록 &lt;code&gt;site.conf&lt;/code&gt; 파일 의 실제 위치에 대한 심볼릭 링크를 작성해야 하지만 최신 버전에서는이를 요구하지 않습니다. 차이를 볼 수 있도록 이전 예제는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1e2e9f48f49b02a6e2a75caca1b843f6d52ad27d" translate="yes" xml:space="preserve">
          <source>In Docker 17.06 and higher, Docker also tells all nodes to immediately renew their TLS certificates. This process may take several minutes, depending on the number of nodes in the swarm.</source>
          <target state="translated">Docker 17.06 이상에서 Docker는 모든 노드에 TLS 인증서를 즉시 갱신하도록 지시합니다. 이 프로세스는 swarm의 노드 수에 따라 몇 분이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae5f457448fc694390bdddfb48512e7fc1888016" translate="yes" xml:space="preserve">
          <source>In Enterprise Edition 3.0, security is improved through the centralized distribution and management of Group Managed Service Account(gMSA) credentials using Docker Config functionality. Swarm now allows using a Docker Config as a gMSA credential spec, which reduces the burden of distributing credential specs to the nodes on which they are used.</source>
          <target state="translated">Enterprise Edition 3.0에서는 Docker Config 기능을 사용하여 gMSA (Group Managed Service Account) 자격 증명의 중앙 집중식 배포 및 관리를 통해 보안이 향상되었습니다. Swarm은 이제 Docker Config를 gMSA 자격 증명 사양으로 사용하여 자격 증명 사양을 사용하는 노드에 자격 증명 사양을 배포하는 부담을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="a15ea31fb01f46bfd56520155cf023c2cc703f20" translate="yes" xml:space="preserve">
          <source>In PowerShell, since GitHub now requires TLS1.2, run the following:</source>
          <target state="translated">PowerShell에서 GitHub에 이제 TLS1.2가 필요하므로 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2819c465da200bd336241494742d8c6069d7cf4c" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;common.yml&lt;/strong&gt; we define the common configuration:</source>
          <target state="translated">A의 &lt;strong&gt;common.yml&lt;/strong&gt; 우리는 공통의 구성을 정의 :</target>
        </trans-unit>
        <trans-unit id="a3552d5600b4d9f18898ff597bbcb4a7aeda6134" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;docker-compose.admin.yml&lt;/strong&gt; add a new service to run the database export or backup.</source>
          <target state="translated">A의 &lt;strong&gt;고정 표시기 - compose.admin.yml&lt;/strong&gt; 데이터베이스 수출 또는 백업을 실행하기 위해 새로운 서비스를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f66a12f1e191bfac4b15b2b7e82d32b416b4c6" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;docker-compose.yml&lt;/strong&gt; we define the concrete services which use the common configuration:</source>
          <target state="translated">A의 &lt;strong&gt;고정 표시기 - compose.yml&lt;/strong&gt; 우리는 일반적인 구성을 사용하는 콘크리트 서비스를 정의 :</target>
        </trans-unit>
        <trans-unit id="533543a7d4c7e79b5cbba450534920c35bc934d9" translate="yes" xml:space="preserve">
          <source>In a distributed application, different pieces of the app are called &amp;ldquo;services&amp;rdquo;. For example, if you imagine a video sharing site, it probably includes a service for storing application data in a database, a service for video transcoding in the background after a user uploads something, a service for the front-end, and so on.</source>
          <target state="translated">분산 응용 프로그램에서는 다른 응용 프로그램을 &quot;서비스&quot;라고합니다. 예를 들어, 비디오 공유 사이트를 상상한다면 데이터베이스에 응용 프로그램 데이터를 저장하는 서비스, 사용자가 무언가를 업로드 한 후 백그라운드에서 비디오 트랜스 코딩을위한 서비스, 프런트 엔드를위한 서비스 등이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a22937ba30c717a6507f3d4a9b3677b139196e19" translate="yes" xml:space="preserve">
          <source>In a previous step of the tutorial, you &lt;a href=&quot;../scale-service/index&quot;&gt;scaled&lt;/a&gt; the number of instances of a service. In this part of the tutorial, you deploy a service based on the Redis 3.0.6 container tag. Then you upgrade the service to use the Redis 3.0.7 container image using rolling updates.</source>
          <target state="translated">학습서의 이전 단계 에서 서비스 인스턴스 수 를 &lt;a href=&quot;../scale-service/index&quot;&gt;조정&lt;/a&gt; 했습니다. 튜토리얼의이 부분에서는 Redis 3.0.6 컨테이너 태그를 기반으로 서비스를 배포합니다. 그런 다음 롤링 업데이트를 사용하여 Redis 3.0.7 컨테이너 이미지를 사용하도록 서비스를 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="ca8de6027d14e43307b73994ba172c9eedd57dfe" translate="yes" xml:space="preserve">
          <source>In a swarm of &lt;code&gt;N&lt;/code&gt; managers, a quorum (a majority) of manager nodes must always be available. For example, in a swarm with 5 managers, a minimum of 3 must be operational and in communication with each other. In other words, the swarm can tolerate up to &lt;code&gt;(N-1)/2&lt;/code&gt; permanent failures beyond which requests involving swarm management cannot be processed. These types of failures include data corruption or hardware failures.</source>
          <target state="translated">떼에서 &lt;code&gt;N&lt;/code&gt; 의 관리자, 관리자 노드의 정족수 (과반수)는 항상 사용할 수 있어야합니다. 예를 들어, 관리자가 5 명인 떼에서 최소 3 명이 작동하고 서로 통신해야합니다. 즉, 스웜은 스웜 관리와 관련된 요청을 처리 할 수없는 최대 &lt;code&gt;(N-1)/2&lt;/code&gt; 의 영구적 인 장애를 허용 할 수 있습니다. 이러한 유형의 오류에는 데이터 손상 또는 하드웨어 오류가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef7dcefd146a7eb680d884b8a9d407b66ea5215" translate="yes" xml:space="preserve">
          <source>In a web browser, go to &lt;code&gt;http://&amp;lt;host_ip&amp;gt;:8000&lt;/code&gt; to bring up the webserver home page. You got the &lt;code&gt;&amp;lt;host_ip&amp;gt;&lt;/code&gt; from the output of the &lt;code&gt;docker-machine ip &amp;lt;machine&amp;gt;&lt;/code&gt; command you ran in a previous step. Use the port you exposed in the &lt;code&gt;docker run&lt;/code&gt; command.</source>
          <target state="translated">웹 브라우저에서 &lt;code&gt;http://&amp;lt;host_ip&amp;gt;:8000&lt;/code&gt; 으로 이동하여 웹 서버 홈 페이지를 불러 오십시오. 이전 단계에서 실행 한 &lt;code&gt;docker-machine ip &amp;lt;machine&amp;gt;&lt;/code&gt; 명령 의 출력에서 &lt;code&gt;&amp;lt;host_ip&amp;gt;&lt;/code&gt; 을 얻었습니다 . &lt;code&gt;docker run&lt;/code&gt; 명령에 노출 된 포트를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="44321900d1984b4d80f20a0b0284d786d26bc5cd" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--privileged&lt;/code&gt;, the operator can have fine grain control over the capabilities using &lt;code&gt;--cap-add&lt;/code&gt; and &lt;code&gt;--cap-drop&lt;/code&gt;. By default, Docker has a default list of capabilities that are kept. The following table lists the Linux capability options which are allowed by default and can be dropped.</source>
          <target state="translated">&lt;code&gt;--privileged&lt;/code&gt; 외에도 운영자는 &lt;code&gt;--cap-add&lt;/code&gt; 및 &lt;code&gt;--cap-drop&lt;/code&gt; 을 사용하여 기능을 세부적으로 제어 할 수 있습니다 . 기본적으로 Docker에는 기본 기능 목록이 유지됩니다. 다음 표는 기본적으로 허용되며 제거 할 수있는 Linux 기능 옵션을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="8dba3d97d1c6e8ce331405e0f7f377b4acd4af30" translate="yes" xml:space="preserve">
          <source>In addition to &lt;em&gt;running&lt;/em&gt; tasks, the output also shows the task history. For example, after updating the service to use the &lt;code&gt;redis:3.0.6&lt;/code&gt; image, the output may look like this:</source>
          <target state="translated">작업 &lt;em&gt;실행&lt;/em&gt; 외에도 출력에는 작업 기록도 표시됩니다. 예를 들어 &lt;code&gt;redis:3.0.6&lt;/code&gt; 이미지 를 사용하도록 서비스를 업데이트 한 후 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="02ccf39aee67211d958c18d2958a29ef3c025c35" translate="yes" xml:space="preserve">
          <source>In addition to Compose file format versions shown in the table, the Compose itself is on a release schedule, as shown in &lt;a href=&quot;https://github.com/docker/compose/releases/&quot;&gt;Compose releases&lt;/a&gt;, but file format versions do not necessarily increment with each release. For example, Compose file format 3.0 was first introduced in &lt;a href=&quot;https://github.com/docker/compose/releases/tag/1.10.0&quot;&gt;Compose release 1.10.0&lt;/a&gt;, and versioned gradually in subsequent releases.</source>
          <target state="translated">표에 표시된 Compose 파일 형식 버전 외에도 &lt;a href=&quot;https://github.com/docker/compose/releases/&quot;&gt;Compose 릴리스에&lt;/a&gt; 표시된대로 작성 자체가 릴리스 스케줄 에 있지만 파일 형식 버전이 반드시 각 릴리스마다 증가하지는 않습니다. 예를 들어, Compose 파일 형식 3.0은 &lt;a href=&quot;https://github.com/docker/compose/releases/tag/1.10.0&quot;&gt;Compose 릴리스 1.10.0&lt;/a&gt; 에서 처음 도입 되었으며 이후 릴리스에서는 점진적으로 버전이 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="59ea0f30071c8b9591e5be8c4ad05bcf2d51891d" translate="yes" xml:space="preserve">
          <source>In addition to Docker&amp;rsquo;s standard plugin registration method, each plugin should implement the following two methods:</source>
          <target state="translated">Docker의 표준 플러그인 등록 방법 외에도 각 플러그인은 다음 두 가지 방법을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="f71e4ed1533f9b3144ef50664bca71e29a02f07a" translate="yes" xml:space="preserve">
          <source>In addition to configuring Docker Engine options as listed above, you can use Machine to specify how the created swarm manager is configured. There is a &lt;code&gt;--swarm-strategy&lt;/code&gt; flag, which you can use to specify the &lt;a href=&quot;https://docs.docker.com/swarm/scheduler/strategy/&quot;&gt;scheduling strategy&lt;/a&gt; which Docker Swarm should use (Machine defaults to the &lt;code&gt;spread&lt;/code&gt; strategy). There is also a general purpose &lt;code&gt;--swarm-opt&lt;/code&gt; option which works similar to the aforementioned &lt;code&gt;--engine-opt&lt;/code&gt; option, except that it specifies options for the &lt;code&gt;swarm manage&lt;/code&gt; command (used to boot a master node) instead of the base command. You can use this to configure features that power users might be interested in, such as configuring the heartbeat interval or Swarm&amp;rsquo;s willingness to over-commit resources. There is also the &lt;code&gt;--swarm-experimental&lt;/code&gt; flag, that allows you to access &lt;a href=&quot;https://github.com/docker/swarm/tree/master/experimental&quot;&gt;experimental features&lt;/a&gt; in Docker Swarm.</source>
          <target state="translated">위에 나열된 Docker Engine 옵션을 구성하는 것 외에도 Machine을 사용하여 생성 된 스웜 관리자가 구성되는 방법을 지정할 수 있습니다. 있습니다 &lt;code&gt;--swarm-strategy&lt;/code&gt; 당신이 지정하는 데 사용할 수있는 플래그, &lt;a href=&quot;https://docs.docker.com/swarm/scheduler/strategy/&quot;&gt;스케줄링 전략&lt;/a&gt; 도커 떼 (받는 기계 기본적으로 사용해야 &lt;code&gt;spread&lt;/code&gt; 전략). &lt;code&gt;swarm manage&lt;/code&gt; 옵션을 지정한다는 점을 제외하고 는 위에서 언급 한 &lt;code&gt;--engine-opt&lt;/code&gt; 옵션 과 유사한 범용 &lt;code&gt;--swarm-opt&lt;/code&gt; 옵션도 있습니다.기본 명령 대신 명령 (마스터 노드를 부팅하는 데 사용). 이를 사용하여 하트 비트 간격 구성 또는 Swarm의 리소스 초과 커밋과 같은 고급 사용자가 관심을 가질 수있는 기능을 구성 할 수 있습니다. Docker Swarm의 &lt;a href=&quot;https://github.com/docker/swarm/tree/master/experimental&quot;&gt;실험 기능&lt;/a&gt; 에 액세스 할 수 있는 &lt;code&gt;--swarm-experimental&lt;/code&gt; 플래그도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6895df25c17b42df521add4b1b67aa3bc759f81" translate="yes" xml:space="preserve">
          <source>In addition to maintaining an odd number of manager nodes, pay attention to datacenter topology when placing managers. For optimal fault-tolerance, distribute manager nodes across a minimum of 3 availability-zones to support failures of an entire set of machines or common maintenance scenarios. If you suffer a failure in any of those zones, the swarm should maintain the quorum of manager nodes available to process requests and rebalance workloads.</source>
          <target state="translated">홀수 개의 관리자 노드를 유지 관리하는 것 외에도 관리자를 배치 할 때 데이터 센터 토폴로지에주의하십시오. 내결함성을 최적화하려면 관리자 시스템을 최소 3 개의 가용 영역에 분산하여 전체 시스템 세트 또는 일반적인 유지 관리 시나리오의 장애를 지원하십시오. 해당 영역에서 장애가 발생하면 웜은 요청을 처리하고 워크로드를 재조정하는 데 사용할 수있는 관리자 노드 쿼럼을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f7e89d0e5dce1710c0689c1ba441f3f53e1f735" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;text/template&lt;/code&gt; syntax, there are some additional functions, &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;prettyjson&lt;/code&gt;, which can be used to format the output as JSON (documented below).</source>
          <target state="translated">또한받는 &lt;code&gt;text/template&lt;/code&gt; 문법, 추가적인 기능있다 &lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;prettyjson&lt;/code&gt; JSON로서 출력 (아래 설명)를 포맷하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="2f902b77d43826ac29278b237fde653a03979e0c" translate="yes" xml:space="preserve">
          <source>In addition to the configuration file format, see the optional password &lt;a href=&quot;index#environment-variables-optional&quot;&gt;environment variables&lt;/a&gt; that the Notary client can take for ease of use.</source>
          <target state="translated">구성 파일 형식 외에도 Notary 클라이언트가 쉽게 사용할 수 있는 선택적 비밀번호 &lt;a href=&quot;index#environment-variables-optional&quot;&gt;환경 변수&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ab9b294fd7a389232a230d2b62d79af190f9d31" translate="yes" xml:space="preserve">
          <source>In addition to the provider, you have the option of identifying a base operating system. It is an option because Docker Machine has defaults for both local and remote providers. For local providers such as VirtualBox, Fusion, Hyper-V, and so forth, the default base operating system is Boot2Docker. For cloud providers, the base operating system is the latest Ubuntu LTS the provider supports.</source>
          <target state="translated">공급자 외에도 기본 운영 체제를 식별 할 수있는 옵션이 있습니다. Docker Machine에는 로컬 및 원격 공급자 모두에 대한 기본값이 있으므로 옵션입니다. VirtualBox, Fusion, Hyper-V 등과 같은 로컬 공급자의 경우 기본 기본 운영 체제는 Boot2Docker입니다. 클라우드 제공자의 경우 기본 운영 체제는 제공자가 지원하는 최신 Ubuntu LTS입니다.</target>
        </trans-unit>
        <trans-unit id="a9581556890e7ba33ac4ca96ae34722bbb7032bf" translate="yes" xml:space="preserve">
          <source>In addition to this subset of daemon flags which are directly supported, Docker Machine also supports an additional flag, &lt;code&gt;--engine-opt&lt;/code&gt;, which can be used to specify arbitrary daemon options with the syntax &lt;code&gt;--engine-opt flagname=value&lt;/code&gt;. For example, to specify that the daemon should use &lt;code&gt;8.8.8.8&lt;/code&gt; as the DNS server for all containers, and always use the &lt;code&gt;syslog&lt;/code&gt;&lt;a href=&quot;../../../engine/reference/run/index#logging-drivers-log-driver&quot;&gt;log driver&lt;/a&gt; you could run the following create command:</source>
          <target state="translated">Docker Machine은 직접 지원되는이 데몬 플래그 하위 집합 외에도 &lt;code&gt;--engine-opt flagname=value&lt;/code&gt; 구문으로 임의의 데몬 옵션을 지정하는 데 사용할 수 있는 추가 플래그 &lt;code&gt;--engine-opt&lt;/code&gt; 를 지원 합니다 . 예를 들어, 데몬이 &lt;code&gt;8.8.8.8&lt;/code&gt; 을 모든 컨테이너의 DNS 서버로 사용해야하고 항상 &lt;code&gt;syslog&lt;/code&gt; &lt;a href=&quot;../../../engine/reference/run/index#logging-drivers-log-driver&quot;&gt;로그 드라이버&lt;/a&gt; 를 사용하도록 지정 하려면 다음 create 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a85ca75ff4dc883deb3bad37e9915a96ba497b" translate="yes" xml:space="preserve">
          <source>In addition to use &lt;code&gt;--cpu-period&lt;/code&gt; and &lt;code&gt;--cpu-quota&lt;/code&gt; for setting CPU period constraints, it is possible to specify &lt;code&gt;--cpus&lt;/code&gt; with a float number to achieve the same purpose. For example, if there is 1 CPU, then &lt;code&gt;--cpus=0.5&lt;/code&gt; will achieve the same result as setting &lt;code&gt;--cpu-period=50000&lt;/code&gt; and &lt;code&gt;--cpu-quota=25000&lt;/code&gt; (50% CPU).</source>
          <target state="translated">CPU주기 제약 조건을 설정 하기 위해 &lt;code&gt;--cpu-period&lt;/code&gt; 및 &lt;code&gt;--cpu-quota&lt;/code&gt; 를 사용하는 것 &lt;code&gt;--cpus&lt;/code&gt; 동일한 목적을 달성하기 위해 --cpus 를 부동 숫자로 지정할 수 있습니다. 예를 들어 CPU가 1 개 있으면 &lt;code&gt;--cpus=0.5&lt;/code&gt; 는 &lt;code&gt;--cpu-period=50000&lt;/code&gt; 및 &lt;code&gt;--cpu-quota=25000&lt;/code&gt; (50 % CPU) 설정과 동일한 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="93da1dca83ad692961dd78b94e5a5ed8ba89b038" translate="yes" xml:space="preserve">
          <source>In addition, if you use &lt;code&gt;mode=host&lt;/code&gt; and you do not use the &lt;code&gt;--mode=global&lt;/code&gt; flag on &lt;code&gt;docker service create&lt;/code&gt;, it is difficult to know which nodes are running the service to route work to them.</source>
          <target state="translated">또한 &lt;code&gt;mode=host&lt;/code&gt; 를 사용하고 &lt;code&gt;docker service create&lt;/code&gt; 에서 &lt;code&gt;--mode=global&lt;/code&gt; 플래그를 사용하지 않으면 작업을 라우팅하기 위해 서비스를 실행중인 노드를 알기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="1f54de1cc9507699e1c7557ff75c9c76ba654718" translate="yes" xml:space="preserve">
          <source>In all cases, &lt;code&gt;word&lt;/code&gt; can be any string, including additional environment variables.</source>
          <target state="translated">모든 경우에, &lt;code&gt;word&lt;/code&gt; 는 추가 환경 변수를 포함하여 모든 문자열이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f0294a233b34dce74a03ef32062fef2fc078c1a" translate="yes" xml:space="preserve">
          <source>In another terminal window, list the running Docker processes with the &lt;code&gt;docker container ls&lt;/code&gt; command.</source>
          <target state="translated">다른 터미널 창에서 &lt;code&gt;docker container ls&lt;/code&gt; 명령으로 실행중인 Docker 프로세스를 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="397d4e8e3c9f798330c8497c9ec1be89c0360966" translate="yes" xml:space="preserve">
          <source>In another terminal, stop the first container. The &lt;code&gt;docker wait&lt;/code&gt; command above returns the exit code.</source>
          <target state="translated">다른 터미널에서 첫 번째 컨테이너를 중지하십시오. 위의 &lt;code&gt;docker wait&lt;/code&gt; 명령은 종료 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8a0d2d64838288d78db9307f8dc6841bd617b6a" translate="yes" xml:space="preserve">
          <source>In case of potential compromise, notary provides a CLI command for rotating keys. You can use the &lt;code&gt;notary key rotate&lt;/code&gt; command to rotate the targets or snapshot keys.</source>
          <target state="translated">잠재적 손상의 경우, notary는 키 회전을위한 CLI 명령을 제공합니다. &lt;code&gt;notary key rotate&lt;/code&gt; 명령을 사용하여 대상 또는 스냅 샷 키를 회전 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8769bfd86b393555cec09d4c89137492e1d1d22" translate="yes" xml:space="preserve">
          <source>In case the updated version of a service doesn&amp;rsquo;t function as expected, it&amp;rsquo;s possible to manually roll back to the previous version of the service using &lt;code&gt;docker service update&lt;/code&gt;&amp;rsquo;s &lt;code&gt;--rollback&lt;/code&gt; flag. This reverts the service to the configuration that was in place before the most recent &lt;code&gt;docker service update&lt;/code&gt; command.</source>
          <target state="translated">업데이트 된 버전의 서비스가 예상대로 작동하지 않는 경우 &lt;code&gt;docker service update&lt;/code&gt; 의 &lt;code&gt;--rollback&lt;/code&gt; 플래그를 사용하여 이전 버전의 서비스로 수동 롤백 할 수 있습니다 . 서비스를 가장 최근의 &lt;code&gt;docker service update&lt;/code&gt; 명령 이전에 있던 구성으로 되돌 립니다.</target>
        </trans-unit>
        <trans-unit id="3f3837fe05a8b392362b1ab9412c41f8ece6fba8" translate="yes" xml:space="preserve">
          <source>In certain cases you want your container to share the host&amp;rsquo;s process namespace, basically allowing processes within the container to see all of the processes on the system. For example, you could build a container with debugging tools like &lt;code&gt;strace&lt;/code&gt; or &lt;code&gt;gdb&lt;/code&gt;, but want to use these tools when debugging processes within the container.</source>
          <target state="translated">어떤 경우에는 기본적으로 컨테이너 내의 프로세스가 시스템의 모든 프로세스를 볼 수 있도록 컨테이너가 호스트의 프로세스 네임 스페이스를 공유하기를 원합니다. 예를 들어, &lt;code&gt;strace&lt;/code&gt; 또는 &lt;code&gt;gdb&lt;/code&gt; 와 같은 디버깅 도구를 사용하여 컨테이너를 빌드 할 수 있지만 컨테이너 내의 프로세스를 디버깅 할 때 이러한 도구를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c99314a395f4bd66ea01711ce213eb84d4a0b001" translate="yes" xml:space="preserve">
          <source>In earlier steps of the tutorial, all the nodes have been running with &lt;code&gt;ACTIVE&lt;/code&gt; availability. The swarm manager can assign tasks to any &lt;code&gt;ACTIVE&lt;/code&gt; node, so up to now all nodes have been available to receive tasks.</source>
          <target state="translated">학습서의 이전 단계에서 모든 노드는 &lt;code&gt;ACTIVE&lt;/code&gt; 가용성 으로 실행되었습니다 . 떼 관리자는 모든 &lt;code&gt;ACTIVE&lt;/code&gt; 노드에 작업을 할당 할 수 있으므로 지금까지 모든 노드가 작업을 수신 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="09d84b033f5532984826b8531fbf6f3992b119f5" translate="yes" xml:space="preserve">
          <source>In effect, the profile is a whitelist which denies access to system calls by default, then whitelists specific system calls. The profile works by defining a &lt;code&gt;defaultAction&lt;/code&gt; of &lt;code&gt;SCMP_ACT_ERRNO&lt;/code&gt; and overriding that action only for specific system calls. The effect of &lt;code&gt;SCMP_ACT_ERRNO&lt;/code&gt; is to cause a &lt;code&gt;Permission Denied&lt;/code&gt; error. Next, the profile defines a specific list of system calls which are fully allowed, because their &lt;code&gt;action&lt;/code&gt; is overridden to be &lt;code&gt;SCMP_ACT_ALLOW&lt;/code&gt;. Finally, some specific rules are for individual system calls such as &lt;code&gt;personality&lt;/code&gt;, &lt;code&gt;socket&lt;/code&gt;, &lt;code&gt;socketcall&lt;/code&gt;, and others, to allow variants of those system calls with specific arguments.</source>
          <target state="translated">사실상, 프로파일은 기본적으로 시스템 호출에 대한 액세스를 거부하는 화이트리스트이며 특정 시스템 호출을 화이트리스트에 추가합니다. 프로파일 은 &lt;code&gt;SCMP_ACT_ERRNO&lt;/code&gt; 의 &lt;code&gt;defaultAction&lt;/code&gt; 을 정의하고 특정 시스템 호출에 대해서만 해당 조치를 대체하여 작동합니다. &lt;code&gt;SCMP_ACT_ERRNO&lt;/code&gt; 의 효과는 &lt;code&gt;Permission Denied&lt;/code&gt; 오류 를 발생시키는 것 입니다. 그런 다음 프로파일은 &lt;code&gt;action&lt;/code&gt; 가 &lt;code&gt;SCMP_ACT_ALLOW&lt;/code&gt; 로 대체 되므로 완전히 허용되는 특정 시스템 호출 목록을 정의합니다 . 마지막으로, 일부 특정 규칙이 개별 시스템에있는 것은 같은 호출 &lt;code&gt;personality&lt;/code&gt; , &lt;code&gt;socket&lt;/code&gt; , &lt;code&gt;socketcall&lt;/code&gt; 특정 인수를 사용하여 해당 시스템 호출의 변형을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9a2a6e9df49f4dcc603cd9085f8046e515db061b" translate="yes" xml:space="preserve">
          <source>In either case, simply run &lt;code&gt;docker stack deploy&lt;/code&gt; again to deploy these changes.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;docker stack deploy&lt;/code&gt; 를 다시 실행 하여 이러한 변경 사항을 배포하십시오.</target>
        </trans-unit>
        <trans-unit id="76fbdb43c4133cf0999946d09f0420d3d642c42c" translate="yes" xml:space="preserve">
          <source>In foreground mode (the default when &lt;code&gt;-d&lt;/code&gt; is not specified), &lt;code&gt;docker run&lt;/code&gt; can start the process in the container and attach the console to the process&amp;rsquo;s standard input, output, and standard error. It can even pretend to be a TTY (this is what most command line executables expect) and pass along signals. All of that is configurable:</source>
          <target state="translated">포 그라운드 모드 ( &lt;code&gt;-d&lt;/code&gt; 가 지정되지 않은 경우 기본값 )에서 &lt;code&gt;docker run&lt;/code&gt; 은 컨테이너에서 프로세스를 시작하고 콘솔을 프로세스의 표준 입력, 출력 및 표준 오류에 연결할 수 있습니다. 심지어 TTY 인 척 할 수도 있으며 (이것은 대부분의 명령 행 실행 파일이 기대하는 것입니다) 신호를 전달합니다. 이 모든 것이 구성 가능합니다.</target>
        </trans-unit>
        <trans-unit id="328c1a9e0fc74c42f8074267c542e443625c2d76" translate="yes" xml:space="preserve">
          <source>In general it should be safe to enable this option by default. It will help when unintentional leaking of mount point happens across multiple mount namespaces.</source>
          <target state="translated">일반적으로이 옵션을 기본적으로 사용하는 것이 안전해야합니다. 의도하지 않은 마운트 포인트 유출이 여러 마운트 네임 스페이스에서 발생할 때 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="66943ec59ec0388ba65a3392decd34d106b0475c" translate="yes" xml:space="preserve">
          <source>In kernel x86 real mode virtual machine. Also gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;.</source>
          <target state="translated">커널 x86 리얼 모드 가상 머신. &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="2269218bfb4b3b65fa8f1ab01160feef0b7a00ec" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to put each Dockerfile in an empty directory. Then, add to that directory only the files needed for building the Dockerfile. To increase the build&amp;rsquo;s performance, you can exclude files and directories by adding a &lt;code&gt;.dockerignore&lt;/code&gt; file to that directory as well. For information on creating one, see the &lt;a href=&quot;../../builder/index#dockerignore-file&quot;&gt;.dockerignore file&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 각 Dockerfile을 빈 디렉토리에 두는 것이 가장 좋습니다. 그런 다음 Dockerfile을 빌드하는 데 필요한 파일 만 해당 디렉토리에 추가하십시오. 빌드 성능을 향상시키기 위해 해당 디렉토리에 &lt;code&gt;.dockerignore&lt;/code&gt; 파일을 추가하여 파일 및 디렉토리를 제외 할 수 있습니다. 작성에 대한 정보는 &lt;a href=&quot;../../builder/index#dockerignore-file&quot;&gt;.dockerignore 파일을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="378b863cae308a6d28e59bc80ff0e1d272905381" translate="yes" xml:space="preserve">
          <source>In most cases, you should shut down a node before removing it from a swarm with the &lt;code&gt;docker node rm&lt;/code&gt; command. If a node becomes unreachable, unresponsive, or compromised you can forcefully remove the node without shutting it down by passing the &lt;code&gt;--force&lt;/code&gt; flag. For instance, if &lt;code&gt;node9&lt;/code&gt; becomes compromised:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;docker node rm&lt;/code&gt; 명령 을 사용하여 떼에서 노드를 제거하기 전에 노드를 종료해야합니다 . 노드에 도달 할 수 없거나 응답이 없거나 손상된 경우 &lt;code&gt;--force&lt;/code&gt; 플래그 를 전달하여 노드를 종료하지 않고 강제로 제거 할 수 있습니다 . 예를 들어 &lt;code&gt;node9&lt;/code&gt; 가 손상된 경우 :</target>
        </trans-unit>
        <trans-unit id="85c6b654dcba5a7495f7617273a2693372930488" translate="yes" xml:space="preserve">
          <source>In most situations, you do not need to worry about this implementation detail and Docker Machine acts sensibly out of the box. However, if you deliberately want to use the Go native version, you can do so with a global command line flag / environment variable like so:</source>
          <target state="translated">대부분의 상황에서이 구현 세부 사항에 대해 걱정할 필요가 없으며 Docker Machine은 눈에 띄게 작동합니다. 그러나 의도적으로 Go 네이티브 버전을 사용하려는 경우 다음과 같이 전역 명령 줄 플래그 / 환경 변수를 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e386581222ebf4485d1bb8fd4d615a4d6167e328" translate="yes" xml:space="preserve">
          <source>In order to retrieve logs before a specific point in time, run:</source>
          <target state="translated">특정 시점 이전에 로그를 검색하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a3907efe6e721ea176d26de90bbf285ba22f6516" translate="yes" xml:space="preserve">
          <source>In part 3, we scale our application and enable load-balancing. To do this, we must go one level up in the hierarchy of a distributed application: the &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">3 부에서는 애플리케이션을 확장하고로드 밸런싱을 활성화합니다. 이를 위해서는 분산 응용 프로그램의 계층 구조에서 &lt;strong&gt;서비스&lt;/strong&gt; 수준을 한 단계 높여야 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d307aa39db6ae926e0502e3bbd4b356cb05892e8" translate="yes" xml:space="preserve">
          <source>In part 4 you learned what a swarm is, how nodes in swarms can be managers or workers, created a swarm, and deployed an application on it. You saw that the core Docker commands didn&amp;rsquo;t change from part 3, they just had to be targeted to run on a swarm master. You also saw the power of Docker&amp;rsquo;s networking in action, which kept load-balancing requests across containers, even though they were running on different machines. Finally, you learned how to iterate and scale your app on a cluster.</source>
          <target state="translated">4 부에서는 스웜이 무엇인지, 스웜의 노드가 관리자 또는 작업자가되는 방법, 스웜을 생성하고 애플리케이션을 배포하는 방법을 배웠습니다. 핵심 Docker 명령이 3 부에서 변경되지 않았으며, 스웜 마스터에서 실행되도록 대상을 지정해야했습니다. 또한 Docker의 네트워킹 기능이 실제로 작동하는 것을 보았습니다. 이는 다른 시스템에서 실행 중이더라도 컨테이너 전체에서로드 밸런싱 요청을 유지했습니다. 마지막으로 클러스터에서 앱을 반복하고 확장하는 방법을 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="b0f3788d7f0c9322113fa02952b76a42809054fa" translate="yes" xml:space="preserve">
          <source>In previous releases, Docker Machine was used to provision swarm clusters, but this is legacy. &lt;a href=&quot;../../engine/swarm/index&quot;&gt;Swarm mode&lt;/a&gt;, built into Docker Engine, supersedes Machine provisioning of swarm clusters. The topics below show you how to get started with the new swarm mode.</source>
          <target state="translated">이전 릴리스에서 Docker Machine은 스웜 클러스터를 프로비저닝하는 데 사용되었지만 이는 레거시입니다. Docker Engine에 내장 된 &lt;a href=&quot;../../engine/swarm/index&quot;&gt;Swarm 모드&lt;/a&gt; 는 스웜 클러스터의 시스템 프로비저닝을 대체합니다. 아래 주제는 새로운 떼 모드를 시작하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a58edf728e9381d2f0646937d62331b45e9db8ef" translate="yes" xml:space="preserve">
          <source>In some cases you don&amp;rsquo;t want images to be updated to newer versions, but prefer to use a fixed version of an image. Docker enables you to pull an image by its &lt;em&gt;digest&lt;/em&gt;. When pulling an image by digest, you specify &lt;em&gt;exactly&lt;/em&gt; which version of an image to pull. Doing so, allows you to &amp;ldquo;pin&amp;rdquo; an image to that version, and guarantee that the image you&amp;rsquo;re using is always the same.</source>
          <target state="translated">경우에 따라 이미지를 최신 버전으로 업데이트하지 않으려는 경우 고정 버전의 이미지를 사용하는 것을 선호합니다. Docker를 사용하면 &lt;em&gt;다이제스트&lt;/em&gt; 하여 이미지를 가져올 수 있습니다 . 다이제스트 하여 이미지를 가져올 때 가져올 이미지의 버전을 &lt;em&gt;정확하게&lt;/em&gt; 지정 &lt;em&gt;합니다&lt;/em&gt; . 이렇게하면 이미지를 해당 버전에 &quot;고정&quot;할 수 있으며 사용중인 이미지가 항상 동일하다는 것을 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee8d00b4d900b019b2c21facfb3122b1408652f0" translate="yes" xml:space="preserve">
          <source>In terms of Docker Swarm services, a &lt;em&gt;secret&lt;/em&gt; is a blob of data, such as a password, SSH private key, SSL certificate, or another piece of data that should not be transmitted over a network or stored unencrypted in a Dockerfile or in your application&amp;rsquo;s source code. In Docker 1.13 and higher, you can use Docker &lt;em&gt;secrets&lt;/em&gt; to centrally manage this data and securely transmit it to only those containers that need access to it. Secrets are encrypted during transit and at rest in a Docker swarm. A given secret is only accessible to those services which have been granted explicit access to it, and only while those service tasks are running.</source>
          <target state="translated">Docker Swarm 서비스 측면에서 &lt;em&gt;비밀&lt;/em&gt; 은 암호, SSH 개인 키, SSL 인증서 또는 네트워크를 통해 전송되거나 Dockerfile 또는 응용 프로그램의 암호화되지 않은 상태로 저장되어서는 안되는 다른 데이터와 같은 데이터 덩어리입니다. 소스 코드. Docker 1.13 이상에서는 Docker &lt;em&gt;비밀&lt;/em&gt; 을 사용하여이 데이터를 중앙에서 관리하고 액세스해야하는 컨테이너에만 안전하게 전송할 수 있습니다. 비밀은 운송 중 및 도커 떼에서 휴식 중에 암호화됩니다. 지정된 비밀은 명시 적으로 액세스 권한이 부여 된 서비스 및 해당 서비스 작업이 실행되는 동안에 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="507226952435217d9ad5503d958728b43e56de30" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1 file format&lt;/a&gt;, &lt;code&gt;dockerfile&lt;/code&gt; is different from newer versions in two ways:</source>
          <target state="translated">에서 &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;버전 1 파일 형식&lt;/a&gt; , &lt;code&gt;dockerfile&lt;/code&gt; 는 두 가지 방법으로 최신 버전 다릅니다 :</target>
        </trans-unit>
        <trans-unit id="617c4d86c7c6707dcb58c380e63ae534c6469e0f" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;shell&lt;/em&gt; form you can use a &lt;code&gt;\&lt;/code&gt; (backslash) to continue a single RUN instruction onto the next line. For example, consider these two lines:</source>
          <target state="translated">에서 &lt;em&gt;쉘&lt;/em&gt; 형태 당신은 사용할 수 있습니다 &lt;code&gt;\&lt;/code&gt; 다음 줄에 하나의 RUN 명령을 계속 (백 슬래시). 예를 들어 다음 두 줄을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6e1cd2a54fc03f9bec9112614a8823eae429f7cf" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;replicated services&lt;/strong&gt; model, the swarm manager distributes a specific number of replica tasks among the nodes based upon the scale you set in the desired state.</source>
          <target state="translated">에서 &lt;strong&gt;복제 된 서비스&lt;/strong&gt; 모델, 떼 관리자가 원하는 상태로 설정 규모에 따라 노드 간의 복제 작업의 특정 번호를 배포합니다.</target>
        </trans-unit>
        <trans-unit id="86d260fe838f26c03b73ffb1cd6384d7745e98e0" translate="yes" xml:space="preserve">
          <source>In the above example, Compose waits for the &lt;code&gt;redis&lt;/code&gt; service to be started (legacy behavior) and the &lt;code&gt;db&lt;/code&gt; service to be healthy before starting &lt;code&gt;web&lt;/code&gt;.</source>
          <target state="translated">위의 예제에서 Compose는 &lt;code&gt;web&lt;/code&gt; 을 시작하기 전에 &lt;code&gt;redis&lt;/code&gt; 서비스가 시작될 때까지 (레거시 동작) &lt;code&gt;db&lt;/code&gt; 서비스가 정상 상태 가되도록 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="8630f97bf74475504907a6046ff76d49b8663460" translate="yes" xml:space="preserve">
          <source>In the above example, you can see &lt;code&gt;profile=/usr/bin/docker&lt;/code&gt;. This means the user has the &lt;code&gt;docker-engine&lt;/code&gt; (Docker Engine Daemon) profile loaded.</source>
          <target state="translated">위의 예에서 &lt;code&gt;profile=/usr/bin/docker&lt;/code&gt; 를 볼 수 있습니다 . 이는 사용자에게 &lt;code&gt;docker-engine&lt;/code&gt; (Docker Engine Daemon) 프로파일이로드 되었음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d1388cf0b4c63993bf69879f326b2f346a2c870c" translate="yes" xml:space="preserve">
          <source>In the absence of having named volumes with specified sources, Docker creates an anonymous volume for each task backing a service. Anonymous volumes do not persist after the associated containers are removed.</source>
          <target state="translated">지정된 소스가있는 명명 된 볼륨이없는 경우 Docker는 서비스를 지원하는 각 작업에 대해 익명의 볼륨을 만듭니다. 연결된 컨테이너를 제거한 후에도 익명 볼륨이 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3666264801bda2584f25182aad55b37381fde40" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;image&lt;/code&gt;, when using &lt;a href=&quot;../compose-file/compose-file-v1/index&quot;&gt;version 1 of the Compose file format&lt;/a&gt;, using one option in the local service causes Compose to discard the other option if it was defined in the original service.</source>
          <target state="translated">의 경우 &lt;code&gt;build&lt;/code&gt; 및 &lt;code&gt;image&lt;/code&gt; 사용하여 &lt;a href=&quot;../compose-file/compose-file-v1/index&quot;&gt;파일 작성 형식의 버전 1을&lt;/a&gt; 로컬 서비스에서 하나의 옵션을 사용하여, 그것은 원래의 서비스에 정의 된 경우 다른 옵션을 폐기하기 위해 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3c908a9bc6e29241e4f6989c0dbca5cc7172d063" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;environment&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;volumes&lt;/code&gt;, and &lt;code&gt;devices&lt;/code&gt;, Compose &amp;ldquo;merges&amp;rdquo; entries together with locally-defined values taking precedence. For &lt;code&gt;environment&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;, the environment variable or label name determines which value is used:</source>
          <target state="translated">의 경우 &lt;code&gt;environment&lt;/code&gt; , &lt;code&gt;labels&lt;/code&gt; , &lt;code&gt;volumes&lt;/code&gt; 및 &lt;code&gt;devices&lt;/code&gt; 함께 국부적으로 정의 된 값이 우선 복용 작성 &quot;병합&quot;항목. 용 &lt;code&gt;environment&lt;/code&gt; 및 &lt;code&gt;labels&lt;/code&gt; , 값이 사용되는 환경 변수 나 라벨 이름 결정</target>
        </trans-unit>
        <trans-unit id="056d637af8dd63924b6d7ac728a513f46ff71c60" translate="yes" xml:space="preserve">
          <source>In the case of a swarm with auto-lock enabled, the unlock key is also the same as on the old swarm, and the unlock key is needed to restore the swarm.</source>
          <target state="translated">자동 잠금이 활성화 된 스웜의 경우 잠금 해제 키는 이전 스웜과 동일하며 스웜을 복원하려면 잠금 해제 키가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7fc0bdad15628feea9a6df5058ced71dea1df4a5" translate="yes" xml:space="preserve">
          <source>In the case of transferring files from machine to machine, they go through the local host&amp;rsquo;s filesystem first (using &lt;code&gt;scp&lt;/code&gt;&amp;rsquo;s &lt;code&gt;-3&lt;/code&gt; flag).</source>
          <target state="translated">기계에서 기계로 파일을 전송하는 경우, 먼저 로컬 호스트의 파일 시스템을 통과합니다 ( &lt;code&gt;scp&lt;/code&gt; 의 &lt;code&gt;-3&lt;/code&gt; 플래그 사용).</target>
        </trans-unit>
        <trans-unit id="dca635a5cd29a93950b84c34f242179e70411fcd" translate="yes" xml:space="preserve">
          <source>In the case that the timestamp has expired, Notary server would go through the entire sequence where it generates a new timestamp, request Notary signer for a signature, stores the newly signed timestamp in the database. It then sends this new timestamp, along with the rest of the stored metadata, to the requesting client.</source>
          <target state="translated">In the case that the timestamp has expired, Notary server would go through the entire sequence where it generates a new timestamp, request Notary signer for a signature, stores the newly signed timestamp in the database. It then sends this new timestamp, along with the rest of the stored metadata, to the requesting client.</target>
        </trans-unit>
        <trans-unit id="e8faee6b24d09276001dcffa82ee5fbc5a5e07c5" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a remote file URL, the destination will have permissions of 600. If the remote file being retrieved has an HTTP &lt;code&gt;Last-Modified&lt;/code&gt; header, the timestamp from that header will be used to set the &lt;code&gt;mtime&lt;/code&gt; on the destination file. However, like any other file processed during an &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt; will not be included in the determination of whether or not the file has changed and the cache should be updated.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 원격 파일을 검색하는 HTTP가되는 경우 원격 파일의 URL이며, 대상은 600의 권한을 갖게됩니다 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더를 그 헤더에서 타임 스탬프는 설정하는 데 사용됩니다 &lt;code&gt;mtime&lt;/code&gt; 대상에 파일. 그러나, 처리 중에있는 다른 파일과 마찬가지로 &lt;code&gt;ADD&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; 파일이 변경되어, 캐시가 갱신되어야하는지 여부의 판정에 포함되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="8298e779355193cf9653abc4e5dcf542c129a056" translate="yes" xml:space="preserve">
          <source>In the current directory, create a new file called &lt;code&gt;site.conf&lt;/code&gt; with the following contents:</source>
          <target state="translated">현재 디렉토리 에서 다음 내용으로 &lt;code&gt;site.conf&lt;/code&gt; 라는 새 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f13078e3c70b9c6c2fe808659a7b8f6d23c16c10" translate="yes" xml:space="preserve">
          <source>In the daemon mode, it only allows connections from clients authenticated by a certificate signed by that CA. In the client mode, it only connects to servers with a certificate signed by that CA.</source>
          <target state="translated">데몬 모드에서는 해당 CA가 서명 한 인증서로 인증 된 클라이언트의 연결 만 허용합니다. 클라이언트 모드에서는 해당 CA가 서명 한 인증서가있는 서버에만 연결합니다.</target>
        </trans-unit>
        <trans-unit id="e79df26f0e1d382e5807005f023a1896be147523" translate="yes" xml:space="preserve">
          <source>In the diagram, a load balancer routes external traffic to a cluster of Notary server instances. These may make requests to Notary signer instances if either a) signing is required, or b) key generation is required. The requests from a Notary server to a Notary signer cluster are router via an internal load balancer.</source>
          <target state="translated">다이어그램에서로드 밸런서는 외부 트래픽을 Notary 서버 인스턴스의 클러스터로 라우팅합니다. a) 서명이 필요하거나 b) 키 생성이 필요한 경우 공증 서명자 인스턴스에 요청할 수 있습니다. Notary 서버에서 Notary 서명자 클러스터로의 요청은 내부로드 밸런서를 통해 라우터입니다.</target>
        </trans-unit>
        <trans-unit id="203428b275a1dd679990a617c7094b310a197f02" translate="yes" xml:space="preserve">
          <source>In the event of a Notary server compromise, an attacker would have direct access to the metadata stored in the database as well as access to the credentials used to communicate with Notary signer, and therefore, access to arbitrary signing operations with any key the Signer holds.</source>
          <target state="translated">Notary 서버가 손상된 경우 공격자는 데이터베이스에 저장된 메타 데이터에 직접 액세스 할 수있을뿐만 아니라 Notary 서명자와 통신하는 데 사용되는 자격 증명에 액세스 할 수 있으므로 서명자가 보유한 모든 키를 사용하여 임의 서명 작업에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="584928d6a70946abedcb4d46cd0ca87b63ecd8f7" translate="yes" xml:space="preserve">
          <source>In the event of a Notary signer compromise, an attacker would have access to all the (timestamp and snapshot) private keys stored in a database. If the keys are stored in an HSM, they would have the ability to sign arbitrary content with, and to delete, the keys in the HSM, but not to exfiltrate the private material.</source>
          <target state="translated">공증인 서명자가 손상된 경우 공격자는 데이터베이스에 저장된 모든 (타임 스탬프 및 스냅 샷) 개인 키에 액세스 할 수 있습니다. 키가 HSM에 저장된 경우 HSM의 키를 사용하여 임의의 내용에 서명하고 삭제할 수 있지만 개인 자료를 유출하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae477ddd4679f740376181461aeaf86fba22dc34" translate="yes" xml:space="preserve">
          <source>In the event that a cluster CA key or a manager node is compromised, you can rotate the swarm root CA so that none of the nodes trust certificates signed by the old root CA anymore.</source>
          <target state="translated">클러스터 CA 키 또는 관리자 노드가 손상된 경우 더 이상 이전 루트 CA가 서명 한 인증서를 신뢰하는 노드가 없도록 루트 루트 CA를 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9db1d9b06548381c6b977604d97c79541ef06739" translate="yes" xml:space="preserve">
          <source>In the example above, the first element of the list is the address of your DNS server. The second item is Google&amp;rsquo;s DNS which can be used when the first one is not available.</source>
          <target state="translated">위의 예에서 목록의 첫 번째 요소는 DNS 서버의 주소입니다. 두 번째 항목은 첫 번째 항목을 사용할 수 없을 때 사용할 수있는 Google의 DNS입니다.</target>
        </trans-unit>
        <trans-unit id="147494a044cf1de1427dc854afcb1df23af2a787" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;proxy&lt;/code&gt; is the gateway to the outside world. Instead of attempting to create a network called &lt;code&gt;[projectname]_outside&lt;/code&gt;, Compose looks for an existing network simply called &lt;code&gt;outside&lt;/code&gt; and connect the &lt;code&gt;proxy&lt;/code&gt; service&amp;rsquo;s containers to it.</source>
          <target state="translated">아래 예에서 &lt;code&gt;proxy&lt;/code&gt; 는 외부 세계로가는 관문입니다. Compose는 &lt;code&gt;[projectname]_outside&lt;/code&gt; 라는 네트워크를 작성하는 대신 단순히 &lt;code&gt;outside&lt;/code&gt; 호출 된 기존 네트워크를 찾아 &lt;code&gt;proxy&lt;/code&gt; 서비스의 컨테이너를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="6a170437927d9d5f3bae3654145156920ae00944" translate="yes" xml:space="preserve">
          <source>In the example below, instead of attempting to create a volume called &lt;code&gt;[projectname]_data&lt;/code&gt;, Compose looks for an existing volume simply called &lt;code&gt;data&lt;/code&gt; and mount it into the &lt;code&gt;db&lt;/code&gt; service&amp;rsquo;s containers.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;[projectname]_data&lt;/code&gt; 라는 볼륨을 작성하는 대신 , Compose는 단순히 &lt;code&gt;data&lt;/code&gt; 라는 기존 볼륨을 찾아서 이를 &lt;code&gt;db&lt;/code&gt; 서비스 컨테이너에 마운트합니다 .</target>
        </trans-unit>
        <trans-unit id="f311f13a2361ce02003febab38bddb325d7b6618" translate="yes" xml:space="preserve">
          <source>In the example below, three services are provided (&lt;code&gt;web&lt;/code&gt;, &lt;code&gt;worker&lt;/code&gt;, and &lt;code&gt;db&lt;/code&gt;), along with two networks (&lt;code&gt;new&lt;/code&gt; and &lt;code&gt;legacy&lt;/code&gt;). The &lt;code&gt;db&lt;/code&gt; service is reachable at the hostname &lt;code&gt;db&lt;/code&gt; or &lt;code&gt;database&lt;/code&gt; on the &lt;code&gt;new&lt;/code&gt; network, and at &lt;code&gt;db&lt;/code&gt; or &lt;code&gt;mysql&lt;/code&gt; on the &lt;code&gt;legacy&lt;/code&gt; network.</source>
          <target state="translated">아래 예 에서 두 개의 네트워크 ( &lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;legacy&lt;/code&gt; ) 와 함께 세 개의 서비스 ( &lt;code&gt;web&lt;/code&gt; , &lt;code&gt;worker&lt;/code&gt; 및 &lt;code&gt;db&lt;/code&gt; ) 가 제공됩니다 . &lt;code&gt;db&lt;/code&gt; 서비스는 호스트 이름에 도달 &lt;code&gt;db&lt;/code&gt; 또는 &lt;code&gt;database&lt;/code&gt; 상의 &lt;code&gt;new&lt;/code&gt; 네트워크 및에서 &lt;code&gt;db&lt;/code&gt; 또는 &lt;code&gt;mysql&lt;/code&gt; 을 온 &lt;code&gt;legacy&lt;/code&gt; 네트워크.</target>
        </trans-unit>
        <trans-unit id="d32dda3d107bb1d450698a419c41f95e8b7cbb8f" translate="yes" xml:space="preserve">
          <source>In the example below, we set the same environment variable on an Environment file, and the Compose file:</source>
          <target state="translated">아래 예에서는 환경 파일과 작성 파일에 동일한 환경 변수를 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="c38d3675cdf10575b32c2936885a42e5a7571c4f" translate="yes" xml:space="preserve">
          <source>In the example service below, the scheduler applies updates to a maximum of 2 replicas at a time. When an updated task returns either &lt;code&gt;RUNNING&lt;/code&gt; or &lt;code&gt;FAILED&lt;/code&gt;, the scheduler waits 10 seconds before stopping the next task to update:</source>
          <target state="translated">아래 예제 서비스에서 스케줄러는 한 번에 최대 2 개의 복제본에 업데이트를 적용합니다. 업데이트 된 작업이 &lt;code&gt;RUNNING&lt;/code&gt; 또는 &lt;code&gt;FAILED&lt;/code&gt; 를 반환 하면 스케줄러는 10 초 동안 기다렸다가 다음 작업 업데이트를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="2078037af746f3b5511d54697e143b860fb9ed4b" translate="yes" xml:space="preserve">
          <source>In the following example the desired state is &lt;code&gt;5&lt;/code&gt; replicas, but the current number of &lt;code&gt;RUNNING&lt;/code&gt; tasks is &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">다음 예에서 원하는 상태는 &lt;code&gt;5&lt;/code&gt; 개의 복제본이지만 현재 &lt;code&gt;RUNNING&lt;/code&gt; 작업 수는 &lt;code&gt;3&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a844e667f5555543f0a22ea7cde32ed9a981daa9" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;app&lt;/code&gt; service connects to &lt;code&gt;app_net_1&lt;/code&gt; first as it has the highest priority. It then connects to &lt;code&gt;app_net_3&lt;/code&gt;, then &lt;code&gt;app_net_2&lt;/code&gt;, which uses the default priority value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">다음 예에서 &lt;code&gt;app&lt;/code&gt; 서비스는 우선 순위가 가장 높 &lt;code&gt;app_net_1&lt;/code&gt; 먼저 app_net_1에 연결합니다 . 그런 다음 &lt;code&gt;app_net_3&lt;/code&gt; 에 연결 한 다음 &lt;code&gt;app_net_2&lt;/code&gt; 에 연결 하며 기본 우선 순위 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9fdc0122add53ba9a33cbc1a5aa0321850cb0dcd" translate="yes" xml:space="preserve">
          <source>In the following example, you install the &lt;code&gt;sshfs&lt;/code&gt; plugin, verify that it is enabled, and use it to create a volume.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;sshfs&lt;/code&gt; 플러그인 을 설치 하고 사용 가능한지 확인한 후이를 사용하여 볼륨을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="13d30425c671944d6f19dd2632c40dd1bc5f88aa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, moving from version 1 to 2 is a very simple process:</source>
          <target state="translated">대부분의 경우 버전 1에서 2로 이동하는 것은 매우 간단한 과정입니다.</target>
        </trans-unit>
        <trans-unit id="76ef7b93da79d41a3b4613504221f85f964bb68d" translate="yes" xml:space="preserve">
          <source>In the next section of the tutorial, we &lt;a href=&quot;../add-nodes/index&quot;&gt;add two more nodes&lt;/a&gt; to the cluster.</source>
          <target state="translated">학습서의 다음 섹션에서는 클러스터에 &lt;a href=&quot;../add-nodes/index&quot;&gt;두 개의 노드&lt;/a&gt; 를 더 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="10e97313f58911e0d3ece76845a49a34aae95c4e" translate="yes" xml:space="preserve">
          <source>In the next step of the tutorial, you set up a new service and apply a &lt;a href=&quot;../rolling-update/index&quot;&gt;rolling update&lt;/a&gt;.</source>
          <target state="translated">학습서의 다음 단계에서는 새 서비스를 설정하고 &lt;a href=&quot;../rolling-update/index&quot;&gt;지속적 업데이트를&lt;/a&gt; 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="e04dbff675eb7be8581333ad553b4879f552834f" translate="yes" xml:space="preserve">
          <source>In the past, if you were to start writing a Python app, your first order of business was to install a Python runtime onto your machine. But, that creates a situation where the environment on your machine needs to be perfect for your app to run as expected, and also needs to match your production environment.</source>
          <target state="translated">과거에는 Python 앱을 작성하기 시작한 첫 번째 업무 순서는 컴퓨터에 Python 런타임을 설치하는 것이 었습니다. 그러나 이는 머신의 환경이 앱이 예상대로 실행되기에 완벽해야하고 프로덕션 환경과 일치해야하는 상황을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="df0651f4ce318c2881695ad1dbdea4f39debd34f" translate="yes" xml:space="preserve">
          <source>In the preceding example, the output message indicates that only the removal was staged. When performing any write operations they are staged into a change list. This list is applied to the latest version of the trust repository the next time a &lt;code&gt;notary publish&lt;/code&gt; is run for that repository.</source>
          <target state="translated">위의 예에서 출력 메시지는 제거 만 준비되었음을 나타냅니다. 쓰기 작업을 수행 할 때 변경 목록으로 단계 화됩니다. 이 목록은 다음 에 해당 저장소에 대해 &lt;code&gt;notary publish&lt;/code&gt; 가 실행될 때 최신 버전의 신뢰 저장소에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6baf9022b9d9af166711c3e20e9108f81d24bf1d" translate="yes" xml:space="preserve">
          <source>In the preceding example, you add the target &lt;code&gt;delegation/path/target&lt;/code&gt; to collection &lt;code&gt;example/collections&lt;/code&gt; staged for next publish. The file &lt;code&gt;delegation_file.txt&lt;/code&gt; is a target &lt;code&gt;delegation/path/target&lt;/code&gt; using the delegation role &lt;code&gt;targets/releases&lt;/code&gt;. This target&amp;rsquo;s path is valid because it is prefixed by the delegation role&amp;rsquo;s valid path.</source>
          <target state="translated">앞의 예제에서 다음 &lt;code&gt;delegation/path/target&lt;/code&gt; 위해 준비된 컬렉션 &lt;code&gt;example/collections&lt;/code&gt; 대상 위임 / 경로 / 대상 을 추가합니다 . &lt;code&gt;delegation_file.txt&lt;/code&gt; 파일 은 위임 역할 &lt;code&gt;targets/releases&lt;/code&gt; 를 사용 하는 대상 &lt;code&gt;delegation/path/target&lt;/code&gt; 입니다. 이 대상의 경로는 위임 역할의 유효한 경로가 앞에 붙어 있기 때문에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="2855fcdbca29020ccdc5f7418ce34b4a2e312c8b" translate="yes" xml:space="preserve">
          <source>In the same way that you can use &lt;a href=&quot;../../../compose/index&quot;&gt;Docker Compose&lt;/a&gt; to define and run containers, you can define and run swarm service &lt;a href=&quot;../../../get-started/part5/index&quot;&gt;stacks&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../compose/index&quot;&gt;Docker Compose&lt;/a&gt; 를 사용하여 컨테이너를 정의하고 실행할 수있는 것과 같은 방식으로 swarm 서비스 &lt;a href=&quot;../../../get-started/part5/index&quot;&gt;스택을&lt;/a&gt; 정의하고 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="351aa025091a0cdcd01e6ea8bd674f7fd1f9a939" translate="yes" xml:space="preserve">
          <source>In the tutorial, the following command creates a swarm on the &lt;code&gt;manager1&lt;/code&gt; machine:</source>
          <target state="translated">학습서에서 다음 명령은 &lt;code&gt;manager1&lt;/code&gt; 시스템 에 스웜을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="cbd3501137e7a8a17b04eeebf7fb1330cdbb79c2" translate="yes" xml:space="preserve">
          <source>In this case the swarm manager distributed one task to each node. You may see the tasks distributed differently among the nodes in your environment.</source>
          <target state="translated">이 경우 스웜 관리자는 하나의 작업을 각 노드에 배포했습니다. 작업이 사용자 환경의 노드간에 다르게 분산되어 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="885671909abfab36e907973d71986da7b3a89fc5" translate="yes" xml:space="preserve">
          <source>In this case, if you use &lt;code&gt;-P&lt;/code&gt; with &lt;code&gt;docker run&lt;/code&gt;, the port will be exposed once for TCP and once for UDP. Remember that &lt;code&gt;-P&lt;/code&gt; uses an ephemeral high-ordered host port on the host, so the port will not be the same for TCP and UDP.</source>
          <target state="translated">이 경우 &lt;code&gt;docker run&lt;/code&gt; 과 함께 &lt;code&gt;-P&lt;/code&gt; 를 사용 하면 TCP에 대해 한 번, UDP에 대해 한 번 노출됩니다. 기억 &lt;code&gt;-P&lt;/code&gt; 는 포트가 TCP 및 UDP에 대해 동일하지 않도록, 호스트에서 임시 고 주문 호스트 포트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="681476db3d02fb5fb9004193c3422e6779b3f23f" translate="yes" xml:space="preserve">
          <source>In this case, port 8080 must be open between the load balancer and the nodes in the swarm. The swarm nodes can reside on a private network that is accessible to the proxy server, but that is not publicly accessible.</source>
          <target state="translated">이 경우로드 밸런서와 스웜의 노드 사이에 포트 8080이 열려 있어야합니다. 웜 노드는 프록시 서버에서 액세스 할 수 있지만 공개적으로 액세스 할 수없는 개인 네트워크에 상주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4bce5c124cacb5eabda1e12fb3fbc378c4803ef" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;RUN&lt;/code&gt; instruction uses &lt;code&gt;v1.0.0&lt;/code&gt; instead of the &lt;code&gt;ARG&lt;/code&gt; setting passed by the user:&lt;code&gt;v2.0.1&lt;/code&gt; This behavior is similar to a shell script where a locally scoped variable overrides the variables passed as arguments or inherited from environment, from its point of definition.</source>
          <target state="translated">이 경우 &lt;code&gt;RUN&lt;/code&gt; 명령어는 사용자가 전달한 &lt;code&gt;ARG&lt;/code&gt; 설정 대신 &lt;code&gt;v1.0.0&lt;/code&gt; 을 사용 합니다. &lt;code&gt;v2.0.1&lt;/code&gt; 이 동작은 로컬 범위 변수가 인수로 전달되거나 환경에서 상속 된 변수를 해당 변수에서 재정의하는 쉘 스크립트와 유사합니다. 정의의 포인트.</target>
        </trans-unit>
        <trans-unit id="04b8f8d7e71a2768e939aebb67d5d123e9d6b5a4" translate="yes" xml:space="preserve">
          <source>In this case, the one instance of the &lt;code&gt;helloworld&lt;/code&gt; service is running on the &lt;code&gt;worker2&lt;/code&gt; node. You may see the service running on your manager node. By default, manager nodes in a swarm can execute tasks just like worker nodes.</source>
          <target state="translated">이 경우 &lt;code&gt;helloworld&lt;/code&gt; 서비스 의 한 인스턴스가 &lt;code&gt;worker2&lt;/code&gt; 노드 에서 실행 중입니다 . 관리자 노드에서 서비스가 실행중인 것을 볼 수 있습니다. 기본적으로 swarm의 관리자 노드는 작업자 노드와 같은 작업을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b042a5859ac6aa3fc44a52b490ab31dabfbe8b7f" translate="yes" xml:space="preserve">
          <source>In this case, the value of the &lt;code&gt;HTTP_PROXY&lt;/code&gt; variable is not available in the &lt;code&gt;docker history&lt;/code&gt; and is not cached. If you were to change location, and your proxy server changed to &lt;code&gt;http://user:pass@proxy.sfo.example.com&lt;/code&gt;, a subsequent build does not result in a cache miss.</source>
          <target state="translated">이 경우 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 변수 의 값은 &lt;code&gt;docker history&lt;/code&gt; 에서 사용할 수 없으며 캐시되지 않습니다. 위치를 변경하고 프록시 서버가 &lt;code&gt;http://user:pass@proxy.sfo.example.com&lt;/code&gt; 으로 변경된 경우 후속 빌드로 인해 캐시 누락이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63a41cf88ca98b159f7ae72d0d8e89186d2f2533" translate="yes" xml:space="preserve">
          <source>In this case, you get exactly the same result as if you wrote &lt;code&gt;docker-compose.yml&lt;/code&gt; with the same &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;ports&lt;/code&gt; and &lt;code&gt;volumes&lt;/code&gt; configuration values defined directly under &lt;code&gt;web&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;web&lt;/code&gt; 에 직접 정의 된 동일한 &lt;code&gt;build&lt;/code&gt; , &lt;code&gt;ports&lt;/code&gt; 및 &lt;code&gt;volumes&lt;/code&gt; 구성 값을 사용하여 &lt;code&gt;docker-compose.yml&lt;/code&gt; 을 작성한 것과 정확히 동일한 결과를 얻 습니다 .</target>
        </trans-unit>
        <trans-unit id="1bf4fa7b247577339bd1aa1ea3fcf49ef5e5ef69" translate="yes" xml:space="preserve">
          <source>In this example the development configuration exposes some ports to the host, mounts our code as a volume, and builds the web image.</source>
          <target state="translated">이 예제에서 개발 구성은 일부 포트를 호스트에 노출시키고 코드를 볼륨으로 마운트하고 웹 이미지를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="77f7cabb1f5d68f67a48a2498e604f9ab8a5b519" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;docker network create -d overlay net1&lt;/code&gt; will result in &lt;code&gt;10.20.0.0/26&lt;/code&gt; as the allocated subnet for &lt;code&gt;net1&lt;/code&gt;, and &lt;code&gt;docker network create -d overlay net2&lt;/code&gt; will result in &lt;code&gt;10.20.0.64/26&lt;/code&gt; as the allocated subnet for &lt;code&gt;net2&lt;/code&gt;. This continues until all the subnets are exhausted.</source>
          <target state="translated">이 예에서, &lt;code&gt;docker network create -d overlay net1&lt;/code&gt; 될 것이다 &lt;code&gt;10.20.0.0/26&lt;/code&gt; 대한 할당 된 서브넷 &lt;code&gt;net1&lt;/code&gt; 및 &lt;code&gt;docker network create -d overlay net2&lt;/code&gt; 될 것이다 &lt;code&gt;10.20.0.64/26&lt;/code&gt; 대한 할당 된 서브넷 &lt;code&gt;net2&lt;/code&gt; . 이것은 모든 서브넷이 소진 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="1a7aa9b0581ea4db874d745eaac8bdb2d12de04e" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;my_first_config&lt;/code&gt; is created (as &lt;code&gt;&amp;lt;stack_name&amp;gt;_my_first_config)&lt;/code&gt;when the stack is deployed, and &lt;code&gt;my_second_config&lt;/code&gt; already exists in Docker.</source>
          <target state="translated">이 예 에서 스택이 배포되면 &lt;code&gt;my_first_config&lt;/code&gt; 가 &lt;code&gt;&amp;lt;stack_name&amp;gt;_my_first_config)&lt;/code&gt; 로 생성 되고 &lt;code&gt;my_second_config&lt;/code&gt; 가 Docker에 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c6e46cc9d2790dae9bf0dce4483be5182c8915a6" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;my_first_secret&lt;/code&gt; is created as &lt;code&gt;&amp;lt;stack_name&amp;gt;_my_first_secret&lt;/code&gt;when the stack is deployed, and &lt;code&gt;my_second_secret&lt;/code&gt; already exists in Docker.</source>
          <target state="translated">이 예에서, &lt;code&gt;my_first_secret&lt;/code&gt; 은 으로 만들어 &lt;code&gt;&amp;lt;stack_name&amp;gt;_my_first_secret&lt;/code&gt; 스택이 전개 한 경우 &lt;code&gt;my_second_secret&lt;/code&gt; 이미 고정 표시기 존재한다.</target>
        </trans-unit>
        <trans-unit id="3eace086f1ca89f50b54dac824927afa2f9323f2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;redis&lt;/code&gt; is the hostname of the redis container on the application&amp;rsquo;s network. We use the default port for Redis, &lt;code&gt;6379&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;redis&lt;/code&gt; 는 애플리케이션 네트워크에서 redis 컨테이너의 호스트 이름입니다. Redis의 기본 포트 인 &lt;code&gt;6379&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a64f4b6a3a18589a29af7aac8d8c901a16324a7b" translate="yes" xml:space="preserve">
          <source>In this example, no machines have been created yet.</source>
          <target state="translated">이 예에서는 아직 머신이 생성되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="16c0e88b2ca9ba5b32edd4b9a8e590e8219b6624" translate="yes" xml:space="preserve">
          <source>In this example, no name (&lt;code&gt;source&lt;/code&gt;) is specified for the volume, so a new volume is created for each task. This guarantees that each task gets its own volume, and volumes are not shared between tasks. Anonymous volumes are removed after the task using them is complete.</source>
          <target state="translated">이 예에서는 볼륨에 이름 ( &lt;code&gt;source&lt;/code&gt; )이 지정 되지 않으므로 각 작업에 대해 새 볼륨이 작성됩니다. 이를 통해 각 작업이 자체 볼륨을 가져오고 작업간에 볼륨이 공유되지 않습니다. 익명 볼륨은 사용하는 작업이 완료된 후에 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1ae7aee7afc304948b7f799a25e01d795de66f10" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;--force&lt;/code&gt; flag causes the service&amp;rsquo;s tasks to be shut down and replaced with new ones even though none of the other parameters would normally cause that to happen. The &lt;code&gt;--update-parallelism 1&lt;/code&gt; setting ensures that only one task is replaced at a time (this is the default behavior). The &lt;code&gt;--update-delay 30s&lt;/code&gt; setting introduces a 30 second delay between tasks, so that the rolling restart happens gradually.</source>
          <target state="translated">이 예제에서 &lt;code&gt;--force&lt;/code&gt; 플래그를 사용하면 다른 매개 변수 중 어느 것도 해당 작업을 수행하지 않아도 서비스 작업이 종료되고 새 작업으로 대체됩니다. &lt;code&gt;--update-parallelism 1&lt;/code&gt; 하나의 작업을 한 번에 교체 설정 보장하지만 (기본 동작입니다). &lt;code&gt;--update-delay 30s&lt;/code&gt; 롤링 재시작 서서히 발생되도록 도입 작업을 30 초 사이의 지연을 설정.</target>
        </trans-unit>
        <trans-unit id="4a2aae167f8906f5c5dd31f4d7a7a1e24832b8cc" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;-p&lt;/code&gt; option is used to expose port 80 from the &lt;code&gt;nginx&lt;/code&gt; container and make it accessible on port &lt;code&gt;8000&lt;/code&gt; of the &lt;code&gt;aws-sandbox&lt;/code&gt; host:</source>
          <target state="translated">이 예에서 &lt;code&gt;-p&lt;/code&gt; 옵션은 &lt;code&gt;nginx&lt;/code&gt; 컨테이너 에서 포트 80을 노출 하고 &lt;code&gt;aws-sandbox&lt;/code&gt; 호스트 의 포트 &lt;code&gt;8000&lt;/code&gt; 에서 액세스 할 수 있도록하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb10920162c6d6f5c2df646d27ac2d85f3e91a9d" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;-p&lt;/code&gt; option is used to expose port 80 from the &lt;code&gt;nginx&lt;/code&gt; container and make it accessible on port &lt;code&gt;8000&lt;/code&gt; of the &lt;code&gt;docker-sandbox&lt;/code&gt; host.</source>
          <target state="translated">이 예에서 &lt;code&gt;-p&lt;/code&gt; 옵션은 &lt;code&gt;nginx&lt;/code&gt; 컨테이너 에서 포트 80을 노출 하고 &lt;code&gt;docker-sandbox&lt;/code&gt; 호스트 의 포트 &lt;code&gt;8000&lt;/code&gt; 에서 액세스 할 수 있도록하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a2f6aee03314df6720abb574ea68b1288eba9be" translate="yes" xml:space="preserve">
          <source>In this example, the cache miss occurs on line 3. The miss happens because the variable&amp;rsquo;s value in the &lt;code&gt;ENV&lt;/code&gt; references the &lt;code&gt;ARG&lt;/code&gt; variable and that variable is changed through the command line. In this example, the &lt;code&gt;ENV&lt;/code&gt; command causes the image to include the value.</source>
          <target state="translated">이 예제에서 캐시 누락은 3 행에서 발생합니다. 누락은 &lt;code&gt;ENV&lt;/code&gt; 의 변수 값 이 &lt;code&gt;ARG&lt;/code&gt; 변수를 참조 하고 해당 변수가 명령 행을 통해 변경 되기 때문에 발생 합니다. 이 예에서 &lt;code&gt;ENV&lt;/code&gt; 명령은 이미지에 값을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="82c0846c089d798f7a73aa56f8e6fd674b771a54" translate="yes" xml:space="preserve">
          <source>In this example, the volume for &lt;code&gt;/foo&lt;/code&gt; will remain intact, but the volume for &lt;code&gt;/bar&lt;/code&gt; will be removed. The same behavior holds for volumes inherited with &lt;code&gt;--volumes-from&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;/foo&lt;/code&gt; 의 볼륨 은 그대로 유지되지만 &lt;code&gt;/bar&lt;/code&gt; 의 볼륨은 제거됩니다. &lt;code&gt;--volumes-from&lt;/code&gt; 으로 상속 된 볼륨에 대해서도 동일한 동작이 유지 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9b3a1700297305cec2686aa0056d2242ac4541c" translate="yes" xml:space="preserve">
          <source>In this example, we are going to set the template of the created containers based on the service&amp;rsquo;s name, the node&amp;rsquo;s ID and hostname where it sits.</source>
          <target state="translated">이 예제에서는 서비스 이름, 노드의 ID 및 호스트 이름을 기반으로 작성된 컨테이너의 템플리트를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="793f6048a0a8601a7988fbea6a9c962d11ef9005" translate="yes" xml:space="preserve">
          <source>In this example, with the &lt;code&gt;0.1&lt;/code&gt; value, it returns an empty set because no matches were found.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;0.1&lt;/code&gt; 값을 사용하면 일치하는 항목이 없으므로 빈 세트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4751cc96481650529711b0f850cbb1809a65d7d7" translate="yes" xml:space="preserve">
          <source>In this example, you create a custom AppArmor profile for Nginx. Below is the custom profile.</source>
          <target state="translated">이 예에서는 Nginx에 대한 사용자 정의 AppArmor 프로파일을 작성합니다. 아래는 커스텀 프로파일입니다.</target>
        </trans-unit>
        <trans-unit id="bc9be972bc2f18d8f6311822a2ad04b8986c88dd" translate="yes" xml:space="preserve">
          <source>In this example, you create a single-node MySQL service with a custom root password, add the credentials as secrets, and create a single-node WordPress service which uses these credentials to connect to MySQL. The &lt;a href=&quot;#example-rotate-a-secret&quot;&gt;next example&lt;/a&gt; builds on this one and shows you how to rotate the MySQL password and update the services so that the WordPress service can still connect to MySQL.</source>
          <target state="translated">이 예에서는 사용자 지정 루트 암호를 사용하여 단일 노드 MySQL 서비스를 만들고 자격 증명을 비밀로 추가 한 다음 이러한 자격 증명을 사용하여 MySQL에 연결하는 단일 노드 WordPress 서비스를 만듭니다. &lt;a href=&quot;#example-rotate-a-secret&quot;&gt;다음 예제는&lt;/a&gt; 이 하나와 쇼 당신을 어떻게 MySQL의 암호를 회전 워드 프레스 서비스가 여전히 MySQL로 연결할 수 있도록 서비스를 업데이트하는 기반으로.</target>
        </trans-unit>
        <trans-unit id="3b9a1129d761331ffa104c86be232c76a3c51f4b" translate="yes" xml:space="preserve">
          <source>In this general example, the &lt;code&gt;redis&lt;/code&gt; service is constrained to use no more than 50M of memory and &lt;code&gt;0.50&lt;/code&gt; (50% of a single core) of available processing time (CPU), and has &lt;code&gt;20M&lt;/code&gt; of memory and &lt;code&gt;0.25&lt;/code&gt; CPU time reserved (as always available to it).</source>
          <target state="translated">이 일반적인 예에서 &lt;code&gt;redis&lt;/code&gt; 서비스는 50M 이하의 메모리와 &lt;code&gt;0.50&lt;/code&gt; (단일 코어의 50 %)의 가용 처리 시간 (CPU) 을 사용하도록 제한되며 &lt;code&gt;20M&lt;/code&gt; 의 메모리와 &lt;code&gt;0.25&lt;/code&gt; CPU 시간이 예약되어 있습니다 (항상 사용 가능한대로) 그것에).</target>
        </trans-unit>
        <trans-unit id="a3a5041a3a7ff861db8a633ca654e1d84e7d2466" translate="yes" xml:space="preserve">
          <source>In this section, one can provide specific certificates to pin to, or a CA to pin to as a root of trust for a GUN. Multiple sections can be specified, but the pinned certificates take highest priority for validation, followed by the pinned CA, followed by TOFUS (TOFU over HTTPS). The diagram below describes this validation flow:</source>
          <target state="translated">이 섹션에서는 고정 할 특정 인증서를 제공하거나 CA를 GUN의 신뢰 루트로 고정 할 수 있습니다. 여러 섹션을 지정할 수 있지만 고정 된 인증서는 유효성 검사, 고정 된 CA, TOFUS (TOFU over HTTPS)에 따라 우선 순위가 높습니다. 아래 다이어그램은이 유효성 검사 흐름을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6286f7d93adb2f3bde10ad671f8f4aa75697a866" translate="yes" xml:space="preserve">
          <source>In this section, there are two common use cases for multiple Compose files: changing a Compose app for different environments, and running administrative tasks against a Compose app.</source>
          <target state="translated">이 섹션에는 여러 Compose 파일에 대한 두 가지 일반적인 사용 사례가 있습니다. 서로 다른 환경에서 Compose 앱 변경 및 Compose 앱에 대한 관리 작업 실행.</target>
        </trans-unit>
        <trans-unit id="08c5147a96cd0e66029e61313e04531ebbd0bcac" translate="yes" xml:space="preserve">
          <source>In this section, you set up the database connection for Django.</source>
          <target state="translated">이 섹션에서는 Django에 대한 데이터베이스 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="04288368cbc60426fb483634cfbec72223e0ed4b" translate="yes" xml:space="preserve">
          <source>In this section, you use Docker Compose to specify how to set up and link together the &lt;code&gt;trustsandbox&lt;/code&gt; container, the Notary server, and the Registry server.</source>
          <target state="translated">이 섹션에서는 Docker Compose를 사용하여 &lt;code&gt;trustsandbox&lt;/code&gt; 컨테이너, Notary 서버 및 레지스트리 서버 를 설정하고 함께 연결하는 방법을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="e51af388cdc8f97cb8eb1d08de8500fabebf3d20" translate="yes" xml:space="preserve">
          <source>In this step, you create a Django starter project by building the image from the build context defined in the previous procedure.</source>
          <target state="translated">이 단계에서는 이전 절차에서 정의한 빌드 컨텍스트에서 이미지를 빌드하여 Django 스타터 프로젝트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1e01432f90c228d152d047aa8deff8a52d211dba" translate="yes" xml:space="preserve">
          <source>In this step, you write a Dockerfile that builds a Docker image. The image contains all the dependencies the Python application requires, including Python itself.</source>
          <target state="translated">이 단계에서는 Docker 이미지를 빌드하는 Dockerfile을 작성합니다. 이미지에는 Python 자체를 포함하여 Python 응용 프로그램에 필요한 모든 종속성이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa2627c39d008ec8a874ad931d1e12f5847d198f" translate="yes" xml:space="preserve">
          <source>In your project directory, create a file named &lt;code&gt;Dockerfile&lt;/code&gt; and paste the following:</source>
          <target state="translated">프로젝트 디렉토리에서 &lt;code&gt;Dockerfile&lt;/code&gt; 이라는 파일을 작성 하고 다음을 붙여 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="4ff77a321aea72381bf2aa35c530b9fe5bf786ac" translate="yes" xml:space="preserve">
          <source>In your project directory, edit the &lt;code&gt;composeexample/settings.py&lt;/code&gt; file.</source>
          <target state="translated">프로젝트 디렉토리에서 &lt;code&gt;composeexample/settings.py&lt;/code&gt; 파일을 편집 하십시오.</target>
        </trans-unit>
        <trans-unit id="0d3d7d9b5cd6a9e000ada483c14290e972973924" translate="yes" xml:space="preserve">
          <source>Include pre-release versions</source>
          <target state="translated">시험판 버전 포함</target>
        </trans-unit>
        <trans-unit id="dbffe00393d5fb45712267a38682885f997730f5" translate="yes" xml:space="preserve">
          <source>Include the directory in your &lt;code&gt;$fpath&lt;/code&gt; by adding in &lt;code&gt;~/.zshrc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~/.zshrc&lt;/code&gt; 에 추가 하여 &lt;code&gt;$fpath&lt;/code&gt; 에 디렉토리를 포함 시키십시오 :</target>
        </trans-unit>
        <trans-unit id="526ae408d88f0a68705af2b63511a512551d699e" translate="yes" xml:space="preserve">
          <source>Includes popular directories, such as &lt;code&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&lt;/code&gt; 과 같이 널리 사용되는 디렉토리를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="a36a5a753eb20e482d351f30a837bf2ea439031c" translate="yes" xml:space="preserve">
          <source>Incrementally transfer only the changed files in your build context between builds</source>
          <target state="translated">빌드 컨텍스트에서 빌드간에 변경된 파일 만 증분 전송</target>
        </trans-unit>
        <trans-unit id="226e10a49cccd3956fbf0378651af38c9d5e2ebf" translate="yes" xml:space="preserve">
          <source>Indent the whole file by one level and put a &lt;code&gt;services:&lt;/code&gt; key at the top.</source>
          <target state="translated">전체 파일을 한 수준 들여 쓰기하고 &lt;code&gt;services:&lt;/code&gt; 키를 맨 위에 놓습니다.</target>
        </trans-unit>
        <trans-unit id="6d4d32e5969562f6d4c8a1697bb643b1ac1305c2" translate="yes" xml:space="preserve">
          <source>Infinit volume plugin</source>
          <target state="translated">인피니트 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="d49276b3775ffb7a604de088984bd3eae9e57c9d" translate="yes" xml:space="preserve">
          <source>Initial support for volume driver plugins (&lt;a href=&quot;https://github.com/docker/docker/pull/14659&quot;&gt;#14659&lt;/a&gt;)</source>
          <target state="translated">볼륨 드라이버 플러그인에 대한 초기 지원 ( &lt;a href=&quot;https://github.com/docker/docker/pull/14659&quot;&gt;# 14659&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7a0cca60332565efa82da0830e70af27255cc059" translate="yes" xml:space="preserve">
          <source>Initialize a Trusted Collection</source>
          <target state="translated">신뢰할 수있는 컬렉션 초기화</target>
        </trans-unit>
        <trans-unit id="11f9ae2749773d8e95314483370b6db75fdc2c07" translate="yes" xml:space="preserve">
          <source>Initialize a swarm</source>
          <target state="translated">떼를 초기화</target>
        </trans-unit>
        <trans-unit id="7003ecab6ac4d75e2e8f2e1207a6711b17369313" translate="yes" xml:space="preserve">
          <source>Initialize a swarm with autolocking enabled</source>
          <target state="translated">자동 잠금이 활성화 된 스웜 초기화</target>
        </trans-unit>
        <trans-unit id="28694b0b3d1f03f7cdae70f994ca9ec65708493d" translate="yes" xml:space="preserve">
          <source>Initialize a swarm. The docker engine targeted by this command becomes a manager in the newly created single-node swarm.</source>
          <target state="translated">떼를 초기화하십시오. 이 명령의 대상이되는 도커 엔진은 새로 작성된 단일 노드 떼의 관리자가됩니다.</target>
        </trans-unit>
        <trans-unit id="69b6ef38c3841824a41327527d835ecc412b9040" translate="yes" xml:space="preserve">
          <source>Initialize the swarm and add nodes</source>
          <target state="translated">떼를 초기화하고 노드를 추가하십시오</target>
        </trans-unit>
        <trans-unit id="4e3946ff12a229a7dec9c0364f2084edab96d933" translate="yes" xml:space="preserve">
          <source>Initialize volumes</source>
          <target state="translated">볼륨 초기화</target>
        </trans-unit>
        <trans-unit id="aa3480029144fc1747d6781da542a6add4fc7d50" translate="yes" xml:space="preserve">
          <source>Initializing a trusted collection generates the following items; all keys use asymmetric algorithms, but there is no requirement that they all use the &lt;em&gt;same&lt;/em&gt; algorithm:</source>
          <target state="translated">신뢰할 수있는 컬렉션을 초기화하면 다음 항목이 생성됩니다. 모든 키는 비대칭 알고리즘을 사용하지만 모두 &lt;em&gt;동일한&lt;/em&gt; 알고리즘을 사용할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9802ef4d56e81169ff494ba78267ecf92f7d0789" translate="yes" xml:space="preserve">
          <source>Initiate the root CA rotation, but do not wait for the completion of or display the progress of the rotation.</source>
          <target state="translated">루트 CA 회전을 시작하되 회전이 완료 될 때까지 기다리거나 회전 진행률을 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6880f6739c9251b402c6f12118b0fd2683a88281" translate="yes" xml:space="preserve">
          <source>Initiating the Repository</source>
          <target state="translated">리포지토리 시작</target>
        </trans-unit>
        <trans-unit id="058a41f21587dc3bb32900367e4fbdff23554533" translate="yes" xml:space="preserve">
          <source>Insecure registries</source>
          <target state="translated">안전하지 않은 레지스트리</target>
        </trans-unit>
        <trans-unit id="e88687dde18003eb75d76a43b01c7e8bcb628535" translate="yes" xml:space="preserve">
          <source>Inside the container, your app is running on the same port as before &lt;code&gt;3000&lt;/code&gt;, but the Rails Welcome is now available on &lt;code&gt;http://localhost:3001&lt;/code&gt; on your local host.</source>
          <target state="translated">컨테이너 내에서 앱은 &lt;code&gt;3000&lt;/code&gt; 이전과 동일한 포트에서 실행 되지만 이제 Rails Welcome는 로컬 호스트의 &lt;code&gt;http://localhost:3001&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b31429992c34dbc1d09f093f9194acb969c032c" translate="yes" xml:space="preserve">
          <source>Inspect a Docker Hub repository</source>
          <target state="translated">Docker Hub 리포지토리 검사</target>
        </trans-unit>
        <trans-unit id="a5f1a49ca40c0afe3626936f9aaa51eaa0bfd77c" translate="yes" xml:space="preserve">
          <source>Inspect a context by name</source>
          <target state="translated">이름으로 컨텍스트 검사</target>
        </trans-unit>
        <trans-unit id="fe9b429e13e53fe0d1fa77df1523f9b49fa49ef3" translate="yes" xml:space="preserve">
          <source>Inspect a manifest list</source>
          <target state="translated">매니페스트 목록 검사</target>
        </trans-unit>
        <trans-unit id="420079d24950e1155e772c29d34368ce64e8185b" translate="yes" xml:space="preserve">
          <source>Inspect a node</source>
          <target state="translated">노드 검사</target>
        </trans-unit>
        <trans-unit id="a0668f170f8bf043fa3f8e9c766b87398953b408" translate="yes" xml:space="preserve">
          <source>Inspect a secret by name or ID</source>
          <target state="translated">이름이나 ID로 비밀 검사</target>
        </trans-unit>
        <trans-unit id="c3ab8a02dd78c3e54271f8a625519657b78b5527" translate="yes" xml:space="preserve">
          <source>Inspect a service by name or ID</source>
          <target state="translated">이름이나 ID로 서비스를 검사</target>
        </trans-unit>
        <trans-unit id="b6436533c672d459a45257fe6f8527b608e7ae09" translate="yes" xml:space="preserve">
          <source>Inspect a service on the swarm</source>
          <target state="translated">떼에서 서비스를 검사</target>
        </trans-unit>
        <trans-unit id="4aeb395d6058823adcf371cb704cfc8ea8e3afd5" translate="yes" xml:space="preserve">
          <source>Inspect an image&amp;rsquo;s manifest and get the os/arch info</source>
          <target state="translated">이미지의 매니페스트를 검사하고 OS / 아치 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2bf9b13b53ebf817fd46cd1d17e521b1d177c23d" translate="yes" xml:space="preserve">
          <source>Inspect an image&amp;rsquo;s manifest object</source>
          <target state="translated">이미지의 매니페스트 객체 검사</target>
        </trans-unit>
        <trans-unit id="ad97e28e2e02a6e39501674e8974efa0608b289e" translate="yes" xml:space="preserve">
          <source>Inspect an individual node</source>
          <target state="translated">개별 노드 검사</target>
        </trans-unit>
        <trans-unit id="8b35d287031689a9f14229de07991819cc2cd921" translate="yes" xml:space="preserve">
          <source>Inspect changes to files or directories on a container&amp;rsquo;s filesystem</source>
          <target state="translated">컨테이너 파일 시스템의 파일 또는 디렉토리 변경 사항 검사</target>
        </trans-unit>
        <trans-unit id="a655d5b0d76cddfebf396f57b9b19ca49825f9fc" translate="yes" xml:space="preserve">
          <source>Inspect the &lt;code&gt;redis&lt;/code&gt; service:</source>
          <target state="translated">&lt;code&gt;redis&lt;/code&gt; 서비스를 검사하십시오 .</target>
        </trans-unit>
        <trans-unit id="a653c5466994d5d911563050cea4c11201a824db" translate="yes" xml:space="preserve">
          <source>Inspect the changes to an &lt;code&gt;nginx&lt;/code&gt; container:</source>
          <target state="translated">&lt;code&gt;nginx&lt;/code&gt; 컨테이너 의 변경 사항을 검사하십시오 .</target>
        </trans-unit>
        <trans-unit id="7604f326e330f861f74039d2f88bd399cb0c1217" translate="yes" xml:space="preserve">
          <source>Inspect the node to check its availability:</source>
          <target state="translated">노드를 검사하여 가용성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7f3c7e6fe9569b48c38ba6582152afc2ba534e36" translate="yes" xml:space="preserve">
          <source>Inspect the node to see the updated state:</source>
          <target state="translated">노드를 검사하여 업데이트 된 상태를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2a7034b85fb0c0b67f40eb338c1e0691a6c1ecd6" translate="yes" xml:space="preserve">
          <source>Inspect the remote host. For example, &lt;code&gt;docker-machine ip &amp;lt;machine&amp;gt;&lt;/code&gt; returns the host IP address and &lt;code&gt;docker-machine inspect &amp;lt;machine&amp;gt;&lt;/code&gt; lists all the details.</source>
          <target state="translated">원격 호스트를 검사하십시오. 예를 들어 &lt;code&gt;docker-machine ip &amp;lt;machine&amp;gt;&lt;/code&gt; 은 호스트 IP 주소를 반환하고 &lt;code&gt;docker-machine inspect &amp;lt;machine&amp;gt;&lt;/code&gt; 은 모든 세부 정보를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="a3e49f0aaf06ae9fd7c32f03cfeac1efd536f26c" translate="yes" xml:space="preserve">
          <source>Inspects one or more contexts.</source>
          <target state="translated">하나 이상의 컨텍스트를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="6fb970a9973a0fe3dc49cf82ea5d559d4bda0f4b" translate="yes" xml:space="preserve">
          <source>Inspects the specified secret. This command has to be run targeting a manager node.</source>
          <target state="translated">지정된 비밀을 검사합니다. 이 명령은 관리자 노드를 대상으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1238ba6a5fa64a99472e560085e32fed40212754" translate="yes" xml:space="preserve">
          <source>Inspects the specified service. This command has to be run targeting a manager node.</source>
          <target state="translated">지정된 서비스를 검사합니다. 이 명령은 관리자 노드를 대상으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="f87859893d31c71ccf20a186c818ea9a15b8f081" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;Docker&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/install&quot;&gt;Docker를&lt;/a&gt; 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="87a5e4373b319e131c991d46ae5f29fdc177cb11" translate="yes" xml:space="preserve">
          <source>Install Compose</source>
          <target state="translated">편지 쓰기 설치</target>
        </trans-unit>
        <trans-unit id="584cfd1e2b63dc02688935546533c373dd8513a0" translate="yes" xml:space="preserve">
          <source>Install Compose on Linux systems</source>
          <target state="translated">Linux 시스템에 Compose 설치</target>
        </trans-unit>
        <trans-unit id="2edbc8b204fb4f77ab5754dbfd816f818b4cba66" translate="yes" xml:space="preserve">
          <source>Install Compose on Windows Server</source>
          <target state="translated">Windows Server에 편지 쓰기 설치</target>
        </trans-unit>
        <trans-unit id="4cccd54e0c8de4cf84ed8ce5105dcaf0c6bede12" translate="yes" xml:space="preserve">
          <source>Install Compose on Windows desktop systems</source>
          <target state="translated">Windows 데스크탑 시스템에 Compose 설치</target>
        </trans-unit>
        <trans-unit id="6fddb2f6d2ab5236388e781626450bbb7690bfbd" translate="yes" xml:space="preserve">
          <source>Install Compose on macOS</source>
          <target state="translated">macOS에 Compose 설치</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
