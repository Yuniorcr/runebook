<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="docker">
    <body>
      <group id="docker">
        <trans-unit id="60d860189d2158cdf542a9cbb8695de90a38307e" translate="yes" xml:space="preserve">
          <source>Tasks and scheduling</source>
          <target state="translated">작업 및 일정</target>
        </trans-unit>
        <trans-unit id="4724fbe8a48eed671df3989a1d59760d11dc9374" translate="yes" xml:space="preserve">
          <source>Template driver</source>
          <target state="translated">템플릿 드라이버</target>
        </trans-unit>
        <trans-unit id="bbc9347d8ea27318520421a57ccb8f8fa6025618" translate="yes" xml:space="preserve">
          <source>Template example</source>
          <target state="translated">템플릿 예</target>
        </trans-unit>
        <trans-unit id="657b1097533383d1ddb0b93f186763becffe5373" translate="yes" xml:space="preserve">
          <source>Test Docker installation</source>
          <target state="translated">Docker 설치 테스트</target>
        </trans-unit>
        <trans-unit id="7025949d5fc48e86d1eca515546b5ceccd50f755" translate="yes" xml:space="preserve">
          <source>Test Docker version</source>
          <target state="translated">Docker 버전 테스트</target>
        </trans-unit>
        <trans-unit id="655a932ba64b06aacff6652d6aad1b05d8214c81" translate="yes" xml:space="preserve">
          <source>Test some trust operations</source>
          <target state="translated">일부 트러스트 작업 테스트</target>
        </trans-unit>
        <trans-unit id="a34e7038eaa42b7dee344142134b357ad14097cb" translate="yes" xml:space="preserve">
          <source>Test that your installation works by running the simple Docker image, &lt;a href=&quot;https://hub.docker.com/_/hello-world/&quot;&gt;hello-world&lt;/a&gt;:</source>
          <target state="translated">간단한 Docker 이미지 &lt;a href=&quot;https://hub.docker.com/_/hello-world/&quot;&gt;hello-world&lt;/a&gt; 를 실행하여 설치가 작동하는지 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0d302792e518eadee3123226b753c97b5e9f48b" translate="yes" xml:space="preserve">
          <source>Test the database</source>
          <target state="translated">데이터베이스 테스트</target>
        </trans-unit>
        <trans-unit id="2b78370a2b3bb63e40059964522de64d81df33cd" translate="yes" xml:space="preserve">
          <source>Test the image, check for &lt;code&gt;/remove_me&lt;/code&gt; being gone, make sure &lt;code&gt;hello\nworld&lt;/code&gt; is in &lt;code&gt;/hello&lt;/code&gt;, make sure the &lt;code&gt;HELLO&lt;/code&gt; envvar&amp;rsquo;s value is &lt;code&gt;world&lt;/code&gt;.</source>
          <target state="translated">이미지를 테스트하고 &lt;code&gt;/remove_me&lt;/code&gt; 가 사라 졌는지 확인하고 &lt;code&gt;hello\nworld&lt;/code&gt; 가 &lt;code&gt;/hello&lt;/code&gt; 에 있는지 확인하고 &lt;code&gt;HELLO&lt;/code&gt; envvar의 값이 &lt;code&gt;world&lt;/code&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f54d1554b9c0f1b5ea3dfc1b8000a4189c07cfd0" translate="yes" xml:space="preserve">
          <source>Test the installation.</source>
          <target state="translated">설치를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="37f76e912a69eb9799e911065d89e4c93378e4e0" translate="yes" xml:space="preserve">
          <source>Test with malicious images</source>
          <target state="translated">악성 이미지로 테스트</target>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">텍스트 파일</target>
        </trans-unit>
        <trans-unit id="48ea8ca4b67a150bf3621e536df06ea9ea7c6131" translate="yes" xml:space="preserve">
          <source>That way, all new keys are encrypted and decrypted using the passphrase &lt;code&gt;mynewfancypassword&lt;/code&gt;, but old keys that were encrypted using the passphrase &lt;code&gt;mypassword&lt;/code&gt; can still be decrypted.</source>
          <target state="translated">이렇게하면 모든 새 키가 &lt;code&gt;mynewfancypassword&lt;/code&gt; 암호 구를 사용하여 암호화 및 암호 해독 되지만 &lt;code&gt;mypassword&lt;/code&gt; 암호 구를 사용하여 암호화 된 이전 키 는 여전히 암호 해독 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f44ab494894033becbc4ef28b56d983341a26a48" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;ll put your application code inside an image that builds a container with Ruby, Bundler and all your dependencies inside it. For more information on how to write Dockerfiles, see the &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker user guide&lt;/a&gt; and the &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile reference&lt;/a&gt;.</source>
          <target state="translated">Ruby, Bundler 및 그 안에 모든 종속성이있는 컨테이너를 빌드하는 이미지 안에 응용 프로그램 코드를 넣습니다. Dockerfile 작성 방법에 대한 자세한 정보는 &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker 사용자 안내서&lt;/a&gt; 및 &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="430585eb3dbe6bdbca1532982cb4635d1c03a556" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all for this page. In the next section, we learn how to scale our application by running this container in a &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">이것이이 페이지의 전부입니다. 다음 섹션에서는이 컨테이너를 &lt;strong&gt;서비스&lt;/strong&gt; 에서 실행하여 응용 프로그램을 확장하는 방법을 배웁니다 .</target>
        </trans-unit>
        <trans-unit id="127d13646cf25b737700c8acfd62e6ec2061e547" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it! You don&amp;rsquo;t need Python or anything in &lt;code&gt;requirements.txt&lt;/code&gt; on your system, nor does building or running this image install them on your system. It doesn&amp;rsquo;t seem like you&amp;rsquo;ve really set up an environment with Python and Flask, but you have.</source>
          <target state="translated">그게 다야! Python 또는 시스템의 &lt;code&gt;requirements.txt&lt;/code&gt; 에 아무것도 필요 하지 않으며이 이미지를 빌드하거나 실행하여 시스템에 설치하지 않습니다. 실제로 Python과 Flask로 환경을 설정 한 것처럼 보이지는 않지만 실제로 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9e7a95197709bea6ecc44d69a12ed465b3c942f" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it. Your app should now be running on port 3000 on your Docker daemon.</source>
          <target state="translated">그게 다야. 이제 앱이 Docker 데몬의 포트 3000에서 실행되고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="14dbbc8fc7113c6b6607f3c73f3f768d6b74600d" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;.env&amp;rdquo; file</source>
          <target state="translated">&amp;ldquo;.env&amp;rdquo;파일</target>
        </trans-unit>
        <trans-unit id="654f1dc286e9b3f410a2830d4fdbbb483a2a9ef6" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;env_file&amp;rdquo; configuration option</source>
          <target state="translated">&amp;ldquo;env_file&amp;rdquo;구성 옵션</target>
        </trans-unit>
        <trans-unit id="bb41e99c9aff699c5080b3991e8752ac32858843" translate="yes" xml:space="preserve">
          <source>The 4th container fails and reports &amp;ldquo;[8] System error: resource temporarily unavailable&amp;rdquo; error. This fails because the caller set &lt;code&gt;nproc=3&lt;/code&gt; resulting in the first three containers using up the three processes quota set for the &lt;code&gt;daemon&lt;/code&gt; user.</source>
          <target state="translated">네 번째 컨테이너가 실패하고 &quot;[8] 시스템 오류 : 리소스를 일시적으로 사용할 수 없음&quot;오류가보고됩니다. 호출자가 &lt;code&gt;nproc=3&lt;/code&gt; 을 설정하여 &lt;code&gt;daemon&lt;/code&gt; 사용자에 대해 설정된 세 개의 프로세스 할당량을 사용하여 처음 세 개의 컨테이너를 생성 하기 때문에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="cebd5eb02d39d7497be7af8026f9c48eeca2be59" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#compatibility-matrix&quot;&gt;Compatibility Matrix&lt;/a&gt; shows Compose file versions mapped to Docker Engine releases.</source>
          <target state="translated">&lt;a href=&quot;#compatibility-matrix&quot;&gt;호환성 매트릭스&lt;/a&gt; 도커 엔진 출시에 매핑 작성 파일 버전을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b7a1f2f65fda41b01612fd40aaaa3de01a0f93ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../extend/plugin_api/index#json-specification&quot;&gt;&lt;code&gt;PluginSpec&lt;/code&gt;&lt;/a&gt; is defined by the plugin developer. To add the plugin to all Docker nodes, use the &lt;a href=&quot;https://docs.docker.com/engine/api/v1.31/#operation/ServiceCreate&quot;&gt;&lt;code&gt;service/create&lt;/code&gt;&lt;/a&gt; API, passing the &lt;code&gt;PluginSpec&lt;/code&gt; JSON defined in the &lt;code&gt;TaskTemplate&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../extend/plugin_api/index#json-specification&quot;&gt; &lt;code&gt;PluginSpec&lt;/code&gt; 는&lt;/a&gt; 플러그인 개발자에 의해 정의된다. 모든 도커 노드에 플러그인을 추가하려면, 사용하는 &lt;a href=&quot;https://docs.docker.com/engine/api/v1.31/#operation/ServiceCreate&quot;&gt; &lt;code&gt;service/create&lt;/code&gt; &lt;/a&gt; 통과, API를 &lt;code&gt;PluginSpec&lt;/code&gt; JSON이 정의 &lt;code&gt;TaskTemplate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73eeeb2a3c032a0ea6d429f4744721f37565d8f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../commandline/build/index&quot;&gt;&lt;code&gt;docker build&lt;/code&gt;&lt;/a&gt; command builds an image from a &lt;code&gt;Dockerfile&lt;/code&gt; and a &lt;em&gt;context&lt;/em&gt;. The build&amp;rsquo;s context is the set of files at a specified location &lt;code&gt;PATH&lt;/code&gt; or &lt;code&gt;URL&lt;/code&gt;. The &lt;code&gt;PATH&lt;/code&gt; is a directory on your local filesystem. The &lt;code&gt;URL&lt;/code&gt; is a Git repository location.</source>
          <target state="translated">&lt;a href=&quot;../commandline/build/index&quot;&gt; &lt;code&gt;docker build&lt;/code&gt; &lt;/a&gt; 명령은에서 이미지 빌드 &lt;code&gt;Dockerfile&lt;/code&gt; 와 &lt;em&gt;컨텍스트를&lt;/em&gt; . 빌드 컨텍스트는 지정된 위치 &lt;code&gt;PATH&lt;/code&gt; 또는 &lt;code&gt;URL&lt;/code&gt; 에있는 파일 세트입니다 . &lt;code&gt;PATH&lt;/code&gt; 는 사용자의 로컬 파일 시스템의 디렉토리입니다. &lt;code&gt;URL&lt;/code&gt; 은 힘내 저장소 위치입니다.</target>
        </trans-unit>
        <trans-unit id="c5f4ed1ae5916f39e4823b8399b775c3b2e70409" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compose-file-v2/index#depends_on&quot;&gt;&lt;code&gt;depends_on&lt;/code&gt;&lt;/a&gt; option can be used in place of links to indicate dependencies between services and startup order.</source>
          <target state="translated">&lt;a href=&quot;../compose-file-v2/index#depends_on&quot;&gt; &lt;code&gt;depends_on&lt;/code&gt; 의&lt;/a&gt; 옵션은 서비스 시작 순서 간의 종속성을 표시하기 위해 링크 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="018f7b331a3235cebca4b4072ded7099501dab4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compose-file/index&quot;&gt;Compose file&lt;/a&gt; provides a way to document and configure all of the application&amp;rsquo;s service dependencies (databases, queues, caches, web service APIs, etc). Using the Compose command line tool you can create and start one or more containers for each dependency with a single command (&lt;code&gt;docker-compose up&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;compose-file/index&quot;&gt;작성 파일은&lt;/a&gt; 문서 및 구성 응용 프로그램의 서비스 종속성의 모든 (데이터베이스, 큐, 캐시, 웹 서비스 API 등) 할 수있는 방법을 제공합니다. 작성 명령 행 도구를 사용하면 단일 명령 ( &lt;code&gt;docker-compose up&lt;/code&gt; )으로 각 종속성에 대해 하나 이상의 컨테이너를 작성하고 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87fa9331ae9490bf7870124f14587e5c346d0b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;installation section&lt;/a&gt; shows you how to install Docker on a variety of platforms.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/install&quot;&gt;설치 섹션&lt;/a&gt; 은 다양한 플랫폼에서 부두 노동자를 설치하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6b33d5ede8e3026d0ca1bc748f5aa28796c41cf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.docker.com/storage/storagedriver/select-storage-driver/#docker-ce&quot;&gt;default storage driver&lt;/a&gt; may fail on Debian, specifying &lt;code&gt;overlay2&lt;/code&gt; should resolve this issue.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/storage/storagedriver/select-storage-driver/#docker-ce&quot;&gt;기본 저장 드라이버&lt;/a&gt; 지정, 데비안에 실패 할 수 있습니다 &lt;code&gt;overlay2&lt;/code&gt; 이 문제를 해결해야한다.</target>
        </trans-unit>
        <trans-unit id="628b046b134e285847b720a7dd669b6db236e360" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/docker/libnetwork&quot;&gt;LibNetwork&lt;/a&gt; project</source>
          <target state="translated">&lt;a href=&quot;https://github.com/docker/libnetwork&quot;&gt;LibNetwork의&lt;/a&gt; 프로젝트</target>
        </trans-unit>
        <trans-unit id="b662250e23d13987f6741fabca2dfda9a8da7838" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt; the Data Source Name used to access the DB.&lt;/a&gt; ( include &lt;code&gt;parseTime=true&lt;/code&gt; as part of the DSN)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt;데이터 원본 이름은 DB에 액세스하는 데 사용. &lt;/a&gt;( DSN의 일부로 &lt;code&gt;parseTime=true&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="fd73d42be4fd177aa9ab1fed999f88e1afe43fbc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt; the Data Source Name used to access the DB.&lt;/a&gt; (include &lt;code&gt;parseTime=true&lt;/code&gt; as part of the DSN)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt;데이터 원본 이름은 DB에 액세스하는 데 사용. &lt;/a&gt;( DSN의 일부로 &lt;code&gt;parseTime=true&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="504f0db06e322e719534c5c4a5a6576e4f23edb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.exoscale.com/templates/&quot;&gt;VM templates&lt;/a&gt; available at Exoscale are listed on the Portal when adding a new instance.</source>
          <target state="translated">&lt;a href=&quot;https://www.exoscale.com/templates/&quot;&gt;VM 템플릿&lt;/a&gt; 새로운 인스턴스를 추가 할 때 Exoscale에서 사용할 수는 포털에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e0a8ecc927fdc7e3340ea02fe6771187b8cca0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;Understanding Docker section&lt;/a&gt; helps you:</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;이해 도커 섹션은&lt;/a&gt; 당신을 도와줍니다 :</target>
        </trans-unit>
        <trans-unit id="4284d13cb4745a7492b807ffca26395534a811e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;${variable_name}&lt;/code&gt; syntax also supports a few of the standard &lt;code&gt;bash&lt;/code&gt; modifiers as specified below:</source>
          <target state="translated">&lt;code&gt;${variable_name}&lt;/code&gt; 구문은 표준의 몇 가지 지원 &lt;code&gt;bash&lt;/code&gt; 는 아래에 지정된대로 수정 :</target>
        </trans-unit>
        <trans-unit id="67a51f2b831d7d69d9eddea8b3cf5f1cc026ce01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;PUBLISHED-PORT&amp;gt;&lt;/code&gt; is the port where the swarm makes the service available. If you omit it, a random high-numbered port is bound. The &lt;code&gt;&amp;lt;CONTAINER-PORT&amp;gt;&lt;/code&gt; is the port where the container listens. This parameter is required.</source>
          <target state="translated">&lt;code&gt;&amp;lt;PUBLISHED-PORT&amp;gt;&lt;/code&gt; 떼가 서비스를 사용할 수 있도록 포트입니다. 생략하면 임의의 높은 번호의 포트가 바인드됩니다. &lt;code&gt;&amp;lt;CONTAINER-PORT&amp;gt;&lt;/code&gt; 여기서 컨테이너 수신하는 포트입니다. 이 매개 변수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="a57f293402afe0c5879e54f7873750bb0d8b3939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; is an absolute path, or a path relative to &lt;code&gt;WORKDIR&lt;/code&gt;, into which the source will be copied inside the destination container.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 절대 경로 또는 상대 경로이다 &lt;code&gt;WORKDIR&lt;/code&gt; 소스가 목적지 용기 내부에 복사 될.</target>
        </trans-unit>
        <trans-unit id="f72a134e51f24916887b605c8357253041c38107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; path must be inside the &lt;em&gt;context&lt;/em&gt; of the build; you cannot &lt;code&gt;ADD ../something /something&lt;/code&gt;, because the first step of a &lt;code&gt;docker build&lt;/code&gt; is to send the context directory (and subdirectories) to the docker daemon.</source>
          <target state="translated">&lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 경로 안에 있어야 &lt;em&gt;문맥&lt;/em&gt; 빌드; &lt;code&gt;docker build&lt;/code&gt; 의 첫 번째 단계 는 컨텍스트 디렉토리 (및 서브 디렉토리)를 도커 디먼으로 보내는 것이므로 &lt;code&gt;ADD ../something /something&lt;/code&gt; 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dc1afca2b065dd1b6a9740d25d7aa2a3ebf159b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; path must be inside the &lt;em&gt;context&lt;/em&gt; of the build; you cannot &lt;code&gt;COPY ../something /something&lt;/code&gt;, because the first step of a &lt;code&gt;docker build&lt;/code&gt; is to send the context directory (and subdirectories) to the docker daemon.</source>
          <target state="translated">&lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 경로 안에 있어야 &lt;em&gt;문맥&lt;/em&gt; 빌드; &lt;code&gt;docker build&lt;/code&gt; 의 첫 번째 단계 는 컨텍스트 디렉토리 (및 서브 디렉토리)를 도커 디먼으로 보내는 것이므로 &lt;code&gt;COPY ../something /something&lt;/code&gt; 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3a3a213a12552b6e7f649b0b0cdf56d19ec341db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; next to the node ID indicates that you&amp;rsquo;re currently connected on this node.</source>
          <target state="translated">노드 ID 옆 의 &lt;code&gt;*&lt;/code&gt; 는 현재이 노드에 연결되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bb630ccd56d5687939202633b11ad7715a867b16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--advertise-addr&lt;/code&gt; flag configures the manager node to publish its address as &lt;code&gt;192.168.99.100&lt;/code&gt;. The other nodes in the swarm must be able to access the manager at the IP address.</source>
          <target state="translated">&lt;code&gt;--advertise-addr&lt;/code&gt; 플래그로 해당 주소를 게시 할 수있는 관리 노드 구성 &lt;code&gt;192.168.99.100&lt;/code&gt; 을 . swarm의 다른 노드는 IP 주소에서 관리자에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec919e6dd21335064b00777c52cd63ecae7ba32d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--blkio-weight-device=&quot;DEVICE_NAME:WEIGHT&quot;&lt;/code&gt; flag sets a specific device weight. The &lt;code&gt;DEVICE_NAME:WEIGHT&lt;/code&gt; is a string containing a colon-separated device name and weight. For example, to set &lt;code&gt;/dev/sda&lt;/code&gt; device weight to &lt;code&gt;200&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--blkio-weight-device=&quot;DEVICE_NAME:WEIGHT&quot;&lt;/code&gt; 플래그 세트를 특정 장치 중량. &lt;code&gt;DEVICE_NAME:WEIGHT&lt;/code&gt; 콜론 분리 장치 이름 및 중량을 포함하는 문자열이다. 예를 들어, 설정 &lt;code&gt;/dev/sda&lt;/code&gt; 으로 장치의 무게를 &lt;code&gt;200&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b22bb7e3dc97be5255fb3143973a08918865460c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--blkio-weight&lt;/code&gt; flag can set the weighting to a value between 10 to 1000. For example, the commands below create two containers with different blkio weight:</source>
          <target state="translated">&lt;code&gt;--blkio-weight&lt;/code&gt; 플래그는 예를 들어, 다른 명령은 아래 BLKIO 가중치 개의 컨테이너를 작성 1000 10 사이의 값으로 가중치를 설정할 수있다 :</target>
        </trans-unit>
        <trans-unit id="f42470659caa51ce06fd7bee1e26762683d77671" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cgroup-parent&lt;/code&gt; option allows you to set the default cgroup parent to use for containers. If this option is not set, it defaults to &lt;code&gt;/docker&lt;/code&gt; for fs cgroup driver and &lt;code&gt;system.slice&lt;/code&gt; for systemd cgroup driver.</source>
          <target state="translated">&lt;code&gt;--cgroup-parent&lt;/code&gt; 옵션을 사용하면 컨테이너에 사용할 기본 cgroup에 부모를 설정할 수 있습니다. 이 옵션을 설정하지 않으면 fs cgroup 드라이버의 경우 &lt;code&gt;/docker&lt;/code&gt; 가 기본값 이고 systemd cgroup 드라이버의 경우 &lt;code&gt;system.slice&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1826d2db2b75e861af8712525d23a1ed0f1a1ea8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--change&lt;/code&gt; option will apply &lt;code&gt;Dockerfile&lt;/code&gt; instructions to the image that is created. Supported &lt;code&gt;Dockerfile&lt;/code&gt; instructions: &lt;code&gt;CMD&lt;/code&gt;|&lt;code&gt;ENTRYPOINT&lt;/code&gt;|&lt;code&gt;ENV&lt;/code&gt;|&lt;code&gt;EXPOSE&lt;/code&gt;|&lt;code&gt;LABEL&lt;/code&gt;|&lt;code&gt;ONBUILD&lt;/code&gt;|&lt;code&gt;USER&lt;/code&gt;|&lt;code&gt;VOLUME&lt;/code&gt;|&lt;code&gt;WORKDIR&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--change&lt;/code&gt; 의 옵션이 적용됩니다 &lt;code&gt;Dockerfile&lt;/code&gt; 의 생성 된 이미지에 지시를. 지원되는 &lt;code&gt;Dockerfile&lt;/code&gt; 지침 : &lt;code&gt;CMD&lt;/code&gt; | &lt;code&gt;ENTRYPOINT&lt;/code&gt; | &lt;code&gt;ENV&lt;/code&gt; | &lt;code&gt;EXPOSE&lt;/code&gt; | &lt;code&gt;LABEL&lt;/code&gt; | &lt;code&gt;ONBUILD&lt;/code&gt; | &lt;code&gt;USER&lt;/code&gt; | &lt;code&gt;VOLUME&lt;/code&gt; | &lt;code&gt;WORKDIR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="331901ea2d4b659f72eb06d67078bb16233be25a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--change&lt;/code&gt; option will apply &lt;code&gt;Dockerfile&lt;/code&gt; instructions to the image that is created. Supported &lt;code&gt;Dockerfile&lt;/code&gt; instructions: &lt;code&gt;CMD&lt;/code&gt;|&lt;code&gt;ENTRYPOINT&lt;/code&gt;|&lt;code&gt;ENV&lt;/code&gt;|&lt;code&gt;EXPOSE&lt;/code&gt;|&lt;code&gt;ONBUILD&lt;/code&gt;|&lt;code&gt;USER&lt;/code&gt;|&lt;code&gt;VOLUME&lt;/code&gt;|&lt;code&gt;WORKDIR&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--change&lt;/code&gt; 의 옵션이 적용됩니다 &lt;code&gt;Dockerfile&lt;/code&gt; 의 생성 된 이미지에 지시를. 지원되는 &lt;code&gt;Dockerfile&lt;/code&gt; 지침 : &lt;code&gt;CMD&lt;/code&gt; | &lt;code&gt;ENTRYPOINT&lt;/code&gt; | &lt;code&gt;ENV&lt;/code&gt; | &lt;code&gt;EXPOSE&lt;/code&gt; | &lt;code&gt;ONBUILD&lt;/code&gt; | &lt;code&gt;USER&lt;/code&gt; | &lt;code&gt;VOLUME&lt;/code&gt; | &lt;code&gt;WORKDIR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6372b4419938c42b7b941008577f7addb6bf25a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cluster-advertise&lt;/code&gt; option specifies the &lt;code&gt;host:port&lt;/code&gt; or &lt;code&gt;interface:port&lt;/code&gt; combination that this particular daemon instance should use when advertising itself to the cluster. The daemon is reached by remote hosts through this value. If you specify an interface, make sure it includes the IP address of the actual Docker host. For Engine installation created through &lt;code&gt;docker-machine&lt;/code&gt;, the interface is typically &lt;code&gt;eth1&lt;/code&gt;.</source>
          <target state="translated">는 &lt;code&gt;--cluster-advertise&lt;/code&gt; 옵션을 지정 &lt;code&gt;host:port&lt;/code&gt; 또는 &lt;code&gt;interface:port&lt;/code&gt; 클러스터에 자신을 광고 할 때이 특정 데몬 인스턴스가 사용할 필요가 조합을. 이 값을 통해 원격 호스트가 디먼에 도달합니다. 인터페이스를 지정하는 경우 실제 Docker 호스트의 IP 주소가 포함되어 있는지 확인하십시오. &lt;code&gt;docker-machine&lt;/code&gt; 을 통해 생성 된 엔진 설치의 경우 인터페이스는 일반적으로 &lt;code&gt;eth1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="118bb688281323a5d961497c2a015437d9cc0d17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--config-file&lt;/code&gt; option allows you to set any configuration option for the daemon in a JSON format. This file uses the same flag names as keys, except for flags that allow several entries, where it uses the plural of the flag name, e.g., &lt;code&gt;labels&lt;/code&gt; for the &lt;code&gt;label&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;--config-file&lt;/code&gt; 옵션을 사용하면 JSON 형식의 데몬에 대한 구성 옵션을 설정할 수 있습니다. 이 파일은 여러 항목 (예 : &lt;code&gt;label&lt;/code&gt; 플래그 &lt;code&gt;labels&lt;/code&gt; 을 사용하는 여러 항목을 허용하는 플래그를 제외하고 키와 동일한 플래그 이름을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3001b2baac6ad6ca78a42c7dabc4c6fdb80dc832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cpu-quota&lt;/code&gt; flag limits the container&amp;rsquo;s CPU usage. The default 0 value allows the container to take 100% of a CPU resource (1 CPU). The CFS (Completely Fair Scheduler) handles resource allocation for executing processes and is default Linux Scheduler used by the kernel. Set this value to 50000 to limit the container to 50% of a CPU resource. For multiple CPUs, adjust the &lt;code&gt;--cpu-quota&lt;/code&gt; as necessary. For more information, see the &lt;a href=&quot;https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt&quot;&gt;CFS documentation on bandwidth limiting&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--cpu-quota&lt;/code&gt; 플래그는 컨테이너의 CPU 사용량을 제한합니다. 기본 0 값을 사용하면 컨테이너가 CPU 리소스 (1 CPU)의 100 %를 사용할 수 있습니다. CFS (Completely Fair Scheduler)는 프로세스 실행을위한 자원 할당을 처리하며 커널에서 사용하는 기본 Linux 스케줄러입니다. 컨테이너를 CPU 자원의 50 %로 제한하려면이 값을 50000으로 설정하십시오. 여러 CPU의 경우 필요에 따라 &lt;code&gt;--cpu-quota&lt;/code&gt; 를 조정하십시오 . 자세한 내용 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt&quot;&gt;은 대역폭 제한에&lt;/a&gt; 대한 CFS 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="043ce561f5352353cd4aea732d4ed3e377b7df93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--credential-spec&lt;/code&gt; must be one of the following formats:</source>
          <target state="translated">&lt;code&gt;--credential-spec&lt;/code&gt; 다음 형식 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="7645da86ca6a208ce5ac2ceec3ff44fc83723aa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--device-read-bps&lt;/code&gt; flag limits the read rate (bytes per second) from a device. For example, this command creates a container and limits the read rate to &lt;code&gt;1mb&lt;/code&gt; per second from &lt;code&gt;/dev/sda&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--device-read-bps&lt;/code&gt; 플래그는 디바이스로부터 판독 율 (초당 바이트)를 제한한다. 예를 &lt;code&gt;1mb&lt;/code&gt; 명령은 컨테이너를 만들고 &lt;code&gt;/dev/sda&lt;/code&gt; 에서 읽기 속도를 초당 1mb로 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="712e9b14b8091c01098667b0a748389286c56f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--device-read-iops&lt;/code&gt; flag limits read rate (IO per second) from a device. For example, this command creates a container and limits the read rate to &lt;code&gt;1000&lt;/code&gt; IO per second from &lt;code&gt;/dev/sda&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--device-read-iops&lt;/code&gt; 플래그 제한 장치로부터 레이트 (초당 IO)를 읽는다. 예를 들어,이 명령은 컨테이너를 만들고 &lt;code&gt;/dev/sda&lt;/code&gt; 에서 초당 &lt;code&gt;1000&lt;/code&gt; IO로 읽기 속도를 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="fe281068f7ac2e41c30ca85d06921f36e2e2462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--device-write-bps&lt;/code&gt; flag limits the write rate (bytes per second) to a device. For example, this command creates a container and limits the write rate to &lt;code&gt;1mb&lt;/code&gt; per second for &lt;code&gt;/dev/sda&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--device-write-bps&lt;/code&gt; 플래그는 장치에 기록 속도 (초당 바이트)를 제한한다. 예를 &lt;code&gt;1mb&lt;/code&gt; 명령은 컨테이너를 만들고 &lt;code&gt;/dev/sda&lt;/code&gt; 에 대해 쓰기 속도를 초당 1mb로 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="963edac892eb4f59d48156a5a245122b7ec75c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--device-write-iops&lt;/code&gt; flag limits write rate (IO per second) to a device. For example, this command creates a container and limits the write rate to &lt;code&gt;1000&lt;/code&gt; IO per second to &lt;code&gt;/dev/sda&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--device-write-iops&lt;/code&gt; 플래그 제한 장치에 속도 (초당 IO)를 물품. 예를 들어,이 명령은 컨테이너를 만들고 초당 &lt;code&gt;1000&lt;/code&gt; IO로 쓰기 속도 를 &lt;code&gt;/dev/sda&lt;/code&gt; 로 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="b41e02b0b1c16f6f4b137f3f08c43bb795e2f980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--disable-legacy-registry&lt;/code&gt; flag was disabled in Docker 17.12 and will print an error when used. For this error to be printed, the flag itself is still present, but hidden. The flag will be removed in Docker 18.03.</source>
          <target state="translated">&lt;code&gt;--disable-legacy-registry&lt;/code&gt; 플래그는 도커 17.12에서 비활성화되고 사용할 때 오류를 인쇄합니다. 이 오류가 인쇄 되려면 플래그 자체는 여전히 존재하지만 숨겨져 있습니다. Docker 18.03에서 플래그가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="aa8855c7d7182fcadca1fed0a08f183547580585" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--format&lt;/code&gt; option can be used to obtain specific information about a service. For example, the following command outputs the number of replicas of the &amp;ldquo;redis&amp;rdquo; service.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 의 옵션은 서비스에 대한 특정 정보를 얻을 수 있습니다. 예를 들어 다음 명령은 &quot;redis&quot;서비스의 복제본 수를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="d2691a80d15b06a3fcb43e9cbfb91577d7e5061b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--gpus&amp;shy;&lt;/code&gt; flag allows you to access NVIDIA GPU resources. First you need to install &lt;a href=&quot;https://nvidia.github.io/nvidia-container-runtime/&quot;&gt;nvidia-container-runtime&lt;/a&gt;. Visit &lt;a href=&quot;https://docs.docker.com/config/containers/resource_constraints/&quot;&gt;Specify a container&amp;rsquo;s resources&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;--gpus&amp;shy;&lt;/code&gt; 플래그는 NVIDIA GPU 리소스에 액세스 할 수 있습니다. 먼저 &lt;a href=&quot;https://nvidia.github.io/nvidia-container-runtime/&quot;&gt;nvidia-container-runtime&lt;/a&gt; 을 설치해야 합니다 . 자세한 내용 &lt;a href=&quot;https://docs.docker.com/config/containers/resource_constraints/&quot;&gt;은 컨테이너 리소스 지정을&lt;/a&gt; 방문 하십시오.</target>
        </trans-unit>
        <trans-unit id="7e733ea054c1c1ff7988c93e553e76ceca01093a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--metrics-addr&lt;/code&gt; option takes a tcp address to serve the metrics API. This feature is still experimental, therefore, the daemon must be running in experimental mode for this feature to work.</source>
          <target state="translated">&lt;code&gt;--metrics-addr&lt;/code&gt; 옵션은 메트릭 API를 제공하는 TCP 주소를합니다. 이 기능은 아직 실험 중이므로이 기능이 작동하려면 데몬이 실험 모드에서 실행 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="55edf7ef0d43cb5742eeaebcc6bc88b518d3096c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount-add&lt;/code&gt; flag takes the same parameters as the &lt;code&gt;--mount&lt;/code&gt; flag on &lt;code&gt;service create&lt;/code&gt;. Refer to the &lt;a href=&quot;../service_create/index#volumes-and-bind-mounts-mount&quot;&gt;volumes and bind mounts&lt;/a&gt; section in the &lt;code&gt;service create&lt;/code&gt; reference for details.</source>
          <target state="translated">&lt;code&gt;--mount-add&lt;/code&gt; 플래그는 같은 매개 변수를 취 &lt;code&gt;--mount&lt;/code&gt; 에 플래그 &lt;code&gt;service create&lt;/code&gt; . 세부 사항 은 &lt;code&gt;service create&lt;/code&gt; 참조 서 의 &lt;a href=&quot;../service_create/index#volumes-and-bind-mounts-mount&quot;&gt;볼륨 및 바인드 마운트&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2dcb66c9db4a6af0634718f030b3c6961948aceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount-rm&lt;/code&gt; flag takes the &lt;code&gt;target&lt;/code&gt; path of the mount.</source>
          <target state="translated">&lt;code&gt;--mount-rm&lt;/code&gt; 플래그가 얻어 &lt;code&gt;target&lt;/code&gt; 마운트의 경로.</target>
        </trans-unit>
        <trans-unit id="02aa3c4cfe092d2907c9c5953f6b842f826fec95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag allows you to mount volumes, host-directories and &lt;code&gt;tmpfs&lt;/code&gt; mounts in a container.</source>
          <target state="translated">&lt;code&gt;--mount&lt;/code&gt; 플래그는 볼륨, 호스트 디렉토리와 마운트 할 수 &lt;code&gt;tmpfs&lt;/code&gt; 용기에 마운트합니다.</target>
        </trans-unit>
        <trans-unit id="8750034606c120ce24db3130aa8129649ec8c176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag allows you to specify a volume driver and volume driver options &lt;em&gt;per volume&lt;/em&gt;, without creating the volumes in advance. In contrast, &lt;code&gt;docker run&lt;/code&gt; allows you to specify a single volume driver which is shared by all volumes, using the &lt;code&gt;--volume-driver&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;--mount&lt;/code&gt; 플래그는 볼륨 드라이버와 볼륨 드라이버 옵션을 지정할 수 있습니다 &lt;em&gt;볼륨 당을&lt;/em&gt; 사전에 볼륨을 생성하지 않고. 반대로 &lt;code&gt;docker run&lt;/code&gt; 을 사용하면 &lt;code&gt;--volume-driver&lt;/code&gt; 플래그를 사용하여 모든 볼륨이 공유하는 단일 볼륨 드라이버를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36dc4d2874ffe2c6696a361b4631e72a78be9474" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag allows you to specify custom metadata (&amp;ldquo;labels&amp;rdquo;) for a volume, before the volume is created.</source>
          <target state="translated">&lt;code&gt;--mount&lt;/code&gt; 플래그는 볼륨이 생성되기 전에, 볼륨에 대한 ( &quot;라벨&quot;)을 사용자 정의 메타 데이터를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfadbb2f7c0cefeea1691c7fe0bf1951cbef87e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag does not allow you to relabel a volume with &lt;code&gt;Z&lt;/code&gt; or &lt;code&gt;z&lt;/code&gt; flags, which are used for &lt;code&gt;selinux&lt;/code&gt; labeling.</source>
          <target state="translated">&lt;code&gt;--mount&lt;/code&gt; 플래그는 당신이 볼륨 레이블을 다시 지정하는 것을 허용하지 않습니다 &lt;code&gt;Z&lt;/code&gt; 또는 &lt;code&gt;z&lt;/code&gt; 에 사용되는 플래그, &lt;code&gt;selinux&lt;/code&gt; 라벨.</target>
        </trans-unit>
        <trans-unit id="c3ddb7d697487f1f5e66906e8782d710723952e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag supports most options that are supported by the &lt;code&gt;-v&lt;/code&gt; or &lt;code&gt;--volume&lt;/code&gt; flag for &lt;code&gt;docker run&lt;/code&gt;, with some important exceptions:</source>
          <target state="translated">&lt;code&gt;--mount&lt;/code&gt; 플래그는 지원하는 대부분의 옵션을 지원 &lt;code&gt;-v&lt;/code&gt; 또는 &lt;code&gt;--volume&lt;/code&gt; 에 대한 플래그 &lt;code&gt;docker run&lt;/code&gt; 몇 가지 중요한 예외를 :</target>
        </trans-unit>
        <trans-unit id="af06b038fe8b5ee4cf2200adf2410db371b3030b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag supports most options that are supported by the &lt;code&gt;-v&lt;/code&gt; or the &lt;code&gt;--volume&lt;/code&gt; flag, but uses a different syntax. For in-depth information on the &lt;code&gt;--mount&lt;/code&gt; flag, and a comparison between &lt;code&gt;--volume&lt;/code&gt; and &lt;code&gt;--mount&lt;/code&gt;, refer to the &lt;a href=&quot;../service_create/index#add-bind-mounts-or-volumes&quot;&gt;service create command reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--mount&lt;/code&gt; 플래그는 지원하는 대부분의 옵션을 지원 &lt;code&gt;-v&lt;/code&gt; 또는 &lt;code&gt;--volume&lt;/code&gt; 플래그를하지만, 다른 구문을 사용합니다. &lt;code&gt;--mount&lt;/code&gt; 플래그 에 대한 자세한 정보 와 &lt;code&gt;--volume&lt;/code&gt; 과 &lt;code&gt;--mount&lt;/code&gt; 를 비교 하려면 &lt;a href=&quot;../service_create/index#add-bind-mounts-or-volumes&quot;&gt;service create 명령 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bed7237ccc0b8ad3437fa30020a578288a4e4483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--name&lt;/code&gt; flag names the service &lt;code&gt;helloworld&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--name&lt;/code&gt; 플래그 이름 서비스 &lt;code&gt;helloworld&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="a853eb9fbc1c99f3f8c76dfce1506f84d6fa4344" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--no-resolve&lt;/code&gt; option shows IDs for task name, without mapping IDs to Names.</source>
          <target state="translated">&lt;code&gt;--no-resolve&lt;/code&gt; 이름에 매핑 ID가없는 작업 이름에 대한 옵션 프로그램 ID를.</target>
        </trans-unit>
        <trans-unit id="32826a87c3c4abc30e935b98ecd14f2cca87e51e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--node-generic-resources&lt;/code&gt; option takes a list of key-value pair (&lt;code&gt;key=value&lt;/code&gt;) that allows you to advertise user defined resources in a swarm cluster.</source>
          <target state="translated">&lt;code&gt;--node-generic-resources&lt;/code&gt; 옵션은 키 - 값 쌍 (목록 취 &lt;code&gt;key=value&lt;/code&gt; 이 떼 클러스터에서 사용자 정의 자원을 광고 할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="fe1b46c54563bf68f3d96fa56384895ffc4790ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--privileged&lt;/code&gt; flag gives &lt;em&gt;all&lt;/em&gt; capabilities to the container, and it also lifts all the limitations enforced by the &lt;code&gt;device&lt;/code&gt; cgroup controller. In other words, the container can then do almost everything that the host can do. This flag exists to allow special use-cases, like running Docker within Docker.</source>
          <target state="translated">&lt;code&gt;--privileged&lt;/code&gt; 플래그주는 &lt;em&gt;모든&lt;/em&gt; 용기에 대한 기능을하고, 또한 적용하여 모든 제한 리프트 &lt;code&gt;device&lt;/code&gt; cgroup의 컨트롤러. 다시 말해 컨테이너는 호스트가 수행 할 수있는 거의 모든 작업을 수행 할 수 있습니다. 이 플래그는 Docker 내에서 Docker를 실행하는 것과 같은 특수한 사용 사례를 허용하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="bb774c803d079b4a41ab3354f300b230d3e14040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--replicas&lt;/code&gt; flag specifies the desired state of 1 running instance.</source>
          <target state="translated">&lt;code&gt;--replicas&lt;/code&gt; 플래그 1 개 실행 인스턴스의 원하는 상태를 지정한다.</target>
        </trans-unit>
        <trans-unit id="f83197c97e8759a9b35a0a3cfe176f25ddfffb9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rotate&lt;/code&gt; flag does not require any parameters to do a rotation, but you can optionally specify a certificate and key, or a certificate and external CA URL, and those will be used instead of an automatically-generated certificate/key pair.</source>
          <target state="translated">&lt;code&gt;--rotate&lt;/code&gt; 플래그는 회전을 할 매개 변수를 필요로하지 않습니다,하지만 당신은 선택적으로 인증서와 키 또는 인증서 및 외부 CA URL을 지정할 수 있습니다, 그 대신 자동으로 생성 된 인증서 / 키 쌍으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d093ee6fc107327da7a54146804ca8a627398258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--since&lt;/code&gt; and &lt;code&gt;--until&lt;/code&gt; parameters can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &lt;code&gt;10m&lt;/code&gt;, &lt;code&gt;1h30m&lt;/code&gt;) computed relative to the client machine&amp;rsquo;s time. If you do not provide the &lt;code&gt;--since&lt;/code&gt; option, the command returns only new and/or live events. Supported formats for date formatted time stamps include RFC3339Nano, RFC3339, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt;, &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt;, &lt;code&gt;2006-01-02Z07:00&lt;/code&gt;, and &lt;code&gt;2006-01-02&lt;/code&gt;. The local timezone on the client will be used if you do not provide either a &lt;code&gt;Z&lt;/code&gt; or a &lt;code&gt;+-00:00&lt;/code&gt; timezone offset at the end of the timestamp. When providing Unix timestamps enter seconds[.nanoseconds], where seconds is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (aka Unix epoch or Unix time), and the optional .nanoseconds field is a fraction of a second no more than nine digits long.</source>
          <target state="translated">&lt;code&gt;--since&lt;/code&gt; 및 &lt;code&gt;--until&lt;/code&gt; 매개 변수는 유닉스 (예 : 날짜 형식의 타임 스탬프, 또는 이동 시간 문자열을 타임 스탬프가 될 수 &lt;code&gt;10m&lt;/code&gt; , &lt;code&gt;1h30m&lt;/code&gt; 클라이언트 컴퓨터의 시간을 기준으로 계산을). &lt;code&gt;--since&lt;/code&gt; 옵션을 제공하지 않으면 명령은 새 이벤트 및 / 또는 라이브 이벤트 만 반환합니다. 날짜 형식 타임 스탬프에 지원되는 형식에는 RFC3339Nano, RFC3339, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt; , &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt; , &lt;code&gt;2006-01-02Z07:00&lt;/code&gt; 및 &lt;code&gt;2006-01-02&lt;/code&gt; 가 있습니다. &lt;code&gt;Z&lt;/code&gt; 또는 A를 제공하지 않으면 클라이언트의 현지 시간대가 사용됩니다 . &lt;code&gt;+-00:00&lt;/code&gt; 을 .타임 스탬프 끝의 시간대 오프셋 유닉스 타임 스탬프를 제공 할 때 초 [.nanoseconds]를 입력하면 초는 1970 년 1 월 1 일 (자정 UTC / GMT) 이후 경과 한 초 수이며, 유닉스 초 (일명 유닉스 시대 또는 유닉스 시간)를 계산하지 않으며 선택 사항입니다. 나노초 필드는 9 자리 이하의 초의 분수입니다.</target>
        </trans-unit>
        <trans-unit id="652b6615884bf6a1cd485ceedcea4963abfed879" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--since&lt;/code&gt; option shows only the container logs generated after a given date. You can specify the date as an RFC 3339 date, a UNIX timestamp, or a Go duration string (e.g. &lt;code&gt;1m30s&lt;/code&gt;, &lt;code&gt;3h&lt;/code&gt;). Besides RFC3339 date format you may also use RFC3339Nano, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt;, &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt;, &lt;code&gt;2006-01-02Z07:00&lt;/code&gt;, and &lt;code&gt;2006-01-02&lt;/code&gt;. The local timezone on the client will be used if you do not provide either a &lt;code&gt;Z&lt;/code&gt; or a &lt;code&gt;+-00:00&lt;/code&gt; timezone offset at the end of the timestamp. When providing Unix timestamps enter seconds[.nanoseconds], where seconds is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (aka Unix epoch or Unix time), and the optional .nanoseconds field is a fraction of a second no more than nine digits long. You can combine the &lt;code&gt;--since&lt;/code&gt; option with either or both of the &lt;code&gt;--follow&lt;/code&gt; or &lt;code&gt;--tail&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;--since&lt;/code&gt; 의 유일한 옵션을 보여줍니다 해당 날짜 이후에 생성 된 컨테이너 로그. 날짜를 RFC 3339 날짜, UNIX 타임 스탬프 또는 Go 지속 문자열 (예 : &lt;code&gt;1m30s&lt;/code&gt; , &lt;code&gt;3h&lt;/code&gt; ) 로 지정할 수 있습니다 . RFC3339 날짜 형식 외에도 RFC3339Nano, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt; , &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt; , &lt;code&gt;2006-01-02Z07:00&lt;/code&gt; 및 &lt;code&gt;2006-01-02&lt;/code&gt; 를 사용할 수도 있습니다. &lt;code&gt;Z&lt;/code&gt; 또는 &lt;code&gt;+-00:00&lt;/code&gt; 을 제공하지 않으면 클라이언트의 현지 시간대가 사용됩니다 .타임 스탬프 끝의 시간대 오프셋 유닉스 타임 스탬프를 제공 할 때 초 [.nanoseconds]를 입력하면 초는 1970 년 1 월 1 일 (자정 UTC / GMT) 이후 경과 한 초 수이며, 유닉스 초 (일명 유닉스 시대 또는 유닉스 시간)를 계산하지 않으며 선택 사항입니다. 나노초 필드는 9 자리 이하의 초의 분수입니다. 당신은 결합 할 수 있습니다 &lt;code&gt;--since&lt;/code&gt; 의 한쪽 또는 양쪽의와 옵션을 &lt;code&gt;--follow&lt;/code&gt; 또는 &lt;code&gt;--tail&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="bab01cf2bd689f9a42400bd61c72369e65a07ab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--since&lt;/code&gt; option shows only the service logs generated after a given date. You can specify the date as an RFC 3339 date, a UNIX timestamp, or a Go duration string (e.g. &lt;code&gt;1m30s&lt;/code&gt;, &lt;code&gt;3h&lt;/code&gt;). Besides RFC3339 date format you may also use RFC3339Nano, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt;, &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt;, &lt;code&gt;2006-01-02Z07:00&lt;/code&gt;, and &lt;code&gt;2006-01-02&lt;/code&gt;. The local timezone on the client will be used if you do not provide either a &lt;code&gt;Z&lt;/code&gt; or a &lt;code&gt;+-00:00&lt;/code&gt; timezone offset at the end of the timestamp. When providing Unix timestamps enter seconds[.nanoseconds], where seconds is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (aka Unix epoch or Unix time), and the optional .nanoseconds field is a fraction of a second no more than nine digits long. You can combine the &lt;code&gt;--since&lt;/code&gt; option with either or both of the &lt;code&gt;--follow&lt;/code&gt; or &lt;code&gt;--tail&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;--since&lt;/code&gt; 의 유일한 옵션을 보여줍니다 해당 날짜 이후에 생성 된 서비스 로그. 날짜를 RFC 3339 날짜, UNIX 타임 스탬프 또는 Go 지속 문자열 (예 : &lt;code&gt;1m30s&lt;/code&gt; , &lt;code&gt;3h&lt;/code&gt; ) 로 지정할 수 있습니다 . RFC3339 날짜 형식 외에도 RFC3339Nano, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt; , &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt; , &lt;code&gt;2006-01-02Z07:00&lt;/code&gt; 및 &lt;code&gt;2006-01-02&lt;/code&gt; 를 사용할 수도 있습니다. &lt;code&gt;Z&lt;/code&gt; 또는 &lt;code&gt;+-00:00&lt;/code&gt; 을 제공하지 않으면 클라이언트의 현지 시간대가 사용됩니다 .타임 스탬프 끝의 시간대 오프셋 유닉스 타임 스탬프를 제공 할 때 초 [.nanoseconds]를 입력하면 초는 1970 년 1 월 1 일 (자정 UTC / GMT) 이후 경과 한 초 수이며, 유닉스 초 (일명 유닉스 시대 또는 유닉스 시간)를 계산하지 않으며 선택 사항입니다. 나노초 필드는 9 자리 이하의 초의 분수입니다. 당신은 결합 할 수 있습니다 &lt;code&gt;--since&lt;/code&gt; 의 한쪽 또는 양쪽의와 옵션을 &lt;code&gt;--follow&lt;/code&gt; 또는 &lt;code&gt;--tail&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="3600edac5452a3667a2c3e6900d550bfe91f655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--squash&lt;/code&gt; option has a number of known limitations:</source>
          <target state="translated">&lt;code&gt;--squash&lt;/code&gt; 옵션은 알려진 제한 사항을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="868df34827a00906506bf1395e46d56e0920fb6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--squash&lt;/code&gt; option is an experimental feature, and should not be considered stable.</source>
          <target state="translated">&lt;code&gt;--squash&lt;/code&gt; 옵션은 실험적인 기능이며, 안정적인 것으로 간주되어서는 안된다.</target>
        </trans-unit>
        <trans-unit id="54d86090ae9e58411843350e49a7bf462b0b39ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stop-signal&lt;/code&gt; flag sets the system call signal that will be sent to the container to exit. This signal can be a valid unsigned number that matches a position in the kernel&amp;rsquo;s syscall table, for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.</source>
          <target state="translated">&lt;code&gt;--stop-signal&lt;/code&gt; 플래그는 출구에 컨테이너로 전송됩니다 시스템 호출 신호를 설정합니다. 이 신호는 커널의 syscall 테이블의 위치 (예 : 9) 또는 SIGNAME 형식의 신호 이름 (예 : SIGKILL)과 일치하는 유효한 부호없는 숫자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8846e238508789402dc6ccf956f8dc91d051d006" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stop-timeout&lt;/code&gt; flag sets the timeout (in seconds) that a pre-defined (see &lt;code&gt;--stop-signal&lt;/code&gt;) system call signal that will be sent to the container to exit. After timeout elapses the container will be killed with SIGKILL.</source>
          <target state="translated">&lt;code&gt;--stop-timeout&lt;/code&gt; 플래그 (초) 타임 아웃을 설정하는 것을 사전에 정의 된 (참조 &lt;code&gt;--stop-signal&lt;/code&gt; 출구 컨테이너로 전송한다) 시스템 호출 신호. 타임 아웃이 경과하면 컨테이너는 SIGKILL과 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="5495a7454f1586617a7dc6a7549e59d398007aca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--sysctl&lt;/code&gt; sets namespaced kernel parameters (sysctls) in the container. For example, to turn on IP forwarding in the containers network namespace, run this command:</source>
          <target state="translated">&lt;code&gt;--sysctl&lt;/code&gt; 의 용기에 커널 매개 변수 (sysctls) 네임 스페이스를 설정합니다. 예를 들어, 컨테이너 네트워크 네임 스페이스에서 IP 전달을 켜려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="854ac408f31454204ac08d0e6423e78b130a7510" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--tmpfs&lt;/code&gt; flag mounts an empty tmpfs into the container with the &lt;code&gt;rw&lt;/code&gt;, &lt;code&gt;noexec&lt;/code&gt;, &lt;code&gt;nosuid&lt;/code&gt;, &lt;code&gt;size=65536k&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;--tmpfs&lt;/code&gt; 와 함께 용기에 플래그는 마운트 빈의 tmpfs를 &lt;code&gt;rw&lt;/code&gt; , &lt;code&gt;noexec&lt;/code&gt; , &lt;code&gt;nosuid&lt;/code&gt; , &lt;code&gt;size=65536k&lt;/code&gt; 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0fa0a35baa2bfba7770838b9ad13455ac8f296b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--update-delay&lt;/code&gt; flag configures the time delay between updates to a service task or sets of tasks. You can describe the time &lt;code&gt;T&lt;/code&gt; as a combination of the number of seconds &lt;code&gt;Ts&lt;/code&gt;, minutes &lt;code&gt;Tm&lt;/code&gt;, or hours &lt;code&gt;Th&lt;/code&gt;. So &lt;code&gt;10m30s&lt;/code&gt; indicates a 10 minute 30 second delay.</source>
          <target state="translated">&lt;code&gt;--update-delay&lt;/code&gt; 플래그는 서비스 작업에 업데이트 또는 작업 세트 사이의 시간 지연을 구성합니다. 시간 &lt;code&gt;T&lt;/code&gt; 를 초 &lt;code&gt;Ts&lt;/code&gt; , 분 &lt;code&gt;Tm&lt;/code&gt; 또는 시간 &lt;code&gt;Th&lt;/code&gt; 의 조합으로 설명 할 수 있습니다 . 따라서 &lt;code&gt;10m30s&lt;/code&gt; 는 10 분 30 초 지연을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="934f930ffe6caf2c011d78e9b4448a9de589e06f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--update-max-failure-ratio&lt;/code&gt; flag controls what fraction of tasks can fail during an update before the update as a whole is considered to have failed. For example, with &lt;code&gt;--update-max-failure-ratio 0.1 --update-failure-action pause&lt;/code&gt;, after 10% of the tasks being updated fail, the update is paused.</source>
          <target state="translated">&lt;code&gt;--update-max-failure-ratio&lt;/code&gt; 전체 업데이트하기 전에 업데이트하는 동안 실패 할 수있는 작업의 어떤 부분 플래그 컨트롤은 실패한 것으로 간주됩니다. 예를 들어 &lt;code&gt;--update-max-failure-ratio 0.1 --update-failure-action pause&lt;/code&gt; 와 함께 업데이트중인 작업의 10 %가 실패하면 업데이트가 일시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="59ad8b554a390785f6d30eb5a97c2b44cc58fc73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--virtualbox-boot2docker-url&lt;/code&gt; flag takes a few different forms. By default, if no value is specified for this flag, Machine checks locally for a boot2docker ISO. If one is found, it is used as the ISO for the created machine. If one is not found, the latest ISO release available on &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;boot2docker/boot2docker&lt;/a&gt; is downloaded and stored locally for future use. Therefore, you must run &lt;code&gt;docker-machine upgrade&lt;/code&gt; deliberately on a machine if you wish to update the &amp;ldquo;cached&amp;rdquo; boot2docker ISO.</source>
          <target state="translated">&lt;code&gt;--virtualbox-boot2docker-url&lt;/code&gt; 플래그는 몇 가지 다른 형태 걸립니다. 기본적으로이 플래그에 값을 지정하지 않으면 Machine은 로컬로 boot2docker ISO를 확인합니다. 발견 된 경우 생성 된 시스템의 ISO로 사용됩니다. 찾을 수없는 경우 &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;boot2docker / boot2docker&lt;/a&gt; 에서 사용 가능한 최신 ISO 릴리스 가 다운로드되어 나중에 사용하기 위해 로컬로 저장됩니다. 따라서 &quot;캐시 된&quot;boot2docker ISO를 업데이트하려면 시스템에서 고의적으로 &lt;code&gt;docker-machine upgrade&lt;/code&gt; 에서 docker-machine upgrade를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f4dfe5d38bdec5d1891053f396d04d8f227ea20e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--volume&lt;/code&gt; (or &lt;code&gt;-v&lt;/code&gt;) flag takes a value that is in the format &lt;code&gt;&amp;lt;volume_name&amp;gt;:&amp;lt;mountpoint&amp;gt;&lt;/code&gt;. The two parts of the value are separated by a colon (&lt;code&gt;:&lt;/code&gt;) character.</source>
          <target state="translated">&lt;code&gt;--volume&lt;/code&gt; 는 (또는 &lt;code&gt;-v&lt;/code&gt; ) 플래그는 형식 인 값 얻어 &lt;code&gt;&amp;lt;volume_name&amp;gt;:&amp;lt;mountpoint&amp;gt;&lt;/code&gt; . (값의 두 부분은 콜론으로 구분된다 &lt;code&gt;:&lt;/code&gt; ) 문자.</target>
        </trans-unit>
        <trans-unit id="79c57bd734a2d57c422c7ec0f9b8f3c9c845afa9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--volumes-from&lt;/code&gt; flag mounts all the defined volumes from the referenced containers. Containers can be specified by repetitions of the &lt;code&gt;--volumes-from&lt;/code&gt; argument. The container ID may be optionally suffixed with &lt;code&gt;:ro&lt;/code&gt; or &lt;code&gt;:rw&lt;/code&gt; to mount the volumes in read-only or read-write mode, respectively. By default, the volumes are mounted in the same mode (read write or read only) as the reference container.</source>
          <target state="translated">&lt;code&gt;--volumes-from&lt;/code&gt; 참조 된 용기에서 플래그의 모든 마운트 정의 된 볼륨. 컨테이너는 &lt;code&gt;--volumes-from&lt;/code&gt; 인수 를 반복하여 지정할 수 있습니다 . 컨테이너 ID는 선택적으로 &lt;code&gt;:ro&lt;/code&gt; 또는 &lt;code&gt;:rw&lt;/code&gt; 를 접미 하여 볼륨을 각각 읽기 전용 또는 읽기 / 쓰기 모드로 마운트 할 수 있습니다. 기본적으로 볼륨은 참조 컨테이너와 동일한 모드 (읽기 쓰기 또는 읽기 전용)로 마운트됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a5149b5262d073b9c766e953b846fff95d80d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-P&lt;/code&gt; option publishes all the ports to the host interfaces. Docker binds each exposed port to a random port on the host. The range of ports are within an &lt;em&gt;ephemeral port range&lt;/em&gt; defined by &lt;code&gt;/proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt;. Use the &lt;code&gt;-p&lt;/code&gt; flag to explicitly map a single port or range of ports.</source>
          <target state="translated">&lt;code&gt;-P&lt;/code&gt; 의 옵션은 호스트 인터페이스로 모든 포트를 게시합니다. Docker는 노출 된 각 포트를 호스트의 임의 포트에 바인딩합니다. &lt;em&gt;포트 범위&lt;/em&gt; 는 &lt;code&gt;/proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt; 에 의해 정의 된 &lt;em&gt;임시 포트 범위&lt;/em&gt; 내에 있습니다. 단일 포트 또는 포트 범위를 명시 적으로 맵핑 하려면 &lt;code&gt;-p&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d187d0c1f780586ccb4a349b371c0d9954d1e7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-a&lt;/code&gt; flag tells &lt;code&gt;docker run&lt;/code&gt; to bind to the container&amp;rsquo;s &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt;. This makes it possible to manipulate the output and input as needed.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; 플래그는 말한다 &lt;code&gt;docker run&lt;/code&gt; 컨테이너에 바인딩 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 또는 &lt;code&gt;STDERR&lt;/code&gt; . 따라서 필요에 따라 출력 및 입력을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00e78bca83bff0346cfa7bb1929f7a24bd5628d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-b, --bridge=&lt;/code&gt; flag is set to &lt;code&gt;docker0&lt;/code&gt; as default bridge network. It is created automatically when you install Docker. If you are not using the default, you must create and configure the bridge manually or just set it to &amp;lsquo;none&amp;rsquo;: &lt;code&gt;--bridge=none&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;-b, --bridge=&lt;/code&gt; 플래그가 설정되어 &lt;code&gt;docker0&lt;/code&gt; 기본 브리지 네트워크로. Docker를 설치할 때 자동으로 생성됩니다. 기본값을 사용하지 않는 경우 브리지를 수동으로 생성 및 구성하거나 '없음'으로 설정해야합니다. &lt;code&gt;--bridge=none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fef31794e25c5885ab349aeec30b37ec9cfb2e31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-f&lt;/code&gt; flag is optional. If you don&amp;rsquo;t provide this flag on the command line, Compose traverses the working directory and its parent directories looking for a &lt;code&gt;docker-compose.yml&lt;/code&gt; and a &lt;code&gt;docker-compose.override.yml&lt;/code&gt; file. You must supply at least the &lt;code&gt;docker-compose.yml&lt;/code&gt; file. If both files are present on the same directory level, Compose combines the two files into a single configuration.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 플래그는 선택 사항입니다. 명령 행에서이 플래그를 제공하지 않으면 Compose는 작업 디렉토리 및 상위 디렉토리를 탐색하여 &lt;code&gt;docker-compose.yml&lt;/code&gt; 및 &lt;code&gt;docker-compose.override.yml&lt;/code&gt; 파일을 찾습니다 . 최소한 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 제공해야 합니다. 두 파일이 모두 동일한 디렉토리 레벨에 있으면 Compose는 두 파일을 단일 구성으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="be855a59336774399e3a7b83f1b2b7f1d547f976" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--graph&lt;/code&gt; flag for the &lt;code&gt;dockerd&lt;/code&gt; or &lt;code&gt;docker daemon&lt;/code&gt; command was used to indicate the directory in which to store persistent data and resource configuration and has been replaced with the more descriptive &lt;code&gt;--data-root&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;dockerd&lt;/code&gt; 또는 &lt;code&gt;docker daemon&lt;/code&gt; 명령 의 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--graph&lt;/code&gt; 플래그는 영구 데이터 및 자원 구성을 저장할 디렉토리를 나타 내기 위해 사용되었으며보다 설명적인 &lt;code&gt;--data-root&lt;/code&gt; 플래그 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="76c0ec7a2c9ee426e880b46a80e62d861fb434da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; or &lt;code&gt;--quiet&lt;/code&gt; option only shows IDs of the tasks in the stack. This example outputs all task IDs of the &amp;ldquo;voting&amp;rdquo; stack;</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; 또는 &lt;code&gt;--quiet&lt;/code&gt; 옵션은 스택의 작업의 ID를 보여줍니다. 이 예는 &quot;투표&quot;스택의 모든 작업 ID를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="321f4b5ce4448eb4e35448e4bc0fe2f7c45b6bec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-v&lt;/code&gt; flag mounts the current working directory into the container. The &lt;code&gt;-w&lt;/code&gt; lets the command being executed inside the current working directory, by changing into the directory to the value returned by &lt;code&gt;pwd&lt;/code&gt;. So this combination executes the command using the container, but inside the current working directory.</source>
          <target state="translated">&lt;code&gt;-v&lt;/code&gt; 플래그는 용기에 현재 작업 디렉토리를 마운트합니다. &lt;code&gt;-w&lt;/code&gt; 는 에 의해 반환 된 값으로 디렉토리로 변경하여, 현재 작업 디렉토리 내에서 실행되는 명령 할 수 있습니다 &lt;code&gt;pwd&lt;/code&gt; . 따라서이 조합은 컨테이너를 사용하지만 현재 작업 디렉토리 내에서 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6715ad91a3f3e2ea443f1c9685408c8bf699b5f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-w&lt;/code&gt; lets the command being executed inside directory given, here &lt;code&gt;/path/to/dir/&lt;/code&gt;. If the path does not exist it is created inside the container.</source>
          <target state="translated">&lt;code&gt;-w&lt;/code&gt; 는 명령이 여기에 주어진 디렉토리 내에서 실행되는 수 &lt;code&gt;/path/to/dir/&lt;/code&gt; . 경로가 존재하지 않으면 경로가 컨테이너 내부에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a07135f67e45c6c5342f6d4af54f3e2573322ad0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.Field&lt;/code&gt; syntax doesn&amp;rsquo;t work when the field name begins with a number, but the template language&amp;rsquo;s &lt;code&gt;index&lt;/code&gt; function does. The &lt;code&gt;.NetworkSettings.Ports&lt;/code&gt; section contains a map of the internal port mappings to a list of external address/port objects. To grab just the numeric public port, you use &lt;code&gt;index&lt;/code&gt; to find the specific port map, and then &lt;code&gt;index&lt;/code&gt; 0 contains the first object inside of that. Then we ask for the &lt;code&gt;HostPort&lt;/code&gt; field to get the public address.</source>
          <target state="translated">&lt;code&gt;.Field&lt;/code&gt; 의 필드 이름이 숫자로 시작하지만 템플릿 언어의 경우 구문이 작동하지 않는 &lt;code&gt;index&lt;/code&gt; 기능을 수행합니다. &lt;code&gt;.NetworkSettings.Ports&lt;/code&gt; 의 부분은 외부 주소 / 포트 개체의 목록에 대한 내부 포트 매핑의지도가 포함되어 있습니다. 숫자 공용 포트만 가져 오려면 &lt;code&gt;index&lt;/code&gt; 를 사용 하여 특정 포트 맵을 찾은 다음 &lt;code&gt;index&lt;/code&gt; 0에 그 안에 첫 번째 객체가 포함됩니다. 그런 다음 공개 주소를 얻기 위해 &lt;code&gt;HostPort&lt;/code&gt; 필드를 요청 합니다.</target>
        </trans-unit>
        <trans-unit id="b45bcfe28cfbc7bf1e4c9d18f73bcfd15b5b4045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ADD&lt;/code&gt; instruction copies new files, directories or remote file URLs from &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; and adds them to the filesystem of the image at the path &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ADD&lt;/code&gt; 명령에서 파일, 디렉토리 또는 원격 파일 URL 새 복사본 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 과 경로에있는 이미지의 파일 시스템에 추가 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac454db47a7141d94be83ec27a2881ff73c5a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ARG&lt;/code&gt; instruction defines a variable that users can pass at build-time to the builder with the &lt;code&gt;docker build&lt;/code&gt; command using the &lt;code&gt;--build-arg &amp;lt;varname&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; flag. If a user specifies a build argument that was not defined in the Dockerfile, the build outputs a warning.</source>
          <target state="translated">&lt;code&gt;ARG&lt;/code&gt; 의 명령어는 사용자가 빌더와 제작시에 전달할 수있는 변수 정의 &lt;code&gt;docker build&lt;/code&gt; 은 USING 명령 &lt;code&gt;--build-arg &amp;lt;varname&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 플래그. 사용자가 Dockerfile에 정의되지 않은 빌드 인수를 지정하면 빌드가 경고를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="d0ccb62f794462cdcfdf2433ebe70961e4918f85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AVAILABILITY&lt;/code&gt; column shows whether or not the scheduler can assign tasks to the node:</source>
          <target state="translated">&lt;code&gt;AVAILABILITY&lt;/code&gt; 스케줄러가 노드에 작업을 할당 할 수 있는지 여부를 열 쇼 :</target>
        </trans-unit>
        <trans-unit id="417ce49286ee166704f694561cf8b565bdfb59bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CMD&lt;/code&gt; instruction has three forms:</source>
          <target state="translated">&lt;code&gt;CMD&lt;/code&gt; 의 명령은 세 가지 형태가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9a203c026fa9c79445c4b63b7715ada33d208b40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COPY&lt;/code&gt; instruction copies new files or directories from &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; and adds them to the filesystem of the container at the path &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 명령 사본을 새 파일이나 디렉토리에서 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 및 경로에서 컨테이너의 파일 시스템에 추가 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d9652ade73caed1f5cb10142c1b7360bd4afe13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dockerfile&lt;/code&gt; assumes that your application is called &lt;code&gt;aspnetapp&lt;/code&gt;. Change the &lt;code&gt;Dockerfile&lt;/code&gt; to use the DLL file of your project.</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 는 응용 프로그램이 호출한다고 가정 &lt;code&gt;aspnetapp&lt;/code&gt; . &lt;code&gt;Dockerfile&lt;/code&gt; 을 변경 하여 프로젝트의 DLL 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82f6ee7a0e96f694b25ee985575726b6ec82c45b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ENTRYPOINT&lt;/code&gt; of an image is similar to a &lt;code&gt;COMMAND&lt;/code&gt; because it specifies what executable to run when the container starts, but it is (purposely) more difficult to override. The &lt;code&gt;ENTRYPOINT&lt;/code&gt; gives a container its default nature or behavior, so that when you set an &lt;code&gt;ENTRYPOINT&lt;/code&gt; you can run the container &lt;em&gt;as if it were that binary&lt;/em&gt;, complete with default options, and you can pass in more options via the &lt;code&gt;COMMAND&lt;/code&gt;. But, sometimes an operator may want to run something else inside the container, so you can override the default &lt;code&gt;ENTRYPOINT&lt;/code&gt; at runtime by using a string to specify the new &lt;code&gt;ENTRYPOINT&lt;/code&gt;. Here is an example of how to run a shell in a container that has been set up to automatically run something else (like &lt;code&gt;/usr/bin/redis-server&lt;/code&gt;):</source>
          <target state="translated">이미지 의 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 는 컨테이너가 시작될 때 실행할 실행 파일을 지정하기 때문에 &lt;code&gt;COMMAND&lt;/code&gt; 과 유사 하지만 (의도적으로) 재정의하기가 더 어렵습니다. &lt;code&gt;ENTRYPOINT&lt;/code&gt; 당신이 설정 한 경우 그래서, 컨테이너를 기본 성격이나 행동을 제공 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 당신이 용기를 실행할 수 &lt;em&gt;는 바이너리 것처럼&lt;/em&gt; 기본 옵션을 완료, 당신은을 통해 더 많은 옵션에 전달할 수 &lt;code&gt;COMMAND&lt;/code&gt; . 그러나 때로는 운영자가 컨테이너 내부에서 다른 것을 실행하려고 할 수 있으므로 런타임에 새 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 를 지정하는 문자열을 사용하여 기본 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 를 무시할 수 있습니다.. 다음은 &lt;code&gt;/usr/bin/redis-server&lt;/code&gt; 와 같은 다른 것을 자동으로 실행하도록 설정된 컨테이너에서 셸을 실행하는 방법의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="45551afa7e325e55770cef5ae4c690193b754077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ENV&lt;/code&gt; instruction has two forms. The first form, &lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;, will set a single variable to a value. The entire string after the first space will be treated as the &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; - including whitespace characters. The value will be interpreted for other environment variables, so quote characters will be removed if they are not escaped.</source>
          <target state="translated">&lt;code&gt;ENV&lt;/code&gt; 의 명령은 두 가지 형태가있다. 첫 번째 형식 인 &lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; 는 단일 변수를 값으로 설정합니다. 첫 번째 공백 뒤의 전체 문자열은 공백 문자를 포함 하여 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 으로 취급됩니다 . 값은 다른 환경 변수에 대해 해석되므로 이스케이프하지 않으면 따옴표 문자가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e26b1f9ce0f2c0c2eaf61a3bc6b69242e0d92f5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ENV&lt;/code&gt; instruction sets the environment variable &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; to the value &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt;. This value will be in the environment for all subsequent instructions in the build stage and can be &lt;a href=&quot;#environment-replacement&quot;&gt;replaced inline&lt;/a&gt; in many as well.</source>
          <target state="translated">&lt;code&gt;ENV&lt;/code&gt; 의 지시는 환경 변수 설정 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 값 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; . 이 값은 빌드 단계의 모든 후속 명령에 대한 환경에 있으며 &lt;a href=&quot;#environment-replacement&quot;&gt;인라인&lt;/a&gt; 으로도 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f497b45d5ed2e762023ba2fab7f21dad19db409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPOSE&lt;/code&gt; instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published. To actually publish the port when running the container, use the &lt;code&gt;-p&lt;/code&gt; flag on &lt;code&gt;docker run&lt;/code&gt; to publish and map one or more ports, or the &lt;code&gt;-P&lt;/code&gt; flag to publish all exposed ports and map them to high-order ports.</source>
          <target state="translated">&lt;code&gt;EXPOSE&lt;/code&gt; 명령은 실제로 포트를 게시하지 않습니다. 이미지를 작성하는 사람과 컨테이너를 실행하는 사람 사이에서 공개 할 포트에 대한 문서 유형으로 작동합니다. 컨테이너를 실행할 때 실제로 포트를 공개하려면 &lt;code&gt;docker run&lt;/code&gt; 에서 &lt;code&gt;-p&lt;/code&gt; 플래그를 사용하여 하나 이상의 포트를 공개하고 맵핑하거나 &lt;code&gt;-P&lt;/code&gt; 플래그를 사용하여 노출 된 모든 포트를 공개하고 상위 포트에 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="645f60437d027833327e4b44fb9a229f2bfb6400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPOSE&lt;/code&gt; instruction informs Docker that the container listens on the specified network ports at runtime. You can specify whether the port listens on TCP or UDP, and the default is TCP if the protocol is not specified.</source>
          <target state="translated">&lt;code&gt;EXPOSE&lt;/code&gt; 지시 정보 용 도커 그 실행시 지정된 네트워크 포트 용기를 기울인다. 포트가 TCP 또는 UDP에서 수신되는지 여부를 지정할 수 있으며 프로토콜이 지정되지 않은 경우 기본값은 TCP입니다.</target>
        </trans-unit>
        <trans-unit id="716562e8a5dadfe33cef2e8369dbac6cc00b394f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; instruction initializes a new build stage and sets the &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#base-image&quot;&gt;&lt;em&gt;Base Image&lt;/em&gt;&lt;/a&gt; for subsequent instructions. As such, a valid &lt;code&gt;Dockerfile&lt;/code&gt; must start with a &lt;code&gt;FROM&lt;/code&gt; instruction. The image can be any valid image &amp;ndash; it is especially easy to start by &lt;strong&gt;pulling an image&lt;/strong&gt; from the &lt;a href=&quot;../../../get-started/index&quot;&gt;&lt;em&gt;Public Repositories&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 명령은 새로운 빌드 단계를 초기화하고 설정하는 &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#base-image&quot;&gt;&lt;em&gt;기본 이미지&lt;/em&gt;&lt;/a&gt; 다음 지침을. 따라서 유효한 &lt;code&gt;Dockerfile&lt;/code&gt; 은 &lt;code&gt;FROM&lt;/code&gt; 명령으로 시작해야합니다 . 이미지는 유효한 이미지 일 수 있습니다. 특히 &lt;a href=&quot;../../../get-started/index&quot;&gt;&lt;em&gt;공용 리포지토리&lt;/em&gt;&lt;/a&gt; 에서 &lt;strong&gt;이미지를&lt;/strong&gt; 가져 &lt;strong&gt;와서&lt;/strong&gt; 쉽게 시작할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42ec5b4969dc13ba5cb34f54cea73cb4d3f05903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; tag is pulling a signed image. You cannot build an image that has a &lt;code&gt;FROM&lt;/code&gt; that is not either present locally or signed. Given that content trust data exists for the tag &lt;code&gt;latest&lt;/code&gt;, the following build should succeed:</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 태그는 서명 이미지를 당기고 있습니다. 로컬에 있거나 서명되지 않은 &lt;code&gt;FROM&lt;/code&gt; 이있는 이미지는 작성할 수 없습니다 . &lt;code&gt;latest&lt;/code&gt; 태그에 대한 콘텐츠 신뢰 데이터가 존재 하면 다음 빌드가 성공합니다.</target>
        </trans-unit>
        <trans-unit id="c2e9d22e237ec841e63406770ce97846d2dc59a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEALTHCHECK&lt;/code&gt; feature was added in Docker 1.12.</source>
          <target state="translated">&lt;code&gt;HEALTHCHECK&lt;/code&gt; 기능은 도커 1.12에서 추가되었다.</target>
        </trans-unit>
        <trans-unit id="8d43fa4cfb4ede6f95d66b190829555714301acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEALTHCHECK&lt;/code&gt; instruction has two forms:</source>
          <target state="translated">&lt;code&gt;HEALTHCHECK&lt;/code&gt; 명령은 두 가지 형태가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ea5519b5379f448f3642a0d47adc25774c5c8041" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEALTHCHECK&lt;/code&gt; instruction tells Docker how to test a container to check that it is still working. This can detect cases such as a web server that is stuck in an infinite loop and unable to handle new connections, even though the server process is still running.</source>
          <target state="translated">&lt;code&gt;HEALTHCHECK&lt;/code&gt; 명령은 여전히 작동하는지 확인하기 위해 컨테이너를 테스트하는 방법 도커를 알려줍니다. 이것은 서버 프로세스가 여전히 실행 중이더라도 무한 루프에 갇혀서 새 연결을 처리 할 수없는 웹 서버와 같은 경우를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b7ee116d84bdf3e73f6a2de56ebf95b883e1a00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LABEL&lt;/code&gt; instruction adds metadata to an image. A &lt;code&gt;LABEL&lt;/code&gt; is a key-value pair. To include spaces within a &lt;code&gt;LABEL&lt;/code&gt; value, use quotes and backslashes as you would in command-line parsing. A few usage examples:</source>
          <target state="translated">&lt;code&gt;LABEL&lt;/code&gt; 의 명령은 이미지에 메타 데이터를 추가한다. &lt;code&gt;LABEL&lt;/code&gt; 는 키 - 값 쌍이다. &lt;code&gt;LABEL&lt;/code&gt; 값 내에 공백을 포함 시키려면 명령 행 구문 분석에서와 같이 따옴표와 백 슬래시를 사용하십시오. 몇 가지 사용 예 :</target>
        </trans-unit>
        <trans-unit id="67a0a8cc35e4d2e1aa6af5e6fbd62bde27b51ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MAINTAINER&lt;/code&gt; instruction sets the &lt;em&gt;Author&lt;/em&gt; field of the generated images. The &lt;code&gt;LABEL&lt;/code&gt; instruction is a much more flexible version of this and you should use it instead, as it enables setting any metadata you require, and can be viewed easily, for example with &lt;code&gt;docker inspect&lt;/code&gt;. To set a label corresponding to the &lt;code&gt;MAINTAINER&lt;/code&gt; field you could use:</source>
          <target state="translated">&lt;code&gt;MAINTAINER&lt;/code&gt; 의 명령어 세트 &lt;em&gt;저자&lt;/em&gt; 생성 이미지 필드. &lt;code&gt;LABEL&lt;/code&gt; 의 명령이 훨씬 더 유연 버전이며 당신이 필요한 모든 메타 데이터를 설정 가능하고, 함께 예를 들어, 쉽게 볼 수 있습니다 당신은 대신 사용한다 &lt;code&gt;docker inspect&lt;/code&gt; . &lt;code&gt;MAINTAINER&lt;/code&gt; 필드에 해당하는 레이블을 설정하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ebbb70f1473098a5c74c9ab58cb56302be856a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MANAGER STATUS&lt;/code&gt; column shows node participation in the Raft consensus:</source>
          <target state="translated">&lt;code&gt;MANAGER STATUS&lt;/code&gt; 뗏목 컨센서스에 열 쇼 노드 참여 :</target>
        </trans-unit>
        <trans-unit id="f7c7704a78191792a1d8655bea11a83fc3049b98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MANAGER&lt;/code&gt; column identifies the manager nodes in the swarm. The empty status in this column for &lt;code&gt;worker1&lt;/code&gt; and &lt;code&gt;worker2&lt;/code&gt; identifies them as worker nodes.</source>
          <target state="translated">&lt;code&gt;MANAGER&lt;/code&gt; 의 열은 무리에서 관리 노드를 식별합니다. 이 열의 빈 상태 &lt;code&gt;worker1&lt;/code&gt; 에 와 &lt;code&gt;worker2&lt;/code&gt; 에 작업자 노드로 식별을.</target>
        </trans-unit>
        <trans-unit id="501ef9a7f35fb49486364828614f2e22487de202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mountpoint&lt;/code&gt; is the path on the host (v1) or in the plugin (v2) where the volume has been made available.</source>
          <target state="translated">&lt;code&gt;Mountpoint&lt;/code&gt; 호스트 (V1) 또는 볼륨이 제공되어 플러그 (V2)의 경로이다.</target>
        </trans-unit>
        <trans-unit id="f72509df1f3a093ed48e1717dc925c13dc152b72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ONBUILD&lt;/code&gt; instruction adds to the image a &lt;em&gt;trigger&lt;/em&gt; instruction to be executed at a later time, when the image is used as the base for another build. The trigger will be executed in the context of the downstream build, as if it had been inserted immediately after the &lt;code&gt;FROM&lt;/code&gt; instruction in the downstream &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ONBUILD&lt;/code&gt; 의 명령은 이미지에 추가 &lt;em&gt;트리거&lt;/em&gt; 화상 다른 빌드 용 기재로서 사용 이후에 실행되는 명령. 트리거는 다운 스트림 &lt;code&gt;Dockerfile&lt;/code&gt; 의 &lt;code&gt;FROM&lt;/code&gt; 명령 바로 다음에 삽입 된 것처럼 다운 스트림 빌드 컨텍스트에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a097269ed1f1efba8a2d1de1fbc25ad35e65dfc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PLUGIN_ID&lt;/code&gt; value is either the plugin&amp;rsquo;s name or a path to its specification file. The plugin&amp;rsquo;s implementation determines whether you can specify a name or path. Consult with your Docker administrator to get information about the plugins available to you.</source>
          <target state="translated">&lt;code&gt;PLUGIN_ID&lt;/code&gt; 의 값 중 하나를 플러그인의 이름이나 사양 파일에 대한 경로입니다. 플러그인의 구현은 이름 또는 경로를 지정할 수 있는지 여부를 결정합니다. 사용 가능한 플러그인에 대한 정보는 Docker 관리자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="3340492be3828b9c868ba42851749e55259a3bbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REPLICAS&lt;/code&gt; column shows both the &lt;em&gt;actual&lt;/em&gt; and &lt;em&gt;desired&lt;/em&gt; number of tasks for the service.</source>
          <target state="translated">&lt;code&gt;REPLICAS&lt;/code&gt; 열 방송 모두 &lt;em&gt;실제&lt;/em&gt; 및 &lt;em&gt;원하는&lt;/em&gt; 서비스에 대한 태스크의 수.</target>
        </trans-unit>
        <trans-unit id="870bd21b88f50c54e7de0b3f963b7fc150117ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RUN&lt;/code&gt; instruction will execute any commands in a new layer on top of the current image and commit the results. The resulting committed image will be used for the next step in the &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RUN&lt;/code&gt; 의 명령은 현재 화상의 위에 새로운 층에 임의의 명령어를 실행하고 그 결과를 투입한다. 결과 커밋 된 이미지는 &lt;code&gt;Dockerfile&lt;/code&gt; 의 다음 단계에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="aee97a7ef2f533b4a208999ce506515a16a4128f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; feature was added in Docker 1.12.</source>
          <target state="translated">&lt;code&gt;SHELL&lt;/code&gt; 의 기능은 도커 1.12에서 추가되었다.</target>
        </trans-unit>
        <trans-unit id="1f46243e9474ba3fbb5fc42070b6a0e810312875" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction allows the default shell used for the &lt;em&gt;shell&lt;/em&gt; form of commands to be overridden. The default shell on Linux is &lt;code&gt;[&quot;/bin/sh&quot;, &quot;-c&quot;]&lt;/code&gt;, and on Windows is &lt;code&gt;[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]&lt;/code&gt;. The &lt;code&gt;SHELL&lt;/code&gt; instruction &lt;em&gt;must&lt;/em&gt; be written in JSON form in a Dockerfile.</source>
          <target state="translated">&lt;code&gt;SHELL&lt;/code&gt; 의 명령은 사용되는 기본 쉘 수 있습니다 &lt;em&gt;쉘&lt;/em&gt; 오버라이드 (override) 할 명령의 형태. Linux의 기본 쉘은 &lt;code&gt;[&quot;/bin/sh&quot;, &quot;-c&quot;]&lt;/code&gt; 이고 Windows의 경우 &lt;code&gt;[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]&lt;/code&gt; 입니다. &lt;code&gt;SHELL&lt;/code&gt; 의 명령이 &lt;em&gt;있어야합니다&lt;/em&gt; Dockerfile에 JSON 형태로 기록.</target>
        </trans-unit>
        <trans-unit id="1163d8948bca451e34ca883bf4efe7959b615e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction can also be used on Linux should an alternate shell be required such as &lt;code&gt;zsh&lt;/code&gt;, &lt;code&gt;csh&lt;/code&gt;, &lt;code&gt;tcsh&lt;/code&gt; and others.</source>
          <target state="translated">&lt;code&gt;SHELL&lt;/code&gt; 의 리눅스에서 사용할 수있는 명령은 다른 쉘과 같은 요구해야한다 &lt;code&gt;zsh&lt;/code&gt; 을 , &lt;code&gt;csh&lt;/code&gt; , &lt;code&gt;tcsh&lt;/code&gt; 의 등.</target>
        </trans-unit>
        <trans-unit id="9402e574cf122018a583eec5b329c405d3666b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction can appear multiple times. Each &lt;code&gt;SHELL&lt;/code&gt; instruction overrides all previous &lt;code&gt;SHELL&lt;/code&gt; instructions, and affects all subsequent instructions. For example:</source>
          <target state="translated">&lt;code&gt;SHELL&lt;/code&gt; 의 명령이 여러 번 나타날 수 있습니다. 각 &lt;code&gt;SHELL&lt;/code&gt; 의 명령은 이전의 모든 우선 &lt;code&gt;SHELL&lt;/code&gt; 의 지침을, 이후의 모든 명령에 영향을 미칩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e98590ef0a2096201cca8d93674ffaef975a01dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction could also be used to modify the way in which a shell operates. For example, using &lt;code&gt;SHELL cmd /S /C /V:ON|OFF&lt;/code&gt; on Windows, delayed environment variable expansion semantics could be modified.</source>
          <target state="translated">&lt;code&gt;SHELL&lt;/code&gt; 의 명령은 쉘이 작동하는 방식을 수정하는 데 사용할 수 있습니다. 예를 들어, Windows에서 &lt;code&gt;SHELL cmd /S /C /V:ON|OFF&lt;/code&gt; 를 사용하면 지연된 환경 변수 확장 시맨틱을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6298e85aed297aa06c04ef1003db81ec2c7ef26c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction is particularly useful on Windows where there are two commonly used and quite different native shells: &lt;code&gt;cmd&lt;/code&gt; and &lt;code&gt;powershell&lt;/code&gt;, as well as alternate shells available including &lt;code&gt;sh&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SHELL&lt;/code&gt; 의 두 일반적으로 사용되는 아주 다양한 기본 쉘이 어디에 명령은 Windows에서 특히 유용 &lt;code&gt;cmd&lt;/code&gt; 를 하고 &lt;code&gt;powershell&lt;/code&gt; 뿐만 아니라 포함하여 사용 가능한 대체 쉘 &lt;code&gt;sh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70da59d5f956e683e513e4afc1818bb61971fb54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGNED TAG&lt;/code&gt; is the signed image tag with a unique content-addressable &lt;code&gt;DIGEST&lt;/code&gt;. &lt;code&gt;SIGNERS&lt;/code&gt; lists all entities who have signed.</source>
          <target state="translated">&lt;code&gt;SIGNED TAG&lt;/code&gt; 고유 한 내용 주소와 서명 이미지 태그입니다 &lt;code&gt;DIGEST&lt;/code&gt; . &lt;code&gt;SIGNERS&lt;/code&gt; 는 서명 한 모든 엔티티를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="1d1da3c14a5462c93cead1c428e7eedd8878cdc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIZE&lt;/code&gt; is the cumulative space taken up by the image and all its parent images. This is also the disk space used by the contents of the Tar file created when you &lt;code&gt;docker save&lt;/code&gt; an image.</source>
          <target state="translated">&lt;code&gt;SIZE&lt;/code&gt; 이미지의 모든 부모 이미지가 차지하는 공간을 누적한다. 도 &lt;code&gt;docker save&lt;/code&gt; 이미지를 저장할 때 생성 된 Tar 파일의 내용에 사용되는 디스크 공간이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="1541d778170a621d3c22bd5b6e13485df9fa5abd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;STOPSIGNAL&lt;/code&gt; instruction sets the system call signal that will be sent to the container to exit. This signal can be a valid unsigned number that matches a position in the kernel&amp;rsquo;s syscall table, for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.</source>
          <target state="translated">&lt;code&gt;STOPSIGNAL&lt;/code&gt; 명령 출구 컨테이너에 전송 될 시스템 호출 신호를 설정한다. 이 신호는 커널의 syscall 테이블의 위치 (예 : 9) 또는 SIGNAME 형식의 신호 이름 (예 : SIGKILL)과 일치하는 유효한 부호없는 숫자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3510f8e32a94f048c18787c43f116f8b2b1db4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SignedTags&lt;/code&gt; key will list the &lt;code&gt;SignedTag&lt;/code&gt; name, its &lt;code&gt;Digest&lt;/code&gt;, and the &lt;code&gt;Signers&lt;/code&gt; responsible for the signature.</source>
          <target state="translated">&lt;code&gt;SignedTags&lt;/code&gt; 의 키를 나열합니다 &lt;code&gt;SignedTag&lt;/code&gt; 의 이름, &lt;code&gt;Digest&lt;/code&gt; 와 &lt;code&gt;Signers&lt;/code&gt; 서명에 대한 책임을.</target>
        </trans-unit>
        <trans-unit id="0a3f768c13747f5e7ee4e46e620852cfb97cee1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TLSConfig&lt;/code&gt; field is optional and TLS will only be verified if this configuration is present.</source>
          <target state="translated">&lt;code&gt;TLSConfig&lt;/code&gt; 의 필드는 선택 사항이며,이 구성이 존재하는 경우 TLS 만 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="c93989b2fb4eaed0d00803c2508edabbae9aa2ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;URL&lt;/code&gt; parameter can refer to three kinds of resources: Git repositories, pre-packaged tarball contexts and plain text files.</source>
          <target state="translated">&lt;code&gt;URL&lt;/code&gt; 의 Git 저장소, 미리 포장 된 타르볼 컨텍스트 및 일반 텍스트 파일 : 매개 변수는 자원 세 가지 종류를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="995c1b14070453923cd78f9b81be5fac37fc342e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USER&lt;/code&gt; at line 2 evaluates to &lt;code&gt;some_user&lt;/code&gt; as the &lt;code&gt;user&lt;/code&gt; variable is defined on the subsequent line 3. The &lt;code&gt;USER&lt;/code&gt; at line 4 evaluates to &lt;code&gt;what_user&lt;/code&gt; as &lt;code&gt;user&lt;/code&gt; is defined and the &lt;code&gt;what_user&lt;/code&gt; value was passed on the command line. Prior to its definition by an &lt;code&gt;ARG&lt;/code&gt; instruction, any use of a variable results in an empty string.</source>
          <target state="translated">&lt;code&gt;USER&lt;/code&gt; 라인 2 개에서 평가하여 &lt;code&gt;some_user&lt;/code&gt; 는 AS &lt;code&gt;user&lt;/code&gt; 변수는 이후 라인 3에 정의 &lt;code&gt;USER&lt;/code&gt; 행에서 4 개 평가하여 &lt;code&gt;what_user&lt;/code&gt; 를 같이 &lt;code&gt;user&lt;/code&gt; 정의되고 &lt;code&gt;what_user&lt;/code&gt; 의 값은 명령 라인에 통과시켰다. &lt;code&gt;ARG&lt;/code&gt; 명령어로 정의하기 전에 변수를 사용하면 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="b2b6c1993ea47bca5c16249690dcc2cdf3b59597" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USER&lt;/code&gt; instruction sets the user name (or UID) and optionally the user group (or GID) to use when running the image and for any &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt; and &lt;code&gt;ENTRYPOINT&lt;/code&gt; instructions that follow it in the &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;USER&lt;/code&gt; 의 명령어 집합은 사용자 이름 (또는 UID) 및 임의로 사용자 그룹 (또는 GID) 이미지를 실행할 때 사용하기위한 임의 &lt;code&gt;RUN&lt;/code&gt; , &lt;code&gt;CMD&lt;/code&gt; 및 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 그것을 따라 안내 &lt;code&gt;Dockerfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d33671ff9ff81e4a1193fb055f7f6d6cbdaea5a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VOLUME&lt;/code&gt; instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers. The value can be a JSON array, &lt;code&gt;VOLUME [&quot;/var/log/&quot;]&lt;/code&gt;, or a plain string with multiple arguments, such as &lt;code&gt;VOLUME /var/log&lt;/code&gt; or &lt;code&gt;VOLUME /var/log /var/db&lt;/code&gt;. For more information/examples and mounting instructions via the Docker client, refer to &lt;a href=&quot;https://docs.docker.com/storage#/mount-a-host-directory-as-a-data-volume&quot;&gt;&lt;em&gt;Share Directories via Volumes&lt;/em&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;VOLUME&lt;/code&gt; 명령어는 지정된 이름과 부호를 유지하는 외부 네이티브 호스트 또는 다른 용기로부터의 볼륨으로 장착과 마운트 포인트를 생성한다. 값은 JSON 배열, &lt;code&gt;VOLUME [&quot;/var/log/&quot;]&lt;/code&gt; 또는 여러 인수가있는 일반 문자열 (예 : &lt;code&gt;VOLUME /var/log&lt;/code&gt; 또는 &lt;code&gt;VOLUME /var/log /var/db&lt;/code&gt; 있습니다. Docker 클라이언트를 통한 자세한 정보 / 예 및 마운트 지침은 &lt;a href=&quot;https://docs.docker.com/storage#/mount-a-host-directory-as-a-data-volume&quot;&gt;&lt;em&gt;볼륨을 통한 디렉토리 공유&lt;/em&gt;&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e27e606679dcb2a5aacc2d44d5f337f925fc0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WORKDIR&lt;/code&gt; instruction can be used multiple times in a &lt;code&gt;Dockerfile&lt;/code&gt;. If a relative path is provided, it will be relative to the path of the previous &lt;code&gt;WORKDIR&lt;/code&gt; instruction. For example:</source>
          <target state="translated">&lt;code&gt;WORKDIR&lt;/code&gt; 의 명령은 여러 번 사용할 수 있습니다 &lt;code&gt;Dockerfile&lt;/code&gt; . 상대 경로가 제공되면 이전 &lt;code&gt;WORKDIR&lt;/code&gt; 명령어 의 경로를 기준으로합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a147d370a985d02c05500bdc3abd64abc4f75c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WORKDIR&lt;/code&gt; instruction can resolve environment variables previously set using &lt;code&gt;ENV&lt;/code&gt;. You can only use environment variables explicitly set in the &lt;code&gt;Dockerfile&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;WORKDIR&lt;/code&gt; 의 명령은 환경 변수가 이전에 사용하여 설정 해결할 수 있습니다 &lt;code&gt;ENV&lt;/code&gt; 를 . &lt;code&gt;Dockerfile&lt;/code&gt; 에 명시 적으로 설정된 환경 변수 만 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c841bd1ff530bf145434255ac0536325cb79900e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WORKDIR&lt;/code&gt; instruction sets the working directory for any &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt;, &lt;code&gt;ENTRYPOINT&lt;/code&gt;, &lt;code&gt;COPY&lt;/code&gt; and &lt;code&gt;ADD&lt;/code&gt; instructions that follow it in the &lt;code&gt;Dockerfile&lt;/code&gt;. If the &lt;code&gt;WORKDIR&lt;/code&gt; doesn&amp;rsquo;t exist, it will be created even if it&amp;rsquo;s not used in any subsequent &lt;code&gt;Dockerfile&lt;/code&gt; instruction.</source>
          <target state="translated">&lt;code&gt;WORKDIR&lt;/code&gt; 의 명령은 작업 디렉토리를 설정 &lt;code&gt;RUN&lt;/code&gt; , &lt;code&gt;CMD&lt;/code&gt; , &lt;code&gt;ENTRYPOINT&lt;/code&gt; , &lt;code&gt;COPY&lt;/code&gt; 및 &lt;code&gt;ADD&lt;/code&gt; 에에 따라 지침 &lt;code&gt;Dockerfile&lt;/code&gt; . 는 IF &lt;code&gt;WORKDIR&lt;/code&gt; 이 존재하지 않는,이 이후에 사용 아니더라도 생성됩니다 &lt;code&gt;Dockerfile&lt;/code&gt; 의 명령.</target>
        </trans-unit>
        <trans-unit id="2dd0484854b35b2483fd38a2b7dc3bb5dc5ef886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[REPOSITORY[:TAG]]&lt;/code&gt; value must be an &amp;ldquo;exact match&amp;rdquo;. This means that, for example, &lt;code&gt;docker images jav&lt;/code&gt; does not match the image &lt;code&gt;java&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[REPOSITORY[:TAG]]&lt;/code&gt; 값은 &quot;정확히 일치&quot;해야합니다. 이는 예를 들어 &lt;code&gt;docker images jav&lt;/code&gt; 가 &lt;code&gt;java&lt;/code&gt; 이미지와 일치하지 않음 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="13597d6a87d88f87cf53223339f91d85dd2b2aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ancestor&lt;/code&gt; filter matches containers based on its image or a descendant of it. The filter supports the following image representation:</source>
          <target state="translated">&lt;code&gt;ancestor&lt;/code&gt; 필터는 이미지 또는 그것의 자손에 기초하여 용기 일치한다. 필터는 다음 이미지 표현을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e2af6f0edf436040d36923f5820566c22d471ac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aufs&lt;/code&gt; driver is the oldest, but is based on a Linux kernel patch-set that is unlikely to be merged into the main kernel. These are also known to cause some serious kernel crashes. However &lt;code&gt;aufs&lt;/code&gt; allows containers to share executable and shared library memory, so is a useful choice when running thousands of containers with the same program or libraries.</source>
          <target state="translated">&lt;code&gt;aufs&lt;/code&gt; 드라이버는 가장 오래된, 그러나 메인 커널에 병합 될 가능성이 리눅스 커널 패치 세트를 기반으로합니다. 이것들은 심각한 커널 충돌을 일으키는 것으로 알려져 있습니다. 그러나 &lt;code&gt;aufs&lt;/code&gt; 를 사용하면 컨테이너가 실행 파일 및 공유 라이브러리 메모리를 공유 할 수 있으므로 동일한 프로그램 또는 라이브러리로 수천 개의 컨테이너를 실행할 때 유용한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d21264ed9be94f59b90f635a011c3e1c7dccb1ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aufs&lt;/code&gt; storage driver facilitates running Docker on distros that have no support for OverlayFS, such as Ubuntu 14.04 LTS, which originally shipped with a 3.14 kernel.</source>
          <target state="translated">&lt;code&gt;aufs&lt;/code&gt; 같은 원래 3.14 커널과 함께 제공 우분투 14.04 LTS, 같은 OverlayFS에 대한 지원을이없는 배포판에 도커을 실행하는 스토리지 드라이버 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="ac5b8e87a209b84e7e37fcdb8a390ec2e2305090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aufs&lt;/code&gt; storage driver is deprecated in favor of &lt;code&gt;overlay2&lt;/code&gt;, and will be removed in a future release. Users of the &lt;code&gt;aufs&lt;/code&gt; storage driver are recommended to migrate to a different storage driver, such as &lt;code&gt;overlay2&lt;/code&gt;, which is now the default storage driver.</source>
          <target state="translated">&lt;code&gt;aufs&lt;/code&gt; 저장 장치 드라이버는 찬성되지 않습니다 &lt;code&gt;overlay2&lt;/code&gt; , 향후 릴리스에서 제거 될 것입니다. 의 사용자 &lt;code&gt;aufs&lt;/code&gt; 저장 장치 드라이버 같은 다른 저장 장치 드라이버로 마이그레이션하는 것이 좋습니다 &lt;code&gt;overlay2&lt;/code&gt; 이제 기본 저장 장치 드라이버입니다.</target>
        </trans-unit>
        <trans-unit id="043c98c9bd9cb2795c2de8bf56042b5344260468" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;before&lt;/code&gt; filter shows only containers created before the container with given id or name. For example, having these containers created:</source>
          <target state="translated">은 &lt;code&gt;before&lt;/code&gt; 필터만을 도시 용기 주어진 이름 또는 ID와 컨테이너 전에 만들었다. 예를 들어, 이러한 컨테이너를 작성하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="074d496d9037bf300f47a0466f625105ef5ae8c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;before&lt;/code&gt; filter shows only images created before the image with given id or reference. For example, having these images:</source>
          <target state="translated">은 &lt;code&gt;before&lt;/code&gt; 필터만을 도시 이미지 주어진 ID 또는 참조 화상 전에 만들었다. 예를 들어 다음과 같은 이미지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="680eea36a92a6d600ce8f2d291b3dabb1fd2b4f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind-propagation&lt;/code&gt; option defaults to &lt;code&gt;rprivate&lt;/code&gt; for both bind mounts and volume mounts, and is only configurable for bind mounts. In other words, named volumes do not support bind propagation.</source>
          <target state="translated">&lt;code&gt;bind-propagation&lt;/code&gt; 옵션 기본값 &lt;code&gt;rprivate&lt;/code&gt; 바인드 마운트 및 볼륨 마운트 모두, 그리고 바인드 마운트 만 구성 할 수 있습니다. 즉, 명명 된 볼륨은 바인드 전파를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67f07157a985d84dcd79e8d91f8e6b76da258ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;btrfs&lt;/code&gt; driver is very fast for &lt;code&gt;docker build&lt;/code&gt; - but like &lt;code&gt;devicemapper&lt;/code&gt; does not share executable memory between devices. Use &lt;code&gt;dockerd -s btrfs -g /mnt/btrfs_partition&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;btrfs&lt;/code&gt; 를의 드라이버는 매우 빠르게 &lt;code&gt;docker build&lt;/code&gt; -하지만 같은 &lt;code&gt;devicemapper&lt;/code&gt; 장치 사이의 실행 메모리를 공유하지 않습니다. &lt;code&gt;dockerd -s btrfs -g /mnt/btrfs_partition&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc0ba098ceac4dd5ea14ad79d5a4ce5bb841ef45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;capability&lt;/code&gt; filter matches on plugin capabilities. One plugin might have multiple capabilities. Currently &lt;code&gt;volumedriver&lt;/code&gt;, &lt;code&gt;networkdriver&lt;/code&gt;, &lt;code&gt;ipamdriver&lt;/code&gt;, &lt;code&gt;logdriver&lt;/code&gt;, &lt;code&gt;metricscollector&lt;/code&gt;, and &lt;code&gt;authz&lt;/code&gt; are supported capabilities.</source>
          <target state="translated">&lt;code&gt;capability&lt;/code&gt; 필터 기능을 플러그인에 일치합니다. 하나의 플러그인에는 여러 기능이있을 수 있습니다. 현재 &lt;code&gt;volumedriver&lt;/code&gt; , &lt;code&gt;networkdriver&lt;/code&gt; , &lt;code&gt;ipamdriver&lt;/code&gt; , &lt;code&gt;logdriver&lt;/code&gt; , &lt;code&gt;metricscollector&lt;/code&gt; , 그리고 &lt;code&gt;authz&lt;/code&gt; 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fdecbd9da265febad688f0f54cfcc497df8b3feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config.json&lt;/code&gt; file describes the plugin. See the &lt;a href=&quot;config/index&quot;&gt;plugins config reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;config.json&lt;/code&gt; 의 파일은 플러그인을 설명합니다. 참고 항목 &lt;a href=&quot;config/index&quot;&gt;플러그인 설정 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="736cffcd57446baeaf57dc1d916874f3ab44b5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config.json&lt;/code&gt; file stores a JSON encoding of several properties:</source>
          <target state="translated">&lt;code&gt;config.json&lt;/code&gt; 의 파일에는 여러 속성의 코딩하는 JSON :</target>
        </trans-unit>
        <trans-unit id="2310e282ca831fa888d8ebbe5bcaac153cd3667b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;container-dest&lt;/code&gt; must always be an absolute path such as &lt;code&gt;/src/docs&lt;/code&gt;. The &lt;code&gt;host-src&lt;/code&gt; can either be an absolute path or a &lt;code&gt;name&lt;/code&gt; value. If you supply an absolute path for the &lt;code&gt;host-dir&lt;/code&gt;, Docker bind-mounts to the path you specify. If you supply a &lt;code&gt;name&lt;/code&gt;, Docker creates a named volume by that &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;container-dest&lt;/code&gt; 항상 절대 경로 등해야 &lt;code&gt;/src/docs&lt;/code&gt; . &lt;code&gt;host-src&lt;/code&gt; 하나의 절대 경로 또는 일 수 &lt;code&gt;name&lt;/code&gt; 값. &lt;code&gt;host-dir&lt;/code&gt; 에 대한 절대 경로를 제공하면 Docker 바인드 마운트는 지정한 경로에 연결됩니다. &lt;code&gt;name&lt;/code&gt; 을 제공하면 Docker는 해당 &lt;code&gt;name&lt;/code&gt; 이 지정된 볼륨을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8630a18f96c819b6fc8d9fb47228d4ec089bb06b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;container:...&lt;/code&gt; formats are only supported in the &lt;a href=&quot;../compose-versioning/index#version-2&quot;&gt;version 2 file format&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;container:...&lt;/code&gt; 형식 만 지원하는 &lt;a href=&quot;../compose-versioning/index#version-2&quot;&gt;버전 2 파일 형식&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc1a8fdb596af07bb07751edfd381fdce594be84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content-trust&lt;/code&gt; flag is based around a &lt;code&gt;mode&lt;/code&gt; variable instructing the engine whether to enforce signed images, and a &lt;code&gt;trust-pinning&lt;/code&gt; variable instructing the engine which sources to trust.</source>
          <target state="translated">&lt;code&gt;content-trust&lt;/code&gt; 플래그는 주위를 기반으로 &lt;code&gt;mode&lt;/code&gt; 서명 이미지를 적용할지 여부 엔진을 지시 변수를, 그리고 &lt;code&gt;trust-pinning&lt;/code&gt; 변수는 신뢰하는 소스 엔진을 지시.</target>
        </trans-unit>
        <trans-unit id="012a8331c2e0e74449f2ab7bb73efed40ea1a1e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cp&lt;/code&gt; command behaves like the Unix &lt;code&gt;cp -a&lt;/code&gt; command in that directories are copied recursively with permissions preserved if possible. Ownership is set to the user and primary group at the destination. For example, files copied to a container are created with &lt;code&gt;UID:GID&lt;/code&gt; of the root user. Files copied to the local machine are created with the &lt;code&gt;UID:GID&lt;/code&gt; of the user which invoked the &lt;code&gt;docker cp&lt;/code&gt; command. However, if you specify the &lt;code&gt;-a&lt;/code&gt; option, &lt;code&gt;docker cp&lt;/code&gt; sets the ownership to the user and primary group at the source. If you specify the &lt;code&gt;-L&lt;/code&gt; option, &lt;code&gt;docker cp&lt;/code&gt; follows any symbolic link in the &lt;code&gt;SRC_PATH&lt;/code&gt;. &lt;code&gt;docker cp&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; create parent directories for &lt;code&gt;DEST_PATH&lt;/code&gt; if they do not exist.</source>
          <target state="translated">&lt;code&gt;cp&lt;/code&gt; 유닉스와 같은 명령 동작합니다 &lt;code&gt;cp -a&lt;/code&gt; 그 디렉토리의 명령은 가능하면 보존 권한을 반복적으로 복사됩니다. 소유권은 대상의 사용자 및 기본 그룹으로 설정됩니다. 예를 들어 컨테이너에 복사 된 파일 은 루트 사용자의 &lt;code&gt;UID:GID&lt;/code&gt; 로 생성됩니다 . 로컬 시스템에 복사 된 파일 은 &lt;code&gt;docker cp&lt;/code&gt; 명령 을 호출 한 사용자 의 &lt;code&gt;UID:GID&lt;/code&gt; 로 작성 됩니다 . 그러나 &lt;code&gt;-a&lt;/code&gt; 옵션 을 지정하면 &lt;code&gt;docker cp&lt;/code&gt; 는 소유권을 소스의 사용자 및 기본 그룹으로 설정합니다. &lt;code&gt;-L&lt;/code&gt; 옵션 을 지정하면 &lt;code&gt;docker cp&lt;/code&gt; 는 &lt;code&gt;SRC_PATH&lt;/code&gt; 의 모든 심볼릭 링크를 따릅니다.. &lt;code&gt;docker cp&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 에 대한 부모 디렉토리 생성 &lt;code&gt;DEST_PATH&lt;/code&gt; 을 가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="d47ce5d678976a7476b0c18e9222d25c8a694629" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dangling&lt;/code&gt; filter matches on all volumes not referenced by any containers</source>
          <target state="translated">&lt;code&gt;dangling&lt;/code&gt; 있는 용기가 참조하는 모든 볼륨에 필터 일치</target>
        </trans-unit>
        <trans-unit id="ca501fcadca0fc33fcf1980848e49bf924e5837a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;depends_on&lt;/code&gt; option is ignored when &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a version 3 Compose file.</source>
          <target state="translated">&lt;code&gt;depends_on&lt;/code&gt; 의 경우 옵션은 무시됩니다 &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;떼 모드에서 스택을 배포&lt;/a&gt; 버전 3 작성 파일.</target>
        </trans-unit>
        <trans-unit id="a10821048e200222decc18b5caa6ef73360f3e65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deploy&lt;/code&gt; command supports compose file version &lt;code&gt;3.0&lt;/code&gt; and above.</source>
          <target state="translated">&lt;code&gt;deploy&lt;/code&gt; 명령은 작성 파일 버전 지원 &lt;code&gt;3.0&lt;/code&gt; 이상을.</target>
        </trans-unit>
        <trans-unit id="d97f79dd18614fb6309fc4cb7e75346b229c6a7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;desired-state&lt;/code&gt; filter can take the values &lt;code&gt;running&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;accepted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;desired-state&lt;/code&gt; 필터는 값이 걸릴 수 있습니다 &lt;code&gt;running&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; , 또는 &lt;code&gt;accepted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c577e679b95985fa19b5d2c2ba04dd7e2e5beeaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;devicemapper&lt;/code&gt; driver uses thin provisioning and Copy on Write (CoW) snapshots. For each devicemapper graph location &amp;ndash; typically &lt;code&gt;/var/lib/docker/devicemapper&lt;/code&gt; &amp;ndash; a thin pool is created based on two block devices, one for data and one for metadata. By default, these block devices are created automatically by using loopback mounts of automatically created sparse files. Refer to &lt;a href=&quot;#devicemapper-options&quot;&gt;Devicemapper options&lt;/a&gt; below for a way how to customize this setup. &lt;a href=&quot;http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/&quot;&gt;~jpetazzo/Resizing Docker containers with the Device Mapper plugin&lt;/a&gt; article explains how to tune your existing setup without the use of options.</source>
          <target state="translated">&lt;code&gt;devicemapper&lt;/code&gt; 의 드라이버는 쓰기 (COW) 스냅 샷에 씬 프로비저닝 및 복사를 사용합니다. 각 장치 매퍼 그래프 위치 (일반적으로 &lt;code&gt;/var/lib/docker/devicemapper&lt;/code&gt; )에 대해 씬 풀은 두 개의 블록 장치 (데이터 용 및 메타 데이터 용)를 기반으로 생성됩니다. 기본적으로이 블록 장치는 자동으로 생성 된 스파 스 파일의 루프백 마운트를 사용하여 자동으로 생성됩니다. 이 설정을 사용자 정의하는 방법은 아래의 &lt;a href=&quot;#devicemapper-options&quot;&gt;Devicemapper 옵션을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/&quot;&gt;~ jpetazzo / Device Mapper 플러그인&lt;/a&gt; 기사를 사용하여 Docker 컨테이너 크기 조정 옵션은 옵션을 사용하지 않고 기존 설정을 조정하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="941fb0922c6070e3d2140cfe4d235f0c8f11171d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;devicemapper&lt;/code&gt; driver uses thin provisioning and Copy on Write (CoW) snapshots. For each devicemapper graph location &amp;ndash; typically &lt;code&gt;/var/lib/docker/devicemapper&lt;/code&gt; &amp;ndash; a thin pool is created based on two block devices, one for data and one for metadata. By default, these block devices are created automatically by using loopback mounts of automatically created sparse files. Refer to &lt;a href=&quot;#devicemapper-options&quot;&gt;Devicemapper options&lt;/a&gt; below for a way how to customize this setup. &lt;a href=&quot;https://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/&quot;&gt;~jpetazzo/Resizing Docker containers with the Device Mapper plugin&lt;/a&gt; article explains how to tune your existing setup without the use of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccd0195d721f403d76a89afd53f755e0c58494d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;devicemapper&lt;/code&gt; storage driver facilitates running Docker on older (3.x) kernels that have no support for other storage drivers (such as overlay2, or AUFS).</source>
          <target state="translated">&lt;code&gt;devicemapper&lt;/code&gt; 의 다른 저장 (예 : 오버레이 2 등, 또는 AUFS) 드라이버에 대한 지원이 없습니다 나이 (3.x의) 커널에서 부두 노동자를 실행하는 스토리지 드라이버 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="89272b2ed83b2ae8d4a0b79b32cc9955f7c51e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;devicemapper&lt;/code&gt; storage driver is deprecated in favor of &lt;code&gt;overlay2&lt;/code&gt;, and will be removed in a future release. Users of the &lt;code&gt;devicemapper&lt;/code&gt; storage driver are recommended to migrate to a different storage driver, such as &lt;code&gt;overlay2&lt;/code&gt;, which is now the default storage driver.</source>
          <target state="translated">&lt;code&gt;devicemapper&lt;/code&gt; 의 저장 장치 드라이버는 찬성되지 않습니다 &lt;code&gt;overlay2&lt;/code&gt; , 향후 릴리스에서 제거 될 것입니다. &lt;code&gt;devicemapper&lt;/code&gt; 스토리지 드라이버 사용자 는 이제 기본 스토리지 드라이버 인 &lt;code&gt;overlay2&lt;/code&gt; 와 같은 다른 스토리지 드라이버로 마이그레이션하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="07ecd732b3bd07e8737e552d0f0bcba3e4908ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disable-legacy-registry&lt;/code&gt; configuration option has been removed and, when used, will produce an error on daemon startup.</source>
          <target state="translated">&lt;code&gt;disable-legacy-registry&lt;/code&gt; 구성 옵션이 제거 된, 사용하는 경우, 데몬 시작시 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4a497a0da289a9d8c0ef81082723389a06ffe41a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker build&lt;/code&gt; command builds Docker images from a Dockerfile and a &amp;ldquo;context&amp;rdquo;. A build&amp;rsquo;s context is the set of files located in the specified &lt;code&gt;PATH&lt;/code&gt; or &lt;code&gt;URL&lt;/code&gt;. The build process can refer to any of the files in the context. For example, your build can use a &lt;a href=&quot;../../builder/index#copy&quot;&gt;&lt;em&gt;COPY&lt;/em&gt;&lt;/a&gt; instruction to reference a file in the context.</source>
          <target state="translated">&lt;code&gt;docker build&lt;/code&gt; 명령은 Dockerfile과 &quot;컨텍스트&quot;에서 부두 노동자의 이미지를 구축합니다. 빌드 컨텍스트는 지정된 &lt;code&gt;PATH&lt;/code&gt; 또는 &lt;code&gt;URL&lt;/code&gt; 에있는 파일 세트입니다 . 빌드 프로세스는 컨텍스트의 모든 파일을 참조 할 수 있습니다. 예를 들어, 빌드는 &lt;a href=&quot;../../builder/index#copy&quot;&gt;&lt;em&gt;COPY&lt;/em&gt;&lt;/a&gt; 명령어를 사용 하여 컨텍스트에서 파일을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d00da26adc0934efef97a4a66ba07d087391f9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker cp&lt;/code&gt; command assumes container paths are relative to the container&amp;rsquo;s &lt;code&gt;/&lt;/code&gt; (root) directory. This means supplying the initial forward slash is optional; The command sees &lt;code&gt;compassionate_darwin:/tmp/foo/myfile.txt&lt;/code&gt; and &lt;code&gt;compassionate_darwin:tmp/foo/myfile.txt&lt;/code&gt; as identical. Local machine paths can be an absolute or relative value. The command interprets a local machine&amp;rsquo;s relative paths as relative to the current working directory where &lt;code&gt;docker cp&lt;/code&gt; is run.</source>
          <target state="translated">&lt;code&gt;docker cp&lt;/code&gt; 명령은 컨테이너 경로가 컨테이너를 기준으로 가정 &lt;code&gt;/&lt;/code&gt; (루트) 디렉토리. 즉, 초기 슬래시를 제공하는 것은 선택 사항입니다. 이 명령은 &lt;code&gt;compassionate_darwin:/tmp/foo/myfile.txt&lt;/code&gt; 와 &lt;code&gt;compassionate_darwin:tmp/foo/myfile.txt&lt;/code&gt; 를 동일하게 간주합니다. 로컬 머신 경로는 절대 또는 상대 값일 수 있습니다. 이 명령은 로컬 시스템의 상대 경로를 &lt;code&gt;docker cp&lt;/code&gt; 가 실행 되는 현재 작업 디렉토리를 기준으로 해석 합니다.</target>
        </trans-unit>
        <trans-unit id="f0488fda8ff3401a355142d0109c0774079f4704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker cp&lt;/code&gt; utility copies the contents of &lt;code&gt;SRC_PATH&lt;/code&gt; to the &lt;code&gt;DEST_PATH&lt;/code&gt;. You can copy from the container&amp;rsquo;s file system to the local machine or the reverse, from the local filesystem to the container. If &lt;code&gt;-&lt;/code&gt; is specified for either the &lt;code&gt;SRC_PATH&lt;/code&gt; or &lt;code&gt;DEST_PATH&lt;/code&gt;, you can also stream a tar archive from &lt;code&gt;STDIN&lt;/code&gt; or to &lt;code&gt;STDOUT&lt;/code&gt;. The &lt;code&gt;CONTAINER&lt;/code&gt; can be a running or stopped container. The &lt;code&gt;SRC_PATH&lt;/code&gt; or &lt;code&gt;DEST_PATH&lt;/code&gt; can be a file or directory.</source>
          <target state="translated">&lt;code&gt;docker cp&lt;/code&gt; 유틸리티 사본의 내용 &lt;code&gt;SRC_PATH&lt;/code&gt; 을 받는 &lt;code&gt;DEST_PATH&lt;/code&gt; . 컨테이너의 파일 시스템에서 로컬 시스템으로 또는 그 반대로 로컬 파일 시스템에서 컨테이너로 복사 할 수 있습니다. 경우 &lt;code&gt;-&lt;/code&gt; 중 하나에 대해 지정된 &lt;code&gt;SRC_PATH&lt;/code&gt; 또는 &lt;code&gt;DEST_PATH&lt;/code&gt; , 당신은 또한에서 tar 아카이브 스트리밍 할 수 있습니다 &lt;code&gt;STDIN&lt;/code&gt; 거나 &lt;code&gt;STDOUT&lt;/code&gt; 을 . &lt;code&gt;CONTAINER&lt;/code&gt; 실행중인 또는 중지 용기가 될 수 있습니다. &lt;code&gt;SRC_PATH&lt;/code&gt; 또는 &lt;code&gt;DEST_PATH&lt;/code&gt; 는 파일이나 디렉토리를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d84e65b44b0ace486ef052eb68a53a9c7db22eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker create&lt;/code&gt; command creates a writeable container layer over the specified image and prepares it for running the specified command. The container ID is then printed to &lt;code&gt;STDOUT&lt;/code&gt;. This is similar to &lt;code&gt;docker run -d&lt;/code&gt; except the container is never started. You can then use the &lt;code&gt;docker start &amp;lt;container_id&amp;gt;&lt;/code&gt; command to start the container at any point.</source>
          <target state="translated">&lt;code&gt;docker create&lt;/code&gt; 명령은 지정된 이미지를 통해 쓰기 가능한 컨테이너 레이어를 생성하고 지정된 명령을 실행을 위해 준비합니다. 그런 다음 컨테이너 ID가 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄됩니다 . 컨테이너가 시작되지 않았다는 점을 제외하면 &lt;code&gt;docker run -d&lt;/code&gt; 와 유사합니다 . 그런 다음 &lt;code&gt;docker start &amp;lt;container_id&amp;gt;&lt;/code&gt; 명령을 사용하여 언제든지 컨테이너를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e49c5596561af85a1388d3ee7f38cdf68214b18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker exec&lt;/code&gt; command runs a new command in a running container.</source>
          <target state="translated">&lt;code&gt;docker exec&lt;/code&gt; 명령은 실행중인 컨테이너에 새 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="36a4345c685a94da4a4d72493c8dd4b169284353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker export&lt;/code&gt; command does not export the contents of volumes associated with the container. If a volume is mounted on top of an existing directory in the container, &lt;code&gt;docker export&lt;/code&gt; will export the contents of the &lt;em&gt;underlying&lt;/em&gt; directory, not the contents of the volume.</source>
          <target state="translated">&lt;code&gt;docker export&lt;/code&gt; 명령은 컨테이너와 관련된 볼륨의 내용을 내 보내지 않습니다. 볼륨이 컨테이너의 기존 디렉토리 위에 마운트되면 &lt;code&gt;docker export&lt;/code&gt; 는 볼륨의 내용이 아닌 &lt;em&gt;기본&lt;/em&gt; 디렉토리 의 내용을 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="212faf92123f1bd5dad504ad0c9711f075a2a885" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker images&lt;/code&gt; command takes an optional &lt;code&gt;[REPOSITORY[:TAG]]&lt;/code&gt; argument that restricts the list to images that match the argument. If you specify &lt;code&gt;REPOSITORY&lt;/code&gt;but no &lt;code&gt;TAG&lt;/code&gt;, the &lt;code&gt;docker images&lt;/code&gt; command lists all images in the given repository.</source>
          <target state="translated">&lt;code&gt;docker images&lt;/code&gt; 명령을 선택합니다 &lt;code&gt;[REPOSITORY[:TAG]]&lt;/code&gt; 인수와 일치하는 이미지 목록을 제한 인수를. 를 지정하면 &lt;code&gt;REPOSITORY&lt;/code&gt; 하지만 &lt;code&gt;TAG&lt;/code&gt; 는 &lt;code&gt;docker images&lt;/code&gt; 나열 주어진 저장소에있는 모든 이미지를 명령.</target>
        </trans-unit>
        <trans-unit id="9cf01d6be8fbd1ded8fffe4de73a77b12d992e6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker import&lt;/code&gt; command format &lt;code&gt;file|URL|- [REPOSITORY [TAG]]&lt;/code&gt; is deprecated since November 2013. It&amp;rsquo;s no more supported.</source>
          <target state="translated">&lt;code&gt;docker import&lt;/code&gt; 명령 형식의 &lt;code&gt;file|URL|- [REPOSITORY [TAG]]&lt;/code&gt; 그것은 더 이상 지원되는 11 월 중간 2013 년 이후 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dce7f5061f028dd79b6c9199c2e8844396289e6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker kill&lt;/code&gt; subcommand kills one or more containers. The main process inside the container is sent &lt;code&gt;SIGKILL&lt;/code&gt; signal (default), or the signal that is specified with the &lt;code&gt;--signal&lt;/code&gt; option. You can kill a container using the container&amp;rsquo;s ID, ID-prefix, or name.</source>
          <target state="translated">&lt;code&gt;docker kill&lt;/code&gt; 부속 명령은 하나 개 이상의 컨테이너를 죽인다. 컨테이너 내부의 주요 프로세스에는 &lt;code&gt;SIGKILL&lt;/code&gt; 신호 (기본값) 또는 &lt;code&gt;--signal&lt;/code&gt; 옵션으로 지정된 신호 가 전송 됩니다. 컨테이너의 ID, ID 접두사 또는 이름을 사용하여 컨테이너를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d43c3096a9a9284aa348945d30f3d5d392ae079e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs --details&lt;/code&gt; command will add on extra attributes, such as environment variables and labels, provided to &lt;code&gt;--log-opt&lt;/code&gt; when creating the container.</source>
          <target state="translated">&lt;code&gt;docker logs --details&lt;/code&gt; 명령은 제공 환경 변수 및 라벨 등의 추가 속성에 추가합니다 &lt;code&gt;--log-opt&lt;/code&gt; 컨테이너를 만들 때.</target>
        </trans-unit>
        <trans-unit id="e5948949f42d952f60c7708fcce602b9cb6dc943" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs --follow&lt;/code&gt; command will continue streaming the new output from the container&amp;rsquo;s &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker logs --follow&lt;/code&gt; 명령은 컨테이너에서 새 출력 스트리밍 계속 &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d8a9ca6208ff085d23a305e8d1993aaa303ef846" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs --timestamps&lt;/code&gt; command will add an &lt;a href=&quot;https://golang.org/pkg/time/#pkg-constants&quot;&gt;RFC3339Nano timestamp&lt;/a&gt; , for example &lt;code&gt;2014-09-16T06:17:46.000000000Z&lt;/code&gt;, to each log entry. To ensure that the timestamps are aligned the nano-second part of the timestamp will be padded with zero when necessary.</source>
          <target state="translated">&lt;code&gt;docker logs --timestamps&lt;/code&gt; 명령이 추가됩니다 &lt;a href=&quot;https://golang.org/pkg/time/#pkg-constants&quot;&gt;RFC3339Nano 타임 스탬프를&lt;/a&gt; 예를 들어, &lt;code&gt;2014-09-16T06:17:46.000000000Z&lt;/code&gt; , 각 로그 항목에. 타임 스탬프가 정렬되도록하기 위해 타임 스탬프의 나노초 부분은 필요할 때 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="f379943afa430ee6b50ed771213d592f53df6cd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs&lt;/code&gt; command batch-retrieves logs present at the time of execution.</source>
          <target state="translated">&lt;code&gt;docker logs&lt;/code&gt; 실행시 배치를 검색 로그 선물을 명령.</target>
        </trans-unit>
        <trans-unit id="6b969e0fdf69b61cfacee42a371cb8dcea9a37c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs&lt;/code&gt; command is available only for the &lt;code&gt;json-file&lt;/code&gt; and &lt;code&gt;journald&lt;/code&gt; logging drivers. For detailed information on working with logging drivers, see &lt;a href=&quot;https://docs.docker.com/config/containers/logging/configure/&quot;&gt;Configure logging drivers&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker logs&lt;/code&gt; 명령은 사용할 수 &lt;code&gt;json-file&lt;/code&gt; 및 &lt;code&gt;journald&lt;/code&gt; 로깅 된 드라이버를 제공합니다. 로깅 드라이버 작업에 대한 자세한 정보는 로깅 드라이버 &lt;a href=&quot;https://docs.docker.com/config/containers/logging/configure/&quot;&gt;구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55752f0f1f17d3b512c98898ce7574796f4e5407" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker manifest inspect&lt;/code&gt; command takes an optional &lt;code&gt;--verbose&lt;/code&gt; flag that gives you the image&amp;rsquo;s name (Ref), and architecture and os (Platform).</source>
          <target state="translated">&lt;code&gt;docker manifest inspect&lt;/code&gt; 명령을 선택합니다 &lt;code&gt;--verbose&lt;/code&gt; 당신에게 이미지의 이름 (참조), 및 아키텍처 및 OS (플랫폼)을 제공 플래그.</target>
        </trans-unit>
        <trans-unit id="6c3ad1c2e88a035ec19fe4201ac4b782caf157a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker manifest&lt;/code&gt; command by itself performs no action. In order to operate on a manifest or manifest list, one of the subcommands must be used.</source>
          <target state="translated">&lt;code&gt;docker manifest&lt;/code&gt; 자체 명령은 아무 작업도 수행하지 않습니다. 매니페스트 또는 매니페스트 목록에서 작동하려면 하위 명령 중 하나를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="75c99ddf08d348672ee86f07f42d81770f1637c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker pause&lt;/code&gt; command suspends all processes in the specified containers. On Linux, this uses the cgroups freezer. Traditionally, when suspending a process the &lt;code&gt;SIGSTOP&lt;/code&gt; signal is used, which is observable by the process being suspended. With the cgroups freezer the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed. On Windows, only Hyper-V containers can be paused.</source>
          <target state="translated">&lt;code&gt;docker pause&lt;/code&gt; 명령은 지정된 용기에 모든 프로세스를 일시 중단합니다. Linux에서는 cgroups freezer를 사용합니다. 일반적으로 프로세스를 일시 중단 할 때 &lt;code&gt;SIGSTOP&lt;/code&gt; 신호가 사용되며 이는 프로세스가 일시 중단되어 관찰 할 수 있습니다. cgroups freezer를 사용하면 프로세스가 인식되지 않고 캡처 할 수 없으므로 프로세스가 일시 중단 된 후 재개됩니다. Windows에서는 Hyper-V 컨테이너 만 일시 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4fcb5e9f179d47f06df5ff0e7c5e4b7f44e31e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker ps --before&lt;/code&gt; and &lt;code&gt;docker ps --since&lt;/code&gt; options are deprecated. Use &lt;code&gt;docker ps --filter=before=...&lt;/code&gt; and &lt;code&gt;docker ps --filter=since=...&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;docker ps --before&lt;/code&gt; 및 &lt;code&gt;docker ps --since&lt;/code&gt; 옵션은 사용되지 않습니다. 대신 &lt;code&gt;docker ps --filter=before=...&lt;/code&gt; 및 &lt;code&gt;docker ps --filter=since=...&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c88758404e46e53d12887c5e58b9a83faebb4784" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker ps&lt;/code&gt; command only shows running containers by default. To see all containers, use the &lt;code&gt;-a&lt;/code&gt; (or &lt;code&gt;--all&lt;/code&gt;) flag:</source>
          <target state="translated">&lt;code&gt;docker ps&lt;/code&gt; 명령은 기본적으로 실행 컨테이너를 보여줍니다. 모든 컨테이너를 보려면 &lt;code&gt;-a&lt;/code&gt; (또는 &lt;code&gt;--all&lt;/code&gt; ) 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="60742f07fa12b395820e597a3d69a0275c37092a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker rename&lt;/code&gt; command renames a container.</source>
          <target state="translated">&lt;code&gt;docker rename&lt;/code&gt; 명령은 컨테이너 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="349b19b1df93f399fb4b343e7c3f1b48014c976d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker run&lt;/code&gt; command can be used in combination with &lt;code&gt;docker commit&lt;/code&gt; to &lt;a href=&quot;../commit/index&quot;&gt;&lt;em&gt;change the command that a container runs&lt;/em&gt;&lt;/a&gt;. There is additional detailed information about &lt;code&gt;docker run&lt;/code&gt; in the &lt;a href=&quot;../../run/index&quot;&gt;Docker run reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker run&lt;/code&gt; 명령과 함께 사용할 수 있습니다 &lt;code&gt;docker commit&lt;/code&gt; 에 &lt;a href=&quot;../commit/index&quot;&gt;&lt;em&gt;컨테이너가 실행하는 명령을 변경합니다&lt;/em&gt;&lt;/a&gt; . &lt;a href=&quot;../../run/index&quot;&gt;Docker run reference&lt;/a&gt; 에 &lt;code&gt;docker run&lt;/code&gt; 에 대한 추가 세부 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cbc062ae7a3f96974d3b09cc48a4d036bab9de4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker run&lt;/code&gt; command first &lt;code&gt;creates&lt;/code&gt; a writeable container layer over the specified image, and then &lt;code&gt;starts&lt;/code&gt; it using the specified command. That is, &lt;code&gt;docker run&lt;/code&gt; is equivalent to the API &lt;code&gt;/containers/create&lt;/code&gt; then &lt;code&gt;/containers/(id)/start&lt;/code&gt;. A stopped container can be restarted with all its previous changes intact using &lt;code&gt;docker start&lt;/code&gt;. See &lt;code&gt;docker ps -a&lt;/code&gt; to view a list of all containers.</source>
          <target state="translated">&lt;code&gt;docker run&lt;/code&gt; 명령은 먼저 &lt;code&gt;creates&lt;/code&gt; 지정된 이미지 위에 기록 가능한 콘테이너 층 후 &lt;code&gt;starts&lt;/code&gt; 지정된 명령을 사용한다. 즉, &lt;code&gt;docker run&lt;/code&gt; 은 API &lt;code&gt;/containers/create&lt;/code&gt; 다음 &lt;code&gt;/containers/(id)/start&lt;/code&gt; 와 같습니다 . &lt;code&gt;docker start&lt;/code&gt; 를 사용하여 이전의 모든 변경 사항을 그대로 유지하면서 중지 된 컨테이너를 다시 시작할 수 있습니다 . 모든 컨테이너 목록을 보려면 &lt;code&gt;docker ps -a&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8db5978a7d7f7646bc12237ae6823cb2607d57b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker run&lt;/code&gt; command initializes the newly created volume with any data that exists at the specified location within the base image. For example, consider the following Dockerfile snippet:</source>
          <target state="translated">&lt;code&gt;docker run&lt;/code&gt; 명령은 기본 이미지 내의 지정된 위치에 존재하는 모든 데이터를 새로 만든 볼륨을 초기화합니다. 예를 들어 다음 Dockerfile 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="08f6f844a66eaa6760e5fe6294cac62a9f838920" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker run&lt;/code&gt; command must specify an &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#image&quot;&gt;&lt;em&gt;IMAGE&lt;/em&gt;&lt;/a&gt; to derive the container from. An image developer can define image defaults related to:</source>
          <target state="translated">&lt;code&gt;docker run&lt;/code&gt; 명령은 지정해야합니다 &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#image&quot;&gt;&lt;em&gt;이미지&lt;/em&gt;&lt;/a&gt; 에서 컨테이너를 도출 할 수 있습니다. 이미지 개발자는 다음과 관련된 이미지 기본값을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7e7fcd62d448b7d3efd101f9754749e96cc06f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker search --automated&lt;/code&gt; and &lt;code&gt;docker search --stars&lt;/code&gt; options are deprecated. Use &lt;code&gt;docker search --filter=is-automated=...&lt;/code&gt; and &lt;code&gt;docker search --filter=stars=...&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;docker search --automated&lt;/code&gt; 및 &lt;code&gt;docker search --stars&lt;/code&gt; 옵션은 사용되지 않습니다. 대신 &lt;code&gt;docker search --filter=is-automated=...&lt;/code&gt; 및 &lt;code&gt;docker search --filter=stars=...&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4aabab092cfe3cb42af64ee2c599a695b974e3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service create&lt;/code&gt; command creates the service.</source>
          <target state="translated">&lt;code&gt;docker service create&lt;/code&gt; 명령은 서비스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5cff7ed0601c6010af07e5b704b1ef7693421a0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs --details&lt;/code&gt; command will add on extra attributes, such as environment variables and labels, provided to &lt;code&gt;--log-opt&lt;/code&gt; when creating the service.</source>
          <target state="translated">&lt;code&gt;docker service logs --details&lt;/code&gt; 명령은 제공 환경 변수 및 라벨 등의 추가 속성에 추가합니다 &lt;code&gt;--log-opt&lt;/code&gt; 서비스를 만들 때.</target>
        </trans-unit>
        <trans-unit id="3b1a61f7542a854c2c468b381383555fd4a0e0a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs --follow&lt;/code&gt; command will continue streaming the new output from the service&amp;rsquo;s &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker service logs --follow&lt;/code&gt; 명령은 서비스의에서 새 출력 스트리밍 계속 &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ec273344485322eeae5f9cae2c1a61b08d484ffb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs --timestamps&lt;/code&gt; command will add an &lt;a href=&quot;https://golang.org/pkg/time/#pkg-constants&quot;&gt;RFC3339Nano timestamp&lt;/a&gt; , for example &lt;code&gt;2014-09-16T06:17:46.000000000Z&lt;/code&gt;, to each log entry. To ensure that the timestamps are aligned the nano-second part of the timestamp will be padded with zero when necessary.</source>
          <target state="translated">&lt;code&gt;docker service logs --timestamps&lt;/code&gt; 명령이 추가됩니다 &lt;a href=&quot;https://golang.org/pkg/time/#pkg-constants&quot;&gt;RFC3339Nano 타임 스탬프를&lt;/a&gt; 예를 들어, &lt;code&gt;2014-09-16T06:17:46.000000000Z&lt;/code&gt; , 각 로그 항목에. 타임 스탬프가 정렬되도록하기 위해 타임 스탬프의 나노초 부분은 필요할 때 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="10d50fd68ded8731e1e0d64ba1ecf10befcfd427" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs&lt;/code&gt; command batch-retrieves logs present at the time of execution.</source>
          <target state="translated">&lt;code&gt;docker service logs&lt;/code&gt; 실행시 배치를 검색 로그 선물을 명령.</target>
        </trans-unit>
        <trans-unit id="640c1ffd784e8f72b9a5490dec23bcb47dfb66cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs&lt;/code&gt; command can be used with either the name or ID of a service, or with the ID of a task. If a service is passed, it will display logs for all of the containers in that service. If a task is passed, it will only display logs from that particular task.</source>
          <target state="translated">&lt;code&gt;docker service logs&lt;/code&gt; 명령은 이름이나 ID 서비스의, 또는 작업의 ID와 함께 사용할 수 있습니다. 서비스가 전달되면 해당 서비스의 모든 컨테이너에 대한 로그가 표시됩니다. 작업이 전달되면 해당 특정 작업의 로그 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3d6799e8fd809602d47bbaef1fed0086a066b9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service scale&lt;/code&gt; command allows you to set the desired number of tasks for multiple services at once. The following example scales both the backend and frontend services:</source>
          <target state="translated">&lt;code&gt;docker service scale&lt;/code&gt; 명령을 사용하면 한 번에 여러 서비스에 대한 작업의 수를 설정할 수 있습니다. 다음 예제는 백엔드 및 프론트 엔드 서비스를 모두 확장합니다.</target>
        </trans-unit>
        <trans-unit id="35f8643610a500188dc8fdf3f7c0514e81a3046b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker stack&lt;/code&gt; command supports defining configs in a Compose file. However, the &lt;code&gt;configs&lt;/code&gt; key is not supported for &lt;code&gt;docker compose&lt;/code&gt;. See &lt;a href=&quot;../../../compose/compose-file/index#configs&quot;&gt;the Compose file reference&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;docker stack&lt;/code&gt; 명령 지원은 작성 파일에 CONFIGS을 정의. 그러나 &lt;code&gt;configs&lt;/code&gt; 키는 &lt;code&gt;docker compose&lt;/code&gt; 에 지원되지 않습니다 . 자세한 내용 &lt;a href=&quot;../../../compose/compose-file/index#configs&quot;&gt;은 파일 작성 참조&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e37aaf9ed0cf3abb97c6ae7c0ac113e4a6d55b78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker stats&lt;/code&gt; command returns a live data stream for running containers. To limit data to one or more specific containers, specify a list of container names or ids separated by a space. You can specify a stopped container but stopped containers do not return any data.</source>
          <target state="translated">&lt;code&gt;docker stats&lt;/code&gt; 명령은 컨테이너를 실행하기위한 실시간 데이터 스트림을 반환합니다. 데이터를 하나 이상의 특정 컨테이너로 제한하려면 컨테이너 이름 또는 ID 목록을 공백으로 구분하여 지정하십시오. 중지 된 컨테이너를 지정할 수 있지만 중지 된 컨테이너는 데이터를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffa34f440b12b822742a35ad1b0ae9e02c01aede" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker swarm join&lt;/code&gt; command does the following:</source>
          <target state="translated">&lt;code&gt;docker swarm join&lt;/code&gt; 명령은 다음을 수행합니다</target>
        </trans-unit>
        <trans-unit id="3824f90f3968e4e8230115835228e6aebae8ad0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker system df&lt;/code&gt; command displays information regarding the amount of disk space used by the docker daemon.</source>
          <target state="translated">&lt;code&gt;docker system df&lt;/code&gt; 고정 표시기 데몬에 의해 사용되는 디스크 공간의 양에 대한 명령 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="db1650195cef112b49d3648c9d83e1ec42925b18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker unpause&lt;/code&gt; command un-suspends all processes in the specified containers. On Linux, it does this using the cgroups freezer.</source>
          <target state="translated">&lt;code&gt;docker unpause&lt;/code&gt; 명령 지정된 컨테이너의 모든 프로세스를 취소합니다 일시 중단합니다. Linux에서는 cgroups freezer를 사용하여이 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e36a30f337ce860b63b6680f160a9b4d5546b044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker update&lt;/code&gt; command dynamically updates container configuration. You can use this command to prevent containers from consuming too many resources from their Docker host. With a single command, you can place limits on a single container or on many. To specify more than one container, provide space-separated list of container names or IDs.</source>
          <target state="translated">&lt;code&gt;docker update&lt;/code&gt; 명령은 동적으로 컨테이너 구성을 업데이트합니다. 이 명령을 사용하여 컨테이너가 Docker 호스트에서 너무 많은 리소스를 소비하지 않도록 할 수 있습니다. 단일 명령으로 단일 컨테이너 또는 여러 컨테이너에 제한을 둘 수 있습니다. 둘 이상의 컨테이너를 지정하려면 공백으로 구분 된 컨테이너 이름 또는 ID 목록을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="19196d6f9e4c444a904f2de757b7f6396f216e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose run&lt;/code&gt; command allows you to run one-off commands for your services. For example, to see what environment variables are available to the &lt;code&gt;web&lt;/code&gt; service:</source>
          <target state="translated">&lt;code&gt;docker-compose run&lt;/code&gt; 명령은 당신이 당신의 서비스에 대한 일회성 명령을 실행할 수 있습니다. 예를 들어, &lt;code&gt;web&lt;/code&gt; 서비스에 사용 가능한 환경 변수를 확인하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="a96f0c05b1b67f88be01dc43a967085da416ae02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose run&lt;/code&gt; command is for running &amp;ldquo;one-off&amp;rdquo; or &amp;ldquo;adhoc&amp;rdquo; tasks. It requires the service name you want to run and only starts containers for services that the running service depends on. Use &lt;code&gt;run&lt;/code&gt; to run tests or perform an administrative task such as removing or adding data to a data volume container. The &lt;code&gt;run&lt;/code&gt; command acts like &lt;code&gt;docker run -ti&lt;/code&gt; in that it opens an interactive terminal to the container and returns an exit status matching the exit status of the process in the container.</source>
          <target state="translated">&lt;code&gt;docker-compose run&lt;/code&gt; 명령은 &quot;일회성&quot;또는 &quot;애드혹&quot;작업을 실행하는 것입니다. 실행하려는 서비스 이름이 필요하며 실행중인 서비스가 의존하는 서비스의 컨테이너 만 시작합니다. &lt;code&gt;run&lt;/code&gt; 을 사용 하여 테스트를 실행하거나 데이터 볼륨 컨테이너에서 데이터 제거 또는 추가와 같은 관리 작업을 수행하십시오. &lt;code&gt;run&lt;/code&gt; 명령은 같은 역할을 &lt;code&gt;docker run -ti&lt;/code&gt; 는 컨테이너 반환 컨테이너에서 프로세스의 종료 상태와 일치하는 종료 상태에 대화 형 터미널을 여는에서.</target>
        </trans-unit>
        <trans-unit id="d7ddb5e3e9d59bef26d3067922a3583ee29c8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose start&lt;/code&gt; command is useful only to restart containers that were previously created, but were stopped. It never creates new containers.</source>
          <target state="translated">&lt;code&gt;docker-compose start&lt;/code&gt; 명령은 이전에 생성되었지만 중지 된 재시작 컨테이너에 유용합니다. 새로운 컨테이너를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae035654bee087f0eea5350f20215eb42ce4f2f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose up&lt;/code&gt; command aggregates the output of each container (essentially running &lt;code&gt;docker-compose logs -f&lt;/code&gt;). When the command exits, all containers are stopped. Running &lt;code&gt;docker-compose up -d&lt;/code&gt; starts the containers in the background and leaves them running.</source>
          <target state="translated">&lt;code&gt;docker-compose up&lt;/code&gt; 명령 집계 각 컨테이너의 출력은 (기본적으로 실행 &lt;code&gt;docker-compose logs -f&lt;/code&gt; ). 명령이 종료되면 모든 컨테이너가 중지됩니다. &lt;code&gt;docker-compose up -d&lt;/code&gt; 를 실행 하면 백그라운드에서 컨테이너가 시작되고 컨테이너가 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="43d3c64fa422d8a0abeec4a7dfcfccf738e571a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose.yml&lt;/code&gt; file describes the services that make your app. In this example those services are a web server and database. The compose file also describes which Docker images these services use, how they link together, any volumes they might need mounted inside the containers. Finally, the &lt;code&gt;docker-compose.yml&lt;/code&gt; file describes which ports these services expose. See the &lt;a href=&quot;../compose-file/index&quot;&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; reference&lt;/a&gt; for more information on how this file works.</source>
          <target state="translated">&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일은 응용 프로그램을 구성하는 서비스에 대해 설명합니다. 이 예에서 이러한 서비스는 웹 서버 및 데이터베이스입니다. compose 파일은 이러한 서비스가 사용하는 Docker 이미지, 연결 방법 및 컨테이너 내부에 마운트해야 할 볼륨을 설명합니다. 마지막으로 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일은 이러한 서비스가 노출하는 포트를 설명합니다. 이 파일의 작동 방식에 대한 자세한 내용은 &lt;a href=&quot;../compose-file/index&quot;&gt; &lt;code&gt;docker-compose.yml&lt;/code&gt; 참조&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="42e300efff75e3110759be633a66d0569b3f5b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose.yml&lt;/code&gt; file might specify a &lt;code&gt;webapp&lt;/code&gt; service.</source>
          <target state="translated">&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일은 지정할 수 있습니다 &lt;code&gt;webapp&lt;/code&gt; 서비스를.</target>
        </trans-unit>
        <trans-unit id="ce23ece18ea650efd0145a4a258ce3fc78e02e6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-default&lt;/code&gt; profile for containers lives in &lt;a href=&quot;https://github.com/moby/moby/tree/master/profiles/apparmor&quot;&gt;profiles/apparmor&lt;/a&gt;.</source>
          <target state="translated">컨테이너 의 &lt;code&gt;docker-default&lt;/code&gt; 프로파일은 &lt;a href=&quot;https://github.com/moby/moby/tree/master/profiles/apparmor&quot;&gt;profiles / apparmor에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e295c8599d28f52be79d6f37991897d2f4101fc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-default&lt;/code&gt; profile is the default for running containers. It is moderately protective while providing wide application compatibility. The profile is generated from the following &lt;a href=&quot;https://github.com/moby/moby/blob/master/profiles/apparmor/template.go&quot;&gt;template&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker-default&lt;/code&gt; 프로필은 컨테이너를 실행하기위한 기본이다. 광범위한 응용 프로그램 호환성을 제공하면서 적당히 보호됩니다. 프로필은 다음 &lt;a href=&quot;https://github.com/moby/moby/blob/master/profiles/apparmor/template.go&quot;&gt;템플릿&lt;/a&gt; 에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="53293c102800f99d9a3f56ca9a39e8ff9fd8b31f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-machine create&lt;/code&gt; command has some flags which apply to all drivers. These largely control aspects of Machine&amp;rsquo;s provisioning process (including the creation of Docker Swarm containers) that the user may wish to customize.</source>
          <target state="translated">&lt;code&gt;docker-machine create&lt;/code&gt; 명령은 모든 드라이버에 적용되는 몇 가지 플래그를 가지고있다. 이것들은 사용자가 커스터마이징 할 수있는 머신 프로비저닝 프로세스 (Docker Swarm 컨테이너 생성 포함)의 측면을 크게 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e849ce54b451a6cbfd8103fd5b47b57985f8374f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-machine create&lt;/code&gt; command typically requires that you specify, at a minimum:</source>
          <target state="translated">&lt;code&gt;docker-machine create&lt;/code&gt; 일반적으로는 최소한 지정해야합니다 명령을 :</target>
        </trans-unit>
        <trans-unit id="2db3618b71fffeeb2d53ba032a660f3e49b7592b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-machine&lt;/code&gt; subcommands are slightly different than the &lt;code&gt;boot2docker&lt;/code&gt; subcommands. The table below lists the equivalent &lt;code&gt;docker-machine&lt;/code&gt; subcommand and what it does:</source>
          <target state="translated">&lt;code&gt;docker-machine&lt;/code&gt; 부속 명령은보다 약간 다른 &lt;code&gt;boot2docker&lt;/code&gt; 의 하위 명령. 아래 표에는 해당 &lt;code&gt;docker-machine&lt;/code&gt; 하위 명령과 그 기능이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1db1683487e14949bbb78f38e959277a8f5ce96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dockerd&lt;/code&gt; options that support the &lt;code&gt;overlay&lt;/code&gt; network are:</source>
          <target state="translated">&lt;code&gt;dockerd&lt;/code&gt; 의 지원 옵션 &lt;code&gt;overlay&lt;/code&gt; 네트워크는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="7761e7440db05872e7e8ff271cc30ebcfb8af0e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver&lt;/code&gt; filter matches networks based on their driver.</source>
          <target state="translated">&lt;code&gt;driver&lt;/code&gt; 필터는 드라이버를 기반으로 네트워크를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="94879eb9ab387b61bf11d2e1021a2478cd5cb8f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver&lt;/code&gt; filter matches volumes based on their driver.</source>
          <target state="translated">&lt;code&gt;driver&lt;/code&gt; 필터는 드라이버에 따라 볼륨을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="65484cf66101bd80c3b61d4be6a3893152113f3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver&lt;/code&gt; name specifies a logging driver for the service&amp;rsquo;s containers, as with the &lt;code&gt;--log-driver&lt;/code&gt; option for docker run (&lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;documented here&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;driver&lt;/code&gt; 이름은에서와 같이, 서비스의 컨테이너에 대한 로깅 드라이버를 지정 &lt;code&gt;--log-driver&lt;/code&gt; (고정 표시기 실행에 대한 옵션 &lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;여기 문서화&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5900845392b6117d52a5cf8872beb287865bd83b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enabled&lt;/code&gt; filter matches on plugins enabled or disabled.</source>
          <target state="translated">&lt;code&gt;enabled&lt;/code&gt; 플러그인에 필터 일치 활성화 또는 비활성화.</target>
        </trans-unit>
        <trans-unit id="c2307cc28eea42e0d4cfd9d9269b5a168a00b09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erase&lt;/code&gt; command can write error messages to &lt;code&gt;STDOUT&lt;/code&gt; that the docker engine will show if there was an issue.</source>
          <target state="translated">&lt;code&gt;erase&lt;/code&gt; 명령은 오류 메시지를 기록 할 수 &lt;code&gt;STDOUT&lt;/code&gt; 문제가 된 경우 고정 표시기 엔진이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bea1b0179ece69facab7b56689aa14845a2f6b29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erase&lt;/code&gt; command takes a string payload from &lt;code&gt;STDIN&lt;/code&gt;. That payload carries the server address that the docker engine wants to remove credentials for. This is an example of that payload: &lt;code&gt;https://index.docker.io/v1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erase&lt;/code&gt; 명령에서 문자열 페이로드 소요 &lt;code&gt;STDIN&lt;/code&gt; 을 . 해당 페이로드는 도커 엔진이 자격 증명을 제거하려는 서버 주소를 전달합니다. &lt;code&gt;https://index.docker.io/v1&lt;/code&gt; 페이로드의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="3254cd82ba3134bf8e742dc3c8b67f6c4d144c42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;escape&lt;/code&gt; directive sets the character used to escape characters in a &lt;code&gt;Dockerfile&lt;/code&gt;. If not specified, the default escape character is &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;escape&lt;/code&gt; 지시어는 문자 탈출하는 데 사용되는 문자 설정 &lt;code&gt;Dockerfile&lt;/code&gt; 을 . 지정하지 않으면 기본 이스케이프 문자는 &lt;code&gt;\&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4cfc30d9ac969e04f4a3ad1ed08dbd7718761a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exited&lt;/code&gt; filter matches containers by exist status code. For example, to filter for containers that have exited successfully:</source>
          <target state="translated">&lt;code&gt;exited&lt;/code&gt; 필터가 존재하는 상태 코드가 일치 용기. 예를 들어, 성공적으로 종료 된 컨테이너를 필터링하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7f10d4cc68da79397364680c26647bc7ff0e9fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filter&lt;/code&gt; param to filter the list of image by reference (name or name:tag) is now implemented as a regular filter, named &lt;code&gt;reference&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 이제 정규 필터라는 이름으로 구현된다 PARAM 참조 (태그 이름 또는 이름)에 의한 이미지의 목록을 필터링 &lt;code&gt;reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9bf88f2b1a3cee4d1df04d1341ef1e7a515a38b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; command takes a string payload from the standard input. That payload carries the server address that the docker engine needs credentials for. This is an example of that payload: &lt;code&gt;https://index.docker.io/v1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 명령은 표준 입력에서 문자열 페이로드를합니다. 해당 페이로드에는 도커 엔진이 자격 증명이 필요한 서버 주소가 있습니다. &lt;code&gt;https://index.docker.io/v1&lt;/code&gt; 페이로드의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="9f9a5dac63313f2426c581b6b16d66b50692278c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; command writes a JSON payload to &lt;code&gt;STDOUT&lt;/code&gt;. Docker reads the user name and password from this payload:</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 명령에 JSON 페이로드를 기록 &lt;code&gt;STDOUT&lt;/code&gt; . Docker는이 페이로드에서 사용자 이름과 비밀번호를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2eea40067a6206a0916c6632051f6c874f33f8f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches a task&amp;rsquo;s id.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 필터는 작업의 ID를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="874d9c20a73081ecc0605f94bd826accf1ed089f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches all or part of a node&amp;rsquo;s id.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 필터는 노드의 ID의 전부 또는 일부를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="062f71d75d6eee0e75a08eb04d77e976398622ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches all or part of a service&amp;rsquo;s id.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 필터는 서비스의 ID의 전부 또는 일부를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9e7e6e53805c2ffc518e3b6b0f7c3661959a337d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches all or prefix of a secret&amp;rsquo;s id.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 필터는 비밀의 ID의 전부 또는 접두사와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c040b7fd003539442feca73620bd35debb9865f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches on all or a prefix of a task&amp;rsquo;s ID.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 필터는 모든 또는 작업의 ID의 접두사에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="33be488005446a7b9d19d4576733f3cd58f14e22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches on all or part of a network&amp;rsquo;s ID.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 필터는 네트워크의 ID의 전부 또는 일부에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1a9cc726ad58a1f48a622098d6bd09b650006d37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key=value&lt;/code&gt; must be unique to avoid overwriting the label value. If you specify labels with identical keys but different values, each subsequent value overwrites the previous. Docker uses the last &lt;code&gt;key=value&lt;/code&gt; you supply.</source>
          <target state="translated">&lt;code&gt;key=value&lt;/code&gt; 레이블 값을 덮어 쓰지 않도록하기 위해 고유해야합니다. 키는 동일하지만 값이 다른 레이블을 지정하면 이후의 각 값이 이전 값을 덮어 씁니다. Docker는 사용자가 제공 한 마지막 &lt;code&gt;key=value&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5654d9f7d98e717322ea30f463a002b491eb3daa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter accepts two formats. One is the &lt;code&gt;label=...&lt;/code&gt; (&lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes containers with the specified labels. The other format is the &lt;code&gt;label!=...&lt;/code&gt; (&lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes containers without the specified labels.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터는 두 가지 형식을 받아들입니다. 하나는 지정된 레이블이있는 컨테이너를 제거 하는 &lt;code&gt;label=...&lt;/code&gt; ( &lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; )입니다. 다른 형식은 지정된 레이블이없는 컨테이너를 제거 하는 &lt;code&gt;label!=...&lt;/code&gt; ( &lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="be97cd3616a16824993de31a828d5df1d9b52148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter accepts two formats. One is the &lt;code&gt;label=...&lt;/code&gt; (&lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes containers, images, networks, and volumes with the specified labels. The other format is the &lt;code&gt;label!=...&lt;/code&gt; (&lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes containers, images, networks, and volumes without the specified labels.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터는 두 가지 형식을 받아들입니다. 하나는 &lt;code&gt;label=...&lt;/code&gt; ( &lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; )이며 지정된 레이블이있는 컨테이너, 이미지, 네트워크 및 볼륨을 제거합니다. 다른 형식은 &lt;code&gt;label!=...&lt;/code&gt; ( &lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; )이며, 지정된 레이블없이 컨테이너, 이미지, 네트워크 및 볼륨을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b8a2df36fd4d938bef98a3473bfa58e3dccc1bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter accepts two formats. One is the &lt;code&gt;label=...&lt;/code&gt; (&lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes images with the specified labels. The other format is the &lt;code&gt;label!=...&lt;/code&gt; (&lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes images without the specified labels.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터는 두 가지 형식을 받아들입니다. 하나는 &lt;code&gt;label=...&lt;/code&gt; ( &lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; )이며 지정된 레이블이있는 이미지를 제거합니다. 다른 형식은 지정된 레이블이없는 이미지를 제거 하는 &lt;code&gt;label!=...&lt;/code&gt; ( &lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="52ff0a6b1f787c9e75fb01815b0e6b266ae2a1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter accepts two formats. One is the &lt;code&gt;label=...&lt;/code&gt; (&lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes networks with the specified labels. The other format is the &lt;code&gt;label!=...&lt;/code&gt; (&lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes networks without the specified labels.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터는 두 가지 형식을 받아들입니다. 하나는 &lt;code&gt;label=...&lt;/code&gt; ( &lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; )이며 지정된 레이블이있는 네트워크를 제거합니다. 다른 형식은 &lt;code&gt;label!=...&lt;/code&gt; ( &lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; )이며, 지정된 레이블이없는 네트워크를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="018de019755b87e20d5872730ae9dd136b302390" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches containers based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터 (A)의 존재에 기초하여 매치 용기 &lt;code&gt;label&lt;/code&gt; 형 또는 &lt;code&gt;label&lt;/code&gt; 및 값.</target>
        </trans-unit>
        <trans-unit id="4d8af22aa6e6d75efc58ea064321d18436b8a10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches images based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터 (A)의 존재에 따라 이미지와 일치하는 &lt;code&gt;label&lt;/code&gt; 형 또는 &lt;code&gt;label&lt;/code&gt; 및 값.</target>
        </trans-unit>
        <trans-unit id="98e6df95904d703aaec7b0207a80452c247789a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches networks based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터 (A)의 존재에 기초하여 매치 네트워크 &lt;code&gt;label&lt;/code&gt; 형 또는 &lt;code&gt;label&lt;/code&gt; 및 값.</target>
        </trans-unit>
        <trans-unit id="5e15c96bb92954198ca742ec3d8e8b0984c3f9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches nodes based on engine labels and on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value. Node labels are currently not used for filtering.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터는 엔진 레이블과의 존재 여부에 따라 노드와 일치 &lt;code&gt;label&lt;/code&gt; 혼자 또는 &lt;code&gt;label&lt;/code&gt; 과 값을. 노드 레이블은 현재 필터링에 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d48e63cfaa1dbb7dceb781c12aed418e6036a7cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches secrets based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터는의 존재 여부에 따라 비밀과 일치 &lt;code&gt;label&lt;/code&gt; 혼자 또는 &lt;code&gt;label&lt;/code&gt; 과 값을.</target>
        </trans-unit>
        <trans-unit id="4d4f1362ae0c77d72fd3decf3629591112e34b0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches services based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터는의 존재에 기반 서비스와 일치 &lt;code&gt;label&lt;/code&gt; 혼자 또는 &lt;code&gt;label&lt;/code&gt; 과 값을.</target>
        </trans-unit>
        <trans-unit id="7d6a1563d22c594b3e7762479f46564bf33ef840" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches tasks based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터는의 존재 여부에 따라 작업과 일치하는 &lt;code&gt;label&lt;/code&gt; 혼자 또는 &lt;code&gt;label&lt;/code&gt; 과 값을.</target>
        </trans-unit>
        <trans-unit id="af9c4f8bbdf1d60d98233e85dfbc13dc94b96e98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches volumes based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 필터 (A)의 존재에 기초하여 매치 된 볼륨 &lt;code&gt;label&lt;/code&gt; 형 또는 &lt;code&gt;label&lt;/code&gt; 및 값.</target>
        </trans-unit>
        <trans-unit id="0c2988bf145e8ccc73b38070bfaf3b48226f427f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command tries to reach each host in parallel. If a given host does not answer in less than 10 seconds, the &lt;code&gt;ls&lt;/code&gt; command states that this host is in &lt;code&gt;Timeout&lt;/code&gt; state. In some circumstances (poor connection, high load, or while troubleshooting), you may want to increase or decrease this value. You can use the -t flag for this purpose with a numerical value in seconds.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 병렬로 각 호스트에 도달하기 위해 시도를 명령. 주어진 호스트가 10 초 이내에 응답하지 않으면 &lt;code&gt;ls&lt;/code&gt; 명령은이 호스트가 &lt;code&gt;Timeout&lt;/code&gt; 상태에 있음을 나타냅니다. 연결 상태가 좋지 않거나 부하가 높거나 문제 해결 중일 때이 값을 늘리거나 줄일 수 있습니다. 이 목적으로 -t 플래그를 숫자 값 (초)과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5703b34d2ea18e80b932f011cb44b023bff8d66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;membership&lt;/code&gt; filter matches nodes based on the presence of a &lt;code&gt;membership&lt;/code&gt; and a value &lt;code&gt;accepted&lt;/code&gt; or &lt;code&gt;pending&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;membership&lt;/code&gt; 필터는의 존재 여부에 따라 노드와 일치하는 &lt;code&gt;membership&lt;/code&gt; 과 값 &lt;code&gt;accepted&lt;/code&gt; 또는 &lt;code&gt;pending&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b1c08c13336a840ca4426784eba1b9975c6865" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; filter matches on the mode (either &lt;code&gt;replicated&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;) of a service.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 필터 모드 (중 하나에 일치하는 &lt;code&gt;replicated&lt;/code&gt; 또는 &lt;code&gt;global&lt;/code&gt; 서비스의).</target>
        </trans-unit>
        <trans-unit id="f89ad7e1e240d286b92475de1880259e4179996e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my-label&lt;/code&gt; key doesn&amp;rsquo;t specify a value so the label defaults to an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;). To add multiple labels, repeat the label flag (&lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--label&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;my-label&lt;/code&gt; 키 (빈 문자열로 레이블 기본값 그래서 값을 지정하지 않습니다 &lt;code&gt;&quot;&quot;&lt;/code&gt; ). 여러 레이블을 추가하려면 레이블 플래그 ( &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--label&lt;/code&gt; )를 반복하십시오 .</target>
        </trans-unit>
        <trans-unit id="082614082d232a3fdd600eb393e84c2b7810814a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mynet&lt;/code&gt; network is now owned by &lt;code&gt;weave&lt;/code&gt;, so subsequent commands referring to that network will be sent to the plugin,</source>
          <target state="translated">&lt;code&gt;mynet&lt;/code&gt; 의 네트워크는 현재 소유하고 &lt;code&gt;weave&lt;/code&gt; 해당 네트워크에 참조하는 후속 명령은 플러그인으로 전송 될 수 있도록,</target>
        </trans-unit>
        <trans-unit id="4116f19330146743a5b9ffe7f885dbf991a4c292" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a container&amp;rsquo;s name.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필터는 컨테이너의 이름의 전부 또는 일부에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bdf2c18aa87a750b7d502fbc1168479b6f550ff3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a network&amp;rsquo;s name.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필터는 네트워크의 이름의 전부 또는 일부에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="13d14b84aa19afef87897aa55f10ed51ff7376a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a node hostname.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필터는 모든 또는 노드 호스트의 일부에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3c06f079b7410ab5cfcbb6181eb803ec0ef01f81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a service&amp;rsquo;s name.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필터는 서비스의 이름의 전부 또는 일부에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="40ee93534c85c37ac235cd07ceadd27279867de7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a task&amp;rsquo;s name.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필터는 작업의 이름의 전부 또는 일부에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7b0e1af36ee24c5616ec9fb952dc64e9cdf914ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a volume&amp;rsquo;s name.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필터는 볼륨의 이름의 전부 또는 일부에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="65875118713d9d791bb0a46435277fd73f9d0631" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or prefix of a secret&amp;rsquo;s name.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필터는 비밀의 이름의 전체 또는 접두사 일치합니다.</target>
        </trans-unit>
        <trans-unit id="48deeb28be69f5f57a0691024754fc4fcedb79e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on task names.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 필터는 작업 이름에 일치합니다.</target>
        </trans-unit>
        <trans-unit id="702fb5469953d05950f731252ceb1e71cb5ced6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;native.cgroupdriver&lt;/code&gt; option specifies the management of the container&amp;rsquo;s cgroups. You can only specify &lt;code&gt;cgroupfs&lt;/code&gt; or &lt;code&gt;systemd&lt;/code&gt;. If you specify &lt;code&gt;systemd&lt;/code&gt; and it is not available, the system errors out. If you omit the &lt;code&gt;native.cgroupdriver&lt;/code&gt; option,&lt;code&gt;cgroupfs&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;native.cgroupdriver&lt;/code&gt; 의 옵션은 컨테이너의 cgroup을의 관리를 지정합니다. &lt;code&gt;cgroupfs&lt;/code&gt; 또는 &lt;code&gt;systemd&lt;/code&gt; 만 지정할 수 있습니다 . &lt;code&gt;systemd&lt;/code&gt; 를 지정 했는데 사용할 수 없으면 시스템 오류가 발생합니다. &lt;code&gt;native.cgroupdriver&lt;/code&gt; 옵션 을 생략하면 &lt;code&gt;cgroupfs&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e84716020b3bafa9802a7e4d62c5858b8b46e922" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;network&lt;/code&gt; filter shows only containers that are connected to a network with a given name or id.</source>
          <target state="translated">&lt;code&gt;network&lt;/code&gt; 만 필터 보여주는 주어진 이름 또는 ID를 가진 네트워크에 연결되어있는 용기.</target>
        </trans-unit>
        <trans-unit id="b651cc06a639b090262a5f5c552b2399900192a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; filter matches on a node name or a node ID.</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 필터는 노드 이름 또는 노드 ID에 일치한다.</target>
        </trans-unit>
        <trans-unit id="4f8e6ad6eb59b8cb6cf3c618793766797bc47785" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notary list&lt;/code&gt; and &lt;code&gt;notary remove&lt;/code&gt; commands can also take the &lt;code&gt;--roles&lt;/code&gt; flag to specify roles to list or remove targets from. By default, this operates over the base &lt;code&gt;targets&lt;/code&gt; role.</source>
          <target state="translated">&lt;code&gt;notary list&lt;/code&gt; 및 &lt;code&gt;notary remove&lt;/code&gt; 명령도 취할 수 &lt;code&gt;--roles&lt;/code&gt; 에서 목록 또는 삭제 대상에 역할을 지정하는 플래그. 기본적으로 이는 기본 &lt;code&gt;targets&lt;/code&gt; 역할을 통해 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b27f7d14334c92b16cec1e9a1b3aed69946a76d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay2&lt;/code&gt; uses the same fast union filesystem but takes advantage of &lt;a href=&quot;https://lkml.org/lkml/2015/2/11/106&quot;&gt;additional features&lt;/a&gt; added in Linux kernel 4.0 to avoid excessive inode consumption. Call &lt;code&gt;dockerd -s overlay2&lt;/code&gt; to use it.</source>
          <target state="translated">&lt;code&gt;overlay2&lt;/code&gt; 같은 고속 노조 파일 시스템을 사용하지만 활용합니다 &lt;a href=&quot;https://lkml.org/lkml/2015/2/11/106&quot;&gt;추가 기능&lt;/a&gt; 과도한 아이 노드 소모를 방지하기 위해 리눅스 커널 4.0에 추가합니다. &lt;code&gt;dockerd -s overlay2&lt;/code&gt; 를 호출 하여 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f62b83b6c6304e6bd37693d3d4d2a3ba5d121dc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay&lt;/code&gt; driver creates a named network across multiple nodes in a &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;overlay&lt;/code&gt; 드라이버는 여러 노드에서 명명 된 네트워크 생성 &lt;a href=&quot;../../engine/swarm/index&quot;&gt;떼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1095b703bcc7591339e488256d38b8fabfd5f0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay&lt;/code&gt; is a very fast union filesystem. It is now merged in the main Linux kernel as of &lt;a href=&quot;https://lkml.org/lkml/2014/10/26/137&quot;&gt;3.18.0&lt;/a&gt;. &lt;code&gt;overlay&lt;/code&gt; also supports page cache sharing, this means multiple containers accessing the same file can share a single page cache entry (or entries), it makes &lt;code&gt;overlay&lt;/code&gt; as efficient with memory as &lt;code&gt;aufs&lt;/code&gt; driver. Call &lt;code&gt;dockerd -s overlay&lt;/code&gt; to use it.</source>
          <target state="translated">&lt;code&gt;overlay&lt;/code&gt; 매우 빠른 조합의 파일 시스템이다. 이제 &lt;a href=&quot;https://lkml.org/lkml/2014/10/26/137&quot;&gt;3.18.0부터&lt;/a&gt; 기본 Linux 커널에 병합되었습니다 . &lt;code&gt;overlay&lt;/code&gt; 는 또한 페이지 캐시 공유를 지원합니다. 즉, 동일한 파일에 액세스하는 여러 컨테이너가 단일 페이지 캐시 항목 (또는 항목)을 공유 할 수 있으며, 이는 &lt;code&gt;aufs&lt;/code&gt; 드라이버 만큼 메모리를 사용하여 &lt;code&gt;overlay&lt;/code&gt; 를 효율적으로 만듭니다 . &lt;code&gt;dockerd -s overlay&lt;/code&gt; 를 호출 하여 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e8add9ee4df5f9e747f7dfaaa7ea17cfd452a7db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay&lt;/code&gt; storage driver is deprecated in favor of the &lt;code&gt;overlay2&lt;/code&gt; storage driver, which has all the benefits of &lt;code&gt;overlay&lt;/code&gt;, without its limitations (excessive inode consumption). The legacy &lt;code&gt;overlay&lt;/code&gt; storage driver will be removed in a future release. Users of the &lt;code&gt;overlay&lt;/code&gt; storage driver should migrate to the &lt;code&gt;overlay2&lt;/code&gt; storage driver.</source>
          <target state="translated">&lt;code&gt;overlay&lt;/code&gt; 스토리지 드라이버는 &lt;code&gt;overlay2&lt;/code&gt; 드라이버 를 위해 더 이상 사용되지 않습니다 . 오버레이 드라이버는 한계 (과도한 inode 소비)없이 &lt;code&gt;overlay&lt;/code&gt; 모든 이점을 제공 합니다. 레거시 &lt;code&gt;overlay&lt;/code&gt; 스토리지 드라이버는 향후 릴리스에서 제거 될 예정입니다. &lt;code&gt;overlay&lt;/code&gt; 스토리지 드라이버 사용자는 &lt;code&gt;overlay2&lt;/code&gt; 스토리지 드라이버 로 마이그레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="57d6cd43d9cf4064b15d5370549b191804dbe847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;expose&lt;/code&gt; filters show only containers that have published or exposed port with a given port number, port range, and/or protocol. The default protocol is &lt;code&gt;tcp&lt;/code&gt; when not specified.</source>
          <target state="translated">&lt;code&gt;publish&lt;/code&gt; 및 &lt;code&gt;expose&lt;/code&gt; 필터는 게시 또는 지정된 포트 번호, 포트 범위, 및 / 또는 프로토콜 포트를 노출 만 컨테이너를 보여줍니다. 지정되지 않은 경우 기본 프로토콜은 &lt;code&gt;tcp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32212b2ccd1049c0834c60bdfd798e9765d7db57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;redis&lt;/code&gt; service uses a public &lt;a href=&quot;https://registry.hub.docker.com/_/redis/&quot;&gt;Redis&lt;/a&gt; image pulled from the Docker Hub registry.</source>
          <target state="translated">&lt;code&gt;redis&lt;/code&gt; 서비스는 공공 사용 &lt;a href=&quot;https://registry.hub.docker.com/_/redis/&quot;&gt;레디 스의&lt;/a&gt; 도커 허브 레지스트리에서 가져온 이미지를.</target>
        </trans-unit>
        <trans-unit id="a10f28df2d9ece01d4995b17a29708fde3933b04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reference&lt;/code&gt; filter shows only images whose reference matches the specified pattern.</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; 필터 그 방송 기준 지정된 패턴에 일치하는 경우에만 영상.</target>
        </trans-unit>
        <trans-unit id="e28bcc91dc3b30ca61505750632dc3ed05692327" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remote_server&lt;/code&gt; specifies how to connect to a Notary server to download metadata updates and publish metadata changes.</source>
          <target state="translated">&lt;code&gt;remote_server&lt;/code&gt; 지정 방법 메타 데이터 업데이트를 다운로드 및 메타 데이터 변경 사항을 공개하는 공증인 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f95d30a98fcc537264adac1b069c3de5c624096e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repository:shortid&lt;/code&gt; syntax for referencing images is very little used, collides with tag references, and can be confused with digest references.</source>
          <target state="translated">&lt;code&gt;repository:shortid&lt;/code&gt; 참조 화상에 대한 구문은 거의 태그 참조하여, 충돌을 이용하여, 다이제스트에 대한 참조와 혼동 될 수있다.</target>
        </trans-unit>
        <trans-unit id="946a27d27a594272d228a2f9ebd5d23d58f82f9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;role&lt;/code&gt; filter matches nodes based on the presence of a &lt;code&gt;role&lt;/code&gt; and a value &lt;code&gt;worker&lt;/code&gt; or &lt;code&gt;manager&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;role&lt;/code&gt; 필터는의 존재 여부에 따라 노드와 일치 &lt;code&gt;role&lt;/code&gt; 과 가치 &lt;code&gt;worker&lt;/code&gt; 또는 &lt;code&gt;manager&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19a30e315bc4c8b432b7da06b140919f686444f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;root_keys&lt;/code&gt; subdirectory within &lt;code&gt;private&lt;/code&gt; stores root private keys, while &lt;code&gt;tuf_keys&lt;/code&gt; stores targets, snapshots, and delegations private keys.</source>
          <target state="translated">&lt;code&gt;root_keys&lt;/code&gt; 은 내 서브 디렉토리 &lt;code&gt;private&lt;/code&gt; 상점 개인 키를 근절하면서, &lt;code&gt;tuf_keys&lt;/code&gt; 의 저장 대상, 스냅 샷 및 대표단 개인 키.</target>
        </trans-unit>
        <trans-unit id="6610e72ef34ecc0f23817bc0409ff6cf2dea2b7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootfs&lt;/code&gt; directory represents the root filesystem of the plugin. In this example, it was created from a Dockerfile:</source>
          <target state="translated">&lt;code&gt;rootfs&lt;/code&gt; 의 디렉토리는 플러그인의 루트 파일 시스템을 나타냅니다. 이 예제에서는 Dockerfile에서 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="27e15a03c1fef8554bd0e6252de77d87b274d86d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope&lt;/code&gt; filter matches networks based on their scope.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 필터는 그 범위에 따라 네트워크를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8a091005755a7e40cc57b9186a022197457f724c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;service&lt;/code&gt; file (for example &lt;code&gt;/lib/systemd/system/your-plugin.service&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;service&lt;/code&gt; (예 : 대한 파일 &lt;code&gt;/lib/systemd/system/your-plugin.service&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="37491830e511de1d5bb58a0686627f39963dcb6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;service&lt;/code&gt; the name of the service being extended, for example &lt;code&gt;web&lt;/code&gt; or &lt;code&gt;database&lt;/code&gt;. The &lt;code&gt;file&lt;/code&gt; is the location of a Compose configuration file defining that service.</source>
          <target state="translated">&lt;code&gt;service&lt;/code&gt; 서비스의 이름은 예를 들어, 확장 된 &lt;code&gt;web&lt;/code&gt; 또는 &lt;code&gt;database&lt;/code&gt; . &lt;code&gt;file&lt;/code&gt; 해당 서비스를 정의하는 작성 구성 파일의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="a360e2cea9622846c780d822d40a24715633debd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;since&lt;/code&gt; filter shows only containers created since the container with given id or name. For example, with the same containers as in &lt;code&gt;before&lt;/code&gt; filter:</source>
          <target state="translated">이 &lt;code&gt;since&lt;/code&gt; 필터만을 도시 용기 주어진 이름 또는 ID와 컨테이너 이후 만들었다. 예를 들어 &lt;code&gt;before&lt;/code&gt; 필터 와 동일한 컨테이너를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="84d3e1bb8cb5d26bcfef75759b883a6e402ea173" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;site.csr&lt;/code&gt; and &lt;code&gt;site.cnf&lt;/code&gt; files are not needed by the Nginx service, but you need them if you want to generate a new site certificate. Protect the &lt;code&gt;root-ca.key&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;site.csr&lt;/code&gt; 및 &lt;code&gt;site.cnf&lt;/code&gt; 파일은 Nginx에 서비스가 필요하지만 새 사이트 인증서를 생성하려는 경우 당신이 그들을 필요로하지 않습니다. &lt;code&gt;root-ca.key&lt;/code&gt; 파일을 보호 하십시오.</target>
        </trans-unit>
        <trans-unit id="3977312060c807dab33ea48b26fdaff6022f83de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socket&lt;/code&gt; file (for example &lt;code&gt;/lib/systemd/system/your-plugin.socket&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; (예 : 대한 파일 &lt;code&gt;/lib/systemd/system/your-plugin.socket&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="74dddfba7279c1388888439111e559495678ed60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;status&lt;/code&gt; filter matches containers by status. You can filter using &lt;code&gt;created&lt;/code&gt;, &lt;code&gt;restarting&lt;/code&gt;, &lt;code&gt;running&lt;/code&gt;, &lt;code&gt;removing&lt;/code&gt;, &lt;code&gt;paused&lt;/code&gt;, &lt;code&gt;exited&lt;/code&gt; and &lt;code&gt;dead&lt;/code&gt;. For example, to filter for &lt;code&gt;running&lt;/code&gt; containers:</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 필터 는 상태 별로 컨테이너를 일치시킵니다. 다음을 사용하여 필터링 할 수 있습니다 &lt;code&gt;created&lt;/code&gt; , &lt;code&gt;restarting&lt;/code&gt; , &lt;code&gt;running&lt;/code&gt; , &lt;code&gt;removing&lt;/code&gt; , &lt;code&gt;paused&lt;/code&gt; , &lt;code&gt;exited&lt;/code&gt; 및 &lt;code&gt;dead&lt;/code&gt; . 예를 들어, 컨테이너 &lt;code&gt;running&lt;/code&gt; 을 필터링하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c2e44a9200bd1d71315631b0c2c98438f27f8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;store&lt;/code&gt; command can write error messages to &lt;code&gt;STDOUT&lt;/code&gt; that the docker engine will show if there was an issue.</source>
          <target state="translated">&lt;code&gt;store&lt;/code&gt; 명령에 오류 메시지를 기록 할 수 &lt;code&gt;STDOUT&lt;/code&gt; 문제가 된 경우 고정 표시기 엔진이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="201eae4e5d21feaa880c1da9df3662878ff71506" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;store&lt;/code&gt; command takes a JSON payload from the standard input. That payload carries the server address, to identify the credential, the user name, and either a password or an identity token.</source>
          <target state="translated">&lt;code&gt;store&lt;/code&gt; 명령은 표준 입력으로부터 JSON 페이 걸린다. 해당 페이로드는 서버 주소를 전달하여 신임 정보, 사용자 이름 및 비밀번호 또는 ID 토큰을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="8f8d92702335aa3cf9f7d6e3d0646cb9035f7d39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag&lt;/code&gt; or &lt;code&gt;digest&lt;/code&gt; values are optional. If you omit either of them, the builder assumes a &lt;code&gt;latest&lt;/code&gt; tag by default. The builder returns an error if it cannot find the &lt;code&gt;tag&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;tag&lt;/code&gt; 또는 &lt;code&gt;digest&lt;/code&gt; 값은 선택 사항입니다. 둘 중 하나를 생략하면 빌더는 기본적으로 &lt;code&gt;latest&lt;/code&gt; 태그를 가정합니다 . 빌더는 &lt;code&gt;tag&lt;/code&gt; 값을 찾을 수 없으면 오류를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="acb29c4110ede458e19d89941d169232476d9c7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trust_dir&lt;/code&gt; specifies the location (as an absolute path or a path relative to the directory of the configuration file) where the TUF metadata and private keys are stored.</source>
          <target state="translated">&lt;code&gt;trust_dir&lt;/code&gt; 는 TUF 메타 데이터 및 개인 키가 저장된다 (절대 경로 또는 구성 파일의 디렉토리에 상대적인 경로 등)의 위치를 지정한다.</target>
        </trans-unit>
        <trans-unit id="d567b63c2e261aff2ddbc1c532e24bc856109547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trust_pinning&lt;/code&gt; specifies how to bootstrap trust for the root of a Notary client&amp;rsquo;s trusted collection.</source>
          <target state="translated">&lt;code&gt;trust_pinning&lt;/code&gt; 지정은 어떻게 공증인 고객의 신뢰 모음 루트에 대한 신뢰를 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="5c3ba868e5bbc2288271513312680c5aea6e1bc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; filter supports two values; &lt;code&gt;builtin&lt;/code&gt; displays predefined networks (&lt;code&gt;bridge&lt;/code&gt;, &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt;), whereas &lt;code&gt;custom&lt;/code&gt; displays user defined networks.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 필터는 두 값을 지원; &lt;code&gt;builtin&lt;/code&gt; 디스플레이 미리 네트워크 ( &lt;code&gt;bridge&lt;/code&gt; , &lt;code&gt;none&lt;/code&gt; , &lt;code&gt;host&lt;/code&gt; 반면), &lt;code&gt;custom&lt;/code&gt; 디스플레이 사용자 정의 네트워크.</target>
        </trans-unit>
        <trans-unit id="623dd4366d3e03347278170a9392f26c7b6dca59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;until&lt;/code&gt; filter can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &lt;code&gt;10m&lt;/code&gt;, &lt;code&gt;1h30m&lt;/code&gt;) computed relative to the daemon machine&amp;rsquo;s time. Supported formats for date formatted time stamps include RFC3339Nano, RFC3339, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt;, &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt;, &lt;code&gt;2006-01-02Z07:00&lt;/code&gt;, and &lt;code&gt;2006-01-02&lt;/code&gt;. The local timezone on the daemon will be used if you do not provide either a &lt;code&gt;Z&lt;/code&gt; or a &lt;code&gt;+-00:00&lt;/code&gt; timezone offset at the end of the timestamp. When providing Unix timestamps enter seconds[.nanoseconds], where seconds is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (aka Unix epoch or Unix time), and the optional .nanoseconds field is a fraction of a second no more than nine digits long.</source>
          <target state="translated">&lt;code&gt;until&lt;/code&gt; 필터는 유닉스 타임 스탬프, 날짜 형식의 타임 스탬프, 또는 이동 시간 문자열 (예, 할 수 있습니다 &lt;code&gt;10m&lt;/code&gt; , &lt;code&gt;1h30m&lt;/code&gt; 데몬 컴퓨터의 시간을 기준으로 계산). 날짜 형식 타임 스탬프에 지원되는 형식에는 RFC3339Nano, RFC3339, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt; , &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt; , &lt;code&gt;2006-01-02Z07:00&lt;/code&gt; 및 &lt;code&gt;2006-01-02&lt;/code&gt; 가 있습니다. &lt;code&gt;Z&lt;/code&gt; 또는 &lt;code&gt;+-00:00&lt;/code&gt; 을 제공하지 않으면 데몬의 현지 시간대가 사용됩니다 .타임 스탬프 끝의 시간대 오프셋 유닉스 타임 스탬프를 제공 할 때 초 [.nanoseconds]를 입력하면 초는 1970 년 1 월 1 일 (자정 UTC / GMT) 이후 경과 한 초 수이며, 유닉스 초 (일명 유닉스 시대 또는 유닉스 시간)를 계산하지 않으며 선택 사항입니다. 나노초 필드는 9 자리 이하의 초의 분수입니다.</target>
        </trans-unit>
        <trans-unit id="88838fefdaa39b0ba1f163b1d4ed778a4bd3b967" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volume&lt;/code&gt; filter shows only containers that mount a specific volume or have a volume mounted in a specific path:</source>
          <target state="translated">&lt;code&gt;volume&lt;/code&gt; 필터 나타내는 특정 볼륨을 장착하거나 부피가 특정 경로에 장착 한 경우에만 컨테이너 :</target>
        </trans-unit>
        <trans-unit id="fffe874eceb8a6d1dad5be3972e327372c8f22a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;web&lt;/code&gt; service uses an image that&amp;rsquo;s built from the &lt;code&gt;Dockerfile&lt;/code&gt; in the current directory. It then binds the container and the host machine to the exposed port, &lt;code&gt;5000&lt;/code&gt;. This example service uses the default port for the Flask web server, &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;web&lt;/code&gt; 서비스가에서으로 구축 이미지 사용 &lt;code&gt;Dockerfile&lt;/code&gt; 현재 디렉토리에 있습니다. 그런 다음 컨테이너와 호스트 시스템을 노출 된 포트 &lt;code&gt;5000&lt;/code&gt; 에 바인딩합니다 . 이 예제 서비스는 Flask 웹 서버의 기본 포트 인 &lt;code&gt;5000&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="cfb1cd9971be9ceb83fb0faa1ce31cb35adfc984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zfs&lt;/code&gt; driver is probably not as fast as &lt;code&gt;btrfs&lt;/code&gt; but has a longer track record on stability. Thanks to &lt;code&gt;Single Copy ARC&lt;/code&gt; shared blocks between clones will be cached only once. Use &lt;code&gt;dockerd -s zfs&lt;/code&gt;. To select a different zfs filesystem set &lt;code&gt;zfs.fsname&lt;/code&gt; option as described in &lt;a href=&quot;#zfs-options&quot;&gt;ZFS options&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;zfs&lt;/code&gt; 드라이버는 최대한 빨리 아마하지 &lt;code&gt;btrfs&lt;/code&gt; 를 하지만, 안정성에 더 긴 트랙 기록을 가지고 있습니다. 복제본 간의 &lt;code&gt;Single Copy ARC&lt;/code&gt; 공유 블록 덕분에 한 번만 캐시됩니다. &lt;code&gt;dockerd -s zfs&lt;/code&gt; 를 사용하십시오 . 다른 zfs 파일 시스템을 선택하려면 &lt;a href=&quot;#zfs-options&quot;&gt;ZFS 옵션에&lt;/a&gt; 설명 된대로 &lt;code&gt;zfs.fsname&lt;/code&gt; 옵션을 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6624f3a95723eb7deecfcb67c0306da23d188f9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;exec&lt;/em&gt; form makes it possible to avoid shell string munging, and to &lt;code&gt;RUN&lt;/code&gt; commands using a base image that does not contain the specified shell executable.</source>
          <target state="translated">&lt;em&gt;간부&lt;/em&gt; 형태는 가능 쉘 문자열 munging을 피하고,에 할 수 &lt;code&gt;RUN&lt;/code&gt; 의 지정된 쉘 실행 파일을 포함하지 않는 기본 이미지를 사용하여 명령.</target>
        </trans-unit>
        <trans-unit id="7658e2cd9f6d19cd1a74039c07d230202a829f8c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shell&lt;/em&gt; form prevents any &lt;code&gt;CMD&lt;/code&gt; or &lt;code&gt;run&lt;/code&gt; command line arguments from being used, but has the disadvantage that your &lt;code&gt;ENTRYPOINT&lt;/code&gt; will be started as a subcommand of &lt;code&gt;/bin/sh -c&lt;/code&gt;, which does not pass signals. This means that the executable will not be the container&amp;rsquo;s &lt;code&gt;PID 1&lt;/code&gt; - and will &lt;em&gt;not&lt;/em&gt; receive Unix signals - so your executable will not receive a &lt;code&gt;SIGTERM&lt;/code&gt; from &lt;code&gt;docker stop &amp;lt;container&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;쉘&lt;/em&gt; 형태의 방지 어떤 &lt;code&gt;CMD&lt;/code&gt; 또는 &lt;code&gt;run&lt;/code&gt; 에서 명령 줄 인수를 사용하지만 그 단점이되고있는 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 의 하위 명령으로 시작됩니다 &lt;code&gt;/bin/sh -c&lt;/code&gt; 신호를 전달하지 않습니다. 즉, 실행 파일은 컨테이너의 &lt;code&gt;PID 1&lt;/code&gt; 이 &lt;em&gt;아니며&lt;/em&gt; Unix 신호를 수신하지 않으므로 &lt;code&gt;docker stop &amp;lt;container&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;SIGTERM&lt;/code&gt; 을 수신 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="58b7b4aa81e7c742e582727ad709a516ccd434f0" translate="yes" xml:space="preserve">
          <source>The API is versioned via an Accept header, which currently is always set to &lt;code&gt;application/vnd.docker.plugins.v1+json&lt;/code&gt;.</source>
          <target state="translated">API는 현재 항상 &lt;code&gt;application/vnd.docker.plugins.v1+json&lt;/code&gt; 으로 설정되는 Accept 헤더를 통해 버전이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e306793d0c42815f9b23cd928d98f6eb8a992cc" translate="yes" xml:space="preserve">
          <source>The BugSnag API key to use to report errors.</source>
          <target state="translated">오류를보고하는 데 사용할 BugSnag API 키.</target>
        </trans-unit>
        <trans-unit id="a5433b4be7d70650a05b6da15569a592be1d2f16" translate="yes" xml:space="preserve">
          <source>The CLI interprets the &lt;code&gt;.dockerignore&lt;/code&gt; file as a newline-separated list of patterns similar to the file globs of Unix shells. For the purposes of matching, the root of the context is considered to be both the working and the root directory. For example, the patterns &lt;code&gt;/foo/bar&lt;/code&gt; and &lt;code&gt;foo/bar&lt;/code&gt; both exclude a file or directory named &lt;code&gt;bar&lt;/code&gt; in the &lt;code&gt;foo&lt;/code&gt; subdirectory of &lt;code&gt;PATH&lt;/code&gt; or in the root of the git repository located at &lt;code&gt;URL&lt;/code&gt;. Neither excludes anything else.</source>
          <target state="translated">CLI는 &lt;code&gt;.dockerignore&lt;/code&gt; 파일을 줄 바꿈으로 구분 된 패턴 목록으로 해석하고 Unix 쉘의 파일 글로브와 유사합니다. 일치를 위해 컨텍스트의 루트는 작업 디렉토리와 루트 디렉토리로 간주됩니다. 예를 들어, &lt;code&gt;/foo/bar&lt;/code&gt; 및 &lt;code&gt;foo/bar&lt;/code&gt; 패턴은 모두 &lt;code&gt;PATH&lt;/code&gt; 의 &lt;code&gt;foo&lt;/code&gt; 서브 디렉토리 또는 &lt;code&gt;URL&lt;/code&gt; 에있는 git 저장소의 루트에서 &lt;code&gt;bar&lt;/code&gt; 라는 파일 또는 디렉토리를 제외합니다 . 다른 것도 배제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a6904fbb817ebee7ff84f7e6d4354ab155db813" translate="yes" xml:space="preserve">
          <source>The Compose file can also be provided as standard input with &lt;code&gt;--compose-file -&lt;/code&gt;:</source>
          <target state="translated">작성 파일은 &lt;code&gt;--compose-file -&lt;/code&gt; 과 함께 표준 입력으로 제공 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a8f68cb614e118d7a4b20ace969787816ab48d0" translate="yes" xml:space="preserve">
          <source>The Compose file formats are now described in these references, specific to each version.</source>
          <target state="translated">작성 파일 형식은 이제 각 버전에 따라이 참조에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d29374d8810128ad1904bc2c9e9b744865870f4" translate="yes" xml:space="preserve">
          <source>The Compose file is a &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; file defining &lt;a href=&quot;#service-configuration-reference&quot;&gt;services&lt;/a&gt;, &lt;a href=&quot;#network-configuration-reference&quot;&gt;networks&lt;/a&gt; and &lt;a href=&quot;#volume-configuration-reference&quot;&gt;volumes&lt;/a&gt;. The default path for a Compose file is &lt;code&gt;./docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">작성 파일은 &lt;a href=&quot;#service-configuration-reference&quot;&gt;서비스&lt;/a&gt; , &lt;a href=&quot;#network-configuration-reference&quot;&gt;네트워크&lt;/a&gt; 및 &lt;a href=&quot;#volume-configuration-reference&quot;&gt;볼륨을&lt;/a&gt; 정의 하는 &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; 파일 입니다. 작성 파일의 기본 경로는 &lt;code&gt;./docker-compose.yml&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f2e30c63852d32e3d75aa2f8d4ff22ba7d03a09" translate="yes" xml:space="preserve">
          <source>The Compose file is a &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; file defining services, networks, and volumes for a Docker application.</source>
          <target state="translated">작성 파일은 Docker 애플리케이션의 서비스, 네트워크 및 볼륨을 정의 하는 &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="516fc9fe7a027246ddf927cabfb86b10368bf5ea" translate="yes" xml:space="preserve">
          <source>The DigitalOcean driver uses &lt;code&gt;ubuntu-16-04-x64&lt;/code&gt; as the default image.</source>
          <target state="translated">DigitalOcean 드라이버는 기본 이미지로 &lt;code&gt;ubuntu-16-04-x64&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="60e1c1a3e2fc863f910eda1e82acf0df54987727" translate="yes" xml:space="preserve">
          <source>The Docker API only supports requests from clients which report a specific version. If you receive a &lt;code&gt;client and server don't have same version&lt;/code&gt; error using &lt;code&gt;docker-compose&lt;/code&gt;, you can workaround this error by setting this environment variable. Set the version value to match the server version.</source>
          <target state="translated">Docker API는 특정 버전을보고하는 클라이언트의 요청 만 지원합니다. 당신이받는 경우 &lt;code&gt;client and server don't have same version&lt;/code&gt; 사용하여 오류를 &lt;code&gt;docker-compose&lt;/code&gt; ,이 환경 변수를 설정하여이 오류를 해결할 수 있습니다. 서버 버전과 일치하도록 버전 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d1504232c28254b9f9fcec3e6f6770c5273875bb" translate="yes" xml:space="preserve">
          <source>The Docker Engine - our lightweight and powerful open source containerization technology combined with a work flow for building and containerizing your applications.</source>
          <target state="translated">Docker Engine-가볍고 강력한 오픈 소스 컨테이너화 기술로 애플리케이션 구축 및 컨테이너화를위한 워크 플로우와 결합합니다.</target>
        </trans-unit>
        <trans-unit id="e981d539da2aad65e18d80315ff72524e7e5303d" translate="yes" xml:space="preserve">
          <source>The Docker Engine can be configured to only run signed images. The Docker Content Trust signature verification feature is built directly into the &lt;code&gt;dockerd&lt;/code&gt; binary.</source>
          <target state="translated">Docker Engine은 서명 된 이미지 만 실행하도록 구성 할 수 있습니다. Docker Content Trust 서명 확인 기능은 &lt;code&gt;dockerd&lt;/code&gt; 바이너리에 직접 내장되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="769b3a4ec31c20cda0955586d45d677bc3ea572f" translate="yes" xml:space="preserve">
          <source>The Docker Engine can keep user credentials in an external credentials store, such as the native keychain of the operating system. Using an external store is more secure than storing credentials in the Docker configuration file.</source>
          <target state="translated">Docker Engine은 운영 체제의 기본 키 체인과 같은 외부 자격 증명 저장소에 사용자 자격 증명을 유지할 수 있습니다. 외부 저장소를 사용하는 것이 Docker 구성 파일에 신임 정보를 저장하는 것보다 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a95fdd73bfffcdc36ab59e6eb0861915736278a5" translate="yes" xml:space="preserve">
          <source>The Docker Engine client takes care of these name expansions for you so do not change the names you use with the Engine client or API. This is a requirement only when interacting with the same Docker Hub repositories through the Notary client.</source>
          <target state="translated">Docker Engine 클라이언트는 이러한 이름 확장을 처리하므로 엔진 클라이언트 또는 API에 사용하는 이름을 변경하지 마십시오. 이는 Notary 클라이언트를 통해 동일한 Docker Hub 리포지토리와 상호 작용할 때만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e5e6b53dfbe1a35edb43e21132908b08612d8d0b" translate="yes" xml:space="preserve">
          <source>The Docker Engine joins the swarm depending on the &lt;strong&gt;join-token&lt;/strong&gt; you provide to the &lt;code&gt;docker swarm join&lt;/code&gt; command. The node only uses the token at join time. If you subsequently rotate the token, it doesn&amp;rsquo;t affect existing swarm nodes. Refer to &lt;a href=&quot;../swarm-mode/index#view-the-join-command-or-update-a-swarm-join-token&quot;&gt;Run Docker Engine in swarm mode&lt;/a&gt;.</source>
          <target state="translated">Docker 엔진 은 &lt;code&gt;docker swarm join&lt;/code&gt; 명령에 제공 하는 &lt;strong&gt;결합 토큰&lt;/strong&gt; 에 따라 swarm에 결합 합니다. 노드는 결합시에만 토큰을 사용합니다. 이후에 토큰을 회전해도 기존 스웜 노드에는 영향을 미치지 않습니다. &lt;a href=&quot;../swarm-mode/index#view-the-join-command-or-update-a-swarm-join-token&quot;&gt;swarm 모드에서 Docker Engine 실행을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f02c0b12a5516b4fd13dbbd313dee5b1eda6fe97" translate="yes" xml:space="preserve">
          <source>The Docker Engine returns an error if the driver is not available.</source>
          <target state="translated">드라이버를 사용할 수없는 경우 Docker 엔진이 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="26a113db9a410ab73f222f9bca15d695db3743ad" translate="yes" xml:space="preserve">
          <source>The Docker client stores the keys in the &lt;code&gt;~/.docker/trust/private&lt;/code&gt; directory. Before backing them up, you should &lt;code&gt;tar&lt;/code&gt; them into an archive:</source>
          <target state="translated">Docker 클라이언트는 키를 &lt;code&gt;~/.docker/trust/private&lt;/code&gt; 디렉토리에 저장합니다. 백업하기 전에 아카이브로 &lt;code&gt;tar&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f784453fb940cff3136cf6c4eccf303e18360b96" translate="yes" xml:space="preserve">
          <source>The Docker client will honor the &lt;code&gt;DOCKER_HOST&lt;/code&gt; environment variable to set the &lt;code&gt;-H&lt;/code&gt; flag for the client. Use &lt;strong&gt;one&lt;/strong&gt; of the following commands:</source>
          <target state="translated">Docker 클라이언트는 &lt;code&gt;DOCKER_HOST&lt;/code&gt; 환경 변수를 사용 하여 클라이언트 의 &lt;code&gt;-H&lt;/code&gt; 플래그 를 설정합니다 . 다음 명령 &lt;strong&gt;중 하나&lt;/strong&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9b1e227b06064053804ed860bc5f7814dea3d4e" translate="yes" xml:space="preserve">
          <source>The Docker client will honor the &lt;code&gt;HTTP_PROXY&lt;/code&gt;, &lt;code&gt;HTTPS_PROXY&lt;/code&gt;, and &lt;code&gt;NO_PROXY&lt;/code&gt; environment variables (or the lowercase versions thereof). &lt;code&gt;HTTPS_PROXY&lt;/code&gt; takes precedence over &lt;code&gt;HTTP_PROXY&lt;/code&gt;.</source>
          <target state="translated">도커 클라이언트 명예 것이다 &lt;code&gt;HTTP_PROXY&lt;/code&gt; , &lt;code&gt;HTTPS_PROXY&lt;/code&gt; 하고 &lt;code&gt;NO_PROXY&lt;/code&gt; 환경 변수 (또는 소문자 변형체 참조). &lt;code&gt;HTTPS_PROXY&lt;/code&gt; 가 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="a5c8f241b1b8d61a93d92c1530c2e12812c43b35" translate="yes" xml:space="preserve">
          <source>The Docker daemon can listen for &lt;a href=&quot;https://docs.docker.com/develop/sdk&quot;&gt;Docker Engine API&lt;/a&gt; requests via three different types of Socket: &lt;code&gt;unix&lt;/code&gt;, &lt;code&gt;tcp&lt;/code&gt;, and &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">Docker 데몬은 서로 다른 세 가지 유형의 소켓 ( &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; 및 &lt;code&gt;fd&lt;/code&gt; )을 통해 &lt;a href=&quot;https://docs.docker.com/develop/sdk&quot;&gt;Docker Engine API&lt;/a&gt; 요청을 청취 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9c9784a3450d3d22b2aa9a2e66a2518f32553f2" translate="yes" xml:space="preserve">
          <source>The Docker daemon interprets &lt;code&gt;.crt&lt;/code&gt; files as CA certificates and &lt;code&gt;.cert&lt;/code&gt; files as client certificates. If a CA certificate is accidentally given the extension &lt;code&gt;.cert&lt;/code&gt; instead of the correct &lt;code&gt;.crt&lt;/code&gt; extension, the Docker daemon logs the following error message:</source>
          <target state="translated">Docker 데몬은 &lt;code&gt;.crt&lt;/code&gt; 파일을 CA 인증서로 해석 하고 &lt;code&gt;.cert&lt;/code&gt; 파일을 클라이언트 인증서 로 해석 합니다 . CA 인증서에 실수로 올바른 &lt;code&gt;.crt&lt;/code&gt; 확장자 대신 &lt;code&gt;.cert&lt;/code&gt; 확장자가 제공되면 Docker 데몬은 다음 오류 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="cb898408cbd90376be8d461674bfc0ca2aa29162" translate="yes" xml:space="preserve">
          <source>The Docker daemon relies on a &lt;a href=&quot;https://github.com/opencontainers/runtime-spec&quot;&gt;OCI&lt;/a&gt; compliant runtime (invoked via the &lt;code&gt;containerd&lt;/code&gt; daemon) as its interface to the Linux kernel &lt;code&gt;namespaces&lt;/code&gt;, &lt;code&gt;cgroups&lt;/code&gt;, and &lt;code&gt;SELinux&lt;/code&gt;.</source>
          <target state="translated">Docker 데몬은 &lt;code&gt;containerd&lt;/code&gt; 커널 데몬을 통해 호출 된 &lt;a href=&quot;https://github.com/opencontainers/runtime-spec&quot;&gt;OCI&lt;/a&gt; 호환 런타임 을 Linux 커널 &lt;code&gt;namespaces&lt;/code&gt; , &lt;code&gt;cgroups&lt;/code&gt; 및 &lt;code&gt;SELinux&lt;/code&gt; 에 대한 인터페이스로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6f8b8fe412b9032f49ad4147a38c5684876ea1dd" translate="yes" xml:space="preserve">
          <source>The Docker daemon runs the instructions in the &lt;code&gt;Dockerfile&lt;/code&gt; one-by-one, committing the result of each instruction to a new image if necessary, before finally outputting the ID of your new image. The Docker daemon will automatically clean up the context you sent.</source>
          <target state="translated">Docker 데몬은 &lt;code&gt;Dockerfile&lt;/code&gt; 에서 명령을 하나씩 실행하여 필요한 경우 새 이미지의 ID를 출력하기 전에 각 명령의 결과를 새 이미지에 커밋합니다. Docker 데몬은 보낸 컨텍스트를 자동으로 정리합니다.</target>
        </trans-unit>
        <trans-unit id="b6e1be11d17f40601ae630a15a10dbd070a820fd" translate="yes" xml:space="preserve">
          <source>The Docker swarm mode scheduler may reschedule your running service containers at any time if they become unhealthy or unreachable.</source>
          <target state="translated">Docker swarm 모드 스케줄러는 실행중인 서비스 컨테이너가 건강하지 않거나 도달 할 수없는 경우 언제든지 일정을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72310a65dcf93f71664669032c86d03ef6046ea8" translate="yes" xml:space="preserve">
          <source>The Dockerfile defines an application&amp;rsquo;s image content via one or more build commands that configure that image. Once built, you can run the image in a container. For more information on &lt;code&gt;Dockerfile&lt;/code&gt;, see the &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker user guide&lt;/a&gt; and the &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile reference&lt;/a&gt;.</source>
          <target state="translated">Dockerfile은 해당 이미지를 구성하는 하나 이상의 빌드 명령을 통해 애플리케이션의 이미지 컨텐츠를 정의합니다. 일단 빌드되면 컨테이너에서 이미지를 실행할 수 있습니다. &lt;code&gt;Dockerfile&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker 사용 설명서&lt;/a&gt; 및 &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8db94bec7c2e718a34b45671510f274255de23e" translate="yes" xml:space="preserve">
          <source>The Engine mounts binds and volumes</source>
          <target state="translated">엔진 마운트 바인드 및 볼륨</target>
        </trans-unit>
        <trans-unit id="77a5c1284bd5d29f74b9038bb69295fca9657338" translate="yes" xml:space="preserve">
          <source>The Exoscale driver does an educated guess to pick the correct default SSH user. If left empty, it picks a suitable one following those rules:</source>
          <target state="translated">Exoscale 드라이버는 정확한 기본 SSH 사용자를 선택하기 위해 정확한 추측을합니다. 비워두면 해당 규칙에 따라 적합한 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e7776bb7b1feb0cdf6b9d378083948ecee5a364b" translate="yes" xml:space="preserve">
          <source>The GCE driver uses the &lt;code&gt;ubuntu-1604-xenial-v20161130&lt;/code&gt; instance image unless otherwise specified. To obtain a list of image URLs run:</source>
          <target state="translated">GCE 드라이버는 달리 지정하지 않는 한 &lt;code&gt;ubuntu-1604-xenial-v20161130&lt;/code&gt; 인스턴스 이미지를 사용합니다. 이미지 URL 목록을 얻으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3ed225f02abcd916a36da6d5362330e6ef486c76" translate="yes" xml:space="preserve">
          <source>The GRPC port of the remote trust service</source>
          <target state="translated">원격 트러스트 서비스의 GRPC 포트</target>
        </trans-unit>
        <trans-unit id="01efbfe017c227f04baa00c60ccb41e0ae379e7a" translate="yes" xml:space="preserve">
          <source>The Google driver uses &lt;a href=&quot;https://developers.google.com/identity/protocols/application-default-credentials&quot;&gt;Application Default Credentials&lt;/a&gt; to get authorization credentials for use in calling Google APIs.</source>
          <target state="translated">Google 드라이버는 &lt;a href=&quot;https://developers.google.com/identity/protocols/application-default-credentials&quot;&gt;애플리케이션 기본 자격&lt;/a&gt; 증명을 사용하여 Google API 호출에 사용할 인증 자격 증명 을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="f4f3efcfd0b9bf004bc8b95386891f6d660ca1c4" translate="yes" xml:space="preserve">
          <source>The HTML output is truncated:</source>
          <target state="translated">HTML 출력이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="28915ec304ba22579fc2a14faedd1ca73cf26b2f" translate="yes" xml:space="preserve">
          <source>The HTTP method (GET/DELETE/POST)</source>
          <target state="translated">HTTP 메소드 (GET / DELETE / POST)</target>
        </trans-unit>
        <trans-unit id="2631817e449cb6201d6128453c2b450e67c7f0c6" translate="yes" xml:space="preserve">
          <source>The HTTP request URI including API version (e.g., v.1.17/containers/json)</source>
          <target state="translated">API 버전을 포함한 HTTP 요청 URI (예 : v.1.17 / containers / json)</target>
        </trans-unit>
        <trans-unit id="f6b4e4056419626a88d045ad2a89f79c6a1828c1" translate="yes" xml:space="preserve">
          <source>The IP address must be assigned to a network interface available to the host operating system. All nodes in the swarm need to connect to the manager at the IP address.</source>
          <target state="translated">IP 주소는 호스트 운영 체제에서 사용 가능한 네트워크 인터페이스에 할당해야합니다. swarm의 모든 노드는 IP 주소에서 관리자에 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="b59ce3b3c22ba1282f1f27b4d7318e2a6aed4b0a" translate="yes" xml:space="preserve">
          <source>The IP address of the manager machine</source>
          <target state="translated">관리자 시스템의 IP 주소</target>
        </trans-unit>
        <trans-unit id="14e893cc4f0f163841ea538ac2b79f8d8a3b79da" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;image&lt;/code&gt; which provides the Linux distribution (see &lt;a href=&quot;https://api.linode.com/v4/images&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">Linux 배포판을 제공하는 Linode 인스턴스 &lt;code&gt;image&lt;/code&gt; ( &lt;a href=&quot;https://api.linode.com/v4/images&quot;&gt;여기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="83b7e9cefa7ff387cdd56e7ff68e1a677949aefe" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;label&lt;/code&gt;, unless overridden this will match the docker-machine name. This &lt;code&gt;label&lt;/code&gt; must be unique on the account.</source>
          <target state="translated">Linode Instance &lt;code&gt;label&lt;/code&gt; 은 재정의되지 않은 경우 docker-machine 이름과 일치합니다. 이 &lt;code&gt;label&lt;/code&gt; 은 계정에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="bcc9c3a146345291574afc8492f61ed2e65b48d2" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;region&lt;/code&gt; (see &lt;a href=&quot;https://api.linode.com/v4/regions&quot;&gt;here&lt;/a&gt;)</source>
          <target state="translated">Linode 인스턴스 &lt;code&gt;region&lt;/code&gt; ( &lt;a href=&quot;https://api.linode.com/v4/regions&quot;&gt;여기&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="6ae16b541187b536715d8341f613c9b770516823" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;root_pass&lt;/code&gt; (password assigned to the &lt;code&gt;root&lt;/code&gt; account)</source>
          <target state="translated">Linode 인스턴스 &lt;code&gt;root_pass&lt;/code&gt; ( &lt;code&gt;root&lt;/code&gt; 계정에 지정된 비밀번호 )</target>
        </trans-unit>
        <trans-unit id="5668a87d5f3cb3f0f372b8772fdf1ff3faa88431" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;type&lt;/code&gt; (see &lt;a href=&quot;https://api.linode.com/v4/linode/types&quot;&gt;here&lt;/a&gt;)</source>
          <target state="translated">Linode 인스턴스 &lt;code&gt;type&lt;/code&gt; ( &lt;a href=&quot;https://api.linode.com/v4/linode/types&quot;&gt;여기&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="ab313ad7fbd67b8ea1f71091c8c23d1efc05816d" translate="yes" xml:space="preserve">
          <source>The Linux kernel &lt;a href=&quot;http://man7.org/linux/man-pages/man7/user_namespaces.7.html&quot;&gt;user namespace support&lt;/a&gt; provides additional security by enabling a process, and therefore a container, to have a unique range of user and group IDs which are outside the traditional user and group range utilized by the host system. Potentially the most important security improvement is that, by default, container processes running as the &lt;code&gt;root&lt;/code&gt; user will have expected administrative privilege (with some restrictions) inside the container but will effectively be mapped to an unprivileged &lt;code&gt;uid&lt;/code&gt; on the host.</source>
          <target state="translated">Linux 커널 &lt;a href=&quot;http://man7.org/linux/man-pages/man7/user_namespaces.7.html&quot;&gt;사용자 네임 스페이스 지원&lt;/a&gt; 은 프로세스 및 컨테이너가 호스트 시스템에서 사용하는 기존 사용자 및 그룹 범위를 벗어나는 고유 한 범위의 사용자 및 그룹 ID를 가질 수 있도록하여 추가 보안을 제공합니다. 잠재적으로 가장 중요한 보안 개선 사항은 기본적으로 &lt;code&gt;root&lt;/code&gt; 사용자 로 실행되는 컨테이너 프로세스 는 컨테이너 내부에 관리자 권한 (일부 제한 사항)이 있지만 호스트 에서 권한이없는 &lt;code&gt;uid&lt;/code&gt; 에 효과적으로 매핑된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="000c040d8ab5e7c7ac50c8fdd132c54bd647e56f" translate="yes" xml:space="preserve">
          <source>The Machine provisioning process will:</source>
          <target state="translated">머신 프로비저닝 프로세스는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4cfd5fd9df9bb644721ce760e1a72a350c0aac10" translate="yes" xml:space="preserve">
          <source>The Machine repository supplies several &lt;code&gt;bash&lt;/code&gt; scripts that add features such as:</source>
          <target state="translated">Machine 리포지토리는 다음과 같은 기능을 추가하는 몇 가지 &lt;code&gt;bash&lt;/code&gt; 스크립트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a6915b8754b576be2fa1f8db4e62a17da6c7cb93" translate="yes" xml:space="preserve">
          <source>The Notary Service always holds the timestamp key. If the attacker has Notary Service write credentials, then they have effective access to the timestamp key because the server generates and signs the timestamp for them.</source>
          <target state="translated">공증인 서비스에는 항상 타임 스탬프 키가 있습니다. 공격자가 Notary Service에 자격 증명을 쓰면 서버가 타임 스탬프 키에 효과적으로 액세스하여 서버에서 타임 스탬프를 생성하고 서명합니다.</target>
        </trans-unit>
        <trans-unit id="f510469dc42e51346acf512073fd66bf115cb369" translate="yes" xml:space="preserve">
          <source>The Notary repository includes sample certificates in the fixtures directory. When you initialize a development service using the provided &lt;code&gt;docker-compose.yml&lt;/code&gt; file, these sample certificates are used to create a more production like environment.</source>
          <target state="translated">Notary 저장소는 조명기 디렉토리에 샘플 인증서를 포함합니다. 제공된 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 사용하여 개발 서비스를 초기화 할 때 이러한 샘플 인증서는보다 생산적인 환경을 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="50de710da14be82d6d655046022a33a82c1ccc49" translate="yes" xml:space="preserve">
          <source>The Notary signer is responsible for:</source>
          <target state="translated">공증인 서명자는 다음을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="c7afa7afbcd2ecc33c972605b1ce47bb9ca61017" translate="yes" xml:space="preserve">
          <source>The Plugin API is RPC-style JSON over HTTP, much like webhooks.</source>
          <target state="translated">플러그인 API는 웹 후크처럼 RPC over JSON over HTTP입니다.</target>
        </trans-unit>
        <trans-unit id="c227709ccd232d5e24a6d93f58178e25df562116" translate="yes" xml:space="preserve">
          <source>The Rackspace driver uses &lt;code&gt;821ba5f4-712d-4ec8-9c65-a3fa4bc500f9&lt;/code&gt; (Ubuntu 16.04 LTS) by default.</source>
          <target state="translated">Rackspace 드라이버는 &lt;code&gt;821ba5f4-712d-4ec8-9c65-a3fa4bc500f9&lt;/code&gt; (Ubuntu 16.04 LTS)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="82a21a7905a3cbb90eca7f4af732c295bd94e70a" translate="yes" xml:space="preserve">
          <source>The SoftLayer driver uses &lt;code&gt;UBUNTU_LATEST&lt;/code&gt; as the image type by default.</source>
          <target state="translated">SoftLayer 드라이버는 &lt;code&gt;UBUNTU_LATEST&lt;/code&gt; 으로 이미지 유형으로 UBUNTU_LATEST 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3bb056935b1763e55e51fba63a4a7934510e7050" translate="yes" xml:space="preserve">
          <source>The TCP address (IP and port) to listen for GRPC traffic. Examples:</source>
          <target state="translated">GRPC 트래픽을 수신하기위한 TCP 주소 (IP 및 포트). 예 :</target>
        </trans-unit>
        <trans-unit id="88b4794d69904fc8e3ffc932b8cfd22da1dd7afc" translate="yes" xml:space="preserve">
          <source>The TCP address (IP and port) to listen for HTTP traffic on. Examples:</source>
          <target state="translated">HTTP 트래픽을 청취 할 TCP 주소 (IP 및 포트)입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="58f9d4f77b99b0275d71525e448d6600d2ca8f64" translate="yes" xml:space="preserve">
          <source>The TCP address (IP and port) to listen on. Examples:</source>
          <target state="translated">수신 할 TCP 주소 (IP 및 포트)입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="7f378ce0f64115e9ae1db3da7716eb7c2cda8d30" translate="yes" xml:space="preserve">
          <source>The TCP port of the Linode that Docker will be listening on</source>
          <target state="translated">Docker가 수신 할 Linode의 TCP 포트</target>
        </trans-unit>
        <trans-unit id="4f34c1c251f453c03bae93c9980a57d4667489ef" translate="yes" xml:space="preserve">
          <source>The UTS namespace is for setting the hostname and the domain that is visible to running processes in that namespace. By default, all containers, including those with &lt;code&gt;--network=host&lt;/code&gt;, have their own UTS namespace. The &lt;code&gt;host&lt;/code&gt; setting will result in the container using the same UTS namespace as the host. Note that &lt;code&gt;--hostname&lt;/code&gt; and &lt;code&gt;--domainname&lt;/code&gt; are invalid in &lt;code&gt;host&lt;/code&gt; UTS mode.</source>
          <target state="translated">UTS 네임 스페이스는 해당 네임 스페이스에서 실행중인 프로세스에 표시되는 호스트 이름과 도메인을 설정하기위한 것입니다. 기본적으로 &lt;code&gt;--network=host&lt;/code&gt; 컨테이너를 포함한 모든 컨테이너 에는 고유 한 UTS 네임 스페이스가 있습니다. &lt;code&gt;host&lt;/code&gt; 설정은 호스트와 동일한 UTS 네임 스페이스를 사용하여 컨테이너 될 것이다. 하는 것으로 &lt;code&gt;--hostname&lt;/code&gt; 및 &lt;code&gt;--domainname&lt;/code&gt; 은 에서 유효하지 않은 &lt;code&gt;host&lt;/code&gt; UTS 모드.</target>
        </trans-unit>
        <trans-unit id="9570e3606e8e0207aa0ccc41a7f3d6bbb9a975b3" translate="yes" xml:space="preserve">
          <source>The UUID identifiers come from the Docker daemon. If you do not assign a container name with the &lt;code&gt;--name&lt;/code&gt; option, then the daemon generates a random string name for you. Defining a &lt;code&gt;name&lt;/code&gt; can be a handy way to add meaning to a container. If you specify a &lt;code&gt;name&lt;/code&gt;, you can use it when referencing the container within a Docker network. This works for both background and foreground Docker containers.</source>
          <target state="translated">UUID 식별자는 Docker 데몬에서 가져옵니다. &lt;code&gt;--name&lt;/code&gt; 옵션을 사용하여 컨테이너 이름을 지정하지 않으면 데몬은 임의의 문자열 이름을 생성합니다. &lt;code&gt;name&lt;/code&gt; 정의하면 컨테이너에 의미를 추가하는 편리한 방법이 될 수 있습니다. &lt;code&gt;name&lt;/code&gt; 을 지정 하면 Docker 네트워크 내에서 컨테이너를 참조 할 때 사용할 수 있습니다. 백그라운드 및 전경 Docker 컨테이너 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d79d287da69a4a3f2d788cfe61abfc21d2875db3" translate="yes" xml:space="preserve">
          <source>The VAR_NOT_INTERPOLATED_BY_COMPOSE is not set. Substituting an empty string.</source>
          <target state="translated">VAR_NOT_INTERPOLATED_BY_COMPOSE가 설정되지 않았습니다. 빈 문자열을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="fd2331cc37261fcbeb226c52aee1f2bad68a2512" translate="yes" xml:space="preserve">
          <source>The VMware Fusion driver uses the latest boot2docker image. See &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;frapposelli/boot2docker&lt;/a&gt;</source>
          <target state="translated">VMware Fusion 드라이버는 최신 boot2docker 이미지를 사용합니다. &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;frapposelli / boot2docker&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="b92c6a3df559cf9f9bf7e2a377d941da13c2302a" translate="yes" xml:space="preserve">
          <source>The VMware vCloud Air driver uses the &lt;code&gt;Ubuntu Server 12.04 LTS (amd64 20140927)&lt;/code&gt; image by default.</source>
          <target state="translated">VMware vCloud Air 드라이버는 기본적으로 &lt;code&gt;Ubuntu Server 12.04 LTS (amd64 20140927)&lt;/code&gt; 이미지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f1f49461b6458d5fa20b8e5eef851e3e1e7567b" translate="yes" xml:space="preserve">
          <source>The VMware vSphere driver uses the latest boot2docker image.</source>
          <target state="translated">VMware vSphere 드라이버는 최신 boot2docker 이미지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ac2fd9823008d438c71601d7a5b438706dd53245" translate="yes" xml:space="preserve">
          <source>The Version 1 Compose file is a &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; file that defines &lt;a href=&quot;#service-configuration-reference&quot;&gt;services&lt;/a&gt;.</source>
          <target state="translated">버전 1 작성 파일은 &lt;a href=&quot;#service-configuration-reference&quot;&gt;서비스&lt;/a&gt; 를 정의 하는 &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="053bbb5df4e49691e9c5c6aa76dfa2421d6004be" translate="yes" xml:space="preserve">
          <source>The above command sets the &lt;em&gt;desired&lt;/em&gt; number of tasks for the service. Even though the command returns immediately, actual scaling of the service may take some time. The &lt;code&gt;REPLICAS&lt;/code&gt; column shows both the &lt;em&gt;actual&lt;/em&gt; and &lt;em&gt;desired&lt;/em&gt; number of replica tasks for the service.</source>
          <target state="translated">위 명령은 &lt;em&gt;원하는&lt;/em&gt; 서비스 작업 수를 설정합니다 . 명령이 즉시 리턴 되더라도 서비스의 실제 스케일링에는 다소 시간이 걸릴 수 있습니다. &lt;code&gt;REPLICAS&lt;/code&gt; 열 방송은 모두 &lt;em&gt;실제&lt;/em&gt; 및 &lt;em&gt;원하는&lt;/em&gt; 서비스에 대한 복제 작업의 수.</target>
        </trans-unit>
        <trans-unit id="9d5d9e53c576fe5f14e8462005d5c33d1293b13b" translate="yes" xml:space="preserve">
          <source>The above command will use the current directory as the build context and read a Dockerfile from stdin.</source>
          <target state="translated">위의 명령은 현재 디렉토리를 빌드 컨텍스트로 사용하고 stdin에서 Dockerfile을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="34faf87ada6f2c49d8b93b6a04fcd4278bb71522" translate="yes" xml:space="preserve">
          <source>The above command works on Windows only if you use a terminal emulator such as &lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git BASH&lt;/a&gt;, which supports Linux commands like &lt;code&gt;chmod&lt;/code&gt;.</source>
          <target state="translated">위 명령은 &lt;code&gt;chmod&lt;/code&gt; 와 같은 Linux 명령을 지원하는 &lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git BASH&lt;/a&gt; 와 같은 터미널 에뮬레이터를 사용하는 경우에만 Windows에서 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="34ea0c251fca629c07e331bace6e9df9d3f364b9" translate="yes" xml:space="preserve">
          <source>The above commands will build the current build context (as specified by the &lt;code&gt;.&lt;/code&gt;) twice, once using a debug version of a &lt;code&gt;Dockerfile&lt;/code&gt; and once using a production version.</source>
          <target state="translated">위의 명령은 현재 빌드 환경 구축 할 것 (에 의해 지정된대로를 &lt;code&gt;.&lt;/code&gt; )를 두 번하는의 디버그 버전 사용하여 한 번 &lt;code&gt;Dockerfile&lt;/code&gt; 를 프로덕션 버전을 사용하여 한 번.</target>
        </trans-unit>
        <trans-unit id="5179bbf9a5fe4d0559c4202f0c4cdc5b926bb0bd" translate="yes" xml:space="preserve">
          <source>The above example for controlling log files and sizes uses options specific to the &lt;a href=&quot;https://docs.docker.com/config/containers/logging#json-file&quot;&gt;json-file driver&lt;/a&gt;. These particular options are not available on other logging drivers. For a full list of supported logging drivers and their options, see &lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;logging drivers&lt;/a&gt;.</source>
          <target state="translated">로그 파일 및 크기를 제어하기위한 위의 예제는 &lt;a href=&quot;https://docs.docker.com/config/containers/logging#json-file&quot;&gt;json-file 드라이버&lt;/a&gt; 고유의 옵션을 사용 합니다 . 다른 로깅 드라이버에서는 이러한 특정 옵션을 사용할 수 없습니다. 지원 로깅 드라이버와 그 옵션의 전체 목록을 보려면 &lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;로깅 드라이버를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f093a1321de60dc8c82ee545590e3b79fa5f264b" translate="yes" xml:space="preserve">
          <source>The above output shows that the &lt;code&gt;docker-default&lt;/code&gt; profile running on various container PIDs is in &lt;code&gt;enforce&lt;/code&gt; mode. This means AppArmor is actively blocking and auditing in &lt;code&gt;dmesg&lt;/code&gt; anything outside the bounds of the &lt;code&gt;docker-default&lt;/code&gt; profile.</source>
          <target state="translated">위의 출력은 다양한 컨테이너 PID에서 실행 되는 &lt;code&gt;docker-default&lt;/code&gt; 프로필이 &lt;code&gt;enforce&lt;/code&gt; 모드 임을 나타냅니다 . 이는 AppArmor가 &lt;code&gt;docker-default&lt;/code&gt; 프로필 의 경계를 벗어난 모든 것을 &lt;code&gt;dmesg&lt;/code&gt; 에서 적극적으로 차단 및 감사하고 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="d200c15742fb2300e685da66c69867efdfe210c9" translate="yes" xml:space="preserve">
          <source>The actual extent of integration depends on which version of the &lt;a href=&quot;../compose-file/index#versioning&quot;&gt;Compose file format&lt;/a&gt; you are using:</source>
          <target state="translated">실제 통합 범위 는 사용 중인 &lt;a href=&quot;../compose-file/index#versioning&quot;&gt;Compose 파일 형식의&lt;/a&gt; 버전에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="c53f12c881a1a893720f7f15ed293fb4da6174a6" translate="yes" xml:space="preserve">
          <source>The administrative keys listed specify the root key of trust, as well as the administrative repository key. These keys are responsible for modifying signers, and rotating keys for the signed repository.</source>
          <target state="translated">나열된 관리 키는 관리 저장소 키뿐만 아니라 루트 신뢰 키를 지정합니다. 이 키는 서명자를 수정하고 서명 된 저장소의 회전 키를 담당합니다.</target>
        </trans-unit>
        <trans-unit id="c79b727478823a0e43b0fc18d5e82dfe0f2c00b1" translate="yes" xml:space="preserve">
          <source>The amount of data the container has read to and written from block devices on the host</source>
          <target state="translated">컨테이너가 호스트의 블록 장치에서 읽고 쓴 데이터의 양</target>
        </trans-unit>
        <trans-unit id="2bf47d87fbe717e121dd86bd58bd038bd68358c7" translate="yes" xml:space="preserve">
          <source>The amount of data the container has sent and received over its network interface</source>
          <target state="translated">컨테이너가 네트워크 인터페이스를 통해 보내고받은 데이터의 양</target>
        </trans-unit>
        <trans-unit id="590f9091420642ff940715d49d155ce5d6434be6" translate="yes" xml:space="preserve">
          <source>The amount of swap space provisioned on the Linode Instance</source>
          <target state="translated">Linode 인스턴스에서 프로비저닝 된 스왑 공간의 양</target>
        </trans-unit>
        <trans-unit id="420b520b189370c5709e162d6da932a4837c8376" translate="yes" xml:space="preserve">
          <source>The app is now bootable, but you&amp;rsquo;re not quite there yet. By default, Rails expects a database to be running on &lt;code&gt;localhost&lt;/code&gt; - so you need to point it at the &lt;code&gt;db&lt;/code&gt; container instead. You also need to change the database and username to align with the defaults set by the &lt;code&gt;postgres&lt;/code&gt; image.</source>
          <target state="translated">이제 앱을 부팅 할 수 있지만 아직 업그레이드되지 않았습니다. 기본적으로 Rails는 데이터베이스가 &lt;code&gt;localhost&lt;/code&gt; 에서 실행될 것으로 예상 하므로 대신 &lt;code&gt;db&lt;/code&gt; 컨테이너로 지정해야합니다. 또한 &lt;code&gt;postgres&lt;/code&gt; 이미지에서 설정 한 기본값에 맞게 데이터베이스 및 사용자 이름을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7be6a30db5c572cf9181942bf629645491a22e50" translate="yes" xml:space="preserve">
          <source>The app itself</source>
          <target state="translated">앱 자체</target>
        </trans-unit>
        <trans-unit id="2d56df5fefd85739b353e0b719bdb02818f55645" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;alpine ping docker.com&lt;/code&gt; define the service as an Alpine Linux container that executes the command &lt;code&gt;ping docker.com&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alpine ping docker.com&lt;/code&gt; 인수 는 서비스를 &lt;code&gt;ping docker.com&lt;/code&gt; 명령을 실행하는 Alpine Linux 컨테이너로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="afa69edabec810d13a65a3dae4b99ff827c93ebf" translate="yes" xml:space="preserve">
          <source>The attacker does not have access to the timestamp key, which is always held by the Notary Service, and cannot set up a malicious mirror.</source>
          <target state="translated">공격자는 항상 공증인 서비스가 보유한 타임 스탬프 키에 액세스 할 수 없으며 악의적 인 미러를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92bc7e040b0ebdfa21b86e8239695e6807bea67a" translate="yes" xml:space="preserve">
          <source>The authentication method used</source>
          <target state="translated">사용 된 인증 방법</target>
        </trans-unit>
        <trans-unit id="ce7c51376025d7fd3f3793a740d0bdaad6f07e17" translate="yes" xml:space="preserve">
          <source>The base command for the Docker CLI.</source>
          <target state="translated">Docker CLI의 기본 명령입니다.</target>
        </trans-unit>
        <trans-unit id="12915a5aac3b55411ca3d3305b49845def9ac6b6" translate="yes" xml:space="preserve">
          <source>The base device size can be increased at daemon restart which will allow all future images and containers (based on those new images) to be of the new base device size.</source>
          <target state="translated">데몬을 다시 시작할 때 기본 장치 크기를 늘릴 수 있으므로 이후의 모든 이미지와 컨테이너 (새 이미지를 기반으로 함)는 새 기본 장치 크기가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0703b58e4bf73ac4c5d674ad3512db88784d9285" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;docker run&lt;/code&gt; command takes this form:</source>
          <target state="translated">기본 &lt;code&gt;docker run&lt;/code&gt; 명령은 다음과 같은 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="575b79f3ef4a8047ed7a1e057b92fbd05da4bf47" translate="yes" xml:space="preserve">
          <source>The best solution is to perform this check in your application code, both at startup and whenever a connection is lost for any reason. However, if you don&amp;rsquo;t need this level of resilience, you can work around the problem with a wrapper script:</source>
          <target state="translated">가장 좋은 해결책은 시작할 때와 어떤 이유로 든 연결이 끊길 때마다 응용 프로그램 코드에서이 확인을 수행하는 것입니다. 그러나이 수준의 복원력이 필요하지 않은 경우 래퍼 스크립트를 사용하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda46c8cf09024e246ff7c52fa8ece30868a6e32" translate="yes" xml:space="preserve">
          <source>The best way to prevent privilege-escalation attacks from within a container is to configure your container&amp;rsquo;s applications to run as unprivileged users. For containers whose processes must run as the &lt;code&gt;root&lt;/code&gt; user within the container, you can re-map this user to a less-privileged user on the Docker host. The mapped user is assigned a range of UIDs which function within the namespace as normal UIDs from 0 to 65536, but have no privileges on the host machine itself.</source>
          <target state="translated">컨테이너 내에서 권한 상승 공격을 방지하는 가장 좋은 방법은 컨테이너 응용 프로그램을 권한이없는 사용자로 실행하도록 구성하는 것입니다. 컨테이너 내에서 프로세스가 &lt;code&gt;root&lt;/code&gt; 사용자 로 실행되어야 하는 컨테이너의 경우이 사용자를 Docker 호스트의 권한이없는 사용자에게 다시 맵핑 할 수 있습니다. 매핑 된 사용자에게는 네임 스페이스 내에서 0-65536의 일반 UID로 작동하지만 호스트 시스템 자체에 대한 권한이없는 다양한 UID가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f1f474ffbfb080d2299496ab85e3b7e63f8b4aa0" translate="yes" xml:space="preserve">
          <source>The best way to recover from losing the quorum is to bring the failed nodes back online. If you can&amp;rsquo;t do that, the only way to recover from this state is to use the &lt;code&gt;--force-new-cluster&lt;/code&gt; action from a manager node. This removes all managers except the manager the command was run from. The quorum is achieved because there is now only one manager. Promote nodes to be managers until you have the desired number of managers.</source>
          <target state="translated">쿼럼 손실을 복구하는 가장 좋은 방법은 장애가 발생한 노드를 다시 온라인 상태로 만드는 것입니다. 이를 수행 할 수없는 경우이 상태에서 복구하는 유일한 방법 은 관리자 노드에서 &lt;code&gt;--force-new-cluster&lt;/code&gt; 작업을 사용하는 것입니다. 명령이 실행 된 관리자를 제외한 모든 관리자가 제거됩니다. 쿼럼은 이제 한 명의 관리자 만 있기 때문에 달성됩니다. 원하는 수의 관리자가있을 때까지 노드를 관리자로 승격하십시오.</target>
        </trans-unit>
        <trans-unit id="35282ae4886a7519b2b65816e9e41a8dc0bfb991" translate="yes" xml:space="preserve">
          <source>The build is run by the Docker daemon, not by the CLI. The first thing a build process does is send the entire context (recursively) to the daemon. In most cases, it&amp;rsquo;s best to start with an empty directory as context and keep your Dockerfile in that directory. Add only the files needed for building the Dockerfile.</source>
          <target state="translated">빌드는 CLI가 아닌 Docker 데몬에 의해 실행됩니다. 빌드 프로세스가 가장 먼저하는 일은 전체 컨텍스트를 재귀 적으로 데몬에 보내는 것입니다. 대부분의 경우 빈 디렉토리를 컨텍스트로 시작하고 Dockerfile을 해당 디렉토리에 유지하는 것이 가장 좋습니다. Dockerfile을 빌드하는 데 필요한 파일 만 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="bd548e026d0cb7646c6abcf18976b5314a6291ee" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;local&lt;/code&gt; driver on Linux accepts options similar to the linux &lt;code&gt;mount&lt;/code&gt; command. You can provide multiple options by passing the &lt;code&gt;--opt&lt;/code&gt; flag multiple times. Some &lt;code&gt;mount&lt;/code&gt; options (such as the &lt;code&gt;o&lt;/code&gt; option) can take a comma-separated list of options. Complete list of available mount options can be found &lt;a href=&quot;http://man7.org/linux/man-pages/man8/mount.8.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Linux 의 내장 &lt;code&gt;local&lt;/code&gt; 드라이버는 linux &lt;code&gt;mount&lt;/code&gt; 명령 과 유사한 옵션을 허용 합니다. &lt;code&gt;--opt&lt;/code&gt; 플래그를 여러 번 전달하여 여러 옵션을 제공 할 수 있습니다 . &lt;code&gt;o&lt;/code&gt; 옵션 과 같은 일부 &lt;code&gt;mount&lt;/code&gt; 옵션 은 쉼표로 구분 된 옵션 목록을 사용할 수 있습니다. 사용 가능한 마운트 옵션의 전체 목록은 &lt;a href=&quot;http://man7.org/linux/man-pages/man8/mount.8.html&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e589f84ba8092374a7adacbfb4c36a6c8dfce2ac" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;local&lt;/code&gt; driver on Windows does not support any options.</source>
          <target state="translated">Windows 의 내장 &lt;code&gt;local&lt;/code&gt; 드라이버는 옵션을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc6031f34bc45122b3da56b152c8aaed58988503" translate="yes" xml:space="preserve">
          <source>The built-in LXC execution driver, the lxc-conf flag, and API fields have been removed.</source>
          <target state="translated">내장 LXC 실행 드라이버, lxc-conf 플래그 및 API 필드가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="aaf21ffa56c46051a2828bb0284bd2fce1a4396e" translate="yes" xml:space="preserve">
          <source>The cache for &lt;code&gt;RUN&lt;/code&gt; instructions can be invalidated by &lt;code&gt;ADD&lt;/code&gt; instructions. See &lt;a href=&quot;#add&quot;&gt;below&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;RUN&lt;/code&gt; 명령어 캐시는 &lt;code&gt;ADD&lt;/code&gt; 명령어 로 무효화 될 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#add&quot;&gt;아래&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e21ac022d083f0dac5c9f4270fdf6df8f9b5274" translate="yes" xml:space="preserve">
          <source>The cache for &lt;code&gt;RUN&lt;/code&gt; instructions isn&amp;rsquo;t invalidated automatically during the next build. The cache for an instruction like &lt;code&gt;RUN apt-get dist-upgrade -y&lt;/code&gt; will be reused during the next build. The cache for &lt;code&gt;RUN&lt;/code&gt; instructions can be invalidated by using the &lt;code&gt;--no-cache&lt;/code&gt; flag, for example &lt;code&gt;docker build --no-cache&lt;/code&gt;.</source>
          <target state="translated">다음 빌드 중에는 &lt;code&gt;RUN&lt;/code&gt; 명령어 캐시 가 자동으로 무효화되지 않습니다. &lt;code&gt;RUN apt-get dist-upgrade -y&lt;/code&gt; 와 같은 명령의 캐시 는 다음 빌드 중에 재사용됩니다. &lt;code&gt;--no-cache&lt;/code&gt; 플래그 를 사용하여 &lt;code&gt;RUN&lt;/code&gt; 명령어 캐시를 무효화 할 수 있습니다 ( 예 : &lt;code&gt;docker build --no-cache&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="387890bfaa5ca05d821fa5a3b5d1ee0a6cfad608" translate="yes" xml:space="preserve">
          <source>The client can now immediately download the latest metadata from the server, using the still-valid bearer token to connect. Notary server only needs to obtain the metadata from the database, since none of the metadata has expired.</source>
          <target state="translated">클라이언트는 여전히 유효한 베어러 토큰을 사용하여 서버에서 최신 메타 데이터를 즉시 다운로드 할 수 있습니다. 공증 서버는 메타 데이터가 만료되지 않았기 때문에 데이터베이스에서 메타 데이터 만 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="18d5ec6bc9d750748f1efde7c61a2989b641b66e" translate="yes" xml:space="preserve">
          <source>The client logs in to the authorization server via basic auth over HTTPS, obtain a bearer token, and then present the token to Notary server on future requests.</source>
          <target state="translated">클라이언트는 HTTPS를 통한 기본 인증을 통해 권한 부여 서버에 로그인하고 베어러 토큰을 확보 한 후 향후 요청시 토큰을 공증인 서버에 제시합니다.</target>
        </trans-unit>
        <trans-unit id="008a74ce549151e51ed0e972fe5969ff680c6df9" translate="yes" xml:space="preserve">
          <source>The cluster management and orchestration features embedded in the Docker Engine are built using &lt;a href=&quot;https://github.com/docker/swarmkit/&quot;&gt;swarmkit&lt;/a&gt;. Swarmkit is a separate project which implements Docker&amp;rsquo;s orchestration layer and is used directly within Docker.</source>
          <target state="translated">Docker Engine에 내장 된 클러스터 관리 및 오케스트레이션 기능은 &lt;a href=&quot;https://github.com/docker/swarmkit/&quot;&gt;swarmkit을&lt;/a&gt; 사용하여 빌드 됩니다. Swarmkit은 Docker의 오케스트레이션 계층을 구현하는 별도의 프로젝트이며 Docker 내에서 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d803a4a4aa2732e3815dd3fec6ac2441d70eb5" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;../reference/down/index&quot;&gt;&lt;code&gt;docker-compose down&lt;/code&gt;&lt;/a&gt; removes the containers and default network, but preserves your WordPress database.</source>
          <target state="translated">&lt;a href=&quot;../reference/down/index&quot;&gt; &lt;code&gt;docker-compose down&lt;/code&gt; &lt;/a&gt; 명령 은 컨테이너와 기본 네트워크를 제거하지만 WordPress 데이터베이스는 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d103dac69f74e6da15998f384bbbf98c322bd326" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;docker-compose down --volumes&lt;/code&gt; removes the containers, default network, and the WordPress database.</source>
          <target state="translated">&lt;code&gt;docker-compose down --volumes&lt;/code&gt; 명령 은 컨테이너, 기본 네트워크 및 WordPress 데이터베이스를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a1ded79620e6d1ae5604250cb4f5ac48fde1be04" translate="yes" xml:space="preserve">
          <source>The command after the &lt;code&gt;CMD&lt;/code&gt; keyword can be either a shell command (e.g. &lt;code&gt;HEALTHCHECK CMD /bin/check-running&lt;/code&gt;) or an &lt;em&gt;exec&lt;/em&gt; array (as with other Dockerfile commands; see e.g. &lt;code&gt;ENTRYPOINT&lt;/code&gt; for details).</source>
          <target state="translated">&lt;code&gt;CMD&lt;/code&gt; 키워드 다음의 명령 은 쉘 명령 (예 : &lt;code&gt;HEALTHCHECK CMD /bin/check-running&lt;/code&gt; ) 또는 &lt;em&gt;exec&lt;/em&gt; 배열 일 수 있습니다 (다른 Dockerfile 명령과 동일 함; 자세한 내용은 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="a4ad35310c7aa7c67030bd46a3f2c137ecbcce0e" translate="yes" xml:space="preserve">
          <source>The command can also be a list, in a manner similar to &lt;a href=&quot;../../../engine/reference/builder/index#cmd&quot;&gt;dockerfile&lt;/a&gt;:</source>
          <target state="translated">이 명령은 &lt;a href=&quot;../../../engine/reference/builder/index#cmd&quot;&gt;dockerfile&lt;/a&gt; 과 비슷한 방식으로 목록이 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb23a07d84e630a5e8757111b76c8800f31539ec" translate="yes" xml:space="preserve">
          <source>The command can also be a list, in a manner similar to &lt;a href=&quot;../../engine/reference/builder/index#cmd&quot;&gt;dockerfile&lt;/a&gt;:</source>
          <target state="translated">이 명령은 &lt;a href=&quot;../../engine/reference/builder/index#cmd&quot;&gt;dockerfile&lt;/a&gt; 과 비슷한 방식으로 목록이 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0956efd491b81018147a694d5d0b1c6091fab3ac" translate="yes" xml:space="preserve">
          <source>The command invoked by docker will be:</source>
          <target state="translated">docker가 호출 한 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dae172cbb22e837995c3df1ccd985a845c6b4d13" translate="yes" xml:space="preserve">
          <source>The command requires &lt;code&gt;SRC_PATH&lt;/code&gt; and &lt;code&gt;DEST_PATH&lt;/code&gt; to exist according to the above rules. If &lt;code&gt;SRC_PATH&lt;/code&gt; is local and is a symbolic link, the symbolic link, not the target, is copied by default. To copy the link target and not the link, specify the &lt;code&gt;-L&lt;/code&gt; option.</source>
          <target state="translated">위의 규칙에 따라 명령에 &lt;code&gt;SRC_PATH&lt;/code&gt; 및 &lt;code&gt;DEST_PATH&lt;/code&gt; 가 있어야합니다 . 경우 &lt;code&gt;SRC_PATH&lt;/code&gt; 는 로컬과 심볼릭 링크, 심볼릭 링크가 아닌 대상, 기본적으로 복사됩니다. 링크가 아닌 링크 대상을 복사하려면 &lt;code&gt;-L&lt;/code&gt; 옵션을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d58d57885d29e1a2606150c96168372661b385e" translate="yes" xml:space="preserve">
          <source>The command started using &lt;code&gt;docker exec&lt;/code&gt; only runs while the container&amp;rsquo;s primary process (&lt;code&gt;PID 1&lt;/code&gt;) is running, and it is not restarted if the container is restarted.</source>
          <target state="translated">&lt;code&gt;docker exec&lt;/code&gt; 사용을 시작한 명령 은 컨테이너의 기본 프로세스 ( &lt;code&gt;PID 1&lt;/code&gt; )가 실행 되는 동안에 만 실행되며 컨테이너가 다시 시작되면 다시 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0a72ceb0f35e23bf2d1761717be1222bd1f2b70" translate="yes" xml:space="preserve">
          <source>The command&amp;rsquo;s exit status indicates the health status of the container. The possible values are:</source>
          <target state="translated">명령의 종료 상태는 컨테이너의 상태를 나타냅니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9a93e6beea86e2782016f21845beb9cd6afbccd" translate="yes" xml:space="preserve">
          <source>The commands to configure your shell differ depending on whether you are Mac, Linux, or Windows, so examples of each are shown on the tabs below.</source>
          <target state="translated">쉘을 구성하는 명령은 Mac, Linux 또는 Windows인지에 따라 다르므로 각각의 예가 아래 탭에 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fcf81cd2c19a4aa739ef6f89bede8ea8de9d5ea" translate="yes" xml:space="preserve">
          <source>The commit operation will not include any data contained in volumes mounted inside the container.</source>
          <target state="translated">커밋 작업에는 컨테이너 내부에 마운트 된 볼륨에 포함 된 데이터가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83a0a167e28d8f87b6757f8a0015a4c55e5a2769" translate="yes" xml:space="preserve">
          <source>The complete list of deprecated features can be found on the &lt;a href=&quot;deprecated/index&quot;&gt;Deprecated Features page&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않는 기능의 전체 목록은 더 이상 사용되지 &lt;a href=&quot;deprecated/index&quot;&gt;않는 기능 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="468d9a29501077e3aa8dde888309cbb4c0b42e6a" translate="yes" xml:space="preserve">
          <source>The config.json file</source>
          <target state="translated">config.json 파일</target>
        </trans-unit>
        <trans-unit id="63580fe0751f0a80b7f41e5612dc01cfec484ac4" translate="yes" xml:space="preserve">
          <source>The configuration file for Notary client normally resides at &lt;code&gt;~/.notary/config.json&lt;/code&gt;, but the path to a different configuration file can be specified using the &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--configFile&lt;/code&gt; command line flag.</source>
          <target state="translated">Notary 클라이언트의 구성 파일은 일반적으로 &lt;code&gt;~/.notary/config.json&lt;/code&gt; 에 있지만 다른 구성 파일의 경로는 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;--configFile&lt;/code&gt; 명령 행 플래그를 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42aecee7e3d42c214cbe47500065d6827ebee111" translate="yes" xml:space="preserve">
          <source>The configuration in the &lt;code&gt;docker-compose.override.yml&lt;/code&gt; file is applied over and in addition to the values in the &lt;code&gt;docker-compose.yml&lt;/code&gt; file.</source>
          <target state="translated">의 구성 &lt;code&gt;docker-compose.override.yml&lt;/code&gt; 파일에 도포하고있는 숫자에 부가되는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="06a3d484626f8819afe1dc776cba1d83d88a0606" translate="yes" xml:space="preserve">
          <source>The consistency requirements for the mount; one of</source>
          <target state="translated">마운트에 대한 일관성 요구 사항 중 하나</target>
        </trans-unit>
        <trans-unit id="4f609b0747ecf4db5b68bbca89691e8478935849" translate="yes" xml:space="preserve">
          <source>The container can have a different logging driver than the Docker daemon. Use the &lt;code&gt;--log-driver=VALUE&lt;/code&gt; with the &lt;code&gt;docker run&lt;/code&gt; command to configure the container&amp;rsquo;s logging driver. The following options are supported:</source>
          <target state="translated">컨테이너에는 Docker 데몬과 다른 로깅 드라이버가있을 수 있습니다. 사용 &lt;code&gt;--log-driver=VALUE&lt;/code&gt; 와 &lt;code&gt;docker run&lt;/code&gt; 컨테이너의 로깅 드라이버를 구성하는 명령을 사용합니다. 다음과 같은 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1e120a80067063699b6c9309ae85bbe648e64ec8" translate="yes" xml:space="preserve">
          <source>The container can use as much memory as it needs. The memory reservation setting ensures the container doesn&amp;rsquo;t consume too much memory for long time, because every memory reclaim shrinks the container&amp;rsquo;s consumption to the reservation.</source>
          <target state="translated">컨테이너는 필요한만큼의 메모리를 사용할 수 있습니다. 모든 메모리 재 확보는 컨테이너의 소비를 예약으로 줄이므로 메모리 예약 설정은 컨테이너가 오랫동안 너무 많은 메모리를 소비하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="6c41c4e059c0f6d5b08e701882d43028ba6a1c76" translate="yes" xml:space="preserve">
          <source>The container creation endpoint (&lt;code&gt;/containers/create&lt;/code&gt;) accepts a &lt;code&gt;VolumeDriver&lt;/code&gt; field of type &lt;code&gt;string&lt;/code&gt; allowing to specify the name of the driver. If not specified, it defaults to &lt;code&gt;&quot;local&quot;&lt;/code&gt; (the default driver for local volumes).</source>
          <target state="translated">컨테이너 작성 엔드 포인트 ( &lt;code&gt;/containers/create&lt;/code&gt; )는 &lt;code&gt;string&lt;/code&gt; 이름의 &lt;code&gt;VolumeDriver&lt;/code&gt; 필드를 허용하여 드라이버 이름을 지정할 수 있습니다. 지정하지 않으면 기본값은 &lt;code&gt;&quot;local&quot;&lt;/code&gt; (로컬 볼륨의 기본 드라이버)입니다.</target>
        </trans-unit>
        <trans-unit id="c5fc2a7434f444d2bf6be0610e195a7bb56b36c4" translate="yes" xml:space="preserve">
          <source>The container has unlimited memory which can cause the host to run out memory and require killing system processes to free memory. The &lt;code&gt;--oom-score-adj&lt;/code&gt; parameter can be changed to select the priority of which containers will be killed when the system is out of memory, with negative scores making them less likely to be killed, and positive scores more likely.</source>
          <target state="translated">컨테이너에는 무제한 메모리가있어 호스트에 메모리가 부족하여 시스템 프로세스를 강제 종료하여 메모리를 확보해야합니다. &lt;code&gt;--oom-score-adj&lt;/code&gt; 매개 변수는 부정적인 점수가 그들을 덜 살해 할 수있게하고, 가능성이 긍정적 인 점수로, 시스템의 메모리가 부족하면 용기가 살해 될의 우선 순위를 선택하기 위해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333084b3793f80a3fdbaa6d2ac4ef96b2a7ad2c4" translate="yes" xml:space="preserve">
          <source>The contents of the source tree, with conflicts resolved in favor of &amp;ldquo;2.&amp;rdquo; on a file-by-file basis.</source>
          <target state="translated">&quot;2&quot;에 찬성하여 갈등이 해결 된 소스 트리의 내용. 파일 단위로.</target>
        </trans-unit>
        <trans-unit id="cbe1954333dba969dd75128ef1a9d14d906afd02" translate="yes" xml:space="preserve">
          <source>The contents of those fields are ignored by Compose, but they can be inserted in your resource definitions using &lt;a href=&quot;http://www.yaml.org/spec/1.2/spec.html#id2765878&quot;&gt;YAML anchors&lt;/a&gt;. For example, if you want several of your services to use the same logging configuration:</source>
          <target state="translated">해당 필드의 내용은 Compose에서 무시되지만 &lt;a href=&quot;http://www.yaml.org/spec/1.2/spec.html#id2765878&quot;&gt;YAML 앵커를&lt;/a&gt; 사용하여 자원 정의에 삽입 할 수 있습니다 . 예를 들어, 여러 서비스에서 동일한 로깅 구성을 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="55bb6aa9bd31acce0a500a34fa7ad10a92eb38dc" translate="yes" xml:space="preserve">
          <source>The corresponding network configuration in the &lt;a href=&quot;#network-configuration-reference&quot;&gt;top-level networks section&lt;/a&gt; must have an &lt;code&gt;ipam&lt;/code&gt; block with subnet and gateway configurations covering each static address. If IPv6 addressing is desired, the &lt;a href=&quot;#enableipv6&quot;&gt;&lt;code&gt;enable_ipv6&lt;/code&gt;&lt;/a&gt; option must be set.</source>
          <target state="translated">&lt;a href=&quot;#network-configuration-reference&quot;&gt;최상위 네트워크 섹션&lt;/a&gt; 의 해당 네트워크 구성에는 각 고정 주소를 포함하는 서브넷 및 게이트웨이 구성이 포함 된 &lt;code&gt;ipam&lt;/code&gt; 블록이 있어야합니다 . IPv6 주소 지정이 필요한 경우 &lt;a href=&quot;#enableipv6&quot;&gt; &lt;code&gt;enable_ipv6&lt;/code&gt; &lt;/a&gt; 옵션을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="586d71b6ade2d35dd85189494da13a3579476751" translate="yes" xml:space="preserve">
          <source>The corresponding network configuration in the &lt;a href=&quot;#network-configuration-reference&quot;&gt;top-level networks section&lt;/a&gt; must have an &lt;code&gt;ipam&lt;/code&gt; block with subnet configurations covering each static address.</source>
          <target state="translated">&lt;a href=&quot;#network-configuration-reference&quot;&gt;최상위 네트워크 섹션&lt;/a&gt; 의 해당 네트워크 구성에는 각 고정 주소를 포함하는 서브넷 구성 이있는 &lt;code&gt;ipam&lt;/code&gt; 블록이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fad571b286cbf1b134860d78c384eaf61397a5ea" translate="yes" xml:space="preserve">
          <source>The current expected use case is to advertise NVIDIA GPUs so that services requesting &lt;code&gt;NVIDIA-GPU=[0-16]&lt;/code&gt; can land on a node that has enough GPUs for the task to run.</source>
          <target state="translated">현재 예상되는 사용 사례는 &lt;code&gt;NVIDIA-GPU=[0-16]&lt;/code&gt; 을 요청하는 서비스 가 작업을 실행하기에 충분한 GPU가있는 노드에 도달 할 수 있도록 NVIDIA GPU를 보급 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bcb1c15d1b89c3f94e8dabe5ed1066e78563ff31" translate="yes" xml:space="preserve">
          <source>The current release stage, such as &lt;code&gt;&quot;production&quot;&lt;/code&gt;. You can use this value to filter errors in the Bugsnag dashboard.</source>
          <target state="translated">같은 현재 릴리스 단계, &lt;code&gt;&quot;production&quot;&lt;/code&gt; . 이 값을 사용하여 Bugsnag 대시 보드에서 오류를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c1993b21d61bb6110c17c440c31c9f2b3c920bb" translate="yes" xml:space="preserve">
          <source>The currently supported cluster store options are:</source>
          <target state="translated">현재 지원되는 클러스터 저장소 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bc214496669aa244b1cc5d85b13d7d6cb05c343" translate="yes" xml:space="preserve">
          <source>The currently supported filters are:</source>
          <target state="translated">현재 지원되는 필터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4b2d4d7c5b15f6ba647817c9d9d938449c46c97" translate="yes" xml:space="preserve">
          <source>The daemon is also potentially vulnerable to other inputs, such as image loading from either disk with &lt;code&gt;docker load&lt;/code&gt;, or from the network with &lt;code&gt;docker pull&lt;/code&gt;. As of Docker 1.3.2, images are now extracted in a chrooted subprocess on Linux/Unix platforms, being the first-step in a wider effort toward privilege separation. As of Docker 1.10.0, all images are stored and accessed by the cryptographic checksums of their contents, limiting the possibility of an attacker causing a collision with an existing image.</source>
          <target state="translated">데몬은 &lt;code&gt;docker load&lt;/code&gt; 디스크 또는 &lt;code&gt;docker pull&lt;/code&gt; 있는 네트워크의 이미지로드와 같은 다른 입력에 잠재적으로 취약합니다 . Docker 1.3.2부터 이미지는 Linux / Unix 플랫폼의 루트 하위 프로세스에서 추출되며 권한 분리를위한보다 광범위한 노력의 첫 단계입니다. Docker 1.10.0부터 모든 이미지는 내용의 암호화 체크섬에 의해 저장되고 액세스되므로 공격자가 기존 이미지와 충돌 할 가능성을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="1b40a58c33ae6973207a461d4362662281b137fb" translate="yes" xml:space="preserve">
          <source>The daemon is moved to a separate binary (&lt;code&gt;dockerd&lt;/code&gt;), and should be used instead.</source>
          <target state="translated">데몬은 별도의 바이너리 ( &lt;code&gt;dockerd&lt;/code&gt; ) 로 이동되어 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b7c8c7558a775a2edcd115a970ad32948322ddb" translate="yes" xml:space="preserve">
          <source>The daemon uses &lt;a href=&quot;https://github.com/docker/libkv/&quot;&gt;libkv&lt;/a&gt; to advertise the node within the cluster. Some key-value backends support mutual TLS. To configure the client TLS settings used by the daemon can be configured using the &lt;code&gt;--cluster-store-opt&lt;/code&gt; flag, specifying the paths to PEM encoded files. For example:</source>
          <target state="translated">데몬은 &lt;a href=&quot;https://github.com/docker/libkv/&quot;&gt;libkv&lt;/a&gt; 를 사용 하여 클러스터 내의 노드를 알립니다. 일부 키-값 백엔드는 상호 TLS를 지원합니다. 데몬이 사용하는 클라이언트 TLS 설정을 구성하려면 &lt;code&gt;--cluster-store-opt&lt;/code&gt; 플래그를 사용하여 PEM 인코딩 파일의 경로를 지정하여 구성 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10c61591c638186cd78e6bcb2f76d135a645641c" translate="yes" xml:space="preserve">
          <source>The data file is where the images are stored and the metadata file is where the meta data regarding those images are stored. When run for the first time Docker allocates a certain amount of data space and meta data space from the space available on the volume where &lt;code&gt;/var/lib/docker&lt;/code&gt; is mounted.</source>
          <target state="translated">데이터 파일은 이미지가 저장되는 위치이고 메타 데이터 파일은 해당 이미지와 관련된 메타 데이터가 저장되는 위치입니다. Docker는 처음 실행될 때 &lt;code&gt;/var/lib/docker&lt;/code&gt; 가 마운트 된 볼륨에서 사용 가능한 공간에서 일정량의 데이터 공간과 메타 데이터 공간을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="6e1b782dc4239cc2ee12f8ada2116b7cec6452c5" translate="yes" xml:space="preserve">
          <source>The db service uses both secrets, and the wordpress is using one.</source>
          <target state="translated">db 서비스는 두 가지 비밀을 모두 사용하며 wordpress는 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="88b708d10b5bb132b812231de52a9a57fd050d57" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;docker images&lt;/code&gt; will show all top level images, their repository and tags, and their size.</source>
          <target state="translated">기본 &lt;code&gt;docker images&lt;/code&gt; 에는 모든 최상위 이미지, 저장소 및 태그 및 크기가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e751a256a79a508fc6a8dac6bc7ba71dd7cb189a" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;seccomp&lt;/code&gt; profile provides a sane default for running containers with seccomp and disables around 44 system calls out of 300+. It is moderately protective while providing wide application compatibility. The default Docker profile can be found &lt;a href=&quot;https://github.com/moby/moby/blob/master/profiles/seccomp/default.json&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;code&gt;seccomp&lt;/code&gt; 프로파일은 seccomp를 사용하여 컨테이너를 실행하기위한 정상 기본값을 제공하고 300+에서 약 44 개의 시스템 호출을 비활성화합니다. 광범위한 응용 프로그램 호환성을 제공하면서 적당히 보호됩니다. 기본 Docker 프로파일은 &lt;a href=&quot;https://github.com/moby/moby/blob/master/profiles/seccomp/default.json&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02e46ce6640ecc061d7753130fd0e3ce54b962ca" translate="yes" xml:space="preserve">
          <source>The default CPU CFS (Completely Fair Scheduler) period is 100ms. We can use &lt;code&gt;--cpu-period&lt;/code&gt; to set the period of CPUs to limit the container&amp;rsquo;s CPU usage. And usually &lt;code&gt;--cpu-period&lt;/code&gt; should work with &lt;code&gt;--cpu-quota&lt;/code&gt;.</source>
          <target state="translated">기본 CPU CFS (Completely Fair Scheduler) 기간은 100ms입니다. 컨테이너의 CPU 사용량을 제한하기 위해 &lt;code&gt;--cpu-period&lt;/code&gt; 를 사용하여 CPU 주기 를 설정할 수 있습니다 . 일반적으로 &lt;code&gt;--cpu-period&lt;/code&gt; 는 &lt;code&gt;--cpu-quota&lt;/code&gt; 와 함께 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="835a0981f4ea865680edc5b2da7de4c21a68744c" translate="yes" xml:space="preserve">
          <source>The default SSH username for the default AMIs is &lt;code&gt;ubuntu&lt;/code&gt;.</source>
          <target state="translated">기본 AMI의 기본 SSH 사용자 이름은 &lt;code&gt;ubuntu&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59cdf16cd5e29f0ac54596e99e587be9a13ea86c" translate="yes" xml:space="preserve">
          <source>The default driver &lt;a href=&quot;https://docs.docker.com/config/containers/logging#json-file&quot;&gt;json-file&lt;/a&gt;, has options to limit the amount of logs stored. To do this, use a key-value pair for maximum storage size and maximum number of files:</source>
          <target state="translated">기본 드라이버 &lt;a href=&quot;https://docs.docker.com/config/containers/logging#json-file&quot;&gt;json-file&lt;/a&gt; 에는 저장되는 로그의 양을 제한하는 옵션이 있습니다. 이렇게하려면 최대 저장소 크기와 최대 파일 수에 키-값 쌍을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ce72086dcefd05b0b3815fadb5d6794a3874059b" translate="yes" xml:space="preserve">
          <source>The default driver depends on how the Docker Engine you&amp;rsquo;re using is configured, but in most instances it is &lt;code&gt;bridge&lt;/code&gt; on a single host and &lt;code&gt;overlay&lt;/code&gt; on a Swarm.</source>
          <target state="translated">기본 드라이버는 사용중인 Docker Engine의 구성 방법에 따라 다르지만 대부분의 경우 단일 호스트에서 &lt;code&gt;bridge&lt;/code&gt; 되고 Swarm에서 &lt;code&gt;overlay&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="c7f4b3f884940abe279914db7dec9662f4803c53" translate="yes" xml:space="preserve">
          <source>The default for this option will also be changed accordingly for &lt;code&gt;docker service rollback&lt;/code&gt; and &lt;code&gt;docker service scale&lt;/code&gt; in Docker 17.10.</source>
          <target state="translated">이 옵션의 기본값 은 Docker 17.10의 &lt;code&gt;docker service rollback&lt;/code&gt; 및 &lt;code&gt;docker service scale&lt;/code&gt; 에 따라 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a6dfa1d042a5a81b6bf6160ce5c49ad7812c75e" translate="yes" xml:space="preserve">
          <source>The default format is as follows:</source>
          <target state="translated">기본 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c1cb315610bf195b7d26211262a21ff2fe2bdfe" translate="yes" xml:space="preserve">
          <source>The default init binary that is used is &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;Tini&lt;/a&gt;, and is installed in &lt;code&gt;/usr/libexec/docker-init&lt;/code&gt; on the daemon host. You can configure the daemon to use a custom init binary through the &lt;a href=&quot;../../../engine/reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt;&lt;code&gt;init-path&lt;/code&gt; configuration option&lt;/a&gt;.</source>
          <target state="translated">사용되는 기본 초기화 바이너리는 &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;Tini&lt;/a&gt; 이며 데몬 호스트의 &lt;code&gt;/usr/libexec/docker-init&lt;/code&gt; 에 설치됩니다 . &lt;a href=&quot;../../../engine/reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt; &lt;code&gt;init-path&lt;/code&gt; 구성 옵션을&lt;/a&gt; 통해 사용자 정의 초기화 바이너리를 사용하도록 데몬을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3a2403daddc36ae40af72ba1509df0c525c4f7a" translate="yes" xml:space="preserve">
          <source>The default init binary that is used is &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;Tini&lt;/a&gt;, and is installed in &lt;code&gt;/usr/libexec/docker-init&lt;/code&gt; on the daemon host. You can configure the daemon to use a custom init binary through the &lt;a href=&quot;../../engine/reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt;&lt;code&gt;init-path&lt;/code&gt; configuration option&lt;/a&gt;.</source>
          <target state="translated">사용되는 기본 초기화 바이너리는 &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;Tini&lt;/a&gt; 이며 데몬 호스트의 &lt;code&gt;/usr/libexec/docker-init&lt;/code&gt; 에 설치됩니다 . &lt;a href=&quot;../../engine/reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt; &lt;code&gt;init-path&lt;/code&gt; 구성 옵션을&lt;/a&gt; 통해 사용자 정의 초기화 바이너리를 사용하도록 데몬을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b46500a2cf3200d1811ab7e8c81dc7096ac8b4f" translate="yes" xml:space="preserve">
          <source>The default init process used is the first &lt;code&gt;docker-init&lt;/code&gt; executable found in the system path of the Docker daemon process. This &lt;code&gt;docker-init&lt;/code&gt; binary, included in the default installation, is backed by &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;tini&lt;/a&gt;.</source>
          <target state="translated">사용되는 기본 초기화 프로세스 는 Docker 데몬 프로세스의 시스템 경로에있는 첫 번째 &lt;code&gt;docker-init&lt;/code&gt; 실행 파일입니다. 기본 설치에 포함 된 이 &lt;code&gt;docker-init&lt;/code&gt; 바이너리는 &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;tini에&lt;/a&gt; 의해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d29444d706667623d7f48549919ccd31c44e5c9" translate="yes" xml:space="preserve">
          <source>The default isolation on Windows server operating systems is &lt;code&gt;process&lt;/code&gt;. The default isolation on Windows client operating systems is &lt;code&gt;hyperv&lt;/code&gt;. An attempt to start a container on a client operating system older than Windows 10 1809 with &lt;code&gt;--isolation process&lt;/code&gt; will fail.</source>
          <target state="translated">Windows 서버 운영 체제의 기본 격리는 &lt;code&gt;process&lt;/code&gt; 입니다. Windows 클라이언트 운영 체제의 기본 격리는 &lt;code&gt;hyperv&lt;/code&gt; 입니다. &lt;code&gt;--isolation process&lt;/code&gt; Windows 10 1809 이전의 클라이언트 운영 체제에서 컨테이너를 시작하려는 시도 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1003ad4f0dfb7841d434646ca9e28a70873641dc" translate="yes" xml:space="preserve">
          <source>The default location of the configuration file on Linux is &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;. The &lt;code&gt;--config-file&lt;/code&gt; flag can be used to specify a non-default location.</source>
          <target state="translated">Linux에서 구성 파일의 기본 위치는 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 입니다. &lt;code&gt;--config-file&lt;/code&gt; 플래그는 기본이 아닌 위치를 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="946fe86eb52848a137c16603863073ed3192847f" translate="yes" xml:space="preserve">
          <source>The default location of the configuration file on Windows is &lt;code&gt;%programdata%\docker\config\daemon.json&lt;/code&gt;. The &lt;code&gt;--config-file&lt;/code&gt; flag can be used to specify a non-default location.</source>
          <target state="translated">Windows에서 구성 파일의 기본 위치는 &lt;code&gt;%programdata%\docker\config\daemon.json&lt;/code&gt; 입니다. &lt;code&gt;--config-file&lt;/code&gt; 플래그는 기본이 아닌 위치를 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d77799e03e62749f4abf25bccc750b066c07d78" translate="yes" xml:space="preserve">
          <source>The default network, if one is used</source>
          <target state="translated">기본 네트워크 (사용 된 경우)</target>
        </trans-unit>
        <trans-unit id="098406d500f9e645da44a793a6233d0cd7c06c69" translate="yes" xml:space="preserve">
          <source>The default path for a Compose file is &lt;code&gt;./docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">작성 파일의 기본 경로는 &lt;code&gt;./docker-compose.yml&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb8857f4a0cda00b382ca084d9bef1fbf8561297" translate="yes" xml:space="preserve">
          <source>The default project name is the basename of the project directory. You can set a custom project name by using the &lt;a href=&quot;reference/overview/index&quot;&gt;&lt;code&gt;-p&lt;/code&gt; command line option&lt;/a&gt; or the &lt;a href=&quot;reference/envvars/index#compose-project-name&quot;&gt;&lt;code&gt;COMPOSE_PROJECT_NAME&lt;/code&gt; environment variable&lt;/a&gt;.</source>
          <target state="translated">기본 프로젝트 이름은 프로젝트 디렉토리의 기본 이름입니다. &lt;a href=&quot;reference/overview/index&quot;&gt; &lt;code&gt;-p&lt;/code&gt; 명령 행 옵션&lt;/a&gt; 또는 &lt;a href=&quot;reference/envvars/index#compose-project-name&quot;&gt; &lt;code&gt;COMPOSE_PROJECT_NAME&lt;/code&gt; 환경 변수&lt;/a&gt; 를 사용하여 사용자 정의 프로젝트 이름을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e933c3002f8889546c0ab43e358c6c7eb91f636a" translate="yes" xml:space="preserve">
          <source>The default seccomp profile will adjust to the selected capabilities, in order to allow use of facilities allowed by the capabilities, so you should not have to adjust this, since Docker 1.12. In Docker 1.10 and 1.11 this did not happen and it may be necessary to use a custom seccomp profile or use &lt;code&gt;--security-opt seccomp=unconfined&lt;/code&gt; when adding capabilities.</source>
          <target state="translated">기본 seccomp 프로파일은 기능이 허용하는 기능을 사용할 수 있도록 선택된 기능에 맞게 조정되므로 Docker 1.12부터이를 조정할 필요가 없습니다. Docker 1.10 및 1.11에서는 이러한 상황이 발생하지 않았으므로 사용자 정의 seccomp 프로파일을 사용하거나 기능을 추가 할 때 &lt;code&gt;--security-opt seccomp=unconfined&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1c1e388da7ec0a0a04b987272aedc0229521e525" translate="yes" xml:space="preserve">
          <source>The default shell for the &lt;em&gt;shell&lt;/em&gt; form can be changed using the &lt;code&gt;SHELL&lt;/code&gt; command.</source>
          <target state="translated">&lt;em&gt;쉘&lt;/em&gt; 양식 의 기본 쉘 은 &lt;code&gt;SHELL&lt;/code&gt; 명령을 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79f1b805588ca93f12c5151f467a7d3172574cbb" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;--cpus&lt;/code&gt; is &lt;code&gt;0.000&lt;/code&gt;, which means there is no limit.</source>
          <target state="translated">&lt;code&gt;--cpus&lt;/code&gt; 의 기본값 은 &lt;code&gt;0.000&lt;/code&gt; 이며 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4a3f2aa0f06fe9f002e0533949e71bd65c91612" translate="yes" xml:space="preserve">
          <source>The default value is json-file.</source>
          <target state="translated">기본값은 json-file입니다.</target>
        </trans-unit>
        <trans-unit id="43c639c5f9940e65b93aed2edfa229895d878456" translate="yes" xml:space="preserve">
          <source>The default working directory for running binaries within a container is the root directory (&lt;code&gt;/&lt;/code&gt;), but the developer can set a different default with the Dockerfile &lt;code&gt;WORKDIR&lt;/code&gt; command. The operator can override this with:</source>
          <target state="translated">컨테이너 내에서 바이너리를 실행하기위한 기본 작업 디렉토리는 루트 디렉토리 ( &lt;code&gt;/&lt;/code&gt; )이지만 개발자는 Dockerfile &lt;code&gt;WORKDIR&lt;/code&gt; 명령 으로 다른 기본값을 설정할 수 있습니다 . 운영자는 다음을 사용하여이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f08a74fcb0c137793370ee0cf17b818a97b0e38" translate="yes" xml:space="preserve">
          <source>The delegation (an online) key passphrase</source>
          <target state="translated">위임 (온라인) 키 암호</target>
        </trans-unit>
        <trans-unit id="4b17714a5567df9952e53a2f8facd472db67ca19" translate="yes" xml:space="preserve">
          <source>The developer can set a default user to run the first process with the Dockerfile &lt;code&gt;USER&lt;/code&gt; instruction. When starting a container, the operator can override the &lt;code&gt;USER&lt;/code&gt; instruction by passing the &lt;code&gt;-u&lt;/code&gt; option.</source>
          <target state="translated">개발자는 Dockerfile &lt;code&gt;USER&lt;/code&gt; 명령으로 첫 번째 프로세스를 실행하도록 기본 사용자를 설정할 수 있습니다 . 컨테이너를 시작할 때 운영자는 &lt;code&gt;-u&lt;/code&gt; 옵션 을 전달하여 &lt;code&gt;USER&lt;/code&gt; 명령을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05147ac693f70511d9e9341898fa849f2c06b771" translate="yes" xml:space="preserve">
          <source>The diagram below illustrates how manager nodes and worker nodes encrypt communications using a minimum of TLS 1.2.</source>
          <target state="translated">아래 다이어그램은 관리자 노드와 작업자 노드가 최소 TLS 1.2를 사용하여 통신을 암호화하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cb288d1103743acfb8d43d7f42964ab0c718c9e1" translate="yes" xml:space="preserve">
          <source>The diagram below shows a three-service replica in yellow and a global service in gray.</source>
          <target state="translated">아래 다이어그램은 3 개의 서비스 복제본을 노란색으로, 글로벌 서비스를 회색으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d322b7f5d4fe953d4548dff5c94e40c25755e35d" translate="yes" xml:space="preserve">
          <source>The diagram below shows how swarm mode accepts service create requests and schedules tasks to worker nodes.</source>
          <target state="translated">아래 다이어그램은 swarm 모드가 서비스 작성 요청을 승인하고 작업을 작업자 노드에 예약하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a542ef3183b38578e602775ecc5d8ac346cdbbc6" translate="yes" xml:space="preserve">
          <source>The directories which are owned by the remapped user are used instead of the same directories directly beneath &lt;code&gt;/var/lib/docker/&lt;/code&gt; and the unused versions (such as &lt;code&gt;/var/lib/docker/tmp/&lt;/code&gt; in the example here) can be removed. Docker does not use them while &lt;code&gt;userns-remap&lt;/code&gt; is enabled.</source>
          <target state="translated">재 맵핑 된 사용자가 소유 한 디렉토리는 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 바로 아래의 동일한 디렉토리 대신 사용되며 사용 되지 않는 버전 (예 : &lt;code&gt;/var/lib/docker/tmp/&lt;/code&gt; 와 같은)은 제거 할 수 있습니다. 사용자 &lt;code&gt;userns-remap&lt;/code&gt; 이 활성화 된 동안 Docker는이를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ced9b493d368f4aa1a0fe354475a92f041e9fd7a" translate="yes" xml:space="preserve">
          <source>The docker login command is removing the ability to automatically register for an account with the target registry if the given username doesn&amp;rsquo;t exist. Due to this change, the email flag is no longer required, and will be deprecated.</source>
          <target state="translated">docker login 명령은 주어진 사용자 이름이 존재하지 않으면 대상 레지스트리에 계정을 자동으로 등록하는 기능을 제거합니다. 이 변경으로 인해 전자 메일 플래그는 더 이상 필요하지 않으며 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3f61e1a16f6c08b9e1d558d719854f08c48dd22" translate="yes" xml:space="preserve">
          <source>The docker volume &lt;code&gt;db_data&lt;/code&gt; persists any updates made by WordPress to the database. &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;Learn more about docker volumes&lt;/a&gt;</source>
          <target state="translated">도커 볼륨 &lt;code&gt;db_data&lt;/code&gt; 는 WordPress에서 데이터베이스에 대한 모든 업데이트를 유지합니다. &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;도커 볼륨에 대해 더 알아보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1416be20c4d01103caaee715619ae02361dcc4e5" translate="yes" xml:space="preserve">
          <source>The docker-machine create command</source>
          <target state="translated">docker-machine create 명령</target>
        </trans-unit>
        <trans-unit id="2c33c4de05fef67739d59f64c71b01bf34737dbd" translate="yes" xml:space="preserve">
          <source>The download operation will be performed on the host the Docker daemon is running on, which is not necessarily the same host from which the build command is being issued. The Docker daemon will fetch &lt;code&gt;context.tar.gz&lt;/code&gt; and use it as the build context. Tarball contexts must be tar archives conforming to the standard &lt;code&gt;tar&lt;/code&gt; UNIX format and can be compressed with any one of the &amp;lsquo;xz&amp;rsquo;, &amp;lsquo;bzip2&amp;rsquo;, &amp;lsquo;gzip&amp;rsquo; or &amp;lsquo;identity&amp;rsquo; (no compression) formats.</source>
          <target state="translated">다운로드 작업은 Docker 데몬이 실행되는 호스트에서 수행되며, 빌드 명령이 실행되는 호스트와 반드시 같은 호스트는 아닙니다. Docker 데몬은 &lt;code&gt;context.tar.gz&lt;/code&gt; 를 가져 와서 빌드 컨텍스트로 사용합니다. Tarball 컨텍스트는 표준 &lt;code&gt;tar&lt;/code&gt; UNIX 형식을 따르는 tar 아카이브 여야하며 'xz', 'bzip2', 'gzip'또는 'identity'(압축 없음) 형식 중 하나로 압축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7edb9183a839b9915a5a25418cfe38fbb6391bb2" translate="yes" xml:space="preserve">
          <source>The drained node shows &lt;code&gt;Drain&lt;/code&gt; for &lt;code&gt;AVAILABILITY&lt;/code&gt;.</source>
          <target state="translated">배수 된 노드는 &lt;code&gt;Drain&lt;/code&gt; for &lt;code&gt;AVAILABILITY&lt;/code&gt; 를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="008ecc6d5a62a3ca5a113cadbf298669fecf4eaf" translate="yes" xml:space="preserve">
          <source>The driver is not required to implement &lt;code&gt;Capabilities&lt;/code&gt;. If it is not implemented, the default values are used.</source>
          <target state="translated">드라이버는 &lt;code&gt;Capabilities&lt;/code&gt; 을 구현할 필요는 없습니다 . 구현되지 않으면 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45d754e6b3d42d6576d69090d424263def84711c" translate="yes" xml:space="preserve">
          <source>The easiest way to deploy Notary Server is by using Docker Compose. To follow the procedure on this page, you must have already &lt;a href=&quot;../../../../compose/install/index&quot;&gt;installed Docker Compose&lt;/a&gt;.</source>
          <target state="translated">Notary Server를 배포하는 가장 쉬운 방법은 Docker Compose를 사용하는 것입니다. 이 페이지의 절차를 수행하려면 &lt;a href=&quot;../../../../compose/install/index&quot;&gt;Docker Compose&lt;/a&gt; 가 이미 설치되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cbb3473804a03fd64904744c7f89f506da1b00af" translate="yes" xml:space="preserve">
          <source>The easiest way to deploy an application is to run it on a single server, similar to how you would run your development environment. If you want to scale up your application, you can run Compose apps on a Swarm cluster.</source>
          <target state="translated">응용 프로그램을 배포하는 가장 쉬운 방법은 개발 환경을 실행하는 방법과 유사하게 단일 서버에서 실행하는 것입니다. 응용 프로그램을 확장하려는 경우 Swarm 클러스터에서 Compose apps를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f3be48a8a42306450b08c080985765fe25d537c" translate="yes" xml:space="preserve">
          <source>The easiest way to produce a bundle is to generate it using &lt;code&gt;docker-compose&lt;/code&gt; from an existing &lt;code&gt;docker-compose.yml&lt;/code&gt;. Of course, that&amp;rsquo;s just &lt;em&gt;one&lt;/em&gt; possible way to proceed, in the same way that &lt;code&gt;docker build&lt;/code&gt; isn&amp;rsquo;t the only way to produce a Docker image.</source>
          <target state="translated">번들을 생성하는 가장 쉬운 방법 은 기존 &lt;code&gt;docker-compose.yml&lt;/code&gt; 에서 &lt;code&gt;docker-compose&lt;/code&gt; 를 사용하여 생성하는 것 입니다. 물론, 그것은 단지 &lt;em&gt;하나의&lt;/em&gt; 것과 같은 방식으로 진행하기 위해 가능한 방법 &lt;code&gt;docker build&lt;/code&gt; 도커 이미지를 생성 할 수있는 유일한 방법은 아니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e21df395f3446d584a4ca9200bc32ed01c54aa7" translate="yes" xml:space="preserve">
          <source>The endpoint &lt;code&gt;/containers/(id or name)/copy&lt;/code&gt; is deprecated in favor of &lt;code&gt;/containers/(id or name)/archive&lt;/code&gt;.</source>
          <target state="translated">엔드 포인트 &lt;code&gt;/containers/(id or name)/copy&lt;/code&gt; 는 &lt;code&gt;/containers/(id or name)/archive&lt;/code&gt; 대신 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5c08b62b88c6225b00d167dc7e607242e3b89d5e" translate="yes" xml:space="preserve">
          <source>The entrypoint can also be a list, in a manner similar to &lt;a href=&quot;../../../engine/reference/builder/index#entrypoint&quot;&gt;dockerfile&lt;/a&gt;:</source>
          <target state="translated">진입 점은 &lt;a href=&quot;../../../engine/reference/builder/index#entrypoint&quot;&gt;dockerfile&lt;/a&gt; 과 비슷한 방식으로 목록이 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f40c04ee015b92c39817e6ca9d4f62c70b5a83bd" translate="yes" xml:space="preserve">
          <source>The entrypoint can also be a list, in a manner similar to &lt;a href=&quot;../../engine/reference/builder/index#entrypoint&quot;&gt;dockerfile&lt;/a&gt;:</source>
          <target state="translated">진입 점은 &lt;a href=&quot;../../engine/reference/builder/index#entrypoint&quot;&gt;dockerfile&lt;/a&gt; 과 비슷한 방식으로 목록이 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec2a98ae62a1beccce3cba7cfa61a0b6efb72b90" translate="yes" xml:space="preserve">
          <source>The env command supports a &lt;code&gt;--no-proxy&lt;/code&gt; flag which ensures that the created machine&amp;rsquo;s IP address is added to the &lt;a href=&quot;https://wiki.archlinux.org/index.php/Proxy_settings&quot;&gt;&lt;code&gt;NO_PROXY&lt;/code&gt;/&lt;code&gt;no_proxy&lt;/code&gt; environment variable&lt;/a&gt;.</source>
          <target state="translated">env 명령은 생성 된 시스템의 IP 주소가 &lt;a href=&quot;https://wiki.archlinux.org/index.php/Proxy_settings&quot;&gt; &lt;code&gt;NO_PROXY&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;no_proxy&lt;/code&gt; 환경 변수에 추가되도록 하는 &lt;code&gt;--no-proxy&lt;/code&gt; 플래그를 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="e1826416e57d3bef2c80c7a035f75c85a4ffee30" translate="yes" xml:space="preserve">
          <source>The environment variables for the older passwords are optional, but Notary Signer cannot decrypt older keys if they are not provided, and attempts to sign data using those keys fail.</source>
          <target state="translated">이전 비밀번호의 환경 변수는 선택 사항이지만 Notary Signer는 이전 키가 제공되지 않으면 이전 키를 해독 할 수 없으며 해당 키를 사용하여 데이터에 서명하려는 시도는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a6627fbb8c91d0fc377c2ff347617c288abca678" translate="yes" xml:space="preserve">
          <source>The environment variables set using &lt;code&gt;ENV&lt;/code&gt; will persist when a container is run from the resulting image. You can view the values using &lt;code&gt;docker inspect&lt;/code&gt;, and change them using &lt;code&gt;docker run --env &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ENV&lt;/code&gt; 를 사용하여 설정 한 환경 변수 는 결과 이미지에서 컨테이너가 실행될 때 지속됩니다. &lt;code&gt;docker inspect&lt;/code&gt; 를 사용하여 값을보고 &lt;code&gt;docker run --env &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 를 사용하여 값을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2d4a06ff2b2c1bb65797bcb34409b040d8f44ca" translate="yes" xml:space="preserve">
          <source>The environment variables you define here are used for &lt;a href=&quot;../compose-file/index#variable-substitution&quot;&gt;variable substitution&lt;/a&gt; in your Compose file, and can also be used to define the following &lt;a href=&quot;../reference/envvars/index&quot;&gt;CLI variables&lt;/a&gt;:</source>
          <target state="translated">여기에서 정의한 환경 변수는 작성 파일의 &lt;a href=&quot;../compose-file/index#variable-substitution&quot;&gt;변수 대체&lt;/a&gt; 에 사용되며 다음 &lt;a href=&quot;../reference/envvars/index&quot;&gt;CLI 변수&lt;/a&gt; 를 정의하는 데에도 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d428381f478d7b84b477c7df64a8f6a6a9edd161" translate="yes" xml:space="preserve">
          <source>The escape character is used both to escape characters in a line, and to escape a newline. This allows a &lt;code&gt;Dockerfile&lt;/code&gt; instruction to span multiple lines. Note that regardless of whether the &lt;code&gt;escape&lt;/code&gt; parser directive is included in a &lt;code&gt;Dockerfile&lt;/code&gt;, &lt;em&gt;escaping is not performed in a &lt;code&gt;RUN&lt;/code&gt; command, except at the end of a line.&lt;/em&gt;</source>
          <target state="translated">이스케이프 문자는 한 줄의 문자를 이스케이프하고 개행을 이스케이프하는 데 사용됩니다. 이를 통해 &lt;code&gt;Dockerfile&lt;/code&gt; 명령어가 여러 줄에 걸쳐있을 수 있습니다. 에 관계없이 여부에 유의 &lt;code&gt;escape&lt;/code&gt; 파서 지시자가 포함되어 &lt;code&gt;Dockerfile&lt;/code&gt; , &lt;em&gt;A의 수행되지 않습니다 이스케이프 &lt;code&gt;RUN&lt;/code&gt; 의 줄 끝을 제외하고, 명령.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eeba3b74b0236d42f86530a251ea9e62a35c7995" translate="yes" xml:space="preserve">
          <source>The events that can be received using this can be seen &lt;a href=&quot;../../../engine/reference/commandline/events/index#object-types&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이를 사용하여 수신 할 수있는 이벤트는 &lt;a href=&quot;../../../engine/reference/commandline/events/index#object-types&quot;&gt;여기에서&lt;/a&gt; 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a17988740e39b0620e37d4cec3a97d766137f47" translate="yes" xml:space="preserve">
          <source>The example below demonstrates joining a manager node using a manager token.</source>
          <target state="translated">아래 예는 관리자 토큰을 사용하여 관리자 노드에 가입하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="25b4970988441b740e2a781fbee1a66aa2b61f5a" translate="yes" xml:space="preserve">
          <source>The example below demonstrates joining a worker node using a worker token.</source>
          <target state="translated">아래 예제는 작업자 토큰을 사용하여 작업자 노드에 가입하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b7a1e5a37682ef20c70bef17964c7684d70c655a" translate="yes" xml:space="preserve">
          <source>The example below exposes the first and third GPUs.</source>
          <target state="translated">아래 예제는 첫 번째 및 세 번째 GPU를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="136216b3bc39195557bd1003225e277d5f1e1c60" translate="yes" xml:space="preserve">
          <source>The example below illustrates this:</source>
          <target state="translated">아래 예제는이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7ed635a4e298f0a02b5b0d66b8bfc619f56a50cc" translate="yes" xml:space="preserve">
          <source>The example below mounts an empty tmpfs into the container with the &lt;code&gt;rw&lt;/code&gt;, &lt;code&gt;noexec&lt;/code&gt;, &lt;code&gt;nosuid&lt;/code&gt;, and &lt;code&gt;size=65536k&lt;/code&gt; options.</source>
          <target state="translated">아래 예제는 &lt;code&gt;rw&lt;/code&gt; , &lt;code&gt;noexec&lt;/code&gt; , &lt;code&gt;nosuid&lt;/code&gt; 및 &lt;code&gt;size=65536k&lt;/code&gt; 옵션을 사용 하여 빈 tmpfs를 컨테이너에 마운트합니다 .</target>
        </trans-unit>
        <trans-unit id="cd44fcd3927c43527b19df5d70413fafa8dafd56" translate="yes" xml:space="preserve">
          <source>The example below shows the information from a certificate from a worker node:</source>
          <target state="translated">아래 예는 작업자 노드의 인증서 정보를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="54d8617f0498acb2ab072f389ab875b0bca6e0a6" translate="yes" xml:space="preserve">
          <source>The example below shows the output for a daemon running on Red Hat Enterprise Linux, using the &lt;code&gt;devicemapper&lt;/code&gt; storage driver. As can be seen in the output, additional information about the &lt;code&gt;devicemapper&lt;/code&gt; storage driver is shown:</source>
          <target state="translated">아래 예제는 &lt;code&gt;devicemapper&lt;/code&gt; 스토리지 드라이버를 사용하여 Red Hat Enterprise Linux에서 실행되는 데몬의 출력을 보여줍니다 . 출력에서 볼 수 있듯이 &lt;code&gt;devicemapper&lt;/code&gt; 스토리지 드라이버 에 대한 추가 정보 가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="029833a3c9a7900068d40d95bb8919839dba6dc3" translate="yes" xml:space="preserve">
          <source>The example on this page is using experimental mode in Docker 1.13.</source>
          <target state="translated">이 페이지의 예는 Docker 1.13에서 실험 모드를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14272aafaddb2ec6f187da9a77f600e86a905b2" translate="yes" xml:space="preserve">
          <source>The example shown above would store log files until they reach a &lt;code&gt;max-size&lt;/code&gt; of 200kB, and then rotate them. The amount of individual log files stored is specified by the &lt;code&gt;max-file&lt;/code&gt; value. As logs grow beyond the max limits, older log files are removed to allow storage of new logs.</source>
          <target state="translated">위에 표시된 예는 &lt;code&gt;max-size&lt;/code&gt; 200kB에 도달 할 때까지 로그 파일을 저장 한 다음 회전합니다. 저장된 개별 로그 파일의 양은 &lt;code&gt;max-file&lt;/code&gt; 값으로 지정됩니다 . 로그가 최대 한계를 초과하면 새 로그를 저장할 수 있도록 이전 로그 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c577259842d61990aced0fbd2f28da4da6a3648f" translate="yes" xml:space="preserve">
          <source>The examples here show how to create and start a machine, run Docker commands, and work with containers.</source>
          <target state="translated">여기 예제는 머신을 작성 및 시작하고 Docker 명령을 실행하고 컨테이너를 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0849d6689ed7be80620bb8487fe1dd07e740085a" translate="yes" xml:space="preserve">
          <source>The exit code from &lt;code&gt;docker run&lt;/code&gt; gives information about why the container failed to run or why it exited. When &lt;code&gt;docker run&lt;/code&gt; exits with a non-zero code, the exit codes follow the &lt;code&gt;chroot&lt;/code&gt; standard, see below:</source>
          <target state="translated">&lt;code&gt;docker run&lt;/code&gt; 의 종료 코드 는 컨테이너가 실행되지 않은 이유 또는 종료 된 이유에 대한 정보를 제공합니다. 때 &lt;code&gt;docker run&lt;/code&gt; 종료 0이 아닌 코드, 종료 코드는 다음과 &lt;code&gt;chroot&lt;/code&gt; 환경의 표준을, 아래 참조 :</target>
        </trans-unit>
        <trans-unit id="582264dedcc552f5bc709f56c6bf7ac62d1091c7" translate="yes" xml:space="preserve">
          <source>The experimental channel uses incremental versioning with the major and minor component from the stable channel on the time of the release. For example:</source>
          <target state="translated">실험 채널은 출시 시점에 안정적인 채널의 주요 및 부 구성 요소와 함께 증분 버전 관리를 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52885d2644998577e6073933e22175a4ebac7538" translate="yes" xml:space="preserve">
          <source>The failure rate to tolerate during a rollback, specified as a floating-point number between 0 and 1. For instance, given 5 tasks, a failure ratio of &lt;code&gt;.2&lt;/code&gt; would tolerate one task failing to roll back. A value of &lt;code&gt;0&lt;/code&gt; means no failure are tolerated, while a value of &lt;code&gt;1&lt;/code&gt; means any number of failure are tolerated.</source>
          <target state="translated">롤백 중 허용되는 실패율은 0과 1 사이의 부동 소수점 숫자로 지정됩니다. 예를 들어, 5 개의 태스크에서 실패 비율은 &lt;code&gt;.2&lt;/code&gt; 이며 하나의 태스크가 롤백에 실패한 것을 허용합니다. 값이 &lt;code&gt;0&lt;/code&gt; 이면 실패가 허용되지 않음을 의미하고 값이 &lt;code&gt;1&lt;/code&gt; 이면 임의의 수의 실패가 허용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d68f9035a468196dba9c2b9c69d4081509161884" translate="yes" xml:space="preserve">
          <source>The features of Compose that make it effective are:</source>
          <target state="translated">효과적인 Compose의 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5586c9b78df4bbb7f9f4a597bb211ee31c9db6a9" translate="yes" xml:space="preserve">
          <source>The fields &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;Status&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; in the events API have been deprecated in favor of a more rich structure. See the events API documentation for the new format.</source>
          <target state="translated">필드의 &lt;code&gt;ID&lt;/code&gt; , &lt;code&gt;Status&lt;/code&gt; 및 &lt;code&gt;From&lt;/code&gt; 이벤트의 API에 좀 더 풍부한 구조에 찬성 사용되지 않습니다. 새로운 형식에 대해서는 이벤트 API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e940422c1fe38ec0a69aaf8826be36a4ebca5660" translate="yes" xml:space="preserve">
          <source>The file doesn&amp;rsquo;t need to have any contents.</source>
          <target state="translated">파일에 내용이 없어도됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1b2e21312a1d047cc07a276a5f08dda69ecae6" translate="yes" xml:space="preserve">
          <source>The file path in this example is not a requirement. In production, you could use another.</source>
          <target state="translated">이 예제의 파일 경로는 필수 사항이 아닙니다. 프로덕션에서는 다른 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5a70924dcb932c02c158eac18cd4f544c78e2d1" translate="yes" xml:space="preserve">
          <source>The files are actually being transferred using &lt;code&gt;sftp&lt;/code&gt; (over an ssh connection), so this program (&amp;ldquo;sftp&amp;rdquo;) needs to be present on the machine - but it usually is.</source>
          <target state="translated">파일은 실제로 &lt;code&gt;sftp&lt;/code&gt; (ssh 연결을 통해)를 사용하여 전송 되므로이 프로그램 ( &quot;sftp&quot;)은 컴퓨터에 있어야하지만 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c30c54a6a3202f383fed47f50a78dfcf095b8ba" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags. For example: &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;--filter&lt;/code&gt; ) 형식은 &lt;code&gt;key=value&lt;/code&gt; 쌍입니다. 하나 이상의 필터가있는 경우 여러 플래그를 전달하십시오. 예를 들면 다음과 같습니다. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f285ce11e5dcd83c24e5bd33204635adf09ba89" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;--filter&lt;/code&gt;) format is of &amp;ldquo;key=value&amp;rdquo;. If there is more than one filter, then pass multiple flags (e.g., &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;--filter&lt;/code&gt; ) 형식은&amp;ldquo;key = value&amp;rdquo;입니다. 하나 이상의 필터가있는 경우 여러 플래그를 전달하십시오 (예 : &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="17cb4654fb42a49d5cd6d0cc710a22c55ee18d5c" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; ) 형식은 &lt;code&gt;key=value&lt;/code&gt; 쌍입니다. 하나 이상의 필터가있는 경우 여러 플래그를 전달하십시오 (예 : &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="426aa2257cf91d00fd6ee5760b570121af7b130b" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;). Multiple filter flags are combined as an &lt;code&gt;OR&lt;/code&gt; filter.</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; ) 형식은 &lt;code&gt;key=value&lt;/code&gt; 쌍입니다. 하나 이상의 필터가있는 경우 여러 플래그를 전달하십시오 (예 : &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ). 여러 필터 플래그가 &lt;code&gt;OR&lt;/code&gt; 필터 로 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8989ebfc2055cad776feeb144c1f803cbdf05ec" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;). Multiple filter flags are combined as an &lt;code&gt;OR&lt;/code&gt; filter. For example, &lt;code&gt;-f name=redis.1 -f name=redis.7&lt;/code&gt; returns both &lt;code&gt;redis.1&lt;/code&gt; and &lt;code&gt;redis.7&lt;/code&gt; tasks.</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; ) 형식은 &lt;code&gt;key=value&lt;/code&gt; 쌍입니다. 하나 이상의 필터가있는 경우 여러 플래그를 전달하십시오 (예 : &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ). 여러 필터 플래그가 &lt;code&gt;OR&lt;/code&gt; 필터 로 결합됩니다 . 예를 들어, &lt;code&gt;-f name=redis.1 -f name=redis.7&lt;/code&gt; 은 &lt;code&gt;redis.1&lt;/code&gt; 과 &lt;code&gt;redis.7&lt;/code&gt; 태스크를 합니다.</target>
        </trans-unit>
        <trans-unit id="6cfeb05ebb258fa8134b6ec40524576b415408df" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;). Multiple filter flags are combined as an &lt;code&gt;OR&lt;/code&gt; filter. For example, &lt;code&gt;-f type=custom -f type=builtin&lt;/code&gt; returns both &lt;code&gt;custom&lt;/code&gt; and &lt;code&gt;builtin&lt;/code&gt; networks.</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; ) 형식은 &lt;code&gt;key=value&lt;/code&gt; 쌍입니다. 하나 이상의 필터가있는 경우 여러 플래그를 전달하십시오 (예 : &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ). 여러 필터 플래그가 &lt;code&gt;OR&lt;/code&gt; 필터 로 결합됩니다 . 예를 들어, &lt;code&gt;-f type=custom -f type=builtin&lt;/code&gt; 은 &lt;code&gt;custom&lt;/code&gt; 과 custom을 모두 반환합니다. &lt;code&gt;builtin&lt;/code&gt; 네트워크 기본 제공 네트워크를 .</target>
        </trans-unit>
        <trans-unit id="aa57b9da7a41568c91cc65822e0d547ada31afd2" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g., &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; ) 형식은 &lt;code&gt;key=value&lt;/code&gt; 쌍입니다. 하나 이상의 필터가있는 경우 여러 플래그를 전달하십시오 (예 : &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6d153c537e3f437d55503da7c3af5fa8df3281c1" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is of &amp;ldquo;key=value&amp;rdquo;. If there is more than one filter, then pass multiple flags (e.g., &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; ) 형식은&amp;ldquo;key = value&amp;rdquo;입니다. 하나 이상의 필터가있는 경우 여러 플래그를 전달하십시오 (예 : &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="21c9307216d7ac9e58873bc62de805e595d77fb7" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is of &amp;ldquo;key=value&amp;rdquo;. If you would like to use multiple filters, pass multiple flags (e.g., &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">필터링 플래그 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; ) 형식은&amp;ldquo;key = value&amp;rdquo;입니다. 여러 필터를 사용하려면 여러 플래그를 전달하십시오 (예 : &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c89d57bdf2df6a04b4fa2b97bdec037616b402af" translate="yes" xml:space="preserve">
          <source>The first example shows both the short and long syntax for secrets, and the second example shows only the short syntax. The short syntax creates files in &lt;code&gt;/run/secrets/&lt;/code&gt; with the same name as the secret. Within the running containers, the following three files now exist:</source>
          <target state="translated">첫 번째 예는 비밀에 대한 짧은 구문과 긴 구문을 보여주고 두 번째 예는 짧은 구문 만 보여줍니다. 짧은 구문은 &lt;code&gt;/run/secrets/&lt;/code&gt; 과 동일한 이름으로 / run / secrets /에 파일을 만듭니다 . 실행중인 컨테이너 내에 다음 세 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1e4c3387577d12532a6e4a3ecfe47ce12c0a55e" translate="yes" xml:space="preserve">
          <source>The first machine acts as the manager, which executes management commands and authenticates workers to join the swarm, and the second is a worker.</source>
          <target state="translated">첫 번째 컴퓨터는 관리자 역할을하며 관리자는 관리 명령을 실행하고 작업자가 웜에 가입하도록 인증하고 두 번째 컴퓨터는 작업자입니다.</target>
        </trans-unit>
        <trans-unit id="2bba495c3320b897a52b14601599924b407dce11" translate="yes" xml:space="preserve">
          <source>The first time you run this, the docker-in-docker, Notary server, and registry images are downloaded from Docker Hub.</source>
          <target state="translated">이것을 처음 실행하면 docker-in-docker, Notary 서버 및 레지스트리 이미지가 Docker Hub에서 다운로드됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e3339436cc84f78df58b00f645a3e8f63ffc1d" translate="yes" xml:space="preserve">
          <source>The first time you try to create a machine, Azure driver asks you to authenticate:</source>
          <target state="translated">컴퓨터를 처음 만들려고하면 Azure 드라이버가 인증을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="cb84cfdbd020c04d119b920f80cb7bc8cfcb5740" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--api-enable-cors&lt;/code&gt; is deprecated since v1.6.0. Use the flag &lt;code&gt;--api-cors-header&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;--api-enable-cors&lt;/code&gt; 플래그 는 v1.6.0부터 더 이상 사용되지 않습니다. 대신 &lt;code&gt;--api-cors-header&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="05639fcd64ed17067c7ecbfbfdb1be4d5640f23e" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--limit&lt;/code&gt; is the maximum number of results returned by a search. This value could be in the range between 1 and 100. The default value of &lt;code&gt;--limit&lt;/code&gt; is 25.</source>
          <target state="translated">&lt;code&gt;--limit&lt;/code&gt; 플래그 는 검색에서 반환 된 최대 결과 수입니다. 이 값의 범위는 1에서 100 사이 입니다. &lt;code&gt;--limit&lt;/code&gt; 의 기본값 은 25입니다.</target>
        </trans-unit>
        <trans-unit id="cab2ad76191c73b2c24b2a692e1bc849f354e599" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--run&lt;/code&gt; of the docker commit (and its short version &lt;code&gt;-run&lt;/code&gt;) were deprecated in favor of the &lt;code&gt;--changes&lt;/code&gt; flag that allows to pass &lt;code&gt;Dockerfile&lt;/code&gt; commands.</source>
          <target state="translated">Docker 커밋 의 플래그 &lt;code&gt;--run&lt;/code&gt; 및 짧은 버전 &lt;code&gt;-run&lt;/code&gt; 은 &lt;code&gt;Dockerfile&lt;/code&gt; 을 전달할 수 있는 &lt;code&gt;--changes&lt;/code&gt; 플래그를 위해 더 이상 사용되지 않습니다. 명령 .</target>
        </trans-unit>
        <trans-unit id="66b31971db73964ceb63d241b628599ed67bd387" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--security-opt&lt;/code&gt; doesn&amp;rsquo;t use the colon separator (&lt;code&gt;:&lt;/code&gt;) anymore to divide keys and values, it uses the equal symbol (&lt;code&gt;=&lt;/code&gt;) for consistency with other similar flags, like &lt;code&gt;--storage-opt&lt;/code&gt;.</source>
          <target state="translated">플래그 &lt;code&gt;--security-opt&lt;/code&gt; (결장 세퍼레이터를 사용하지 않는 &lt;code&gt;:&lt;/code&gt; ) 분할 키 값 이상은, 상기 동일한 심볼 (사용 &lt;code&gt;=&lt;/code&gt; 같은 다른 유사한 플래그와 일관성) &lt;code&gt;--storage-opt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8989880255f74df623b434530f23c19d9dd927e2" translate="yes" xml:space="preserve">
          <source>The flag can be used multiple times to allow multiple registries to be marked as insecure.</source>
          <target state="translated">이 플래그를 여러 번 사용하여 여러 레지스트리를 안전하지 않은 것으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="211c61f70624ea83298a758a91c7c1645a33a063" translate="yes" xml:space="preserve">
          <source>The flags &lt;code&gt;-d&lt;/code&gt; and &lt;code&gt;--daemon&lt;/code&gt; are deprecated in favor of the &lt;code&gt;daemon&lt;/code&gt; subcommand:</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 및 &lt;code&gt;--daemon&lt;/code&gt; 플래그 는 &lt;code&gt;daemon&lt;/code&gt; 부속 명령 을 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fe514827a2bc8cfeb3427c13cc2ba47f6aba7300" translate="yes" xml:space="preserve">
          <source>The flags are:</source>
          <target state="translated">플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fec17d2ea0cac008bfab4ea63128760ff0394bf" translate="yes" xml:space="preserve">
          <source>The flags you pass to &lt;code&gt;ip addr show&lt;/code&gt; depend on whether you are using IPv4 or IPv6 networking in your containers. Use the following flags for IPv4 address retrieval for a network device named &lt;code&gt;eth0&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ip addr show&lt;/code&gt; 전달하는 플래그 는 컨테이너에서 IPv4 또는 IPv6 네트워킹을 사용하는지 여부에 따라 다릅니다. &lt;code&gt;eth0&lt;/code&gt; 이라는 네트워크 장치의 IPv4 주소 검색에 다음 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="71648dc68d5b64d785048324356509378e05cbab" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ARG&lt;/code&gt; variables are set automatically:</source>
          <target state="translated">다음 &lt;code&gt;ARG&lt;/code&gt; 변수는 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="30e40704f73a0a3a123810462ea6e8146a6cf011" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;Dockerfile&lt;/code&gt; shows using the &lt;code&gt;ENTRYPOINT&lt;/code&gt; to run Apache in the foreground (i.e., as &lt;code&gt;PID 1&lt;/code&gt;):</source>
          <target state="translated">다음 &lt;code&gt;Dockerfile&lt;/code&gt; 은 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 를 사용하여 포 그라운드에서 Apache를 실행 하는 것을 보여줍니다 (예 : &lt;code&gt;PID 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="37f735ff00a071c2cf805f826830d3b8e2b5d95b" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;run&lt;/code&gt; command options work with container networking:</source>
          <target state="translated">다음 &lt;code&gt;run&lt;/code&gt; 명령 옵션은 컨테이너 네트워킹에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2dd8971bea651d99e456deec000fc508c3c98507" translate="yes" xml:space="preserve">
          <source>The following arguments can be passed to &lt;code&gt;docker network create&lt;/code&gt; for any network driver, again with their approximate equivalents to &lt;code&gt;docker daemon&lt;/code&gt;.</source>
          <target state="translated">다음 인수는 모든 네트워크 드라이버에 대해 &lt;code&gt;docker network create&lt;/code&gt; 에 전달할 수 있으며 , 다시 &lt;code&gt;docker daemon&lt;/code&gt; 과 동등한 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="b23a60a2303821537dcbfdf274039df8c3b54583" translate="yes" xml:space="preserve">
          <source>The following assumptions are made:</source>
          <target state="translated">다음과 같은 가정이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="8c8e4bd61d1bff8edef1e67a6084184b1eb9a3d0" translate="yes" xml:space="preserve">
          <source>The following command creates a global service:</source>
          <target state="translated">다음 명령은 글로벌 서비스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3f41dfd8129fa7163b1fcd0686727a3dff3ac419" translate="yes" xml:space="preserve">
          <source>The following command creates a service with three replicas with an anonymous volume on &lt;code&gt;/path/in/container&lt;/code&gt;:</source>
          <target state="translated">다음 명령은 &lt;code&gt;/path/in/container&lt;/code&gt; 에 익명 볼륨을 가진 세 개의 복제본으로 서비스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="29c23ead74fe204bf41fa629c5ab8b6b4b70e8a5" translate="yes" xml:space="preserve">
          <source>The following command pulls the &lt;code&gt;testing/test-image&lt;/code&gt; image from a local registry listening on port 5000 (&lt;code&gt;myregistry.local:5000&lt;/code&gt;):</source>
          <target state="translated">다음 명령 은 포트 5000 ( &lt;code&gt;myregistry.local:5000&lt;/code&gt; ) 에서 청취하는 로컬 레지스트리에서 &lt;code&gt;testing/test-image&lt;/code&gt; 이미지를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7e7782423be2ee9e2d32ef7fe59037eb232cd112" translate="yes" xml:space="preserve">
          <source>The following command scales the &amp;ldquo;frontend&amp;rdquo; service to 50 tasks.</source>
          <target state="translated">다음 명령은 &quot;프론트 엔드&quot;서비스를 50 개의 작업으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="e98a7778ab952d2730fb21ff8b3b5a2385a04618" translate="yes" xml:space="preserve">
          <source>The following command shows all services in the &lt;code&gt;myapp&lt;/code&gt; stack:</source>
          <target state="translated">다음 명령은 &lt;code&gt;myapp&lt;/code&gt; 스택의 모든 서비스를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f6737e57d5cb6dbd975d1866fc4b37937d8fb0ea" translate="yes" xml:space="preserve">
          <source>The following command shows all stacks and some additional information:</source>
          <target state="translated">다음 명령은 모든 스택과 일부 추가 정보를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d5faa074805d759eea82bbf46ff2134e3cf5cf46" translate="yes" xml:space="preserve">
          <source>The following command shows all the tasks that are part of the &lt;code&gt;redis&lt;/code&gt; service:</source>
          <target state="translated">다음 명령은 &lt;code&gt;redis&lt;/code&gt; 서비스의 일부인 모든 작업을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7366e9c16d47b415ad53ada639d3d553801f6fcb" translate="yes" xml:space="preserve">
          <source>The following command shows all the tasks that are part of the &lt;code&gt;voting&lt;/code&gt; stack:</source>
          <target state="translated">다음 명령은 &lt;code&gt;voting&lt;/code&gt; 스택의 일부인 모든 작업을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="33aa1c0ff959003ae5db74897da312b568866247" translate="yes" xml:space="preserve">
          <source>The following command shows both the &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;db&lt;/code&gt; services:</source>
          <target state="translated">다음 명령은 &lt;code&gt;web&lt;/code&gt; 과 &lt;code&gt;db&lt;/code&gt; 를 모두 보여줍니다. 서비스를 .</target>
        </trans-unit>
        <trans-unit id="cc1df223fe15bc104674c09a48d71feaab974d1f" translate="yes" xml:space="preserve">
          <source>The following command shows images and which family they belong to (if any):</source>
          <target state="translated">다음 명령은 이미지와 이미지가 속한 패밀리를 보여줍니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="f3237696ef19d83021d5a836b6a1e9cef0f6a8c6" translate="yes" xml:space="preserve">
          <source>The following command tries to scale a global service to 10 tasks and returns an error.</source>
          <target state="translated">다음 명령은 전역 서비스를 10 개의 작업으로 확장하려고 시도하고 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="743253aea145f2b6b290ac340121787c9e892dbc" translate="yes" xml:space="preserve">
          <source>The following commands show several different ways to filter the &lt;code&gt;docker event&lt;/code&gt; output.</source>
          <target state="translated">다음 명령은 &lt;code&gt;docker event&lt;/code&gt; 출력 을 필터링하는 여러 가지 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b6298983a47ff8b831614b53250bab44a457c001" translate="yes" xml:space="preserve">
          <source>The following daemon options must be configured for each daemon:</source>
          <target state="translated">각 데몬에 대해 다음 데몬 옵션을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e1249ef154b913b7dd2bbe55b18194abec49cea" translate="yes" xml:space="preserve">
          <source>The following diagram illustrates the interactions between the Notary client, server, and signer:</source>
          <target state="translated">다음 다이어그램은 Notary 클라이언트, 서버 및 서명자 간의 상호 작용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="073116ed512a6960c0757670bc051f3d85c14ca2" translate="yes" xml:space="preserve">
          <source>The following double-dash options are deprecated and have no replacement:</source>
          <target state="translated">다음 이중 대시 옵션은 더 이상 사용되지 않으며 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7553e37733080d989c32cbc7394667475874c240" translate="yes" xml:space="preserve">
          <source>The following environment variables are set for Linux containers:</source>
          <target state="translated">Linux 컨테이너에는 다음 환경 변수가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1cf7dac8f25b3b64ccb5f54f340c992264a83cea" translate="yes" xml:space="preserve">
          <source>The following environment variables containing signing key passphrases can be used to facilitate &lt;a href=&quot;../../advanced_usage/index&quot;&gt;Notary client CLI interaction&lt;/a&gt;. If provided, these passwords are used initially to sign TUF metadata. If the passphrase is incorrect, you are prompted to enter the correct passphrase.</source>
          <target state="translated">서명 키 비밀번호 문구를 포함하는 다음 환경 변수를 사용하여 &lt;a href=&quot;../../advanced_usage/index&quot;&gt;Notary 클라이언트 CLI 상호 작용&lt;/a&gt; 을 용이하게 할 수 있습니다 . 제공된 경우이 비밀번호는 처음에 TUF 메타 데이터에 서명하는 데 사용됩니다. 암호가 틀리면 올바른 암호를 입력하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="330e46b20430cd7e0f80c1c374963e5118293212" translate="yes" xml:space="preserve">
          <source>The following example adds a new alias name to an existing service already connected to network my-network:</source>
          <target state="translated">다음 예제는 네트워크 my-network에 이미 연결된 기존 서비스에 새 별칭 이름을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bfce6b526de13780562727784926aed9ee9477cf" translate="yes" xml:space="preserve">
          <source>The following example adds a published service port to an existing service.</source>
          <target state="translated">다음 예제는 게시 된 서비스 포트를 기존 서비스에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cdac32ddb3bc500f52a2c4a75021fc5f7dc815f7" translate="yes" xml:space="preserve">
          <source>The following example adds a secret named &lt;code&gt;ssh-2&lt;/code&gt; and removes &lt;code&gt;ssh-1&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 &lt;code&gt;ssh-2&lt;/code&gt; 라는 비밀을 추가하고 &lt;code&gt;ssh-1&lt;/code&gt; 을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="ed35b68636be0f973b90873b9a9b7655e381e216" translate="yes" xml:space="preserve">
          <source>The following example assumes a gMSA and its credential spec (called credspec.json) already exists, and that the nodes being deployed to are correctly configured for the gMSA.</source>
          <target state="translated">다음 예는 gMSA 및 해당 자격 증명 사양 (credspec.json이라고 함)이 이미 존재하며 배포 할 노드가 gMSA에 대해 올바르게 구성되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="58de12602d90215b83000afdccd448ef3bc54d9f" translate="yes" xml:space="preserve">
          <source>The following example bind-mounts a host directory at &lt;code&gt;/path/in/container&lt;/code&gt; in the containers backing the service:</source>
          <target state="translated">다음 예제 는 서비스를 지원하는 &lt;code&gt;/path/in/container&lt;/code&gt; 에 호스트 디렉토리를 바인드 마운트합니다 .</target>
        </trans-unit>
        <trans-unit id="345356612044ec35634acb958647f9ee76b8ead7" translate="yes" xml:space="preserve">
          <source>The following example change the env variable &lt;code&gt;DEBUG&lt;/code&gt; on the &lt;code&gt;sample-volume-plugin&lt;/code&gt; plugin.</source>
          <target state="translated">다음 예제 는 &lt;code&gt;sample-volume-plugin&lt;/code&gt; 플러그인 에서 env 변수 &lt;code&gt;DEBUG&lt;/code&gt; 를 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="1b9d6b0fdf70b163165b0fcce02f13448db748ce" translate="yes" xml:space="preserve">
          <source>The following example change the path of the &lt;code&gt;mydevice&lt;/code&gt; device on the &lt;code&gt;myplugin&lt;/code&gt; plugin.</source>
          <target state="translated">다음 예제 는 &lt;code&gt;myplugin&lt;/code&gt; 플러그인 에서 &lt;code&gt;mydevice&lt;/code&gt; 장치 의 경로를 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="37a4c9d8a660383f462090e521ec2df16b8718d3" translate="yes" xml:space="preserve">
          <source>The following example change the source of the &lt;code&gt;mymount&lt;/code&gt; mount on the &lt;code&gt;myplugin&lt;/code&gt; plugin.</source>
          <target state="translated">다음 예제 는 &lt;code&gt;myplugin&lt;/code&gt; 플러그인 에서 &lt;code&gt;mymount&lt;/code&gt; 마운트 의 소스를 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="f8267ab2e1a38cb0d0220942e495dc3d366efa5a" translate="yes" xml:space="preserve">
          <source>The following example change the value of the args on the &lt;code&gt;myplugin&lt;/code&gt; plugin.</source>
          <target state="translated">다음 예제는 &lt;code&gt;myplugin&lt;/code&gt; 플러그인 에서 args 값을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="f650868197d937aea99d7e6f5a9ab9219f7b7e10" translate="yes" xml:space="preserve">
          <source>The following example configures a &lt;code&gt;redis&lt;/code&gt; service to roll back automatically if a &lt;code&gt;docker service update&lt;/code&gt; fails to deploy. Two tasks can be rolled back in parallel. Tasks are monitored for 20 seconds after rollback to be sure they do not exit, and a maximum failure ratio of 20% is tolerated. Default values are used for &lt;code&gt;--rollback-delay&lt;/code&gt; and &lt;code&gt;--rollback-failure-action&lt;/code&gt;.</source>
          <target state="translated">다음 예제 는 &lt;code&gt;docker service update&lt;/code&gt; 가 배포되지 않으면 &lt;code&gt;redis&lt;/code&gt; 서비스가 자동으로 롤백되도록 구성합니다 . 두 가지 작업을 동시에 롤백 할 수 있습니다. 롤백 후 20 초 동안 작업을 모니터링하여 종료되지 않았는지 확인하고 최대 실패율은 20 %입니다. &lt;code&gt;--rollback-delay&lt;/code&gt; 및 &lt;code&gt;--rollback-failure-action&lt;/code&gt; 에 기본값이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfc6ef49320e217eb5c253c2ac24897dc4371265" translate="yes" xml:space="preserve">
          <source>The following example creates a network using the built-in &lt;code&gt;bridge&lt;/code&gt; network driver and running a container in the created network</source>
          <target state="translated">다음 예제는 내장 &lt;code&gt;bridge&lt;/code&gt; 네트워크 드라이버를 사용하고 생성 된 네트워크에서 컨테이너를 실행하는 네트워크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6f15ed186e216c41ccf590a70e61097dd40b3081" translate="yes" xml:space="preserve">
          <source>The following example creates a service that uses a named volume:</source>
          <target state="translated">다음 예제는 명명 된 볼륨을 사용하는 서비스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="be9175ed1d5e994edd6a5d5d4d2a3f9572676d39" translate="yes" xml:space="preserve">
          <source>The following example creates a service which mounts the &lt;code&gt;test-data&lt;/code&gt; volume to &lt;code&gt;/somewhere&lt;/code&gt;. The next step updates the service to also mount the &lt;code&gt;other-volume&lt;/code&gt; volume to &lt;code&gt;/somewhere-else&lt;/code&gt;volume, The last step unmounts the &lt;code&gt;/somewhere&lt;/code&gt; mount point, effectively removing the &lt;code&gt;test-data&lt;/code&gt; volume. Each command returns the service name.</source>
          <target state="translated">다음 예제는 &lt;code&gt;test-data&lt;/code&gt; 볼륨을 &lt;code&gt;/somewhere&lt;/code&gt; 에 마운트하는 서비스를 작성합니다 . 다음 단계는 서비스를 업데이트하여 &lt;code&gt;other-volume&lt;/code&gt; 볼륨을 &lt;code&gt;/somewhere-else&lt;/code&gt; 볼륨에 마운트합니다. 마지막 단계는 &lt;code&gt;/somewhere&lt;/code&gt; 마운트 포인트를 마운트 해제 하여 &lt;code&gt;test-data&lt;/code&gt; 볼륨을 효과적으로 제거합니다 . 각 명령은 서비스 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8c7341d24e14d740d2f93a0ba945ff8e13e5984" translate="yes" xml:space="preserve">
          <source>The following example creates a service with a single replica, updates the service to use three replicas, and then rolls back the service to the previous version, having one replica.</source>
          <target state="translated">다음 예제는 단일 복제본으로 서비스를 작성하고 세 개의 복제본을 사용하도록 서비스를 업데이트 한 다음 하나의 복제본이있는 이전 버전으로 서비스를 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="29fd998771d5f61ae99690e05c2da76e000b7f1e" translate="yes" xml:space="preserve">
          <source>The following example disables and removes the &lt;code&gt;sample-volume-plugin:latest&lt;/code&gt; plugin:</source>
          <target state="translated">다음 예제는 &lt;code&gt;sample-volume-plugin:latest&lt;/code&gt; 플러그인을 비활성화하고 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="58414d829baf96224b330e04ddc456870ac303da" translate="yes" xml:space="preserve">
          <source>The following example filter matches volumes with the &lt;code&gt;is-timelord&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">다음 예제 필터 는 값에 관계없이 볼륨을 &lt;code&gt;is-timelord&lt;/code&gt; 레이블 과 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a9825e605f4ae30ab10a0382379dec35cdfaaa78" translate="yes" xml:space="preserve">
          <source>The following example installs &lt;code&gt;vieus/sshfs&lt;/code&gt; plugin and &lt;a href=&quot;../plugin_set/index&quot;&gt;sets&lt;/a&gt; its &lt;code&gt;DEBUG&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. To install, &lt;code&gt;pull&lt;/code&gt; the plugin from Docker Hub and prompt the user to accept the list of privileges that the plugin needs, set the plugin&amp;rsquo;s parameters and enable the plugin.</source>
          <target state="translated">다음 예는 설치 &lt;code&gt;vieus/sshfs&lt;/code&gt; 플러그인 및 &lt;a href=&quot;../plugin_set/index&quot;&gt;세트&lt;/a&gt; 의 &lt;code&gt;DEBUG&lt;/code&gt; 를 환경 변수를 &lt;code&gt;1&lt;/code&gt; . 설치하려면, &lt;code&gt;pull&lt;/code&gt; 플러그인 요구, 플러그인의 매개 변수를 설정하고 플러그인을 사용하도록 설정하는 것이 특권의 목록을 받아 도커 허브에서 플러그인 및 프롬프트 사용자.</target>
        </trans-unit>
        <trans-unit id="813d16401bf2f9114259b05a74110ed1120c1ce5" translate="yes" xml:space="preserve">
          <source>The following example installs &lt;code&gt;vieus/sshfs&lt;/code&gt; plugin, uses it to create and use a volume, then upgrades the plugin.</source>
          <target state="translated">다음 예제는 &lt;code&gt;vieus/sshfs&lt;/code&gt; 플러그인을 설치 하고이를 사용하여 볼륨을 작성하고 사용한 다음 플러그인을 업그레이드합니다.</target>
        </trans-unit>
        <trans-unit id="488f39c6669e0e91254e7cfb402fee79b9fa2d8b" translate="yes" xml:space="preserve">
          <source>The following example is a common pattern found on Windows which can be streamlined by using the &lt;code&gt;SHELL&lt;/code&gt; instruction:</source>
          <target state="translated">다음 예제는 &lt;code&gt;SHELL&lt;/code&gt; 명령어 를 사용하여 간소화 할 수있는 Windows에서 발견되는 일반적인 패턴입니다 .</target>
        </trans-unit>
        <trans-unit id="7f9a9efded9b244dee8aabd2a087f9e89c5da7e9" translate="yes" xml:space="preserve">
          <source>The following example limits the memory (&lt;code&gt;-m&lt;/code&gt;) to 500M and sets the memory reservation to 200M.</source>
          <target state="translated">다음 예제는 메모리 ( &lt;code&gt;-m&lt;/code&gt; )를 500M으로 제한 하고 메모리 예약을 200M으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c98bc0fde049889c7f7676fa21cfc061612b3f91" translate="yes" xml:space="preserve">
          <source>The following example limits the memory to 100M and disables the OOM killer for this container:</source>
          <target state="translated">다음 예제는 메모리를 100M으로 제한하고이 컨테이너에 대한 OOM 킬러를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="61de1584870695125b4a74e826905894c3c68353" translate="yes" xml:space="preserve">
          <source>The following example load the credential spec from a value named &lt;code&gt;my-credential-spec&lt;/code&gt; in the registry:</source>
          <target state="translated">다음 예제 는 레지스트리의 &lt;code&gt;my-credential-spec&lt;/code&gt; 값에서 신임 스펙을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="f31dcebd5640e4ee3430345cde44ce122416adb9" translate="yes" xml:space="preserve">
          <source>The following example matches networks with the &lt;code&gt;bridge&lt;/code&gt; driver:</source>
          <target state="translated">다음 예제는 네트워크를 &lt;code&gt;bridge&lt;/code&gt; 드라이버 와 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="b727cd30c474b02b8830e2bceade1108e4fb2687" translate="yes" xml:space="preserve">
          <source>The following example matches networks with the &lt;code&gt;local&lt;/code&gt; scope:</source>
          <target state="translated">다음 예제는 네트워크를 &lt;code&gt;local&lt;/code&gt; 범위 와 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="991d737d7f20b84a74e6a617d5dc2116e8fd9fc0" translate="yes" xml:space="preserve">
          <source>The following example matches networks with the &lt;code&gt;swarm&lt;/code&gt; scope:</source>
          <target state="translated">다음 예는 &lt;code&gt;swarm&lt;/code&gt; 범위 와 네트워크를 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="85f19a1b28b0c4b4d423eed2db6c9916310c58bd" translate="yes" xml:space="preserve">
          <source>The following example matches volumes that are created with the &lt;code&gt;local&lt;/code&gt; driver:</source>
          <target state="translated">다음 예제는 &lt;code&gt;local&lt;/code&gt; 드라이버 로 작성된 볼륨과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="09cb8c4ce1df308900b83a52d7298b2ae3ac003f" translate="yes" xml:space="preserve">
          <source>The following example reads a password from a file, and passes it to the &lt;code&gt;docker login&lt;/code&gt; command using &lt;code&gt;STDIN&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 파일에서 비밀번호를 읽고 &lt;code&gt;STDIN&lt;/code&gt; 을 사용하여 &lt;code&gt;docker login&lt;/code&gt; 명령으로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="e0ddfae23ebd183f0203154109919119f0be6ff1" translate="yes" xml:space="preserve">
          <source>The following example removes images with the label &lt;code&gt;deprecated&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 레이블이 &lt;code&gt;deprecated&lt;/code&gt; 이미지를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="8f4b6e6ce6615def6425c69da97cb6c9e5ff166a" translate="yes" xml:space="preserve">
          <source>The following example removes images with the label &lt;code&gt;maintainer&lt;/code&gt; set to &lt;code&gt;john&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 레이블 &lt;code&gt;maintainer&lt;/code&gt; 가 &lt;code&gt;john&lt;/code&gt; 으로 설정된 이미지를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="b71aef8df0c62b67fdb13f10edccc0071e581b90" translate="yes" xml:space="preserve">
          <source>The following example runs a container from the &lt;code&gt;alpine&lt;/code&gt; image with the &lt;code&gt;sha256:9cacb71397b640eca97488cf08582ae4e4068513101088e9f96c9814bfda95e0&lt;/code&gt; digest:</source>
          <target state="translated">다음 예제는 &lt;code&gt;sha256:9cacb71397b640eca97488cf08582ae4e4068513101088e9f96c9814bfda95e0&lt;/code&gt; 다이제스트 를 사용하여 &lt;code&gt;alpine&lt;/code&gt; 이미지 에서 컨테이너를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="14bc07f818ef5b8e3874b5e3f0cede09acf315cf" translate="yes" xml:space="preserve">
          <source>The following example runs nginx as a service on each node in your swarm and exposes nginx port locally on each swarm node.</source>
          <target state="translated">다음 예제는 웜의 각 노드에서 nginx를 서비스로 실행하고 각 웜 노드에서 로컬로 nginx 포트를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="3c1ee6b9dcdd5a62ce81941fd4fd7e8bb580e939" translate="yes" xml:space="preserve">
          <source>The following example sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the container named &lt;code&gt;my_container&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 &lt;code&gt;SIGHUP&lt;/code&gt; 신호를 &lt;code&gt;my_container&lt;/code&gt; 라는 컨테이너로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="b046c8d9a9d59e70ba785c2fa43e3ae60f63c35d" translate="yes" xml:space="preserve">
          <source>The following example sends the default &lt;code&gt;KILL&lt;/code&gt; signal to the container named &lt;code&gt;my_container&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 기본 &lt;code&gt;KILL&lt;/code&gt; 신호를 &lt;code&gt;my_container&lt;/code&gt; 컨테이너에 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="2124a458e14880a140fd9d2f4cfa3b4d4cdf3eb7" translate="yes" xml:space="preserve">
          <source>The following example set memory reservation to 1G without a hard memory limit.</source>
          <target state="translated">다음 예는 하드 메모리 제한없이 메모리 예약을 1G로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="db08df032a2de4d6f23e749dae8e6565966b669b" translate="yes" xml:space="preserve">
          <source>The following example sets a preference to spread the deployment across nodes based on the value of the &lt;code&gt;datacenter&lt;/code&gt; label. If some nodes have &lt;code&gt;datacenter=us-east&lt;/code&gt; and others have &lt;code&gt;datacenter=us-west&lt;/code&gt;, the service is deployed as evenly as possible across the two sets of nodes.</source>
          <target state="translated">다음 예는 &lt;code&gt;datacenter&lt;/code&gt; 레이블 값을 기반으로 노드 전체에 배포를 분산시키는 환경 설정을 설정합니다 . 일부 노드에 &lt;code&gt;datacenter=us-east&lt;/code&gt; 가 있고 다른 노드에 &lt;code&gt;datacenter=us-west&lt;/code&gt; 가 있으면 서비스가 두 노드 세트에 가능한 한 고르게 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="8230dd1220dd706cf8566dbee10e4dc1ad1c9d4a" translate="yes" xml:space="preserve">
          <source>The following example sets name of the &lt;code&gt;my_secret&lt;/code&gt; to &lt;code&gt;redis_secret&lt;/code&gt; within the container, sets the mode to &lt;code&gt;0440&lt;/code&gt; (group-readable) and sets the user and group to &lt;code&gt;103&lt;/code&gt;. The &lt;code&gt;redis&lt;/code&gt; service does not have access to the &lt;code&gt;my_other_secret&lt;/code&gt; secret.</source>
          <target state="translated">다음의 예시적인 세트 이름 &lt;code&gt;my_secret&lt;/code&gt; 은 하기 &lt;code&gt;redis_secret&lt;/code&gt; 용기 내로 모드를 설정 &lt;code&gt;0440&lt;/code&gt; (그룹 판독)과의 사용자와 그룹 세트 &lt;code&gt;103&lt;/code&gt; . &lt;code&gt;redis&lt;/code&gt; 서비스는에 액세스 할 수 없습니다 &lt;code&gt;my_other_secret&lt;/code&gt; 의 비밀을.</target>
        </trans-unit>
        <trans-unit id="1e0837645e3fcc573d29accac038d64c469ddaf8" translate="yes" xml:space="preserve">
          <source>The following example sets the name of &lt;code&gt;my_config&lt;/code&gt; to &lt;code&gt;redis_config&lt;/code&gt; within the container, sets the mode to &lt;code&gt;0440&lt;/code&gt; (group-readable) and sets the user and group to &lt;code&gt;103&lt;/code&gt;. The &lt;code&gt;redis&lt;/code&gt; service does not have access to the &lt;code&gt;my_other_config&lt;/code&gt; config.</source>
          <target state="translated">다음 예제는 컨테이너 내에서 &lt;code&gt;my_config&lt;/code&gt; 의 이름 을 &lt;code&gt;redis_config&lt;/code&gt; 로 설정하고 모드를 &lt;code&gt;0440&lt;/code&gt; (그룹 읽기 가능)으로 설정하고 사용자 및 그룹을 &lt;code&gt;103&lt;/code&gt; 으로 설정합니다 . &lt;code&gt;redis&lt;/code&gt; 서비스는에 액세스 할 수 없습니다 &lt;code&gt;my_other_config&lt;/code&gt; 의 설정을.</target>
        </trans-unit>
        <trans-unit id="e6c9ffb891e37aec1140f9e04c47f3d25c956b59" translate="yes" xml:space="preserve">
          <source>The following example sets up a service with multiple placement preferences. Tasks are spread first over the various datacenters, and then over racks (as indicated by the respective labels):</source>
          <target state="translated">다음 예는 여러 게재 위치 환경 설정으로 서비스를 설정합니다. 작업은 먼저 다양한 데이터 센터에 분산 된 다음 랙에 분산됩니다 (각 레이블에 표시된대로).</target>
        </trans-unit>
        <trans-unit id="ddc395cc2f65ffce110b409fbfb09d97f9609f3a" translate="yes" xml:space="preserve">
          <source>The following example shows how to create a sample &lt;code&gt;plugin&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 샘플 &lt;code&gt;plugin&lt;/code&gt; 을 작성하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7ae3957799f337692f9bc9b28a6e2e2c634ffcc0" translate="yes" xml:space="preserve">
          <source>The following example shows how to push a sample &lt;code&gt;user/plugin&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 샘플 &lt;code&gt;user/plugin&lt;/code&gt; 를 푸시하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f81ed1c286e21dc1188ff9a6fb0987668305135a" translate="yes" xml:space="preserve">
          <source>The following example shows that the &lt;code&gt;sample-volume-plugin&lt;/code&gt; plugin is installed and enabled:</source>
          <target state="translated">다음 예제는 &lt;code&gt;sample-volume-plugin&lt;/code&gt; 플러그인이 설치되어 활성화되어 있음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5852f4e870d19346460239d94051ab30d075af83" translate="yes" xml:space="preserve">
          <source>The following example shows that the &lt;code&gt;sample-volume-plugin&lt;/code&gt; plugin is installed, but disabled:</source>
          <target state="translated">다음 예제는 &lt;code&gt;sample-volume-plugin&lt;/code&gt; 플러그인이 설치되었지만 비활성화 된 것을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="884f0bedd2eaaa130232ed33769aceea522058d0" translate="yes" xml:space="preserve">
          <source>The following example updates the number of replicas for the service from 4 to 5, and then rolls back to the previous configuration.</source>
          <target state="translated">다음 예제는 서비스의 복제본 수를 4에서 5로 업데이트 한 다음 이전 구성으로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="99a95c61d8e93bc7cab02ddeaaf85dc7ad465b73" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Container&lt;/code&gt; and &lt;code&gt;CPUPerc&lt;/code&gt; entries separated by a colon for all images:</source>
          <target state="translated">다음 예제에서는 헤더가없는 템플릿을 사용하고 모든 이미지에 대해 콜론으로 구분 된 &lt;code&gt;Container&lt;/code&gt; 및 &lt;code&gt;CPUPerc&lt;/code&gt; 항목을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="2a792120d0b9a1a451b8375e49426da3fb636d7a" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Command&lt;/code&gt; entries separated by a colon for all running containers:</source>
          <target state="translated">다음 예제에서는 헤더가없는 템플릿을 사용하고 실행중인 모든 컨테이너에 대해 콜론으로 구분 된 &lt;code&gt;ID&lt;/code&gt; 및 &lt;code&gt;Command&lt;/code&gt; 항목을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="c34a9ca7aa8333d80688cb47f375496e30fb62a3" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;CreatedSince&lt;/code&gt; entries separated by a colon for the &lt;code&gt;busybox&lt;/code&gt; image:</source>
          <target state="translated">다음 예제에서는 헤더없이 템플릿을 사용 하고 &lt;code&gt;busybox&lt;/code&gt; 이미지 의 콜론으로 구분 된 &lt;code&gt;ID&lt;/code&gt; 및 &lt;code&gt;CreatedSince&lt;/code&gt; 항목을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="9053190ef7a8482789c99b20dbfb533dfc395e2b" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Driver&lt;/code&gt; entries separated by a colon for all networks:</source>
          <target state="translated">다음 예제는 헤더가없는 템플릿을 사용하고 모든 네트워크에 대해 콜론으로 구분 된 &lt;code&gt;ID&lt;/code&gt; 및 &lt;code&gt;Driver&lt;/code&gt; 항목을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="0d3c21214705e5d6c9f771dca55ab75a5d739cda" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Name&lt;/code&gt; entries separated by a colon for all images:</source>
          <target state="translated">다음 예제는 헤더없이 템플릿을 사용하여 &lt;code&gt;ID&lt;/code&gt; 모든 이미지에 대해 콜론으로 구분 된 ID 및 &lt;code&gt;Name&lt;/code&gt; 항목을 .</target>
        </trans-unit>
        <trans-unit id="a79d89630514bb61b7a4ec4ec9fdc9ffefd497f7" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Name&lt;/code&gt; entries separated by a colon for all plugins:</source>
          <target state="translated">다음 예제는 헤더없이 템플릿을 사용하여 &lt;code&gt;ID&lt;/code&gt; 모든 플러그인에 대해 콜론으로 구분 된 ID 및 &lt;code&gt;Name&lt;/code&gt; 항목을 .</target>
        </trans-unit>
        <trans-unit id="804de291801d65c46987d10d9722e8e1597a61c7" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Repository&lt;/code&gt; entries separated by a colon for all images:</source>
          <target state="translated">다음 예제는 헤더없이 템플릿을 사용하여 &lt;code&gt;ID&lt;/code&gt; 모든 이미지에 대해 콜론으로 구분 된 ID 및 &lt;code&gt;Repository&lt;/code&gt; 항목을 .</target>
        </trans-unit>
        <trans-unit id="4f0930ce338dadf5495c9cc22ea15ee538bd074c" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;Hostname&lt;/code&gt;, and &lt;code&gt;TLS Status&lt;/code&gt; entries separated by a colon for all nodes:</source>
          <target state="translated">다음 예제는 헤더가없는 템플릿을 사용하고 &lt;code&gt;ID&lt;/code&gt; 를 출력합니다 . &lt;code&gt;Hostname&lt;/code&gt; 모든 노드에 대해 콜론으로 구분 된 호스트 이름 및 &lt;code&gt;TLS Status&lt;/code&gt; 항목을 .</target>
        </trans-unit>
        <trans-unit id="f139db89194cb2e0f5218bff4781bbaf174f7a38" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;Mode&lt;/code&gt;, and &lt;code&gt;Replicas&lt;/code&gt; entries separated by a colon for all services:</source>
          <target state="translated">다음 예제는 헤더가없는 템플릿을 사용하고 &lt;code&gt;ID&lt;/code&gt; 를 출력합니다 . &lt;code&gt;Mode&lt;/code&gt; 모든 서비스에 대해 콜론으로 구분 된 모드 및 &lt;code&gt;Replicas&lt;/code&gt; 항목을 .</target>
        </trans-unit>
        <trans-unit id="b8665cdaa79b1fbb23875fb4872bb3265da68042" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Driver&lt;/code&gt; entries separated by a colon for all running machines:</source>
          <target state="translated">다음 예제는 헤더없이 템플릿을 사용하고 &lt;code&gt;Name&lt;/code&gt; 을 출력합니다. 실행중인 모든 시스템에 대해 콜론으로 구분 된 및 &lt;code&gt;Driver&lt;/code&gt; 항목을 .</target>
        </trans-unit>
        <trans-unit id="72fecd4b8a0d3a98296aa22d178ffd98c1a2ed29" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Driver&lt;/code&gt; entries separated by a colon for all volumes:</source>
          <target state="translated">다음 예제는 헤더없이 템플릿을 사용하고 &lt;code&gt;Name&lt;/code&gt; 을 출력합니다. 모든 볼륨에 대해 콜론으로 구분 된 및 &lt;code&gt;Driver&lt;/code&gt; 항목을 .</target>
        </trans-unit>
        <trans-unit id="eedefcafa867fc51893471b85cafbed225dd74ee" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Image&lt;/code&gt; entries separated by a colon for all tasks:</source>
          <target state="translated">다음 예제는 헤더없이 템플릿을 사용하고 &lt;code&gt;Name&lt;/code&gt; 을 출력합니다. 모든 작업에 대해 콜론으로 구분 된 및 &lt;code&gt;Image&lt;/code&gt; 항목을 합니다.</target>
        </trans-unit>
        <trans-unit id="a607ab10c65e128911094483d04501824e7a3c19" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Services&lt;/code&gt; entries separated by a colon for all stacks:</source>
          <target state="translated">다음 예제에서는 헤더가없는 템플릿을 사용하고 모든 스택에 대해 콜론으로 구분 된 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Services&lt;/code&gt; 항목을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="27840da3b3c26b130c2393ce1a25742a883dfebd" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;StarCount&lt;/code&gt; entries separated by a colon for all images:</source>
          <target state="translated">다음 예제에서는 헤더가없는 템플릿을 사용하고 모든 이미지에 대해 콜론으로 구분 된 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;StarCount&lt;/code&gt; 항목을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="5097e4e285bcb4f61bbb1c5261ad561df449bf75" translate="yes" xml:space="preserve">
          <source>The following example uses the short syntax to grant the &lt;code&gt;redis&lt;/code&gt; service access to the &lt;code&gt;my_config&lt;/code&gt; and &lt;code&gt;my_other_config&lt;/code&gt; configs. The value of &lt;code&gt;my_config&lt;/code&gt; is set to the contents of the file &lt;code&gt;./my_config.txt&lt;/code&gt;, and &lt;code&gt;my_other_config&lt;/code&gt; is defined as an external resource, which means that it has already been defined in Docker, either by running the &lt;code&gt;docker config create&lt;/code&gt; command or by another stack deployment. If the external config does not exist, the stack deployment fails with a &lt;code&gt;config not found&lt;/code&gt; error.</source>
          <target state="translated">다음 예제는 짧은 구문을 사용하여 &lt;code&gt;redis&lt;/code&gt; 서비스에 &lt;code&gt;my_config&lt;/code&gt; 및 &lt;code&gt;my_other_config&lt;/code&gt; 구성에 대한 액세스 권한을 부여합니다 . &lt;code&gt;my_config&lt;/code&gt; 의 값은 &lt;code&gt;./my_config.txt&lt;/code&gt; 파일의 내용으로 설정 되고 &lt;code&gt;my_other_config&lt;/code&gt; 는 외부 자원으로 정의됩니다. 즉, &lt;code&gt;docker config create&lt;/code&gt; 명령을 실행하거나 다른 스택에 의해 Docker에서 이미 정의되어 있음을 의미합니다. 전개. 외부 구성이 존재하지 않으면 스택 배치가 &lt;code&gt;config not found&lt;/code&gt; 오류 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="edbdc0dd7768c9a4ffab0a305de18d34860216cf" translate="yes" xml:space="preserve">
          <source>The following example uses the short syntax to grant the &lt;code&gt;redis&lt;/code&gt; service access to the &lt;code&gt;my_secret&lt;/code&gt; and &lt;code&gt;my_other_secret&lt;/code&gt; secrets. The value of &lt;code&gt;my_secret&lt;/code&gt; is set to the contents of the file &lt;code&gt;./my_secret.txt&lt;/code&gt;, and &lt;code&gt;my_other_secret&lt;/code&gt; is defined as an external resource, which means that it has already been defined in Docker, either by running the &lt;code&gt;docker secret create&lt;/code&gt; command or by another stack deployment. If the external secret does not exist, the stack deployment fails with a &lt;code&gt;secret not found&lt;/code&gt; error.</source>
          <target state="translated">다음 예제는 짧은 구문을 사용하여 &lt;code&gt;redis&lt;/code&gt; 서비스에 &lt;code&gt;my_secret&lt;/code&gt; 및 &lt;code&gt;my_other_secret&lt;/code&gt; 비밀에 대한 액세스 권한을 부여합니다 . 값 &lt;code&gt;my_secret&lt;/code&gt; 이 파일의 내용으로 설정되어 &lt;code&gt;./my_secret.txt&lt;/code&gt; 및 &lt;code&gt;my_other_secret&lt;/code&gt; 는 어느 주행으로 이미 고정 표시기 정의되었음을 의미 외부 자원으로 정의되는 &lt;code&gt;docker secret create&lt;/code&gt; 명령 또는 다른 스택 전개. 외부 비밀이 존재하지 않으면 비밀 배치를 &lt;code&gt;secret not found&lt;/code&gt; 오류 와 함께 스택 배치가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="700f7f72c505a0cd991e4670f83883bf1ce0e178" translate="yes" xml:space="preserve">
          <source>The following example, illustrates a dangerous way to use the flag:</source>
          <target state="translated">다음 예제는 플래그를 사용하는 위험한 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="89c0412b4e8637f46684214f9bcf2b4a30f4e274" translate="yes" xml:space="preserve">
          <source>The following examples show bind mount syntax:</source>
          <target state="translated">다음 예제는 바인드 마운트 구문을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1e7cc6f5f98f421cfe718405a306f6462cbf3f4c" translate="yes" xml:space="preserve">
          <source>The following examples will fail when using Windows-based containers, as the destination of a volume or bind mount inside the container must be one of: a non-existing or empty directory; or a drive other than C:. Further, the source of a bind mount must be a local directory, not a file.</source>
          <target state="translated">컨테이너 내의 볼륨 또는 바인드 마운트 대상은 존재하지 않거나 비어있는 디렉토리 중 하나 여야하므로 Windows 기반 컨테이너를 사용할 때 다음 예제는 실패합니다. 또는 C : 이외의 드라이브 또한 바인드 마운트의 소스는 파일이 아닌 로컬 디렉토리 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7f19f64e11cd93069667bbfd55960c6a2ddbbdd1" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers that are connected to a network with a name containing &lt;code&gt;net1&lt;/code&gt;.</source>
          <target state="translated">다음 필터는 이름이 &lt;code&gt;net1&lt;/code&gt; 인 네트워크에 연결된 모든 컨테이너를 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="800e886868cfa732f164d0182de8422c8e649e13" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers that have exposed TCP port in the range of &lt;code&gt;8000-8080&lt;/code&gt;:</source>
          <target state="translated">다음 필터는 &lt;code&gt;8000-8080&lt;/code&gt; 범위의 TCP 포트를 노출 한 모든 컨테이너와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="07ea30f7ec788e0e5ca1c99051771631a91c5e82" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers that have exposed UDP port &lt;code&gt;80&lt;/code&gt;:</source>
          <target state="translated">다음 필터는 UDP 포트 &lt;code&gt;80&lt;/code&gt; 을 노출 한 모든 컨테이너와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="15fd706a88462118bd357b932c54f13e0615f52c" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers that have published port of 80:</source>
          <target state="translated">다음 필터는 포트 80을 게시 한 모든 컨테이너와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1e4d3cb6490f16b07bc00af218867d1488effaf6" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers with a name containing the &lt;code&gt;nostalgic_stallman&lt;/code&gt; string.</source>
          <target state="translated">다음 필터는 &lt;code&gt;nostalgic_stallman&lt;/code&gt; 문자열을 포함하는 이름을 가진 모든 컨테이너를 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="25cb2d40a8b8244e76b46bc97aff980f8b372f1a" translate="yes" xml:space="preserve">
          <source>The following filter matches all networks with a name containing the &lt;code&gt;foobar&lt;/code&gt; string.</source>
          <target state="translated">다음 필터는 &lt;code&gt;foobar&lt;/code&gt; 문자열을 포함하는 이름으로 모든 네트워크를 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="74560278c6c44f13fcb3eaaf5e9b566f270ef9d7" translate="yes" xml:space="preserve">
          <source>The following filter matches all networks with an ID containing the &lt;code&gt;63d1ff1f77b0...&lt;/code&gt; string.</source>
          <target state="translated">다음 필터는 &lt;code&gt;63d1ff1f77b0...&lt;/code&gt; 문자열을 포함하는 ID로 모든 네트워크를 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="b664a6dc08d148cd14a3d5a10883f3f6253a5b12" translate="yes" xml:space="preserve">
          <source>The following filter matches all secrets with a &lt;code&gt;project&lt;/code&gt; label regardless of its value:</source>
          <target state="translated">다음 필터 는 값에 관계없이 모든 비밀을 &lt;code&gt;project&lt;/code&gt; 레이블 과 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="6bf325e14afdfeb070566c7cb8408f19be850830" translate="yes" xml:space="preserve">
          <source>The following filter matches all services with a &lt;code&gt;project&lt;/code&gt; label regardless of its value:</source>
          <target state="translated">다음 필터 는 값에 관계없이 모든 서비스를 &lt;code&gt;project&lt;/code&gt; 레이블 과 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="377c5cebf1a800ec740bab4e255ece52bcd5502c" translate="yes" xml:space="preserve">
          <source>The following filter matches all tasks with a name containing the &lt;code&gt;redis&lt;/code&gt; string.</source>
          <target state="translated">다음 필터는 &lt;code&gt;redis&lt;/code&gt; 문자열을 포함하는 이름으로 모든 작업을 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f6adbe9e7302ddb4e65fe46ef26fc7737fa9efc6" translate="yes" xml:space="preserve">
          <source>The following filter matches all user defined networks:</source>
          <target state="translated">다음 필터는 모든 사용자 정의 네트워크와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e0e789cbca67054d34bb67e75d18c65067c0090f" translate="yes" xml:space="preserve">
          <source>The following filter matches all volumes with a name containing the &lt;code&gt;rose&lt;/code&gt; string.</source>
          <target state="translated">다음 필터는 모든 볼륨을 &lt;code&gt;rose&lt;/code&gt; 문자열이 포함 된 이름과 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="333929673e07bb3910786d16dc8890e7af897ae5" translate="yes" xml:space="preserve">
          <source>The following filter matches containers with the &lt;code&gt;color&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">다음 필터 는 값에 관계없이 컨테이너를 &lt;code&gt;color&lt;/code&gt; 레이블 과 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="287065c5f990a604ba29bf8f28ec863ce71f474a" translate="yes" xml:space="preserve">
          <source>The following filter matches containers with the &lt;code&gt;color&lt;/code&gt; label with the &lt;code&gt;blue&lt;/code&gt; value.</source>
          <target state="translated">다음 필터는 &lt;code&gt;color&lt;/code&gt; 레이블이있는 컨테이너를 &lt;code&gt;blue&lt;/code&gt; 값 과 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a55d9b8aa17bf7ea4bcc95ca05e971410dd1c999" translate="yes" xml:space="preserve">
          <source>The following filter matches images with the &lt;code&gt;com.example.version&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">다음 필터 는 값에 관계없이 이미지를 &lt;code&gt;com.example.version&lt;/code&gt; 레이블 과 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="9308f1b2567a263989225a707e87d9f43669990b" translate="yes" xml:space="preserve">
          <source>The following filter matches images with the &lt;code&gt;com.example.version&lt;/code&gt; label with the &lt;code&gt;1.0&lt;/code&gt; value.</source>
          <target state="translated">다음 필터는 &lt;code&gt;com.example.version&lt;/code&gt; 레이블이있는 이미지와 &lt;code&gt;1.0&lt;/code&gt; 값을 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="81c15752312e03a6c5a55cd6e5284d7d5de8e547" translate="yes" xml:space="preserve">
          <source>The following filter matches networks with the &lt;code&gt;usage&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">다음 필터 는 값에 관계없이 &lt;code&gt;usage&lt;/code&gt; 레이블 과 네트워크를 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="342327877e58e3c8eafe26ccb4de7e7111b5b529" translate="yes" xml:space="preserve">
          <source>The following filter matches networks with the &lt;code&gt;usage&lt;/code&gt; label with the &lt;code&gt;prod&lt;/code&gt; value.</source>
          <target state="translated">다음 필터 는 &lt;code&gt;prod&lt;/code&gt; 값을 가진 &lt;code&gt;usage&lt;/code&gt; 레이블이있는 네트워크를 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1bfe9f9a5aba90f02fb92c52e07d997aad516d99" translate="yes" xml:space="preserve">
          <source>The following filter matches nodes with the &lt;code&gt;foo&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">다음 필터 는 값에 관계없이 &lt;code&gt;foo&lt;/code&gt; 레이블 이있는 노드를 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="831f1c4b12005720b96b4a2eca523b0715c5f7cf" translate="yes" xml:space="preserve">
          <source>The following filter matches nodes with the &lt;code&gt;manager&lt;/code&gt; role.</source>
          <target state="translated">다음 필터는 노드를 &lt;code&gt;manager&lt;/code&gt; 역할 과 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5d5928dc77f9ac8f51a5bf3a491007d5cb959aa9" translate="yes" xml:space="preserve">
          <source>The following filter matches nodes with the &lt;code&gt;membership&lt;/code&gt; of &lt;code&gt;accepted&lt;/code&gt;.</source>
          <target state="translated">다음 필터는와 노드와 일치 &lt;code&gt;membership&lt;/code&gt; 의 &lt;code&gt;accepted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cae334a9403125be8e105d77b121e928b810cb0d" translate="yes" xml:space="preserve">
          <source>The following filter matches only &lt;code&gt;global&lt;/code&gt; services.</source>
          <target state="translated">다음 필터는 &lt;code&gt;global&lt;/code&gt; 서비스 에만 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="71b96abf9c912452dccc5fc2d078ff7d724074bf" translate="yes" xml:space="preserve">
          <source>The following filter matches only services with the &lt;code&gt;project&lt;/code&gt; label with the &lt;code&gt;project-a&lt;/code&gt; value.</source>
          <target state="translated">다음 필터는 &lt;code&gt;project&lt;/code&gt; 레이블이 &lt;code&gt;project-a&lt;/code&gt; 값인 서비스 만 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="d589708b36e77b120b1eb37f5b3855633a489266" translate="yes" xml:space="preserve">
          <source>The following filter matches secret with a name containing a prefix of &lt;code&gt;test&lt;/code&gt;.</source>
          <target state="translated">다음 필터는 접두어 &lt;code&gt;test&lt;/code&gt; 가 포함 된 이름과 secret을 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="51f41d32e59f1be3db1713960110b6924fa71193" translate="yes" xml:space="preserve">
          <source>The following filter matches services with a name containing &lt;code&gt;redis&lt;/code&gt;.</source>
          <target state="translated">다음 필터는 이름이 &lt;code&gt;redis&lt;/code&gt; 인 서비스와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d06c94f037f10c7f3edd2ff9c61b81881e819a03" translate="yes" xml:space="preserve">
          <source>The following filter matches tasks with the &lt;code&gt;usage&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">다음 필터 는 값에 관계없이 &lt;code&gt;usage&lt;/code&gt; 레이블 이있는 작업을 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="af809a75960cb0ab861cb2b30735a0d65c64aa88" translate="yes" xml:space="preserve">
          <source>The following filter matches the nodes with a name equal to &lt;code&gt;swarm-master&lt;/code&gt; string.</source>
          <target state="translated">다음 필터는 &lt;code&gt;swarm-master&lt;/code&gt; 문자열 과 이름이 같은 노드를 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="2791d823738fc796e3aff5cac56fe1c0dc58c276" translate="yes" xml:space="preserve">
          <source>The following flags are supported:</source>
          <target state="translated">다음과 같은 플래그가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1ba2ceab8147a44173e52004a7d49f0cf956ab1a" translate="yes" xml:space="preserve">
          <source>The following illustrates a configuration with custom certificates:</source>
          <target state="translated">다음은 사용자 정의 인증서가있는 구성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cdd40803f742cb5b009b755a1dfe76bf10cfc698" translate="yes" xml:space="preserve">
          <source>The following image depicts the various signing keys and their relationships:</source>
          <target state="translated">다음 이미지는 다양한 서명 키와 그 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="352e506ead5abd1cae6bbdfa70483c6c355b9774" translate="yes" xml:space="preserve">
          <source>The following instructions can be affected by the &lt;code&gt;SHELL&lt;/code&gt; instruction when the &lt;em&gt;shell&lt;/em&gt; form of them is used in a Dockerfile: &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt; and &lt;code&gt;ENTRYPOINT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SHELL&lt;/code&gt; 명령의 &lt;em&gt;쉘&lt;/em&gt; 양식이 Dockerfile에 사용될 때 SHELL 명령의 영향을받을 수있는 명령은 &lt;code&gt;RUN&lt;/code&gt; , &lt;code&gt;CMD&lt;/code&gt; 및 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1530583c09c98f904de912a6701d7304d51b5c33" translate="yes" xml:space="preserve">
          <source>The following is an example adding 2 runtimes via the configuration:</source>
          <target state="translated">다음은 구성을 통해 2 개의 런타임을 추가하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="90af25db82c012aee8c9941342b7fd06be7e8128" translate="yes" xml:space="preserve">
          <source>The following is an example of docker build with &lt;code&gt;--squash&lt;/code&gt; argument</source>
          <target state="translated">다음은 &lt;code&gt;--squash&lt;/code&gt; 인수를 사용하는 docker build의 예입니다.</target>
        </trans-unit>
        <trans-unit id="ddd205b6626f4c3147db765c896821f29986b142" translate="yes" xml:space="preserve">
          <source>The following is an example usage:</source>
          <target state="translated">다음은 사용법 예입니다.</target>
        </trans-unit>
        <trans-unit id="679caa8ac3b309f79951e6369db67f2ba236eef1" translate="yes" xml:space="preserve">
          <source>The following list of features are deprecated in Engine. To learn more about Docker Engine&amp;rsquo;s deprecation policy, see &lt;a href=&quot;../index#feature-deprecation-policy&quot;&gt;Feature Deprecation Policy&lt;/a&gt;.</source>
          <target state="translated">다음 기능 목록은 엔진에서 더 이상 사용되지 않습니다. Docker Engine의 지원 중단 정책에 대한 자세한 내용은 &lt;a href=&quot;../index#feature-deprecation-policy&quot;&gt;기능&lt;/a&gt; 지원 중단 정책을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64c0fd6330bb4fe27c1e99d4cbe6591be24268cc" translate="yes" xml:space="preserve">
          <source>The following matches containers based on the layer &lt;code&gt;d0e008c6cf02&lt;/code&gt; or an image that have this layer in its layer stack.</source>
          <target state="translated">다음은 레이어 &lt;code&gt;d0e008c6cf02&lt;/code&gt; 또는 레이어 스택에이 레이어가있는 이미지를 기반으로하는 컨테이너와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="bd05d4ce6012ea3e96f3277ce3e558e06a24423a" translate="yes" xml:space="preserve">
          <source>The following options can only be used for bind mounts (&lt;code&gt;type=bind&lt;/code&gt;):</source>
          <target state="translated">다음 옵션은 바인드 마운트 ( &lt;code&gt;type=bind&lt;/code&gt; ) 에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cea3dc98beed9105761d1cfaaea9c4b21e0e47cf" translate="yes" xml:space="preserve">
          <source>The following options can only be used for named volumes (&lt;code&gt;type=volume&lt;/code&gt;):</source>
          <target state="translated">다음 옵션은 명명 된 볼륨 ( &lt;code&gt;type=volume&lt;/code&gt; ) 에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39bd07dcb7784b47d42d9d00b3b6828077c80e7a" translate="yes" xml:space="preserve">
          <source>The following options can only be used for tmpfs mounts (&lt;code&gt;type=tmpfs&lt;/code&gt;);</source>
          <target state="translated">다음 옵션은 tmpfs 마운트에만 사용할 수 있습니다 ( &lt;code&gt;type=tmpfs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd1b04f078db2f9a2a6553fdded57f5727f9750d" translate="yes" xml:space="preserve">
          <source>The following pages describe the usage information for the &lt;a href=&quot;overview/index&quot;&gt;docker-compose&lt;/a&gt; subcommands. You can also see this information by running &lt;code&gt;docker-compose [SUBCOMMAND] --help&lt;/code&gt; from the command line.</source>
          <target state="translated">다음 페이지는 &lt;a href=&quot;overview/index&quot;&gt;docker-compose&lt;/a&gt; 하위 명령 의 사용법 정보를 설명합니다 . 명령 행에서 &lt;code&gt;docker-compose [SUBCOMMAND] --help&lt;/code&gt; 를 실행하여이 정보를 볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc364422c59019db7e4caaa1bcce2d190b0a4ced" translate="yes" xml:space="preserve">
          <source>The following parser directives are supported:</source>
          <target state="translated">다음과 같은 파서 지시문이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ee1ca432f62944696342ff92fbc385c17290cb85" translate="yes" xml:space="preserve">
          <source>The following ports must be available. On some systems, these ports are open by default.</source>
          <target state="translated">다음 포트가 사용 가능해야합니다. 일부 시스템에서는이 포트가 기본적으로 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a06f0ecc09621b84e84a7621d8f9b7b0ea89d01" translate="yes" xml:space="preserve">
          <source>The following removes containers created before &lt;code&gt;2017-01-04T13:10:00&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;2017-01-04T13:10:00&lt;/code&gt; 이전에 생성 된 컨테이너를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="a5383a9d9670f9fdcac5ef218e29b45584acf08d" translate="yes" xml:space="preserve">
          <source>The following removes containers created more than 5 minutes ago:</source>
          <target state="translated">다음은 5 분 이상 전에 작성된 컨테이너를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="202bf18e4819e0fe8e3548e75a0fa6fea50dae22" translate="yes" xml:space="preserve">
          <source>The following removes images created before &lt;code&gt;2017-01-04T00:00:00&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;2017-01-04T00:00:00&lt;/code&gt; 이전에 생성 된 이미지를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="01bf49080ffa5c29f8ac4d7b93c3575d2fc4a323" translate="yes" xml:space="preserve">
          <source>The following removes images created more than 10 days (&lt;code&gt;240h&lt;/code&gt;) ago:</source>
          <target state="translated">다음은 10 일 ( &lt;code&gt;240h&lt;/code&gt; ) 전에 생성 된 이미지를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="d46d20f52659f2d385980b8dc19d20edf5adca1a" translate="yes" xml:space="preserve">
          <source>The following removes networks created more than 5 minutes ago. Note that system networks such as &lt;code&gt;bridge&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt;, and &lt;code&gt;none&lt;/code&gt; will never be pruned:</source>
          <target state="translated">다음은 5 분 이상 전에 작성된 네트워크를 제거합니다. &lt;code&gt;bridge&lt;/code&gt; , &lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;none&lt;/code&gt; 과 같은 시스템 네트워크 는 정리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7021eb31e260a4ca6fc6f6f26bc884d3533e40f" translate="yes" xml:space="preserve">
          <source>The following sections illustrate ways to use this command.</source>
          <target state="translated">다음 섹션에서는이 명령을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="afdb57289147fd04a4ba308a16d159524fbc3492" translate="yes" xml:space="preserve">
          <source>The following sections provide details about service configuration. This topic does not cover every flag or scenario. In almost every instance where you can define a configuration at service creation, you can also update an existing service&amp;rsquo;s configuration in a similar way.</source>
          <target state="translated">다음 섹션에서는 서비스 구성에 대한 세부 사항을 제공합니다. 이 주제는 모든 플래그 또는 시나리오를 다루지는 않습니다. 서비스 생성시 구성을 정의 할 수있는 거의 모든 인스턴스에서 유사한 방식으로 기존 서비스 구성을 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb72a975dadb1beb00c0c5a8ab9b701acb1be71" translate="yes" xml:space="preserve">
          <source>The following service&amp;rsquo;s containers have an environment variable &lt;code&gt;$MYVAR&lt;/code&gt; set to &lt;code&gt;myvalue&lt;/code&gt;, run from the &lt;code&gt;/tmp/&lt;/code&gt; directory, and run as the &lt;code&gt;my_user&lt;/code&gt; user.</source>
          <target state="translated">다음 서비스의 용기는 환경 변수가 &lt;code&gt;$MYVAR&lt;/code&gt; 로 설정 &lt;code&gt;myvalue&lt;/code&gt; 으로부터 실행 &lt;code&gt;/tmp/&lt;/code&gt; 디렉토리를, 그리고로 실행 &lt;code&gt;my_user&lt;/code&gt; 의 사용자.</target>
        </trans-unit>
        <trans-unit id="0ab0d241a851d150a626e3f1ab1b7b1212496ed2" translate="yes" xml:space="preserve">
          <source>The following simple example retrieves the gMSA name and JSON contents from your Active Directory (AD) instance:</source>
          <target state="translated">다음 간단한 예는 AD (Active Directory) 인스턴스에서 gMSA 이름과 JSON 내용을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="38079e33d70456cc78ac6a52b32f01a2f427e7f7" translate="yes" xml:space="preserve">
          <source>The following single-dash (&lt;code&gt;-opt&lt;/code&gt;) variant of certain command line options are deprecated and replaced with double-dash options (&lt;code&gt;--opt&lt;/code&gt;):</source>
          <target state="translated">특정 명령 행 옵션 의 다음 단일 대시 ( &lt;code&gt;-opt&lt;/code&gt; ) 변형은 더 이상 사용되지 않으며 이중 대시 옵션 ( &lt;code&gt;--opt&lt;/code&gt; )으로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a9d899e8a7c4ecbad3f9d3cdace6b7d2cb28d82" translate="yes" xml:space="preserve">
          <source>The following standard Docker features are incompatible with running a Docker daemon with user namespaces enabled:</source>
          <target state="translated">다음 표준 Docker 기능은 사용자 네임 스페이스가 활성화 된 Docker 데몬 실행과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ceab97b073bdd541ffd2040b147c10ea3c77a29f" translate="yes" xml:space="preserve">
          <source>The following sub-options (supported for &lt;code&gt;docker-compose up&lt;/code&gt; and &lt;code&gt;docker-compose run&lt;/code&gt;) are &lt;em&gt;not supported&lt;/em&gt; for &lt;code&gt;docker stack deploy&lt;/code&gt; or the &lt;code&gt;deploy&lt;/code&gt; key.</source>
          <target state="translated">(지원 다음 하위 옵션 &lt;code&gt;docker-compose up&lt;/code&gt; 및 &lt;code&gt;docker-compose run&lt;/code&gt; )하는 &lt;em&gt;지원되지 않습니다&lt;/em&gt; 에 대한 &lt;code&gt;docker stack deploy&lt;/code&gt; 또는 &lt;code&gt;deploy&lt;/code&gt; 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="a512515c3c3198b7df3ff59809648ff2c8837053" translate="yes" xml:space="preserve">
          <source>The following table describes options which apply to both bind mounts and named volumes in a service:</source>
          <target state="translated">다음 표는 서비스의 바인드 마운트와 이름 지정된 볼륨 모두에 적용되는 옵션을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="97af8835fb1b0d42baf566cddbcbd484b22e0273" translate="yes" xml:space="preserve">
          <source>The following table represents all the valid suffixes with their build contexts:</source>
          <target state="translated">다음 표는 모든 유효한 접미사와 해당 빌드 컨텍스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50973c531dcf0fca5d800927b2bb86570dc6d0d2" translate="yes" xml:space="preserve">
          <source>The following topics are available:</source>
          <target state="translated">다음과 같은 주제를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92203c1f68f879df757bddd6ad2f3fdfa59c581" translate="yes" xml:space="preserve">
          <source>The following values are accepted:</source>
          <target state="translated">다음 값이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d23ee3675fec03d4201ad5d2868adb69fbb5b7cc" translate="yes" xml:space="preserve">
          <source>The format of the command is:</source>
          <target state="translated">명령 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b9473095568a70fbc515fca5a0c0de6d7b7304b" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty prints container output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 컨테이너 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c90b205d5d057562cc93124ef1fb067815c006a8" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty prints secrets output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 비밀 출력을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1e5fb6599ab24fd4faffd8e8e434811f64c4a751" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty-prints container output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 컨테이너 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1e114329ca4f7454a532ed757c39d973cba22e9d" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty-prints machines using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 컴퓨터를 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4cecb8823d0ae5d7ce668900da8f03c68d247526" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty-prints search output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 검색 결과를 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9a7c2de2b27bbeda9fbf4be2fff41c1c922774e7" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty-prints stacks using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 스택을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="48e15b8c4939c370c3bb6974bca1dc0fcff7af41" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) will pretty print container output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 컨테이너 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6132c3a006eb8cedb324f2bffedcbf9e0fcc1405" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) will pretty-prints history output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 기록 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="24b5cac13ad3ca9432388011779d2d67c8c0d7ff" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints networks output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 네트워크 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f383ba453be785051b7c5611493a2ff002cfda87" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints nodes output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 노드 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4fac954b380cf768ad87c1f69c92adba5a56b9ee" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints plugins output using a Go template.</source>
          <target state="translated">형식화 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플리트를 사용하여 플러그인 출력을 pretty-prints합니다.</target>
        </trans-unit>
        <trans-unit id="a5b662551ceb72817b0d9d973a68e9e4c8e129c8" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints services output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 서비스 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="67076d11d977bc7a1dcefe49045e4eae2c6c8f21" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints tasks output using a Go template.</source>
          <target state="translated">서식 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 작업 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a63922a8194d1ad1d264b55c3eca84dfc755a202" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints volumes output using a Go template.</source>
          <target state="translated">포맷 옵션 ( &lt;code&gt;--format&lt;/code&gt; )은 Go 템플릿을 사용하여 볼륨 출력을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2478ba4d66a52065d825d802915cb3a4ef902b9b" translate="yes" xml:space="preserve">
          <source>The functionality described on this page is marked as Experimental, and as such, may change before it becomes generally available.</source>
          <target state="translated">이 페이지에 설명 된 기능은 실험용으로 표시되어 있으며 일반적으로 사용 가능해지기 전에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53df056b93586ddb8659e1d397c9782f60693b8e" translate="yes" xml:space="preserve">
          <source>The general format is shown here.</source>
          <target state="translated">일반적인 형식이 여기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="275c8aaaaa26e22f95d5301cc3b55ac3cdec446d" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;-D&lt;/code&gt; option causes all &lt;code&gt;docker&lt;/code&gt; commands to output debug information.</source>
          <target state="translated">global &lt;code&gt;-D&lt;/code&gt; 옵션은 모든 &lt;code&gt;docker&lt;/code&gt; 명령이 디버그 정보를 출력하게합니다.</target>
        </trans-unit>
        <trans-unit id="6ad7d09f09c6ebab4bee47e20efdb157b4305cec" translate="yes" xml:space="preserve">
          <source>The hard part is over. Now you just repeat the process you used in &lt;a href=&quot;../part3/index&quot;&gt;part 3&lt;/a&gt; to deploy on your new swarm. Just remember that only swarm managers like &lt;code&gt;myvm1&lt;/code&gt; execute Docker commands; workers are just for capacity.</source>
          <target state="translated">어려운 부분은 끝났습니다. 이제 &lt;a href=&quot;../part3/index&quot;&gt;3 부&lt;/a&gt; 에서 사용한 프로세스를 반복 하여 새 떼에 배포합니다. &lt;code&gt;myvm1&lt;/code&gt; 과 같은 스웜 관리자 만 Docker 명령을 실행 한다는 것을 기억하십시오 . 노동자는 단지 능력을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a17f01abd893e1c6c4a0f1c0bf80ec053a99aa9" translate="yes" xml:space="preserve">
          <source>The health check will first run &lt;strong&gt;interval&lt;/strong&gt; seconds after the container is started, and then again &lt;strong&gt;interval&lt;/strong&gt; seconds after each previous check completes.</source>
          <target state="translated">상태 확인은 컨테이너가 시작된 후 먼저 &lt;strong&gt;간격 (&lt;/strong&gt; 초)을 실행 한 다음 이전의 각 확인이 완료된 후 다시 &lt;strong&gt;간격 (&lt;/strong&gt; 초)을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="50587757d59b1045d03cb2b55f5bd32ec2daecbc" translate="yes" xml:space="preserve">
          <source>The health status is also displayed in the &lt;code&gt;docker ps&lt;/code&gt; output.</source>
          <target state="translated">상태는 &lt;code&gt;docker ps&lt;/code&gt; 출력 에도 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a44e290ddaf714a047442f22669818b2b8934cc6" translate="yes" xml:space="preserve">
          <source>The helpers always use the first argument in the command to identify the action. There are only three possible values for that argument: &lt;code&gt;store&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, and &lt;code&gt;erase&lt;/code&gt;.</source>
          <target state="translated">헬퍼는 항상 명령의 첫 번째 인수를 사용하여 조치를 식별합니다. 해당 인수에 대해 가능한 값은 세 가지뿐입니다 : &lt;code&gt;store&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;erase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49e3d75f86bffa0f3dc84c1b532153407879db50" translate="yes" xml:space="preserve">
          <source>The hostname associated with the container</source>
          <target state="translated">컨테이너와 관련된 호스트 이름</target>
        </trans-unit>
        <trans-unit id="24b249127db194475ad1fa29636e81e19aba196a" translate="yes" xml:space="preserve">
          <source>The hostname of the remote trust service</source>
          <target state="translated">원격 트러스트 서비스의 호스트 이름</target>
        </trans-unit>
        <trans-unit id="bc8d4004d9c5c0b1afc9e1c0ff064322235cdc74" translate="yes" xml:space="preserve">
          <source>The image manifest &lt;a href=&quot;https://github.com/docker/distribution/blob/fda42e5ef908bdba722d435ff1f330d40dfcd56c/docs/spec/manifest-v2-1/&quot;&gt;v2 schema 1&lt;/a&gt; format is deprecated in favor of the &lt;a href=&quot;https://github.com/docker/distribution/blob/fda42e5ef908bdba722d435ff1f330d40dfcd56c/docs/spec/manifest-v2-2/&quot;&gt;v2 schema 2&lt;/a&gt; format.</source>
          <target state="translated">이미지 매니페스트 &lt;a href=&quot;https://github.com/docker/distribution/blob/fda42e5ef908bdba722d435ff1f330d40dfcd56c/docs/spec/manifest-v2-1/&quot;&gt;v2 스키마 1&lt;/a&gt; 형식은 &lt;a href=&quot;https://github.com/docker/distribution/blob/fda42e5ef908bdba722d435ff1f330d40dfcd56c/docs/spec/manifest-v2-2/&quot;&gt;v2 스키마 2&lt;/a&gt; 형식 을 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="95437efa4b2f4d528cee5344d23a48586427b1cb" translate="yes" xml:space="preserve">
          <source>The image that the service runs. Docker images should be referenced with full content hash to fully specify the deployment artifact for the service. Example: &lt;code&gt;postgres@sha256:e0a230a9f5b4e1b8b03bb3e8cf7322b0e42b7838c5c87f4545edb48f5eb8f077&lt;/code&gt;</source>
          <target state="translated">서비스가 실행하는 이미지입니다. Docker 이미지는 전체 컨텐츠 해시로 참조되어 서비스의 배치 아티팩트를 완전히 지정해야합니다. 예 : &lt;code&gt;postgres@sha256:e0a230a9f5b4e1b8b03bb3e8cf7322b0e42b7838c5c87f4545edb48f5eb8f077&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c2247e031dafb7acba700a626e657e0cfe4cdcf" translate="yes" xml:space="preserve">
          <source>The implementation of the consensus algorithm in swarm mode means it features the properties inherent to distributed systems:</source>
          <target state="translated">swarm 모드에서 합의 알고리즘을 구현한다는 것은 분산 시스템 고유의 속성을 특징으로합니다.</target>
        </trans-unit>
        <trans-unit id="9c31e09abe96c3782c39594f852fa5e18a0ad156" translate="yes" xml:space="preserve">
          <source>The instruction is not case-sensitive. However, convention is for them to be UPPERCASE to distinguish them from arguments more easily.</source>
          <target state="translated">명령은 대소 문자를 구분하지 않습니다. 그러나 관례는 그것들을 인수와보다 쉽게 ​​구별하기 위해 대문자로하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="432ac2568e57f2999351cf4730fe1a622e719e5b" translate="yes" xml:space="preserve">
          <source>The instructions below outline installation of the current stable release (&lt;strong&gt;v1.24.1&lt;/strong&gt;) of Compose. To install a different version of Compose, replace the given release number with the one that you want. Compose releases are also listed and available for direct download on the &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;Compose repository release page on GitHub&lt;/a&gt;. To install a &lt;strong&gt;pre-release&lt;/strong&gt; of Compose, refer to the &lt;a href=&quot;#install-pre-release-builds&quot;&gt;install pre-release builds&lt;/a&gt; section.</source>
          <target state="translated">아래 지시 사항 은 Compose 의 현재 안정 릴리스 ( &lt;strong&gt;v1.24.1&lt;/strong&gt; ) 설치를 &lt;strong&gt;요약&lt;/strong&gt; 합니다. 다른 버전의 Compose를 설치하려면 제공된 릴리스 번호를 원하는 버전으로 바꾸십시오. 작성 릴리스는 &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;GitHub&lt;/a&gt; 의 작성 저장소 릴리스 페이지에 나열되어 있으며 직접 다운로드 할 수도 있습니다 . Compose &lt;strong&gt;시험판&lt;/strong&gt; 을 설치하려면 &lt;a href=&quot;#install-pre-release-builds&quot;&gt;시험판 빌드 설치&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a728e9ba163d13c002fa9cbc101bd55bb3117d98" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;secrets:&lt;/code&gt; defines two secrets &lt;code&gt;db_password:&lt;/code&gt; and &lt;code&gt;db_root_password:&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;secrets:&lt;/code&gt; 는 두 가지 비밀 &lt;code&gt;db_password:&lt;/code&gt; 및 &lt;code&gt;db_root_password:&lt;/code&gt; 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f38f01c9dd04c1cf0aaafe08aeddca4be0e7e775" translate="yes" xml:space="preserve">
          <source>The label-file format is similar to the format for loading environment variables. (Unlike environment variables, labels are not visible to processes running inside a container.) The following example illustrates a label-file format:</source>
          <target state="translated">레이블 파일 형식은 환경 변수로드 형식과 유사합니다. 환경 변수와 달리 레이블은 컨테이너 내에서 실행중인 프로세스에 표시되지 않습니다. 다음 예제는 레이블 파일 형식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b061ec279352905ba71ef5544860362f98c44798" translate="yes" xml:space="preserve">
          <source>The labels you set for nodes using &lt;code&gt;docker node update&lt;/code&gt; apply only to the node entity within the swarm. Do not confuse them with the docker daemon labels for &lt;a href=&quot;https://docs.docker.com/config#daemon-labels&quot;&gt;dockerd&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker node update&lt;/code&gt; 사용하여 노드에 설정 한 레이블 은 스웜 내의 노드 엔터티에만 적용됩니다. 그것들을 &lt;a href=&quot;https://docs.docker.com/config#daemon-labels&quot;&gt;dockerd&lt;/a&gt; 의 docker 데몬 레이블과 혼동하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="00c354608645937cfbba945cdf048bbd0c24872e" translate="yes" xml:space="preserve">
          <source>The labels you set for nodes using docker node update apply only to the node entity within the swarm. Do not confuse them with the docker daemon labels for &lt;a href=&quot;https://docs.docker.com/config#daemon-labels&quot;&gt;dockerd&lt;/a&gt;.</source>
          <target state="translated">도커 노드 업데이트를 사용하여 노드에 설정 한 레이블은 스웜 내의 노드 엔터티에만 적용됩니다. 그것들을 &lt;a href=&quot;https://docs.docker.com/config#daemon-labels&quot;&gt;dockerd&lt;/a&gt; 의 docker 데몬 레이블과 혼동하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="a43092dff37282e5d580b06cc9c9a241636d4555" translate="yes" xml:space="preserve">
          <source>The last argument is set to &lt;code&gt;-&lt;/code&gt;, which indicates that the input is read from standard input.</source>
          <target state="translated">마지막 인수는 &lt;code&gt;-&lt;/code&gt; 로 설정되어 표준 입력에서 입력을 읽음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f88ec5c1efa88b85aa9dbdbf3b9ef1192d7e39a6" translate="yes" xml:space="preserve">
          <source>The legacy &lt;code&gt;overlay&lt;/code&gt; storage driver allowed using overlayFS-backed filesystems on pre 4.x kernels. Now that all supported distributions are able to run &lt;code&gt;overlay2&lt;/code&gt; (as they are either on kernel 4.x, or have support for multiple lowerdirs backported), there is no reason to keep maintaining the &lt;code&gt;overlay&lt;/code&gt; storage driver.</source>
          <target state="translated">레거시 &lt;code&gt;overlay&lt;/code&gt; 스토리지 드라이버는 4.x 이전 커널에서 overlayFS 지원 파일 시스템을 사용하도록 허용했습니다. 지원되는 모든 배포판이 &lt;code&gt;overlay2&lt;/code&gt; 를 실행할 수 있으므로 (커널 4.x에서 또는 여러 하위 디렉토리를 백 포트 한 것처럼) &lt;code&gt;overlay&lt;/code&gt; 저장소 드라이버 를 계속 유지할 이유가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="72ca0136842dab10471332313be4ade3373c948b" translate="yes" xml:space="preserve">
          <source>The list of currently supported feature options:</source>
          <target state="translated">현재 지원되는 기능 옵션 목록 :</target>
        </trans-unit>
        <trans-unit id="d3c8c2e1de66029817dafcb63fc75fe2dc499fd0" translate="yes" xml:space="preserve">
          <source>The list of currently supported options that can be reconfigured is this:</source>
          <target state="translated">재구성 할 수있는 현재 지원되는 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e98a52d303448e87f626daa2e157f85abb30be2" translate="yes" xml:space="preserve">
          <source>The logging and bug reporting configuration options for both Notary server and Notary signer have the same keys and format. The following sections provide further detail.</source>
          <target state="translated">Notary 서버와 Notary 서명자에 대한 로깅 및 버그보고 구성 옵션은 동일한 키와 형식을 갖습니다. 다음 섹션에서 자세한 내용을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86bd991ac2f1db82855964d5b14b4bce6e93bce7" translate="yes" xml:space="preserve">
          <source>The logging section sets the log level of the server. If it is not provided, the signer/server defaults to an ERROR logging level. However if an explicit value was provided, it must be a valid value.</source>
          <target state="translated">로깅 섹션은 서버의 로그 수준을 설정합니다. 제공되지 않으면 서명자 / 서버의 기본값은 오류 로깅 레벨입니다. 그러나 명시적인 값이 제공된 경우 유효한 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9e762c03589c3d17a47706808801d159143b4877" translate="yes" xml:space="preserve">
          <source>The long form syntax allows the configuration of additional fields that can&amp;rsquo;t be expressed in the short form.</source>
          <target state="translated">긴 형식 구문을 사용하면 짧은 형식으로 표현할 수없는 추가 필드를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b98877d748e2beaa689b50122d97e4a10950df00" translate="yes" xml:space="preserve">
          <source>The long syntax provides more granularity in how the config is created within the service&amp;rsquo;s task containers.</source>
          <target state="translated">긴 구문은 서비스의 태스크 컨테이너 내에서 구성을 작성하는 방법에 대한 세분성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ab4ed053560438068d3b26d30072e5bb12d4735d" translate="yes" xml:space="preserve">
          <source>The long syntax provides more granularity in how the secret is created within the service&amp;rsquo;s task containers.</source>
          <target state="translated">긴 구문은 서비스의 태스크 컨테이너 내에서 비밀이 작성되는 방식에 더 세분성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e55fd2f0d1c7aad656123b72a8eaa4423c80f42a" translate="yes" xml:space="preserve">
          <source>The machine IP addresses returned by &lt;code&gt;docker-machine ls&lt;/code&gt; include port 2376, which is the Docker daemon port. Do not use this port or &lt;a href=&quot;https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2&quot;&gt;you may experience errors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker-machine ls&lt;/code&gt; 에서 리턴 한 시스템 IP 주소 에는 Docker 디먼 포트 인 포트 2376이 포함됩니다. 이 포트를 사용하지 않으면 &lt;a href=&quot;https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2&quot;&gt;오류가 발생할 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1e4cfbe37efbd898032e44dbda616a3d3379c37" translate="yes" xml:space="preserve">
          <source>The main process inside the container referenced under the link &lt;code&gt;redis&lt;/code&gt; will receive &lt;code&gt;SIGKILL&lt;/code&gt;, then the container will be removed.</source>
          <target state="translated">링크 &lt;code&gt;redis&lt;/code&gt; 아래에 참조 된 컨테이너 내부의 기본 프로세스 는 &lt;code&gt;SIGKILL&lt;/code&gt; 을 수신 한 후 컨테이너가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6387957ec493a472590c3ca3e7ac1366b4edd047" translate="yes" xml:space="preserve">
          <source>The main process inside the container will receive &lt;code&gt;SIGTERM&lt;/code&gt;, and after a grace period, &lt;code&gt;SIGKILL&lt;/code&gt;.</source>
          <target state="translated">컨테이너 내부의 주요 프로세스는 &lt;code&gt;SIGTERM&lt;/code&gt; 을 받고 유예 기간 후에 &lt;code&gt;SIGKILL&lt;/code&gt; 을 받습니다.</target>
        </trans-unit>
        <trans-unit id="ee7fca0430379bc3c92a18b854c9921ca0e85f66" translate="yes" xml:space="preserve">
          <source>The manager instructs the worker nodes to redeploy the tasks using the image at that tag.</source>
          <target state="translated">관리자는 작업자 노드에게 해당 태그의 이미지를 사용하여 작업을 재배치하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="710695523bad549ff83605c3df401f525b183c0d" translate="yes" xml:space="preserve">
          <source>The manager node also generates two tokens to use when you join additional nodes to the swarm: one &lt;strong&gt;worker token&lt;/strong&gt; and one &lt;strong&gt;manager token&lt;/strong&gt;. Each token includes the digest of the root CA&amp;rsquo;s certificate and a randomly generated secret. When a node joins the swarm, the joining node uses the digest to validate the root CA certificate from the remote manager. The remote manager uses the secret to ensure the joining node is an approved node.</source>
          <target state="translated">또한 관리자 노드는 추가 노드를 swarm에 결합 할 때 사용할 &lt;strong&gt;작업자 토큰&lt;/strong&gt; 하나와 &lt;strong&gt;관리자 토큰&lt;/strong&gt; 하나 라는 두 개의 토큰을 생성 합니다. 각 토큰에는 루트 CA 인증서의 요약과 무작위로 생성 된 비밀이 포함됩니다. 노드가 웜에 가입하면 가입 노드는 다이제스트를 사용하여 원격 관리자에서 루트 CA 인증서의 유효성을 검사합니다. 원격 관리자는 비밀을 사용하여 결합 노드가 승인 된 노드인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6fe7ef87a2896b45c763e7b46ac2607a814197d3" translate="yes" xml:space="preserve">
          <source>The manifest command interacts solely with a Docker registry. Because of this, it has no way to query the engine for the list of allowed insecure registries. To allow the CLI to interact with an insecure registry, some &lt;code&gt;docker manifest&lt;/code&gt; commands have an &lt;code&gt;--insecure&lt;/code&gt; flag. For each transaction, such as a &lt;code&gt;create&lt;/code&gt;, which queries a registry, the &lt;code&gt;--insecure&lt;/code&gt; flag must be specified. This flag tells the CLI that this registry call may ignore security concerns like missing or self-signed certificates. Likewise, on a &lt;code&gt;manifest push&lt;/code&gt; to an insecure registry, the &lt;code&gt;--insecure&lt;/code&gt; flag must be specified. If this is not used with an insecure registry, the manifest command fails to find a registry that meets the default requirements.</source>
          <target state="translated">manifest 명령은 Docker 레지스트리와 만 상호 작용합니다. 이 때문에 허용되는 안전하지 않은 레지스트리 목록을 엔진에 쿼리 할 수있는 방법이 없습니다. CLI가 안전하지 않은 레지스트리와 상호 작용할 수 있도록 일부 &lt;code&gt;docker manifest&lt;/code&gt; 명령에는 &lt;code&gt;--insecure&lt;/code&gt; 플래그가 있습니다. 레지스트리를 쿼리하는 &lt;code&gt;create&lt;/code&gt; 와 같은 각 트랜잭션에 대해 &lt;code&gt;--insecure&lt;/code&gt; 플래그를 지정해야합니다. 이 플래그는 CLI에이 레지스트리 호출이 누락되거나 자체 서명 된 인증서와 같은 보안 문제를 무시할 수 있음을 알려줍니다. 마찬가지로,에 &lt;code&gt;manifest push&lt;/code&gt; 안전하지 않은 레지스트리의 &lt;code&gt;--insecure&lt;/code&gt; 플래그를 지정해야합니다. 이것이 안전하지 않은 레지스트리와 함께 사용되지 않으면 manifest 명령이 기본 요구 사항을 충족시키는 레지스트리를 찾지 못합니다.</target>
        </trans-unit>
        <trans-unit id="9ffd76b694c7c7a6e6da7a3f6166050339325636" translate="yes" xml:space="preserve">
          <source>The max age, in seconds, for caching services to cache the latest metadata for a role and the metadata by checksum for a role. This value is set on the cache control headers for GET-ting metadata. `must-revalidate` is also set on the cache control headers for current metadata, as current metadata may change whenever new metadata is signed into a repo. Consistent metadata should never change, although it may be deleted, so the max age can be a higher value.</source>
          <target state="translated">캐싱 서비스가 역할의 최신 메타 데이터와 역할의 체크섬으로 메타 데이터를 캐시하기위한 최대 보존 기간 (초)입니다. 이 값은 GET-ting 메타 데이터에 대한 캐시 제어 헤더에서 설정됩니다. 새 메타 데이터가 저장소에 서명 될 때마다 현재 메타 데이터가 변경 될 수 있으므로 현재 메타 데이터에 대한 캐시 제어 헤더에 'must-revalidate'가 설정됩니다. 일관된 메타 데이터는 삭제 될 수 있지만 절대 변경되지 않아야하므로 최대 보존 기간이 더 높아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a5cf58f71249302a3075f943ef43b227012536" translate="yes" xml:space="preserve">
          <source>The maximum number of tasks to roll back in parallel. By default, one task is rolled back at a time. A value of &lt;code&gt;0&lt;/code&gt; causes all tasks to be rolled back in parallel.</source>
          <target state="translated">병렬로 롤백 할 최대 작업 수입니다. 기본적으로 한 번에 하나의 작업이 롤백됩니다. 값이 &lt;code&gt;0&lt;/code&gt; 이면 모든 작업이 동시에 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="a35c3e7a9e4e6e95678b28327ea178f97e6c0685" translate="yes" xml:space="preserve">
          <source>The means of installing and running a network driver plugin depend on the particular plugin. So, be sure to install your plugin according to the instructions obtained from the plugin developer.</source>
          <target state="translated">네트워크 드라이버 플러그인을 설치하고 실행하는 방법은 특정 플러그인에 따라 다릅니다. 따라서 플러그인 개발자가 제공 한 지침에 따라 플러그인을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="4a2d84181923d3b2758ab234bc6aa9a8b22fc07a" translate="yes" xml:space="preserve">
          <source>The minimum Docker Engine version you must be running</source>
          <target state="translated">실행해야하는 최소 Docker Engine 버전</target>
        </trans-unit>
        <trans-unit id="b01ded6c0b3d82f55e3f46535073246347104b21" translate="yes" xml:space="preserve">
          <source>The mode to use for binding the port, either</source>
          <target state="translated">포트 바인딩에 사용할 모드</target>
        </trans-unit>
        <trans-unit id="db6f7022b8d25772c7d891f36408220c2990344a" translate="yes" xml:space="preserve">
          <source>The most basic operation is listing the available signed tags in a repository. The Notary client used in isolation does not know where the trust repositories are located. So, you must provide the &lt;code&gt;-s&lt;/code&gt; (or long form &lt;code&gt;--server&lt;/code&gt;) flag to tell the client which repository server it should communicate with.</source>
          <target state="translated">가장 기본적인 작업은 사용 가능한 서명 된 태그를 저장소에 나열하는 것입니다. 격리에 사용 된 Notary 클라이언트는 트러스트 리포지토리의 위치를 ​​모릅니다. 따라서 클라이언트에게 통신해야 할 저장소 서버를 알리 려면 &lt;code&gt;-s&lt;/code&gt; (또는 long form &lt;code&gt;--server&lt;/code&gt; ) 플래그를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e3c0616a28189d339564bcd3117d8057f5d15956" translate="yes" xml:space="preserve">
          <source>The most important delegation within Docker Content Trust is &lt;code&gt;targets/releases&lt;/code&gt;. This is seen as the canonical source of a trusted image tag, and without a contributor&amp;rsquo;s key being under this delegation, they will be unable to sign a tag.</source>
          <target state="translated">Docker Content Trust에서 가장 중요한 위임은 &lt;code&gt;targets/releases&lt;/code&gt; 입니다. 신뢰할 수있는 이미지 태그의 정식 소스로 표시되며이 위임에 참여자의 키가 없으면 태그에 서명 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1963cac251482ce51e0f0c9b512493c59a096c5c" translate="yes" xml:space="preserve">
          <source>The mount is created inside the container&amp;rsquo;s &lt;code&gt;/world&lt;/code&gt; directory. Docker does not support relative paths for mount points inside the container.</source>
          <target state="translated">마운트는 컨테이너의 &lt;code&gt;/world&lt;/code&gt; 디렉토리 안에 작성됩니다 . Docker는 컨테이너 내부의 마운트 지점에 대한 상대 경로를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f65ec1cc00b9bb1818ddcdd9dc95e9ae4db3f15d" translate="yes" xml:space="preserve">
          <source>The mount point of the volume on the host</source>
          <target state="translated">호스트에서 볼륨의 마운트 지점</target>
        </trans-unit>
        <trans-unit id="5c2ff1f321223719bfae08a21a2ef3fe1dad75a7" translate="yes" xml:space="preserve">
          <source>The name of the file (excluding the extension) determines the plugin name.</source>
          <target state="translated">파일 이름 (확장자 제외)에 따라 플러그인 이름이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2c2d2aa17023ec6fcc56386e68b98696ac0b646e" translate="yes" xml:space="preserve">
          <source>The namespaces &lt;code&gt;com.docker.*&lt;/code&gt;, &lt;code&gt;io.docker.*&lt;/code&gt;, and &lt;code&gt;org.dockerproject.*&lt;/code&gt; in engine labels were always documented to be reserved, but there was never any enforcement.</source>
          <target state="translated">엔진 레이블 의 네임 스페이스 &lt;code&gt;com.docker.*&lt;/code&gt; , &lt;code&gt;io.docker.*&lt;/code&gt; 및 &lt;code&gt;org.dockerproject.*&lt;/code&gt; 는 항상 예약 된 것으로 문서화되었지만 시행 된 적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4db72238fc7d78007b167442cf07bb6fabacfd9e" translate="yes" xml:space="preserve">
          <source>The network driver protocol, in addition to the plugin activation call, is documented as part of libnetwork: &lt;a href=&quot;https://github.com/docker/libnetwork/blob/master/docs/remote/&quot;&gt;https://github.com/docker/libnetwork/blob/master/docs/remote.md&lt;/a&gt;.</source>
          <target state="translated">플러그인 활성화 호출 외에 네트워크 드라이버 프로토콜은 libnetwork ( &lt;a href=&quot;https://github.com/docker/libnetwork/blob/master/docs/remote/&quot;&gt;https://github.com/docker/libnetwork/blob/master/docs/remote.md)의&lt;/a&gt; 일부로 문서화되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d8b041ac43e25f9c65ebc52b5baf0e82a00ee6a" translate="yes" xml:space="preserve">
          <source>The network filter matches on both the network&amp;rsquo;s name and id. The following example shows all containers that are attached to the &lt;code&gt;net1&lt;/code&gt; network, using the network id as a filter;</source>
          <target state="translated">네트워크 필터는 네트워크 이름과 ID에서 모두 일치합니다. 다음 예제는 네트워크 ID를 필터로 사용하여 &lt;code&gt;net1&lt;/code&gt; 네트워크에 연결된 모든 컨테이너를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="29a642482c30f96a4033899c0fdaea9ec3beee25" translate="yes" xml:space="preserve">
          <source>The network from which copying the configuration</source>
          <target state="translated">구성을 복사하는 네트워크</target>
        </trans-unit>
        <trans-unit id="efe659c7cfe7d28e40435e0deeb5154cf1b4363e" translate="yes" xml:space="preserve">
          <source>The network you created is shared between them and load-balancing. Run &lt;code&gt;docker-machine ls&lt;/code&gt; to get your VMs&amp;rsquo; IP addresses and visit either of them on a browser on port 4000, hitting refresh (or just &lt;code&gt;curl&lt;/code&gt; them).</source>
          <target state="translated">생성 한 네트워크는 네트워크와 부하 분산간에 공유됩니다. &lt;code&gt;docker-machine ls&lt;/code&gt; 를 실행 하여 VM의 IP 주소를 가져와 포트 4000의 브라우저에서 두 IP 주소 중 하나를 방문하여 새로 고침을 수행하십시오 (또는 &lt;code&gt;curl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="87723d2ef8e1904797dd36ac4993e2ae45bad90e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;aws-sandbox&lt;/code&gt; instance is running and is the active host as indicated by the asterisk (*). When you create a new machine, your command shell automatically connects to it. You can also check active status by running &lt;code&gt;docker-machine active&lt;/code&gt;.</source>
          <target state="translated">새 &lt;code&gt;aws-sandbox&lt;/code&gt; 인스턴스가 실행 중이며 별표 (*)로 표시된 활성 호스트입니다. 새 머신을 만들면 명령 셸이 자동으로 연결됩니다. &lt;code&gt;docker-machine active&lt;/code&gt; 를 실행하여 활성 상태를 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="183db4b8d88e39dbe104cc52c7ad0b7baded2ed7" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;docker-sandbox&lt;/code&gt; machine is running, and it is the active host as indicated by the asterisk (*). When you create a new machine, your command shell automatically connects to it. If for some reason your new machine is not the active host, run &lt;code&gt;docker-machine env docker-sandbox&lt;/code&gt;, followed by &lt;code&gt;eval $(docker-machine env docker-sandbox)&lt;/code&gt; to connect to it.</source>
          <target state="translated">새 &lt;code&gt;docker-sandbox&lt;/code&gt; 시스템이 실행 중이며 별표 (*)로 표시된 활성 호스트입니다. 새 머신을 만들면 명령 셸이 자동으로 연결됩니다. 어떤 이유로 새 시스템이 활성 호스트가 아닌 경우 &lt;code&gt;docker-machine env docker-sandbox&lt;/code&gt; 를 실행 한 다음 &lt;code&gt;eval $(docker-machine env docker-sandbox)&lt;/code&gt; 를 실행하여 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="0d5eeb3e8799d63324d4a44f2b2fa61c3e46867c" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;volumes&lt;/code&gt; key mounts the project directory (current directory) on the host to &lt;code&gt;/code&lt;/code&gt; inside the container, allowing you to modify the code on the fly, without having to rebuild the image. The &lt;code&gt;environment&lt;/code&gt; key sets the &lt;code&gt;FLASK_ENV&lt;/code&gt; environment variable, which tells &lt;code&gt;flask run&lt;/code&gt; to run in development mode and reload the code on change. This mode should only be used in development.</source>
          <target state="translated">새 &lt;code&gt;volumes&lt;/code&gt; 키는 호스트의 프로젝트 디렉토리 (현재 디렉토리)를 컨테이너 내부의 &lt;code&gt;/code&lt;/code&gt; 에 마운트 하여 이미지를 다시 작성하지 않고도 코드를 즉석에서 수정할 수 있습니다. &lt;code&gt;environment&lt;/code&gt; 키는 설정 &lt;code&gt;FLASK_ENV&lt;/code&gt; 의 지시 환경 변수, &lt;code&gt;flask run&lt;/code&gt; 개발 모드에서 실행하고 변화에 코드를 다시로드합니다. 이 모드는 개발시에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e404d1970236a5dc75cedbe336754c764fa97e2" translate="yes" xml:space="preserve">
          <source>The new solutions come with their own native virtualization solutions rather than Oracle VirtualBox, so keep the following considerations in mind when using Machine to create local VMs.</source>
          <target state="translated">새로운 솔루션에는 Oracle VirtualBox 대신 고유 한 가상화 솔루션이 제공되므로 Machine을 사용하여 로컬 VM을 만들 때 다음 사항을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b234c0b19a2b37103809d22b0044e00398b27483" translate="yes" xml:space="preserve">
          <source>The newly created configuration file contains information about the location of your local Docker trust data and the notary server URL.</source>
          <target state="translated">새로 작성된 구성 파일에는 로컬 Docker 신뢰 데이터의 위치 및 공증 서버 URL에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bc5727abee1ac6e471930402f1f4be87dab74892" translate="yes" xml:space="preserve">
          <source>The next table shows the capabilities which are not granted by default and may be added.</source>
          <target state="translated">다음 표는 기본적으로 부여되지 않았으며 추가 될 수있는 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f3fa21b777fd584afc62cf8b69c40e4fffcc5ba1" translate="yes" xml:space="preserve">
          <source>The node listens for inbound swarm manager traffic on this address. The default is to listen on 0.0.0.0:2377. It is also possible to specify a network interface to listen on that interface&amp;rsquo;s address; for example &lt;code&gt;--listen-addr eth0:2377&lt;/code&gt;.</source>
          <target state="translated">노드는이 주소에서 인바운드 떼 관리자 트래픽을 수신합니다. 기본값은 0.0.0.0:2377에서 청취하는 것입니다. 해당 인터페이스의 주소를 수신 할 네트워크 인터페이스를 지정할 수도 있습니다. 예를 들어 &lt;code&gt;--listen-addr eth0:2377&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb2efabd37befde6cddb78b91ecab1ab217a31a9" translate="yes" xml:space="preserve">
          <source>The node will still appear in the node list, and marked as &lt;code&gt;down&lt;/code&gt;. It no longer affects swarm operation, but a long list of &lt;code&gt;down&lt;/code&gt; nodes can clutter the node list. To remove an inactive node from the list, use the &lt;a href=&quot;../node_rm/index&quot;&gt;&lt;code&gt;node rm&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">노드는 여전히 노드 목록에 표시되고 &lt;code&gt;down&lt;/code&gt; 으로 표시됩니다 . 더 이상 swarm 조작에 영향을 미치지 않지만 긴 &lt;code&gt;down&lt;/code&gt; 노드 목록이 노드 목록을 어지럽 힐 수 있습니다. 목록에서 비활성 노드를 제거하려면 &lt;a href=&quot;../node_rm/index&quot;&gt; &lt;code&gt;node rm&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="92a57b3a23013f31bf5b08572bd51664bc7950ef" translate="yes" xml:space="preserve">
          <source>The notary server credentials: &lt;code&gt;&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;&lt;/code&gt; encoded in base64</source>
          <target state="translated">공증 서버 자격 증명 : &lt;code&gt;&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;&lt;/code&gt; base64로 인코딩 됨</target>
        </trans-unit>
        <trans-unit id="14bfe3d31f5f78a4f822b4d8e315b4ba8ca678ee" translate="yes" xml:space="preserve">
          <source>The notary server is always responsible for managing the timestamp key. However, it is possible for the notary server to manage the snapshot key, if the snapshot key is rotated from the notary client to server, as described in the following subsection.</source>
          <target state="translated">공증인 서버는 항상 타임 스탬프 키 관리를 담당합니다. 그러나 다음 하위 섹션에 설명 된대로 스냅 샷 키가 Notary 클라이언트에서 서버로 회전되면 Notary 서버가 스냅 샷 키를 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b336f656d8197e0632577208cd876d6d20c4b84c" translate="yes" xml:space="preserve">
          <source>The notation for associating a local image with a repository on a registry is &lt;code&gt;username/repository:tag&lt;/code&gt;. The tag is optional, but recommended, since it is the mechanism that registries use to give Docker images a version. Give the repository and tag meaningful names for the context, such as &lt;code&gt;get-started:part2&lt;/code&gt;. This puts the image in the &lt;code&gt;get-started&lt;/code&gt; repository and tags it as &lt;code&gt;part2&lt;/code&gt;.</source>
          <target state="translated">로컬 이미지를 레지스트리의 저장소와 연관시키는 표기법은 &lt;code&gt;username/repository:tag&lt;/code&gt; 입니다. 태그는 선택 사항이지만 레지스트리가 Docker 이미지에 버전을 제공하는 데 사용하는 메커니즘이므로 권장됩니다. &lt;code&gt;get-started:part2&lt;/code&gt; 와 같이 컨텍스트에 저장소 및 태그에 의미있는 이름을 지정하십시오 . 그러면 이미지가 &lt;code&gt;get-started&lt;/code&gt; 저장소에 배치되고 &lt;code&gt;part2&lt;/code&gt; 로 태그가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b69ac60cbd9e75489828f500df16f2177a96db75" translate="yes" xml:space="preserve">
          <source>The notation is &lt;code&gt;machinename:/path/to/dir&lt;/code&gt; for the argument; you can also supply an alternative mount point (default is the same dir path).</source>
          <target state="translated">인수 는 &lt;code&gt;machinename:/path/to/dir&lt;/code&gt; 입니다. 대체 마운트 지점을 제공 할 수도 있습니다 (기본값은 동일한 디렉토리 경로 임).</target>
        </trans-unit>
        <trans-unit id="d11c5e1162367e795a70983b83cfdf3d1ee3ac48" translate="yes" xml:space="preserve">
          <source>The notation is &lt;code&gt;machinename:/path/to/files&lt;/code&gt; for the arguments; in the host machine&amp;rsquo;s case, you don&amp;rsquo;t need to specify the name, just the path.</source>
          <target state="translated">표기법은 인수에 대한 &lt;code&gt;machinename:/path/to/files&lt;/code&gt; 입니다. 호스트 시스템의 경우 경로 만 이름을 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="917f866a3c931d8ef3e0b7a32449c7405bbd0d26" translate="yes" xml:space="preserve">
          <source>The number of items in the task history is determined by the &lt;code&gt;--task-history-limit&lt;/code&gt; option that was set when initializing the swarm. You can change the task history retention limit using the &lt;a href=&quot;../swarm_update/index&quot;&gt;&lt;code&gt;docker swarm update&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">작업 기록의 항목 수 는 스웜을 초기화 할 때 설정 한 &lt;code&gt;--task-history-limit&lt;/code&gt; 옵션에 의해 결정됩니다 . &lt;a href=&quot;../swarm_update/index&quot;&gt; &lt;code&gt;docker swarm update&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 작업 기록 보존 제한을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f44ace853eedd4d2b3d52b4a07c2863c83910a2d" translate="yes" xml:space="preserve">
          <source>The number should increment.</source>
          <target state="translated">숫자가 증가해야합니다.</target>
        </trans-unit>
        <trans-unit id="2335d7fb127df2a4cdc6970180f0ce850a983406" translate="yes" xml:space="preserve">
          <source>The official Docker Hub Notary servers are located at &lt;code&gt;https://notary.docker.io&lt;/code&gt;. If you would like to use your own Notary server, it is important to use the same or a newer &lt;a href=&quot;https://github.com/docker/notary/releases&quot;&gt;Notary version&lt;/a&gt;, as the client for feature compatibility (ex: client version 0.2, server/signer version &amp;gt;= 0.2). Additionally, Notary stores your own signing keys, and a cache of previously downloaded trust metadata in a directory, provided with the &lt;code&gt;-d&lt;/code&gt; flag. When interacting with Docker Hub repositories, you must instruct the client to use the associated trust directory, which by default is found at &lt;code&gt;.docker/trust&lt;/code&gt; within the calling user&amp;rsquo;s home directory (failing to use this directory may result in errors when publishing updates to your trust data):</source>
          <target state="translated">공식 Docker Hub Notary 서버는 &lt;code&gt;https://notary.docker.io&lt;/code&gt; 에 있습니다. 고유 한 Notary 서버를 사용하려면 기능 호환성을위한 클라이언트 와 동일하거나 최신 &lt;a href=&quot;https://github.com/docker/notary/releases&quot;&gt;Notary 버전&lt;/a&gt; 을 사용해야합니다 (예 : 클라이언트 버전 0.2, 서버 / 서명 버전&amp;gt; = 0.2). 또한 Notary는 자체 서명 키와 이전에 다운로드 한 신뢰 메타 데이터 캐시를 &lt;code&gt;-d&lt;/code&gt; 플래그 와 함께 제공된 디렉토리에 저장합니다 . Docker Hub 리포지토리와 상호 작용할 때 클라이언트에게 연결된 트러스트 디렉토리를 사용하도록 지시해야합니다.이 트러스트 디렉토리는 기본적으로 발신 사용자의 홈 디렉토리 내 &lt;code&gt;.docker/trust&lt;/code&gt; 에 있습니다 (이 디렉토리를 사용하지 않으면 업데이트를 게시 할 때 오류가 발생할 수 있음) 신뢰 데이터) :</target>
        </trans-unit>
        <trans-unit id="22218babb42765a654a32765cf74fbd5b2200f1a" translate="yes" xml:space="preserve">
          <source>The only thing new here is the peer service to &lt;code&gt;web&lt;/code&gt;, named &lt;code&gt;visualizer&lt;/code&gt;. Notice two new things here: a &lt;code&gt;volumes&lt;/code&gt; key, giving the visualizer access to the host&amp;rsquo;s socket file for Docker, and a &lt;code&gt;placement&lt;/code&gt; key, ensuring that this service only ever runs on a swarm manager -- never a worker. That&amp;rsquo;s because this container, built from &lt;a href=&quot;https://github.com/ManoMarks/docker-swarm-visualizer&quot;&gt;an open source project created by Docker&lt;/a&gt;, displays Docker services running on a swarm in a diagram.</source>
          <target state="translated">여기에서 유일한 새로운 것은 &lt;code&gt;visualizer&lt;/code&gt; 라는 &lt;code&gt;web&lt;/code&gt; 피어 서비스 입니다. 여기에 두 가지 새로운 점이 있습니다. &lt;code&gt;volumes&lt;/code&gt; 키는 Visualizer가 Docker의 호스트 소켓 파일에 액세스 할 수있게하고 &lt;code&gt;placement&lt;/code&gt; 키는이 서비스가 작업자가 아닌 떼 관리자에서만 실행되도록합니다. &lt;a href=&quot;https://github.com/ManoMarks/docker-swarm-visualizer&quot;&gt;Docker가 만든 오픈 소스 프로젝트로&lt;/a&gt; 빌드 된이 컨테이너 는 떼에서 실행되는 Docker 서비스를 다이어그램에 표시하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="89730a2ade1b5abddc9347ab148e5d119931f020" translate="yes" xml:space="preserve">
          <source>The operator can also adjust the performance parameters of the container:</source>
          <target state="translated">작업자는 컨테이너의 성능 매개 변수를 조정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="41382989315f8c3ee9e303ef492c566711e626ec" translate="yes" xml:space="preserve">
          <source>The operator can identify a container in three ways:</source>
          <target state="translated">운영자는 세 가지 방법으로 컨테이너를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7367fe1cca6b073f6f2a1faf3da852281eae9d5" translate="yes" xml:space="preserve">
          <source>The optional field &lt;code&gt;features&lt;/code&gt; in &lt;code&gt;daemon.json&lt;/code&gt; allows users to enable or disable specific daemon features. For example, &lt;code&gt;{&quot;features&quot;:{&quot;buildkit&quot;: true}}&lt;/code&gt; enables &lt;code&gt;buildkit&lt;/code&gt; as the default docker image builder.</source>
          <target state="translated">&lt;code&gt;daemon.json&lt;/code&gt; 의 선택적 필드 &lt;code&gt;features&lt;/code&gt; 을 통해 사용자는 특정 데몬 기능을 활성화하거나 비활성화 할 수 있습니다. 예를 들어, &lt;code&gt;{&quot;features&quot;:{&quot;buildkit&quot;: true}}&lt;/code&gt; 는 기본 docker 이미지 빌더로 &lt;code&gt;buildkit&lt;/code&gt; 을 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="e28c99503cf59797f397d36b1752165612aec9cc" translate="yes" xml:space="preserve">
          <source>The options described here are specific to the &lt;code&gt;deploy&lt;/code&gt; key and swarm mode. If you want to set resource constraints on non swarm deployments, use &lt;a href=&quot;compose-file-v2/index#cpu-and-other-resources&quot;&gt;Compose file format version 2 CPU, memory, and other resource options&lt;/a&gt;. If you have further questions, refer to the discussion on the GitHub issue &lt;a href=&quot;https://github.com/docker/compose/issues/4513&quot;&gt;docker/compose/4513&lt;/a&gt;.</source>
          <target state="translated">여기에 설명 된 옵션은 &lt;code&gt;deploy&lt;/code&gt; 키 및 스웜 모드와 관련이 있습니다. 비 swarm 배치에서 자원 제한 조건을 설정하려면 &lt;a href=&quot;compose-file-v2/index#cpu-and-other-resources&quot;&gt;파일 형식 버전 2 CPU, 메모리 및 기타 자원 옵션 작성을&lt;/a&gt; 사용 하십시오 . 추가 질문이있는 경우 GitHub 문제 &lt;a href=&quot;https://github.com/docker/compose/issues/4513&quot;&gt;docker / compose / 4513&lt;/a&gt; 에 대한 토론을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be781eb9a4261dfa7130c6d663bb44e808306180" translate="yes" xml:space="preserve">
          <source>The options for &lt;code&gt;endpoint_mode&lt;/code&gt; also work as flags on the swarm mode CLI command &lt;a href=&quot;../../engine/reference/commandline/service_create/index&quot;&gt;docker service create&lt;/a&gt;. For a quick list of all swarm related &lt;code&gt;docker&lt;/code&gt; commands, see &lt;a href=&quot;../../engine/swarm/index#swarm-mode-key-concepts-and-tutorial&quot;&gt;Swarm mode CLI commands&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;endpoint_mode&lt;/code&gt; 옵션 은 swarm mode CLI 명령 &lt;a href=&quot;../../engine/reference/commandline/service_create/index&quot;&gt;docker service create&lt;/a&gt; 에서 플래그로 작동 합니다. 모든 swarm 관련 &lt;code&gt;docker&lt;/code&gt; 명령 의 빠른 목록 은 &lt;a href=&quot;../../engine/swarm/index#swarm-mode-key-concepts-and-tutorial&quot;&gt;Swarm mode CLI 명령을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de59387120196b30f85a7b76e5242eebb18bcb72" translate="yes" xml:space="preserve">
          <source>The options for token auth. See &lt;a href=&quot;https://github.com/docker/distribution/blob/master/docs/configuration/#token&quot;&gt; the registry token configuration documentation&lt;/a&gt; for the parameter details.</source>
          <target state="translated">토큰 인증 옵션. 참조 &lt;a href=&quot;https://github.com/docker/distribution/blob/master/docs/configuration/#token&quot;&gt;레지스트리 토큰 구성 문서&lt;/a&gt; 매개 변수의 자세한 내용입니다.</target>
        </trans-unit>
        <trans-unit id="7412839711afce147b5113fb7e29aef802049f6a" translate="yes" xml:space="preserve">
          <source>The options set in the configuration file must not conflict with options set via flags. The docker daemon fails to start if an option is duplicated between the file and the flags, regardless their value. We do this to avoid silently ignore changes introduced in configuration reloads. For example, the daemon fails to start if you set daemon labels in the configuration file and also set daemon labels via the &lt;code&gt;--label&lt;/code&gt; flag. Options that are not present in the file are ignored when the daemon starts.</source>
          <target state="translated">구성 파일에 설정된 옵션은 플래그를 통해 설정된 옵션과 충돌하지 않아야합니다. 파일과 플래그 사이에 옵션이 값과 관계없이 옵션이 중복되면 docker 데몬이 시작되지 않습니다. 구성 재로드에 도입 된 변경 사항을 자동으로 무시하지 않기 위해이를 수행합니다. 예를 들어, 구성 파일에서 데몬 레이블을 설정하고 &lt;code&gt;--label&lt;/code&gt; 플래그 를 통해 데몬 레이블을 설정하면 데몬이 시작되지 않습니다 . 파일에없는 옵션은 데몬이 시작될 때 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="887339b939d9bd41483f880117e295c27a275ba5" translate="yes" xml:space="preserve">
          <source>The options that can appear before &lt;code&gt;CMD&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;CMD&lt;/code&gt; 전에 나타날 수있는 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15025a31073c4bf6ead7579cba512726377f05f7" translate="yes" xml:space="preserve">
          <source>The options you can specify are:</source>
          <target state="translated">지정할 수있는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be530e2255560ffe12f81210b54801ad89713238" translate="yes" xml:space="preserve">
          <source>The output above also shows the &lt;code&gt;/usr/bin/docker&lt;/code&gt; (Docker Engine daemon) profile is running in &lt;code&gt;complain&lt;/code&gt; mode. This means AppArmor &lt;em&gt;only&lt;/em&gt; logs to &lt;code&gt;dmesg&lt;/code&gt; activity outside the bounds of the profile. (Except in the case of Ubuntu Trusty, where some interesting behaviors are enforced.)</source>
          <target state="translated">위의 출력은 또한 &lt;code&gt;/usr/bin/docker&lt;/code&gt; (Docker Engine 데몬) 프로파일이 &lt;code&gt;complain&lt;/code&gt; 모드 로 실행 중임을 보여줍니다 . 이는 AppArmor 가 프로파일 경계 외부의 &lt;code&gt;dmesg&lt;/code&gt; 활동 &lt;em&gt;에만&lt;/em&gt; 로그 함을 의미 합니다. (우분투 트러스티의 경우를 제외하고 흥미로운 행동이 시행됩니다.)</target>
        </trans-unit>
        <trans-unit id="2355a5f85cf53a441cc11d2d8bdc79e7dae6c672" translate="yes" xml:space="preserve">
          <source>The output described above is intended for the shells &lt;code&gt;bash&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt; (if you&amp;rsquo;re not sure which shell you&amp;rsquo;re using, there&amp;rsquo;s a very good possibility that it&amp;rsquo;s &lt;code&gt;bash&lt;/code&gt;). However, these are not the only shells which Docker Machine supports. Docker Machine detects the shells available in your environment and lists them. Docker supports &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;cmd&lt;/code&gt;, &lt;code&gt;powershell&lt;/code&gt;, and &lt;code&gt;emacs&lt;/code&gt;.</source>
          <target state="translated">위에서 설명한 출력은 쉘 &lt;code&gt;bash&lt;/code&gt; 및 &lt;code&gt;zsh&lt;/code&gt; 용입니다 (사용중인 쉘이 확실하지 않으면 &lt;code&gt;bash&lt;/code&gt; 일 가능성이 큽니다 ). 그러나 Docker Machine이 지원하는 유일한 쉘은 아닙니다. Docker Machine은 환경에서 사용 가능한 쉘을 감지하여 나열합니다. Docker는 &lt;code&gt;bash&lt;/code&gt; , &lt;code&gt;cmd&lt;/code&gt; , &lt;code&gt;powershell&lt;/code&gt; 및 &lt;code&gt;emacs&lt;/code&gt; 를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="a45c5a07cae9a3fc556e42c151f1b595b59af9be" translate="yes" xml:space="preserve">
          <source>The output for &lt;code&gt;docker swarm init&lt;/code&gt; provides the connection command to use when you join new worker nodes to the swarm:</source>
          <target state="translated">&lt;code&gt;docker swarm init&lt;/code&gt; 의 출력은 새 작업자 노드를 swarm에 가입시킬 때 사용할 연결 명령을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd47af0af4efb7be690f1343bf0a5ed1d3833bd4" translate="yes" xml:space="preserve">
          <source>The output includes the commands to join new nodes to the swarm. Nodes will join as managers or workers depending on the value for the &lt;code&gt;--token&lt;/code&gt; flag.</source>
          <target state="translated">출력에는 새 노드를 swarm에 연결하는 명령이 포함됩니다. 노드는 &lt;code&gt;--token&lt;/code&gt; 플래그 의 값에 따라 관리자 또는 작업자로 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="640437e1ea9cf751f8f36635ede5392a77849e3d" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;service inspect&lt;/code&gt; shows if your update paused due to failure:</source>
          <target state="translated">의 출력 &lt;code&gt;service inspect&lt;/code&gt; 하여 업데이트로 인해 고장으로 일시 정지하는 경우 보여줍니다 :</target>
        </trans-unit>
        <trans-unit id="cce7e1017043a07f1dba87713af3ef3207ceec71" translate="yes" xml:space="preserve">
          <source>The output of the final &lt;code&gt;pwd&lt;/code&gt; command in this &lt;code&gt;Dockerfile&lt;/code&gt; would be &lt;code&gt;/a/b/c&lt;/code&gt;.</source>
          <target state="translated">최종의 출력 &lt;code&gt;pwd&lt;/code&gt; 이 명령에 &lt;code&gt;Dockerfile&lt;/code&gt; 는 것이다 &lt;code&gt;/a/b/c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5b0809469381a9d3d38b296dd33b48f8cf206a7" translate="yes" xml:space="preserve">
          <source>The output of the final &lt;code&gt;pwd&lt;/code&gt; command in this &lt;code&gt;Dockerfile&lt;/code&gt; would be &lt;code&gt;/path/$DIRNAME&lt;/code&gt;</source>
          <target state="translated">최종의 출력 &lt;code&gt;pwd&lt;/code&gt; 이의 명령 &lt;code&gt;Dockerfile&lt;/code&gt; 는 것 &lt;code&gt;/path/$DIRNAME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="773e939704075237973f7c14690a3cee57cf3927" translate="yes" xml:space="preserve">
          <source>The output shows the &lt;code&gt;&amp;lt;CONTAINER-PORT&amp;gt;&lt;/code&gt; (labeled &lt;code&gt;TargetPort&lt;/code&gt;) from the containers and the &lt;code&gt;&amp;lt;PUBLISHED-PORT&amp;gt;&lt;/code&gt; (labeled &lt;code&gt;PublishedPort&lt;/code&gt;) where nodes listen for requests for the service.</source>
          <target state="translated">출력은 &lt;code&gt;&amp;lt;CONTAINER-PORT&amp;gt;&lt;/code&gt; 의 &amp;lt;CONTAINER-PORT&amp;gt; ( &lt;code&gt;TargetPort&lt;/code&gt; )와 노드가 서비스 요청을 청취 하는 &lt;code&gt;&amp;lt;PUBLISHED-PORT&amp;gt;&lt;/code&gt; ( &lt;code&gt;PublishedPort&lt;/code&gt; )를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="7b45be3f9ca95cc06eaa63157a9914673b94e68f" translate="yes" xml:space="preserve">
          <source>The output shows us the names of the tags available, the hex encoded sha256 digest of the image manifest associated with that tag, the size of the manifest, and the Notary role that signed this tag into the repository. The &amp;ldquo;targets&amp;rdquo; role is the most common role in a simple repository. When a repository has (or expects) to have collaborators, you may see other &amp;ldquo;delegated&amp;rdquo; roles listed as signers, based on the choice of the administrator as to how they organize their collaborators.</source>
          <target state="translated">출력에는 사용 가능한 태그 이름, 해당 태그와 연관된 이미지 매니페스트의 16 진 인코딩 sha256 다이제스트, 매니페스트 크기 및이 태그를 저장소에 서명 한 공증인 역할이 표시됩니다. &quot;대상&quot;역할은 간단한 리포지토리에서 가장 일반적인 역할입니다. 리포지토리에 공동 작업자가있을 것으로 예상되는 경우 관리자가 공동 작업자를 구성하는 방법에 대한 선택에 따라 다른 &quot;위임 된&quot;역할이 서명자로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a20f79e9ea92e3d5d042b3749d55e9fb231dda1" translate="yes" xml:space="preserve">
          <source>The overlay and overlay2 storage driver does not work as expected if the backing filesystem does not support &lt;code&gt;d_type&lt;/code&gt;. For example, XFS does not support &lt;code&gt;d_type&lt;/code&gt; if it is formatted with the &lt;code&gt;ftype=0&lt;/code&gt; option.</source>
          <target state="translated">백업 파일 시스템이 &lt;code&gt;d_type&lt;/code&gt; 을 지원하지 않으면 overlay 및 overlay2 스토리지 드라이버가 예상대로 작동하지 않습니다 . 예를 들어, XFS는 &lt;code&gt;ftype=0&lt;/code&gt; 옵션으로 포맷 된 경우 &lt;code&gt;d_type&lt;/code&gt; 을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6772401b9f59c7d3631574fc262b4cfd5c6fae97" translate="yes" xml:space="preserve">
          <source>The passphrases you chose for both the root key and your repository key should be randomly generated and stored in a password manager. Having the repository key allows users to sign image tags on a repository. Passphrases are used to encrypt your keys at rest and ensure that a lost laptop or an unintended backup doesn&amp;rsquo;t put the private key material at risk.</source>
          <target state="translated">루트 키와 리포지토리 키 모두에 대해 선택한 암호는 임의로 생성되어 암호 관리자에 저장되어야합니다. 저장소 키를 사용하면 사용자가 저장소에서 이미지 태그에 서명 할 수 있습니다. 암호는 보관중인 키를 암호화하고 노트북 분실 또는 의도하지 않은 백업으로 인해 개인 키 자료가 위험에 빠지지 않도록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7921733af36283370ff2c7a3bafa55d215831e2e" translate="yes" xml:space="preserve">
          <source>The path to the certificate to use for HTTPS. Must be provided together with &lt;code&gt;tls_key_file&lt;/code&gt;, or not at all. If neither are provided, the server uses HTTP instead of HTTPS. The path is relative to the directory of the configuration file.</source>
          <target state="translated">HTTPS에 사용할 인증서의 경로입니다. &lt;code&gt;tls_key_file&lt;/code&gt; 과 함께 제공 되거나 전혀 제공 되지 않아야합니다. 둘 다 제공되지 않으면 서버는 HTTPS 대신 HTTP를 사용합니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="d49a7cbb3325ee43f3655cca35361be16fa0ce11" translate="yes" xml:space="preserve">
          <source>The path to the certificate to use for HTTPS. The path is relative to the directory of the configuration file.</source>
          <target state="translated">HTTPS에 사용할 인증서의 경로입니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="cc6fea9e413138463ad3caf57d146a91b37f385c" translate="yes" xml:space="preserve">
          <source>The path to the certificate to use for TLS mutual authentication. This must be provided together with &lt;code&gt;tls_client_key&lt;/code&gt; or not at all. The path is relative to the directory of the configuration file.</source>
          <target state="translated">TLS 상호 인증에 사용할 인증서의 경로입니다. 이것은 &lt;code&gt;tls_client_key&lt;/code&gt; 와 함께 제공 되거나 전혀 제공 되지 않아야합니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="a02fb0c3c553eaad6af5d8d6ce2860686b40be67" translate="yes" xml:space="preserve">
          <source>The path to the client certificate to use for mutual TLS with the Notary server. Must be provided along with &lt;code&gt;tls_client_key&lt;/code&gt; or not provided at all. The path is relative to the directory of the configuration file.</source>
          <target state="translated">Notary 서버와의 상호 TLS에 사용할 클라이언트 인증서의 경로입니다. &lt;code&gt;tls_client_key&lt;/code&gt; 와 함께 제공 되거나 전혀 제공되지 않아야합니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="02b50f36283fa77547334520ace19ee4dfcc4135" translate="yes" xml:space="preserve">
          <source>The path to the client key to use for mutual TLS with the Notary server. Must be provided along with &lt;code&gt;tls_client_cert&lt;/code&gt; or not provided at all. The path is relative to the directory of the configuration file.</source>
          <target state="translated">Notary 서버와의 상호 TLS에 사용할 클라이언트 키의 경로입니다. &lt;code&gt;tls_client_cert&lt;/code&gt; 와 함께 제공 되거나 전혀 제공되지 않아야합니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="66ff566fdcbbd6d71352430ce6eeffddb0779a2d" translate="yes" xml:space="preserve">
          <source>The path to the file containing the root CA with which to verify the TLS certificate of the Notary server, for example if it is self-signed. The path is relative to the directory of the configuration file.</source>
          <target state="translated">Notary 서버의 TLS 인증서를 확인하는 데 사용되는 루트 CA가 포함 된 파일의 경로입니다 (예 : 자체 서명 된 경우). 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="8aaf5e7edd9c8cbc20272f7e43807aef90359eee" translate="yes" xml:space="preserve">
          <source>The path to the private key to use for HTTPS. Must be provided together with &lt;code&gt;tls_cert_file&lt;/code&gt;, or not at all. If neither are provided, the server uses HTTP instead of HTTPS. The path is relative to the directory of the configuration file.</source>
          <target state="translated">HTTPS에 사용할 개인 키의 경로입니다. &lt;code&gt;tls_cert_file&lt;/code&gt; 과 함께 제공 되거나 전혀 제공 되지 않아야합니다. 둘 다 제공되지 않으면 서버는 HTTPS 대신 HTTP를 사용합니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="0e3be96cfe128a246a5170eecbbf92354b61abc2" translate="yes" xml:space="preserve">
          <source>The path to the private key to use for HTTPS. The path is relative to the directory of the configuration file.</source>
          <target state="translated">HTTPS에 사용할 개인 키의 경로입니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="b1a4d713e0460af37af02f395caffe48a13e027a" translate="yes" xml:space="preserve">
          <source>The path to the private key to use for TLS mutual authentication. This must be provided together with &lt;code&gt;tls_client_cert&lt;/code&gt; or not at all. The path is relative to the directory of the configuration file.</source>
          <target state="translated">TLS 상호 인증에 사용할 개인 키의 경로입니다. 이것은 &lt;code&gt;tls_client_cert&lt;/code&gt; 와 함께 제공 되거나 전혀 제공 되지 않아야합니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="6ecca1195ce455667b656022d75de39ecdf3c877" translate="yes" xml:space="preserve">
          <source>The path to the root CA that signed the TLS certificate of the remote service. This parameter must be provided if said root CA is not in the system's default trust roots. The path is relative to the directory of the configuration file.</source>
          <target state="translated">원격 서비스의 TLS 인증서에 서명 한 루트 CA의 경로입니다. 루트 CA가 시스템의 기본 트러스트 루트에없는 경우이 매개 변수를 제공해야합니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="012c2ffec87ed472da3d4617f62f9c1d29fe053d" translate="yes" xml:space="preserve">
          <source>The placement constraint you put on the Redis service, ensuring that it always uses the same host.</source>
          <target state="translated">Redis 서비스에 적용한 배치 제약 조건은 항상 동일한 호스트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cf5772e3d94707e32a722854b385febbff079284" translate="yes" xml:space="preserve">
          <source>The placement of &lt;code&gt;!&lt;/code&gt; exception rules influences the behavior: the last line of the &lt;code&gt;.dockerignore&lt;/code&gt; that matches a particular file determines whether it is included or excluded. Consider the following example:</source>
          <target state="translated">의 배치 &lt;code&gt;!&lt;/code&gt; 예외 규칙은 동작에 영향을 미칩니다. 특정 파일과 일치하는 &lt;code&gt;.dockerignore&lt;/code&gt; 의 마지막 행에 파일의 포함 여부가 결정됩니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c7b6aeb70321b0532d875f81f564375bb56ed249" translate="yes" xml:space="preserve">
          <source>The plugin can subsequently be enabled for local use or pushed to the public registry.</source>
          <target state="translated">이후 플러그인을 로컬에서 사용하도록 설정하거나 공용 레지스트리로 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5681b06ba81b98e56e671eda1bf016a361f78c9c" translate="yes" xml:space="preserve">
          <source>The plugin must support two authorization messages formats, one from the daemon to the plugin and then from the plugin to the daemon. The tables below detail the content expected in each message.</source>
          <target state="translated">플러그인은 데몬에서 플러그인으로, 플러그인에서 데몬으로 두 가지 인증 메시지 형식을 지원해야합니다. 아래 표에는 각 메시지에 필요한 내용이 자세히 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf479528d3c864f40b34e6e8a8b256f60574b3aa" translate="yes" xml:space="preserve">
          <source>The plugin requests 2 privileges:</source>
          <target state="translated">플러그인은 2 가지 권한을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="20591766ace52f6ea09ec3a0f14b31599830c93a" translate="yes" xml:space="preserve">
          <source>The port number inside the container (where the service listens) does not need to match the port number exposed on the outside of the container (where clients connect). For example, inside the container an HTTP service is listening on port 80 (and so the image developer specifies &lt;code&gt;EXPOSE 80&lt;/code&gt; in the Dockerfile). At runtime, the port might be bound to 42800 on the host. To find the mapping between the host ports and the exposed ports, use &lt;code&gt;docker port&lt;/code&gt;.</source>
          <target state="translated">컨테이너 내부 (서비스가 수신하는)의 포트 번호는 컨테이너 외부 (노트북이 연결된)에 노출 된 포트 번호와 일치하지 않아도됩니다. 예를 들어, 컨테이너 내부에서 HTTP 서비스가 포트 80에서 수신 대기하고 있으므로 이미지 개발자 는 Dockerfile에서 &lt;code&gt;EXPOSE 80&lt;/code&gt; 을 지정합니다 . 런타임시 포트가 호스트에서 42800에 바인드 될 수 있습니다. 호스트 포트와 노출 된 포트 사이의 맵핑을 찾으려면 &lt;code&gt;docker port&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="04ec18e0ed519d31508f51c1d0dad20602cec320" translate="yes" xml:space="preserve">
          <source>The port that SSH is running on, needed for Docker Machine to provision the Linode.</source>
          <target state="translated">Docker Machine이 Linode를 프로비저닝하는 데 필요한 SSH가 실행중인 포트입니다.</target>
        </trans-unit>
        <trans-unit id="fe1e329bc037c6d750a15b68d6244ffce06f9b6a" translate="yes" xml:space="preserve">
          <source>The preceding example illustrates a request to add the delegation &lt;code&gt;targets/releases&lt;/code&gt; to the GUN &lt;code&gt;example.com/collection&lt;/code&gt;. The delegation name must be prefixed by &lt;code&gt;targets/&lt;/code&gt; to be valid, since all delegations are restricted versions of the target role. The command adds the public key contained in the x509 cert &lt;code&gt;cert.pem&lt;/code&gt; to the &lt;code&gt;targets/releases&lt;/code&gt; delegation.</source>
          <target state="translated">앞의 예는 위임 &lt;code&gt;targets/releases&lt;/code&gt; 를 GUN &lt;code&gt;example.com/collection&lt;/code&gt; 에 추가하라는 요청을 보여줍니다 . 모든 위임은 대상 역할의 제한된 버전이므로 위임 이름 앞에 &lt;code&gt;targets/&lt;/code&gt; 를 붙여야합니다 . 이 명령은 x509 cert &lt;code&gt;cert.pem&lt;/code&gt; 에 포함 된 공개 키 를 &lt;code&gt;targets/releases&lt;/code&gt; 위임에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2cf6cb209a774a788b51f43415e140aebd8f49cb" translate="yes" xml:space="preserve">
          <source>The preceding example is operating-system specific and is for illustrative purposes only. You should consult your operating system documentation for creating an os-provided bundled certificate chain.</source>
          <target state="translated">앞의 예는 운영 체제에 따라 다르며 설명 목적으로 만 사용됩니다. 운영 체제 제공 번들 인증서 체인 작성에 대해서는 운영 체제 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75050ce3b960d53c3dbe585963f55bbcb50f66d5" translate="yes" xml:space="preserve">
          <source>The prerequisites are:</source>
          <target state="translated">전제 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d512ca933bd80757c1dfdd90d2ebb6e19763954d" translate="yes" xml:space="preserve">
          <source>The presence of one or more &lt;code&gt;&amp;lt;filename&amp;gt;.key/cert&lt;/code&gt; pairs indicates to Docker that there are custom certificates required for access to the desired repository.</source>
          <target state="translated">하나 이상의 &lt;code&gt;&amp;lt;filename&amp;gt;.key/cert&lt;/code&gt; 쌍이 있으면 Docker에 원하는 리포지토리에 액세스하는 데 필요한 사용자 지정 인증서가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="64d88377cebbf31910a31e90c8d322de508c55c5" translate="yes" xml:space="preserve">
          <source>The problem is that Swarm might first schedule &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; on different nodes (since they&amp;rsquo;re not dependent on one another), making it impossible to pick an appropriate node for &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">문제는 Swarm이 먼저 서로 다른 노드에서 스케줄 &lt;code&gt;bar&lt;/code&gt; 와 &lt;code&gt;baz&lt;/code&gt; 를 예약 할 수 있으며 (서로에 의존하지 않기 때문에) &lt;code&gt;foo&lt;/code&gt; 에 적절한 노드를 선택할 수 없다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b8b8984e1b09d38e20dadc2233b45e65257a854a" translate="yes" xml:space="preserve">
          <source>The problem of waiting for a database (for example) to be ready is really just a subset of a much larger problem of distributed systems. In production, your database could become unavailable or move hosts at any time. Your application needs to be resilient to these types of failures.</source>
          <target state="translated">데이터베이스 (예를 들어)가 준비되기를 기다리는 문제는 실제로 분산 시스템의 훨씬 더 큰 문제의 일부일뿐입니다. 프로덕션 환경에서는 언제든지 데이터베이스를 사용할 수 없게되거나 호스트를 이동할 수 있습니다. 이러한 유형의 장애에 대해서는 애플리케이션을 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfe05733ac9969fdef95ebcf6c7d8018f77d417f" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;HttpHeaders&lt;/code&gt; specifies a set of headers to include in all messages sent from the Docker client to the daemon. Docker does not try to interpret or understand these header; it simply puts them into the messages. Docker does not allow these headers to change any headers it sets for itself.</source>
          <target state="translated">&lt;code&gt;HttpHeaders&lt;/code&gt; 속성 은 Docker 클라이언트에서 데몬으로 전송 된 모든 메시지에 포함 할 헤더 세트를 지정합니다. Docker는 이러한 헤더를 해석하거나 이해하려고 시도하지 않습니다. 단순히 메시지에 넣습니다. Docker는 이러한 헤더가 자신이 설정 한 헤더를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f899e49371710fd9560f2e9b26b6c551e9faa588" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;configFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker config ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker config ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see &lt;a href=&quot;../config_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker config ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;configFormat&lt;/code&gt; 속성 은 &lt;code&gt;docker config ls&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 플래그가 제공되지 않습니다 &lt;code&gt;docker config ls&lt;/code&gt; 명령, 부두 노동자의 클라이언트는이 속성을 사용합니다. 이 특성을 설정하지 않으면 클라이언트는 기본 테이블 형식으로 돌아갑니다. 지원되는 형식 지정 문 목록은 &lt;a href=&quot;../config_ls/index&quot;&gt; &lt;code&gt;docker config ls&lt;/code&gt; &lt;/a&gt; documentation 의 &lt;strong&gt;형식 지정&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff2c161f1c8c1f61a5754a04ce5dff50f47e7bde" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;credHelpers&lt;/code&gt; specifies a set of credential helpers to use preferentially over &lt;code&gt;credsStore&lt;/code&gt; or &lt;code&gt;auths&lt;/code&gt; when storing and retrieving credentials for specific registries. If this property is set, the binary &lt;code&gt;docker-credential-&amp;lt;value&amp;gt;&lt;/code&gt; will be used when storing or retrieving credentials for a specific registry. For more information, see the &lt;a href=&quot;../login/index#credential-helpers&quot;&gt;&lt;strong&gt;Credential helpers&lt;/strong&gt; section in the &lt;code&gt;docker login&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">속성 &lt;code&gt;credHelpers&lt;/code&gt; 의 지정 자격 헬퍼 세트 위에 우선적으로 사용 &lt;code&gt;credsStore&lt;/code&gt; 또는 &lt;code&gt;auths&lt;/code&gt; 기억 특정 레지스트리에 대한 인증 정보를 검색 할 때. 이 특성을 설정 하면 특정 레지스트리의 신임 정보를 저장하거나 검색 할 때 2 진 &lt;code&gt;docker-credential-&amp;lt;value&amp;gt;&lt;/code&gt; 가 사용됩니다. 자세한 내용 &lt;a href=&quot;../login/index#credential-helpers&quot;&gt;은 &lt;/a&gt; &lt;code&gt;docker login&lt;/code&gt; documentation 의 &lt;strong&gt;Credential helpers&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="885b94cb03ea1c65dc63a5fec3733d6e66bdee06" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;credsStore&lt;/code&gt; specifies an external binary to serve as the default credential store. When this property is set, &lt;code&gt;docker login&lt;/code&gt; will attempt to store credentials in the binary specified by &lt;code&gt;docker-credential-&amp;lt;value&amp;gt;&lt;/code&gt; which is visible on &lt;code&gt;$PATH&lt;/code&gt;. If this property is not set, credentials will be stored in the &lt;code&gt;auths&lt;/code&gt; property of the config. For more information, see the &lt;a href=&quot;../login/index#credentials-store&quot;&gt;&lt;strong&gt;Credentials store&lt;/strong&gt; section in the &lt;code&gt;docker login&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;credsStore&lt;/code&gt; 특성 은 기본 신임 저장소로 사용할 외부 2 진을 지정합니다. 이 속성을 설정하면 &lt;code&gt;docker login&lt;/code&gt; 은 &lt;code&gt;$PATH&lt;/code&gt; 표시 되는 &lt;code&gt;docker-credential-&amp;lt;value&amp;gt;&lt;/code&gt; 로 지정된 이진 파일에 자격 증명을 저장하려고 시도합니다 . 이 특성을 설정하지 않으면 신임 정보가 구성 의 &lt;code&gt;auths&lt;/code&gt; 특성에 저장됩니다 . 자세한 정보 &lt;a href=&quot;../login/index#credentials-store&quot;&gt;는 &lt;/a&gt; &lt;code&gt;docker login&lt;/code&gt; documentation 의 &lt;strong&gt;Credentials store&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="032d9de0808ce12e78a3473ef97c2fc00382a217" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;imagesFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker images&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker images&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see the &lt;a href=&quot;../images/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker images&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;imagesFormat&lt;/code&gt; 속성 은 &lt;code&gt;docker images&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 플래그가 제공되지 않습니다 &lt;code&gt;docker images&lt;/code&gt; 명령, 부두 노동자의 클라이언트는이 속성을 사용합니다. 이 특성을 설정하지 않으면 클라이언트는 기본 테이블 형식으로 돌아갑니다. 지원되는 포맷 지시문 목록은 &lt;a href=&quot;../images/index&quot;&gt; &lt;code&gt;docker images&lt;/code&gt; &lt;/a&gt; 설명서 의 &lt;strong&gt;포맷&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9762ebf835e6bb935778d6f32521ace476e942d" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;nodesFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker node ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker node ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses the value of &lt;code&gt;nodesFormat&lt;/code&gt;. If the value of &lt;code&gt;nodesFormat&lt;/code&gt; is not set, the client uses the default table format. For a list of supported formatting directives, see the &lt;a href=&quot;../node_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker node ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;nodesFormat&lt;/code&gt; 속성 은 &lt;code&gt;docker node ls&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 플래그가 제공되지 않습니다 &lt;code&gt;docker node ls&lt;/code&gt; 명령, 부두 노동자의 클라이언트의 값 사용 &lt;code&gt;nodesFormat&lt;/code&gt; 을 . &lt;code&gt;nodesFormat&lt;/code&gt; 값이 설정되지 않은 경우 클라이언트는 기본 테이블 형식을 사용합니다. 지원되는 형식 지정 문 목록은 &lt;a href=&quot;../node_ls/index&quot;&gt; &lt;code&gt;docker node ls&lt;/code&gt; &lt;/a&gt; documentation 의 &lt;strong&gt;형식 지정&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="674252cd16d5395c7c486b5e598ef4d29bd15baf" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;plugins&lt;/code&gt; contains settings specific to CLI plugins. The key is the plugin name, while the value is a further map of options, which are specific to that plugin.</source>
          <target state="translated">특성 &lt;code&gt;plugins&lt;/code&gt; 에는 CLI 플러그인에 특정한 설정이 포함되어 있습니다. 키는 플러그인 이름이고 값은 해당 플러그인에 특정한 추가 옵션 맵입니다.</target>
        </trans-unit>
        <trans-unit id="16b6f754562d22b95673706648cf3297c4642803" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;pluginsFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker plugin ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker plugin ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see the &lt;a href=&quot;../plugin_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker plugin ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;pluginsFormat&lt;/code&gt; 특성 은 &lt;code&gt;docker plugin ls&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 의 플래그가 제공되지 않습니다 &lt;code&gt;docker plugin ls&lt;/code&gt; 명령, 부두 노동자의 클라이언트는이 속성을 사용합니다. 이 특성을 설정하지 않으면 클라이언트는 기본 테이블 형식으로 돌아갑니다. 지원되는 포맷 지시문 목록은 &lt;a href=&quot;../plugin_ls/index&quot;&gt; &lt;code&gt;docker plugin ls&lt;/code&gt; &lt;/a&gt; documentation 의 &lt;strong&gt;Formatting&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d665772e5032d12e09e20305b4804b9de1d1bb7" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;psFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker ps&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker ps&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see the &lt;a href=&quot;../ps/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker ps&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;psFormat&lt;/code&gt; 속성 은 &lt;code&gt;docker ps&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 의 플래그가 제공되지 않습니다 &lt;code&gt;docker ps&lt;/code&gt; 명령, 부두 노동자의 클라이언트는이 속성을 사용합니다. 이 특성을 설정하지 않으면 클라이언트는 기본 테이블 형식으로 돌아갑니다. 지원되는 포맷 지시문 목록은 &lt;a href=&quot;../ps/index&quot;&gt; &lt;code&gt;docker ps&lt;/code&gt; &lt;/a&gt; documentation 의 &lt;strong&gt;Formatting&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c29241435344425768990fdbce634092e6914be" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;secretFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker secret ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker secret ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see &lt;a href=&quot;../secret_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker secret ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;secretFormat&lt;/code&gt; 속성 은 &lt;code&gt;docker secret ls&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 의 플래그가 제공되지 않습니다 &lt;code&gt;docker secret ls&lt;/code&gt; 명령, 부두 노동자의 클라이언트는이 속성을 사용합니다. 이 특성을 설정하지 않으면 클라이언트는 기본 테이블 형식으로 돌아갑니다. 지원되는 형식 지정 문 목록은 &lt;a href=&quot;../secret_ls/index&quot;&gt; &lt;code&gt;docker secret ls&lt;/code&gt; &lt;/a&gt; documentation 의 &lt;strong&gt;형식 지정&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15f10e024d87a5aa3c77ccceee942e55fd612be9" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;serviceInspectFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker service inspect&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker service inspect&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default json format. For a list of supported formatting directives, see the &lt;a href=&quot;../service_inspect/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker service inspect&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;serviceInspectFormat&lt;/code&gt; 속성 은 &lt;code&gt;docker service inspect&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 의 플래그가 제공되지 않습니다 &lt;code&gt;docker service inspect&lt;/code&gt; 명령, 부두 노동자의 클라이언트가이 속성을 사용합니다. 이 특성을 설정하지 않으면 클라이언트는 기본 json 형식으로 돌아갑니다. 지원되는 형식 지정 문 목록은 &lt;a href=&quot;../service_inspect/index&quot;&gt; &lt;code&gt;docker service inspect&lt;/code&gt; &lt;/a&gt; documentation 의 &lt;strong&gt;형식 지정&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbcbb8f8b6af8aebd036d17bda4cead916d2fab7" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;servicesFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker service ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker service ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default json format. For a list of supported formatting directives, see the &lt;a href=&quot;../service_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker service ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;servicesFormat&lt;/code&gt; 속성 은 &lt;code&gt;docker service ls&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 플래그가 제공되지 않습니다 &lt;code&gt;docker service ls&lt;/code&gt; 명령, 부두 노동자의 클라이언트는이 속성을 사용합니다. 이 특성을 설정하지 않으면 클라이언트는 기본 json 형식으로 돌아갑니다. 지원되는 포맷 지시문 목록은 &lt;a href=&quot;../service_ls/index&quot;&gt; &lt;code&gt;docker service ls&lt;/code&gt; &lt;/a&gt; documentation 의 &lt;strong&gt;Formatting&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29f7b59bf05268406aa48e6182f276000bba09a6" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;stackOrchestrator&lt;/code&gt; specifies the default orchestrator to use when running &lt;code&gt;docker stack&lt;/code&gt; management commands. Valid values are &lt;code&gt;&quot;swarm&quot;&lt;/code&gt;, &lt;code&gt;&quot;kubernetes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;all&quot;&lt;/code&gt;. This property can be overridden with the &lt;code&gt;DOCKER_STACK_ORCHESTRATOR&lt;/code&gt; environment variable, or the &lt;code&gt;--orchestrator&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;stackOrchestrator&lt;/code&gt; 속성 은 &lt;code&gt;docker stack&lt;/code&gt; 관리 명령을 실행할 때 사용할 기본 오케 스트레이터를 지정 합니다. 유효한 값은 &lt;code&gt;&quot;swarm&quot;&lt;/code&gt; , &lt;code&gt;&quot;kubernetes&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 입니다. 이 속성은 &lt;code&gt;DOCKER_STACK_ORCHESTRATOR&lt;/code&gt; 환경 변수 또는 &lt;code&gt;--orchestrator&lt;/code&gt; 플래그 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89096068ab98f54e8022d62790125f24ecea93c3" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;statsFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker stats&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker stats&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see &lt;a href=&quot;../stats/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker stats&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;statsFormat&lt;/code&gt; 속성 은 &lt;code&gt;docker stats&lt;/code&gt; 출력 의 기본 형식을 지정합니다 . 때 &lt;code&gt;--format&lt;/code&gt; 의 플래그가 제공되지 않습니다 &lt;code&gt;docker stats&lt;/code&gt; 명령, 부두 노동자의 클라이언트는이 속성을 사용합니다. 이 특성을 설정하지 않으면 클라이언트는 기본 테이블 형식으로 돌아갑니다. 지원되는 형식 지정 문 목록은 &lt;a href=&quot;../stats/index&quot;&gt; &lt;code&gt;docker stats&lt;/code&gt; &lt;/a&gt; documentation 의 &lt;strong&gt;형식 지정&lt;/strong&gt; 섹션을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e8d8488bd5aeca71220fc57ade98ba0396970b3" translate="yes" xml:space="preserve">
          <source>The proportion will only apply when CPU-intensive processes are running. When tasks in one container are idle, other containers can use the left-over CPU time. The actual amount of CPU time will vary depending on the number of containers running on the system.</source>
          <target state="translated">CPU 집중 프로세스가 실행중인 경우에만 비율이 적용됩니다. 한 컨테이너의 작업이 유휴 상태 인 경우 다른 컨테이너가 남은 CPU 시간을 사용할 수 있습니다. 실제 CPU 시간은 시스템에서 실행되는 컨테이너 수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="29dd043bdbec42216466734cc457a5eb41e7e1d3" translate="yes" xml:space="preserve">
          <source>The protocol to use,</source>
          <target state="translated">사용할 프로토콜</target>
        </trans-unit>
        <trans-unit id="dd4801f0adeb0b0c444ff1a77d62156fc4876952" translate="yes" xml:space="preserve">
          <source>The pull did not complete because the trust system couldn&amp;rsquo;t verify the image.</source>
          <target state="translated">트러스트 시스템이 이미지를 확인할 수 없으므로 풀이 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="05fbaf65a8c8a13a9ab566a2ba1e79a9e9e03a05" translate="yes" xml:space="preserve">
          <source>The quickest way to spin up a full Notary service for testing and development purposes is to use the Docker compose file in the &lt;a href=&quot;https://github.com/docker/notary&quot;&gt;Notary project&lt;/a&gt;.</source>
          <target state="translated">테스트 및 개발 목적으로 전체 공증인 서비스를 시작하는 가장 빠른 방법은 &lt;a href=&quot;https://github.com/docker/notary&quot;&gt;공증인 프로젝트&lt;/a&gt; 에서 Docker compose 파일을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="03aafb92ef99d26e58b4c2893ae4d7e8464a53d1" translate="yes" xml:space="preserve">
          <source>The rate, parallelism, and other parameters of a rollback operation are determined by the values passed with the following flags:</source>
          <target state="translated">롤백 조작의 비율, 병렬 처리 및 기타 매개 변수는 다음 플래그와 함께 전달 된 값에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b246231e5b5b3d634a215da1c5bd509904d947a5" translate="yes" xml:space="preserve">
          <source>The reason both IP addresses work is that nodes in a swarm participate in an ingress &lt;strong&gt;routing mesh&lt;/strong&gt;. This ensures that a service deployed at a certain port within your swarm always has that port reserved to itself, no matter what node is actually running the container. Here&amp;rsquo;s a diagram of how a routing mesh for a service called &lt;code&gt;my-web&lt;/code&gt; published at port &lt;code&gt;8080&lt;/code&gt; on a three-node swarm would look:</source>
          <target state="translated">두 IP 주소가 모두 작동하는 이유는 swarm의 노드가 수신 &lt;strong&gt;라우팅 메쉬에&lt;/strong&gt; 참여하기 때문입니다 . 이를 통해 웜 내의 특정 포트에 배포 된 서비스가 실제로 컨테이너를 실행하는 노드에 관계없이 항상 해당 포트가 자체적으로 예약되도록합니다. 다음 은 3 노드 떼의 포트 &lt;code&gt;8080&lt;/code&gt; 에 게시 된 &lt;code&gt;my-web&lt;/code&gt; 이라는 서비스의 라우팅 메시가 어떻게 보이는지에 대한 다이어그램입니다 .</target>
        </trans-unit>
        <trans-unit id="9ca58fbbf0c45fb062cd8ba7663e5e2b086da215" translate="yes" xml:space="preserve">
          <source>The reason why &lt;em&gt;Docker swarm mode&lt;/em&gt; is using a consensus algorithm is to make sure that all the manager nodes that are in charge of managing and scheduling tasks in the cluster, are storing the same consistent state.</source>
          <target state="translated">&lt;em&gt;Docker swarm 모드&lt;/em&gt; 가 합의 알고리즘을 사용하는 이유 는 클러스터에서 작업 관리 및 예약을 담당하는 모든 관리자 노드가 동일한 일관된 상태를 저장하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2a7ec2d9119bc0f68a55c5feb705fb7e586a2482" translate="yes" xml:space="preserve">
          <source>The reference used to push/pull from a registry</source>
          <target state="translated">레지스트리에서 푸시 / 풀에 사용되는 참조</target>
        </trans-unit>
        <trans-unit id="7569bc34bfdbd4a5889b6033671a33e7ec2584e5" translate="yes" xml:space="preserve">
          <source>The remaining steps in the tutorial don&amp;rsquo;t use the &lt;code&gt;helloworld&lt;/code&gt; service, so now you can delete the service from the swarm.</source>
          <target state="translated">학습서의 나머지 단계는 &lt;code&gt;helloworld&lt;/code&gt; 서비스를 사용하지 않으므로 이제 떼에서 서비스를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ab5290c1463fb3de227a57f2d281e7f50e898ee" translate="yes" xml:space="preserve">
          <source>The remapping itself is handled by two files: &lt;code&gt;/etc/subuid&lt;/code&gt; and &lt;code&gt;/etc/subgid&lt;/code&gt;. Each file works the same, but one is concerned with the user ID range, and the other with the group ID range. Consider the following entry in &lt;code&gt;/etc/subuid&lt;/code&gt;:</source>
          <target state="translated">다시 매핑 자체는 &lt;code&gt;/etc/subuid&lt;/code&gt; 및 &lt;code&gt;/etc/subgid&lt;/code&gt; 파일 두 개로 처리됩니다 . 각 파일은 동일하게 작동하지만 하나는 사용자 ID 범위와 관련되고 다른 하나는 그룹 ID 범위와 관련됩니다. &lt;code&gt;/etc/subuid&lt;/code&gt; 에서 다음 항목을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bf3a365f9776118fbc56e14043d665fdcb36273" translate="yes" xml:space="preserve">
          <source>The reporting section contains any configuration for useful for running the service, such as reporting errors. Currently, Notary only supports reporting errors to &lt;a href=&quot;https://bugsnag.com&quot;&gt;Bugsnag&lt;/a&gt;.</source>
          <target state="translated">보고 섹션에는 오류보고와 같이 서비스를 실행하는 데 유용한 구성이 포함되어 있습니다. 현재 Notary는 &lt;a href=&quot;https://bugsnag.com&quot;&gt;Bugsnag에&lt;/a&gt; 오류보고 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c88d2ba2ed2816515b29f747a56198118252a7d7" translate="yes" xml:space="preserve">
          <source>The root CA rotation will not be completed until all registered nodes have rotated their TLS certificates. If the rotation is not completing within a reasonable amount of time, try running &lt;code&gt;docker node ls --format '{{.ID}} {{.Hostname}} {{.Status}} {{.TLSStatus}}'&lt;/code&gt; to see if any nodes are down or otherwise unable to rotate TLS certificates.</source>
          <target state="translated">등록 된 모든 노드가 TLS 인증서를 교체 할 때까지 루트 CA 교체가 완료되지 않습니다. 적절한 시간 내에 회전이 완료되지 않으면 &lt;code&gt;docker node ls --format '{{.ID}} {{.Hostname}} {{.Status}} {{.TLSStatus}}'&lt;/code&gt; 를 실행 해보십시오. 노드가 다운되었거나 TLS 인증서를 교체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="465cc3be871925b74afbbcaa771fbc172146cce6" translate="yes" xml:space="preserve">
          <source>The root and targets key are generated and stored locally client-side.</source>
          <target state="translated">루트 및 대상 키가 생성되어 로컬 클라이언트 측에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="eb3fbf76706a263fc41ee7f0e5b3732ad52454f6" translate="yes" xml:space="preserve">
          <source>The root certificate to trust for mutual authentication. If provided, any clients connecting to Notary signer need a client certificate signed by this root. If not provided, mutual authentication is not required. The path is relative to the directory of the configuration file.</source>
          <target state="translated">상호 인증을 위해 신뢰하는 루트 인증서입니다. 제공되는 경우, 공증인 서명자에 연결하는 모든 클라이언트는이 루트가 서명 한 클라이언트 인증서가 필요합니다. 제공되지 않으면 상호 인증이 필요하지 않습니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="b91ee6325038098e40965654c5b58f973a1c04a0" translate="yes" xml:space="preserve">
          <source>The root key is the root of all trust. It signs the &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L489&quot;&gt;root metadata file&lt;/a&gt;, which lists the IDs of the root, targets, snapshot, and timestamp public keys. Clients use these public keys to verify the signatures on all the metadata files in the repository. This key is held by a collection owner, and should be kept offline and safe, more so than any other key.</source>
          <target state="translated">루트 키는 모든 신뢰의 루트입니다. 루트, 대상, 스냅 샷 및 타임 스탬프 공개 키의 ID를 나열 하는 &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L489&quot;&gt;루트 메타 데이터 파일에&lt;/a&gt; 서명합니다 . 클라이언트는이 공개 키를 사용하여 저장소의 모든 메타 데이터 파일에서 서명을 확인합니다. 이 키는 컬렉션 소유자가 보유하며 다른 키보다 오프라인 및 안전 상태로 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="b295f881568376eb1d80d57cee88cfe5b7c2bfe9" translate="yes" xml:space="preserve">
          <source>The root/offline key passphrase</source>
          <target state="translated">루트 / 오프라인 키 암호</target>
        </trans-unit>
        <trans-unit id="8102a636a624047ab10c86d269bc0df4dae6624a" translate="yes" xml:space="preserve">
          <source>The rootfs directory</source>
          <target state="translated">rootfs 디렉토리</target>
        </trans-unit>
        <trans-unit id="a8adc27400fa9d16cf99f74a14e6a34821d755bf" translate="yes" xml:space="preserve">
          <source>The routing mesh listens on the published port for any IP address assigned to the node. For externally routable IP addresses, the port is available from outside the host. For all other IP addresses the access is only available from within the host.</source>
          <target state="translated">라우팅 메시는 게시 된 포트에서 노드에 할당 된 모든 IP 주소를 수신합니다. 외부에서 라우팅 가능한 IP 주소의 경우 호스트 외부에서 포트를 사용할 수 있습니다. 다른 모든 IP 주소의 경우 호스트 내에서만 액세스가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="651ea2301cb30ccac05c14bcc4f8596b34135c1e" translate="yes" xml:space="preserve">
          <source>The sample private key files in the Notary repository are obviously public knowledge and using them in a production deployment is highly insecure.</source>
          <target state="translated">Notary 저장소의 샘플 개인 키 파일은 명백히 공개 지식이며 프로덕션 배치에서 파일을 사용하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0680e84ec3606b9b2a28ebd30c137017045206d7" translate="yes" xml:space="preserve">
          <source>The scale command enables you to scale one or more replicated services either up or down to the desired number of replicas. This command cannot be applied on services which are global mode. The command will return immediately, but the actual scaling of the service may take some time. To stop all replicas of a service while keeping the service active in the swarm you can set the scale to 0.</source>
          <target state="translated">scale 명령을 사용하면 하나 이상의 복제 된 서비스를 원하는 수의 복제본으로 늘리거나 줄일 수 있습니다. 글로벌 모드 인 서비스에는이 명령을 적용 할 수 없습니다. 명령이 즉시 반환되지만 서비스의 실제 확장에는 시간이 걸릴 수 있습니다. swarm에서 서비스를 활성 상태로 유지하면서 서비스의 모든 복제본을 중지하려면 스케일을 0으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd5e3a3daf8f3af35f3576952165a75efca3c43f" translate="yes" xml:space="preserve">
          <source>The scheduler applies rolling updates as follows by default:</source>
          <target state="translated">스케줄러는 기본적으로 다음과 같이 롤링 업데이트를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="7fdad0e461a858285fc18d11169e3855ceaafd78" translate="yes" xml:space="preserve">
          <source>The second difference is that the &lt;code&gt;docker-compose run&lt;/code&gt; command does not create any of the ports specified in the service configuration. This prevents port collisions with already-open ports. If you &lt;em&gt;do want&lt;/em&gt; the service&amp;rsquo;s ports to be created and mapped to the host, specify the &lt;code&gt;--service-ports&lt;/code&gt; flag:</source>
          <target state="translated">두 번째 차이점은 &lt;code&gt;docker-compose run&lt;/code&gt; 명령이 서비스 구성에 지정된 포트를 생성하지 않는다는 것입니다. 이것은 이미 열린 포트와 포트 충돌을 방지합니다. 당신이 경우 &lt;em&gt;할까요&lt;/em&gt; 서비스의 포트를 만들고 호스트에 매핑 할, 지정 &lt;code&gt;--service-ports&lt;/code&gt; 플래그 :</target>
        </trans-unit>
        <trans-unit id="1369662f4279d3737e3689ad5061118d736eaf00" translate="yes" xml:space="preserve">
          <source>The second form, &lt;code&gt;ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code&gt;, allows for multiple variables to be set at one time. Notice that the second form uses the equals sign (=) in the syntax, while the first form does not. Like command line parsing, quotes and backslashes can be used to include spaces within values.</source>
          <target state="translated">두 번째 형식 인 &lt;code&gt;ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code&gt; 는 여러 변수를 한 번에 설정할 수 있도록합니다. 두 번째 양식은 구문에서 등호 (=)를 사용하지만 첫 번째 양식은 사용하지 않습니다. 명령 줄 구문 분석과 같이 따옴표와 백 슬래시는 값 내에 공백을 포함하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18b471e24f517ee24f17b02f1944454e7b27901" translate="yes" xml:space="preserve">
          <source>The secrets are each mounted in a &lt;code&gt;tmpfs&lt;/code&gt; filesystem at &lt;code&gt;/run/secrets/mysql_password&lt;/code&gt; and &lt;code&gt;/run/secrets/mysql_root_password&lt;/code&gt;. They are never exposed as environment variables, nor can they be committed to an image if the &lt;code&gt;docker commit&lt;/code&gt; command is run. The &lt;code&gt;mysql_password&lt;/code&gt; secret is the one used by the non-privileged WordPress container to connect to MySQL.</source>
          <target state="translated">비밀은 각각 &lt;code&gt;/run/secrets/mysql_password&lt;/code&gt; 및 &lt;code&gt;/run/secrets/mysql_root_password&lt;/code&gt; 의 &lt;code&gt;tmpfs&lt;/code&gt; 파일 시스템에 마운트됩니다 . &lt;code&gt;docker commit&lt;/code&gt; 명령이 실행 되면 환경 변수로 노출되거나 이미지에 커밋 될 수 없습니다 . &lt;code&gt;mysql_password&lt;/code&gt; 의 비밀은 MySQL로 연결하는 권한이없는 워드 프레스 컨테이너가 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f092993aa746c14f11973e92473a80799b7c5cdb" translate="yes" xml:space="preserve">
          <source>The secrets are stored in the encrypted Raft logs for the swarm.</source>
          <target state="translated">비밀은 웜의 암호화 된 Raft 로그에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a950b0ba4b36dfaab8fd235063e02e8ae56ebb64" translate="yes" xml:space="preserve">
          <source>The sections below provide an inexhaustive overview of available plugins.</source>
          <target state="translated">아래 섹션은 사용 가능한 플러그인에 대한 포괄적 인 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ed44fc39d73da3d657ea6e32cb6e540bcc7e237b" translate="yes" xml:space="preserve">
          <source>The security of keys held and administered by users depends on measures taken by the users. If the Notary Client CLI was used to create them, then they are password protected and the Notary CLI does not provide options to export them in plaintext.</source>
          <target state="translated">사용자가 보유하고 관리하는 키의 보안은 사용자가 취한 조치에 따라 다릅니다. Notary Client CLI를 사용하여 작성한 경우 암호로 보호되며 Notary CLI는 일반 텍스트로 내보내는 옵션을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc6046dbe345edbe3a9289f0ffe25429820506bd" translate="yes" xml:space="preserve">
          <source>The self-signed certificate&amp;rsquo;s subject name and subject alternative names are &lt;code&gt;notary-server&lt;/code&gt;, &lt;code&gt;notaryserver&lt;/code&gt;, and &lt;code&gt;localhost&lt;/code&gt;, so if your Docker host is not on &lt;code&gt;localhost&lt;/code&gt; (for example if you are using Docker Machine), update your hosts file such that the name &lt;code&gt;notary-server&lt;/code&gt; is associated with the IP address of your Docker host.</source>
          <target state="translated">자체 서명 인증서의 주체 이름 및 주체 대체 이름은 &lt;code&gt;notary-server&lt;/code&gt; , &lt;code&gt;notaryserver&lt;/code&gt; 및 &lt;code&gt;localhost&lt;/code&gt; 이므로 Docker 호스트가 &lt;code&gt;localhost&lt;/code&gt; 에 있지 않은 경우 (예 : Docker Machine을 사용하는 경우) 호스트 파일을 업데이트하여 이름이 &lt;code&gt;notary-server&lt;/code&gt; 는 Docker 호스트의 IP 주소와 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="05fc316e8da00fa94322c414c61e50be43f29aa2" translate="yes" xml:space="preserve">
          <source>The sequence diagrams below depict an allow and deny authorization flow:</source>
          <target state="translated">아래 시퀀스 다이어그램은 허용 및 거부 권한 부여 흐름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cfda3a75597b63ea614d8b5f992985ded0fd10f1" translate="yes" xml:space="preserve">
          <source>The server and signer each require a database. These should be separate databases with different users. The users should be limited in their permissions. We recommend giving the following MySQL (or equivalent) permissions to the users restricted to only their own databases:</source>
          <target state="translated">서버와 서명자는 각각 데이터베이스가 필요합니다. 사용자가 다른 별도의 데이터베이스 여야합니다. 사용자는 권한이 제한되어야합니다. 자신의 데이터베이스로만 제한된 사용자에게 다음 MySQL (또는 이와 동등한) 권한을 부여하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a1d5383055ec3d5ebeeb1ca8d9b08a8b9065d399" translate="yes" xml:space="preserve">
          <source>The service is scheduled on an available node. To confirm that the service was created and started successfully, use the &lt;code&gt;docker service ls&lt;/code&gt; command:</source>
          <target state="translated">서비스는 사용 가능한 노드에서 스케줄됩니다. 서비스가 작성되고 성공적으로 시작되었는지 확인하려면 &lt;code&gt;docker service ls&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5355f89c4a23e588939caf6ab76b28c21f8b64ba" translate="yes" xml:space="preserve">
          <source>The service mode determines whether this is a &lt;em&gt;replicated&lt;/em&gt; service or a &lt;em&gt;global&lt;/em&gt; service. A replicated service runs as many tasks as specified, while a global service runs on each active node in the swarm.</source>
          <target state="translated">서비스 모드는 이것이 &lt;em&gt;복제 된&lt;/em&gt; 서비스인지 &lt;em&gt;글로벌&lt;/em&gt; 서비스 인지를 결정합니다 . 복제 된 서비스는 지정된 수만큼 작업을 실행하는 반면 글로벌 서비스는 떼의 각 활성 노드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="82c2d6c046e79fb08237072b087819e985e2f1f6" translate="yes" xml:space="preserve">
          <source>The service that does all the heavy-lifting of managing trust</source>
          <target state="translated">신뢰 관리의 모든 노력을 수행하는 서비스</target>
        </trans-unit>
        <trans-unit id="188371eb2e278b2bcaa57e5e84f1de91dd45b6f9" translate="yes" xml:space="preserve">
          <source>The settings currently supported are:</source>
          <target state="translated">현재 지원되는 설정은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="5e9f71dbad06279098210209165a53aa91ebb9a3" translate="yes" xml:space="preserve">
          <source>The severity of the compromise of a trust collection owner/administrator&amp;rsquo;s decrypted key depends on the type and combination of keys compromised. For example, were the snapshot and targets key both compromised, or just the targets key?</source>
          <target state="translated">신뢰 콜렉션 소유자 / 관리자의 암호 해독 된 키가 손상되는 정도는 손상된 키의 유형 및 조합에 따라 다릅니다. 예를 들어, 스냅 샷 및 대상 키가 모두 손상되었거나 대상 키만 있습니까?</target>
        </trans-unit>
        <trans-unit id="5e285e5fc1c5c5b83b6e6ae21945064a554d6911" translate="yes" xml:space="preserve">
          <source>The short syntax uses the generic &lt;code&gt;[SOURCE:]TARGET[:MODE]&lt;/code&gt; format, where &lt;code&gt;SOURCE&lt;/code&gt; can be either a host path or volume name. &lt;code&gt;TARGET&lt;/code&gt; is the container path where the volume is mounted. Standard modes are &lt;code&gt;ro&lt;/code&gt; for read-only and &lt;code&gt;rw&lt;/code&gt; for read-write (default).</source>
          <target state="translated">짧은 구문은 일반적인 &lt;code&gt;[SOURCE:]TARGET[:MODE]&lt;/code&gt; 형식을 사용합니다. 여기서 &lt;code&gt;SOURCE&lt;/code&gt; 는 호스트 경로 또는 볼륨 이름 일 수 있습니다. &lt;code&gt;TARGET&lt;/code&gt; 은 볼륨이 마운트 된 컨테이너 경로입니다. 표준 모드는 읽기 전용 인 경우 &lt;code&gt;ro&lt;/code&gt; 이고 읽기 / 쓰기 인 경우 &lt;code&gt;rw&lt;/code&gt; 입니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="479ecea93938657188a1718269a0502002d14409" translate="yes" xml:space="preserve">
          <source>The short syntax variant only specifies the config name. This grants the container access to the config and mounts it at &lt;code&gt;/&amp;lt;config_name&amp;gt;&lt;/code&gt; within the container. The source name and destination mountpoint are both set to the config name.</source>
          <target state="translated">짧은 구문 변형은 구성 이름 만 지정합니다. 그러면 컨테이너에 구성에 대한 액세스 권한이 부여되고 컨테이너 내의 &lt;code&gt;/&amp;lt;config_name&amp;gt;&lt;/code&gt; 에 마운트됩니다 . 소스 이름과 대상 마운트 지점은 모두 구성 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cfba78e508fa6569fb674621ccb1b91714d1e973" translate="yes" xml:space="preserve">
          <source>The short syntax variant only specifies the secret name. This grants the container access to the secret and mounts it at &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; within the container. The source name and destination mountpoint are both set to the secret name.</source>
          <target state="translated">짧은 구문 변형은 비밀 이름 만 지정합니다. 그러면 컨테이너에 비밀에 대한 액세스 권한이 부여되고 컨테이너 내의 &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; 에 마운트됩니다 . 소스 이름과 대상 마운트 지점은 모두 비밀 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1da25af45d12b0e226e934e1363a91d8c769594b" translate="yes" xml:space="preserve">
          <source>The shorthand (&lt;code&gt;-h&lt;/code&gt;) is less common than &lt;code&gt;--help&lt;/code&gt; on Linux and cannot be used on all subcommands (due to it conflicting with, e.g. &lt;code&gt;-h&lt;/code&gt; / &lt;code&gt;--hostname&lt;/code&gt; on &lt;code&gt;docker create&lt;/code&gt;). For this reason, the &lt;code&gt;-h&lt;/code&gt; shorthand was not printed in the &amp;ldquo;usage&amp;rdquo; output of subcommands, nor documented, and is now marked &amp;ldquo;deprecated&amp;rdquo;.</source>
          <target state="translated">속기는 ( &lt;code&gt;-h&lt;/code&gt; )보다 일반적이다 &lt;code&gt;--help&lt;/code&gt; 리눅스와 (그것 때문에 예를 들어, 충돌 모든 하위 명령에 사용할 수 없습니다 &lt;code&gt;-h&lt;/code&gt; / &lt;code&gt;--hostname&lt;/code&gt; 에 &lt;code&gt;docker create&lt;/code&gt; ). 이러한 이유로 &lt;code&gt;-h&lt;/code&gt; 속기는 하위 명령의 &quot;usage&quot;출력에 인쇄되지 않았으며 문서화되지 않았으며 이제는 &quot;deprecated&quot;로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1823de424eca78e8cd4261e1adb302d80224200" translate="yes" xml:space="preserve">
          <source>The single copy of &lt;code&gt;visualizer&lt;/code&gt; is running on the manager as you expect, and the 5 instances of &lt;code&gt;web&lt;/code&gt; are spread out across the swarm. You can corroborate this visualization by running &lt;code&gt;docker stack ps &amp;lt;stack&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;visualizer&lt;/code&gt; 의 단일 사본 이 예상대로 관리자에서 실행되고 있으며 5 개의 &lt;code&gt;web&lt;/code&gt; 인스턴스가 떼에 퍼져 있습니다. &lt;code&gt;docker stack ps &amp;lt;stack&amp;gt;&lt;/code&gt; 을 실행하여이 시각화를 확증 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8cd0880463635b8e67d1ef02c532e8c3032cbe66" translate="yes" xml:space="preserve">
          <source>The single-dash (&lt;code&gt;-help&lt;/code&gt;) was removed, in favor of the double-dash &lt;code&gt;--help&lt;/code&gt;</source>
          <target state="translated">단일 대시 ( &lt;code&gt;-help&lt;/code&gt; )는 이중 대시 &lt;code&gt;--help&lt;/code&gt; 를 위해 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="34a4291305962d962a0ae36d42891028cba295a8" translate="yes" xml:space="preserve">
          <source>The size of the VM&amp;rsquo;s disk can be configured this way:</source>
          <target state="translated">VM 디스크의 크기는 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b72510ced0d790516e0ce0a66a581ebc5933ec3f" translate="yes" xml:space="preserve">
          <source>The snapshot (an online) key passphrase</source>
          <target state="translated">스냅 샷 (온라인) 키 비밀번호 문구</target>
        </trans-unit>
        <trans-unit id="64a63b8afef04c5fd245cceea8bf9d95936bf43a" translate="yes" xml:space="preserve">
          <source>The snapshot key signs the &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L604&quot;&gt;snapshot metadata file&lt;/a&gt;, which enumerates the filenames, sizes, and hashes of the root, targets, and delegation metadata files for the collection. This file is used to verify the integrity of the other metadata files. The snapshot key is held by either a collection owner/administrator, or held by the Notary service to facilitate &lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;signing by multiple collaborators via delegation roles&lt;/a&gt;.</source>
          <target state="translated">스냅 샷 키는 &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L604&quot;&gt;스냅 샷 메타 데이터 파일에&lt;/a&gt; 서명합니다 .이 파일은 컬렉션에 대한 루트, 대상 및 위임 메타 데이터 파일의 파일 이름, 크기 및 해시를 열거합니다. 이 파일은 다른 메타 데이터 파일의 무결성을 확인하는 데 사용됩니다. 스냅 샷 키는 컬렉션 소유자 / 관리자 또는 공증인 서비스가 보유 &lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;하여 위임 역할을 통해 여러 공동 작업자&lt;/a&gt; 가 쉽게 서명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3009e949c1d5550b7288bb677530e0a0ba478ba" translate="yes" xml:space="preserve">
          <source>The solution is to use &lt;code&gt;ONBUILD&lt;/code&gt; to register advance instructions to run later, during the next build stage.</source>
          <target state="translated">해결책은 &lt;code&gt;ONBUILD&lt;/code&gt; 를 사용 하여 다음 빌드 단계에서 나중에 실행할 고급 명령을 등록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b8f682785a6e43ae0cbbde58fcc4f0b5598edd1" translate="yes" xml:space="preserve">
          <source>The storage section specifies which storage backend the server should use to store TUF metadata. Only MySQL or an in-memory store is supported.</source>
          <target state="translated">스토리지 섹션은 서버가 TUF 메타 데이터를 저장하는 데 사용해야하는 스토리지 백엔드를 지정합니다. MySQL 또는 인 메모리 저장소 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7071e38fef942da46e433f01278d254227287231" translate="yes" xml:space="preserve">
          <source>The structure and permitted configuration keys</source>
          <target state="translated">구조 및 허용 된 구성 키</target>
        </trans-unit>
        <trans-unit id="ea12639961c26144f02d08ab564148f99bd4aa3b" translate="yes" xml:space="preserve">
          <source>The subnet range comes from the &lt;code&gt;--default-addr-pool&lt;/code&gt;, (such as &lt;code&gt;10.10.0.0/16&lt;/code&gt;). The size of 16 there represents the number of networks one can create within that &lt;code&gt;default-addr-pool&lt;/code&gt; range. The &lt;code&gt;--default-address-pool&lt;/code&gt; option may occur multiple times with each option providing additional addresses for docker to use for overlay subnets.</source>
          <target state="translated">서브넷 범위는 &lt;code&gt;--default-addr-pool&lt;/code&gt; 에서 가져옵니다 (예 : &lt;code&gt;10.10.0.0/16&lt;/code&gt; ). 16의 크기는 해당 &lt;code&gt;default-addr-pool&lt;/code&gt; 범위 내에서 만들 수있는 네트워크 수를 나타냅니다 . &lt;code&gt;--default-address-pool&lt;/code&gt; 옵션은 오버레이 서브넷에 사용할 고정 표시기에 대한 추가 주소를 제공하는 각각의 옵션을 여러 번 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f4fcc17f1c191d796a33a3a9af64120d639fd0d" translate="yes" xml:space="preserve">
          <source>The subordinate UID and GID ranges must be associated with an existing user, even though the association is an implementation detail. The user owns the namespaced storage directories under &lt;code&gt;/var/lib/docker/&lt;/code&gt;. If you don&amp;rsquo;t want to use an existing user, Docker can create one for you and use that. If you want to use an existing username or user ID, it must already exist. Typically, this means that the relevant entries need to be in &lt;code&gt;/etc/passwd&lt;/code&gt; and &lt;code&gt;/etc/group&lt;/code&gt;, but if you are using a different authentication back-end, this requirement may translate differently.</source>
          <target state="translated">연관이 구현 세부 사항이지만 하위 UID 및 GID 범위는 기존 사용자와 연관되어야합니다. 사용자는 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 아래에 네임 스페이스가있는 스토리지 디렉토리를 소유합니다 . 기존 사용자를 사용하지 않으려는 경우 Docker가 사용자를 대신하여 사용할 수 있습니다. 기존 사용자 이름 또는 사용자 ID를 사용하려면 이미 존재해야합니다. 일반적으로 이는 관련 항목이 &lt;code&gt;/etc/passwd&lt;/code&gt; 및 &lt;code&gt;/etc/group&lt;/code&gt; 에 있어야 함을 의미 하지만 다른 인증 백엔드를 사용하는 경우이 요구 사항이 다르게 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41d38596a5c2344ff17e02b039500f02d18f800e" translate="yes" xml:space="preserve">
          <source>The supported flags are as follows:</source>
          <target state="translated">지원되는 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53bda3a84f325c0d6fe257e495edda6f4f91eef8" translate="yes" xml:space="preserve">
          <source>The supported flags are the following :</source>
          <target state="translated">지원되는 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21892ba3c3ab5a265fafe92a1d86c39ed241c3d6" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;, and their alternative notation &lt;code&gt;kb&lt;/code&gt;, &lt;code&gt;mb&lt;/code&gt; and &lt;code&gt;gb&lt;/code&gt;. Decimal values are not supported at this time.</source>
          <target state="translated">지원되는 단위는 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;g&lt;/code&gt; 및 대체 표기법 &lt;code&gt;kb&lt;/code&gt; , &lt;code&gt;mb&lt;/code&gt; 및 &lt;code&gt;gb&lt;/code&gt; 입니다. 현재 10 진수 값은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="807cd4896b900c1b59b5b7d890258f1331a14b7c" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;code&gt;us&lt;/code&gt;, &lt;code&gt;ms&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">지원되는 단위는 &lt;code&gt;us&lt;/code&gt; , &lt;code&gt;ms&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;h&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ee7b3ee3acebd9009344f2838f9b5ae0e30b16d9" translate="yes" xml:space="preserve">
          <source>The swarm extends &lt;code&gt;my-network&lt;/code&gt; to each node running the service.</source>
          <target state="translated">떼는 &lt;code&gt;my-network&lt;/code&gt; 를 서비스를 실행하는 각 노드로 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="e8db2ff14bf4c80ac8a86419be635fcf751e90ef" translate="yes" xml:space="preserve">
          <source>The swarm extends my-network to each node running the service.</source>
          <target state="translated">떼는 내 네트워크를 서비스를 실행하는 각 노드로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="2bf9f6bd81f0a82dc7b12293d79dee778c3d6d05" translate="yes" xml:space="preserve">
          <source>The swarm manager maintains the desired state by ending the task on a node with &lt;code&gt;Drain&lt;/code&gt; availability and creating a new task on a node with &lt;code&gt;Active&lt;/code&gt; availability.</source>
          <target state="translated">떼 관리자는 &lt;code&gt;Drain&lt;/code&gt; 가용성이 있는 노드에서 작업을 종료하고 &lt;code&gt;Active&lt;/code&gt; 가용성이 있는 노드에서 새 작업을 생성 하여 원하는 상태를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="65790f3186fe670370e99c3c01ba5d4fbd93871e" translate="yes" xml:space="preserve">
          <source>The swarm manager uses &lt;strong&gt;ingress load balancing&lt;/strong&gt; to expose the services you want to make available externally to the swarm. The swarm manager can automatically assign the service a &lt;strong&gt;PublishedPort&lt;/strong&gt; or you can configure a PublishedPort for the service. You can specify any unused port. If you do not specify a port, the swarm manager assigns the service a port in the 30000-32767 range.</source>
          <target state="translated">웜 관리자는 &lt;strong&gt;수신로드 밸런싱&lt;/strong&gt; 을 사용 하여 웜 외부에서 제공하려는 서비스를 노출합니다. 스웜 관리자는 서비스에 &lt;strong&gt;PublishedPort를&lt;/strong&gt; 자동으로 할당하거나 서비스에 대해 &lt;strong&gt;PublishedPort&lt;/strong&gt; 를 구성 할 수 있습니다. 사용하지 않는 포트를 지정할 수 있습니다. 포트를 지정하지 않으면 swarm 관리자는 서비스에 30000-32767 범위의 포트를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="56909f0d7f17f9e0bbe59c5689143779666dbf5a" translate="yes" xml:space="preserve">
          <source>The swarm mode public key infrastructure (PKI) system built into Docker makes it simple to securely deploy a container orchestration system. The nodes in a swarm use mutual Transport Layer Security (TLS) to authenticate, authorize, and encrypt the communications with other nodes in the swarm.</source>
          <target state="translated">Docker에 내장 된 swarm 모드 공개 키 인프라 (PKI) 시스템을 사용하면 컨테이너 오케스트레이션 시스템을 안전하게 배포 할 수 있습니다. 웜의 노드는 상호 TLS (Transport Layer Security)를 사용하여 웜의 다른 노드와의 통신을 인증, 권한 부여 및 암호화합니다.</target>
        </trans-unit>
        <trans-unit id="177825a6c20f4575a9a1b1e5fdac44315634cd55" translate="yes" xml:space="preserve">
          <source>The syntax directive defines the location of the Dockerfile builder that is used for building the current Dockerfile. The BuildKit backend allows to seamlessly use external implementations of builders that are distributed as Docker images and execute inside a container sandbox environment.</source>
          <target state="translated">구문 지시문은 현재 Dockerfile을 빌드하는 데 사용되는 Dockerfile 빌더의 위치를 ​​정의합니다. BuildKit 백엔드는 Docker 이미지로 배포되고 컨테이너 샌드 박스 환경 내에서 실행되는 외부 빌더 구현을 원활하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e83e8c32440b639e2870f007f94e67fbe95cc31" translate="yes" xml:space="preserve">
          <source>The syntax for file globbing in AppArmor is a bit different than some other globbing implementations. It is highly suggested you take a look at some of the below resources with regard to AppArmor profile syntax.</source>
          <target state="translated">AppArmor의 파일 globbing 구문은 다른 globbing 구현과 약간 다릅니다. AppArmor 프로파일 구문과 관련하여 아래 리소스 중 일부를 살펴 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9b7bd5feec5d7731585bce13eb511ccb98f70714" translate="yes" xml:space="preserve">
          <source>The syntax for using built-in networks such as &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;none&lt;/code&gt; is a little different. Define an external network with the name &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt; (that Docker has already created automatically) and an alias that Compose can use (&lt;code&gt;hostnet&lt;/code&gt; or &lt;code&gt;nonet&lt;/code&gt; in the following examples), then grant the service access to that network using the alias.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;none&lt;/code&gt; 과 같은 내장 네트워크를 사용하는 구문 은 약간 다릅니다. 이름이 &lt;code&gt;host&lt;/code&gt; 이거나 &lt;code&gt;none&lt;/code&gt; (Docker가 이미 자동으로 생성 한) 및 Compose가 사용할 수있는 별명 ( 다음 예에서 &lt;code&gt;hostnet&lt;/code&gt; 또는 &lt;code&gt;nonet&lt;/code&gt; )으로 외부 네트워크를 정의한 후 별명을 사용하여 해당 네트워크에 서비스 액세스 권한을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="f0ff47db46947fd89be3900e6662eb377c24199a" translate="yes" xml:space="preserve">
          <source>The systemd cgroup driver has different rules for &lt;code&gt;--cgroup-parent&lt;/code&gt;. Systemd represents hierarchy by slice and the name of the slice encodes the location in the tree. So &lt;code&gt;--cgroup-parent&lt;/code&gt; for systemd cgroups should be a slice name. A name can consist of a dash-separated series of names, which describes the path to the slice from the root slice. For example, &lt;code&gt;--cgroup-parent=user-a-b.slice&lt;/code&gt; means the memory cgroup for the container is created in &lt;code&gt;/sys/fs/cgroup/memory/user.slice/user-a.slice/user-a-b.slice/docker-&amp;lt;id&amp;gt;.scope&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--cgroup-parent&lt;/code&gt; cgroup 드라이버에는 --cgroup-parent에 대한 규칙이 다릅니다 . Systemd는 슬라이스로 계층 구조를 나타내며 슬라이스 이름은 트리의 위치를 ​​인코딩합니다. 따라서 &lt;code&gt;--cgroup-parent&lt;/code&gt; cgroup의 --cgroup-parent 는 슬라이스 이름이어야합니다. 이름은 루트 슬라이스에서 슬라이스로의 경로를 설명하는 대시로 구분 된 일련의 이름으로 구성 될 수 있습니다. 예를 들어, &lt;code&gt;--cgroup-parent=user-a-b.slice&lt;/code&gt; 컨테이너의 메모리가 cgroup에에서 생성 수단 &lt;code&gt;/sys/fs/cgroup/memory/user.slice/user-a.slice/user-a-b.slice/docker-&amp;lt;id&amp;gt;.scope&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0533656b4b74c590cc6513549d259075f037f41c" translate="yes" xml:space="preserve">
          <source>The table below shows what command is executed for different &lt;code&gt;ENTRYPOINT&lt;/code&gt; / &lt;code&gt;CMD&lt;/code&gt; combinations:</source>
          <target state="translated">아래 표는 다른 &lt;code&gt;ENTRYPOINT&lt;/code&gt; / &lt;code&gt;CMD&lt;/code&gt; 조합에 대해 실행되는 명령을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0185173a349942562bd58274872dd22dc8f0e29c" translate="yes" xml:space="preserve">
          <source>The target port within the container and the port to map it to on the nodes, using the routing mesh (</source>
          <target state="translated">컨테이너 내 대상 포트 및 라우팅 메시를 사용하여 노드에 매핑 할 포트 (</target>
        </trans-unit>
        <trans-unit id="01f09d14eb7d87e9c346afdcc156ecf97088e58b" translate="yes" xml:space="preserve">
          <source>The targets (an online) key passphrase</source>
          <target state="translated">대상 (온라인) 키 비밀번호 문구</target>
        </trans-unit>
        <trans-unit id="69ce8dd4214ab3a54dcd700601b8837bbda45bf0" translate="yes" xml:space="preserve">
          <source>The targets key must be locally managed - to rotate the targets key, for instance in case of compromise, use the &lt;code&gt;notary key rotate targets&lt;/code&gt; command without the &lt;code&gt;-r&lt;/code&gt; flag.</source>
          <target state="translated">대상 키를 로컬로 관리해야합니다. 예를 들어 손상이 발생한 경우 &lt;code&gt;notary key rotate targets&lt;/code&gt; 하려면 &lt;code&gt;-r&lt;/code&gt; 플래그 없이 notary key rotate targets 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="097f73b93a96add7eae69c74428e99d8d28480db" translate="yes" xml:space="preserve">
          <source>The targets key signs the &lt;a href=&quot;ttps://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L678&quot;&gt;targets metadata file&lt;/a&gt;, which lists filenames in the collection, and their sizes and respective &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;hashes&lt;/a&gt;. This file is used to verify the integrity of some or all of the actual contents of the repository. It is also used to &lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;delegate trust to other collaborators via delegation roles&lt;/a&gt;. The targets key is held by the collection owner or administrator.</source>
          <target state="translated">targets 키는 &lt;a href=&quot;ttps://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L678&quot;&gt;대상의 메타 데이터 파일에&lt;/a&gt; 서명합니다. 이 메타 데이터 파일 에는 컬렉션의 파일 이름과 크기 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;해시&lt;/a&gt; 가 나열 됩니다. 이 파일은 저장소의 일부 또는 모든 실제 컨텐츠의 무결성을 검증하는 데 사용됩니다. 또한 &lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;위임 역할을 통해 다른 공동 작업자에게 신뢰&lt;/a&gt; 를 위임 하는 데 사용됩니다 . 대상 키는 컬렉션 소유자 또는 관리자가 보유합니다.</target>
        </trans-unit>
        <trans-unit id="8e03566e6e6cb3a1a03671d36368093bc50beb83" translate="yes" xml:space="preserve">
          <source>The timestamp and snapshot keys are safely generated and stored in a signing server that is deployed alongside the Docker registry. These keys are generated in a backend service that isn&amp;rsquo;t directly exposed to the internet and are encrypted at rest.</source>
          <target state="translated">타임 스탬프 및 스냅 샷 키는 Docker 레지스트리와 함께 배포되는 서명 서버에 안전하게 생성되고 저장됩니다. 이러한 키는 백엔드 서비스에서 생성되며 인터넷에 직접 노출되지 않으며 유휴 상태에서 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="3d18b09fad96c7637380585b8bee68a93fdbc75f" translate="yes" xml:space="preserve">
          <source>The timestamp key signs the &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L827&quot;&gt;timestamp metadata file&lt;/a&gt;, which provides freshness guarantees for the collection by having the shortest expiry time of any particular piece of metadata and by specifying the filename, size, and hash of the most recent snapshot for the collection. It is used to verify the integrity of the snapshot file. The timestamp key is held by the Notary service so the timestamp can be automatically re-generated when it is requested from the server, rather than require that a collection owner come online before each timestamp expiry.</source>
          <target state="translated">타임 스탬프 키는 &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L827&quot;&gt;타임 스탬프 메타 데이터 파일에&lt;/a&gt; 서명합니다.이 타임 스탬프 메타 데이터 파일 은 특정 메타 데이터의 만료 시간이 가장 짧고 컬렉션에 대한 최신 스냅 샷의 파일 이름, 크기 및 해시를 지정하여 컬렉션에 대한 최신 정보를 제공합니다. 스냅 샷 파일의 무결성을 확인하는 데 사용됩니다. 타임 스탬프 키는 Notary 서비스에 의해 유지되므로 각 타임 스탬프 만료 전에 컬렉션 소유자가 온라인 상태가되도록하는 것이 아니라 서버에서 요청할 때 타임 스탬프를 자동으로 다시 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="704394fd5b8493bd6e289ef12138c69f8e714fdb" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;configs&lt;/code&gt; declaration defines or references &lt;a href=&quot;../../engine/swarm/configs/index&quot;&gt;configs&lt;/a&gt; that can be granted to the services in this stack. The source of the config is either &lt;code&gt;file&lt;/code&gt; or &lt;code&gt;external&lt;/code&gt;.</source>
          <target state="translated">최상위 &lt;code&gt;configs&lt;/code&gt; 선언은 이 스택의 서비스에 부여 할 수있는 &lt;a href=&quot;../../engine/swarm/configs/index&quot;&gt;구성&lt;/a&gt; 을 정의하거나 참조합니다 . 구성의 소스는 &lt;code&gt;file&lt;/code&gt; 또는 &lt;code&gt;external&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06c35a757b239c69a0548e919ffccda1b64e9cb1" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;networks&lt;/code&gt; key lets you specify networks to be created.</source>
          <target state="translated">최상위 &lt;code&gt;networks&lt;/code&gt; 키를 사용하면 생성 할 네트워크를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7414ff9907a0e9a522d26984ac446fdfa9604491" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;networks&lt;/code&gt; key lets you specify networks to be created. For a full explanation of Compose&amp;rsquo;s use of Docker networking features, see the &lt;a href=&quot;../../networking/index&quot;&gt;Networking guide&lt;/a&gt;.</source>
          <target state="translated">최상위 &lt;code&gt;networks&lt;/code&gt; 키를 사용하면 생성 할 네트워크를 지정할 수 있습니다. Compose의 Docker 네트워킹 기능 사용에 대한 전체 설명은 &lt;a href=&quot;../../networking/index&quot;&gt;네트워킹 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0390c92b705085454360c5f24d96c5340fcc7036" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;secrets&lt;/code&gt; declaration defines or references &lt;a href=&quot;../../engine/swarm/secrets/index&quot;&gt;secrets&lt;/a&gt; that can be granted to the services in this stack. The source of the secret is either &lt;code&gt;file&lt;/code&gt; or &lt;code&gt;external&lt;/code&gt;.</source>
          <target state="translated">최상위 &lt;code&gt;secrets&lt;/code&gt; 선언은 이 스택의 서비스에 부여 할 수있는 &lt;a href=&quot;../../engine/swarm/secrets/index&quot;&gt;비밀&lt;/a&gt; 을 정의하거나 참조합니다 . 비밀의 출처는 &lt;code&gt;file&lt;/code&gt; 또는 &lt;code&gt;external&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="322e63c416ba6a457d865d372c3db8990b527d11" translate="yes" xml:space="preserve">
          <source>The topics below describe available options to set resource constraints on services or containers in a swarm.</source>
          <target state="translated">아래 주제는 스웜의 서비스 또는 컨테이너에 대한 자원 제한 조건을 설정하는 데 사용 가능한 옵션을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="54cf08ae091cd1246737172b45300405441fa449" translate="yes" xml:space="preserve">
          <source>The topics below explain the differences among the versions, Docker Engine compatibility, and &lt;a href=&quot;#upgrading&quot;&gt;how to upgrade&lt;/a&gt;.</source>
          <target state="translated">아래 주제는 버전 간의 차이점, Docker Engine 호환성 및 &lt;a href=&quot;#upgrading&quot;&gt;업그레이드 방법에 대해 설명합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ed6348d39665453e5afbba76aa26e4b42d3aec5" translate="yes" xml:space="preserve">
          <source>The topics on this reference page are organized alphabetically by top-level key to reflect the structure of the Compose file itself. Top-level keys that define a section in the configuration file such as &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;deploy&lt;/code&gt;, &lt;code&gt;depends_on&lt;/code&gt;, &lt;code&gt;networks&lt;/code&gt;, and so on, are listed with the options that support them as sub-topics. This maps to the &lt;code&gt;&amp;lt;key&amp;gt;: &amp;lt;option&amp;gt;: &amp;lt;value&amp;gt;&lt;/code&gt; indent structure of the Compose file.</source>
          <target state="translated">이 참조 페이지의 주제는 Compose 파일 자체의 구조를 반영하기 위해 최상위 키를 기준으로 사전 순으로 구성됩니다. 구성 파일에서 &lt;code&gt;build&lt;/code&gt; , &lt;code&gt;deploy&lt;/code&gt; , &lt;code&gt;depends_on&lt;/code&gt; , &lt;code&gt;networks&lt;/code&gt; 등과 같은 섹션을 정의하는 최상위 키는 하위 주제로이를 지원하는 옵션과 함께 나열됩니다. 이는 작성 파일 의 &lt;code&gt;&amp;lt;key&amp;gt;: &amp;lt;option&amp;gt;: &amp;lt;value&amp;gt;&lt;/code&gt; 들여 쓰기 구조에 맵핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="6c53132ec117df95bc0650452a0b9339edb16b37" translate="yes" xml:space="preserve">
          <source>The transfer of context from the local machine to the Docker daemon is what the &lt;code&gt;docker&lt;/code&gt; client means when you see the &amp;ldquo;Sending build context&amp;rdquo; message.</source>
          <target state="translated">도커 데몬에 로컬 컴퓨터에서 컨텍스트의 전송은 무엇 &lt;code&gt;docker&lt;/code&gt; 클라이언트 수단은 당신이 &quot;빌드 컨텍스트를 보내기&quot;메시지가 나타날 때.</target>
        </trans-unit>
        <trans-unit id="95f5b0e2ba8bddb684a7c26a00396d9830eeafb5" translate="yes" xml:space="preserve">
          <source>The tutorial guides you through the following activities:</source>
          <target state="translated">학습서는 다음 활동을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="6b5befa58d03f8a29b0c139f5cc34961087af58e" translate="yes" xml:space="preserve">
          <source>The tutorial uses &lt;code&gt;manager1&lt;/code&gt; : &lt;code&gt;192.168.99.100&lt;/code&gt;.</source>
          <target state="translated">이 튜토리얼에서는 &lt;code&gt;manager1&lt;/code&gt; : &lt;code&gt;192.168.99.100&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e7c05446c0a238cd4c756284cf18fb1555be975d" translate="yes" xml:space="preserve">
          <source>The type of mount, can be either</source>
          <target state="translated">마운트 유형은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="808a955c835bc826a78db93a8f283cb1de51c319" translate="yes" xml:space="preserve">
          <source>The underlying logic of Docker swarm mode is a general purpose scheduler and orchestrator. The service and task abstractions themselves are unaware of the containers they implement. Hypothetically, you could implement other types of tasks such as virtual machine tasks or non-containerized process tasks. The scheduler and orchestrator are agnostic about the type of task. However, the current version of Docker only supports container tasks.</source>
          <target state="translated">Docker swarm 모드의 기본 논리는 범용 스케줄러 및 오케 스트레이터입니다. 서비스 및 작업 추상화 자체는 구현하는 컨테이너를 인식하지 못합니다. 가상 머신 작업 또는 컨테이너가 아닌 프로세스 작업과 같은 다른 유형의 작업을 구현할 수 있습니다. 스케줄러와 오케 스트레이터는 작업 유형에 대해 독립적입니다. 그러나 현재 Docker 버전은 컨테이너 작업 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="077b2070cdc00a73a64fa6daed16da1a2d09e083" translate="yes" xml:space="preserve">
          <source>The unknown directive is treated as a comment due to not being recognized. In addition, the known directive is treated as a comment due to appearing after a comment which is not a parser directive.</source>
          <target state="translated">알 수없는 지시문은 인식되지 않아 주석으로 처리됩니다. 또한 알려진 지시문은 구문 분석기 지시문이 아닌 주석 뒤에 표시되므로 주석으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="813604c1f616eff640341fd47c3ef347077481ed" translate="yes" xml:space="preserve">
          <source>The user as which docker-machine should log in to the Linode instance to install Docker. This user must have passwordless sudo.</source>
          <target state="translated">Docker를 설치하려면 Docker 시스템이 Linode 인스턴스에 로그인해야하는 사용자입니다. 이 사용자에게는 비밀번호가없는 sudo가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9576dab363bda69179f31e7cb6a084eeae7e6f30" translate="yes" xml:space="preserve">
          <source>The user identification</source>
          <target state="translated">사용자 식별</target>
        </trans-unit>
        <trans-unit id="950b799dd4aed77dfb0676c4acc74f28e973ee02" translate="yes" xml:space="preserve">
          <source>The usual cause of this error is that the container has a volume (defined either in its image or in the Compose file) without an explicit mapping, and so in order to preserve its data, Compose has directed Swarm to schedule the new container on the same node as the old container. This results in a port clash.</source>
          <target state="translated">이 오류의 일반적인 원인은 컨테이너에 명시적인 매핑이없는 볼륨 (이미지 또는 작성 파일에 정의되어 있음)이 있으므로 데이터를 보존하기 위해 Compose가 Swarm에게 새 컨테이너를 예약하도록 지시했습니다. 이전 컨테이너와 동일한 노드 포트 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a787679f2f02da5f6dce687df16d0ad2de650af" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;VAL&lt;/code&gt; is used as is and not modified at all. For example if the value is surrounded by quotes (as is often the case of shell variables), the quotes are included in the value passed to Compose.</source>
          <target state="translated">&lt;code&gt;VAL&lt;/code&gt; 값은 그대로 사용되며 전혀 수정되지 않습니다. 예를 들어 값이 따옴표로 묶인 경우 (쉘 변수의 경우와 같이) 따옴표는 Compose에 전달 된 값에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="61609f3bd2f21ab04e9d50f0aa0ad5208715c1ba" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;DEBUG&lt;/code&gt; variable in the container is taken from the value for the same variable in the shell in which Compose is run.</source>
          <target state="translated">컨테이너 의 &lt;code&gt;DEBUG&lt;/code&gt; 변수 값은 작성이 실행되는 쉘의 동일한 변수 값에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="746c6ac6a23b8454770142b20f0126d7ade6f0e5" translate="yes" xml:space="preserve">
          <source>The value returned is not the password, but the ID of the secret. In the remainder of this tutorial, the ID output is omitted.</source>
          <target state="translated">리턴 된 값은 비밀번호가 아니라 비밀번호의 ID입니다. 이 학습서의 나머지 부분에서는 ID 출력이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="1889542e56eda59f3d3d8ea98417148b9aec534d" translate="yes" xml:space="preserve">
          <source>The values are sent to the appropriate &lt;code&gt;syscall&lt;/code&gt; as they are set. Docker doesn&amp;rsquo;t perform any byte conversion. Take this into account when setting the values.</source>
          <target state="translated">값은 설정된대로 해당 시스템 &lt;code&gt;syscall&lt;/code&gt; 로 전송됩니다 . Docker는 바이트 변환을 수행하지 않습니다. 값을 설정할 때 이것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="50d5528070cdcdf314e138aa479cb9727774525f" translate="yes" xml:space="preserve">
          <source>The variable expansion technique in this example allows you to pass arguments from the command line and persist them in the final image by leveraging the &lt;code&gt;ENV&lt;/code&gt; instruction. Variable expansion is only supported for &lt;a href=&quot;#environment-replacement&quot;&gt;a limited set of Dockerfile instructions.&lt;/a&gt;</source>
          <target state="translated">이 예제의 변수 확장 기술을 사용하면 명령 줄에서 인수를 전달하고 &lt;code&gt;ENV&lt;/code&gt; 명령어를 사용 하여 최종 이미지에서 인수를 유지할 수 있습니다 . 변수 확장은 &lt;a href=&quot;#environment-replacement&quot;&gt;제한된 Dockerfile 명령어 세트에&lt;/a&gt; 대해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad9e412128cae9e2070e957151f854e8924ad398" translate="yes" xml:space="preserve">
          <source>The visualizer is a standalone service that can run in any app that includes it in the stack. It doesn&amp;rsquo;t depend on anything else. Now let&amp;rsquo;s create a service that &lt;em&gt;does&lt;/em&gt; have a dependency: the Redis service that provides a visitor counter.</source>
          <target state="translated">Visualizer는 스택에 포함 된 모든 앱에서 실행할 수있는 독립 실행 형 서비스입니다. 다른 것에 의존하지 않습니다. 이제 서비스를 만들 수 &lt;em&gt;않는&lt;/em&gt; 방문자 카운터를 제공하는 레디 스 서비스 : 종속성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="984e84f6857002353b6ddc22dd16cfaabdf532de" translate="yes" xml:space="preserve">
          <source>The volume name is a human-readable name for the volume, and cannot begin with a &lt;code&gt;/&lt;/code&gt; character. It is referred to as &lt;code&gt;volume_name&lt;/code&gt; in the rest of this topic.</source>
          <target state="translated">볼륨 이름은 사람이 읽을 수있는 볼륨 이름이며 &lt;code&gt;/&lt;/code&gt; 문자로 시작할 수 없습니다 . 이 주제의 나머지 부분에서 &lt;code&gt;volume_name&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="0783572785fa9651cdf59fe05a1291f10567dced" translate="yes" xml:space="preserve">
          <source>The volume you created that lets the container access &lt;code&gt;./data&lt;/code&gt; (on the host) as &lt;code&gt;/data&lt;/code&gt; (inside the Redis container). While containers come and go, the files stored on &lt;code&gt;./data&lt;/code&gt; on the specified host persists, enabling continuity.</source>
          <target state="translated">컨테이너가 &lt;code&gt;./data&lt;/code&gt; (호스트의)를 &lt;code&gt;/data&lt;/code&gt; (Redis 컨테이너 내부 )로 액세스 할 수 있도록 생성 한 볼륨 입니다. 컨테이너가 들어오고 나가는 동안 지정된 호스트의 &lt;code&gt;./data&lt;/code&gt; 에 저장된 파일 은 지속되므로 연속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4942b66d1eb91033003011fbf6eb332e419dd45c" translate="yes" xml:space="preserve">
          <source>The volumes commands are complex enough to have their own documentation in section &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;&lt;em&gt;Use volumes&lt;/em&gt;&lt;/a&gt;. A developer can define one or more &lt;code&gt;VOLUME&lt;/code&gt;&amp;rsquo;s associated with an image, but only the operator can give access from one container to another (or from a container to a volume mounted on the host).</source>
          <target state="translated">볼륨 명령은 &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;&lt;em&gt;볼륨 사용&lt;/em&gt;&lt;/a&gt; 섹션에 자체 문서가있을 정도로 복잡 합니다. 개발자는 이미지와 관련된 하나 이상의 &lt;code&gt;VOLUME&lt;/code&gt; 을 정의 할 수 있지만 운영자 만 한 컨테이너에서 다른 컨테이너로 (또는 컨테이너에서 호스트에 마운트 된 볼륨으로) 액세스 권한을 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cde13cc54c1b745deadeca881f546b49d1ec0604" translate="yes" xml:space="preserve">
          <source>The way the namespace remapping is handled on the host is using two files, &lt;code&gt;/etc/subuid&lt;/code&gt; and &lt;code&gt;/etc/subgid&lt;/code&gt;. These files are typically managed automatically when you add or remove users or groups, but on a few distributions such as RHEL and CentOS 7.3, you may need to manage these files manually.</source>
          <target state="translated">호스트에서 네임 스페이스 다시 매핑이 처리되는 방식은 &lt;code&gt;/etc/subuid&lt;/code&gt; 및 &lt;code&gt;/etc/subgid&lt;/code&gt; 의 두 파일을 사용하는 것 입니다. 이러한 파일은 일반적으로 사용자 또는 그룹을 추가하거나 제거 할 때 자동으로 관리되지만 RHEL 및 CentOS 7.3과 같은 일부 배포에서는 이러한 파일을 수동으로 관리해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45b1f6108a82bf67b71c85d0639d5979f14f7ca" translate="yes" xml:space="preserve">
          <source>Then make sure the experimental flag is enabled:</source>
          <target state="translated">그런 다음 실험용 플래그가 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f0f9379ccf766a586a4628c88e3a02475ae34742" translate="yes" xml:space="preserve">
          <source>Then reload your shell:</source>
          <target state="translated">그런 다음 쉘을 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="16ac1788505b466a3f21ddb8e7fff258927db3f1" translate="yes" xml:space="preserve">
          <source>Then run it, mapping the exposed port to one on the host</source>
          <target state="translated">그런 다음 노출 된 포트를 호스트의 포트에 매핑하여 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ba0f97060d2e1000948b0ee70a4d723aaa8a3cc9" translate="yes" xml:space="preserve">
          <source>Then run the following command to download the current stable release of Compose (v1.24.1):</source>
          <target state="translated">그런 다음 다음 명령을 실행하여 Compose의 현재 안정 릴리스 (v1.24.1)를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="228d7d3092c1d2d33a29a03d6afceb9497d2f340" translate="yes" xml:space="preserve">
          <source>Then specify the arguments under the &lt;code&gt;build&lt;/code&gt; key. You can pass a mapping or a list:</source>
          <target state="translated">그런 다음 &lt;code&gt;build&lt;/code&gt; 키 아래에 인수를 지정하십시오 . 매핑 또는 목록을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f619b0978d2bfc96e064c4f4798aa4408b70e708" translate="yes" xml:space="preserve">
          <source>Then start your Docker daemon with &lt;code&gt;HTTPS_PROXY=http://username:password@proxy:port/ dockerd&lt;/code&gt;. The &lt;code&gt;username:&lt;/code&gt; and &lt;code&gt;password@&lt;/code&gt; are optional - and are only needed if your proxy is set up to require authentication.</source>
          <target state="translated">그런 다음 &lt;code&gt;HTTPS_PROXY=http://username:password@proxy:port/ dockerd&lt;/code&gt; Docker 데몬을 시작하십시오 . &lt;code&gt;username:&lt;/code&gt; 및 &lt;code&gt;password@&lt;/code&gt; 선택 - 그리고 프록시가 인증을 요구하도록 설정되어있는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c079d6aea55289143434dbc5a465fbbf83112617" translate="yes" xml:space="preserve">
          <source>Then they can send it to whichever CA you trust to sign certificates, or they can self-sign the certificate (in this example, creating a certificate that is valid for 1 year):</source>
          <target state="translated">그런 다음 인증서 서명을 신뢰하는 어느 CA로나 보내거나 인증서에 자체 서명 할 수 있습니다 (이 예에서는 1 년 동안 유효한 인증서 만들기).</target>
        </trans-unit>
        <trans-unit id="67b4998ea0be4fba5d41e8c39a43342f50125aea" translate="yes" xml:space="preserve">
          <source>Then they need to generate an x509 certificate containing the public key, which is what you need from them. Here is the command to generate a CSR (certificate signing request):</source>
          <target state="translated">그런 다음 공개 키가 포함 된 x509 인증서를 생성해야합니다. CSR (인증서 서명 요청)을 생성하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f98543252d0cf2bd1bc0835d978d514dcdabc924" translate="yes" xml:space="preserve">
          <source>Then they need to give you &lt;code&gt;delegation.crt&lt;/code&gt;, whether it is self-signed or signed by a CA.</source>
          <target state="translated">그런 다음 CA가 자체 서명했거나 서명했는지 여부에 관계없이 &lt;code&gt;delegation.crt&lt;/code&gt; 를 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7f0f2bd70f5c8bbac6125eb7ed05e5ef0b2fdf49" translate="yes" xml:space="preserve">
          <source>Then write a docker-compose file that bind mounts it in:</source>
          <target state="translated">그런 다음 바인드로 마운트하는 도커 작성 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2f8d9774582e7502132f5270ffce97532f11b56e" translate="yes" xml:space="preserve">
          <source>Then you can set:</source>
          <target state="translated">그런 다음 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571bfb0a1edc1b50bdfe5e978fd0ae01ac16b272" translate="yes" xml:space="preserve">
          <source>Then you need to run &lt;code&gt;source /etc/bash_completion.d/docker-machine-prompt.bash&lt;/code&gt; in your bash terminal to tell your setup where it can find the file &lt;code&gt;docker-machine-prompt.bash&lt;/code&gt; that you previously downloaded.</source>
          <target state="translated">그런 다음 bash 터미널에서 &lt;code&gt;source /etc/bash_completion.d/docker-machine-prompt.bash&lt;/code&gt; 를 실행 하여 이전에 다운로드 한 &lt;code&gt;docker-machine-prompt.bash&lt;/code&gt; 파일을 찾을 수있는 위치를 설정 해야합니다.</target>
        </trans-unit>
        <trans-unit id="da78cfe7ed5b6cb10ab0b2174b36663e652c5c77" translate="yes" xml:space="preserve">
          <source>Then you provide account verification, security credentials, and configuration options for the providers as flags to &lt;code&gt;docker-machine create&lt;/code&gt;. The flags are unique for each cloud-specific driver. For instance, to pass a DigitalOcean access token you use the &lt;code&gt;--digitalocean-access-token&lt;/code&gt; flag. Take a look at the examples below for DigitalOcean and AWS.</source>
          <target state="translated">그런 다음 공급자에 대한 계정 확인, 보안 자격 증명 및 구성 옵션을 &lt;code&gt;docker-machine create&lt;/code&gt; 플래그로 제공 합니다. 플래그는 각 클라우드 특정 드라이버마다 고유합니다. 예를 들어, DigitalOcean 액세스 토큰을 전달하려면 &lt;code&gt;--digitalocean-access-token&lt;/code&gt; 플래그 를 사용하십시오 . DigitalOcean 및 AWS에 대한 아래 예를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="199f762f8c8d3029eb46e8f8b8d9f5acda2921b7" translate="yes" xml:space="preserve">
          <source>Then, a user could ask &lt;code&gt;udev&lt;/code&gt; to execute a script that would &lt;code&gt;docker exec my-container mknod newDevX c 42 &amp;lt;minor&amp;gt;&lt;/code&gt; the required device when it is added.</source>
          <target state="translated">그런 다음 사용자는 &lt;code&gt;udev&lt;/code&gt; 에게 필요한 &lt;code&gt;docker exec my-container mknod newDevX c 42 &amp;lt;minor&amp;gt;&lt;/code&gt; 를 추가 할 때 my-container mknod newDevX c 42 &amp;lt;minor&amp;gt; 를 실행하는 스크립트를 실행 하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2854e1d7f0e6d6eec93f6eab6fe27b1c48cc1487" translate="yes" xml:space="preserve">
          <source>Then, assume this image is built with this command:</source>
          <target state="translated">그런 다음이 이미지가 다음 명령으로 빌드되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="e6079812a1f2778a6a21c1d63667ecca6da677c8" translate="yes" xml:space="preserve">
          <source>Then, install the latest release of the Linode machine driver for your environment from the &lt;a href=&quot;https://github.com/linode/docker-machine-driver-linode/releases&quot;&gt;releases list&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://github.com/linode/docker-machine-driver-linode/releases&quot;&gt;릴리스 목록&lt;/a&gt; 에서 환경에 맞는 최신 Linode 시스템 드라이버 릴리스를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="6806394a7c9ad960785738687166412a97ca5e1a" translate="yes" xml:space="preserve">
          <source>Then, run the custom profile with &lt;code&gt;--security-opt&lt;/code&gt; like so:</source>
          <target state="translated">그런 다음 &lt;code&gt;--security-opt&lt;/code&gt; 를 사용하여 사용자 정의 프로파일을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="b73e331846444f80e366e7040fb663466a3470e0" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://github.com/search?q=in%3Apath+docker-compose.yml+extension%3Ayml&amp;amp;type=Code&quot;&gt;many examples of Compose files on github&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/search?q=in%3Apath+docker-compose.yml+extension%3Ayml&amp;amp;type=Code&quot;&gt;github에는 Compose 파일의 많은 예가&lt;/a&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7814cd8379144950605ca794127eccce00dcde3" translate="yes" xml:space="preserve">
          <source>There are currently three versions of the Compose file format:</source>
          <target state="translated">작성 파일 형식에는 현재 세 가지 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7940b6f7dad82d1a9e956120f2b7089211bf1646" translate="yes" xml:space="preserve">
          <source>There are five possible container IDs all cycling by randomly, demonstrating the load-balancing.</source>
          <target state="translated">로드 밸런싱을 보여 주면서 무작위로 사이클링 할 수있는 5 개의 컨테이너 ID가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0de849851d22b43f8ffa512bd662db77eca8ad" translate="yes" xml:space="preserve">
          <source>There are four major areas to consider when reviewing Docker security:</source>
          <target state="translated">Docker 보안을 검토 할 때 고려해야 할 4 가지 주요 영역이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d778b5b15fe825c32888587cbc69d4f27f45b66" translate="yes" xml:space="preserve">
          <source>There are multiple parts of Compose that deal with environment variables in one sense or another. This page should help you find the information you need.</source>
          <target state="translated">Compose에는 환경 변수를 다루는 여러 부분이 있습니다. 이 페이지는 필요한 정보를 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="aeda8a40ea312e9777dda9667b4da9b34a9d0320" translate="yes" xml:space="preserve">
          <source>There are several cases where the user might want to set options for the created Docker engine (also known as the Docker &lt;em&gt;daemon&lt;/em&gt;) themselves. For example, they may want to allow connection to a &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;registry&lt;/a&gt; that they are running themselves using the &lt;code&gt;--insecure-registry&lt;/code&gt; flag for the daemon. Docker Machine supports the configuration of such options for the created engines via the &lt;code&gt;create&lt;/code&gt; command flags which begin with &lt;code&gt;--engine&lt;/code&gt;.</source>
          <target state="translated">사용자가 생성 된 Docker 엔진 (Docker &lt;em&gt;데몬&lt;/em&gt; 이라고도 함 ) 자체에 대한 옵션을 설정하려는 경우가 있습니다. 예를 들어, 데몬에 대해 &lt;code&gt;--insecure-registry&lt;/code&gt; 플래그를 사용하여 자신이 실행중인 &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;레지스트리&lt;/a&gt; 에 대한 연결을 허용 할 수 있습니다 . Docker Machine은 &lt;code&gt;--engine&lt;/code&gt; 으로 시작 하는 &lt;code&gt;create&lt;/code&gt; 명령 플래그를 통해 생성 된 엔진에 대한 이러한 옵션 구성을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="97ca57e34878d9d455f58028c76cb939649ff43d" translate="yes" xml:space="preserve">
          <source>There are several things to be aware of when using &lt;code&gt;depends_on&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;depends_on&lt;/code&gt; 을 사용할 때주의해야 할 사항이 몇 가지 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91711ed59c8022626f780ec2fbf3eb54e0f15adc" translate="yes" xml:space="preserve">
          <source>There are several things to note, depending on which &lt;a href=&quot;../compose-versioning/index#versioning&quot;&gt;Compose file version&lt;/a&gt; you&amp;rsquo;re using:</source>
          <target state="translated">사용중인 &lt;a href=&quot;../compose-versioning/index#versioning&quot;&gt;작성 파일 버전&lt;/a&gt; 에 따라 몇 가지주의해야 할 사항 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0187ca342f3a08a30c681cab0c7791034bfb8706" translate="yes" xml:space="preserve">
          <source>There are several versions of the Compose file format &amp;ndash; 1, 2, 2.x, and 3.x</source>
          <target state="translated">Compose 파일 형식에는 1, 2, 2.x 및 3.x의 여러 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25125d555c6868815e8ee9d7df65db55c5d2807c" translate="yes" xml:space="preserve">
          <source>There are several versions of the Compose file format &amp;ndash; 1, 2, 2.x, and 3.x The table below is a quick look. For full details on what each version includes and how to upgrade, see &lt;strong&gt;&lt;a href=&quot;../compose-versioning/index&quot;&gt;About versions and upgrading&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Compose 파일 형식에는 1, 2, 2.x 및 3.x의 여러 버전이 있습니다. 아래 표는 간략하게 보여줍니다. 각 버전에 포함 된 내용 및 업그레이드 방법에 대한 자세한 내용은 &lt;strong&gt;&lt;a href=&quot;../compose-versioning/index&quot;&gt;버전 및 업그레이드 정보를&lt;/a&gt;&lt;/strong&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40bc0cbdfa8ca5327db23d0dec4ef03b9664c4f2" translate="yes" xml:space="preserve">
          <source>There are several versions of the Compose file format &amp;ndash; 1, 2, 2.x, and 3.x. The table below is a quick look. For full details on what each version includes and how to upgrade, see &lt;strong&gt;&lt;a href=&quot;compose-versioning/index&quot;&gt;About versions and upgrading&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Compose 파일 형식에는 1, 2, 2.x 및 3.x의 여러 버전이 있습니다. 아래 표는 간략히 보여줍니다. 각 버전에 포함 된 내용 및 업그레이드 방법에 대한 자세한 내용은 &lt;strong&gt;&lt;a href=&quot;compose-versioning/index&quot;&gt;버전 및 업그레이드 정보를&lt;/a&gt;&lt;/strong&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="741d63007545485e619b16d848df8c7aff45bdf3" translate="yes" xml:space="preserve">
          <source>There are some variations in behavior between the two methods, so report any issues or inconsistencies if you come across them.</source>
          <target state="translated">두 방법 간에는 동작에 약간의 차이가 있으므로 문제 나 불일치를 발견하면보고하십시오.</target>
        </trans-unit>
        <trans-unit id="e78ebb7a2059162d806fa2029f73ae7c6fcfa1b2" translate="yes" xml:space="preserve">
          <source>There are three types of files which can be put in the plugin directory.</source>
          <target state="translated">플러그인 디렉토리에는 세 가지 유형의 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cf0c0eaad237b6c73a28f6dd75f35d7f472776e" translate="yes" xml:space="preserve">
          <source>There are two options for trust pinning user-signed images:</source>
          <target state="translated">트러스트 고정 사용자 서명 이미지에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ecf6e9b95eb4c02baccc868b92d4665fe217696" translate="yes" xml:space="preserve">
          <source>There are two types of nodes: &lt;a href=&quot;#manager-nodes&quot;&gt;&lt;strong&gt;managers&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;#worker-nodes&quot;&gt;&lt;strong&gt;workers&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">노드에는 &lt;a href=&quot;#manager-nodes&quot;&gt;&lt;strong&gt;관리자&lt;/strong&gt;&lt;/a&gt; 와 작업 &lt;a href=&quot;#worker-nodes&quot;&gt;&lt;strong&gt;자라는&lt;/strong&gt;&lt;/a&gt; 두 가지 유형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc09e07084850510543084daf1f91c42a9f17fe3" translate="yes" xml:space="preserve">
          <source>There are two types of service deployments, replicated and global.</source>
          <target state="translated">서비스 배포에는 복제 및 전역의 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="45b1371ce6228c69ca79895526ca065b03babbe6" translate="yes" xml:space="preserve">
          <source>There are two viable workarounds for this problem:</source>
          <target state="translated">이 문제에 대한 해결 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbd4f77633783e3c8d534038973dd23605b9f89f" translate="yes" xml:space="preserve">
          <source>There are two ways to connect to the PostgreSQL server. We can use &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&lt;em&gt;Link Containers&lt;/em&gt;&lt;/a&gt;, or we can access it from our host (or the network).</source>
          <target state="translated">PostgreSQL 서버에 연결하는 방법은 두 가지가 있습니다. &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&lt;em&gt;링크 컨테이너&lt;/em&gt;&lt;/a&gt; 를 사용 하거나 호스트 (또는 네트워크)에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a9bea40f116e961dedc24c36590df75bee7e1ef" translate="yes" xml:space="preserve">
          <source>There are two ways to run the Engine in swarm mode:</source>
          <target state="translated">스웜 모드에서 엔진을 실행하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f54c1303cdfa771953ec88e0bfab370d1cdc3de0" translate="yes" xml:space="preserve">
          <source>There can only be one &lt;code&gt;CMD&lt;/code&gt; instruction in a &lt;code&gt;Dockerfile&lt;/code&gt;. If you list more than one &lt;code&gt;CMD&lt;/code&gt; then only the last &lt;code&gt;CMD&lt;/code&gt; will take effect.</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 에는 하나의 &lt;code&gt;CMD&lt;/code&gt; 명령 만있을 수 있습니다 . 둘 이상의 &lt;code&gt;CMD&lt;/code&gt; 를 나열 하면 마지막 &lt;code&gt;CMD&lt;/code&gt; 만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="550d578e017477c6594796ed69856a32f3fde0d2" translate="yes" xml:space="preserve">
          <source>There can only be one &lt;code&gt;HEALTHCHECK&lt;/code&gt; instruction in a Dockerfile. If you list more than one then only the last &lt;code&gt;HEALTHCHECK&lt;/code&gt; will take effect.</source>
          <target state="translated">&lt;code&gt;HEALTHCHECK&lt;/code&gt; 에는 하나의 HEALTHCHECK 명령 만있을 수 있습니다 . 둘 이상을 나열하면 마지막 &lt;code&gt;HEALTHCHECK&lt;/code&gt; 만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0df320a875323d0c7c7d6a4f46cd3776c2f98030" translate="yes" xml:space="preserve">
          <source>There has already been a lot written about this problem of &lt;a href=&quot;https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86&quot;&gt;processes handling signals&lt;/a&gt; in containers.</source>
          <target state="translated">컨테이너에서 &lt;a href=&quot;https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86&quot;&gt;신호&lt;/a&gt; 를 처리하는 프로세스 의이 문제에 대해 이미 많은 글이 있었습니다.</target>
        </trans-unit>
        <trans-unit id="77d469c7c182850a6574b09d72ba3863433df44e" translate="yes" xml:space="preserve">
          <source>There is a limit to the number of machines that an anti-affinity group can have. This can be worked around by specifying an additional anti-affinity group using &lt;code&gt;--exoscale-affinity-group=docker-machineX&lt;/code&gt;</source>
          <target state="translated">반 선호 그룹이 가질 수있는 시스템 수에는 제한이 있습니다. &lt;code&gt;--exoscale-affinity-group=docker-machineX&lt;/code&gt; 를 사용하여 추가 반 선호도 그룹을 지정하면이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a003cd7737f7589bad419544346f832d93be43fc" translate="yes" xml:space="preserve">
          <source>There is a side effect when using this flag: user remapping will not be enabled for that container but, because the read-only (image) layers are shared between containers, ownership of the the containers filesystem will still be remapped.</source>
          <target state="translated">이 플래그를 사용하면 부작용이 있습니다. 해당 컨테이너에 대해 사용자 재 매핑을 사용할 수 없지만 컨테이너간에 읽기 전용 (이미지) 레이어가 공유되므로 컨테이너 파일 시스템의 소유권은 여전히 ​​재 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="807fe7b30bf42d01a6f7b614c0c1e3e2cf015de6" translate="yes" xml:space="preserve">
          <source>There is also a long format, which is easier to read and allows you to specify more options. The long format is preferred. You cannot specify the service&amp;rsquo;s mode when using the short format. Here is an example of using the long format for the same service as above:</source>
          <target state="translated">또한 읽기 쉬운 형식과 더 많은 옵션을 지정할 수있는 긴 형식이 있습니다. 긴 형식이 선호됩니다. 짧은 형식을 사용할 때는 서비스 모드를 지정할 수 없습니다. 위와 동일한 서비스에 긴 형식을 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7159817725d7d3f10517f75ce07ddcc5d62ded9f" translate="yes" xml:space="preserve">
          <source>There is much more to the Docker platform than what was covered here, but you have a good idea of the basics of containers, images, services, swarms, stacks, scaling, load-balancing, volumes, and placement constraints.</source>
          <target state="translated">Docker 플랫폼에는 여기에서 다루는 것보다 훨씬 더 많은 것이 있지만 컨테이너, 이미지, 서비스, 스웜, 스택, 스케일링,로드 밸런싱, 볼륨 및 배치 제약 조건의 기초를 잘 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ea1f9e166a0f3ace0e8c4e2faba71437003d220" translate="yes" xml:space="preserve">
          <source>There is no limit on the number of manager nodes. The decision about how many manager nodes to implement is a trade-off between performance and fault-tolerance. Adding manager nodes to a swarm makes the swarm more fault-tolerant. However, additional manager nodes reduce write performance because more nodes must acknowledge proposals to update the swarm state. This means more network round-trip traffic.</source>
          <target state="translated">관리자 노드 수에는 제한이 없습니다. 구현할 관리자 노드 수에 대한 결정은 성능과 내결함성 간의 균형입니다. 웜에 관리자 노드를 추가하면 웜에 대한 내결함성이 높아집니다. 그러나 추가 관리자 노드는 더 많은 노드가 swarm 상태를 업데이트하기위한 제안을 승인해야하기 때문에 쓰기 성능을 저하시킵니다. 이는 더 많은 네트워크 왕복 트래픽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c46ae2b51f093b4d567a20743cf894773a9d4341" translate="yes" xml:space="preserve">
          <source>There is no memory limit for the container. The container can use as much memory as needed.</source>
          <target state="translated">컨테이너에 대한 메모리 제한이 없습니다. 컨테이너는 필요한만큼의 메모리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54df66a39d52c7bcabb4266fa44bd074305be26b" translate="yes" xml:space="preserve">
          <source>There is no special handling of quotation marks. This means that &lt;strong&gt;they are part of the VAL&lt;/strong&gt;.</source>
          <target state="translated">따옴표에는 특별한 처리가 없습니다. 이는 &lt;strong&gt;이들이 VAL의 일부&lt;/strong&gt; 임을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="bc8488fc468fa3d5bf59b15f4d91a3229dc387f4" translate="yes" xml:space="preserve">
          <source>There may be cases where you want to use both. You can have the image include the code using a &lt;code&gt;COPY&lt;/code&gt;, and use a &lt;code&gt;volume&lt;/code&gt; in your Compose file to include the code from the host during development. The volume overrides the directory contents of the image.</source>
          <target state="translated">두 가지를 모두 사용하려는 경우가 있습니다. &lt;code&gt;COPY&lt;/code&gt; 를 사용하여 이미지에 코드 가 포함되도록하고 Compose 파일 의 &lt;code&gt;volume&lt;/code&gt; 을 사용하여 개발 중에 호스트의 코드를 포함시킬 수 있습니다. 볼륨이 이미지의 디렉토리 내용보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9151a652d582569b556b13188766c2cd2a43286b" translate="yes" xml:space="preserve">
          <source>Therefore, node labels can be used to limit critical tasks to nodes that meet certain requirements. For example, schedule only on machines where special workloads should be run, such as machines that meet &lt;a href=&quot;https://www.pcisecuritystandards.org/&quot;&gt;PCI-SS compliance&lt;/a&gt;.</source>
          <target state="translated">따라서 노드 레이블을 사용하여 중요한 작업을 특정 요구 사항을 충족하는 노드로 제한 할 수 있습니다. 예를 들어, &lt;a href=&quot;https://www.pcisecuritystandards.org/&quot;&gt;PCI-SS 준수&lt;/a&gt; 를 충족하는 시스템과 같이 특수한 워크로드를 실행해야하는 시스템에서만 스케줄하십시오 .</target>
        </trans-unit>
        <trans-unit id="311428cc61f122ac8f0ff1fe39f6b93b94ca88a8" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ctrl-a&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, or &lt;code&gt;ctrl-\\&lt;/code&gt; values are all examples of valid key sequences. To configure a different configuration default key sequence for all containers, see &lt;a href=&quot;../cli/index#configuration-files&quot;&gt;&lt;strong&gt;Configuration file&lt;/strong&gt; section&lt;/a&gt;.</source>
          <target state="translated">이러한 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;ctrl-a&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;ctrl-\\&lt;/code&gt; 값은 모두 유효한 키 시퀀스의 예입니다. 모든 컨테이너에 대해 다른 구성 기본 키 시퀀스를 구성하려면 &lt;a href=&quot;../cli/index#configuration-files&quot;&gt;&lt;strong&gt;구성 파일&lt;/strong&gt; 섹션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64b5474c1794485b2d40653c9e2e09081765ab8a" translate="yes" xml:space="preserve">
          <source>These Go environment variables are case-insensitive. See the &lt;a href=&quot;http://golang.org/pkg/net/http/&quot;&gt;Go specification&lt;/a&gt; for details on these variables.</source>
          <target state="translated">이러한 Go 환경 변수는 대소 문자를 구분하지 않습니다. 이러한 변수에 대한 자세한 내용은 &lt;a href=&quot;http://golang.org/pkg/net/http/&quot;&gt;Go 사양&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ba86a5d568343c9da0766df96e235161cf63bc5" translate="yes" xml:space="preserve">
          <source>These Go environment variables are case-insensitive. See the &lt;a href=&quot;https://golang.org/pkg/net/http/&quot;&gt;Go specification&lt;/a&gt; for details on these variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31caaf6623b9c633e6c1073eb9040be966d639aa" translate="yes" xml:space="preserve">
          <source>These are created once when the first machine is created and reused afterwards. Although they are free resources, driver does a best effort to clean them up after the last machine using these resources is removed.</source>
          <target state="translated">이들은 첫 번째 머신이 생성 된 후 한 번 생성되어 나중에 재사용됩니다. 무료 리소스이지만 드라이버는 이러한 리소스를 사용하는 마지막 시스템이 제거 된 후 정리를 위해 최선을 다합니다.</target>
        </trans-unit>
        <trans-unit id="39fe1e5ad586d0e7cf7856a65e7b6669576d3d25" translate="yes" xml:space="preserve">
          <source>These are the ports you need to expose for each service:</source>
          <target state="translated">각 서비스에 노출해야하는 포트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bac967147ac9fac7063b2796ffd0dbb09be399f8" translate="yes" xml:space="preserve">
          <source>These arguments are defined in the global scope so are not automatically available inside build stages or for your &lt;code&gt;RUN&lt;/code&gt; commands. To expose one of these arguments inside the build stage redefine it without value.</source>
          <target state="translated">이러한 인수는 전역 범위에서 정의되므로 빌드 단계 또는 &lt;code&gt;RUN&lt;/code&gt; 명령에서 자동으로 사용할 수 없습니다 . 빌드 단계에서 이러한 인수 중 하나를 표시하려면 값없이 다시 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="584b62ca74acc41372cd2036de01d6464c923b50" translate="yes" xml:space="preserve">
          <source>These command examples shows a Bash shell. For a different shell, such as C Shell, the same commands are the same except where noted.</source>
          <target state="translated">이 명령 예제는 Bash 쉘을 보여줍니다. C 쉘과 같은 다른 쉘의 경우, 언급 된 경우를 제외하고 동일한 명령은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e74c851f71498e84ce39a15acf42934d7c72f3de" translate="yes" xml:space="preserve">
          <source>These differences are explained below.</source>
          <target state="translated">이러한 차이점은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7246908a42dc07a518a78b2cabf07f47d70b301a" translate="yes" xml:space="preserve">
          <source>These flags were added before Docker 1.0, so will not be &lt;em&gt;removed&lt;/em&gt;, only &lt;em&gt;hidden&lt;/em&gt;, to discourage their use.</source>
          <target state="translated">이러한 플래그는 도커 1.0 이전에 추가 된, 그렇게되지 않습니다 &lt;em&gt;제거&lt;/em&gt; 만 &lt;em&gt;숨겨진&lt;/em&gt; 사용을 억제하기 위해.</target>
        </trans-unit>
        <trans-unit id="c2b20459caa4cc0cc4428337ecd3dbaee5eb97fb" translate="yes" xml:space="preserve">
          <source>These instructions assume you are running in Linux or macOS. You can run this sandbox on a local machine or on a virtual machine. You need to have privileges to run docker commands on your local machine or in the VM.</source>
          <target state="translated">이 지시 사항은 Linux 또는 macOS에서 실행중인 것으로 가정합니다. 이 샌드 박스를 로컬 컴퓨터 나 가상 컴퓨터에서 실행할 수 있습니다. 로컬 컴퓨터 또는 VM에서 docker 명령을 실행하려면 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d8c56cad2f39c4a7b2f668100d9da8dd6631ef4" translate="yes" xml:space="preserve">
          <source>These instructions assume you have installed the Docker Engine 1.12 or later on a machine to serve as a manager node in your swarm.</source>
          <target state="translated">이 지시 사항은 웜에서 관리자 노드 역할을 할 시스템에 Docker Engine 1.12 이상을 설치했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="84e044fa18790282168ffba099e31deab2a0f085" translate="yes" xml:space="preserve">
          <source>These options are passed directly to the volume driver. Options for different volume drivers may do different things (or nothing at all).</source>
          <target state="translated">이 옵션은 볼륨 드라이버로 직접 전달됩니다. 다른 볼륨 드라이버 옵션은 다른 작업을 수행하거나 전혀 수행하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230271f219630a6dfecde6978e6f7c8484085c31" translate="yes" xml:space="preserve">
          <source>These parameters always set an upper limit on the memory available to the container. On Linux, this is set on the cgroup and applications in a container can query it at &lt;code&gt;/sys/fs/cgroup/memory/memory.limit_in_bytes&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 항상 컨테이너가 사용할 수있는 메모리의 상한을 설정합니다. Linux에서 이는 cgroup에 설정되며 컨테이너의 응용 프로그램은 &lt;code&gt;/sys/fs/cgroup/memory/memory.limit_in_bytes&lt;/code&gt; 에서이를 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb1e65e28097900a5e6798cdcb5c67d92ccb7612" translate="yes" xml:space="preserve">
          <source>These portable images are defined by something called a &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">이러한 휴대용 이미지는 &lt;code&gt;Dockerfile&lt;/code&gt; 이라는 것으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="c44349d63c8f29613ee6fa93097acd99df2851dd" translate="yes" xml:space="preserve">
          <source>These properties are deprecated in favor of per-network properties in &lt;code&gt;NetworkSettings.Networks&lt;/code&gt;. These properties were already &amp;ldquo;deprecated&amp;rdquo; in docker 1.9, but kept around for backward compatibility.</source>
          <target state="translated">이러한 속성은 &lt;code&gt;NetworkSettings.Networks&lt;/code&gt; 의 네트워크 별 속성을 위해 더 이상 사용되지 않습니다 . 이 속성은 docker 1.9에서 이미 &quot;더 이상 사용되지 않지만&quot;이전 버전과의 호환성을 위해 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="95ad3420806ce4f7e45f02368e5d74ee7259066d" translate="yes" xml:space="preserve">
          <source>These settings are determined by the &lt;a href=&quot;https://hub.docker.com/images/postgres&quot;&gt;postgres&lt;/a&gt; Docker image specified in &lt;code&gt;docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">이 설정은 &lt;code&gt;docker-compose.yml&lt;/code&gt; 에 지정된 &lt;a href=&quot;https://hub.docker.com/images/postgres&quot;&gt;postgres&lt;/a&gt; Docker 이미지에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0006a01688ee5bb8760e82efcaab62e7a7b452cd" translate="yes" xml:space="preserve">
          <source>These syntax rules apply to the &lt;code&gt;.env&lt;/code&gt; file:</source>
          <target state="translated">이 구문 규칙은 &lt;code&gt;.env&lt;/code&gt; 파일에 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4632832f247dcfe72ed61367b13859852ff268" translate="yes" xml:space="preserve">
          <source>These topics describe version 1 of the Compose file format. This is the oldest version.</source>
          <target state="translated">이 주제에서는 Compose 파일 형식의 버전 1에 대해 설명합니다. 가장 오래된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="37e57e0e52a34f096be81802356245c57ce84aec" translate="yes" xml:space="preserve">
          <source>These topics describe version 2 of the Compose file format.</source>
          <target state="translated">이 주제에서는 Compose 파일 형식의 버전 2에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="239f599300fe3779fc761e4efc4bdc384fbe57be" translate="yes" xml:space="preserve">
          <source>These topics describe version 3 of the Compose file format. This is the newest version.</source>
          <target state="translated">이 주제에서는 Compose 파일 형식의 버전 3에 대해 설명합니다. 이것은 최신 버전입니다.</target>
        </trans-unit>
        <trans-unit id="9bf35be4d7ca6fb7048d753152c839ba29757169" translate="yes" xml:space="preserve">
          <source>These two &lt;code&gt;docker build&lt;/code&gt; commands do the exact same thing. They both use the contents of the &lt;code&gt;debug&lt;/code&gt; file instead of looking for a &lt;code&gt;Dockerfile&lt;/code&gt; and will use &lt;code&gt;/home/me/myapp&lt;/code&gt; as the root of the build context. Note that &lt;code&gt;debug&lt;/code&gt; is in the directory structure of the build context, regardless of how you refer to it on the command line.</source>
          <target state="translated">이 두 &lt;code&gt;docker build&lt;/code&gt; 명령은 똑같은 일을합니다. 둘 다 &lt;code&gt;Dockerfile&lt;/code&gt; 을 찾는 대신 &lt;code&gt;debug&lt;/code&gt; 파일 의 내용을 사용 하며 빌드 컨텍스트의 루트로 &lt;code&gt;/home/me/myapp&lt;/code&gt; 를 사용합니다. 참고 &lt;code&gt;debug&lt;/code&gt; 관계없이 명령 행에서이를 참조하는 방법, 빌드 환경의 디렉토리 구조에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bc9ec20c6ba6550b3916f42f42debaecc83c305" translate="yes" xml:space="preserve">
          <source>They should keep &lt;code&gt;delegation.key&lt;/code&gt; private because it is used to sign tags.</source>
          <target state="translated">태그에 서명하는 데 사용되므로 &lt;code&gt;delegation.key&lt;/code&gt; 를 비공개로 유지해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f8bb7a76c170c136f81e1e0fbc79c555341c4e8c" translate="yes" xml:space="preserve">
          <source>This (size) will allow to set the container rootfs size to 120G at creation time. This option is only available for the &lt;code&gt;devicemapper&lt;/code&gt;, &lt;code&gt;btrfs&lt;/code&gt;, &lt;code&gt;overlay2&lt;/code&gt;, &lt;code&gt;windowsfilter&lt;/code&gt; and &lt;code&gt;zfs&lt;/code&gt; graph drivers. For the &lt;code&gt;devicemapper&lt;/code&gt;, &lt;code&gt;btrfs&lt;/code&gt;, &lt;code&gt;windowsfilter&lt;/code&gt; and &lt;code&gt;zfs&lt;/code&gt; graph drivers, user cannot pass a size less than the Default BaseFS Size. For the &lt;code&gt;overlay2&lt;/code&gt; storage driver, the size option is only available if the backing fs is &lt;code&gt;xfs&lt;/code&gt; and mounted with the &lt;code&gt;pquota&lt;/code&gt; mount option. Under these conditions, user can pass any size less than the backing fs size.</source>
          <target state="translated">이 크기는 생성시 컨테이너 rootfs 크기를 120G로 설정할 수있게합니다. 이 옵션은에만 사용할 수 있습니다 &lt;code&gt;devicemapper&lt;/code&gt; , &lt;code&gt;btrfs&lt;/code&gt; 를 , &lt;code&gt;overlay2&lt;/code&gt; , &lt;code&gt;windowsfilter&lt;/code&gt; 및 &lt;code&gt;zfs&lt;/code&gt; 그래프 드라이버. 를 들어 &lt;code&gt;devicemapper&lt;/code&gt; , &lt;code&gt;btrfs&lt;/code&gt; 를 , &lt;code&gt;windowsfilter&lt;/code&gt; 및 &lt;code&gt;zfs&lt;/code&gt; 그래프 드라이버, 사용자는 기본 BaseFS 크기보다 작은 크기를 전달할 수 없습니다. 를 들어 &lt;code&gt;overlay2&lt;/code&gt; 기가 FS 경우 저장 장치 드라이버, 크기 옵션에만 사용할 수 있습니다 &lt;code&gt;xfs&lt;/code&gt; 와 장착 &lt;code&gt;pquota&lt;/code&gt; 옵션을 탑재합니다. 이러한 조건에서 사용자는 백업 fs 크기보다 작은 크기를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f57ef99877faf08ed983654bb76f051727a7a4a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Dockerfile&lt;/code&gt; refers to a couple of files we haven&amp;rsquo;t created yet, namely &lt;code&gt;app.py&lt;/code&gt; and &lt;code&gt;requirements.txt&lt;/code&gt;. Let&amp;rsquo;s create those next.</source>
          <target state="translated">이 &lt;code&gt;Dockerfile&lt;/code&gt; 은 아직 생성하지 않은 두 파일, 즉 &lt;code&gt;app.py&lt;/code&gt; 및 &lt;code&gt;requirements.txt&lt;/code&gt; 를 나타 냅니다. 다음에 그것들을 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="47b5a932b8b87db6fd83585f80ce51e69d78bd4d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Dockerfile&lt;/code&gt; starts with a &lt;a href=&quot;https://hub.docker.com/r/library/python/tags/3/&quot;&gt;Python 3 parent image&lt;/a&gt;. The parent image is modified by adding a new &lt;code&gt;code&lt;/code&gt; directory. The parent image is further modified by installing the Python requirements defined in the &lt;code&gt;requirements.txt&lt;/code&gt; file.</source>
          <target state="translated">이 &lt;code&gt;Dockerfile&lt;/code&gt; 은 &lt;a href=&quot;https://hub.docker.com/r/library/python/tags/3/&quot;&gt;Python 3 부모 이미지로&lt;/a&gt; 시작 합니다 . 부모 &lt;code&gt;code&lt;/code&gt; 는 새 코드 디렉토리를 추가하여 수정됩니다 . &lt;code&gt;requirements.txt&lt;/code&gt; 파일에 정의 된 Python 요구 사항을 설치하여 상위 이미지를 추가로 수정 합니다.</target>
        </trans-unit>
        <trans-unit id="fcc11cd71fd30d08d07edb398a96dbfeeb5387c9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;docker-compose.yml&lt;/code&gt; file tells Docker to do the following:</source>
          <target state="translated">이 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일은 Docker에게 다음을 수행하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="42b222153a9a1c425f836be3f93bd24f5404188e" translate="yes" xml:space="preserve">
          <source>This Compose file defines two services: &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;redis&lt;/code&gt;.</source>
          <target state="translated">이 작성 파일은 &lt;code&gt;web&lt;/code&gt; 및 &lt;code&gt;redis&lt;/code&gt; 의 두 가지 서비스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="358fc9bba91271cbe664fce4a5159a52599bd1b3" translate="yes" xml:space="preserve">
          <source>This Dockerfile results in an image that causes &lt;code&gt;docker run&lt;/code&gt; to create a new mount point at &lt;code&gt;/myvol&lt;/code&gt; and copy the &lt;code&gt;greeting&lt;/code&gt; file into the newly created volume.</source>
          <target state="translated">이 Dockerfile은 &lt;code&gt;docker run&lt;/code&gt; 이 &lt;code&gt;/myvol&lt;/code&gt; 에 새 마운트 지점을 만들고 &lt;code&gt;greeting&lt;/code&gt; 파일을 새로 만든 볼륨에 복사 하는 이미지 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="75674b77be279ff4516a3e04e754ff23ee2f1790" translate="yes" xml:space="preserve">
          <source>This Quickstart guide shows you how to use Docker Compose to set up and run a Rails/PostgreSQL app. Before starting, &lt;a href=&quot;../install/index&quot;&gt;install Compose&lt;/a&gt;.</source>
          <target state="translated">이 빠른 시작 안내서는 Docker Compose를 사용하여 Rails / PostgreSQL 앱을 설정하고 실행하는 방법을 보여줍니다. 시작하기 전에 &lt;a href=&quot;../install/index&quot;&gt;Compose를 설치하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f01905754800cfb79fe2f86a2616a78f01578a67" translate="yes" xml:space="preserve">
          <source>This adds the local file &lt;code&gt;my_file.txt&lt;/code&gt; (which must exist relative to the current working directory), under the target name &lt;code&gt;v1&lt;/code&gt;, to the &lt;code&gt;example.com/collection&lt;/code&gt; collection we set up. The contents of the local file are not actually added to the collection - a &amp;ldquo;target&amp;rdquo; consists of the file path and one or more checksums of the contents.</source>
          <target state="translated">이렇게 하면 대상 이름 &lt;code&gt;v1&lt;/code&gt; 아래에 있는 로컬 파일 &lt;code&gt;my_file.txt&lt;/code&gt; (현재 작업중인 디렉토리와 관련하여 존재해야 함) 가 &lt;code&gt;example.com/collection&lt;/code&gt; 컬렉션에 추가됩니다. 로컬 파일의 내용은 실제로 컬렉션에 추가되지 않습니다. &quot;대상&quot;은 파일 경로와 내용의 하나 이상의 체크섬으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="df4a4d34e6996802cfe8fa551770ac282cbd2296" translate="yes" xml:space="preserve">
          <source>This also causes a change in the swarm&amp;rsquo;s join tokens. The previous join tokens are no longer valid.</source>
          <target state="translated">또한 swarm의 조인 토큰이 변경됩니다. 이전 가입 토큰은 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86a0e1e2e2d988ec765aa8086c19c406f4640726" translate="yes" xml:space="preserve">
          <source>This article demonstrates how to ensure the traffic between the Docker registry server and the Docker daemon (a client of the registry server) is encrypted and properly authenticated using &lt;em&gt;certificate-based client-server authentication&lt;/em&gt;.</source>
          <target state="translated">이 기사는 Docker 레지스트리 서버와 Docker 데몬 (레지스트리 서버의 클라이언트) 간의 트래픽이 &lt;em&gt;인증서 기반 클라이언트 서버 인증을&lt;/em&gt; 사용하여 암호화되고 올바르게 인증되는지 확인하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9d38d1f1f6a9a807fd73d238aabfdc22a2067cc2" translate="yes" xml:space="preserve">
          <source>This behavior illustrates that the requirements and configuration of your tasks are not tightly tied to the current state of the swarm. As the administrator of a swarm, you declare the desired state of your swarm, and the manager works with the nodes in the swarm to create that state. You do not need to micro-manage the tasks on the swarm.</source>
          <target state="translated">이 동작은 작업의 요구 사항과 구성이 현재 떼의 현재 상태와 밀접한 관련이 없음을 보여줍니다. 떼의 관리자는 원하는 떼의 상태를 선언하고 관리자는 떼의 노드와 함께 해당 상태를 만듭니다. 떼에서 작업을 미세 관리 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1c412d460861eab1e7925494ef21e2f85862ad8" translate="yes" xml:space="preserve">
          <source>This binds port &lt;code&gt;8080&lt;/code&gt; of the container to TCP port &lt;code&gt;80&lt;/code&gt; on &lt;code&gt;127.0.0.1&lt;/code&gt; of the host machine. You can also specify &lt;code&gt;udp&lt;/code&gt; and &lt;code&gt;sctp&lt;/code&gt; ports. The &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker User Guide&lt;/a&gt; explains in detail how to manipulate ports in Docker.</source>
          <target state="translated">컨테이너의 포트 &lt;code&gt;8080&lt;/code&gt; 을 호스트 시스템의 &lt;code&gt;127.0.0.1&lt;/code&gt; 의 TCP 포트 &lt;code&gt;80&lt;/code&gt; 에 바인딩 합니다. &lt;code&gt;udp&lt;/code&gt; 및 &lt;code&gt;sctp&lt;/code&gt; 포트를 지정할 수도 있습니다. &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;도커 사용 설명서는&lt;/a&gt; 도커에서 포트를 조작하는 방법을 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f1d02d4b2ae7965df9c4265d0e3adff2cc9369f8" translate="yes" xml:space="preserve">
          <source>This builds the development Notary server and Notary signer images, and start up containers for the Notary server, Notary signer, and the MySQL database that both of them share. The MySQL data is stored in a volume.</source>
          <target state="translated">이를 통해 개발 Notary 서버 및 Notary 서명자 이미지가 구축되고, Notary 서버, Notary 서명자 및 둘 다 공유하는 MySQL 데이터베이스의 컨테이너가 시작됩니다. MySQL 데이터는 볼륨에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="97f761181ab7632d59e26ed008632c00f572855e" translate="yes" xml:space="preserve">
          <source>This can be used to create a context out of an existing &lt;code&gt;DOCKER_HOST&lt;/code&gt; based script:</source>
          <target state="translated">기존 &lt;code&gt;DOCKER_HOST&lt;/code&gt; 기반 스크립트 에서 컨텍스트를 작성하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edce6ba04bb5661e80ee7609a1990a5b26a9e5aa" translate="yes" xml:space="preserve">
          <source>This causes problems when using a web server such as Nginx to serve static files from a shared volume. For development environments, a good workaround is to disable sendfile in your server configuration.</source>
          <target state="translated">Nginx와 같은 웹 서버를 사용하여 공유 볼륨에서 정적 파일을 제공 할 때 문제가 발생합니다. 개발 환경의 경우 서버 구성에서 sendfile을 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0af2aba4a2db980cbd2853a408306d57c1c6a1c8" translate="yes" xml:space="preserve">
          <source>This command displays system wide information regarding the Docker installation. Information displayed includes the kernel version, number of containers and images. The number of images shown is the number of unique images. The same image tagged under different names is counted only once.</source>
          <target state="translated">이 명령은 Docker 설치에 관한 시스템 전체 정보를 표시합니다. 표시되는 정보에는 커널 버전, 컨테이너 수 및 이미지가 포함됩니다. 표시된 이미지 수는 고유 이미지 수입니다. 다른 이름으로 태그가 지정된 동일한 이미지는 한 번만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="240ca2085f5947e49de738600c8da8f441afca27" translate="yes" xml:space="preserve">
          <source>This command downloads a lightweight Linux distribution (&lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;boot2docker&lt;/a&gt;) with the Docker daemon installed, and creates and starts a VirtualBox VM with Docker running.</source>
          <target state="translated">이 명령 은 Docker 데몬이 설치된 경량 Linux 배포 ( &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;boot2docker&lt;/a&gt; )를 다운로드하고 Docker가 실행중인 VirtualBox VM을 만들고 시작합니다.</target>
        </trans-unit>
        <trans-unit id="35184527810629c1311c56b69a8f765cc48c694d" translate="yes" xml:space="preserve">
          <source>This command is experimental on the Docker client. It should not be used in production environments. To enable experimental features in the Docker CLI, edit the &lt;a href=&quot;../cli/index#configuration-files&quot;&gt;config.json&lt;/a&gt; and set &lt;code&gt;experimental&lt;/code&gt; to &lt;code&gt;enabled&lt;/code&gt;.</source>
          <target state="translated">이 명령은 Docker 클라이언트에서 실험 중입니다. 프로덕션 환경에서는 사용하지 않아야합니다. Docker CLI에서 실험 기능을 사용하려면 &lt;a href=&quot;../cli/index#configuration-files&quot;&gt;config.json을&lt;/a&gt; 편집 하고 설정하십시오. &lt;code&gt;experimental&lt;/code&gt; 에 &lt;code&gt;enabled&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df32b930eb31af34fe2b76612ef1e6f0009304a3" translate="yes" xml:space="preserve">
          <source>This command is experimental on the Docker daemon. It should not be used in production environments. To enable experimental features on the Docker daemon, edit the &lt;a href=&quot;../dockerd/index#daemon-configuration-file&quot;&gt;daemon.json&lt;/a&gt; and set &lt;code&gt;experimental&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 명령은 Docker 데몬에서 실험적입니다. 프로덕션 환경에서는 사용하지 않아야합니다. Docker 데몬에서 실험 기능을 사용하려면 &lt;a href=&quot;../dockerd/index#daemon-configuration-file&quot;&gt;daemon.json을&lt;/a&gt; 편집하고 &lt;code&gt;experimental&lt;/code&gt; 설정하십시오. 을 &lt;code&gt;true&lt;/code&gt; 로 .</target>
        </trans-unit>
        <trans-unit id="b4fad7e4f212ad30b2c2846839873bab6f4ae67d" translate="yes" xml:space="preserve">
          <source>This command is experimental.</source>
          <target state="translated">이 명령은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="e3a6d53a3cf2ebcf1bd54d7f955d415d822847a8" translate="yes" xml:space="preserve">
          <source>This command is optional because the person who created the &lt;code&gt;IMAGE&lt;/code&gt; may have already provided a default &lt;code&gt;COMMAND&lt;/code&gt; using the Dockerfile &lt;code&gt;CMD&lt;/code&gt; instruction. As the operator (the person running a container from the image), you can override that &lt;code&gt;CMD&lt;/code&gt; instruction just by specifying a new &lt;code&gt;COMMAND&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IMAGE&lt;/code&gt; 를 만든 사람 이 Dockerfile &lt;code&gt;CMD&lt;/code&gt; &lt;code&gt;COMMAND&lt;/code&gt; 사용하여 이미 기본 명령 을 제공했을 수 있으므로이 명령은 선택 사항입니다. 연산자 (이미지에서 컨테이너를 실행하는 사람) 는 새 &lt;code&gt;COMMAND&lt;/code&gt; 를 지정하여 해당 &lt;code&gt;CMD&lt;/code&gt; 명령을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e297bdb9616106c472adc915c5da37860a04aa4e" translate="yes" xml:space="preserve">
          <source>This command pulls all images from the &lt;code&gt;fedora&lt;/code&gt; repository:</source>
          <target state="translated">이 명령은 &lt;code&gt;fedora&lt;/code&gt; 저장소 에서 모든 이미지를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="365f6a7147122b686375358bdf74e35f3d587264" translate="yes" xml:space="preserve">
          <source>This command when run targeting a manager, lists services are running in the swarm.</source>
          <target state="translated">이 명령은 관리자를 대상으로 실행할 때 서비스가 떼에서 실행되고 있음을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="ddf782cc635d52ac46f7c8308682cd36d0868308" translate="yes" xml:space="preserve">
          <source>This command will delete all stopped containers. The command &lt;code&gt;docker ps -a -q&lt;/code&gt; will return all existing container IDs and pass them to the &lt;code&gt;rm&lt;/code&gt; command which will delete them. Any running containers will not be deleted.</source>
          <target state="translated">이 명령은 중지 된 모든 컨테이너를 삭제합니다. &lt;code&gt;docker ps -a -q&lt;/code&gt; 명령 은 기존의 모든 컨테이너 ID를 반환하고이를 삭제 하는 &lt;code&gt;rm&lt;/code&gt; 명령으로 전달 합니다. 실행중인 컨테이너는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a22c94088bd64bc47d90d7a2bf3e8f1ae563b3ae" translate="yes" xml:space="preserve">
          <source>This command will force-remove a running container.</source>
          <target state="translated">이 명령은 실행중인 컨테이너를 강제로 제거합니다.</target>
        </trans-unit>
        <trans-unit id="24bca651c57768c2cbbc0f8a0064b563ef57bafa" translate="yes" xml:space="preserve">
          <source>This command will remove the container and any volumes associated with it. Note that if a volume was specified with a name, it will not be removed.</source>
          <target state="translated">이 명령은 컨테이너 및 이와 관련된 모든 볼륨을 제거합니다. 볼륨이 이름으로 지정된 경우 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a907da2bfe0f1e4e51ceded4cd12d4f72da28ae" translate="yes" xml:space="preserve">
          <source>This configuration option can overridden with the command line flag `--tlscacert`, which would specify a path relative to the current working directory where the Notary client is invoked.</source>
          <target state="translated">이 구성 옵션은 명령 행 플래그`--tlscacert`로 대체 될 수 있으며,이 명령은 Notary 클라이언트가 호출되는 현재 작업 디렉토리에 상대적인 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f3dac2903a9e3b3bcb2b9748cb607af7325f6ae4" translate="yes" xml:space="preserve">
          <source>This configuration option can overridden with the command line flag `--tlscert`, which would specify a path relative to the current working directory where the Notary client is invoked.</source>
          <target state="translated">이 구성 옵션은 명령 행 플래그`--tlscert`로 대체 될 수 있으며,이 명령은 Notary 클라이언트가 호출되는 현재 작업 디렉토리에 상대적인 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e323c3dfc61399ca682bdcd3c5130865f67656b5" translate="yes" xml:space="preserve">
          <source>This configuration option can overridden with the command line flag `--tlskey`, which would specify a path relative to the current working directory where the Notary client is invoked.</source>
          <target state="translated">이 구성 옵션은 명령 행 플래그`--tlskey`로 대체 될 수 있으며,이 명령은 Notary 클라이언트가 호출되는 현재 작업 디렉토리에 상대적인 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="709ff60d32f8c4d39b9a6e28d1237a9155af5e63" translate="yes" xml:space="preserve">
          <source>This creates a virtual machine running locally in VirtualBox which uses the &lt;code&gt;overlay&lt;/code&gt; storage backend, has the key-value pairs &lt;code&gt;foo=bar&lt;/code&gt; and &lt;code&gt;spam=eggs&lt;/code&gt; as labels on the engine, and allows pushing / pulling from the insecure registry located at &lt;code&gt;registry.myco.com&lt;/code&gt;. You can verify much of this by inspecting the output of &lt;code&gt;docker info&lt;/code&gt;:</source>
          <target state="translated">이렇게하면 &lt;code&gt;overlay&lt;/code&gt; 스토리지 백엔드 를 사용하는 VirtualBox에서 로컬로 실행되는 가상 머신이 생성되고 엔진의 레이블로 키-값 쌍 &lt;code&gt;foo=bar&lt;/code&gt; 및 &lt;code&gt;spam=eggs&lt;/code&gt; 가 있으며 registry.myco에있는 안전하지 않은 레지스트리에서 푸시 / 풀기를 허용 &lt;code&gt;registry.myco.com&lt;/code&gt; . &lt;code&gt;docker info&lt;/code&gt; 출력을 검사 하여이 중 많은 부분을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41a11612feac37d243bc29270cc7b6836505ff66" translate="yes" xml:space="preserve">
          <source>This deploys all three services using the configuration in &lt;code&gt;docker-compose.yml&lt;/code&gt; and &lt;code&gt;docker-compose.prod.yml&lt;/code&gt; (but not the dev configuration in &lt;code&gt;docker-compose.override.yml&lt;/code&gt;).</source>
          <target state="translated">이는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 및 &lt;code&gt;docker-compose.prod.yml&lt;/code&gt; 의 구성을 사용하여 세 가지 서비스를 모두 배포합니다 ( 단 , docker-compose.override.yml 의 dev 구성은 &lt;code&gt;docker-compose.override.yml&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ac8d354c9ba0ef9da4ef3101bd1948b3180a500" translate="yes" xml:space="preserve">
          <source>This diagram illustrates how placement preferences work:</source>
          <target state="translated">이 다이어그램은 게재 위치 환경 설정의 작동 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d1bc61090cecad38ab7e1afe84b40d5a2df3de11" translate="yes" xml:space="preserve">
          <source>This disconnects the shell from &lt;code&gt;docker-machine&lt;/code&gt; created virtual machines, and allows you to continue working in the same shell, now using native &lt;code&gt;docker&lt;/code&gt; commands (for example, on Docker Desktop for Mac or Docker Desktop for Windows). To learn more, see the &lt;a href=&quot;../../machine/get-started/index#unset-environment-variables-in-the-current-shell&quot;&gt;Machine topic on unsetting environment variables&lt;/a&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;docker-machine&lt;/code&gt; 으로 생성 된 가상 머신 에서 셸의 연결이 끊어지고 이제 고유 &lt;code&gt;docker&lt;/code&gt; 명령 (예 : Mac 용 Docker Desktop 또는 Windows 용 Docker Desktop)을 사용하여 동일한 셸에서 작업을 계속할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../../machine/get-started/index#unset-environment-variables-in-the-current-shell&quot;&gt;환경 변수 설정 해제에&lt;/a&gt; 대한 기계 주제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d2f8bae28c2c9e880782a4809b0b4ebefad7b1c" translate="yes" xml:space="preserve">
          <source>This document assumes familiarity with &lt;a href=&quot;https://www.theupdateframework.com/&quot;&gt;The Update Framework&lt;/a&gt;, but here is a brief recap of the TUF roles and corresponding key hierarchy:</source>
          <target state="translated">이 문서는 &lt;a href=&quot;https://www.theupdateframework.com/&quot;&gt;The Update Framework에&lt;/a&gt; 대해 잘 알고 있지만 TUF 역할과 해당 키 계층에 대해 간략히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f3db2d513e02b85d3f9b2621224278858e2df00d" translate="yes" xml:space="preserve">
          <source>This document describes Docker Engine network driver plugins generally available in Docker Engine. To view information on plugins managed by Docker Engine, refer to &lt;a href=&quot;../index&quot;&gt;Docker Engine plugin system&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Docker Engine에서 일반적으로 사용 가능한 Docker Engine 네트워크 드라이버 플러그인에 대해 설명합니다. Docker Engine에서 관리하는 플러그인에 대한 정보를 보려면 &lt;a href=&quot;../index&quot;&gt;Docker Engine 플러그인 시스템을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6e7554c11c0d25f0bdedde0eaf7221ec3abe7f5" translate="yes" xml:space="preserve">
          <source>This document describes basic use of the Notary CLI as a tool supporting Docker Content Trust. For more advanced use cases, you must &lt;a href=&quot;../running_a_service/index&quot;&gt;run your own Notary service&lt;/a&gt;. Read the &lt;a href=&quot;../advanced_usage/index&quot;&gt;use the Notary client for advanced users&lt;/a&gt; documentation.</source>
          <target state="translated">이 문서는 Docker Content Trust를 지원하는 도구로 Notary CLI의 기본 사용법을 설명합니다. 고급 사용 사례의 경우 &lt;a href=&quot;../running_a_service/index&quot;&gt;고유 한 Notary 서비스를 실행&lt;/a&gt; 해야합니다 . &lt;a href=&quot;../advanced_usage/index&quot;&gt;고급 사용자를위한 Notary 클라이언트 사용&lt;/a&gt; 문서 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="0fa42b8f27f63672e035019dbb27d49c75249850" translate="yes" xml:space="preserve">
          <source>This document describes the Docker Engine plugin API. To view information on plugins managed by Docker Engine, refer to &lt;a href=&quot;../index&quot;&gt;Docker Engine plugin system&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Docker Engine 플러그인 API에 대해 설명합니다. Docker Engine이 관리하는 플러그인에 대한 정보를 보려면 &lt;a href=&quot;../index&quot;&gt;Docker Engine 플러그인 시스템을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92a5e71cde0d41862aadd7efb2569e87955944e7" translate="yes" xml:space="preserve">
          <source>This document describes the Docker Engine plugins generally available in Docker Engine. To view information on plugins managed by Docker Engine, refer to &lt;a href=&quot;../index&quot;&gt;Docker Engine plugin system&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Docker Engine에서 일반적으로 사용 가능한 Docker Engine 플러그인에 대해 설명합니다. Docker Engine이 관리하는 플러그인에 대한 정보를 보려면 &lt;a href=&quot;../index&quot;&gt;Docker Engine 플러그인 시스템을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="977a9aa369ad0a7c94c5def3b85e5184449f8f22" translate="yes" xml:space="preserve">
          <source>This document describes the Docker Engine plugins generally available in Docker Engine. To view information on plugins managed by Docker, refer to &lt;a href=&quot;../index&quot;&gt;Docker Engine plugin system&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Docker Engine에서 일반적으로 사용 가능한 Docker Engine 플러그인에 대해 설명합니다. Docker가 관리하는 플러그인에 대한 정보를 보려면 &lt;a href=&quot;../index&quot;&gt;Docker Engine 플러그인 시스템을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a6bfc98e4ea8d246879d5a991655ac15af82d7d" translate="yes" xml:space="preserve">
          <source>This document is for anyone who wants to run their own Notary service (such as those who want to use Notary with a private Docker registry). Running a Notary service requires that you are already familiar with using &lt;a href=&quot;https://docs.docker.com/config/daemon&quot;&gt;Docker Engine&lt;/a&gt; and &lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt;.</source>
          <target state="translated">이 문서는 자체 Notary 서비스를 실행하려는 사람 (예 : 개인 Docker 레지스트리와 함께 Notary를 사용하려는 사람)을위한 것입니다. 공증인 서비스를 실행하려면 이미 &lt;a href=&quot;https://docs.docker.com/config/daemon&quot;&gt;Docker Engine&lt;/a&gt; 및 &lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt; 사용에 익숙해야합니다 .</target>
        </trans-unit>
        <trans-unit id="667ba7c5086cd3f9086bb97fe691713d68d06fdf" translate="yes" xml:space="preserve">
          <source>This document is for power users of the &lt;a href=&quot;../../advanced_usage/index&quot;&gt;Notary client&lt;/a&gt; who want to facilitate CLI interaction or specify custom options.</source>
          <target state="translated">이 문서는 CLI 상호 작용을 용이하게하거나 사용자 정의 옵션을 지정하려는 &lt;a href=&quot;../../advanced_usage/index&quot;&gt;Notary 클라이언트&lt;/a&gt; 의 고급 사용자 를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d14334b6cf15bb6366cf71f20d5f69c1e4bdd6ea" translate="yes" xml:space="preserve">
          <source>This document is for power users of the &lt;a href=&quot;../advanced_usage/index&quot;&gt;notary client&lt;/a&gt;, or for those who are &lt;a href=&quot;../running_a_service/index&quot;&gt;running their own service&lt;/a&gt; who want to facilitate CLI interaction or specify custom options.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;../advanced_usage/index&quot;&gt;공증인 클라이언트&lt;/a&gt; 의 고급 사용자 또는 CLI 상호 작용을 촉진하거나 사용자 정의 옵션을 지정하려는 &lt;a href=&quot;../running_a_service/index&quot;&gt;고유 한 서비스&lt;/a&gt; 를 실행중인 사용자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="336585c13b95433518135a03992347242015d28d" translate="yes" xml:space="preserve">
          <source>This document is for those who are &lt;a href=&quot;../../running_a_service/index&quot;&gt;running their own Notary service&lt;/a&gt; who want to specify custom options.</source>
          <target state="translated">이 문서는 사용자 지정 옵션을 지정하려는 &lt;a href=&quot;../../running_a_service/index&quot;&gt;고유 한 공증인 서비스&lt;/a&gt; 를 실행하는 사람들을위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a3523a80f4fb22175f1197cab78624b412918813" translate="yes" xml:space="preserve">
          <source>This document outlines the format of the V0 plugin configuration. The plugin config described herein was introduced in the Docker daemon in the &lt;a href=&quot;https://github.com/docker/docker/commit/f37117045c5398fd3dca8016ea8ca0cb47e7312b&quot;&gt;v1.12.0 release&lt;/a&gt;.</source>
          <target state="translated">이 문서는 V0 플러그인 구성의 형식을 간략하게 설명합니다. 여기에 설명 된 플러그인 구성은 &lt;a href=&quot;https://github.com/docker/docker/commit/f37117045c5398fd3dca8016ea8ca0cb47e7312b&quot;&gt;v1.12.0 릴리스&lt;/a&gt; 의 Docker 데몬에 도입 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="88801665323f52ce7e37ca0d98754639e1876f23" translate="yes" xml:space="preserve">
          <source>This document&amp;rsquo;s command examples omit the &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt; flags. If you do not know what these options do, read the &lt;a href=&quot;../getting_started/index&quot;&gt;Getting Started&lt;/a&gt; docs or run &lt;code&gt;notary --help&lt;/code&gt; before continuing. Once you understand what these flags do, you must provide your own values for these options while following this document. You can also configure these options, see &lt;a href=&quot;../reference/index&quot;&gt;advanced configuration options&lt;/a&gt; for more information.</source>
          <target state="translated">이 문서의 명령 예제는 &lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-d&lt;/code&gt; 플래그를 생략합니다 . 이러한 옵션의 기능을 모르는 경우 계속하기 전에 &lt;a href=&quot;../getting_started/index&quot;&gt;시작하기&lt;/a&gt; 문서를 읽 거나 &lt;code&gt;notary --help&lt;/code&gt; 를 실행하십시오 . 이러한 플래그의 기능을 이해하면이 문서를 따르는 동안 이러한 옵션에 대한 고유 한 값을 제공해야합니다. 이러한 옵션을 구성 할 수도 있습니다 . 자세한 내용 은 &lt;a href=&quot;../reference/index&quot;&gt;고급 구성 옵션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ca6ae0c176ba4178b4b3258f721cfed1ca466f8" translate="yes" xml:space="preserve">
          <source>This does not remove images from a registry. You cannot remove an image of a running container unless you use the &lt;code&gt;-f&lt;/code&gt; option. To see all images on a host use the &lt;a href=&quot;../images/index&quot;&gt;&lt;code&gt;docker image ls&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">레지스트리에서 이미지를 제거하지는 않습니다. &lt;code&gt;-f&lt;/code&gt; 옵션 을 사용하지 않으면 실행중인 컨테이너의 이미지를 제거 할 수 없습니다 . 호스트의 모든 이미지를 보려면 &lt;a href=&quot;../images/index&quot;&gt; &lt;code&gt;docker image ls&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="29c95833fd291c916b66a22ef975e69524fe0812" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t affect regular web apps, but reduces the vectors of attack by malicious users considerably. By default Docker drops all capabilities except &lt;a href=&quot;https://github.com/moby/moby/blob/master/oci/defaults.go#L14-L30&quot;&gt;those needed&lt;/a&gt;, a whitelist instead of a blacklist approach. You can see a full list of available capabilities in &lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;Linux manpages&lt;/a&gt;.</source>
          <target state="translated">이는 일반적인 웹 앱에는 영향을 미치지 않지만 악의적 인 사용자의 공격 벡터를 크게 줄입니다. 기본적으로 Docker 는 블랙리스트 방식 대신 화이트리스트에 &lt;a href=&quot;https://github.com/moby/moby/blob/master/oci/defaults.go#L14-L30&quot;&gt;필요한&lt;/a&gt; 기능을 제외한 모든 기능을 삭제합니다 . &lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;Linux 맨 페이지&lt;/a&gt; 에서 사용 가능한 기능의 전체 목록을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a43a9520de487587d0fbcc7ec2262af5285678e1" translate="yes" xml:space="preserve">
          <source>This entire section is optional. However, if you would like authentication for your server, then you need the required parameters below to configure it.</source>
          <target state="translated">이 전체 섹션은 선택 사항입니다. 그러나 서버에 대한 인증을 원하는 경우 아래의 필수 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3a433067a0a5e5fcc3e2fd416075fa3c8f721f5e" translate="yes" xml:space="preserve">
          <source>This entire section is optional. However, if you would like to specify a different log level, then you need the required parameters below to configure it.</source>
          <target state="translated">이 전체 섹션은 선택 사항입니다. 그러나 다른 로그 레벨을 지정하려면 아래에 필수 매개 변수가 있어야 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ea48ec9b38860daa76dd08decddeba0cb452ba2" translate="yes" xml:space="preserve">
          <source>This entire section is optional. If you want to report errors to Bugsnag, then you need to include a &lt;code&gt;bugsnag&lt;/code&gt; subsection, along with the required parameters below, to configure it.</source>
          <target state="translated">이 전체 섹션은 선택 사항입니다. Bugsnag에 오류를보고 하려면 아래 필수 매개 변수와 함께 &lt;code&gt;bugsnag&lt;/code&gt; 하위 섹션을 구성하여 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f77a7d533cc24ee410fe3e4b950ec5a19938c5e" translate="yes" xml:space="preserve">
          <source>This example assumes that you have PowerShell installed.</source>
          <target state="translated">이 예에서는 PowerShell이 ​​설치되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="579d25d3fa42da9cf3b7765d1ba3889e8d54df66" translate="yes" xml:space="preserve">
          <source>This example assumes the VPC ID was found in the &lt;code&gt;a&lt;/code&gt; availability zone. Use the&lt;code&gt;--amazonec2-zone&lt;/code&gt; flag to specify a zone other than the &lt;code&gt;a&lt;/code&gt; zone. For example, &lt;code&gt;--amazonec2-zone c&lt;/code&gt; signifies &lt;code&gt;us-east1-c&lt;/code&gt;.</source>
          <target state="translated">이 예는 VPC ID가 발견 된 가정 가용성 영역. 사용 &lt;code&gt;--amazonec2-zone&lt;/code&gt; 댄 다른 영역을 지정하는 플래그를 &lt;code&gt;a&lt;/code&gt; 영역을. 예를 들어 &lt;code&gt;--amazonec2-zone c&lt;/code&gt; 는 &lt;code&gt;us-east1-c&lt;/code&gt; 를 나타냅니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7dabe53e43b79614d8438010395bf2de91947e2" translate="yes" xml:space="preserve">
          <source>This example assumes you already have an ASP.NET Core app on your machine. If you are new to ASP.NET you can follow a &lt;a href=&quot;https://www.asp.net/get-started&quot;&gt;simple tutorial&lt;/a&gt; to initialize a project or clone our &lt;a href=&quot;https://github.com/dotnet/dotnet-docker/tree/master/samples/aspnetapp&quot;&gt;ASP.NET Docker Sample&lt;/a&gt;.</source>
          <target state="translated">이 예에서는 컴퓨터에 이미 ASP.NET Core 앱이 있다고 가정합니다. ASP.NET을 처음 사용하는 경우 &lt;a href=&quot;https://www.asp.net/get-started&quot;&gt;간단한 자습서&lt;/a&gt; 를 따라 프로젝트를 초기화하거나 &lt;a href=&quot;https://github.com/dotnet/dotnet-docker/tree/master/samples/aspnetapp&quot;&gt;ASP.NET Docker 샘플을&lt;/a&gt; 복제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b072eb53d731dbe872bf5499fc8375a6c9b49d0a" translate="yes" xml:space="preserve">
          <source>This example builds upon the previous one. In this scenario, you create a new secret with a new MySQL password, update the &lt;code&gt;mysql&lt;/code&gt; and &lt;code&gt;wordpress&lt;/code&gt; services to use it, then remove the old secret.</source>
          <target state="translated">이 예제는 이전 예제를 기반으로합니다. 이 시나리오에서는 새 MySQL 비밀번호로 새 비밀번호를 작성하고 이를 사용 하도록 &lt;code&gt;mysql&lt;/code&gt; 및 &lt;code&gt;wordpress&lt;/code&gt; 서비스를 업데이트 한 후 이전 비밀번호를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="634e957efa7945da265880d09e1c009341ec0d3f" translate="yes" xml:space="preserve">
          <source>This example creates a simple WordPress site using two secrets in a compose file.</source>
          <target state="translated">이 예에서는 작성 파일에 두 가지 비밀을 사용하여 간단한 WordPress 사이트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c0c1d508a75d41b428bb130225b60f1d0a96206d" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to dockerize an ASP.NET Core application.</source>
          <target state="translated">이 예제는 ASP.NET Core 응용 프로그램을 고정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cb3e7c67c57703593b3796456e5ef4778a541b6f" translate="yes" xml:space="preserve">
          <source>This example displays images with a name containing &amp;lsquo;busybox&amp;rsquo; and are automated builds:</source>
          <target state="translated">이 예는 이름이 'busybox'를 포함하고 자동화 된 빌드 인 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d437f7cb185e6f0f539ce5261b7757395e2fb234" translate="yes" xml:space="preserve">
          <source>This example displays images with a name containing &amp;lsquo;busybox&amp;rsquo; and at least 3 stars:</source>
          <target state="translated">이 예는 이름이 'busybox'이고 별이 3 개 이상인 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="089c84ed40f5a74f086ac6569d6bd88f3bdc3419" translate="yes" xml:space="preserve">
          <source>This example displays images with a name containing &amp;lsquo;busybox&amp;rsquo;, at least 3 stars and are official builds:</source>
          <target state="translated">이 예는 별이 3 개 이상인 'busybox'를 포함하는 이름을 가진 이미지를 표시하며 공식 빌드입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
