<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="docker">
    <body>
      <group id="docker">
        <trans-unit id="9c9f7b682bab6a44bd538f6d2618377c9d88ebf3" translate="yes" xml:space="preserve">
          <source>This example displays images with a name containing &amp;lsquo;busybox&amp;rsquo;, at least 3 stars and the description isn&amp;rsquo;t truncated in the output:</source>
          <target state="translated">이 예는 별이 3 개 이상이고 이름이 'busybox'를 포함하고 이미지에서 설명이 잘리지 않는 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6eba9c7e71f29918228f74c8055da8a02b312f1d" translate="yes" xml:space="preserve">
          <source>This example displays images with a name containing &amp;lsquo;busybox&amp;rsquo;:</source>
          <target state="translated">이 예는 이름이 'busybox'인 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0a4157e43c96ca0241f93cdf0f0fd84d6e72bf92" translate="yes" xml:space="preserve">
          <source>This example illustrates some techniques to use Docker secrets to avoid saving sensitive credentials within your image or passing them directly on the command line.</source>
          <target state="translated">이 예제는 이미지 내에 민감한 자격 증명을 저장하거나 명령 줄에 직접 전달하지 않도록 Docker 비밀을 사용하는 몇 가지 기술을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dc30d391e6c1eb0cafa3fb875dba31a87120a05f" translate="yes" xml:space="preserve">
          <source>This example is divided into two parts. &lt;a href=&quot;#generate-the-site-certificate&quot;&gt;The first part&lt;/a&gt; is all about generating the site certificate and does not directly involve Docker configs at all, but it sets up &lt;a href=&quot;#configure-the-nginx-container&quot;&gt;the second part&lt;/a&gt;, where you store and use the site certificate as a series of secrets and the Nginx configuration as a config. The example shows how to set options on the config, such as the target location within the container and the file permissions (&lt;code&gt;mode&lt;/code&gt;).</source>
          <target state="translated">이 예제는 두 부분으로 나뉩니다. &lt;a href=&quot;#generate-the-site-certificate&quot;&gt;첫 번째 부분&lt;/a&gt; 은 사이트 인증서 생성에 관한 것이며 Docker 구성을 직접 포함하지는 않지만 &lt;a href=&quot;#configure-the-nginx-container&quot;&gt;두 번째 부분&lt;/a&gt; 은 사이트 인증서를 일련의 비밀로 저장하고 사용하는 Nginx 구성을 구성으로 설정합니다. 이 예제는 컨테이너의 대상 위치 및 파일 권한 ( &lt;code&gt;mode&lt;/code&gt; ) 과 같은 구성에서 옵션을 설정하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="be1de2e4e765f59fa609da136c95f017d2b842e4" translate="yes" xml:space="preserve">
          <source>This example is divided into two parts. &lt;a href=&quot;#generate-the-site-certificate&quot;&gt;The first part&lt;/a&gt; is all about generating the site certificate and does not directly involve Docker secrets at all, but it sets up &lt;a href=&quot;#configure-the-nginx-container&quot;&gt;the second part&lt;/a&gt;, where you store and use the site certificate and Nginx configuration as secrets.</source>
          <target state="translated">이 예제는 두 부분으로 나뉩니다. &lt;a href=&quot;#generate-the-site-certificate&quot;&gt;첫 번째 부분&lt;/a&gt; 은 사이트 인증서 생성에 관한 것이며 Docker 비밀을 직접 포함하지는 않지만 &lt;a href=&quot;#configure-the-nginx-container&quot;&gt;두 번째 부분을&lt;/a&gt; 설정 하여 사이트 인증서와 Nginx 구성을 비밀로 저장하고 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f44a24dd4e591c700687a4e45acdc0197fd37f3" translate="yes" xml:space="preserve">
          <source>This example outputs a table format:</source>
          <target state="translated">이 예제는 테이블 형식을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="e10bbbbba424e466c62818ae9402ad4263b572c7" translate="yes" xml:space="preserve">
          <source>This example removes a secret:</source>
          <target state="translated">이 예는 비밀을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a78141592d005e659ba00e71941bf06333b14dc3" translate="yes" xml:space="preserve">
          <source>This example removes images which have a maintainer label not set to &lt;code&gt;john&lt;/code&gt;:</source>
          <target state="translated">이 예제는 유지 보수 레이블이 &lt;code&gt;john&lt;/code&gt; 으로 설정되지 않은 이미지를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="4fac1bc679f649f868cf9d28a2903fbba45806cd" translate="yes" xml:space="preserve">
          <source>This example removes images which have no &lt;code&gt;maintainer&lt;/code&gt; label:</source>
          <target state="translated">이 예제는 &lt;code&gt;maintainer&lt;/code&gt; 레이블 이없는 이미지를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="b7bae738b014b2992b003324821252fee76806dd" translate="yes" xml:space="preserve">
          <source>This example restricts the processes in the container to only use memory from memory nodes 0, 1 and 2.</source>
          <target state="translated">이 예제는 컨테이너의 프로세스가 메모리 노드 0, 1 및 2의 메모리 만 사용하도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="2efb21cb22c1a26daa1fb3cebf96188cfcc9da20" translate="yes" xml:space="preserve">
          <source>This example restricts the processes in the container to only use memory from memory nodes 1 and 3.</source>
          <target state="translated">이 예제는 컨테이너의 프로세스가 메모리 노드 1 및 3의 메모리 만 사용하도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="1615ecdaa4849de43ea0c27507789f81c51f5e88" translate="yes" xml:space="preserve">
          <source>This example runs a container named &lt;code&gt;test&lt;/code&gt; using the &lt;code&gt;debian:latest&lt;/code&gt; image. The &lt;code&gt;-it&lt;/code&gt; instructs Docker to allocate a pseudo-TTY connected to the container&amp;rsquo;s stdin; creating an interactive &lt;code&gt;bash&lt;/code&gt; shell in the container. In the example, the &lt;code&gt;bash&lt;/code&gt; shell is quit by entering &lt;code&gt;exit 13&lt;/code&gt;. This exit code is passed on to the caller of &lt;code&gt;docker run&lt;/code&gt;, and is recorded in the &lt;code&gt;test&lt;/code&gt; container&amp;rsquo;s metadata.</source>
          <target state="translated">이 예제는 &lt;code&gt;debian:latest&lt;/code&gt; 이미지를 사용하여 &lt;code&gt;test&lt;/code&gt; 라는 컨테이너를 실행합니다 . &lt;code&gt;-it&lt;/code&gt; 컨테이너의 표준 입력에 연결된-TTY는 의사를 할당 도커 지시; 컨테이너에 대화식 &lt;code&gt;bash&lt;/code&gt; 쉘 작성 예에서, &lt;code&gt;bash&lt;/code&gt; 쉘은 &lt;code&gt;exit 13&lt;/code&gt; 을 입력하여 종료 됩니다. 이 종료 코드는 &lt;code&gt;docker run&lt;/code&gt; 의 호출자에게 전달되며 &lt;code&gt;test&lt;/code&gt; 컨테이너의 메타 데이터에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb97a2b62dfc69be5a36c6d8bc3dd5f0ec7ee3c4" translate="yes" xml:space="preserve">
          <source>This example sets the &lt;code&gt;cgroupdriver&lt;/code&gt; to &lt;code&gt;systemd&lt;/code&gt;:</source>
          <target state="translated">이 예는 &lt;code&gt;cgroupdriver&lt;/code&gt; 를 &lt;code&gt;systemd&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f317281bd83742e369f8b299317ea97212757fdd" translate="yes" xml:space="preserve">
          <source>This example sets the template of the created containers based on the service&amp;rsquo;s name and the ID of the node where the container is running:</source>
          <target state="translated">이 예제는 서비스 이름 및 컨테이너가 실행중인 노드의 ID를 기반으로 작성된 컨테이너의 템플리트를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f1c28c6b74588071e6ca6b916879bfae7ddcb3ef" translate="yes" xml:space="preserve">
          <source>This example shows a named volume (&lt;code&gt;mydata&lt;/code&gt;) being used by the &lt;code&gt;web&lt;/code&gt; service, and a bind mount defined for a single service (first path under &lt;code&gt;db&lt;/code&gt; service &lt;code&gt;volumes&lt;/code&gt;). The &lt;code&gt;db&lt;/code&gt; service also uses a named volume called &lt;code&gt;dbdata&lt;/code&gt; (second path under &lt;code&gt;db&lt;/code&gt; service &lt;code&gt;volumes&lt;/code&gt;), but defines it using the old string format for mounting a named volume. Named volumes must be listed under the top-level &lt;code&gt;volumes&lt;/code&gt; key, as shown.</source>
          <target state="translated">이 예는 &lt;code&gt;web&lt;/code&gt; 서비스에서 사용중인 명명 된 볼륨 ( &lt;code&gt;mydata&lt;/code&gt; ) 과 단일 서비스 ( &lt;code&gt;db&lt;/code&gt; service &lt;code&gt;volumes&lt;/code&gt; 아래의 첫 번째 경로)에 대해 정의 된 바인드 마운트 를 보여줍니다 . &lt;code&gt;db&lt;/code&gt; 서비스는 명명 된 볼륨이라고합니다 &lt;code&gt;dbdata&lt;/code&gt; (아래 두 번째 경로 &lt;code&gt;db&lt;/code&gt; 서비스 &lt;code&gt;volumes&lt;/code&gt; ), 그러나 정의는 명명 된 볼륨을 장착 기존의 문자열 형식을 사용하여. 명명 된 볼륨은 표시된 것처럼 최상위 &lt;code&gt;volumes&lt;/code&gt; 키 아래에 나열되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7d23c49b05f34f0a627a12996b69b8ce821a609" translate="yes" xml:space="preserve">
          <source>This example shows the use of the &lt;code&gt;.dockerignore&lt;/code&gt; file to exclude the &lt;code&gt;.git&lt;/code&gt; directory from the context. Its effect can be seen in the changed size of the uploaded context. The builder reference contains detailed information on &lt;a href=&quot;../../builder/index#dockerignore-file&quot;&gt;creating a .dockerignore file&lt;/a&gt;</source>
          <target state="translated">이 예제는 &lt;code&gt;.dockerignore&lt;/code&gt; 파일을 사용 하여 컨텍스트에서 &lt;code&gt;.git&lt;/code&gt; 디렉토리 를 제외하는 것을 보여줍니다 . 그 효과는 업로드 된 컨텍스트의 변경된 크기에서 볼 수 있습니다. 빌더 참조에는 &lt;a href=&quot;../../builder/index#dockerignore-file&quot;&gt;.dockerignore 파일 작성에&lt;/a&gt; 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a87fde5df555e0d28b2a6a18a7d2a7dafe05be" translate="yes" xml:space="preserve">
          <source>This example specifies that the &lt;code&gt;PATH&lt;/code&gt; is &lt;code&gt;.&lt;/code&gt;, and so all the files in the local directory get &lt;code&gt;tar&lt;/code&gt;d and sent to the Docker daemon. The &lt;code&gt;PATH&lt;/code&gt; specifies where to find the files for the &amp;ldquo;context&amp;rdquo; of the build on the Docker daemon. Remember that the daemon could be running on a remote machine and that no parsing of the Dockerfile happens at the client side (where you&amp;rsquo;re running &lt;code&gt;docker build&lt;/code&gt;). That means that &lt;em&gt;all&lt;/em&gt; the files at &lt;code&gt;PATH&lt;/code&gt; get sent, not just the ones listed to &lt;a href=&quot;../../builder/index#add&quot;&gt;&lt;em&gt;ADD&lt;/em&gt;&lt;/a&gt; in the Dockerfile.</source>
          <target state="translated">이 예는 것을 지정 &lt;code&gt;PATH&lt;/code&gt; 가 있다 &lt;code&gt;.&lt;/code&gt; 따라서 로컬 디렉토리의 모든 파일은 &lt;code&gt;tar&lt;/code&gt; d로 가져 와서 Docker 데몬으로 전송됩니다. &lt;code&gt;PATH&lt;/code&gt; 의 지정은 어디 도커 데몬에 빌드의 &quot;상황&quot;에 대한 파일을 찾을 수 있습니다. 데몬은 원격 컴퓨터에서 실행될 수 있으며 Dockerfile의 구문 분석은 클라이언트 측 ( &lt;code&gt;docker build&lt;/code&gt; 실행중인 ) 에서 발생하지 않습니다 . 즉 , Dockerfile의 &lt;a href=&quot;../../builder/index#add&quot;&gt;&lt;em&gt;ADD&lt;/em&gt;&lt;/a&gt; 에 나열된 파일 뿐만 아니라 &lt;code&gt;PATH&lt;/code&gt; 의&lt;em&gt;모든&lt;/em&gt; 파일 이 전송됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3f1b4b2ec0107a4788eeb351035b6620a00bc3a1" translate="yes" xml:space="preserve">
          <source>This exposes port &lt;code&gt;80&lt;/code&gt; of the container without publishing the port to the host system&amp;rsquo;s interfaces.</source>
          <target state="translated">이것은 포트를 호스트 시스템의 인터페이스에 공개하지 않고 컨테이너의 포트 &lt;code&gt;80&lt;/code&gt; 을 노출시킵니다 .</target>
        </trans-unit>
        <trans-unit id="7973f46d933381d3f9e97acb9d3166e3b57f94f6" translate="yes" xml:space="preserve">
          <source>This feature is available only if Docker has been built with &lt;code&gt;seccomp&lt;/code&gt; and the kernel is configured with &lt;code&gt;CONFIG_SECCOMP&lt;/code&gt; enabled. To check if your kernel supports &lt;code&gt;seccomp&lt;/code&gt;:</source>
          <target state="translated">이 기능은 Docker가 &lt;code&gt;seccomp&lt;/code&gt; 로 빌드되고 커널이 &lt;code&gt;CONFIG_SECCOMP&lt;/code&gt; 를 사용 하도록 구성된 경우에만 사용할 수 있습니다. 커널 지원이 있는지 확인하려면 &lt;code&gt;seccomp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="070122dfb768dc53f7d3aef23f672a47650e34a7" translate="yes" xml:space="preserve">
          <source>This feature is only available when using the &lt;a href=&quot;#buildkit&quot;&gt;BuildKit&lt;/a&gt; backend.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;#buildkit&quot;&gt;BuildKit&lt;/a&gt; 백엔드를 사용할 때만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48d0a8489f237e78c64950cced8d3f332a402517" translate="yes" xml:space="preserve">
          <source>This feature is only enabled if the &lt;a href=&quot;#buildkit&quot;&gt;BuildKit&lt;/a&gt; backend is used.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;#buildkit&quot;&gt;BuildKit&lt;/a&gt; 백엔드가 사용되는 경우에만 활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab1f118a9d1a31b812c1396a91fefa23b6fb9cd" translate="yes" xml:space="preserve">
          <source>This feature provides more insight to administrators than previously available with the CLI for enforcing and performing image signature verification.</source>
          <target state="translated">이 기능은 이미지 서명 확인을 시행하고 수행하기 위해 CLI를 통해 이전에 사용했던 것보다 더 많은 통찰력을 관리자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d3c36f53b5d8c2347dcc039c86557db2e2dec86" translate="yes" xml:space="preserve">
          <source>This file causes the following build behavior:</source>
          <target state="translated">이 파일은 다음과 같은 빌드 동작을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b84d0b8a2cd80cbceded9d1f0d9d22904a59ab52" translate="yes" xml:space="preserve">
          <source>This file defines two services: The &lt;code&gt;db&lt;/code&gt; service and the &lt;code&gt;web&lt;/code&gt; service.</source>
          <target state="translated">이 파일은 &lt;code&gt;db&lt;/code&gt; 서비스와 &lt;code&gt;web&lt;/code&gt; 서비스 의 두 가지 서비스를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="95857ecb6992103e8ebcb8e175e2afd7547d29a0" translate="yes" xml:space="preserve">
          <source>This file is used by the &lt;code&gt;RUN pip install -r requirements.txt&lt;/code&gt; command in your &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">이 파일은 &lt;code&gt;Dockerfile&lt;/code&gt; 의 &lt;code&gt;RUN pip install -r requirements.txt&lt;/code&gt; 명령에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="196157189d8d2a5ed71c8f3d197a913261911ce4" translate="yes" xml:space="preserve">
          <source>This first rebuilds the image for &lt;code&gt;web&lt;/code&gt; and then stop, destroy, and recreate &lt;em&gt;just&lt;/em&gt; the &lt;code&gt;web&lt;/code&gt; service. The &lt;code&gt;--no-deps&lt;/code&gt; flag prevents Compose from also recreating any services which &lt;code&gt;web&lt;/code&gt; depends on.</source>
          <target state="translated">이것은 처음에 이미지 재 구축 &lt;code&gt;web&lt;/code&gt; 한 다음 중지, 파괴, 그리고 다시 &lt;em&gt;바로 &lt;/em&gt; &lt;code&gt;web&lt;/code&gt; 서비스를. &lt;code&gt;--no-deps&lt;/code&gt; 또한 모든 서비스 다시에서 플래그 방지 작성을 &lt;code&gt;web&lt;/code&gt; 에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="69986be847074a6716ab299c2e76741b68bdc2da" translate="yes" xml:space="preserve">
          <source>This flag allows you to configure the UDP port number to use for data path traffic. The provided port number must be within the 1024 - 49151 range. If this flag is not set or is set to 0, the default port number 4789 is used. The data path port can only be configured when initializing the swarm, and applies to all nodes that join the swarm. The following example initializes a new Swarm, and configures the data path port to UDP port 7777;</source>
          <target state="translated">이 플래그를 사용하면 데이터 경로 트래픽에 사용할 UDP 포트 번호를 구성 할 수 있습니다. 제공된 포트 번호는 1024-49151 범위 내에 있어야합니다. 이 플래그를 설정하지 않거나 0으로 설정하면 기본 포트 번호 4789가 사용됩니다. 데이터 경로 포트는 웜을 초기화 할 때만 구성 할 수 있으며 웜에 참여하는 모든 노드에 적용됩니다. 다음 예는 새 Swarm을 초기화하고 데이터 경로 포트를 UDP 포트 7777로 구성합니다.</target>
        </trans-unit>
        <trans-unit id="09741286d4981528eaa313e7563493ef90e45c72" translate="yes" xml:space="preserve">
          <source>This flag allows you to pass the build-time variables that are accessed like regular environment variables in the &lt;code&gt;RUN&lt;/code&gt; instruction of the Dockerfile. Also, these values don&amp;rsquo;t persist in the intermediate or final images like &lt;code&gt;ENV&lt;/code&gt; values do. You must add &lt;code&gt;--build-arg&lt;/code&gt; for each build argument.</source>
          <target state="translated">이 플래그를 사용하면 Dockerfile 의 &lt;code&gt;RUN&lt;/code&gt; 명령 에서 일반 환경 변수처럼 액세스되는 빌드 타임 변수를 전달할 수 있습니다 . 또한 이러한 값은 &lt;code&gt;ENV&lt;/code&gt; 값 과 같이 중간 또는 최종 이미지에서 유지되지 않습니다 . 각 빌드 인수에 대해 &lt;code&gt;--build-arg&lt;/code&gt; 를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="374d76d83227e5b376b5f3e2e176de9ac7a79aae" translate="yes" xml:space="preserve">
          <source>This flag enables automatic locking of managers with an encryption key. The private keys and data stored by all managers will be protected by the encryption key printed in the output, and will not be accessible without it. Thus, it is very important to store this key in order to activate a manager after it restarts. The key can be passed to &lt;code&gt;docker swarm unlock&lt;/code&gt; to reactivate the manager. Autolock can be disabled by running &lt;code&gt;docker swarm update --autolock=false&lt;/code&gt;. After disabling it, the encryption key is no longer required to start the manager, and it will start up on its own without user intervention.</source>
          <target state="translated">이 플래그를 사용하면 암호화 키로 관리자를 자동으로 잠글 수 있습니다. 모든 관리자가 저장 한 개인 키와 데이터는 출력에 인쇄 된 암호화 키에 의해 보호되며 암호 키가 없으면 액세스 할 수 없습니다. 따라서 관리자를 다시 시작한 후에 활성화하려면이 키를 저장하는 것이 매우 중요합니다. 이 키는 관리자를 다시 활성화 하기 위해 &lt;code&gt;docker swarm unlock&lt;/code&gt; 으로 전달 될 수 있습니다 . &lt;code&gt;docker swarm update --autolock=false&lt;/code&gt; 를 실행하여 자동 잠금을 비활성화 할 수 있습니다 . 암호화 키를 비활성화 한 후에는 더 이상 관리자를 시작하기 위해 암호화 키가 필요하지 않으며 사용자 개입없이 자체적으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="28844c8e1b8c5c2dde9fccc85c1dbac9f9c0e75d" translate="yes" xml:space="preserve">
          <source>This flag forces an existing node that was part of a quorum that was lost to restart as a single node Manager without losing its data.</source>
          <target state="translated">이 플래그는 쿼럼의 일부였던 기존 노드가 데이터 손실없이 단일 노드 관리자로 다시 시작되도록합니다.</target>
        </trans-unit>
        <trans-unit id="d90c9f76065599006eb81e3a82a0ec792d83c3b7" translate="yes" xml:space="preserve">
          <source>This flag is generally not necessary when joining an existing swarm.</source>
          <target state="translated">이 플래그는 일반적으로 기존 떼에 가입 할 때 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b01a60515cc500dd8faf15cc228dc135de9d21a" translate="yes" xml:space="preserve">
          <source>This flag is generally not necessary when joining an existing swarm. If you&amp;rsquo;re joining new nodes through a load balancer, you should use this flag to ensure the node advertises its IP address and not the IP address of the load balancer.</source>
          <target state="translated">이 플래그는 일반적으로 기존 떼에 가입 할 때 필요하지 않습니다. 로드 밸런서를 통해 새 노드를 결합하는 경우이 플래그를 사용하여 노드가로드 밸런서의 IP 주소가 아닌 IP 주소를 알리도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3b426fd1bf8c84ddd55b8daddda9ca4f4dc7c1b" translate="yes" xml:space="preserve">
          <source>This flag is only supported on a daemon running on Windows, and only supports the &lt;code&gt;credentialspec&lt;/code&gt; option. The &lt;code&gt;credentialspec&lt;/code&gt; must be in the format &lt;code&gt;file://spec.txt&lt;/code&gt; or &lt;code&gt;registry://keyname&lt;/code&gt;.</source>
          <target state="translated">이 플래그는 Windows에서 실행되는 데몬에서만 지원되며 &lt;code&gt;credentialspec&lt;/code&gt; 옵션 만 지원합니다 . &lt;code&gt;credentialspec&lt;/code&gt; 는 형식이어야합니다 &lt;code&gt;file://spec.txt&lt;/code&gt; 또는 &lt;code&gt;registry://keyname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2a5a6e33e602c0db38e0f95a2d38fe5670959f" translate="yes" xml:space="preserve">
          <source>This flag is useful in certain situations. For example, a cluster may want to have dedicated manager nodes that are not served as worker nodes. This could be achieved by passing &lt;code&gt;--availability=drain&lt;/code&gt; to &lt;code&gt;docker swarm init&lt;/code&gt;.</source>
          <target state="translated">이 플래그는 특정 상황에서 유용합니다. 예를 들어, 클러스터에는 작업자 노드로 제공되지 않는 전용 관리자 노드가 필요할 수 있습니다. &lt;code&gt;--availability=drain&lt;/code&gt; 을 &lt;code&gt;docker swarm init&lt;/code&gt; 에 전달 하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="965b41964ca78c42b28deeba7ec4605dc4171174" translate="yes" xml:space="preserve">
          <source>This flag is useful in certain situations. For example, a cluster may want to have dedicated manager nodes that are not served as worker nodes. This could be achieved by passing &lt;code&gt;--availability=drain&lt;/code&gt; to &lt;code&gt;docker swarm join&lt;/code&gt;.</source>
          <target state="translated">이 플래그는 특정 상황에서 유용합니다. 예를 들어, 클러스터에는 작업자 노드로 제공되지 않는 전용 관리자 노드가 필요할 수 있습니다. &lt;code&gt;--availability=drain&lt;/code&gt; 을 &lt;code&gt;docker swarm join&lt;/code&gt; 으로 전달 하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="c63968e097ab59a130422517d7e1c432897dd193" translate="yes" xml:space="preserve">
          <source>This flag sets the frequency with which nodes are told to use as a period to report their health.</source>
          <target state="translated">이 플래그는 노드가 상태를보고하는 기간으로 사용하도록 지시되는 빈도를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2c7ab7900e82261550f08562874a49f95c9c0d2b" translate="yes" xml:space="preserve">
          <source>This flag sets the number of old Raft snapshots to retain in addition to the current Raft snapshots. By default, no old snapshots are retained. This option may be used for debugging, or to store old snapshots of the swarm state for disaster recovery purposes.</source>
          <target state="translated">이 플래그는 현재 Raft 스냅 샷 외에 보존 할 기존 Raft 스냅 샷 수를 설정합니다. 기본적으로 오래된 스냅 샷은 유지되지 않습니다. 이 옵션은 재난 복구를 위해 디버깅 또는 웜 상태의 오래된 스냅 샷을 저장하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21338c4cd0e705835606ae937cba8e48d58bcc63" translate="yes" xml:space="preserve">
          <source>This flag sets the validity period for node certificates.</source>
          <target state="translated">이 플래그는 노드 인증서의 유효 기간을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="182b22958531c3b2ecf807df4174624da7ce0237" translate="yes" xml:space="preserve">
          <source>This flag sets up task history retention limit.</source>
          <target state="translated">이 플래그는 작업 기록 보존 제한을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="33ec87960094266051d98c7e71949deefb1c4578" translate="yes" xml:space="preserve">
          <source>This flag sets up the swarm to use an external CA to issue node certificates. The value takes the form &lt;code&gt;protocol=X,url=Y&lt;/code&gt;. The value for &lt;code&gt;protocol&lt;/code&gt; specifies what protocol should be used to send signing requests to the external CA. Currently, the only supported value is &lt;code&gt;cfssl&lt;/code&gt;. The URL specifies the endpoint where signing requests should be submitted.</source>
          <target state="translated">이 플래그는 외부 CA를 사용하여 노드 인증서를 발급하도록 웜을 설정합니다. 값은 &lt;code&gt;protocol=X,url=Y&lt;/code&gt; 형식 입니다. &lt;code&gt;protocol&lt;/code&gt; 값은 서명 요청을 외부 CA에 보내는 데 사용해야 하는 프로토콜을 지정합니다. 현재 지원되는 유일한 값은 &lt;code&gt;cfssl&lt;/code&gt; 입니다. URL은 서명 요청을 제출해야하는 엔드 포인트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="42943b66e28caafe70f9e0fbe4da987b032324cb" translate="yes" xml:space="preserve">
          <source>This flag specifies default subnet pools for global scope networks. Format example is &lt;code&gt;--default-addr-pool 30.30.0.0/16 --default-addr-pool 40.40.0.0/16&lt;/code&gt;</source>
          <target state="translated">이 플래그는 글로벌 범위 네트워크에 대한 기본 서브넷 풀을 지정합니다. 형식 예는 &lt;code&gt;--default-addr-pool 30.30.0.0/16 --default-addr-pool 40.40.0.0/16&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3584ceba9556dac01c282a6d287207c320ae2d85" translate="yes" xml:space="preserve">
          <source>This flag specifies default subnet pools mask length for default-addr-pool. Format example is &lt;code&gt;--default-addr-pool-mask-length 24&lt;/code&gt;</source>
          <target state="translated">이 플래그는 default-addr-pool의 기본 서브넷 풀 마스크 길이를 지정합니다. 형식 예는 &lt;code&gt;--default-addr-pool-mask-length 24&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d88c81589962eebdd197d27485bd865b027e9ec2" translate="yes" xml:space="preserve">
          <source>This flag specifies how many log entries to allow in between Raft snapshots. Setting this to a higher number will trigger snapshots less frequently. Snapshots compact the Raft log and allow for more efficient transfer of the state to new managers. However, there is a performance cost to taking snapshots frequently.</source>
          <target state="translated">이 플래그는 Raft 스냅 샷 사이에 허용 할 로그 항목 수를 지정합니다. 이 값을 더 높게 설정하면 스냅 샷이 덜 자주 트리거됩니다. 스냅 샷은 Raft 로그를 압축하여 상태를 새로운 관리자에게보다 효율적으로 전송할 수 있도록합니다. 그러나 스냅 샷을 자주 만들려면 성능 비용이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ae9a8e14ca39fab192227750bdbb8dde9c2bdd6d" translate="yes" xml:space="preserve">
          <source>This flag specifies the address that global scope network drivers will publish towards other nodes in order to reach the containers running on this node. Using this parameter it is then possible to separate the container&amp;rsquo;s data traffic from the management traffic of the cluster. If unspecified, Docker will use the same IP address or interface that is used for the advertise address.</source>
          <target state="translated">이 플래그는이 노드에서 실행중인 컨테이너에 도달하기 위해 글로벌 범위 네트워크 드라이버가 다른 노드로 공개 할 주소를 지정합니다. 이 매개 변수를 사용하면 컨테이너의 데이터 트래픽을 클러스터의 관리 트래픽과 분리 할 수 ​​있습니다. 지정되지 않은 경우 Docker는 보급 주소에 사용 된 것과 동일한 IP 주소 또는 인터페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d81a2eeb06d2cdd5e888007e591c5c3914f0142f" translate="yes" xml:space="preserve">
          <source>This flag specifies the address that will be advertised to other members of the swarm for API access and overlay networking. If unspecified, Docker will check if the system has a single IP address, and use that IP address with the listening port (see &lt;code&gt;--listen-addr&lt;/code&gt;). If the system has multiple IP addresses, &lt;code&gt;--advertise-addr&lt;/code&gt; must be specified so that the correct address is chosen for inter-manager communication and overlay networking.</source>
          <target state="translated">This flag specifies the address that will be advertised to other members of the swarm for API access and overlay networking. If unspecified, Docker will check if the system has a single IP address, and use that IP address with the listening port (see &lt;code&gt;--listen-addr&lt;/code&gt; ). If the system has multiple IP addresses, &lt;code&gt;--advertise-addr&lt;/code&gt; must be specified so that the correct address is chosen for inter-manager communication and overlay networking.</target>
        </trans-unit>
        <trans-unit id="3204c892b68400424d4423cbbd7cbee01da6cef4" translate="yes" xml:space="preserve">
          <source>This flag specifies the address that will be advertised to other members of the swarm for API access. If unspecified, Docker will check if the system has a single IP address, and use that IP address with the listening port (see &lt;code&gt;--listen-addr&lt;/code&gt;). If the system has multiple IP addresses, &lt;code&gt;--advertise-addr&lt;/code&gt; must be specified so that the correct address is chosen for inter-manager communication and overlay networking.</source>
          <target state="translated">이 플래그는 API 액세스를 위해 swarm의 다른 구성원에게 알릴 주소를 지정합니다. 지정되지 않은 경우 Docker는 시스템에 단일 IP 주소가 있는지 확인하고 청취 포트와 함께 해당 IP 주소를 사용합니다 ( &lt;code&gt;--listen-addr&lt;/code&gt; 참조 ). 시스템에 여러 IP 주소 가있는 경우 관리자 간 통신 및 오버레이 네트워킹에 올바른 주소가 선택되도록 &lt;code&gt;--advertise-addr&lt;/code&gt; 을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8f9862e09ee3d53a6713c97ece1f81d54247b38" translate="yes" xml:space="preserve">
          <source>This flag specifies the availability of the node at the time the node joins a master. Possible availability values are &lt;code&gt;active&lt;/code&gt;, &lt;code&gt;pause&lt;/code&gt;, or &lt;code&gt;drain&lt;/code&gt;.</source>
          <target state="translated">이 플래그는 노드가 마스터에 참여할 때 노드의 가용성을 지정합니다. 가능한 가용성 값은 &lt;code&gt;active&lt;/code&gt; , &lt;code&gt;pause&lt;/code&gt; 또는 &lt;code&gt;drain&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="394efaf7cdae8af33e4245e6959028f74c23a319" translate="yes" xml:space="preserve">
          <source>This guide follows the steps as described &lt;a href=&quot;../content_trust/index#signing-images-with-docker-content-trust&quot;&gt;here&lt;/a&gt; so please read that and understand its prerequisites.</source>
          <target state="translated">이 안내서는 &lt;a href=&quot;../content_trust/index#signing-images-with-docker-content-trust&quot;&gt;여기에&lt;/a&gt; 설명 된 단계를 따르 므로 해당 전제 조건을 읽고 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="5f7a1eacb3304171e1925882b2fa0171e40e7bee" translate="yes" xml:space="preserve">
          <source>This has a strong security implication: for example, if you instrument Docker from a web server to provision containers through an API, you should be even more careful than usual with parameter checking, to make sure that a malicious user cannot pass crafted parameters causing Docker to create arbitrary containers.</source>
          <target state="translated">예를 들어, 웹 서버에서 Docker를 인스트루먼트하여 API를 통해 컨테이너를 프로비저닝하는 경우, 악의적 인 사용자가 Docker를 유발하는 조작 된 매개 변수를 전달할 수 없도록 평소보다 매개 변수 확인에 더주의해야합니다. 임의의 컨테이너를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a71b4d1c25bb9da90d5695fe9d0554ee40008e5" translate="yes" xml:space="preserve">
          <source>This instructs Compose to re-use the configuration for the &lt;code&gt;webapp&lt;/code&gt; service defined in the &lt;code&gt;common-services.yml&lt;/code&gt; file. Suppose that &lt;code&gt;common-services.yml&lt;/code&gt; looks like this:</source>
          <target state="translated">이는 &lt;code&gt;webapp&lt;/code&gt; 가 &lt;code&gt;common-services.yml&lt;/code&gt; 파일에 정의 된 webapp 서비스 의 구성을 재사용하도록 지시 합니다. &lt;code&gt;common-services.yml&lt;/code&gt; 이 다음과 같다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6c8856ee9d438c5fcab941824d42d2352d44d8" translate="yes" xml:space="preserve">
          <source>This instructs Compose to run &lt;code&gt;django-admin startproject composeexample&lt;/code&gt; in a container, using the &lt;code&gt;web&lt;/code&gt; service&amp;rsquo;s image and configuration. Because the &lt;code&gt;web&lt;/code&gt; image doesn&amp;rsquo;t exist yet, Compose builds it from the current directory, as specified by the &lt;code&gt;build: .&lt;/code&gt; line in &lt;code&gt;docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;web&lt;/code&gt; 서비스의 이미지와 구성을 사용하여 컨테이너에서 &lt;code&gt;django-admin startproject composeexample&lt;/code&gt; 을 컨테이너 에 실행하도록 작성 합니다. 때문에 &lt;code&gt;web&lt;/code&gt; 이미지가 아직 존재하지 않는, 작성이 지정한대로, 현재 디렉토리에서 빌드 &lt;code&gt;build: .&lt;/code&gt; &lt;code&gt;docker-compose.yml&lt;/code&gt; 의 줄입니다 .</target>
        </trans-unit>
        <trans-unit id="40c35322ebdb6d67c7e211c76c762e9d5c1fc4e8" translate="yes" xml:space="preserve">
          <source>This is a full example of the allowed configuration options on Linux:</source>
          <target state="translated">다음은 Linux에서 허용되는 구성 옵션의 전체 예입니다.</target>
        </trans-unit>
        <trans-unit id="ceb898ff81355d4608a328078b4d64c620853057" translate="yes" xml:space="preserve">
          <source>This is a full example of the allowed configuration options on Windows:</source>
          <target state="translated">다음은 Windows에서 허용되는 구성 옵션의 전체 예입니다.</target>
        </trans-unit>
        <trans-unit id="3521882215107882fcc4d41290bb3df11bfd4fa2" translate="yes" xml:space="preserve">
          <source>This is a very simple example which shows how to use configs with a Microsoft IIS service running on Docker 17.06 EE on Microsoft Windows Server 2016 or Docker for Windows 17.06 CE on Microsoft Windows 10. It stores the webpage in a config.</source>
          <target state="translated">이 예제는 Microsoft Windows Server 2016의 Docker 17.06 EE 또는 Microsoft Windows 10의 Windows 17.06 CE 용 Docker 17.06 EE에서 실행되는 Microsoft IIS 서비스와 함께 구성을 사용하는 방법을 보여주는 매우 간단한 예입니다. 웹 페이지를 구성에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ed4fd8bdbb17e4c6687c078c8d4146c91469a924" translate="yes" xml:space="preserve">
          <source>This is a very simple example which shows how to use secrets with a Microsoft IIS service running on Docker 17.06 EE on Microsoft Windows Server 2016 or Docker Desktop for Mac 17.06 on Microsoft Windows 10. It is a naive example that stores the webpage in a secret.</source>
          <target state="translated">이것은 Microsoft Windows Server 2016의 Docker 17.06 EE 또는 Microsoft Windows 10의 Mac 17.06의 Docker Desktop에서 실행되는 Microsoft IIS 서비스와 함께 비밀을 사용하는 방법을 보여주는 매우 간단한 예입니다. 웹 페이지를 비밀로 저장하는 순진한 예입니다. .</target>
        </trans-unit>
        <trans-unit id="5df4d072d41ae4438b709a23c88eb738fcb8d1a2" translate="yes" xml:space="preserve">
          <source>This is an example of the configuration file for devicemapper on Linux:</source>
          <target state="translated">다음은 Linux에서 devicemapper 구성 파일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="ff573ac58dedf3910913a4fe0dd5f50646ef17cf" translate="yes" xml:space="preserve">
          <source>This is an implementation of the same authentication used by version 2 of the &lt;a href=&quot;https://github.com/docker/distribution&quot;&gt;Docker Registry&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://github.com/docker/distribution&quot;&gt;Docker Registry&lt;/a&gt; 버전 2에서 사용하는 것과 동일한 인증을 구현 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="887d7a2fd0f8f20cef1333269d28588527adfa07" translate="yes" xml:space="preserve">
          <source>This is an offline command, and we must run a &lt;code&gt;notary publish example.com/collection&lt;/code&gt; for the add to take effect.</source>
          <target state="translated">이 명령은 오프라인 명령이므로 추가 &lt;code&gt;notary publish example.com/collection&lt;/code&gt; 를 적용하려면 공증인 게시 example.com/collection 을 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d131cd02f891c7fa57498c4c03ac4e35d582166" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;image&lt;/code&gt; cannot be used together in a version 1 file.</source>
          <target state="translated">버전 1 파일에서 &lt;code&gt;build&lt;/code&gt; 및 &lt;code&gt;image&lt;/code&gt; 를 함께 사용할 수 없기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="9e80b277ca7089d72d078aabbcccf5e116562dec" translate="yes" xml:space="preserve">
          <source>This is configured in the Dockerd configuration file.</source>
          <target state="translated">이것은 Dockerd 구성 파일에서 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="98781eb7bde96f838d1a4a7135d33e2e8801cca3" translate="yes" xml:space="preserve">
          <source>This is how piping a file into a container could be done for a build. The container&amp;rsquo;s ID will be printed after the build is done and the build logs could be retrieved using &lt;code&gt;docker logs&lt;/code&gt;. This is useful if you need to pipe a file or something else into a container and retrieve the container&amp;rsquo;s ID once the container has finished running.</source>
          <target state="translated">이것이 빌드를 위해 파일을 컨테이너로 파이핑하는 방법입니다. 빌드가 완료된 후 컨테이너의 ID가 인쇄되고 &lt;code&gt;docker logs&lt;/code&gt; 를 사용하여 빌드 로그를 검색 할 수 있습니다 . 파일이나 다른 것을 컨테이너에 파이프하고 컨테이너 실행이 끝나면 컨테이너의 ID를 검색해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="50911e9d24c857beac4c5d66836adb85d18997a6" translate="yes" xml:space="preserve">
          <source>This is inefficient for two reasons. First, there is an un-necessary cmd.exe command processor (aka shell) being invoked. Second, each &lt;code&gt;RUN&lt;/code&gt; instruction in the &lt;em&gt;shell&lt;/em&gt; form requires an extra &lt;code&gt;powershell -command&lt;/code&gt; prefixing the command.</source>
          <target state="translated">이것은 두 가지 이유로 비효율적입니다. 먼저 불필요한 cmd.exe 명령 프로세서 (일명 셸)가 호출됩니다. 둘째, &lt;em&gt;쉘&lt;/em&gt; 형식 의 각 &lt;code&gt;RUN&lt;/code&gt; 명령에는 &lt;code&gt;powershell -command&lt;/code&gt; 앞에 접두사를 추가로 추가해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2ee8d08a3a2966baa81eb1c7429f9fc51ecef0d" translate="yes" xml:space="preserve">
          <source>This is normally defaults to &lt;code&gt;~/.notary&lt;/code&gt;, but specifying &lt;code&gt;~/.docker/trust&lt;/code&gt; facilitates interoperability with content trust.</source>
          <target state="translated">일반적으로 기본값은 &lt;code&gt;~/.notary&lt;/code&gt; 이지만 &lt;code&gt;~/.docker/trust&lt;/code&gt; 를 지정 하면 컨텐츠 신뢰와의 상호 운용성이 용이합니다.</target>
        </trans-unit>
        <trans-unit id="fa1bbf331adba80ab20f6493273d833a03a0fcca" translate="yes" xml:space="preserve">
          <source>This is often required by a container registry before a particular repository can be deleted.</source>
          <target state="translated">이는 특정 저장소를 삭제하기 전에 컨테이너 레지스트리에 필요한 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="91fd90ef4aaad05330d5452fcd7ec7ec6087933e" translate="yes" xml:space="preserve">
          <source>This is similar to how &lt;code&gt;docker run -e&lt;/code&gt; works. Refer to the &lt;a href=&quot;../run/index#set-environment-variables--e---env---env-file&quot;&gt;&lt;code&gt;docker run&lt;/code&gt; documentation&lt;/a&gt; for more information.</source>
          <target state="translated">이것은 &lt;code&gt;docker run -e&lt;/code&gt; 작동 방식과 유사 합니다. 자세한 내용은 &lt;a href=&quot;../run/index#set-environment-variables--e---env---env-file&quot;&gt; &lt;code&gt;docker run&lt;/code&gt; 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef618a52c0bf271c31c60baf9ea32508fcdb1fa4" translate="yes" xml:space="preserve">
          <source>This is the JSON format for a plugin:</source>
          <target state="translated">플러그인의 JSON 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7305d96aeda88cc552aef5be7f5bde7be555b4ea" translate="yes" xml:space="preserve">
          <source>This is the default behavior (when &lt;code&gt;--virtualbox-boot2docker-url=&quot;&quot;&lt;/code&gt;), but the option also supports specifying ISOs by the &lt;code&gt;http://&lt;/code&gt; and &lt;code&gt;file://&lt;/code&gt; protocols. &lt;code&gt;file://&lt;/code&gt; looks at the path specified locally to locate the ISO: for instance, you could specify &lt;code&gt;--virtualbox-boot2docker-url file://$HOME/Downloads/rc.iso&lt;/code&gt; to test out a release candidate ISO that you have downloaded already. You could also just get an ISO straight from the Internet using the &lt;code&gt;http://&lt;/code&gt; form.</source>
          <target state="translated">이것이 기본 동작 ( &lt;code&gt;--virtualbox-boot2docker-url=&quot;&quot;&lt;/code&gt; 일 때 )이지만이 옵션은 &lt;code&gt;http://&lt;/code&gt; 및 &lt;code&gt;file://&lt;/code&gt; 프로토콜에 의한 ISO 지정도 지원 합니다. &lt;code&gt;file://&lt;/code&gt; 은 ISO를 찾기 위해 로컬에 지정된 경로를 찾습니다. 예를 들어 &lt;code&gt;--virtualbox-boot2docker-url file://$HOME/Downloads/rc.iso&lt;/code&gt; 를 지정 하여 보유한 릴리스 후보 ISO를 테스트 할 수 있습니다. 이미 다운로드했습니다. &lt;code&gt;http://&lt;/code&gt; 양식을 사용하여 인터넷에서 바로 ISO를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a0fa39722954e0d3b0c104d4e845a2617736fc6" translate="yes" xml:space="preserve">
          <source>This is the default usage of &lt;code&gt;inspect&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;inspect&lt;/code&gt; 의 기본 사용법입니다 .</target>
        </trans-unit>
        <trans-unit id="af2ef167c464d3226e03ea880ae052a754b713f0" translate="yes" xml:space="preserve">
          <source>This is the equivalent of &lt;code&gt;docker exec&lt;/code&gt;. With this subcommand you can run arbitrary commands in your services. Commands are by default allocating a TTY, so you can use a command such as &lt;code&gt;docker-compose exec web sh&lt;/code&gt; to get an interactive prompt.</source>
          <target state="translated">이것은 &lt;code&gt;docker exec&lt;/code&gt; 와 같습니다 . 이 하위 명령을 사용하면 서비스에서 임의의 명령을 실행할 수 있습니다. 명령은 기본적으로 TTY를 할당하므로 &lt;code&gt;docker-compose exec web sh&lt;/code&gt; 와 같은 명령을 사용 하여 대화식 프롬프트를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85c3861e897128ca07f6b330bd7c1240812c8049" translate="yes" xml:space="preserve">
          <source>This is the list of currently available credentials helpers and where you can download them from:</source>
          <target state="translated">현재 사용 가능한 자격 증명 도우미 목록과 다음 위치에서 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5862be3ae4f73cdd710cb9ee987295bdc8b9ac72" translate="yes" xml:space="preserve">
          <source>This is the personal access token used in the next step to create your cloud server.</source>
          <target state="translated">이는 클라우드 서버를 생성하기 위해 다음 단계에서 사용되는 개인 액세스 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="f0c5f9b395826f39c10bef305be8f5db6bb30682" translate="yes" xml:space="preserve">
          <source>This is the same &lt;code&gt;docker wait&lt;/code&gt; command from above, but it now exits, returning &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">위와 동일한 &lt;code&gt;docker wait&lt;/code&gt; 명령이지만 이제 종료되어 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3555f0fca87e0f9ff9496a882c687f574c02dc73" translate="yes" xml:space="preserve">
          <source>This is the same example via the command line:</source>
          <target state="translated">이것은 명령 행을 통한 동일한 예입니다.</target>
        </trans-unit>
        <trans-unit id="251a9da2d1b4f0bd61f8256864e6b4ebe6a72a52" translate="yes" xml:space="preserve">
          <source>This is the simplest method, you can then create a new machine with:</source>
          <target state="translated">이것은 가장 간단한 방법이며 다음을 사용하여 새 머신을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b231c7fb71e242adeaaeff66bb4de586f261f9" translate="yes" xml:space="preserve">
          <source>This is the standard memory limitation mechanism already present before using kernel memory. Kernel memory is completely ignored.</source>
          <target state="translated">이것은 커널 메모리를 사용하기 전에 이미 존재하는 표준 메모리 제한 메커니즘입니다. 커널 메모리는 완전히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="19e4bde3d0f60733a3e0ad9bce7974e35bcc44d6" translate="yes" xml:space="preserve">
          <source>This is used to store encrypted private keys. We only support MySQL or an in-memory store, currently.</source>
          <target state="translated">암호화 된 개인 키를 저장하는 데 사용됩니다. 현재 MySQL 또는 인 메모리 저장소 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d54da147c996ef27c593b7d07ae9ff4994b4f79a" translate="yes" xml:space="preserve">
          <source>This is useful if you are building an image which will be used as a base to build other images, for example an application build environment or a daemon which may be customized with user-specific configuration.</source>
          <target state="translated">이는 다른 이미지를 빌드하기위한 기반으로 사용될 이미지를 빌드 할 때 유용합니다 (예 : 응용 프로그램 빌드 환경 또는 사용자 별 구성으로 사용자 정의 할 수있는 디먼).</target>
        </trans-unit>
        <trans-unit id="48f4db13420819f2767c47cc8924c535b4918fe6" translate="yes" xml:space="preserve">
          <source>This is useful when using &lt;code&gt;docker-machine&lt;/code&gt; with a local VM provider, such as &lt;code&gt;virtualbox&lt;/code&gt; or &lt;code&gt;vmwarefusion&lt;/code&gt;, in network environments where an HTTP proxy is required for internet access.</source>
          <target state="translated">이는 인터넷 액세스에 HTTP 프록시가 필요한 네트워크 환경에서 &lt;code&gt;virtualbox&lt;/code&gt; 또는 &lt;code&gt;vmwarefusion&lt;/code&gt; 과 같은 로컬 VM 제공자와 함께 &lt;code&gt;docker-machine&lt;/code&gt; 을 사용할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="5a7b1461e3ee98e1f1d34f112616529a3957831f" translate="yes" xml:space="preserve">
          <source>This is useful when you want to set up a container configuration ahead of time so that it is ready to start when you need it. The initial status of the new container is &lt;code&gt;created&lt;/code&gt;.</source>
          <target state="translated">컨테이너 구성을 미리 설정하여 필요할 때 시작할 준비가되었을 때 유용합니다. 새 컨테이너의 초기 상태가 &lt;code&gt;created&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="242280060f1a747d5d62fa574aa2db8f307d6fa8" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t going to print anything unless there&amp;rsquo;s an error because we&amp;rsquo;ve only attached to the &lt;code&gt;STDERR&lt;/code&gt; of the container. The container&amp;rsquo;s logs still store what&amp;rsquo;s been written to &lt;code&gt;STDERR&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="translated">컨테이너 의 &lt;code&gt;STDERR&lt;/code&gt; 에만 첨부되어 있기 때문에 오류가 없으면 아무것도 인쇄하지 않습니다 . 컨테이너의 로그에는 여전히 &lt;code&gt;STDERR&lt;/code&gt; 및 &lt;code&gt;STDOUT&lt;/code&gt; 에 작성된 내용이 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="b04e5b87a95aeb05841a0835214650cd8ff8e690" translate="yes" xml:space="preserve">
          <source>This key allows Docker image repositories to have freshness security guarantees without requiring periodic content refreshes on the client&amp;rsquo;s side.</source>
          <target state="translated">이 키를 사용하면 Docker 이미지 저장소가 클라이언트 측에서 주기적으로 컨텐츠를 새로 고치지 않아도 최신 보안을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc9f1697bcfe844f2abff99aa695a8640467143" translate="yes" xml:space="preserve">
          <source>This key allows you to sign image tags, to manage delegations including delegated keys or permitted delegation paths. Also known as the repository key, since this key determines what tags can be signed into an image repository.</source>
          <target state="translated">이 키를 사용하면 이미지 태그에 서명하고 위임 된 키 또는 허용 된 위임 경로를 포함한 위임을 관리 할 수 ​​있습니다. 이 키는 이미지 저장소에 서명 할 수있는 태그를 결정하므로 저장소 키라고도합니다.</target>
        </trans-unit>
        <trans-unit id="0ee6ba929f00726e2f0585d573a2dfa825f67b1b" translate="yes" xml:space="preserve">
          <source>This key signs the current collection of image tags, preventing mix and match attacks.</source>
          <target state="translated">이 키는 현재 이미지 태그 모음에 서명하여 믹스 앤 매치 공격을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="4f77290ea2869acff19a050095fe90ce3122e97a" translate="yes" xml:space="preserve">
          <source>This loss also requires &lt;strong&gt;manual intervention&lt;/strong&gt; from every consumer that pulled the tagged image prior to the loss. Image consumers would get an error for content that they already downloaded:</source>
          <target state="translated">이 손실은 또한 손실 전에 태그 이미지를 가져온 모든 소비자의 &lt;strong&gt;수동 개입&lt;/strong&gt; 이 필요합니다 . 이미지 소비자는 이미 다운로드 한 컨텐츠에 대해 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1c58d800f6f93f6ac23f9417190716231f4e6ca5" translate="yes" xml:space="preserve">
          <source>This means a lot for container security; let&amp;rsquo;s see why!</source>
          <target state="translated">이것은 컨테이너 보안에 많은 의미가 있습니다. 이유를 보자!</target>
        </trans-unit>
        <trans-unit id="57b7f29b05ce9f5fbb9eb609c0f9284f0daaf51d" translate="yes" xml:space="preserve">
          <source>This means processes in container can be executed on cpu 0, cpu 1 and cpu 2.</source>
          <target state="translated">이는 컨테이너의 프로세스가 CPU 0, CPU 1 및 CPU 2에서 실행될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b3cfe09c86fb751994a178ab22bdcf760e7c1414" translate="yes" xml:space="preserve">
          <source>This means processes in container can be executed on cpu 1 and cpu 3.</source>
          <target state="translated">이는 컨테이너의 프로세스가 CPU 1 및 CPU 3에서 실행될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0bfd3f5ba2e037f66ae2105dd609d0014d346456" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;testuser&lt;/code&gt; is assigned a subordinate user ID range of &lt;code&gt;231072&lt;/code&gt; and the next 65536 integers in sequence. UID &lt;code&gt;231072&lt;/code&gt; is mapped within the namespace (within the container, in this case) as UID &lt;code&gt;0&lt;/code&gt; (&lt;code&gt;root&lt;/code&gt;). UID &lt;code&gt;231073&lt;/code&gt; is mapped as UID &lt;code&gt;1&lt;/code&gt;, and so forth. If a process attempts to escalate privilege outside of the namespace, the process is running as an unprivileged high-number UID on the host, which does not even map to a real user. This means the process has no privileges on the host system at all.</source>
          <target state="translated">즉, &lt;code&gt;testuser&lt;/code&gt; 에는 &lt;code&gt;231072&lt;/code&gt; 의 하위 사용자 ID 범위 와 다음 65536 정수가 순서대로 할당 됩니다. UID &lt;code&gt;231072&lt;/code&gt; 는 네임 스페이스 (이 경우 컨테이너 내) 내에 UID &lt;code&gt;0&lt;/code&gt; ( &lt;code&gt;root&lt;/code&gt; ) 으로 매핑됩니다 . UID &lt;code&gt;231073&lt;/code&gt; 은 UID &lt;code&gt;1&lt;/code&gt; 등 으로 매핑됩니다 . 프로세스가 네임 스페이스 외부에서 권한을 에스컬레이션하려고 시도하면 프로세스가 호스트에서 권한이없는 높은 숫자의 UID로 실행 중이며 실제 사용자에게도 맵핑되지 않습니다. 이는 프로세스에 호스트 시스템에 대한 권한이 전혀 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="30a07d01e7b27c33ddc4d0946c7f0b54e8fa898a" translate="yes" xml:space="preserve">
          <source>This means that commands that raise privileges such as &lt;code&gt;su&lt;/code&gt; or &lt;code&gt;sudo&lt;/code&gt; will no longer work. It also causes any seccomp filters to be applied later, after privileges have been dropped which may mean you can have a more restrictive set of filters. For more details, see the &lt;a href=&quot;https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt&quot;&gt;kernel documentation&lt;/a&gt;.</source>
          <target state="translated">이는 &lt;code&gt;su&lt;/code&gt; 또는 &lt;code&gt;sudo&lt;/code&gt; 와 같은 권한을 올리는 명령 이 더 이상 작동하지 않음을 의미합니다. 또한 권한이 삭제 된 후 seccomp 필터가 나중에 적용되어보다 제한적인 필터 세트를 가질 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt&quot;&gt;커널 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ee4e31ae7518e4aba3b08daf725b09cc465d272" translate="yes" xml:space="preserve">
          <source>This means that even if an intruder manages to escalate to root within a container, it is much harder to do serious damage, or to escalate to the host.</source>
          <target state="translated">이는 침입자가 컨테이너 내에서 루트로 에스컬레이션 할 수 있다고해도 심각한 피해를 입히거나 호스트로 에스컬레이션하기가 훨씬 더 어렵다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cfba96fcdabc85b27cf0354360479e1a65d7a0a6" translate="yes" xml:space="preserve">
          <source>This means that in most cases, containers do not need &amp;ldquo;real&amp;rdquo; root privileges &lt;em&gt;at all&lt;/em&gt;. And therefore, containers can run with a reduced capability set; meaning that &amp;ldquo;root&amp;rdquo; within a container has much less privileges than the real &amp;ldquo;root&amp;rdquo;. For instance, it is possible to:</source>
          <target state="translated">이 방법은 대부분의 경우, 컨테이너는 &quot;진짜&quot;루트 권한이 필요하지 않습니다 &lt;em&gt;전혀&lt;/em&gt; . 따라서 컨테이너는 기능 세트가 축소 된 상태로 실행될 수 있습니다. 컨테이너 내의 &quot;루트&quot;는 실제 &quot;루트&quot;보다 훨씬 적은 권한을 갖습니다. 예를 들어 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="48f2e56c16bd5a8788d2bdee07af5fa0873dde6f" translate="yes" xml:space="preserve">
          <source>This means that user-namespaced processes started by &lt;code&gt;testuser&lt;/code&gt; are owned by host UID &lt;code&gt;231072&lt;/code&gt; (which looks like UID &lt;code&gt;0&lt;/code&gt; inside the namespace) through 296607 (231072 + 65536 - 1). These ranges should not overlap, to ensure that namespaced processes cannot access each other&amp;rsquo;s namespaces.</source>
          <target state="translated">이는 &lt;code&gt;testuser&lt;/code&gt; 가 시작한 사용자 이름 공간 프로세스가 296607 (231072 + 65536-1)을 통해 호스트 UID &lt;code&gt;231072&lt;/code&gt; ( 네임 스페이스 내부의 UID &lt;code&gt;0&lt;/code&gt; 처럼 보임)에 의해 소유 됨을 의미합니다 . 네임 스페이스 프로세스가 서로의 네임 스페이스에 액세스 할 수 없도록 이러한 범위가 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7600b39f3c3ea87e505c16f306e0490a4ce5ec49" translate="yes" xml:space="preserve">
          <source>This means you run your own content trust (Notary) server and registry. If you work exclusively with the Docker Hub, you would not need with these components. They are built into the Docker Hub for you. For the sandbox, however, you build your own entire, mock production environment.</source>
          <target state="translated">즉, 고유 한 컨텐츠 신뢰 (공증인) 서버 및 레지스트리를 실행해야합니다. Docker Hub에서만 독점적으로 작업하는 경우 이러한 구성 요소가 필요하지 않습니다. Docker Hub에 내장되어 있습니다. 그러나 샌드 박스의 경우 자체 모의 프로덕션 환경을 구축합니다.</target>
        </trans-unit>
        <trans-unit id="4be21e58b2ba0448e561f4023a1ef3cecba87466" translate="yes" xml:space="preserve">
          <source>This opens an interactive PostgreSQL shell for the linked &lt;code&gt;db&lt;/code&gt; container.</source>
          <target state="translated">연결된 &lt;code&gt;db&lt;/code&gt; 컨테이너에 대한 대화식 PostgreSQL 셸이 열립니다 .</target>
        </trans-unit>
        <trans-unit id="7d383519df6c6513bd69ba83e4ed66750ea9fc1f" translate="yes" xml:space="preserve">
          <source>This option can also be set in the configuration file.</source>
          <target state="translated">이 옵션은 구성 파일에서도 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="786e7d6ffd559942db81568bb9e1e90f3c8666fb" translate="yes" xml:space="preserve">
          <source>This option can be overridden with the command line flag &lt;code&gt;--trustDir&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 명령 행 플래그 &lt;code&gt;--trustDir&lt;/code&gt; 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="602e27f24732b02e597ef9d5c2498011784c8d49" translate="yes" xml:space="preserve">
          <source>This option can be used multiple times.</source>
          <target state="translated">이 옵션은 여러 번 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deb85cf374d2bd098ea8bf65926f5bd0296e5ac1" translate="yes" xml:space="preserve">
          <source>This option can be used to perform batch operations. For example, you can use the task IDs as input for other commands, such as &lt;code&gt;docker inspect&lt;/code&gt;. The following example inspects all tasks of the &amp;ldquo;voting&amp;rdquo; stack;</source>
          <target state="translated">이 옵션은 배치 작업을 수행하는 데 사용할 수 있습니다. 예를 들어, &lt;code&gt;docker inspect&lt;/code&gt; 와 같은 다른 명령에 대한 입력으로 작업 ID를 사용할 수 있습니다 . 다음 예는 &quot;투표&quot;스택의 모든 작업을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="09c05ac58960b992e4b1ec957239a624b2b15cd8" translate="yes" xml:space="preserve">
          <source>This option cannot be set in the configuration file, since some log messages are produced on startup before the configuration file has been read.</source>
          <target state="translated">구성 파일을 읽기 전에 시작시 일부 로그 메시지가 생성되므로이 옵션은 구성 파일에서 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b544efcdd617df8c8ebb314fd8bb18a08e0d1c7" translate="yes" xml:space="preserve">
          <source>This option is ignored when &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a (version 3) Compose file.</source>
          <target state="translated">(버전 3) 작성 파일을 사용 &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;하여 스택 모드&lt;/a&gt; 로 스택을 배포 할 때는이 옵션이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc5425b76c95826c100ba5446ec4e726d8998ffb" translate="yes" xml:space="preserve">
          <source>This option is only used for services using Windows containers. The &lt;code&gt;--credential-spec&lt;/code&gt; must be in the format &lt;code&gt;file://&amp;lt;filename&amp;gt;&lt;/code&gt; or &lt;code&gt;registry://&amp;lt;value-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 Windows 컨테이너를 사용하는 서비스에만 사용됩니다. &lt;code&gt;--credential-spec&lt;/code&gt; 형식이어야합니다 &lt;code&gt;file://&amp;lt;filename&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;registry://&amp;lt;value-name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a01b357f248f0c5b0a8b9362685cf5aadf905f1" translate="yes" xml:space="preserve">
          <source>This option is useful in situations where you are running Docker containers on Windows. The &lt;code&gt;--isolation &amp;lt;value&amp;gt;&lt;/code&gt; option sets a container&amp;rsquo;s isolation technology. On Linux, the only supported is the &lt;code&gt;default&lt;/code&gt; option which uses Linux namespaces. These two commands are equivalent on Linux:</source>
          <target state="translated">이 옵션은 Windows에서 Docker 컨테이너를 실행하는 상황에서 유용합니다. &lt;code&gt;--isolation &amp;lt;value&amp;gt;&lt;/code&gt; 옵션은 컨테이너의 절연 기술을 설정합니다. Linux 에서는 Linux 네임 스페이스를 사용 하는 &lt;code&gt;default&lt;/code&gt; 옵션 만 지원됩니다 . 이 두 명령은 Linux에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0e1474e103bac32d3633014fa5ef286d6e98a022" translate="yes" xml:space="preserve">
          <source>This option is useful in situations where you are running Docker containers on Windows. The &lt;code&gt;--isolation=&amp;lt;value&amp;gt;&lt;/code&gt; option sets a container&amp;rsquo;s isolation technology. On Linux, the only supported is the &lt;code&gt;default&lt;/code&gt; option which uses Linux namespaces. On Microsoft Windows, you can specify these values:</source>
          <target state="translated">이 옵션은 Windows에서 Docker 컨테이너를 실행하는 상황에서 유용합니다. &lt;code&gt;--isolation=&amp;lt;value&amp;gt;&lt;/code&gt; 옵션은 컨테이너의 절연 기술을 설정합니다. Linux 에서는 Linux 네임 스페이스를 사용 하는 &lt;code&gt;default&lt;/code&gt; 옵션 만 지원됩니다 . Microsoft Windows에서 다음 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3502397d9c95e8752a045691eeabeb56830d1d1" translate="yes" xml:space="preserve">
          <source>This option is useful when pushing images containing nondistributable artifacts to a registry on an air-gapped network so hosts on that network can pull the images without connecting to another server.</source>
          <target state="translated">이 옵션은 배포 할 수없는 아티팩트가 포함 된 이미지를 에어 갭 네트워크의 레지스트리로 푸시 할 때 유용하므로 해당 네트워크의 호스트가 다른 서버에 연결하지 않고 이미지를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99eeb17c4ee34c08168c8ec5dfdcc18fa3795d2c" translate="yes" xml:space="preserve">
          <source>This option sets the docker service containers hostname to a specific string. For example:</source>
          <target state="translated">이 옵션은 docker 서비스 컨테이너 호스트 이름을 특정 문자열로 설정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="981270b4c5799e6fe462195aa37966c4a2030ccc" translate="yes" xml:space="preserve">
          <source>This page applies to Compose file formats &lt;a href=&quot;../compose-file/compose-file-v2/index&quot;&gt;version 2&lt;/a&gt; and &lt;a href=&quot;../compose-file/index&quot;&gt;higher&lt;/a&gt;. Networking features are not supported for Compose file &lt;a href=&quot;../compose-file/compose-file-v1/index&quot;&gt;version 1 (legacy)&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 작성 파일 형식에 적용 &lt;a href=&quot;../compose-file/compose-file-v2/index&quot;&gt;버전 2&lt;/a&gt; 및 &lt;a href=&quot;../compose-file/index&quot;&gt;높은&lt;/a&gt; . 작성 파일 &lt;a href=&quot;../compose-file/compose-file-v1/index&quot;&gt;버전 1 (레거시)&lt;/a&gt; 에는 네트워킹 기능이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b3bcee27a3e5ad0d22df092686f11de2435eb18b" translate="yes" xml:space="preserve">
          <source>This page describes the commands you can use in a &lt;code&gt;Dockerfile&lt;/code&gt;. When you are done reading this page, refer to the &lt;a href=&quot;https://docs.docker.com/develop/develop-images&quot;&gt;&lt;code&gt;Dockerfile&lt;/code&gt; Best Practices&lt;/a&gt; for a tip-oriented guide.</source>
          <target state="translated">이 페이지는 &lt;code&gt;Dockerfile&lt;/code&gt; 에서 사용할 수있는 명령을 설명합니다 . 이 페이지를 &lt;a href=&quot;https://docs.docker.com/develop/develop-images&quot;&gt; &lt;code&gt;Dockerfile&lt;/code&gt; 모범 사례&lt;/a&gt; 를 참조하여 팁 중심의 안내서를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="520b8773046dd27d7e1f25471d051e56182724ac" translate="yes" xml:space="preserve">
          <source>This page details how to use the &lt;code&gt;docker run&lt;/code&gt; command to define the container&amp;rsquo;s resources at runtime.</source>
          <target state="translated">이 페이지는 &lt;code&gt;docker run&lt;/code&gt; 명령을 사용하여 런타임에 컨테이너의 자원을 정의하는 방법을 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="a1dd89b5fa251310eb3ee973322ff3a094201bdb" translate="yes" xml:space="preserve">
          <source>This page explains advanced uses of Notary client for users who are running their own Notary service. Make sure you have first read and understood how to &lt;a href=&quot;../running_a_service/index&quot;&gt;run your own Notary service&lt;/a&gt; before continuing.</source>
          <target state="translated">이 페이지에서는 자체 Notary 서비스를 실행중인 사용자를위한 Notary 클라이언트의 고급 사용법에 대해 설명합니다. 계속하기 전에 먼저 &lt;a href=&quot;../running_a_service/index&quot;&gt;자신의 공증인 서비스&lt;/a&gt; 를 운영 하는 방법을 읽고 이해했는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b18cbcc127ee1f004b66d9d1933c4e16e9912d7" translate="yes" xml:space="preserve">
          <source>This page explains how to set up and use a sandbox for experimenting with trust. The sandbox allows you to configure and try trust operations locally without impacting your production images.</source>
          <target state="translated">이 페이지에서는 신뢰 실험을 위해 샌드 박스를 설정하고 사용하는 방법에 대해 설명합니다. 샌드 박스를 사용하면 프로덕션 이미지에 영향을주지 않고 로컬에서 트러스트 작업을 구성하고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce9146232e8f6563acf7cbede4e05fe73611e2d" translate="yes" xml:space="preserve">
          <source>This page is intended for people who want to develop their own Docker plugin. If you just want to learn about or use Docker plugins, look &lt;a href=&quot;../legacy_plugins/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 자체 Docker 플러그인을 개발하려는 사람들을위한 것입니다. Docker 플러그인에 대해 배우거나 사용하려면 &lt;a href=&quot;../legacy_plugins/index&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc10a8f4423dc87d792404760250d462923aec64" translate="yes" xml:space="preserve">
          <source>This page provides the usage information for the &lt;code&gt;docker-compose&lt;/code&gt; Command.</source>
          <target state="translated">이 페이지는 &lt;code&gt;docker-compose&lt;/code&gt; 명령 의 사용법 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="fd979b0e56c0e84cc55b9aebae95771ea2abdea4" translate="yes" xml:space="preserve">
          <source>This parameter determines which version of the image will be pulled and/or on which platform the service&amp;rsquo;s build will be performed.</source>
          <target state="translated">이 매개 변수는 가져올 버전 및 / 또는 서비스 빌드를 수행 할 플랫폼을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7834362bad9f0c5ac4c0231260c73961428425f8" translate="yes" xml:space="preserve">
          <source>This parameter specifies the alias of the current password used to encrypt the private keys in the DB. All new private keys are encrypted using this password, which must also be provided as the environment variable &lt;code&gt;NOTARY_SIGNER_&amp;lt;DEFAULT_ALIAS_VALUE&amp;gt;&lt;/code&gt;. See the &lt;a href=&quot;index#environment-variables-required-if-using-mysql&quot;&gt;environment variable&lt;/a&gt; section for more information.</source>
          <target state="translated">이 매개 변수는 DB에서 개인 키를 암호화하는 데 사용되는 현재 비밀번호의 별명을 지정합니다. 모든 새 개인 키는이 비밀번호를 사용하여 암호화되며 환경 변수 &lt;code&gt;NOTARY_SIGNER_&amp;lt;DEFAULT_ALIAS_VALUE&amp;gt;&lt;/code&gt; 로도 제공되어야합니다 . 자세한 정보는 &lt;a href=&quot;index#environment-variables-required-if-using-mysql&quot;&gt;환경 변수&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="777dd799c74e2adc2e81ed1d25f994ec8bee45d2" translate="yes" xml:space="preserve">
          <source>This passes the login token from your local client to the swarm nodes where the service is deployed, using the encrypted WAL logs. With this information, the nodes are able to log into the registry and pull the image.</source>
          <target state="translated">그러면 암호화 된 WAL 로그를 사용하여 로그인 토큰을 로컬 클라이언트에서 서비스가 배포 된 스웜 노드로 전달합니다. 이 정보를 사용하여 노드는 레지스트리에 로그인하여 이미지를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="186bd09d4ceee22a6e34a32f2e71aaad0d395416" translate="yes" xml:space="preserve">
          <source>This pipes data into a container and prints the container&amp;rsquo;s ID by attaching only to the container&amp;rsquo;s &lt;code&gt;STDIN&lt;/code&gt;.</source>
          <target state="translated">이것은 컨테이너에 데이터를 파이프하고 컨테이너의 &lt;code&gt;STDIN&lt;/code&gt; 에만 첨부하여 컨테이너의 ID를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="cbbe535825f032e9c23c746bc41235f80250d2f0" translate="yes" xml:space="preserve">
          <source>This plugin is a volume driver. It requires a &lt;code&gt;host&lt;/code&gt; network and the &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; capability. It depends upon the &lt;code&gt;/docker-volume-sshfs&lt;/code&gt; entrypoint and uses the &lt;code&gt;/run/docker/plugins/sshfs.sock&lt;/code&gt; socket to communicate with Docker Engine. This plugin has no runtime parameters.</source>
          <target state="translated">이 플러그인은 볼륨 드라이버입니다. &lt;code&gt;host&lt;/code&gt; 네트워크와 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 기능 이 필요 합니다. 그것은에 따라 달라집니다 &lt;code&gt;/docker-volume-sshfs&lt;/code&gt; 엔트리 포인트와 사용 &lt;code&gt;/run/docker/plugins/sshfs.sock&lt;/code&gt; 의 도커 엔진과 통신 할 소켓을. 이 플러그인에는 런타임 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d2f209a3ba087c8c67f2de6bc50a74cc47a50d9" translate="yes" xml:space="preserve">
          <source>This port remapping of &lt;code&gt;4000:80&lt;/code&gt; demonstrates the difference between &lt;code&gt;EXPOSE&lt;/code&gt; within the &lt;code&gt;Dockerfile&lt;/code&gt; and what the &lt;code&gt;publish&lt;/code&gt; value is set to when running &lt;code&gt;docker run -p&lt;/code&gt;. In later steps, map port 4000 on the host to port 80 in the container and use &lt;code&gt;http://localhost&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;4000:80&lt;/code&gt; 의이 포트 재 매핑은 &lt;code&gt;Dockerfile&lt;/code&gt; 내의 &lt;code&gt;EXPOSE&lt;/code&gt; 와 &lt;code&gt;docker run -p&lt;/code&gt; 를 실행할 때 &lt;code&gt;publish&lt;/code&gt; 값이 설정되는 것의 차이를 보여줍니다 . 이후 단계에서 호스트의 포트 4000을 컨테이너의 포트 80에 맵핑하고 &lt;code&gt;http://localhost&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="400f85bbbb30f2db4b530953974fa7f8f34248d8" translate="yes" xml:space="preserve">
          <source>This project directory contains a &lt;code&gt;docker-compose.yml&lt;/code&gt; file which is complete in itself for a good starter wordpress project.</source>
          <target state="translated">이 프로젝트 디렉토리에는 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일이 포함되어 있으며,이 파일은 우수한 초보자 용 워드 프레스 프로젝트를 위해 자체적으로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="0fab90084a9574add069411094898125425161d6" translate="yes" xml:space="preserve">
          <source>This quick-start guide demonstrates how to use Docker Compose to set up and run a simple Django/PostgreSQL app. Before starting, &lt;a href=&quot;../install/index&quot;&gt;install Compose&lt;/a&gt;.</source>
          <target state="translated">이 빠른 시작 안내서는 Docker Compose를 사용하여 간단한 Django / PostgreSQL 앱을 설정하고 실행하는 방법을 보여줍니다. 시작하기 전에 &lt;a href=&quot;../install/index&quot;&gt;Compose를 설치하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43734e73ef0ab40baf5043068cbd9606f0db30af" translate="yes" xml:space="preserve">
          <source>This re-mapping is transparent to the container, but introduces some configuration complexity in situations where the container needs access to resources on the Docker host, such as bind mounts into areas of the filesystem that the system user cannot write to. From a security standpoint, it is best to avoid these situations.</source>
          <target state="translated">이 다시 매핑은 컨테이너에 투명하지만 컨테이너가 시스템 사용자가 쓸 수없는 파일 시스템 영역에 바인드 마운트와 같이 컨테이너가 Docker 호스트의 리소스에 액세스해야하는 상황에서 일부 구성이 복잡해집니다. 보안 관점에서 이러한 상황을 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2ac24de773f731f14c2aa9b535d04f2d0fe4fb25" translate="yes" xml:space="preserve">
          <source>This reference page includes an &lt;a href=&quot;index#example&quot;&gt;example&lt;/a&gt; showing you how to use an elevated (Administrator-level) PowerShell and create and use an external network switch.</source>
          <target state="translated">이 참조 페이지에는 관리자 (고급) PowerShell을 사용하고 외부 네트워크 스위치를 만들고 사용하는 방법을 보여주는 &lt;a href=&quot;index#example&quot;&gt;예가&lt;/a&gt; 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b8530043a8c63a7b1bf544dc37654c646288627" translate="yes" xml:space="preserve">
          <source>This results in an image named &lt;code&gt;webapp&lt;/code&gt; and tagged &lt;code&gt;tag&lt;/code&gt;, built from &lt;code&gt;./dir&lt;/code&gt;.</source>
          <target state="translated">결과적으로 &lt;code&gt;./dir&lt;/code&gt; 에서 빌드 된 &lt;code&gt;webapp&lt;/code&gt; 라는 이미지 와 태그가 지정된 &lt;code&gt;tag&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="c4a19e399a6b2f22766891f01bcf211751581c40" translate="yes" xml:space="preserve">
          <source>This runs &lt;a href=&quot;../reference/up/index&quot;&gt;&lt;code&gt;docker-compose up&lt;/code&gt;&lt;/a&gt; in detached mode, pulls the needed Docker images, and starts the wordpress and database containers, as shown in the example below.</source>
          <target state="translated">아래 예제와 같이 &lt;a href=&quot;../reference/up/index&quot;&gt; &lt;code&gt;docker-compose up&lt;/code&gt; &lt;/a&gt; 을 분리 모드로 실행 하고 필요한 Docker 이미지를 가져온 다음 wordpress 및 데이터베이스 컨테이너를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f9b9eb4cba5242d0517d69026c6dbbef8a348333" translate="yes" xml:space="preserve">
          <source>This runs a database upgrade script, and removes the container when finished running, even if a restart policy is specified in the service configuration.</source>
          <target state="translated">서비스 구성에 재시작 정책이 지정된 경우에도 데이터베이스 업그레이드 스크립트가 실행되고 실행이 완료되면 컨테이너가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e150e35bd17dc66b08dd165468a66d8d046d4aff" translate="yes" xml:space="preserve">
          <source>This sandbox requires you to install two Docker tools: Docker Engine &amp;gt;= 1.10.0 and Docker Compose &amp;gt;= 1.6.0. To install the Docker Engine, choose from the &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;list of supported platforms&lt;/a&gt;. To install Docker Compose, see the &lt;a href=&quot;../../../../compose/install/index&quot;&gt;detailed instructions here&lt;/a&gt;.</source>
          <target state="translated">이 샌드 박스를 사용하려면 Docker Engine&amp;gt; = 1.10.0 및 Docker Compose&amp;gt; = 1.6.0의 두 Docker 도구를 설치해야합니다. Docker Engine을 설치하려면 &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;지원되는 플랫폼 목록&lt;/a&gt; 에서 선택하십시오 . Docker Compose를 설치하려면 &lt;a href=&quot;../../../../compose/install/index&quot;&gt;여기&lt;/a&gt; 에서 자세한 지시 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d722c716942538bb06fbff5809f80307eb51376" translate="yes" xml:space="preserve">
          <source>This section configures either a remote trust service, such as &lt;a href=&quot;../signer-config/index&quot;&gt;Notary signer&lt;/a&gt; or a local in-memory ED25519 trust service.</source>
          <target state="translated">이 섹션에서는 &lt;a href=&quot;../signer-config/index&quot;&gt;공증인 서명자&lt;/a&gt; 와 같은 원격 트러스트 서비스 또는 로컬 메모리 내 ED25519 트러스트 서비스를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="4c86039c85f7195b021ecad64f1fee5cc131f784" translate="yes" xml:space="preserve">
          <source>This section contains a list of all configuration options supported by a service definition in version 1.</source>
          <target state="translated">이 섹션에는 버전 1의 서비스 정의가 지원하는 모든 구성 옵션 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b7d0dcb6dd13d4db78e60408f7235755a2526a" translate="yes" xml:space="preserve">
          <source>This section contains a list of all configuration options supported by a service definition in version 2.</source>
          <target state="translated">이 섹션에는 버전 2의 서비스 정의가 지원하는 모든 구성 옵션 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0cf6a85c5e3740d43205d33a70e820bd507428a" translate="yes" xml:space="preserve">
          <source>This section contains a list of all configuration options supported by a service definition in version 3.</source>
          <target state="translated">이 섹션에는 버전 3의 서비스 정의에서 지원하는 모든 구성 옵션 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d549129bb6cf24086902861560365e7cc52b6b1" translate="yes" xml:space="preserve">
          <source>This section contains the following:</source>
          <target state="translated">이 섹션에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ee83559b5577073cb43336d61876b19d3de3df75" translate="yes" xml:space="preserve">
          <source>This section describes how to run multiple Docker daemons on a single host. To run multiple daemons, you must configure each daemon so that it does not conflict with other daemons on the same host. You can set these options either by providing them as flags, or by using a &lt;a href=&quot;#daemon-configuration-file&quot;&gt;daemon configuration file&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 단일 호스트에서 여러 Docker 데몬을 실행하는 방법에 대해 설명합니다. 여러 데몬을 실행하려면 동일한 데몬의 다른 데몬과 충돌하지 않도록 각 데몬을 구성해야합니다. 이러한 옵션을 플래그로 제공하거나 &lt;a href=&quot;#daemon-configuration-file&quot;&gt;디먼 구성 파일&lt;/a&gt; 을 사용하여 옵션을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c38e85475538bb7b0dbb9cc421408046c48d2d71" translate="yes" xml:space="preserve">
          <source>This section discusses the security features you can configure and use within your Docker Engine installation.</source>
          <target state="translated">이 섹션에서는 Docker Engine 설치 내에서 구성하고 사용할 수있는 보안 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="57e64893facea6a939694998656d3d9a3b97113d" translate="yes" xml:space="preserve">
          <source>This section includes graduated examples which illustrate how to use Docker configs.</source>
          <target state="translated">이 섹션에는 Docker 구성 사용 방법을 보여주는 단계별 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b55a57d8c3e24e8a67a377f147fdc8c57a6e8223" translate="yes" xml:space="preserve">
          <source>This section includes three graduated examples which illustrate how to use Docker secrets. The images used in these examples have been updated to make it easier to use Docker secrets. To find out how to modify your own images in a similar way, see &lt;a href=&quot;#build-support-for-docker-secrets-into-your-images&quot;&gt;Build support for Docker Secrets into your images&lt;/a&gt;.</source>
          <target state="translated">이 섹션에는 Docker 비밀을 사용하는 방법을 보여주는 세 가지 예가 포함되어 있습니다. 이 예제에서 사용 된 이미지는 Docker 비밀을보다 쉽게 ​​사용할 수 있도록 업데이트되었습니다. 비슷한 방식으로 자신의 이미지를 수정하는 방법을 찾으려면 이미지에 &lt;a href=&quot;#build-support-for-docker-secrets-into-your-images&quot;&gt;Docker Secrets 지원 빌드를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="40000fb43f9e8961c3806bbd14470f5ceb866a60" translate="yes" xml:space="preserve">
          <source>This section is optional, Notary uses TOFU over HTTPS by default and trust certificates in the downloaded root file.</source>
          <target state="translated">이 섹션은 선택 사항입니다. Notary는 기본적으로 HTTPS를 통해 TOFU를 사용하고 다운로드 한 루트 파일에서 인증서를 신뢰합니다.</target>
        </trans-unit>
        <trans-unit id="2b4a2a0375631d1fcd2fe15c8ccfd5c62ddf3b3b" translate="yes" xml:space="preserve">
          <source>This sections specifies the authentication options for the server. Currently, we only support token authentication.</source>
          <target state="translated">이 섹션에서는 서버의 인증 옵션을 지정합니다. 현재 토큰 인증 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="966c7b77e5a06686bbebfe1ea406be83e1e9af65" translate="yes" xml:space="preserve">
          <source>This sends the URL &lt;code&gt;http://server/ctx.tar.gz&lt;/code&gt; to the Docker daemon, which downloads and extracts the referenced tarball. The &lt;code&gt;-f ctx/Dockerfile&lt;/code&gt; parameter specifies a path inside &lt;code&gt;ctx.tar.gz&lt;/code&gt; to the &lt;code&gt;Dockerfile&lt;/code&gt; that is used to build the image. Any &lt;code&gt;ADD&lt;/code&gt; commands in that &lt;code&gt;Dockerfile&lt;/code&gt; that refers to local paths must be relative to the root of the contents inside &lt;code&gt;ctx.tar.gz&lt;/code&gt;. In the example above, the tarball contains a directory &lt;code&gt;ctx/&lt;/code&gt;, so the &lt;code&gt;ADD ctx/container.cfg /&lt;/code&gt; operation works as expected.</source>
          <target state="translated">URL &lt;code&gt;http://server/ctx.tar.gz&lt;/code&gt; 를 Docker 데몬으로 보내면 Docker 데몬이 참조 된 tarball을 다운로드하고 추출합니다. &lt;code&gt;-f ctx/Dockerfile&lt;/code&gt; 내부 파라미터를 지정하는 경로 &lt;code&gt;ctx.tar.gz&lt;/code&gt; 받는 &lt;code&gt;Dockerfile&lt;/code&gt; 이미지를 구축하기 위해 사용된다. 모든 &lt;code&gt;ADD&lt;/code&gt; 점에서 명령 &lt;code&gt;Dockerfile&lt;/code&gt; 로컬 경로를 의미 내부 내용의 루트에 상대적이어야합니다 &lt;code&gt;ctx.tar.gz&lt;/code&gt; . 위의 예에서 tarball에는 &lt;code&gt;ctx/&lt;/code&gt; 디렉토리가 포함되어 있으므로 &lt;code&gt;ADD ctx/container.cfg /&lt;/code&gt; 작업이 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="974b41f3201f016ec5c3e9849ecb6508dcb28a1a" translate="yes" xml:space="preserve">
          <source>This sets an environment variable for all tasks in a service. For example:</source>
          <target state="translated">서비스의 모든 작업에 대한 환경 변수를 설정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d90f670708c83eff5ea090c34943d2213c5cef9e" translate="yes" xml:space="preserve">
          <source>This sets environment variables for the current shell that the Docker client reads which specify the TLS settings. You need to do this each time you open a new shell or restart your machine. (See also, how to &lt;a href=&quot;index#unset-environment-variables-in-the-current-shell&quot;&gt;unset environment variables in the current shell&lt;/a&gt;.)</source>
          <target state="translated">Docker 클라이언트가 읽는 TLS 설정을 지정하는 현재 쉘의 환경 변수를 설정합니다. 새 쉘을 열거 나 시스템을 다시 시작할 때마다이 작업을 수행해야합니다. ( &lt;a href=&quot;index#unset-environment-variables-in-the-current-shell&quot;&gt;현재 쉘에서 환경 변수&lt;/a&gt; 를 설정 해제 하는 방법도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1362fb48da9129cbf04fcca91c118ead689b1c4e" translate="yes" xml:space="preserve">
          <source>This sets the swarm scheduling strategy to &amp;ldquo;binpack&amp;rdquo; (pack in containers as tightly as possible per host instead of spreading them out), and the &amp;ldquo;heartbeat&amp;rdquo; interval to 5 seconds.</source>
          <target state="translated">이는 스웜 스케줄링 전략을 &quot;binpack&quot;(호스트 당 확산하지 않고 가능한 한 컨테이너에 단단히 포장)과 &quot;하트 비트&quot;간격을 5 초로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b3b87bc39d56be4bd9141ed4a4af84631f01df54" translate="yes" xml:space="preserve">
          <source>This setting can also be set per container, using the &lt;code&gt;--cgroup-parent&lt;/code&gt; option on &lt;code&gt;docker create&lt;/code&gt; and &lt;code&gt;docker run&lt;/code&gt;, and takes precedence over the &lt;code&gt;--cgroup-parent&lt;/code&gt; option on the daemon.</source>
          <target state="translated">이 설정은 &lt;code&gt;docker create&lt;/code&gt; 및 &lt;code&gt;docker run&lt;/code&gt; 의 &lt;code&gt;--cgroup-parent&lt;/code&gt; 옵션을 사용하여 컨테이너별로 설정할 수도 있고 데몬 의 &lt;code&gt;--cgroup-parent&lt;/code&gt; 옵션 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="b5e3e1d674f8abe14804489765522aad11f84326" translate="yes" xml:space="preserve">
          <source>This simple example shows how configs work in just a few commands. For a real-world example, continue to &lt;a href=&quot;#advanced-example-use-configs-with-a-nginx-service&quot;&gt;Intermediate example: Use configs with a Nginx service&lt;/a&gt;.</source>
          <target state="translated">이 간단한 예제는 몇 가지 명령으로 구성이 작동하는 방식을 보여줍니다. 실제 예제의 경우, &lt;a href=&quot;#advanced-example-use-configs-with-a-nginx-service&quot;&gt;중간 예제 : Nginx 서비스와 함께 구성 사용을&lt;/a&gt; 계속 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8869c03290570ec3c236c0316a496fa966d2587f" translate="yes" xml:space="preserve">
          <source>This simple example shows how secrets work in just a few commands. For a real-world example, continue to &lt;a href=&quot;#intermediate-example-use-secrets-with-a-nginx-service&quot;&gt;Intermediate example: Use secrets with a Nginx service&lt;/a&gt;.</source>
          <target state="translated">이 간단한 예는 몇 가지 명령으로 비밀이 작동하는 방식을 보여줍니다. 실제 예의 경우 &lt;a href=&quot;#intermediate-example-use-secrets-with-a-nginx-service&quot;&gt;중간 예 : Nginx 서비스와 함께 비밀 사용을&lt;/a&gt; 계속 하십시오 .</target>
        </trans-unit>
        <trans-unit id="935813b774f4c64a2129e8202383a5e37e5b9c90" translate="yes" xml:space="preserve">
          <source>This source of truth has two components:</source>
          <target state="translated">이 진실의 근원에는 두 가지 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac3bd0b1ca3457ee506b7ef9b6ec60e732b8a769" translate="yes" xml:space="preserve">
          <source>This step is only necessary because the sandbox is using its own server. Normally, if you are using the Docker Public Hub this step isn&amp;rsquo;t necessary.</source>
          <target state="translated">샌드 박스가 자체 서버를 사용하고 있기 때문에이 단계 만 필요합니다. 일반적으로 Docker Public Hub를 사용하는 경우이 단계가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70becb11131736d9ec9fef24e84b839e9e9c23b2" translate="yes" xml:space="preserve">
          <source>This step should be run on your Docker client machine. As such, you need to copy your CA certificate, your server certificate, and your client certificate to that machine.</source>
          <target state="translated">이 단계는 Docker 클라이언트 시스템에서 실행해야합니다. 따라서 CA 인증서, 서버 인증서 및 클라이언트 인증서를 해당 시스템에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef3d6aa647a4cc8346123554475e90f78fbc275d" translate="yes" xml:space="preserve">
          <source>This succeeds in starting the &lt;code&gt;nginx&lt;/code&gt; service inside the container. However, it fails the detached container paradigm in that, the root process (&lt;code&gt;service nginx start&lt;/code&gt;) returns and the detached container stops as designed. As a result, the &lt;code&gt;nginx&lt;/code&gt; service is started but could not be used. Instead, to start a process such as the &lt;code&gt;nginx&lt;/code&gt; web server do the following:</source>
          <target state="translated">이것은 컨테이너 내부에서 &lt;code&gt;nginx&lt;/code&gt; 서비스 를 시작하는 데 성공합니다 . 그러나 분리 된 컨테이너 패러다임에 실패하면 루트 프로세스 ( &lt;code&gt;service nginx start&lt;/code&gt; )가 리턴되고 분리 된 컨테이너가 설계된대로 중지됩니다. 결과적으로 &lt;code&gt;nginx&lt;/code&gt; 서비스가 시작되었지만 사용할 수 없습니다. 대신, &lt;code&gt;nginx&lt;/code&gt; 웹 서버 와 같은 프로세스를 시작 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="04066a5ee501d3a6ecffa5db03011e7e1310d04e" translate="yes" xml:space="preserve">
          <source>This table shows which Compose file versions support specific Docker releases.</source>
          <target state="translated">이 표는 특정 Docker 릴리스를 지원하는 Compose 파일 버전을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="db52a8d22c75e45b640fd061cd6bf87ebe9358fd" translate="yes" xml:space="preserve">
          <source>This tells Docker to:</source>
          <target state="translated">Docker에게 다음을 지시합니다.</target>
        </trans-unit>
        <trans-unit id="633e98d1e3f318794639c977c2e2c86175a8f8ba" translate="yes" xml:space="preserve">
          <source>This time the profile is &lt;code&gt;docker-default&lt;/code&gt;, which is run on containers by default unless in &lt;code&gt;privileged&lt;/code&gt; mode. This line shows that apparmor has denied &lt;code&gt;ptrace&lt;/code&gt; in the container. This is exactly as expected.</source>
          <target state="translated">이번에는 프로파일이 &lt;code&gt;docker-default&lt;/code&gt; 이며 &lt;code&gt;privileged&lt;/code&gt; 모드가 아닌 한 기본적으로 컨테이너에서 실행 됩니다. 이 줄은 컨테이너에서 의류가 &lt;code&gt;ptrace&lt;/code&gt; 를 거부했음을 나타냅니다 . 이것은 정확히 예상대로입니다.</target>
        </trans-unit>
        <trans-unit id="4532e04feecfda34e6f6502424bc974b794d3db6" translate="yes" xml:space="preserve">
          <source>This time, we&amp;rsquo;re requesting shared access to &lt;code&gt;$COUCH1&lt;/code&gt;&amp;rsquo;s volumes.</source>
          <target state="translated">이번에는 &lt;code&gt;$COUCH1&lt;/code&gt; 볼륨에 대한 공유 액세스를 요청하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77f89cecfda3150577df43adb50823690dcdbeb9" translate="yes" xml:space="preserve">
          <source>This topic introduces some of the concepts unique to the cluster management and orchestration features of Docker Engine 1.12.</source>
          <target state="translated">이 주제에서는 Docker Engine 1.12의 클러스터 관리 및 오케스트레이션 기능에 고유 한 개념 중 일부를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="6bea05dc821ffe6a989620457dd6f123fa54bbe0" translate="yes" xml:space="preserve">
          <source>This tutorial demos both &lt;code&gt;docker-machine ssh&lt;/code&gt; and &lt;code&gt;docker-machine env&lt;/code&gt;, since these are available on all platforms via the &lt;code&gt;docker-machine&lt;/code&gt; CLI.</source>
          <target state="translated">이 튜토리얼은 &lt;code&gt;docker-machine ssh&lt;/code&gt; 및 &lt;code&gt;docker-machine env&lt;/code&gt; 를 모두 시연합니다. 이는 &lt;code&gt;docker-machine&lt;/code&gt; CLI 를 통해 모든 플랫폼에서 사용할 수 있기 때문 입니다 .</target>
        </trans-unit>
        <trans-unit id="48a388225c8d9a8f5b6b885b854bebc8a0baa78a" translate="yes" xml:space="preserve">
          <source>This tutorial introduces you to the features of Docker Engine Swarm mode. You may want to familiarize yourself with the &lt;a href=&quot;../key-concepts/index&quot;&gt;key concepts&lt;/a&gt; before you begin.</source>
          <target state="translated">이 튜토리얼에서는 Docker Engine Swarm 모드의 기능을 소개합니다. 시작하기 전에 &lt;a href=&quot;../key-concepts/index&quot;&gt;주요 개념&lt;/a&gt; 을 익히고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcf9e5ca0c710c2a00ea462338dd91d5b1bf9cc0" translate="yes" xml:space="preserve">
          <source>This tutorial requires Docker Engine 1.12 or newer on each of the host machines. Install Docker Engine and verify that the Docker Engine daemon is running on each of the machines. You can get the latest version of Docker Engine as follows:</source>
          <target state="translated">이 학습서에는 각 호스트 시스템에서 Docker Engine 1.12 이상이 필요합니다. Docker Engine을 설치하고 Docker Engine 데몬이 각 머신에서 실행 중인지 확인하십시오. 다음과 같이 최신 버전의 Docker Engine을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2561f3b23f34507c7789234d2c80a981d03c723a" translate="yes" xml:space="preserve">
          <source>This tutorial requires three Linux hosts which have Docker installed and can communicate over a network. These can be physical machines, virtual machines, Amazon EC2 instances, or hosted in some other way. You can even use Docker Machine from a Linux, Mac, or Windows host. Check out &lt;a href=&quot;../../../get-started/part4/index#prerequisites&quot;&gt;Getting started - Swarms&lt;/a&gt; for one possible set-up for the hosts.</source>
          <target state="translated">이 학습서에는 Docker가 설치되어 있고 네트워크를 통해 통신 할 수있는 세 개의 Linux 호스트가 필요합니다. 물리적 시스템, 가상 시스템, Amazon EC2 인스턴스 또는 다른 방식으로 호스팅 될 수 있습니다. Linux, Mac 또는 Windows 호스트에서 Docker Machine을 사용할 수도 있습니다. &lt;a href=&quot;../../../get-started/part4/index#prerequisites&quot;&gt;시작하기-Swarms&lt;/a&gt; 에서 가능한 호스트 설정을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b63ef67c2394f3ab1bdfb028e510b3547fb7a914" translate="yes" xml:space="preserve">
          <source>This tutorial uses Docker Engine CLI commands entered on the command line of a terminal window.</source>
          <target state="translated">이 학습서는 터미널 창의 명령 행에 입력 된 Docker Engine CLI 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b050194d0d01217faf76c2a6551904240564a852" translate="yes" xml:space="preserve">
          <source>This uses &lt;code&gt;--placement-pref&lt;/code&gt; with a &lt;code&gt;spread&lt;/code&gt; strategy (currently the only supported strategy) to spread tasks evenly over the values of the &lt;code&gt;datacenter&lt;/code&gt; node label. In this example, we assume that every node has a &lt;code&gt;datacenter&lt;/code&gt; node label attached to it. If there are three different values of this label among nodes in the swarm, one third of the tasks will be placed on the nodes associated with each value. This is true even if there are more nodes with one value than another. For example, consider the following set of nodes:</source>
          <target state="translated">&lt;code&gt;spread&lt;/code&gt; 전략 (현재 유일하게 지원되는 전략) 과 함께 &lt;code&gt;--placement-pref&lt;/code&gt; 를 사용 하여 &lt;code&gt;datacenter&lt;/code&gt; 노드 레이블 값에 작업을 고르게 분산 시킵니다. 이 예에서는 모든 노드에 연결된 &lt;code&gt;datacenter&lt;/code&gt; 노드 레이블 이 있다고 가정 합니다. swarm의 노드간에이 레이블의 값이 서로 다른 경우 작업의 3 분의 1이 각 값과 연관된 노드에 배치됩니다. 하나의 값을 가진 노드가 다른 노드보다 많은 경우에도 마찬가지입니다. 예를 들어 다음 노드 세트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ea051caa2b21f50046d64451bad7e3630768b925" translate="yes" xml:space="preserve">
          <source>This value affects the system-wide &amp;ldquo;base&amp;rdquo; empty filesystem that may already be initialized and inherited by pulled images. Typically, a change to this value requires additional steps to take effect:</source>
          <target state="translated">이 값은 이미 가져온 이미지로 초기화되고 상속 될 수있는 시스템 전체의 &quot;기본&quot;빈 파일 시스템에 영향을줍니다. 일반적으로이 값을 변경하려면 추가 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1ddb422201d896594d5bc56e8588e13a5865016c" translate="yes" xml:space="preserve">
          <source>This value is &lt;strong&gt;not&lt;/strong&gt; safe for production usage. Refer to the &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/ref/settings/#allowed-hosts&quot;&gt;Django documentation&lt;/a&gt; for more information.</source>
          <target state="translated">이 값은 프로덕션 사용에 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 자세한 내용은 &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/ref/settings/#allowed-hosts&quot;&gt;Django 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e557568dc00ab2a66f3f0ba456e503c3f7aed386" translate="yes" xml:space="preserve">
          <source>This variable supports multiple Compose files separated by a path separator (on Linux and macOS the path separator is &lt;code&gt;:&lt;/code&gt;, on Windows it is &lt;code&gt;;&lt;/code&gt;). For example: &lt;code&gt;COMPOSE_FILE=docker-compose.yml:docker-compose.prod.yml&lt;/code&gt;. The path separator can also be customized using &lt;code&gt;COMPOSE_PATH_SEPARATOR&lt;/code&gt;.</source>
          <target state="translated">이 변수는 경로 구분 기호로 구분 된 여러 개의 작성 파일을 지원합니다 (Linux 및 macOS에서 경로 구분 기호는 &lt;code&gt;:&lt;/code&gt; , Windows의 경우 &lt;code&gt;;&lt;/code&gt; ). 예를 들면 다음과 같습니다 &lt;code&gt;COMPOSE_FILE=docker-compose.yml:docker-compose.prod.yml&lt;/code&gt; . 경로 구분 기호는 &lt;code&gt;COMPOSE_PATH_SEPARATOR&lt;/code&gt; 를 사용하여 사용자 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="152a8c8fcc924829f35e92ceb398d08661557bc8" translate="yes" xml:space="preserve">
          <source>This volume can now be mounted into containers.</source>
          <target state="translated">이제이 볼륨을 컨테이너에 장착 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="977e0ba0926f2bac7a3672ff13639208a7e69e2a" translate="yes" xml:space="preserve">
          <source>This will &lt;em&gt;not&lt;/em&gt; work, because by default, most potentially dangerous kernel capabilities are dropped; including &lt;code&gt;cap_sys_admin&lt;/code&gt; (which is required to mount filesystems). However, the &lt;code&gt;--privileged&lt;/code&gt; flag will allow it to run:</source>
          <target state="translated">이 것 &lt;em&gt;없습니다&lt;/em&gt; 기본적으로 대부분의 잠재적 인 위험 커널 기능이 삭제되기 때문에, 작동; &lt;code&gt;cap_sys_admin&lt;/code&gt; 포함 (파일 시스템을 마운트하는 데 필요) 그러나 &lt;code&gt;--privileged&lt;/code&gt; 플래그를 사용하면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbae9d719d2eeb06f5b7b26c25496b7eef9371e0" translate="yes" xml:space="preserve">
          <source>This will allow plugins to be actually started when the Docker daemon connects to the sockets they&amp;rsquo;re listening on (for instance the first time the daemon uses them or if one of the plugin goes down accidentally).</source>
          <target state="translated">이렇게하면 Docker 데몬이 듣고있는 소켓에 연결될 때 실제로 플러그인을 시작할 수 있습니다 (예 : 데몬을 처음 사용하거나 플러그인 중 하나가 실수로 다운 된 경우).</target>
        </trans-unit>
        <trans-unit id="d671a9defc02462449db42399b97ee4201b8d865" translate="yes" xml:space="preserve">
          <source>This will build an image for a compressed context read from &lt;code&gt;STDIN&lt;/code&gt;. Supported formats are: bzip2, gzip and xz.</source>
          <target state="translated">&lt;code&gt;STDIN&lt;/code&gt; 에서 읽은 압축 된 컨텍스트의 이미지를 빌드합니다 . 지원되는 형식은 bzip2, gzip 및 xz입니다.</target>
        </trans-unit>
        <trans-unit id="0321f3bc4f35c25ce460a7567f64149919b95f58" translate="yes" xml:space="preserve">
          <source>This will build like the previous example, but it will then tag the resulting image. The repository name will be &lt;code&gt;vieux/apache&lt;/code&gt; and the tag will be &lt;code&gt;2.0&lt;/code&gt;. &lt;a href=&quot;../tag/index&quot;&gt;Read more about valid tags&lt;/a&gt;.</source>
          <target state="translated">이것은 이전 예제와 같이 빌드되지만 결과 이미지에 태그를 지정합니다. 저장소 이름은 &lt;code&gt;vieux/apache&lt;/code&gt; 이고 태그는 &lt;code&gt;2.0&lt;/code&gt; 입니다. &lt;a href=&quot;../tag/index&quot;&gt;유효한 태그에 대해 자세히 알아보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af0fbb68417136986c187184ecad4acfe8e89495" translate="yes" xml:space="preserve">
          <source>This will clone the GitHub repository and use the cloned repository as context. The Dockerfile at the root of the repository is used as Dockerfile. You can specify an arbitrary Git repository by using the &lt;code&gt;git://&lt;/code&gt; or &lt;code&gt;git@&lt;/code&gt; scheme.</source>
          <target state="translated">GitHub 리포지토리를 복제하고 복제 된 리포지토리를 컨텍스트로 사용합니다. 저장소의 루트에있는 Dockerfile이 Dockerfile로 사용됩니다. &lt;code&gt;git://&lt;/code&gt; 또는 &lt;code&gt;git@&lt;/code&gt; 체계 를 사용하여 임의의 Git 저장소를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2a305fead63531e71eb36423ee7e62ddcd1c2a2" translate="yes" xml:space="preserve">
          <source>This will create a container and print &lt;code&gt;test&lt;/code&gt; to the console. The &lt;code&gt;cidfile&lt;/code&gt; flag makes Docker attempt to create a new file and write the container ID to it. If the file exists already, Docker will return an error. Docker will close this file when &lt;code&gt;docker run&lt;/code&gt; exits.</source>
          <target state="translated">콘솔에 대한 컨테이너 및 인쇄 &lt;code&gt;test&lt;/code&gt; 가 생성 됩니다. &lt;code&gt;cidfile&lt;/code&gt; 의 플래그는 새로운 파일을 생성하고,이 파일에 컨테이너 ID를 작성하는 도커 시도를한다. 파일이 이미 존재하면 Docker는 오류를 반환합니다. Docker &lt;code&gt;docker run&lt;/code&gt; 종료 되면 Docker가이 파일을 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb6247af7751c9c59feb81eceba79feec896d93" translate="yes" xml:space="preserve">
          <source>This will create a container named &lt;code&gt;ubuntu_bash&lt;/code&gt; and start a Bash session.</source>
          <target state="translated">그러면 &lt;code&gt;ubuntu_bash&lt;/code&gt; 라는 컨테이너가 생성 되고 Bash 세션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f7378d5022bee9179627b3803656e749aacae9" translate="yes" xml:space="preserve">
          <source>This will create a new Bash session in the container &lt;code&gt;ubuntu_bash&lt;/code&gt; with environment variable &lt;code&gt;$VAR&lt;/code&gt; set to &amp;ldquo;1&amp;rdquo;. Note that this environment variable will only be valid on the current Bash session.</source>
          <target state="translated">그러면 환경 변수 &lt;code&gt;$VAR&lt;/code&gt; 이&amp;ldquo;1&amp;rdquo;로 설정된 &lt;code&gt;ubuntu_bash&lt;/code&gt; 컨테이너에 새 Bash 세션이 생성됩니다 . 이 환경 변수는 현재 Bash 세션에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="32e49955e9af4f3f88a960aacf17ad24e1e672eb" translate="yes" xml:space="preserve">
          <source>This will create a new Bash session in the container &lt;code&gt;ubuntu_bash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ubuntu_bash&lt;/code&gt; 컨테이너에 새로운 Bash 세션이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="edc523a8d4d43c3aee75b39b463dd0cd8452cdfe" translate="yes" xml:space="preserve">
          <source>This will create a new file &lt;code&gt;/tmp/execWorks&lt;/code&gt; inside the running container &lt;code&gt;ubuntu_bash&lt;/code&gt;, in the background.</source>
          <target state="translated">이것은 실행중인 컨테이너 &lt;code&gt;ubuntu_bash&lt;/code&gt; 안에 백그라운드에서 &lt;code&gt;/tmp/execWorks&lt;/code&gt; 파일을 새로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9f70040f4a0114c4650666dc138c9295b6e3c38a" translate="yes" xml:space="preserve">
          <source>This will create a new untagged image.</source>
          <target state="translated">태그가 지정되지 않은 이미지가 새로 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="e6acb4ffd3cd2c8e0d768c8b3bafda0d1e4ce3e6" translate="yes" xml:space="preserve">
          <source>This will display untagged images that are the leaves of the images tree (not intermediary layers). These images occur when a new build of an image takes the &lt;code&gt;repo:tag&lt;/code&gt; away from the image ID, leaving it as &lt;code&gt;&amp;lt;none&amp;gt;:&amp;lt;none&amp;gt;&lt;/code&gt; or untagged. A warning will be issued if trying to remove an image when a container is presently using it. By having this flag it allows for batch cleanup.</source>
          <target state="translated">이미지 트리의 잎인 태그가없는 이미지가 표시됩니다 (중개 레이어 아님). 이러한 이미지는 이미지의 새로운 빌드가 &lt;code&gt;repo:tag&lt;/code&gt; 를 이미지 ID에서 가져 와서 &lt;code&gt;&amp;lt;none&amp;gt;:&amp;lt;none&amp;gt;&lt;/code&gt; 또는 태그가없는 상태로 남겨 둘 때 발생합니다 . 컨테이너가 현재 사용중인 이미지를 제거하려고하면 경고가 표시됩니다. 이 플래그를 사용하면 일괄 정리가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c4aa0e68f034a1c05bb8f3bd4d4537c7ef9f706a" translate="yes" xml:space="preserve">
          <source>This will increase the base device size to 50G. The Docker daemon will throw an error if existing base device size is larger than 50G. A user can use this option to expand the base device size however shrinking is not permitted.</source>
          <target state="translated">기본 장치 크기가 50G로 증가합니다. 기존 기본 장치 크기가 50G보다 큰 경우 Docker 데몬에서 오류가 발생합니다. 사용자는이 옵션을 사용하여 기본 장치 크기를 확장 할 수 있지만 축소는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5544d60b744b4e37366ebe34f8f131dd801bc62" translate="yes" xml:space="preserve">
          <source>This will only add the proxy and authentication to the Docker daemon&amp;rsquo;s requests - your &lt;code&gt;docker build&lt;/code&gt;s and running containers will need extra configuration to use the proxy</source>
          <target state="translated">Docker 데몬의 요청에만 프록시와 인증이 추가됩니다 &lt;code&gt;docker build&lt;/code&gt; 및 실행중인 컨테이너는 프록시를 사용하기 위해 추가 구성이 필요합니다</target>
        </trans-unit>
        <trans-unit id="7b28d2cdda4f21df136ea59e2569aeaf5ba0aca0" translate="yes" xml:space="preserve">
          <source>This will read a Dockerfile from &lt;code&gt;STDIN&lt;/code&gt; without context. Due to the lack of a context, no contents of any local directory will be sent to the Docker daemon. Since there is no context, a Dockerfile &lt;code&gt;ADD&lt;/code&gt; only works if it refers to a remote URL.</source>
          <target state="translated">문맥없이 &lt;code&gt;STDIN&lt;/code&gt; 에서 Dockerfile을 읽습니다 . 컨텍스트가 없기 때문에 로컬 디렉토리의 내용이 Docker 데몬으로 전송되지 않습니다. 컨텍스트가 없으므로 Dockerfile &lt;code&gt;ADD&lt;/code&gt; 는 원격 URL을 참조하는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cd752cc01d9b7f3c8307901d43034d67c2230808" translate="yes" xml:space="preserve">
          <source>This will remove all the specified stacks, &lt;code&gt;myapp&lt;/code&gt; and &lt;code&gt;vossibility&lt;/code&gt;. Services, networks, and secrets associated with all the specified stacks will be removed.</source>
          <target state="translated">지정된 스택, &lt;code&gt;myapp&lt;/code&gt; 및 &lt;code&gt;vossibility&lt;/code&gt; 가 모두 제거됩니다 . 지정된 모든 스택과 관련된 서비스, 네트워크 및 비밀이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="753755e6f658e6ba72f4b35924aaade544ac55fe" translate="yes" xml:space="preserve">
          <source>This will remove the container referenced under the link &lt;code&gt;/redis&lt;/code&gt;.</source>
          <target state="translated">링크 &lt;code&gt;/redis&lt;/code&gt; 아래에 참조 된 컨테이너가 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce6c268fdbc508e745251901ec43da0401249689" translate="yes" xml:space="preserve">
          <source>This will remove the stack with the name &lt;code&gt;myapp&lt;/code&gt;. Services, networks, and secrets associated with the stack will be removed.</source>
          <target state="translated">그러면 이름이 &lt;code&gt;myapp&lt;/code&gt; 인 스택이 제거됩니다 . 스택과 관련된 서비스, 네트워크 및 비밀이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="94cbd54f16b46431006ad056158491458f612388" translate="yes" xml:space="preserve">
          <source>This will remove the underlying link between &lt;code&gt;/webapp&lt;/code&gt; and the &lt;code&gt;/redis&lt;/code&gt; containers on the default bridge network, removing all network communication between the two containers. This does not apply when &lt;code&gt;--link&lt;/code&gt; is used with user-specified networks.</source>
          <target state="translated">그러면 기본 브리지 네트워크에서 &lt;code&gt;/webapp&lt;/code&gt; 와 &lt;code&gt;/redis&lt;/code&gt; 컨테이너 간의 기본 링크가 제거 되어 두 컨테이너 간의 모든 네트워크 통신이 제거됩니다. &lt;code&gt;--link&lt;/code&gt; 가 사용자 지정 네트워크와 함께 사용되는 경우에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7fb5e3186cd2a1b04b731f8830a92f0d8467f214" translate="yes" xml:space="preserve">
          <source>This will revert the service to the configuration that was in place before the most recent &lt;code&gt;docker service update&lt;/code&gt; command.</source>
          <target state="translated">서비스를 가장 최근의 &lt;code&gt;docker service update&lt;/code&gt; 명령 이전에 있던 구성으로 되돌 립니다.</target>
        </trans-unit>
        <trans-unit id="b0c9bd42415d5474e0860d74bb78c8a6453edf9d" translate="yes" xml:space="preserve">
          <source>This will run the &lt;code&gt;redis&lt;/code&gt; container with a restart policy of &lt;strong&gt;always&lt;/strong&gt; so that if the container exits, Docker will restart it.</source>
          <target state="translated">컨테이너가 종료되면 Docker가 다시 시작하도록 &lt;strong&gt;항상&lt;/strong&gt; 재시작 정책으로 &lt;code&gt;redis&lt;/code&gt; 컨테이너를 실행 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="675257bf3f28d9922da2d66778357a6993a5d50c" translate="yes" xml:space="preserve">
          <source>This will run the &lt;code&gt;redis&lt;/code&gt; container with a restart policy of &lt;strong&gt;on-failure&lt;/strong&gt; and a maximum restart count of 10. If the &lt;code&gt;redis&lt;/code&gt; container exits with a non-zero exit status more than 10 times in a row Docker will abort trying to restart the container. Providing a maximum restart limit is only valid for the &lt;strong&gt;on-failure&lt;/strong&gt; policy.</source>
          <target state="translated">이것은 실행 &lt;code&gt;redis&lt;/code&gt; 다시 시작 정책 컨테이너 &lt;strong&gt;에 실패&lt;/strong&gt; , 10의 최대 다시 시작 카운트 경우 &lt;code&gt;redis&lt;/code&gt; 0이 아닌 종료 상태로 컨테이너가 종료 연속 10 회 이상은 부두 노동자가 컨테이너를 다시 시작하려고 중단됩니다. 최대 재시작 제한을 제공하는 것은 &lt;strong&gt;장애 조치&lt;/strong&gt; 정책 에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="abc0ef9bcaab355478d09cc53da61c88d1938cc7" translate="yes" xml:space="preserve">
          <source>This will then be visible from &lt;code&gt;docker inspect&lt;/code&gt; with the other labels.</source>
          <target state="translated">그러면 다른 레이블을 사용하여 &lt;code&gt;docker inspect&lt;/code&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f156cf8e34e681c12b6d65b139839617dd52809" translate="yes" xml:space="preserve">
          <source>This will use a file called &lt;code&gt;Dockerfile.debug&lt;/code&gt; for the build instructions instead of &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">이것은라는 파일을 사용합니다 &lt;code&gt;Dockerfile.debug&lt;/code&gt; 대신 빌드 지침 &lt;code&gt;Dockerfile&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="eb92336a8212ba996bc7f692f12d135203fd5d76" translate="yes" xml:space="preserve">
          <source>Threat model</source>
          <target state="translated">위협 모델</target>
        </trans-unit>
        <trans-unit id="38d64b34e2de473b4b1dc526ff50cb7a3baee250" translate="yes" xml:space="preserve">
          <source>Three arguments form in &lt;code&gt;docker import&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;docker import&lt;/code&gt; 에서 세 가지 인수가 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="efa31858cf8ec81390655897e1190052e3c8f5a3" translate="yes" xml:space="preserve">
          <source>Three networked host machines</source>
          <target state="translated">네트워크로 연결된 호스트 컴퓨터 3 대</target>
        </trans-unit>
        <trans-unit id="5f1b023b9b94b0213d53467a225dd9ddb3befc5d" translate="yes" xml:space="preserve">
          <source>Three nodes with &lt;code&gt;node.labels.datacenter=east&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;node.labels.datacenter=east&lt;/code&gt; 를 가진 세 개의 노드</target>
        </trans-unit>
        <trans-unit id="3abda546302e0d1b4ba387068a8850b439d2c3bb" translate="yes" xml:space="preserve">
          <source>Three tasks run on up to three nodes. You don&amp;rsquo;t need to know which nodes are running the tasks; connecting to port 8080 on &lt;strong&gt;any&lt;/strong&gt; of the 10 nodes connects you to one of the three &lt;code&gt;nginx&lt;/code&gt; tasks. You can test this using &lt;code&gt;curl&lt;/code&gt;. The following example assumes that &lt;code&gt;localhost&lt;/code&gt; is one of the swarm nodes. If this is not the case, or &lt;code&gt;localhost&lt;/code&gt; does not resolve to an IP address on your host, substitute the host&amp;rsquo;s IP address or resolvable host name.</source>
          <target state="translated">세 개의 작업이 최대 세 개의 노드에서 실행됩니다. 어떤 노드가 작업을 실행 중인지 알 필요가 없습니다. 포트 8080에 연결하는 &lt;strong&gt;모든&lt;/strong&gt; 10 개 노드의 것은 세 가지 중 하나에 연결됩니다 &lt;code&gt;nginx&lt;/code&gt; 작업. &lt;code&gt;curl&lt;/code&gt; 을 사용하여 이것을 테스트 할 수 있습니다 . 다음 예제에서는 &lt;code&gt;localhost&lt;/code&gt; 가 swarm 노드 중 하나 라고 가정합니다 . 그렇지 않은 경우 또는 &lt;code&gt;localhost&lt;/code&gt; 가 호스트의 IP 주소로 해석되지 않으면 호스트의 IP 주소 또는 분석 가능한 호스트 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="25e81d24c5d635bd70ae658aec2b5c90fb43b39b" translate="yes" xml:space="preserve">
          <source>Through DCT, image publishers can sign their images and image consumers can ensure that the images they use are signed. Publishers could be individuals or organizations manually signing their content or automated software supply chains signing content as part of their release process.</source>
          <target state="translated">DCT를 통해 이미지 게시자는 이미지에 서명하고 이미지 소비자는 자신이 사용하는 이미지에 서명을 할 수 있습니다. 게시자는 콘텐츠에 수동으로 서명하는 개인 또는 조직이거나 릴리스 프로세스의 일부로 콘텐츠에 서명하는 자동화 된 소프트웨어 공급망 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a11ff3bf313f104278c61e0ad7ef2107be8829b7" translate="yes" xml:space="preserve">
          <source>Thus, the following two commands are equivalent:</source>
          <target state="translated">따라서 다음 두 명령은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7f8557ae7bda77ddaf6aacd81644c0c29359a782" translate="yes" xml:space="preserve">
          <source>Time between running the check (ms|s|m|h)</source>
          <target state="translated">검사 실행 사이의 시간 (ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="dc414bb7840b47fbc9d40a1862dc9540bbbae8f7" translate="yes" xml:space="preserve">
          <source>Time between running the check (ms|s|m|h) (default 0s)</source>
          <target state="translated">검사 실행 사이의 시간 (ms | s | m | h) (기본값 0s)</target>
        </trans-unit>
        <trans-unit id="1af1db00ca84e257aae04565a288fde661a89512" translate="yes" xml:space="preserve">
          <source>Time taken by the host to respond</source>
          <target state="translated">호스트가 응답하는 데 걸린 시간</target>
        </trans-unit>
        <trans-unit id="c82d26d56dc15851f4cf921db6fc2090cabaff8e" translate="yes" xml:space="preserve">
          <source>Time to wait before force killing a container (ns|us|ms|s|m|h)</source>
          <target state="translated">컨테이너 강제 종료 전 대기 시간 (ns | us | ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="bc1e369b147e0a24ce2640c12cfaab22d2c01505" translate="yes" xml:space="preserve">
          <source>Time to wait before force killing a container (ns|us|ms|s|m|h) (default 10s)</source>
          <target state="translated">컨테이너 강제 종료 전 대기 시간 (ns | us | ms | s | m | h) (기본 10 초)</target>
        </trans-unit>
        <trans-unit id="4974d2f6799f42bebb176e7526006895456be2d1" translate="yes" xml:space="preserve">
          <source>Time when the container was created.</source>
          <target state="translated">컨테이너가 생성 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="59ea42e814d67c5de3ea1f0f1be9ddb01dafaa59" translate="yes" xml:space="preserve">
          <source>Time when the image was created</source>
          <target state="translated">이미지가 생성 된 시간</target>
        </trans-unit>
        <trans-unit id="144af34250383e028899232f603f90927d68b175" translate="yes" xml:space="preserve">
          <source>Time when the network was created</source>
          <target state="translated">네트워크가 생성 된 시간</target>
        </trans-unit>
        <trans-unit id="2b1bb4c87d7f20f7d1c4dff45998b6902a4861cf" translate="yes" xml:space="preserve">
          <source>Time when the secret was created</source>
          <target state="translated">비밀이 만들어진 시간</target>
        </trans-unit>
        <trans-unit id="1352fb06f34521ca529f817b3ef6bf84fd1a49e7" translate="yes" xml:space="preserve">
          <source>Time when the secret was updated</source>
          <target state="translated">비밀이 업데이트 된 시간</target>
        </trans-unit>
        <trans-unit id="f482d5aa8cf5abaa435e6d3c3d75f6a611704cdd" translate="yes" xml:space="preserve">
          <source>Time/date is not namespaced. Also gated by &lt;code&gt;CAP_SYS_TIME&lt;/code&gt;.</source>
          <target state="translated">시간 / 날짜는 네임 스페이스가 아닙니다. &lt;code&gt;CAP_SYS_TIME&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="3ede2c8a6f720a28ef76dc964d8c3f6ffe639f9e" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) to stop a container</source>
          <target state="translated">컨테이너를 중지하는 시간 초과 (초)</target>
        </trans-unit>
        <trans-unit id="cfd6323ad97b7d6c5960f93fbf47b0342fbddd5e" translate="yes" xml:space="preserve">
          <source>Timestamp of when image was created</source>
          <target state="translated">이미지가 생성 된 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="539d7c78ddf28827aa773f40117cda9aa703b817" translate="yes" xml:space="preserve">
          <source>To add more space to a LVM (logical volume management) thin pool, just add more storage to the volume group container thin pool; this should automatically resolve any errors. If your configuration uses loop devices, then stop the Engine daemon, grow the size of loop files and restart the daemon to resolve the issue.</source>
          <target state="translated">LVM (논리 볼륨 관리) 씬 풀에 더 많은 공간을 추가하려면 볼륨 그룹 컨테이너 씬 풀에 더 많은 스토리지를 추가하십시오. 이렇게하면 오류가 자동으로 해결됩니다. 구성에서 루프 장치를 사용하는 경우 엔진 디먼을 중지하고 루프 파일 크기를 늘리고 디먼을 다시 시작하여 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="3a8c652bbbcd3a2b6759adafed8b1652d1224709" translate="yes" xml:space="preserve">
          <source>To add multiple labels to a node, pass the &lt;code&gt;--label-add&lt;/code&gt; flag for each label:</source>
          <target state="translated">노드에 여러 레이블을 추가하려면 각 레이블에 대해 &lt;code&gt;--label-add&lt;/code&gt; 플래그를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4fa0a8b0be1629cc9998343b3f4c0ac18e8ec31" translate="yes" xml:space="preserve">
          <source>To add targets to a specified delegation role, we can use the &lt;code&gt;notary add&lt;/code&gt; command with the &lt;code&gt;--roles&lt;/code&gt; flag.</source>
          <target state="translated">지정된 위임 역할에 대상을 추가하기 위해 &lt;code&gt;--roles&lt;/code&gt; 플래그 와 함께 &lt;code&gt;notary add&lt;/code&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d08b83862f7a471dd2470c93805671ee3eaa7235" translate="yes" xml:space="preserve">
          <source>To add targets to a trusted collection with notary CLI:</source>
          <target state="translated">Notary CLI를 사용하여 신뢰할 수있는 컬렉션에 대상을 추가하려면</target>
        </trans-unit>
        <trans-unit id="de80dda5d848dc2110cfb4577f8b4a8f6f9a3106" translate="yes" xml:space="preserve">
          <source>To allow the &lt;code&gt;docker&lt;/code&gt; daemon to start, regardless of &lt;code&gt;udev&lt;/code&gt; sync not being supported, set &lt;code&gt;dm.override_udev_sync_check&lt;/code&gt; to true:</source>
          <target state="translated">지원되지 않는 &lt;code&gt;udev&lt;/code&gt; 동기화에 관계없이 &lt;code&gt;docker&lt;/code&gt; 데몬을 시작 하려면 &lt;code&gt;dm.override_udev_sync_check&lt;/code&gt; 를 true로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9778a7ffd9b4d486813b023a651a736b60bf8c63" translate="yes" xml:space="preserve">
          <source>To automate importing a delegation private key to the local Docker trust store, we need to pass a passphrase for the new key. This passphrase will be required everytime that delegation signs a tag.</source>
          <target state="translated">위임 개인 키를 로컬 Docker 신뢰 저장소로 가져 오기를 자동화하려면 새 키의 암호를 전달해야합니다. 이 암호는 위임이 태그에 서명 할 때마다 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6c14c0246ea1a4daed6b5806ff472b4876709569" translate="yes" xml:space="preserve">
          <source>To avoid interference with manager node operation, you can drain manager nodes to make them unavailable as worker nodes:</source>
          <target state="translated">관리자 노드 작동과의 간섭을 피하기 위해 관리자 노드를 드레인하여 작업자 노드로 사용할 수 없도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba0816d297b98ff67febecfe3fdf69d8a9e28ef" translate="yes" xml:space="preserve">
          <source>To avoid permission errors (and the use of &lt;code&gt;sudo&lt;/code&gt;), add your user to the &lt;code&gt;docker&lt;/code&gt; group. &lt;a href=&quot;https://docs.docker.com/install/linux&quot;&gt;Read more&lt;/a&gt;.</source>
          <target state="translated">권한 오류 (및 &lt;code&gt;sudo&lt;/code&gt; 사용)를 피하려면 사용자를 &lt;code&gt;docker&lt;/code&gt; 그룹에 추가하십시오 . &lt;a href=&quot;https://docs.docker.com/install/linux&quot;&gt;더 읽어보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0da5e79aaacc875e32d7f9569cde5259686e28ed" translate="yes" xml:space="preserve">
          <source>To avoid repeating certain update failures, you may need to reconfigure the service by passing flags to &lt;code&gt;docker service update&lt;/code&gt;.</source>
          <target state="translated">특정 업데이트 실패를 반복하지 않으려면 플래그를 &lt;code&gt;docker service update&lt;/code&gt; 에 전달하여 서비스를 다시 구성해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e388c4a7df1fd4aadbe4c220ca9e497efb5b0ba" translate="yes" xml:space="preserve">
          <source>To avoid this failure, enable both deferred device deletion and deferred device removal on the daemon.</source>
          <target state="translated">이 실패를 피하려면 디먼에서 지연된 장치 삭제 및 지연된 장치 제거를 모두 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="528a6e6f37b7a97ed2ccbdae83855c8f36481a81" translate="yes" xml:space="preserve">
          <source>To build the image using:</source>
          <target state="translated">다음을 사용하여 이미지를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c1120b0abdecba386aac55c691066fe2e7ca897a" translate="yes" xml:space="preserve">
          <source>To bypass the routing mesh, you must use the long &lt;code&gt;--publish&lt;/code&gt; service and set &lt;code&gt;mode&lt;/code&gt; to &lt;code&gt;host&lt;/code&gt;. If you omit the &lt;code&gt;mode&lt;/code&gt; key or set it to &lt;code&gt;ingress&lt;/code&gt;, the routing mesh is used. The following command creates a global service using &lt;code&gt;host&lt;/code&gt; mode and bypassing the routing mesh.</source>
          <target state="translated">라우팅 메시를 우회하려면 long- &lt;code&gt;--publish&lt;/code&gt; 서비스를 사용하고 &lt;code&gt;mode&lt;/code&gt; 를 &lt;code&gt;host&lt;/code&gt; 로 설정 해야 합니다 . &lt;code&gt;mode&lt;/code&gt; 키 를 생략 하거나 &lt;code&gt;ingress&lt;/code&gt; 로 설정 하면 라우팅 메시가 사용됩니다. 다음 명령은 &lt;code&gt;host&lt;/code&gt; 모드를 사용 하고 라우팅 메시를 우회 하여 전역 서비스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b038d6a0fec119ac138e21665e94d81f366d977c" translate="yes" xml:space="preserve">
          <source>To change the label in the container context, you can add either of two suffixes &lt;code&gt;:z&lt;/code&gt; or &lt;code&gt;:Z&lt;/code&gt; to the volume mount. These suffixes tell Docker to relabel file objects on the shared volumes. The &lt;code&gt;z&lt;/code&gt; option tells Docker that two containers share the volume content. As a result, Docker labels the content with a shared content label. Shared volume labels allow all containers to read/write content. The &lt;code&gt;Z&lt;/code&gt; option tells Docker to label the content with a private unshared label. Only the current container can use a private volume.</source>
          <target state="translated">컨테이너 컨텍스트에서 레이블을 변경 하기 위해 볼륨 마운트 에 두 개의 접미사 &lt;code&gt;:z&lt;/code&gt; 또는 &lt;code&gt;:Z&lt;/code&gt; 를 추가 할 수 있습니다 . 이 접미사는 Docker에게 공유 볼륨의 파일 객체 레이블을 다시 지정하도록 지시합니다. &lt;code&gt;z&lt;/code&gt; 옵션은 두 개의 컨테이너가 볼륨의 컨텐츠를 공유하는 부두 노동자를 알려줍니다. 결과적으로 Docker는 컨텐츠에 공유 컨텐츠 레이블을 레이블합니다. 공유 볼륨 레이블을 사용하면 모든 컨테이너가 내용을 읽고 쓸 수 있습니다. &lt;code&gt;Z&lt;/code&gt; 의 옵션은 개인 비공유 레이블 내용 레이블을 도커를 알려줍니다. 현재 컨테이너 만 개인용 볼륨을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="920d05baca9a73de9d83dfcb8a2b801ff81ec855" translate="yes" xml:space="preserve">
          <source>To check the status of installed plugins, use the &lt;code&gt;docker plugin ls&lt;/code&gt; command. Plugins that start successfully are listed as enabled in the output.</source>
          <target state="translated">설치된 플러그인의 상태를 확인하려면 &lt;code&gt;docker plugin ls&lt;/code&gt; 명령을 사용하십시오 . 성공적으로 시작된 플러그인은 출력에서 ​​활성화 된 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1c0dd3b8677594a66099c085dbbda592e9784ab4" translate="yes" xml:space="preserve">
          <source>To clean up after running this example, remove the &lt;code&gt;nginx&lt;/code&gt; service and the stored secrets.</source>
          <target state="translated">이 예제를 실행 한 후 정리하려면 &lt;code&gt;nginx&lt;/code&gt; 서비스와 저장된 비밀을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e57801ffc296d25fa85471f60804c69b6db0b3b" translate="yes" xml:space="preserve">
          <source>To clean up, you can remove the &lt;code&gt;nginx&lt;/code&gt; service, as well as the secrets and configs.</source>
          <target state="translated">정리하기 위해 &lt;code&gt;nginx&lt;/code&gt; 서비스와 비밀 및 구성을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3c819c0e9147be4124112c4734f1f08feec3b3f" translate="yes" xml:space="preserve">
          <source>To cleanly re-join a manager node to a cluster:</source>
          <target state="translated">관리자 노드를 클러스터에 완전히 다시 가입 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0feac055d21638e6e74f002a5bce9986f8e82f0e" translate="yes" xml:space="preserve">
          <source>To configure custom default address pools, you must define pools at Swarm initialization using the &lt;code&gt;--default-addr-pool&lt;/code&gt; command line option. This command line option uses CIDR notation for defining the subnet mask. To create the custom address pool for Swarm, you must define at least one default address pool, and an optional default address pool subnet mask. For example, for the &lt;code&gt;10.0.0.0/27&lt;/code&gt;, use the value &lt;code&gt;27&lt;/code&gt;.</source>
          <target state="translated">사용자 지정 기본 주소 풀을 구성하려면 &lt;code&gt;--default-addr-pool&lt;/code&gt; 명령 줄 옵션을 사용하여 Swarm 초기화시 풀을 정의해야합니다 . 이 명령 행 옵션은 서브넷 마스크를 정의하기 위해 CIDR 표기법을 사용합니다. Swarm에 대한 사용자 지정 주소 풀을 만들려면 하나 이상의 기본 주소 풀과 선택적 기본 주소 풀 서브넷 마스크를 정의해야합니다. 예를 들어 &lt;code&gt;10.0.0.0/27&lt;/code&gt; 의 경우 &lt;code&gt;27&lt;/code&gt; 값을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="acebe6bbff99c6a2164814149ef86987e2d24a36" translate="yes" xml:space="preserve">
          <source>To connect to Docker and validate its certificate, provide your client keys, certificates and trusted CA:</source>
          <target state="translated">Docker에 연결하고 인증서를 확인하려면 클라이언트 키, 인증서 및 신뢰할 수있는 CA를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="276b3a88766cc7ea24740f2fb69533b4d88c434d" translate="yes" xml:space="preserve">
          <source>To connect using the Notary Client CLI, see &lt;a href=&quot;../getting_started/index&quot;&gt;Getting Started&lt;/a&gt;. The version of the Notary server and signer needs to be greater than or equal to that of the Notary Client CLI to ensure feature compatibility. For instance, if you use Notary Client CLI 0.2, the server and signer each need to be at least version 0.2 as well.</source>
          <target state="translated">Notary Client CLI를 사용하여 연결하려면 &lt;a href=&quot;../getting_started/index&quot;&gt;시작하기를&lt;/a&gt; 참조하십시오 . 기능 호환성을 위해 Notary 서버 및 서명자의 버전은 Notary Client CLI의 버전 이상이어야합니다. 예를 들어, Notary Client CLI 0.2를 사용하는 경우 서버 및 서명자는 각각 버전 0.2 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="db862edd89a39289cbb2128f02dec7301e722185" translate="yes" xml:space="preserve">
          <source>To contribute code or documentation changes, &lt;a href=&quot;https://github.com/docker/machine/pulls&quot;&gt;submit a pull request on Github&lt;/a&gt;.</source>
          <target state="translated">코드 또는 문서 변경 사항을 제공하려면 &lt;a href=&quot;https://github.com/docker/machine/pulls&quot;&gt;Github에 풀 요청을 제출하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ec84be351704dc345d8560ae8bdaea9bd796a9b" translate="yes" xml:space="preserve">
          <source>To contribute code or documentation changes: submit a &lt;a href=&quot;https://github.com/docker/compose/pulls&quot;&gt;pull request on Github&lt;/a&gt;.</source>
          <target state="translated">코드 또는 문서 변경 사항을 제공하려면 &lt;a href=&quot;https://github.com/docker/compose/pulls&quot;&gt;Github에 풀 요청을&lt;/a&gt; 제출하십시오 .</target>
        </trans-unit>
        <trans-unit id="94dd73b52c28b593d6df1a403ed55902366e0f75" translate="yes" xml:space="preserve">
          <source>To correct this, they need to download a new image tag that is signed with the new key.</source>
          <target state="translated">이 문제를 해결하려면 새 키로 서명 된 새 이미지 태그를 다운로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="429d42896dbf6c2e05601b677a2907eef85a06ce" translate="yes" xml:space="preserve">
          <source>To create a context from scratch provide the docker and, if required, kubernetes options. The example below creates the context &lt;code&gt;my-context&lt;/code&gt; with a docker endpoint of &lt;code&gt;/var/run/docker.sock&lt;/code&gt; and a kubernetes configuration sourced from the file &lt;code&gt;/home/me/my-kube-config&lt;/code&gt;:</source>
          <target state="translated">컨텍스트를 처음부터 작성하려면 도커 및 필요한 경우 kubernetes 옵션을 제공하십시오. 아래 예제 는 &lt;code&gt;/var/run/docker.sock&lt;/code&gt; 도커 엔드 포인트 와 &lt;code&gt;/home/me/my-kube-config&lt;/code&gt; 파일에서 제공되는 kubernetes 구성을 사용 하여 컨텍스트 &lt;code&gt;my-context&lt;/code&gt; 컨텍스트를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="7caced9e26bf2022cc2ed76fed4613134cef300b" translate="yes" xml:space="preserve">
          <source>To create a default IP address pool with a /16 (class B) for the 10.20.0.0 network looks like this:</source>
          <target state="translated">10.20.0.0 네트워크에 대해 / 16 (클래스 B)으로 기본 IP 주소 풀을 작성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb9bc9eedb4c5107eba7487ece9479186050797b" translate="yes" xml:space="preserve">
          <source>To create a default IP address pool with a &lt;code&gt;/16&lt;/code&gt; (class B) for the &lt;code&gt;10.20.0.0&lt;/code&gt; and &lt;code&gt;10.30.0.0&lt;/code&gt; networks, and to create a subnet mask of &lt;code&gt;/26&lt;/code&gt; for each network looks like this:</source>
          <target state="translated">&lt;code&gt;10.20.0.0&lt;/code&gt; 및 &lt;code&gt;10.30.0.0&lt;/code&gt; 네트워크에 대해 &lt;code&gt;/16&lt;/code&gt; (클래스 B) 으로 기본 IP 주소 풀 을 작성하고 각 네트워크에 대해 &lt;code&gt;/26&lt;/code&gt; 의 서브넷 마스크를 작성하는 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fbe6c28267f2aab219055b7df6b56fd8a6e0a41" translate="yes" xml:space="preserve">
          <source>To create a machine instance, specify &lt;code&gt;--driver google&lt;/code&gt;, the project ID and the machine name.</source>
          <target state="translated">머신 인스턴스를 만들려면 &lt;code&gt;--driver google&lt;/code&gt; , 프로젝트 ID 및 머신 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2351ff8f5606ddd71f68cb566573e804a0e68ed4" translate="yes" xml:space="preserve">
          <source>To create a machine with a non-default VPC-ID:</source>
          <target state="translated">기본이 아닌 VPC-ID로 머신을 생성하려면 :</target>
        </trans-unit>
        <trans-unit id="b366b59633688db22b09fd242dde1f7d119b73aa" translate="yes" xml:space="preserve">
          <source>To create a manifest list, you first &lt;code&gt;create&lt;/code&gt; the manifest list locally by specifying the constituent images you would like to have included in your manifest list. Keep in mind that this is pushed to a registry, so if you want to push to a registry other than the docker registry, you need to create your manifest list with the registry name or IP and port. This is similar to tagging an image and pushing it to a foreign registry.</source>
          <target state="translated">매니페스트 목록을 만들려면 먼저 매니페스트 목록에 포함하려는 구성 이미지를 지정하여 로컬로 매니페스트 목록을 &lt;code&gt;create&lt;/code&gt; . 이것은 레지스트리로 푸시되므로 docker 레지스트리 이외의 레지스트리로 푸시하려면 레지스트리 이름 또는 IP 및 포트를 사용하여 매니페스트 목록을 작성해야합니다. 이는 이미지에 태그를 지정하고 외부 레지스트리로 푸시하는 것과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="1a2b7fb40204c1f2fc26c6fd91a3f068fa50f969" translate="yes" xml:space="preserve">
          <source>To create a service with access to Docker-managed secrets, use the &lt;code&gt;--secret&lt;/code&gt; flag. For more information, see &lt;a href=&quot;../secrets/index&quot;&gt;Manage sensitive strings (secrets) for Docker services&lt;/a&gt;</source>
          <target state="translated">Docker 관리 비밀에 액세스하여 서비스를 작성하려면 &lt;code&gt;--secret&lt;/code&gt; 플래그를 사용하십시오 . 자세한 정보 &lt;a href=&quot;../secrets/index&quot;&gt;는 Docker 서비스의 민감한 문자열 (비밀) 관리를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ae31e00ef19d1196aaaca8e64644c27b7cd3fcd8" translate="yes" xml:space="preserve">
          <source>To create a single-replica service with no extra configuration, you only need to supply the image name. This command starts an Nginx service with a randomly-generated name and no published ports. This is a naive example, since you can&amp;rsquo;t interact with the Nginx service.</source>
          <target state="translated">추가 구성없이 단일 복제 서비스를 만들려면 이미지 이름 만 제공하면됩니다. 이 명령은 임의로 생성 된 이름으로 게시 된 포트가없는 Nginx 서비스를 시작합니다. Nginx 서비스와 상호 작용할 수 없기 때문에 이것은 순진한 예입니다.</target>
        </trans-unit>
        <trans-unit id="23a2876bc2987dcfbf089fcf94cef613d50daa8e" translate="yes" xml:space="preserve">
          <source>To create a virtual machine, you supply Docker Machine with the name of the driver you want to use. The driver determines where the virtual machine is created. For example, on a local Mac or Windows system, the driver is typically Oracle VirtualBox. For provisioning physical machines, a generic driver is provided. For cloud providers, Docker Machine supports drivers such as AWS, Microsoft Azure, DigitalOcean, and many more. The Docker Machine reference includes a complete &lt;a href=&quot;../drivers/index&quot;&gt;list of supported drivers&lt;/a&gt;.</source>
          <target state="translated">가상 머신을 작성하려면 사용하려는 드라이버 이름을 Docker Machine에 제공하십시오. 드라이버는 가상 머신이 생성되는 위치를 결정합니다. 예를 들어 로컬 Mac 또는 Windows 시스템에서 드라이버는 일반적으로 Oracle VirtualBox입니다. 실제 머신을 프로비저닝하기 위해 일반 드라이버가 제공됩니다. 클라우드 제공 업체의 경우 Docker Machine은 AWS, Microsoft Azure, DigitalOcean 등과 같은 드라이버를 지원합니다. Docker Machine 참조에는 &lt;a href=&quot;../drivers/index&quot;&gt;지원되는 전체 드라이버 목록이&lt;/a&gt; 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2711fc987c5362bdcddf078b5e5a5fbdd16c701" translate="yes" xml:space="preserve">
          <source>To create machines on &lt;a href=&quot;http://aws.amazon.com&quot;&gt;Amazon Web Services&lt;/a&gt;, you must supply two parameters: the AWS Access Key ID and the AWS Secret Access Key.</source>
          <target state="translated">&lt;a href=&quot;http://aws.amazon.com&quot;&gt;Amazon Web Services&lt;/a&gt; 에서 머신을 생성하려면 AWS Access Key ID와 AWS Secret Access Key의 두 가지 파라미터를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec913ea1f172e088c27a60db4787e664b8917153" translate="yes" xml:space="preserve">
          <source>To create machines on &lt;a href=&quot;https://aws.amazon.com&quot;&gt;Amazon Web Services&lt;/a&gt;, you must supply two parameters: the AWS Access Key ID and the AWS Secret Access Key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80225fe6938ddccfcddf30318ca1d72ba026d326" translate="yes" xml:space="preserve">
          <source>To create machines on AWS, you must supply two parameters:</source>
          <target state="translated">AWS에서 머신을 생성하려면 두 가지 파라미터를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4298a71dfbd94d762373d54a12abd6dcea770a9" translate="yes" xml:space="preserve">
          <source>To customize the host only adapter, you can use the &lt;code&gt;--virtualbox-hostonly-cidr&lt;/code&gt; flag. This specifies the host IP and Machine calculates the VirtualBox DHCP server address (a random IP on the subnet between &lt;code&gt;.1&lt;/code&gt; and &lt;code&gt;.25&lt;/code&gt;) so it does not clash with the specified host IP. Machine specifies the DHCP lower bound to &lt;code&gt;.100&lt;/code&gt; and the upper bound to &lt;code&gt;.254&lt;/code&gt;. For example, a specified CIDR of &lt;code&gt;192.168.24.1/24&lt;/code&gt; would have a DHCP server between &lt;code&gt;192.168.24.2-25&lt;/code&gt;, a lower bound of &lt;code&gt;192.168.24.100&lt;/code&gt; and upper bound of &lt;code&gt;192.168.24.254&lt;/code&gt;.</source>
          <target state="translated">호스트 전용 어댑터를 사용자 정의하기 위해 &lt;code&gt;--virtualbox-hostonly-cidr&lt;/code&gt; 플래그를 사용할 수 있습니다 . 호스트 IP와 머신이 VirtualBox DHCP 서버 주소 ( &lt;code&gt;.1&lt;/code&gt; 과 &lt;code&gt;.25&lt;/code&gt; 사이의 서브넷에있는 임의의 IP)를 계산 하여 지정된 호스트 IP와 충돌하지 않도록 지정합니다. Machine은 DHCP 하한을 &lt;code&gt;.100&lt;/code&gt; 으로 지정하고 상한을 &lt;code&gt;.254&lt;/code&gt; 로 지정 합니다. 예를 들어, 지정된 CIDR &lt;code&gt;192.168.24.1/24&lt;/code&gt; 는 &lt;code&gt;192.168.24.2-25&lt;/code&gt; 사이의 DHCP 서버 , 하한은 &lt;code&gt;192.168.24.100&lt;/code&gt; 및 상한은 &lt;code&gt;192.168.24.254&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0025887353390dc0a17ebcee1508a806e21771b4" translate="yes" xml:space="preserve">
          <source>To decrease logging level</source>
          <target state="translated">로깅 수준을 줄이려면</target>
        </trans-unit>
        <trans-unit id="983b60e4fc62e04885f33ad5005010027bfce9e6" translate="yes" xml:space="preserve">
          <source>To delete multiple networks in a single &lt;code&gt;docker network rm&lt;/code&gt; command, provide multiple network names or ids. The following example deletes a network with id &lt;code&gt;3695c422697f&lt;/code&gt; and a network named &lt;code&gt;my-network&lt;/code&gt;:</source>
          <target state="translated">단일 &lt;code&gt;docker network rm&lt;/code&gt; 명령 에서 여러 네트워크를 삭제하려면 여러 네트워크 이름 또는 ID를 제공하십시오. 다음 예는 ID가 &lt;code&gt;3695c422697f&lt;/code&gt; 이고 이름이 &lt;code&gt;my-network&lt;/code&gt; 인 네트워크 를 삭제 합니다 .</target>
        </trans-unit>
        <trans-unit id="2534dd96efc1de81edefc31853d4cf4dbbfa52ab" translate="yes" xml:space="preserve">
          <source>To demonstrate the portability of what we just created, let&amp;rsquo;s upload our built image and run it somewhere else. After all, you need to know how to push to registries when you want to deploy containers to production.</source>
          <target state="translated">방금 만든 것의 이식성을 보여주기 위해 빌드 된 이미지를 업로드하고 다른 곳에서 실행 해 봅시다. 결국 컨테이너를 프로덕션에 배치하려는 경우 레지스트리에 푸시하는 방법을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="bdc6cbcd73157cdafbc8831aea08e09b438bef40" translate="yes" xml:space="preserve">
          <source>To demote a node or set of nodes, run &lt;code&gt;docker node demote&lt;/code&gt; from a manager node:</source>
          <target state="translated">노드 또는 노드 세트를 강등 시키려면 관리자 노드에서 &lt;code&gt;docker node demote&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="841c9798f51d77e3b27bd846119ec291836c3e7c" translate="yes" xml:space="preserve">
          <source>To demote the node to a worker, run &lt;code&gt;docker node demote &amp;lt;NODE&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">노드를 작업자로 강등 시키려면 &lt;code&gt;docker node demote &amp;lt;NODE&amp;gt;&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="21100643fb6d68b7b62eae2fe8d698dd8dc20550" translate="yes" xml:space="preserve">
          <source>To deploy an application image when Docker Engine is in swarm mode, you create a service. Frequently a service is the image for a microservice within the context of some larger application. Examples of services might include an HTTP server, a database, or any other type of executable program that you wish to run in a distributed environment.</source>
          <target state="translated">Docker Engine이 스웜 모드에있을 때 애플리케이션 이미지를 배치하려면 서비스를 작성하십시오. 종종 서비스는 일부 더 큰 애플리케이션의 맥락에서 마이크로 서비스를위한 이미지입니다. 서비스의 예로는 HTTP 서버, 데이터베이스 또는 분산 환경에서 실행하려는 다른 유형의 실행 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f428fc2d635ce863af8f803769e2437ebd1be7e0" translate="yes" xml:space="preserve">
          <source>To deploy with this production Compose file you can run</source>
          <target state="translated">이 프로덕션 Compose 파일을 사용하여 배포하려면</target>
        </trans-unit>
        <trans-unit id="32a463abf83c04adfc45892c74d5fd9391f63d69" translate="yes" xml:space="preserve">
          <source>To deploy your application to a swarm, you submit a service definition to a &lt;strong&gt;manager node&lt;/strong&gt;. The manager node dispatches units of work called &lt;a href=&quot;#services-and-tasks&quot;&gt;tasks&lt;/a&gt; to worker nodes.</source>
          <target state="translated">애플리케이션을 swarm에 배치하려면 서비스 정의를 &lt;strong&gt;관리자 노드에&lt;/strong&gt; 제출 &lt;strong&gt;하십시오&lt;/strong&gt; . 관리자 노드는 작업이라는 &lt;a href=&quot;#services-and-tasks&quot;&gt;작업&lt;/a&gt; 단위 를 작업자 노드로 발송 합니다 .</target>
        </trans-unit>
        <trans-unit id="98b4a1945b6227a599d96f7b7ab7f32ac2ac62bd" translate="yes" xml:space="preserve">
          <source>To disable a plugin, use the &lt;code&gt;docker plugin disable&lt;/code&gt; command. To completely remove it, use the &lt;code&gt;docker plugin remove&lt;/code&gt; command. For other available commands and options, see the &lt;a href=&quot;../reference/commandline/docker/index&quot;&gt;command line reference&lt;/a&gt;.</source>
          <target state="translated">플러그인을 비활성화하려면 &lt;code&gt;docker plugin disable&lt;/code&gt; 명령을 사용하십시오 . 완전히 제거하려면 &lt;code&gt;docker plugin remove&lt;/code&gt; 명령을 사용하십시오 . 사용 가능한 다른 명령 및 옵션에 대해서는 &lt;a href=&quot;../reference/commandline/docker/index&quot;&gt;명령 행 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e8eb0b689ebf4f3572eb25ab95a7b6c508a9ccd" translate="yes" xml:space="preserve">
          <source>To disable any default healthcheck set by the image, you can use &lt;code&gt;disable: true&lt;/code&gt;. This is equivalent to specifying &lt;code&gt;test: [&quot;NONE&quot;]&lt;/code&gt;.</source>
          <target state="translated">이미지가 설정 한 기본 상태 확인을 비활성화하려면 disable &lt;code&gt;disable: true&lt;/code&gt; 사용할 수 있습니다 . 이것은 &lt;code&gt;test: [&quot;NONE&quot;]&lt;/code&gt; 지정과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8310c7921d11735aa50c8a14a806a49ff484b86b" translate="yes" xml:space="preserve">
          <source>To disable autolock, set &lt;code&gt;--autolock&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. The mutual TLS key and the encryption key used to read and write Raft logs are stored unencrypted on disk. There is a trade-off between the risk of storing the encryption key unencrypted at rest and the convenience of restarting a swarm without needing to unlock each manager.</source>
          <target state="translated">자동 잠금을 비활성화하려면 &lt;code&gt;--autolock&lt;/code&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . Raft 로그를 읽고 쓰는 데 사용되는 상호 TLS 키와 암호화 키는 디스크에 암호화되지 않은 상태로 저장됩니다. 휴지 상태에서 암호화되지 않은 암호화 키를 저장하는 위험과 각 관리자의 잠금을 해제하지 않고 웜을 다시 시작하는 편리함 사이에는 상충 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b51d2df44006324e9c7fa3983fe68f4df788cb" translate="yes" xml:space="preserve">
          <source>To disable the plugin, use the following command:</source>
          <target state="translated">플러그인을 비활성화하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="30ac867c70ca22666bcabaf1147b500fba7e5668" translate="yes" xml:space="preserve">
          <source>To disable the security labeling for this container versus running with the &lt;code&gt;--privileged&lt;/code&gt; flag, use the following command:</source>
          <target state="translated">이 컨테이너에 대한 보안 레이블링을 비활성화하고 &lt;code&gt;--privileged&lt;/code&gt; 플래그로 실행 하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="899b15f0bea2b907fc0f55369c476f8e0036d494" translate="yes" xml:space="preserve">
          <source>To disable user namespaces for a specific container, add the &lt;code&gt;--userns=host&lt;/code&gt; flag to the &lt;code&gt;docker container create&lt;/code&gt;, &lt;code&gt;docker container run&lt;/code&gt;, or &lt;code&gt;docker container exec&lt;/code&gt; command.</source>
          <target state="translated">특정 컨테이너에 대한 사용자 네임 스페이스를 비활성화하려면 &lt;code&gt;--userns=host&lt;/code&gt; 플래그를 &lt;code&gt;docker container create&lt;/code&gt; , &lt;code&gt;docker container run&lt;/code&gt; 또는 &lt;code&gt;docker container exec&lt;/code&gt; 명령에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fe74bc53cef1c8651074ba7b064f82c49da093f6" translate="yes" xml:space="preserve">
          <source>To disconnect a running service from a network, use the &lt;code&gt;--network-rm&lt;/code&gt; flag.</source>
          <target state="translated">네트워크에서 실행중인 서비스를 연결 해제하려면 &lt;code&gt;--network-rm&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="910bb30824662c7c6ff17aa18539838b47e4d216" translate="yes" xml:space="preserve">
          <source>To do input/output with a detached container use network connections or shared volumes. These are required because the container is no longer listening to the command line where &lt;code&gt;docker run&lt;/code&gt; was run.</source>
          <target state="translated">분리 된 컨테이너로 입 / 출력을 수행하려면 네트워크 연결 또는 공유 볼륨을 사용하십시오. 컨테이너가 더 이상 &lt;code&gt;docker run&lt;/code&gt; 이 실행 된 명령 줄을 수신하지 않기 때문에 필수 입니다.</target>
        </trans-unit>
        <trans-unit id="ccbea93a8509d49173795d375ca3faed2f1e3b34" translate="yes" xml:space="preserve">
          <source>To download a particular image, or set of images (i.e., a repository), use &lt;code&gt;docker pull&lt;/code&gt;.</source>
          <target state="translated">특정 이미지 또는 이미지 세트 (예 : 저장소)를 다운로드하려면 &lt;code&gt;docker pull&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a664a7ba94302c3162ea98c88d4a678db5efafad" translate="yes" xml:space="preserve">
          <source>To download a particular image, or set of images (i.e., a repository), use &lt;code&gt;docker pull&lt;/code&gt;. If no tag is provided, Docker Engine uses the &lt;code&gt;:latest&lt;/code&gt; tag as a default. This command pulls the &lt;code&gt;debian:latest&lt;/code&gt; image:</source>
          <target state="translated">특정 이미지 또는 이미지 세트 (예 : 저장소)를 다운로드하려면 &lt;code&gt;docker pull&lt;/code&gt; 을 사용하십시오 . 태그가 제공되지 않으면 Docker Engine은 &lt;code&gt;:latest&lt;/code&gt; 태그를 기본값으로 사용합니다. 이 명령은 &lt;code&gt;debian:latest&lt;/code&gt; 이미지를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="2251cf9907c4c021b5ee4b838a72c9c2da86b48e" translate="yes" xml:space="preserve">
          <source>To ease plugins development, we&amp;rsquo;re providing an &lt;code&gt;sdk&lt;/code&gt; for each kind of plugins currently supported by Docker at &lt;a href=&quot;https://github.com/docker/go-plugins-helpers&quot;&gt;docker/go-plugins-helpers&lt;/a&gt;.</source>
          <target state="translated">플러그인 개발을 용이하게하기 위해 Docker &lt;a href=&quot;https://github.com/docker/go-plugins-helpers&quot;&gt;/ go-plugins-helpers&lt;/a&gt; 에서 Docker가 현재 지원하는 각 종류의 플러그인에 대한 &lt;code&gt;sdk&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f6cf38a8a5291c1fcf37e9a8792dd4da6509eca8" translate="yes" xml:space="preserve">
          <source>To enable and configure the authorization plugin, the plugin developer must support the Docker client interactions detailed in this section.</source>
          <target state="translated">인증 플러그인을 활성화하고 구성하려면 플러그인 개발자가이 섹션에 자세히 설명 된 Docker 클라이언트 상호 작용을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="39b61fd0182f46dfd2cb5c20593a3ecbbfdf3eee" translate="yes" xml:space="preserve">
          <source>To enable autolock on an existing swarm, set the &lt;code&gt;autolock&lt;/code&gt; flag to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기존 떼에서 자동 잠금을 사용하려면 &lt;code&gt;autolock&lt;/code&gt; 플래그를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d928aeef7618a644c1c99784c8c19ba29c031eb5" translate="yes" xml:space="preserve">
          <source>To enable experimental features from the Docker Desktop menu, click &lt;strong&gt;Settings&lt;/strong&gt; (&lt;strong&gt;Preferences&lt;/strong&gt; on macOS) &amp;gt; &lt;strong&gt;Daemon&lt;/strong&gt; and then select the &lt;strong&gt;Experimental features&lt;/strong&gt; check box.</source>
          <target state="translated">Docker Desktop 메뉴에서 실험 기능을 활성화하려면 &lt;strong&gt;설정&lt;/strong&gt; ( macOS의 &lt;strong&gt;기본 설정&lt;/strong&gt; )&amp;gt; &lt;strong&gt;데몬&lt;/strong&gt; 을 클릭 한 다음 &lt;strong&gt;실험 기능&lt;/strong&gt; 확인란 을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="1614abd778219825008b1ed50f2f41fdd0cef48b" translate="yes" xml:space="preserve">
          <source>To enable experimental features in the Docker CLI, edit the &lt;code&gt;config.json&lt;/code&gt; file and set &lt;code&gt;experimental&lt;/code&gt; to enabled.</source>
          <target state="translated">Docker CLI에서 실험 기능을 사용하려면 &lt;code&gt;config.json&lt;/code&gt; 파일을 편집하고 &lt;code&gt;experimental&lt;/code&gt; 을 사용으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c7820f6182c605851ad74f456a9c40b396b36c4c" translate="yes" xml:space="preserve">
          <source>To enable experimental mode, users need to restart the docker daemon with the experimental flag enabled.</source>
          <target state="translated">실험 모드를 활성화하려면 실험 플래그가 활성화 된 상태에서 docker 데몬을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="7f4b1a290cdc84e10cf5a7492d3db2be1fc13a78" translate="yes" xml:space="preserve">
          <source>To enable the &lt;code&gt;docker-machine&lt;/code&gt; shell prompt, add &lt;code&gt;$(__docker_machine_ps1)&lt;/code&gt; to your &lt;code&gt;PS1&lt;/code&gt; setting in &lt;code&gt;~/.bashrc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker-machine&lt;/code&gt; 셸 프롬프트 를 활성화하려면 &lt;code&gt;~/.bashrc&lt;/code&gt; 의 &lt;code&gt;PS1&lt;/code&gt; 설정에 &lt;code&gt;$(__docker_machine_ps1)&lt;/code&gt; 을 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="77ea5095314020531dd1edca23499b4f23b70dfb" translate="yes" xml:space="preserve">
          <source>To enable the plugin, use the following command:</source>
          <target state="translated">플러그인을 사용하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e027fc141f47db0b030fc5dad8a24c03c19604f" translate="yes" xml:space="preserve">
          <source>To enable this feature, trustpinning can be configured in &lt;code&gt;daemon.json&lt;/code&gt;, whereby only repositories signed with a user-specified root key can be pulled and run.</source>
          <target state="translated">이 기능을 활성화하기 위해 daemon.json에서 &lt;code&gt;daemon.json&lt;/code&gt; 구성 할 수 있으며 , 사용자 지정 루트 키로 서명 된 저장소 만 가져 와서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a27d5dc8bbcd4c8c0e5a0311c991bd28a42ad3d" translate="yes" xml:space="preserve">
          <source>To ensure that the Docker client is automatically configured at the start of each shell session, you can embed &lt;code&gt;eval $(docker-machine env default)&lt;/code&gt; in your shell profiles, by adding it to the &lt;code&gt;~/.bash_profile&lt;/code&gt; file or the equivalent configuration file for your shell. However, this fails if a machine called &lt;code&gt;default&lt;/code&gt; is not running. You can configure your system to start the &lt;code&gt;default&lt;/code&gt; machine automatically. The following example shows how to do this in macOS.</source>
          <target state="translated">Docker 클라이언트가 각 셸 세션이 시작될 때 자동으로 구성 되도록하려면 &lt;code&gt;~/.bash_profile&lt;/code&gt; 파일 또는 이에 해당하는 구성 파일 에 추가하여 &lt;code&gt;eval $(docker-machine env default)&lt;/code&gt; 을 쉘 프로파일에 포함시킬 수 있습니다. 당신의 껍질. 그러나 &lt;code&gt;default&lt;/code&gt; 라는 머신 이 실행 중이 아니면 실패합니다 . &lt;code&gt;default&lt;/code&gt; 시스템을 자동으로 시작하도록 시스템을 구성 할 수 있습니다 . 다음 예제는 macOS에서이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9023ec9a32794038f1c2b95f571735b1263d7b01" translate="yes" xml:space="preserve">
          <source>To examine the result further, you can use &lt;code&gt;docker exec&lt;/code&gt;:</source>
          <target state="translated">결과를 자세히 조사하려면 &lt;code&gt;docker exec&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d6b9a117dcb9512febd78a9746228288594322c" translate="yes" xml:space="preserve">
          <source>To exit the &lt;code&gt;docker events&lt;/code&gt; command, use &lt;code&gt;CTRL+C&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker events&lt;/code&gt; 명령 을 종료하려면 &lt;code&gt;CTRL+C&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f22dabfc1bfe491ee4e13158953715516e100bb3" translate="yes" xml:space="preserve">
          <source>To exit the &lt;code&gt;docker system events&lt;/code&gt; command, use &lt;code&gt;CTRL+C&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker system events&lt;/code&gt; 명령 을 종료하려면 &lt;code&gt;CTRL+C&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="95997b950cd6dce12e07a227c0953d918f91114c" translate="yes" xml:space="preserve">
          <source>To expose a container&amp;rsquo;s internal port, an operator can start the container with the &lt;code&gt;-P&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; flag. The exposed port is accessible on the host and the ports are available to any client that can reach the host.</source>
          <target state="translated">컨테이너의 내부 포트를 노출하기 위해 운영자는 &lt;code&gt;-P&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 플래그를 사용 하여 컨테이너를 시작할 수 있습니다 . 노출 된 포트는 호스트에서 액세스 할 수 있으며 포트는 호스트에 도달 할 수있는 모든 클라이언트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c5a74ccdb773699208bbe3dc1f2f893c4a4ec92" translate="yes" xml:space="preserve">
          <source>To expose an inbound port to the new machine, use the flag, &lt;code&gt;--amazonec2-open-port&lt;/code&gt;:</source>
          <target state="translated">인바운드 포트를 새 시스템에 노출 시키려면 &lt;code&gt;--amazonec2-open-port&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e699565757ae1248974af66e4a4d298f8b2892fa" translate="yes" xml:space="preserve">
          <source>To expose on both TCP and UDP, include two lines:</source>
          <target state="translated">TCP와 UDP 모두에 노출 시키려면 다음 두 줄을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="1e33664e9060aad68f09cdab1f832fb4daba2b3c" translate="yes" xml:space="preserve">
          <source>To filter for &lt;code&gt;paused&lt;/code&gt; containers:</source>
          <target state="translated">&lt;code&gt;paused&lt;/code&gt; 된 컨테이너 를 필터링하려면</target>
        </trans-unit>
        <trans-unit id="de6fe1b7e044de15c7ff64f065c1308b5b444b02" translate="yes" xml:space="preserve">
          <source>To find the VPC ID:</source>
          <target state="translated">VPC ID를 찾으려면</target>
        </trans-unit>
        <trans-unit id="95f976d5ee5b5be4180ab180479960fcdce3f692" translate="yes" xml:space="preserve">
          <source>To fix this problem, try the following:</source>
          <target state="translated">이 문제를 해결하려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="4c34b0ef08315da08272edc5631e4dc513fd9529" translate="yes" xml:space="preserve">
          <source>To generate your access token:</source>
          <target state="translated">액세스 토큰을 생성하려면</target>
        </trans-unit>
        <trans-unit id="6ce2cea60f58c4ddf95724b2226670e92092de14" translate="yes" xml:space="preserve">
          <source>To get started using &lt;code&gt;docker-machine&lt;/code&gt; commands, see these topics:</source>
          <target state="translated">&lt;code&gt;docker-machine&lt;/code&gt; 명령을 사용하려면 다음 주제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69327c8806f41c421ac0cb9257fe7b47f4cd9878" translate="yes" xml:space="preserve">
          <source>To get the &lt;code&gt;redis&lt;/code&gt; service working, you need to &lt;code&gt;ssh&lt;/code&gt; into the cloud server where the &lt;code&gt;manager&lt;/code&gt; is running, and make a &lt;code&gt;data/&lt;/code&gt; directory in &lt;code&gt;/home/docker/&lt;/code&gt; before you run &lt;code&gt;docker stack deploy&lt;/code&gt;. Another option is to change the data path in the &lt;code&gt;docker-stack.yml&lt;/code&gt; to a pre-existing path on the &lt;code&gt;manager&lt;/code&gt; server. This example does not include this step, so the &lt;code&gt;redis&lt;/code&gt; service is not up in the example output.</source>
          <target state="translated">얻으려면 &lt;code&gt;redis&lt;/code&gt; 서비스 작업을, 당신은 필요 &lt;code&gt;ssh&lt;/code&gt; 를 하여 클라우드 서버에 &lt;code&gt;manager&lt;/code&gt; 실행 및 만들 &lt;code&gt;data/&lt;/code&gt; 에 디렉토리를 &lt;code&gt;/home/docker/&lt;/code&gt; 당신이 실행하기 전에 &lt;code&gt;docker stack deploy&lt;/code&gt; . 다른 옵션은 &lt;code&gt;docker-stack.yml&lt;/code&gt; 의 데이터 경로를 &lt;code&gt;manager&lt;/code&gt; 서버의 기존 경로로 변경하는 것 입니다. 이 예제에는이 단계가 포함되어 있지 않으므로 &lt;code&gt;redis&lt;/code&gt; 서비스가 예제 출력에 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a79265649a0667bda4042b4e11c178182002103" translate="yes" xml:space="preserve">
          <source>To get your Debian-based containers to use the proxy, you have following options. Replace &lt;code&gt;dockerhost&lt;/code&gt; with the IP address or FQDN of the host running the &lt;code&gt;test_apt_cacher_ng&lt;/code&gt; container.</source>
          <target state="translated">데비안 기반 컨테이너가 프록시를 사용하도록하려면 다음 옵션이 있습니다. 교체 &lt;code&gt;dockerhost&lt;/code&gt; 실행중인 호스트의 IP 주소 또는 FQDN으로 &lt;code&gt;test_apt_cacher_ng&lt;/code&gt; 의 컨테이너를.</target>
        </trans-unit>
        <trans-unit id="5859b60c795bafa987e7a219c6424a9d0d1ac4ee" translate="yes" xml:space="preserve">
          <source>To give a container access to a volume, use the &lt;code&gt;--volume&lt;/code&gt; and &lt;code&gt;--volume-driver&lt;/code&gt; flags on the &lt;code&gt;docker container run&lt;/code&gt; command. The &lt;code&gt;--volume&lt;/code&gt; (or &lt;code&gt;-v&lt;/code&gt;) flag accepts a volume name and path on the host, and the &lt;code&gt;--volume-driver&lt;/code&gt; flag accepts a driver type.</source>
          <target state="translated">컨테이너에 볼륨에 대한 액세스 권한을 부여하려면 &lt;code&gt;docker container run&lt;/code&gt; 명령 에서 &lt;code&gt;--volume&lt;/code&gt; 및 &lt;code&gt;--volume-driver&lt;/code&gt; 플래그를 사용하십시오 . &lt;code&gt;--volume&lt;/code&gt; 는 (또는 &lt;code&gt;-v&lt;/code&gt; ) 플래그는 호스트의 볼륨 이름과 경로를 수용하고 &lt;code&gt;--volume-driver&lt;/code&gt; 플래그는 드라이버 입력을 받아 들인다.</target>
        </trans-unit>
        <trans-unit id="a10fd3a6da1929faa2b711ea2846a711fc244ed8" translate="yes" xml:space="preserve">
          <source>To grant a service access to multiple secrets, use multiple &lt;code&gt;--secret&lt;/code&gt; flags.</source>
          <target state="translated">여러 비밀에 서비스 액세스 권한을 부여하려면 여러 &lt;code&gt;--secret&lt;/code&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="563529a7c1b8188fd224d942eaf30ab899832ab3" translate="yes" xml:space="preserve">
          <source>To handle this, design your application to attempt to re-establish a connection to the database after a failure. If the application retries the connection, it can eventually connect to the database.</source>
          <target state="translated">이를 처리하려면 실패 후 데이터베이스에 대한 연결을 다시 설정하도록 응용 프로그램을 설계하십시오. 응용 프로그램이 연결을 재 시도하면 결국 데이터베이스에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9136328d2e85500400ae5e1770a292b90be3b3b3" translate="yes" xml:space="preserve">
          <source>To help &lt;code&gt;docker-machine&lt;/code&gt; be as stable as possible, we added a monitoring of crashes whenever you try to &lt;code&gt;create&lt;/code&gt; or &lt;code&gt;upgrade&lt;/code&gt; a host. This sends, over HTTPS, to Bugsnag some information about your &lt;code&gt;docker-machine&lt;/code&gt; version, build, OS, ARCH, the path to your current shell and, the history of the last command as you could see it with a &lt;code&gt;--debug&lt;/code&gt; option. This data is sent to help us pinpoint recurring issues with &lt;code&gt;docker-machine&lt;/code&gt; and is only transmitted in the case of a crash of &lt;code&gt;docker-machine&lt;/code&gt;.</source>
          <target state="translated">도움말에 &lt;code&gt;docker-machine&lt;/code&gt; 당신이하려고 할 때마다 최대한 안정적으로, 우리는 충돌의 모니터링을 추가 할 수 &lt;code&gt;create&lt;/code&gt; 거나 &lt;code&gt;upgrade&lt;/code&gt; 호스트. 이것은 HTTPS를 통해 &lt;code&gt;docker-machine&lt;/code&gt; 버전, 빌드, OS, ARCH, 현재 쉘의 경로 및 &lt;code&gt;--debug&lt;/code&gt; 옵션으로 볼 수있는 마지막 명령의 기록에 대한 정보를 Bugsnag에 보냅니다 . 이 데이터는 우리와 함께 반복되는 문제를 파악하기 위해 전송되는 &lt;code&gt;docker-machine&lt;/code&gt; 만의 충돌의 경우에 전송되는 &lt;code&gt;docker-machine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f7349657daca1bb2b896f028693f2581fedc317" translate="yes" xml:space="preserve">
          <source>To help debug failing probes, any output text (UTF-8 encoded) that the command writes on stdout or stderr will be stored in the health status and can be queried with &lt;code&gt;docker inspect&lt;/code&gt;. Such output should be kept short (only the first 4096 bytes are stored currently).</source>
          <target state="translated">실패한 프로브를 디버그하기 위해 명령이 stdout 또는 stderr에 작성하는 모든 출력 텍스트 (UTF-8 인코딩)는 상태에 저장되며 &lt;code&gt;docker inspect&lt;/code&gt; 로 쿼리 할 수 ​​있습니다 . 이러한 출력은 짧게 유지해야합니다 (처음 4096 바이트 만 현재 저장 됨).</target>
        </trans-unit>
        <trans-unit id="68ef801fbfc2c68a0daa18d9df2256813a32e9f7" translate="yes" xml:space="preserve">
          <source>To increase availability, you can run multiple instances of both the server and signer applications. These can scale arbitrarily and independently. The database can also scale independently but this is left as an exercise for experienced DBAs and Operations teams. A typical deployment looks like this:</source>
          <target state="translated">가용성을 높이기 위해 서버 및 서명자 응용 프로그램의 여러 인스턴스를 실행할 수 있습니다. 이들은 임의로 독립적으로 확장 할 수 있습니다. 또한 데이터베이스는 독립적으로 확장 할 수 있지만 숙련 된 DBA 및 운영 팀에게는 연습으로 남아 있습니다. 일반적인 배포는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0991d1e7e9bbc984a493a51125622d7dbef598ff" translate="yes" xml:space="preserve">
          <source>To increase logging level</source>
          <target state="translated">로깅 수준을 높이려면</target>
        </trans-unit>
        <trans-unit id="e0c0ef73103c30963d052d4a2b71fdaaf990f70b" translate="yes" xml:space="preserve">
          <source>To install a different version of Compose, substitute &lt;code&gt;1.24.1&lt;/code&gt; with the version of Compose you want to use.</source>
          <target state="translated">다른 버전의 Compose를 설치하려면 사용하려는 Compose 버전으로 &lt;code&gt;1.24.1&lt;/code&gt; 을 대체 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8174e853bc8feb36611082e07e6df1f11cc1a6fc" translate="yes" xml:space="preserve">
          <source>To install a plugin, use the &lt;code&gt;docker plugin install&lt;/code&gt; command, which pulls the plugin from Docker Hub or your private registry, prompts you to grant permissions or capabilities if necessary, and enables the plugin.</source>
          <target state="translated">플러그인을 설치하려면 &lt;code&gt;docker plugin install&lt;/code&gt; 명령을 사용하십시오.이 명령은 Docker Hub 또는 개인 레지스트리에서 플러그인을 가져오고 필요한 경우 권한 또는 기능을 부여하라는 프롬프트를 표시하고 플러그인을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="7bc17e0c179b06ce6fd6951e968ab53d5b4e5ed8" translate="yes" xml:space="preserve">
          <source>To interact with the Docker maintainers and other interested users, see the IRC channel &lt;code&gt;#docker-network&lt;/code&gt;.</source>
          <target state="translated">Docker 관리자 및 기타 관심있는 사용자와 상호 작용하려면 IRC 채널 &lt;code&gt;#docker-network&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25442a6f7db3850b08b6c0723b0934a05ebe1d94" translate="yes" xml:space="preserve">
          <source>To know the digest of an image, pull the image first. Let&amp;rsquo;s pull the latest &lt;code&gt;ubuntu:14.04&lt;/code&gt; image from Docker Hub:</source>
          <target state="translated">이미지의 요약을 보려면 먼저 이미지를 당기십시오. Docker Hub에서 최신 &lt;code&gt;ubuntu:14.04&lt;/code&gt; 이미지를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d033d7d6355c48d5b6ea18e018e8993485f3f4f2" translate="yes" xml:space="preserve">
          <source>To learn about Docker in more detail and to answer questions about usage and implementation, check out the &lt;a href=&quot;https://docs.docker.com/config/daemon&quot;&gt;Docker User Guide&lt;/a&gt;.</source>
          <target state="translated">Docker에 대한 자세한 내용을보고 사용법 및 구현에 대한 질문에 대답하려면 &lt;a href=&quot;https://docs.docker.com/config/daemon&quot;&gt;Docker 사용 설명서를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="c85636a1b96b43fe9e6e59ad0fe20d8b0ee8601a" translate="yes" xml:space="preserve">
          <source>To learn about the experimental Dockerfile syntax available to BuildKit-based builds &lt;a href=&quot;https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental/&quot;&gt;refer to the documentation in the BuildKit repository&lt;/a&gt;.</source>
          <target state="translated">BuildKit 기반 빌드에 사용 가능한 실험용 Dockerfile 구문에 대해 배우려면 &lt;a href=&quot;https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental/&quot;&gt;BuildKit 저장소의 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd41cee80b5790b5613c3f58616433ce9272f9de" translate="yes" xml:space="preserve">
          <source>To learn how to interpret the types of &lt;code&gt;[OPTIONS]&lt;/code&gt;, see &lt;a href=&quot;../commandline/cli/index#option-types&quot;&gt;&lt;em&gt;Option types&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;[OPTIONS]&lt;/code&gt; 유형을 해석하는 방법을 배우려면 &lt;a href=&quot;../commandline/cli/index#option-types&quot;&gt;&lt;em&gt;옵션 유형을&lt;/em&gt;&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85fe3108fc962c876f5c1a0ebe06376e7e927bde" translate="yes" xml:space="preserve">
          <source>To learn more about service discovery and networking in swarm mode, see &lt;a href=&quot;https://docs.docker.com/network#configure-service-discovery&quot;&gt;Configure service discovery&lt;/a&gt; in the swarm mode topics.</source>
          <target state="translated">스웜 모드에서의 서비스 검색 및 네트워킹에 대한 자세한 내용은 스웜 모드 항목에서 &lt;a href=&quot;https://docs.docker.com/network#configure-service-discovery&quot;&gt;서비스 검색 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3f55044016b1dde1f9e1879192440f6cc13de3c" translate="yes" xml:space="preserve">
          <source>To learn more about volumes and bind mounts, see &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;Manage data in Docker&lt;/a&gt;</source>
          <target state="translated">볼륨 및 바인드 마운트에 대한 자세한 내용은 &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;Docker에서 데이터 관리를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="9f504c0fa5a9d673fc95334893fe168e9d7b1ca6" translate="yes" xml:space="preserve">
          <source>To limit a container&amp;rsquo;s cpu-shares to 512, first identify the container name or ID. You can use &lt;code&gt;docker ps&lt;/code&gt; to find these values. You can also use the ID returned from the &lt;code&gt;docker run&lt;/code&gt; command. Then, do the following:</source>
          <target state="translated">컨테이너의 CPU 공유를 512로 제한하려면 먼저 컨테이너 이름 또는 ID를 식별하십시오. &lt;code&gt;docker ps&lt;/code&gt; 를 사용 하여 이러한 값을 찾을 수 있습니다. &lt;code&gt;docker run&lt;/code&gt; 명령 에서 반환 된 ID를 사용할 수도 있습니다 . 그런 다음 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cc0a5f793244f6e2ed87e967871f31b5cf638dd8" translate="yes" xml:space="preserve">
          <source>To list all containers statistics with their name, CPU percentage and memory usage in a table format you can use:</source>
          <target state="translated">이름, CPU 백분율 및 메모리 사용량과 함께 모든 컨테이너 통계를 테이블 형식으로 나열하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b8abe7f52782cdc6a9e4b18adb41f4eaf63943e" translate="yes" xml:space="preserve">
          <source>To list all images with their repository and tag in a table format you can use:</source>
          <target state="translated">저장소 및 태그가있는 모든 이미지를 표 형식으로 나열하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db025649d5d56c863b8f28e498f82eac4161a3a8" translate="yes" xml:space="preserve">
          <source>To list all machine names with their driver in a table format you can use:</source>
          <target state="translated">드라이버와 함께 모든 시스템 이름을 테이블 형식으로 나열하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0e8f4c5e182d8d2838813b839da7dfcafe5542" translate="yes" xml:space="preserve">
          <source>To list all running containers with their labels in a table format you can use:</source>
          <target state="translated">레이블이있는 모든 실행 컨테이너를 테이블 형식으로 나열하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0fd874c7327d94c944f1ce691024636a1d42d43" translate="yes" xml:space="preserve">
          <source>To list all secrets with their name and created date in a table format you can use:</source>
          <target state="translated">이름과 만든 날짜와 함께 모든 비밀을 테이블 형식으로 나열하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="520df76a65d11bad10b0185fd21e935c317042e9" translate="yes" xml:space="preserve">
          <source>To list available commands, either run &lt;code&gt;docker&lt;/code&gt; with no parameters or execute &lt;code&gt;docker help&lt;/code&gt;:</source>
          <target state="translated">사용 가능한 명령을 나열하려면 매개 변수없이 &lt;code&gt;docker&lt;/code&gt; 를 실행하거나 &lt;code&gt;docker help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3d619adfbc1a976caaca0e1086f05b555853410" translate="yes" xml:space="preserve">
          <source>To list the help on any command just execute the command, followed by the &lt;code&gt;--help&lt;/code&gt; option.</source>
          <target state="translated">명령에 대한 도움말을 나열하려면 명령을 실행 한 다음 &lt;code&gt;--help&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="100731d57f6e16d4fafeee9ecf576152333db304" translate="yes" xml:space="preserve">
          <source>To list the keys that have been imported in to the local Docker trust store we can use the Notary CLI.</source>
          <target state="translated">로컬 Docker 신뢰 저장소로 가져온 키를 나열하기 위해 Notary CLI를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80912436fd2e8ebcb77789f76a43c2a7abeff758" translate="yes" xml:space="preserve">
          <source>To load a new profile into AppArmor for use with containers:</source>
          <target state="translated">컨테이너와 함께 사용할 새 프로파일을 AppArmor에로드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ed034cf6b8948864db4f34d65e88927e32650f88" translate="yes" xml:space="preserve">
          <source>To login, just run &lt;code&gt;docker-machine ssh machinename&lt;/code&gt;:</source>
          <target state="translated">로그인하려면 &lt;code&gt;docker-machine ssh machinename&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="44ea57bccb8cab29a8a5eaf6953f438088eda258" translate="yes" xml:space="preserve">
          <source>To make tagging consistent across the various &lt;code&gt;docker&lt;/code&gt; commands, the &lt;code&gt;-f&lt;/code&gt; flag on the &lt;code&gt;docker tag&lt;/code&gt; command is deprecated. It is not longer necessary to specify &lt;code&gt;-f&lt;/code&gt; to move a tag from one image to another. Nor will &lt;code&gt;docker&lt;/code&gt; generate an error if the &lt;code&gt;-f&lt;/code&gt; flag is missing and the specified tag is already in use.</source>
          <target state="translated">다양한 &lt;code&gt;docker&lt;/code&gt; 명령에서 일관된 태깅을 수행하기 위해 &lt;code&gt;docker tag&lt;/code&gt; 명령 의 &lt;code&gt;-f&lt;/code&gt; 플래그 가 더 이상 사용되지 않습니다. 한 이미지에서 다른 이미지로 태그를 이동 하기 위해 더 이상 &lt;code&gt;-f&lt;/code&gt; 를 지정할 필요가 없습니다 . 도 아니다 것 &lt;code&gt;docker&lt;/code&gt; 경우 오류가 발생 &lt;code&gt;-f&lt;/code&gt; 플래그가 누락하고 지정된 태그가 이미 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="ba00cf159c6077cd447bca1082b000e5ce912245" translate="yes" xml:space="preserve">
          <source>To make the key suitable for client authentication, create a new extensions config file:</source>
          <target state="translated">키를 클라이언트 인증에 적합하게하려면 새 확장 구성 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="146247a2638b73795ca06a22169edde76480ec9e" translate="yes" xml:space="preserve">
          <source>To make this more efficient, one of two mechanisms can be employed. One is to use the JSON form of the RUN command such as:</source>
          <target state="translated">이를보다 효율적으로 만들기 위해 두 가지 메커니즘 중 하나를 사용할 수 있습니다. 하나는 다음과 같은 JSON 형식의 RUN 명령을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f86f720ccbc40b3c6f9257366fc85700341eb0b" translate="yes" xml:space="preserve">
          <source>To make your build context as small as possible add a &lt;a href=&quot;../../reference/builder/index#dockerignore-file&quot;&gt;&lt;code&gt;.dockerignore&lt;/code&gt; file&lt;/a&gt; to your project folder and copy the following into it.</source>
          <target state="translated">빌드 컨텍스트를 최대한 작게하려면 &lt;a href=&quot;../../reference/builder/index#dockerignore-file&quot;&gt; &lt;code&gt;.dockerignore&lt;/code&gt; 파일&lt;/a&gt; 을 프로젝트 폴더에 추가 하고 다음을 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="d9d8d9ad611022b2d90ae12f8807fbc7f2bfab90" translate="yes" xml:space="preserve">
          <source>To modify the proportion from the default of 1024, use the &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cpu-shares&lt;/code&gt; flag to set the weighting to 2 or higher. If 0 is set, the system will ignore the value and use the default of 1024.</source>
          <target state="translated">기본값 1024에서 비율을 수정하려면 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;--cpu-shares&lt;/code&gt; 플래그를 사용하여 가중치를 2 이상으로 설정하십시오. 0이 설정되면 시스템은 값을 무시하고 기본값 인 1024를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0f0f4484d9913e84d631f88e253ec609e413507d" translate="yes" xml:space="preserve">
          <source>To mount a FUSE based filesystem, you need to combine both &lt;code&gt;--cap-add&lt;/code&gt; and &lt;code&gt;--device&lt;/code&gt;:</source>
          <target state="translated">FUSE 기반 파일 시스템을 마운트하려면 &lt;code&gt;--cap-add&lt;/code&gt; 와 &lt;code&gt;--device&lt;/code&gt; 를 모두 결합해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e044a14bee5e7118d526ba58fea86c82b107d8df" translate="yes" xml:space="preserve">
          <source>To mount a read-only bind:</source>
          <target state="translated">읽기 전용 바인드를 마운트하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d397a01a0e65c0ef85c3e2c5fdbec3c469af901a" translate="yes" xml:space="preserve">
          <source>To mount a read-write bind:</source>
          <target state="translated">읽기-쓰기 바인드를 마운트하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="caf5a70446923400bf2aa594f7c5afb6601d8c47" translate="yes" xml:space="preserve">
          <source>To move your project to a later version, see the &lt;a href=&quot;#upgrading&quot;&gt;Upgrading&lt;/a&gt; section.</source>
          <target state="translated">프로젝트를 이후 버전으로 이동하려면 &lt;a href=&quot;#upgrading&quot;&gt;업그레이드&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfee1ff6d4e73f0aacaa865f3f5223623976a3a7" translate="yes" xml:space="preserve">
          <source>To obtain a family URL, replace &lt;code&gt;&amp;lt;PROJECT&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;FAMILY&amp;gt;&lt;/code&gt; in the following template.</source>
          <target state="translated">제품군 URL을 얻으려면 다음 템플릿에서 &lt;code&gt;&amp;lt;PROJECT&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;FAMILY&amp;gt;&lt;/code&gt; 를 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="b1bc439211ee52dd379c6b93b051b69200315ffc" translate="yes" xml:space="preserve">
          <source>To opt out of error reporting, create a &lt;code&gt;no-error-report&lt;/code&gt; file in your &lt;code&gt;$HOME/.docker/machine&lt;/code&gt; directory:</source>
          <target state="translated">오류보고를 거부하려면 &lt;code&gt;$HOME/.docker/machine&lt;/code&gt; 디렉토리에 &lt;code&gt;no-error-report&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="411473a0ae942433392bdba5342be3c54e626c83" translate="yes" xml:space="preserve">
          <source>To override the sequence for an individual container, use the &lt;code&gt;--detach-keys=&quot;&amp;lt;sequence&amp;gt;&quot;&lt;/code&gt; flag with the &lt;code&gt;docker attach&lt;/code&gt; command. The format of the &lt;code&gt;&amp;lt;sequence&amp;gt;&lt;/code&gt; is either a letter [a-Z], or the &lt;code&gt;ctrl-&lt;/code&gt; combined with any of the following:</source>
          <target state="translated">개별 컨테이너의 시퀀스를 재정의하려면 &lt;code&gt;docker attach&lt;/code&gt; 명령 과 함께 &lt;code&gt;--detach-keys=&quot;&amp;lt;sequence&amp;gt;&quot;&lt;/code&gt; 플래그를 사용하십시오 . &lt;code&gt;&amp;lt;sequence&amp;gt;&lt;/code&gt; 의 형식은 문자 [aZ]이거나 다음 중 하나와 함께 &lt;code&gt;ctrl-&lt;/code&gt; 조합입니다.</target>
        </trans-unit>
        <trans-unit id="3bc3cb9f8ca6501039bd01f42d3b1c1ec99e8426" translate="yes" xml:space="preserve">
          <source>To override this behavior for specific registries, use the &lt;code&gt;--allow-nondistributable-artifacts&lt;/code&gt; option in one of the following forms:</source>
          <target state="translated">특정 레지스트리에 대해이 동작을 무시하려면 다음 형식 중 하나에서 &lt;code&gt;--allow-nondistributable-artifacts&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e21de091d65933ce5d617490c6ed180d3d87e0d2" translate="yes" xml:space="preserve">
          <source>To prevent the scheduler from placing tasks on a manager node in a multi-node swarm, set the availability for the manager node to &lt;code&gt;Drain&lt;/code&gt;. The scheduler gracefully stops tasks on nodes in &lt;code&gt;Drain&lt;/code&gt; mode and schedules the tasks on an &lt;code&gt;Active&lt;/code&gt; node. The scheduler does not assign new tasks to nodes with &lt;code&gt;Drain&lt;/code&gt; availability.</source>
          <target state="translated">스케줄러가 다중 노드 스웜의 관리자 노드에 태스크를 배치하지 못하게하려면 관리자 노드의 가용성을 &lt;code&gt;Drain&lt;/code&gt; 설정하십시오 . 스케줄러는 &lt;code&gt;Drain&lt;/code&gt; 모드 에서 노드의 작업을 정상적으로 중지 하고 &lt;code&gt;Active&lt;/code&gt; 노드 에서 작업을 예약 합니다. 스케줄러는 &lt;code&gt;Drain&lt;/code&gt; 가용성 이있는 노드에 새 작업을 할당하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9af9374ac27538dab43af37ddda5ce5b1b17bfa0" translate="yes" xml:space="preserve">
          <source>To promote a node or set of nodes, run &lt;code&gt;docker node promote&lt;/code&gt; from a manager node:</source>
          <target state="translated">노드 또는 노드 세트를 승격 시키려면 관리자 노드에서 &lt;code&gt;docker node promote&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="faee2caabc0e115340518180584ae26aec494763" translate="yes" xml:space="preserve">
          <source>To protect your keys from accidental damage, remove their write permissions. To make them only readable by you, change file modes as follows:</source>
          <target state="translated">실수로 키가 손상되지 않도록하려면 쓰기 권한을 제거하십시오. 사용자 만 읽을 수있게하려면 다음과 같이 파일 모드를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="6e64058f0bf352eed38ba919557e5716d1d7d33b" translate="yes" xml:space="preserve">
          <source>To provide a name for your service, use the &lt;code&gt;--name&lt;/code&gt; flag:</source>
          <target state="translated">서비스 이름을 제공하려면 &lt;code&gt;--name&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce30ec76b8549ea23ad3c5c95ddb6478abf11cbc" translate="yes" xml:space="preserve">
          <source>To publish a service&amp;rsquo;s ports externally to the swarm, use the &lt;code&gt;--publish &amp;lt;PUBLISHED-PORT&amp;gt;:&amp;lt;SERVICE-PORT&amp;gt;&lt;/code&gt; flag. The swarm makes the service accessible at the published port &lt;strong&gt;on every swarm node&lt;/strong&gt;. If an external host connects to that port on any swarm node, the routing mesh routes it to a task. The external host does not need to know the IP addresses or internally-used ports of the service tasks to interact with the service. When a user or process connects to a service, any worker node running a service task may respond. For more details about swarm service networking, see &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Manage swarm service networks&lt;/a&gt;.</source>
          <target state="translated">서비스 포트를 &lt;code&gt;--publish &amp;lt;PUBLISHED-PORT&amp;gt;:&amp;lt;SERVICE-PORT&amp;gt;&lt;/code&gt; 외부에 게시하려면 --publish &amp;lt;PUBLISHED-PORT&amp;gt; : &amp;lt;SERVICE-PORT&amp;gt; 플래그를 사용하십시오. swarm은 &lt;strong&gt;모든 swarm 노드&lt;/strong&gt; 의 게시 된 포트에서 서비스에 액세스 할 수 있도록 &lt;strong&gt;합니다&lt;/strong&gt; . 외부 호스트가 임의의 swarm 노드에서 해당 포트에 연결하면 라우팅 메시가 해당 포트를 작업으로 라우팅합니다. 외부 호스트는 서비스와 상호 작용하기 위해 서비스 작업의 IP 주소 또는 내부적으로 사용되는 포트를 알 필요가 없습니다. 사용자 또는 프로세스가 서비스에 연결되면 서비스 작업을 실행하는 작업자 노드가 응답 할 수 있습니다. 스웜 서비스 네트워킹에 대한 자세한 내용은 스웜 서비스 네트워크 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;관리를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfca3199eef8ec450f2791c18c7e2a42585c3248" translate="yes" xml:space="preserve">
          <source>To push an image to a private registry and not the central Docker registry you must tag it with the registry hostname and port (if needed).</source>
          <target state="translated">중앙 Docker 레지스트리가 아닌 개인 레지스트리로 이미지를 푸시하려면 레지스트리 호스트 이름 및 포트 (필요한 경우)로 태그를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f4af00206bd87665e8844f158ca78c647e96fd7" translate="yes" xml:space="preserve">
          <source>To query the status of the node as a worker that accept tasks:</source>
          <target state="translated">태스크를 승인하는 작업자로서 노드의 상태를 조회하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6b5ed40f68551f8888f38af30cec53a9b5d42947" translate="yes" xml:space="preserve">
          <source>To read more about these options and how to configure them, see &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&amp;ldquo;&lt;em&gt;Get started with multi-host network&lt;/em&gt;&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">자세한 옵션과 방법을 구성하는 방법에 대한 읽으려면 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&quot; &lt;em&gt;멀티 호스트 네트워크 시작하기&lt;/em&gt; &quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d14b25dbcff005a42a603b7afbd6b706dcd7b031" translate="yes" xml:space="preserve">
          <source>To reattach to a detached container, use &lt;code&gt;docker&lt;/code&gt;&lt;a href=&quot;../commandline/attach/index&quot;&gt;&lt;em&gt;attach&lt;/em&gt;&lt;/a&gt; command.</source>
          <target state="translated">분리 된 컨테이너에 다시 부착하려면 &lt;code&gt;docker&lt;/code&gt; &lt;a href=&quot;../commandline/attach/index&quot;&gt;&lt;em&gt;attach&lt;/em&gt;&lt;/a&gt; 명령을 사용 &lt;em&gt;하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c29f40237c9e14487a58c35b9c616614d46a2382" translate="yes" xml:space="preserve">
          <source>To recap, while typing &lt;code&gt;docker run&lt;/code&gt; is simple enough, the true implementation of a container in production is running it as a service. Services codify a container&amp;rsquo;s behavior in a Compose file, and this file can be used to scale, limit, and redeploy our app. Changes to the service can be applied in place, as it runs, using the same command that launched the service: &lt;code&gt;docker stack deploy&lt;/code&gt;.</source>
          <target state="translated">요약하면 &lt;code&gt;docker run&lt;/code&gt; 을 입력 하는 것은 간단하지만 프로덕션에서 컨테이너를 실제로 구현하면 서비스로 실행됩니다. 서비스는 작성 파일에서 컨테이너의 동작을 체계화하며이 파일을 사용하여 앱을 확장, 제한 및 재배치 할 수 있습니다. 서비스를 시작한 것과 동일한 명령을 사용하여 서비스 변경 사항을 적절하게 적용 할 수 있습니다 ( &lt;code&gt;docker stack deploy&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="46fdb6bf16d125dc28a5c67538374743497a4ec5" translate="yes" xml:space="preserve">
          <source>To recover from this error, you must create more free space in the thin pool to recover from the error. You can create free space by deleting some images and containers from the thin pool. You can also add more storage to the thin pool.</source>
          <target state="translated">이 오류를 복구하려면 씬 풀에 더 많은 여유 공간을 만들어 오류를 복구해야합니다. 씬 풀에서 일부 이미지와 컨테이너를 삭제하여 여유 공간을 만들 수 있습니다. 씬 풀에 스토리지를 더 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58431c585e29df36a389201040aae84b4725a1ee" translate="yes" xml:space="preserve">
          <source>To remove &lt;code&gt;worker2&lt;/code&gt;, issue the following command from &lt;code&gt;worker2&lt;/code&gt; itself:</source>
          <target state="translated">&lt;code&gt;worker2&lt;/code&gt; 를 제거하려면 &lt;code&gt;worker2&lt;/code&gt; 자체 에서 다음 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="717347d3b9e53d1235e2b49a914c7ec8c3c29c7e" translate="yes" xml:space="preserve">
          <source>To remove a host and all of its containers and images, first stop the machine, then use &lt;code&gt;docker-machine rm&lt;/code&gt;:</source>
          <target state="translated">호스트와 모든 컨테이너와 이미지를 제거하려면 먼저 머신을 중지 한 다음 &lt;code&gt;docker-machine rm&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6ed978a0e2616402cb917d9d43a13b7fef58642" translate="yes" xml:space="preserve">
          <source>To remove a service, use the &lt;code&gt;docker service remove&lt;/code&gt; command. You can remove a service by its ID or name, as shown in the output of the &lt;code&gt;docker service ls&lt;/code&gt; command. The following command removes the &lt;code&gt;my_web&lt;/code&gt; service.</source>
          <target state="translated">서비스를 제거하려면 &lt;code&gt;docker service remove&lt;/code&gt; 명령을 사용하십시오 . &lt;code&gt;docker service ls&lt;/code&gt; 명령 의 출력에 표시된대로 ID 또는 이름으로 서비스를 제거 할 수 있습니다 . 다음 명령은 &lt;code&gt;my_web&lt;/code&gt; 서비스를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="40dd29f11a9d90d20aed5f0407c2ab41bbe23c55" translate="yes" xml:space="preserve">
          <source>To remove all machines: &lt;code&gt;docker-machine rm -f $(docker-machine ls -q)&lt;/code&gt; (you might need to use &lt;code&gt;-force&lt;/code&gt; on Windows).</source>
          <target state="translated">모든 시스템을 제거하려면 &lt;code&gt;docker-machine rm -f $(docker-machine ls -q)&lt;/code&gt; ( Windows에서 &lt;code&gt;-force&lt;/code&gt; 를 사용해야 할 수도 있음 )</target>
        </trans-unit>
        <trans-unit id="98ce6357b9ca06941b6937275d86d115a08ec845" translate="yes" xml:space="preserve">
          <source>To remove an image using its digest:</source>
          <target state="translated">다이제스트를 사용하여 이미지를 제거하려면</target>
        </trans-unit>
        <trans-unit id="64ccd7ba3f4d4e9d893002cbf68cfd773f8ed33c" translate="yes" xml:space="preserve">
          <source>To remove an instance and all of its containers and images, first stop the machine, then use &lt;code&gt;docker-machine rm&lt;/code&gt;.</source>
          <target state="translated">인스턴스와 모든 컨테이너 및 이미지를 제거하려면 먼저 머신을 중지 한 다음 &lt;code&gt;docker-machine rm&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="810ffb9b6cb8dff02fd24d2ff58be8add441735c" translate="yes" xml:space="preserve">
          <source>To remove each machine individually: &lt;code&gt;docker-machine rm &amp;lt;machine-name&amp;gt;&lt;/code&gt;</source>
          <target state="translated">각 시스템을 개별적으로 제거하려면 다음과 같이하십시오. &lt;code&gt;docker-machine rm &amp;lt;machine-name&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8072cd03ac164c076d813a966df1dec8996520c" translate="yes" xml:space="preserve">
          <source>To remove targets, we use the &lt;code&gt;notary remove&lt;/code&gt; command, specifying the GUN and target name.</source>
          <target state="translated">대상을 제거하기 위해 GUN 및 대상 이름을 지정하여 &lt;code&gt;notary remove&lt;/code&gt; 명령을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="997e2cc43df946a2ea185ad244e7895e3fe080e9" translate="yes" xml:space="preserve">
          <source>To remove the network named &amp;lsquo;my-network&amp;rsquo;:</source>
          <target state="translated">'my-network'라는 네트워크를 제거하려면 :</target>
        </trans-unit>
        <trans-unit id="2cdb92c790b440d4c19e5c9b423218c44bac5d49" translate="yes" xml:space="preserve">
          <source>To remove the node from the swarm, run &lt;code&gt;docker node rm &amp;lt;NODE&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">떼에서 노드를 제거하려면 &lt;code&gt;docker node rm &amp;lt;NODE&amp;gt;&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba06f206e50a7586d7abdc4909321b5f004cfddc" translate="yes" xml:space="preserve">
          <source>To remove this target from our delegation, use the &lt;code&gt;notary remove&lt;/code&gt; command with the same flag:</source>
          <target state="translated">위임에서이 대상을 제거하려면 동일한 플래그와 함께 &lt;code&gt;notary remove&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2974e5b647d1f9937dd49138a4a9d4e38f16ceb1" translate="yes" xml:space="preserve">
          <source>To report bugs or file feature requests, use the &lt;a href=&quot;https://github.com/docker/machine/issues&quot;&gt;issue tracker on Github&lt;/a&gt;.</source>
          <target state="translated">버그 또는 파일 기능 요청을보고하려면 &lt;a href=&quot;https://github.com/docker/machine/issues&quot;&gt;Github&lt;/a&gt; 의 이슈 트래커를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="04a7e38317899e3d1114f4a7a189fd735cefe509" translate="yes" xml:space="preserve">
          <source>To report bugs or file feature requests: use the &lt;a href=&quot;https://github.com/docker/compose/issues&quot;&gt;issue tracker on Github&lt;/a&gt;.</source>
          <target state="translated">버그 또는 파일 기능 요청을보고하려면 : &lt;a href=&quot;https://github.com/docker/compose/issues&quot;&gt;Github&lt;/a&gt; 의 이슈 트래커를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="534c8d44800f1497c4b9bd3902958e6c66deae26" translate="yes" xml:space="preserve">
          <source>To reserve a given amount of memory or number of CPUs for a service, use the &lt;code&gt;--reserve-memory&lt;/code&gt; or &lt;code&gt;--reserve-cpu&lt;/code&gt; flags. If no available nodes can satisfy the requirement (for instance, if you request 4 CPUs and no node in the swarm has 4 CPUs), the service remains in a pending state until an appropriate node is available to run its tasks.</source>
          <target state="translated">서비스에 대해 주어진 양의 메모리 또는 CPU 수를 예약하려면 &lt;code&gt;--reserve-memory&lt;/code&gt; 또는 &lt;code&gt;--reserve-cpu&lt;/code&gt; 플래그를 사용하십시오. 사용 가능한 노드가 요구 사항을 충족 할 수없는 경우 (예를 들어, 4 개의 CPU를 요청하고 웜의 노드에 4 개의 CPU가없는 경우) 해당 노드가 작업을 실행할 수있을 때까지 서비스는 보류 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc6b7b17e03c9020048975ac4a5e7bdcc6a32d6" translate="yes" xml:space="preserve">
          <source>To restart a machine that&amp;rsquo;s stopped, run:</source>
          <target state="translated">중지 된 머신을 다시 시작하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e9775b3d354d3be17bb81b18bfcbbd74a51040be" translate="yes" xml:space="preserve">
          <source>To restart a paused update run &lt;code&gt;docker service update &amp;lt;SERVICE-ID&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">일시 중지 된 업데이트를 다시 시작하려면 &lt;code&gt;docker service update &amp;lt;SERVICE-ID&amp;gt;&lt;/code&gt; 를 실행하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36b91b87fc7cd6104144a9a3d7d7cdfd8e91f307" translate="yes" xml:space="preserve">
          <source>To restart the application run &lt;code&gt;docker-compose up&lt;/code&gt; in the project directory.</source>
          <target state="translated">응용 프로그램을 다시 시작하려면 프로젝트 디렉토리에서 &lt;code&gt;docker-compose up&lt;/code&gt; 을 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="6365fc26def896bdb15fb3ae3facd435cdbbc942" translate="yes" xml:space="preserve">
          <source>To restore, see &lt;a href=&quot;#restore-from-a-backup&quot;&gt;Restore from a backup&lt;/a&gt;.</source>
          <target state="translated">복원하려면 &lt;a href=&quot;#restore-from-a-backup&quot;&gt;백업에서&lt;/a&gt; 복원을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd5ac55f99b4e4dfa69666eb38ec9e144e73c8f9" translate="yes" xml:space="preserve">
          <source>To retrieve the join command including the join token for manager nodes, run the following command on a manager node:</source>
          <target state="translated">관리자 노드의 결합 토큰을 포함하여 join 명령을 검색하려면 관리자 노드에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="21de6e34820ec7593df696b2db3334c997576da9" translate="yes" xml:space="preserve">
          <source>To retrieve the join command including the join token for worker nodes, run the following command on a manager node:</source>
          <target state="translated">작업자 노드의 조인 토큰을 포함하여 join 명령을 검색하려면 관리자 노드에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="be50ffb7c3a3a97ddca931a464bf99676aef52b5" translate="yes" xml:space="preserve">
          <source>To retrieve the join command including the join token for worker nodes, run:</source>
          <target state="translated">작업자 노드의 조인 토큰을 포함하여 join 명령을 검색하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="15de0da3bb255e4ba9b22df9510640fb1a68e248" translate="yes" xml:space="preserve">
          <source>To rotate a config, you first save a new config with a different name than the one that is currently in use. You then redeploy the service, removing the old config and adding the new config at the same mount point within the container. This example builds upon the previous one by rotating the &lt;code&gt;site.conf&lt;/code&gt; configuration file.</source>
          <target state="translated">구성을 회전하려면 먼저 현재 사용중인 이름과 다른 이름으로 새 구성을 저장하십시오. 그런 다음 서비스를 재배치하고 이전 구성을 제거하고 컨테이너 내의 동일한 마운트 지점에 새 구성을 추가하십시오. 이 예제는 &lt;code&gt;site.conf&lt;/code&gt; 구성 파일 을 회전시켜 이전 예제를 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="9300021e45ed41a7b3822c08b507e129425f7f33" translate="yes" xml:space="preserve">
          <source>To run Compose as a non-root user, see &lt;a href=&quot;https://docs.docker.com/install/linux/linux-postinstall/&quot;&gt;Manage Docker as a non-root user&lt;/a&gt;.</source>
          <target state="translated">루트가 아닌 사용자로 작성을 실행하려면 루트가 아닌 사용자로 &lt;a href=&quot;https://docs.docker.com/install/linux/linux-postinstall/&quot;&gt;Docker 관리를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f30e869fcc8c2280c61d26577473c2e2bd22187" translate="yes" xml:space="preserve">
          <source>To run a Docker container, you:</source>
          <target state="translated">Docker 컨테이너를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8e84e72164c2094ed71a3aabcf888e79efae1c7b" translate="yes" xml:space="preserve">
          <source>To run nginx in detached mode:</source>
          <target state="translated">분리 모드에서 nginx를 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="9169efc66794810df7fe7fe89e4b20aaf81249af" translate="yes" xml:space="preserve">
          <source>To run the &lt;code&gt;docker login&lt;/code&gt; command non-interactively, you can set the &lt;code&gt;--password-stdin&lt;/code&gt; flag to provide a password through &lt;code&gt;STDIN&lt;/code&gt;. Using &lt;code&gt;STDIN&lt;/code&gt; prevents the password from ending up in the shell&amp;rsquo;s history, or log-files.</source>
          <target state="translated">&lt;code&gt;docker login&lt;/code&gt; 명령을 비 대화식으로 실행하려면 &lt;code&gt;--password-stdin&lt;/code&gt; 플래그를 설정하여 &lt;code&gt;STDIN&lt;/code&gt; 을 통해 비밀번호를 제공 할 수 있습니다 . &lt;code&gt;STDIN&lt;/code&gt; 을 사용 하면 비밀번호가 쉘 히스토리 또는 로그 파일에서 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdffc74217a2dbea402d1314e7364ede4ae72462" translate="yes" xml:space="preserve">
          <source>To run the daemon with debug output, use &lt;code&gt;dockerd -D&lt;/code&gt; or add &lt;code&gt;&quot;debug&quot;: true&lt;/code&gt; to the &lt;code&gt;daemon.json&lt;/code&gt; file.</source>
          <target state="translated">디버그 출력으로 데몬을 실행하려면 &lt;code&gt;dockerd -D&lt;/code&gt; 를 사용 하거나 &lt;code&gt;&quot;debug&quot;: true&lt;/code&gt; 를 &lt;code&gt;daemon.json&lt;/code&gt; 파일 에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="d598a7c06e20a49b206a70cb1a7599be5afeedbc" translate="yes" xml:space="preserve">
          <source>To run this tutorial, you need the following:</source>
          <target state="translated">이 학습서를 실행하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="082ec3ef855aefcc1c5e85718ddcb8cfe7497356" translate="yes" xml:space="preserve">
          <source>To see a detailed list of changes for past and current releases of Docker Compose, refer to the &lt;a href=&quot;https://github.com/docker/compose/blob/master/CHANGELOG/&quot;&gt;CHANGELOG&lt;/a&gt;.</source>
          <target state="translated">Docker Compose의 이전 및 현재 릴리스에 대한 자세한 변경 사항 목록을 보려면 &lt;a href=&quot;https://github.com/docker/compose/blob/master/CHANGELOG/&quot;&gt;CHANGELOG를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2c2347a0e46106b7b63fa77d236560fbbdeb1ac" translate="yes" xml:space="preserve">
          <source>To see a list of providers and review the options available to a provider, see the reference for that driver.</source>
          <target state="translated">공급자 목록을보고 공급자가 사용할 수있는 옵션을 검토하려면 해당 드라이버에 대한 참조를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e46eb3912f2fd79620b7cc30eecdc49b1c679704" translate="yes" xml:space="preserve">
          <source>To see an image&amp;rsquo;s current digest, issue the command &lt;code&gt;docker inspect &amp;lt;IMAGE&amp;gt;:&amp;lt;TAG&amp;gt;&lt;/code&gt; and look for the &lt;code&gt;RepoDigests&lt;/code&gt; line. The following is the current digest for &lt;code&gt;ubuntu:latest&lt;/code&gt; at the time this content was written. The output is truncated for clarity.</source>
          <target state="translated">이미지의 현재 요약을 보려면 &lt;code&gt;docker inspect &amp;lt;IMAGE&amp;gt;:&amp;lt;TAG&amp;gt;&lt;/code&gt; 명령을 실행 하고 &lt;code&gt;RepoDigests&lt;/code&gt; 줄을 찾으 십시오. 다음은 이 컨텐츠가 쓰여질 당시의 &lt;code&gt;ubuntu:latest&lt;/code&gt; 다이제스트 입니다. 명확성을 위해 출력이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="41bff8947a64a33ada96a1deb33c4d1916a1ba30" translate="yes" xml:space="preserve">
          <source>To see how the &lt;code&gt;docker:apache&lt;/code&gt; image was added to a container&amp;rsquo;s base image:</source>
          <target state="translated">&lt;code&gt;docker:apache&lt;/code&gt; 이미지가 컨테이너의 기본 이미지에 추가 된 방법을 보려면 :</target>
        </trans-unit>
        <trans-unit id="7fac1f89ffd5d8c1c803082b7645d8d0d8cc93ba" translate="yes" xml:space="preserve">
          <source>To see how the &lt;code&gt;docker:latest&lt;/code&gt; image was built:</source>
          <target state="translated">&lt;code&gt;docker:latest&lt;/code&gt; 이미지가 어떻게 빌드 되었는지 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="0ee2577cccf8e27d9d0514d167c7bf5c9f7ea203" translate="yes" xml:space="preserve">
          <source>To see the details on the &lt;code&gt;helloworld&lt;/code&gt; service:</source>
          <target state="translated">&lt;code&gt;helloworld&lt;/code&gt; 서비스 에 대한 세부 사항을 보려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b837bc652c41fbea82b97ebabf29c1b14f723d5" translate="yes" xml:space="preserve">
          <source>To see the logfiles that are &lt;code&gt;tailed&lt;/code&gt; in the default command, you can use:</source>
          <target state="translated">기본 명령에서 &lt;code&gt;tailed&lt;/code&gt; 가 붙은 로그 파일을 보려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c57a462c3dc5b1a53f6db72c043ea066d58ad879" translate="yes" xml:space="preserve">
          <source>To see the provider-specific flags, simply pass a value for &lt;code&gt;--driver&lt;/code&gt; when invoking the &lt;code&gt;create&lt;/code&gt; help text.</source>
          <target state="translated">공급자 별 플래그를 보려면 &lt;code&gt;create&lt;/code&gt; help text를 호출 할 때 &lt;code&gt;--driver&lt;/code&gt; 에 값을 전달하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4d6d4797f52f2f3ab5e2ec9ac125dccfcc13bc" translate="yes" xml:space="preserve">
          <source>To see the result of using the template, use the &lt;code&gt;docker service ps&lt;/code&gt; and &lt;code&gt;docker inspect&lt;/code&gt; commands.</source>
          <target state="translated">템플리트 사용 결과를 보려면 &lt;code&gt;docker service ps&lt;/code&gt; 및 &lt;code&gt;docker inspect&lt;/code&gt; 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="129cad5f269f116bf25bc033fdbf6af79639a2a5" translate="yes" xml:space="preserve">
          <source>To see what environment variables are available to a service, run &lt;code&gt;docker-compose run SERVICE env&lt;/code&gt;.</source>
          <target state="translated">서비스에 사용 가능한 환경 변수를 보려면 &lt;code&gt;docker-compose run SERVICE env&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b5950525321f7c461a099fdb136b2b8c2bc7871" translate="yes" xml:space="preserve">
          <source>To see which images are present locally, use the &lt;a href=&quot;../images/index&quot;&gt;&lt;code&gt;docker images&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">어떤 이미지가 로컬에 있는지 확인하려면 &lt;a href=&quot;../images/index&quot;&gt; &lt;code&gt;docker images&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb554a51c2e9e0f0c7c2ee4cb960809fc36b0796" translate="yes" xml:space="preserve">
          <source>To serve the metrics API on &lt;code&gt;localhost:9323&lt;/code&gt; you would specify &lt;code&gt;--metrics-addr 127.0.0.1:9323&lt;/code&gt;, allowing you to make requests on the API at &lt;code&gt;127.0.0.1:9323/metrics&lt;/code&gt; to receive metrics in the &lt;a href=&quot;https://prometheus.io/docs/instrumenting/exposition_formats/&quot;&gt;prometheus&lt;/a&gt; format.</source>
          <target state="translated">&lt;code&gt;localhost:9323&lt;/code&gt; 에서 메트릭 API를 제공하려면 &lt;code&gt;--metrics-addr 127.0.0.1:9323&lt;/code&gt; 을 지정 하면 API에서 &lt;code&gt;127.0.0.1:9323/metrics&lt;/code&gt; 로 요청 하여 프로 &lt;a href=&quot;https://prometheus.io/docs/instrumenting/exposition_formats/&quot;&gt;메테우스&lt;/a&gt; 형식의 메트릭을 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c713f8261498437251e22b59409f896ac8ed8262" translate="yes" xml:space="preserve">
          <source>To set labels on containers instead, use the &lt;code&gt;labels&lt;/code&gt; key outside of &lt;code&gt;deploy&lt;/code&gt;:</source>
          <target state="translated">대신 컨테이너에 레이블을 설정하려면 &lt;code&gt;deploy&lt;/code&gt; 외부 에서 &lt;code&gt;labels&lt;/code&gt; 키를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="01e468de676963d213e376546e7dde34754366c3" translate="yes" xml:space="preserve">
          <source>To set the DNS search domain for all Docker containers, use:</source>
          <target state="translated">모든 Docker 컨테이너에 대한 DNS 검색 도메인을 설정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b93b25d38e5fdeccbea33bf4d0ae206b11b4cfb4" translate="yes" xml:space="preserve">
          <source>To set the DNS server for all Docker containers, use:</source>
          <target state="translated">모든 Docker 컨테이너에 대해 DNS 서버를 설정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="787329e3a5e2d2cf825f03dff6cf6b63fc53b7f6" translate="yes" xml:space="preserve">
          <source>To set up port redirection on the host system, see &lt;a href=&quot;../run/index#expose-incoming-ports&quot;&gt;using the -P flag&lt;/a&gt;. The &lt;code&gt;docker network&lt;/code&gt; command supports creating networks for communication among containers without the need to expose or publish specific ports, because the containers connected to the network can communicate with each other over any port. For detailed information, see the &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;overview of this feature&lt;/a&gt;).</source>
          <target state="translated">호스트 시스템에서 포트 리디렉션을 설정하려면 &lt;a href=&quot;../run/index#expose-incoming-ports&quot;&gt;-P 플래그 사용을&lt;/a&gt; 참조하십시오 . &lt;code&gt;docker network&lt;/code&gt; 는 네트워크에 접속 된 컨테이너가 어느 포트를 통해 서로 통신 할 수 있으므로, 노출 또는 특정 포트를 발행 할 필요없이 콘테이너들 사이의 통신을위한 네트워크를 만드는 명령 지지체. 자세한 내용 &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;은이 기능&lt;/a&gt; 의 개요를 참조하십시오 ).</target>
        </trans-unit>
        <trans-unit id="13c438b7bb4eb69e4450eca40b43c1da7f7f2c04" translate="yes" xml:space="preserve">
          <source>To set your shell to talk to a different machine like &lt;code&gt;myvm2&lt;/code&gt;, simply re-run &lt;code&gt;docker-machine env&lt;/code&gt; in the same or a different shell, then run the given command to point to &lt;code&gt;myvm2&lt;/code&gt;. This is always specific to the current shell. If you change to an unconfigured shell or open a new one, you need to re-run the commands. Use &lt;code&gt;docker-machine ls&lt;/code&gt; to list machines, see what state they are in, get IP addresses, and find out which one, if any, you are connected to. To learn more, see the &lt;a href=&quot;../../machine/get-started/index#create-a-machine&quot;&gt;Docker Machine getting started topics&lt;/a&gt;.</source>
          <target state="translated">같은 다른 시스템에 토론 쉘을 설정하려면 &lt;code&gt;myvm2&lt;/code&gt; , 단순히 다시 실행 &lt;code&gt;docker-machine env&lt;/code&gt; 동일하거나 다른 쉘에서, 다음에 점에 주어진 명령을 실행 &lt;code&gt;myvm2&lt;/code&gt; . 이것은 항상 현재 쉘에만 해당됩니다. 구성되지 않은 쉘로 변경하거나 새 쉘을 열면 명령을 다시 실행해야합니다. &lt;code&gt;docker-machine ls&lt;/code&gt; 를 사용 하여 시스템 을 나열하고 시스템의 상태를 확인하고 IP 주소를 얻고 연결된 시스템을 찾으십시오. 자세한 내용은 &lt;a href=&quot;../../machine/get-started/index#create-a-machine&quot;&gt;Docker Machine 시작 주제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d95f0e63413f4f2a57f9f3fc7a41b8fff2c3de04" translate="yes" xml:space="preserve">
          <source>To sign a Docker Image you will need a delegation key pair. These keys can be generated locally using &lt;code&gt;$ docker trust key generate&lt;/code&gt;, generated by a certificate authority, or if you are using Docker Enterprise&amp;rsquo;s Universal Control Plane (UCP), a user&amp;rsquo;s Client Bundle provides adequate keys for a delegation. Find more information on Delegation Keys &lt;a href=&quot;../trust_delegation/index#creating-delegation-keys&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Docker Image에 서명하려면 위임 키 쌍이 필요합니다. 이 키는 인증 기관에서 생성 한 &lt;code&gt;$ docker trust key generate&lt;/code&gt; 를 사용하여 로컬로 생성 하거나 Docker Enterprise의 UCP (Universal Control Plane)를 사용하는 경우 사용자의 클라이언트 번들이 위임에 적합한 키를 제공합니다. 위임 키에 대한 자세한 내용은 &lt;a href=&quot;../trust_delegation/index#creating-delegation-keys&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b76f0572de46a8fd7880971b6a93cb3113afea1" translate="yes" xml:space="preserve">
          <source>To source only the &lt;code&gt;docker&lt;/code&gt; endpoint configuration from an existing context use the &lt;code&gt;--docker from=&amp;lt;context-name&amp;gt;&lt;/code&gt; option. The example below creates a new context named &lt;code&gt;my-context&lt;/code&gt; using the docker endpoint configuration from the existing context &lt;code&gt;existing-context&lt;/code&gt; and a kubernetes configuration sourced from the file &lt;code&gt;/home/me/my-kube-config&lt;/code&gt;:</source>
          <target state="translated">기존 컨텍스트에서 &lt;code&gt;docker&lt;/code&gt; 엔드 포인트 구성 만 소싱하려면 &lt;code&gt;--docker from=&amp;lt;context-name&amp;gt;&lt;/code&gt; 옵션을 사용하십시오. 아래 예제 는 기존 컨텍스트 &lt;code&gt;existing-context&lt;/code&gt; 컨텍스트의 docker endpoint 구성 과 &lt;code&gt;/home/me/my-kube-config&lt;/code&gt; 파일에서 제공되는 kubernetes 구성을 사용하여 &lt;code&gt;my-context&lt;/code&gt; context라는 새 컨텍스트를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="32fd48d34832f360b22ddda4a1de5d9d1db136b2" translate="yes" xml:space="preserve">
          <source>To source only the &lt;code&gt;kubernetes&lt;/code&gt; configuration from an existing context use the &lt;code&gt;--kubernetes from=&amp;lt;context-name&amp;gt;&lt;/code&gt; option. The example below creates a new context named &lt;code&gt;my-context&lt;/code&gt; using the kuberentes configuration from the existing context &lt;code&gt;existing-context&lt;/code&gt; and a docker endpoint of &lt;code&gt;/var/run/docker.sock&lt;/code&gt;:</source>
          <target state="translated">기존 컨텍스트에서 &lt;code&gt;kubernetes&lt;/code&gt; 구성 만 소싱 하려면 &lt;code&gt;--kubernetes from=&amp;lt;context-name&amp;gt;&lt;/code&gt; 옵션을 사용하십시오. 아래 예제 는 기존 컨텍스트의 &lt;code&gt;existing-context&lt;/code&gt; 및 &lt;code&gt;/var/run/docker.sock&lt;/code&gt; 의 docker 끝점 에서 kuberentes 구성을 사용하여 &lt;code&gt;my-context&lt;/code&gt; context라는 새 컨텍스트를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f9bd19ce7af971b23f79dd5d36c0dae8dda26b14" translate="yes" xml:space="preserve">
          <source>To specify multiple environment variables, specify multiple &lt;code&gt;--env&lt;/code&gt; flags, each with a separate key-value pair.</source>
          <target state="translated">여러 환경 변수를 지정하려면 각각 별도의 키-값 쌍을 가진 여러 &lt;code&gt;--env&lt;/code&gt; 플래그를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa5590a399db05fd9c44bfa3b8ea3f4359554e14" translate="yes" xml:space="preserve">
          <source>To start a container in detached mode, you use &lt;code&gt;-d=true&lt;/code&gt; or just &lt;code&gt;-d&lt;/code&gt; option. By design, containers started in detached mode exit when the root process used to run the container exits, unless you also specify the &lt;code&gt;--rm&lt;/code&gt; option. If you use &lt;code&gt;-d&lt;/code&gt; with &lt;code&gt;--rm&lt;/code&gt;, the container is removed when it exits &lt;strong&gt;or&lt;/strong&gt; when the daemon exits, whichever happens first.</source>
          <target state="translated">분리 모드에서 컨테이너를 시작하려면 &lt;code&gt;-d=true&lt;/code&gt; 또는 &lt;code&gt;-d&lt;/code&gt; 옵션 만 사용하십시오 . &lt;code&gt;--rm&lt;/code&gt; 옵션을 지정하지 않으면 컨테이너를 실행하는 데 사용 된 루트 프로세스가 종료 될 때 컨테이너는 분리 모드 종료로 시작됩니다 . &lt;code&gt;--rm&lt;/code&gt; 과 함께 &lt;code&gt;-d&lt;/code&gt; 를 사용 하면 컨테이너가 종료 &lt;strong&gt;되거나&lt;/strong&gt; 데몬이 종료 될 때 컨테이너가 먼저 발생합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29a9c49bb702fdef33af30ac60450dcd6192a87f" translate="yes" xml:space="preserve">
          <source>To start a global service on each available node, pass &lt;code&gt;--mode global&lt;/code&gt; to &lt;code&gt;docker service create&lt;/code&gt;. Every time a new node becomes available, the scheduler places a task for the global service on the new node. For example to start a service that runs alpine on every node in the swarm:</source>
          <target state="translated">사용 가능한 각 노드에서 글로벌 서비스를 시작하려면 &lt;code&gt;--mode global&lt;/code&gt; 을 &lt;code&gt;docker service create&lt;/code&gt; 로 전달하십시오 . 새 노드가 사용 가능할 때마다 스케줄러는 글로벌 서비스에 대한 태스크를 새 노드에 배치합니다. 예를 들어 swarm의 모든 노드에서 알파인을 실행하는 서비스를 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a336a72de729795b1d7896306e5e837f60dbc839" translate="yes" xml:space="preserve">
          <source>To start a normal environment run &lt;code&gt;docker-compose up -d&lt;/code&gt;. To run a database backup, include the &lt;code&gt;docker-compose.admin.yml&lt;/code&gt; as well.</source>
          <target state="translated">정상적인 환경을 시작하려면 &lt;code&gt;docker-compose up -d&lt;/code&gt; 를 실행하십시오 . 데이터베이스 백업을 실행하려면 &lt;code&gt;docker-compose.admin.yml&lt;/code&gt; 도 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="259f09a8193969099fb3f6f34187b1a763b66341" translate="yes" xml:space="preserve">
          <source>To stop a container, use &lt;code&gt;CTRL-c&lt;/code&gt;. This key sequence sends &lt;code&gt;SIGKILL&lt;/code&gt; to the container. If &lt;code&gt;--sig-proxy&lt;/code&gt; is true (the default),&lt;code&gt;CTRL-c&lt;/code&gt; sends a &lt;code&gt;SIGINT&lt;/code&gt; to the container. If the container was run with &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt;, you can detach from a container and leave it running using the &lt;code&gt;CTRL-p CTRL-q&lt;/code&gt; key sequence.</source>
          <target state="translated">컨테이너를 중지하려면 &lt;code&gt;CTRL-c&lt;/code&gt; 를 사용하십시오 . 이 키 시퀀스는 &lt;code&gt;SIGKILL&lt;/code&gt; 을 컨테이너로 보냅니다 . 경우 &lt;code&gt;--sig-proxy&lt;/code&gt; true (디폴트), &lt;code&gt;CTRL-c&lt;/code&gt; 전송 &lt;code&gt;SIGINT&lt;/code&gt; 컨테이너에 있습니다. 컨테이너가 &lt;code&gt;-i&lt;/code&gt; 및 &lt;code&gt;-t&lt;/code&gt; 로 실행 된 경우 컨테이너에서 분리하고 &lt;code&gt;CTRL-p CTRL-q&lt;/code&gt; 키 시퀀스를 사용하여 컨테이너를 실행 상태로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b85dc1bc1ecd3f08eac00f5db26cf3f0b0489ff" translate="yes" xml:space="preserve">
          <source>To stop the application, run &lt;a href=&quot;../reference/down/index&quot;&gt;docker-compose down&lt;/a&gt; in your project directory. You can use the same terminal window in which you started the database, or another one where you have access to a command prompt. This is a clean way to stop the application.</source>
          <target state="translated">응용 프로그램을 중지하려면 프로젝트 디렉토리에서 &lt;a href=&quot;../reference/down/index&quot;&gt;docker-compose down&lt;/a&gt; 을 실행 하십시오. 데이터베이스를 시작한 것과 동일한 터미널 창이나 명령 프롬프트에 액세스 할 수있는 다른 터미널 창을 사용할 수 있습니다. 이것은 응용 프로그램을 중지하는 깔끔한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="abed9702df3b1e0206c37a0e923cfce7295767a2" translate="yes" xml:space="preserve">
          <source>To support things like key rotation and expiring / retiring keys you can publish multiple contributor keys per delegation. The only prerequisite here is to make sure you use the same the delegation name, in this case &lt;code&gt;jeff&lt;/code&gt;. Docker trust will automatically handle adding this new key to &lt;code&gt;targets/releases&lt;/code&gt;.</source>
          <target state="translated">키 순환 및 만료 / 종료 키와 같은 기능을 지원하기 위해 위임마다 여러 기고자 키를 게시 할 수 있습니다. 여기에서 유일한 전제 조건은 동일한 위임 이름 (이 경우 &lt;code&gt;jeff&lt;/code&gt; ) 을 사용해야합니다 . Docker trust는이 새 키를 &lt;code&gt;targets/releases&lt;/code&gt; 추가하는 것을 자동으로 처리 합니다 .</target>
        </trans-unit>
        <trans-unit id="3facf0781a8b98dfc53491f3d017724c39504571" translate="yes" xml:space="preserve">
          <source>To tag a local image with ID &amp;ldquo;0e5574283393&amp;rdquo; into the &amp;ldquo;fedora&amp;rdquo; repository with &amp;ldquo;version1.0&amp;rdquo;:</source>
          <target state="translated">ID가 &quot;0e5574283393&quot;인 로컬 이미지에 &quot;version1.0&quot;을 사용하여 &quot;fedora&quot;저장소에 태그를 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b755e725e9ffe69bea5b6bb0ba0a3f9ed8815f93" translate="yes" xml:space="preserve">
          <source>To tag a local image with name &amp;ldquo;httpd&amp;rdquo; and tag &amp;ldquo;test&amp;rdquo; into the &amp;ldquo;fedora&amp;rdquo; repository with &amp;ldquo;version1.0.test&amp;rdquo;:</source>
          <target state="translated">이름이&amp;ldquo;httpd&amp;rdquo;인 로컬 이미지에 태그를 지정하고&amp;ldquo;test&amp;rdquo;를&amp;ldquo;version1.0.test&amp;rdquo;를 사용하여&amp;ldquo;fedora&amp;rdquo;저장소에 태그 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="289cba92532c8e642747a2302f3565925351b95c" translate="yes" xml:space="preserve">
          <source>To tag a local image with name &amp;ldquo;httpd&amp;rdquo; into the &amp;ldquo;fedora&amp;rdquo; repository with &amp;ldquo;version1.0&amp;rdquo;:</source>
          <target state="translated">이름이 &quot;httpd&quot;인 로컬 이미지에 &quot;version1.0&quot;을 사용하여 &quot;fedora&quot;저장소에 태그를 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0ab0df6e7f368ac1e8e9d50140140c9344fe16fe" translate="yes" xml:space="preserve">
          <source>To tag the image into multiple repositories after the build, add multiple &lt;code&gt;-t&lt;/code&gt; parameters when you run the &lt;code&gt;build&lt;/code&gt; command:</source>
          <target state="translated">빌드 후 이미지를 여러 저장소에 태그하려면 &lt;code&gt;build&lt;/code&gt; 명령 을 실행할 때 여러 개의 &lt;code&gt;-t&lt;/code&gt; 매개 변수를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="242d56953a629ab2d6376d003ffafa6b5aa75624" translate="yes" xml:space="preserve">
          <source>To take advantage of swarm mode&amp;rsquo;s fault-tolerance features, Docker recommends you implement an odd number of nodes according to your organization&amp;rsquo;s high-availability requirements. When you have multiple managers you can recover from the failure of a manager node without downtime.</source>
          <target state="translated">스웜 모드의 내결함성 기능을 활용하려면 Docker는 조직의 고 가용성 요구 사항에 따라 홀수 개의 노드를 구현하는 것이 좋습니다. 여러 관리자가있는 경우 가동 중지 시간없이 관리자 노드의 장애로부터 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f957db5215096f98ff2a417c0e583573485f5864" translate="yes" xml:space="preserve">
          <source>To talk about the project with people in real time, join the &lt;code&gt;#docker-machine&lt;/code&gt; channel on IRC.</source>
          <target state="translated">사람들과 실시간으로 프로젝트에 대해 이야기하려면 IRC 의 &lt;code&gt;#docker-machine&lt;/code&gt; 채널에 가입하십시오 .</target>
        </trans-unit>
        <trans-unit id="55b10cd74ab21402bc34507beef8ff2cd9dccdb0" translate="yes" xml:space="preserve">
          <source>To talk about the project with people in real time: join the &lt;code&gt;#docker-compose&lt;/code&gt; channel on freenode IRC.</source>
          <target state="translated">사람들과 실시간으로 프로젝트에 대해 이야기하려면 : freenode IRC 의 &lt;code&gt;#docker-compose&lt;/code&gt; 채널에 가입하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b997c591250d0b2a1c6129b215a071efc71730e" translate="yes" xml:space="preserve">
          <source>To the consumer who has not enabled DCT, nothing about how they work with Docker images changes. Every image is visible regardless of whether it is signed or not.</source>
          <target state="translated">DCT를 활성화하지 않은 소비자에게는 Docker 이미지 변경 작업에 대한 정보가 없습니다. 서명 여부에 관계없이 모든 이미지를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29924dcf069352443d66775fa05e11dbabb805fd" translate="yes" xml:space="preserve">
          <source>To uninstall Docker Compose if you installed using &lt;code&gt;curl&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;curl&lt;/code&gt; 을 사용하여 설치 한 경우 Docker Compose를 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6f4b50a565b371bd8fd3ec37d37b90afa716ff63" translate="yes" xml:space="preserve">
          <source>To uninstall Docker Compose if you installed using &lt;code&gt;pip&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;pip&lt;/code&gt; 를 사용하여 설치 한 경우 Docker Compose를 설치 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6943461b099aa1d71f5c7c513425d8ea2f688c78" translate="yes" xml:space="preserve">
          <source>To uninstall Docker Machine:</source>
          <target state="translated">Docker Machine을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2854b06be4aed6447229aaf67c350ce1bda902d7" translate="yes" xml:space="preserve">
          <source>To unload a profile from AppArmor:</source>
          <target state="translated">AppArmor에서 프로파일을 언로드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5a704d4ddd95fcb6dfcd1d9c51aa0604ef191ecc" translate="yes" xml:space="preserve">
          <source>To unlock a locked swarm, use &lt;code&gt;docker swarm unlock&lt;/code&gt;.</source>
          <target state="translated">잠긴 떼를 잠금 해제하려면 &lt;code&gt;docker swarm unlock&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="70f868582407676852d7aeb6c195a52fdef91c5f" translate="yes" xml:space="preserve">
          <source>To unmount the directory again, you can use the same options but the &lt;code&gt;-u&lt;/code&gt; flag. You can also call &lt;code&gt;fuserunmount&lt;/code&gt; (or &lt;code&gt;fusermount -u&lt;/code&gt;) commands directly.</source>
          <target state="translated">디렉토리를 다시 마운트 해제하려면 &lt;code&gt;-u&lt;/code&gt; 플래그 와 동일한 옵션을 사용할 수 있습니다 . &lt;code&gt;fuserunmount&lt;/code&gt; (또는 &lt;code&gt;fusermount -u&lt;/code&gt; ) 명령을 직접 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="34d085e9c943a535c8ac6f30c0905e78322e1c46" translate="yes" xml:space="preserve">
          <source>To update a stack, make changes to your Compose file, then re-run &lt;code&gt;docker stack deploy -c &amp;lt;new-compose-file&amp;gt; &amp;lt;stack-name&amp;gt;&lt;/code&gt;. If you use a new config in that file, your services start using them. Keep in mind that configurations are immutable, so you can&amp;rsquo;t change the file for an existing service. Instead, you create a new config to use a different file</source>
          <target state="translated">스택을 업데이트하려면 Compose 파일을 변경 한 다음 &lt;code&gt;docker stack deploy -c &amp;lt;new-compose-file&amp;gt; &amp;lt;stack-name&amp;gt;&lt;/code&gt; 을 다시 실행 하십시오 . 해당 파일에서 새 구성을 사용하면 서비스에서 해당 구성을 사용하기 시작합니다. 구성은 변경할 수 없으므로 기존 서비스의 파일을 변경할 수 없습니다. 대신 다른 파일을 사용하도록 새 구성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cd41731a8c8abf8e8dd9d1aaa9fa7a9aa974b539" translate="yes" xml:space="preserve">
          <source>To update multiple resource configurations for multiple containers:</source>
          <target state="translated">여러 컨테이너에 대한 여러 리소스 구성을 업데이트하려면</target>
        </trans-unit>
        <trans-unit id="ae67f042db449ff528c8e8d4766bddaef9fc88d2" translate="yes" xml:space="preserve">
          <source>To update or roll back configs more easily, consider adding a version number or date to the config name. This is made easier by the ability to control the mount point of the config within a given container.</source>
          <target state="translated">구성을보다 쉽게 ​​업데이트하거나 롤백하려면 구성 이름에 버전 번호 또는 날짜를 추가하십시오. 주어진 컨테이너 내에서 구성의 마운트 지점을 제어하는 ​​기능으로 인해 더 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="25e84cef4c7e742fd2183378187a6f04e11c2e3f" translate="yes" xml:space="preserve">
          <source>To update or roll back secrets more easily, consider adding a version number or date to the secret name. This is made easier by the ability to control the mount point of the secret within a given container.</source>
          <target state="translated">비밀을보다 쉽게 ​​업데이트하거나 롤백하려면 비밀 번호에 버전 번호 또는 날짜를 추가하는 것이 좋습니다. 이것은 주어진 컨테이너 내에서 비밀의 마운트 지점을 제어하는 ​​기능으로 인해 더 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="4e37f269c0d67f3c7667ad8d77d8420a5dd0ccaf" translate="yes" xml:space="preserve">
          <source>To update restart policy for one or more containers:</source>
          <target state="translated">하나 이상의 컨테이너에 대한 재시작 정책을 업데이트하려면</target>
        </trans-unit>
        <trans-unit id="03a661d880cb9d779a7d092bfd0547b087490326" translate="yes" xml:space="preserve">
          <source>To update the command an existing service runs, you can use the &lt;code&gt;--args&lt;/code&gt; flag. The following example updates an existing service called &lt;code&gt;helloworld&lt;/code&gt; so that it runs the command &lt;code&gt;ping docker.com&lt;/code&gt; instead of whatever command it was running before:</source>
          <target state="translated">기존 서비스가 실행하는 명령을 업데이트하기 위해 &lt;code&gt;--args&lt;/code&gt; 플래그를 사용할 수 있습니다 . 다음 예제라는 기존 서비스 갱신 &lt;code&gt;helloworld&lt;/code&gt; 는 명령 실행되도록 &lt;code&gt;ping docker.com&lt;/code&gt; 대신 전에 실행 한 명령대로의 :</target>
        </trans-unit>
        <trans-unit id="78316bb0a73f4a4c64c48899091eaea66798c1b3" translate="yes" xml:space="preserve">
          <source>To upload the first key to a delegation, at the same time initiating a repository, you can use the &lt;code&gt;$ docker trust signer add&lt;/code&gt; command. This will add the contributor&amp;rsquo;s public key to the &lt;code&gt;targets/releases&lt;/code&gt; delegation, and create a second &lt;code&gt;targets/&amp;lt;name&amp;gt;&lt;/code&gt; delegation.</source>
          <target state="translated">첫 번째 키를 위임에 업로드하려면 동시에 저장소를 시작하기 위해 &lt;code&gt;$ docker trust signer add&lt;/code&gt; 명령을 사용할 수 있습니다 . 그러면 기여자 공개 키가 &lt;code&gt;targets/releases&lt;/code&gt; 위임에 추가되고 두 ​​번째 &lt;code&gt;targets/&amp;lt;name&amp;gt;&lt;/code&gt; 위임이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a84837e4b12f31be713e52adca55886b6229349d" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;--gpus&lt;/code&gt;, specify which GPUs (or all) to use. If no value is provied, all available GPUs are used. The example below exposes all available GPUs.</source>
          <target state="translated">&lt;code&gt;--gpus&lt;/code&gt; 를 사용하려면 사용할 GPU (또는 모두)를 지정하십시오. 값이 제공되지 않으면 사용 가능한 모든 GPU가 사용됩니다. 아래 예제는 사용 가능한 모든 GPU를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cd864fd0bcb6424e05b48aebf17840a45692edab" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;curl&lt;/code&gt; to make test API requests, you need to use three extra command line flags:</source>
          <target state="translated">&lt;code&gt;curl&lt;/code&gt; 을 사용 하여 테스트 API 요청을 작성하려면 세 개의 추가 명령 행 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7df31040cebc98b4698b2f7f0600fb045c9ccd30" translate="yes" xml:space="preserve">
          <source>To use Docker in swarm mode, install Docker. See &lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;installation instructions&lt;/a&gt; for all operating systems and platforms.</source>
          <target state="translated">웜 모드에서 Docker를 사용하려면 Docker를 설치하십시오. 모든 운영 체제 및 플랫폼에 대한 &lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;설치 지침&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6c07e474152eec3e16bf0164d37ff958230df00" translate="yes" xml:space="preserve">
          <source>To use SSH connection, you need to set up &lt;code&gt;ssh&lt;/code&gt; so that it can reach the remote host with public key authentication. Password authentication is not supported. If your key is protected with passphrase, you need to set up &lt;code&gt;ssh-agent&lt;/code&gt;.</source>
          <target state="translated">SSH 연결을 사용하려면 공개 키 인증으로 원격 호스트에 도달 할 수 있도록 &lt;code&gt;ssh&lt;/code&gt; 를 설정해야 합니다. 비밀번호 인증이 지원되지 않습니다. 키가 암호로 보호되어 있으면 &lt;code&gt;ssh-agent&lt;/code&gt; 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="697d0fe900452fc31d1750d4f9811305ae0cd088" translate="yes" xml:space="preserve">
          <source>To use a Config as a credential spec, create a Docker Config in a credential spec file named &lt;code&gt;credpspec.json&lt;/code&gt;. You can specify any name for the name of the &lt;code&gt;config&lt;/code&gt;.</source>
          <target state="translated">구성을 신임 스펙으로 사용하려면 &lt;code&gt;credpspec.json&lt;/code&gt; 신임 스펙 파일에 Docker 구성을 작성하십시오 . &lt;code&gt;config&lt;/code&gt; 이름의 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a79b79e31ffb7461580a2f5b28f149dc2889d64" translate="yes" xml:space="preserve">
          <source>To use a Config as a credential spec, first create the Docker Config containing the credential spec:</source>
          <target state="translated">구성을 자격 증명 사양으로 사용하려면 먼저 자격 증명 사양이 포함 된 Docker 구성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5cd6f7259501745cf822fda1672ba5ec0994ff96" translate="yes" xml:space="preserve">
          <source>To use a credentials store, you need an external helper program to interact with a specific keychain or external store. Docker requires the helper program to be in the client&amp;rsquo;s host &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">자격 증명 저장소를 사용하려면 특정 키 체인 또는 외부 저장소와 상호 작용할 수있는 외부 도우미 프로그램이 필요합니다. Docker는 도우미 프로그램이 클라이언트의 호스트 &lt;code&gt;$PATH&lt;/code&gt; 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="41516660fda8fda0863b83253c5162ba95af5d8b" translate="yes" xml:space="preserve">
          <source>To use a different base operating system on a remote provider, specify the provider&amp;rsquo;s image flag and one of its available images. For example, to select a &lt;code&gt;debian-8-x64&lt;/code&gt; image on DigitalOcean you would supply the &lt;code&gt;--digitalocean-image=debian-8-x64&lt;/code&gt; flag.</source>
          <target state="translated">원격 제공자에서 다른 기본 운영 체제를 사용하려면 제공자의 이미지 플래그 및 사용 가능한 이미지 중 하나를 지정하십시오. 예를 들어 DigitalOcean 에서 &lt;code&gt;debian-8-x64&lt;/code&gt; 이미지 를 선택 하려면 &lt;code&gt;--digitalocean-image=debian-8-x64&lt;/code&gt; 플래그를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="2d4925a8e40dc110db13004e48506a6f21a0b710" translate="yes" xml:space="preserve">
          <source>To use a file in the build context, the &lt;code&gt;Dockerfile&lt;/code&gt; refers to the file specified in an instruction, for example, a &lt;code&gt;COPY&lt;/code&gt; instruction. To increase the build&amp;rsquo;s performance, exclude files and directories by adding a &lt;code&gt;.dockerignore&lt;/code&gt; file to the context directory. For information about how to &lt;a href=&quot;#dockerignore-file&quot;&gt;create a &lt;code&gt;.dockerignore&lt;/code&gt; file&lt;/a&gt; see the documentation on this page.</source>
          <target state="translated">빌드 컨텍스트에서 파일을 사용하기 위해 &lt;code&gt;Dockerfile&lt;/code&gt; 은 명령에 지정된 파일 (예 : &lt;code&gt;COPY&lt;/code&gt; 명령)을 참조합니다. 빌드 성능을 향상 시키 려면 컨텍스트 디렉토리에 &lt;code&gt;.dockerignore&lt;/code&gt; 파일을 추가하여 파일 및 디렉토리를 제외하십시오 . &lt;a href=&quot;#dockerignore-file&quot;&gt; &lt;code&gt;.dockerignore&lt;/code&gt; &lt;/a&gt; 파일 을 만드는 방법에 대한 자세한 내용은 이 페이지의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51a0dd1058ec1bb95a38582fa2ba084a5db58cf3" translate="yes" xml:space="preserve">
          <source>To use an external load balancer without the routing mesh, set &lt;code&gt;--endpoint-mode&lt;/code&gt; to &lt;code&gt;dnsrr&lt;/code&gt; instead of the default value of &lt;code&gt;vip&lt;/code&gt;. In this case, there is not a single virtual IP. Instead, Docker sets up DNS entries for the service such that a DNS query for the service name returns a list of IP addresses, and the client connects directly to one of these. You are responsible for providing the list of IP addresses and ports to your load balancer. See &lt;a href=&quot;https://docs.docker.com/network#configure-service-discovery&quot;&gt;Configure service discovery&lt;/a&gt;.</source>
          <target state="translated">라우팅 메시없이 외부로드 밸런서를 사용하려면 기본값 &lt;code&gt;vip&lt;/code&gt; 대신 &lt;code&gt;--endpoint-mode&lt;/code&gt; 를 &lt;code&gt;dnsrr&lt;/code&gt; 로 설정 하십시오 . 이 경우 단일 가상 IP가 없습니다. 대신 Docker는 서비스 이름에 대한 DNS 쿼리가 IP 주소 목록을 반환하고 클라이언트가 이들 중 하나에 직접 연결되도록 서비스에 대한 DNS 항목을 설정합니다. 로드 밸런서에 IP 주소 및 포트 목록을 제공해야합니다. &lt;a href=&quot;https://docs.docker.com/network#configure-service-discovery&quot;&gt;서비스 검색 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16c1a5e6e10aea4df2671f8721a2614b0ea9b8a0" translate="yes" xml:space="preserve">
          <source>To use existing data volumes with a service use the &lt;code&gt;--mount&lt;/code&gt; flag:</source>
          <target state="translated">서비스와 함께 기존 데이터 볼륨을 사용하려면 &lt;code&gt;--mount&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="18c033a152d8ac2584c8acdb48b2152af43e1404" translate="yes" xml:space="preserve">
          <source>To use multiple override files, or an override file with a different name, you can use the &lt;code&gt;-f&lt;/code&gt; option to specify the list of files. Compose merges files in the order they&amp;rsquo;re specified on the command line. See the &lt;a href=&quot;../reference/overview/index&quot;&gt;&lt;code&gt;docker-compose&lt;/code&gt; command reference&lt;/a&gt; for more information about using &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">여러 대체 파일 또는 다른 이름의 대체 파일을 사용하려면 &lt;code&gt;-f&lt;/code&gt; 옵션을 사용하여 파일 목록을 지정할 수 있습니다. 작성은 파일을 명령 줄에 지정된 순서대로 병합합니다. &lt;code&gt;-f&lt;/code&gt; 사용에 대한 자세한 정보 는 &lt;a href=&quot;../reference/overview/index&quot;&gt; &lt;code&gt;docker-compose&lt;/code&gt; 명령 참조&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19766773eada5693600fd875bb8b4878ae945368" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;targets/releases&lt;/code&gt; role for pushing and pulling images with content trust, follow the steps above to add and publish the delegation role with notary. When adding the delegation, the &lt;code&gt;--all-paths&lt;/code&gt; flag should be used to allow signing all tags.</source>
          <target state="translated">컨텐츠 신뢰가있는 이미지를 밀고 당기는 데 &lt;code&gt;targets/releases&lt;/code&gt; 역할 을 사용하려면 위의 단계에 따라 공증인으로 위임 역할을 추가하고 공개하십시오. 위임을 추가 할 때 모든 태그에 서명 할 수 있도록 &lt;code&gt;--all-paths&lt;/code&gt; 플래그를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ac5ba0cdad5e4b14a0044009b112040d6d823c3" translate="yes" xml:space="preserve">
          <source>To use the BuildKit backend, you need to set an environment variable &lt;code&gt;DOCKER_BUILDKIT=1&lt;/code&gt; on the CLI before invoking &lt;code&gt;docker build&lt;/code&gt;.</source>
          <target state="translated">BuildKit 백엔드를 사용하려면 &lt;code&gt;docker build&lt;/code&gt; 를 호출하기 전에 CLI에서 환경 변수 &lt;code&gt;DOCKER_BUILDKIT=1&lt;/code&gt; 을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6f8d4c75e01dd5a0eac6711c933f5e434ef75758" translate="yes" xml:space="preserve">
          <source>To use the ingress network in the swarm, you need to have the following ports open between the swarm nodes before you enable swarm mode:</source>
          <target state="translated">스웜에서 수신 네트워크를 사용하려면 스웜 모드를 활성화하기 전에 스웜 노드간에 다음 포트를 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="e81fbd5d064c4c4620b6198de045f19d5408a962" translate="yes" xml:space="preserve">
          <source>To use these, simply pass them on the command line using the flag:</source>
          <target state="translated">이를 사용하려면 플래그를 사용하여 명령 행에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="2247bab194e9cbd16fe47f7c294f7bd9de12b193" translate="yes" xml:space="preserve">
          <source>To verify if the plugin API socket that the docker daemon communicates with is responsive, use curl. In this example, we will make API calls from the docker host to volume and network plugins using curl 7.47.0 to ensure that the plugin is listening on the said socket. For a well functioning plugin, these basic requests should work. Note that plugin sockets are available on the host under &lt;code&gt;/var/run/docker/plugins/&amp;lt;pluginID&amp;gt;&lt;/code&gt;</source>
          <target state="translated">docker 데몬이 통신하는 플러그인 API 소켓이 응답하는지 확인하려면 curl을 사용하십시오. 이 예에서는 플러그인이 해당 소켓에서 수신 대기하는지 확인하기 위해 curl 7.47.0을 사용하여 도커 호스트에서 볼륨 및 네트워크 플러그인으로 API를 호출합니다. 제대로 작동하는 플러그인의 경우 이러한 기본 요청이 작동합니다. 플러그인 소켓은 &lt;code&gt;/var/run/docker/plugins/&amp;lt;pluginID&amp;gt;&lt;/code&gt; 아래의 호스트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e16b005af40c9b6ebd32012889a37e33ea032c3" translate="yes" xml:space="preserve">
          <source>To verify that it worked, use &lt;code&gt;docker service ls&lt;/code&gt;:</source>
          <target state="translated">작동하는지 확인하려면 &lt;code&gt;docker service ls&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb6cdc1945807eea6b60e885a06bac6eaeb8014f" translate="yes" xml:space="preserve">
          <source>To verify the container is connected, use the &lt;code&gt;docker network inspect&lt;/code&gt; command. Use &lt;code&gt;docker network disconnect&lt;/code&gt; to remove a container from the network.</source>
          <target state="translated">컨테이너가 연결되어 있는지 확인하려면 &lt;code&gt;docker network inspect&lt;/code&gt; 명령을 사용하십시오 . &lt;code&gt;docker network disconnect&lt;/code&gt; 를 사용 하여 네트워크에서 컨테이너를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a91fa02704619dc5e2d119cfaae045c004bb098a" translate="yes" xml:space="preserve">
          <source>To verify this, use the &lt;code&gt;id&lt;/code&gt; command:</source>
          <target state="translated">이를 확인하려면 &lt;code&gt;id&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="277b6d1adbc64ac406df43983c8c384cae01658e" translate="yes" xml:space="preserve">
          <source>To view a list of nodes in the swarm run &lt;code&gt;docker node ls&lt;/code&gt; from a manager node:</source>
          <target state="translated">swarm의 노드 목록을 보려면 관리자 노드에서 &lt;code&gt;docker node ls&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="65c584d4bfb2d2116adcd95ba8e4f2046078a29e" translate="yes" xml:space="preserve">
          <source>To view all tasks of a stack, you can run &lt;code&gt;docker stack ps&lt;/code&gt; followed by your app name, as shown in the following example:</source>
          <target state="translated">스택의 모든 작업을 보려면 다음 예제와 같이 &lt;code&gt;docker stack ps&lt;/code&gt; 와 앱 이름을 차례로 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ef6c9f67135a7aedfb4a52655075fa4e8fd8606" translate="yes" xml:space="preserve">
          <source>To view an image&amp;rsquo;s labels, use the &lt;code&gt;docker inspect&lt;/code&gt; command.</source>
          <target state="translated">이미지의 레이블을 보려면 &lt;code&gt;docker inspect&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc138732c9a55323b730c8adb709c89a330ee570" translate="yes" xml:space="preserve">
          <source>To view the &lt;code&gt;udev&lt;/code&gt; sync support of a Docker daemon that is using the &lt;code&gt;devicemapper&lt;/code&gt; driver, run:</source>
          <target state="translated">&lt;code&gt;devicemapper&lt;/code&gt; 드라이버를 사용하는 Docker 데몬 의 &lt;code&gt;udev&lt;/code&gt; 동기화 지원 을 보려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="512c831a5a7b126dcfbc76c5dbc9404fb37f6e88" translate="yes" xml:space="preserve">
          <source>To view the join command and token for manager nodes, run:</source>
          <target state="translated">관리자 노드에 대한 join 명령 및 토큰을 보려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="33a8b9ccb9a255df98f9287be3b8a8200246285b" translate="yes" xml:space="preserve">
          <source>To work around this, use &lt;a href=&quot;index#manual-scheduling&quot;&gt;manual scheduling&lt;/a&gt; to ensure that all three services end up on the same node:</source>
          <target state="translated">이 문제를 해결하려면 &lt;a href=&quot;index#manual-scheduling&quot;&gt;수동 스케줄링&lt;/a&gt; 을 사용하여 세 서비스가 모두 동일한 노드에있게하십시오.</target>
        </trans-unit>
        <trans-unit id="f91e3e738b0dafce0e1e876e824979a3dd71e9d1" translate="yes" xml:space="preserve">
          <source>Together they are equivalent to this single line:</source>
          <target state="translated">함께 그들은이 한 줄과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="a7cd3a25d051cdce727b34b10a47c3b707e155b6" translate="yes" xml:space="preserve">
          <source>Together, these features provide a convenient way for developers to get started on a project. Compose can reduce a multi-page &amp;ldquo;developer getting started guide&amp;rdquo; to a single machine readable Compose file and a few commands.</source>
          <target state="translated">이러한 기능을 함께 사용하면 개발자가 프로젝트를 시작할 수있는 편리한 방법을 제공합니다. Compose는 단일 페이지에서 읽을 수있는 Compose 파일과 몇 가지 명령으로 여러 페이지 &quot;개발자 시작 안내서&quot;를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8882ea28c47adb11578fc3fd3c6d77e3a0bdae38" translate="yes" xml:space="preserve">
          <source>Together, this is creating a &amp;ldquo;source of truth&amp;rdquo; in your host&amp;rsquo;s physical filesystem for the Redis data. Without this, Redis would store its data in &lt;code&gt;/data&lt;/code&gt; inside the container&amp;rsquo;s filesystem, which would get wiped out if that container were ever redeployed.</source>
          <target state="translated">이는 Redis 데이터에 대한 호스트의 실제 파일 시스템에서 &quot;진실의 소스&quot;를 생성합니다. 이것이 없으면 Redis는 컨테이너의 파일 시스템 내부의 &lt;code&gt;/data&lt;/code&gt; 에 데이터를 저장하며 , 컨테이너가 재배치되면 지워집니다.</target>
        </trans-unit>
        <trans-unit id="f9898585f16b12c9c8f9ee4c1c08a28eb30455a9" translate="yes" xml:space="preserve">
          <source>Token for entry into the swarm</source>
          <target state="translated">떼에 들어가기위한 토큰</target>
        </trans-unit>
        <trans-unit id="fda6d35e476c7f065b402643e5d3401c4b4784a4" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;networks&lt;/code&gt; key</source>
          <target state="translated">최상위 &lt;code&gt;networks&lt;/code&gt; 키</target>
        </trans-unit>
        <trans-unit id="bbb6b3fdac488f701678e0a9fcfcf5ac56d98904" translate="yes" xml:space="preserve">
          <source>Top-level network properties in NetworkSettings</source>
          <target state="translated">NetworkSettings의 최상위 네트워크 속성</target>
        </trans-unit>
        <trans-unit id="2e143737c371c503be5604081cb15d6717df4e3d" translate="yes" xml:space="preserve">
          <source>Total memory limit (memory + swap, format: &lt;code&gt;&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt;). Number is a positive integer. Unit can be one of &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">총 메모리 제한 (메모리 + 스왑, 형식 : &lt;code&gt;&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt; ). 숫자는 양의 정수입니다. 단위는 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c43a41c9d3d9609270761bdbf57207ae8a0316f" translate="yes" xml:space="preserve">
          <source>Trace arbitrary processes using ptrace(2).</source>
          <target state="translated">ptrace (2)를 사용하여 임의의 프로세스를 추적하십시오.</target>
        </trans-unit>
        <trans-unit id="51250637921eae59caf583fac0804fd1496b53da" translate="yes" xml:space="preserve">
          <source>Tracing/profiling syscall, which could leak a lot of information on the host.</source>
          <target state="translated">호스트에서 많은 정보를 유출 할 수있는 syscall 추적 / 프로파일 링</target>
        </trans-unit>
        <trans-unit id="4174302f4890a1ab873787038dad71c2dcbf251c" translate="yes" xml:space="preserve">
          <source>Tracing/profiling syscall, which could leak a lot of information on the host. Already blocked by dropping &lt;code&gt;CAP_PTRACE&lt;/code&gt;.</source>
          <target state="translated">호스트에서 많은 정보를 유출 할 수있는 syscall 추적 / 프로파일 링 &lt;code&gt;CAP_PTRACE&lt;/code&gt; 를 삭제하여 이미 차단되었습니다 .</target>
        </trans-unit>
        <trans-unit id="76948d9d830d9b43fd1be107c6fc4a890221969b" translate="yes" xml:space="preserve">
          <source>Tracing/profiling syscall, which could leak a lot of information on the host. Also gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;.</source>
          <target state="translated">호스트에서 많은 정보를 유출 할 수있는 syscall 추적 / 프로파일 링 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 에 의해 게이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd37a05a50f56ad511258641bf48584a2a094e64" translate="yes" xml:space="preserve">
          <source>Traditionally, the &lt;code&gt;Dockerfile&lt;/code&gt; is called &lt;code&gt;Dockerfile&lt;/code&gt; and located in the root of the context. You use the &lt;code&gt;-f&lt;/code&gt; flag with &lt;code&gt;docker build&lt;/code&gt; to point to a Dockerfile anywhere in your file system.</source>
          <target state="translated">전통적으로, &lt;code&gt;Dockerfile&lt;/code&gt; 이 라고 &lt;code&gt;Dockerfile&lt;/code&gt; 컨텍스트의 루트에있는. &lt;code&gt;docker build&lt;/code&gt; 와 함께 &lt;code&gt;-f&lt;/code&gt; 플래그를 사용하면 파일 시스템의 어느 곳에서나 Dockerfile을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="142994f0ab25fe7bf64612d336663841bb79df68" translate="yes" xml:space="preserve">
          <source>Treated as a comment due to appearing after a builder instruction:</source>
          <target state="translated">빌더 지시 후에 표시되어 주석으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fb6f87f3d5539d8dad7b5c648924f0adaf8899c2" translate="yes" xml:space="preserve">
          <source>Treated as a comment due to appearing after a comment which is not a parser directive:</source>
          <target state="translated">파서 지시문이 아닌 주석 뒤에 표시되어 주석으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d954468d670a422e9579dcc9f2faa922a47f6c4e" translate="yes" xml:space="preserve">
          <source>Trigger something that will wake up the system.</source>
          <target state="translated">시스템을 깨울 수있는 무언가를 트리거하십시오.</target>
        </trans-unit>
        <trans-unit id="85782e5429e735d524a5612c5bf9e55c7fe7ffd8" translate="yes" xml:space="preserve">
          <source>Triggers are cleared from the final image after being executed. In other words they are not inherited by &amp;ldquo;grand-children&amp;rdquo; builds.</source>
          <target state="translated">실행 후 최종 이미지에서 트리거가 지워집니다. 다시 말해, 그들은 &quot;손자&quot;빌드에 의해 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f85e568d56e59ffec134f197a357202501ba1e58" translate="yes" xml:space="preserve">
          <source>Troubleshoot a manager node</source>
          <target state="translated">관리자 노드 문제 해결</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="4f35ddb9bdcff4ed205ad9cd732eb9d8e3e7df9a" translate="yes" xml:space="preserve">
          <source>Troubleshooting a plugin</source>
          <target state="translated">플러그인 문제 해결</target>
        </trans-unit>
        <trans-unit id="e89fb5edc8cab94c48cf86754cd5eb796a8d38ad" translate="yes" xml:space="preserve">
          <source>Troubleshooting for Linux users</source>
          <target state="translated">Linux 사용자를위한 문제 해결</target>
        </trans-unit>
        <trans-unit id="12b2ee2c68cb0592c73e4fd6365a1fa270ea08e7" translate="yes" xml:space="preserve">
          <source>Troubleshooting tips</source>
          <target state="translated">문제 해결 팁</target>
        </trans-unit>
        <trans-unit id="75d18469c7d4f5016d8878c26cfde56880ebdec2" translate="yes" xml:space="preserve">
          <source>Trust for an image tag is managed through the use of keys. Docker&amp;rsquo;s content trust makes use of five different types of keys:</source>
          <target state="translated">이미지 태그에 대한 신뢰는 키를 사용하여 관리됩니다. Docker의 컨텐츠 신뢰는 5 가지 유형의 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c8b69b1ad24d8d41dfd33093ac309e2082697565" translate="yes" xml:space="preserve">
          <source>Trust for an image tag is managed through the use of signing keys. A key set is created when an operation using DCT is first invoked. A key set consists of the following classes of keys:</source>
          <target state="translated">이미지 태그에 대한 신뢰는 서명 키를 사용하여 관리됩니다. DCT를 사용한 조작이 처음 호출 될 때 키 세트가 작성됩니다. 키 세트는 다음과 같은 키 클래스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="555c0a1d890244b057c47775cec5ac2d0a69ed16" translate="yes" xml:space="preserve">
          <source>Try out new experimental or third-party features</source>
          <target state="translated">새로운 실험 또는 타사 기능을 사용해보십시오</target>
        </trans-unit>
        <trans-unit id="247804d70056c4b6f3c0c5366200b6ebc9209a45" translate="yes" xml:space="preserve">
          <source>Try pulling the image you just pushed:</source>
          <target state="translated">방금 누른 이미지를 당겨보십시오.</target>
        </trans-unit>
        <trans-unit id="5db9bc8c7dd8830a296f090ea75bb3c99007f77d" translate="yes" xml:space="preserve">
          <source>Try removing the config. The removal fails because the &lt;code&gt;redis&lt;/code&gt; service is running and has access to the config.</source>
          <target state="translated">구성을 제거하십시오. &lt;code&gt;redis&lt;/code&gt; 서비스가 실행 중이고 구성에 액세스 할 수 있으므로 제거에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="69f6a3b4f67ca25fe39a6056a00af19d0334b41d" translate="yes" xml:space="preserve">
          <source>Try removing the secret. The removal fails because the &lt;code&gt;redis&lt;/code&gt; service is running and has access to the secret.</source>
          <target state="translated">비밀을 제거하십시오. &lt;code&gt;redis&lt;/code&gt; 서비스가 실행 중이고 비밀에 액세스 할 수 있으므로 제거에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="f0b73cb5511b8e168539fd6f637859677fd07065" translate="yes" xml:space="preserve">
          <source>Try some operations to test the profile.</source>
          <target state="translated">프로파일을 테스트하기 위해 몇 가지 조작을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="d450d80d1e3a54caa8562f025476a3cae687a704" translate="yes" xml:space="preserve">
          <source>Try to run &lt;code&gt;docker exec&lt;/code&gt; on a paused container</source>
          <target state="translated">일시 중지 된 컨테이너에서 &lt;code&gt;docker exec&lt;/code&gt; 를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a5270fb17d72f9c4fa8b655ec642296a058da9fd" translate="yes" xml:space="preserve">
          <source>Tune a container&amp;rsquo;s memory swappiness behavior. Accepts an integer between 0 and 100.</source>
          <target state="translated">컨테이너의 메모리 교환 동작을 조정하십시오. 0에서 100 사이의 정수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8828bcd6e582b63c557581d73b3d8fa9991cafc8" translate="yes" xml:space="preserve">
          <source>Tune container memory swappiness (0 to 100)</source>
          <target state="translated">컨테이너 메모리 교환 조정 (0 ~ 100)</target>
        </trans-unit>
        <trans-unit id="061454a0b62103964ee4dfd2286eb7ef02eced06" translate="yes" xml:space="preserve">
          <source>Tune container pids limit (set -1 for unlimited)</source>
          <target state="translated">컨테이너 pid 제한 조정 (무제한 -1로 설정)</target>
        </trans-unit>
        <trans-unit id="66817150ccd1c06f941544d4239090323eb6cebd" translate="yes" xml:space="preserve">
          <source>Tune container&amp;rsquo;s OOM preferences (-1000 to 1000)</source>
          <target state="translated">컨테이너의 OOM 환경 설정 조정 (-1000 ~ 1000)</target>
        </trans-unit>
        <trans-unit id="2888b0a8297f60820dc0b270946c198021483d70" translate="yes" xml:space="preserve">
          <source>Tune host&amp;rsquo;s OOM preferences (-1000 to 1000)</source>
          <target state="translated">호스트의 OOM 환경 설정 조정 (-1000 ~ 1000)</target>
        </trans-unit>
        <trans-unit id="5758113472d72c5e53139aa1af79ea604c96aeec" translate="yes" xml:space="preserve">
          <source>Tunes a container&amp;rsquo;s PIDs limit. Set to &lt;code&gt;-1&lt;/code&gt; for unlimited PIDs.</source>
          <target state="translated">컨테이너의 PID 한계를 조정합니다. 무제한 PID의 경우 &lt;code&gt;-1&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="68975c64d1176001b6b884128029ce182a7a5bab" translate="yes" xml:space="preserve">
          <source>Twistlock AuthZ Broker</source>
          <target state="translated">Twistlock AuthZ 브로커</target>
        </trans-unit>
        <trans-unit id="f68ec2bdfa7bc65c1c0e09d584e3bdc4395958c5" translate="yes" xml:space="preserve">
          <source>Two nodes with &lt;code&gt;node.labels.datacenter=south&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;node.labels.datacenter=south&lt;/code&gt; 를 가진 두 개의 노드</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="7a324141c1856c41880a998f0c6b02724293b975" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;docker-machine env myvm1&lt;/code&gt;, then copy-paste and run the command provided as the last line of the output to configure your shell to talk to &lt;code&gt;myvm1&lt;/code&gt;, the swarm manager.</source>
          <target state="translated">유형 &lt;code&gt;docker-machine env myvm1&lt;/code&gt; 한 후 붙여 넣기 복사 얘기로 쉘을 구성하는 출력의 마지막 줄에서 제공하는 명령을 실행 &lt;code&gt;myvm1&lt;/code&gt; , 떼 관리자를.</target>
        </trans-unit>
        <trans-unit id="8af31b753266c3f94fdd77b967cab7ccd64aa0f2" translate="yes" xml:space="preserve">
          <source>Type the following command.</source>
          <target state="translated">다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c7a1084ca55dc82d68f7839d7b3001119aa50242" translate="yes" xml:space="preserve">
          <source>Types of plugins</source>
          <target state="translated">플러그인의 종류</target>
        </trans-unit>
        <trans-unit id="e5b760e1de534a215a9305eaa0ee392d2ac711dc" translate="yes" xml:space="preserve">
          <source>Typical servers run several processes as &lt;code&gt;root&lt;/code&gt;, including the SSH daemon, &lt;code&gt;cron&lt;/code&gt; daemon, logging daemons, kernel modules, network configuration tools, and more. A container is different, because almost all of those tasks are handled by the infrastructure around the container:</source>
          <target state="translated">일반적인 서버 는 SSH 데몬, &lt;code&gt;cron&lt;/code&gt; 데몬, 로깅 데몬, 커널 모듈, 네트워크 구성 도구 등을 포함하여 여러 프로세스를 &lt;code&gt;root&lt;/code&gt; 로 실행 합니다. 컨테이너는 거의 모든 작업이 컨테이너 주변의 인프라에서 처리되므로 컨테이너가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7a8f20f0649eebee0ccd10407e8b19f207eef072" translate="yes" xml:space="preserve">
          <source>Typically, you want &lt;code&gt;docker-compose up&lt;/code&gt;. Use &lt;code&gt;up&lt;/code&gt; to start or restart all the services defined in a &lt;code&gt;docker-compose.yml&lt;/code&gt;. In the default &amp;ldquo;attached&amp;rdquo; mode, you see all the logs from all the containers. In &amp;ldquo;detached&amp;rdquo; mode (&lt;code&gt;-d&lt;/code&gt;), Compose exits after starting the containers, but the containers continue to run in the background.</source>
          <target state="translated">일반적으로 &lt;code&gt;docker-compose up&lt;/code&gt; 이 필요합니다 . &lt;code&gt;docker-compose.yml&lt;/code&gt; 에 정의 된 모든 서비스를 시작하거나 다시 시작 하려면 &lt;code&gt;up&lt;/code&gt; 을 사용하십시오 . 기본 &quot;첨부 된&quot;모드에서는 모든 컨테이너의 모든 로그가 표시됩니다. &quot;분리 된&quot;모드 ( &lt;code&gt;-d&lt;/code&gt; )에서 컨테이너를 시작한 후 작성이 종료되지만 컨테이너는 백그라운드에서 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4ac4413362e6edb9a09d840856de196b66b0845d" translate="yes" xml:space="preserve">
          <source>UDP only</source>
          <target state="translated">UDP 만</target>
        </trans-unit>
        <trans-unit id="528aca941d838b03cc9e51ac57f6c9f6a6081aa7" translate="yes" xml:space="preserve">
          <source>UNIX domain socket files must be located under &lt;code&gt;/run/docker/plugins&lt;/code&gt;, whereas spec files can be located either under &lt;code&gt;/etc/docker/plugins&lt;/code&gt; or &lt;code&gt;/usr/lib/docker/plugins&lt;/code&gt;.</source>
          <target state="translated">UNIX 도메인 소켓 파일은 &lt;code&gt;/run/docker/plugins&lt;/code&gt; 에 있어야하고 사양 파일은 &lt;code&gt;/etc/docker/plugins&lt;/code&gt; 또는 &lt;code&gt;/usr/lib/docker/plugins&lt;/code&gt; 에있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f5c420a92dc81a7dbff67746a09c96bb42b3890" translate="yes" xml:space="preserve">
          <source>URL of the Notary server: defaults to https://notary.docker.io This configuration option can be overridden with the command line flag `-s` or `--server`.</source>
          <target state="translated">Notary 서버의 URL : 기본값은 https://notary.docker.io입니다.이 구성 옵션은 명령 줄 플래그`-s` 또는`--server`로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb0c61201a96afc99cbf180f1c8d93c0a9fd8c8" translate="yes" xml:space="preserve">
          <source>USER</source>
          <target state="translated">USER</target>
        </trans-unit>
        <trans-unit id="3caafa88608dc267452ed9c9127c5a4b614e2611" translate="yes" xml:space="preserve">
          <source>UTS namespace to use</source>
          <target state="translated">사용할 UTS 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="fdc814b20077faa4ebb4c003c553df2c32b729a3" translate="yes" xml:space="preserve">
          <source>UTS settings (--uts)</source>
          <target state="translated">UTS 설정 (--uts)</target>
        </trans-unit>
        <trans-unit id="beaefe5e5ab6b21cda39ac220750706fa9007d59" translate="yes" xml:space="preserve">
          <source>UUID long identifier</source>
          <target state="translated">UUID 긴 식별자</target>
        </trans-unit>
        <trans-unit id="9c92c469e079fc875945afbdf288dab4dbcca403" translate="yes" xml:space="preserve">
          <source>UUID short identifier</source>
          <target state="translated">UUID 짧은 식별자</target>
        </trans-unit>
        <trans-unit id="a1c366cacdc2e4f2ca5e9f514afccf66ad1dfa3e" translate="yes" xml:space="preserve">
          <source>Ubuntu</source>
          <target state="translated">Ubuntu</target>
        </trans-unit>
        <trans-unit id="98594cedef5d84389ed5c8345aded6db78dbd817" translate="yes" xml:space="preserve">
          <source>Ulimit options</source>
          <target state="translated">Ulimit 옵션</target>
        </trans-unit>
        <trans-unit id="94c1aca7e3479b80aa81212fa1f4a739278e467c" translate="yes" xml:space="preserve">
          <source>Under this configuration, when the container consumes memory more than 200M and less than 500M, the next system memory reclaim attempts to shrink container memory below 200M.</source>
          <target state="translated">이 구성에서 컨테이너가 200M 이상 500M 미만의 메모리를 사용하면 다음 시스템 메모리 회수는 컨테이너 메모리를 200M 미만으로 축소하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="68156e9c82572c9737f1374209dbdd2917854070" translate="yes" xml:space="preserve">
          <source>Understand Machine concepts</source>
          <target state="translated">기계 개념 이해</target>
        </trans-unit>
        <trans-unit id="cfad7b33be9b969867f4f274f69593e2ffae0e55" translate="yes" xml:space="preserve">
          <source>Understand Notary naming</source>
          <target state="translated">공증인 이름 이해</target>
        </trans-unit>
        <trans-unit id="eefd5394352021efd1442174cb2e58a2887f709d" translate="yes" xml:space="preserve">
          <source>Understand how ARG and FROM interact</source>
          <target state="translated">ARG와 FROM의 상호 작용 이해</target>
        </trans-unit>
        <trans-unit id="3ba18a112c781bda2f5ec1fa287930537da80134" translate="yes" xml:space="preserve">
          <source>Understand how CMD and ENTRYPOINT interact</source>
          <target state="translated">CMD와 ENTRYPOINT의 상호 작용 이해</target>
        </trans-unit>
        <trans-unit id="850eb5c1f583e912c918d864cb73bd9271821ed2" translate="yes" xml:space="preserve">
          <source>Understand the Notary service architecture</source>
          <target state="translated">공증인 서비스 아키텍처 이해</target>
        </trans-unit>
        <trans-unit id="b0792c36f8a441f33f71da2c46564f6a68b6f7fb" translate="yes" xml:space="preserve">
          <source>Understand the architecture of Docker</source>
          <target state="translated">Docker의 아키텍처 이해</target>
        </trans-unit>
        <trans-unit id="1f8573caf7352237035de27f3e732674f596c9c2" translate="yes" xml:space="preserve">
          <source>Understand the configuration</source>
          <target state="translated">구성 이해</target>
        </trans-unit>
        <trans-unit id="7f0dab32c8420413853fddab57b84579a37fbd57" translate="yes" xml:space="preserve">
          <source>Understand the extends configuration</source>
          <target state="translated">확장 구성 이해</target>
        </trans-unit>
        <trans-unit id="aa6c6262804d72724463f19c42852c32b03a38f2" translate="yes" xml:space="preserve">
          <source>Understand the policies</source>
          <target state="translated">정책 이해</target>
        </trans-unit>
        <trans-unit id="b38cb8c0a663ff8cadfa66c451ab309b8a881180" translate="yes" xml:space="preserve">
          <source>Understanding Swarm clusters</source>
          <target state="translated">스웜 클러스터 이해</target>
        </trans-unit>
        <trans-unit id="c285e219db19e27a5bb1e415dbaed5934a5d9c95" translate="yes" xml:space="preserve">
          <source>Understanding multiple Compose files</source>
          <target state="translated">여러 작성 파일 이해</target>
        </trans-unit>
        <trans-unit id="eb45a9c3025eaa4734a0cffb97226d387103ffbd" translate="yes" xml:space="preserve">
          <source>Uninstallation</source>
          <target state="translated">Uninstallation</target>
        </trans-unit>
        <trans-unit id="99947182c472de1d053eb1b1f89115963dfa4e5f" translate="yes" xml:space="preserve">
          <source>Universal Control Plane (UCP) manages CLI and API access to its clusters through certificates generated in a Client Bundle. These certificates and keys can be used as a delegation key pair. Within each client bundle there is a unique private key (&lt;code&gt;key.pem&lt;/code&gt;) and x509 certificate containing a public key (&lt;code&gt;cert.pem&lt;/code&gt;).</source>
          <target state="translated">UCP (Universal Control Plane)는 클라이언트 번들에서 생성 된 인증서를 통해 클러스터에 대한 CLI 및 API 액세스를 관리합니다. 이러한 인증서와 키는 위임 키 쌍으로 사용할 수 있습니다. 각 클라이언트 번들에는 고유 한 개인 키 ( &lt;code&gt;key.pem&lt;/code&gt; ) 및 공개 키 ( &lt;code&gt;cert.pem&lt;/code&gt; )를 포함하는 x509 인증서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f781434f465ddddaa2cdb43f4d74410034561cd" translate="yes" xml:space="preserve">
          <source>Unless they are already running, this command also starts any linked services.</source>
          <target state="translated">이미 실행 중이 아니면이 명령은 연결된 서비스도 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2ddab433eff8d8aba3d8eb8155b011c9e7432786" translate="yes" xml:space="preserve">
          <source>Unless you are going to continue to the next example, clean up after running this example by removing the &lt;code&gt;nginx&lt;/code&gt; service and the stored secrets and config.</source>
          <target state="translated">다음 예제를 계속 진행하지 않는 한,이 예제를 실행 한 후 &lt;code&gt;nginx&lt;/code&gt; 서비스와 저장된 비밀 및 구성 을 제거하여 정리 하십시오.</target>
        </trans-unit>
        <trans-unit id="fbb768e53744c9c6aa8922c365409b24ba12b4c6" translate="yes" xml:space="preserve">
          <source>Unlike an &lt;code&gt;ARG&lt;/code&gt; instruction, &lt;code&gt;ENV&lt;/code&gt; values are always persisted in the built image. Consider a docker build without the &lt;code&gt;--build-arg&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;ARG&lt;/code&gt; 명령어 와 달리 &lt;code&gt;ENV&lt;/code&gt; 값은 항상 빌드 된 이미지에서 유지됩니다. &lt;code&gt;--build-arg&lt;/code&gt; 플래그가 없는 도커 빌드를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="7911249df7b67e90adf47d5d386542f0d416550e" translate="yes" xml:space="preserve">
          <source>Unlike constraints, placement preferences are best-effort, and a service does not fail to deploy if no nodes can satisfy the preference. If you specify a placement preference for a service, nodes that match that preference are ranked higher when the swarm managers decide which nodes should run the service tasks. Other factors, such as high availability of the service, also factor into which nodes are scheduled to run service tasks. For example, if you have N nodes with the rack label (and then some others), and your service is configured to run N+1 replicas, the +1 is scheduled on a node that doesn&amp;rsquo;t already have the service on it if there is one, regardless of whether that node has the &lt;code&gt;rack&lt;/code&gt; label or not.</source>
          <target state="translated">제약 조건과 달리 배치 기본 설정은 최선의 노력이며, 기본 설정을 만족할 수있는 노드가없는 경우 서비스가 배포되지 않습니다. 서비스에 대한 배치 환경 설정을 지정하는 경우, 떼 관리자가 서비스 작업을 실행할 노드를 결정할 때 해당 환경 설정과 일치하는 노드의 순위가 더 높습니다. 서비스의 고가용 성과 같은 다른 요인들도 서비스 작업을 수행 할 노드가 결정됩니다. 예를 들어 랙 레이블이있는 N 개의 노드가 있고 다른 노드가 있고 서비스가 N + 1 복제본을 실행하도록 구성된 경우 +1은 아직 서비스가없는 노드에서 예약됩니다. 해당 노드에 &lt;code&gt;rack&lt;/code&gt; 레이블 이 있는지 여부에 관계없이 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef4f8dbdf763df9b35547143025feb154e6152cb" translate="yes" xml:space="preserve">
          <source>Unlike the scenario where you were running the swarm on local Docker machine VMs, your swarm and any apps deployed on it continue to run on cloud servers regardless of whether you shut down your local host.</source>
          <target state="translated">로컬 Docker 머신 VM에서 웜을 실행 한 시나리오와 달리 웜 및 그에 배포 된 모든 앱은 로컬 호스트의 종료 여부에 관계없이 클라우드 서버에서 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="222eb371016b484671cbe00e3a586b5034cebab7" translate="yes" xml:space="preserve">
          <source>Unlock a swarm</source>
          <target state="translated">떼를 잠금 해제</target>
        </trans-unit>
        <trans-unit id="a0380c68842341d152e08c4fc64484a09b10ec6c" translate="yes" xml:space="preserve">
          <source>Unlock swarm</source>
          <target state="translated">떼 떼기</target>
        </trans-unit>
        <trans-unit id="c5bed66b37d8b04281fc10550b16e7d0707e8487" translate="yes" xml:space="preserve">
          <source>Unlocks a locked manager using a user-supplied unlock key. This command must be used to reactivate a manager after its Docker daemon restarts if the autolock setting is turned on. The unlock key is printed at the time when autolock is enabled, and is also available from the &lt;code&gt;docker swarm unlock-key&lt;/code&gt; command.</source>
          <target state="translated">사용자 제공 잠금 해제 키를 사용하여 잠긴 관리자를 잠금 해제합니다. 자동 잠금 설정이 설정된 경우 Docker 데몬이 다시 시작된 후이 명령을 사용하여 관리자를 다시 활성화해야합니다. 잠금 해제 키는 자동 잠금이 활성화 될 때 인쇄되며 &lt;code&gt;docker swarm unlock-key&lt;/code&gt; 명령 에서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="880237c7ce4ae1ecc01eafeff01c0b4f7e3408e0" translate="yes" xml:space="preserve">
          <source>Unpause all processes within one or more containers</source>
          <target state="translated">하나 이상의 컨테이너 내에서 모든 프로세스 일시 중지</target>
        </trans-unit>
        <trans-unit id="4afb0bb94b84c92f7cdf342827733a30c576133e" translate="yes" xml:space="preserve">
          <source>Unpauses paused containers of a service.</source>
          <target state="translated">일시 중지 된 서비스 컨테이너를 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="0ec99c3d24a789842bab5d56b69a106e607eff70" translate="yes" xml:space="preserve">
          <source>Unset environment variables in the current shell</source>
          <target state="translated">현재 쉘에서 설정되지 않은 환경 변수</target>
        </trans-unit>
        <trans-unit id="2957ae4ea9f3e4ddfe03719d190a06c4d02712d8" translate="yes" xml:space="preserve">
          <source>Unsetting docker-machine shell variable settings</source>
          <target state="translated">docker-machine shell 변수 설정 설정 해제</target>
        </trans-unit>
        <trans-unit id="339d4e3c560687f121712ba52f548574407d876b" translate="yes" xml:space="preserve">
          <source>Up until now, you have been using Docker in a single-host mode on your local machine. But Docker also can be switched into &lt;strong&gt;swarm mode&lt;/strong&gt;, and that&amp;rsquo;s what enables the use of swarms. Enabling swarm mode instantly makes the current machine a swarm manager. From then on, Docker runs the commands you execute on the swarm you&amp;rsquo;re managing, rather than just on the current machine.</source>
          <target state="translated">지금까지는 로컬 시스템의 단일 호스트 모드에서 Docker를 사용했습니다. 그러나 Docker는 &lt;strong&gt;swarm 모드&lt;/strong&gt; 로 전환 할 수 있으므로 &lt;strong&gt;swarm을&lt;/strong&gt; 사용할 수 있습니다 . 스웜 모드를 활성화하면 현재 시스템이 스웜 관리자가됩니다. 그때부터 Docker는 현재 컴퓨터가 아닌 관리중인 떼에서 실행하는 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="74263c9f93147c46666b915ea6de5a6a674be9e4" translate="yes" xml:space="preserve">
          <source>Update a container with cpu-shares and memory</source>
          <target state="translated">CPU 공유 및 메모리로 컨테이너 업데이트</target>
        </trans-unit>
        <trans-unit id="04d1cbb929fdeb36830c6fac1527b5adfc04f106" translate="yes" xml:space="preserve">
          <source>Update a container&amp;rsquo;s cpu-shares</source>
          <target state="translated">컨테이너의 CPU 공유 업데이트</target>
        </trans-unit>
        <trans-unit id="c439cbf9620786d6048c63e470ba5cd2aa73457f" translate="yes" xml:space="preserve">
          <source>Update a container&amp;rsquo;s kernel memory constraints</source>
          <target state="translated">컨테이너의 커널 메모리 제약 조건 업데이트</target>
        </trans-unit>
        <trans-unit id="f3d3f99645f9b835640e7e1d9c915587bb071058" translate="yes" xml:space="preserve">
          <source>Update a container&amp;rsquo;s restart policy</source>
          <target state="translated">컨테이너의 재시작 정책 업데이트</target>
        </trans-unit>
        <trans-unit id="b8efd12dd576886865b91a7a33309067cfe42fef" translate="yes" xml:space="preserve">
          <source>Update a context</source>
          <target state="translated">컨텍스트 업데이트</target>
        </trans-unit>
        <trans-unit id="3fe81a3b0ec2d13f861dfcc67f046017653dc62c" translate="yes" xml:space="preserve">
          <source>Update a local engine</source>
          <target state="translated">로컬 엔진 업데이트</target>
        </trans-unit>
        <trans-unit id="c48b172eb89880d3e04e653cac42b8295adeb3e6" translate="yes" xml:space="preserve">
          <source>Update a node</source>
          <target state="translated">노드 업데이트</target>
        </trans-unit>
        <trans-unit id="df6f6f40cefac982a60cccba4b1f61ead209db34" translate="yes" xml:space="preserve">
          <source>Update a service</source>
          <target state="translated">서비스 업데이트</target>
        </trans-unit>
        <trans-unit id="9207dfe5d0e722cab59ec5c7f84042d02780a80d" translate="yes" xml:space="preserve">
          <source>Update a service&amp;rsquo;s image after creation</source>
          <target state="translated">생성 후 서비스 이미지 업데이트</target>
        </trans-unit>
        <trans-unit id="21718c2206b154ae2af68ad12fb4959190f63fda" translate="yes" xml:space="preserve">
          <source>Update configuration of one or more containers</source>
          <target state="translated">하나 이상의 컨테이너 구성 업데이트</target>
        </trans-unit>
        <trans-unit id="6ee9cf84bd1b024643932429ec3436f14e8165c5" translate="yes" xml:space="preserve">
          <source>Update containers</source>
          <target state="translated">컨테이너 업데이트</target>
        </trans-unit>
        <trans-unit id="7e63b839bf073d2b03eb9759f7ccf73b742d10a4" translate="yes" xml:space="preserve">
          <source>Update kernel memory of running container &lt;code&gt;test2&lt;/code&gt; will fail. You need to stop the container before updating the &lt;code&gt;--kernel-memory&lt;/code&gt; setting. The next time you start it, the container uses the new value.</source>
          <target state="translated">컨테이너 &lt;code&gt;test2&lt;/code&gt; 실행의 커널 메모리 업데이트 가 실패합니다. &lt;code&gt;--kernel-memory&lt;/code&gt; 설정을 업데이트하기 전에 컨테이너를 중지해야 합니다. 다음에 컨테이너를 시작할 때 새 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06ce6b8e599ccdd7d0613fa24c9100ed4cbd1358" translate="yes" xml:space="preserve">
          <source>Update metadata about a node, such as its availability, labels, or roles.</source>
          <target state="translated">가용성, 레이블 또는 역할과 같은 노드에 대한 메타 데이터를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="eab5c386cee71f9a797057025b7cc643e0188903" translate="yes" xml:space="preserve">
          <source>Update order (&amp;ldquo;start-first&amp;rdquo;|&amp;rdquo;stop-first&amp;rdquo;)</source>
          <target state="translated">업데이트 순서 ( &quot;start-first&quot;| &quot;stop-first&quot;)</target>
        </trans-unit>
        <trans-unit id="ef77dc9356be6ba41db55f57e38337f947ecad31" translate="yes" xml:space="preserve">
          <source>Update order (&amp;ldquo;start-first&amp;rdquo;|&amp;rdquo;stop-first&amp;rdquo;) (default &amp;ldquo;stop-first&amp;rdquo;)</source>
          <target state="translated">업데이트 순서 ( &quot;start-first&quot;| &quot;stop-first&quot;) (기본 &quot;stop-first&quot;)</target>
        </trans-unit>
        <trans-unit id="4298dc2c224955090d5c943851052d9ecbb55a4a" translate="yes" xml:space="preserve">
          <source>Update services using templates</source>
          <target state="translated">템플릿을 사용하여 서비스 업데이트</target>
        </trans-unit>
        <trans-unit id="9545afe40de226d5ed4c466546db3b8235cbfcd4" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;nginx&lt;/code&gt; service to use the new config instead of the old one.</source>
          <target state="translated">이전 구성 대신 새 구성을 사용 하도록 &lt;code&gt;nginx&lt;/code&gt; 서비스를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef303f506151d15b14d752abd59aa0db853a44ac" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;wordpress&lt;/code&gt; service to use the new password, keeping the target path at &lt;code&gt;/run/secrets/wp_db_secret&lt;/code&gt; and keeping the file permissions at &lt;code&gt;0400&lt;/code&gt;. This triggers a rolling restart of the WordPress service and the new secret is used.</source>
          <target state="translated">대상 경로를 &lt;code&gt;/run/secrets/wp_db_secret&lt;/code&gt; 에 유지하고 파일 권한을 &lt;code&gt;0400&lt;/code&gt; 에 유지하여 새 비밀번호를 사용 하도록 &lt;code&gt;wordpress&lt;/code&gt; 서비스를 업데이트하십시오 . 이로 인해 WordPress 서비스의 롤링 재시작이 시작되고 새 암호가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b5fde9b927000fcacd1a92b94a2c10781177d4b2" translate="yes" xml:space="preserve">
          <source>Update the MySQL service to give it access to both the old and new secrets. Remember that you cannot update or rename a secret, but you can revoke a secret and grant access to it using a new target filename.</source>
          <target state="translated">이전 및 새로운 비밀 모두에 액세스 할 수 있도록 MySQL 서비스를 업데이트하십시오. 비밀을 업데이트하거나 이름을 바꿀 수는 없지만 비밀을 취소하고 새 대상 파일 이름을 사용하여 액세스 권한을 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20d6ad95abfc52cfbc883066ea7b1d0cfc05d2e5" translate="yes" xml:space="preserve">
          <source>Update the command an existing service runs</source>
          <target state="translated">기존 서비스가 실행하는 명령 업데이트</target>
        </trans-unit>
        <trans-unit id="a544819adc8614829d526f53e98f7fa028b63800" translate="yes" xml:space="preserve">
          <source>Update the service to use three replicas:</source>
          <target state="translated">세 개의 복제본을 사용하도록 서비스를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="13a1d1927c4fcdc5fc3cbe02edbfbfad8c79c3b8" translate="yes" xml:space="preserve">
          <source>Update the swarm</source>
          <target state="translated">떼를 업데이트</target>
        </trans-unit>
        <trans-unit id="add135d8b7d31d84713a9567d228d2331181727b" translate="yes" xml:space="preserve">
          <source>Updates a service as described by the specified parameters. This command has to be run targeting a manager node. The parameters are the same as &lt;a href=&quot;../service_create/index&quot;&gt;&lt;code&gt;docker service create&lt;/code&gt;&lt;/a&gt;. Please look at the description there for further information.</source>
          <target state="translated">지정된 매개 변수에 설명 된대로 서비스를 업데이트합니다. 이 명령은 관리자 노드를 대상으로 실행해야합니다. 매개 변수는 &lt;a href=&quot;../service_create/index&quot;&gt; &lt;code&gt;docker service create&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 자세한 내용은 해당 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7f69957dec36cffac68625d7e93d5eaee0355d7" translate="yes" xml:space="preserve">
          <source>Updates a swarm with new parameter values. This command must target a manager node.</source>
          <target state="translated">새로운 매개 변수 값으로 떼를 업데이트합니다. 이 명령은 관리자 노드를 대상으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ced7f0946d7faad9a669b3cec26620de9ad1bfa" translate="yes" xml:space="preserve">
          <source>Updates an existing &lt;code&gt;context&lt;/code&gt;. See &lt;a href=&quot;../context_create/index&quot;&gt;context create&lt;/a&gt;</source>
          <target state="translated">기존 &lt;code&gt;context&lt;/code&gt; 업데이트합니다 . &lt;a href=&quot;../context_create/index&quot;&gt;컨텍스트 작성&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="320cd39c7f0f399d403599421510bdabdf895419" translate="yes" xml:space="preserve">
          <source>Updating a service causes it to restart, and when the MySQL service restarts the second time, it has access to the old secret under &lt;code&gt;/run/secrets/old_mysql_password&lt;/code&gt; and the new secret under &lt;code&gt;/run/secrets/mysql_password&lt;/code&gt;.</source>
          <target state="translated">서비스를 업데이트하면 서비스가 다시 시작되고 MySQL 서비스가 두 번째로 다시 시작되면 &lt;code&gt;/run/secrets/old_mysql_password&lt;/code&gt; 아래의 이전 비밀 및 &lt;code&gt;/run/secrets/mysql_password&lt;/code&gt; 아래의 새로운 비밀에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6596562e42e13c191083ac68a233a3a010e1816" translate="yes" xml:space="preserve">
          <source>Updating and reloading the cluster configurations such as &lt;code&gt;--cluster-store&lt;/code&gt;, &lt;code&gt;--cluster-advertise&lt;/code&gt; and &lt;code&gt;--cluster-store-opts&lt;/code&gt; will take effect only if these configurations were not previously configured. If &lt;code&gt;--cluster-store&lt;/code&gt; has been provided in flags and &lt;code&gt;cluster-advertise&lt;/code&gt; not, &lt;code&gt;cluster-advertise&lt;/code&gt; can be added in the configuration file without accompanied by &lt;code&gt;--cluster-store&lt;/code&gt;. Configuration reload will log a warning message if it detects a change in previously configured cluster configurations.</source>
          <target state="translated">&lt;code&gt;--cluster-store&lt;/code&gt; , &lt;code&gt;--cluster-advertise&lt;/code&gt; 및 &lt;code&gt;--cluster-store-opts&lt;/code&gt; 와 같은 클러스터 구성을 업데이트하고 다시로드 하면 이러한 구성이 이전에 구성되지 않은 경우에만 적용됩니다. 경우 &lt;code&gt;--cluster-store&lt;/code&gt; 깃발에 제공되었습니다 &lt;code&gt;cluster-advertise&lt;/code&gt; 가 아닌 &lt;code&gt;cluster-advertise&lt;/code&gt; 동반하지 않고 구성 파일에 추가 할 수 있습니다 &lt;code&gt;--cluster-store&lt;/code&gt; . 구성 재로드는 이전에 구성된 클러스터 구성의 변경을 감지하면 경고 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="ea677af2fb98c0675157469393bd5642d926ce4e" translate="yes" xml:space="preserve">
          <source>Upgrade a machine to the latest version of Docker. How this upgrade happens depends on the underlying distribution used on the created instance.</source>
          <target state="translated">컴퓨터를 최신 버전의 Docker로 업그레이드하십시오. 이 업그레이드 방법은 생성 된 인스턴스에 사용 된 기본 배포에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bdfee709c2f9fb7d7171076e28564bb38fa8c240" translate="yes" xml:space="preserve">
          <source>Upgrade an existing plugin</source>
          <target state="translated">기존 플러그인 업그레이드</target>
        </trans-unit>
        <trans-unit id="32bda70aa6da7aaa0e9bd1a1d38d4bbd2ff95d95" translate="yes" xml:space="preserve">
          <source>Upgrades a machine&amp;rsquo;s Docker client to the latest stable release.</source>
          <target state="translated">머신의 Docker 클라이언트를 최신 안정 릴리스로 업그레이드합니다.</target>
        </trans-unit>
        <trans-unit id="2b69b9f62c0c07249da0d83c0ae7ea77234f2bb5" translate="yes" xml:space="preserve">
          <source>Upgrades an existing plugin to the specified remote plugin image. If no remote is specified, Docker will re-pull the current image and use the updated version. All existing references to the plugin will continue to work. The plugin must be disabled before running the upgrade.</source>
          <target state="translated">기존 플러그인을 지정된 원격 플러그인 이미지로 업그레이드합니다. 리모컨을 지정하지 않으면 Docker는 현재 이미지를 다시 가져 와서 업데이트 된 버전을 사용합니다. 플러그인에 대한 모든 기존 참조는 계속 작동합니다. 업그레이드를 실행하기 전에 플러그인을 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7dd3a1d8ed51cf30314c15a934d4cae0718aa5a" translate="yes" xml:space="preserve">
          <source>Upgrading</source>
          <target state="translated">Upgrading</target>
        </trans-unit>
        <trans-unit id="0b1f162d934e37feddeb26ec08f036d482d14382" translate="yes" xml:space="preserve">
          <source>Upload your tagged image to the repository:</source>
          <target state="translated">태그 된 이미지를 저장소에 업로드하십시오.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="c2ac3dbd9c530343e798461493e951b54a086fab" translate="yes" xml:space="preserve">
          <source>Usage is &lt;code&gt;docker-machine provision [name]&lt;/code&gt;. Multiple names may be specified.</source>
          <target state="translated">사용법은 &lt;code&gt;docker-machine provision [name]&lt;/code&gt; 입니다. 여러 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3151ec063ef31c929aeedd9ce89b0b6124d4cb03" translate="yes" xml:space="preserve">
          <source>Usage of these namespaces will now cause a warning in the engine logs to discourage their use, and will error instead in 18.12 and above.</source>
          <target state="translated">이러한 네임 스페이스를 사용하면 엔진 로그에 경고 메시지가 표시되어 사용이 중단되고 대신 18.12 이상에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aae61d2ab13222bcf0d992536069eedf4e875a7f" translate="yes" xml:space="preserve">
          <source>Usage: docker-machine help &lt;em&gt;subcommand&lt;/em&gt;</source>
          <target state="translated">사용법 : docker-machine help &lt;em&gt;하위 명령&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ade217654e96682c6936528cf07556044eb4629b" translate="yes" xml:space="preserve">
          <source>Use &amp;lsquo;-&amp;lsquo; as the source to read a tar archive from stdin and extract it to a directory destination in a container. Use &amp;lsquo;-&amp;lsquo; as the destination to stream a tar archive of a container source to stdout.</source>
          <target state="translated">stdin에서 tar 아카이브를 읽고 컨테이너의 디렉토리 대상으로 추출하려면 소스로 '-'를 사용하십시오. 컨테이너 소스의 tar 아카이브를 stdout으로 스트리밍하려면 대상으로 '-'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="acfaca703671d9314f0d44e4bca78597e85216fe" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-f&lt;/code&gt; to specify name and path of one or more Compose files</source>
          <target state="translated">하나 이상의 작성 파일의 이름과 경로를 지정 하려면 &lt;code&gt;-f&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="16268d9af9596674a4cc624b627c81ed692f2eae" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-p&lt;/code&gt; to specify a project name</source>
          <target state="translated">&lt;code&gt;-p&lt;/code&gt; 를 사용하여 프로젝트 이름을 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="30453a319d45031a1fc3e606ff4530b3c2a57a0a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker attach&lt;/code&gt; to attach your terminal&amp;rsquo;s standard input, output, and error (or any combination of the three) to a running container using the container&amp;rsquo;s ID or name. This allows you to view its ongoing output or to control it interactively, as though the commands were running directly in your terminal.</source>
          <target state="translated">사용 &lt;code&gt;docker attach&lt;/code&gt; 컨테이너의 ID 또는 이름을 사용하여 실행중인 컨테이너 터미널의 표준 입력, 출력 및 오류 (또는 세 가지의 조합)를 첨부 할 수 있습니다. 이를 통해 명령이 터미널에서 직접 실행되는 것처럼 진행중인 출력을 보거나 대화식으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32ae1a602f2feb2d7ed4bebbe3d05a699b294ea6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker events&lt;/code&gt; to get real-time events from the server. These events differ per Docker object type.</source>
          <target state="translated">&lt;code&gt;docker events&lt;/code&gt; 를 사용 하여 서버에서 실시간 이벤트 를 가져옵니다. 이러한 이벤트는 Docker 객체 유형마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f9f7934ba4146e78e621a477b06c0975149e0de0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker node ls&lt;/code&gt; to list the nodes in your swarm.</source>
          <target state="translated">&lt;code&gt;docker node ls&lt;/code&gt; 를 사용 하여 swarm의 노드를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="03689b49c1899a2c527051b8920fdb567dc62d7f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker push&lt;/code&gt; to share your images to the &lt;a href=&quot;https://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt; registry or to a self-hosted one.</source>
          <target state="translated">&lt;code&gt;docker push&lt;/code&gt; 를 사용 하여 이미지를 &lt;a href=&quot;https://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt; 레지스트리 또는 자체 호스팅 된 이미지와 공유하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae2bdf7a631236e465128f006eef30098b68b88e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker run&lt;/code&gt; to download and run &lt;code&gt;busybox&lt;/code&gt; with a simple &amp;lsquo;echo&amp;rsquo; command.</source>
          <target state="translated">&lt;code&gt;docker run&lt;/code&gt; 을 사용 하여 간단한 'echo'명령으로 &lt;code&gt;busybox&lt;/code&gt; 를 다운로드하고 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7556093f31cca79189c0be3927abee22d21e1989" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker service ls&lt;/code&gt; to list services.</source>
          <target state="translated">&lt;code&gt;docker service ls&lt;/code&gt; 를 사용 하여 서비스를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="ea784c14a45c0350a53d8416dd45872d3eb1ba07" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker service ps &amp;lt;service&amp;gt;&lt;/code&gt; to view tasks for a service.</source>
          <target state="translated">&lt;code&gt;docker service ps &amp;lt;service&amp;gt;&lt;/code&gt; 를 사용 하여 서비스 작업을 봅니다.</target>
        </trans-unit>
        <trans-unit id="ac955ce3b6a30c88a784f5bf823a3d2e6557a92d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker system events&lt;/code&gt; to get real-time events from the server. These events differ per Docker object type.</source>
          <target state="translated">&lt;code&gt;docker system events&lt;/code&gt; 를 사용 하여 서버에서 실시간 이벤트 를 가져옵니다. 이러한 이벤트는 Docker 객체 유형마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fd34589e99c142baae92d1eac9d3d2b649ea1832" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;docker-machine ls&lt;/code&gt; to list available machines.</source>
          <target state="translated">&lt;code&gt;docker-machine ls&lt;/code&gt; 를 사용 하여 사용 가능한 기계를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="cb8529692f874fe03372e946062d850ada3f8628" translate="yes" xml:space="preserve">
          <source>Use Compose in production</source>
          <target state="translated">프로덕션에서 작성 사용</target>
        </trans-unit>
        <trans-unit id="7d296dde124e24f2fd937438072ae9212da21a79" translate="yes" xml:space="preserve">
          <source>Use Compose with Swarm</source>
          <target state="translated">Swarm과 함께 작성 사용</target>
        </trans-unit>
        <trans-unit id="637a5b732cb05bf1fd103fcaeb123d167d684fee" translate="yes" xml:space="preserve">
          <source>Use Docker Desktop for Mac or Docker Desktop for Windows</source>
          <target state="translated">Mac 용 Docker Desktop 또는 Windows 용 Docker Desktop 사용</target>
        </trans-unit>
        <trans-unit id="001572ca20f53ccbdba5e1c6edddc939c2e2c2f8" translate="yes" xml:space="preserve">
          <source>Use Docker Engine plugins</source>
          <target state="translated">Docker Engine 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="9adae32b001f8d2b6e261e8b53c8e27ce7bd5ee3" translate="yes" xml:space="preserve">
          <source>Use Docker Machine to provision hosts on cloud providers</source>
          <target state="translated">Docker Machine을 사용하여 클라우드 제공 업체에서 호스트 제공</target>
        </trans-unit>
        <trans-unit id="3b22faf4bc50897d7976f7db8ac512a6a8d420cc" translate="yes" xml:space="preserve">
          <source>Use Docker&amp;rsquo;s &lt;code&gt;--restart&lt;/code&gt; to specify a container&amp;rsquo;s &lt;em&gt;restart policy&lt;/em&gt;. A restart policy controls whether the Docker daemon restarts a container after exit. Docker supports the following restart policies:</source>
          <target state="translated">Docker의 &lt;code&gt;--restart&lt;/code&gt; 를 사용하여 컨테이너의 &lt;em&gt;재시작 정책&lt;/em&gt; 을 지정하십시오 . 재시작 정책은 Docker 데몬이 종료 후 컨테이너를 다시 시작할지 여부를 제어합니다. Docker는 다음 재시작 정책을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="174d82d043fec4ac0fdfbe18457b74fc391e1ed3" translate="yes" xml:space="preserve">
          <source>Use Machine to provision Docker Swarm clusters</source>
          <target state="translated">머신을 사용하여 Docker Swarm 클러스터 프로비저닝</target>
        </trans-unit>
        <trans-unit id="359bc9458b99f4681988a96aae6ea846c44f4964" translate="yes" xml:space="preserve">
          <source>Use Machine to run Docker containers</source>
          <target state="translated">Machine을 사용하여 Docker 컨테이너를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ed92211baf1ffddd526d016a1df6aa1a225d6573" translate="yes" xml:space="preserve">
          <source>Use OpenSSL&amp;rsquo;s &lt;code&gt;genrsa&lt;/code&gt; and &lt;code&gt;req&lt;/code&gt; commands to first generate an RSA key and then use the key to create the certificate.</source>
          <target state="translated">OpenSSL의 &lt;code&gt;genrsa&lt;/code&gt; 및 &lt;code&gt;req&lt;/code&gt; 명령을 사용하여 먼저 RSA 키를 생성 한 다음이 키를 사용하여 인증서를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bf7327183c3a0e035e7a7c5b80946a423e90cda0" translate="yes" xml:space="preserve">
          <source>Use RAW and PACKET sockets.</source>
          <target state="translated">RAW 및 PACKET 소켓을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c3074ad4def7c64a835cc292cab058aec86c1ab" translate="yes" xml:space="preserve">
          <source>Use Secrets in Compose</source>
          <target state="translated">작성시 비밀 사용</target>
        </trans-unit>
        <trans-unit id="48528022e4248d2f55bcd808a0dc1326930247db" translate="yes" xml:space="preserve">
          <source>Use a .dockerignore file</source>
          <target state="translated">.dockerignore 파일 사용</target>
        </trans-unit>
        <trans-unit id="48248fe50a7c367fc775256731e26cb00bee92d0" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;-f&lt;/code&gt; with &lt;code&gt;-&lt;/code&gt; (dash) as the filename to read the configuration from &lt;code&gt;stdin&lt;/code&gt;. When &lt;code&gt;stdin&lt;/code&gt; is used all paths in the configuration are relative to the current working directory.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 에서 구성을 읽으려면 파일 이름으로 &lt;code&gt;-&lt;/code&gt; (대시) 와 함께 &lt;code&gt;-f&lt;/code&gt; 를 사용하십시오 . 때 &lt;code&gt;stdin&lt;/code&gt; 사용되는 구성의 모든 경로는 현재 작업 디렉토리를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="98a8def7026b7602afa813d98fa33248634e9e79" translate="yes" xml:space="preserve">
          <source>Use a Yubikey</source>
          <target state="translated">Yubikey 사용</target>
        </trans-unit>
        <trans-unit id="b59e5dc79d1b6bf0f4e3f7144a5e471734c74f88" translate="yes" xml:space="preserve">
          <source>Use a custom checkpoint storage directory</source>
          <target state="translated">사용자 정의 체크 포인트 스토리지 디렉토리 사용</target>
        </trans-unit>
        <trans-unit id="1720454a8652d1dc9faafdd9f8fb92ea0b4b5354" translate="yes" xml:space="preserve">
          <source>Use a custom parent cgroup (--cgroup-parent)</source>
          <target state="translated">사용자 정의 상위 cgroup 사용 (--cgroup-parent)</target>
        </trans-unit>
        <trans-unit id="58a10d596bba7605c6f0efd0b4d6b21b4fa69fbd" translate="yes" xml:space="preserve">
          <source>Use a pre-existing network</source>
          <target state="translated">기존 네트워크 사용</target>
        </trans-unit>
        <trans-unit id="8c79748c9edf83adbb3b606e609a94e3458fa9a1" translate="yes" xml:space="preserve">
          <source>Use a tool such as &lt;a href=&quot;https://github.com/vishnubob/wait-for-it&quot;&gt;wait-for-it&lt;/a&gt;, &lt;a href=&quot;https://github.com/jwilder/dockerize&quot;&gt;dockerize&lt;/a&gt;, or sh-compatible &lt;a href=&quot;https://github.com/Eficode/wait-for&quot;&gt;wait-for&lt;/a&gt;. These are small wrapper scripts which you can include in your application&amp;rsquo;s image to poll a given host and port until it&amp;rsquo;s accepting TCP connections.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vishnubob/wait-for-it&quot;&gt;wait-for-it&lt;/a&gt; , &lt;a href=&quot;https://github.com/jwilder/dockerize&quot;&gt;dockerize&lt;/a&gt; 또는 sh-compatible &lt;a href=&quot;https://github.com/Eficode/wait-for&quot;&gt;wait-for&lt;/a&gt; 와 같은 도구를 사용하십시오 . 이들은 작은 래퍼 스크립트로, 애플리케이션의 이미지에 포함되어 TCP 연결을 수락 할 때까지 지정된 호스트와 포트를 폴링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fa2be3beb3dc655e8f5fc051a4e02730bd7cd29" translate="yes" xml:space="preserve">
          <source>Use aa-status</source>
          <target state="translated">상태 사용</target>
        </trans-unit>
        <trans-unit id="704c5d2c7895567ef561484c2e59e3a1cf3344e9" translate="yes" xml:space="preserve">
          <source>Use acct(2), switch process accounting on or off.</source>
          <target state="translated">acct (2)를 사용하고 프로세스 계정을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="a660e4635ab6e63fd1be778338e2b8b36d475644" translate="yes" xml:space="preserve">
          <source>Use an init inside each service container to forward signals and reap processes</source>
          <target state="translated">각 서비스 컨테이너 내부에 init를 사용하여 신호를 전달하고 프로세스를 거두십시오.</target>
        </trans-unit>
        <trans-unit id="b50b2cf70b2d83f79229c09fc3ef0e29f87a5e01" translate="yes" xml:space="preserve">
          <source>Use chroot(2), change root directory.</source>
          <target state="translated">chroot (2)를 사용하여 루트 디렉토리를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e6a892e41b6b6a1587634b036daf718c22128bd0" translate="yes" xml:space="preserve">
          <source>Use container linking</source>
          <target state="translated">컨테이너 연결 사용</target>
        </trans-unit>
        <trans-unit id="a5e1f1c77d985e4e8c40b0b1169b871bd283fdcd" translate="yes" xml:space="preserve">
          <source>Use daemon&amp;rsquo;s default.</source>
          <target state="translated">데몬의 기본값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="16c01db1d657ab3dad2d84f58ad39c888ac731fc" translate="yes" xml:space="preserve">
          <source>Use delegations with content trust</source>
          <target state="translated">콘텐츠 신뢰에 위임 사용</target>
        </trans-unit>
        <trans-unit id="234fb961bdf7b193691751e209ba4b8ebaba3ded" translate="yes" xml:space="preserve">
          <source>Use dmesg</source>
          <target state="translated">dmesg 사용</target>
        </trans-unit>
        <trans-unit id="f0f39a437e7503292444c2a00a7301655cd39f0c" translate="yes" xml:space="preserve">
          <source>Use external Dockerfile implementations with many new features</source>
          <target state="translated">많은 새로운 기능으로 외부 Dockerfile 구현 사용</target>
        </trans-unit>
        <trans-unit id="30a90f68bb63ada8001c0ff7cfb7d7037f9327de" translate="yes" xml:space="preserve">
          <source>Use network driver plugins</source>
          <target state="translated">네트워크 드라이버 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="8699f8548f593bff8c21adf9fee280f6caac8e3e" translate="yes" xml:space="preserve">
          <source>Use one of two methods to unset DOCKER environment variables in the current shell.</source>
          <target state="translated">현재 쉘에서 DOCKER 환경 변수를 설정 해제하려면 두 가지 방법 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e4dba9754ba1336f2a6a7e2067e95e71871b143" translate="yes" xml:space="preserve">
          <source>Use placement constraints to control the nodes a service can be assigned to. In the following example, the service only runs on nodes with the &lt;a href=&quot;../manage-nodes/index#add-or-remove-label-metadata&quot;&gt;label&lt;/a&gt;&lt;code&gt;region&lt;/code&gt; set to &lt;code&gt;east&lt;/code&gt;. If no appropriately-labelled nodes are available, tasks will wait in &lt;code&gt;Pending&lt;/code&gt; until they become available. The &lt;code&gt;--constraint&lt;/code&gt; flag uses an equality operator (&lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;). For replicated services, it is possible that all services run on the same node, or each node only runs one replica, or that some nodes don&amp;rsquo;t run any replicas. For global services, the service runs on every node that meets the placement constraint and any &lt;a href=&quot;#reserve-memory-or-cpus-for-a-service&quot;&gt;resource requirements&lt;/a&gt;.</source>
          <target state="translated">배치 제한 조건을 사용하여 서비스를 지정할 수있는 노드를 제어하십시오. 다음 예제에서 서비스는 &lt;a href=&quot;../manage-nodes/index#add-or-remove-label-metadata&quot;&gt;레이블 &lt;/a&gt; &lt;code&gt;region&lt;/code&gt; 이 &lt;code&gt;east&lt;/code&gt; 로 설정된 노드에서만 실행됩니다 . 적절하게 레이블이 지정된 노드가 없으면 작업 이 사용 가능해질 때까지 &lt;code&gt;Pending&lt;/code&gt; 합니다. &lt;code&gt;--constraint&lt;/code&gt; 플래그는 항등 연산자를 사용하여 ( &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; ). 복제 된 서비스의 경우 모든 서비스가 동일한 노드에서 실행되거나 각 노드가 하나의 복제본 만 실행하거나 일부 노드가 복제본을 실행하지 않을 수 있습니다. 글로벌 서비스의 경우 서비스는 배치 제한 조건 및 모든 &lt;a href=&quot;#reserve-memory-or-cpus-for-a-service&quot;&gt;자원 요구 사항&lt;/a&gt; 을 충족시키는 모든 노드에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="326ab8f4511376235f1dbd378e46d2698e2b28e0" translate="yes" xml:space="preserve">
          <source>Use reboot(2) and kexec_load(2), reboot and load a new kernel for later execution.</source>
          <target state="translated">reboot (2) 및 kexec_load (2)를 사용하고 나중에 실행하기 위해 새 커널을 재부팅 한 후로드하십시오.</target>
        </trans-unit>
        <trans-unit id="e5618eafd4dd05f31d473a4f78be608423a345cb" translate="yes" xml:space="preserve">
          <source>Use swarm mode routing mesh</source>
          <target state="translated">스웜 모드 라우팅 메시 사용</target>
        </trans-unit>
        <trans-unit id="b14178d0abcc3f70d70b76c8f8c51f4baeb31def" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--from=&amp;lt;context-name&amp;gt;&lt;/code&gt; option to create a new context from an existing context. The example below creates a new context named &lt;code&gt;my-context&lt;/code&gt; from the existing context &lt;code&gt;existing-context&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;code&gt;--from=&amp;lt;context-name&amp;gt;&lt;/code&gt; 기존의 컨텍스트에서 새 컨텍스트를 만드는 옵션을 선택합니다. 아래 예제 는 기존 컨텍스트 &lt;code&gt;existing-context&lt;/code&gt; 에서 &lt;code&gt;my-context&lt;/code&gt; 라는 새 컨텍스트를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c75e17a597a9f98bdc7f30178d7e465deea89c08" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--label-file&lt;/code&gt; flag to load multiple labels from a file. Delimit each label in the file with an EOL mark. The example below loads labels from a labels file in the current directory:</source>
          <target state="translated">&lt;code&gt;--label-file&lt;/code&gt; 에서 여러 레이블을로드 하려면 --label-file 플래그를 사용하십시오 . 파일의 각 레이블을 EOL 표시로 구분하십시오. 아래 예제는 현재 디렉토리의 레이블 파일에서 레이블을로드합니다.</target>
        </trans-unit>
        <trans-unit id="ffdb2f7837c70c793374d6d4dd6b1f81affbe283" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--mount-add&lt;/code&gt; or &lt;code&gt;--mount-rm&lt;/code&gt; options add or remove a service&amp;rsquo;s bind mounts or volumes.</source>
          <target state="translated">사용 &lt;code&gt;--mount-add&lt;/code&gt; 또는 &lt;code&gt;--mount-rm&lt;/code&gt; 옵션을 추가하거나 서비스의 바인드 마운트 또는 볼륨을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4e1bb024450b33e2c748c988f372f1ad332e49de" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--network-add&lt;/code&gt; or &lt;code&gt;--network-rm&lt;/code&gt; flags to add or remove a network for a service. You can use the short or long syntax discussed in the &lt;a href=&quot;../service_create/index#attach-a-service-to-an-existing-network-network&quot;&gt;docker service create&lt;/a&gt; reference.</source>
          <target state="translated">서비스에 대한 네트워크를 추가하거나 제거 하려면 &lt;code&gt;--network-add&lt;/code&gt; 또는 &lt;code&gt;--network-rm&lt;/code&gt; 플래그를 사용하십시오. &lt;a href=&quot;../service_create/index#attach-a-service-to-an-existing-network-network&quot;&gt;docker service create&lt;/a&gt; reference 에서 논의 된 짧거나 긴 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de0b078b0dabec7c2a0bbf911163557990f3016c" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--no-trunc&lt;/code&gt; option to display the full network id:</source>
          <target state="translated">&lt;code&gt;--no-trunc&lt;/code&gt; 옵션을 사용하여 전체 네트워크 ID를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="20b344543604477bc1b6f7369d27ffb01b0926a8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--publish-add&lt;/code&gt; or &lt;code&gt;--publish-rm&lt;/code&gt; flags to add or remove a published port for a service. You can use the short or long syntax discussed in the &lt;a href=&quot;../service_create/index#publish-service-ports-externally-to-the-swarm&quot;&gt;docker service create&lt;/a&gt; reference.</source>
          <target state="translated">사용 &lt;code&gt;--publish-add&lt;/code&gt; 또는 &lt;code&gt;--publish-rm&lt;/code&gt; 추가하거나 서비스를 위해 게시 된 포트를 제거하는 플래그. &lt;a href=&quot;../service_create/index#publish-service-ports-externally-to-the-swarm&quot;&gt;docker service create&lt;/a&gt; reference 에서 논의 된 짧거나 긴 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52010d205ae94d19842df9d99ac3d34a4b9f5704" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--publish&lt;/code&gt; flag to publish a port when you create a service. &lt;code&gt;target&lt;/code&gt; is used to specify the port inside the container, and &lt;code&gt;published&lt;/code&gt; is used to specify the port to bind on the routing mesh. If you leave off the &lt;code&gt;published&lt;/code&gt; port, a random high-numbered port is bound for each service task. You need to inspect the task to determine the port.</source>
          <target state="translated">서비스를 만들 때 &lt;code&gt;--publish&lt;/code&gt; 플래그를 사용하여 포트를 게시하십시오. &lt;code&gt;target&lt;/code&gt; 은 컨테이너 내부의 포트를 지정하는 데 사용되며 &lt;code&gt;published&lt;/code&gt; 는 라우팅 메시에서 바인딩 할 포트를 지정하는 데 사용됩니다. &lt;code&gt;published&lt;/code&gt; 포트 를 벗어나면 각 서비스 작업에 대해 임의의 높은 번호의 포트가 바인딩됩니다. 포트를 확인하려면 작업을 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee107556cc8e9011ddd2ce4d424d96bdb11bac30" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--replicas-max-per-node&lt;/code&gt; flag to set the maximum number of replica tasks that can run on a node. The following command creates a nginx service with 2 replica tasks but only one replica task per node.</source>
          <target state="translated">사용 &lt;code&gt;--replicas-max-per-node&lt;/code&gt; 노드에서 실행할 수있는 복제 작업의 최대 수를 설정하는 플래그. 다음 명령은 2 개의 복제 작업이 있지만 노드 당 하나의 복제 작업 만있는 nginx 서비스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="10a61d7ce91549f60de8efa90b0f7398f6c6dfc6" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--replicas&lt;/code&gt; flag to set the number of replica tasks for a replicated service. The following command creates a &lt;code&gt;redis&lt;/code&gt; service with &lt;code&gt;5&lt;/code&gt; replica tasks:</source>
          <target state="translated">&lt;code&gt;--replicas&lt;/code&gt; 플래그를 사용하여 복제 된 서비스에 대한 복제 작업 수를 설정하십시오. 다음 명령은 &lt;code&gt;5&lt;/code&gt; 개의 복제본 작업 으로 &lt;code&gt;redis&lt;/code&gt; 서비스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c5b50957ff2a621b037d7ab8c60f657c24665cd6" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--rollback&lt;/code&gt; option to roll back to the previous version of the service.</source>
          <target state="translated">&lt;code&gt;--rollback&lt;/code&gt; 옵션을 사용하여 이전 버전의 서비스로 롤백 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfb033eca45fcbcc817520034c4d58ad4799f388" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--secret-add&lt;/code&gt; or &lt;code&gt;--secret-rm&lt;/code&gt; options add or remove a service&amp;rsquo;s secrets.</source>
          <target state="translated">사용 &lt;code&gt;--secret-add&lt;/code&gt; 또는 &lt;code&gt;--secret-rm&lt;/code&gt; 옵션을 추가 또는 서비스의 비밀을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0d9d0a97f4476884e9fb05e9599215245d6d766a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--secret&lt;/code&gt; flag to give a container access to a &lt;a href=&quot;../secret_create/index&quot;&gt;secret&lt;/a&gt;.</source>
          <target state="translated">컨테이너에 &lt;a href=&quot;../secret_create/index&quot;&gt;비밀에&lt;/a&gt; 대한 액세스 권한을 부여 하려면 &lt;code&gt;--secret&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a34d163686fbbea6ead4ca9ff627104eedb8ad61" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;--env&lt;/code&gt;, and &lt;code&gt;--env-file&lt;/code&gt; flags to set simple (non-array) environment variables in the container you&amp;rsquo;re running, or overwrite variables that are defined in the Dockerfile of the image you&amp;rsquo;re running.</source>
          <target state="translated">사용 &lt;code&gt;-e&lt;/code&gt; 를 , &lt;code&gt;--env&lt;/code&gt; 및 &lt;code&gt;--env-file&lt;/code&gt; 이미지의 Dockerfile에 정의 된 설정 단순 (비 배열) 실행중인 컨테이너에서 환경 변수 또는 덮어 쓰기 변수 플래그 당신이있는 거 실행 .</target>
        </trans-unit>
        <trans-unit id="1a7e81f19c501d66637064b74f32e8e856a2cf60" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;-f&lt;/code&gt; flag to specify the location of a Compose configuration file.</source>
          <target state="translated">사용 &lt;code&gt;-f&lt;/code&gt; 작성 구성 파일의 위치를 지정하는 플래그.</target>
        </trans-unit>
        <trans-unit id="876f9a0004ab69d3886014f3265d4483878ee784" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;device&lt;/code&gt; option to specify GPUs. The example below exposes a specific GPU.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; 옵션을 사용하여 GPU를 지정 하십시오 . 아래 예제는 특정 GPU를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bbdc154955bccd68c1a0e7c293ac8431187041fb" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;docker service rollback&lt;/code&gt; command to roll back to the previous version of a service. After executing this command, the service is reverted to the configuration that was in place before the most recent &lt;code&gt;docker service update&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;docker service rollback&lt;/code&gt; 명령을 사용하여 이전 버전의 서비스로 롤백 하십시오 . 이 명령을 실행 한 후 서비스는 가장 최근의 &lt;code&gt;docker service update&lt;/code&gt; 명령 이전에 있던 구성으로 되돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="6e749702c99f0387f69002427d23fdc0f0a10d64" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;docker trust inspect&lt;/code&gt; to get trust information about an image. The following example prints trust information for the &lt;code&gt;alpine:latest&lt;/code&gt; image:</source>
          <target state="translated">&lt;code&gt;docker trust inspect&lt;/code&gt; 를 사용하여 이미지에 대한 신뢰 정보를 얻습니다. 다음 예제는 &lt;code&gt;alpine:latest&lt;/code&gt; 이미지에 대한 신뢰 정보를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="c285cb03887b848800d51e790ac4d0e4ac89ba70" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;docker-machine&lt;/code&gt; command to interact with the migrated VM.</source>
          <target state="translated">사용 &lt;code&gt;docker-machine&lt;/code&gt; 마이그레이션 된 VM과 상호 작용하는 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b13aa8cf93154502f38eb246c739f261b0f74496" translate="yes" xml:space="preserve">
          <source>Use the Docker command line</source>
          <target state="translated">Docker 명령 행 사용</target>
        </trans-unit>
        <trans-unit id="1ba239c7035c3af6b195b521af30dd908d81d00c" translate="yes" xml:space="preserve">
          <source>Use the Microsoft Hyper-V driver and reference the new virtual switch you created.</source>
          <target state="translated">Microsoft Hyper-V 드라이버를 사용하고 생성 한 새 가상 스위치를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac9d5ed2810beab3507f7e3a62ce58b2cede428d" translate="yes" xml:space="preserve">
          <source>Use the Notary client for advanced users</source>
          <target state="translated">고급 사용자를 위해 Notary 클라이언트 사용</target>
        </trans-unit>
        <trans-unit id="a768006dbfb9a7d171f8d1753d379ca0747e3e47" translate="yes" xml:space="preserve">
          <source>Use the container volumes</source>
          <target state="translated">컨테이너 볼륨 사용</target>
        </trans-unit>
        <trans-unit id="f651fb69cc7e68e5b9b635ae8abe36290000c1b5" translate="yes" xml:space="preserve">
          <source>Use the following Dockerfile:</source>
          <target state="translated">다음 Dockerfile을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="37129d3dfa011edb2e862ffb42aeaa12e1d86897" translate="yes" xml:space="preserve">
          <source>Use the following command to run &lt;code&gt;htop&lt;/code&gt; inside a container:</source>
          <target state="translated">컨테이너 내에서 &lt;code&gt;htop&lt;/code&gt; 을 실행하려면 다음 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b893fd57c4042d51b8b420d1e0549860cea98e6d" translate="yes" xml:space="preserve">
          <source>Use the following commands to build and run your Docker image:</source>
          <target state="translated">Docker 이미지를 빌드하고 실행하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9930b29080b4754fdada1a5aaf75b7c874575c47" translate="yes" xml:space="preserve">
          <source>Use the host system&amp;rsquo;s IPC namespace.</source>
          <target state="translated">호스트 시스템의 IPC 네임 스페이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="514054573ac52eebdb21e856f973bad73fb5f128" translate="yes" xml:space="preserve">
          <source>Use the host&amp;rsquo;s networking stack, or no networking. Equivalent to &lt;code&gt;docker run --net=host&lt;/code&gt; or &lt;code&gt;docker run --net=none&lt;/code&gt;. Only used if you use &lt;code&gt;docker stack&lt;/code&gt; commands. If you use the &lt;code&gt;docker-compose&lt;/code&gt; command, use &lt;a href=&quot;#network_mode&quot;&gt;network_mode&lt;/a&gt; instead.</source>
          <target state="translated">호스트의 네트워킹 스택을 사용하거나 네트워킹을 사용하지 않습니다. 상당 &lt;code&gt;docker run --net=host&lt;/code&gt; 또는 &lt;code&gt;docker run --net=none&lt;/code&gt; . &lt;code&gt;docker stack&lt;/code&gt; 명령 을 사용하는 경우에만 사용됩니다 . 당신이 사용하는 경우 &lt;code&gt;docker-compose&lt;/code&gt; 명령을 사용 &lt;a href=&quot;#network_mode&quot;&gt;network_mode&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="e8a9eb8d7d9acb13997e8a108e8a3ddbdb0a57cf" translate="yes" xml:space="preserve">
          <source>Use the host's network stack inside the container.</source>
          <target state="translated">컨테이너 내부에서 호스트의 네트워크 스택을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="327f2c9a9f6a1d79e424bbcde154274ec5ed1dec" translate="yes" xml:space="preserve">
          <source>Use the latest features without updating the daemon</source>
          <target state="translated">데몬을 업데이트하지 않고 최신 기능을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="b3762352234b8662124ebc9181c6d82898caccbc" translate="yes" xml:space="preserve">
          <source>Use the legacy &lt;code&gt;--link&lt;/code&gt; option</source>
          <target state="translated">레거시 &lt;code&gt;--link&lt;/code&gt; 옵션 사용</target>
        </trans-unit>
        <trans-unit id="bce298549ed8e659163cc54cf3988275fd21ea17" translate="yes" xml:space="preserve">
          <source>Use the network stack of another container, specified via its &lt;em&gt;name&lt;/em&gt; or &lt;em&gt;id&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;name&lt;/em&gt; 또는 &lt;em&gt;id&lt;/em&gt; 를 통해 지정된 다른 컨테이너의 네트워크 스택을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e580a5bd6389f679f4c278f2b6a5ecb3d207897" translate="yes" xml:space="preserve">
          <source>Use the same process, driver, and network switch to create the other nodes.</source>
          <target state="translated">동일한 프로세스, 드라이버 및 네트워크 스위치를 사용하여 다른 노드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f3434b4fc56cad13875912ee6e72ff485bbf8a47" translate="yes" xml:space="preserve">
          <source>Use the value specified by the Docker daemon&amp;rsquo;s &lt;code&gt;--exec-opt&lt;/code&gt; . If the &lt;code&gt;daemon&lt;/code&gt; does not specify an isolation technology, Microsoft Windows uses &lt;code&gt;process&lt;/code&gt; as its default value if the</source>
          <target state="translated">Docker 데몬의 &lt;code&gt;--exec-opt&lt;/code&gt; 에 지정된 값을 사용하십시오 . 경우 &lt;code&gt;daemon&lt;/code&gt; 절연 기술을 지정하지 않고, 마이크로 소프트 윈도우는 사용 &lt;code&gt;process&lt;/code&gt; 은 if 기본 값으로</target>
        </trans-unit>
        <trans-unit id="0cc19350b5f1e7b1ad499867a509c5f385eef9fd" translate="yes" xml:space="preserve">
          <source>Use the value specified by the Docker daemon&amp;rsquo;s &lt;code&gt;--exec-opt&lt;/code&gt; . If the &lt;code&gt;daemon&lt;/code&gt; does not specify an isolation technology, Microsoft Windows uses &lt;code&gt;process&lt;/code&gt; as its default value.</source>
          <target state="translated">Docker 데몬의 &lt;code&gt;--exec-opt&lt;/code&gt; 에 지정된 값을 사용하십시오 . 경우 &lt;code&gt;daemon&lt;/code&gt; 절연 기술을 지정하지 않고, 마이크로 소프트 윈도우는 사용 &lt;code&gt;process&lt;/code&gt; 기본 값으로.</target>
        </trans-unit>
        <trans-unit id="5dfd5f9f642283f788e74fbb1d1e2b4d7f1a8be0" translate="yes" xml:space="preserve">
          <source>Use the value specified by the Docker daemon&amp;rsquo;s &lt;code&gt;--exec-opt&lt;/code&gt; or system default (see below).</source>
          <target state="translated">Docker 데몬의 &lt;code&gt;--exec-opt&lt;/code&gt; 또는 시스템 기본값으로 지정된 값을 사용 하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="018046510371089545871813604e7dbb78763bb1" translate="yes" xml:space="preserve">
          <source>Use these links to read about specific commands, or continue to the &lt;a href=&quot;index#example-use-configs-with-a-service&quot;&gt;example about using configs with a service&lt;/a&gt;.</source>
          <target state="translated">이 링크를 사용하여 특정 명령에 대해 읽거나 &lt;a href=&quot;index#example-use-configs-with-a-service&quot;&gt;서비스와 함께 구성 사용&lt;/a&gt; 에 대한 예제를 계속하십시오 .</target>
        </trans-unit>
        <trans-unit id="75ceb9cf50d6148a3ee4b33ac9a7312fd9c30adc" translate="yes" xml:space="preserve">
          <source>Use these links to read about specific commands, or continue to the &lt;a href=&quot;index#example-use-secrets-with-a-service&quot;&gt;example about using secrets with a service&lt;/a&gt;.</source>
          <target state="translated">이 링크를 사용하여 특정 명령에 대해 읽거나 &lt;a href=&quot;index#example-use-secrets-with-a-service&quot;&gt;서비스와 함께 비밀을 사용&lt;/a&gt; 하는 예를 계속하십시오 .</target>
        </trans-unit>
        <trans-unit id="58481994a152b3db812528d8671b0e9f5ce419ed" translate="yes" xml:space="preserve">
          <source>Use this command to list the machines and get their IP addresses.</source>
          <target state="translated">기계를 나열하고 해당 IP 주소를 얻으려면이 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cfc5a04bd3ea798e5ddd8fc31ad4d9e84b0875d2" translate="yes" xml:space="preserve">
          <source>Use trusted images</source>
          <target state="translated">신뢰할 수있는 이미지 사용</target>
        </trans-unit>
        <trans-unit id="dc01c23ccc88ce7862c6a234f5c4fbc04d592094" translate="yes" xml:space="preserve">
          <source>Use vhangup(2); employ various privileged ioctl(2) operations on virtual terminals.</source>
          <target state="translated">vhangup (2)를 사용하십시오. 가상 터미널에서 다양한 특권 ioctl (2) 작업을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bd27e4bd20445b10ef5d06a502b3595abea0f1cd" translate="yes" xml:space="preserve">
          <source>Used to send or receive packets and for other socket operations. All &lt;code&gt;socket&lt;/code&gt; and &lt;code&gt;socketcall&lt;/code&gt; calls are blocked except communication domains &lt;code&gt;AF_UNIX&lt;/code&gt;, &lt;code&gt;AF_INET&lt;/code&gt;, &lt;code&gt;AF_INET6&lt;/code&gt;, &lt;code&gt;AF_NETLINK&lt;/code&gt;, and &lt;code&gt;AF_PACKET&lt;/code&gt;.</source>
          <target state="translated">패킷을 보내거나받는 데 사용되며 다른 소켓 작업에 사용됩니다. 모든 &lt;code&gt;socket&lt;/code&gt; 및 &lt;code&gt;socketcall&lt;/code&gt; 전화는 통신 도메인을 제외하고 차단 &lt;code&gt;AF_UNIX&lt;/code&gt; , &lt;code&gt;AF_INET&lt;/code&gt; , &lt;code&gt;AF_INET6&lt;/code&gt; , &lt;code&gt;AF_NETLINK&lt;/code&gt; 및 &lt;code&gt;AF_PACKET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="64389f7e1430a98666dbc2c914775241a45f7183" translate="yes" xml:space="preserve">
          <source>User &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">사용자 &lt;code&gt;string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e253405e8205a9cb9e7f7811ae794940498c8db6" translate="yes" xml:space="preserve">
          <source>User defined resources</source>
          <target state="translated">사용자 정의 리소스</target>
        </trans-unit>
        <trans-unit id="9a907a2a9e2d8f2282b25aa37fedd952420dd3fa" translate="yes" xml:space="preserve">
          <source>User guide</source>
          <target state="translated">사용자 설명서</target>
        </trans-unit>
        <trans-unit id="1cb847a3dac2278c559968ce9e503055d3b0533f" translate="yes" xml:space="preserve">
          <source>User memory constraints</source>
          <target state="translated">사용자 메모리 제약</target>
        </trans-unit>
        <trans-unit id="0675c398a043aa665f1c1d074d1409855793e386" translate="yes" xml:space="preserve">
          <source>User namespace known limitations</source>
          <target state="translated">사용자 네임 스페이스 알려진 제한 사항</target>
        </trans-unit>
        <trans-unit id="e0f19b270736e0387cabe617ca97938f825f7765" translate="yes" xml:space="preserve">
          <source>User namespace to use</source>
          <target state="translated">사용할 사용자 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="3715b2623594f3f7ac8d73b21f3fe3986d105759" translate="yes" xml:space="preserve">
          <source>User namespaces are an advanced feature and require coordination with other capabilities. For example, if volumes are mounted from the host, file ownership must be pre-arranged need read or write access to the volume contents.</source>
          <target state="translated">사용자 네임 스페이스는 고급 기능이며 다른 기능과의 조정이 필요합니다. 예를 들어, 볼륨이 호스트에서 마운트 된 경우, 파일 소유권은 볼륨 내용에 대한 읽기 또는 쓰기 액세스 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="118509abec5cd94fc68691eb9ce063c3307b62d8" translate="yes" xml:space="preserve">
          <source>User-Signed images</source>
          <target state="translated">사용자 서명 이미지</target>
        </trans-unit>
        <trans-unit id="9a39a1e1fc8652e6225162217608c6fcf374a4f8" translate="yes" xml:space="preserve">
          <source>User-defined network</source>
          <target state="translated">사용자 정의 네트워크</target>
        </trans-unit>
        <trans-unit id="84c29015de33e5d22422382a372caba5c58f8c01" translate="yes" xml:space="preserve">
          <source>Username</source>
          <target state="translated">Username</target>
        </trans-unit>
        <trans-unit id="bf5a7021b64be8a919a3c120bb534a35fb0a9737" translate="yes" xml:space="preserve">
          <source>Username or UID (format: &amp;lt;name|uid&amp;gt;[:&amp;lt;group|gid&amp;gt;])</source>
          <target state="translated">사용자 이름 또는 UID (형식 : &amp;lt;name | uid&amp;gt; [: &amp;lt;group | gid&amp;gt;])</target>
        </trans-unit>
        <trans-unit id="a1430319aa374eefa875903c3457ee55eeac660b" translate="yes" xml:space="preserve">
          <source>Username or UID (format: &lt;code&gt;&amp;lt;name|uid&amp;gt;[:&amp;lt;group|gid&amp;gt;]&lt;/code&gt;).</source>
          <target state="translated">사용자 이름 또는 UID (형식 : &lt;code&gt;&amp;lt;name|uid&amp;gt;[:&amp;lt;group|gid&amp;gt;]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="202ab825cb40f4e35914be9964fddef3eda84e79" translate="yes" xml:space="preserve">
          <source>Usernames and passwords</source>
          <target state="translated">사용자 이름과 비밀번호</target>
        </trans-unit>
        <trans-unit id="4dad39450b558c63572de43822f5c726ed8f0a68" translate="yes" xml:space="preserve">
          <source>Users are expected to take note of the list of deprecated features each release and plan their migration away from those features, and (if applicable) towards the replacement features as soon as possible.</source>
          <target state="translated">사용자는 각 릴리스에서 더 이상 사용되지 않는 기능 목록을 기록하고 해당 기능에서 멀어지고 가능한 빨리 교체 기능으로 마이그레이션을 계획해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6504d846f28edd7b99e0310477de017d5658a41" translate="yes" xml:space="preserve">
          <source>Userspace page fault handling, largely needed for process migration.</source>
          <target state="translated">프로세스 마이그레이션에 주로 필요한 사용자 공간 페이지 결함 처리</target>
        </trans-unit>
        <trans-unit id="487c1a086a7d5f34d804a55cdadb5431b8195301" translate="yes" xml:space="preserve">
          <source>Uses the volume &lt;code&gt;mydata&lt;/code&gt; to store the MySQL data, so that it persists across restarts to the &lt;code&gt;mysql&lt;/code&gt; service.</source>
          <target state="translated">&lt;code&gt;mydata&lt;/code&gt; 볼륨 을 사용하여 MySQL 데이터를 저장하므로 &lt;code&gt;mysql&lt;/code&gt; 서비스 를 다시 시작할 때에도 지속 됩니다.</target>
        </trans-unit>
        <trans-unit id="4b7fccb045203d94f8e30dbf5172045097ccab88" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-&lt;/code&gt; as the &lt;code&gt;SRC_PATH&lt;/code&gt; streams the contents of &lt;code&gt;STDIN&lt;/code&gt; as a tar archive. The command extracts the content of the tar to the &lt;code&gt;DEST_PATH&lt;/code&gt; in container&amp;rsquo;s filesystem. In this case, &lt;code&gt;DEST_PATH&lt;/code&gt; must specify a directory. Using &lt;code&gt;-&lt;/code&gt; as the &lt;code&gt;DEST_PATH&lt;/code&gt; streams the contents of the resource as a tar archive to &lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 를 &lt;code&gt;SRC_PATH&lt;/code&gt; 로 사용하면 &lt;code&gt;STDIN&lt;/code&gt; 의 내용이 tar 아카이브로 스트리밍 됩니다. 이 명령은 tar의 컨텐츠를 컨테이너 파일 시스템 의 &lt;code&gt;DEST_PATH&lt;/code&gt; 로 추출합니다 . 이 경우 &lt;code&gt;DEST_PATH&lt;/code&gt; 는 디렉토리를 지정해야합니다. 사용 &lt;code&gt;-&lt;/code&gt; 는 AS &lt;code&gt;DEST_PATH&lt;/code&gt; 가 에 tar 아카이브로 자원의 내용 스트림 &lt;code&gt;STDOUT&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7213dd66c162bd46f821b1d3520ef6e0eff91987" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;build&lt;/code&gt; together with &lt;a href=&quot;#image&quot;&gt;&lt;code&gt;image&lt;/code&gt;&lt;/a&gt; is not allowed. Attempting to do so results in an error.</source>
          <target state="translated">사용하여 &lt;code&gt;build&lt;/code&gt; 함께 &lt;a href=&quot;#image&quot;&gt; &lt;code&gt;image&lt;/code&gt; &lt;/a&gt; 허용되지 않습니다. 이렇게하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6353a5e8d38af3248c7ed0cfdcdf69d15d92f39d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;docker-machine&lt;/code&gt; commands, you can start, inspect, stop, and restart a managed host, upgrade the Docker client and daemon, and configure a Docker client to talk to your host.</source>
          <target state="translated">&lt;code&gt;docker-machine&lt;/code&gt; 명령을 사용 하여 관리 호스트를 시작, 검사, 중지 및 다시 시작하고 Docker 클라이언트 및 데몬을 업그레이드하고 호스트와 통신하도록 Docker 클라이언트를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e7d432dd8c1a4aa02d6db1bdfd5b49b04b31c5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;dockerfile&lt;/code&gt; together with &lt;a href=&quot;#image&quot;&gt;&lt;code&gt;image&lt;/code&gt;&lt;/a&gt; is not allowed. Attempting to do so results in an error.</source>
          <target state="translated">사용 &lt;code&gt;dockerfile&lt;/code&gt; 을 함께 &lt;a href=&quot;#image&quot;&gt; &lt;code&gt;image&lt;/code&gt; &lt;/a&gt; 허용되지 않습니다. 이렇게하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="21f55b220d2d250198a8a92e4efa305301559ca3" translate="yes" xml:space="preserve">
          <source>Using ARG variables</source>
          <target state="translated">ARG 변수 사용</target>
        </trans-unit>
        <trans-unit id="a25733219ecab6a5156ac9dd36a4d36d4e8d0710" translate="yes" xml:space="preserve">
          <source>Using Compose is basically a three-step process:</source>
          <target state="translated">작성 사용은 기본적으로 3 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="ffb0ce40d8c902505cc68bdb96138750e9c16bd4" translate="yes" xml:space="preserve">
          <source>Using DCT in an offline environment</source>
          <target state="translated">오프라인 환경에서 DCT 사용</target>
        </trans-unit>
        <trans-unit id="f1be6efbe8ebab50d868665850ab2d4d8c33698f" translate="yes" xml:space="preserve">
          <source>Using Docker Content Trust with a Remote UCP Cluster</source>
          <target state="translated">원격 UCP 클러스터와 함께 Docker Content Trust 사용</target>
        </trans-unit>
        <trans-unit id="6bbcbc36a30c9ceab9ec3c0a016895b501b3886d" translate="yes" xml:space="preserve">
          <source>Using Docker Trust to Generate Keys</source>
          <target state="translated">Docker Trust를 사용하여 키 생성</target>
        </trans-unit>
        <trans-unit id="18564a981f5e5336e7fa4c1eaa0a49266352464c" translate="yes" xml:space="preserve">
          <source>Using TLS and managing a CA is an advanced topic. Please familiarize yourself with OpenSSL, x509, and TLS before using it in production.</source>
          <target state="translated">TLS 사용 및 CA 관리는 고급 주제입니다. OpenSSL, x509 및 TLS를 프로덕션 환경에서 사용하기 전에 숙지하십시오.</target>
        </trans-unit>
        <trans-unit id="29d7902f47653a1d7e4ac5acd9f57c9a6d6812a8" translate="yes" xml:space="preserve">
          <source>Using Universal Control Plane&amp;rsquo;s Client Bundles</source>
          <target state="translated">범용 제어 플레인의 클라이언트 번들 사용</target>
        </trans-unit>
        <trans-unit id="150e9f9137f0817b9182f120d1190f3c847c432a" translate="yes" xml:space="preserve">
          <source>Using a &lt;a href=&quot;https://raft.github.io/raft.pdf&quot;&gt;Raft&lt;/a&gt; implementation, the managers maintain a consistent internal state of the entire swarm and all the services running on it. For testing purposes it is OK to run a swarm with a single manager. If the manager in a single-manager swarm fails, your services continue to run, but you need to create a new cluster to recover.</source>
          <target state="translated">관리자 는 &lt;a href=&quot;https://raft.github.io/raft.pdf&quot;&gt;Raft&lt;/a&gt; 구현을 사용 하여 전체 떼와 그 위에서 실행되는 모든 서비스의 일관된 내부 상태를 유지합니다. 테스트 목적으로 단일 관리자로 스웜을 실행하는 것이 좋습니다. 단일 관리자 떼의 관리자가 실패하면 서비스는 계속 실행되지만 복구 할 새 클러스터를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="474dc15f6523675b181c05db7a5e3fe1d69ccace" translate="yes" xml:space="preserve">
          <source>Using certificates for repository client verification</source>
          <target state="translated">저장소 클라이언트 확인을 위해 인증서 사용</target>
        </trans-unit>
        <trans-unit id="dcca70c7c2a9ce8bd728aafe0f4326d888cad94d" translate="yes" xml:space="preserve">
          <source>Using curl to debug plugin socket issues.</source>
          <target state="translated">curl을 사용하여 플러그인 소켓 문제를 디버그합니다.</target>
        </trans-unit>
        <trans-unit id="b8278295279aaa1b95d64c032ef52b057c0375f1" translate="yes" xml:space="preserve">
          <source>Using docker-runc to obtain logfiles and shell into the plugin.</source>
          <target state="translated">docker-runc를 사용하여 로그 파일과 플러그인을 플러그인으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="573f927e5781624d059f1015cc981ebc06b7f35e" translate="yes" xml:space="preserve">
          <source>Using multiple Compose files enables you to customize a Compose application for different environments or different workflows.</source>
          <target state="translated">여러 개의 작성 파일을 사용하면 환경이나 워크 플로우에 따라 작성 애플리케이션을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ca8e76e4798cfdae7c1cac2e836bad104ec775" translate="yes" xml:space="preserve">
          <source>Using multiple filters will be handled as a &lt;em&gt;AND&lt;/em&gt;; for example &lt;code&gt;--filter container=588a23dac085 --filter event=start&lt;/code&gt; will display events for container container 588a23dac085 &lt;em&gt;AND&lt;/em&gt; the event type is &lt;em&gt;start&lt;/em&gt;</source>
          <target state="translated">여러 필터를 사용하면 &lt;em&gt;AND&lt;/em&gt; 로 처리됩니다 . 예를 들면 &lt;code&gt;--filter container=588a23dac085 --filter event=start&lt;/code&gt; 컨테이너 용기 588a23dac085의 이벤트 표시 &lt;em&gt;AND&lt;/em&gt; 이벤트 유형이 &lt;em&gt;시작&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0eb3f8c495b124e83f4fdb773c68ac12e4834d88" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--cgroup-parent&lt;/code&gt; flag, you can pass a specific cgroup to run a container in. This allows you to create and manage cgroups on their own. You can define custom resources for those cgroups and put containers under a common parent group.</source>
          <target state="translated">&lt;code&gt;--cgroup-parent&lt;/code&gt; 플래그를 사용하면 특정 cgroup을 전달하여 컨테이너를 실행할 수 있습니다. 이렇게하면 cgroup을 자체적으로 만들고 관리 할 수 ​​있습니다. 해당 cgroup에 대한 사용자 지정 리소스를 정의하고 컨테이너를 공통 상위 그룹 아래에 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88003bd74a22a4eb29911529e2caa26fa2e33943" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--privileged&lt;/code&gt; mode flag on &lt;code&gt;docker run&lt;/code&gt; without also specifying &lt;code&gt;--userns=host&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--userns=host&lt;/code&gt; 를 지정하지 않고 &lt;code&gt;docker run&lt;/code&gt; 에서 &lt;code&gt;--privileged&lt;/code&gt; mode 플래그를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="cb95555c637eb63b10c173af092ba0840e912eb2" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--restart&lt;/code&gt; flag on Docker run you can specify a restart policy for how a container should or should not be restarted on exit.</source>
          <target state="translated">Docker run 에서 &lt;code&gt;--restart&lt;/code&gt; 플래그를 사용하면 종료시 컨테이너를 재시작해야하는 방법에 대한 재시작 정책을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbea4831f47b9328f9e31923e1c2058584d8aa40" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--ulimit&lt;/code&gt; option with &lt;code&gt;docker build&lt;/code&gt; will cause each build step&amp;rsquo;s container to be started using those &lt;a href=&quot;../run/index#set-ulimits-in-container-ulimit&quot;&gt;&lt;code&gt;--ulimit&lt;/code&gt; flag values&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker build&lt;/code&gt; 와 함께 &lt;code&gt;--ulimit&lt;/code&gt; 옵션을 사용 하면 각 빌드 단계의 컨테이너가 &lt;a href=&quot;../run/index#set-ulimits-in-container-ulimit&quot;&gt; &lt;code&gt;--ulimit&lt;/code&gt; &lt;/a&gt; 플래그 값을 사용하여 시작 됩니다 .</target>
        </trans-unit>
        <trans-unit id="faeed98db8d69f44e4b8b84af556fd9f03650ba5" translate="yes" xml:space="preserve">
          <source>Using the example above but a different &lt;code&gt;ENV&lt;/code&gt; specification you can create more useful interactions between &lt;code&gt;ARG&lt;/code&gt; and &lt;code&gt;ENV&lt;/code&gt; instructions:</source>
          <target state="translated">위의 예를 사용하지만 다른 &lt;code&gt;ENV&lt;/code&gt; 사양을 사용하면 &lt;code&gt;ARG&lt;/code&gt; 와 &lt;code&gt;ENV&lt;/code&gt; 명령어 간에보다 유용한 상호 작용을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0d689502a08159312ecb654a041bcd3635de33c" translate="yes" xml:space="preserve">
          <source>Using the routing mesh</source>
          <target state="translated">라우팅 메쉬 사용</target>
        </trans-unit>
        <trans-unit id="eab81e094af40964b3ef6c5a4c4d0b68f95cdfa4" translate="yes" xml:space="preserve">
          <source>Using the routing mesh may not be the right choice for your application if you need to make routing decisions based on application state or you need total control of the process for routing requests to your service&amp;rsquo;s tasks. To publish a service&amp;rsquo;s port directly on the node where it is running, use the &lt;code&gt;mode=host&lt;/code&gt; option to the &lt;code&gt;--publish&lt;/code&gt; flag.</source>
          <target state="translated">응용 프로그램 상태에 따라 라우팅을 결정해야하거나 요청을 서비스 작업으로 라우팅하는 프로세스를 완전히 제어해야하는 경우 라우팅 메시를 사용하는 것이 응용 프로그램에 적합하지 않을 수 있습니다. 서비스 포트가 실행중인 노드에 직접 서비스 포트를 게시하려면 &lt;code&gt;mode=host&lt;/code&gt; 옵션을 &lt;code&gt;--publish&lt;/code&gt; 플래그에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6848acf2229e6b1433fdbeca8c26c0cb10dbca9a" translate="yes" xml:space="preserve">
          <source>Using the same filter multiple times will be handled as a &lt;em&gt;OR&lt;/em&gt;; for example &lt;code&gt;--filter container=588a23dac085 --filter container=a8f7720b8c22&lt;/code&gt; will display events for container 588a23dac085 &lt;em&gt;OR&lt;/em&gt; container a8f7720b8c22</source>
          <target state="translated">동일한 필터를 여러 번 사용하면 &lt;em&gt;OR&lt;/em&gt; 로 처리됩니다 . 예를 들어 &lt;code&gt;--filter container=588a23dac085 --filter container=a8f7720b8c22&lt;/code&gt; 는 컨테이너 588a23dac085 &lt;em&gt;또는&lt;/em&gt; 컨테이너 a8f7720b8c22에 대한 이벤트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="17e7379447ca9b4bbc15da3c0f555590087a6950" translate="yes" xml:space="preserve">
          <source>Using this Dockerfile example, &lt;code&gt;CONT_IMG_VER&lt;/code&gt; is still persisted in the image but its value would be &lt;code&gt;v1.0.0&lt;/code&gt; as it is the default set in line 3 by the &lt;code&gt;ENV&lt;/code&gt; instruction.</source>
          <target state="translated">이 Dockerfile 예를 사용하여, &lt;code&gt;CONT_IMG_VER&lt;/code&gt; 는 여전히 이미지의 지속되지만 그 값은 될 것 &lt;code&gt;v1.0.0&lt;/code&gt; 개발자 는에 의해 3 행에서 기본 설정되어 &lt;code&gt;ENV&lt;/code&gt; 의 명령.</target>
        </trans-unit>
        <trans-unit id="9546f8c33084c5412fed71eb5574764fbcd6409c" translate="yes" xml:space="preserve">
          <source>Using this flag will not alter the output you see when the &lt;code&gt;ARG&lt;/code&gt; lines from the Dockerfile are echoed during the build process.</source>
          <target state="translated">이 플래그를 사용해도 빌드 프로세스 중에 Dockerfile 의 &lt;code&gt;ARG&lt;/code&gt; 라인이 에코 될 때 표시되는 출력이 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2b59888e464af62259fbeaf603b0bae69e8075ca" translate="yes" xml:space="preserve">
          <source>Using this subsystem, you don&amp;rsquo;t need to rebuild the Docker daemon to add an authorization plugin. You can add a plugin to an installed Docker daemon. You do need to restart the Docker daemon to add a new plugin.</source>
          <target state="translated">이 서브 시스템을 사용하면 권한 플러그인을 추가하기 위해 Docker 데몬을 다시 빌드 할 필요가 없습니다. 설치된 Docker 데몬에 플러그인을 추가 할 수 있습니다. 새 플러그인을 추가하려면 Docker 데몬을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="1511ac65fb3c540e87d816a3aacb8ac11619d3d4" translate="yes" xml:space="preserve">
          <source>Usually, the manager can resolve the tag to a new digest and the service updates, redeploying each task to use the new image. If the manager can&amp;rsquo;t resolve the tag or some other problem occurs, the next two sections outline what to expect.</source>
          <target state="translated">일반적으로 관리자는 태그를 새 다이제스트 및 서비스 업데이트로 해결하여 새 이미지를 사용하도록 각 작업을 재배치 할 수 있습니다. 관리자가 태그를 해결할 수 없거나 다른 문제가 발생하면 다음 두 섹션에 예상되는 내용이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df12e6cdb701b48ea8d46489a50d537adf91c0f" translate="yes" xml:space="preserve">
          <source>VMs on your local machine (Mac, Linux, Windows 7 and 8)</source>
          <target state="translated">로컬 컴퓨터의 VM (Mac, Linux, Windows 7 및 8)</target>
        </trans-unit>
        <trans-unit id="26a1fc6bac6fb3a75465beee95f220edad8cb4ea" translate="yes" xml:space="preserve">
          <source>VMs on your local machine (Windows 10)</source>
          <target state="translated">로컬 컴퓨터의 VM (Windows 10)</target>
        </trans-unit>
        <trans-unit id="9aaa1b1f9336f067178a5191e0425fb86fa20f73" translate="yes" xml:space="preserve">
          <source>VMware Fusion</source>
          <target state="translated">VMware Fusion</target>
        </trans-unit>
        <trans-unit id="2af560d779fddcd338b6d73eda08fa5e82831652" translate="yes" xml:space="preserve">
          <source>VMware vCloud Air</source>
          <target state="translated">VMware vCloud Air</target>
        </trans-unit>
        <trans-unit id="d5083aaf63cd71d1c84271a3412c9f561638207b" translate="yes" xml:space="preserve">
          <source>VMware vSphere</source>
          <target state="translated">VMware vSphere</target>
        </trans-unit>
        <trans-unit id="b380e613c60d3e15e686ef62847eed4bf81a40c0" translate="yes" xml:space="preserve">
          <source>VMware vSphere Storage Plugin</source>
          <target state="translated">VMware vSphere 스토리지 플러그인</target>
        </trans-unit>
        <trans-unit id="de4f1aab58091db3e6fcebdda92e296c5013d16e" translate="yes" xml:space="preserve">
          <source>VOLUME</source>
          <target state="translated">VOLUME</target>
        </trans-unit>
        <trans-unit id="39e2325c591f732028a94290d78a45e63c85efd4" translate="yes" xml:space="preserve">
          <source>VOLUME (Shared Filesystems)</source>
          <target state="translated">볼륨 (공유 파일 시스템)</target>
        </trans-unit>
        <trans-unit id="e3a9804fdc1aac203568413f943fe260c54d2e27" translate="yes" xml:space="preserve">
          <source>VOLUME (shared filesystems)</source>
          <target state="translated">VOLUME (공유 파일 시스템)</target>
        </trans-unit>
        <trans-unit id="0503427c09caf2993b662c68e6d6edba046c6165" translate="yes" xml:space="preserve">
          <source>VPC Connectivity</source>
          <target state="translated">VPC 연결</target>
        </trans-unit>
        <trans-unit id="1598d5ccc97080807456f4cff34f0de4e9575114" translate="yes" xml:space="preserve">
          <source>VPC ID</source>
          <target state="translated">VPC ID</target>
        </trans-unit>
        <trans-unit id="7c427f9257d348810e376a747e4c5966fa5d518d" translate="yes" xml:space="preserve">
          <source>Valid placeholders for the Go template are listed below:</source>
          <target state="translated">Go 템플릿의 유효한 자리 표시자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c807ecd1a2c91fd0beabb0cda6844185d1910dfe" translate="yes" xml:space="preserve">
          <source>Valid placeholders for the Go template are:</source>
          <target state="translated">Go 템플릿에 유효한 자리 표시자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d425c92fc32058ef8970d49e1fe17ae8c88045d1" translate="yes" xml:space="preserve">
          <source>Validate and view the Compose file.</source>
          <target state="translated">작성 파일을 검증하고보십시오.</target>
        </trans-unit>
        <trans-unit id="3f9dfbc76de81860167420a20e547320994c7e7e" translate="yes" xml:space="preserve">
          <source>Validity period for node certificates (ns|us|ms|s|m|h)</source>
          <target state="translated">노드 인증서의 유효 기간 (ns | us | ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="e61387fe3032095762315b80cb30fc04faa695ac" translate="yes" xml:space="preserve">
          <source>Value of a specific label for this container. For example &lt;code&gt;'{{.Label &quot;com.docker.swarm.cpu&quot;}}'&lt;/code&gt;</source>
          <target state="translated">이 컨테이너의 특정 레이블 값입니다. 예를 들어 &lt;code&gt;'{{.Label &quot;com.docker.swarm.cpu&quot;}}'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70cb64d3a8ffdd190ffedce7535b1fec085a69fc" translate="yes" xml:space="preserve">
          <source>Value of a specific label for this network. For example &lt;code&gt;{{.Label &quot;project.version&quot;}}&lt;/code&gt;</source>
          <target state="translated">이 네트워크에 대한 특정 레이블의 값입니다. 예를 들어 &lt;code&gt;{{.Label &quot;project.version&quot;}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39f26e470187356c184843c3476aea4692e1d576" translate="yes" xml:space="preserve">
          <source>Value of a specific label for this secret. For example &lt;code&gt;{{.Label &quot;secret.ssh.key&quot;}}&lt;/code&gt;</source>
          <target state="translated">이 비밀에 대한 특정 레이블의 값입니다. 예를 들어 &lt;code&gt;{{.Label &quot;secret.ssh.key&quot;}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62efbe0c0e827cc408729b3faf370c8d49e6fa6b" translate="yes" xml:space="preserve">
          <source>Value of a specific label for this volume. For example &lt;code&gt;{{.Label &quot;project.version&quot;}}&lt;/code&gt;</source>
          <target state="translated">이 볼륨에 대한 특정 레이블의 값입니다. 예를 들어 &lt;code&gt;{{.Label &quot;project.version&quot;}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="897e8d96555f36916d5c8d4de8bb1038f12cbd44" translate="yes" xml:space="preserve">
          <source>Values in the shell take precedence over those specified in the &lt;code&gt;.env&lt;/code&gt; file. If you set &lt;code&gt;TAG&lt;/code&gt; to a different value in your shell, the substitution in &lt;code&gt;image&lt;/code&gt; uses that instead:</source>
          <target state="translated">셸의 값이 &lt;code&gt;.env&lt;/code&gt; 파일에 지정된 값보다 우선 합니다. 쉘에서 &lt;code&gt;TAG&lt;/code&gt; 를 다른 값으로 설정하면 &lt;code&gt;image&lt;/code&gt; 대체 는 다음을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="521b087d89ed4142ec58a969bbb2ec1d9d9194e9" translate="yes" xml:space="preserve">
          <source>Values present in the environment at runtime always override those defined inside the &lt;code&gt;.env&lt;/code&gt; file. Similarly, values passed via command-line arguments take precedence as well.</source>
          <target state="translated">런타임시 환경에 존재하는 값은 항상 &lt;code&gt;.env&lt;/code&gt; 파일에 정의 된 값보다 우선 합니다. 마찬가지로 명령 줄 인수를 통해 전달 된 값도 우선합니다.</target>
        </trans-unit>
        <trans-unit id="0bcb3f004c60573ec10519a012c0997b42c166ed" translate="yes" xml:space="preserve">
          <source>Values specified must fall within the range of valid &lt;code&gt;libdm&lt;/code&gt; log levels. At the time of writing, the following is the list of &lt;code&gt;libdm&lt;/code&gt; log levels as well as their corresponding levels when output by &lt;code&gt;dockerd&lt;/code&gt;.</source>
          <target state="translated">지정된 값은 유효한 &lt;code&gt;libdm&lt;/code&gt; 로그 수준 범위 내에 있어야합니다 . 글을 쓰는 시점에서, 다음의 목록입니다 &lt;code&gt;libdm&lt;/code&gt; 로그 수준뿐만 아니라 해당 레벨에 의해 출력 &lt;code&gt;dockerd&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="27399800b1113fffd2705de35e2951ae1e310377" translate="yes" xml:space="preserve">
          <source>Variable is not defined</source>
          <target state="translated">변수가 정의되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="translated">변수 치환</target>
        </trans-unit>
        <trans-unit id="effb0b04b40314fb1d7313704500d659d84c9510" translate="yes" xml:space="preserve">
          <source>Variables and moving a composition between environments</source>
          <target state="translated">환경 간 변수 및 구성 이동</target>
        </trans-unit>
        <trans-unit id="9cc5240a5eef09b3119be6653286e5d3a5706280" translate="yes" xml:space="preserve">
          <source>Variables starting with &lt;code&gt;DOCKER_&lt;/code&gt; are the same as those used to configure the Docker command-line client. If you&amp;rsquo;re using &lt;code&gt;docker-machine&lt;/code&gt;, then the &lt;code&gt;eval &quot;$(docker-machine env my-docker-vm)&quot;&lt;/code&gt; command should set them to their correct values. (In this example, &lt;code&gt;my-docker-vm&lt;/code&gt; is the name of a machine you created.)</source>
          <target state="translated">&lt;code&gt;DOCKER_&lt;/code&gt; 로 시작하는 변수 는 Docker 명령 행 클라이언트를 구성하는 데 사용 된 변수와 동일합니다. 당신이 사용하는 경우 &lt;code&gt;docker-machine&lt;/code&gt; , 그 &lt;code&gt;eval &quot;$(docker-machine env my-docker-vm)&quot;&lt;/code&gt; 명령이 올바른 값으로 설정해야합니다. (이 예에서 &lt;code&gt;my-docker-vm&lt;/code&gt; 은 생성 한 시스템의 이름입니다.)</target>
        </trans-unit>
        <trans-unit id="e239d005dd99d7234bb8679647a5242429d5295b" translate="yes" xml:space="preserve">
          <source>Vboxfs suffers from a &lt;a href=&quot;https://www.virtualbox.org/ticket/9069&quot;&gt;longstanding bug&lt;/a&gt; causing &lt;a href=&quot;http://linux.die.net/man/2/sendfile&quot;&gt;sendfile(2)&lt;/a&gt; to serve cached file contents.</source>
          <target state="translated">A로부터 Vboxfs을 겪고있다 &lt;a href=&quot;https://www.virtualbox.org/ticket/9069&quot;&gt;오랜 버그&lt;/a&gt; 의 원인 &lt;a href=&quot;http://linux.die.net/man/2/sendfile&quot;&gt;이 sendfile (2)&lt;/a&gt; 캐시 파일 내용을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb838a729db7e4b189f80f1af4af84fdbff76143" translate="yes" xml:space="preserve">
          <source>Vboxfs suffers from a &lt;a href=&quot;https://www.virtualbox.org/ticket/9069&quot;&gt;longstanding bug&lt;/a&gt; causing &lt;a href=&quot;https://linux.die.net/man/2/sendfile&quot;&gt;sendfile(2)&lt;/a&gt; to serve cached file contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e4edb0e72b9ff6e6cab5f904444edf5f91f829" translate="yes" xml:space="preserve">
          <source>Verbose output for diagnostics</source>
          <target state="translated">진단을위한 상세 출력</target>
        </trans-unit>
        <trans-unit id="a4e1fc87449af076692dd8cb44bddd456b73c65f" translate="yes" xml:space="preserve">
          <source>Verify Docker Engine is installed correctly by running &lt;code&gt;docker&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;docker&lt;/code&gt; 명령 을 실행하여 Docker Engine이 올바르게 설치되었는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="10e8a98c927de2f84da086dd61628f9e826ca916" translate="yes" xml:space="preserve">
          <source>Verify repository client with certificates</source>
          <target state="translated">인증서가있는 저장소 클라이언트 확인</target>
        </trans-unit>
        <trans-unit id="9841759b9ac4b9b220cecfe13d4390bb55f86313" translate="yes" xml:space="preserve">
          <source>Verify that WordPress works by browsing to http://localhost:30000/ on any swarm node again. Use the WordPress username and password from when you ran through the WordPress wizard in the previous task.</source>
          <target state="translated">swarm 노드에서 http : // localhost : 30000 /을 다시 찾아 WordPress가 작동하는지 확인하십시오. 이전 작업에서 WordPress 마법사를 실행했을 때의 WordPress 사용자 이름과 비밀번호를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="75683fbc78360bed4f4fa913b887ffba6c50afb3" translate="yes" xml:space="preserve">
          <source>Verify that a namespaced directory exists within &lt;code&gt;/var/lib/docker/&lt;/code&gt; named with the UID and GID of the namespaced user, owned by that UID and GID, and not group-or-world-readable. Some of the subdirectories are still owned by &lt;code&gt;root&lt;/code&gt; and have different permissions.</source>
          <target state="translated">네임 스페이스가있는 디렉토리가 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 내에 네임 스페이스가있는 사용자의 UID 및 GID로 이름이 지정되고 해당 UID 및 GID가 소유하며 그룹 또는 세계가 읽을 수없는 디렉토리에 있는지 확인하십시오 . 일부 서브 디렉토리는 여전히 &lt;code&gt;root&lt;/code&gt; 소유이며 다른 권한을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb126571c7633e331b62f2f0b88286eeed7a57fc" translate="yes" xml:space="preserve">
          <source>Verify that all your nodes are actively available.</source>
          <target state="translated">모든 노드가 사용 가능한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fe96c9a7de858ea0c7f972f855d689151f0a42a8" translate="yes" xml:space="preserve">
          <source>Verify that previous images are not available using the &lt;code&gt;docker image ls&lt;/code&gt; command. The output should be empty.</source>
          <target state="translated">&lt;code&gt;docker image ls&lt;/code&gt; 명령을 사용하여 이전 이미지를 사용할 수 없는지 확인하십시오 . 출력은 비어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2ede84198188ef3b202f8f4291c6ab04ab37a220" translate="yes" xml:space="preserve">
          <source>Verify that the &lt;code&gt;mysql&lt;/code&gt; container is running using the &lt;code&gt;docker service ls&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;docker service ls&lt;/code&gt; 명령을 사용하여 &lt;code&gt;mysql&lt;/code&gt; 컨테이너가 실행 중인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="97d81f04f6bd5339d72342d411ad96364c4afde4" translate="yes" xml:space="preserve">
          <source>Verify that the &lt;code&gt;nginx&lt;/code&gt; service is fully re-deployed, using &lt;code&gt;docker service ps nginx&lt;/code&gt;. When it is, you can remove the old &lt;code&gt;site.conf&lt;/code&gt; config.</source>
          <target state="translated">&lt;code&gt;docker service ps nginx&lt;/code&gt; 를 사용하여 &lt;code&gt;nginx&lt;/code&gt; 서비스가 완전히 재배치 되었는지 확인하십시오 . 이 경우 이전 &lt;code&gt;site.conf&lt;/code&gt; 구성을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd2f0fa3a988a4a4d81f297938bd8a1786b09005" translate="yes" xml:space="preserve">
          <source>Verify that the Nginx service is running.</source>
          <target state="translated">Nginx 서비스가 실행 중인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="58bb4effce2e90b5d7181c485ba1da349da5dd85" translate="yes" xml:space="preserve">
          <source>Verify that the blog post you wrote still exists, and if you changed any configuration values, verify that they are still changed.</source>
          <target state="translated">작성한 블로그 게시물이 여전히 존재하는지 확인하고 구성 값을 변경 한 경우 여전히 변경되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="72f215df400f6ddd80ea418d33ee12780957e790" translate="yes" xml:space="preserve">
          <source>Verify that the entry has been added to &lt;code&gt;/etc/subuid&lt;/code&gt; and &lt;code&gt;/etc/subgid&lt;/code&gt;:</source>
          <target state="translated">항목이 &lt;code&gt;/etc/subuid&lt;/code&gt; 및 &lt;code&gt;/etc/subgid&lt;/code&gt; 에 추가되었는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d17175d412b068d117e322b69f6a8810fb94984b" translate="yes" xml:space="preserve">
          <source>Verify that the secret is &lt;strong&gt;not&lt;/strong&gt; available if you commit the container.</source>
          <target state="translated">비밀이 있는지 확인 &lt;strong&gt;하지&lt;/strong&gt; 당신이 컨테이너를 위탁하는 경우 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ae88b312bf159a66f16531d2429c32b50d7fdf7a" translate="yes" xml:space="preserve">
          <source>Verify that the service is operational: you can reach the Nginx server, and that the correct TLS certificate is being used.</source>
          <target state="translated">서비스가 작동하는지 확인하십시오. Nginx 서버에 연결할 수 있고 올바른 TLS 인증서가 사용되고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="87dd3bf7f6327977fc668a24a9b0309bc62b4707" translate="yes" xml:space="preserve">
          <source>Verify that the state of the swarm is as expected. This may include application-specific tests or simply checking the output of &lt;code&gt;docker service ls&lt;/code&gt; to be sure that all expected services are present.</source>
          <target state="translated">떼의 상태가 예상대로인지 확인하십시오. 여기에는 응용 프로그램 별 테스트 또는 &lt;code&gt;docker service ls&lt;/code&gt; 출력을 단순히 확인하여 모든 예상 서비스가 있는지 확인하는 것이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59050bba180e19419fa3fe32ca1eb4d1fcc88d62" translate="yes" xml:space="preserve">
          <source>Verify that the task is running without issues using &lt;code&gt;docker service ps&lt;/code&gt;. If everything is working, the output looks similar to this:</source>
          <target state="translated">&lt;code&gt;docker service ps&lt;/code&gt; 사용하여 작업이 문제없이 실행되고 있는지 확인하십시오 . 모든 것이 작동하면 출력은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="060f5aa996cfb8f33b58584154e12d3e34d1f475" translate="yes" xml:space="preserve">
          <source>Verify that the volume was created successfully.</source>
          <target state="translated">볼륨이 성공적으로 작성되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a074e7f60903500a6bc31a4c82aa4f09de27088a" translate="yes" xml:space="preserve">
          <source>Verify the service is running using &lt;code&gt;docker service ls&lt;/code&gt; and &lt;code&gt;docker service ps&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;docker service ls&lt;/code&gt; 및 &lt;code&gt;docker service ps&lt;/code&gt; 명령을 사용하여 서비스가 실행 중인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="db3cbc01da600701b9fe4a497fe328e71fa7022f" translate="yes" xml:space="preserve">
          <source>Version 1</source>
          <target state="translated">버전 1</target>
        </trans-unit>
        <trans-unit id="bb58d3b6a37c4a866ee4ccee469b5707725652a8" translate="yes" xml:space="preserve">
          <source>Version 1 files cannot declare named &lt;a href=&quot;../index#volume-configuration-reference&quot;&gt;volumes&lt;/a&gt;, &lt;a href=&quot;../index#network-configuration-reference&quot;&gt;networks&lt;/a&gt; or &lt;a href=&quot;../index#args&quot;&gt;build arguments&lt;/a&gt;.</source>
          <target state="translated">버전 1 파일은 명명 된 &lt;a href=&quot;../index#volume-configuration-reference&quot;&gt;볼륨&lt;/a&gt; , &lt;a href=&quot;../index#network-configuration-reference&quot;&gt;네트워크&lt;/a&gt; 또는 &lt;a href=&quot;../index#args&quot;&gt;빌드 인수를&lt;/a&gt; 선언 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f65156b44d7d75e30447da365363273de1e0249d" translate="yes" xml:space="preserve">
          <source>Version 1 is supported by &lt;strong&gt;Compose up to 1.6.x&lt;/strong&gt;. It will be deprecated in a future Compose release.</source>
          <target state="translated">버전 1은 &lt;strong&gt;1.6.x까지 작성에&lt;/strong&gt; 의해 지원됩니다 . 향후 Compose 릴리스에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf2944d770dee8a8ddf0ec12b4ba2911650e817b" translate="yes" xml:space="preserve">
          <source>Version 1 to 2.x</source>
          <target state="translated">버전 1 ~ 2.x</target>
        </trans-unit>
        <trans-unit id="ed833ddaa491a9c3de776df53d58577dbceb2c22" translate="yes" xml:space="preserve">
          <source>Version 1 updates</source>
          <target state="translated">버전 1 업데이트</target>
        </trans-unit>
        <trans-unit id="df03c4691c0d3c0e461705e519187287600e5c7e" translate="yes" xml:space="preserve">
          <source>Version 1, the legacy format. This is specified by omitting a &lt;code&gt;version&lt;/code&gt; key at the root of the YAML.</source>
          <target state="translated">레거시 형식 인 버전 1 YAML 루트에서 &lt;code&gt;version&lt;/code&gt; 키를 생략하여 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="122332c273069bd6389c03468d93e9275f0c7d4d" translate="yes" xml:space="preserve">
          <source>Version 1.8.3 added a flag (&lt;code&gt;--disable-legacy-registry=false&lt;/code&gt;) which prevents the docker daemon from &lt;code&gt;pull&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, and &lt;code&gt;login&lt;/code&gt; operations against v1 registries. Though enabled by default, this signals the intent to deprecate the v1 protocol.</source>
          <target state="translated">버전 1.8.3 에는 docker 데몬이 v1 레지스트리에 대해 &lt;code&gt;pull&lt;/code&gt; , &lt;code&gt;push&lt;/code&gt; 및 &lt;code&gt;login&lt;/code&gt; 작업을 수행 하지 못하게 하는 플래그 ( &lt;code&gt;--disable-legacy-registry=false&lt;/code&gt; )가 추가되었습니다 . 기본적으로 활성화되어 있지만 v1 프로토콜을 폐기하려는 의도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57ce28f628abe360a4bb4a57891d0472e82ed0fe" translate="yes" xml:space="preserve">
          <source>Version 2</source>
          <target state="translated">버전 2</target>
        </trans-unit>
        <trans-unit id="6077300f49ef62cdcc5c287978e6d92d812dbde8" translate="yes" xml:space="preserve">
          <source>Version 2 files are supported by &lt;strong&gt;Compose 1.6.0+&lt;/strong&gt; and require a Docker Engine of version &lt;strong&gt;1.10.0+&lt;/strong&gt;.</source>
          <target state="translated">버전 2 파일은 &lt;strong&gt;Compose 1.6.0+에서&lt;/strong&gt; 지원되며 버전 &lt;strong&gt;1.10.0+&lt;/strong&gt; 의 Docker Engine이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="20f8d62cea934c59b43ef831f4f9a1e3758c033f" translate="yes" xml:space="preserve">
          <source>Version 2 updates</source>
          <target state="translated">버전 2 업데이트</target>
        </trans-unit>
        <trans-unit id="8870139b38dc6dbcc333e4720c5638bbcccaba57" translate="yes" xml:space="preserve">
          <source>Version 2.1</source>
          <target state="translated">버전 2.1</target>
        </trans-unit>
        <trans-unit id="e43c274ed1836390b89e98fe2af4aadc1ee8831c" translate="yes" xml:space="preserve">
          <source>Version 2.2</source>
          <target state="translated">버전 2.2</target>
        </trans-unit>
        <trans-unit id="3b990092a3cd719217a9e9bcd8bf065a916f5649" translate="yes" xml:space="preserve">
          <source>Version 2.3</source>
          <target state="translated">버전 2.3</target>
        </trans-unit>
        <trans-unit id="2eb307439b7ee3925eb3d57a7e7e158d89b63311" translate="yes" xml:space="preserve">
          <source>Version 2.4</source>
          <target state="translated">버전 2.4</target>
        </trans-unit>
        <trans-unit id="80b49fd47a38f255af92346f79ef69c0dc1b4360" translate="yes" xml:space="preserve">
          <source>Version 2.x to 3.x</source>
          <target state="translated">버전 2.x ~ 3.x</target>
        </trans-unit>
        <trans-unit id="1fa04ad3ce1f7e4a4eadb94c3e4ccc312eff244d" translate="yes" xml:space="preserve">
          <source>Version 2.x. This is specified with a &lt;code&gt;version: '2'&lt;/code&gt; or &lt;code&gt;version: '2.1'&lt;/code&gt;, etc., entry at the root of the YAML.</source>
          <target state="translated">버전 2.x. 이것은 &lt;code&gt;version: '2'&lt;/code&gt; 또는 &lt;code&gt;version: '2.1'&lt;/code&gt; 등으로 지정되며 YAML의 루트에있는 항목입니다.</target>
        </trans-unit>
        <trans-unit id="51867dd1effea73912f84dfad6c4579f1f4c10db" translate="yes" xml:space="preserve">
          <source>Version 3</source>
          <target state="translated">버전 3</target>
        </trans-unit>
        <trans-unit id="324f4d70180da4a8174554325ebbac7ec5300697" translate="yes" xml:space="preserve">
          <source>Version 3 no longer supports the &lt;code&gt;condition&lt;/code&gt; form of &lt;code&gt;depends_on&lt;/code&gt;.</source>
          <target state="translated">버전 3은 더 이상 &lt;code&gt;depends_on&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; 양식을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6a199670b9471077fb1bf2221a14c0255f156c53" translate="yes" xml:space="preserve">
          <source>Version 3 updates</source>
          <target state="translated">버전 3 업데이트</target>
        </trans-unit>
        <trans-unit id="f2397db59aec46b597b352dcef0dfe7c259c6d0d" translate="yes" xml:space="preserve">
          <source>Version 3.3</source>
          <target state="translated">버전 3.3</target>
        </trans-unit>
        <trans-unit id="dcba97985f57416d7e8bedd32b150e30a7a41165" translate="yes" xml:space="preserve">
          <source>Version 3.4</source>
          <target state="translated">버전 3.4</target>
        </trans-unit>
        <trans-unit id="10dd90c7115b6212ca538c46c8f3eacf1eceeb1f" translate="yes" xml:space="preserve">
          <source>Version 3.5</source>
          <target state="translated">버전 3.5</target>
        </trans-unit>
        <trans-unit id="86df59d4254b183fd39f197140f1c8c6e06c9758" translate="yes" xml:space="preserve">
          <source>Version 3.6</source>
          <target state="translated">버전 3.6</target>
        </trans-unit>
        <trans-unit id="e88e00b8980607020b94b99775ebecfdfa4850c7" translate="yes" xml:space="preserve">
          <source>Version 3.7</source>
          <target state="translated">버전 3.7</target>
        </trans-unit>
        <trans-unit id="7f3c743571fe3735a96b0e4d2408db7ec9d73d9a" translate="yes" xml:space="preserve">
          <source>Version 3.x, the latest and recommended version, designed to be cross-compatible between Compose and the Docker Engine&amp;rsquo;s &lt;a href=&quot;../../../engine/swarm/index&quot;&gt;swarm mode&lt;/a&gt;. This is specified with a &lt;code&gt;version: '3'&lt;/code&gt; or &lt;code&gt;version: '3.1'&lt;/code&gt;, etc., entry at the root of the YAML.</source>
          <target state="translated">버전 3.x, 작성 및 부두 노동자 엔진의 사이에 상호 호환되도록 설계 최신 권장 버전, &lt;a href=&quot;../../../engine/swarm/index&quot;&gt;떼 모드&lt;/a&gt; . 이것은 &lt;code&gt;version: '3'&lt;/code&gt; 또는 &lt;code&gt;version: '3.1'&lt;/code&gt; 등으로 지정되며 YAML의 루트에있는 항목입니다.</target>
        </trans-unit>
        <trans-unit id="2750d3223582565870adf32b96da562927d7229f" translate="yes" xml:space="preserve">
          <source>Versioning</source>
          <target state="translated">Versioning</target>
        </trans-unit>
        <trans-unit id="2e02a424231d4381be56926effaa6badd248c036" translate="yes" xml:space="preserve">
          <source>View or rotate the current swarm CA certificate. This command must target a manager node.</source>
          <target state="translated">현재 swarm CA 인증서를 보거나 회전시킵니다. 이 명령은 관리자 노드를 대상으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="a845082cf701467a055b98cbb669de360100171e" translate="yes" xml:space="preserve">
          <source>View the Rails welcome page!</source>
          <target state="translated">Rails 시작 페이지를보십시오!</target>
        </trans-unit>
        <trans-unit id="09b9771ffea47523c6ba5869b6625ca454b76e29" translate="yes" xml:space="preserve">
          <source>View the current unlock key for a running swarm</source>
          <target state="translated">실행중인 떼의 현재 잠금 해제 키를 봅니다.</target>
        </trans-unit>
        <trans-unit id="c0abc415461f90cc6a8a28d93b472ff7f39a0115" translate="yes" xml:space="preserve">
          <source>View the join command or update a swarm join token</source>
          <target state="translated">join 명령을 보거나 swarm join token을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="f49744e72cc31919ad8b19c47d00d3b6e6d30b8e" translate="yes" xml:space="preserve">
          <source>View the status of running services</source>
          <target state="translated">실행중인 서비스 상태보기</target>
        </trans-unit>
        <trans-unit id="3f6626acc3dc660439c707648a79e7db4aac07f4" translate="yes" xml:space="preserve">
          <source>View the web page running from a container</source>
          <target state="translated">컨테이너에서 실행중인 웹 페이지를 봅니다.</target>
        </trans-unit>
        <trans-unit id="bb57f07d3a6254b12cea719128c5aba500d0e7f4" translate="yes" xml:space="preserve">
          <source>Viewing local Delegation keys</source>
          <target state="translated">로컬 위임 키보기</target>
        </trans-unit>
        <trans-unit id="2fa1d5236b28ca97fb6fc3adef37744d4ba14107" translate="yes" xml:space="preserve">
          <source>Virtuozzo Storage and Ploop plugin</source>
          <target state="translated">Virtuozzo 스토리지 및 Ploop 플러그인</target>
        </trans-unit>
        <trans-unit id="88831eb06b9412a97982fb64468205454c230d47" translate="yes" xml:space="preserve">
          <source>Volume configuration reference</source>
          <target state="translated">볼륨 구성 참조</target>
        </trans-unit>
        <trans-unit id="3c0756ac991fb342e91b75bd22624c6d86c0f336" translate="yes" xml:space="preserve">
          <source>Volume driver</source>
          <target state="translated">볼륨 드라이버</target>
        </trans-unit>
        <trans-unit id="9665af7c3b742ca3077e709658c4e7c951357470" translate="yes" xml:space="preserve">
          <source>Volume name</source>
          <target state="translated">볼륨 이름</target>
        </trans-unit>
        <trans-unit id="c0092884648d18615968189067b6fed6c9de7b1b" translate="yes" xml:space="preserve">
          <source>Volume names must be unique among drivers. This means you cannot use the same volume name with two different drivers. If you attempt this &lt;code&gt;docker&lt;/code&gt; returns an error:</source>
          <target state="translated">볼륨 이름은 드라이버마다 고유해야합니다. 이것은 두 개의 다른 드라이버와 동일한 볼륨 이름을 사용할 수 없음을 의미합니다. 이 &lt;code&gt;docker&lt;/code&gt; 를 시도 하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="31c57b83b4e550bb5f96a03b2046b6972f611908" translate="yes" xml:space="preserve">
          <source>Volume plugin protocol</source>
          <target state="translated">볼륨 플러그인 프로토콜</target>
        </trans-unit>
        <trans-unit id="85a046085cfed4ab0fa9c85d4d2dd7f3174a535e" translate="yes" xml:space="preserve">
          <source>Volume plugins</source>
          <target state="translated">볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="21067741377749847fe1f9e53dce5548fcf9997f" translate="yes" xml:space="preserve">
          <source>Volume scope (local, global)</source>
          <target state="translated">볼륨 범위 (로컬, 글로벌)</target>
        </trans-unit>
        <trans-unit id="39c0ee03f2b53ddb768f449a18c7a3e41ad94f8f" translate="yes" xml:space="preserve">
          <source>Volumes</source>
          <target state="translated">Volumes</target>
        </trans-unit>
        <trans-unit id="abc3061eb5952fb8a4b3cad91c75b76f9e61e469" translate="yes" xml:space="preserve">
          <source>Volumes can be used in combination with &lt;code&gt;--read-only&lt;/code&gt; to control where a container writes files. The &lt;code&gt;--read-only&lt;/code&gt; flag mounts the container&amp;rsquo;s root filesystem as read only prohibiting writes to locations other than the specified volumes for the container.</source>
          <target state="translated">컨테이너가 파일을 쓰는 위치를 제어하기 위해 볼륨을 &lt;code&gt;--read-only&lt;/code&gt; 와 함께 사용할 수 있습니다 . &lt;code&gt;--read-only&lt;/code&gt; 플래그 마운트는 컨테이너의 루트 파일 시스템은 컨테이너의 지정된 볼륨이 아닌 다른 위치에 쓰기를 금지 읽기.</target>
        </trans-unit>
        <trans-unit id="b5186b04d0afdeb9be2bbb9fb690ba6f6f5d6981" translate="yes" xml:space="preserve">
          <source>Volumes for services, swarms, and stack files</source>
          <target state="translated">서비스, ​​스웜 및 스택 파일의 볼륨</target>
        </trans-unit>
        <trans-unit id="109e67e94a9376d209c22199abd046a5a471d987" translate="yes" xml:space="preserve">
          <source>WAKE_ALARM</source>
          <target state="translated">WAKE_ALARM</target>
        </trans-unit>
        <trans-unit id="9166d7e923bf094d59b59fec4ddb10b2a283f7a1" translate="yes" xml:space="preserve">
          <source>WORKDIR</source>
          <target state="translated">WORKDIR</target>
        </trans-unit>
        <trans-unit id="dfaf2322feaced79826007ad0371dc84b384a65b" translate="yes" xml:space="preserve">
          <source>Want to go deeper? Here are some resources we recommend:</source>
          <target state="translated">더 깊이 가고 싶습니까? 권장되는 리소스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f39dd51f9bc15001a0f9d2d234ed19ffe267d3ec" translate="yes" xml:space="preserve">
          <source>Warnings about kernel support</source>
          <target state="translated">커널 지원에 대한 경고</target>
        </trans-unit>
        <trans-unit id="4e0f7f0b80ff493cebce75c36d745c8e95c0ddf4" translate="yes" xml:space="preserve">
          <source>We are ready to build the app. Make sure you are still at the top level of your new directory. Here&amp;rsquo;s what &lt;code&gt;ls&lt;/code&gt; should show:</source>
          <target state="translated">앱을 만들 준비가되었습니다. 여전히 새 디렉토리의 최상위 레벨에 있는지 확인하십시오. &lt;code&gt;ls&lt;/code&gt; 가 보여 주어야 할 내용 은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="68a230a63865d2d95b4d9fd82339db44262aaf16" translate="yes" xml:space="preserve">
          <source>We can set cpus in which to allow execution for containers.</source>
          <target state="translated">컨테이너 실행을 허용 할 CPU를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="366da03560902580dd32dd32cf53443a4fff968a" translate="yes" xml:space="preserve">
          <source>We can set mems in which to allow execution for containers. Only effective on NUMA systems.</source>
          <target state="translated">컨테이너 실행을 허용하는 mems를 설정할 수 있습니다. NUMA 시스템에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="8d42da396ed9877f89a7ca74af37e36df79dc97a" translate="yes" xml:space="preserve">
          <source>We can verify that services were correctly created:</source>
          <target state="translated">서비스가 올바르게 생성되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77fe1afabbf062ff332a4cfaec62863a0318fcda" translate="yes" xml:space="preserve">
          <source>We could find that all layer&amp;rsquo;s name is &lt;code&gt;&amp;lt;missing&amp;gt;&lt;/code&gt;, and there is a new layer with COMMENT &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">모든 레이어의 이름이 &lt;code&gt;&amp;lt;missing&amp;gt;&lt;/code&gt; 이고 COMMENT &lt;code&gt;merge&lt;/code&gt; 인 새 레이어가 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c55e0cbc39b09229b62d43de855d726f33ad583" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t support completely reloading notary configuration files yet at present. What we support for now is:</source>
          <target state="translated">현재 공증 구성 파일을 완전히 다시로드하는 기능은 지원하지 않습니다. 우리가 지금 지원하는 것은 :</target>
        </trans-unit>
        <trans-unit id="81b3d9198cb26408c257b8a1b47b902a2ae41366" translate="yes" xml:space="preserve">
          <source>We have four ways to set user memory usage:</source>
          <target state="translated">사용자 메모리 사용을 설정하는 네 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b2bfb9b5a957c3c6e526c0dfc3dff9f35cd7865" translate="yes" xml:space="preserve">
          <source>We make it easy to build new containers, enable rapid iteration of your applications, and increase the visibility of changes. This helps everyone in your organization understand how an application works and how it is built.</source>
          <target state="translated">새로운 컨테이너를 쉽게 구축하고 애플리케이션을 신속하게 반복하며 변경 사항의 가시성을 높입니다. 이를 통해 조직의 모든 사람이 응용 프로그램 작동 방식 및 구축 방법을 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d490e6a744ded4f2ec028fcf00d4589d74673db0" translate="yes" xml:space="preserve">
          <source>We recommend against using &lt;code&gt;--compatibility&lt;/code&gt; mode in production. Because the resulting configuration is only an approximate using non-Swarm mode properties, it may produce unexpected results.</source>
          <target state="translated">프로덕션에서는 &lt;code&gt;--compatibility&lt;/code&gt; 모드를 사용하지 않는 것이 좋습니다 . 결과 구성은 비 Swarm 모드 속성을 사용하는 대략적인 것이므로 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c55648ee10e49e4276166a7b4464295934bcd5" translate="yes" xml:space="preserve">
          <source>We recommend keeping up-to-date with newer releases as much as possible. However, if you are using an older version of Docker and want to determine which Compose release is compatible, refer to the &lt;a href=&quot;https://github.com/docker/compose/releases/&quot;&gt;Compose release notes&lt;/a&gt;. Each set of release notes gives details on which versions of Docker Engine are supported, along with compatible Compose file format versions. (See also, the discussion in &lt;a href=&quot;https://github.com/docker/docker.github.io/issues/3404&quot;&gt;issue #3404&lt;/a&gt;.)</source>
          <target state="translated">가능한 한 최신 릴리스를 최신 상태로 유지하는 것이 좋습니다. 그러나 이전 버전의 Docker를 사용 중이고 호환 가능한 Compose 릴리스를 판별하려면 &lt;a href=&quot;https://github.com/docker/compose/releases/&quot;&gt;Compose 릴리스 정보를&lt;/a&gt; 참조하십시오 . 각 릴리스 정보 세트는 호환 가능한 Compose 파일 형식 버전과 함께 지원되는 Docker Engine 버전에 대한 세부 사항을 제공합니다. ( &lt;a href=&quot;https://github.com/docker/docker.github.io/issues/3404&quot;&gt;문제 # 3404&lt;/a&gt; 의 토론도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6bab6e6d3df1559fe3f24e9b8fda6afb65cc2539" translate="yes" xml:space="preserve">
          <source>We recommend that you rotate the join tokens in the following circumstances:</source>
          <target state="translated">다음과 같은 상황에서 조인 토큰을 교체하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1c393093ffe550f3d403cfefe135ef95bfe2f962" translate="yes" xml:space="preserve">
          <source>We recommend that you use reverse-DNS notation to prevent your labels from conflicting with those used by other software.</source>
          <target state="translated">레이블이 다른 소프트웨어에서 사용되는 레이블과 충돌하지 않도록 역 DNS 표기법을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6692fbf702ea9e455c8bff2ead6fed6b4611d2dd" translate="yes" xml:space="preserve">
          <source>We set both memory and swap memory, so the processes in the container can use 300M memory and 700M swap memory.</source>
          <target state="translated">메모리와 스왑 메모리를 모두 설정하므로 컨테이너의 프로세스는 300M 메모리와 700M 스왑 메모리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f98413083fe76cbf9cb8bf8325393b58bb1a5fc1" translate="yes" xml:space="preserve">
          <source>We set kernel memory without &lt;strong&gt;-m&lt;/strong&gt;, so the processes in the container can use as much memory as they want, but they can only use 50M kernel memory.</source>
          <target state="translated">커널 메모리를 &lt;strong&gt;-m&lt;/strong&gt; 없이 설정 하므로 컨테이너의 프로세스는 원하는만큼의 메모리를 사용할 수 있지만 50M 커널 메모리 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78fe8be15fe4635a85001408f1a9380dd741043a" translate="yes" xml:space="preserve">
          <source>We set memory and kernel memory, so the processes in the container can use 500M memory in total, in this 500M memory, it can be 50M kernel memory tops.</source>
          <target state="translated">우리는 메모리와 커널 메모리를 설정하므로 컨테이너의 프로세스는 총 500M 메모리를 사용할 수 있습니다.이 500M 메모리에서는 50M 커널 메모리가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe2b21bb29dd1e1ad672f339226dd1ad6f2b13ff" translate="yes" xml:space="preserve">
          <source>We set memory limit and disabled swap memory limit, this means the processes in the container can use 300M memory and as much swap memory as they need (if the host supports swap memory).</source>
          <target state="translated">메모리 제한을 설정하고 스왑 메모리 제한을 비활성화했습니다. 이는 컨테이너의 프로세스가 300M 메모리를 사용할 수 있고 필요한만큼의 스왑 메모리를 사용할 수 있음을 의미합니다 (호스트가 스왑 메모리를 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="40172fa41fb0b0bd89d66e2f441ed0b41a50445b" translate="yes" xml:space="preserve">
          <source>We set memory limit only, this means the processes in the container can use 300M memory and 300M swap memory, by default, the total virtual memory size (--memory-swap) will be set as double of memory, in this case, memory + swap would be 2*300M, so processes can use 300M swap memory as well.</source>
          <target state="translated">메모리 제한 만 설정합니다. 이는 컨테이너의 프로세스가 300M 메모리와 300M 스왑 메모리를 사용할 수 있음을 의미합니다. 기본적으로 총 가상 메모리 크기 (--memory-swap)는 메모리의 두 배로 설정됩니다. + 스왑은 2 * 300M이므로 프로세스는 300M 스왑 메모리도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2756003c44352b8b144da376d4c8094ab2bb4740" translate="yes" xml:space="preserve">
          <source>We set nothing about memory, this means the processes in the container can use as much memory and swap memory as they need.</source>
          <target state="translated">우리는 메모리에 대해 아무것도 설정하지 않았습니다. 이는 컨테이너의 프로세스가 필요한만큼의 메모리를 사용하고 메모리를 교환 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="74aa67367e9866d0758513576d456609d5644a70" translate="yes" xml:space="preserve">
          <source>We show you how to install a Certificate Authority (CA) root certificate for the registry and how to set the client TLS certificate for verification.</source>
          <target state="translated">레지스트리에 인증 기관 (CA) 루트 인증서를 설치하는 방법과 확인을 위해 클라이언트 TLS 인증서를 설정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4c2b89726dac3a78434ba0cfdbe1b2833535e2a1" translate="yes" xml:space="preserve">
          <source>We talk more about placement constraints and volumes in a moment.</source>
          <target state="translated">게재 위치 제약 조건 및 수량에 대해 더 자세히 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="e83fc7c486f90339b5bcb7a4af628cab560ffa7e" translate="yes" xml:space="preserve">
          <source>We use Amazon Web Services (AWS) as an example.</source>
          <target state="translated">AWS는 Amazon Web Services (AWS)를 예로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="755d8d9d60dd22ae6053cf7d3b6948028a166611" translate="yes" xml:space="preserve">
          <source>We want your environment to work better. Docker containers, and the work flow that comes with them, help your developers, sysadmins, QA folks, and release engineers work together to get your code into production and make it useful. We&amp;rsquo;ve created a standard container format that lets developers care about their applications inside containers while sysadmins and operators can work on running the container in your deployment. This separation of duties streamlines and simplifies the management and deployment of code.</source>
          <target state="translated">우리는 당신의 환경이 더 잘 작동하기를 원합니다. Docker 컨테이너와 함께 제공되는 작업 흐름은 개발자, 시스템 관리자, QA 담당자 및 릴리스 엔지니어가 함께 작업하여 코드를 프로덕션에 적용하고 유용하게 만드는 데 도움이됩니다. sysadmins 및 운영자가 배포에서 컨테이너를 실행하는 동안 개발자가 컨테이너 내부의 응용 프로그램을 관리 할 수 ​​있도록 표준 컨테이너 형식을 만들었습니다. 이러한 업무 분리는 코드의 관리 및 배포를 간소화하고 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="806ef39f6ad8d972fd2d94ac9c9cd75aff1a4030" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re assuming your Docker host is reachable at &lt;code&gt;localhost&lt;/code&gt;. If not, replace &lt;code&gt;localhost&lt;/code&gt; with the public IP of your Docker host.</source>
          <target state="translated">&lt;code&gt;localhost&lt;/code&gt; 호스트에서 Docker 호스트에 연결할 수 있다고 가정합니다 . 그렇지 않은 경우 &lt;code&gt;localhost&lt;/code&gt; 를 Docker 호스트의 공용 IP로 바꾸 십시오.</target>
        </trans-unit>
        <trans-unit id="501c14d27cbfa328d95ff43ff1c90d31c375b5f0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re marking &lt;code&gt;/var/lib/couchdb&lt;/code&gt; as a data volume.</source>
          <target state="translated">우리는 마킹하고 &lt;code&gt;/var/lib/couchdb&lt;/code&gt; 같은 데이터 볼륨을.</target>
        </trans-unit>
        <trans-unit id="e2347545d25f54042e61f0399be084433041f178" translate="yes" xml:space="preserve">
          <source>Weave Network Plugin</source>
          <target state="translated">직조 네트워크 플러그인</target>
        </trans-unit>
        <trans-unit id="71a9a275d6478de86f55b0a72d6696c524c07d54" translate="yes" xml:space="preserve">
          <source>Web service</source>
          <target state="translated">웹 서비스</target>
        </trans-unit>
        <trans-unit id="44cd0fb0594edf05fd78853e1e917e894ea150c2" translate="yes" xml:space="preserve">
          <source>Welcome! We are excited that you want to learn Docker. The &lt;em&gt;Docker Get Started Tutorial&lt;/em&gt; teaches you how to:</source>
          <target state="translated">어서 오십시오! Docker를 배우게되어 기쁩니다. &lt;em&gt;도커 시작하기 자습서&lt;/em&gt; 하는 방법을 배웁니다 :</target>
        </trans-unit>
        <trans-unit id="a36cd21f5706faf4c0a0cbdc8d9da3f9740e19f8" translate="yes" xml:space="preserve">
          <source>What about the redis service to persist data?</source>
          <target state="translated">데이터를 유지하기위한 redis 서비스는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="8f924a958a541b949a73d78d2b4459c2133f7b78" translate="yes" xml:space="preserve">
          <source>What happens when data is corrupted and you try to pull it when trust is enabled? In this section, you go into the &lt;code&gt;sandboxregistry&lt;/code&gt; and tamper with some data. Then, you try and pull it.</source>
          <target state="translated">데이터가 손상되어 트러스트가 활성화 된 상태에서 가져 오려고하면 어떻게됩니까? 이 섹션에서는 &lt;code&gt;sandboxregistry&lt;/code&gt; 로 이동 하여 일부 데이터를 변경합니다. 그런 다음 시도해보십시오.</target>
        </trans-unit>
        <trans-unit id="64fb14f8aa88b7d2e91635f389f4edfafe37121c" translate="yes" xml:space="preserve">
          <source>What is Docker Machine?</source>
          <target state="translated">도커 머신이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8d3f04b7718c6aaa0737c4e64011638377583b28" translate="yes" xml:space="preserve">
          <source>What is Notary</source>
          <target state="translated">공증인이란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="22a48e7808feb9049f2aea86ade92700f8cf9e4a" translate="yes" xml:space="preserve">
          <source>What is a swarm?</source>
          <target state="translated">떼는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e799c8f6882e548f3f8cc5d59060bae24daa90ac" translate="yes" xml:space="preserve">
          <source>What is in the sandbox?</source>
          <target state="translated">샌드 박스에 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="29a3958eb701300263e7f339dc7661408e35949a" translate="yes" xml:space="preserve">
          <source>What plugins are</source>
          <target state="translated">어떤 플러그인</target>
        </trans-unit>
        <trans-unit id="91d14624a28f729837466482c450d97cb2caba59" translate="yes" xml:space="preserve">
          <source>What this means is that the whole container filesystem will belong to the user specified in the &lt;code&gt;--userns-remap&lt;/code&gt; daemon config (&lt;code&gt;231072&lt;/code&gt; in the example above). This can lead to unexpected behavior of programs inside the container. For instance &lt;code&gt;sudo&lt;/code&gt; (which checks that its binaries belong to user &lt;code&gt;0&lt;/code&gt;) or binaries with a &lt;code&gt;setuid&lt;/code&gt; flag.</source>
          <target state="translated">이것이 의미하는 바는 전체 컨테이너 파일 시스템이 &lt;code&gt;--userns-remap&lt;/code&gt; 데몬 구성 ( 위 예제의 &lt;code&gt;231072&lt;/code&gt; ) 에 지정된 사용자에게 속한다는 것 입니다. 이로 인해 컨테이너 내부의 프로그램이 예기치 않게 작동 할 수 있습니다. 예를 들어 &lt;code&gt;sudo&lt;/code&gt; (바이너리가 사용자 &lt;code&gt;0&lt;/code&gt; 에 속하는지 확인 ) 또는 &lt;code&gt;setuid&lt;/code&gt; 플래그 가있는 바이너리입니다 .</target>
        </trans-unit>
        <trans-unit id="0c564930a438d61179a5f862967e76654c4d3aaa" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s next?</source>
          <target state="translated">무엇 향후 계획?</target>
        </trans-unit>
        <trans-unit id="c4b37c7c3262c56f99b3e9ba8eb6e0740101d8cd" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the difference between &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, and &lt;code&gt;start&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;up&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; 및 &lt;code&gt;start&lt;/code&gt; 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="82449ea4e8eed626fe3a969bca8775db93e124f4" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the difference between Docker Engine and Docker Machine?</source>
          <target state="translated">Docker Engine과 Docker Machine의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="70c2d3b747ccd53c30ec4bc3c351c827ec35ba28" translate="yes" xml:space="preserve">
          <source>Whatever existed at the destination path and</source>
          <target state="translated">목적지 경로에 존재했던 것</target>
        </trans-unit>
        <trans-unit id="34b3793d4180f2428aa3dcdf0c009cb7dbe68827" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../swarm/index&quot;&gt;deploying a Compose application to a Swarm cluster&lt;/a&gt;, you can make use of the built-in &lt;code&gt;overlay&lt;/code&gt; driver to enable multi-host communication between containers with no changes to your Compose file or application code.</source>
          <target state="translated">&lt;a href=&quot;../swarm/index&quot;&gt;Compose 응용 프로그램을 Swarm 클러스터에 배포&lt;/a&gt; 할 때는 기본 제공 &lt;code&gt;overlay&lt;/code&gt; 드라이버를 사용하여 Compose 파일 또는 응용 프로그램 코드를 변경하지 않고도 컨테이너간에 멀티 호스트 통신을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ab67af9408393f170b0f50999cc4eddc717193" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;alice&lt;/code&gt;, one of the signers, runs &lt;code&gt;docker trust revoke&lt;/code&gt;:</source>
          <target state="translated">때 &lt;code&gt;alice&lt;/code&gt; , 서명자 중 하나는, 실행 &lt;code&gt;docker trust revoke&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e77344ddd0d1be4695ea3e0a4d18f6bc0628add" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;docker build&lt;/code&gt; is run with the &lt;code&gt;--cgroup-parent&lt;/code&gt; option the containers used in the build will be run with the &lt;a href=&quot;../../run/index#specifying-custom-cgroups&quot;&gt;corresponding &lt;code&gt;docker run&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;docker build&lt;/code&gt; 으로 실행 &lt;code&gt;--cgroup-parent&lt;/code&gt; 옵션 빌드에 사용 된 컨테이너는 실행됩니다 &lt;a href=&quot;../../run/index#specifying-custom-cgroups&quot;&gt;해당하는 &lt;code&gt;docker run&lt;/code&gt; 플래그&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c156fe5743036e2fb55113868b2787c72c394ce3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;udev&lt;/code&gt; sync support is &lt;code&gt;false&lt;/code&gt;, a race condition occurs between the&lt;code&gt;devicemapper&lt;/code&gt; and &lt;code&gt;udev&lt;/code&gt; during create and cleanup. The race condition results in errors and failures. (For information on these failures, see &lt;a href=&quot;https://github.com/docker/docker/issues/4036&quot;&gt;docker#4036&lt;/a&gt;)</source>
          <target state="translated">때 &lt;code&gt;udev&lt;/code&gt; 에 동기화 지원은 &lt;code&gt;false&lt;/code&gt; , 경쟁 조건은 사이에 발생 &lt;code&gt;devicemapper&lt;/code&gt; 와 &lt;code&gt;udev&lt;/code&gt; 를 만들고 정리하는 동안. 경쟁 조건으로 인해 오류와 실패가 발생합니다. (이 실패에 대한 정보는 &lt;a href=&quot;https://github.com/docker/docker/issues/4036&quot;&gt;docker # 4036을&lt;/a&gt; 참조하십시오 )</target>
        </trans-unit>
        <trans-unit id="1df12efc747de17bb3d5aee4cee30a91103ed5c1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;udev&lt;/code&gt; sync support is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;devicemapper&lt;/code&gt; and udev can coordinate the activation and deactivation of devices for containers.</source>
          <target state="translated">경우 &lt;code&gt;udev&lt;/code&gt; 에 동기화 지원이 &lt;code&gt;true&lt;/code&gt; 이어서, &lt;code&gt;devicemapper&lt;/code&gt; 이나 udev는 용기 장치의 활성화 및 비활성화를 조정할 수있다.</target>
        </trans-unit>
        <trans-unit id="dea8f3f7ff571f4a621fc4e7db51e7c51eb451b6" translate="yes" xml:space="preserve">
          <source>When DCT is enabled in the Docker client, &lt;code&gt;docker&lt;/code&gt; CLI commands that operate on tagged images must either have content signatures or explicit content hashes. The commands that operate with DCT are:</source>
          <target state="translated">Docker 클라이언트에서 DCT가 활성화되면 태그가 지정된 이미지에서 작동하는 &lt;code&gt;docker&lt;/code&gt; CLI 명령에 컨텐츠 서명 또는 명시 적 컨텐츠 해시가 있어야합니다. DCT와 함께 작동하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abd8532f7fb4e42791b7d2d0664e10a49fbd88bd" translate="yes" xml:space="preserve">
          <source>When Docker Machine is invoked, it checks to see if you have the venerable &lt;code&gt;ssh&lt;/code&gt; binary around locally and attempts to use that for the SSH commands it needs to run, whether they are a part of an operation such as creation or have been requested by the user directly. If it does not find an external &lt;code&gt;ssh&lt;/code&gt; binary locally, it defaults to using a native Go implementation from &lt;a href=&quot;https://godoc.org/golang.org/x/crypto/ssh&quot;&gt;crypto/ssh&lt;/a&gt;. This is useful in situations where you may not have access to traditional UNIX tools, such as if you are using Docker Machine on Windows without having msysgit installed alongside of it.</source>
          <target state="translated">Docker Machine이 호출되면 로컬에 적합한 &lt;code&gt;ssh&lt;/code&gt; 바이너리 가 있는지 확인 하고 SSH 명령이 생성과 같은 작업의 일부인지 또는 요청한 것인지 여부에 관계없이 SSH 명령을 실행하려고합니다. 사용자 직접. 외부 &lt;code&gt;ssh&lt;/code&gt; 바이너리를 로컬에서 찾지 못하면 기본적으로 &lt;a href=&quot;https://godoc.org/golang.org/x/crypto/ssh&quot;&gt;crypto / ssh&lt;/a&gt; 의 기본 Go 구현을 사용합니다 . 이는 msysgit와 함께 설치하지 않고 Windows에서 Docker Machine을 사용하는 경우와 같이 기존 UNIX 도구에 액세스 할 수없는 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c2846c04cde815af3b4e60089dd43bbf90583f46" translate="yes" xml:space="preserve">
          <source>When Docker Machine provisions containers on local network provider or with a remote, cloud provider such as Amazon Web Services, you must define both the driver for your provider and a base operating system. There are over 10 supported drivers and a generic driver for adding machines for other providers.</source>
          <target state="translated">Docker Machine이 로컬 네트워크 공급자 또는 Amazon Web Services와 같은 원격 클라우드 공급자와 함께 컨테이너를 프로비저닝 할 때 공급자 및 기본 운영 체제의 드라이버를 모두 정의해야합니다. 10 개 이상의 지원되는 드라이버와 다른 공급자를위한 컴퓨터를 추가하기위한 일반 드라이버가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3e8197f73a2accac0e4f3cb2824a3716c9ce9cf" translate="yes" xml:space="preserve">
          <source>When Docker is running in swarm mode, you can still run standalone containers on any of the Docker hosts participating in the swarm, as well as swarm services. A key difference between standalone containers and swarm services is that only swarm managers can manage a swarm, while standalone containers can be started on any daemon. Docker daemons can participate in a swarm as managers, workers, or both.</source>
          <target state="translated">Docker가 스웜 모드에서 실행중인 경우 스웜 서비스뿐만 아니라 스웜에 참여하는 모든 Docker 호스트에서 독립형 컨테이너를 계속 실행할 수 있습니다. 독립형 컨테이너와 스웜 서비스의 주요 차이점은 스웜 관리자 만 스웜을 관리 할 수 ​​있고 독립형 컨테이너는 모든 데몬에서 시작할 수 있다는 것입니다. Docker 데몬은 관리자, 작업자 또는 둘 다로 무리에 참여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71818434b04e6d0a32057c34113db6ef370b899a" translate="yes" xml:space="preserve">
          <source>When Docker restarts, both the TLS key used to encrypt communication among swarm nodes, and the key used to encrypt and decrypt Raft logs on disk, are loaded into each manager node&amp;rsquo;s memory. Docker 1.13 introduces the ability to protect the mutual TLS encryption key and the key used to encrypt and decrypt Raft logs at rest, by allowing you to take ownership of these keys and to require manual unlocking of your managers. This feature is called &lt;em&gt;autolock&lt;/em&gt;.</source>
          <target state="translated">Docker가 다시 시작되면 swarm 노드 간의 통신을 암호화하는 데 사용되는 TLS 키와 디스크의 Raft 로그를 암호화 및 암호 해독하는 데 사용되는 키가 각 관리자 노드의 메모리에로드됩니다. Docker 1.13에는 상호 TLS 암호화 키와 보관시 Raft 로그를 암호화 및 암호 해독하는 데 사용되는 키를 보호하는 기능이 도입되어 이러한 키를 소유하고 관리자를 수동으로 잠금 해제해야합니다. 이 기능을 &lt;em&gt;자동 잠금&lt;/em&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="b5711ab0695665e11b5db9e34e22594bc885dde0" translate="yes" xml:space="preserve">
          <source>When Docker restarts, you must &lt;a href=&quot;index#unlock-a-swarm&quot;&gt;unlock the swarm&lt;/a&gt; first, using a &lt;em&gt;key encryption key&lt;/em&gt; generated by Docker when the swarm was locked. You can rotate this key encryption key at any time.</source>
          <target state="translated">Docker가 다시 시작되면 웜 이 잠겨있을 때 Docker가 생성 한 &lt;em&gt;키 암호화 키를&lt;/em&gt; 사용하여 &lt;a href=&quot;index#unlock-a-swarm&quot;&gt;웜을 잠금 해제&lt;/a&gt; 해야합니다 . 언제든지이 키 암호화 키를 회전 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9206362873923078261c5cb76b5fe2a4bc8a5aad" translate="yes" xml:space="preserve">
          <source>When Docker restarts, you need to &lt;a href=&quot;index#unlock-a-swarm&quot;&gt;unlock the swarm&lt;/a&gt;. A locked swarm causes an error like the following when you try to start or restart a service:</source>
          <target state="translated">Docker가 다시 시작되면 &lt;a href=&quot;index#unlock-a-swarm&quot;&gt;swarm의 잠금&lt;/a&gt; 을 해제 해야합니다 . 서비스를 시작하거나 다시 시작하려고 할 때 잠겨있는 무리는 다음과 같은 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="14093156d3f677ba0a426d38fe5b8654ced864c6" translate="yes" xml:space="preserve">
          <source>When a container has a healthcheck specified, it has a &lt;em&gt;health status&lt;/em&gt; in addition to its normal status. This status is initially &lt;code&gt;starting&lt;/code&gt;. Whenever a health check passes, it becomes &lt;code&gt;healthy&lt;/code&gt; (whatever state it was previously in). After a certain number of consecutive failures, it becomes &lt;code&gt;unhealthy&lt;/code&gt;.</source>
          <target state="translated">컨테이너가 지정된 상태 검사가있는 경우, 그것은이 &lt;em&gt;건강 상태&lt;/em&gt; 가 정상 상태에 추가합니다. 이 상태는 처음에 &lt;code&gt;starting&lt;/code&gt; 입니다. 건강 체크를 통과 할 때마다,이된다 &lt;code&gt;healthy&lt;/code&gt; (그 이전에 있었던 어떤 상태). 일정한 수의 연속 실패 후에는 &lt;code&gt;unhealthy&lt;/code&gt; 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="463aa393312b047e8e1bc884819ed358d4da5ec7" translate="yes" xml:space="preserve">
          <source>When a developer builds an image from a &lt;a href=&quot;../builder/index&quot;&gt;&lt;em&gt;Dockerfile&lt;/em&gt;&lt;/a&gt; or when she commits it, the developer can set a number of default parameters that take effect when the image starts up as a container.</source>
          <target state="translated">개발자가 &lt;a href=&quot;../builder/index&quot;&gt;&lt;em&gt;Dockerfile&lt;/em&gt;&lt;/a&gt; 에서 이미지를 빌드 하거나 커밋 할 때 이미지가 컨테이너로 시작될 때 적용되는 여러 기본 매개 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="127ce10561635f9a3053a9ffc06daf734a37fef1" translate="yes" xml:space="preserve">
          <source>When a node leaves the swarm, the Docker Engine stops running in swarm mode. The orchestrator no longer schedules tasks to the node.</source>
          <target state="translated">노드가 떼에서 나가면 Docker Engine은 떼 모드에서 실행을 중지합니다. 오케 스트레이터는 더 이상 작업을 노드에 예약하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c20168625c2b3d2ddca63e35fe6fb9b88074b54" translate="yes" xml:space="preserve">
          <source>When a plugin is first referred to -- either by a user referring to it by name (e.g. &lt;code&gt;docker run --volume-driver=foo&lt;/code&gt;) or a container already configured to use a plugin being started -- Docker looks for the named plugin in the plugin directory and activates it with a handshake. See Handshake API below.</source>
          <target state="translated">플러그인이 처음 참조 될 때 (이름으로 참조하는 사용자 (예 : &lt;code&gt;docker run --volume-driver=foo&lt;/code&gt; ) 또는 이미 시작된 플러그인을 사용하도록 구성된 컨테이너) Docker는 지정된 플러그인을 찾습니다. 플러그인 디렉토리와 악수로 활성화합니다. 아래의 핸드 셰이크 API를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5dd0c49d29f77bdd4af5c9684af5a7bbd732ff33" translate="yes" xml:space="preserve">
          <source>When a restart policy is active on a container, it will be shown as either &lt;code&gt;Up&lt;/code&gt; or &lt;code&gt;Restarting&lt;/code&gt; in &lt;a href=&quot;../commandline/ps/index&quot;&gt;&lt;code&gt;docker ps&lt;/code&gt;&lt;/a&gt;. It can also be useful to use &lt;a href=&quot;../commandline/events/index&quot;&gt;&lt;code&gt;docker events&lt;/code&gt;&lt;/a&gt; to see the restart policy in effect.</source>
          <target state="translated">컨테이너에서 재시작 정책이 활성화되면 &lt;a href=&quot;../commandline/ps/index&quot;&gt; &lt;code&gt;docker ps&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;Up&lt;/code&gt; 또는 &lt;code&gt;Restarting&lt;/code&gt; 으로 표시됩니다 . &lt;a href=&quot;../commandline/events/index&quot;&gt; &lt;code&gt;docker events&lt;/code&gt; &lt;/a&gt; 를 사용 하여 재시작 정책이 유효 한지 확인하는 것도 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7aefa66e2c8789e678ffa009cc1f5696cb356e8" translate="yes" xml:space="preserve">
          <source>When a task fails to roll back, whether to &lt;code&gt;pause&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; trying to roll back other tasks.</source>
          <target state="translated">작업이 롤 뒷면에 실패하면 여부를 &lt;code&gt;pause&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; 롤 다시 다른 작업을하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e443e0c067b327f07284fe8eac7d27d8a5b3c48f" translate="yes" xml:space="preserve">
          <source>When adding a delegation, your must acquire a x509 certificate with the public key of the user you wish to delegate to. The user who assumes this delegation role must hold the private key to sign content with notary.</source>
          <target state="translated">위임을 추가 할 때 위임하려는 사용자의 공개 키를 사용하여 x509 인증서를 획득해야합니다. 이 위임 역할을 담당하는 사용자는 공증인으로 콘텐츠에 서명하려면 개인 키를 보유해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a40811863417be5754fbcf0e4e298195d68cbe8" translate="yes" xml:space="preserve">
          <source>When adding files or directories that contain special characters (such as &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;), you need to escape those paths following the Golang rules to prevent them from being treated as a matching pattern. For example, to add a file named &lt;code&gt;arr[0].txt&lt;/code&gt;, use the following;</source>
          <target state="translated">특수 문자 (예 : &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; ) 가 포함 된 파일 또는 디렉토리를 추가 할 때는 일치 패턴으로 취급되지 않도록 Golang 규칙에 따라 해당 경로를 이스케이프해야합니다. 예를 들어, &lt;code&gt;arr[0].txt&lt;/code&gt; 라는 파일을 추가 하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5dd4c9f28609c04500e45f25f8decb82ab1ed9a9" translate="yes" xml:space="preserve">
          <source>When an HTTP request is made to the Docker daemon through the CLI or via the Engine API, the authentication subsystem passes the request to the installed authentication plugin(s). The request contains the user (caller) and command context. The plugin is responsible for deciding whether to allow or deny the request.</source>
          <target state="translated">CLI 또는 엔진 API를 통해 Docker 데몬에 HTTP 요청을하면 인증 서브 시스템은 요청을 설치된 인증 플러그인으로 전달합니다. 요청에는 사용자 (호출자) 및 명령 컨텍스트가 포함됩니다. 플러그인은 요청을 허용할지 거부 할지를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cf3c3ab1223d92040c03207f3a08a99689a96139" translate="yes" xml:space="preserve">
          <source>When an update to an individual task returns a state of &lt;code&gt;RUNNING&lt;/code&gt;, the scheduler continues the update by continuing to another task until all tasks are updated. If, at any time during an update a task returns &lt;code&gt;FAILED&lt;/code&gt;, the scheduler pauses the update. You can control the behavior using the &lt;code&gt;--update-failure-action&lt;/code&gt; flag for &lt;code&gt;docker service create&lt;/code&gt; or &lt;code&gt;docker service update&lt;/code&gt;.</source>
          <target state="translated">개별 작업에 대한 업데이트가 &lt;code&gt;RUNNING&lt;/code&gt; 상태를 반환 하면 스케줄러는 모든 작업이 업데이트 될 때까지 다른 작업을 계속하여 업데이트를 계속합니다. 업데이트 중 언제라도 작업이 &lt;code&gt;FAILED&lt;/code&gt; 를 반환 하면 스케줄러가 업데이트를 일시 중지합니다. &lt;code&gt;docker service create&lt;/code&gt; 또는 &lt;code&gt;docker service update&lt;/code&gt; 에 &lt;code&gt;--update-failure-action&lt;/code&gt; 플래그를 사용하여 동작을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7f599891c525618fb58e5bda838a432e6f67624" translate="yes" xml:space="preserve">
          <source>When attempting to squash an image that does not make changes to the filesystem (for example, the Dockerfile only contains &lt;code&gt;ENV&lt;/code&gt; instructions), the squash step will fail (see &lt;a href=&quot;https://github.com/moby/moby/issues/33823&quot;&gt;issue #33823&lt;/a&gt;).</source>
          <target state="translated">파일 시스템을 변경하지 않는 이미지를 스쿼시하려고하면 (예 : Dockerfile에 &lt;code&gt;ENV&lt;/code&gt; 명령어 만 포함 ) 스쿼시 단계가 실패합니다 ( &lt;a href=&quot;https://github.com/moby/moby/issues/33823&quot;&gt;문제 # 33823&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a77b46a0b2c983b55caac38805c976358aa0eed4" translate="yes" xml:space="preserve">
          <source>When building a Dockerfile with multiple build stages, &lt;code&gt;--target&lt;/code&gt; can be used to specify an intermediate build stage by name as a final stage for the resulting image. Commands after the target stage will be skipped.</source>
          <target state="translated">빌드 단계가 여러 개인 Dockerfile을 빌드 할 때 &lt;code&gt;--target&lt;/code&gt; 을 사용하여 이름으로 중간 빌드 단계를 결과 이미지의 최종 단계로 지정할 수 있습니다. 대상 단계 이후의 명령은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="618dc33e037978f3558533aed638a5e430e811cc" translate="yes" xml:space="preserve">
          <source>When building this Dockerfile, the &lt;code&gt;HTTP_PROXY&lt;/code&gt; is preserved in the &lt;code&gt;docker history&lt;/code&gt;, and changing its value invalidates the build cache.</source>
          <target state="translated">이 Dockerfile을 빌드 할 때 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 는 &lt;code&gt;docker history&lt;/code&gt; 에 유지되며 값을 변경하면 빌드 캐시가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="71df87efade891f48cf3374bb0d7a442707e1944" translate="yes" xml:space="preserve">
          <source>When clients uploads new metadata files, Notary server checks them against any previous versions for conflicts, and verifies the signatures, checksums, and validity of the uploaded metadata.</source>
          <target state="translated">클라이언트가 새 메타 데이터 파일을 업로드하면 Notary 서버는 이전 버전과 충돌하는지 확인하고 업로드 된 메타 데이터의 서명, 체크섬 및 유효성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7e7481348f5d24498ee74fbc168cc94b2cd809cf" translate="yes" xml:space="preserve">
          <source>When configuring a gMSA credential spec for a service, you only need to specify a credential spec with &lt;code&gt;config&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">서비스에 대한 gMSA 자격 증명 사양을 구성 할 때 다음 예제와 같이 &lt;code&gt;config&lt;/code&gt; 로 자격 증명 사양 만 지정하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="afed8838b2d50b257fe08b3cf3ec1c305c4ea6f0" translate="yes" xml:space="preserve">
          <source>When copying files or directories that contain special characters (such as &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;), you need to escape those paths following the Golang rules to prevent them from being treated as a matching pattern. For example, to copy a file named &lt;code&gt;arr[0].txt&lt;/code&gt;, use the following;</source>
          <target state="translated">특수 문자 (예 : &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; ) 가 포함 된 파일 또는 디렉토리를 복사 할 때 일치하는 패턴으로 처리되지 않도록 Golang 규칙에 따라 해당 경로를 이스케이프해야합니다. 예를 들어, &lt;code&gt;arr[0].txt&lt;/code&gt; 라는 파일을 복사 하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e4dfcf9d710224b6eaa95111c9b1cf293239edf8" translate="yes" xml:space="preserve">
          <source>When creating a custom network, the default network driver (i.e. &lt;code&gt;bridge&lt;/code&gt;) has additional options that can be passed. The following are those options and the equivalent docker daemon flags used for docker0 bridge:</source>
          <target state="translated">사용자 지정 네트워크를 만들 때 기본 네트워크 드라이버 (예 : &lt;code&gt;bridge&lt;/code&gt; )에는 전달할 수있는 추가 옵션이 있습니다. 다음은 docker0 브리지에 사용되는 해당 옵션 및 해당 docker 데몬 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="347676355375bba3281cbec5479bbc3946b01bf8" translate="yes" xml:space="preserve">
          <source>When creating a service which uses Windows containers, the options to specify UID, GID, and mode are not supported for configs. Configs are currently only accessible by administrators and users with &lt;code&gt;system&lt;/code&gt; access within the container.</source>
          <target state="translated">Windows 컨테이너를 사용하는 서비스를 생성 할 때 UID, GID 및 모드를 지정하는 옵션은 구성에 지원되지 않습니다. 구성은 현재 컨테이너 내에서 &lt;code&gt;system&lt;/code&gt; 액세스 권한을 가진 관리자 및 사용자 만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb77848131a1ef45a66f89ad9a6eb6e074932bfa" translate="yes" xml:space="preserve">
          <source>When creating a service which uses Windows containers, the options to specify UID, GID, and mode are not supported for secrets. Secrets are currently only accessible by administrators and users with &lt;code&gt;system&lt;/code&gt; access within the container.</source>
          <target state="translated">Windows 컨테이너를 사용하는 서비스를 생성 할 때 비밀에 대해 UID, GID 및 모드를 지정하는 옵션이 지원되지 않습니다. 비밀은 현재 컨테이너 내에서 &lt;code&gt;system&lt;/code&gt; 액세스 권한을 가진 관리자 및 사용자 만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a2e9325aa49ae9b855822d458b17d7e566800bd" translate="yes" xml:space="preserve">
          <source>When defining any service in &lt;code&gt;docker-compose.yml&lt;/code&gt;, you can declare that you are extending another service like this:</source>
          <target state="translated">&lt;code&gt;docker-compose.yml&lt;/code&gt; 에서 서비스를 정의 할 때 다음과 같이 다른 서비스를 확장한다고 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21bcf537614dc27c0892c8f1d25d4b4f1e3fdc0" translate="yes" xml:space="preserve">
          <source>When deploying a service, docker resolves the digest for the service&amp;rsquo;s image, and pins the service to that digest. The digest is not shown by default, but is printed if &lt;code&gt;--no-trunc&lt;/code&gt; is used. The &lt;code&gt;--no-trunc&lt;/code&gt; option also shows the non-truncated task ID, and error-messages, as can be seen below;</source>
          <target state="translated">서비스를 배포 할 때 도커는 서비스 이미지의 다이제스트를 확인하고 서비스를 해당 다이제스트에 고정합니다. 다이제스트는 기본적으로 표시되지 않지만 &lt;code&gt;--no-trunc&lt;/code&gt; 가 사용 되면 인쇄 됩니다. &lt;code&gt;--no-trunc&lt;/code&gt; 아래에 볼 수있는 옵션도, 비 절단 작업 ID 및 오류 메시지를 보여줍니다;</target>
        </trans-unit>
        <trans-unit id="cfe0a9c5fc35c4aa7588813812bd33399874daff" translate="yes" xml:space="preserve">
          <source>When deploying a service, docker resolves the digest for the service&amp;rsquo;s image, and pins the service to that digest. The digest is not shown by default, but is printed if &lt;code&gt;--no-trunc&lt;/code&gt; is used. The &lt;code&gt;--no-trunc&lt;/code&gt; option also shows the non-truncated task IDs, and error-messages, as can be seen below:</source>
          <target state="translated">서비스를 배포 할 때 도커는 서비스 이미지의 다이제스트를 확인하고 서비스를 해당 다이제스트에 고정합니다. 다이제스트는 기본적으로 표시되지 않지만 &lt;code&gt;--no-trunc&lt;/code&gt; 가 사용 되면 인쇄 됩니다. &lt;code&gt;--no-trunc&lt;/code&gt; 아래에 볼 수있는 옵션도, 비 절단 작업 ID 및 오류 메시지를 보여줍니다</target>
        </trans-unit>
        <trans-unit id="bf922f13b2e0bc8bd23a47a810469d17c5bfd388" translate="yes" xml:space="preserve">
          <source>When deploying, Docker creates these two secrets and populates them with the content from the file specified in the compose file.</source>
          <target state="translated">배포시 Docker는이 두 비밀을 작성하고 작성 파일에 지정된 파일의 컨텐츠로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="511b0cb2c358a331cc01a4b2626afbe040e58af9" translate="yes" xml:space="preserve">
          <source>When doing a &lt;code&gt;docker push&lt;/code&gt; with Content Trust enabled for the first time, the root, targets, snapshot, and timestamp keys are generated automatically for the image repository:</source>
          <target state="translated">Content Trust를 사용하여 처음으로 &lt;code&gt;docker push&lt;/code&gt; 를 수행 하면 이미지 저장소에 대해 루트, 대상, 스냅 샷 및 타임 스탬프 키가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f59201fb392232fdc5f482e1898dbc8cc183e84e" translate="yes" xml:space="preserve">
          <source>When explicitly passing environment variables</source>
          <target state="translated">환경 변수를 명시 적으로 전달하는 경우</target>
        </trans-unit>
        <trans-unit id="9fce3a5987a4c87098696deeea50c21c928e4dcb" translate="yes" xml:space="preserve">
          <source>When initiating a repository, you will need the key and the passphrase of a local Notary Canonical Root Key. If you have not initiated a repository before, and therefore don&amp;rsquo;t have a Notary root key, &lt;code&gt;$ docker trust&lt;/code&gt; will create one for you.</source>
          <target state="translated">리포지토리를 시작할 때 로컬 Notary Canonical Root Key의 키와 암호가 필요합니다. 이전에 리포지토리를 시작하지 않았으므로 Notary 루트 키가없는 경우 &lt;code&gt;$ docker trust&lt;/code&gt; 가이 를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="da23c544ecc07a7f26bce24924fd3e40d7b31662" translate="yes" xml:space="preserve">
          <source>When initiating a swarm, you must specify the &lt;code&gt;--advertise-addr&lt;/code&gt; flag to advertise your address to other manager nodes in the swarm. For more information, see &lt;a href=&quot;../swarm-mode/index#configure-the-advertise-address&quot;&gt;Run Docker Engine in swarm mode&lt;/a&gt;. Because manager nodes are meant to be a stable component of the infrastructure, you should use a &lt;em&gt;fixed IP address&lt;/em&gt; for the advertise address to prevent the swarm from becoming unstable on machine reboot.</source>
          <target state="translated">스웜을 시작할 때 &lt;code&gt;--advertise-addr&lt;/code&gt; 플래그를 지정하여 스웜의 다른 관리자 노드에 주소를 알리 십시오. 자세한 정보 &lt;a href=&quot;../swarm-mode/index#configure-the-advertise-address&quot;&gt;는 swarm 모드에서 Docker Engine 실행을&lt;/a&gt; 참조 하십시오 . 관리자 노드는 인프라의 안정적인 구성 요소이므로 &lt;em&gt;고정 IP 주소를&lt;/em&gt; 사용해야합니다&lt;em&gt;&lt;/em&gt; 시스템 재부팅시 스웜이 불안 정해지지 않도록 광고 주소에 를 .</target>
        </trans-unit>
        <trans-unit id="0644abaf7cbcba5ce9c0f3b9c4b13034a85108fb" translate="yes" xml:space="preserve">
          <source>When inspecting a container, &lt;code&gt;NetworkSettings&lt;/code&gt; contains top-level information about the default (&amp;ldquo;bridge&amp;rdquo;) network;</source>
          <target state="translated">컨테이너를 검사 할 때 &lt;code&gt;NetworkSettings&lt;/code&gt; 에는 기본 ( &quot;브리지&quot;) 네트워크에 대한 최상위 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="601cae27195075e7160aab5c8bef776bacd68983" translate="yes" xml:space="preserve">
          <source>When it encounters an &lt;code&gt;ONBUILD&lt;/code&gt; instruction, the builder adds a trigger to the metadata of the image being built. The instruction does not otherwise affect the current build.</source>
          <target state="translated">&lt;code&gt;ONBUILD&lt;/code&gt; 명령 이 발생하면 빌더는 빌드중인 이미지의 메타 데이터에 트리거를 추가합니다. 지침은 현재 빌드에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01648cf0e1e62f5ef448a237dbc964d254dfb9ea" translate="yes" xml:space="preserve">
          <source>When moving from development to production there are a number of considerations that must be made to ensure security and scalability.</source>
          <target state="translated">개발에서 프로덕션으로 전환 할 때 보안 및 확장 성을 보장하기 위해 고려해야 할 사항이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f09f06ff9622ddf90aac7883a47f9c48431d1208" translate="yes" xml:space="preserve">
          <source>When no tag is specified, &lt;code&gt;docker trust&lt;/code&gt; revokes all signatures that you have a signing key for.</source>
          <target state="translated">태그를 지정하지 않으면 &lt;code&gt;docker trust&lt;/code&gt; 는 서명 키가있는 모든 서명을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="87f1189049dbb4903a48364647d79d60cf4d38e9" translate="yes" xml:space="preserve">
          <source>When passing a boolean value to any option</source>
          <target state="translated">옵션에 부울 값을 전달할 때</target>
        </trans-unit>
        <trans-unit id="0daaa7569d311aef3b5165eb364e361b779b0a70" translate="yes" xml:space="preserve">
          <source>When people say &amp;ldquo;Docker&amp;rdquo; they typically mean &lt;strong&gt;Docker Engine&lt;/strong&gt;, the client-server application made up of the Docker daemon, a REST API that specifies interfaces for interacting with the daemon, and a command line interface (CLI) client that talks to the daemon (through the REST API wrapper). Docker Engine accepts &lt;code&gt;docker&lt;/code&gt; commands from the CLI, such as &lt;code&gt;docker run &amp;lt;image&amp;gt;&lt;/code&gt;, &lt;code&gt;docker ps&lt;/code&gt; to list running containers, &lt;code&gt;docker image ls&lt;/code&gt; to list images, and so on.</source>
          <target state="translated">사람들이 &quot;Docker&quot;라고 말하면 일반적으로 &lt;strong&gt;Docker Engine&lt;/strong&gt; , Docker 데몬, 데몬과 상호 작용하기위한 인터페이스를 지정하는 REST API 및 데몬과 통신하는 명령 행 인터페이스 (CLI) 클라이언트로 구성된 클라이언트 서버 애플리케이션을 의미합니다. (REST API 래퍼를 통해). Docker Engine은 CLI에서 &lt;code&gt;docker run &amp;lt;image&amp;gt;&lt;/code&gt; , &lt;code&gt;docker ps&lt;/code&gt; 실행 컨테이너 표시, &lt;code&gt;docker image ls&lt;/code&gt; 이미지 표시 등과 같은 CLI에서 &lt;code&gt;docker&lt;/code&gt; 명령을 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="0492e7f7eb43ae1c658d3aafab047f301cd25d88" translate="yes" xml:space="preserve">
          <source>When pushing or pulling to a 2.0 registry, the &lt;code&gt;push&lt;/code&gt; or &lt;code&gt;pull&lt;/code&gt; command output includes the image digest. You can &lt;code&gt;pull&lt;/code&gt; using a digest value. You can also reference by digest in &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, and &lt;code&gt;rmi&lt;/code&gt; commands, as well as the &lt;code&gt;FROM&lt;/code&gt; image reference in a Dockerfile.</source>
          <target state="translated">2.0 레지스트리를 &lt;code&gt;push&lt;/code&gt; 거나 &lt;code&gt;pull&lt;/code&gt; push 또는 pull 명령 출력에 이미지 요약이 포함됩니다. 다이제스트 값을 사용하여 &lt;code&gt;pull&lt;/code&gt; 수 있습니다 . &lt;code&gt;create&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; 및 &lt;code&gt;rmi&lt;/code&gt; 명령 에서 digest 와 Dockerfile 의 &lt;code&gt;FROM&lt;/code&gt; 이미지 참조를 통해 참조 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fecebdbf09a2272c5ec30668e54681f6ea612b31" translate="yes" xml:space="preserve">
          <source>When run from a manager node, removes the specified nodes from a swarm.</source>
          <target state="translated">관리자 노드에서 실행될 때 swarm에서 지정된 노드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d5b4bf3a4de834cfa68022e776528b7c808ecb39" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;docker pull&lt;/code&gt; with Docker Content Trust on Docker Engine 1.10, Docker attempts to search the &lt;code&gt;targets/releases&lt;/code&gt; role for the signed image tag, and falls back to the default &lt;code&gt;targets&lt;/code&gt; role if it does not exist. When searching the default &lt;code&gt;targets&lt;/code&gt; role, Docker 1.10 may pick up on other non-&lt;code&gt;targets/releases&lt;/code&gt; delegation roles&amp;rsquo; signed images if they exist for this tag. In Docker 1.11, this behavior is changed such that all &lt;code&gt;docker pull&lt;/code&gt; commands with Docker Content Trust must pull tags only signed by the &lt;code&gt;targets/releases&lt;/code&gt; delegation role or the &lt;code&gt;targets&lt;/code&gt; base role.</source>
          <target state="translated">Docker Engine 1.10에서 Docker Content Trust를 사용하여 &lt;code&gt;docker pull&lt;/code&gt; 을 실행하면 Docker 는 서명 된 이미지 태그 의 &lt;code&gt;targets/releases&lt;/code&gt; 역할 을 검색하려고 시도하고 존재하지 않는 경우 기본 &lt;code&gt;targets&lt;/code&gt; 역할로 돌아갑니다 . 기본 &lt;code&gt;targets&lt;/code&gt; 역할을 검색 할 때 Docker 1.10 은이 태그에 대해 다른 비 &lt;code&gt;targets/releases&lt;/code&gt; 위임 역할의 서명 된 이미지가있는 경우이를 선택할 수 있습니다 . Docker 1.11에서는 Docker Content Trust가 있는 모든 &lt;code&gt;docker pull&lt;/code&gt; 명령이 &lt;code&gt;targets/releases&lt;/code&gt; 위임 역할 또는 &lt;code&gt;targets&lt;/code&gt; 기본 역할에 의해 서명 된 태그 만 가져 오도록 이 동작이 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d3f896e6fcb70cbf5b955b01e5a6a284f5182f8f" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;docker push&lt;/code&gt; with Docker Content Trust, Docker Engine 1.10 attempts to sign and push with the &lt;code&gt;targets/releases&lt;/code&gt; delegation role if it exists, otherwise falling back to the &lt;code&gt;targets&lt;/code&gt; role. In Docker 1.11, a &lt;code&gt;docker push&lt;/code&gt; attempts to sign and push with all delegation roles directly under targets (ex: &lt;code&gt;targets/role&lt;/code&gt; but not &lt;code&gt;targets/nested/role&lt;/code&gt;) that the user has signing keys for. If delegation roles exist but the user does not have signing keys, the push fails. If no delegation roles exist, the push attempts to sign with the base &lt;code&gt;targets&lt;/code&gt; role.</source>
          <target state="translated">Docker Content Trust와 함께 &lt;code&gt;docker push&lt;/code&gt; 를 실행할 때 Docker Engine 1.10은 &lt;code&gt;targets/releases&lt;/code&gt; 위임 역할이있는 경우 서명하고 푸시하려고 시도 합니다. 그렇지 않으면 &lt;code&gt;targets&lt;/code&gt; 역할로 돌아갑니다 . Docker 1.11에서 &lt;code&gt;docker push&lt;/code&gt; 는 사용자가 서명 키가있는 대상 (예 : &lt;code&gt;targets/role&lt;/code&gt; 이지만 &lt;code&gt;targets/nested/role&lt;/code&gt; 아님) 바로 아래의 모든 위임 역할로 서명 및 푸시를 시도합니다 . 위임 역할이 있지만 사용자에게 서명 키가없는 경우 푸시가 실패합니다. 위임 역할이 없으면 푸시는 기본 &lt;code&gt;targets&lt;/code&gt; 역할 로 서명을 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="23348b405542f00a816be2ce23cc4f47750b1721" translate="yes" xml:space="preserve">
          <source>When running inside a LAN that uses an &lt;code&gt;HTTPS&lt;/code&gt; proxy, the Docker Hub certificates will be replaced by the proxy&amp;rsquo;s certificates. These certificates need to be added to your Docker host&amp;rsquo;s configuration:</source>
          <target state="translated">&lt;code&gt;HTTPS&lt;/code&gt; 프록시 를 사용하는 LAN 내부에서 실행 하면 Docker Hub 인증서가 프록시 인증서로 대체됩니다. 이 인증서는 Docker 호스트 구성에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="659fec972e069c7c59881e58bb663a865cd786b8" translate="yes" xml:space="preserve">
          <source>When running the command, the Docker CLI client checks the value the variable has in your local environment and passes it to the container. If no &lt;code&gt;=&lt;/code&gt; is provided and that variable is not exported in your local environment, the variable won&amp;rsquo;t be set in the container.</source>
          <target state="translated">명령을 실행할 때 Docker CLI 클라이언트는 로컬 환경에서 변수의 값을 확인하여 컨테이너에 전달합니다. 어떤 경우 &lt;code&gt;=&lt;/code&gt; 이 제공되지 않고, 그 변수는 해당 지역의 환경에서 내보낼 수 없습니다, 변수는 컨테이너에 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e5838f27a3bb4cc1fcdc9639f77e1eaa39b268f" translate="yes" xml:space="preserve">
          <source>When set to anything other than an empty string, enables TLS communication with the &lt;code&gt;docker&lt;/code&gt; daemon.</source>
          <target state="translated">빈 문자열 이외의 것으로 설정하면 &lt;code&gt;docker&lt;/code&gt; 데몬 과의 TLS 통신을 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="b084374239a9efe79349b1dfefb50d6d84c6e5a5" translate="yes" xml:space="preserve">
          <source>When setting duplicate keys with conflicting values, an error will be produced, and the daemon will fail to start.</source>
          <target state="translated">값이 충돌하는 중복 키를 설정하면 오류가 발생하고 데몬이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9f537bf06a2b4d909bb20b835ed6f30404e99b2" translate="yes" xml:space="preserve">
          <source>When squashing layers, the resulting image cannot take advantage of layer sharing with other images, and may use significantly more space. Sharing the base image is still supported.</source>
          <target state="translated">레이어를 스쿼시 할 때 결과 이미지는 다른 이미지와 레이어 공유를 이용할 수 없으며 훨씬 더 많은 공간을 사용할 수 있습니다. 기본 이미지 공유는 여전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f30a97ec9a26f57ca205bc979ead834fcb38f949" translate="yes" xml:space="preserve">
          <source>When starting a Docker container, you must first decide if you want to run the container in the background in a &amp;ldquo;detached&amp;rdquo; mode or in the default foreground mode:</source>
          <target state="translated">Docker 컨테이너를 시작할 때 먼저 &quot;분리 된&quot;모드 또는 기본 포 그라운드 모드에서 컨테이너를 백그라운드에서 실행할지 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f659d3dc17151003cbabcd9deccc26cc9015784" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;URL&lt;/code&gt; parameter points to the location of a Git repository, the repository acts as the build context. The system recursively fetches the repository and its submodules. The commit history is not preserved. A repository is first pulled into a temporary directory on your local host. After that succeeds, the directory is sent to the Docker daemon as the context. Local copy gives you the ability to access private repositories using local user credentials, VPN&amp;rsquo;s, and so forth.</source>
          <target state="translated">때 &lt;code&gt;URL&lt;/code&gt; 의 힘내 저장소의 위치 매개 변수 포인트, 저장소는 빌드 컨텍스트 역할을합니다. 시스템은 리포지토리와 해당 하위 모듈을 반복적으로 가져옵니다. 커밋 히스토리가 유지되지 않습니다. 저장소는 먼저 로컬 호스트의 임시 디렉토리로 가져옵니다. 성공한 후 디렉토리는 컨텍스트로 Docker 데몬에 전송됩니다. 로컬 복사본을 사용하면 로컬 사용자 자격 증명, VPN 등을 사용하여 개인 리포지토리에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf75f65d4c19cd0d08a36f20657798919de261c5" translate="yes" xml:space="preserve">
          <source>When the Docker Engine runs in swarm mode, manager nodes implement the &lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot;&gt;Raft Consensus Algorithm&lt;/a&gt; to manage the global cluster state.</source>
          <target state="translated">Docker Engine이 스웜 모드에서 실행될 때 관리자 노드는 &lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot;&gt;Raft Consensus Algorithm&lt;/a&gt; 을 구현 하여 글로벌 클러스터 상태를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="2a7c036a349af77c01a9cd0bddde1a783d62e442" translate="yes" xml:space="preserve">
          <source>When the Droplet is created, Docker generates a unique SSH key and stores it on your local system in &lt;code&gt;~/.docker/machines&lt;/code&gt;. Initially, this is used to provision the host. Later, it&amp;rsquo;s used under the hood to access the Droplet directly with the &lt;code&gt;docker-machine ssh&lt;/code&gt; command. Docker Engine is installed on the cloud server and the daemon is configured to accept remote connections over TCP using TLS for authentication.</source>
          <target state="translated">Droplet이 생성되면 Docker는 고유 한 SSH 키를 생성하여 로컬 시스템의 &lt;code&gt;~/.docker/machines&lt;/code&gt; 에 저장 합니다. 처음에는 호스트를 프로비저닝하는 데 사용됩니다. 나중에 후드 아래에서 &lt;code&gt;docker-machine ssh&lt;/code&gt; 명령으로 Droplet에 직접 액세스하는 데 사용됩니다 . Docker Engine은 클라우드 서버에 설치되며 데몬은 인증을 위해 TLS를 사용하여 TCP를 통한 원격 연결을 수락하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ea94e885b61dafdf1f7ce5b687ff9ec12389569b" translate="yes" xml:space="preserve">
          <source>When the first Delegation is added to the Notary Server using &lt;code&gt;$ docker trust&lt;/code&gt;, we automatically initiate trust data for the repository. This includes creating the notary target and snapshots keys, and rotating the snapshot key to be managed by the notary server. More information on these keys can be found &lt;a href=&quot;../trust_key_mng/index&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;$ docker trust&lt;/code&gt; 를 사용하여 첫 번째 위임이 Notary Server에 추가 되면 저장소에 대한 신뢰 데이터가 자동으로 시작됩니다. 여기에는 공증 대상 및 스냅 샷 키 생성과 공증 서버에서 관리 할 스냅 샷 키 회전이 포함됩니다. 이 키에 대한 자세한 내용은 &lt;a href=&quot;../trust_key_mng/index&quot;&gt;여기를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75edf33bc6be90beb43fe9ad660f3a86ded76bf4" translate="yes" xml:space="preserve">
          <source>When the health status of a container changes, a &lt;code&gt;health_status&lt;/code&gt; event is generated with the new status.</source>
          <target state="translated">컨테이너의 상태가 변경되면 새로운 상태와 함께 &lt;code&gt;health_status&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b8cda7377d31de74ef1bba33d6429775f09cf118" translate="yes" xml:space="preserve">
          <source>When the host directory of a bind-mounted volume doesn&amp;rsquo;t exist, Docker will automatically create this directory on the host for you. In the example above, Docker will create the &lt;code&gt;/doesnt/exist&lt;/code&gt; folder before starting your container.</source>
          <target state="translated">바인드 마운트 볼륨의 호스트 디렉토리가 존재하지 않으면 Docker가 자동으로 호스트에이 디렉토리를 작성합니다. 위의 예에서 Docker는 컨테이너를 시작하기 전에 &lt;code&gt;/doesnt/exist&lt;/code&gt; 폴더를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="37eaa270d0fc80dc52f9d5bd7996c0b0c45967d7" translate="yes" xml:space="preserve">
          <source>When the image is finished pulling, you can hit the server at port 8000 on the IP address given to you by &lt;code&gt;docker-machine ip&lt;/code&gt;. For instance:</source>
          <target state="translated">이미지 가져 오기가 완료되면 &lt;code&gt;docker-machine ip&lt;/code&gt; 에서 제공 한 IP 주소의 포트 8000에서 서버에 도달 할 수 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="a73fe123cef9361a28fbc3e9edf90c8d8f005555" translate="yes" xml:space="preserve">
          <source>When the load is balanced to your satisfaction, you can scale the service back down to the original scale. You can use &lt;code&gt;docker service ps&lt;/code&gt; to assess the current balance of your service across nodes.</source>
          <target state="translated">부하가 만족스러운 수준으로 조정되면 서비스를 원래 규모로 다시 축소 할 수 있습니다. &lt;code&gt;docker service ps&lt;/code&gt; 를 사용 하여 노드에서 서비스의 현재 균형을 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c318e60dc901868948fe4381dcdfd1efe16581e" translate="yes" xml:space="preserve">
          <source>When the operator executes &lt;code&gt;docker run --privileged&lt;/code&gt;, Docker will enable access to all devices on the host as well as set some configuration in AppArmor or SELinux to allow the container nearly all the same access to the host as processes running outside containers on the host. Additional information about running with &lt;code&gt;--privileged&lt;/code&gt; is available on the &lt;a href=&quot;http://blog.docker.com/2013/09/docker-can-now-run-within-docker/&quot;&gt;Docker Blog&lt;/a&gt;.</source>
          <target state="translated">운영자가 &lt;code&gt;docker run --privileged&lt;/code&gt; 를 실행하면 Docker는 호스트의 모든 장치에 대한 액세스를 활성화하고 AppArmor 또는 SELinux의 일부 구성을 설정하여 컨테이너가 호스트의 컨테이너 외부에서 실행되는 프로세스와 거의 동일한 컨테이너 액세스를 허용합니다 . &lt;code&gt;--privileged&lt;/code&gt; 를 사용한 실행에 대한 추가 정보 는 &lt;a href=&quot;http://blog.docker.com/2013/09/docker-can-now-run-within-docker/&quot;&gt;Docker 블로그&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89792eee5fff814f02d50bb9de5869b5f955d7a3" translate="yes" xml:space="preserve">
          <source>When the operator executes &lt;code&gt;docker run --privileged&lt;/code&gt;, Docker will enable access to all devices on the host as well as set some configuration in AppArmor or SELinux to allow the container nearly all the same access to the host as processes running outside containers on the host. Additional information about running with &lt;code&gt;--privileged&lt;/code&gt; is available on the &lt;a href=&quot;https://blog.docker.com/2013/09/docker-can-now-run-within-docker/&quot;&gt;Docker Blog&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c6a88c8ccf3dd31b48babc2fb936bc6e2eb113" translate="yes" xml:space="preserve">
          <source>When the task is started, the volume is mounted on &lt;code&gt;/path/in/container/&lt;/code&gt; inside the container.</source>
          <target state="translated">작업이 시작되면 볼륨은 &lt;code&gt;/path/in/container/&lt;/code&gt; 내부의 / path / in / container /에 마운트됩니다 .</target>
        </trans-unit>
        <trans-unit id="c18f199a0d194a80dc95bb89bab019f59b7c1c6a" translate="yes" xml:space="preserve">
          <source>When the value supplied is a relative path, it is interpreted as relative to the location of the Compose file. This directory is also the build context that is sent to the Docker daemon.</source>
          <target state="translated">제공된 값이 상대 경로 인 경우 Compose 파일의 위치를 ​​기준으로 해석됩니다. 이 디렉토리는 Docker 데몬으로 전송되는 빌드 컨텍스트이기도합니다.</target>
        </trans-unit>
        <trans-unit id="13b9a85a29067926eeac3f86f7eef25ee148240d" translate="yes" xml:space="preserve">
          <source>When this value is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;devicemapper&lt;/code&gt; continues and simply warns you the errors are happening.</source>
          <target state="translated">이 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;devicemapper&lt;/code&gt; 는 계속 진행되고 오류가 발생 했음을 경고합니다.</target>
        </trans-unit>
        <trans-unit id="d8566b00b0899ded6d349d22c0554b076d1a80a6" translate="yes" xml:space="preserve">
          <source>When transferring data among networked systems, &lt;em&gt;trust&lt;/em&gt; is a central concern. In particular, when communicating over an untrusted medium such as the internet, it is critical to ensure the integrity and the publisher of all the data a system operates on. You use the Docker Engine to push and pull images (data) to a public or private registry. Content trust gives you the ability to verify both the integrity and the publisher of all the data received from a registry over any channel.</source>
          <target state="translated">네트워크 시스템간에 데이터를 전송할 때 &lt;em&gt;신뢰&lt;/em&gt; 는 핵심 관심사입니다. 특히 인터넷과 같은 신뢰할 수없는 매체를 통해 통신 할 때는 시스템에서 작동하는 모든 데이터의 무결성과 게시자를 보장하는 것이 중요합니다. Docker Engine을 사용하여 이미지 (데이터)를 공개 또는 개인 레지스트리로 푸시 및 풀합니다. 컨텐츠 신뢰는 모든 채널을 통해 레지스트리에서 수신 한 모든 데이터의 무결성과 게시자를 모두 확인할 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5aacfb0870be5c15d019742bbc508afa718247b9" translate="yes" xml:space="preserve">
          <source>When transferring directories and not just files, avoid rsync surprises by using trailing slashes on both the source and destination. For example:</source>
          <target state="translated">파일뿐만 아니라 디렉토리를 전송할 때 소스와 대상 모두에서 슬래시를 사용하여 rsync 놀라움을 피하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbe5d6c10f721557e1b988345c3c888f5f61c38b" translate="yes" xml:space="preserve">
          <source>When transferring large files or updating directories with lots of files, you can use the &lt;code&gt;-d&lt;/code&gt; flag, which uses &lt;code&gt;rsync&lt;/code&gt; to transfer deltas instead of transferring all of the files.</source>
          <target state="translated">큰 파일을 전송하거나 많은 파일로 디렉토리를 업데이트 할 때 &lt;code&gt;-d&lt;/code&gt; 플래그를 사용하면 모든 파일을 전송하는 대신 &lt;code&gt;rsync&lt;/code&gt; 를 사용 하여 델타를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="1c72a60e749a404cd10297501e739f5774943c7a" translate="yes" xml:space="preserve">
          <source>When updating a service with &lt;code&gt;docker service update&lt;/code&gt;, &lt;code&gt;--placement-pref-add&lt;/code&gt; appends a new placement preference after all existing placement preferences. &lt;code&gt;--placement-pref-rm&lt;/code&gt; removes an existing placement preference that matches the argument.</source>
          <target state="translated">와 서비스를 업데이트 할 때 &lt;code&gt;docker service update&lt;/code&gt; , &lt;code&gt;--placement-pref-add&lt;/code&gt; 기존의 모든 배치 환경 설정 후 새로운 배치 기본 설정을 추가합니다. &lt;code&gt;--placement-pref-rm&lt;/code&gt; 은 인수와 일치하는 기존 배치 환경 설정을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="823c92dc97c64a87d1f9aac48312bb43cae23d90" translate="yes" xml:space="preserve">
          <source>When upgrading a plugin, you should first stop the Docker daemon, upgrade the plugin, then start Docker again.</source>
          <target state="translated">플러그인을 업그레이드 할 때는 먼저 Docker 데몬을 중지하고 플러그인을 업그레이드 한 다음 Docker를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="de620616ef11ae28c032da27d732f8e37f9d844d" translate="yes" xml:space="preserve">
          <source>When used in the shell or exec formats, the &lt;code&gt;CMD&lt;/code&gt; instruction sets the command to be executed when running the image.</source>
          <target state="translated">쉘 또는 exec 형식으로 사용되는 경우 &lt;code&gt;CMD&lt;/code&gt; 명령은 이미지를 실행할 때 명령이 실행되도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="849885b59df6a3d91ea9ac787bdb44c8cc39a76a" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;file:&lt;/code&gt;, the referenced file must be present in the &lt;code&gt;CredentialSpecs&lt;/code&gt; subdirectory in the Docker data directory, which defaults to &lt;code&gt;C:\ProgramData\Docker\&lt;/code&gt; on Windows. The following example loads the credential spec from a file named &lt;code&gt;C:\ProgramData\Docker\CredentialSpecs\my-credential-spec.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;file:&lt;/code&gt; 사용할 때 참조 된 파일은 Docker 데이터 디렉토리 의 &lt;code&gt;CredentialSpecs&lt;/code&gt; 서브 디렉토리에 있어야하며, Windows의 경우 기본값은 &lt;code&gt;C:\ProgramData\Docker\&lt;/code&gt; 입니다. 다음 예제는 &lt;code&gt;C:\ProgramData\Docker\CredentialSpecs\my-credential-spec.json&lt;/code&gt; 파일에서 신임 스펙을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="64e498c034d38c25323c58ac31e6fb8586df5ded" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;registry:&lt;/code&gt;, the credential spec is read from the Windows registry on the daemon&amp;rsquo;s host. A registry value with the given name must be located in:</source>
          <target state="translated">&lt;code&gt;registry:&lt;/code&gt; 사용할 때 신임 스펙은 디먼 호스트의 Windows 레지스트리에서 읽습니다. 지정된 이름의 레지스트리 값은 다음 위치에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="82f1377990ecefd93dce58e0c09df55b49e3fa34" translate="yes" xml:space="preserve">
          <source>When using curl 7.5 and above, the URL should be of the form &lt;code&gt;http://hostname/APICall&lt;/code&gt;, where &lt;code&gt;hostname&lt;/code&gt; is the valid hostname where the plugin is installed and &lt;code&gt;APICall&lt;/code&gt; is the call to the plugin API.</source>
          <target state="translated">curl 7.5 이상을 사용하는 경우 URL은 &lt;code&gt;http://hostname/APICall&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;hostname&lt;/code&gt; 은 플러그인이 설치된 유효한 호스트 이름이고 &lt;code&gt;APICall&lt;/code&gt; 은 플러그인 API에 대한 호출입니다.</target>
        </trans-unit>
        <trans-unit id="dbd244df95e7458096b2ecfb2f0276d1dc554879" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../compose-file/index#links&quot;&gt;&amp;lsquo;links&amp;rsquo; option&lt;/a&gt; in a &lt;a href=&quot;../compose-file/index#version-1&quot;&gt;v1 Compose file&lt;/a&gt;, environment variables are created for each link. They are documented in the &lt;a href=&quot;../link-env-deprecated/index&quot;&gt;Link environment variables reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../compose-file/index#version-1&quot;&gt;v1 Compose 파일&lt;/a&gt; 에서 &lt;a href=&quot;../compose-file/index#links&quot;&gt;'links'옵션&lt;/a&gt; 을 사용하면 각 링크에 대해 환경 변수가 작성됩니다. 이것들은 &lt;a href=&quot;../link-env-deprecated/index&quot;&gt;링크 환경 변수 참조에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7235db6c8c3823f3cb87169f1cf7c9b267f011e" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;history&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, will include column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;history&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2b6d6c83e119fbfdf4e92db273938981c98779a3" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;image&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, will include column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용하는 경우 &lt;code&gt;image&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6c8581e4765da77c1306a784d789631d1c1f7649" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;ls&lt;/code&gt; command either outputs the data exactly as the template declares or, when using the table directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용하는 경우 &lt;code&gt;ls&lt;/code&gt; 명령은 템플리트가 선언 한대로 데이터를 출력하거나 테이블 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="430f7509e9fa8c581d9c478d859eff1ca3b1bd47" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;network ls&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;network ls&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3bbc4d5d656f5ad712741f8033114a4d715bf624" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;node ls&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;node ls&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a5d97583ffd6fc32dfb012d34cd4700e42c7019e" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;node ps&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;node ps&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="513456e5055e8428cf32e6a372cb34e7864f9d52" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;plugin ls&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;plugin ls&lt;/code&gt; 명령은 템플리트가 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2e5402121c7c8bcbc99df38187c01b00b01cf5cf" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;ps&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;ps&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="335c98558696c6c7c24a1a9f9ff32d9d00712b9d" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;secret ls&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, will include column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용하는 경우 &lt;code&gt;secret ls&lt;/code&gt; 명령은 템플리트가 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3b1a4a58c88ca87f88bd8cb3a0fda8e16b01f9af" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;service ls&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;service ls&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8d0ecc38204b51f55e691489a69ba521acb3845b" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;service ps&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;service ps&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="488c6110e7ade87de5fee548b14103c9f06cb94d" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;stack ls&lt;/code&gt; command either outputs the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;stack ls&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d9757c892ca4f3e590cb98aed8bb44b1b82e35e6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;stack ps&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;stack ps&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="345034efb34cc6a14d02ddff43c431dd767980a3" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;stack services&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;stack services&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8b006f4580802b246b7b8ab17e3b5d4dce7a6928" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;stats&lt;/code&gt; command either outputs the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용할 때 &lt;code&gt;stats&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b7ee8ba3f63361f675f6ab0cc39236b569ee3334" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;volume ls&lt;/code&gt; command will either output the data exactly as the template declares or, when using the &lt;code&gt;table&lt;/code&gt; directive, includes column headers as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션을 사용하는 경우 &lt;code&gt;volume ls&lt;/code&gt; 명령은 템플릿이 선언 한대로 데이터를 출력하거나 &lt;code&gt;table&lt;/code&gt; 지시문을 사용할 때 열 헤더도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="45bf98e54f499374314a08d04643fc426d44913a" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;file://&amp;lt;filename&amp;gt;&lt;/code&gt; format, the referenced file must be present in the &lt;code&gt;CredentialSpecs&lt;/code&gt; subdirectory in the docker data directory, which defaults to &lt;code&gt;C:\ProgramData\Docker\&lt;/code&gt; on Windows. For example, specifying &lt;code&gt;file://spec.json&lt;/code&gt; loads &lt;code&gt;C:\ProgramData\Docker\CredentialSpecs\spec.json&lt;/code&gt;.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;file://&amp;lt;filename&amp;gt;&lt;/code&gt; 형식을 참조 된 파일에 있어야합니다 &lt;code&gt;CredentialSpecs&lt;/code&gt; 되는시 기본값 고정 표시기 데이터 디렉토리에서 하위 디렉토리, &lt;code&gt;C:\ProgramData\Docker\&lt;/code&gt; Windows에서. 예를 들어, 지정 &lt;code&gt;file://spec.json&lt;/code&gt; 로드 &lt;code&gt;C:\ProgramData\Docker\CredentialSpecs\spec.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06c8a36a6efcdf7f49e3ae95fe569833a18e20c7" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;linode/containerlinux&lt;/code&gt;&lt;code&gt;linode-image&lt;/code&gt;, the &lt;code&gt;linode-ssh-user&lt;/code&gt; will default to &lt;code&gt;core&lt;/code&gt;</source>
          <target state="translated">사용하는 경우 &lt;code&gt;linode/containerlinux&lt;/code&gt; &lt;code&gt;linode-image&lt;/code&gt; 의 &lt;code&gt;linode-ssh-user&lt;/code&gt; 기본값이됩니다 &lt;code&gt;core&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7466867dfc0fc755525c29c2910efdffa2c686d" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;registry://&amp;lt;value-name&amp;gt;&lt;/code&gt; format, the credential spec is read from the Windows registry on the daemon&amp;rsquo;s host. The specified registry value must be located in:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;registry://&amp;lt;value-name&amp;gt;&lt;/code&gt; 형식을 자격 증명 사양은 데몬의 호스트에 Windows 레지스트리에서 읽습니다. 지정된 레지스트리 값은 다음 위치에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ccafaac6d934bc8cf5fc144e631d9b8ce5453ab3" translate="yes" xml:space="preserve">
          <source>When using this option you may see significantly more space used due to storing two copies of the image, one for the build cache with all the cache layers in tact, and one for the squashed version.</source>
          <target state="translated">이 옵션을 사용하면 이미지의 두 사본을 저장하기 때문에 사용 된 공간이 훨씬 더 많이 보일 수 있습니다. 하나는 모든 캐시 레이어가있는 빌드 캐시 용이고 다른 하나는 찌그러진 버전 용입니다.</target>
        </trans-unit>
        <trans-unit id="5846c7b13d2b2307573586b320663daeebdb3134" translate="yes" xml:space="preserve">
          <source>When working directly with the Notary client, it uses its &lt;a href=&quot;../../../../notary/reference/client-config/index#environment-variables-optional&quot;&gt;own set of environment variables&lt;/a&gt;.</source>
          <target state="translated">Notary 클라이언트와 직접 작업 할 때는 &lt;a href=&quot;../../../../notary/reference/client-config/index#environment-variables-optional&quot;&gt;자체 환경 변수 세트를&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="90901b87b4427462f10ef8d905e7b07eb42b79fb" translate="yes" xml:space="preserve">
          <source>When working with services, swarms, and &lt;code&gt;docker-stack.yml&lt;/code&gt; files, keep in mind that the tasks (containers) backing a service can be deployed on any node in a swarm, and this may be a different node each time the service is updated.</source>
          <target state="translated">서비스, ​​스웜 및 &lt;code&gt;docker-stack.yml&lt;/code&gt; 파일로 작업 할 때 서비스를 지원하는 작업 (컨테이너)은 스웜의 모든 노드에 배포 할 수 있으며 서비스가 업데이트 될 때마다 다른 노드가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0899512fb68dc41c44f35ffd3ccea4d191f1d86" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;../service_create/index&quot;&gt;create a service&lt;/a&gt;, you can use node labels as a constraint. A constraint limits the nodes where the scheduler deploys tasks for a service.</source>
          <target state="translated">&lt;a href=&quot;../service_create/index&quot;&gt;서비스&lt;/a&gt; 를 작성할 때 노드 레이블을 제한 조건으로 사용할 수 있습니다. 제약 조건은 스케줄러가 서비스 작업을 배포하는 노드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="d7c771034895ec3f7ed0fbdd4cc4cb51cb731c55" translate="yes" xml:space="preserve">
          <source>When you access port 8080 on any node, Docker routes your request to an active container. On the swarm nodes themselves, port 8080 may not actually be bound, but the routing mesh knows how to route the traffic and prevents any port conflicts from happening.</source>
          <target state="translated">모든 노드에서 포트 8080에 액세스하면 Docker는 요청을 활성 컨테이너로 라우팅합니다. 스웜 노드 자체에서 포트 8080은 실제로 바인딩되지 않을 수 있지만 라우팅 메시는 트래픽을 라우팅하는 방법을 알고 포트 충돌이 발생하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="4774129b1035118342dd4dd61bce087e0c81d044" translate="yes" xml:space="preserve">
          <source>When you access the HAProxy load balancer on port 80, it forwards requests to nodes in the swarm. The swarm routing mesh routes the request to an active task. If, for any reason the swarm scheduler dispatches tasks to different nodes, you don&amp;rsquo;t need to reconfigure the load balancer.</source>
          <target state="translated">포트 80에서 HAProxy로드 밸런서에 액세스하면 스웜의 노드로 요청을 전달합니다. 스웜 라우팅 메시는 요청을 활성 작업으로 라우팅합니다. 어떤 이유로 든 스웜 스케줄러가 작업을 다른 노드로 디스패치 할 경우로드 밸런서를 재구성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="476585f7d5df6e4cd70e304a918d6c853c1dee8a" translate="yes" xml:space="preserve">
          <source>When you add a config to the swarm, Docker sends the config to the swarm manager over a mutual TLS connection. The config is stored in the Raft log, which is encrypted. The entire Raft log is replicated across the other managers, ensuring the same high availability guarantees for configs as for the rest of the swarm management data.</source>
          <target state="translated">swarm에 구성을 추가하면 Docker는 상호 TLS 연결을 통해 구성을 swarm 관리자에게 보냅니다. 구성은 Raft 로그에 저장되며 암호화됩니다. 전체 Raft 로그는 다른 관리자에게 복제되어 나머지 떼 관리 데이터와 동일한 구성에 대해 동일한 고 가용성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="706af2bc12db923cb2cea566b5db8fe83652902a" translate="yes" xml:space="preserve">
          <source>When you add a secret to the swarm, Docker sends the secret to the swarm manager over a mutual TLS connection. The secret is stored in the Raft log, which is encrypted. The entire Raft log is replicated across the other managers, ensuring the same high availability guarantees for secrets as for the rest of the swarm management data.</source>
          <target state="translated">웜에 비밀을 추가하면 Docker는 상호 TLS 연결을 통해 웜 관리자에게 비밀을 보냅니다. 비밀은 암호화 된 Raft 로그에 저장됩니다. 전체 Raft 로그는 다른 관리자에게 복제되어 나머지 떼 관리 데이터와 동일한 비밀 보장을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="6beadc11369cf61c573f0af34179fb193166dee9" translate="yes" xml:space="preserve">
          <source>When you are done, and want to clean up all the services you&amp;rsquo;ve started and any anonymous volumes that have been created, just run the following command in the directory where you&amp;rsquo;ve created your Docker Compose file:</source>
          <target state="translated">완료하고 시작한 모든 서비스와 작성된 익명 볼륨을 정리하려면 Docker Compose 파일을 작성한 디렉토리에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d0a684e5260498f211bb1ab67536d98bdb80496e" translate="yes" xml:space="preserve">
          <source>When you configure Docker to use the &lt;code&gt;userns-remap&lt;/code&gt; feature, you can optionally specify an existing user and/or group, or you can specify &lt;code&gt;default&lt;/code&gt;. If you specify &lt;code&gt;default&lt;/code&gt;, a user and group &lt;code&gt;dockremap&lt;/code&gt; is created and used for this purpose.</source>
          <target state="translated">&lt;code&gt;userns-remap&lt;/code&gt; 기능 을 사용하도록 Docker를 구성 할 때 선택적으로 기존 사용자 및 / 또는 그룹을 지정하거나 &lt;code&gt;default&lt;/code&gt; 를 지정할 수 있습니다 . &lt;code&gt;default&lt;/code&gt; 를 지정 하면 사용자 및 그룹 &lt;code&gt;dockremap&lt;/code&gt; 이 작성 되어이 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e67729a34e921a29f603afdb24720ecd5bfc9c6" translate="yes" xml:space="preserve">
          <source>When you copy files to a remote server with &lt;code&gt;docker-machine scp&lt;/code&gt; for app deployment, make sure &lt;code&gt;docker-compose&lt;/code&gt; and the Docker daemon know how to find them. Avoid using relative paths, but specify absolute paths in &lt;a href=&quot;../../../compose/compose-file/index&quot;&gt;Compose files&lt;/a&gt;. It&amp;rsquo;s best to specify absolute paths both for the location on the Docker daemon and within the container.</source>
          <target state="translated">앱 배포를 위해 &lt;code&gt;docker-machine scp&lt;/code&gt; 를 사용하여 파일을 원격 서버에 복사하는 경우 &lt;code&gt;docker-compose&lt;/code&gt; 및 Docker 데몬이 파일을 찾는 방법을 알고 있어야합니다. 상대 경로는 사용하지 말고 &lt;a href=&quot;../../../compose/compose-file/index&quot;&gt;파일 작성&lt;/a&gt; 에서 절대 경로를 지정 하십시오 . Docker 데몬의 위치와 컨테이너 내에서 절대 경로를 지정하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2e19d68c5617be6a215c196b5ce12b135a0e45b1" translate="yes" xml:space="preserve">
          <source>When you create a network, Engine creates a non-overlapping subnetwork for the network by default. This subnetwork is not a subdivision of an existing network. It is purely for ip-addressing purposes. You can override this default and specify subnetwork values directly using the &lt;code&gt;--subnet&lt;/code&gt; option. On a &lt;code&gt;bridge&lt;/code&gt; network you can only create a single subnet:</source>
          <target state="translated">네트워크를 만들면 엔진은 기본적으로 네트워크에 겹치지 않는 하위 네트워크를 만듭니다. 이 서브 네트워크는 기존 네트워크의 서브 디비전이 아닙니다. 순전히 ip-addressing 목적입니다. &lt;code&gt;--subnet&lt;/code&gt; 옵션을 사용하여이 기본값을 무시하고 서브 네트워크 값을 직접 지정할 수 있습니다 . A의 &lt;code&gt;bridge&lt;/code&gt; 네트워크는 단일 서브넷을 생성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="efad2531fc84b01f5db39e8cc0778613f7dd6902" translate="yes" xml:space="preserve">
          <source>When you create a service and pass the &lt;code&gt;--network&lt;/code&gt; flag to attach the service to the overlay network:</source>
          <target state="translated">서비스를 생성하고 &lt;code&gt;--network&lt;/code&gt; 플래그를 전달 하여 서비스를 오버레이 네트워크에 연결하는 경우 :</target>
        </trans-unit>
        <trans-unit id="97539d35326c69e062ae463f08cfadb1fe386e3d" translate="yes" xml:space="preserve">
          <source>When you create a service without specifying any details about the version of the image to use, the service uses the version tagged with the &lt;code&gt;latest&lt;/code&gt; tag. You can force the service to use a specific version of the image in a few different ways, depending on your desired outcome.</source>
          <target state="translated">사용할 이미지 버전에 대한 세부 사항을 지정하지 않고 서비스를 작성하면 서비스는 &lt;code&gt;latest&lt;/code&gt; 태그로 태그가 지정된 버전을 사용합니다 . 원하는 결과에 따라 서비스가 몇 가지 다른 방식으로 특정 버전의 이미지를 사용하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8b846c1bbcdc806a9bacb09c56af8ab59a611d5" translate="yes" xml:space="preserve">
          <source>When you create a service, the image&amp;rsquo;s tag is resolved to the specific digest the tag points to &lt;strong&gt;at the time of service creation&lt;/strong&gt;. Worker nodes for that service use that specific digest forever unless the service is explicitly updated. This feature is particularly important if you do use often-changing tags such as &lt;code&gt;latest&lt;/code&gt;, because it ensures that all service tasks use the same version of the image.</source>
          <target state="translated">서비스를 만들 때 이미지의 태그는 &lt;strong&gt;서비스 생성시&lt;/strong&gt; 태그가 가리키는 특정 다이제스트로 확인됩니다 . 해당 서비스의 작업자 노드는 서비스가 명시 적으로 업데이트되지 않는 한 특정 다이제스트를 영원히 사용합니다. 이 기능은 모든 서비스 작업이 동일한 버전의 이미지를 사용하도록하기 때문에 &lt;code&gt;latest&lt;/code&gt; 와 같이 자주 변경되는 태그를 사용하는 경우 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="03ba6de5f08a9af3b92b170610e5a49220315a81" translate="yes" xml:space="preserve">
          <source>When you create a service, you can specify a rolling update behavior for how the swarm should apply changes to the service when you run &lt;code&gt;docker service update&lt;/code&gt;. You can also specify these flags as part of the update, as arguments to &lt;code&gt;docker service update&lt;/code&gt;.</source>
          <target state="translated">서비스를 만들 때 &lt;code&gt;docker service update&lt;/code&gt; 를 실행할 때 웜이 서비스에 변경 사항을 적용하는 방법에 대한 롤링 업데이트 동작을 지정할 수 있습니다 . &lt;code&gt;docker service update&lt;/code&gt; 의 인수로 이러한 플래그를 업데이트의 일부로 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1486beabe526befe73c2865ebe0d6bbe06a84f57" translate="yes" xml:space="preserve">
          <source>When you create a service, you specify which container image to use and which commands to execute inside running containers.</source>
          <target state="translated">서비스를 만들 때 사용할 컨테이너 이미지와 실행중인 컨테이너 내에서 실행할 명령을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0b744cd9fa1f5aae250605eb29d90a39b9bea360" translate="yes" xml:space="preserve">
          <source>When you create a service, you specify which container image to use and which commands to execute inside running containers. You also define options for the service including:</source>
          <target state="translated">서비스를 만들 때 사용할 컨테이너 이미지와 실행중인 컨테이너 내에서 실행할 명령을 지정합니다. 또한 다음을 포함하여 서비스 옵션을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b9ed198b28ef67d8249822a3deeef304c229fa27" translate="yes" xml:space="preserve">
          <source>When you create a swarm by running &lt;code&gt;docker swarm init&lt;/code&gt;, Docker designates itself as a manager node. By default, the manager node generates a new root Certificate Authority (CA) along with a key pair, which are used to secure communications with other nodes that join the swarm. If you prefer, you can specify your own externally-generated root CA, using the &lt;code&gt;--external-ca&lt;/code&gt; flag of the &lt;a href=&quot;../../../reference/commandline/swarm_init/index&quot;&gt;docker swarm init&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;docker swarm init&lt;/code&gt; 를 실행하여 swarm을 만들면 Docker는 자신을 관리자 노드로 지정합니다. 기본적으로 관리자 노드는 웜에 가입 한 다른 노드와의 통신을 보호하는 데 사용되는 키 페어와 함께 새로운 루트 인증 기관 (CA)을 생성합니다. 원하는 경우 &lt;a href=&quot;../../../reference/commandline/swarm_init/index&quot;&gt;docker swarm init&lt;/a&gt; 명령 의 &lt;code&gt;--external-ca&lt;/code&gt; 플래그를 사용하여 외부에서 생성 한 루트 CA를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="425387b1ef6a4e44c2586331f5248d4d8f67f1c1" translate="yes" xml:space="preserve">
          <source>When you create a swarm service, you can publish that service&amp;rsquo;s ports to hosts outside the swarm in two ways:</source>
          <target state="translated">스웜 서비스를 생성하면 다음 두 가지 방법으로 해당 서비스의 포트를 스웜 외부의 호스트에 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c40fd94784d76593594a35ed557e50b35778e510" translate="yes" xml:space="preserve">
          <source>When you define your app with Compose in development, you can use this definition to run your application in different environments such as CI, staging, and production.</source>
          <target state="translated">개발 중 Compose를 사용하여 앱을 정의 할 때이 정의를 사용하여 CI, 스테이징 및 프로덕션과 같은 다른 환경에서 애플리케이션을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcc15d665ed4054bc8895cda4d2758f38c7a4cd" translate="yes" xml:space="preserve">
          <source>When you deploy the service to the swarm, the swarm manager accepts your service definition as the desired state for the service. Then it schedules the service on nodes in the swarm as one or more replica tasks. The tasks run independently of each other on nodes in the swarm.</source>
          <target state="translated">웜에 서비스를 배포 할 때 웜 관리자는 서비스 정의를 원하는 서비스 상태로 받아들입니다. 그런 다음 swarm의 노드에서 서비스를 하나 이상의 복제 작업으로 예약합니다. 작업은 떼의 노드에서 서로 독립적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f34984626d0b7e92e15d11f51b567b42c8154657" translate="yes" xml:space="preserve">
          <source>When you deploy, Docker mounts a file under &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; in the services. These files are never persisted in disk, but are managed in memory.</source>
          <target state="translated">배포 할 때 Docker는 서비스의 &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; 아래에 파일을 마운트 합니다. 이러한 파일은 디스크에 유지되지 않지만 메모리에서 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="9b73d905ca12539a125f7665b770f5926d517e20" translate="yes" xml:space="preserve">
          <source>When you drain a node, the scheduler reassigns any tasks running on the node to other available worker nodes in the swarm. It also prevents the scheduler from assigning tasks to the node.</source>
          <target state="translated">노드를 비울 때 스케줄러는 노드에서 실행중인 모든 작업을 떼의 다른 사용 가능한 작업자 노드에 다시 할당합니다. 또한 스케줄러가 태스크를 노드에 지정하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="50973d4f7bd68037beced46954015877e87b60b0" translate="yes" xml:space="preserve">
          <source>When you first create a swarm, you place a single Docker Engine into swarm mode. To take full advantage of swarm mode you can add nodes to the swarm:</source>
          <target state="translated">스웜을 처음 만들 때 단일 Docker 엔진을 스웜 모드로 설정합니다. swarm 모드를 최대한 활용하려면 swarm에 노드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8dccb8738e2600e38e5b10a9c28cb91449c812c" translate="yes" xml:space="preserve">
          <source>When you first install and start working with Docker Engine, swarm mode is disabled by default. When you enable swarm mode, you work with the concept of services managed through the &lt;code&gt;docker service&lt;/code&gt; command.</source>
          <target state="translated">Docker Engine을 처음 설치하고 작업을 시작하면 기본적으로 웜 모드가 비활성화됩니다. 스웜 모드를 활성화하면 &lt;code&gt;docker service&lt;/code&gt; 명령을 통해 관리되는 서비스 개념을 사용하게됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c7249aba780563c809f2db930abdc6e1bfd6962" translate="yes" xml:space="preserve">
          <source>When you grant a newly-created or running service access to a config, the config is mounted as a file in the container. The location of the mount point within the container defaults to &lt;code&gt;/&amp;lt;config-name&amp;gt;&lt;/code&gt; in Linux containers. In Windows containers, configs are all mounted into &lt;code&gt;C:\ProgramData\Docker\configs&lt;/code&gt; and symbolic links are created to the desired location, which defaults to &lt;code&gt;C:\&amp;lt;config-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">새로 작성되었거나 실행중인 서비스에 구성에 대한 액세스 권한을 부여하면 구성이 컨테이너에 파일로 마운트됩니다. 컨테이너 내 마운트 지점의 위치는 Linux 컨테이너에서 &lt;code&gt;/&amp;lt;config-name&amp;gt;&lt;/code&gt; 으로 기본 설정 됩니다. Windows 컨테이너에서 구성은 모두 &lt;code&gt;C:\ProgramData\Docker\configs&lt;/code&gt; 마운트되고 기호 링크는 원하는 위치에 작성되며 기본값은 &lt;code&gt;C:\&amp;lt;config-name&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ee41a6c4dd4b46589cf697136a0dcb8c0d62b8c" translate="yes" xml:space="preserve">
          <source>When you grant a newly-created or running service access to a secret, the decrypted secret is mounted into the container in an in-memory filesystem. The location of the mount point within the container defaults to &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; in Linux containers, or &lt;code&gt;C:\ProgramData\Docker\secrets&lt;/code&gt; in Windows containers. You can specify a custom location in Docker 17.06 and higher.</source>
          <target state="translated">새로 생성되었거나 실행중인 서비스에 비밀에 대한 액세스 권한을 부여하면 해독 된 비밀이 메모리 내 파일 시스템의 컨테이너에 마운트됩니다. 컨테이너 내의 마운트 지점 위치는 기본적으로 Linux 컨테이너의 경우 &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; 또는 Windows 컨테이너의 경우 &lt;code&gt;C:\ProgramData\Docker\secrets&lt;/code&gt; 입니다. Docker 17.06 이상에서 사용자 정의 위치를 ​​지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebc514bab4714886f47b65daa8d1cc1cb2a839a9" translate="yes" xml:space="preserve">
          <source>When you have &lt;a href=&quot;../deploy-service/index&quot;&gt;deployed a service&lt;/a&gt; to your swarm, you can use the Docker CLI to see details about the service running in the swarm.</source>
          <target state="translated">당신이 한 경우 &lt;a href=&quot;../deploy-service/index&quot;&gt;서비스를 전개&lt;/a&gt; 하여 떼에, 당신은 무리에서 실행중인 서비스에 대한 세부 정보를 볼 수 도커 CLI를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e6a72db5067c8c45a49a31d45b2cccdec963330" translate="yes" xml:space="preserve">
          <source>When you have multiple Docker servers, or build unrelated Docker containers which can&amp;rsquo;t make use of the Docker build cache, it can be useful to have a caching proxy for your packages. This container makes the second download of any package almost instant.</source>
          <target state="translated">여러 Docker 서버가 있거나 Docker 빌드 캐시를 사용할 수없는 관련되지 않은 Docker 컨테이너를 빌드하는 경우 패키지에 캐싱 프록시를 사용하는 것이 유용 할 수 있습니다. 이 컨테이너는 모든 패키지의 두 번째 다운로드를 거의 즉시 만듭니다.</target>
        </trans-unit>
        <trans-unit id="227a9aa4df9134eec2610dbc3759daf153f5d97b" translate="yes" xml:space="preserve">
          <source>When you initialize a new swarm, you can use the &lt;code&gt;--autolock&lt;/code&gt; flag to enable autolocking of swarm manager nodes when Docker restarts.</source>
          <target state="translated">새 swarm을 초기화 할 때 &lt;code&gt;--autolock&lt;/code&gt; 플래그를 사용하여 Docker가 다시 시작될 때 swarm manager 노드의 자동 잠금을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fd7e62869c95d9c7b891f332c27a85b900503eb" translate="yes" xml:space="preserve">
          <source>When you install Docker Machine, you get a set of drivers for various cloud providers (like Amazon Web Services, DigitalOcean, or Microsoft Azure) and local providers (like Oracle VirtualBox, VMWare Fusion, or Microsoft Hyper-V).</source>
          <target state="translated">Docker Machine을 설치하면 다양한 클라우드 공급자 (Amazon Web Services, DigitalOcean 또는 Microsoft Azure) 및 로컬 공급자 (Oracle VirtualBox, VMWare Fusion 또는 Microsoft Hyper-V)를위한 드라이버 세트가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4748ebd19f4904a354dddd52e21ae5a210180134" translate="yes" xml:space="preserve">
          <source>When you issue the &lt;code&gt;docker swarm ca --rotate&lt;/code&gt; command, the following things happen in sequence:</source>
          <target state="translated">당신은 실행하면 &lt;code&gt;docker swarm ca --rotate&lt;/code&gt; 명령을 다음과 같은 일이 순차적으로 일어날 :</target>
        </trans-unit>
        <trans-unit id="9be1ec1c3aa439d6a8f3799366b6483c1b3d0fdb" translate="yes" xml:space="preserve">
          <source>When you make changes to your app code, remember to rebuild your image and recreate your app&amp;rsquo;s containers. To redeploy a service called &lt;code&gt;web&lt;/code&gt;, use:</source>
          <target state="translated">앱 코드를 변경할 때는 이미지를 다시 작성하고 앱 컨테이너를 다시 작성해야합니다. &lt;code&gt;web&lt;/code&gt; 이라는 서비스를 재배치하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="181c3985bd54dc8a7f5e0263b672f843275ab7da" translate="yes" xml:space="preserve">
          <source>When you play in the sandbox, you also create root and repository keys. The sandbox is configured to store all the keys and files inside the &lt;code&gt;trustsandbox&lt;/code&gt; container. Since the keys you create in the sandbox are for play only, destroying the container destroys them as well.</source>
          <target state="translated">샌드 박스에서 재생할 때 루트 및 리포지토리 키도 생성합니다. 샌드 박스는 모든 키와 파일을 &lt;code&gt;trustsandbox&lt;/code&gt; 컨테이너 안에 저장하도록 구성되어 있습니다 . 샌드 박스에서 생성 한 키는 재생 용이므로 컨테이너를 파괴하면 키도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="d98cb1a8e6388f3184b434ac6bea88d4430f1f63" translate="yes" xml:space="preserve">
          <source>When you publish a service port using &lt;code&gt;ingress&lt;/code&gt; mode, the swarm routing mesh makes the service accessible at the published port on every node regardless if there is a task for the service running on the node. If you use &lt;code&gt;host&lt;/code&gt; mode, the port is only bound on nodes where the service is running, and a given port on a node can only be bound once. You can only set the publication mode using the long syntax. For more information refer to &lt;a href=&quot;../../../swarm/ingress/index&quot;&gt;Use swarm mode routing mesh&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ingress&lt;/code&gt; 모드를 사용하여 서비스 포트를 게시 하면 스웜 라우팅 메시는 서비스가 노드에서 실행중인 작업에 관계없이 모든 노드의 게시 된 포트에서 서비스에 액세스 할 수 있도록합니다. &lt;code&gt;host&lt;/code&gt; 모드 를 사용하는 경우 포트는 서비스가 실행중인 노드에서만 바인드되며 노드의 지정된 포트는 한 번만 바인드 될 수 있습니다. 긴 구문을 사용하여 게시 모드 만 설정할 수 있습니다. 자세한 정보는 &lt;a href=&quot;../../../swarm/ingress/index&quot;&gt;스웜 모드 라우팅 메쉬 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b358de5f2366722230c389dc3af8cae955a51f5" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;docker swarm join&lt;/code&gt; and pass the manager token, the Docker Engine switches into swarm mode the same as for workers. Manager nodes also participate in the raft consensus. The new nodes should be &lt;code&gt;Reachable&lt;/code&gt;, but the existing manager remains the swarm &lt;code&gt;Leader&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;docker swarm join&lt;/code&gt; 을 실행 하고 관리자 토큰을 전달하면 Docker 엔진은 작업자와 동일하게 swarm 모드로 전환됩니다. 관리자 노드는 또한 뗏목 합의에 참여합니다. 새 노드는 &lt;code&gt;Reachable&lt;/code&gt; 해야 하지만 기존 관리자는 떼 &lt;code&gt;Leader&lt;/code&gt; 남아 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9aa31e4be234ea9be34dc4b55b5975444c30de17" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;docker-compose up&lt;/code&gt; it reads the overrides automatically.</source>
          <target state="translated">&lt;code&gt;docker-compose up&lt;/code&gt; 을 실행 하면 재정의를 자동으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b7a1e41fc9ef791323721c8081a92c6b380fbbe8" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;docker-compose up&lt;/code&gt; with this configuration, Compose looks for the &lt;code&gt;POSTGRES_VERSION&lt;/code&gt; environment variable in the shell and substitutes its value in. For this example, Compose resolves the &lt;code&gt;image&lt;/code&gt; to &lt;code&gt;postgres:9.3&lt;/code&gt; before running the configuration.</source>
          <target state="translated">이 구성으로 &lt;code&gt;docker-compose up&lt;/code&gt; 를 실행하면 Compose는 셸에서 &lt;code&gt;POSTGRES_VERSION&lt;/code&gt; 환경 변수를 찾아 그 값을 대체합니다.이 예에서 Compose 는 구성을 실행하기 전에 &lt;code&gt;image&lt;/code&gt; 를 &lt;code&gt;postgres:9.3&lt;/code&gt; 으로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="e12bfaac846841252dc0fec7e38897794bae3d8b" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;docker-compose up&lt;/code&gt;, the &lt;code&gt;web&lt;/code&gt; service defined above uses the image &lt;code&gt;webapp:v1.5&lt;/code&gt;. You can verify this with the &lt;a href=&quot;../reference/config/index&quot;&gt;config command&lt;/a&gt;, which prints your resolved application config to the terminal:</source>
          <target state="translated">당신이 실행할 때 &lt;code&gt;docker-compose up&lt;/code&gt; 의 &lt;code&gt;web&lt;/code&gt; 사용 이미지 위에 정의 된 서비스 &lt;code&gt;webapp:v1.5&lt;/code&gt; . &lt;a href=&quot;../reference/config/index&quot;&gt;config 명령을&lt;/a&gt; 사용하여이를 확인할 수 있습니다 . 이는 해결 된 애플리케이션 구성을 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="769848490fa8b9bd71e97a90ce524eb9302c98de" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;docker-compose up&lt;/code&gt;, the following happens:</source>
          <target state="translated">&lt;code&gt;docker-compose up&lt;/code&gt; 을 실행 하면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e7d318565f3027259008aa0cf835c852a704f761" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;service update&lt;/code&gt; with the &lt;code&gt;--image&lt;/code&gt; flag, the swarm manager queries Docker Hub or your private Docker registry for the digest the tag currently points to and updates the service tasks to use that digest.</source>
          <target state="translated">&lt;code&gt;--image&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;service update&lt;/code&gt; 를 실행 하면 swarm 관리자는 Docker Hub 또는 개인 Docker 레지스트리에 현재 태그가 가리키는 다이제스트를 쿼리하고 해당 다이제스트를 사용하도록 서비스 작업을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1e001c42af74019f63f06aae03d9090fcc8c3bfa" translate="yes" xml:space="preserve">
          <source>When you run a &lt;a href=&quot;../service_update/index&quot;&gt;service update&lt;/a&gt;, the scheduler updates a maximum of 2 tasks at a time, with &lt;code&gt;10s&lt;/code&gt; between updates. For more information, refer to the &lt;a href=&quot;../../../swarm/swarm-tutorial/rolling-update/index&quot;&gt;rolling updates tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../service_update/index&quot;&gt;서비스 업데이트&lt;/a&gt; 를 실행 하면 스케줄러가 한 번에 최대 2 개의 작업을 업데이트하고 업데이트 간격 은 &lt;code&gt;10s&lt;/code&gt; 입니다. 자세한 정보는 &lt;a href=&quot;../../../swarm/swarm-tutorial/rolling-update/index&quot;&gt;롤링 업데이트 학습서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe8353be6e6c84c145bacb17c4d3aa92a8d805c3" translate="yes" xml:space="preserve">
          <source>When you run a &lt;code&gt;docker pull&lt;/code&gt; command, Docker Engine is using an integrated Notary library (the same one as Notary CLI) to request the mapping of tag to sha256 digest for the one tag you are interested in (or if you passed the &lt;code&gt;--all&lt;/code&gt; flag, the client uses the list operation to efficiently retrieve all the mappings). Having validated the signatures on the trust data, the client instructs the Engine to do a &amp;ldquo;pull by digest&amp;rdquo;. During this pull, the Engine uses the sha256 checksum as a content address to request and validate the image manifest from the Docker registry.</source>
          <target state="translated">&lt;code&gt;docker pull&lt;/code&gt; 명령 을 실행할 때 Docker Engine은 통합 된 Notary 라이브러리 (Notary CLI와 동일한 라이브러리)를 사용하여 관심있는 하나의 태그 (또는 &lt;code&gt;--all&lt;/code&gt; 을 전달한 경우)에 대해 sha256 다이제스트에 태그의 매핑을 요청합니다. 클라이언트는 목록 작업을 사용하여 모든 매핑을 효율적으로 검색합니다. 신뢰 데이터에서 서명의 유효성을 검사 한 후 클라이언트는 엔진에 &quot;다이제스트 풀 (pull by digest)&quot;을 수행하도록 지시합니다. 이 풀 동안 엔진은 sha256 체크섬을 콘텐츠 주소로 사용하여 Docker 레지스트리에서 이미지 매니페스트를 요청하고 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="0f8812f0025bfda9b648a91a70d4c415d7cc227b" translate="yes" xml:space="preserve">
          <source>When you run a container, it uses the &lt;code&gt;docker-default&lt;/code&gt; policy unless you override it with the &lt;code&gt;security-opt&lt;/code&gt; option. For example, the following explicitly specifies the default policy:</source>
          <target state="translated">컨테이너를 실행할 때 &lt;code&gt;security-opt&lt;/code&gt; 옵션으로 재정의하지 않는 한 &lt;code&gt;docker-default&lt;/code&gt; 정책을 사용합니다 . 예를 들어 다음은 기본 정책을 명시 적으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1e6aa4e5faa2a45e376f9b3bedd3a469848e8e6f" translate="yes" xml:space="preserve">
          <source>When you run a container, it uses the default profile unless you override it with the &lt;code&gt;--security-opt&lt;/code&gt; option. For example, the following explicitly specifies a policy:</source>
          <target state="translated">컨테이너를 실행할 때 &lt;code&gt;--security-opt&lt;/code&gt; 옵션으로 재정의하지 않는 한 기본 프로필이 사용 됩니다. 예를 들어, 다음은 명시 적으로 정책을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="61bf4508a1257561b77a529715856368bdb729a4" translate="yes" xml:space="preserve">
          <source>When you run a swarm of Docker Engines, &lt;strong&gt;manager nodes&lt;/strong&gt; are the key components for managing the swarm and storing the swarm state. It is important to understand some key features of manager nodes to properly deploy and maintain the swarm.</source>
          <target state="translated">Docker Engine의 떼를 실행할 때 &lt;strong&gt;관리자 노드&lt;/strong&gt; 는 떼를 관리하고 떼 상태를 저장하기위한 핵심 구성 요소입니다. 떼를 올바르게 배치하고 유지 관리하려면 관리자 노드의 일부 주요 기능을 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="72d32934008766b5c46ded52e53dd889b220a00b" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;docker swarm init&lt;/code&gt; command with the &lt;code&gt;--force-new-cluster&lt;/code&gt; flag, the Docker Engine where you run the command becomes the manager node of a single-node swarm which is capable of managing and running services. The manager has all the previous information about services and tasks, worker nodes are still part of the swarm, and services are still running. You need to add or re-add manager nodes to achieve your previous task distribution and ensure that you have enough managers to maintain high availability and prevent losing the quorum.</source>
          <target state="translated">당신은 실행하면 &lt;code&gt;docker swarm init&lt;/code&gt; 와 명령을 &lt;code&gt;--force-new-cluster&lt;/code&gt; 플래그, 당신이 명령을 실행 도커 엔진 관리 및 서비스를 실행 할 수있는 단일 노드 떼의 매니저 노드가된다. 관리자는 서비스 및 작업에 대한 모든 이전 정보를 가지고 있으며 작업자 노드는 여전히 웜의 일부이며 서비스는 여전히 실행 중입니다. 이전 작업 분배를 달성하고 고 가용성을 유지하고 쿼럼 손실을 방지하기에 충분한 관리자가 있는지 확인하려면 관리자 노드를 추가하거나 다시 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="2ffbaa86e33367e6a7467bdc6bea428c7d40a1e1" translate="yes" xml:space="preserve">
          <source>When you run the Engine in swarm mode on your local machine, you can create and test services based upon images you&amp;rsquo;ve created or other available images. In your production environment, swarm mode provides a fault-tolerant platform with cluster management features to keep your services running and available.</source>
          <target state="translated">로컬 머신에서 스웜 모드로 엔진을 실행하면 생성 한 이미지 또는 사용 가능한 다른 이미지를 기반으로 서비스를 생성하고 테스트 할 수 있습니다. 프로덕션 환경에서 swarm 모드는 클러스터 관리 기능이있는 내결함성 플랫폼을 제공하여 서비스를 계속 실행하고 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="750c4b710d0cb74402ddfba17f73f7d0eb3ab307" translate="yes" xml:space="preserve">
          <source>When you run the command to create a swarm, the Docker Engine starts running in swarm mode.</source>
          <target state="translated">스웜을 생성하기 위해 명령을 실행하면 Docker 엔진이 스웜 모드에서 실행되기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d992273270b65a90a731d6f61610be5b8525d3ee" translate="yes" xml:space="preserve">
          <source>When you run the container, the environment variable defined in the Compose file takes precedence.</source>
          <target state="translated">컨테이너를 실행할 때 작성 파일에 정의 된 환경 변수가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3abb5399848c4ee635f216af3eb628543f771345" translate="yes" xml:space="preserve">
          <source>When you run the container, you can see that &lt;code&gt;top&lt;/code&gt; is the only process:</source>
          <target state="translated">컨테이너를 실행하면 &lt;code&gt;top&lt;/code&gt; 이 유일한 프로세스 임을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51557aa9da2407a3cd428affbfa7c31e0188d702" translate="yes" xml:space="preserve">
          <source>When you run this command on a worker, that worker leaves the swarm.</source>
          <target state="translated">작업자에서이 명령을 실행하면 해당 작업자가 떼에서 나옵니다.</target>
        </trans-unit>
        <trans-unit id="98687e0b4ae89bd66bce98ffa41c159a344ca9ee" translate="yes" xml:space="preserve">
          <source>When you run this image, you&amp;rsquo;ll see the single &lt;code&gt;PID 1&lt;/code&gt; process:</source>
          <target state="translated">이 이미지를 실행하면 단일 &lt;code&gt;PID 1&lt;/code&gt; 프로세스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="351351567aaf46c905a0b66edac7f236d7ce9f87" translate="yes" xml:space="preserve">
          <source>When you set the node back to &lt;code&gt;Active&lt;/code&gt; availability, it can receive new tasks:</source>
          <target state="translated">노드를 다시 &lt;code&gt;Active&lt;/code&gt; 가용성으로 설정하면 새 작업을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28595c7309ac3f4d61a93d465dc644caf9420d22" translate="yes" xml:space="preserve">
          <source>When you set the same environment variable in multiple files, here&amp;rsquo;s the priority used by Compose to choose which value to use:</source>
          <target state="translated">여러 파일에서 동일한 환경 변수를 설정하는 경우 사용할 값을 선택하기 위해 작성에 사용되는 우선 순위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="54fb08685f8af27002faa75fd1cef88f1b76e09a" translate="yes" xml:space="preserve">
          <source>When you specify multiple networks, the command attempts to delete each in turn. If the deletion of one network fails, the command continues to the next on the list and tries to delete that. The command reports success or failure for each deletion.</source>
          <target state="translated">여러 네트워크를 지정하면 명령은 각 네트워크를 차례로 삭제하려고 시도합니다. 한 네트워크의 삭제에 실패하면 명령은 목록에서 다음 네트워크로 계속 진행하여 삭제를 시도합니다. 이 명령은 각 삭제에 대한 성공 또는 실패를보고합니다.</target>
        </trans-unit>
        <trans-unit id="706807a25a8e54da896fbcaa01fe782d538959bb" translate="yes" xml:space="preserve">
          <source>When you start a WordPress container, you provide it with the parameters it needs by setting them as environment variables. The WordPress image has been updated so that the environment variables which contain important data for WordPress, such as &lt;code&gt;WORDPRESS_DB_PASSWORD&lt;/code&gt;, also have variants which can read their values from a file (&lt;code&gt;WORDPRESS_DB_PASSWORD_FILE&lt;/code&gt;). This strategy ensures that backward compatibility is preserved, while allowing your container to read the information from a Docker-managed secret instead of being passed directly.</source>
          <target state="translated">WordPress 컨테이너를 시작할 때 환경 변수로 설정하여 필요한 매개 변수를 제공합니다. WordPress 이미지가 업데이트되어 &lt;code&gt;WORDPRESS_DB_PASSWORD&lt;/code&gt; 와 같이 WordPress에 대한 중요한 데이터가 포함 된 환경 변수 에도 파일에서 값을 읽을 수있는 변형 ( &lt;code&gt;WORDPRESS_DB_PASSWORD_FILE&lt;/code&gt; )이 있습니다. 이 전략은 하위 호환성을 유지하면서 컨테이너가 직접 전달되지 않고 Docker 관리 비밀 정보를 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="f203cb316009fe72169e51e61661922166053c2a" translate="yes" xml:space="preserve">
          <source>When you start a container use the &lt;code&gt;--network&lt;/code&gt; flag to connect it to a network. This adds the &lt;code&gt;busybox&lt;/code&gt; container to the &lt;code&gt;my-net&lt;/code&gt; network.</source>
          <target state="translated">컨테이너를 시작할 때 &lt;code&gt;--network&lt;/code&gt; 플래그를 사용하여 컨테이너 를 네트워크에 연결하십시오. 그러면 &lt;code&gt;busybox&lt;/code&gt; 컨테이너가 &lt;code&gt;my-net&lt;/code&gt; 네트워크에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="08628f8b0765690e72e520f6f47c23348a00e7ee" translate="yes" xml:space="preserve">
          <source>When you start a container, use the &lt;code&gt;--network&lt;/code&gt; flag to connect it to a network. This example adds the &lt;code&gt;busybox&lt;/code&gt; container to the &lt;code&gt;mynet&lt;/code&gt; network:</source>
          <target state="translated">컨테이너를 시작할 때 &lt;code&gt;--network&lt;/code&gt; 플래그를 사용하여 컨테이너 를 네트워크에 연결하십시오. 이 예제는 &lt;code&gt;busybox&lt;/code&gt; 컨테이너를 &lt;code&gt;mynet&lt;/code&gt; 네트워크에 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="8a82fcfb8cf725c9fc19f051610ed497be3f1aab" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;--mount&lt;/code&gt; with &lt;code&gt;type=bind&lt;/code&gt;, the host-path must refer to an &lt;em&gt;existing&lt;/em&gt; path on the host. The path will not be created for you and the service will fail with an error if the path does not exist.</source>
          <target state="translated">&lt;code&gt;--mount&lt;/code&gt; 를 &lt;code&gt;type=bind&lt;/code&gt; 와 함께 사용 하는 경우 호스트 경로는 호스트의 &lt;em&gt;기존&lt;/em&gt; 경로를 참조해야합니다 . 경로는 생성되지 않으며 경로가 존재하지 않으면 오류와 함께 서비스가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4c5b67dc83ae27dcab6f2360463cf44190eb3e41" translate="yes" xml:space="preserve">
          <source>When you use multiple configuration files, you must make sure all paths in the files are relative to the base Compose file (the first Compose file specified with &lt;code&gt;-f&lt;/code&gt;). This is required because override files need not be valid Compose files. Override files can contain small fragments of configuration. Tracking which fragment of a service is relative to which path is difficult and confusing, so to keep paths easier to understand, all paths must be defined relative to the base file.</source>
          <target state="translated">여러 구성 파일을 사용하는 경우 파일의 모든 경로가 기본 작성 파일 ( &lt;code&gt;-f&lt;/code&gt; 로 지정된 첫 번째 작성 파일 )을 기준으로해야합니다. 대체 파일은 유효한 작성 파일 일 필요가 없기 때문에 필요합니다. 재정의 파일에는 작은 구성 조각이 포함될 수 있습니다. 서비스의 어느 부분이 어떤 경로가 어렵고 혼란 스러운지 추적하므로 경로를 이해하기 쉽게 유지하려면 모든 경로를 기본 파일과 관련하여 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="6dd325599d42e8c204578019eb5b5e0f4bbab9b4" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;--format&lt;/code&gt; option, the &lt;code&gt;search&lt;/code&gt; command will output the data exactly as the template declares. If you use the &lt;code&gt;table&lt;/code&gt; directive, column headers are included as well.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션 을 사용하면 &lt;code&gt;search&lt;/code&gt; 명령은 템플릿이 선언 한대로 정확하게 데이터를 출력합니다. &lt;code&gt;table&lt;/code&gt; 지시문 을 사용하면 열 머리글도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5eba4498e9290af10de98ddcffc826e4055534a0" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re developing software, the ability to run an application in an isolated environment and interact with it is crucial. The Compose command line tool can be used to create the environment and interact with it.</source>
          <target state="translated">소프트웨어를 개발할 때는 격리 된 환경에서 응용 프로그램을 실행하고 상호 작용하는 기능이 중요합니다. 작성 명령 행 도구를 사용하여 환경을 작성하고 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="763c16d7b081aae2a8308556197f30cff173394f" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with your build, you&amp;rsquo;re ready to look into &lt;a href=&quot;../../../get-started/index#/contributing-to-docker-hub&quot;&gt;&lt;em&gt;Pushing a repository to its registry&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">빌드가 완료되면 &lt;a href=&quot;../../../get-started/index#/contributing-to-docker-hub&quot;&gt;&lt;em&gt;리포지토리를 레지스트리&lt;/em&gt;&lt;/a&gt; 에 &lt;em&gt;푸시&lt;/em&gt; 할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="707e7a36e3e69545d23dbacd2932b1286dc19676" translate="yes" xml:space="preserve">
          <source>When your daemons use different values for these flags, you can run them on the same host without any problems. It is very important to properly understand the meaning of those options and to use them correctly.</source>
          <target state="translated">데몬이이 플래그에 대해 다른 값을 사용하면 아무런 문제없이 동일한 호스트에서 실행할 수 있습니다. 이러한 옵션의 의미를 올바르게 이해하고 올바르게 사용하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="35c068a50a221384b7bfa6530b181fb06056b361" translate="yes" xml:space="preserve">
          <source>Whenever a new a thin pool device is created (during &lt;code&gt;docker pull&lt;/code&gt; or during container creation), the Engine checks if the minimum free space is available. If sufficient space is unavailable, then device creation fails and any relevant &lt;code&gt;docker&lt;/code&gt; operation fails.</source>
          <target state="translated">&lt;code&gt;docker pull&lt;/code&gt; 중 또는 컨테이너 작성 중 새 씬 풀 장치가 작성 될 때마다 엔진은 사용 가능한 최소 여유 공간이 있는지 확인합니다. 충분한 공간을 사용할 수 없으면 장치 생성이 실패하고 관련 &lt;code&gt;docker&lt;/code&gt; 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="44ec6cb40c35edc5b0191246be62c24270dbc675" translate="yes" xml:space="preserve">
          <source>Whenever possible, Docker will re-use the intermediate images (cache), to accelerate the &lt;code&gt;docker build&lt;/code&gt; process significantly. This is indicated by the &lt;code&gt;Using cache&lt;/code&gt; message in the console output. (For more information, see the &lt;a href=&quot;https://docs.docker.com/develop/develop-images#build-cache&quot;&gt;Build cache section&lt;/a&gt; in the &lt;code&gt;Dockerfile&lt;/code&gt; best practices guide):</source>
          <target state="translated">Docker는 가능할 때마다 중간 이미지 (캐시)를 재사용하여 Docker &lt;code&gt;docker build&lt;/code&gt; 프로세스를 크게 가속화합니다 . 이는 콘솔 출력에서 &lt;code&gt;Using cache&lt;/code&gt; 메시지로 표시됩니다 . (자세한 내용 은 &lt;code&gt;Dockerfile&lt;/code&gt; 모범 사례 안내서 의 &lt;a href=&quot;https://docs.docker.com/develop/develop-images#build-cache&quot;&gt;빌드 캐시 섹션&lt;/a&gt; 을 참조하십시오 ) :</target>
        </trans-unit>
        <trans-unit id="27a56ebbe46149362bc13f661d7aff0131a3ac79" translate="yes" xml:space="preserve">
          <source>Where can I find example compose files?</source>
          <target state="translated">예제 작성 파일을 어디에서 찾을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f8341ff60c2c2468028d444b1e4546ae8ee8cbb3" translate="yes" xml:space="preserve">
          <source>Where is your built image? It&amp;rsquo;s in your machine&amp;rsquo;s local Docker image registry:</source>
          <target state="translated">빌드 한 이미지는 어디에 있습니까? 컴퓨터의 로컬 Docker 이미지 레지스트리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0320ac9cef49bf6819f7f5ea05026898ca882a24" translate="yes" xml:space="preserve">
          <source>Where to go next</source>
          <target state="translated">다음에 갈 곳</target>
        </trans-unit>
        <trans-unit id="a644fa5b67d4b2e0d76488bf86449a117b5ff2b2" translate="yes" xml:space="preserve">
          <source>Whether IPv6 is enabled on the network or not.</source>
          <target state="translated">네트워크에서 IPv6 사용 여부.</target>
        </trans-unit>
        <trans-unit id="f9413184ca919d289497ed4cc271fbef5835b7df" translate="yes" xml:space="preserve">
          <source>Whether plugin is enabled or not</source>
          <target state="translated">플러그인 사용 여부</target>
        </trans-unit>
        <trans-unit id="eae9fa23e792e46bb9c0094f09d78ff16d03491a" translate="yes" xml:space="preserve">
          <source>Whether the network is internal or not.</source>
          <target state="translated">네트워크가 내부인지 아닌지.</target>
        </trans-unit>
        <trans-unit id="27d5c20766efcd445220b34a340e9e9e2dd98b64" translate="yes" xml:space="preserve">
          <source>Whether to disable OOM Killer for the container or not.</source>
          <target state="translated">컨테이너에 OOM Killer를 비활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ba2de49dd81e93c5dffc11f4938991db86ec05ce" translate="yes" xml:space="preserve">
          <source>Whether your primary system is Mac, Windows, or Linux, you can install Docker Machine on it and use &lt;code&gt;docker-machine&lt;/code&gt; commands to provision and manage large numbers of Docker hosts. It automatically creates hosts, installs Docker Engine on them, then configures the &lt;code&gt;docker&lt;/code&gt; clients. Each managed host (&amp;ldquo;&lt;strong&gt;&lt;em&gt;machine&lt;/em&gt;&lt;/strong&gt;&amp;rdquo;) is the combination of a Docker host and a configured client.</source>
          <target state="translated">기본 시스템이 Mac, Windows 또는 Linux이든 관계없이 Docker Machine을 설치하고 &lt;code&gt;docker-machine&lt;/code&gt; 명령을 사용하여 많은 Docker 호스트를 프로비저닝하고 관리 할 수 ​​있습니다. 그것은 자동으로에 도커 엔진 설치 후 구성, 호스트를 생성 &lt;code&gt;docker&lt;/code&gt; 클라이언트를. 각 관리 호스트 ( &quot; &lt;strong&gt;&lt;em&gt;machine&lt;/em&gt;&lt;/strong&gt; &quot;)는 Docker 호스트와 구성된 클라이언트의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="0efdbd0a7053e2ee0fbc85c28cc298fa93191756" translate="yes" xml:space="preserve">
          <source>Which will exit cleanly on &lt;code&gt;docker stop&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;docker stop&lt;/code&gt; 에서 깨끗하게 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="4422566ade275ffedf7476a519c4c818dfd32edd" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#placement-constraints&quot;&gt;placement constraints&lt;/a&gt; limit the nodes a service can run on, &lt;em&gt;placement preferences&lt;/em&gt; try to place tasks on appropriate nodes in an algorithmic way (currently, only spread evenly). For instance, if you assign each node a &lt;code&gt;rack&lt;/code&gt; label, you can set a placement preference to spread the service evenly across nodes with the &lt;code&gt;rack&lt;/code&gt; label, by value. This way, if you lose a rack, the service is still running on nodes on other racks.</source>
          <target state="translated">&lt;a href=&quot;#placement-constraints&quot;&gt;배치 제약 조건&lt;/a&gt; 은 서비스가 실행될 수있는 노드를 제한 하지만 배치 &lt;em&gt;환경 설정&lt;/em&gt; 은 알고리즘 방식으로 적절한 노드에 작업을 배치하려고합니다 (현재는 균등하게 분산). 예를 들어, 각 노드에 &lt;code&gt;rack&lt;/code&gt; 레이블 을 할당 하면 값을 기준으로 &lt;code&gt;rack&lt;/code&gt; 레이블 이있는 노드에 서비스가 고르게 분산되도록 배치 기본 설정을 지정할 수 있습니다 . 이렇게하면 랙을 잃어도 다른 랙의 노드에서 서비스가 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b77da42e2054fee5ff7f7a237235ab11d93f46" translate="yes" xml:space="preserve">
          <source>While Docker currently only enables capabilities, it doesn&amp;rsquo;t interfere with the other systems. This means that there are many different ways to harden a Docker host. Here are a few examples.</source>
          <target state="translated">Docker는 현재 기능 만 사용할 수 있지만 다른 시스템에는 영향을주지 않습니다. 이는 Docker 호스트를 강화하는 여러 가지 방법이 있음을 의미합니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="1f1eeddee8bf03683d7d13b37af1f9a961ec2067" translate="yes" xml:space="preserve">
          <source>While a client is connected to container&amp;rsquo;s stdio using &lt;code&gt;docker attach&lt;/code&gt;, Docker uses a ~1MB memory buffer to maximize the throughput of the application. If this buffer is filled, the speed of the API connection will start to have an effect on the process output writing speed. This is similar to other applications like SSH. Because of this, it is not recommended to run performance critical applications that generate a lot of output in the foreground over a slow client connection. Instead, users should use the &lt;code&gt;docker logs&lt;/code&gt; command to get access to the logs.</source>
          <target state="translated">클라이언트는 &lt;code&gt;docker attach&lt;/code&gt; 를 사용하여 컨테이너의 stdio에 연결되어 있지만 Docker는 ~ 1MB 메모리 버퍼를 사용하여 응용 프로그램의 처리량을 최대화합니다. 이 버퍼가 채워지면 API 연결 속도가 프로세스 출력 쓰기 속도에 영향을주기 시작합니다. 이것은 SSH와 같은 다른 응용 프로그램과 유사합니다. 이 때문에 느린 클라이언트 연결을 통해 포 그라운드에서 많은 출력을 생성하는 성능이 중요한 응용 프로그램을 실행하지 않는 것이 좋습니다. 대신, 사용자는 &lt;code&gt;docker logs&lt;/code&gt; 명령을 사용하여 로그에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="268b018726c6c7311c68727b479e2d0400d30a75" translate="yes" xml:space="preserve">
          <source>While a mixed FIPS environment makes upgrading or changing status easier, Docker recommends not running a mixed FIPS environment in production.</source>
          <target state="translated">혼합 FIPS 환경에서는 업그레이드 또는 상태 변경이 쉬워 지지만 Docker는 프로덕션 환경에서 혼합 FIPS 환경을 실행하지 않는 것이 좋습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
