<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="jest">
    <body>
      <group id="jest">
        <trans-unit id="f2884236a5a7d1409f769ed84cceee98770e2aba" translate="yes" xml:space="preserve">
          <source>Runs tests related to the changes since the provided branch. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">提供されたブランチ以降の変更に関連するテストを実行します。現在のブランチが特定のブランチから分岐している場合、ローカルで行われた変更のみがテストされます。 &lt;code&gt;--onlyChanged&lt;/code&gt; と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="fdee9094809cabf1a25af1ca3211f475ddc04a54" translate="yes" xml:space="preserve">
          <source>Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">現在の変更と最後のコミットで行われた変更に関連するテストを実行します。 &lt;code&gt;--onlyChanged&lt;/code&gt; と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="ea13653cdec671f745362f34fcd64c3406b64c75" translate="yes" xml:space="preserve">
          <source>Scoped modules can be mocked by creating a file in a directory structure that matches the name of the scoped module. For example, to mock a scoped module called &lt;code&gt;@scope/project-name&lt;/code&gt;, create a file at &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt;, creating the &lt;code&gt;@scope/&lt;/code&gt; directory accordingly.</source>
          <target state="translated">スコープモジュールは、スコープモジュールの名前と一致するディレクトリ構造内にファイルを作成することでモックできます。たとえば、 &lt;code&gt;@scope/project-name&lt;/code&gt; というスコープモジュールをモックするには、 &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt; にファイルを作成し、それに応じて &lt;code&gt;@scope/&lt;/code&gt; ディレクトリを作成します。</target>
        </trans-unit>
        <trans-unit id="cbc636498e1c269635cd060804fe4bc4c5cc9f77" translate="yes" xml:space="preserve">
          <source>Scoping</source>
          <target state="translated">Scoping</target>
        </trans-unit>
        <trans-unit id="211a5b2321ab26457503f06cb4dc7556791fc7d0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;configuring Jest&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;Jestの設定&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="efddd22422ff36c5396f782f1486c33090e561a7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;Create Table API&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;Create Table APIを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="f34a9c66618a8a38e77218fa386d8ca82390118e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;ドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d0f8c5b32a609f4f0cc5792e1d82420240d67f10" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;documentation&lt;/a&gt; for details (configuring MongoDB version, etc).</source>
          <target state="translated">詳細（MongoDBバージョンの構成など）については、&lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;ドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="85e1678b6936236b6f910c2ee40e764fd5fd5efb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;ドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac033bc12bf7544e09b943fc85a55ee0e0eb5bb2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;Help&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;ヘルプを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4bd8f6623cb0bd7f5cbd56dab7f5f02bfe1b459a" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;automock&lt;/code&gt; section of &lt;a href=&quot;configuration#automock-boolean&quot;&gt;configuration&lt;/a&gt; for more information</source>
          <target state="translated">詳細については、&lt;a href=&quot;configuration#automock-boolean&quot;&gt;設定の&lt;/a&gt; &lt;code&gt;automock&lt;/code&gt; セクションを参照してください</target>
        </trans-unit>
        <trans-unit id="b6f206289cb851ace292e1546d209054802eb0c9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#testregex-string--arraystring&quot;&gt;&lt;code&gt;testRegex&lt;/code&gt; [string | array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="translated">参照してください&lt;a href=&quot;#testregex-string--arraystring&quot;&gt; &lt;code&gt;testRegex&lt;/code&gt; [文字列| array &amp;lt;string&amp;gt;]&lt;/a&gt;。ただし、両方のオプションを指定することはできません。</target>
        </trans-unit>
        <trans-unit id="94efbf6a114ebb2635afd14dc7211a7f961c8a16" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; package for details of the patterns you can specify.</source>
          <target state="translated">指定できるパターンの詳細については、&lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt;パッケージを参照してください。</target>
        </trans-unit>
        <trans-unit id="615ea98380b0e9ec8f2989a621cea9a7e764e463" translate="yes" xml:space="preserve">
          <source>Set the default timeout interval for tests and before/after hooks in milliseconds.</source>
          <target state="translated">テストとフック前後のデフォルトのタイムアウト間隔をミリ秒単位で設定します。</target>
        </trans-unit>
        <trans-unit id="4c094b57443ef1dac1663cfc0d2869275b9ac2e1" translate="yes" xml:space="preserve">
          <source>Sets the path to the &lt;a href=&quot;https://prettier.io/&quot;&gt;&lt;code&gt;prettier&lt;/code&gt;&lt;/a&gt; node module used to update inline snapshots.</source>
          <target state="translated">インラインスナップショットの更新に使用される、&lt;a href=&quot;https://prettier.io/&quot;&gt; &lt;code&gt;prettier&lt;/code&gt; &lt;/a&gt;ノードモジュールへのパスを設定します。</target>
        </trans-unit>
        <trans-unit id="03632ef1c76d8a3790f3ba38329aa3105012b7ef" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;fake&lt;/code&gt; allows the use of fake timers for functions such as &lt;code&gt;setTimeout&lt;/code&gt;. Fake timers are useful when a piece of code sets a long timeout that we don't want to wait for in a test.</source>
          <target state="translated">この値を &lt;code&gt;fake&lt;/code&gt; に設定すると、 &lt;code&gt;setTimeout&lt;/code&gt; などの関数に偽のタイマーを使用できます。偽のタイマーは、コードでテストで待機したくない長いタイムアウトを設定する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="5f07ec3fe4ba8082e43fef02f2b4d5d1a2a1d466" translate="yes" xml:space="preserve">
          <source>Setup and Teardown</source>
          <target state="translated">セットアップとティアダウン</target>
        </trans-unit>
        <trans-unit id="24b1a600607b12b94694aa1cdc63d96c8b7a540d" translate="yes" xml:space="preserve">
          <source>Setup with Create React App</source>
          <target state="translated">Create Reactアプリで設定</target>
        </trans-unit>
        <trans-unit id="9e9d9e60fd56a1f1ea8ea643530acaeb4d062997" translate="yes" xml:space="preserve">
          <source>Setup without Create React App</source>
          <target state="translated">Reactアプリを作成せずに設定する</target>
        </trans-unit>
        <trans-unit id="822b3a2435ec58cb5bc9376be9ad2eeac55edc92" translate="yes" xml:space="preserve">
          <source>Should snapshot files be committed?</source>
          <target state="translated">スナップショットファイルはコミットすべきか?</target>
        </trans-unit>
        <trans-unit id="492eafbaea4c259f43100935024f5e3a182f7170" translate="yes" xml:space="preserve">
          <source>Should your plugin attempt to overwrite a reserved key, Jest will error out with a descriptive message, something like:</source>
          <target state="translated">あなたのプラグインが予約されたキーを上書きしようとすると、Jest は次のような説明的なメッセージでエラーになります。</target>
        </trans-unit>
        <trans-unit id="bd51fd0dd8cd830d4a42fc531c55cdfccd2ac812" translate="yes" xml:space="preserve">
          <source>Show the help information, similar to this page.</source>
          <target state="translated">このページと同様のヘルプ情報を表示します。</target>
        </trans-unit>
        <trans-unit id="fb22048fa6d1f11cbc46a0377600ca142853ad0a" translate="yes" xml:space="preserve">
          <source>Similarly webpack's &lt;code&gt;resolve.root&lt;/code&gt; option functions like setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, which you can set, or make use of the &lt;code&gt;modulePaths&lt;/code&gt; option.</source>
          <target state="translated">同様に、webpackの &lt;code&gt;resolve.root&lt;/code&gt; オプションは、 &lt;code&gt;NODE_PATH&lt;/code&gt; 環境変数の設定と同様に機能します。これは、設定できるか、 &lt;code&gt;modulePaths&lt;/code&gt; オプションを利用できます。</target>
        </trans-unit>
        <trans-unit id="c1b6800d4211e291c95387e4b2e79446e622a4f0" translate="yes" xml:space="preserve">
          <source>Since Jest 22.1.0+, the &lt;code&gt;jest.spyOn&lt;/code&gt; method takes an optional third argument of &lt;code&gt;accessType&lt;/code&gt; that can be either &lt;code&gt;'get'&lt;/code&gt; or &lt;code&gt;'set'&lt;/code&gt;, which proves to be useful when you want to spy on a getter or a setter, respectively.</source>
          <target state="translated">Jest 22.1.0以降、 &lt;code&gt;jest.spyOn&lt;/code&gt; メソッドはaccessTypeのオプションの3番目の引数を &lt;code&gt;accessType&lt;/code&gt; します。これは &lt;code&gt;'get'&lt;/code&gt; または &lt;code&gt;'set'&lt;/code&gt; のいずれかであり、ゲッターまたはセッターをそれぞれスパイしたい場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="4f8bae34a73e1f4213cb283f5a11b822ba4dc217" translate="yes" xml:space="preserve">
          <source>Since the later describes exactly what's expected in the output, it's more clear to see when it's wrong:</source>
          <target state="translated">後の方が正確に出力に記載されているので、それが間違っている場合はより明確になります。</target>
        </trans-unit>
        <trans-unit id="b9678530810438e60dd8aa3f6aa12c28ea2f3f1c" translate="yes" xml:space="preserve">
          <source>Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.</source>
          <target state="translated">別のアドレスを指すようにコンポーネントを更新したばかりなので、このコンポーネントのスナップショットの変更を期待するのが妥当です。更新されたコンポーネントのスナップショットが、このテストケースのスナップショット・アーティファクトと一致しなくなったため、スナップショット・テストケースは失敗しています。</target>
        </trans-unit>
        <trans-unit id="540cf57482add7abae948ebe3f5722e703011e20" translate="yes" xml:space="preserve">
          <source>Since we'd like our tests to avoid actually hitting the disk (that's pretty slow and fragile), we create a manual mock for the &lt;code&gt;fs&lt;/code&gt; module by extending an automatic mock. Our manual mock will implement custom versions of the &lt;code&gt;fs&lt;/code&gt; APIs that we can build on for our tests:</source>
          <target state="translated">テストが実際にディスクに当たらないようにしたいので（かなり遅くて壊れやすい）、自動モックを拡張して &lt;code&gt;fs&lt;/code&gt; モジュールの手動モックを作成します。手動モックは、テスト用に構築できる &lt;code&gt;fs&lt;/code&gt; APIのカスタムバージョンを実装します。</target>
        </trans-unit>
        <trans-unit id="66842e9da141137fe7352a0a53d93d8d95043a5c" translate="yes" xml:space="preserve">
          <source>Snapshot Test</source>
          <target state="translated">スナップショットテスト</target>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="translated">スナップショットテスト</target>
        </trans-unit>
        <trans-unit id="89df76fc07cdab1a593d1520d1e485a89eaa0758" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Jest</source>
          <target state="translated">Jestを使ったスナップショットテスト</target>
        </trans-unit>
        <trans-unit id="133546ab2de371a152f49c68a57605cf66823f74" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Mocks, Enzyme and React 16</source>
          <target state="translated">モック、酵素、Reactを使ったスナップショットテスト 16</target>
        </trans-unit>
        <trans-unit id="5a16d1671f06c1b79f4ca90da446bf86ec30018f" translate="yes" xml:space="preserve">
          <source>Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.</source>
          <target state="translated">スナップショットファイルは常にカバーしているモジュールの現在の状態を表していなければなりません。そのため、2つのブランチをマージしていてスナップショットファイルにコンフリクトが発生した場合は、手動でコンフリクトを解決するか、Jestを実行して結果を確認してスナップショットファイルを更新します。</target>
        </trans-unit>
        <trans-unit id="e2f67f68de52f1c63bdae4635f588faaa8a269e7" translate="yes" xml:space="preserve">
          <source>Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;Jest blog&lt;/a&gt;.</source>
          <target state="translated">スナップショットテストと視覚回帰テストは、UIをテストする2つの異なる方法であり、目的は異なります。視覚回帰テストツールは、Webページのスクリーンショットを取り、結果の画像をピクセルごとに比較します。スナップショットを使用すると、テスト値はシリアル化され、テキストファイルに格納され、diffアルゴリズムを使用して比較されます。考慮すべきさまざまなトレードオフがあり、スナップショットテストが&lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;Jestブログ&lt;/a&gt;に組み込まれた理由をリストしました。</target>
        </trans-unit>
        <trans-unit id="67c5ace60d5fc8adf8135b3fa0469ad4f55990c3" translate="yes" xml:space="preserve">
          <source>Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.</source>
          <target state="translated">スナップショットテストは、Jestに搭載されている20以上のアサーションのうちの1つに過ぎません。スナップショットテストの目的は、既存のユニットテストを置き換えることではなく、付加価値を提供し、テストを楽にすることです。シナリオによっては、スナップショットテストは特定の機能セット(例:Reactコンポーネント)のためのユニットテストの必要性をなくすことができますが、それらは一緒に動作することもできます。</target>
        </trans-unit>
        <trans-unit id="d78cced32db30f3bf1c92f37bcc6a46c7cbbb0b3" translate="yes" xml:space="preserve">
          <source>Snapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.</source>
          <target state="translated">スナップショットテストは、UIが不意に変化しないことを確認したいときに非常に便利なツールです。</target>
        </trans-unit>
        <trans-unit id="46a65a578f3ba45c38c2f4b67393d191767bfc07" translate="yes" xml:space="preserve">
          <source>Snapshots are a fantastic tool for identifying unexpected interface changes within your application &amp;ndash; whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.</source>
          <target state="translated">スナップショットは、インターフェースがAPI応答、UI、ログ、またはエラーメッセージであるかどうかにかかわらず、アプリケーション内の予期しないインターフェース変更を識別するための素晴らしいツールです。他のテスト戦略と同様に、それらを効果的に使用するために、知っておくべきベストプラクティスと従うべきガイドラインがあります。</target>
        </trans-unit>
        <trans-unit id="6f682ce988a8d01605c894c6eb3963ca0cc76e8b" translate="yes" xml:space="preserve">
          <source>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside &lt;code&gt;node_modules&lt;/code&gt; are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use &lt;code&gt;transformIgnorePatterns&lt;/code&gt; to whitelist such modules. You'll find a good example of this use case in &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt;.</source>
          <target state="translated">ときどき（特にReact NativeプロジェクトまたはTypeScriptプロジェクトで）サードパーティのモジュールが翻訳されていないものとして公開されることがあります。 &lt;code&gt;node_modules&lt;/code&gt; 内のすべてのファイルはデフォルトでは変換されないため、Jestはこれらのモジュールのコードを理解できず、構文エラーが発生します。これを克服するには、 &lt;code&gt;transformIgnorePatterns&lt;/code&gt; を使用して、そのようなモジュールをホワイトリストに登録します。このユースケースの良い例が&lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guideにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e2b30ccb8fda73d533a0e969bafd118c24c88742" translate="yes" xml:space="preserve">
          <source>Sometimes you need to provide a more complex manual mock. For example if you'd like to forward the prop types or static fields of a native component to a mock, you can return a different React component from a mock through this helper from jest-react-native:</source>
          <target state="translated">より複雑な手動のモックを提供する必要がある場合があります。例えば、ネイティブコンポーネントのプロップタイプや静的フィールドをモックに転送したい場合、 jest-react-native のこのヘルパーを使ってモックから別の React コンポーネントを返すことができます。</target>
        </trans-unit>
        <trans-unit id="695c0e7e9d729e27f87cadca0070a18d74fc0abb" translate="yes" xml:space="preserve">
          <source>Sort test path alphabetically.</source>
          <target state="translated">テストパスをアルファベット順に並べ替えます。</target>
        </trans-unit>
        <trans-unit id="e68b54695ab9a614c999727da57981ffa8733914" translate="yes" xml:space="preserve">
          <source>Specifies notification mode. Requires &lt;code&gt;notify: true&lt;/code&gt;.</source>
          <target state="translated">通知モードを指定します。 &lt;code&gt;notify: true&lt;/code&gt; が必要：true。</target>
        </trans-unit>
        <trans-unit id="3484b5172e046d75121af3f84a8f20757a6f1353" translate="yes" xml:space="preserve">
          <source>Specify preset in your Jest configuration:</source>
          <target state="translated">Jestの設定でプリセットを指定します。</target>
        </trans-unit>
        <trans-unit id="072147ce4032ecb883aadc972685fb5dc5cab93b" translate="yes" xml:space="preserve">
          <source>Spying on methods of our class</source>
          <target state="translated">私たちのクラスのメソッドをスパイする</target>
        </trans-unit>
        <trans-unit id="3e66bbc94f94d5c9febbf71967e8a53cc9c379f0" translate="yes" xml:space="preserve">
          <source>Spying on the constructor</source>
          <target state="translated">コンストラクタをスパイする</target>
        </trans-unit>
        <trans-unit id="024a38d0b03fcbf63acc93daff4e631c67675d3b" translate="yes" xml:space="preserve">
          <source>Starting from react-native version 0.38, a Jest setup is included by default when running &lt;code&gt;react-native init&lt;/code&gt;. The following configuration should be automatically added to your package.json file:</source>
          <target state="translated">react-nativeバージョン0.38以降、 &lt;code&gt;react-native init&lt;/code&gt; を実行すると、Jestセットアップがデフォルトで含まれます。次の構成は、package.jsonファイルに自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="1991c5175326e4c289d97fffe85eadf0791dd3bd" translate="yes" xml:space="preserve">
          <source>Static ES6 module imports are hoisted to the top of the file, so instead we have to import them dynamically using &lt;code&gt;import()&lt;/code&gt;.</source>
          <target state="translated">静的ES6モジュールのインポートはファイルの先頭に配置されるため、代わりに &lt;code&gt;import()&lt;/code&gt; を使用して動的にインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="28f738d61989d25363252d6dd69c2b75719b7de9" translate="yes" xml:space="preserve">
          <source>Still unresolved?</source>
          <target state="translated">まだ解決してないのか?</target>
        </trans-unit>
        <trans-unit id="6c6f5518d1fa80f650e491adb2e489a09a7f982c" translate="yes" xml:space="preserve">
          <source>Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with &lt;code&gt;jest.fn&lt;/code&gt; or the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method on mock functions.</source>
          <target state="translated">それでも、戻り値を指定する機能を超えて、モック関数の実装を全面的に置き換えることが役立つ場合があります。これは、モック関数の &lt;code&gt;jest.fn&lt;/code&gt; または &lt;code&gt;mockImplementationOnce&lt;/code&gt; メソッドで実行できます。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="bcc358b3aaafb093f4a2baf42f0160bfb2bfd061" translate="yes" xml:space="preserve">
          <source>Suppose we have a class that fetches users from our API. The class uses &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt; to call the API then returns the &lt;code&gt;data&lt;/code&gt; attribute which contains all the users:</source>
          <target state="translated">APIからユーザーをフェッチするクラスがあるとします。クラスは&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt;を使用してAPIを呼び出し、すべてのユーザーを含む &lt;code&gt;data&lt;/code&gt; 属性を返します。</target>
        </trans-unit>
        <trans-unit id="3a4bc60f3a09d9eb5a73886f79212b0e558b15ec" translate="yes" xml:space="preserve">
          <source>Syntactic sugar function for:</source>
          <target state="translated">のための構文糖関数。</target>
        </trans-unit>
        <trans-unit id="ae135cb4bf99d2d69cbac3f5fd417c5399be204b" translate="yes" xml:space="preserve">
          <source>Test environment options that will be passed to the &lt;code&gt;testEnvironment&lt;/code&gt;. The relevant options depend on the environment. For example you can override options given to &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt; such as &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;testEnvironment&lt;/code&gt; に渡されるテスト環境オプション。関連するオプションは環境によって異なります。たとえば、 &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt; などの&lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdomに&lt;/a&gt;指定されたオプションをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="b55666a28ff3618a6bc88a5a3086460692f20399" translate="yes" xml:space="preserve">
          <source>Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.</source>
          <target state="translated">テスト ファイルは通常、コード カバレッジの収集から無視されます。このオプションを使用すると、この動作を上書きして、そうでなければ無視されるファイルをコードカバレッジに含めることができます。</target>
        </trans-unit>
        <trans-unit id="32a2b6bfc1cb248afcfe7c96a42e9a946326cac4" translate="yes" xml:space="preserve">
          <source>Test files run inside a &lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;vm&lt;/a&gt;, which slows calls to global context properties (e.g. &lt;code&gt;Math&lt;/code&gt;). With this option you can specify extra properties to be defined inside the vm for faster lookups.</source>
          <target state="translated">テストファイルは&lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;vm&lt;/a&gt;内で実行されるため、グローバルコンテキストプロパティ（例： &lt;code&gt;Math&lt;/code&gt; ）への呼び出しが遅くなります。このオプションを使用すると、VM内で定義する追加のプロパティを指定して、検索を高速化できます。</target>
        </trans-unit>
        <trans-unit id="da102bd566881f332f6aa321d898e870666704cb" translate="yes" xml:space="preserve">
          <source>Testing Asynchronous Code</source>
          <target state="translated">非同期コードのテスト</target>
        </trans-unit>
        <trans-unit id="b4b91ec445494c8e5c6d2ecedd86aa56ac5179b5" translate="yes" xml:space="preserve">
          <source>Testing React Apps</source>
          <target state="translated">Reactアプリのテスト</target>
        </trans-unit>
        <trans-unit id="5987105ad86879109c74631bcc686434d71992ae" translate="yes" xml:space="preserve">
          <source>Testing React Native Apps</source>
          <target state="translated">Reactネイティブアプリのテスト</target>
        </trans-unit>
        <trans-unit id="225fc2b10e9a9ea9b701c17da2b76bad93c7b747" translate="yes" xml:space="preserve">
          <source>Testing Web Frameworks</source>
          <target state="translated">ウェブフレームワークのテスト</target>
        </trans-unit>
        <trans-unit id="b228c0a462e4fbc62499ce73feb2a8eb75c4bd39" translate="yes" xml:space="preserve">
          <source>Tests are Extremely Slow on Docker and/or Continuous Integration (CI) server.</source>
          <target state="translated">Dockerや継続的インテグレーション(CI)サーバーではテストが非常に遅い。</target>
        </trans-unit>
        <trans-unit id="c2d1541959da20e20096a585a0538d9010954c98" translate="yes" xml:space="preserve">
          <source>Tests are Failing and You Don't Know Why</source>
          <target state="translated">テストが失敗しているのに、その理由がわからない</target>
        </trans-unit>
        <trans-unit id="3c8e525d4231c4190be70b1ad66cd616c6e2aa0f" translate="yes" xml:space="preserve">
          <source>Tests must be defined synchronously for Jest to be able to collect your tests.</source>
          <target state="translated">Jest がテストを収集できるようにするためには、テストを同期的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="ba7f8377fd3129e903838676530e75e431a41733" translate="yes" xml:space="preserve">
          <source>That module can also contain a &lt;code&gt;getCacheKey&lt;/code&gt; function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.</source>
          <target state="translated">そのモジュールには、キャッシュキーを生成する &lt;code&gt;getCacheKey&lt;/code&gt; 関数を含めることもできます。これにより、ロジックが変更され、それに依存するキャッシュされたアーティファクトを破棄する必要があるかどうかを判断できます。</target>
        </trans-unit>
        <trans-unit id="11a78e492a9e9e7ac361c24117bfb5e811bddb35" translate="yes" xml:space="preserve">
          <source>That's all there is to it! You can even update the snapshots with &lt;code&gt;--updateSnapshot&lt;/code&gt; or using the &lt;code&gt;u&lt;/code&gt; key in &lt;code&gt;--watch&lt;/code&gt; mode.</source>
          <target state="translated">これですべてです！ &lt;code&gt;--updateSnapshot&lt;/code&gt; を使用して、または &lt;code&gt;--watch&lt;/code&gt; モードで &lt;code&gt;u&lt;/code&gt; キーを使用して、スナップショットを更新することもできます。</target>
        </trans-unit>
        <trans-unit id="fa64459e4e03b6885bddfefb159ed4eb86b6825b" translate="yes" xml:space="preserve">
          <source>That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.</source>
          <target state="translated">以上です!webpack は複雑で柔軟なツールなので、特定のアプリケーションのニーズに対応するためにいくつかの調整をしなければならないかもしれません。幸いなことに、ほとんどのプロジェクトでは、Jest はあなたの webpack の設定を処理するのに十分な柔軟性を持っているはずです。</target>
        </trans-unit>
        <trans-unit id="7c3361ad0e93e6bc1e1c3de2667211b364b378cd" translate="yes" xml:space="preserve">
          <source>The 4 ways to create an ES6 class mock</source>
          <target state="translated">ES6クラスのモックを作成する4つの方法</target>
        </trans-unit>
        <trans-unit id="95c25a4fa34143b1216d44b01d41f9f29688f727" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt;&lt;code&gt;clearMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to clear mocks automatically between tests.</source>
          <target state="translated">&lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt; &lt;code&gt;clearMocks&lt;/code&gt; の&lt;/a&gt;設定オプションは、テストの間で自動的にモックをクリアするために利用可能です。</target>
        </trans-unit>
        <trans-unit id="06c017e6536e5d9f6110e8d0080ca094a5e9ea11" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt;&lt;code&gt;moduleNameMapper&lt;/code&gt;&lt;/a&gt; can be used to map a module path to a different module. By default the preset maps all images to an image stub module but if a module cannot be found this configuration option can help:</source>
          <target state="translated">&lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt; &lt;code&gt;moduleNameMapper&lt;/code&gt; は&lt;/a&gt;異なるモジュールにモジュールパスをマッピングするために使用することができます。デフォルトでは、プリセットはすべての画像を画像スタブモジュールにマッピングしますが、モジュールが見つからない場合、この構成オプションが役立ちます。</target>
        </trans-unit>
        <trans-unit id="d4d9df38ccbce3dc2ed35e993bc8900c35030ec6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt;&lt;code&gt;restoreMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to restore mocks automatically between tests.</source>
          <target state="translated">&lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt; &lt;code&gt;restoreMocks&lt;/code&gt; の&lt;/a&gt;設定オプションは、テストの間で自動的にモックを復元することができます。</target>
        </trans-unit>
        <trans-unit id="f1fd9f27ef141c8e346e850781739fd26da2e8bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt;&lt;code&gt;transformIgnorePatterns&lt;/code&gt;&lt;/a&gt; option can be used to whitelist or blacklist files from being transformed with Babel. Many react-native npm modules unfortunately don't pre-compile their source code before publishing.</source>
          <target state="translated">&lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt; &lt;code&gt;transformIgnorePatterns&lt;/code&gt; の&lt;/a&gt;オプションはバベルで形質転換されることから、ホワイトリストやブラックリストのファイルに使用することができます。多くの反応ネイティブnpmモジュールは、残念ながら公開前にソースコードをプリコンパイルしません。</target>
        </trans-unit>
        <trans-unit id="5fcd870eb6449696a26dbe9a35105b1b3f0eb6a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; file has less than 100% coverage.</source>
          <target state="translated">&lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; ファイルには、100％未満の範囲を持っています。</target>
        </trans-unit>
        <trans-unit id="a4b1bdae91ac8b4ba9e5526619539ee09ec8ff0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/components&lt;/code&gt; directory has less than 40% branch or statement coverage.</source>
          <target state="translated">&lt;code&gt;./src/components&lt;/code&gt; のディレクトリには、40％未満の枝やステートメントカバレッジを持っています。</target>
        </trans-unit>
        <trans-unit id="afcc7bfb1a0f92aed03ab154b1ea46d01fb61f0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.assertions(2)&lt;/code&gt; call ensures that both callbacks actually get called.</source>
          <target state="translated">&lt;code&gt;expect.assertions(2)&lt;/code&gt; は、両方のコールバックを実際に呼び出されることを保証を呼び出します。</target>
        </trans-unit>
        <trans-unit id="8801cb3154dc90b6dabeb0f8d6adc04b7c96a994" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.hasAssertions()&lt;/code&gt; call ensures that the &lt;code&gt;prepareState&lt;/code&gt; callback actually gets called.</source>
          <target state="translated">&lt;code&gt;expect.hasAssertions()&lt;/code&gt; というコール性を保証 &lt;code&gt;prepareState&lt;/code&gt; のコールバックが実際に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6c3326411c984dac96e58b8dd16be60c0de3724a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect&lt;/code&gt; function is used every time you want to test a value. You will rarely call &lt;code&gt;expect&lt;/code&gt; by itself. Instead, you will use &lt;code&gt;expect&lt;/code&gt; along with a &quot;matcher&quot; function to assert something about a value.</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; 機能は、あなたが値をテストするたびに使用されます。単独で &lt;code&gt;expect&lt;/code&gt; を呼び出すことはめったにありません。代わりに、「matcher」関数とともに &lt;code&gt;expect&lt;/code&gt; を使用して、値について何かをアサートします。</target>
        </trans-unit>
        <trans-unit id="6594bb5f273e5a4f7094c361061889db4f707818" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function should return an iterable (&lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, etc.) with the dependencies found in the code.</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; 関数は、反復可能（返すべき &lt;code&gt;Array&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; コードに見出される依存関係、等）。</target>
        </trans-unit>
        <trans-unit id="5539a986bbbbf8c351471c1981c9549b0ae07121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; command line runner has a number of useful options. You can run &lt;code&gt;jest --help&lt;/code&gt; to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's &lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt; options can also be specified through the CLI.</source>
          <target state="translated">&lt;code&gt;jest&lt;/code&gt; コマンドラインランナーは、便利なオプションの数を持っています。 &lt;code&gt;jest --help&lt;/code&gt; を実行して、使用可能なすべてのオプションを表示できます。以下に示すオプションの多くは、一緒に使用して、希望どおりにテストを実行することもできます。Jestのすべての&lt;a href=&quot;configuration&quot;&gt;構成&lt;/a&gt;オプションは、CLIからも指定できます。</target>
        </trans-unit>
        <trans-unit id="8cb0dc4d98327301d27ed47332b5824609aeec5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; object is automatically in scope within every test file. The methods in the &lt;code&gt;jest&lt;/code&gt; object help create mocks and let you control Jest's overall behavior.</source>
          <target state="translated">&lt;code&gt;jest&lt;/code&gt; オブジェクトは、すべてのテストファイル内の範囲で自動的にあります。 &lt;code&gt;jest&lt;/code&gt; オブジェクトのメソッドはモックの作成に役立ち、Jestの全体的な動作を制御できます。</target>
        </trans-unit>
        <trans-unit id="b7b8cc683ede161fc025b891451a1f71de3a0d36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mockImplementation&lt;/code&gt; method is useful when you need to define the default implementation of a mock function that is created from another module:</source>
          <target state="translated">&lt;code&gt;mockImplementation&lt;/code&gt; のあなたが別のモジュールから作成されたモック機能のデフォルトの実装を定義する必要があるときに方法が便利です。</target>
        </trans-unit>
        <trans-unit id="f414ca5debc72d67a32f4e6f4214b85eb7903c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; property contains the value that was thrown or returned. &lt;code&gt;value&lt;/code&gt; is undefined when &lt;code&gt;type === 'incomplete'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; プロパティは、スローまたは返された値が含まれています。 &lt;code&gt;type === 'incomplete'&lt;/code&gt; 場合、 &lt;code&gt;value&lt;/code&gt; は未定義です。</target>
        </trans-unit>
        <trans-unit id="60ae20badadde4a0ac472d6382213bf5645d769e" translate="yes" xml:space="preserve">
          <source>The Chrome Developer Tools will be displayed, and a breakpoint will be set at the first line of the Jest CLI script (this is done to give you time to open the developer tools and to prevent Jest from executing before you have time to do so). Click the button that looks like a &quot;play&quot; button in the upper right hand side of the screen to continue execution. When Jest executes the test that contains the &lt;code&gt;debugger&lt;/code&gt; statement, execution will pause and you can examine the current scope and call stack.</source>
          <target state="translated">Chromeデベロッパーツールが表示され、Jest CLIスクリプトの最初の行にブレークポイントが設定されます（これは、デベロッパーツールを開く時間を与え、実行する前にJestが実行されないようにするために行われます）。 。画面右上の「再生」ボタンのようなボタンをクリックすると、実行を継続します。 Jestが &lt;code&gt;debugger&lt;/code&gt; ステートメントを含むテストを実行すると、実行が一時停止し、現在のスコープと呼び出しスタックを調べることができます。</target>
        </trans-unit>
        <trans-unit id="cdefcc002eddfb7f6c28f9c7a1871357f57fe794" translate="yes" xml:space="preserve">
          <source>The Jest Object</source>
          <target state="translated">ジェストオブジェクト</target>
        </trans-unit>
        <trans-unit id="af5336b9f0d6a51b49389a0b7ed3fd6e4c3872c6" translate="yes" xml:space="preserve">
          <source>The Jest preset built into &lt;code&gt;react-native&lt;/code&gt; comes with a few default mocks that are applied on a react-native repository. However some react-native components or third party components rely on native code to be rendered. In such cases, Jest's manual mocking system can help to mock out the underlying implementation.</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt; 組み込まれたJestプリセットには、反応ネイティブリポジトリに適用されるいくつかのデフォルトモックが付属しています。ただし、一部の反応ネイティブコンポーネントまたはサードパーティコンポーネントは、レンダリングされるネイティブコードに依存しています。そのような場合、Jestの手動モッキングシステムは、基礎となる実装を模擬するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="2453c12b4a4f24fbc05ce1e4c46073678639c15d" translate="yes" xml:space="preserve">
          <source>The Jest watch plugin system provides a way to hook into specific parts of Jest and to define watch mode menu prompts that execute code on key press. Combined, these features allow you to develop interactive experiences custom for your workflow.</source>
          <target state="translated">Jestウォッチプラグインシステムは、Jestの特定の部分にフックしたり、キーを押すとコードを実行するウォッチモードのメニュープロンプトを定義する方法を提供します。これらの機能を組み合わせることで、ワークフローに合わせてカスタマイズされたインタラクティブな体験を開発することができます。</target>
        </trans-unit>
        <trans-unit id="9caca20f4fce1e72a9edd33743ac65377cd25c74" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;expect&lt;/code&gt; should be the value that your code produces, and any argument to the matcher should be the correct value. If you mix them up, your tests will still work, but the error messages on failing tests will look strange.</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; 引数は、コードが生成する値である必要があり、マッチャーへの引数はすべて正しい値である必要があります。それらを混同しても、テストは機能しますが、失敗したテストのエラーメッセージは奇妙に見えます。</target>
        </trans-unit>
        <trans-unit id="8cc68f24cef4585983c9f185a90ee734f90aa8ae" translate="yes" xml:space="preserve">
          <source>The class may optionally expose a &lt;code&gt;handleTestEvent&lt;/code&gt; method to bind to events fired by &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;&lt;code&gt;jest-circus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クラスは、オプションで、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt; &lt;code&gt;jest-circus&lt;/code&gt; &lt;/a&gt;によって &lt;code&gt;handleTestEvent&lt;/code&gt; れたイベントにバインドするhandleTestEventメソッドを公開できます。</target>
        </trans-unit>
        <trans-unit id="505efbd4b63a11e029fe3900fcf34d5ab8217315" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples/async&lt;/a&gt;.</source>
          <target state="translated">この例のコードは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples / asyncにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="61f42c40ba4012116e65e0172c4574798fdcc3a1" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples/enzyme&lt;/a&gt;.</source>
          <target state="translated">この例のコードは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples / enzymeにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="4e772aeae1e1e3865bc4cf9718bec60261ce607b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples/jquery&lt;/a&gt;.</source>
          <target state="translated">この例のコードは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples / jqueryにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3e7eb572425bcca3655b70ad564fc1692cbc457f" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;examples/manual-mocks&lt;/a&gt;.</source>
          <target state="translated">この例のコードは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;examples / manual-mocksにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d0665793600a54f70d63deadff14baccb32f7bff" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples/react-native&lt;/a&gt;.</source>
          <target state="translated">この例のコードは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples / react-nativeにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9347a0f5e3be6b1f8c7f0c4795c7b215bb18ebd4" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples/react-testing-library&lt;/a&gt;.</source>
          <target state="translated">この例のコードは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples / react-testing-libraryにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b032ec230190e1c4fc446fee9c02430a5dbbd77b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples/snapshot&lt;/a&gt;.</source>
          <target state="translated">この例のコードは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples / snapshotにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="dc4f949fe92e0d8c8e3b3a03859bac8aa481d502" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples/timer&lt;/a&gt;.</source>
          <target state="translated">この例のコードは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples / timerにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f12a555ea8e1761a86877b27341850cacd56ac73" translate="yes" xml:space="preserve">
          <source>The community around Jest is working hard to make the testing experience even greater.</source>
          <target state="translated">Jestを取り巻くコミュニティは、テスト体験をより素晴らしいものにするために努力しています。</target>
        </trans-unit>
        <trans-unit id="7585ea7c7f78a15b022764598b8197c90e7876b0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should output its coverage files.</source>
          <target state="translated">Jestがカバレッジファイルを出力するディレクトリ。</target>
        </trans-unit>
        <trans-unit id="376f21d7672ef7ba555cd8e4de07656368d480d0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should store its cached dependency information.</source>
          <target state="translated">Jestがキャッシュされた依存関係情報を保存するディレクトリ。</target>
        </trans-unit>
        <trans-unit id="b455adf26e8057d7ba70aa7e64159f9222cf09e6" translate="yes" xml:space="preserve">
          <source>The easiest way to debug Jest tests in &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; is using &lt;code&gt;Jest run/debug configuration&lt;/code&gt;. It will launch tests and automatically attach debugger.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStormで&lt;/a&gt; Jestテストをデバッグする最も簡単な方法は、 &lt;code&gt;Jest run/debug configuration&lt;/code&gt; です。テストを起動し、デバッガを自動的にアタッチします。</target>
        </trans-unit>
        <trans-unit id="ecbe9621df2404d5fbb33e2600044e0b27c47481" translate="yes" xml:space="preserve">
          <source>The example mock shown here uses &lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt;&lt;code&gt;jest.genMockFromModule&lt;/code&gt;&lt;/a&gt; to generate an automatic mock, and overrides its default behavior. This is the recommended approach, but is completely optional. If you do not want to use the automatic mock at all, you can export your own functions from the mock file. One downside to fully manual mocks is that they're manual &amp;ndash; meaning you have to manually update them any time the module they are mocking changes. Because of this, it's best to use or extend the automatic mock when it works for your needs.</source>
          <target state="translated">ここに示すモックの例では、&lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt; &lt;code&gt;jest.genMockFromModule&lt;/code&gt; &lt;/a&gt;を使用して自動モックを生成し、そのデフォルトの動作をオーバーライドしています。これは推奨されるアプローチですが、完全にオプションです。自動モックをまったく使用しない場合は、モックファイルから独自の関数をエクスポートできます。完全に手動のモックの欠点の1つは、それらが手動であることです。つまり、モックされているモジュールが変更されるたびに、手動でモックを更新する必要があります。このため、ニーズに応じて機能する自動モックを使用または拡張することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e4a4a43d898d3af6802055c9164972d36548014d" translate="yes" xml:space="preserve">
          <source>The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">最初の引数はテスト名です。2番目の引数は、テストする期待値を含む関数です。3番目の引数（オプション）は、中止するまでの待機時間を指定する &lt;code&gt;timeout&lt;/code&gt; （ミリ秒単位）です。&lt;em&gt;注：デフォルトのタイムアウトは5秒です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6838de5b16cb59f34f7a719f1e8d3453345e067e" translate="yes" xml:space="preserve">
          <source>The first time this test is run, Jest creates a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;snapshot file&lt;/a&gt; that looks like this:</source>
          <target state="translated">このテストを初めて実行すると、Jestは次のような&lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;スナップショットファイル&lt;/a&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="1492463266cc80f52fcf093c60f36ae239754aca" translate="yes" xml:space="preserve">
          <source>The following example contains a &lt;code&gt;houseForSale&lt;/code&gt; object with nested properties. We are using &lt;code&gt;toHaveProperty&lt;/code&gt; to check for the existence and values of various properties in the object.</source>
          <target state="translated">次の例には、ネストされたプロパティを持つ &lt;code&gt;houseForSale&lt;/code&gt; オブジェクトが含まれています。オブジェクト内のさまざまなプロパティの存在と値を確認するために &lt;code&gt;toHaveProperty&lt;/code&gt; を使用しています。</target>
        </trans-unit>
        <trans-unit id="a7f734d3eeaab81fca3e29f3523738b60fc7cd77" translate="yes" xml:space="preserve">
          <source>The following is a visualization of the default regex:</source>
          <target state="translated">以下はデフォルトの正規表現を可視化したものです。</target>
        </trans-unit>
        <trans-unit id="47cef9c94451278775edf865a9789b6d6b64cf3f" translate="yes" xml:space="preserve">
          <source>The following keys for built-in functionality &lt;strong&gt;can be overwritten&lt;/strong&gt; :</source>
          <target state="translated">次の組み込み機能のキーは&lt;strong&gt;上書きできます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d021e17efe498d997940dd70ef8fa277b5a2e9cd" translate="yes" xml:space="preserve">
          <source>The function being tested adds an event listener on the &lt;code&gt;#button&lt;/code&gt; DOM element, so we need to set up our DOM correctly for the test. Jest ships with &lt;code&gt;jsdom&lt;/code&gt; which simulates a DOM environment as if you were in the browser. This means that every DOM API that we call can be observed in the same way it would be observed in a browser!</source>
          <target state="translated">テストされる関数は &lt;code&gt;#button&lt;/code&gt; DOM要素にイベントリスナーを追加するため、テストのためにDOMを正しく設定する必要があります。 Jest には、ブラウザーにいるかのようにDOM環境をシミュレートする &lt;code&gt;jsdom&lt;/code&gt; が同梱されています。つまり、私たちが呼び出すすべてのDOM APIは、ブラウザーで観察されるのと同じ方法で観察できます。</target>
        </trans-unit>
        <trans-unit id="6596e95c4d26bf49becdf01cb51e6fc651959a04" translate="yes" xml:space="preserve">
          <source>The function should either return a path to the module that should be resolved or throw an error if the module can't be found.</source>
          <target state="translated">この関数は、解決すべきモジュールへのパスを返すか、モジュールが見つからない場合にエラーをスローしなければなりません。</target>
        </trans-unit>
        <trans-unit id="aab58f520069315bb0a84d63dee876237963ccad" translate="yes" xml:space="preserve">
          <source>The glob patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;.</source>
          <target state="translated">Jestがテストファイルを検出するために使用するグロブパターン。デフォルトでは、 &lt;code&gt;.jsx&lt;/code&gt; &lt;code&gt;__tests__&lt;/code&gt; フォルダー内の &lt;code&gt;.js&lt;/code&gt; 、.jsx、 &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; ファイル、および &lt;code&gt;.test&lt;/code&gt; または &lt;code&gt;.spec&lt;/code&gt; のサフィックスを持つファイル（たとえば、 &lt;code&gt;Component.test.js&lt;/code&gt; または &lt;code&gt;Component.spec.js&lt;/code&gt; ）を検索します。また、 &lt;code&gt;test.js&lt;/code&gt; または &lt;code&gt;spec.js&lt;/code&gt; というファイルも検索します。</target>
        </trans-unit>
        <trans-unit id="1723fc61e3e4203902e2769fce84e0f47e6816e8" translate="yes" xml:space="preserve">
          <source>The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.</source>
          <target state="translated">目標は、プルリクエストでスナップショットを簡単にレビューできるようにし、テストスイートが失敗したときに、失敗の根本的な原因を調べる代わりにスナップショットを再生成する習慣と戦うことです。</target>
        </trans-unit>
        <trans-unit id="2689ebeac189b738f558285371fec779e8a24bfd" translate="yes" xml:space="preserve">
          <source>The jest-community org maintains an &lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;awesome-jest&lt;/a&gt; list of great projects and resources related to Jest, this includes all projects not just the ones in the jest-community org.</source>
          <target state="translated">jest-community orgは、Jestに関連するすばらしいプロジェクトとリソースの&lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;awesome-jest&lt;/a&gt;リストを保持しています。これには、jest-community orgのプロジェクトだけでなく、すべてのプロジェクトが含まれます。</target>
        </trans-unit>
        <trans-unit id="327140711518544eb69d91ed359d0f86086c942f" translate="yes" xml:space="preserve">
          <source>The manual mock equivalent of this would be:</source>
          <target state="translated">これに相当するのがマニュアルのモックでしょう。</target>
        </trans-unit>
        <trans-unit id="968ed8d3094b9f92af942c92765f9081682130bf" translate="yes" xml:space="preserve">
          <source>The module factory function passed to &lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; can be a HOF that returns a function*. This will allow calling &lt;code&gt;new&lt;/code&gt; on the mock. Again, this allows you to inject different behavior for testing, but does not provide a way to spy on calls.</source>
          <target state="translated">&lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; 渡されるモジュールファクトリ関数は、関数*を返すHOFにすることができます。これにより、モックで &lt;code&gt;new&lt;/code&gt; を呼び出すことができます。繰り返しますが、これにより、テスト用にさまざまな動作を注入できますが、呼び出しをスパイする方法は提供されません。</target>
        </trans-unit>
        <trans-unit id="4376614c6f08aa0261023a608b95c6492b8e9525" translate="yes" xml:space="preserve">
          <source>The most common asynchronous pattern is callbacks.</source>
          <target state="translated">最も一般的な非同期パターンはコールバックです。</target>
        </trans-unit>
        <trans-unit id="0274127a2409aa50ab0b03082620b24a366d505d" translate="yes" xml:space="preserve">
          <source>The most common use of this API is for specifying the module a given test intends to be testing (and thus doesn't want automatically mocked).</source>
          <target state="translated">このAPIの最も一般的な使用法は、与えられたテストがテストしようとするモジュールを指定することです(したがって、自動的にモックされることを望まない)。</target>
        </trans-unit>
        <trans-unit id="6cba2620d821c40d1a35b89d6a989fe10a704a0f" translate="yes" xml:space="preserve">
          <source>The most useful ones are &lt;code&gt;matcherHint&lt;/code&gt;, &lt;code&gt;printExpected&lt;/code&gt; and &lt;code&gt;printReceived&lt;/code&gt; to format the error messages nicely. For example, take a look at the implementation for the &lt;code&gt;toBe&lt;/code&gt; matcher:</source>
          <target state="translated">最も有用なものは、エラーメッセージを &lt;code&gt;printReceived&lt;/code&gt; にフォーマットするための &lt;code&gt;matcherHint&lt;/code&gt; 、 &lt;code&gt;printExpected&lt;/code&gt; 、およびprintReceivedです。たとえば、 &lt;code&gt;toBe&lt;/code&gt; マッチャーの実装を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e952463962a1b689236ab9f6e17c97ccd482a4f3" translate="yes" xml:space="preserve">
          <source>The native timer functions (i.e., &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;clearTimeout&lt;/code&gt;, &lt;code&gt;clearInterval&lt;/code&gt;) are less than ideal for a testing environment since they depend on real time to elapse. Jest can swap out timers with functions that allow you to control the passage of time. &lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;Great Scott!&lt;/a&gt;</source>
          <target state="translated">ネイティブタイマー関数（つまり、 &lt;code&gt;setTimeout&lt;/code&gt; 、 &lt;code&gt;setInterval&lt;/code&gt; 、 &lt;code&gt;clearTimeout&lt;/code&gt; 、 &lt;code&gt;clearInterval&lt;/code&gt; ）は、経過時間がリアルタイムに依存するため、テスト環境には理想的ではありません。Jestは、タイマーを時間の経過を制御できる機能と交換できます。&lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;素晴らしいスコット！&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c7bd0e4ffc67ba49a20c3a2e181946f66fdd8b6" translate="yes" xml:space="preserve">
          <source>The next time you run Jest, &lt;code&gt;tree&lt;/code&gt; will be evaluated, and a snapshot will be written as an argument to &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;:</source>
          <target state="translated">次にJestを実行すると、 &lt;code&gt;tree&lt;/code&gt; が評価され、スナップショットが &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt; への引数として書き込まれます。</target>
        </trans-unit>
        <trans-unit id="5b848fe1137b4b9b68da4deb8ef3d11d697c37f6" translate="yes" xml:space="preserve">
          <source>The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with &lt;code&gt;jest -u&lt;/code&gt; to overwrite the existing snapshot.</source>
          <target state="translated">次にテストを実行するとき、レンダリングされた出力は、以前に作成されたスナップショットと比較されます。スナップショットは、コードの変更に沿ってコミットする必要があります。スナップショットテストが失敗した場合、それが意図した変更か意図しない変更かを検査する必要があります。変更が予想される場合は、 &lt;code&gt;jest -u&lt;/code&gt; を使用してJestを呼び出し、既存のスナップショットを上書きできます。</target>
        </trans-unit>
        <trans-unit id="a31eaed7b5b436b050c922084e63b820147d0c79" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;numDigits&lt;/code&gt; argument has default value &lt;code&gt;2&lt;/code&gt; which means the criterion is &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (that is, &lt;code&gt;10 ** -2 / 2&lt;/code&gt;).</source>
          <target state="translated">オプションの &lt;code&gt;numDigits&lt;/code&gt; 引数のデフォルト値は &lt;code&gt;2&lt;/code&gt; です。これは、基準が &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; （つまり、 &lt;code&gt;10 ** -2 / 2&lt;/code&gt; ）であることを意味します。</target>
        </trans-unit>
        <trans-unit id="fb0899f14809b1bdd6ebd980d7e7260be1575887" translate="yes" xml:space="preserve">
          <source>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first.</source>
          <target state="translated">マッピングを定義する順番が重要です。パターンは、1つが適合するまで1つずつチェックされます。最も具体的なルールを最初に記載します。</target>
        </trans-unit>
        <trans-unit id="4c5b04e8fcaf70465aadc92771f5000507ea04a5" translate="yes" xml:space="preserve">
          <source>The path to a module that can resolve test&amp;lt;-&amp;gt;snapshot path. This config option lets you customize where Jest stores snapshot files on disk.</source>
          <target state="translated">テストを解決できるモジュールへのパス&amp;lt;-&amp;gt;スナップショットパス。この構成オプションを使用すると、Jestがディスク上のスナップショットファイルを保存する場所をカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="af95718edc02b7821b4e9e81772f5338985c3a20" translate="yes" xml:space="preserve">
          <source>The path to a module that runs some code to configure or set up the testing framework before each test. Beware that files imported by the setup script will not be mocked during testing.</source>
          <target state="translated">各テストの前にテストフレームワークを設定したり設定したりするコードを実行するモジュールへのパスです。セットアップスクリプトによってインポートされたファイルはテスト中にモックされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4431569135edde52cd7dc8cd910c15a768e3e1b1" translate="yes" xml:space="preserve">
          <source>The pattern or patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;. See also &lt;a href=&quot;#testmatch-arraystring&quot;&gt;&lt;code&gt;testMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="translated">Jestがテストファイルを検出するために使用するパターン。デフォルトでは、 &lt;code&gt;.jsx&lt;/code&gt; &lt;code&gt;__tests__&lt;/code&gt; フォルダー内の &lt;code&gt;.js&lt;/code&gt; 、.jsx、 &lt;code&gt;.ts&lt;/code&gt; 、 &lt;code&gt;.tsx&lt;/code&gt; ファイル、および &lt;code&gt;.test&lt;/code&gt; または &lt;code&gt;.spec&lt;/code&gt; のサフィックスを持つファイル（たとえば、 &lt;code&gt;Component.test.js&lt;/code&gt; または &lt;code&gt;Component.spec.js&lt;/code&gt; ）を検索します。また、 &lt;code&gt;test.js&lt;/code&gt; または &lt;code&gt;spec.js&lt;/code&gt; というファイルも検索します。&lt;a href=&quot;#testmatch-arraystring&quot;&gt; &lt;code&gt;testMatch&lt;/code&gt; &lt;/a&gt; [array &amp;lt;string&amp;gt;]も参照してください。ただし、両方のオプションを指定することはできません。</target>
        </trans-unit>
        <trans-unit id="ac24fd9dddf51302b5efc36ff27838314425a460" translate="yes" xml:space="preserve">
          <source>The preset sets up the environment and is very opinionated and based on what we found to be useful at Facebook. All of the configuration options can be overwritten just as they can be customized when no preset is used.</source>
          <target state="translated">プリセットは環境を設定するもので、Facebookで便利だと感じたものをベースにした非常に意見の多い内容になっています。プリセットを使用していないときにカスタマイズできるのと同じように、すべての設定オプションを上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="ac31d1cab716f57b4c0ab81a14ecb8cc6af7f1f3" translate="yes" xml:space="preserve">
          <source>The problem is that the test will complete as soon as &lt;code&gt;fetchData&lt;/code&gt; completes, before ever calling the callback.</source>
          <target state="translated">問題は、コールバックを呼び出す前に、 &lt;code&gt;fetchData&lt;/code&gt; が完了するとすぐにテストが完了することです。</target>
        </trans-unit>
        <trans-unit id="9c9c92c829ae1b54b1e9c5e404efb1cc15d27456" translate="yes" xml:space="preserve">
          <source>The projects feature can also be used to run multiple configurations or multiple &lt;a href=&quot;#runner-string&quot;&gt;runners&lt;/a&gt;. For this purpose you can pass an array of configuration objects. For example, to run both tests and ESLint (via &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;) in the same invocation of Jest:</source>
          <target state="translated">プロジェクト機能を使用して、複数の構成または複数の&lt;a href=&quot;#runner-string&quot;&gt;ランナー&lt;/a&gt;を実行することもできます。この目的で、構成オブジェクトの配列を渡すことができます。たとえば、Jestの同じ呼び出しでテストとESLintの両方を（&lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslintを介して&lt;/a&gt;）実行するには：</target>
        </trans-unit>
        <trans-unit id="d777c2e867accda0c769689ff6458c1a1f2898ad" translate="yes" xml:space="preserve">
          <source>The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your &lt;code&gt;package.json&lt;/code&gt; and want the root directory to be the root of your repo, the value for this config param will default to the directory of the &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">Jestがテストとモジュールをスキャンするルートディレクトリ。Jest設定を &lt;code&gt;package.json&lt;/code&gt; 内に配置し、ルートディレクトリをリポジトリのルートにしたい場合、この設定パラメータの値はデフォルトで &lt;code&gt;package.json&lt;/code&gt; のディレクトリになります。</target>
        </trans-unit>
        <trans-unit id="a722fbdccf79dd6f0ade849e2e9aba5e205e8984" translate="yes" xml:space="preserve">
          <source>The second argument can be used to specify an explicit module factory that is being run instead of using Jest's automocking feature:</source>
          <target state="translated">2 番目の引数は、Jest の自動化機能を使用する代わりに実行する明示的なモジュールファクトリを指定するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="ea2159726c801a056456ea23b7ba004e04675c0c" translate="yes" xml:space="preserve">
          <source>The simplest way to test a value is with exact equality.</source>
          <target state="translated">値をテストする最も簡単な方法は、厳密な平等性です。</target>
        </trans-unit>
        <trans-unit id="89fdf05ff2117139335a3d62f43a887b7ae92045" translate="yes" xml:space="preserve">
          <source>The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; to make snapshots human-readable during code review. On subsequent test runs Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in this case, it's &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; component) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</source>
          <target state="translated">スナップショットアーティファクトは、コードの変更と一緒にコミットし、コードレビュープロセスの一部としてレビューする必要があります。 Jestは、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt;を使用して、コードレビュー中にスナップショットを人間が読めるようにします。後続のテスト実行時に、Jestはレンダリングされた出力を以前のスナップショットと比較します。それらが一致する場合、テストに合格します。それらが一致しない場合、テストランナーが修正する必要があるコード内のバグ（この場合は &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; コンポーネント）を検出したか、実装が変更され、スナップショットを更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="93bd3296b403f0c79b1219e068c720003979038e" translate="yes" xml:space="preserve">
          <source>The test environment that will be used for testing. The default environment in Jest is a browser-like environment through &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;. If you are building a node service, you can use the &lt;code&gt;node&lt;/code&gt; option to use a node-like environment instead.</source>
          <target state="translated">テストに使用されるテスト環境。Jestのデフォルト環境は、&lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;によるブラウザのような環境です。ノードサービスを構築している場合は、代わりに &lt;code&gt;node&lt;/code&gt; オプションを使用してノードのような環境を使用できます。</target>
        </trans-unit>
        <trans-unit id="83a5c50498cba1f5866a682bd859dafc3028b89d" translate="yes" xml:space="preserve">
          <source>The test environment used for all tests. This can point to any file or node module. Examples: &lt;code&gt;jsdom&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;path/to/my-environment.js&lt;/code&gt;.</source>
          <target state="translated">すべてのテストに使用されるテスト環境。これは、任意のファイルまたはノードモジュールを指すことができます。例： &lt;code&gt;jsdom&lt;/code&gt; 、 &lt;code&gt;node&lt;/code&gt; または &lt;code&gt;path/to/my-environment.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d4908fe8da50856a80634fb387ecf713015308b" translate="yes" xml:space="preserve">
          <source>The test for this function will look this way:</source>
          <target state="translated">この関数のテストはこのようになります。</target>
        </trans-unit>
        <trans-unit id="73d8c22714027dd5317a0ccf3a9114cb6f10cf4c" translate="yes" xml:space="preserve">
          <source>The test runner module must export a function with the following signature:</source>
          <target state="translated">テストランナーモジュールは、以下のシグネチャを持つ関数をエクスポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="29baec25ad18f1066c1ae3baa55f05cb1bcb3277" translate="yes" xml:space="preserve">
          <source>The third argument can be used to create virtual mocks &amp;ndash; mocks of modules that don't exist anywhere in the system:</source>
          <target state="translated">3番目の引数は、仮想モック（システムのどこにも存在しないモジュールのモック）を作成するために使用できます。</target>
        </trans-unit>
        <trans-unit id="06b3722bc66e669d036905e4f6b2a5bdde949a1d" translate="yes" xml:space="preserve">
          <source>The transform script was changed or Babel was updated and the changes aren't being recognized by Jest?</source>
          <target state="translated">トランスフォームスクリプトが変更されたのか、バベルが更新されてジェストに変更が認識されていないのか。</target>
        </trans-unit>
        <trans-unit id="ca9dbda065b378b7864401a6ebb986bd5f6ee7e2" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;.rejects&lt;/code&gt; helper works like the &lt;code&gt;.resolves&lt;/code&gt; helper. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="translated">&lt;code&gt;.rejects&lt;/code&gt; のような働きヘルパー &lt;code&gt;.resolves&lt;/code&gt; のヘルパー。約束が満たされた場合、テストは自動的に失敗します。</target>
        </trans-unit>
        <trans-unit id="eb453830c3d6aec96f0b7405572bb292c7ef9964" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;@babel/preset-typescript&lt;/code&gt; to the list of presets in your &lt;code&gt;babel.config.js&lt;/code&gt;.</source>
          <target state="translated">次に &lt;code&gt;@babel/preset-typescript&lt;/code&gt; &lt;code&gt;babel.config.js&lt;/code&gt; -typescriptをbabel.config.jsのプリセットのリストに追加します。</target>
        </trans-unit>
        <trans-unit id="70a1108a97f09cf114548ba44e232397dc6dda32" translate="yes" xml:space="preserve">
          <source>Then all your className lookups on the styles object will be returned as-is (e.g., &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt;). This is pretty handy for React &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;.</source>
          <target state="translated">次に、stylesオブジェクトに対するすべてのclassNameルックアップがそのまま返されます（たとえば、 &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt; ）。これは、React &lt;a href=&quot;snapshot-testing&quot;&gt;スナップショットテストに&lt;/a&gt;非常に便利です。</target>
        </trans-unit>
        <trans-unit id="7fd2e2b8e86105641b83aa873750ac3f07a7e6d6" translate="yes" xml:space="preserve">
          <source>Then attach VS Code's debugger using the following &lt;code&gt;launch.json&lt;/code&gt; config:</source>
          <target state="translated">次に、次の &lt;code&gt;launch.json&lt;/code&gt; 構成を使用してVS Codeのデバッガーをアタッチします。</target>
        </trans-unit>
        <trans-unit id="e2ebdb0fca325019ed94f96f98ebfc6dc5ffe770" translate="yes" xml:space="preserve">
          <source>Then we need a custom Test Environment for puppeteer</source>
          <target state="translated">そこで、人形遣いのためのカスタムテスト環境が必要になります。</target>
        </trans-unit>
        <trans-unit id="91f5afaec66d498efbeae8c4a2a41bd0c4feb389" translate="yes" xml:space="preserve">
          <source>Then you will see warnings in the console:</source>
          <target state="translated">すると、コンソールに警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="e559c23353ae644c58d965edecd0976830cfc4b2" translate="yes" xml:space="preserve">
          <source>Then, create a file named &lt;code&gt;sum.test.js&lt;/code&gt;. This will contain our actual test:</source>
          <target state="translated">次に、 &lt;code&gt;sum.test.js&lt;/code&gt; という名前のファイルを作成します。これには実際のテストが含まれます。</target>
        </trans-unit>
        <trans-unit id="490b7879f324bbb8130b919839cb28e4ee52a87d" translate="yes" xml:space="preserve">
          <source>There are a number of helpful tools exposed on &lt;code&gt;this.utils&lt;/code&gt; primarily consisting of the exports from &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt;&lt;code&gt;jest-matcher-utils&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;this.utils&lt;/code&gt; には、主に&lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt; &lt;code&gt;jest-matcher-utils&lt;/code&gt; &lt;/a&gt;からのエクスポートで構成される便利なツールがいくつか公開されています。</target>
        </trans-unit>
        <trans-unit id="ce3ddc7ca2ed0e64f9ff4f568a1875d4a36fac12" translate="yes" xml:space="preserve">
          <source>There are also scenarios where you might have a recursive timer -- that is a timer that sets a new timer in its own callback. For these, running all the timers would be an endless loop&amp;hellip; so something like &lt;code&gt;jest.runAllTimers()&lt;/code&gt; is not desirable. For these cases you might use &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt;:</source>
          <target state="translated">再帰的なタイマーがあるシナリオもあります-それは、独自のコールバックに新しいタイマーを設定するタイマーです。これらの場合、すべてのタイマーの実行は無限ループになります...したがって、 &lt;code&gt;jest.runAllTimers()&lt;/code&gt; のようなものは望ましくありません。これらのケースでは、 &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="8062c6b456eff0aa9aea644bdb6882897bba1ab7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to debug Jest tests with &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code's&lt;/a&gt; built in &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;debugger&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Codeの&lt;/a&gt;組み込み&lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;デバッガーを使用して&lt;/a&gt; Jestテストをデバッグする方法は複数あります。</target>
        </trans-unit>
        <trans-unit id="2f73f9113b29102310bf6ae603463dfb6eed9cda" translate="yes" xml:space="preserve">
          <source>There are times where you only want Jest to search in a single sub-directory (such as cases where you have a &lt;code&gt;src/&lt;/code&gt; directory in your repo), but prevent it from accessing the rest of the repo.</source>
          <target state="translated">Jestが単一のサブディレクトリのみを検索するようにしたい場合（リポジトリに &lt;code&gt;src/&lt;/code&gt; ディレクトリがある場合など）が、残りのリポジトリにアクセスできないようにする場合があります。</target>
        </trans-unit>
        <trans-unit id="0b73bd505ade591eff51524741c24e46983c0ab6" translate="yes" xml:space="preserve">
          <source>There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a &lt;a href=&quot;manual-mocks&quot;&gt;&lt;code&gt;manual mock&lt;/code&gt;&lt;/a&gt; to override a module dependency.</source>
          <target state="translated">関数をモックする方法は2つあります。テストコードで使用するモック関数を作成するか、モジュールの依存関係をオーバーライドする&lt;a href=&quot;manual-mocks&quot;&gt; &lt;code&gt;manual mock&lt;/code&gt; &lt;/a&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="cb812ec7da9105ae82712a4e1f280b3919c21f67" translate="yes" xml:space="preserve">
          <source>There is a less verbose way using &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise together with any other matcher. If the promise is rejected, the assertion will fail.</source>
          <target state="translated">&lt;code&gt;resolves&lt;/code&gt; を使用して、満たされたpromiseの値を他のマッチャーと一緒にアンラップする、より簡潔な方法があります。約束が拒否された場合、アサーションは失敗します。</target>
        </trans-unit>
        <trans-unit id="d3bc98afc16f0c3f67ba16dbd3f93d1dbca283cf" translate="yes" xml:space="preserve">
          <source>There is an alternate form of &lt;code&gt;test&lt;/code&gt; that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called &lt;code&gt;done&lt;/code&gt;. Jest will wait until the &lt;code&gt;done&lt;/code&gt; callback is called before finishing the test.</source>
          <target state="translated">これを修正する別の形式の &lt;code&gt;test&lt;/code&gt; があります。空の引数を持つ関数にテストを置く代わりに、 &lt;code&gt;done&lt;/code&gt; という単一の引数を使用します。Jestはテストが完了する前に、 &lt;code&gt;done&lt;/code&gt; コールバックが呼び出されるまで待機します。</target>
        </trans-unit>
        <trans-unit id="38513f64442e40688964ff51c98714e3662f0ad9" translate="yes" xml:space="preserve">
          <source>There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:</source>
          <target state="translated">Enzyme と React 16+を使用する際のスナップショットテストには注意点があります。以下のようなスタイルでモジュールをモックアウトした場合。</target>
        </trans-unit>
        <trans-unit id="45969bbe3aaa0e36ec651be5c3c1e2bc6f21618e" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies.</source>
          <target state="translated">依存関係をロードする必要はありません。</target>
        </trans-unit>
        <trans-unit id="feaa8cf5e94e8af347c21dcc253b06efd78e08cf" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies. Puppeteer's &lt;code&gt;page&lt;/code&gt; and &lt;code&gt;browser&lt;/code&gt; classes will automatically be exposed</source>
          <target state="translated">依存関係をロードする必要はありません。Puppeteerの &lt;code&gt;page&lt;/code&gt; と &lt;code&gt;browser&lt;/code&gt; クラスは自動的に公開されます</target>
        </trans-unit>
        <trans-unit id="205f02d2ffd73f73e820d056d16ae760c3445b0d" translate="yes" xml:space="preserve">
          <source>These helper functions and properties can be found on &lt;code&gt;this&lt;/code&gt; inside a custom matcher:</source>
          <target state="translated">これらのヘルパー関数とプロパティは、上で見つけることができます &lt;code&gt;this&lt;/code&gt; カスタム照合の内側：</target>
        </trans-unit>
        <trans-unit id="6b60550c5bbaa39ef042c5fe44f0a413fa65b5bf" translate="yes" xml:space="preserve">
          <source>These matchers are sugar for common forms of inspecting the &lt;code&gt;.mock&lt;/code&gt; property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:</source>
          <target state="translated">これらのマッチャーは、 &lt;code&gt;.mock&lt;/code&gt; プロパティを検査する一般的な形式の砂糖です。それが自分の好みに合っている場合、またはより具体的なことを行う必要がある場合は、いつでも手動でこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="9d8fa2963a415398720fb864829eb323209ccbff" translate="yes" xml:space="preserve">
          <source>These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:</source>
          <target state="translated">これらのモックメンバは、これらの関数がどのようにして呼び出され、インスタンス化され、何を返すのかをアサートするためのテストで非常に便利です。</target>
        </trans-unit>
        <trans-unit id="421ccddd05618e2071d86e6bbbe14f0b2076576e" translate="yes" xml:space="preserve">
          <source>These options let you control Jest's behavior in your &lt;code&gt;package.json&lt;/code&gt; file. The Jest philosophy is to work great by default, but sometimes you just need more configuration power.</source>
          <target state="translated">これらのオプションを使用すると、 &lt;code&gt;package.json&lt;/code&gt; ファイルでJestの動作を制御できます。Jestの哲学は、デフォルトで適切に機能することですが、場合によっては、より多くの構成能力が必要になることもあります。</target>
        </trans-unit>
        <trans-unit id="fcaea31195ac296456fff13bc787d5eef5067d3d" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.</source>
          <target state="translated">これらのパターン文字列は、完全パスと照合されます。 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 文字列トークンを使用して、プロジェクトのルートディレクトリへのパスを含め、ルートディレクトリが異なる可能性のある異なる環境にあるすべてのファイルを誤って無視しないようにします。</target>
        </trans-unit>
        <trans-unit id="17b10be41180956fbf5d08f1f6d6c3f7a2db71c5" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">これらのパターン文字列は、完全パスと照合されます。 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 文字列トークンを使用して、プロジェクトのルートディレクトリへのパスを含め、ルートディレクトリが異なる可能性のある異なる環境にあるすべてのファイルを誤って無視しないようにします。例： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="005b28d7accf90e223dee1c8e7ebc452b6213877" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt;.</source>
          <target state="translated">これらのパターン文字列は、完全パスと照合されます。 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 文字列トークンを使用して、プロジェクトのルートディレクトリへのパスを含め、ルートディレクトリが異なる可能性のある異なる環境にあるすべてのファイルを誤って無視しないようにします。例： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b61d73386d7f1dedf935b736a15ddf6e38555ac" translate="yes" xml:space="preserve">
          <source>These patterns match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">これらのパターンは完全なパスと一致します。 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 文字列トークンを使用して、プロジェクトのルートディレクトリへのパスを含め、ルートディレクトリが異なる可能性のある異なる環境にあるすべてのファイルを誤って無視しないようにします。例： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c464bdbe395120d407822fbb18f9738c9a02965a" translate="yes" xml:space="preserve">
          <source>Third-party plugins are also forbidden to overwrite a key reserved already by another third-party plugin present earlier in the configured plugins list (&lt;code&gt;watchPlugins&lt;/code&gt; array setting). When this happens, you&amp;rsquo;ll also get an error message that tries to help you fix that:</source>
          <target state="translated">サードパーティプラグインは、構成済みプラグインリスト（ &lt;code&gt;watchPlugins&lt;/code&gt; 配列設定）の前に存在する別のサードパーティプラグインによってすでに予約されているキーを上書きすることも禁止されています。これが発生すると、その修正に役立つエラーメッセージも表示されます。</target>
        </trans-unit>
        <trans-unit id="ea26b0157e1130ece50df7d1c6b1515a7cc72eba" translate="yes" xml:space="preserve">
          <source>This allows your test file to import the actual &lt;code&gt;Response&lt;/code&gt; object from &lt;code&gt;node-fetch&lt;/code&gt;, rather than a mocked version. This means the test will now pass correctly.</source>
          <target state="translated">これにより、テストファイルは、モックバージョンではなく、 &lt;code&gt;node-fetch&lt;/code&gt; から実際の &lt;code&gt;Response&lt;/code&gt; オブジェクトをインポートできます。これは、テストが正しくパスすることを意味します。</target>
        </trans-unit>
        <trans-unit id="6c57d62e399034f0a7b381de3e7d5f645f9ad504" translate="yes" xml:space="preserve">
          <source>This ensures that a value matches the most recent snapshot. Check out &lt;a href=&quot;snapshot-testing&quot;&gt;the Snapshot Testing guide&lt;/a&gt; for more information.</source>
          <target state="translated">これにより、値が最新のスナップショットと確実に一致します。詳細について&lt;a href=&quot;snapshot-testing&quot;&gt;は、スナップショットテストガイド&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="dac9e840fc23ac31d800f8538975040bb9ecac74" translate="yes" xml:space="preserve">
          <source>This example also shows how you can nest multiple asymmetric matchers, with &lt;code&gt;expect.stringMatching&lt;/code&gt; inside the &lt;code&gt;expect.arrayContaining&lt;/code&gt;.</source>
          <target state="translated">この例は、 &lt;code&gt;expect.arrayContaining&lt;/code&gt; が &lt;code&gt;expect.stringMatching&lt;/code&gt; 内にある状態で、複数の非対称マッチャーをネストする方法も示しています。</target>
        </trans-unit>
        <trans-unit id="6b58eb0d982c4ebd2168b0b47532f786470fd666" translate="yes" xml:space="preserve">
          <source>This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.</source>
          <target state="translated">この例の設定では、ルートディレクトリとexamplesディレクトリ内のすべてのフォルダでJestを実行します。同じ Jest インスタンスで実行しているプロジェクトの数に制限はありません。</target>
        </trans-unit>
        <trans-unit id="07d5008923646b5de183b191e7806d1642e368f2" translate="yes" xml:space="preserve">
          <source>This is a deep-equality function that will return &lt;code&gt;true&lt;/code&gt; if two objects have the same values (recursively).</source>
          <target state="translated">これは、2つのオブジェクトの値が（再帰的に）同じ場合に &lt;code&gt;true&lt;/code&gt; を返す、深平等関数です。</target>
        </trans-unit>
        <trans-unit id="8787606ea91f4fa45b63964dfe671fe216f1f18b" translate="yes" xml:space="preserve">
          <source>This is especially useful for checking arrays or strings size.</source>
          <target state="translated">これは特に配列や文字列のサイズをチェックするのに便利です。</target>
        </trans-unit>
        <trans-unit id="df6bb81a22b9aea2dc501ec88e58677f39b608e1" translate="yes" xml:space="preserve">
          <source>This is how &lt;code&gt;genMockFromModule&lt;/code&gt; will mock the following data types:</source>
          <target state="translated">これは、 &lt;code&gt;genMockFromModule&lt;/code&gt; が次のデータ型をモックする方法です。</target>
        </trans-unit>
        <trans-unit id="3773feba2fd857753eb4d289910186bb5075a5d0" translate="yes" xml:space="preserve">
          <source>This is just a taste. For a complete list of matchers, check out the &lt;a href=&quot;expect&quot;&gt;reference docs&lt;/a&gt;.</source>
          <target state="translated">これはただの味です。マッチャーの完全なリストについては、&lt;a href=&quot;expect&quot;&gt;リファレンスドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b91b6036665a31c72c932de515d167cc3324bf18" translate="yes" xml:space="preserve">
          <source>This is often useful for synchronously executing setTimeouts during a test in order to synchronously assert about some behavior that would only happen after the &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; callbacks executed. See the &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; doc for more information.</source>
          <target state="translated">これは、 &lt;code&gt;setTimeout()&lt;/code&gt; または &lt;code&gt;setInterval()&lt;/code&gt; コールバックが実行された後にのみ発生するいくつかの動作について同期的にアサートするために、テスト中に同期的にsetTimeoutsを実行する場合に役立ちます。詳細については、&lt;a href=&quot;timer-mocks&quot;&gt;タイマーモック&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="b7d7c1519ae2cf4a773f1afd649832547d401f24" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some global setup state that is shared across tests.</source>
          <target state="translated">これは、テスト間で共有されているグローバルなセットアップ状態をクリーンアップしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="f38502aacbc947736082f8a6708a41145ca79655" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some temporary state that is created by each test.</source>
          <target state="translated">これは、各テストで作成された一時的な状態をクリーンアップしたい場合に便利なことが多いです。</target>
        </trans-unit>
        <trans-unit id="f0881bf0bef2a66191cfe13dc0ddb9fc67b1b880" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to reset some global state that will be used by many tests.</source>
          <target state="translated">これは、多くのテストで使用されるグローバルな状態をリセットしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="c9eaf0b51489505b8e52db0ac5e52495ccfe19ba" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to set up some global state that will be used by many tests.</source>
          <target state="translated">これは、多くのテストで使用されるグローバルな状態を設定したい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="72cca58df7454651ff7a323dceaea7ab640b298b" translate="yes" xml:space="preserve">
          <source>This is useful for scenarios such as one where the module being tested schedules a &lt;code&gt;setTimeout()&lt;/code&gt; whose callback schedules another &lt;code&gt;setTimeout()&lt;/code&gt; recursively (meaning the scheduling never stops). In these scenarios, it's useful to be able to run forward in time by a single step at a time.</source>
          <target state="translated">これは、テスト中のモジュールが &lt;code&gt;setTimeout()&lt;/code&gt; をスケジュールし、そのコールバックが別の &lt;code&gt;setTimeout()&lt;/code&gt; を再帰的にスケジュールする（スケジュールが決して停止しない）などのシナリオに役立ちます。これらのシナリオでは、一度に1ステップずつ前に進むことができると便利です。</target>
        </trans-unit>
        <trans-unit id="3a5ea63e8ffdad93e9fef81bb115e6f5cff87758" translate="yes" xml:space="preserve">
          <source>This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like underscore/lo-dash, etc). It's generally a best practice to keep this list as small as possible and always use explicit &lt;code&gt;jest.mock()&lt;/code&gt;/&lt;code&gt;jest.unmock()&lt;/code&gt; calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.</source>
          <target state="translated">これは、ほとんど常に実装の詳細として使用されている一般的に使用される「ユーティリティ」モジュール（アンダースコア/ローダッシュなど）に役立ちます。通常、このリストをできるだけ小さくして、個々のテストで常に明示的な &lt;code&gt;jest.mock()&lt;/code&gt; / &lt;code&gt;jest.unmock()&lt;/code&gt; 呼び出しを使用することがベストプラクティスです。明示的なテストごとのセットアップは、テストを実行する環境について他のテストの読者が推論する方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="511f2fbaf8920a0608d26d5165905f63a5d73c88" translate="yes" xml:space="preserve">
          <source>This is useful when you want to completely reset a &lt;em&gt;mock&lt;/em&gt; back to its initial state. (Note that resetting a &lt;em&gt;spy&lt;/em&gt; will result in a function with no return value).</source>
          <target state="translated">これは、&lt;em&gt;モック&lt;/em&gt;を完全に初期状態にリセットする場合に便利です。（&lt;em&gt;スパイ&lt;/em&gt;をリセットすると、戻り値のない関数になることに注意してください）。</target>
        </trans-unit>
        <trans-unit id="c8d37ce85710fb471d0b215386de8769da78ab05" translate="yes" xml:space="preserve">
          <source>This is useful when you want to create a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that extends the automatic mock's behavior.</source>
          <target state="translated">これは、自動モックの動作を拡張する&lt;a href=&quot;manual-mocks&quot;&gt;手動モック&lt;/a&gt;を作成する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="d837db43e33775ed71a2885c71c5a5602ed7202b" translate="yes" xml:space="preserve">
          <source>This is useful when you want to mock functions in certain test cases and restore the original implementation in others.</source>
          <target state="translated">これは、特定のテストケースでは関数をモックし、他のテストケースでは元の実装に戻したい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="990db4730f558f16c2dc74a09c332aa10da16053" translate="yes" xml:space="preserve">
          <source>This is usually useful when you have a scenario where the number of dependencies you want to mock is far less than the number of dependencies that you don't. For example, if you're writing a test for a module that uses a large number of dependencies that can be reasonably classified as &quot;implementation details&quot; of the module, then you likely do not want to mock them.</source>
          <target state="translated">これは通常、モックしたい依存関係の数が、モックしたくない依存関係の数よりもはるかに少ないシナリオがある場合に便利です。例えば、モジュールの &quot;実装の詳細 &quot;として合理的に分類できる多数の依存関係を使用するモジュールのテストを書いている場合、それらをモックしたくない可能性が高いでしょう。</target>
        </trans-unit>
        <trans-unit id="2cd58fa126aba532c56c9309e162bd465bef920f" translate="yes" xml:space="preserve">
          <source>This isn't required - you can write the &lt;code&gt;test&lt;/code&gt; blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.</source>
          <target state="translated">これは必須ではありません。 &lt;code&gt;test&lt;/code&gt; ブロックをトップレベルに直接書き込むことができます。しかし、テストをグループにまとめたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="bc38e9460c76ac869bfb97b729c4bebd9601d3e9" translate="yes" xml:space="preserve">
          <source>This matcher also accepts a string, which it will try to match:</source>
          <target state="translated">この Matcherは文字列も受け付け、それをマッチさせようとします。</target>
        </trans-unit>
        <trans-unit id="35176ec62e10ad24d9e5bf5b4f422f755d6dc150" translate="yes" xml:space="preserve">
          <source>This means, if any timers have been scheduled (but have not yet executed), they will be cleared and will never have the opportunity to execute in the future.</source>
          <target state="translated">つまり、もしタイマーがスケジュールされている(まだ実行されていない)場合、それらのタイマーはクリアされ、今後実行する機会がなくなるということです。</target>
        </trans-unit>
        <trans-unit id="688cc7c951b98d9e176b0ce89e8ee57961515438" translate="yes" xml:space="preserve">
          <source>This option allow comments in &lt;code&gt;package.json&lt;/code&gt;. Include the comment text as the value of this key anywhere in &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">このオプションは、 &lt;code&gt;package.json&lt;/code&gt; 内のコメントを許可します。 &lt;code&gt;package.json&lt;/code&gt; の任意の場所に、このキーの値としてコメントテキストを含めます。</target>
        </trans-unit>
        <trans-unit id="50f12b52eb11d088de9a4fec28160df38ac92acd" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an &lt;code&gt;extract&lt;/code&gt; function. E.g.:</source>
          <target state="translated">このオプションでは、カスタムの依存関係抽出機能を使用できます。これは、 &lt;code&gt;extract&lt;/code&gt; 機能でオブジェクトをエクスポートするノードモジュールである必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="7387fe3f611db301893ec5bf7cc4bbe625475ab6" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global setup module which exports an async function that is triggered once before all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="translated">このオプションでは、すべてのテストスイートの前に1回トリガーされる非同期関数をエクスポートするカスタムグローバルセットアップモジュールを使用できます。この関数は、Jestの &lt;code&gt;globalConfig&lt;/code&gt; オブジェクトをパラメーターとして取得します。</target>
        </trans-unit>
        <trans-unit id="f462a8db0f13013cff3f25a99166d1df5cc7a9d9" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global teardown module which exports an async function that is triggered once after all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="translated">このオプションでは、すべてのテストスイートの後にトリガーされる非同期関数をエクスポートするカスタムグローバルティアダウンモジュールを使用できます。この関数は、Jestの &lt;code&gt;globalConfig&lt;/code&gt; オブジェクトをパラメーターとして取得します。</target>
        </trans-unit>
        <trans-unit id="38a9ab5d714461ae4a524d403260c43d23431747" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom resolver. This resolver must be a node module that exports a function expecting a string as the first argument for the path to resolve and an object with the following structure as the second argument:</source>
          <target state="translated">このオプションを使用すると、カスタム・リゾルバを使用することができます。このリゾルバは、解決するパスの第一引数として文字列を期待する関数をエクスポートし、第二引数として以下の構造を持つオブジェクトをエクスポートするノードモジュールでなければなりません。</target>
        </trans-unit>
        <trans-unit id="840ac7a9f3696ee6876dcc9f096bc867ff39672e" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:</source>
          <target state="translated">このオプションを使用すると、カスタム結果プロセッサを使用することができます。このプロセッサは、以下の構造体を第一引数に持つオブジェクトを期待して関数をエクスポートし、それを返すノードモジュールでなければなりません。</target>
        </trans-unit>
        <trans-unit id="551495954b791bddca5765dca30e41d9a29511c6" translate="yes" xml:space="preserve">
          <source>This option allows use of a custom test runner. The default is jasmine2. A custom test runner can be provided by specifying a path to a test runner implementation.</source>
          <target state="translated">このオプションでは、カスタムのテストランナーを使用することができます。デフォルトは jasmine2 です。カスタムテストランナーは、テストランナーの実装へのパスを指定することで提供することができます。</target>
        </trans-unit>
        <trans-unit id="44d88dc72d1af311d80a8540431e21118807550c" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:</source>
          <target state="translated">このオプションでは、Jestのデフォルトのテストランナーの代わりにカスタムランナーを使用することができます。ランナーの例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="f5d6d08e3a74b9984da0a1564cf8f546a76f4a82" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom sequencer instead of Jest's default. &lt;code&gt;sort&lt;/code&gt; may optionally return a Promise.</source>
          <target state="translated">このオプションを使用すると、Jestのデフォルトの代わりにカスタムシーケンサーを使用できます。 &lt;code&gt;sort&lt;/code&gt; はオプションでPromiseを返す場合があります。</target>
        </trans-unit>
        <trans-unit id="c90ce340f3088fe9972394e67acc0935ff513e5d" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom watch plugins. Read more about watch plugins &lt;a href=&quot;watch-plugins&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">このオプションを使用すると、カスタム監視プラグインを使用できます。ウォッチプラグインの詳細については、&lt;a href=&quot;watch-plugins&quot;&gt;こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a29c38f33c668ab5c982f199af3ff02856c863a" translate="yes" xml:space="preserve">
          <source>This option sets the URL for the jsdom environment. It is reflected in properties such as &lt;code&gt;location.href&lt;/code&gt;.</source>
          <target state="translated">このオプションは、jsdom環境のURLを設定します。これは、 &lt;code&gt;location.href&lt;/code&gt; などのプロパティに反映されます。</target>
        </trans-unit>
        <trans-unit id="d6bd84ad18e9b644594d518b7f4d72e5c10823c4" translate="yes" xml:space="preserve">
          <source>This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.</source>
          <target state="translated">このオプションは、テストでインポートされたすべてのモジュールを自動的にモックするようにJestに指示します。テストで使用されるすべてのモジュールは、API の表面を維持したまま、代替の実装を持つことになります。</target>
        </trans-unit>
        <trans-unit id="98e2dcf1f1c275210f7dbe5eb1535d1ff6f9f4c3" translate="yes" xml:space="preserve">
          <source>This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.</source>
          <target state="translated">有用な警告が失われる可能性があるため、通常はこのオプションを選択すべきではありません。しかし、いくつかのケースでは、例えば react-native のコンポーネントをテストするとき、 react-native タグを DOM にレンダリングしているので、多くの警告は無関係です。別の選択肢としては、console.warnをswizzleして特定の警告を抑制することもできます。</target>
        </trans-unit>
        <trans-unit id="360362a3cbe9313d68d1cf19949c3804d1f4ed87" translate="yes" xml:space="preserve">
          <source>This test used &lt;code&gt;expect&lt;/code&gt; and &lt;code&gt;toBe&lt;/code&gt; to test that two values were exactly identical. To learn about the other things that Jest can test, see &lt;a href=&quot;using-matchers&quot;&gt;Using Matchers&lt;/a&gt;.</source>
          <target state="translated">このテストでは、 &lt;code&gt;expect&lt;/code&gt; および &lt;code&gt;toBe&lt;/code&gt; を使用して、2つの値がまったく同じであることをテストしました。Jestでテストできるその他の&lt;a href=&quot;using-matchers&quot;&gt;事項&lt;/a&gt;については、「マッチャーの使用」を参照してください。</target>
        </trans-unit>
        <trans-unit id="e6e9bf3c4c1c53fe256faefd1ca6b822f3ed81ba" translate="yes" xml:space="preserve">
          <source>This will add a line in the watch mode menu &lt;em&gt;(&lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt;)&lt;/em&gt;</source>
          <target state="translated">これにより、監視モードメニューに行が追加されます&lt;em&gt;（&lt;/em&gt;&lt;em&gt; &lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt; &lt;/em&gt;ます&lt;em&gt;。&lt;/em&gt;&lt;em&gt;）&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f973bafbc6c9d08f6e504faea0ed8253ab2995f" translate="yes" xml:space="preserve">
          <source>This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as &lt;code&gt;global&lt;/code&gt;, as a &lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;glob&lt;/a&gt;, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.</source>
          <target state="translated">これは、カバレッジ結果の最小しきい値適用を構成するために使用されます。しきい値は、 &lt;code&gt;global&lt;/code&gt; 、&lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;glob&lt;/a&gt;、およびディレクトリまたはファイルパスとして指定できます。しきい値が満たされない場合、jestは失敗します。正の数として指定されたしきい値は、必要な最小パーセンテージと見なされます。負の数として指定されたしきい値は、許可されるカバーされていないエンティティーの最大数を表します。</target>
        </trans-unit>
        <trans-unit id="9b781fa5a1c5086d94b94b3ea9ed32876793c2c2" translate="yes" xml:space="preserve">
          <source>This will collect coverage information for all the files inside the project's &lt;code&gt;rootDir&lt;/code&gt;, except the ones that match &lt;code&gt;**/node_modules/**&lt;/code&gt; or &lt;code&gt;**/vendor/**&lt;/code&gt;.</source>
          <target state="translated">これ &lt;code&gt;rootDir&lt;/code&gt; 、 &lt;code&gt;**/node_modules/**&lt;/code&gt; または &lt;code&gt;**/vendor/**&lt;/code&gt; に一致するファイルを除いて、プロジェクトのrootDir内のすべてのファイルのカバレッジ情報が収集されます。</target>
        </trans-unit>
        <trans-unit id="90cf7fb35e518c105a5552c6219ed3a42ba97b15" translate="yes" xml:space="preserve">
          <source>This will let us inspect usage of our mocked class, using &lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt;: &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; or near-equivalent: &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</source>
          <target state="translated">これは、私たちが使用して、私たちの嘲笑クラスの使用法を検査できるようになる &lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt; を： &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; またはほぼ同等： &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="209071c8d9163c6dfec4225f989d2e729c2933ea" translate="yes" xml:space="preserve">
          <source>This will override default reporters:</source>
          <target state="translated">これはデフォルトのレポーターを上書きします。</target>
        </trans-unit>
        <trans-unit id="1ce9f7467129f03386e85416d9a79207d3f3cd66" translate="yes" xml:space="preserve">
          <source>This will print something like this:</source>
          <target state="translated">このように印刷されます。</target>
        </trans-unit>
        <trans-unit id="0128c1ff802183c48e311ffffeefd6c4c9feb5e7" translate="yes" xml:space="preserve">
          <source>This will render the component as &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; with all of its props in the snapshot output. See also &lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;caveats around Enzyme and React 16&lt;/a&gt;.</source>
          <target state="translated">これにより、コンポーネントが &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; としてレンダリングされ、すべての小道具がスナップショット出力に表示されます。&lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;Enzyme and React 16に関する警告&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="031037a615f9d64385b25800b6c16eb718e695ad" translate="yes" xml:space="preserve">
          <source>This will run Jest in a Node process that an external debugger can connect to. Note that the process will pause until the debugger has connected to it.</source>
          <target state="translated">これは、外部デバッガが接続できる Node プロセスで Jest を実行します。デバッガが接続するまでプロセスは一時停止することに注意してください。</target>
        </trans-unit>
        <trans-unit id="ff1252de72d76270d68e2df9f8a951026c2b21af" translate="yes" xml:space="preserve">
          <source>This will throw &lt;strong&gt;&lt;em&gt;TypeError: _soundPlayer2.default is not a constructor&lt;/em&gt;&lt;/strong&gt;, unless the code is transpiled to ES5, e.g. by &lt;code&gt;@babel/preset-env&lt;/code&gt;. (ES5 doesn't have arrow functions nor classes, so both will be transpiled to plain functions.)</source>
          <target state="translated">これにより&lt;strong&gt;&lt;em&gt;TypeError&lt;/em&gt;&lt;/strong&gt;がスロー &lt;code&gt;@babel/preset-env&lt;/code&gt; ます。たとえば、@ babel / preset -envによってコードがES5にトランスパイルされない限り、&lt;strong&gt;&lt;em&gt;_soundPlayer2.defaultはコンストラクタではありません&lt;/em&gt;&lt;/strong&gt;。（ES5にはアロー関数もクラスもないため、両方ともプレーン関数に変換されます。）</target>
        </trans-unit>
        <trans-unit id="a06ab4358a87cc38d323a6fe966b85af4c53ee66" translate="yes" xml:space="preserve">
          <source>This will use custom reporter in addition to default reporters that Jest provides:</source>
          <target state="translated">これにより、Jestが提供するデフォルトのレポーターに加えて、カスタムレポーターが使用されます。</target>
        </trans-unit>
        <trans-unit id="5c615ded93f646fc52958cfb01c7b4ab285ef4d0" translate="yes" xml:space="preserve">
          <source>This works if &lt;code&gt;window.matchMedia()&lt;/code&gt; is used in a function (or method) which is invoked in the test. If &lt;code&gt;window.matchMedia()&lt;/code&gt; is executed directly in the tested file, Jest reports the same error. In this case, the solution is to move the manual mock into a separate file and include this one in the test &lt;strong&gt;before&lt;/strong&gt; the tested file:</source>
          <target state="translated">これは、テストで呼び出される関数（またはメソッド）で &lt;code&gt;window.matchMedia()&lt;/code&gt; が使用されている場合に機能します。テストされたファイルで &lt;code&gt;window.matchMedia()&lt;/code&gt; が直接実行された場合、Jestは同じエラーを報告します。この場合の解決策は、手動のモックを別のファイルに移動し、テストしたファイルの&lt;strong&gt;前&lt;/strong&gt;にこれをテスト&lt;strong&gt;に&lt;/strong&gt;含めることです。</target>
        </trans-unit>
        <trans-unit id="0bce8231bb2ded7244230db592d5f3864c807820" translate="yes" xml:space="preserve">
          <source>Timer Mocks</source>
          <target state="translated">タイマーモック</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="2ae1e08337e0c3fff9724e42846cabe84620ef36" translate="yes" xml:space="preserve">
          <source>To add a key to the watch menu, implement the &lt;code&gt;getUsageInfo&lt;/code&gt; method, returning a key and the prompt:</source>
          <target state="translated">監視メニューにキーを追加するには、 &lt;code&gt;getUsageInfo&lt;/code&gt; メソッドを実装し、キーとプロンプトを返します。</target>
        </trans-unit>
        <trans-unit id="47b39578e06150847a8bca907a560548f45db25e" translate="yes" xml:space="preserve">
          <source>To attach the built-in debugger, run your tests as aforementioned:</source>
          <target state="translated">組み込みのデバッガをアタッチするには、前述のようにテストを実行します。</target>
        </trans-unit>
        <trans-unit id="ecb87b5a4ec9578d9ae035bd9525d7f9a0bbc2d6" translate="yes" xml:space="preserve">
          <source>To automatically launch and attach to a process running your tests, use the following configuration:</source>
          <target state="translated">テストを実行しているプロセスを自動的に起動してアタッチするには、以下の設定を使用します。</target>
        </trans-unit>
        <trans-unit id="8ef0aac5dc160f7cae3d13500ae91ad9928ac0f1" translate="yes" xml:space="preserve">
          <source>To build your own please visit the &lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;Custom Transformer&lt;/a&gt; section</source>
          <target state="translated">独自に作成するには、&lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;カスタムトランスフォーマー&lt;/a&gt;セクションにアクセスしてください</target>
        </trans-unit>
        <trans-unit id="aacf02378e2b38f25b6b3e4a83d574f8e35ceb32" translate="yes" xml:space="preserve">
          <source>To clear the record of calls to the mock constructor function and its methods, we call &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt;&lt;code&gt;mockClear()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;beforeEach()&lt;/code&gt; function:</source>
          <target state="translated">モックコンストラクター関数とそのメソッドの呼び出しの記録をクリアするには、 &lt;code&gt;beforeEach()&lt;/code&gt; 関数で&lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt; &lt;code&gt;mockClear()&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="bbcbbcf6e6e23076d275df0fe406a4a0a2189298" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of more than 10 ounces, write:</source>
          <target state="translated">浮動小数点数を比較するには、 &lt;code&gt;toBeGreaterThan&lt;/code&gt; を使用できます。たとえば、 &lt;code&gt;ouncesPerCan()&lt;/code&gt; が10オンスを超える値を返すことをテストする場合は、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="f788e1ff5eca8835f05697583466e13f0b6a83d4" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at least 12 ounces, write:</source>
          <target state="translated">浮動小数点数を比較するには、 &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt; を使用できます。たとえば、 &lt;code&gt;ouncesPerCan()&lt;/code&gt; が少なくとも12オンスの値を返すことをテストする場合は、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="3630a179a57250195ccd7b5b31b4f9f6faacbab0" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of less than 20 ounces, write:</source>
          <target state="translated">浮動小数点数を比較するには、 &lt;code&gt;toBeLessThan&lt;/code&gt; を使用できます。たとえば、 &lt;code&gt;ouncesPerCan()&lt;/code&gt; が20オンス未満の値を返すことをテストする場合は、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="7bc35d8ccb0dac837113cbb13a4a6a626da1b19b" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at most 12 ounces, write:</source>
          <target state="translated">浮動小数点数を比較するには、 &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt; を使用できます。たとえば、 &lt;code&gt;ouncesPerCan()&lt;/code&gt; が最大12オンスの値を返すことをテストする場合は、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="8488371ee9451e1b8abe49379e43d2abac066b15" translate="yes" xml:space="preserve">
          <source>To connect your watch plugin to Jest, add its path under &lt;code&gt;watchPlugins&lt;/code&gt; in your Jest configuration:</source>
          <target state="translated">ウォッチプラグインをJestに接続するには、Jest設定の &lt;code&gt;watchPlugins&lt;/code&gt; の下にそのパスを追加します。</target>
        </trans-unit>
        <trans-unit id="c020af932b115a7543d8e80249a02617ab77e279" translate="yes" xml:space="preserve">
          <source>To debug in Google Chrome (or any Chromium-based browser), open your browser and go to &lt;code&gt;chrome://inspect&lt;/code&gt; and click on &quot;Open Dedicated DevTools for Node&quot;, which will give you a list of available node instances you can connect to. Click on the address displayed in the terminal (usually something like &lt;code&gt;localhost:9229&lt;/code&gt;) after running the above command, and you will be able to debug Jest using Chrome's DevTools.</source>
          <target state="translated">Google Chrome（または任意のChromiumベースのブラウザー）でデバッグするには、ブラウザーを開いて &lt;code&gt;chrome://inspect&lt;/code&gt; に移動し、[Open Dedicated DevTools for Node]をクリックすると、接続できる使用可能なノードインスタンスのリストが表示されます。上記のコマンドを実行した後、ターミナルに表示されるアドレス（通常は &lt;code&gt;localhost:9229&lt;/code&gt; のようなもの）をクリックすると、ChromeのDevToolsを使用してJestをデバッグできます。</target>
        </trans-unit>
        <trans-unit id="b40318402328b187f84e5d748dc7567c2272d612" translate="yes" xml:space="preserve">
          <source>To enable async/await in your project, install &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;&lt;/a&gt; and enable the feature in your &lt;code&gt;babel.config.js&lt;/code&gt; file.</source>
          <target state="translated">プロジェクトでasync / awaitを有効にするには、&lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt; &lt;code&gt;@babel/preset-env&lt;/code&gt; &lt;/a&gt; &lt;code&gt;babel.config.js&lt;/code&gt; -envをインストールし、babel.config.jsファイルで機能を有効にします。</target>
        </trans-unit>
        <trans-unit id="302ab4340db66b28bf4eeafaae3f85ad66b05f81" translate="yes" xml:space="preserve">
          <source>To ensure that a manual mock and its real implementation stay in sync, it might be useful to require the real module using &lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt;&lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt;&lt;/a&gt; in your manual mock and amending it with mock functions before exporting it.</source>
          <target state="translated">手動モックとその実際の実装の同期を維持するには、手動モックで&lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt; &lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt; &lt;/a&gt;を使用して実際のモジュールを要求し、それをエクスポートする前にモック関数で修正すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="d68306f89da229b2b38be29155f82cf63d2fefff" translate="yes" xml:space="preserve">
          <source>To get around problems like this, Jest provides the &lt;code&gt;jest.requireActual&lt;/code&gt; helper. To make the above test work, make the following change to the imports in the test file:</source>
          <target state="translated">このような問題を回避するために、Jestは &lt;code&gt;jest.requireActual&lt;/code&gt; ヘルパーを提供しています。上記のテストを機能させるには、テストファイルのインポートに次の変更を加えます。</target>
        </trans-unit>
        <trans-unit id="11fabe8d8570a5bb7d31d77eddfbad12fd7006ea" translate="yes" xml:space="preserve">
          <source>To handle key press events from the key returned by &lt;code&gt;getUsageInfo&lt;/code&gt;, you can implement the &lt;code&gt;run&lt;/code&gt; method. This method returns a &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; that can be resolved when the plugin wants to return control to Jest. The &lt;code&gt;boolean&lt;/code&gt; specifies if Jest should rerun the tests after it gets the control back.</source>
          <target state="translated">&lt;code&gt;getUsageInfo&lt;/code&gt; によって返されたキーからのキープレスイベントを処理するには、 &lt;code&gt;run&lt;/code&gt; メソッドを実装できます。このメソッドは、プラグインが制御をJestに戻したいときに解決できる &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; を返します。 &lt;code&gt;boolean&lt;/code&gt; それが制御背中を取得した後、冗談、テストを再実行するかどうかを指定します。</target>
        </trans-unit>
        <trans-unit id="90daa538926bb277438f39b2435beb57540f0d66" translate="yes" xml:space="preserve">
          <source>To inject nested object values use you can supply a keyPath i.e. &lt;code&gt;$variable.path.to.value&lt;/code&gt;</source>
          <target state="translated">ネストされたオブジェクト値を注入するには、keyPath、つまり &lt;code&gt;$variable.path.to.value&lt;/code&gt; 指定できます</target>
        </trans-unit>
        <trans-unit id="970630451f28f37da628f2cf8fe84113808b5a54" translate="yes" xml:space="preserve">
          <source>To make a dependency explicit instead of implicit, you can call &lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt;&lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt;&lt;/a&gt; to add a module for an individual test file instead of adding its path to &lt;code&gt;snapshotSerializers&lt;/code&gt; in Jest configuration.</source>
          <target state="translated">依存関係を暗黙的ではなく明示的にするには、Jest構成で &lt;code&gt;snapshotSerializers&lt;/code&gt; へのパスを追加する代わりに、&lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt; &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; &lt;/a&gt;を呼び出して個々のテストファイルのモジュールを追加できます。</target>
        </trans-unit>
        <trans-unit id="7cd5137812be95f283926c769870dc2156199426" translate="yes" xml:space="preserve">
          <source>To make this work with Jest you need to update your Jest configuration with this: &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt;.</source>
          <target state="translated">これをJestで動作させるには、Jest設定を次のように更新する必要があります： &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="579190d7cd820daa4fd8a13a589227f7e2eaf9e7" translate="yes" xml:space="preserve">
          <source>To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:</source>
          <target state="translated">これを解決するには、スナップショットのアーティファクトを更新する必要があります。スナップショットの再生成を指示するフラグを指定して Jest を実行することができます。</target>
        </trans-unit>
        <trans-unit id="ce42fc860995230ab9f043725c3815bd5aecd9d4" translate="yes" xml:space="preserve">
          <source>To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.</source>
          <target state="translated">この関数をテストするには、モック関数を使用し、モックの状態を検査してコールバックが期待通りに呼び出されているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="5fe8e22ac596d3e8399b1774c9a6d272aedb50d5" translate="yes" xml:space="preserve">
          <source>To transform your existing tests, navigate to the project containing the tests and run:</source>
          <target state="translated">既存のテストを変換するには、テストを含むプロジェクトに移動して実行します。</target>
        </trans-unit>
        <trans-unit id="aa8c2a8d1b80b426924e3a346cf5aa28210292b8" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, install required dependencies via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;を使用するには、 &lt;code&gt;yarn&lt;/code&gt; を介して必要な依存関係をインストールします。</target>
        </trans-unit>
        <trans-unit id="45ff297d04a3d2c50427a66fd27f8359258dbfcd" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;my-serializer-module&lt;/code&gt; as a serializer, configuration would be as follows:</source>
          <target state="translated">使用するには &lt;code&gt;my-serializer-module&lt;/code&gt; 次のようにシリアライザよう、設定は次のようになります。</target>
        </trans-unit>
        <trans-unit id="244873608d8f270057c41ef22dd861ecd2f588e8" translate="yes" xml:space="preserve">
          <source>To use snapshot testing inside of your custom matcher you can import &lt;code&gt;jest-snapshot&lt;/code&gt; and use it from within your matcher.</source>
          <target state="translated">カスタムマッチャー内でスナップショットテストを使用するには、 &lt;code&gt;jest-snapshot&lt;/code&gt; をインポートして、マッチャー内から使用できます。</target>
        </trans-unit>
        <trans-unit id="8d8bcde3184680e702bef641e43c9e47fee12e79" translate="yes" xml:space="preserve">
          <source>To write a test-runner, export a class with which accepts &lt;code&gt;globalConfig&lt;/code&gt; in the constructor, and has a &lt;code&gt;runTests&lt;/code&gt; method with the signature:</source>
          <target state="translated">テストランナーを作成するには、コンストラクターで &lt;code&gt;globalConfig&lt;/code&gt; を受け入れ、署名付きの &lt;code&gt;runTests&lt;/code&gt; メソッドを持つクラスをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="2aa91be80e98aceeddfc910352453386480fb849" translate="yes" xml:space="preserve">
          <source>Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.</source>
          <target state="translated">JavaScriptファイルの先頭にあるコメントを抽出して解析するツール。コメントブロック内のデータを操作するための様々な関数をエクスポートします。</target>
        </trans-unit>
        <trans-unit id="b2489dcd056dffceaf32fcd13112faa56f6733de" translate="yes" xml:space="preserve">
          <source>Tool for identifying modified files in a git/hg repository. Exports two functions:</source>
          <target state="translated">git/hg リポジトリ内の変更されたファイルを識別するツール。2 つの機能をエクスポートします。</target>
        </trans-unit>
        <trans-unit id="bba6cd68031555a8aa461d4b5c0878aad6420744" translate="yes" xml:space="preserve">
          <source>Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:</source>
          <target state="translated">ユーザが提出した設定を検証するためのツール。ユーザーの設定と、設定例とその他のオプションを含むオブジェクトの 2 つの引数を取る関数をエクスポートします。戻り値は、二つの属性を持つオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="49e105a4ea6033c274af2894a4fcb5d0e03e7eb5" translate="yes" xml:space="preserve">
          <source>Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a &quot;pretty-printed&quot; string illustrating the difference between the two arguments.</source>
          <target state="translated">データの変化を視覚化するためのツール。任意の型の2つの値を比較し、2つの引数の違いを示す「きれいに印刷された」文字列を返す関数をエクスポートします。</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="9a02428b2ce5edfe4a952ba3e66ede7b538c678d" translate="yes" xml:space="preserve">
          <source>Truthiness</source>
          <target state="translated">Truthiness</target>
        </trans-unit>
        <trans-unit id="6bce18334982e1e09a6fddd7fb83bd243818a5bd" translate="yes" xml:space="preserve">
          <source>Try running Jest with &lt;a href=&quot;cli#--watchman&quot;&gt;&lt;code&gt;--no-watchman&lt;/code&gt;&lt;/a&gt; or set the &lt;code&gt;watchman&lt;/code&gt; configuration option to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli#--watchman&quot;&gt; &lt;code&gt;--no-watchman&lt;/code&gt; を指定&lt;/a&gt;してJestを実行するか、 &lt;code&gt;watchman&lt;/code&gt; 設定オプションを &lt;code&gt;false&lt;/code&gt; に設定してください。</target>
        </trans-unit>
        <trans-unit id="c5c112e63b4110470aacee270c74bf17085f1c78" translate="yes" xml:space="preserve">
          <source>Try using the debugging support built into Node. Note: This will only work in Node.js 8+.</source>
          <target state="translated">Nodeに組み込まれているデバッグサポートを使ってみてください。注意:これはNode.js 8+でのみ動作します。</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="88ebf4f8084b9e64c1280cb83273c9798bb6700b" translate="yes" xml:space="preserve">
          <source>Uh oh, something went wrong? Use this guide to resolve issues with Jest.</source>
          <target state="translated">何か問題が発生したのでしょうか?このガイドを使用して、Jest の問題を解決してください。</target>
        </trans-unit>
        <trans-unit id="aed4821821385ee1bab0a8cb0c2780d5e1b4df72" translate="yes" xml:space="preserve">
          <source>Unresolved Promises</source>
          <target state="translated">未解決の約束</target>
        </trans-unit>
        <trans-unit id="bb0295c9e03b394a6c931085d1d4692dabdf5136" translate="yes" xml:space="preserve">
          <source>Updating Snapshots</source>
          <target state="translated">スナップショットの更新</target>
        </trans-unit>
        <trans-unit id="53431747077771927601efb2109e96aa6b694e10" translate="yes" xml:space="preserve">
          <source>Usage is similar to the module factory function, except that you can omit the second argument from &lt;code&gt;jest.mock()&lt;/code&gt;, and you must import the mocked method into your test file, since it is no longer defined there. Use the original module path for this; don't include &lt;code&gt;__mocks__&lt;/code&gt;.</source>
          <target state="translated">使用法はモジュールファクトリー関数に似ていますが、 &lt;code&gt;jest.mock()&lt;/code&gt; から2番目の引数を省略できる点と、モックされたメソッドがテストファイルにインポートされている必要があります。これには元のモジュールパスを使用します。 &lt;code&gt;__mocks__&lt;/code&gt; を含めないでください。</target>
        </trans-unit>
        <trans-unit id="3b944d8872fd4ee30de2cd74c68ff456d47e22c9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to refer to &lt;a href=&quot;#rootdir-string&quot;&gt;&lt;code&gt;rootDir&lt;/code&gt;&lt;/a&gt; value if you want to use file paths.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; を参照するためにトークン文字列&lt;a href=&quot;#rootdir-string&quot;&gt; &lt;code&gt;rootDir&lt;/code&gt; &lt;/a&gt;使用すると、ファイルパスを使用する場合の値です。</target>
        </trans-unit>
        <trans-unit id="271c57d8c405fa9198756ec5064bbb4c3a46ab5a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.rejects&lt;/code&gt; to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.</source>
          <target state="translated">&lt;code&gt;.rejects&lt;/code&gt; を使用して、プロミスが拒否された理由を解明し、他のマッチャーをチェーンできるようにします。約束が満たされた場合、アサーションは失敗します。</target>
        </trans-unit>
        <trans-unit id="ff4d09b1ab22e18857563408d1fce004b2fe79a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBe&lt;/code&gt; to compare primitive values or to check referential identity of object instances. It calls &lt;code&gt;Object.is&lt;/code&gt; to compare values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="translated">&lt;code&gt;.toBe&lt;/code&gt; を使用して、プリミティブ値を比較するか、オブジェクトインスタンスの参照IDを確認します。 &lt;code&gt;Object.is&lt;/code&gt; を呼び出して値を比較します。これは、 &lt;code&gt;===&lt;/code&gt; の厳密な等価演算子よりもテストに適しています。</target>
        </trans-unit>
        <trans-unit id="67ef92856838e5751e399698b48aa87c7d8163a4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeDefined&lt;/code&gt; to check that a variable is not undefined. For example, if you want to check that a function &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; returns &lt;em&gt;something&lt;/em&gt;, you can write:</source>
          <target state="translated">使用して、 &lt;code&gt;.toBeDefined&lt;/code&gt; 変数が未定義されていないことを確認します。たとえば、関数 &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; が&lt;em&gt;何かを&lt;/em&gt;返す&lt;em&gt;こと&lt;/em&gt;を確認する場合は、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="f81a87ad40dde8019daa6911a9c4296bf8a5d015" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeFalsy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="translated">値が何であるかを気にせず、ブールコンテキストで値がfalseであることを確認する場合は、 &lt;code&gt;.toBeFalsy&lt;/code&gt; を使用します。たとえば、次のようなアプリケーションコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="50aa6948737b4375185feeebf13f13dbe3451e19" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; to check that an object is an instance of a class. This matcher uses &lt;code&gt;instanceof&lt;/code&gt; underneath.</source>
          <target state="translated">使用 &lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; のオブジェクトがクラスのインスタンスであることを確認します。このマッチャーは下の &lt;code&gt;instanceof&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="93a0ac0f3d847ffa6b85c3555bc23bce0abae9d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeNaN&lt;/code&gt; when checking a value is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">値のチェックが &lt;code&gt;NaN&lt;/code&gt; の場合は、 &lt;code&gt;.toBeNaN&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="5e05d177a2e90b6b046b4b02a5621b8f26893024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeTruthy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="translated">値が何であるかを気にせず、ブールコンテキストで値がtrueであることを確認する場合は、 &lt;code&gt;.toBeTruthy&lt;/code&gt; を使用します。たとえば、次のようなアプリケーションコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="c167d5affa8fa782feb54d90f30b85615f390e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeUndefined&lt;/code&gt; to check that a variable is undefined. For example, if you want to check that a function &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt; for the &lt;code&gt;'octopus'&lt;/code&gt; flavor, because there is no good octopus-flavored drink:</source>
          <target state="translated">使用して、 &lt;code&gt;.toBeUndefined&lt;/code&gt; 変数が定義されていないことを確認します。たとえば、 &lt;code&gt;'octopus'&lt;/code&gt; 風味の良い飲み物がないため、関数 &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; が「タコ」風味に対して &lt;code&gt;undefined&lt;/code&gt; を返すことを確認したい場合：</target>
        </trans-unit>
        <trans-unit id="a934298864a7697607ca428a7e4d71c72de7efbf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContain&lt;/code&gt; when you want to check that an item is in an array. For testing the items in the array, this uses &lt;code&gt;===&lt;/code&gt;, a strict equality check. &lt;code&gt;.toContain&lt;/code&gt; can also check whether a string is a substring of another string.</source>
          <target state="translated">アイテムが配列内にあることを確認する場合は、 &lt;code&gt;.toContain&lt;/code&gt; を使用します。配列内の項目をテストするために、これは &lt;code&gt;===&lt;/code&gt; 、厳密な等価チェックを使用します。 &lt;code&gt;.toContain&lt;/code&gt; は、文字列が別の文字列の部分文字列であるかどうかも確認できます。</target>
        </trans-unit>
        <trans-unit id="bd36fedc663beba2df99e661929cac1ca55d82a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContainEqual&lt;/code&gt; when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</source>
          <target state="translated">特定の構造と値を持つ項目が配列に含まれていることを確認する場合は、 &lt;code&gt;.toContainEqual&lt;/code&gt; を使用します。配列内の項目をテストするために、このマッチャーはオブジェクトの同一性をチェックするのではなく、すべてのフィールドの等価性を再帰的にチェックします。</target>
        </trans-unit>
        <trans-unit id="2892f11bab4090104beb941f4d3d44f139cd4a21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toEqual&lt;/code&gt; to compare recursively all properties of object instances (also known as &quot;deep&quot; equality). It calls &lt;code&gt;Object.is&lt;/code&gt; to compare primitive values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="translated">&lt;code&gt;.toEqual&lt;/code&gt; を使用して、オブジェクトインスタンスのすべてのプロパティを再帰的に比較します（「ディープ」等価とも呼ばれます）。 &lt;code&gt;Object.is&lt;/code&gt; を呼び出してプリミティブ値を比較します。これは、 &lt;code&gt;===&lt;/code&gt; 厳密な等価演算子よりもテストに適しています。</target>
        </trans-unit>
        <trans-unit id="22f31877b97035b92fb10441a1a3485e65903b49" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalled&lt;/code&gt; to ensure that a mock function got called.</source>
          <target state="translated">使用は &lt;code&gt;.toHaveBeenCalled&lt;/code&gt; モック関数が呼び出されてしまったことを確実にするため。</target>
        </trans-unit>
        <trans-unit id="dfcaf02f56b10c94ecc202b3c8d9087baccb5181" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; to ensure that a mock function got called exact number of times.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; モック関数は正確な回数呼び出されてしまったことを確実にします。</target>
        </trans-unit>
        <trans-unit id="6c8d2793887755a171ad2f5be4f1a01fc5c6e2d5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; to ensure that a mock function was called with specific arguments.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; モック関数は、特定の引数で呼び出されたことを確実にします。</target>
        </trans-unit>
        <trans-unit id="4be0de20431e47e5724878c19b00a0321ac838e1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="translated">&lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; を使用して、モック関数が最後に返した特定の値をテストします。モック関数への最後の呼び出しでエラーがスローされた場合、期待される戻り値として指定した値に関係なく、このマッチャーは失敗します。</target>
        </trans-unit>
        <trans-unit id="7001ece11621c6dd7371042298806dcb68ab8bdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLength&lt;/code&gt; to check that an object has a &lt;code&gt;.length&lt;/code&gt; property and it is set to a certain numeric value.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveLength&lt;/code&gt; は、オブジェクトが持っていることを確認し &lt;code&gt;.length&lt;/code&gt; プロパティを、それが一定の数値に設定されています。</target>
        </trans-unit>
        <trans-unit id="4a20c538c65f701e8900dd32f27f93e926fbf397" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="translated">&lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; を使用して、モック関数がn番目の呼び出しに対して返した特定の値をテストします。モック関数へのn番目の呼び出しでエラーがスローされた場合、期待される戻り値として提供した値に関係なく、このマッチャーは失敗します。</target>
        </trans-unit>
        <trans-unit id="bc794bedf39c69791593b20f2971ba46bf591e64" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveProperty&lt;/code&gt; to check if property at provided reference &lt;code&gt;keyPath&lt;/code&gt; exists for an object. For checking deeply nested properties in an object you may use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;dot notation&lt;/a&gt; or an array containing the keyPath for deep references.</source>
          <target state="translated">&lt;code&gt;.toHaveProperty&lt;/code&gt; を使用して、指定された参照 &lt;code&gt;keyPath&lt;/code&gt; のプロパティがオブジェクトに存在するかどうかを確認します。オブジェクトの深くネストされたプロパティをチェックするには、&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;ドット表記&lt;/a&gt;または深い参照のkeyPathを含む配列を使用できます。</target>
        </trans-unit>
        <trans-unit id="5c5db22f649bb5e433fce75313e71f348fcdbe60" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; はモック関数が正確な回数を（すなわち、エラーをスローしませんでした）が正常に戻ったことを確認します。エラーをスローするモック関数の呼び出しは、関数が返された回数にはカウントされません。</target>
        </trans-unit>
        <trans-unit id="00cc15ef74e3e3bbb9d04e26768f906229227777" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; to ensure that a mock function returned a specific value.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; モック関数は、特定の値を返したことを確実にします。</target>
        </trans-unit>
        <trans-unit id="3403bfc7d77f929d8284a0b531fb242672320cf2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatch&lt;/code&gt; to check that a string matches a regular expression.</source>
          <target state="translated">使用 &lt;code&gt;.toMatch&lt;/code&gt; 文字列が正規表現と一致していることを確認します。</target>
        </trans-unit>
        <trans-unit id="6aa577eec7c4f8e335bb974a5ba8a04b9b825d62" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatchObject&lt;/code&gt; to check that a JavaScript object matches a subset of the properties of an object. It will match received objects with properties that are &lt;strong&gt;not&lt;/strong&gt; in the expected object.</source>
          <target state="translated">使用 &lt;code&gt;.toMatchObject&lt;/code&gt; JavaScriptオブジェクトは、オブジェクトのプロパティのサブセットと一致していることを確認します。受信したオブジェクトを、予期されたオブジェクトに&lt;strong&gt;ない&lt;/strong&gt;プロパティと照合します。</target>
        </trans-unit>
        <trans-unit id="43d74a2c2c927835dbc06a10fe0a834ecd3cf583" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toStrictEqual&lt;/code&gt; to test that objects have the same types as well as structure.</source>
          <target state="translated">&lt;code&gt;.toStrictEqual&lt;/code&gt; を使用して、オブジェクトが同じタイプと構造を持つことをテストします。</target>
        </trans-unit>
        <trans-unit id="60e9ea675b7707c4a125a8d5da6124d2b7dfa82a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrow&lt;/code&gt; to test that a function throws when it is called. For example, if we want to test that &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; throws, because octopus flavor is too disgusting to drink, we could write:</source>
          <target state="translated">関数が呼び出されたときに関数がスローすることをテストするには、 &lt;code&gt;.toThrow&lt;/code&gt; を使用します。たとえば、 &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; スローすることをテストする場合、タコのフレーバーはあまりにも嫌なため、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="b8835c8692fc22c521a477117dec692aecc544e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="translated">&lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; を使用して、関数が呼び出されたときに、最新のスナップショットと一致するエラーがスローされることをテストします。</target>
        </trans-unit>
        <trans-unit id="8656cd1667dc531479d8b4cb204dd90a1579844f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="translated">&lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; を使用して、関数が呼び出されたときに最新のスナップショットと一致するエラーをスローすることをテストします。</target>
        </trans-unit>
        <trans-unit id="0440b25bd05f6a2e3c56826df198b652d25c12c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.each&lt;/code&gt; if you keep duplicating the same test suites with different data. &lt;code&gt;describe.each&lt;/code&gt; allows you to write the test suite once and pass data in.</source>
          <target state="translated">同じテストスイートを異なるデータで複製し続ける場合は、 &lt;code&gt;describe.each&lt;/code&gt; を使用します。 &lt;code&gt;describe.each&lt;/code&gt; を使用すると、テストスイートを1回記述してデータを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="ef60fa41c287f5e40cf5103947099b8fe473bb0e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.only.each&lt;/code&gt; if you want to only run specific tests suites of data driven tests.</source>
          <target state="translated">データ駆動型テストの特定のテストスイートのみを実行する場合 &lt;code&gt;describe.only.each&lt;/code&gt; 、describe.only.eachを使用します。</target>
        </trans-unit>
        <trans-unit id="cedc27af374f9505722e2e0748157f331b8c1a04" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.skip.each&lt;/code&gt; if you want to stop running a suite of data driven tests.</source>
          <target state="translated">データドリブンテストのスイートの実行を停止 &lt;code&gt;describe.skip.each&lt;/code&gt; 場合は、describe.skip.eachを使用します。</target>
        </trans-unit>
        <trans-unit id="d406a9d711b46330782be9bc2cb621080a4ae6f6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;react-test-renderer&lt;/code&gt;. The test renderer doesn't care about element types and will happily accept e.g. &lt;code&gt;SomeComponent&lt;/code&gt;. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.</source>
          <target state="translated">&lt;code&gt;react-test-renderer&lt;/code&gt; を使用してください。テストレンダラーは要素の種類を &lt;code&gt;SomeComponent&lt;/code&gt; ず、たとえばSomeComponentなどを喜んで受け入れます。テストレンダラーを使用してスナップショットを確認し、Enzymeを使用してコンポーネントの動作を個別に確認できます。</target>
        </trans-unit>
        <trans-unit id="7e3d957c7581b38a6f6d9efe05f990ae9f8f779c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.</source>
          <target state="translated">&lt;code&gt;resolves&lt;/code&gt; を使用して、満たされたpromiseの値を展開し、他のマッチャーをチェーンできるようにします。約束が拒否された場合、アサーションは失敗します。</target>
        </trans-unit>
        <trans-unit id="3afb7e6906f2b3257d85cde9c36efa5c6e5bcbfc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.each&lt;/code&gt; if you keep duplicating the same test with different data. &lt;code&gt;test.each&lt;/code&gt; allows you to write the test once and pass data in.</source>
          <target state="translated">同じテストを異なるデータで複製し続ける場合は、 &lt;code&gt;test.each&lt;/code&gt; を使用します。 &lt;code&gt;test.each&lt;/code&gt; を使用すると、テストを1回記述してデータを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="5ed7e082f3c3b04fc36bc3b9da1fb4c701925c6d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.only.each&lt;/code&gt; if you want to only run specific tests with different test data.</source>
          <target state="translated">異なるテストデータで特定のテストのみを実行する場合は、 &lt;code&gt;test.only.each&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="9a662231e654755bb86491a61d19bfda30bf8dea" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.skip.each&lt;/code&gt; if you want to stop running a collection of data driven tests.</source>
          <target state="translated">データドリブンテストのコレクションの実行を停止する場合は、 &lt;code&gt;test.skip.each&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="04f44ceaa0fcfd12976de28307ac74bab48f40fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.todo&lt;/code&gt; when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.</source>
          <target state="translated">テストの作成を計画している場合は、 &lt;code&gt;test.todo&lt;/code&gt; を使用します。これらのテストは最後に要約出力で強調表示されるため、実行する必要があるテストの数がわかります。</target>
        </trans-unit>
        <trans-unit id="759c0eb81e3b691ac63ce62826c9faeffd303147" translate="yes" xml:space="preserve">
          <source>Use jest-dynamodb Preset</source>
          <target state="translated">is-dynamodbプリセットを使用します。</target>
        </trans-unit>
        <trans-unit id="7194dde7b6fdc7725f8efc98a8775cd0fe57fa0a" translate="yes" xml:space="preserve">
          <source>Use jest-mongodb Preset</source>
          <target state="translated">is-mongodbのプリセットを使用します。</target>
        </trans-unit>
        <trans-unit id="d6629ac509cad69b4360ba597e78efb90888b162" translate="yes" xml:space="preserve">
          <source>Use jest-puppeteer Preset</source>
          <target state="translated">jest-puppeteer プリセットを使用します。</target>
        </trans-unit>
        <trans-unit id="8859f21b394eb7bddbe02c98d39f3c5d61b96c00" translate="yes" xml:space="preserve">
          <source>Use this configuration option to add custom reporters to Jest. A custom reporter is a class that implements &lt;code&gt;onRunStart&lt;/code&gt;, &lt;code&gt;onTestStart&lt;/code&gt;, &lt;code&gt;onTestResult&lt;/code&gt;, &lt;code&gt;onRunComplete&lt;/code&gt; methods that will be called when any of those events occurs.</source>
          <target state="translated">この構成オプションを使用して、カスタムレポーターをJestに追加します。カスタムレポーターは、これらのイベントのいずれかが発生したときに呼び出される &lt;code&gt;onRunStart&lt;/code&gt; 、 &lt;code&gt;onTestStart&lt;/code&gt; 、 &lt;code&gt;onTestResult&lt;/code&gt; 、 &lt;code&gt;onRunComplete&lt;/code&gt; メソッドを実装するクラスです。</target>
        </trans-unit>
        <trans-unit id="0ce722d28dd2ac22869f544554814473ced27729" translate="yes" xml:space="preserve">
          <source>Useful to create async mock functions that will always reject:</source>
          <target state="translated">常にリジェクトする非同期モック関数を作成するのに便利です。</target>
        </trans-unit>
        <trans-unit id="82fe22471a3c89a8a884379e2a589a9b9393684f" translate="yes" xml:space="preserve">
          <source>Useful to mock async functions in async tests:</source>
          <target state="translated">非同期テストで非同期関数をモックするのに便利です。</target>
        </trans-unit>
        <trans-unit id="4d6f5093469250351be715bab11328d708148671" translate="yes" xml:space="preserve">
          <source>Useful to resolve different values over multiple async calls:</source>
          <target state="translated">複数の非同期呼び出しで異なる値を解決するのに便利です。</target>
        </trans-unit>
        <trans-unit id="8386651610226fd04ae64f938ef5bbd0efe279f3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;describe.skip&lt;/code&gt; is often a cleaner alternative to temporarily commenting out a chunk of tests.</source>
          <target state="translated">多くの場合、 &lt;code&gt;describe.skip&lt;/code&gt; の使用は、テストのチャンクを一時的にコメント化するよりもわかりやすい方法です。</target>
        </trans-unit>
        <trans-unit id="8da013e9c1193b5fd4e55adc4f5c72966bc2f345" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;jest.doMock()&lt;/code&gt; with ES6 imports requires additional steps. Follow these if you don't want to use &lt;code&gt;require&lt;/code&gt; in your tests:</source>
          <target state="translated">ES6インポートで &lt;code&gt;jest.doMock()&lt;/code&gt; を使用するには、追加の手順が必要です。テストで &lt;code&gt;require&lt;/code&gt; を使用したくない場合は、以下に従ってください：</target>
        </trans-unit>
        <trans-unit id="5b7ceb252455569b8991c8fe4bfba034672b82cf" translate="yes" xml:space="preserve">
          <source>Using Babel</source>
          <target state="translated">バベルを使う</target>
        </trans-unit>
        <trans-unit id="ad353105ab08c29227ad5d0775b29687a1b718c7" translate="yes" xml:space="preserve">
          <source>Using Matchers</source>
          <target state="translated">マッチャの使用</target>
        </trans-unit>
        <trans-unit id="8c578fdee5f39cae171b3ae3dc5e52be3eb3db63" translate="yes" xml:space="preserve">
          <source>Using TypeScript</source>
          <target state="translated">TypeScriptの使用</target>
        </trans-unit>
        <trans-unit id="e2b797adce82409b798a1e85b5f20128645a30c7" translate="yes" xml:space="preserve">
          <source>Using a mock function</source>
          <target state="translated">モック関数の使用</target>
        </trans-unit>
        <trans-unit id="fdad49cc59429141e7cc6464244c820172f9da4a" translate="yes" xml:space="preserve">
          <source>Using exact equality with floating point numbers is a bad idea. Rounding means that intuitive things fail. For example, this test fails:</source>
          <target state="translated">浮動小数点数で厳密な等式を使うのはよくありません。丸めは直感的に失敗することを意味します。例えば、このテストは失敗します。</target>
        </trans-unit>
        <trans-unit id="d56e8185a2d6c77ca4726dcd2b55295a60bd2572" translate="yes" xml:space="preserve">
          <source>Using webpack</source>
          <target state="translated">webpackを使用する</target>
        </trans-unit>
        <trans-unit id="a5bf7b56e0fe9da5b66e110d7867887929aa794f" translate="yes" xml:space="preserve">
          <source>Using with DynamoDB</source>
          <target state="translated">DynamoDBとの併用</target>
        </trans-unit>
        <trans-unit id="ad43d620306250954a4a631c111cb745bc0804de" translate="yes" xml:space="preserve">
          <source>Using with ES module imports</source>
          <target state="translated">ESモジュールのインポートとの併用</target>
        </trans-unit>
        <trans-unit id="44be8a58330b5c23182d2274fdfd6efbdf4e83a9" translate="yes" xml:space="preserve">
          <source>Using with MongoDB</source>
          <target state="translated">MongoDBでの使用</target>
        </trans-unit>
        <trans-unit id="785e92a5d24055ece246e1162c6d740443f3f058" translate="yes" xml:space="preserve">
          <source>Using with npm scripts</source>
          <target state="translated">npmスクリプトでの使用</target>
        </trans-unit>
        <trans-unit id="094d8ae70af4304a0d4b4a837d18e1de8f8424c0" translate="yes" xml:space="preserve">
          <source>Using with puppeteer</source>
          <target state="translated">人形使いとの併用</target>
        </trans-unit>
        <trans-unit id="62915756095c500af390187568578de70abf9244" translate="yes" xml:space="preserve">
          <source>Using with webpack</source>
          <target state="translated">webpackでの利用</target>
        </trans-unit>
        <trans-unit id="2f6a259c826a5d9735d5a64063f1b31e207c2685" translate="yes" xml:space="preserve">
          <source>Using with webpack 2</source>
          <target state="translated">webpack 2での使用</target>
        </trans-unit>
        <trans-unit id="e92e8a4901b69fac997e23f82569d015987ccae6" translate="yes" xml:space="preserve">
          <source>Using with yarn</source>
          <target state="translated">糸との併用</target>
        </trans-unit>
        <trans-unit id="41c1155f49d57702ee239db81113c543bd9591e4" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't check code using &lt;code&gt;test.only&lt;/code&gt; into source control - you would use it for debugging, and remove it once you have fixed the broken tests.</source>
          <target state="translated">通常、ソース管理に &lt;code&gt;test.only&lt;/code&gt; を使用してコードをチェックすることはありません。デバッグに使用し、壊れたテストを修正したら削除します。</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="4af321d3223afd7ac8763fbd38707f1b871aa01e" translate="yes" xml:space="preserve">
          <source>Warning: If we want to mock Node's core modules (e.g.: &lt;code&gt;fs&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt;), then explicitly calling e.g. &lt;code&gt;jest.mock('path')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;, because core Node modules are not mocked by default.</source>
          <target state="translated">警告：我々はノードのコアモジュール（例：モックとしたい場合は &lt;code&gt;fs&lt;/code&gt; または &lt;code&gt;path&lt;/code&gt; ）、その後、明示的に呼び出すなど &lt;code&gt;jest.mock('path')&lt;/code&gt; されて&lt;strong&gt;必要な&lt;/strong&gt;コアノードモジュールは、デフォルトでは嘲笑されていないので、。</target>
        </trans-unit>
        <trans-unit id="d0993b420d1ece1c116d94df1eb882929103aacb" translate="yes" xml:space="preserve">
          <source>Watch Menu Integration</source>
          <target state="translated">ウォッチメニューの統合</target>
        </trans-unit>
        <trans-unit id="77162c2c5b3f4537b5a429cc13193176c9944f13" translate="yes" xml:space="preserve">
          <source>Watch Plugin Interface</source>
          <target state="translated">ウォッチプラグインインターフェイス</target>
        </trans-unit>
        <trans-unit id="730cb1589addfecd42b5dc91914d54090940dd7b" translate="yes" xml:space="preserve">
          <source>Watch Plugins</source>
          <target state="translated">プラグインを見る</target>
        </trans-unit>
        <trans-unit id="1b41755710b08ba989fe2719763a7cc16cd093cd" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the &lt;code&gt;--watch&lt;/code&gt; option.</source>
          <target state="translated">ファイルの変更を監視し、何か変更があった場合はすべてのテストを再実行します。変更されたファイルに依存するテストのみを再実行する場合は、 &lt;code&gt;--watch&lt;/code&gt; オプションを使用します。</target>
        </trans-unit>
        <trans-unit id="0f500e5f9a091c5d91b9402809c2e1bfb82401f3" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the &lt;code&gt;--watchAll&lt;/code&gt; option instead.</source>
          <target state="translated">ファイルの変更を監視し、変更されたファイルに関連するテストを再実行します。ファイルが変更されたときにすべてのテストを再実行する場合は、代わりに &lt;code&gt;--watchAll&lt;/code&gt; オプションを使用します。</target>
        </trans-unit>
        <trans-unit id="6a33b701f8666961875a562f2fa71a7405de7c06" translate="yes" xml:space="preserve">
          <source>Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.</source>
          <target state="translated">ウォッチモードでは、特定のテストセットに焦点を当てるために、ファイル名やパスを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="aff9902a15b762dc90c7266ccddd98d2b3f64e24" translate="yes" xml:space="preserve">
          <source>Watch plugin YourFaultyPlugin attempted to register key &lt;q&gt;, that is reserved internally for quitting watch mode. Please change the configuration key for this plugin.&lt;/q&gt;</source>
          <target state="translated">ウォッチプラグインYourFaultyPluginが&lt;q&gt;、ウォッチモードを終了するために内部的に予約&lt;/q&gt;されているkeyを登録しようとしました&lt;q&gt;。このプラグインの構成キーを変更してください。&lt;/q&gt;</target>
        </trans-unit>
        <trans-unit id="a673577265e6ead99e3c23f76e5f29409c5b7d10" translate="yes" xml:space="preserve">
          <source>Watch plugins YourFaultyPlugin and TheirFaultyPlugin both attempted to register key</source>
          <target state="translated">Watch plugins YourFaultyPlugin と TheirFaultyPlugin の両方でキーの登録を試みました。</target>
        </trans-unit>
        <trans-unit id="1a8e0b7b820fac76887499e0730014073b6942fc" translate="yes" xml:space="preserve">
          <source>Watchman Issues</source>
          <target state="translated">ウォッチマンの問題</target>
        </trans-unit>
        <trans-unit id="58ed43a0f07990c616800d6e405003e52deb7101" translate="yes" xml:space="preserve">
          <source>We are mocking &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; so that our test doesn't make a real network request but instead resolves to mock data locally. This ensures that our test can complete in milliseconds rather than seconds and guarantees a fast unit test iteration speed.</source>
          <target state="translated">私たちは、モックされ &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; を我々のテストは、実際のネットワーク要求をしないようにではなく、ローカルにモックデータに解決されます。これにより、テストが秒単位ではなくミリ秒単位で完了することが保証され、高速な単体テストの反復速度が保証されます。</target>
        </trans-unit>
        <trans-unit id="39fcaf5408d64ca526faacb5d58f9141c191b735" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;jest.mock('../request')&lt;/code&gt; to tell Jest to use our manual mock. &lt;code&gt;it&lt;/code&gt; expects the return value to be a Promise that is going to be resolved. You can chain as many Promises as you like and call &lt;code&gt;expect&lt;/code&gt; at any time, as long as you return a Promise at the end.</source>
          <target state="translated">&lt;code&gt;jest.mock('../request')&lt;/code&gt; を呼び出して、手動モックを使用するようJestに指示します。戻り値は解決されるPromiseである &lt;code&gt;it&lt;/code&gt; 想定しています。最後にPromiseを返す限り、いつでもいくつでもPromiseをチェーンして、 &lt;code&gt;expect&lt;/code&gt; edを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="69b678bb69e79c49e5b0a08e85e9a17993259892" translate="yes" xml:space="preserve">
          <source>We could test this error gets thrown in several ways:</source>
          <target state="translated">このエラーがいくつかの方法でスローされることをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="0bd52959384de0efc9e324b40ef0a059ef8e64cd" translate="yes" xml:space="preserve">
          <source>We have to specify the &lt;code&gt;__esModule: true&lt;/code&gt; property (see the &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; API for more information).</source>
          <target state="translated">&lt;code&gt;__esModule: true&lt;/code&gt; プロパティを指定する必要があります（詳細については、&lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt; APIを参照してください）。</target>
        </trans-unit>
        <trans-unit id="58e30d514b365fc2673e994c86e9d1067f92cb36" translate="yes" xml:space="preserve">
          <source>We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving &quot;ts&quot; and/or &quot;tsx&quot; to the beginning of the array.</source>
          <target state="translated">プロジェクトで最もよく使われる拡張子を左に配置することをお勧めします。TypeScriptを使用している場合は、&quot;ts &quot;や &quot;tsx &quot;を配列の先頭に移動させることを検討してください。</target>
        </trans-unit>
        <trans-unit id="49cfe85b5d9f91e87c2bb6c4919d6422b42d36a2" translate="yes" xml:space="preserve">
          <source>We'll use a contrived example of a class that plays sound files, &lt;code&gt;SoundPlayer&lt;/code&gt;, and a consumer class which uses that class, &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;. We'll mock &lt;code&gt;SoundPlayer&lt;/code&gt; in our tests for &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;.</source>
          <target state="translated">サウンドファイルを再生するクラスの考案された例 &lt;code&gt;SoundPlayer&lt;/code&gt; と、そのクラスを使用するコンシューマークラス &lt;code&gt;SoundPlayerConsumer&lt;/code&gt; を使用します。 &lt;code&gt;SoundPlayer&lt;/code&gt; Consumerのテストでは、 &lt;code&gt;SoundPlayerConsumer&lt;/code&gt; モックします。</target>
        </trans-unit>
        <trans-unit id="7a570bfe57d90629aa64647c14bb9b9299f88f21" translate="yes" xml:space="preserve">
          <source>We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.</source>
          <target state="translated">スタイルシートや画像の拡張子にマッチするファイルを無視し、代わりにモックファイルを要求するように Jest に指示しました。正規表現を調整して、webpack の設定が扱うファイルタイプに合わせてください。</target>
        </trans-unit>
        <trans-unit id="6e27e07bef6adeae0276f0cd001319eb48d71a2c" translate="yes" xml:space="preserve">
          <source>What is the performance of snapshot testing regarding speed and size of the generated files?</source>
          <target state="translated">生成されたファイルの速度とサイズに関して、スナップショットテストのパフォーマンスはどうですか?</target>
        </trans-unit>
        <trans-unit id="3bc8902ad3e552d6e229d9ad2fb118f5b3735490" translate="yes" xml:space="preserve">
          <source>What's the difference between snapshot testing and visual regression testing?</source>
          <target state="translated">スナップショットテストとビジュアルリグレッションテストの違いは?</target>
        </trans-unit>
        <trans-unit id="18c42c157f8a61af5c55926418fd204e7a9c5be1" translate="yes" xml:space="preserve">
          <source>When Jest runs your test to collect the &lt;code&gt;test&lt;/code&gt;s it will not find any because we have set the definition to happen asynchronously on the next tick of the event loop.</source>
          <target state="translated">Jestがテストを実行してテストを収集するとき、イベントループの次のティックで非同期に発生するように定義を設定しているため、 &lt;code&gt;test&lt;/code&gt; は見つかりません。</target>
        </trans-unit>
        <trans-unit id="66a712f9c4762f8fb45d196c8b569be5ba0595bc" translate="yes" xml:space="preserve">
          <source>When a conflict happens</source>
          <target state="translated">紛争が発生した場合</target>
        </trans-unit>
        <trans-unit id="6ddcfa27c2af8b12d25959aeb81f42c8a1e31340" translate="yes" xml:space="preserve">
          <source>When a manual mock exists for a given module, Jest's module system will use that module when explicitly calling &lt;code&gt;jest.mock('moduleName')&lt;/code&gt;. However, when &lt;code&gt;automock&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the manual mock implementation will be used instead of the automatically created mock, even if &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; is not called. To opt out of this behavior you will need to explicitly call &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; in tests that should use the actual module implementation.</source>
          <target state="translated">特定のモジュールに手動モックが存在する場合、Jestのモジュールシステムは、明示的に &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; を呼び出すときにそのモジュールを使用します。ただし、 &lt;code&gt;automock&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合、 &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; が呼び出されなくても、自動作成されたモックの代わりに手動モック実装が使用されます。この動作をオプトアウトするには、実際のモジュール実装を使用する必要があるテストで &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; を明示的に呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="f71f327fabbf5c0637780926759d884ef99d4c6f" translate="yes" xml:space="preserve">
          <source>When an assertion fails, the error message should give as much signal as necessary to the user so they can resolve their issue quickly. You should craft a precise failure message to make sure users of your custom assertions have a good developer experience.</source>
          <target state="translated">アサーションが失敗した場合、エラー・メッセージは、ユーザが問題を迅速に解決できるように、必要なだけのシグナルをユーザに伝えなければなりません。カスタム・アサーションのユーザが良い開発者体験を得られるように、正確な失敗メッセージを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="9d8bace675f1044daa5589643fe0fa171a34a422" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;projects&lt;/code&gt; configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.</source>
          <target state="translated">場合 &lt;code&gt;projects&lt;/code&gt; 構成がパスまたはグロブパターンのアレイを備えている、冗談を同時に指定プロジェクトのすべてでテストを実行します。これは、モノリポジトリや複数のプロジェクトで同時に作業する場合に最適です。</target>
        </trans-unit>
        <trans-unit id="000d78fbd56ae8d851f29ec24ab5707f75357361" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with &lt;code&gt;mockImplementationOnce&lt;/code&gt;, it will execute the default implementation set with &lt;code&gt;jest.fn&lt;/code&gt; (if it is defined):</source>
          <target state="translated">モックされた関数が &lt;code&gt;mockImplementationOnce&lt;/code&gt; で定義された実装を使い果たすと、デフォルトの実装セットが &lt;code&gt;jest.fn&lt;/code&gt; で実行されます（定義されている場合）。</target>
        </trans-unit>
        <trans-unit id="af9f009231011568611cfa6e9ad01b0075f8a8f9" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; or &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; if they were called:</source>
          <target state="translated">モックされた関数がmockImplementationOnceで定義された実装を使い果たすと、呼び出された場合、 &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; または &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; デフォルトの実装セットが実行されます。</target>
        </trans-unit>
        <trans-unit id="efd67d9a5d58ddfafd6576c76e2d2b45c6a9f072" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending macro-tasks and micro-tasks will be executed. If those tasks themselves schedule new tasks, those will be continually exhausted until there are no more tasks remaining in the queue.</source>
          <target state="translated">このAPIが呼び出されると、保留中のマクロタスクとマイクロタスクがすべて実行されます。これらのタスク自身が新しいタスクをスケジューリングしている場合、キューに残っているタスクがなくなるまで継続して排出されます。</target>
        </trans-unit>
        <trans-unit id="a158c79d89cb2f08512d4bfd3dd789cc435d27dc" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending micro-tasks that have been queued via &lt;code&gt;process.nextTick&lt;/code&gt; will be executed. Additionally, if those micro-tasks themselves schedule new micro-tasks, those will be continually exhausted until there are no more micro-tasks remaining in the queue.</source>
          <target state="translated">このAPIが呼び出されると、 &lt;code&gt;process.nextTick&lt;/code&gt; を介してキューに入れられた保留中のすべてのマイクロタスクが実行されます。さらに、それらのマイクロタスク自体が新しいマイクロタスクをスケジュールすると、キューに残っているマイクロタスクがなくなるまで、それらは継続的に使い果たされます。</target>
        </trans-unit>
        <trans-unit id="de6b8c35376469c436481e4abc3ac0840d106da8" translate="yes" xml:space="preserve">
          <source>When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt;, and would be executed within this time frame will be executed. Additionally if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within &lt;code&gt;msToRun&lt;/code&gt; milliseconds.</source>
          <target state="translated">このAPIが呼び出されると、すべてのタイマーが &lt;code&gt;msToRun&lt;/code&gt; ミリ秒進みます。 &lt;code&gt;setTimeout()&lt;/code&gt; または &lt;code&gt;setInterval()&lt;/code&gt; を介してキューに入れられ、この時間枠内に実行されるすべての保留中の「マクロタスク」が実行されます。さらに、それらのマクロタスクが同じ時間枠内で実行される新しいマクロタスクをスケジュールする場合、それらは、 &lt;code&gt;msToRun&lt;/code&gt; ミリ秒以内に実行される必要があるキューに残っているマクロタスクがなくなるまで実行されます。</target>
        </trans-unit>
        <trans-unit id="e9dca7721cf62aeb16db42f482a108cce06f06d2" translate="yes" xml:space="preserve">
          <source>When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with &lt;code&gt;--updateSnapshot&lt;/code&gt;.</source>
          <target state="translated">このオプションを指定すると、JestはCI環境で実行されていると想定します。これにより、新しいスナップショットが検出されたときの動作が変わります。新しいスナップショットを自動的に保存する通常の動作の代わりに、テストに失敗し、Jestを &lt;code&gt;--updateSnapshot&lt;/code&gt; で実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea2ae246f66a28582d68b56f98e9832a105b042f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;mock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="translated">&lt;code&gt;babel-jest&lt;/code&gt; を使用する場合、 &lt;code&gt;mock&lt;/code&gt; の呼び出しは自動的にコードブロックの最上部に表示されます。この動作を明示的に回避する場合は、このメソッドを使用してください。</target>
        </trans-unit>
        <trans-unit id="18b0443351a14618ca1bcb5f6aa3542dc98f4cfe" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;unmock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="translated">&lt;code&gt;babel-jest&lt;/code&gt; を使用する場合、 &lt;code&gt;unmock&lt;/code&gt; の呼び出しは自動的にコードブロックの最上部に移動します。この動作を明示的に回避する場合は、このメソッドを使用してください。</target>
        </trans-unit>
        <trans-unit id="f978d44fe3f641d915d3d23a0599b90ede804e61" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--config&lt;/code&gt; option, the JSON file must not contain a &quot;jest&quot; key:</source>
          <target state="translated">&lt;code&gt;--config&lt;/code&gt; オプションを使用する場合、JSONファイルに「jest」キーを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="04fedd264e30315e94d0bfc357d0d1a8b0ecd6f0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;factory&lt;/code&gt; parameter for an ES6 module with a default export, the &lt;code&gt;__esModule: true&lt;/code&gt; property needs to be specified. This property is normally generated by Babel / TypeScript, but here it needs to be set manually. When importing a default export, it's an instruction to import the property named &lt;code&gt;default&lt;/code&gt; from the export object:</source>
          <target state="translated">デフォルトのエクスポートでES6モジュールの &lt;code&gt;factory&lt;/code&gt; パラメーターを使用する場合、 &lt;code&gt;__esModule: true&lt;/code&gt; プロパティを指定する必要があります。このプロパティは通常Babel / TypeScriptによって生成されますが、ここでは手動で設定する必要があります。デフォルトのエクスポートをインポートする場合、それはエクスポートオブジェクトから &lt;code&gt;default&lt;/code&gt; という名前のプロパティをインポートするための指示です。</target>
        </trans-unit>
        <trans-unit id="2d001438addabfdc9a62c0bd086018e034d25a28" translate="yes" xml:space="preserve">
          <source>When we require that module in our tests, explicitly calling &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;.</source>
          <target state="translated">テストでそのモジュールが必要な場合、明示的に &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; を呼び出す&lt;strong&gt;必要&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="703ab40aa1656fee5bd7fb985cc5ca7e7af24578" translate="yes" xml:space="preserve">
          <source>When you are debugging a large test file, you will often only want to run a subset of tests. You can use &lt;code&gt;.only&lt;/code&gt; to specify which tests are the only ones you want to run in that test file.</source>
          <target state="translated">大きなテストファイルをデバッグする場合、多くの場合、テストのサブセットのみを実行する必要があります。 &lt;code&gt;.only&lt;/code&gt; を使用して、そのテストファイルで実行するテストを1つだけ指定できます。</target>
        </trans-unit>
        <trans-unit id="7d76e8040b92fed0c690e41513159f4832164a34" translate="yes" xml:space="preserve">
          <source>When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use &lt;code&gt;test.skip&lt;/code&gt; to specify some tests to skip.</source>
          <target state="translated">大きなコードベースを維持している場合、何らかの理由で一時的に壊れているテストが見つかることがあります。このテストの実行をスキップしたいが、このコードを削除したくない場合は、 &lt;code&gt;test.skip&lt;/code&gt; を使用して、スキップするテストを指定できます。</target>
        </trans-unit>
        <trans-unit id="8d417a3cdc1c802c0f3ae5fcb03331fd9db749a0" translate="yes" xml:space="preserve">
          <source>When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method:</source>
          <target state="translated">複数の関数呼び出しが異なる結果を生成するようにモック関数の複雑な動作を再作成する必要がある場合は、 &lt;code&gt;mockImplementationOnce&lt;/code&gt; メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="0933ea7e8d1f77a530a24c9128f18fb45e5eb8fc" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;jest&lt;/code&gt; with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt;. On Windows, you will need to use &lt;code&gt;/&lt;/code&gt; as a path separator or escape &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">引数を指定して &lt;code&gt;jest&lt;/code&gt; を実行すると、その引数はプロジェクト内のファイルと照合するための正規表現として扱われます。パターンを提供することにより、テストスイートを実行することが可能です。パターンが一致するファイルのみが取得され、実行されます。端末によっては、この引数を引用する必要がある場合があります： &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt; 。Windowsでは、パス区切り文字として &lt;code&gt;/&lt;/code&gt; を使用するか、 &lt;code&gt;\&lt;/code&gt; を &lt;code&gt;\\&lt;/code&gt; としてエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="68715485bd1666aefca572f144099e2aa37bff4b" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;yarn test&lt;/code&gt; or &lt;code&gt;jest&lt;/code&gt;, this will produce an output file like this:</source>
          <target state="translated">&lt;code&gt;yarn test&lt;/code&gt; または &lt;code&gt;jest&lt;/code&gt; を実行すると、次のような出力ファイルが生成されます。</target>
        </trans-unit>
        <trans-unit id="a48c34ee84029428f3840a2f252c786c6d129c3b" translate="yes" xml:space="preserve">
          <source>When you're writing tests, you often need to check that values meet certain conditions. &lt;code&gt;expect&lt;/code&gt; gives you access to a number of &quot;matchers&quot; that let you validate different things.</source>
          <target state="translated">テストを作成するとき、多くの場合、値が特定の条件を満たすことを確認する必要があります。 &lt;code&gt;expect&lt;/code&gt; を使用すると、さまざまなものを検証できるいくつかの「マッチャー」にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="35131e0d0e9059a4bd01bbcebb7af6e82ca76302" translate="yes" xml:space="preserve">
          <source>Whether to use the cache. Defaults to true. Disable the cache using &lt;code&gt;--no-cache&lt;/code&gt;. &lt;em&gt;Note: the cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.&lt;/em&gt;</source>
          <target state="translated">キャッシュを使用するかどうか。デフォルトはtrueです。 &lt;code&gt;--no-cache&lt;/code&gt; cacheを使用してキャッシュを無効にします。&lt;em&gt;注：キャッシュは、キャッシュ関連の問題が発生している場合にのみ無効にする必要があります。平均して、キャッシュを無効にすると、Jestが少なくとも2倍遅くなります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83164f909bcd8fc7ba78df4e824b24177b294067" translate="yes" xml:space="preserve">
          <source>Whether to use watchman for file crawling. Defaults to true. Disable using &lt;code&gt;--no-watchman&lt;/code&gt;.</source>
          <target state="translated">ファイルクロールにウォッチマンを使用するかどうか。デフォルトはtrueです。 &lt;code&gt;--no-watchman&lt;/code&gt; の使用を無効にします。</target>
        </trans-unit>
        <trans-unit id="a1d2275b123b75427db7b2987318a2d50b013b7a" translate="yes" xml:space="preserve">
          <source>While Jest is most of the time extremely fast on modern multi-core computers with fast SSDs, it may be slow on certain setups as our users &lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;have&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;discovered&lt;/a&gt;.</source>
          <target state="translated">Jestはほとんどの場合、高速SSDを備えた最新のマルチコアコンピューターでは非常に高速です&lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;が&lt;/a&gt;、ユーザーが&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;発見した&lt;/a&gt;ように、特定のセットアップでは低速になる場合があります。</target>
        </trans-unit>
        <trans-unit id="5c1e359c575a75195c82ced579ca21229a1a43b9" translate="yes" xml:space="preserve">
          <source>While we generally recommend using the same version of every Jest package, this workaround will allow you to continue using the latest version of Jest with Babel 6 for now.</source>
          <target state="translated">一般的には、すべての Jest パッケージの同じバージョンを使用することを推奨していますが、この回避策により、今のところ Babel 6 で最新バージョンの Jest を使用し続けることができます。</target>
        </trans-unit>
        <trans-unit id="0ab9c7998614f26e4eb6805b1167e05ce5311b6e" translate="yes" xml:space="preserve">
          <source>Will result in this error:</source>
          <target state="translated">このエラーになります。</target>
        </trans-unit>
        <trans-unit id="5924ea10aaabb62ee9bc1364ab2d6c8d39fa4316" translate="yes" xml:space="preserve">
          <source>With all the things set up, we can now write our tests like this:</source>
          <target state="translated">すべての設定が完了したので、次はこのようにテストを書くことができます。</target>
        </trans-unit>
        <trans-unit id="f75c7b6834fbac10e18f4c82ab03776229eb74e2" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;configuration#globalsetup-string&quot;&gt;グローバルセットアップ/ティアダウン&lt;/a&gt;と&lt;a href=&quot;configuration#testenvironment-string&quot;&gt;非同期テスト環境&lt;/a&gt;のAPIは、冗談ではとスムーズに動作することができます&lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDBの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09d67fc0b64d61790fbe51d618d9c01a71c9767f" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;configuration#globalsetup-string&quot;&gt;グローバルセットアップ/ティアダウン&lt;/a&gt;と&lt;a href=&quot;configuration#testenvironment-string&quot;&gt;非同期テスト環境&lt;/a&gt;のAPIは、冗談ではとスムーズに動作することができます&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;人形遣い&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efe0a1fdb2d38cad4bc73937febc9018ab5dfa08" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;configuration#globalsetup-string&quot;&gt;グローバルセットアップ/ティアダウン&lt;/a&gt;と&lt;a href=&quot;configuration#testenvironment-string&quot;&gt;非同期テスト環境&lt;/a&gt;のAPIは、冗談ではとスムーズに作業できる&lt;a href=&quot;https://www.mongodb.com/&quot;&gt;のMongoDB&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7a7d359c8bb23694d685fdf6e2b5cde46a49ff3" translate="yes" xml:space="preserve">
          <source>Write test results to a file when the &lt;code&gt;--json&lt;/code&gt; option is also specified. The returned JSON structure is documented in &lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;testResultsProcessor&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--json&lt;/code&gt; オプションも指定されている場合、テスト結果をファイルに書き込みます。返されるJSON構造は&lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;testResultsProcessorに&lt;/a&gt;文書化されています。</target>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="translated">テストを書く</target>
        </trans-unit>
        <trans-unit id="694bf05e5891dd2e709b08f7b1d50372246946ee" translate="yes" xml:space="preserve">
          <source>Write your test</source>
          <target state="translated">テストを書く</target>
        </trans-unit>
        <trans-unit id="94ba98a24cca1fad5979f2e2b8b87aa24d441f8b" translate="yes" xml:space="preserve">
          <source>Writing tests using the &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; syntax is also possible. Here is how you'd write the same examples from before:</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 構文を使用してテストを作成することもできます。これは、以前と同じ例をどのように書くかです。</target>
        </trans-unit>
        <trans-unit id="13442293f45d32c9c4218756254e61b25c456f59" translate="yes" xml:space="preserve">
          <source>Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.</source>
          <target state="translated">はい、すべてのスナップショットファイルは、それらがカバーしているモジュールとそのテストと一緒にコミットされるべきです。これらは、Jest の他のアサーションの値と同様に、テストの一部と考えるべきです。実際には、スナップショットは任意の時点でのソースモジュールの状態を表しています。このようにして、ソースモジュールが変更されたときに、Jest は前のバージョンから何が変わったのかを知ることができます。また、コードレビューの際に多くの追加コンテキストを提供することができ、レビュアーはあなたの変更をよりよく研究することができます。</target>
        </trans-unit>
        <trans-unit id="5059d1df734052fa39f05d1a230ebef9c450fdf6" translate="yes" xml:space="preserve">
          <source>Yes, as well as with any other test.</source>
          <target state="translated">はい、他のテストと同様に。</target>
        </trans-unit>
        <trans-unit id="933a2cbd693a2fc8e1c7cc9d0a79a6433195d072" translate="yes" xml:space="preserve">
          <source>You avoid limits to configuration that might cause you to eject from &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;から排出される可能性がある構成の制限を回避します。</target>
        </trans-unit>
        <trans-unit id="406cbbf63f4fe22d5b8ccaa5240411c1502ac6c2" translate="yes" xml:space="preserve">
          <source>You can also hook up puppeteer from scratch. The basic idea is to:</source>
          <target state="translated">人形師を一からフックアップすることもできます。基本的な考え方は</target>
        </trans-unit>
        <trans-unit id="35aff70317c576091536adc5e1a43d87f6a53f1b" translate="yes" xml:space="preserve">
          <source>You can also nest &lt;code&gt;describe&lt;/code&gt; blocks if you have a hierarchy of tests:</source>
          <target state="translated">テストの階層がある場合は、 &lt;code&gt;describe&lt;/code&gt; ブロックをネストすることもできます。</target>
        </trans-unit>
        <trans-unit id="ecbf1217eb1b7413e5ac5532b9f18df62cd10cea" translate="yes" xml:space="preserve">
          <source>You can also pass an array of objects, in which case the method will return true only if each object in the received array matches (in the &lt;code&gt;toMatchObject&lt;/code&gt; sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to &lt;code&gt;arrayContaining&lt;/code&gt;, which allows for extra elements in the received array.</source>
          <target state="translated">オブジェクトの配列を渡すこともできます。その場合、メソッドは、受信した配列の各オブジェクトが（上記の &lt;code&gt;toMatchObject&lt;/code&gt; の意味で）予期される配列の対応するオブジェクトと一致する場合にのみtrueを返します。これは、2つの配列の要素数が一致していることを確認する場合に役立ちます。これは、受信した配列の要素を追加できる &lt;code&gt;arrayContaining&lt;/code&gt; とは対照的です。</target>
        </trans-unit>
        <trans-unit id="33e631cdb46e5194143ae6343251d5d4abeebe0e" translate="yes" xml:space="preserve">
          <source>You can also test for the opposite of a matcher:</source>
          <target state="translated">マッチャーの逆もテストできます。</target>
        </trans-unit>
        <trans-unit id="766ae758010f2b190e41fbbc693bc28b84e8247c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;.resolves&lt;/code&gt; matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</source>
          <target state="translated">expectステートメントで &lt;code&gt;.resolves&lt;/code&gt; マッチャーを使用することもでき、Jestはその約束が解決されるのを待ちます。約束が拒否された場合、テストは自動的に失敗します。</target>
        </trans-unit>
        <trans-unit id="c23acb6b8a75eb059d0bf1a92f11f8a674f5b5ac" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; to add a module that formats application-specific data structures.</source>
          <target state="translated">&lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; を呼び出して、アプリケーション固有のデータ構造をフォーマットするモジュールを追加できます。</target>
        </trans-unit>
        <trans-unit id="b0148d2ae9957ac3475428862737e46004f4bc04" translate="yes" xml:space="preserve">
          <source>You can check if an array or iterable contains a particular item using &lt;code&gt;toContain&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;toContain&lt;/code&gt; を使用して、配列または反復可能オブジェクトに特定のアイテムが含まれているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="2d51d93712488643fb65c1c14ffe4c74aaa71d14" translate="yes" xml:space="preserve">
          <source>You can check strings against regular expressions with &lt;code&gt;toMatch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;toMatch&lt;/code&gt; を使用すると、正規表現に対して文字列をチェックできます。</target>
        </trans-unit>
        <trans-unit id="e25edb586f40e9238795e2ba9b6c0d4c65291a8a" translate="yes" xml:space="preserve">
          <source>You can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:</source>
          <target state="translated">Jest の特定の機能をチェリーピックして、スタンドアロンパッケージとして使用することができます。利用可能なパッケージのリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="42fd15afca8b3c0e27f3602b1bb8b499e91c1c6b" translate="yes" xml:space="preserve">
          <source>You can collect coverage from those files with setting &lt;code&gt;forceCoverageMatch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceCoverageMatch&lt;/code&gt; を設定すると、これらのファイルからカバレッジを収集できます。</target>
        </trans-unit>
        <trans-unit id="0087ca484c125dc235349950ec51d13f3336f610" translate="yes" xml:space="preserve">
          <source>You can combine &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; with &lt;code&gt;.resolves&lt;/code&gt; or &lt;code&gt;.rejects&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; と &lt;code&gt;await&lt;/code&gt; を &lt;code&gt;.resolves&lt;/code&gt; または &lt;code&gt;.rejects&lt;/code&gt; と組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="d20f2b42e97c65aaef925a2c6a3961d0c033857b" translate="yes" xml:space="preserve">
          <source>You can create your own module that will be used for setting up the test environment. The module must export a class with &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt; and &lt;code&gt;runScript&lt;/code&gt; methods. You can also pass variables from this module to your test suites by assigning them to &lt;code&gt;this.global&lt;/code&gt; object &amp;ndash; this will make them available in your test suites as global variables.</source>
          <target state="translated">テスト環境のセットアップに使用する独自のモジュールを作成できます。モジュールは、 &lt;code&gt;setup&lt;/code&gt; 、 &lt;code&gt;teardown&lt;/code&gt; 、および &lt;code&gt;runScript&lt;/code&gt; メソッドを含むクラスをエクスポートする必要があります。変数を &lt;code&gt;this.global&lt;/code&gt; オブジェクトに割り当てることで、このモジュールからテストスイートに変数を渡すこともできます。これにより、テストスイートで変数をグローバル変数として使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="1ef2f94dd57c5898c7b5cdef5978ab020627b6d9" translate="yes" xml:space="preserve">
          <source>You can match properties against values or against matchers.</source>
          <target state="translated">プロパティを値に対してマッチさせることができますし、マッチャーに対してマッチさせることもできます。</target>
        </trans-unit>
        <trans-unit id="f8d7a47b61e8074001017d01760195a44daa7d92" translate="yes" xml:space="preserve">
          <source>You can optionally provide a name for your mock functions, which will be displayed instead of &quot;jest.fn()&quot; in test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.</source>
          <target state="translated">オプションでモック関数の名前を指定することができ、テストエラー出力で &quot; jest.fn()&quot; の代わりに表示されます。テスト出力でエラーを報告しているモック関数を素早く識別したい場合に使用してください。</target>
        </trans-unit>
        <trans-unit id="141547ac2059520c584383a103038c5f0023150f" translate="yes" xml:space="preserve">
          <source>You can pass configuration to a transformer like &lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; For example, to configure babel-jest for non-default behavior, &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; ようなトランスフォーマーに設定を渡すことができます。たとえば、デフォルト以外の動作のbabel-jestを設定するには、 &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="800cb883045942cfd5bb4081f8af395b4c78910d" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;hint&lt;/code&gt; string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate &lt;strong&gt;multiple&lt;/strong&gt; snapshots in a &lt;strong&gt;single&lt;/strong&gt;&lt;code&gt;it&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; block. Jest sorts snapshots by name in the corresponding &lt;code&gt;.snap&lt;/code&gt; file.</source>
          <target state="translated">テスト名に追加されるオプションの &lt;code&gt;hint&lt;/code&gt; 文字列引数を提供できます。 Jestは常にスナップショット名の末尾に番号を追加しますが、&lt;strong&gt;単一の&lt;/strong&gt; &lt;code&gt;it&lt;/code&gt; または &lt;code&gt;test&lt;/code&gt; ブロックで&lt;strong&gt;複数の&lt;/strong&gt;スナップショットを区別するには、番号よりも短い説明のヒントの方が役立つ場合があります。 Jestは、対応する &lt;code&gt;.snap&lt;/code&gt; ファイル内の名前でスナップショットをソートします。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cc4d175319a45a401106b9809e576146487b0b9" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;propertyMatchers&lt;/code&gt; object argument, which has asymmetric matchers as values of a subset of expected properties, &lt;strong&gt;if&lt;/strong&gt; the received value will be an &lt;strong&gt;object&lt;/strong&gt; instance. It is like &lt;code&gt;toMatchObject&lt;/code&gt; with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties.</source>
          <target state="translated">受け取った値が&lt;strong&gt;オブジェクト&lt;/strong&gt;インスタンスである&lt;strong&gt;場合&lt;/strong&gt;は、予想されるプロパティのサブセットの値として非対称マッチャーを持つオプションの &lt;code&gt;propertyMatchers&lt;/code&gt; オブジェクト引数を指定できます。これは、プロパティのサブセットの柔軟な基準を備えた &lt;code&gt;toMatchObject&lt;/code&gt; に似ており、残りのプロパティの正確な基準としてスナップショットテストが続きます。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="342a9b14684325992d5ff139401436ae7682dd1a" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;value&lt;/code&gt; argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the &lt;code&gt;toEqual&lt;/code&gt; matcher).</source>
          <target state="translated">オプションの &lt;code&gt;value&lt;/code&gt; 引数を指定して、受信したプロパティ値を比較できます（ &lt;code&gt;toEqual&lt;/code&gt; マッチャーのように、オブジェクトインスタンスのすべてのプロパティ（再帰的に深層等価とも呼ばれます）を比較します）。</target>
        </trans-unit>
        <trans-unit id="ecc5cea913bac7656555fb5571fc70b6c18f354b" translate="yes" xml:space="preserve">
          <source>You can provide an optional argument to test that a specific error is thrown:</source>
          <target state="translated">特定のエラーがスローされるかどうかをテストするために、オプションの引数を指定することができます。</target>
        </trans-unit>
        <trans-unit id="c0387678f500b8dabacd6ece5ed81ebc2dad87e6" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-changed-files&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;jest-changed-files&lt;/code&gt; の詳細については、&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;readmeファイルを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a117882f05bee0eb2692567e191ce66d663578e1" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-docblock&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;readmeファイル&lt;/a&gt;で &lt;code&gt;jest-docblock&lt;/code&gt; の詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="46c165debafb7322f712fc6e454196637356e378" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-validate&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;readmeファイル&lt;/a&gt;で &lt;code&gt;jest-validate&lt;/code&gt; の詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="2867c6d937c4005f8963139f59e55ad836a6852b" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-worker&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;readmeファイル&lt;/a&gt;で &lt;code&gt;jest-worker&lt;/code&gt; の詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="d429e36c0ed20b800a39f032d046273b4cea53be" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;pretty-format&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">あなたは&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;readmeファイル&lt;/a&gt;で &lt;code&gt;pretty-format&lt;/code&gt; 詳細を読むことができます。</target>
        </trans-unit>
        <trans-unit id="f91698c99b451b48fdef94d8133ba660ee4beb14" translate="yes" xml:space="preserve">
          <source>You can replace all of the above mocks in order to change the implementation, for a single test or all tests, by calling &lt;code&gt;mockImplementation()&lt;/code&gt; on the existing mock.</source>
          <target state="translated">既存のモックで &lt;code&gt;mockImplementation()&lt;/code&gt; を呼び出すことにより、単一のテストまたはすべてのテストの実装を変更するために、上記のモックをすべて置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="563bf00a2d98bb36c45fffa7a2f6aab090a1748e" translate="yes" xml:space="preserve">
          <source>You can retrieve Jest's default options to expand them if needed:</source>
          <target state="translated">必要に応じて、Jestのデフォルトオプションを取得して拡張することができます。</target>
        </trans-unit>
        <trans-unit id="31bd27fefd08851ca3968f0ceda8045022a66264" translate="yes" xml:space="preserve">
          <source>You can run Jest directly from the CLI (if it's globally available in your &lt;code&gt;PATH&lt;/code&gt;, e.g. by &lt;code&gt;yarn global add jest&lt;/code&gt; or &lt;code&gt;npm install jest --global&lt;/code&gt;) with a variety of useful options.</source>
          <target state="translated">さまざまな便利なオプションを使用して、CLIから直接Jestを実行できます（ &lt;code&gt;PATH&lt;/code&gt; でグローバルに使用できる場合（例えば、 &lt;code&gt;yarn global add jest&lt;/code&gt; または &lt;code&gt;npm install jest --global&lt;/code&gt; によって））。</target>
        </trans-unit>
        <trans-unit id="f225c905306c2c0014f6ff2fdd68b6007152b521" translate="yes" xml:space="preserve">
          <source>You can try out this functionality by cloning the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;snapshot example&lt;/a&gt;, modifying the &lt;code&gt;Link&lt;/code&gt; component, and running Jest.</source>
          <target state="translated">この機能を試すには、&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;スナップショットの例を&lt;/a&gt;複製し、 &lt;code&gt;Link&lt;/code&gt; コンポーネントを変更して、Jestを実行します。</target>
        </trans-unit>
        <trans-unit id="a5ed2e627ad2f097c8fe5c0666910c34f57925f1" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.only&lt;/code&gt; if you want to run only one describe block:</source>
          <target state="translated">1つの記述ブロックのみを実行する場合は、 &lt;code&gt;describe.only&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="221b7b5d130528a59256d65bc2c5c5ab8c11adbb" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.skip&lt;/code&gt; if you do not want to run a particular describe block:</source>
          <target state="translated">特定の記述ブロックを実行したくない場合は、 &lt;code&gt;describe.skip&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="29de8e17dc9a604ab72ee70bda29920afbd2d460" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;expect.extend&lt;/code&gt; to add your own matchers to Jest. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a &lt;code&gt;toBeWithinRange&lt;/code&gt; matcher:</source>
          <target state="translated">&lt;code&gt;expect.extend&lt;/code&gt; を使用して、独自のマッチャーをJestに追加できます。たとえば、数値ユーティリティライブラリをテストしていて、数値が他の数値の特定の範囲内にあることを頻繁に主張しているとします。あなたはそれを &lt;code&gt;toBeWithinRange&lt;/code&gt; マッチャーに抽象化することができます：</target>
        </trans-unit>
        <trans-unit id="414d019cf0872729a505b6b1f50111cb1ce5b29d" translate="yes" xml:space="preserve">
          <source>You can use an &lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;ES6 Proxy&lt;/a&gt; to mock &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS Modules&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;ES6プロキシ&lt;/a&gt;を使用して&lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSSモジュール&lt;/a&gt;を模擬できます。</target>
        </trans-unit>
        <trans-unit id="e0ca37e74baa1f002bba25e20997f296e5781557" translate="yes" xml:space="preserve">
          <source>You can use it instead of a literal value:</source>
          <target state="translated">リテラル値の代わりに使うことができます。</target>
        </trans-unit>
        <trans-unit id="c085c131693a018bbc7ee86b6ff86c3192e859b0" translate="yes" xml:space="preserve">
          <source>You could comment the test out, but it's often a bit nicer to use &lt;code&gt;test.skip&lt;/code&gt; because it will maintain indentation and syntax highlighting.</source>
          <target state="translated">テストをコメントアウトすることもできますが、インデントと構文の強調表示を維持するため、 &lt;code&gt;test.skip&lt;/code&gt; を使用する方が多くの場合少し便利です。</target>
        </trans-unit>
        <trans-unit id="5359ed25529846e45ba23e420d5b9e5c6713de18" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="translated">&lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt; と書くこともできますが、コード内で &lt;code&gt;undefined&lt;/code&gt; を直接参照しないようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1ba59aa451c75435f919998f9ebfc1c5a8dd95b2" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="translated">&lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt; と書くこともできますが、コードで &lt;code&gt;undefined&lt;/code&gt; を直接参照しないようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="88ed689c2ae9512a449e124212b726dc5d4e0c96" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; to use react-testing-library.</source>
          <target state="translated">react-testing-libraryを使用するには、 &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="c2580df5ede4388981be8693d0eb04cda44e78ad" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev enzyme&lt;/code&gt; to use Enzyme. If you are using a React version below 15.5.0, you will also need to install &lt;code&gt;react-addons-test-utils&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;yarn add --dev enzyme&lt;/code&gt; を使用するには、yarn add --dev酵素を実行する必要があります。15.5.0より前のReactバージョンを使用している場合は、 &lt;code&gt;react-addons-test-utils&lt;/code&gt; もインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="7ab8163799282eb2cd2bcd483eb50ba23a2e1feb" translate="yes" xml:space="preserve">
          <source>You make the dependency explicit instead of implicit.</source>
          <target state="translated">依存関係を暗黙的ではなく明示的にします。</target>
        </trans-unit>
        <trans-unit id="0c38db17ba138256cbd5a96be8f1e6dc538f5fa8" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;getErrors&lt;/code&gt; returns, specifically - it might return &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt;, and your code would still work. So if you want to test there are no errors after drinking some La Croix, you could write:</source>
          <target state="translated">あなたは何を気にしないことがあり &lt;code&gt;getErrors&lt;/code&gt; のそれが返すことがあります-リターンは、特に &lt;code&gt;false&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; 、または &lt;code&gt;0&lt;/code&gt; を、そしてあなたのコードはまだ動作します。したがって、ラクロワを飲んだ後にエラーがないことをテストする場合は、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="c89edf49de3c63952efdcc592f2e40d0e91b763b" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;thirstInfo&lt;/code&gt; returns, specifically - it might return &lt;code&gt;true&lt;/code&gt; or a complex object, and your code would still work. So if you want to test that &lt;code&gt;thirstInfo&lt;/code&gt; will be truthy after drinking some La Croix, you could write:</source>
          <target state="translated">具体的には、 &lt;code&gt;thirstInfo&lt;/code&gt; が何を返すかを気にする必要はありません &lt;code&gt;true&lt;/code&gt; または複雑なオブジェクトを返しても、コードは機能します。したがって、ラクロワを飲んだ後に &lt;code&gt;thirstInfo&lt;/code&gt; が真実であることをテストしたい場合は、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="17b4764286d414a473eaaf4d566a76ce25182294" translate="yes" xml:space="preserve">
          <source>You should use the matcher that most precisely corresponds to what you want your code to be doing.</source>
          <target state="translated">コードを実行させたい内容に最も正確に対応する Matcherを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="7f37219870fbd51ab28f12639a113236e2ba5334" translate="yes" xml:space="preserve">
          <source>You will find a number of example test cases in the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt;&lt;code&gt;examples&lt;/code&gt;&lt;/a&gt; folder on GitHub. You can also learn from the excellent tests used by the &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt;, and &lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt; projects.</source>
          <target state="translated">GitHubの&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt; &lt;code&gt;examples&lt;/code&gt; &lt;/a&gt;フォルダーに多数のサンプルテストケースがあります。&lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt;、&lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt;、および&lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt;プロジェクトで使用される優れたテストから学ぶこともできます。</target>
        </trans-unit>
        <trans-unit id="d7eb67e376c7a0795313a9464135b5632741a836" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;package.json&lt;/code&gt; should look something like this (where &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; is the actual latest version number for the package). Please add the scripts and jest configuration entries:</source>
          <target state="translated">あなたの &lt;code&gt;package.json&lt;/code&gt; は、（ここで、次のようになります &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; 、パッケージの実際の最新バージョン番号です）。スクリプトとjest設定エントリを追加してください：</target>
        </trans-unit>
        <trans-unit id="ec89bd1c5f68c024aeca6e9e14636486318a74fe" translate="yes" xml:space="preserve">
          <source>Your test will want to mock the &lt;code&gt;fetch&lt;/code&gt; function so that we can be sure that it gets called without actually making the network request. However, you'll also need to mock the return value of &lt;code&gt;fetch&lt;/code&gt; with a &lt;code&gt;Response&lt;/code&gt; (wrapped in a &lt;code&gt;Promise&lt;/code&gt;), as our function uses it to grab the created user's ID. So you might initially try writing a test like this:</source>
          <target state="translated">テストでは、実際にネットワークリクエストを行わずに &lt;code&gt;fetch&lt;/code&gt; 関数が呼び出されるように、フェッチ関数をモックする必要があります。ただし、私たちの関数はそれを使用して、作成されたユーザーのID を &lt;code&gt;fetch&lt;/code&gt; するため、fetchの戻り値を &lt;code&gt;Response&lt;/code&gt; （ &lt;code&gt;Promise&lt;/code&gt; でラップ）でモックする必要もあります。したがって、最初に次のようなテストを作成してみてください。</target>
        </trans-unit>
        <trans-unit id="1175cedc7032117d3657edf28dbe7bb9385d7c5c" translate="yes" xml:space="preserve">
          <source>Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.</source>
          <target state="translated">テストは決定論的であるべきです。変更されていないコンポーネントで同じテストを複数回実行しても、毎回同じ結果が得られるはずです。生成したスナップショットにプラットフォーム固有のデータやその他の非決定論的なデータが含まれていないことを確認する責任があります。</target>
        </trans-unit>
        <trans-unit id="2f17fc980285f8ffe0be9e33ef7152af13254fe8" translate="yes" xml:space="preserve">
          <source>afterAll()</source>
          <target state="translated">afterAll()</target>
        </trans-unit>
        <trans-unit id="fb268a1811f730c2067165b083e360322d72f477" translate="yes" xml:space="preserve">
          <source>afterEach()</source>
          <target state="translated">afterEach()</target>
        </trans-unit>
        <trans-unit id="9ad6d2fa2c7de85e6b6dd37cd6a886c8f07ad319" translate="yes" xml:space="preserve">
          <source>async-to-gen</source>
          <target state="translated">async-to-gen</target>
        </trans-unit>
        <trans-unit id="bd90b357192cd27b16a70b7698bb14ee20cba402" translate="yes" xml:space="preserve">
          <source>awesome-jest</source>
          <target state="translated">awesome-jest</target>
        </trans-unit>
        <trans-unit id="d09b0fbfb51ee1470bcc585dd8ce8dfa55e488df" translate="yes" xml:space="preserve">
          <source>beforeAll()</source>
          <target state="translated">beforeAll()</target>
        </trans-unit>
        <trans-unit id="c70978f19975e8b38cf044b33e31fad2d272183a" translate="yes" xml:space="preserve">
          <source>beforeEach()</source>
          <target state="translated">beforeEach()</target>
        </trans-unit>
        <trans-unit id="740e438d6d95b968c3b9aaa798d54c124e64790b" translate="yes" xml:space="preserve">
          <source>close puppeteer with Global Teardown</source>
          <target state="translated">グローバルティアダウンのクローズパペット</target>
        </trans-unit>
        <trans-unit id="53cdcf56a867665dc933b593cb499286aadcbc80" translate="yes" xml:space="preserve">
          <source>connect to puppeteer from each Test Environment</source>
          <target state="translated">各テスト環境から人形師に接続</target>
        </trans-unit>
        <trans-unit id="25509aa65c3b573b5425ab6624df82134524f006" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">デフォルト： &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8244e80092f3c12d77f6dd509da0f653409320b" translate="yes" xml:space="preserve">
          <source>describe()</source>
          <target state="translated">describe()</target>
        </trans-unit>
        <trans-unit id="398a5e26f7d6ff23078ffbb871957ca77291b3e7" translate="yes" xml:space="preserve">
          <source>describe.each()</source>
          <target state="translated">describe.each()</target>
        </trans-unit>
        <trans-unit id="4f24a48da5c59a6bd3845bdb54350e1d1d0ee38d" translate="yes" xml:space="preserve">
          <source>describe.only()</source>
          <target state="translated">describe.only()</target>
        </trans-unit>
        <trans-unit id="f11fce8c9ed55e7be7b2cbcc6e46f524b949f14e" translate="yes" xml:space="preserve">
          <source>describe.only.each()</source>
          <target state="translated">describe.only.each()</target>
        </trans-unit>
        <trans-unit id="c3382b09895d6af2c9e821d96ad003e58d4b96de" translate="yes" xml:space="preserve">
          <source>describe.skip()</source>
          <target state="translated">describe.skip()</target>
        </trans-unit>
        <trans-unit id="2c446c6cd1bf47770ef8c7d1bd166c465eedf771" translate="yes" xml:space="preserve">
          <source>describe.skip.each()</source>
          <target state="translated">describe.skip.each()</target>
        </trans-unit>
        <trans-unit id="fcf239e7993ef571d39b364c0de3fda8a3ae0c81" translate="yes" xml:space="preserve">
          <source>error class: error object is &lt;strong&gt;instance of&lt;/strong&gt; class</source>
          <target state="translated">エラークラス：エラーオブジェクトはクラスの&lt;strong&gt;インスタンスです&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7851c6709a8adac9e962eee4f13a4ff8d35c84c6" translate="yes" xml:space="preserve">
          <source>error object: error message is &lt;strong&gt;equal to&lt;/strong&gt; the message property of the object</source>
          <target state="translated">エラーオブジェクト：エラーメッセージはオブジェクトのメッセージプロパティと&lt;strong&gt;同じです&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a00f641af4b4bd382b037a5599ec8c6bd2a58a7a" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jest</source>
          <target state="translated">eslint-plugin-jest</target>
        </trans-unit>
        <trans-unit id="3aede15b1d5d318f2bf628e79d06cd5ec821f235" translate="yes" xml:space="preserve">
          <source>expect()</source>
          <target state="translated">expect()</target>
        </trans-unit>
        <trans-unit id="c531f8f49210f5c5cc7e56c0bcf8809390d60182" translate="yes" xml:space="preserve">
          <source>expect.addSnapshotSerializer()</source>
          <target state="translated">expect.addSnapshotSerializer()</target>
        </trans-unit>
        <trans-unit id="73052babf147d5ab7087790cf489001a5fe6adef" translate="yes" xml:space="preserve">
          <source>expect.any()</source>
          <target state="translated">expect.any()</target>
        </trans-unit>
        <trans-unit id="041f3593b4cfc38ec52995cb888e8d017339e912" translate="yes" xml:space="preserve">
          <source>expect.anything()</source>
          <target state="translated">expect.anything()</target>
        </trans-unit>
        <trans-unit id="b1648f49219a878c2221460718595da8c398b8b3" translate="yes" xml:space="preserve">
          <source>expect.arrayContaining()</source>
          <target state="translated">expect.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="07105ad3d99570c6ffdfd4ccea4770093ccd6589" translate="yes" xml:space="preserve">
          <source>expect.assertions()</source>
          <target state="translated">expect.assertions()</target>
        </trans-unit>
        <trans-unit id="cf206af29db6d448d19d0b2896ed0f7be77ca4b2" translate="yes" xml:space="preserve">
          <source>expect.extend()</source>
          <target state="translated">expect.extend()</target>
        </trans-unit>
        <trans-unit id="bef0c4a5294c45e4f23630650c298423d2b0033a" translate="yes" xml:space="preserve">
          <source>expect.hasAssertions()</source>
          <target state="translated">expect.hasAssertions()</target>
        </trans-unit>
        <trans-unit id="a4b4f299cc5121ba5bb42d780d793dd0d208d5d1" translate="yes" xml:space="preserve">
          <source>expect.not.arrayContaining()</source>
          <target state="translated">expect.not.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="cd369cc867e384fabaa81e31b91e2ec5e06cb648" translate="yes" xml:space="preserve">
          <source>expect.not.objectContaining()</source>
          <target state="translated">expect.not.objectContaining()</target>
        </trans-unit>
        <trans-unit id="c3e51c2efa41f651e0f4da6911e099a7e6ae1ca4" translate="yes" xml:space="preserve">
          <source>expect.not.stringContaining()</source>
          <target state="translated">expect.not.stringContaining()</target>
        </trans-unit>
        <trans-unit id="1146b5bca92b76c491171096be15657da9f28d46" translate="yes" xml:space="preserve">
          <source>expect.not.stringMatching()</source>
          <target state="translated">expect.not.stringMatching()</target>
        </trans-unit>
        <trans-unit id="a323da51fabb3d791f0b36ac04909baab7f19868" translate="yes" xml:space="preserve">
          <source>expect.objectContaining()</source>
          <target state="translated">expect.objectContaining()</target>
        </trans-unit>
        <trans-unit id="05a9b81e11194231b386c00515a14089ffa1ab48" translate="yes" xml:space="preserve">
          <source>expect.stringContaining()</source>
          <target state="translated">expect.stringContaining()</target>
        </trans-unit>
        <trans-unit id="64a818d5f4128d542c68ad3e5b52cf9cb07239c5" translate="yes" xml:space="preserve">
          <source>expect.stringMatching()</source>
          <target state="translated">expect.stringMatching()</target>
        </trans-unit>
        <trans-unit id="5b53271817c17d31475c2601f79c760d8c18c932" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt;</source>
          <target state="translated">中 &lt;code&gt;toEqual&lt;/code&gt; または &lt;code&gt;toBeCalledWith&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14fdeea7a02add9f25f4b254a8109cebfb41a968" translate="yes" xml:space="preserve">
          <source>jest</source>
          <target state="translated">jest</target>
        </trans-unit>
        <trans-unit id="399f3e6c7d355276f40f586cacf83580961e34e9" translate="yes" xml:space="preserve">
          <source>jest --bail</source>
          <target state="translated">jest-保釈</target>
        </trans-unit>
        <trans-unit id="7728f73469dcbf23ae8e337f07d557f5387051c2" translate="yes" xml:space="preserve">
          <source>jest --cache</source>
          <target state="translated">は --cache です。</target>
        </trans-unit>
        <trans-unit id="a4aa246751c414496487d54530974546f8e2e1a7" translate="yes" xml:space="preserve">
          <source>jest --changedFilesWithAncestor</source>
          <target state="translated">jest --changedFilesWithAncestor</target>
        </trans-unit>
        <trans-unit id="e4435b17b912dad78333d9c715e558d3c202ab34" translate="yes" xml:space="preserve">
          <source>jest --changedSince</source>
          <target state="translated">じょうだん --changedSince</target>
        </trans-unit>
        <trans-unit id="b5261799c92dd14f3365e36279542409dc1f4470" translate="yes" xml:space="preserve">
          <source>jest --ci</source>
          <target state="translated">jest --ci</target>
        </trans-unit>
        <trans-unit id="18b3b63f5ed9f4cb059fbdfa287a7092d2bd46c8" translate="yes" xml:space="preserve">
          <source>jest --clearCache</source>
          <target state="translated">jest --clearCache</target>
        </trans-unit>
        <trans-unit id="6b45786c23204e16069d34c716fc3df38b6aa6b3" translate="yes" xml:space="preserve">
          <source>jest --collectCoverageFrom</source>
          <target state="translated">jest --collectCoverageFrom</target>
        </trans-unit>
        <trans-unit id="16739578c7f61b7a8f8542434d00d6ab09963e57" translate="yes" xml:space="preserve">
          <source>jest --colors</source>
          <target state="translated">諧謔 --色</target>
        </trans-unit>
        <trans-unit id="16996765a63984335bd12471e86885562b954705" translate="yes" xml:space="preserve">
          <source>jest --config</source>
          <target state="translated">jest --config</target>
        </trans-unit>
        <trans-unit id="ecd47d28d6d16f7e198f7bb676071b8de7aa625f" translate="yes" xml:space="preserve">
          <source>jest --coverage</source>
          <target state="translated">jest-カバレッジ</target>
        </trans-unit>
        <trans-unit id="200e04fecf37753c77869affc65b05074a843073" translate="yes" xml:space="preserve">
          <source>jest --debug</source>
          <target state="translated">は --debug です。</target>
        </trans-unit>
        <trans-unit id="d0896a807b1438960db7baa7a96cc00d29eb6fbf" translate="yes" xml:space="preserve">
          <source>jest --detectOpenHandles</source>
          <target state="translated">は --detectOpenHandles</target>
        </trans-unit>
        <trans-unit id="1edb0e7b6eaef88efb6ed9a604136e0b2dc3df91" translate="yes" xml:space="preserve">
          <source>jest --env</source>
          <target state="translated">は --env</target>
        </trans-unit>
        <trans-unit id="8a0f943b937dcd72c06bfe59afe73fb4a1f31d48" translate="yes" xml:space="preserve">
          <source>jest --errorOnDeprecated</source>
          <target state="translated">jest --errorOnDeprecated</target>
        </trans-unit>
        <trans-unit id="451e3f27037c6eaedc5c0ee1528d6ecd3860ad73" translate="yes" xml:space="preserve">
          <source>jest --expand</source>
          <target state="translated">諧謔 --拡大</target>
        </trans-unit>
        <trans-unit id="75a8e4a783be5089515d60538e7e8125cdd33fe3" translate="yes" xml:space="preserve">
          <source>jest --findRelatedTests</source>
          <target state="translated">jest --findRelatedTests</target>
        </trans-unit>
        <trans-unit id="4959c728768cddd33ed24149b8756c30f1461b6c" translate="yes" xml:space="preserve">
          <source>jest --forceExit</source>
          <target state="translated">jest --forceExit</target>
        </trans-unit>
        <trans-unit id="e7042ae5c15d17e9dfb626d3b992b070a2b33ac3" translate="yes" xml:space="preserve">
          <source>jest --help</source>
          <target state="translated">jest --help</target>
        </trans-unit>
        <trans-unit id="2b44f9af93a63dbc353bdbb59b8977473460ea15" translate="yes" xml:space="preserve">
          <source>jest --init</source>
          <target state="translated">じょうだん --init</target>
        </trans-unit>
        <trans-unit id="b472735c07ba84430b5dcc73a9578211df4a2c7a" translate="yes" xml:space="preserve">
          <source>jest --json</source>
          <target state="translated">じょうけん --json</target>
        </trans-unit>
        <trans-unit id="67842930eb4c451f524a5334d5d9987f944c0b62" translate="yes" xml:space="preserve">
          <source>jest --lastCommit</source>
          <target state="translated">jest --lastCommit</target>
        </trans-unit>
        <trans-unit id="5ef4898fedf76393b34edae0c0c9eb5f9becbdb5" translate="yes" xml:space="preserve">
          <source>jest --listTests</source>
          <target state="translated">jest --listTests</target>
        </trans-unit>
        <trans-unit id="68a8e8c37228016d5b69d8f98bc9033444f6dcfc" translate="yes" xml:space="preserve">
          <source>jest --logHeapUsage</source>
          <target state="translated">jest --logHeapUsage</target>
        </trans-unit>
        <trans-unit id="34e1461f0465c9780fed87f508481d93f147883c" translate="yes" xml:space="preserve">
          <source>jest --maxConcurrency</source>
          <target state="translated">jest --maxConcurrency</target>
        </trans-unit>
        <trans-unit id="ff2ced6c82113057178b44c26a4df8d1cfcde5ad" translate="yes" xml:space="preserve">
          <source>jest --maxWorkers</source>
          <target state="translated">jest --maxWorkers</target>
        </trans-unit>
        <trans-unit id="8c8c93cffedf5f51fbf6769d1b9f4b08296e0a72" translate="yes" xml:space="preserve">
          <source>jest --noStackTrace</source>
          <target state="translated">jest --noStackTrace</target>
        </trans-unit>
        <trans-unit id="07fe4de480c74eb982dfd2fc1ffabbc5e8000f9a" translate="yes" xml:space="preserve">
          <source>jest --notify</source>
          <target state="translated">剽剽窃</target>
        </trans-unit>
        <trans-unit id="777939208a77b6ed85265bb3541e0aaf5212fbb3" translate="yes" xml:space="preserve">
          <source>jest --onlyChanged</source>
          <target state="translated">jest --OnlyChanged</target>
        </trans-unit>
        <trans-unit id="39d9ffe9fc23f87610839ef7d3409e4bdcaeb08c" translate="yes" xml:space="preserve">
          <source>jest --outputFile</source>
          <target state="translated">jest --outputFile</target>
        </trans-unit>
        <trans-unit id="709a7d88446a6c333c370abdc7cbc81e5007aeb4" translate="yes" xml:space="preserve">
          <source>jest --passWithNoTests</source>
          <target state="translated">jest --passWithNoTests</target>
        </trans-unit>
        <trans-unit id="c01b9e323723244523c23d1edd20bbd8fa1fad8b" translate="yes" xml:space="preserve">
          <source>jest --projects</source>
          <target state="translated">剽剽窃--プロジェクト</target>
        </trans-unit>
        <trans-unit id="28ccc63c68da10265b442f6ddb719c32cb336d21" translate="yes" xml:space="preserve">
          <source>jest --reporters</source>
          <target state="translated">剽剽窃者</target>
        </trans-unit>
        <trans-unit id="64629dd6eadf22a13bedf72b140ffb326b3adf10" translate="yes" xml:space="preserve">
          <source>jest --runInBand</source>
          <target state="translated">jest --runInBand</target>
        </trans-unit>
        <trans-unit id="6d7004d9e45fbe7afc81b68d019a0999a9bc0c7c" translate="yes" xml:space="preserve">
          <source>jest --runTestsByPath</source>
          <target state="translated">jest --runTestsByPath</target>
        </trans-unit>
        <trans-unit id="096d835c379fd03e494f9bdb3bd4cbf0d83b2f71" translate="yes" xml:space="preserve">
          <source>jest --setupTestFrameworkScriptFile</source>
          <target state="translated">jest -setupTestFrameworkScriptFile</target>
        </trans-unit>
        <trans-unit id="940e5b5b259afe41c7f972448e3b14ae829486ab" translate="yes" xml:space="preserve">
          <source>jest --showConfig</source>
          <target state="translated">jest --showConfig</target>
        </trans-unit>
        <trans-unit id="a19e9fb882999e3c40b7635bba97bd9c793f3561" translate="yes" xml:space="preserve">
          <source>jest --silent</source>
          <target state="translated">jest-サイレント</target>
        </trans-unit>
        <trans-unit id="3116d8e92505df6e40aa26ca10c8d3a5aefaf6af" translate="yes" xml:space="preserve">
          <source>jest --testLocationInResults</source>
          <target state="translated">jest --testLocationInResults</target>
        </trans-unit>
        <trans-unit id="8a07b564f31bb6e6c96720d77231a8a1e45f39e3" translate="yes" xml:space="preserve">
          <source>jest --testNamePattern</source>
          <target state="translated">jest --testNamePattern</target>
        </trans-unit>
        <trans-unit id="4de2b306577ed62d6f8717e3427fffb985e1b43b" translate="yes" xml:space="preserve">
          <source>jest --testPathIgnorePatterns</source>
          <target state="translated">jest --testPathIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="c6d599e9db1d5b8b8b9b1e34af131cc7a609574c" translate="yes" xml:space="preserve">
          <source>jest --testPathPattern</source>
          <target state="translated">jest --testPathPattern</target>
        </trans-unit>
        <trans-unit id="f1e05395a90bfd20cc69363133868bb63d439c51" translate="yes" xml:space="preserve">
          <source>jest --testRunner</source>
          <target state="translated">jest --testRunner</target>
        </trans-unit>
        <trans-unit id="a107d7a62c0faae9d219c603e662cbdfb1168139" translate="yes" xml:space="preserve">
          <source>jest --testSequencer</source>
          <target state="translated">jest --testSequencer</target>
        </trans-unit>
        <trans-unit id="c7ef133f2b7dc919c3ad71da9cce4c6ffd6cd868" translate="yes" xml:space="preserve">
          <source>jest --testTimeout</source>
          <target state="translated">jest --testTimeout</target>
        </trans-unit>
        <trans-unit id="855f8a66c2044d0c0aa8ce263401b44fa1019b06" translate="yes" xml:space="preserve">
          <source>jest --updateSnapshot</source>
          <target state="translated">jest --updateSnapshot</target>
        </trans-unit>
        <trans-unit id="4ea12447858a50cdd5c983e5da4ab87dbdf7bf88" translate="yes" xml:space="preserve">
          <source>jest --useStderr</source>
          <target state="translated">jest --useStderr</target>
        </trans-unit>
        <trans-unit id="f073ca0513417405f3d24492d3c2e48be87f71de" translate="yes" xml:space="preserve">
          <source>jest --verbose</source>
          <target state="translated">jest-詳細</target>
        </trans-unit>
        <trans-unit id="8144cdc86e9d7837063cedb0371d26f3eec4e393" translate="yes" xml:space="preserve">
          <source>jest --version</source>
          <target state="translated">jest --version</target>
        </trans-unit>
        <trans-unit id="24a92c60d5aa0d0bc0a04e89176cbe3de81ca593" translate="yes" xml:space="preserve">
          <source>jest --watch</source>
          <target state="translated">戯言 --見物</target>
        </trans-unit>
        <trans-unit id="4a0c8c57a84aa98a2040ae7e753c42a9d15607d0" translate="yes" xml:space="preserve">
          <source>jest --watchAll</source>
          <target state="translated">jest --watchAll</target>
        </trans-unit>
        <trans-unit id="8357ee4077e5c430d196688e7e00e4f2b5298f39" translate="yes" xml:space="preserve">
          <source>jest --watchman</source>
          <target state="translated">戯言 --番人</target>
        </trans-unit>
        <trans-unit id="8dac8b8cbde7c22969d69a11d630521076ff0471" translate="yes" xml:space="preserve">
          <source>jest-changed-files</source>
          <target state="translated">jest-changed-files</target>
        </trans-unit>
        <trans-unit id="b54512fd3b9795a4772b2657ce0156724195ce07" translate="yes" xml:space="preserve">
          <source>jest-codemods</source>
          <target state="translated">jest-codemods</target>
        </trans-unit>
        <trans-unit id="4d0ba9791c912565a89e87ec93cd71cdc4b75579" translate="yes" xml:space="preserve">
          <source>jest-diff</source>
          <target state="translated">jest-diff</target>
        </trans-unit>
        <trans-unit id="fae57be3b9d4c6db0129364d146af1ae34bc4571" translate="yes" xml:space="preserve">
          <source>jest-docblock</source>
          <target state="translated">jest-docblock</target>
        </trans-unit>
        <trans-unit id="33815f7eafadf66bdf82b692a5d7500e04bdcf17" translate="yes" xml:space="preserve">
          <source>jest-extended</source>
          <target state="translated">jest-extended</target>
        </trans-unit>
        <trans-unit id="7a5cb26800c7666578e96bedb106ca6c76db8288" translate="yes" xml:space="preserve">
          <source>jest-get-type</source>
          <target state="translated">jest-get-type</target>
        </trans-unit>
        <trans-unit id="9930457414d8318490b519406b0d01e0c0af9388" translate="yes" xml:space="preserve">
          <source>jest-validate</source>
          <target state="translated">jest-validate</target>
        </trans-unit>
        <trans-unit id="74459ea621c5c89c1a6a8777f420f08a699ce618" translate="yes" xml:space="preserve">
          <source>jest-worker</source>
          <target state="translated">jest-worker</target>
        </trans-unit>
        <trans-unit id="b5268823984999cb437a77b35d87876782899202" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersByTime()</source>
          <target state="translated">jest.advanceTimersByTime()</target>
        </trans-unit>
        <trans-unit id="4f84712675c1d51a3df5e0c8bc41ac8a5291b5b5" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersToNextTimer()</source>
          <target state="translated">jest.advanceTimersToNextTimer()</target>
        </trans-unit>
        <trans-unit id="926befda6fecbd4a52674619f3af9b0e7f68fc1e" translate="yes" xml:space="preserve">
          <source>jest.clearAllMocks()</source>
          <target state="translated">jest.clearAllMocks()</target>
        </trans-unit>
        <trans-unit id="4222fbb57b1accc14807b98d10122439d4ff5022" translate="yes" xml:space="preserve">
          <source>jest.clearAllTimers()</source>
          <target state="translated">jest.clearAllTimers()</target>
        </trans-unit>
        <trans-unit id="c805b56432a104b93bac2f37dc3d95d0ee13d1ef" translate="yes" xml:space="preserve">
          <source>jest.disableAutomock()</source>
          <target state="translated">jest.disableAutomock()</target>
        </trans-unit>
        <trans-unit id="37431f3778ecbfb714d3adbd0be802b5c721c30f" translate="yes" xml:space="preserve">
          <source>jest.doMock()</source>
          <target state="translated">jest.doMock()</target>
        </trans-unit>
        <trans-unit id="e1eb654d0e6f9a86254eb54aacafc37839145bc6" translate="yes" xml:space="preserve">
          <source>jest.dontMock()</source>
          <target state="translated">jest.dontMock()</target>
        </trans-unit>
        <trans-unit id="96a8a03defe83d958b13a8db1048b48645fd3459" translate="yes" xml:space="preserve">
          <source>jest.enableAutomock()</source>
          <target state="translated">jest.enableAutomock()</target>
        </trans-unit>
        <trans-unit id="63706588ece2fbb5ee1cbc26ed3cd9b3394a2aa3" translate="yes" xml:space="preserve">
          <source>jest.fn()</source>
          <target state="translated">jest.fn()</target>
        </trans-unit>
        <trans-unit id="5219ae476b088f3b68bcaf6bf0a3ebfe1cd29904" translate="yes" xml:space="preserve">
          <source>jest.genMockFromModule()</source>
          <target state="translated">jest.genMockFromModule()</target>
        </trans-unit>
        <trans-unit id="def17227de8f296f563b72986222dc177bb11d6d" translate="yes" xml:space="preserve">
          <source>jest.getTimerCount()</source>
          <target state="translated">jest.getTimerCount()</target>
        </trans-unit>
        <trans-unit id="124a77d3e596a96e5e22131aaf874ab0b85168bc" translate="yes" xml:space="preserve">
          <source>jest.isMockFunction()</source>
          <target state="translated">jest.isMockFunction()</target>
        </trans-unit>
        <trans-unit id="f59381d1be107811c5f127861c8b25779aac8d08" translate="yes" xml:space="preserve">
          <source>jest.isolateModules()</source>
          <target state="translated">jest.isolateModules()</target>
        </trans-unit>
        <trans-unit id="7fa6adb6c9fe552d5205372a422e3d7869a09385" translate="yes" xml:space="preserve">
          <source>jest.mock()</source>
          <target state="translated">jest.mock()</target>
        </trans-unit>
        <trans-unit id="ea788268b388e4e34786b83b59c434649a2880ba" translate="yes" xml:space="preserve">
          <source>jest.requireActual()</source>
          <target state="translated">jest.requireActual()</target>
        </trans-unit>
        <trans-unit id="eb1640f83eb73de04420583fd51286a6f8f26358" translate="yes" xml:space="preserve">
          <source>jest.requireMock()</source>
          <target state="translated">jest.requireMock()</target>
        </trans-unit>
        <trans-unit id="d6eb5ae9749a1f0bfe615e87dae5660439f11371" translate="yes" xml:space="preserve">
          <source>jest.resetAllMocks()</source>
          <target state="translated">jest.resetAllMocks()</target>
        </trans-unit>
        <trans-unit id="f5adc7f97ed3055597a83e098ddd8044c1732177" translate="yes" xml:space="preserve">
          <source>jest.resetModules()</source>
          <target state="translated">jest.resetModules()</target>
        </trans-unit>
        <trans-unit id="3fafd64547192fe4a73efe5ad2a0deadac3f3422" translate="yes" xml:space="preserve">
          <source>jest.restoreAllMocks()</source>
          <target state="translated">jest.restoreAllMocks()</target>
        </trans-unit>
        <trans-unit id="a948703e7207e3be8661bf6365a632c32226671e" translate="yes" xml:space="preserve">
          <source>jest.retryTimes()</source>
          <target state="translated">jest.retryTimes()</target>
        </trans-unit>
        <trans-unit id="b8ce73ec4b14b469bb28764f3a8c3d19e82ac7b6" translate="yes" xml:space="preserve">
          <source>jest.runAllImmediates()</source>
          <target state="translated">jest.runAllImmediates()</target>
        </trans-unit>
        <trans-unit id="53af7c8ab5fc7e913ecfb6a326b3610f64160176" translate="yes" xml:space="preserve">
          <source>jest.runAllTicks()</source>
          <target state="translated">jest.runAllTicks()</target>
        </trans-unit>
        <trans-unit id="bdd7917ff7ed9b0c8f251b4ed7bfa4aaf2b6152b" translate="yes" xml:space="preserve">
          <source>jest.runAllTimers()</source>
          <target state="translated">jest.runAllTimers()</target>
        </trans-unit>
        <trans-unit id="5f8881d3c2fa2e3c3978c63711cfc41587308941" translate="yes" xml:space="preserve">
          <source>jest.runOnlyPendingTimers()</source>
          <target state="translated">jest.runOnlyPendingTimers()</target>
        </trans-unit>
        <trans-unit id="115ea6be6949d8073195cf40a89a2c53d963f31a" translate="yes" xml:space="preserve">
          <source>jest.setMock()</source>
          <target state="translated">jest.setMock()</target>
        </trans-unit>
        <trans-unit id="e38a82fd2d18d144fa8049c3a4042f3947d71db8" translate="yes" xml:space="preserve">
          <source>jest.setTimeout()</source>
          <target state="translated">jest.setTimeout()</target>
        </trans-unit>
        <trans-unit id="4a21c582c06cb9f55c32d6a0da8083dbef2d04a4" translate="yes" xml:space="preserve">
          <source>jest.spyOn()</source>
          <target state="translated">jest.spyOn()</target>
        </trans-unit>
        <trans-unit id="e51942569d340db8459bde0b3a57da7a3ae5bd19" translate="yes" xml:space="preserve">
          <source>jest.unmock()</source>
          <target state="translated">jest.unmock()</target>
        </trans-unit>
        <trans-unit id="7bdcc5f2e0051948cd9175cbfd47b9f3a5c8a112" translate="yes" xml:space="preserve">
          <source>jest.useFakeTimers()</source>
          <target state="translated">jest.useFakeTimers()</target>
        </trans-unit>
        <trans-unit id="567a022c7ff0ed1eeecf66243bfb760f39f98839" translate="yes" xml:space="preserve">
          <source>jest.useRealTimers()</source>
          <target state="translated">jest.useRealTimers()</target>
        </trans-unit>
        <trans-unit id="d6c73ed242e8279bf8b5008c49164ea76ecca716" translate="yes" xml:space="preserve">
          <source>launch &amp;amp; file the websocket endpoint of puppeteer with Global Setup</source>
          <target state="translated">グローバル設定でpuppeteerのwebsocketエンドポイントを起動してファイルする</target>
        </trans-unit>
        <trans-unit id="c5534dc1bf91cfa3f571372cc1df1fde4778c65c" translate="yes" xml:space="preserve">
          <source>matching the files that coverage info needs to be collected from.</source>
          <target state="translated">補償情報を収集する必要があるファイルと一致します。</target>
        </trans-unit>
        <trans-unit id="bdaf39bbe2e8ce24d626e5d939f2687b7925a111" translate="yes" xml:space="preserve">
          <source>mockFn.getMockName()</source>
          <target state="translated">mockFn.getMockName()</target>
        </trans-unit>
        <trans-unit id="76ba86f80a3975694b82876ec035c67727b880ce" translate="yes" xml:space="preserve">
          <source>mockFn.mock.calls</source>
          <target state="translated">mockFn.mock.calls</target>
        </trans-unit>
        <trans-unit id="b8f5e098751b2e1a0b0c994fa0e253d7b6667585" translate="yes" xml:space="preserve">
          <source>mockFn.mock.instances</source>
          <target state="translated">mockFn.mock.instances</target>
        </trans-unit>
        <trans-unit id="37a607803e67bc8f0e277c4bad07d899cb8e68ee" translate="yes" xml:space="preserve">
          <source>mockFn.mock.results</source>
          <target state="translated">mockFn.mock.results</target>
        </trans-unit>
        <trans-unit id="d7884cf2e18f52e2befafea1329cc93891d01d0e" translate="yes" xml:space="preserve">
          <source>mockFn.mockClear()</source>
          <target state="translated">mockFn.mockClear()</target>
        </trans-unit>
        <trans-unit id="b1a1dc73ee86a9db45f473726c03a5d44e7d6e00" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementation()</source>
          <target state="translated">mockFn.mockImplementation()</target>
        </trans-unit>
        <trans-unit id="705599d736e3f800c387b8732532a981208d86f3" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementationOnce()</source>
          <target state="translated">mockFn.mockImplementationOnce()</target>
        </trans-unit>
        <trans-unit id="b15f7560dc442cfe559991bd028b3593dbedcfa3" translate="yes" xml:space="preserve">
          <source>mockFn.mockName()</source>
          <target state="translated">mockFn.mockName()</target>
        </trans-unit>
        <trans-unit id="cbee5a4253c363dd81a99f99a7171fe30ca56500" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValue()</source>
          <target state="translated">mockFn.mockRejectedValue()</target>
        </trans-unit>
        <trans-unit id="f0f879d05ce665721a5b420f915a6b799a9261b3" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValueOnce()</source>
          <target state="translated">mockFn.mockRejectedValueOnce()</target>
        </trans-unit>
        <trans-unit id="6379aa11d6a3d7b94b0cabd0ea38f28a5ac0a66b" translate="yes" xml:space="preserve">
          <source>mockFn.mockReset()</source>
          <target state="translated">mockFn.mockReset()</target>
        </trans-unit>
        <trans-unit id="e5f5a2cc9780e616fb57bcbabbb5e1b492e59a7c" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValue()</source>
          <target state="translated">mockFn.mockResolvedValue()</target>
        </trans-unit>
        <trans-unit id="a610c3278d44712a00c28aba1ba0a5f4c56f4602" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValueOnce()</source>
          <target state="translated">mockFn.mockResolvedValueOnce()</target>
        </trans-unit>
        <trans-unit id="93b4b4162d3f8f9f6743942f1582c22d36cf0434" translate="yes" xml:space="preserve">
          <source>mockFn.mockRestore()</source>
          <target state="translated">mockFn.mockRestore()</target>
        </trans-unit>
        <trans-unit id="b89668bf6eee3709904c8e914501f15481a0ec32" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnThis()</source>
          <target state="translated">mockFn.mockReturnThis()</target>
        </trans-unit>
        <trans-unit id="8406d4374df6cedb0774c198a5e18305079be058" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValue()</source>
          <target state="translated">mockFn.mockReturnValue()</target>
        </trans-unit>
        <trans-unit id="91d18268f60b6021a577b531532180c54eed125c" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValueOnce()</source>
          <target state="translated">mockFn.mockReturnValueOnce()</target>
        </trans-unit>
        <trans-unit id="110fd2eef67d470b905e3f770bc78bf0e48c4532" translate="yes" xml:space="preserve">
          <source>moduleNameMapper</source>
          <target state="translated">moduleNameMapper</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="f398e82965b003d86545395906bc58c426a160f4" translate="yes" xml:space="preserve">
          <source>or the following for Windows:</source>
          <target state="translated">またはWindowsの場合は以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="2e4e9d9ce9649c8da277337be899d54f4b10f016" translate="yes" xml:space="preserve">
          <source>pretty-format</source>
          <target state="translated">pretty-format</target>
        </trans-unit>
        <trans-unit id="b41c94dc77a8359c700e959dbc3271747436b9b8" translate="yes" xml:space="preserve">
          <source>react-testing-library</source>
          <target state="translated">react-testing-library</target>
        </trans-unit>
        <trans-unit id="6096aad9326ad51aa7277852583cdbbd0063c505" translate="yes" xml:space="preserve">
          <source>regular expression: error message &lt;strong&gt;matches&lt;/strong&gt; the pattern</source>
          <target state="translated">正規表現：エラーメッセージはパターンに&lt;strong&gt;一致&lt;/strong&gt;します</target>
        </trans-unit>
        <trans-unit id="564cb4d408b58135c97baa36f450885bf9df5afd" translate="yes" xml:space="preserve">
          <source>renamed from &lt;code&gt;runTimersToTime&lt;/code&gt; to &lt;code&gt;advanceTimersByTime&lt;/code&gt; in Jest &lt;strong&gt;22.0.0&lt;/strong&gt;</source>
          <target state="translated">Jest &lt;strong&gt;22.0.0で&lt;/strong&gt;、 &lt;code&gt;advanceTimersByTime&lt;/code&gt; から &lt;code&gt;runTimersToTime&lt;/code&gt; に名前が変更されました&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b081d67ddd0df4286abac590611b195d5398dfcd" translate="yes" xml:space="preserve">
          <source>renamed in Jest &lt;strong&gt;22.0.0+&lt;/strong&gt;</source>
          <target state="translated">Jest &lt;strong&gt;22.0.0以降で&lt;/strong&gt;名前が変更され&lt;strong&gt;ました&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa765d3c5cf61960d9c86c450acc1e2d6113a622" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt; としてexpect（received &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; を書き換えます</target>
        </trans-unit>
        <trans-unit id="12ee99b45418f1c182987feaff420ab1c0a53144" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt; として &lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; を書き換えます。</target>
        </trans-unit>
        <trans-unit id="648a633ae93664b145f1de2382bce78296d0d025" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</source>
          <target state="translated">書き換え &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; として &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4f197332e08a233e78868954dc8a7424597d992" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt;</source>
          <target state="translated">書き換え &lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; として &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98551bd9aa53f809816b1e04556754e5dbd233c3" translate="yes" xml:space="preserve">
          <source>setupFiles</source>
          <target state="translated">setupFiles</target>
        </trans-unit>
        <trans-unit id="cab3c689753017d9ed1c9833b41212afcceb0268" translate="yes" xml:space="preserve">
          <source>string: error message &lt;strong&gt;includes&lt;/strong&gt; the substring</source>
          <target state="translated">文字列：エラーメッセージ&lt;strong&gt;に&lt;/strong&gt;は部分文字列が&lt;strong&gt;含まれ&lt;/strong&gt;ます</target>
        </trans-unit>
        <trans-unit id="1a13bd67d53c6ca5d0ba854cc1c6d8e1dc4db3cb" translate="yes" xml:space="preserve">
          <source>test()</source>
          <target state="translated">test()</target>
        </trans-unit>
        <trans-unit id="96bc193802c9de785826750faae2c6bc85cbfbb8" translate="yes" xml:space="preserve">
          <source>test.each()</source>
          <target state="translated">test.each()</target>
        </trans-unit>
        <trans-unit id="5d3becd10c06347f68018bdfb99aca7f0ac8047e" translate="yes" xml:space="preserve">
          <source>test.only()</source>
          <target state="translated">test.only()</target>
        </trans-unit>
        <trans-unit id="ab30dfd5db9a31603c2e47fbd6881ec8dab86d26" translate="yes" xml:space="preserve">
          <source>test.only.each()</source>
          <target state="translated">test.only.each()</target>
        </trans-unit>
        <trans-unit id="1176e40f403020d9366a6b52b73ff551f31b1814" translate="yes" xml:space="preserve">
          <source>test.skip()</source>
          <target state="translated">test.skip()</target>
        </trans-unit>
        <trans-unit id="f1d908eaf6e6e7fa35622b4b43d6a8af1a3c660e" translate="yes" xml:space="preserve">
          <source>test.skip.each()</source>
          <target state="translated">test.skip.each()</target>
        </trans-unit>
        <trans-unit id="74875a7933e712e5381bd416043bfb0b6616a91e" translate="yes" xml:space="preserve">
          <source>test.todo()</source>
          <target state="translated">test.todo()</target>
        </trans-unit>
        <trans-unit id="f4cea10a1c0dc3c50965ee387dece60500be5cff" translate="yes" xml:space="preserve">
          <source>to match a property in &lt;code&gt;objectContaining&lt;/code&gt; or &lt;code&gt;toMatchObject&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;objectContaining&lt;/code&gt; または &lt;code&gt;toMatchObject&lt;/code&gt; のプロパティを照合する</target>
        </trans-unit>
        <trans-unit id="b1d3d79ec58192bdcdaff5e0ab0b7fbca133543f" translate="yes" xml:space="preserve">
          <source>to match an element in &lt;code&gt;arrayContaining&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;arrayContaining&lt;/code&gt; の要素に一致させる</target>
        </trans-unit>
        <trans-unit id="3556cfc1ba0721081f3f93c076211e40ef1a22b9" translate="yes" xml:space="preserve">
          <source>transformIgnorePatterns customization</source>
          <target state="translated">トランスフォーム無視パターンのカスタマイズ</target>
        </trans-unit>
        <trans-unit id="fc220be1ad7bd8b6a9feda6f6ba1285b333e98e2" translate="yes" xml:space="preserve">
          <source>vscode-jest</source>
          <target state="translated">vscode-jest</target>
        </trans-unit>
        <trans-unit id="5218cb6aea807d0d643ecaa0be3719b154b08685" translate="yes" xml:space="preserve">
          <source>webpack 2 offers native support for ES modules. However, Jest runs in Node, and thus requires ES modules to be transpiled to CommonJS modules. As such, if you are using webpack 2, you most likely will want to configure Babel to transpile ES modules to CommonJS modules only in the &lt;code&gt;test&lt;/code&gt; environment.</source>
          <target state="translated">webpack 2は、ESモジュールのネイティブサポートを提供します。ただし、JestはNodeで実行されるため、ESモジュールをCommonJSモジュールにトランスパイルする必要があります。そのため、webpack 2を使用している場合は、 &lt;code&gt;test&lt;/code&gt; 環境でのみESモジュールをCommonJSモジュールにトランスパイルするようにBabelを構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="5ebedacdf66fa11ed6c1f1cd9d9b0e19efbf3b58" translate="yes" xml:space="preserve">
          <source>you can use:</source>
          <target state="translated">を使うことができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
