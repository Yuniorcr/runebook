<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="04adad35ca195632fb236b9657e9704ced9d2d7c" translate="yes" xml:space="preserve">
          <source>We think it is better to offer a &lt;a href=&quot;faq-versioning#commitment-to-stability&quot;&gt;gradual migration strategy&lt;/a&gt; than to make huge breaking changes &amp;mdash; or to let React stagnate into irrelevance.</source>
          <target state="translated">私たちは、重大な重大な変更を加えるよりも、&lt;a href=&quot;faq-versioning#commitment-to-stability&quot;&gt;段階的な移行戦略&lt;/a&gt;を提供する方がよいと考えています。あるいは、Reactを無意味に停滞させるのです。</target>
        </trans-unit>
        <trans-unit id="9950cb366a5eeff7d38fd73f4a0d3de60ab1d902" translate="yes" xml:space="preserve">
          <source>We used an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; above, but it also works with regular functions:</source>
          <target state="translated">上記の&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;アロー関数&lt;/a&gt;を使用しましたが、通常の関数でも機能します。</target>
        </trans-unit>
        <trans-unit id="7d06765809acf74687f0fa91ffe1041b5eaa0934" translate="yes" xml:space="preserve">
          <source>We wait&amp;hellip;</source>
          <target state="translated">待ってる&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="883db07b441bd1cc42aaa22c4d8c5fa1d14f3d84" translate="yes" xml:space="preserve">
          <source>We want to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;set up a timer&lt;/a&gt; whenever the &lt;code&gt;Clock&lt;/code&gt; is rendered to the DOM for the first time. This is called &amp;ldquo;mounting&amp;rdquo; in React.</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; が初めてDOMにレンダリングされるときはいつでも&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;タイマー&lt;/a&gt;を設定したいと思います。これは、Reactでは「マウント」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="e60a58cd26da36dc6344202c0599d60697f33fbb" translate="yes" xml:space="preserve">
          <source>We will attach a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; to the root DOM element. Inside &lt;code&gt;componentDidMount&lt;/code&gt;, we will get a reference to it so we can pass it to the jQuery plugin.</source>
          <target state="translated">ルートDOM要素に&lt;a href=&quot;refs-and-the-dom&quot;&gt;参照&lt;/a&gt;を添付します。 &lt;code&gt;componentDidMount&lt;/code&gt; 内で、その参照を取得して、jQueryプラグインに渡すことができるようにします。</target>
        </trans-unit>
        <trans-unit id="e74b07ae6f3f43fb223a13322a5557fa91ee2240" translate="yes" xml:space="preserve">
          <source>We will explain these steps below in detail.</source>
          <target state="translated">以下、これらの手順を詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="727da5b71551ddb95c401e73e8e543adf070a83e" translate="yes" xml:space="preserve">
          <source>We will explore rendering React elements to the DOM in the next section.</source>
          <target state="translated">次のセクションでは、React要素をDOMにレンダリングする方法を探っていきます。</target>
        </trans-unit>
        <trans-unit id="971788bde50fd928ed6ba8e3bf2b7bb52780ffe5" translate="yes" xml:space="preserve">
          <source>We will implement it as an &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled component&lt;/a&gt; for simplicity.</source>
          <target state="translated">簡単にするために、&lt;a href=&quot;uncontrolled-components&quot;&gt;制御&lt;/a&gt;されていないコンポーネントとして実装します。</target>
        </trans-unit>
        <trans-unit id="1a236deb13b0671afe90e0152c0f4b89aa0714eb" translate="yes" xml:space="preserve">
          <source>We will later add the timer code back to the component itself.</source>
          <target state="translated">後日、タイマーのコードをコンポーネント自体に追加します。</target>
        </trans-unit>
        <trans-unit id="b0a6b047e5052fd0d39b2c6745d932b87cc1c444" translate="yes" xml:space="preserve">
          <source>We will move the &lt;code&gt;date&lt;/code&gt; from props to state in three steps:</source>
          <target state="translated">3つのステップで &lt;code&gt;date&lt;/code&gt; を小道具から状態に移動します。</target>
        </trans-unit>
        <trans-unit id="c76792b9c2d19f72980bcb3b0acff6bb2647f253" translate="yes" xml:space="preserve">
          <source>We will now add a brand new feature to the profile page &amp;mdash; a list of fun facts about a person:</source>
          <target state="translated">次に、プロフィールページにまったく新しい機能を追加します。これは、人物に関する楽しい事実のリストです。</target>
        </trans-unit>
        <trans-unit id="0dbb37dfdc07e84f9e43a35660e37fc112399531" translate="yes" xml:space="preserve">
          <source>We will post to the &lt;a href=&quot;https://reactjs.org/blog&quot;&gt;React blog&lt;/a&gt; when we&amp;rsquo;re ready to announce new experiments, but that doesn&amp;rsquo;t mean we will publicize every experiment.</source>
          <target state="translated">新しい実験を発表する準備ができたら、&lt;a href=&quot;https://reactjs.org/blog&quot;&gt;Reactブログ&lt;/a&gt;に投稿しますが、すべての実験を公表するわけではありません。</target>
        </trans-unit>
        <trans-unit id="2a8482ef7156081f1581eefc773bc336f6981bd6" translate="yes" xml:space="preserve">
          <source>We will start with a component called &lt;code&gt;BoilingVerdict&lt;/code&gt;. It accepts the &lt;code&gt;celsius&lt;/code&gt; temperature as a prop, and prints whether it is enough to boil the water:</source>
          <target state="translated">&lt;code&gt;BoilingVerdict&lt;/code&gt; というコンポーネントから始めます。 &lt;code&gt;celsius&lt;/code&gt; 温度を小道具として受け入れ、水を沸騰させるのに十分かどうかを出力します。</target>
        </trans-unit>
        <trans-unit id="dadee525eff6a00a825d77ee71e7e982946df9ab" translate="yes" xml:space="preserve">
          <source>We will store the current input&amp;rsquo;s &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; in its local state. This is the state we &amp;ldquo;lifted up&amp;rdquo; from the inputs, and it will serve as the &amp;ldquo;source of truth&amp;rdquo; for both of them. It is the minimal representation of all the data we need to know in order to render both inputs.</source>
          <target state="translated">現在の入力の &lt;code&gt;temperature&lt;/code&gt; と &lt;code&gt;scale&lt;/code&gt; をローカル状態で保存します。これは、入力から「持ち上げた」状態であり、両方の「真実の源」として機能します。これは、両方の入力をレンダリングするために知る必要があるすべてのデータの最小限の表現です。</target>
        </trans-unit>
        <trans-unit id="d01910e116749e98643c489148eb7de5ffdd9fe0" translate="yes" xml:space="preserve">
          <source>We will tear down the timer in the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method:</source>
          <target state="translated">タイマーを &lt;code&gt;componentWillUnmount()&lt;/code&gt; ライフサイクルメソッドで破棄します。</target>
        </trans-unit>
        <trans-unit id="e654907385791ce9020004666c8f0606387ea52d" translate="yes" xml:space="preserve">
          <source>We will use them right below.</source>
          <target state="translated">すぐ下で使います。</target>
        </trans-unit>
        <trans-unit id="8554f0c6b7512278a4491bcbd1d0b8d3364d7dec" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t pass &lt;code&gt;this.props.onChange&lt;/code&gt; directly to Chosen because component&amp;rsquo;s props might change over time, and that includes event handlers. Instead, we will declare a &lt;code&gt;handleChange()&lt;/code&gt; method that calls &lt;code&gt;this.props.onChange&lt;/code&gt;, and subscribe it to the jQuery &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">&lt;code&gt;this.props.onChange&lt;/code&gt; を直接Chosenに渡さないでください。これは、コンポーネントのプロップが時間とともに変化する可能性があり、それにはイベントハンドラーが含まれているためです。代わりに、 &lt;code&gt;handleChange()&lt;/code&gt; を呼び出す &lt;code&gt;this.props.onChange&lt;/code&gt; （）メソッドを宣言し、それをjQuery &lt;code&gt;change&lt;/code&gt; イベントにサブスクライブします。</target>
        </trans-unit>
        <trans-unit id="1dca911b430b3370f62cdffc47de7a06fdd5c7b6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll address this in two steps:</source>
          <target state="translated">2つのステップでこれに対処します。</target>
        </trans-unit>
        <trans-unit id="e57f940373fd0c5266442a10be93fdb7e4add9cd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue this page with an in-depth look at some aspects of &lt;code&gt;useEffect&lt;/code&gt; that experienced React users will likely be curious about. Don&amp;rsquo;t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.</source>
          <target state="translated">このページでは、経験豊富なReactユーザーが興味を持つ可能性のある &lt;code&gt;useEffect&lt;/code&gt; のいくつかの側面を詳しく見ていきます。今それらを掘り下げる義務を感じてはいけない。いつでもこのページに戻って、エフェクトフックの詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="06cbd6e1d166c852966f9e06d4a20311c24f2202" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a &lt;code&gt;Greeting&lt;/code&gt; component that displays either of these components depending on whether a user is logged in:</source>
          <target state="translated">ユーザーがログインしているかどうかに応じて、これらのコンポーネントのいずれかを表示する &lt;code&gt;Greeting&lt;/code&gt; コンポーネントを作成します。</target>
        </trans-unit>
        <trans-unit id="949801e315854c5c1f32189a838ce3882724d1cc" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss this more in &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks&lt;/a&gt;.</source>
          <target state="translated">これについては、&lt;a href=&quot;hooks-custom&quot;&gt;独自のフックの作成で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="480d6951f304afe90e50d8db2ae84d223b006104" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss this more in &lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;Using the Effect Hook&lt;/a&gt;.</source>
          <target state="translated">これについて&lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;は、エフェクトフックの使用で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="127966720e15953e98cccc3796d46bce910c94fb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start learning about Hooks by comparing this code to an equivalent class example.</source>
          <target state="translated">このコードを同等のクラスの例と比較することにより、フックについて学習します。</target>
        </trans-unit>
        <trans-unit id="2e722f3732f23870f1c4ff8fe747d22265714de2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test it using React DOM. To make sure that the behavior matches what happens in the browser, we&amp;rsquo;ll wrap the code rendering and updating it into &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;ReactTestUtils.act()&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">React DOMを使用してテストします。動作がブラウザーで発生する動作と一致することを確認するために、コードのレンダリングをラップして、&lt;a href=&quot;test-utils#act&quot;&gt; &lt;code&gt;ReactTestUtils.act()&lt;/code&gt; &lt;/a&gt;呼び出しに更新します。</target>
        </trans-unit>
        <trans-unit id="a76fcdcb61157f6e0610c1005c5c3f29ebd7936e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll wrap that state update into &lt;code&gt;startTransition&lt;/code&gt;. That&amp;rsquo;s how we tell React &lt;strong&gt;we don&amp;rsquo;t mind React delaying that state update&lt;/strong&gt; if it leads to an undesirable loading state:</source>
          <target state="translated">その状態更新を &lt;code&gt;startTransition&lt;/code&gt; にラップします。このようにして、Reactが望ましくない読み込み状態につながる場合でも&lt;strong&gt;、Reactがその状態の更新を遅らせても問題ないこと&lt;/strong&gt;を伝えます。</target>
        </trans-unit>
        <trans-unit id="cb815fabe0b5ab52d41ee9b7ea186de1f4f0109c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re &lt;strong&gt;using npm here only to install the JSX preprocessor;&lt;/strong&gt; you won&amp;rsquo;t need it for anything else. Both React and the application code can stay as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags with no changes.</source>
          <target state="translated">ここでは&lt;strong&gt;、npmを使用してJSXプリプロセッサをインストールしています。&lt;/strong&gt;他には何も必要ありません。Reactもアプリケーションコードも、変更を加えることなく &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグのままにすることができます。</target>
        </trans-unit>
        <trans-unit id="5b0310a310cf06f594a40e03c38a430ad9503681" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re Still Figuring This Out</source>
          <target state="translated">私たちはまだこれを理解しています</target>
        </trans-unit>
        <trans-unit id="ed67ce78b0f3e99b0d082bb50f326185eb0b81b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also starting to see how Hooks solve problems outlined in &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation&lt;/a&gt;. We&amp;rsquo;ve seen how effect cleanup avoids duplication in &lt;code&gt;componentDidUpdate&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;, brings related code closer together, and helps us avoid bugs. We&amp;rsquo;ve also seen how we can separate effects by their purpose, which is something we couldn&amp;rsquo;t do in classes at all.</source>
          <target state="translated">また、&lt;a href=&quot;hooks-intro#motivation&quot;&gt;モチベーションで&lt;/a&gt;概説されている問題をフックがどのように解決するかを確認し始めています。エフェクトのクリーンアップによって、 &lt;code&gt;componentDidUpdate&lt;/code&gt; と &lt;code&gt;componentWillUnmount&lt;/code&gt; の重複が回避され、関連するコードが互いに接近し、バグを回避するのに役立つことがわかりました。また、目的によって効果を分離する方法も見てきました。これは、クラスではまったく実行できなかったものです。</target>
        </trans-unit>
        <trans-unit id="6da9903b5d3ba7eb4397ce158c0f6108377a0f35" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using &lt;code&gt;isPending&lt;/code&gt; to communicate the state transition progress to the user and to disable the button.</source>
          <target state="translated">私たちは、使用している &lt;code&gt;isPending&lt;/code&gt; ユーザーに状態遷移の進行状況を伝えるために、ボタンを無効にします。</target>
        </trans-unit>
        <trans-unit id="6735373f84ab2dadb0420bcc149f487be0787431" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using this code in production (and it works for us) but there are still some bugs, missing features, and gaps in the documentation. We&amp;rsquo;d like to hear more about what breaks in Concurrent Mode so we can better prepare it for an official stable release in the future.</source>
          <target state="translated">このコードは本番環境で使用しています（私たちにとっても機能します）が、まだいくつかのバグ、不足している機能、ドキュメントのギャップがあります。今後の正式な安定版リリースに向けてより適切に準備できるように、コンカレントモードの不具合について詳しくお聞きしたいと思います。</target>
        </trans-unit>
        <trans-unit id="1092279dfe88e8ae37dd255b457e80f4fcd016f8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already kicked off the requests in &lt;code&gt;fetchProfileData()&lt;/code&gt;. It gave us a special &amp;ldquo;resource&amp;rdquo; instead of a Promise. In a realistic example, it would be provided by our data library&amp;rsquo;s Suspense integration, like Relay.</source>
          <target state="translated">&lt;code&gt;fetchProfileData()&lt;/code&gt; でリクエストを開始しました。それは私たちに約束の代わりに特別な「リソース」を与えました。現実的な例では、Relayなどのデータライブラリのサスペンス統合によって提供されます。</target>
        </trans-unit>
        <trans-unit id="d3fc6ac18f17043ca4acd94bf8d17f2db51154a1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen this example at the top of this page, but let&amp;rsquo;s take a closer look at it:</source>
          <target state="translated">このページの上部ですでにこの例を見てきましたが、詳しく見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e057c5796230f4d10c4ca87533025e33e8d57483" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already used &lt;code&gt;startTransition&lt;/code&gt; to wrap the state update. Now we&amp;rsquo;re going to use &lt;code&gt;isPending&lt;/code&gt; too. React gives this boolean to us so we can tell whether &lt;strong&gt;we&amp;rsquo;re currently waiting for this transition to finish&lt;/strong&gt;. We&amp;rsquo;ll use it to indicate that something is happening:</source>
          <target state="translated">&lt;code&gt;startTransition&lt;/code&gt; を使用して状態の更新をラップしました。次に、 &lt;code&gt;isPending&lt;/code&gt; も使用します。Reactはこのブール値を私たちに提供するので&lt;strong&gt;、この遷移が終了&lt;/strong&gt;するの&lt;strong&gt;を現在待っている&lt;/strong&gt;かどうか&lt;strong&gt;を&lt;/strong&gt;知ることができます。これを使用して、何かが起こっていることを示します。</target>
        </trans-unit>
        <trans-unit id="9aced3aa1f133d3833efd40f37731bb88c66df03" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve fixed the first problem (suspending outside of a transition). But now because of the transition, our state doesn&amp;rsquo;t update immediately, and it can&amp;rsquo;t &amp;ldquo;drive&amp;rdquo; a controlled input!</source>
          <target state="translated">最初の問題を修正しました（トランジション外で中断）。しかし、遷移のために、状態はすぐに更新されず、制御された入力を「駆動」できません。</target>
        </trans-unit>
        <trans-unit id="82123073614b7e2a1707ace493cbc03906ee8fa4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve found that most people don&amp;rsquo;t enjoy manually passing callbacks through every level of a component tree. Even though it is more explicit, it can feel like a lot of &amp;ldquo;plumbing&amp;rdquo;.</source>
          <target state="translated">ほとんどの人は、コンポーネントツリーのすべてのレベルで手動でコールバックを渡すことを楽しんでいないことがわかりました。それはより明白ですが、それは多くの「配管」のように感じることができます。</target>
        </trans-unit>
        <trans-unit id="20a8f1d5554de07fa29800d8a4ff750db37e3153" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve imported the &lt;code&gt;useTransition&lt;/code&gt; Hook and used it the component that updates the state.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; フックをインポートし、状態を更新するコンポーネントを使用しました。</target>
        </trans-unit>
        <trans-unit id="f001cf0b3f4cc8ba635fdca602bd1a42ea0135b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve learned that &lt;code&gt;useEffect&lt;/code&gt; lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; を使用すると、コンポーネントのレンダリング後にさまざまな種類の副作用を表現できることがわかりました。一部の効果は、関数を返すようにクリーンアップが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="78fbd837f605a563c276531668570643feff866d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered the basics of Suspense for Data Fetching! Importantly, we now better understand &lt;em&gt;why&lt;/em&gt; Suspense works this way, and how it fits into the data fetching space.</source>
          <target state="translated">これで、データフェッチ用のサスペンスの基本について説明しました。重要なのは、Suspenseがこのように機能する&lt;em&gt;理由&lt;/em&gt;と、それがデータフェッチングスペースにどのように適合するかについての理解が深まったことです。</target>
        </trans-unit>
        <trans-unit id="b9d77fbf8650ce9fdf27f7587fe7efc208425285" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve often had to maintain components that started out simple but grew into an unmanageable mess of stateful logic and side effects. Each lifecycle method often contains a mix of unrelated logic. For example, components might perform some data fetching in &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, the same &lt;code&gt;componentDidMount&lt;/code&gt; method might also contain some unrelated logic that sets up event listeners, with cleanup performed in &lt;code&gt;componentWillUnmount&lt;/code&gt;. Mutually related code that changes together gets split apart, but completely unrelated code ends up combined in a single method. This makes it too easy to introduce bugs and inconsistencies.</source>
          <target state="translated">単純なものから始まって、ステートフルなロジックと副作用の管理できない混乱に発展したコンポーネントを維持する必要がしばしばありました。多くの場合、各ライフサイクルメソッドには、関連のないロジックが混在しています。たとえば、コンポーネントは、 &lt;code&gt;componentDidMount&lt;/code&gt; と &lt;code&gt;componentDidUpdate&lt;/code&gt; でデータのフェッチを実行する場合があります。ただし、同じ &lt;code&gt;componentDidMount&lt;/code&gt; メソッドには、イベントリスナーを設定する無関係なロジックが含まれている場合があり、クリーンアップは &lt;code&gt;componentWillUnmount&lt;/code&gt; で実行されます。一緒に変更される相互に関連するコードは分割されますが、完全に関連のないコードは1つのメソッドに結合されます。これにより、バグや不整合が発生しやすくなります。</target>
        </trans-unit>
        <trans-unit id="37efc1571cdaa97dd3e90e2682390ebf13fff680" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to stay on the previous screen for at most 3 seconds.</source>
          <target state="translated">前の画面に最大3秒間留まるために &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; を渡しました。</target>
        </trans-unit>
        <trans-unit id="f3cab8c9ea1114a4c30f14c35d44b604fb9099d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve prepared a &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ page&lt;/a&gt; that answers the most common questions about Hooks.</source>
          <target state="translated">&lt;a href=&quot;hooks-faq&quot;&gt;フックに関する&lt;/a&gt;最も一般的な質問に答えるフックのFAQページを用意しました。</target>
        </trans-unit>
        <trans-unit id="602a0253fdc011ba6ec4f21c8ecf132af5c3bcd0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve said before that Concurrent Mode is like React working &amp;ldquo;on a branch&amp;rdquo;. Branches are useful not only for short-term fixes, but also for long-running features. Sometimes you might work on a feature, but it could take weeks before it&amp;rsquo;s in a &amp;ldquo;good enough state&amp;rdquo; to merge into master. This side of our version control metaphor applies to rendering too.</source>
          <target state="translated">以前に、コンカレントモードはReactが「ブランチで」動作しているようなものだと述べました。ブランチは、短期的な修正だけでなく、長時間実行される機能にも役立ちます。機能に取り組んでいる場合もありますが、マスターにマージするのに「十分な状態」になるまでに数週間かかる場合があります。バージョン管理のメタファーのこちら側は、レンダリングにも適用されます。</target>
        </trans-unit>
        <trans-unit id="8bc522ebd2ef515724e353941f7b4486ad297dcb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve solved the previous network &amp;ldquo;waterfall&amp;rdquo;, but accidentally introduced a different one. We wait for &lt;em&gt;all&lt;/em&gt; data to come back with &lt;code&gt;Promise.all()&lt;/code&gt; inside &lt;code&gt;fetchProfileData&lt;/code&gt;, so now we can&amp;rsquo;t render profile details until the posts have been fetched too. We have to wait for both.</source>
          <target state="translated">以前のネットワーク「ウォーターフォール」を解決しましたが、誤って別のネットワークを導入しました。以下のために私たちは待って&lt;em&gt;、すべて&lt;/em&gt;のデータがで戻ってきて &lt;code&gt;Promise.all()&lt;/code&gt; 内の &lt;code&gt;fetchProfileData&lt;/code&gt; の記事があまりにもフェッチされるまで今、我々はプロフィールの詳細をレンダリングすることはできません。両方を待つ必要があります。</target>
        </trans-unit>
        <trans-unit id="fc4e74fbf1eee3d969dbfb73e0089d683c0dcc2e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve wrapped our state update into &lt;code&gt;startTransition&lt;/code&gt; to tell React it&amp;rsquo;s okay to delay it.</source>
          <target state="translated">状態の更新を &lt;code&gt;startTransition&lt;/code&gt; にラップして、Reactに遅延しても大丈夫であることを伝えました。</target>
        </trans-unit>
        <trans-unit id="7d934364c9313824f6e77d311ab14f3ddd86f222" translate="yes" xml:space="preserve">
          <source>Web Components</source>
          <target state="translated">ウェブコンポーネント</target>
        </trans-unit>
        <trans-unit id="89462d36c40b3b8c651a2fecd29c6a47d67d8652" translate="yes" xml:space="preserve">
          <source>Web Components often expose an imperative API. For instance, a &lt;code&gt;video&lt;/code&gt; Web Component might expose &lt;code&gt;play()&lt;/code&gt; and &lt;code&gt;pause()&lt;/code&gt; functions. To access the imperative APIs of a Web Component, you will need to use a ref to interact with the DOM node directly. If you are using third-party Web Components, the best solution is to write a React component that behaves as a wrapper for your Web Component.</source>
          <target state="translated">多くの場合、Webコンポーネントは命令型APIを公開します。たとえば、 &lt;code&gt;video&lt;/code&gt; Webコンポーネントは、 &lt;code&gt;play()&lt;/code&gt; および &lt;code&gt;pause()&lt;/code&gt; 関数を公開する場合があります。Webコンポーネントの命令型APIにアクセスするには、refを使用してDOMノードと直接対話する必要があります。サードパーティのWebコンポーネントを使用している場合、最善の解決策は、Webコンポーネントのラッパーとして動作するReactコンポーネントを作成することです。</target>
        </trans-unit>
        <trans-unit id="e00b9f789bd874e0ed643701b463e09b446cea8c" translate="yes" xml:space="preserve">
          <source>Web accessibility (also referred to as &lt;a href=&quot;https://en.wiktionary.org/wiki/a11y&quot;&gt;&lt;strong&gt;a11y&lt;/strong&gt;&lt;/a&gt;) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages.</source>
          <target state="translated">Webアクセシビリティ（&lt;a href=&quot;https://en.wiktionary.org/wiki/a11y&quot;&gt;&lt;strong&gt;a11y&lt;/strong&gt;&lt;/a&gt;とも呼ばれ&lt;strong&gt;ます&lt;/strong&gt;）は、誰もが使用できるWebサイトの設計と作成です。支援技術がWebページを解釈できるようにするには、アクセシビリティーのサポートが必要です。</target>
        </trans-unit>
        <trans-unit id="92d4811d4665c317fc3c6c88f65cc53f18cc4519" translate="yes" xml:space="preserve">
          <source>WebAIM - Color Contrast Checker</source>
          <target state="translated">WebAIM-カラーコントラストチェッカー</target>
        </trans-unit>
        <trans-unit id="f16c2ab8bf1a5aa2f65c3997b33b403520906211" translate="yes" xml:space="preserve">
          <source>WebAIM - Document Language</source>
          <target state="translated">WebAIM-ドキュメント言語</target>
        </trans-unit>
        <trans-unit id="433235ab1e74117e5fc4f15627618af7d9236d56" translate="yes" xml:space="preserve">
          <source>WebAIM - Skip Navigation Links</source>
          <target state="translated">WebAIM-ナビゲーションリンクをスキップ</target>
        </trans-unit>
        <trans-unit id="3352c721cf8b15e3c5ba7494a77646493b7d5d12" translate="yes" xml:space="preserve">
          <source>WebAIM - Using JAWS to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-JAWSを使ったWebアクセシビリティの評価</target>
        </trans-unit>
        <trans-unit id="0fc47857541ad45199770ccef6d4b96d6599031d" translate="yes" xml:space="preserve">
          <source>WebAIM - Using NVDA to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-NVDAを使用したWebアクセシビリティの評価</target>
        </trans-unit>
        <trans-unit id="813fcd4a26c1f886c1d65397d9ec24b2e1c6f3ee" translate="yes" xml:space="preserve">
          <source>WebAIM - Using VoiceOver to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-VoiceOverを使ったWebアクセシビリティの評価</target>
        </trans-unit>
        <trans-unit id="30fc76fba519e636eb93a339a1826e6626a74fa8" translate="yes" xml:space="preserve">
          <source>WebAIM WAVE</source>
          <target state="translated">WebAIM WAVE</target>
        </trans-unit>
        <trans-unit id="c6dd3413876261d9d5dfa5f7c1dc00a9a234d113" translate="yes" xml:space="preserve">
          <source>WebAIM looks at form validation</source>
          <target state="translated">WebAIMはフォームのバリデーションに注目</target>
        </trans-unit>
        <trans-unit id="9a2d1a6a5c28bcf72a8eb9de74d12f7b9c20191c" translate="yes" xml:space="preserve">
          <source>WebAIM shows us how to label elements</source>
          <target state="translated">WebAIM は、要素にラベルを付ける方法を示しています。</target>
        </trans-unit>
        <trans-unit id="fc2e6cbaeaac02696deef92a72e32fd4e674290a" translate="yes" xml:space="preserve">
          <source>WebAIM talks about keyboard accessibility</source>
          <target state="translated">WebAIMがキーボードアクセシビリティについて語る</target>
        </trans-unit>
        <trans-unit id="122c8865b61493b6f789d0524edf7ac87efe4d03" translate="yes" xml:space="preserve">
          <source>Webpack v4+ will minify your code by default in production mode.</source>
          <target state="translated">Webpack v4+は、本番モードではデフォルトでコードをミニ化します。</target>
        </trans-unit>
        <trans-unit id="91b3f9b7f9ed1db7fbbff897990621a1f329c6b8" translate="yes" xml:space="preserve">
          <source>What Counts as a Breaking Change?</source>
          <target state="translated">壊れる変化として何がカウントされるのか?</target>
        </trans-unit>
        <trans-unit id="306cd9673550a7548afb1d28d13a9e4ab675260a" translate="yes" xml:space="preserve">
          <source>What Goes Into an Experimental Release?</source>
          <target state="translated">実験的リリースには何が必要ですか?</target>
        </trans-unit>
        <trans-unit id="c1c5f3b99c4945dd281accfdc44da90d90092580" translate="yes" xml:space="preserve">
          <source>What If I Don&amp;rsquo;t Use Relay?</source>
          <target state="translated">リレーを使用しない場合はどうなりますか？</target>
        </trans-unit>
        <trans-unit id="8f3ce40e7f755e7f9bd29a4ca2ef4eb8d9b5ec5b" translate="yes" xml:space="preserve">
          <source>What Is Concurrent Mode?</source>
          <target state="translated">コンカレントモードとは?</target>
        </trans-unit>
        <trans-unit id="3a27620fdbb167ecbd14c72dcff5ace0f1c64383" translate="yes" xml:space="preserve">
          <source>What Is Suspense, Exactly?</source>
          <target state="translated">サスペンスとは、正確には何か?</target>
        </trans-unit>
        <trans-unit id="e8a22cac534b1f2cd30ed5f98b635c16f790eab2" translate="yes" xml:space="preserve">
          <source>What Suspense Is Not</source>
          <target state="translated">サスペンスではないもの</target>
        </trans-unit>
        <trans-unit id="c783af8d30d3e4364690860bb0374ea57809d4d3" translate="yes" xml:space="preserve">
          <source>What Suspense Lets You Do</source>
          <target state="translated">サスペンスがやらせてくれること</target>
        </trans-unit>
        <trans-unit id="07167e206dc36076e1208fc57a82343e684c51c1" translate="yes" xml:space="preserve">
          <source>What can I do if my effect dependencies change too often?</source>
          <target state="translated">効果の依存関係が頻繁に変わる場合はどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="1cc6659d6c04ea72141e5d4aadbf96b176eef644" translate="yes" xml:space="preserve">
          <source>What can I do with Hooks that I couldn&amp;rsquo;t with classes?</source>
          <target state="translated">クラスではできなかったフックで何ができますか？</target>
        </trans-unit>
        <trans-unit id="cd3446a7312aac2facf235718a5ffd50e69c7d4a" translate="yes" xml:space="preserve">
          <source>What do Hooks mean for popular APIs like Redux &lt;code&gt;connect()&lt;/code&gt; and React Router?</source>
          <target state="translated">Redux &lt;code&gt;connect()&lt;/code&gt; やReact Router などの人気のあるAPIのフックは何を意味しますか？</target>
        </trans-unit>
        <trans-unit id="f691d89eec058d6953da17f694984d9b247497b5" translate="yes" xml:space="preserve">
          <source>What do Hooks mean for popular APIs like Redux connect() and React Router?</source>
          <target state="translated">Redux connect()やReact Routerのような人気のあるAPIのHooksは何を意味しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="319d6cb4f612b1898af74f1d58e55bb9a00c7f16" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;const [thing, setThing] = useState()&lt;/code&gt; mean?</source>
          <target state="translated">何をしない &lt;code&gt;const [thing, setThing] = useState()&lt;/code&gt; 意味ですか？</target>
        </trans-unit>
        <trans-unit id="64945305af0a0fa7d3c6dbaa11aaf7b00d606169" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;setState&lt;/code&gt; do?</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; は何をしますか？</target>
        </trans-unit>
        <trans-unit id="f8684f51532e8049d48a76354c4c251f1768106b" translate="yes" xml:space="preserve">
          <source>What does const [thing, setThing] = useState() mean?</source>
          <target state="translated">const [that,setThing]=useState()の意味は?</target>
        </trans-unit>
        <trans-unit id="b4f867b8bb7e53e8c3b6611c9f1d46df6d3e89f0" translate="yes" xml:space="preserve">
          <source>What exactly do the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;lint rules&lt;/a&gt; enforce?</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;lintルール&lt;/a&gt;は正確に何を強制するのですか？</target>
        </trans-unit>
        <trans-unit id="07ef000a203cb6f931243d3fceed10fdf912e2fc" translate="yes" xml:space="preserve">
          <source>What exactly do the lint rules enforce?</source>
          <target state="translated">糸くずのルールは具体的に何を強制しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e3b196d959a7d912e75414dca815d74e2142c718" translate="yes" xml:space="preserve">
          <source>What if we want to show a spinner in a different place than &amp;ldquo;above&amp;rdquo; the component in a tree?</source>
          <target state="translated">ツリーのコンポーネントの「上」とは別の場所にスピナーを表示したい場合はどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="d37eb6cbe5fc394050b5ba4dd59e15bb9146d921" translate="yes" xml:space="preserve">
          <source>What is &amp;ldquo;React Fiber&amp;rdquo;?</source>
          <target state="translated">「リアクトファイバー」とは？</target>
        </trans-unit>
        <trans-unit id="126626903bfa28709f9dc97154ed4c6b318643af" translate="yes" xml:space="preserve">
          <source>What is CSS-in-JS?</source>
          <target state="translated">CSS-in-JSとは?</target>
        </trans-unit>
        <trans-unit id="b9b10ee223edff6297e6ec9600bac8dd2ffc48ff" translate="yes" xml:space="preserve">
          <source>What is the Virtual DOM?</source>
          <target state="translated">仮想DOMとは何ですか?</target>
        </trans-unit>
        <trans-unit id="44ad1d597a94eb0351fcc2bab4f5bc2476770773" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; と &lt;code&gt;props&lt;/code&gt; はどう違いますか？</target>
        </trans-unit>
        <trans-unit id="2153ca8a7eb6c240a2df099c7e84b57dedd442bd" translate="yes" xml:space="preserve">
          <source>What is the difference between passing an object or a function in &lt;code&gt;setState&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; でオブジェクトまたは関数を渡すことの違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="ad6b021f6d6be586c97a85a04cd00cea15ecc6a0" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a response? Should caching be global or local? Who manages the cache?</source>
          <target state="translated">レスポンスの寿命とは何ですか?キャッシュはグローバルかローカルか?キャッシュを管理するのは誰ですか?</target>
        </trans-unit>
        <trans-unit id="a7846b7c3a9328a7abfc787060ce35a9d897ee0d" translate="yes" xml:space="preserve">
          <source>What is the prior art for Hooks?</source>
          <target state="translated">フックの先行技術とは?</target>
        </trans-unit>
        <trans-unit id="84fa9a10d5b5938a5cfd5dcd3fbd211cd8ea85e2" translate="yes" xml:space="preserve">
          <source>What to Expect</source>
          <target state="translated">何を期待するか</target>
        </trans-unit>
        <trans-unit id="e9a68218a8babe539cd10930840d839404a2a222" translate="yes" xml:space="preserve">
          <source>What would the equivalent of composing GraphQL queries look like for arbitrary Suspense data?</source>
          <target state="translated">任意のサスペンスデータに対して、GraphQL クエリを構成することに相当するものは、どのようなものでしょうか?</target>
        </trans-unit>
        <trans-unit id="2482c806af9f88ec9421505cdbfb9c23ef1bde71" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Hook?</source>
          <target state="translated">フックとは？</target>
        </trans-unit>
        <trans-unit id="c0a7cdef0637bc5ca89d70c3638524e01a053b8e" translate="yes" xml:space="preserve">
          <source>Wheel Events</source>
          <target state="translated">ホイールイベント</target>
        </trans-unit>
        <trans-unit id="83b5d183aae32b6135d8bdcde578d304743623d8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; is passed to &lt;code&gt;ReactDOM.render()&lt;/code&gt;, React calls the constructor of the &lt;code&gt;Clock&lt;/code&gt; component. Since &lt;code&gt;Clock&lt;/code&gt; needs to display the current time, it initializes &lt;code&gt;this.state&lt;/code&gt; with an object including the current time. We will later update this state.</source>
          <target state="translated">場合 &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; に渡され &lt;code&gt;ReactDOM.render()&lt;/code&gt; 、呼び出しのコンストラクタ反応させ &lt;code&gt;Clock&lt;/code&gt; 成分。ので、 &lt;code&gt;Clock&lt;/code&gt; 、現在時刻を表示する必要があり、それが初期化 &lt;code&gt;this.state&lt;/code&gt; を現在時刻を含むオブジェクトです。後でこの状態を更新します。</target>
        </trans-unit>
        <trans-unit id="adb220ab22b57e8d612d3d8256e10868b648ed39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CommentListWithSubscription&lt;/code&gt; and &lt;code&gt;BlogPostWithSubscription&lt;/code&gt; are rendered, &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt; will be passed a &lt;code&gt;data&lt;/code&gt; prop with the most current data retrieved from &lt;code&gt;DataSource&lt;/code&gt;:</source>
          <target state="translated">とき &lt;code&gt;CommentListWithSubscription&lt;/code&gt; と &lt;code&gt;BlogPostWithSubscription&lt;/code&gt; がレンダリングされ、 &lt;code&gt;CommentList&lt;/code&gt; と &lt;code&gt;BlogPost&lt;/code&gt; 渡される &lt;code&gt;data&lt;/code&gt; から取得した最新のデータとの小道具 &lt;code&gt;DataSource&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="f63f5b998c37b2aac7d34a276c80403e6fbede6f" translate="yes" xml:space="preserve">
          <source>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object &amp;ldquo;props&amp;rdquo;.</source>
          <target state="translated">Reactがユーザー定義コンポーネントを表す要素を見つけると、JSX属性をこのコンポーネントに単一のオブジェクトとして渡します。このオブジェクトを「小道具」と呼びます。</target>
        </trans-unit>
        <trans-unit id="cd960a41239540628263b007251ff1ce228a4975" translate="yes" xml:space="preserve">
          <source>When Webpack comes across this syntax, it automatically starts code-splitting your app. If you&amp;rsquo;re using Create React App, this is already configured for you and you can &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/code-splitting&quot;&gt;start using it&lt;/a&gt; immediately. It&amp;rsquo;s also supported out of the box in &lt;a href=&quot;https://github.com/zeit/next.js/#dynamic-import&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">Webpackがこの構文に遭遇すると、アプリのコード分割が自動的に開始されます。Create React Appを使用している場合、これはすでに構成されており&lt;a href=&quot;https://facebook.github.io/create-react-app/docs/code-splitting&quot;&gt;、&lt;/a&gt;すぐに使用を開始できます。&lt;a href=&quot;https://github.com/zeit/next.js/#dynamic-import&quot;&gt;Next.jsの追加設定なし&lt;/a&gt;でもサポートされます。</target>
        </trans-unit>
        <trans-unit id="24308061c4ea79dc3398cfc8567de4c5dd49d65a" translate="yes" xml:space="preserve">
          <source>When a button gets clicked, it starts a transition and calls &lt;code&gt;props.onClick()&lt;/code&gt; inside of it &amp;mdash; which triggers &lt;code&gt;handleRefreshClick&lt;/code&gt; in the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component. We start fetching the fresh data, but it doesn&amp;rsquo;t trigger a fallback because we&amp;rsquo;re inside a transition, and the 10 second timeout specified in the &lt;code&gt;useTransition&lt;/code&gt; call hasn&amp;rsquo;t passed yet. While a transition is pending, the button displays an inline loading indicator.</source>
          <target state="translated">ボタンがクリックされると、トランジションが開始され、その中の &lt;code&gt;props.onClick()&lt;/code&gt; が &lt;code&gt;handleRefreshClick&lt;/code&gt; れます。これにより、 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; コンポーネントのhandleRefreshClickがトリガーされます。新しいデータのフェッチを開始しますが、トランジション内にいるため、フォールバックはトリガーされません。また、 &lt;code&gt;useTransition&lt;/code&gt; 呼び出しで指定された10秒のタイムアウトがまだ経過していません。トランジションが保留されている間、ボタンにはインライン読み込みインジケータが表示されます。</target>
        </trans-unit>
        <trans-unit id="88c0e0d8605eedba926805cc491ffa3edad3fcca" translate="yes" xml:space="preserve">
          <source>When a component is removed &lt;em&gt;from within&lt;/em&gt; a React tree, the cleanup is performed automatically, but because we are removing the entire tree by hand, we must call this method.</source>
          <target state="translated">Reactツリー&lt;em&gt;内から&lt;/em&gt;コンポーネントを削除&lt;em&gt;する&lt;/em&gt;と、クリーンアップが自動的に実行されますが、ツリー全体を手動で削除しているため、このメソッドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="fa03685bfee385115f05a87525bb34183aa7d3b6" translate="yes" xml:space="preserve">
          <source>When a component renders to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;findDOMNode&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;. When a component renders to a string, &lt;code&gt;findDOMNode&lt;/code&gt; returns a text DOM node containing that value. As of React 16, a component may return a fragment with multiple children, in which case &lt;code&gt;findDOMNode&lt;/code&gt; will return the DOM node corresponding to the first non-empty child.</source>
          <target state="translated">コンポーネントが &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; にレンダリングされると、 &lt;code&gt;findDOMNode&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; を返します。コンポーネントが文字列にレンダリングされると、 &lt;code&gt;findDOMNode&lt;/code&gt; はその値を含むテキストDOMノードを返します。React 16以降、コンポーネントは複数の子を持つフラグメントを返す場合があります。その場合、 &lt;code&gt;findDOMNode&lt;/code&gt; は空でない最初の子に対応するDOMノードを返します。</target>
        </trans-unit>
        <trans-unit id="ebba8cb76e6c7b141346c24f24674447a518526e" translate="yes" xml:space="preserve">
          <source>When a component suspends, React needs to show the closest fallback. But the closest fallback to &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; is at the top level:</source>
          <target state="translated">コンポーネントが一時停止すると、Reactは最も近いフォールバックを表示する必要があります。ただし、 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; に最も近いフォールバックはトップレベルです。</target>
        </trans-unit>
        <trans-unit id="43f8277f42239eae9424a66a512a2fcabb104e3b" translate="yes" xml:space="preserve">
          <source>When a component updates, the instance stays the same, so that state is maintained across renders. React updates the props of the underlying component instance to match the new element, and calls &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; and &lt;code&gt;componentWillUpdate()&lt;/code&gt; on the underlying instance.</source>
          <target state="translated">コンポーネントが更新されると、インスタンスは同じままになるため、レンダリング全体で状態が維持されます。Reactは、基になるコンポーネントインスタンスのプロップを更新して新しい要素に一致させ、基になるインスタンスで &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; および &lt;code&gt;componentWillUpdate()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="29700bd1b2576f98f84deff1ab59eda1ac5d916a" translate="yes" xml:space="preserve">
          <source>When a component&amp;rsquo;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.</source>
          <target state="translated">コンポーネントのプロップまたは状態が変化すると、Reactは、新しく返された要素を以前にレンダリングされた要素と比較することにより、実際のDOM更新が必要かどうかを判断します。それらが等しくない場合、ReactはDOMを更新します。</target>
        </trans-unit>
        <trans-unit id="71688bf085f5be3641ad0e7683c86eab151bc2ac" translate="yes" xml:space="preserve">
          <source>When a component&amp;rsquo;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called &amp;ldquo;reconciliation&amp;rdquo;.</source>
          <target state="translated">コンポーネントのプロップまたは状態が変化すると、Reactは、新しく返された要素を以前にレンダリングされた要素と比較することにより、実際のDOM更新が必要かどうかを判断します。それらが等しくない場合、ReactはDOMを更新します。このプロセスは「調整」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="4a658d61a32f67b5097f57314a0f3ffb42c9b802" translate="yes" xml:space="preserve">
          <source>When a ref is passed to an element in &lt;code&gt;render&lt;/code&gt;, a reference to the node becomes accessible at the &lt;code&gt;current&lt;/code&gt; attribute of the ref.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; の要素にrefが渡されると、ノードの参照は、refの &lt;code&gt;current&lt;/code&gt; 属性でアクセス可能になります。</target>
        </trans-unit>
        <trans-unit id="092bbc82c0f9752a97e3de82e29d782cdf9f9183" translate="yes" xml:space="preserve">
          <source>When an element type starts with a lowercase letter, it refers to a built-in component like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; and results in a string &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt; passed to &lt;code&gt;React.createElement&lt;/code&gt;. Types that start with a capital letter like &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; compile to &lt;code&gt;React.createElement(Foo)&lt;/code&gt; and correspond to a component defined or imported in your JavaScript file.</source>
          <target state="translated">要素タイプが小文字で始まる場合、それは &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; などの組み込みコンポーネントを参照し、 &lt;code&gt;React.createElement&lt;/code&gt; に渡される文字列 &lt;code&gt;'div'&lt;/code&gt; または &lt;code&gt;'span'&lt;/code&gt; になります。 &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; のような大文字で始まるタイプは、 &lt;code&gt;React.createElement(Foo)&lt;/code&gt; にコンパイルされ、JavaScriptファイルで定義またはインポートされたコンポーネントに対応します。</target>
        </trans-unit>
        <trans-unit id="f3b3db069005ff6eb433c8c7e16d92582e642386" translate="yes" xml:space="preserve">
          <source>When called, it should examine &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; and return one of the following types:</source>
          <target state="translated">呼び出されると、 &lt;code&gt;this.props&lt;/code&gt; と &lt;code&gt;this.state&lt;/code&gt; を調べ、次のタイプのいずれかを返します。</target>
        </trans-unit>
        <trans-unit id="3e932a8184d9d49299869706c6d5892582b63c0e" translate="yes" xml:space="preserve">
          <source>When choosing testing tools, it is worth considering a few tradeoffs:</source>
          <target state="translated">テストツールを選択する際には、いくつかのトレードオフを検討する価値があります。</target>
        </trans-unit>
        <trans-unit id="7dffbe923ddf378219923364d4231ca60a1015b6" translate="yes" xml:space="preserve">
          <source>When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes. For example:</source>
          <target state="translated">同じタイプの2つのReact DOM要素を比較するとき、Reactは両方の属性を見て、同じ基礎となるDOMノードを保持し、変更された属性のみを更新します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0950dde1c2700e4c81c02a18f0ea0517525ca827" translate="yes" xml:space="preserve">
          <source>When converting between these two elements, React knows to only modify the &lt;code&gt;color&lt;/code&gt; style, not the &lt;code&gt;fontWeight&lt;/code&gt;.</source>
          <target state="translated">これら2つの要素間で変換するとき、React は &lt;code&gt;fontWeight&lt;/code&gt; ではなく、 &lt;code&gt;color&lt;/code&gt; スタイルのみを変更することを認識しています。</target>
        </trans-unit>
        <trans-unit id="684d074ff1bc6db8a43e7868a40828d155492a57" translate="yes" xml:space="preserve">
          <source>When diffing two trees, React first compares the two root elements. The behavior is different depending on the types of the root elements.</source>
          <target state="translated">2つのツリーを差分するとき、Reactはまず2つのルート要素を比較します。ルート要素の種類によって挙動が異なります。</target>
        </trans-unit>
        <trans-unit id="b3f4316f1f0610218ae53493262f1b06012ea13b" translate="yes" xml:space="preserve">
          <source>When is &lt;code&gt;setState&lt;/code&gt; asynchronous?</source>
          <target state="translated">ときである &lt;code&gt;setState&lt;/code&gt; 非同期は？</target>
        </trans-unit>
        <trans-unit id="9986343101ee6da7851b9828f0c4a4eaf4dce38b" translate="yes" xml:space="preserve">
          <source>When it previously rendered, the &lt;code&gt;Calculator&lt;/code&gt; has specified that &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Celsius &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleCelsiusChange&lt;/code&gt; method, and &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Fahrenheit &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleFahrenheitChange&lt;/code&gt; method. So either of these two &lt;code&gt;Calculator&lt;/code&gt; methods gets called depending on which input we edited.</source>
          <target state="translated">それは以前にレンダリングすると、 &lt;code&gt;Calculator&lt;/code&gt; いることを指定した &lt;code&gt;onTemperatureChange&lt;/code&gt; 摂氏の &lt;code&gt;TemperatureInput&lt;/code&gt; がある &lt;code&gt;Calculator&lt;/code&gt; の &lt;code&gt;handleCelsiusChange&lt;/code&gt; の方法、および &lt;code&gt;onTemperatureChange&lt;/code&gt; 華氏の &lt;code&gt;TemperatureInput&lt;/code&gt; がある &lt;code&gt;Calculator&lt;/code&gt; の &lt;code&gt;handleFahrenheitChange&lt;/code&gt; の方法。したがって、編集した入力に応じて、これらの2つの &lt;code&gt;Calculator&lt;/code&gt; メソッドのいずれかが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e9b2aac6423622e177393a29a45bdfea31a200f8" translate="yes" xml:space="preserve">
          <source>When multiple components need to fetch data, this data may arrive in an unpredictable order. However, if you wrap these items in a &lt;code&gt;SuspenseList&lt;/code&gt;, React will not show an item in the list until previous items have been displayed (this behavior is adjustable).</source>
          <target state="translated">複数のコンポーネントがデータをフェッチする必要がある場合、このデータは予期しない順序で到着する可能性があります。ただし、これらのアイテムを &lt;code&gt;SuspenseList&lt;/code&gt; でラップする場合、Reactは前のアイテムが表示されるまでリストにアイテムを表示しません（この動作は調整可能です）。</target>
        </trans-unit>
        <trans-unit id="42a683f16be3b2ba0e15fb0b13b5fd965aa7a2f8" translate="yes" xml:space="preserve">
          <source>When possible, we advise against exposing DOM nodes, but it can be a useful escape hatch. Note that this approach requires you to add some code to the child component. If you have absolutely no control over the child component implementation, your last option is to use &lt;a href=&quot;react-dom#finddomnode&quot;&gt;&lt;code&gt;findDOMNode()&lt;/code&gt;&lt;/a&gt;, but it is discouraged and deprecated in &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt;&lt;code&gt;StrictMode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可能であれば、DOMノードを公開しないことをお勧めしますが、これは便利なエスケープハッチになる場合があります。この方法では、子コンポーネントにコードを追加する必要があることに注意してください。子コンポーネントの実装を完全に制御できない場合、最後のオプションは&lt;a href=&quot;react-dom#finddomnode&quot;&gt; &lt;code&gt;findDOMNode()&lt;/code&gt; &lt;/a&gt;を使用することですが、&lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt; &lt;code&gt;StrictMode&lt;/code&gt; では&lt;/a&gt;推奨されておらず非推奨です。</target>
        </trans-unit>
        <trans-unit id="60dc9558f9f54b804963bf45bd2054c08d64c066" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;breaking changes&lt;/strong&gt;, we make a &lt;strong&gt;major release&lt;/strong&gt; by changing the &lt;strong&gt;x&lt;/strong&gt; number (ex: 15.6.2 to 16.0.0).</source>
          <target state="translated">解除するときは&lt;strong&gt;重大な変更を&lt;/strong&gt;、我々は作る&lt;strong&gt;のメジャーリリースを&lt;/strong&gt;変更することで&lt;strong&gt;のx&lt;/strong&gt;（：15.6.2 16.0.0へのEX）の数を。</target>
        </trans-unit>
        <trans-unit id="c51bee886f54f565c856364002a6f5a65ec91ed6" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;critical bug fixes&lt;/strong&gt;, we make a &lt;strong&gt;patch release&lt;/strong&gt; by changing the &lt;strong&gt;z&lt;/strong&gt; number (ex: 15.6.2 to 15.6.3).</source>
          <target state="translated">&lt;strong&gt;重大なバグ修正を&lt;/strong&gt;リリースする場合、&lt;strong&gt;z&lt;/strong&gt;番号を変更して&lt;strong&gt;パッチリリース&lt;/strong&gt;を作成します（例：15.6.2から15.6.3）。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da463cb8c8960a42b7c6c641c9cd92e1a9c910f5" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;new features&lt;/strong&gt; or &lt;strong&gt;non-critical fixes&lt;/strong&gt;, we make a &lt;strong&gt;minor release&lt;/strong&gt; by changing the &lt;strong&gt;y&lt;/strong&gt; number (ex: 15.6.2 to 15.7.0).</source>
          <target state="translated">解除時&lt;strong&gt;、新機能&lt;/strong&gt;や&lt;strong&gt;非重要な修正を&lt;/strong&gt;、我々は作る&lt;strong&gt;マイナーリリース&lt;/strong&gt;変更することにより、&lt;strong&gt;Y&lt;/strong&gt;（：15.6.2 15.7.0へのEX）の数を。</target>
        </trans-unit>
        <trans-unit id="4c4ce5e89fb709cdcfcdafac99ab55a42fcb22c8" translate="yes" xml:space="preserve">
          <source>When starting a React project, a &lt;a href=&quot;add-react-to-a-website&quot;&gt;simple HTML page with script tags&lt;/a&gt; might still be the best option. It only takes a minute to set up!</source>
          <target state="translated">Reactプロジェクトを開始するときは&lt;a href=&quot;add-react-to-a-website&quot;&gt;、スクリプトタグ&lt;/a&gt;が付いた単純なHTMLページが最適なオプションである可能性があります。セットアップは1分で完了します。</target>
        </trans-unit>
        <trans-unit id="b761467ad522f1cc9758e17d70a4c8a9a2a07e67" translate="yes" xml:space="preserve">
          <source>When strict mode is enabled, React compiles a list of all class components using the unsafe lifecycles, and logs a warning message with information about these components, like so:</source>
          <target state="translated">厳密モードが有効になっている場合、React は安全でないライフサイクルを使用しているすべてのクラスコンポーネントのリストをコンパイルし、これらのコンポーネントに関する情報を含む警告メッセージを以下のようにログに記録します。</target>
        </trans-unit>
        <trans-unit id="347743a185cce0b0e36269b13516e6388d551e77" translate="yes" xml:space="preserve">
          <source>When tearing down a tree, old DOM nodes are destroyed. Component instances receive &lt;code&gt;componentWillUnmount()&lt;/code&gt;. When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive &lt;code&gt;componentWillMount()&lt;/code&gt; and then &lt;code&gt;componentDidMount()&lt;/code&gt;. Any state associated with the old tree is lost.</source>
          <target state="translated">ツリーを分解すると、古いDOMノードが破棄されます。コンポーネントインスタンスは、 &lt;code&gt;componentWillUnmount()&lt;/code&gt; を受け取ります。新しいツリーを構築すると、新しいDOMノードがDOMに挿入されます。コンポーネントインスタンスは、受信 &lt;code&gt;componentWillMount()&lt;/code&gt; 、次いで &lt;code&gt;componentDidMount()&lt;/code&gt; 。古いツリーに関連付けられている状態はすべて失われます。</target>
        </trans-unit>
        <trans-unit id="30d8a42b09cbe7fd1ec6f1e31e28559adfac664f" translate="yes" xml:space="preserve">
          <source>When testing your rate limiting code works correctly it is helpful to have the ability to fast forward time. If you are using &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;&lt;code&gt;jest&lt;/code&gt;&lt;/a&gt; then you can use &lt;a href=&quot;https://facebook.github.io/jest/docs/en/timer-mocks.html&quot;&gt;&lt;code&gt;mock timers&lt;/code&gt;&lt;/a&gt; to fast forward time. If you are using &lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling then you may find &lt;a href=&quot;https://github.com/alexreardon/raf-stub&quot;&gt;&lt;code&gt;raf-stub&lt;/code&gt;&lt;/a&gt; to be a useful tool to control the ticking of animation frames.</source>
          <target state="translated">レート制限コードをテストして正しく機能する場合、時間を早めることができると便利です。あなたが使用している場合は&lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt; &lt;code&gt;jest&lt;/code&gt; &lt;/a&gt;、あなたは使用することができます&lt;a href=&quot;https://facebook.github.io/jest/docs/en/timer-mocks.html&quot;&gt; &lt;code&gt;mock timers&lt;/code&gt; &lt;/a&gt;早送り時に。 &lt;code&gt;requestAnimationFrame&lt;/code&gt; スロットリングを使用している場合、&lt;a href=&quot;https://github.com/alexreardon/raf-stub&quot;&gt; &lt;code&gt;raf-stub&lt;/code&gt; &lt;/a&gt;がアニメーションフレームのティックを制御するための便利なツールであることがわかります。</target>
        </trans-unit>
        <trans-unit id="778feebbad29d6b5513a63ee18a925568f6d6163" translate="yes" xml:space="preserve">
          <source>When that&amp;rsquo;s not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. The key only has to be unique among its siblings, not globally unique.</source>
          <target state="translated">そうでない場合は、モデルに新しいIDプロパティを追加するか、コンテンツの一部をハッシュしてキーを生成できます。キーは、兄弟間で一意である必要があり、グローバルに一意である必要はありません。</target>
        </trans-unit>
        <trans-unit id="a0c23aa39d66eaa9a54e2e5df7c6fc165ebfd607" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Clock&lt;/code&gt; output is inserted in the DOM, React calls the &lt;code&gt;componentDidMount()&lt;/code&gt; lifecycle method. Inside it, the &lt;code&gt;Clock&lt;/code&gt; component asks the browser to set up a timer to call the component&amp;rsquo;s &lt;code&gt;tick()&lt;/code&gt; method once a second.</source>
          <target state="translated">ときに &lt;code&gt;Clock&lt;/code&gt; 出力をDOMに挿入され、コール反応させ &lt;code&gt;componentDidMount()&lt;/code&gt; ライフサイクル法。その内部で、 &lt;code&gt;Clock&lt;/code&gt; コンポーネントはブラウザに、コンポーネントの &lt;code&gt;tick()&lt;/code&gt; メソッドを1秒に1回呼び出すタイマーを設定するように要求します。</target>
        </trans-unit>
        <trans-unit id="cf10aa37dfd027d0b674dd7f80a8d15edd1555cb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ref&lt;/code&gt; attribute is used on a custom class component, the &lt;code&gt;ref&lt;/code&gt; object receives the mounted instance of the component as its &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;ref&lt;/code&gt; 属性は、カスタム・クラス・コンポーネントで使用され、 &lt;code&gt;ref&lt;/code&gt; オブジェクトは、そのコンポーネントの取り付けられたインスタンスを受信する &lt;code&gt;current&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1196abe0d02468ca061784efb41273736ae2775d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ref&lt;/code&gt; attribute is used on an HTML element, the &lt;code&gt;ref&lt;/code&gt; created in the constructor with &lt;code&gt;React.createRef()&lt;/code&gt; receives the underlying DOM element as its &lt;code&gt;current&lt;/code&gt; property.</source>
          <target state="translated">とき &lt;code&gt;ref&lt;/code&gt; 属性はHTML要素で使用され、 &lt;code&gt;ref&lt;/code&gt; とのコンストラクタで作成された &lt;code&gt;React.createRef()&lt;/code&gt; はその基本となるDOM要素を受け取り &lt;code&gt;current&lt;/code&gt; プロパティ。</target>
        </trans-unit>
        <trans-unit id="4842e3714ef564d446a08145facb86d1faac4e3f" translate="yes" xml:space="preserve">
          <source>When the nearest &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above the component updates, this Hook will trigger a rerender with the latest context &lt;code&gt;value&lt;/code&gt; passed to that &lt;code&gt;MyContext&lt;/code&gt; provider. Even if an ancestor uses &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/a&gt;, a rerender will still happen starting at the component itself using &lt;code&gt;useContext&lt;/code&gt;.</source>
          <target state="translated">コンポーネントの上の最も近い &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; が更新されると、このフックは、その &lt;code&gt;MyContext&lt;/code&gt; プロバイダーに渡された最新のコンテキスト &lt;code&gt;value&lt;/code&gt; レンダリングをトリガーします。祖先が&lt;a href=&quot;react-api#reactmemo&quot;&gt; &lt;code&gt;React.memo&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate&lt;/code&gt; を&lt;/a&gt;使用していても、再レンダリングは &lt;code&gt;useContext&lt;/code&gt; を使用してコンポーネント自体から開始されます。</target>
        </trans-unit>
        <trans-unit id="5f136dce5bc69460397f4de5f24b415b64d0e59e" translate="yes" xml:space="preserve">
          <source>When the ref is attached, &lt;code&gt;ref.current&lt;/code&gt; will point to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM node.</source>
          <target state="translated">refがアタッチされると、 &lt;code&gt;ref.current&lt;/code&gt; は &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOMノードを指します。</target>
        </trans-unit>
        <trans-unit id="5004319c4160942e0f6547bee0d83e11339e4331" translate="yes" xml:space="preserve">
          <source>When to Use Context</source>
          <target state="translated">コンテキストを使用するタイミング</target>
        </trans-unit>
        <trans-unit id="8d9501cf2be99ddf15d3221bfb5919dd4b8ef921" translate="yes" xml:space="preserve">
          <source>When to Use Refs</source>
          <target state="translated">レフを使用するタイミング</target>
        </trans-unit>
        <trans-unit id="ce86eaeb59a0d973185f25e1918297ceadd0737d" translate="yes" xml:space="preserve">
          <source>When updating &lt;code&gt;style&lt;/code&gt;, React also knows to update only the properties that changed. For example:</source>
          <target state="translated">Reactは、 &lt;code&gt;style&lt;/code&gt; 更新するときに、変更されたプロパティのみを更新することも認識しています。例えば：</target>
        </trans-unit>
        <trans-unit id="f686dfc377beeaa047e439ce00efd438744a39e1" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, you&amp;rsquo;ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need &lt;a href=&quot;https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import&quot;&gt;babel-plugin-syntax-dynamic-import&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;を使用する場合は、Babelが動的インポート構文を解析できるが、変換しないことを確認する必要があります。そのためには、&lt;a href=&quot;https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import&quot;&gt;babel-plugin-syntax-dynamic-import&lt;/a&gt;が必要です。</target>
        </trans-unit>
        <trans-unit id="eba57241352930e4939e8b3898ace71b33c7ff40" translate="yes" xml:space="preserve">
          <source>When using React, you generally don&amp;rsquo;t need to call &lt;code&gt;addEventListener&lt;/code&gt; to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</source>
          <target state="translated">Reactを使用する場合、通常、作成後にDOM要素にリスナーを追加するために &lt;code&gt;addEventListener&lt;/code&gt; を呼び出す必要はありません。代わりに、要素が最初にレンダリングされるときにリスナーを提供します。</target>
        </trans-unit>
        <trans-unit id="093f2c7f6c3ba701ba5ea625a4f27b321d9a5fb9" translate="yes" xml:space="preserve">
          <source>When using a HOC to extend components, it is recommended to &lt;a href=&quot;forwarding-refs&quot;&gt;forward the ref&lt;/a&gt; to the wrapped component using the &lt;code&gt;forwardRef&lt;/code&gt; function of React. If a third party HOC does not implement ref forwarding, the above pattern can still be used as a fallback.</source>
          <target state="translated">HOCを使用してコンポーネントを拡張する場合、Reactの &lt;code&gt;forwardRef&lt;/code&gt; 関数を使用して、ラップされたコンポーネントに&lt;a href=&quot;forwarding-refs&quot;&gt;ref&lt;/a&gt;を転送することをお勧めします。サードパーティのHOCが参照転送を実装していない場合でも、上記のパターンをフォールバックとして使用できます。</target>
        </trans-unit>
        <trans-unit id="4e906275be6eecf52c0afbd564f7672d05ee4159" translate="yes" xml:space="preserve">
          <source>When we &lt;code&gt;useTransition&lt;/code&gt;, React will let us &amp;ldquo;stay&amp;rdquo; on the previous screen &amp;mdash; and show a progress indicator there. We call that a &lt;strong&gt;Pending&lt;/strong&gt; state. It feels much better than the Receded state because none of our existing content disappears, and the page stays interactive.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; を使用する場合、Reactは前の画面に「留まる」ようにし、進行状況インジケーターを表示します。これを&lt;strong&gt;保留&lt;/strong&gt;状態と呼びます。既存のコンテンツはどれも消えず、ページはインタラクティブなままであるため、Receded状態よりもはるかに快適です。</target>
        </trans-unit>
        <trans-unit id="4854d06865881970adc4acde9ae2a92249e7a3ea" translate="yes" xml:space="preserve">
          <source>When we click &amp;ldquo;Next&amp;rdquo;, the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component kicks off a request for the next profile, and passes &lt;em&gt;that&lt;/em&gt; object down to the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">「次へ」をクリックすると、 &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; コンポーネントは次のプロファイルのリクエストを開始し、&lt;em&gt;その&lt;/em&gt;オブジェクトを &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; コンポーネントに渡します。</target>
        </trans-unit>
        <trans-unit id="fca1cc82f8e24916153432702dbf9b64cc55319c" translate="yes" xml:space="preserve">
          <source>When we click the &amp;ldquo;Next&amp;rdquo; button to switch the active profile, the existing page data immediately disappears, and we see the loading indicator for the whole page again. We can call this an &amp;ldquo;undesirable&amp;rdquo; loading state. &lt;strong&gt;It would be nice if we could &amp;ldquo;skip&amp;rdquo; it and wait for some content to load before transitioning to the new screen.&lt;/strong&gt;</source>
          <target state="translated">「次へ」ボタンをクリックしてアクティブなプロファイルを切り替えると、既存のページデータがすぐに消え、ページ全体の読み込みインジケータが再び表示されます。これを「望ましくない」ロード状態と呼ぶことができます。&lt;strong&gt;新しい画面に移行する前に、コンテンツを「スキップ」してコンテンツが読み込まれるのを待つことができれば便利です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a9b7e3341f89a25468d35a1902a98055ebd40a4" translate="yes" xml:space="preserve">
          <source>When we declare a state variable with &lt;code&gt;useState&lt;/code&gt;, it returns a pair &amp;mdash; an array with two items. The first item is the current value, and the second is a function that lets us update it. Using &lt;code&gt;[0]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt; to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.</source>
          <target state="translated">&lt;code&gt;useState&lt;/code&gt; を使用して状態変数を宣言すると、ペア（2つの項目を持つ配列）が返されます。最初の項目は現在の値で、2番目の項目はそれを更新できる関数です。使用する &lt;code&gt;[0]&lt;/code&gt; と &lt;code&gt;[1]&lt;/code&gt; を、彼らは特定の意味を持っているので、それらにアクセスすることは少し混乱です。これが、代わりに配列の構造化解除を使用する理由です。</target>
        </trans-unit>
        <trans-unit id="48f1197e89ad2a45509e77a5dc2018726e3c6911" translate="yes" xml:space="preserve">
          <source>When we fetch data for a page, can the API encourage including data for instant transitions &lt;em&gt;from&lt;/em&gt; it?</source>
          <target state="translated">ページのデータをフェッチするとき、APIはページ&lt;em&gt;からの&lt;/em&gt;即時遷移のデータを含めることを推奨できますか？</target>
        </trans-unit>
        <trans-unit id="ed6581c215df6a3091c26a4c2bdef00a960a4785" translate="yes" xml:space="preserve">
          <source>When we render with &lt;code&gt;count&lt;/code&gt; updated to &lt;code&gt;6&lt;/code&gt;, React will compare the items in the &lt;code&gt;[5]&lt;/code&gt; array from the previous render to items in the &lt;code&gt;[6]&lt;/code&gt; array from the next render. This time, React will re-apply the effect because &lt;code&gt;5 !== 6&lt;/code&gt;. If there are multiple items in the array, React will re-run the effect even if just one of them is different.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; を &lt;code&gt;6&lt;/code&gt; に更新してレンダリングすると、Reactは前のレンダーの &lt;code&gt;[5]&lt;/code&gt; 配列のアイテムを次のレンダーの &lt;code&gt;[6]&lt;/code&gt; 配列のアイテムと比較します。今回は、 &lt;code&gt;5 !== 6&lt;/code&gt; ため、Reactはエフェクトを再適用します。配列に複数のアイテムがある場合、そのうちの1つだけが異なっていても、Reactはエフェクトを再実行します。</target>
        </trans-unit>
        <trans-unit id="15dd239dd01373f359404e41d5b7a62dacbb76d9" translate="yes" xml:space="preserve">
          <source>When we want to display the current count in a class, we read &lt;code&gt;this.state.count&lt;/code&gt;:</source>
          <target state="translated">クラスの現在の数を表示したいときは、 &lt;code&gt;this.state.count&lt;/code&gt; を読みます：</target>
        </trans-unit>
        <trans-unit id="7e772ea53410ed97f311017baf25729ac436eb7e" translate="yes" xml:space="preserve">
          <source>When we want to share logic between two JavaScript functions, we extract it to a third function. Both components and Hooks are functions, so this works for them too!</source>
          <target state="translated">2つのJavaScript関数間でロジックを共有したいときは、3つ目の関数にロジックを抽出します。コンポーネントとHooksはどちらも関数なので、これらの関数でも動作します。</target>
        </trans-unit>
        <trans-unit id="b6891052b12cc29726c0f0b0279ac50a1c1387f8" translate="yes" xml:space="preserve">
          <source>When we were learning about &lt;a href=&quot;hooks-effect#example-using-hooks-1&quot;&gt;using the Effect Hook&lt;/a&gt;, we saw this component from a chat application that displays a message indicating whether a friend is online or offline:</source>
          <target state="translated">&lt;a href=&quot;hooks-effect#example-using-hooks-1&quot;&gt;エフェクトフックの使用&lt;/a&gt;について学習していたときに、このコンポーネントをチャットアプリケーションから見て、友人がオンラインかオフラインかを示すメッセージを表示しました。</target>
        </trans-unit>
        <trans-unit id="5b9387f6a30d7fe6f52f7bcb771030991372ac72" translate="yes" xml:space="preserve">
          <source>When we write code with Promises, we might use &lt;code&gt;catch()&lt;/code&gt; to handle errors. How does this work with Suspense, given that we don&amp;rsquo;t &lt;em&gt;wait&lt;/em&gt; for Promises to start rendering?</source>
          <target state="translated">Promiseでコードを記述する場合、 &lt;code&gt;catch()&lt;/code&gt; を使用してエラーを処理することがあります。Promiseがレンダリングを開始するのを&lt;em&gt;待た&lt;/em&gt;ない場合、これはSuspenseでどのように機能しますか？</target>
        </trans-unit>
        <trans-unit id="dbbba4fb5bc3bc71466275b51ebcb399bc61b8c2" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re already on the next screen, sometimes the data needed to &amp;ldquo;unlock&amp;rdquo; different &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries arrives in quick succession. For example, two different responses might arrive after 1000ms and 1050ms, respectively. If you&amp;rsquo;ve already waited for a second, waiting another 50ms is not going to be perceptible. This is why React reveals &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries on a schedule, like a &amp;ldquo;train&amp;rdquo; that arrives periodically. This trades a small delay for reducing the layout thrashing and the number of visual changes presented to the user.</source>
          <target state="translated">すでに次の画面が表示されているときに、さまざまな &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 境界を「ロック解除」するために必要なデータがすぐに連続して届く場合があります。たとえば、2つの異なる応答がそれぞれ1000msと1050ms後に到着する場合があります。もう1秒間待機している場合、さらに50ミリ秒待機しても気付かないでしょう。これが、React が定期的に到着する「電車」のように、スケジュールで &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 境界を明らかにする理由です。これにより、レイアウトのスラッシングとユーザーに表示される視覚的な変更の数を減らすために、少しの遅延が発生します。</target>
        </trans-unit>
        <trans-unit id="1b060390d4cb54331e0099d906d42df3b0d12cba" translate="yes" xml:space="preserve">
          <source>When working with portals, remember that &lt;a href=&quot;accessibility#programmatically-managing-focus&quot;&gt;managing keyboard focus&lt;/a&gt; becomes very important.</source>
          <target state="translated">ポータルを操作するときは、&lt;a href=&quot;accessibility#programmatically-managing-focus&quot;&gt;キーボードフォーカスの管理&lt;/a&gt;が非常に重要になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1b92b098726d1ea5fd34d3c3b1ae6f350cac787b" translate="yes" xml:space="preserve">
          <source>When writing UI tests, tasks like rendering, user events, or data fetching can be considered as &amp;ldquo;units&amp;rdquo; of interaction with a user interface. React provides a helper called &lt;code&gt;act()&lt;/code&gt; that makes sure all updates related to these &amp;ldquo;units&amp;rdquo; have been processed and applied to the DOM before you make any assertions:</source>
          <target state="translated">UIテストを作成する場合、レンダリング、ユーザーイベント、データフェッチなどのタスクは、ユーザーインターフェイスとの対話の「単位」と見なすことができます。Reactは &lt;code&gt;act()&lt;/code&gt; と呼ばれるヘルパーを提供し、アサーションを行う前に、これらの「ユニット」に関連するすべての更新が処理され、DOMに適用されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="815dd6740e6e9c5d08dcb3ad258c5e94e50158fe" translate="yes" xml:space="preserve">
          <source>When writing tests, we&amp;rsquo;d like to mock out the parts of our code that don&amp;rsquo;t have equivalents inside our testing environment (e.g. checking &lt;code&gt;navigator.onLine&lt;/code&gt; status inside Node.js). Tests could also spy on some functions, and observe how other parts of the test interact with them. It is then useful to be able to selectively mock these functions with test-friendly versions.</source>
          <target state="translated">テストを作成するときは、テスト環境内に同等のものがないコードの部分をモックアウトします（Node.js内の &lt;code&gt;navigator.onLine&lt;/code&gt; ステータスの確認など）。テストは、一部の機能をスパイし、テストの他の部分がそれらとどのように相互作用するかを観察することもできます。テストに適したバージョンでこれらの関数を選択的にモックできると便利です。</target>
        </trans-unit>
        <trans-unit id="54186af6fe93abf508be013c58f7c15e821c2212" translate="yes" xml:space="preserve">
          <source>When writing unit tests for React, shallow rendering can be helpful. Shallow rendering lets you render a component &amp;ldquo;one level deep&amp;rdquo; and assert facts about what its render method returns, without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.</source>
          <target state="translated">Reactの単体テストを作成する場合、浅いレンダリングが役立ちます。浅いレンダリングでは、インスタンス化またはレンダリングされない子コンポーネントの動作を気にすることなく、コンポーネントを「1レベル深く」レンダリングし、そのrenderメソッドが返すものについての事実を表明できます。これにはDOMは必要ありません。</target>
        </trans-unit>
        <trans-unit id="82a14329dae74e66f4aea2bb76056b1aafd3fd03" translate="yes" xml:space="preserve">
          <source>When you apply a HOC to a component, though, the original component is wrapped with a container component. That means the new component does not have any of the static methods of the original component.</source>
          <target state="translated">しかし、コンポーネントにHOCを適用すると、元のコンポーネントはコンテナコンポーネントでラップされます。つまり、新しいコンポーネントには元のコンポーネントの静的メソッドはありません。</target>
        </trans-unit>
        <trans-unit id="d789f6dd4fbb7df7db5b972518ccd2f457118883" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;setState()&lt;/code&gt;, React merges the object you provide into the current state.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; を呼び出すと、Reactは指定されたオブジェクトを現在の状態にマージします。</target>
        </trans-unit>
        <trans-unit id="93a56c926d74b4e963b27be254ec9ba6d291fd30" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;useEffect&lt;/code&gt;, you&amp;rsquo;re telling React to run your &amp;ldquo;effect&amp;rdquo; function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render &amp;mdash; &lt;em&gt;including&lt;/em&gt; the first render. (We&amp;rsquo;ll talk more about how this compares to class lifecycles in &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; を呼び出すと、変更をDOMにフラッシュした後で「エフェクト」関数を実行するようにReactに指示することになります。エフェクトはコンポーネント内で宣言されるため、その小道具と状態にアクセスできます。デフォルトでは、React は最初のレンダリング&lt;em&gt;を含め&lt;/em&gt;、すべてのレンダリング後にエフェクトを実行します。（これがクラスのライフサイクルとどのように比較されるかについて&lt;a href=&quot;hooks-effect&quot;&gt;は、エフェクトフックの使用で&lt;/a&gt;詳しく説明します。）</target>
        </trans-unit>
        <trans-unit id="5dc1f9c6d9a1899bf29a171b9ce6e79ac82836a8" translate="yes" xml:space="preserve">
          <source>When you deal with deeply nested objects, updating them in an immutable way can feel convoluted. If you run into this problem, check out &lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;Immer&lt;/a&gt; or &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;. These libraries let you write highly readable code without losing the benefits of immutability.</source>
          <target state="translated">深くネストされたオブジェクトを扱う場合、それらを不変の方法で更新すると、複雑に感じる場合があります。この問題が発生した場合は、&lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;Immer&lt;/a&gt;または&lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helperを&lt;/a&gt;確認してください。これらのライブラリを使用すると、不変性の利点を失うことなく、非常に読みやすいコードを記述できます。</target>
        </trans-unit>
        <trans-unit id="a24b1ec6fc11433896d187e1f658c70a7099a2ad" translate="yes" xml:space="preserve">
          <source>When you define a component using an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt;, a common pattern is for an event handler to be a method on the class. For example, this &lt;code&gt;Toggle&lt;/code&gt; component renders a button that lets the user toggle between &amp;ldquo;ON&amp;rdquo; and &amp;ldquo;OFF&amp;rdquo; states:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6クラス&lt;/a&gt;を使用してコンポーネントを定義する場合、一般的なパターンは、イベントハンドラーがクラスのメソッドになることです。たとえば、次の &lt;code&gt;Toggle&lt;/code&gt; コンポーネントは、ユーザーが「オン」と「オフ」の状態を切り替えることができるボタンをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="01abc8d4d76c5d3b29a56fbabd9fa795ee92ceb3" translate="yes" xml:space="preserve">
          <source>When you design React components, it is usually best to find the &amp;ldquo;minimal representation&amp;rdquo; of state. For example, instead of keeping &lt;code&gt;firstName&lt;/code&gt;, &lt;code&gt;lastName&lt;/code&gt;, and &lt;code&gt;fullName&lt;/code&gt; in state, it&amp;rsquo;s usually better keep only &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt;, and then calculate &lt;code&gt;fullName&lt;/code&gt; during rendering. This lets us avoid mistakes where we update one state but forget the other state.</source>
          <target state="translated">Reactコンポーネントを設計するときは、通常、状態の​​「最小限の表現」を見つけることが最善です。たとえば、 &lt;code&gt;firstName&lt;/code&gt; 、 &lt;code&gt;lastName&lt;/code&gt; 、および &lt;code&gt;fullName&lt;/code&gt; の状態を維持する代わりに、通常は &lt;code&gt;firstName&lt;/code&gt; と &lt;code&gt;lastName&lt;/code&gt; のみを維持してから、レンダリング中に &lt;code&gt;fullName&lt;/code&gt; を計算することをお勧めします。これにより、一方の状態を更新し、他方の状態を忘れるというミスを回避できます。</target>
        </trans-unit>
        <trans-unit id="0b0e176fb66cf11f7e27af0bcb2e55372392f43e" translate="yes" xml:space="preserve">
          <source>When you don&amp;rsquo;t have stable IDs for rendered items, you may use the item index as a key as a last resort:</source>
          <target state="translated">レンダリングされたアイテムに安定したIDがない場合は、最後の手段としてキーとしてアイテムインデックスを使用できます。</target>
        </trans-unit>
        <trans-unit id="f82a0d500de82ea773a24f53e694f0f8c714eaf2" translate="yes" xml:space="preserve">
          <source>When you don&amp;rsquo;t need any props on the Fragment tag you can use the &lt;a href=&quot;fragments#short-syntax&quot;&gt;short syntax&lt;/a&gt;, if your tooling supports it:</source>
          <target state="translated">ツールがサポートしている場合、フラグメントタグに小道具が必要ない場合は、&lt;a href=&quot;fragments#short-syntax&quot;&gt;短い構文を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="1f5d758f7a13f26df949720818e29795ba408fea" translate="yes" xml:space="preserve">
          <source>When you need to handle multiple controlled &lt;code&gt;input&lt;/code&gt; elements, you can add a &lt;code&gt;name&lt;/code&gt; attribute to each element and let the handler function choose what to do based on the value of &lt;code&gt;event.target.name&lt;/code&gt;.</source>
          <target state="translated">複数の制御された &lt;code&gt;input&lt;/code&gt; 要素を処理する必要がある場合、各要素に &lt;code&gt;name&lt;/code&gt; 属性を追加し、ハンドラー関数に &lt;code&gt;event.target.name&lt;/code&gt; の値に基づいて実行する処理を選択させることができます。</target>
        </trans-unit>
        <trans-unit id="c75b2134369a0a04fe58dd9360ac61d55ca554e4" translate="yes" xml:space="preserve">
          <source>When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:</source>
          <target state="translated">文字列リテラルを渡すと、その値はHTML-unscapedされます。つまり、この2つのJSX式は等価です。</target>
        </trans-unit>
        <trans-unit id="231c33cc0825db7915ff2676aa0c0c45eb40c0bc" translate="yes" xml:space="preserve">
          <source>When you run this code, you&amp;rsquo;ll be given a warning that a key should be provided for list items. A &amp;ldquo;key&amp;rdquo; is a special string attribute you need to include when creating lists of elements. We&amp;rsquo;ll discuss why it&amp;rsquo;s important in the next section.</source>
          <target state="translated">このコードを実行すると、リストアイテムにキーを指定する必要があるという警告が表示されます。「キー」は、要素のリストを作成するときに含める必要がある特別な文字列属性です。それが重要である理由については、次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="392e1c61d6fc0a80b224eb56286bbae56068d9da" translate="yes" xml:space="preserve">
          <source>When you see something wrong in the UI, you can use &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source:</source>
          <target state="translated">UIに問題がある場合は、&lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt;を使用して小道具を検査し、状態を更新するコンポーネントが見つかるまでツリーを上に移動できます。これにより、バグをそのソースまで追跡できます。</target>
        </trans-unit>
        <trans-unit id="e6c278736c7925bc9c4014f782054c15bd13051c" translate="yes" xml:space="preserve">
          <source>When you use React, at a single point in time you can think of the &lt;code&gt;render()&lt;/code&gt; function as creating a tree of React elements. On the next state or props update, that &lt;code&gt;render()&lt;/code&gt; function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.</source>
          <target state="translated">Reactを使用する場合、ある時点で &lt;code&gt;render()&lt;/code&gt; 関数をReact要素のツリーを作成するものと考えることができます。次の状態または小道具の更新時に、その &lt;code&gt;render()&lt;/code&gt; 関数はReact要素の別のツリーを返します。次に、Reactは、最新のツリーに一致するようにUIを効率的に更新する方法を理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="3918d1668774c6039a7d4c11830322620a548fcf" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to deploy to production, running &lt;code&gt;npm run build&lt;/code&gt; will create an optimized build of your app in the &lt;code&gt;build&lt;/code&gt; folder. You can learn more about Create React App &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#create-react-app--&quot;&gt;from its README&lt;/a&gt; and the &lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;User Guide&lt;/a&gt;.</source>
          <target state="translated">本番 &lt;code&gt;npm run build&lt;/code&gt; にデプロイする準備ができたら、npm run buildを実行すると、 &lt;code&gt;build&lt;/code&gt; フォルダーにアプリの最適化ビルドが作成されます。Create React Appの詳細について&lt;a href=&quot;https://github.com/facebookincubator/create-react-app#create-react-app--&quot;&gt;は、README&lt;/a&gt;と&lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;ユーザーガイド&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="bebff40c8b08402b37ab557fa24c08cc19a40f98" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, we&amp;rsquo;d encourage you to start trying Hooks in new components you write. Make sure everyone on your team is on board with using them and familiar with this documentation. We don&amp;rsquo;t recommend rewriting your existing classes to Hooks unless you planned to rewrite them anyway (e.g. to fix bugs).</source>
          <target state="translated">準備ができたら、作成した新しいコンポーネントでフックを試すことをお勧めします。チームの全員がそれらを使用し、このドキュメントに精通していることを確認してください。とにかく（たとえば、バグを修正するために）書き換える予定がない限り、既存のクラスをフックに書き換えることはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="60ca1c6e2220d3dcd5eb8ee37e9e869e14d685d1" translate="yes" xml:space="preserve">
          <source>Whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch. Going from &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;, or from &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt;, or from &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; - any of those will lead to a full rebuild.</source>
          <target state="translated">ルート要素のタイプが異なる場合、Reactは古いツリーを破棄し、新しいツリーを最初から構築します。行く &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; へ &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 、またはから &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt; 、またはから &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; へ &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; -これらのいずれかが再構築いっぱいにつながります。</target>
        </trans-unit>
        <trans-unit id="6dd9bbf6973367e79eeae18b9bbda9418cafb732" translate="yes" xml:space="preserve">
          <source>Whenever you get confused by something in JavaScript, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt; and &lt;a href=&quot;https://javascript.info/&quot;&gt;javascript.info&lt;/a&gt; are great websites to check. There are also &lt;a href=&quot;https://reactjs.org/community/support.html&quot;&gt;community support forums&lt;/a&gt; where you can ask for help.</source>
          <target state="translated">JavaScriptの何かに混乱したときはいつでも、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt;と&lt;a href=&quot;https://javascript.info/&quot;&gt;javascript.info&lt;/a&gt;はチェックすべき素晴らしいWebサイトです。あり&lt;a href=&quot;https://reactjs.org/community/support.html&quot;&gt;、コミュニティのサポートフォーラム&lt;/a&gt;あなたが助けを求めることができます。</target>
        </trans-unit>
        <trans-unit id="c8f9e5d66d270d8259063ea04783c1ae12b8c1c6" translate="yes" xml:space="preserve">
          <source>Where Does the Update Happen?</source>
          <target state="translated">更新はどこで行われるのか?</target>
        </trans-unit>
        <trans-unit id="ef742a7bbdd48469bd1b3855fd8bf22859df98d5" translate="yes" xml:space="preserve">
          <source>Where in the component lifecycle should I make an AJAX call?</source>
          <target state="translated">コンポーネントのライフサイクルのどこでAJAX呼び出しを行うべきですか?</target>
        </trans-unit>
        <trans-unit id="ae2b962ed56663e8ecdd89ac3430db8cddb1f349" translate="yes" xml:space="preserve">
          <source>Where required, using your keyboard arrow keys to interact with some elements, such as menus and dropdowns.</source>
          <target state="translated">必要に応じて、キーボードの矢印キーを使用して、メニューやドロップダウンなどの一部の要素を操作します。</target>
        </trans-unit>
        <trans-unit id="88a90f10ab7ebe7a5678e36f1ceddd076dd13ba2" translate="yes" xml:space="preserve">
          <source>Where to Place Error Boundaries</source>
          <target state="translated">誤差の境界線をどこに置くか</target>
        </trans-unit>
        <trans-unit id="5efb59c3c22d68fc4a99b342c9b256a6b2820f68" translate="yes" xml:space="preserve">
          <source>Whereas a component transforms props into UI, a higher-order component transforms a component into another component.</source>
          <target state="translated">コンポーネントが小道具をUIに変換するのに対し、高次のコンポーネントはコンポーネントを別のコンポーネントに変換します。</target>
        </trans-unit>
        <trans-unit id="6e766e695d0adc0641fe24c8e239dc1edab04b55" translate="yes" xml:space="preserve">
          <source>Whether or not it&amp;rsquo;s an appropriate tradeoff depends on the situation. But it&amp;rsquo;s a handy tool, especially when the content doesn&amp;rsquo;t change noticeably between items, and the user might not even realize they were looking at a stale version for a second.</source>
          <target state="translated">それが適切なトレードオフであるかどうかは、状況によって異なります。しかし、特にアイテム間でコンテンツが著しく変化せず、ユーザーが古いバージョンを1秒間見ていたことにユーザーが気付かない場合に、これは便利なツールです。</target>
        </trans-unit>
        <trans-unit id="5313bb949a427d6a34ce0619291d083860ef68d3" translate="yes" xml:space="preserve">
          <source>Whether you declare a component &lt;a href=&quot;#function-and-class-components&quot;&gt;as a function or a class&lt;/a&gt;, it must never modify its own props. Consider this &lt;code&gt;sum&lt;/code&gt; function:</source>
          <target state="translated">コンポーネント&lt;a href=&quot;#function-and-class-components&quot;&gt;を関数として&lt;/a&gt;宣言する場合でも、クラスとして宣言する場合でも、コンポーネント自体のプロパティを変更することはできません。この &lt;code&gt;sum&lt;/code&gt; 関数を考えてみます</target>
        </trans-unit>
        <trans-unit id="9cfad9062c1b8c8d17794fcb8f3a2452cc2e5ab6" translate="yes" xml:space="preserve">
          <source>Which versions of React include Hooks?</source>
          <target state="translated">ReactのどのバージョンにHooksが含まれていますか?</target>
        </trans-unit>
        <trans-unit id="911be78ca9d90df9dbf3aeb3c82775a99547aee6" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;this.props&lt;/code&gt; is set up by React itself and &lt;code&gt;this.state&lt;/code&gt; has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn&amp;rsquo;t participate in the data flow (like a timer ID).</source>
          <target state="translated">一方で &lt;code&gt;this.props&lt;/code&gt; は、それ自体を反応させ、によって設定され &lt;code&gt;this.state&lt;/code&gt; は特別な意味を持っている、あなたは、タイマーIDなどのデータの流れ（に参加していない何かを格納する必要がある場合は、手動でクラスにフィールドを追加するのは自由です）。</target>
        </trans-unit>
        <trans-unit id="1aba78d4a4d0f9fe12fa522d168cd8b574a0e353" translate="yes" xml:space="preserve">
          <source>While declaring a variable and using an &lt;code&gt;if&lt;/code&gt; statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below.</source>
          <target state="translated">変数を宣言して &lt;code&gt;if&lt;/code&gt; ステートメントを使用することは、コンポーネントを条件付きでレンダリングするための優れた方法ですが、短い構文を使用したい場合があります。JSXで条件をインライン化する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="11e78dcc3d744f87f73cd2a47f9767fd1932daf4" translate="yes" xml:space="preserve">
          <source>While it is generally recommended to use unidirectional data flow such as &lt;a href=&quot;lifting-state-up&quot;&gt;React state&lt;/a&gt;, &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, or &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt;, React components can use a model layer from other frameworks and libraries.</source>
          <target state="translated">&lt;a href=&quot;lifting-state-up&quot;&gt;React state&lt;/a&gt;、&lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;、&lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt;などの単方向データフローを使用することをお勧めしますが、Reactコンポーネントは他のフレームワークやライブラリのモデルレイヤーを使用できます。</target>
        </trans-unit>
        <trans-unit id="9cb5eb9a797258730eedaeda45aa9df92fecc85e" translate="yes" xml:space="preserve">
          <source>While the convention for higher-order components is to pass through all props to the wrapped component, this does not work for refs. That&amp;rsquo;s because &lt;code&gt;ref&lt;/code&gt; is not really a prop &amp;mdash; like &lt;code&gt;key&lt;/code&gt;, it&amp;rsquo;s handled specially by React. If you add a ref to an element whose component is the result of a HOC, the ref refers to an instance of the outermost container component, not the wrapped component.</source>
          <target state="translated">高次コンポーネントの規則はすべての小道具を通過してラップされたコンポーネントに渡すことですが、これは参照に対しては機能しません。これは、 &lt;code&gt;ref&lt;/code&gt; が実際にはプロップではないためです&amp;mdash; &lt;code&gt;key&lt;/code&gt; のように、Reactによって特別に処理されます。コンポーネントがHOCの結果である要素に参照を追加する場合、参照は、ラップされたコンポーネントではなく、最も外側のコンテナーコンポーネントのインスタンスを参照します。</target>
        </trans-unit>
        <trans-unit id="80619f6a762505ca83687945b18212f2b9eaa056" translate="yes" xml:space="preserve">
          <source>While this is a very important accessibility feature, it is also a technique that should be used judiciously. Use it to repair the keyboard focus flow when it is disturbed, not to try and anticipate how users want to use applications.</source>
          <target state="translated">これは非常に重要なアクセシビリティ機能ですが、慎重に使うべきテクニックでもあります。ユーザーがどのようにアプリケーションを使いたいかを予測しようとするのではなく、キーボードのフォーカスの流れが乱れたときに修復するために使いましょう。</target>
        </trans-unit>
        <trans-unit id="fd59be0b1a677335857ab70d19708469811c4d18" translate="yes" xml:space="preserve">
          <source>While this is less common, sometimes you might need multiple &amp;ldquo;holes&amp;rdquo; in a component. In such cases you may come up with your own convention instead of using &lt;code&gt;children&lt;/code&gt;:</source>
          <target state="translated">これはあまり一般的ではありませんが、コンポーネントに複数の「穴」が必要になる場合があります。このような場合、 &lt;code&gt;children&lt;/code&gt; を使用する代わりに独自の規則を考え出すことができます。</target>
        </trans-unit>
        <trans-unit id="ceea2b7f2101d3dab298a7e0940196ece8e3cb89" translate="yes" xml:space="preserve">
          <source>While this is not supported today, in the future we plan to let &lt;code&gt;Suspense&lt;/code&gt; handle more scenarios such as data fetching. You can read about this in &lt;a href=&quot;https://reactjs.org/blog/2018/11/27/react-16-roadmap.html&quot;&gt;our roadmap&lt;/a&gt;.</source>
          <target state="translated">これは現在サポートされていませんが、将来的には、データのフェッチなどのシナリオを &lt;code&gt;Suspense&lt;/code&gt; で処理できるようにする予定です。これについては&lt;a href=&quot;https://reactjs.org/blog/2018/11/27/react-16-roadmap.html&quot;&gt;ロードマップ&lt;/a&gt;で読むことができます。</target>
        </trans-unit>
        <trans-unit id="f2a90b6d038e43771f66fdf8ac4ad272e8778019" translate="yes" xml:space="preserve">
          <source>While this is possible today, it can be difficult to orchestrate. In Concurrent Mode, this feature is built-in. React starts preparing the new screen in memory first &amp;mdash; or, as our metaphor goes, &amp;ldquo;on a different branch&amp;rdquo;. So React can wait before updating the DOM so that more content can load. In Concurrent Mode, we can tell React to keep showing the old screen, fully interactive, with an inline loading indicator. And when the new screen is ready, React can take us to it.</source>
          <target state="translated">これは今日では可能ですが、オーケストレーションするのは難しい場合があります。並行モードでは、この機能が組み込まれています。Reactは最初にメモリ内の新しい画面の準備を開始します&amp;mdash;または、私たちの比喩が進むにつれ、「別のブランチで」。したがって、ReactはDOMを更新する前に待機できるため、より多くのコンテンツをロードできます。並行モードでは、インライン読み込みインジケーターを使用して、完全にインタラクティブな古い画面を表示し続けるようにReactに指示できます。そして、新しい画面の準備ができると、Reactがその画面に移動します。</target>
        </trans-unit>
        <trans-unit id="46d7e7d15375515d6dc839c8d2bfd40fc2b4dadb" translate="yes" xml:space="preserve">
          <source>While you could &lt;a href=&quot;#adding-a-ref-to-a-class-component&quot;&gt;add a ref to the child component&lt;/a&gt;, this is not an ideal solution, as you would only get a component instance rather than a DOM node. Additionally, this wouldn&amp;rsquo;t work with function components.</source>
          <target state="translated">&lt;a href=&quot;#adding-a-ref-to-a-class-component&quot;&gt;子コンポーネントにrefを追加する&lt;/a&gt;こともできますが、DOMノードではなくコンポーネントインスタンスしか取得できないため、これは理想的なソリューションではありません。さらに、これは関数コンポーネントでは機能しません。</target>
        </trans-unit>
        <trans-unit id="495b742205ad82447d68cc34f99288cca84b04a8" translate="yes" xml:space="preserve">
          <source>While you probably &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;don&amp;rsquo;t need it&lt;/a&gt;, in rare cases that you do (such as implementing a &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; component), you can update the state right during rendering. React will re-run the component with updated state immediately after exiting the first render so it wouldn&amp;rsquo;t be expensive.</source>
          <target state="translated">おそらく&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;必要ない&lt;/a&gt;かもしれませんが、まれに（ &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; コンポーネントの実装など）、レンダリング中に状態を更新できます。Reactは、最初のレンダリングを終了した直後に、更新された状態でコンポーネントを再実行するため、コストがかかりません。</target>
        </trans-unit>
        <trans-unit id="5ad1fd6b46143604bd95b453287adc7e23e0fcff" translate="yes" xml:space="preserve">
          <source>While you shouldn&amp;rsquo;t need this often, you may expose some imperative methods to a parent component with the &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt; Hook.</source>
          <target state="translated">これは頻繁には必要ありませんが、&lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt; &lt;code&gt;useImperativeHandle&lt;/code&gt; &lt;/a&gt;フックを使用して、いくつかの命令型メソッドを親コンポーネントに公開できます。</target>
        </trans-unit>
        <trans-unit id="9fb67a6e3ebb0c4884c03542ed4d02cc6e3b26d7" translate="yes" xml:space="preserve">
          <source>Who Is This Experimental Release For?</source>
          <target state="translated">この実験的なリリースは誰のためのものですか?</target>
        </trans-unit>
        <trans-unit id="49c3abb6796bdac1acab2ff039684dce6186a9f6" translate="yes" xml:space="preserve">
          <source>Why Accessibility?</source>
          <target state="translated">なぜアクセシビリティなのか?</target>
        </trans-unit>
        <trans-unit id="f8b6dc9d0e248f1aca599f0014bcad47284d99a8" translate="yes" xml:space="preserve">
          <source>Why JSX?</source>
          <target state="translated">なぜJSXなのか?</target>
        </trans-unit>
        <trans-unit id="3fec80c558c9db1e52790dd2506e452dfd97b669" translate="yes" xml:space="preserve">
          <source>Why So Many Modes?</source>
          <target state="translated">なぜこんなに多くのモードがあるのか?</target>
        </trans-unit>
        <trans-unit id="ce0a06b1d50f03b0c1677ffc7fc4f387ed59572e" translate="yes" xml:space="preserve">
          <source>Why am I seeing stale props or state inside my function?</source>
          <target state="translated">なぜ私は、私の機能の中に陳腐な小道具や状態を見ているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="0492b756ff8e4f6df5b3fc7ff6de3541b68d8908" translate="yes" xml:space="preserve">
          <source>Why does our &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;last Suspense example&lt;/a&gt; log a warning when clicking the &amp;ldquo;Next&amp;rdquo; button?</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;最後のサスペンスの例で&lt;/a&gt;「次へ」ボタンをクリックすると警告がログに記録されるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="65762af3a54e62fab1249620c4413deaa6a70304" translate="yes" xml:space="preserve">
          <source>Why doesn&amp;rsquo;t React update &lt;code&gt;this.state&lt;/code&gt; synchronously?</source>
          <target state="translated">Reactが &lt;code&gt;this.state&lt;/code&gt; を同期的に更新しないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="edf9c3c0fe5bd6b0114a879913f827631f515543" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;setState&lt;/code&gt; giving me the wrong value?</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; が間違った値を返すのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="148cbb2bff9a010f21a0ad216df38f1c5d2cd471" translate="yes" xml:space="preserve">
          <source>Why is binding necessary at all?</source>
          <target state="translated">なぜバインディングが全く必要なのか?</target>
        </trans-unit>
        <trans-unit id="f119dd9eafd6f8c4ac0cc157b3a167f93ba90cf5" translate="yes" xml:space="preserve">
          <source>Why is my function being called every time the component renders?</source>
          <target state="translated">コンポーネントがレンダリングされるたびに関数が呼び出されるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="c2085905cfd406c9e6d8d4068c20801835544c3f" translate="yes" xml:space="preserve">
          <source>Why the &lt;code&gt;crossorigin&lt;/code&gt; Attribute?</source>
          <target state="translated">なぜ &lt;code&gt;crossorigin&lt;/code&gt; 属性なのか？</target>
        </trans-unit>
        <trans-unit id="aab036cb04b8ab29e50f15ba17971446021a2255" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;PropTypes.element&lt;/code&gt; you can specify that only a single child can be passed to a component as children.</source>
          <target state="translated">では &lt;code&gt;PropTypes.element&lt;/code&gt; あなただけの単一の子供は子供としてコンポーネントに渡すことができるように指定することができます。</target>
        </trans-unit>
        <trans-unit id="0b569b9d21bf8d1be58d672f5980773d97d54e66" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, this is not necessary because it binds all methods:</source>
          <target state="translated">&lt;code&gt;createReactClass()&lt;/code&gt; それはすべてのメソッドを結合するので、これは必要ありません。</target>
        </trans-unit>
        <trans-unit id="d4883092ff15971d97a8aa837d13ef100a68d5eb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, you have to provide a separate &lt;code&gt;getInitialState&lt;/code&gt; method that returns the initial state:</source>
          <target state="translated">&lt;code&gt;createReactClass()&lt;/code&gt; 、あなたは別の提供する必要が &lt;code&gt;getInitialState&lt;/code&gt; の初期状態を返すメソッドを：</target>
        </trans-unit>
        <trans-unit id="50f377ba092fa5d0a0d282bc37a4c8ec440e268f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, you need to define &lt;code&gt;getDefaultProps()&lt;/code&gt; as a function on the passed object:</source>
          <target state="translated">&lt;code&gt;createReactClass()&lt;/code&gt; 、あなたが定義する必要があり &lt;code&gt;getDefaultProps()&lt;/code&gt; 渡されたオブジェクト上の機能としては：</target>
        </trans-unit>
        <trans-unit id="df984bf31d472187d2e254fc8283606d23024bfe" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;useTransition&lt;/code&gt;, we can opt into showing a Pending state first instead. This will keep us on the previous screen while the next screen is being prepared.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 、我々は最初の代わりに、保留中の状態を示すに選ぶことができます。これにより、次の画面が準備されている間、前の画面に留まります。</target>
        </trans-unit>
        <trans-unit id="0ece6ef7273f365ef2fee3cd6066494eec178a85" translate="yes" xml:space="preserve">
          <source>With Hooks, you can extract stateful logic from a component so it can be tested independently and reused. &lt;strong&gt;Hooks allow you to reuse stateful logic without changing your component hierarchy.&lt;/strong&gt; This makes it easy to share Hooks among many components or with the community.</source>
          <target state="translated">フックを使用すると、コンポーネントからステートフルロジックを抽出できるため、コンポーネントを個別にテストして再利用できます。&lt;strong&gt;フックを使用すると、コンポーネントの階層を変更せずにステートフルロジックを再利用できます。&lt;/strong&gt;これにより、多くのコンポーネント間またはコミュニティとフックを簡単に共有できます。</target>
        </trans-unit>
        <trans-unit id="3d1aed9937b8f4a875f46194f502d03b524dc6dd" translate="yes" xml:space="preserve">
          <source>With JSX you pass a function as the event handler, rather than a string.</source>
          <target state="translated">JSXでは、イベントハンドラとして文字列ではなく関数を渡します。</target>
        </trans-unit>
        <trans-unit id="ed4bd933c03f851c13ccd2147932475182887d8e" translate="yes" xml:space="preserve">
          <source>With React, typically you only need to bind the methods you &lt;em&gt;pass&lt;/em&gt; to other components. For example, &lt;code&gt;&amp;lt;button onClick={this.handleClick}&amp;gt;&lt;/code&gt; passes &lt;code&gt;this.handleClick&lt;/code&gt; so you want to bind it. However, it is unnecessary to bind the &lt;code&gt;render&lt;/code&gt; method or the lifecycle methods: we don&amp;rsquo;t pass them to other components.</source>
          <target state="translated">Reactでは、通常、他のコンポーネントに&lt;em&gt;渡す&lt;/em&gt;メソッドをバインドするだけで済みます。たとえば、 &lt;code&gt;&amp;lt;button onClick={this.handleClick}&amp;gt;&lt;/code&gt; は &lt;code&gt;this.handleClick&lt;/code&gt; を渡すため、バインドします。ただし、 &lt;code&gt;render&lt;/code&gt; メソッドやライフサイクルメソッドをバインドする必要はありません。これらを他のコンポーネントに渡すことはありません。</target>
        </trans-unit>
        <trans-unit id="e7344e4dadc3909a3335b74575ebf433ba99c5ed" translate="yes" xml:space="preserve">
          <source>With Suspense, handling fetching errors works the same way as handling rendering errors &amp;mdash; you can render an &lt;a href=&quot;error-boundaries&quot;&gt;error boundary&lt;/a&gt; anywhere to &amp;ldquo;catch&amp;rdquo; errors in components below.</source>
          <target state="translated">Suspenseでは、フェッチエラーの処理はレンダリングエラーの処理と同じように機能します。&lt;a href=&quot;error-boundaries&quot;&gt;エラー境界を&lt;/a&gt;どこにでもレンダリングして、以下のコンポーネントのエラーを「キャッチ」できます。</target>
        </trans-unit>
        <trans-unit id="9efd00870544783d51928530a161bc172e3d880f" translate="yes" xml:space="preserve">
          <source>With Suspense, we still start fetching first, but we flip the last two steps around:</source>
          <target state="translated">サスペンスの場合は、最初に取りに行くが、最後の2段階を反転させる。</target>
        </trans-unit>
        <trans-unit id="71a13a4bc9a257a4e9bafbaa0cf86edb5925dd2a" translate="yes" xml:space="preserve">
          <source>With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. For example, if we wanted to enforce that names are written with all uppercase letters, we could write &lt;code&gt;handleChange&lt;/code&gt; as:</source>
          <target state="translated">制御されたコンポーネントを使用すると、すべての状態変化にハンドラー関数が関連付けられます。これにより、ユーザー入力の変更または検証が簡単になります。たとえば、名前がすべて大文字で記述されるようにしたい場合は、 &lt;code&gt;handleChange&lt;/code&gt; を次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="67500667906c2a530542da2c6f7b33bdea261d21" translate="yes" xml:space="preserve">
          <source>With functions and ES6 classes &lt;code&gt;defaultProps&lt;/code&gt; is defined as a property on the component itself:</source>
          <target state="translated">関数とES6クラスでは、 &lt;code&gt;defaultProps&lt;/code&gt; はコンポーネント自体のプロパティとして定義されます。</target>
        </trans-unit>
        <trans-unit id="cb4872f49b4f73a2d9aa1f1ea9382a37bb1b4523" translate="yes" xml:space="preserve">
          <source>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to &lt;code&gt;ReactDOM.render()&lt;/code&gt;.</source>
          <target state="translated">これまでの知識では、UIを更新する唯一の方法は、新しい要素を作成し、それを &lt;code&gt;ReactDOM.render()&lt;/code&gt; に渡すことです。</target>
        </trans-unit>
        <trans-unit id="061b1b684b37fa6e01cf5d46650b25478b6d35f1" translate="yes" xml:space="preserve">
          <source>With that out of the way, let&amp;rsquo;s get started!</source>
          <target state="translated">これで、始めましょう！</target>
        </trans-unit>
        <trans-unit id="e970431e1cb945a83be8e8c9ff751a9c325a5c21" translate="yes" xml:space="preserve">
          <source>With the example above, the &lt;code&gt;Post&lt;/code&gt; component can read &lt;code&gt;props.id&lt;/code&gt;, but not &lt;code&gt;props.key&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;Post&lt;/code&gt; コンポーネントは &lt;code&gt;props.id&lt;/code&gt; を読み取ることができますが、props.keyを読み取ることはできませ &lt;code&gt;props.key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7a845306b0978a35ad4c18a5ccd1c03f8079bcf" translate="yes" xml:space="preserve">
          <source>With this approach, we can &lt;strong&gt;fetch code and data in parallel&lt;/strong&gt;. When we navigate between pages, we don&amp;rsquo;t need to wait for a page&amp;rsquo;s code to load to start loading its data. We can start fetching both code and data at the same time (during the link click), delivering a much better user experience.</source>
          <target state="translated">このアプローチでは、&lt;strong&gt;コードとデータを並行してフェッチ&lt;/strong&gt;でき&lt;strong&gt;ます&lt;/strong&gt;。ページ間を移動するとき、データの読み込みを開始するためにページのコードが読み込まれるのを待つ必要はありません。コードとデータの両方を同時に（リンクのクリック中に）取得できるため、ユーザーエクスペリエンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="ca794ea7a32fb93f5c86146905ba234d1fd33e3a" translate="yes" xml:space="preserve">
          <source>With this change, even though we&amp;rsquo;re in the Pending state, we don&amp;rsquo;t display any indication to the user until 500ms has passed. This may not seem like much of an improvement when the API responses are slow. But compare how it feels &lt;a href=&quot;https://codesandbox.io/s/thirsty-liskov-1ygph&quot;&gt;before&lt;/a&gt; and &lt;a href=&quot;https://codesandbox.io/s/hardcore-http-s18xr&quot;&gt;after&lt;/a&gt; when the API call is fast. Even though the rest of the code hasn&amp;rsquo;t changed, suppressing a &amp;ldquo;too fast&amp;rdquo; loading state improves the perceived performance by not calling attention to the delay.</source>
          <target state="translated">この変更により、Pending状態であっても、500ミリ秒が経過するまでユーザーに何も表示されません。APIの応答が遅い場合、これはあまり改善されていないように見えます。しかし、それはどのように感じ、比較&lt;a href=&quot;https://codesandbox.io/s/thirsty-liskov-1ygph&quot;&gt;の前&lt;/a&gt;と&lt;a href=&quot;https://codesandbox.io/s/hardcore-http-s18xr&quot;&gt;後&lt;/a&gt;のAPI呼び出しが速い場合。コードの残りの部分は変更されていませんが、「速すぎる」ロード状態を抑制すると、遅延に注意を向けないため、知覚されるパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="5635b27b3f3a955ac587a6317f7e72991a8317f4" translate="yes" xml:space="preserve">
          <source>With this change, it works as expected. We can type into the input immediately, and the translation later &amp;ldquo;catches up&amp;rdquo; to what we have typed.</source>
          <target state="translated">この変更により、期待どおりに動作します。入力をすぐに入力することができ、翻訳は後で入力した内容に「追いつきます」。</target>
        </trans-unit>
        <trans-unit id="ce08b851d8dd00fc80cae81cb3eb7b40fcfc82a3" translate="yes" xml:space="preserve">
          <source>With this change, only the top-most Page component needs to know about the &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components&amp;rsquo; use of &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt;.</source>
          <target state="translated">この変更により、最上位のPageコンポーネントのみが、 &lt;code&gt;Link&lt;/code&gt; および &lt;code&gt;Avatar&lt;/code&gt; コンポーネントによる &lt;code&gt;user&lt;/code&gt; および &lt;code&gt;avatarSize&lt;/code&gt; の使用について知る必要があります。</target>
        </trans-unit>
        <trans-unit id="3eccd6c7aebe3ee7b1033ca2e41432db51ce2ee2" translate="yes" xml:space="preserve">
          <source>Wrap Lazy Features in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; でのレイジー機能のラップ</target>
        </trans-unit>
        <trans-unit id="a87b9174801725911157c6c5b05263b9d0b4efa5" translate="yes" xml:space="preserve">
          <source>Wrapping setState in a Transition</source>
          <target state="translated">トランジションでの setState のラッピング</target>
        </trans-unit>
        <trans-unit id="560b6056cd03b4bbd6db601b466123014a92c0b9" translate="yes" xml:space="preserve">
          <source>Writing Conversion Functions</source>
          <target state="translated">変換関数の記述</target>
        </trans-unit>
        <trans-unit id="62d53daf650bb95bca68a82e9c932fea369dd88e" translate="yes" xml:space="preserve">
          <source>Yes! The &lt;a href=&quot;hooks-reference#useref&quot;&gt;&lt;code&gt;useRef()&lt;/code&gt;&lt;/a&gt; Hook isn&amp;rsquo;t just for DOM refs. The &amp;ldquo;ref&amp;rdquo; object is a generic container whose &lt;code&gt;current&lt;/code&gt; property is mutable and can hold any value, similar to an instance property on a class.</source>
          <target state="translated">はい！&lt;a href=&quot;hooks-reference#useref&quot;&gt; &lt;code&gt;useRef()&lt;/code&gt; &lt;/a&gt;フックは単にDOMレフリーのためではありません。「ref」オブジェクトは、 &lt;code&gt;current&lt;/code&gt; プロパティが変更可能で、クラスのインスタンスプロパティと同様に任意の値を保持できる汎用コンテナです。</target>
        </trans-unit>
        <trans-unit id="d3e5b9e5308a5e4ac25712b025d561cb9020c6ad" translate="yes" xml:space="preserve">
          <source>Yes, see the docs on styling &lt;a href=&quot;dom-elements#style&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">はい、スタイリングに関するドキュメントは&lt;a href=&quot;dom-elements#style&quot;&gt;こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c94219b317ac261806da31fa074e0f23cb0d9f1" translate="yes" xml:space="preserve">
          <source>Yes. See &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;conditionally firing an effect&lt;/a&gt;. Note that forgetting to handle updates often &lt;a href=&quot;hooks-effect#explanation-why-effects-run-on-each-update&quot;&gt;introduces bugs&lt;/a&gt;, which is why this isn&amp;rsquo;t the default behavior.</source>
          <target state="translated">はい。&lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;条件付きのエフェクトの発射を&lt;/a&gt;参照してください。更新の処理を忘れると&lt;a href=&quot;hooks-effect#explanation-why-effects-run-on-each-update&quot;&gt;バグが発生&lt;/a&gt;することが多いため、これがデフォルトの動作ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4dcce6c1701948f7d9bfd3db4ed94bd67e027e5c" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;don&amp;rsquo;t have to&lt;/strong&gt; use many state variables. State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike &lt;code&gt;this.setState&lt;/code&gt; in a class, updating a state variable always &lt;em&gt;replaces&lt;/em&gt; it instead of merging it.</source>
          <target state="translated">多くの状態変数&lt;strong&gt;を&lt;/strong&gt;使用する&lt;strong&gt;必要はありません&lt;/strong&gt;。状態変数はオブジェクトと配列を適切に保持できるため、関連するデータをグループ化できます。ただし、クラスの &lt;code&gt;this.setState&lt;/code&gt; とは異なり、状態変数を更新すると、マージするのではなく、常に&lt;em&gt;置き換え&lt;/em&gt;られます。</target>
        </trans-unit>
        <trans-unit id="9a4b1f324495e2f088e3d6f0cdc9f89fb5cd9262" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;may call &lt;code&gt;setState()&lt;/code&gt; immediately&lt;/strong&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the &lt;code&gt;render()&lt;/code&gt; will be called twice in this case, the user won&amp;rsquo;t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the &lt;code&gt;constructor()&lt;/code&gt; instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.</source>
          <target state="translated">あなたは&lt;strong&gt;呼び出すことが &lt;code&gt;setState()&lt;/code&gt; すぐ&lt;/strong&gt;に &lt;code&gt;componentDidMount()&lt;/code&gt; 。追加のレンダリングがトリガーされますが、ブラウザが画面を更新する前に発生します。これにより、この場合 &lt;code&gt;render()&lt;/code&gt; が2回呼び出されても、ユーザーには中間状態が表示されないことが保証されます。このパターンはパフォーマンスの問題を引き起こすことが多いため、注意して使用してください。ほとんどの場合、代わりに &lt;code&gt;constructor()&lt;/code&gt; で初期状態を割り当てることができるはずです。ただし、サイズや位置に依存するものをレンダリングする前にDOMノードを測​​定する必要がある場合は、モーダルやツールチップなどの場合に必要になることがあります。</target>
        </trans-unit>
        <trans-unit id="0fffd92980fb270dfc644a9073a729e972320668" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;may call &lt;code&gt;setState()&lt;/code&gt; immediately&lt;/strong&gt; in &lt;code&gt;componentDidUpdate()&lt;/code&gt; but note that &lt;strong&gt;it must be wrapped in a condition&lt;/strong&gt; like in the example above, or you&amp;rsquo;ll cause an infinite loop. It would also cause an extra re-rendering which, while not visible to the user, can affect the component performance. If you&amp;rsquo;re trying to &amp;ldquo;mirror&amp;rdquo; some state to a prop coming from above, consider using the prop directly instead. Read more about &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;why copying props into state causes bugs&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;は&lt;/strong&gt;、 &lt;code&gt;componentDidUpdate()&lt;/code&gt; &lt;strong&gt;（）で&lt;/strong&gt;&lt;strong&gt;すぐ&lt;/strong&gt;に&lt;strong&gt;呼び出す&lt;/strong&gt;こと&lt;strong&gt;が&lt;/strong&gt;できますが、上記の例のような&lt;strong&gt;条件でラップする必要が&lt;/strong&gt;ある&lt;strong&gt;ことに&lt;/strong&gt;注意し&lt;strong&gt;てください。そうしないと&lt;/strong&gt;、無限ループが発生します。また、追加の再レンダリングが発生し、ユーザーには見えませんが、コンポーネントのパフォーマンスに影響を与える可能性があります。上から来るプロップにいくつかの状態を「ミラーリング」しようとしている場合は、代わりにプロップを直接使用することを検討してください。&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;小道具を状態にコピーするとバグが発生する理由の&lt;/a&gt;詳細をご覧ください。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="603dad85523484256e65c5bb07930c069dda7af2" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;should not call &lt;code&gt;setState()&lt;/code&gt;&lt;/strong&gt; in &lt;code&gt;componentWillUnmount()&lt;/code&gt; because the component will never be re-rendered. Once a component instance is unmounted, it will never be mounted again.</source>
          <target state="translated">あなたは&lt;strong&gt;呼び出すべきではありません &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt;内 &lt;code&gt;componentWillUnmount()&lt;/code&gt; コンポーネントが再描画されることはありませんので。コンポーネントインスタンスがアンマウントされると、再度マウントされることはありません。</target>
        </trans-unit>
        <trans-unit id="303da79a4d02468a439c95546cb936fc2ff452ef" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;should not call &lt;code&gt;setState()&lt;/code&gt;&lt;/strong&gt; in the &lt;code&gt;constructor()&lt;/code&gt;. Instead, if your component needs to use local state, &lt;strong&gt;assign the initial state to &lt;code&gt;this.state&lt;/code&gt;&lt;/strong&gt; directly in the constructor:</source>
          <target state="translated">あなたは&lt;strong&gt;呼び出さないでください &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt;に &lt;code&gt;constructor()&lt;/code&gt; 。代わりに、コンポーネントでローカル状態を使用する必要がある場合は、コンストラクターで&lt;strong&gt; &lt;code&gt;this.state&lt;/code&gt; に&lt;/strong&gt;&lt;strong&gt;初期状態を&lt;/strong&gt;直接&lt;strong&gt;割り当て&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b1f32119d9afed969fb6dda4b28934eeedec90f3" translate="yes" xml:space="preserve">
          <source>You Might Not Need a Toolchain</source>
          <target state="translated">ツールチェーンは必要ないかもしれません</target>
        </trans-unit>
        <trans-unit id="67b66c50d30ba90262826fe97b9b36429e378815" translate="yes" xml:space="preserve">
          <source>You are now ready to code! We recommend to check out the following resources to learn more about TypeScript:</source>
          <target state="translated">これでコードを書く準備ができました。TypeScriptについて詳しく知りたい方は、以下のリソースをチェックすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="973e5c03c0fd9a741a0042c982cebb565ec5f9df" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;add-react-to-a-website&quot;&gt;add React to an HTML page in one minute&lt;/a&gt;. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</source>
          <target state="translated">&lt;a href=&quot;add-react-to-a-website&quot;&gt;1分でHTMLページにReactを追加&lt;/a&gt;できます。次に、その存在を徐々に拡大するか、またはいくつかの動的ウィジェットに含めておくことができます。</target>
        </trans-unit>
        <trans-unit id="daa0979344c5bce99fe8cd2033a94efe89e8fc6a" translate="yes" xml:space="preserve">
          <source>You can also add a wrapper DOM node in your component and attach a ref directly to it.</source>
          <target state="translated">また、コンポーネントにラッパー DOM ノードを追加し、そこに直接 ref をアタッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="349b87f9aabf27468c7550f23c44ba9943c43e8f" translate="yes" xml:space="preserve">
          <source>You can also add it to an &lt;strong&gt;existing Create React App project&lt;/strong&gt;, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/adding-typescript&quot;&gt;as documented here&lt;/a&gt;.</source>
          <target state="translated">こちらに記載されているように、&lt;strong&gt;既存のCreate React Appプロジェクト&lt;/strong&gt;に追加することもでき&lt;a href=&quot;https://facebook.github.io/create-react-app/docs/adding-typescript&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc81e5ea9298f4348d258492ffdc2b7046f666c1" translate="yes" xml:space="preserve">
          <source>You can also check out the &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API reference&lt;/a&gt; and the &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hooks-reference&quot;&gt;Hooks APIリファレンス&lt;/a&gt;と&lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ&lt;/a&gt;も確認できます。</target>
        </trans-unit>
        <trans-unit id="9d10268304c0a25dd7504dbf0c423bd8a4ff9a0c" translate="yes" xml:space="preserve">
          <source>You can also create the initial state lazily. To do this, you can pass an &lt;code&gt;init&lt;/code&gt; function as the third argument. The initial state will be set to &lt;code&gt;init(initialArg)&lt;/code&gt;.</source>
          <target state="translated">初期状態を遅延して作成することもできます。これを行うには、3番目の引数として &lt;code&gt;init&lt;/code&gt; 関数を渡します。初期状態は &lt;code&gt;init(initialArg)&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="9ce8997748b7b364b2a5b8fa6eb06cb5298fac78" translate="yes" xml:space="preserve">
          <source>You can also follow the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt; on Twitter, but you won&amp;rsquo;t miss anything essential if you only read the blog.</source>
          <target state="translated">Twitterで&lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjsアカウント&lt;/a&gt;をフォローすることもできますが、ブログを読むだけで重要なことを見逃すことはありません。</target>
        </trans-unit>
        <trans-unit id="c56670d911da74ad4acea3f7f57edb7a5fe3c872" translate="yes" xml:space="preserve">
          <source>You can also pick specific props that your component will consume while passing all other props using the spread operator.</source>
          <target state="translated">また、スプレッド演算子を使用して他のすべての小道具を通過させながら、コンポーネントが消費する特定の小道具を選択することもできます。</target>
        </trans-unit>
        <trans-unit id="e229f290934869795a385808e0402ed8f11b8ceb" translate="yes" xml:space="preserve">
          <source>You can also refer to a React component using dot-notation from within JSX. This is convenient if you have a single module that exports many React components. For example, if &lt;code&gt;MyComponents.DatePicker&lt;/code&gt; is a component, you can use it directly from JSX with:</source>
          <target state="translated">JSX内からドット表記を使用してReactコンポーネントを参照することもできます。これは、多数のReactコンポーネントをエクスポートする単一のモジュールがある場合に便利です。たとえば、 &lt;code&gt;MyComponents.DatePicker&lt;/code&gt; がコンポーネントの場合、JSXから次のように直接使用できます。</target>
        </trans-unit>
        <trans-unit id="8623b3d7d4d43f6c6f405c02d8001ad9f14ba623" translate="yes" xml:space="preserve">
          <source>You can also rewrite code that mutates objects to avoid mutation, in a similar way. For example, let&amp;rsquo;s say we have an object named &lt;code&gt;colormap&lt;/code&gt; and we want to write a function that changes &lt;code&gt;colormap.right&lt;/code&gt; to be &lt;code&gt;'blue'&lt;/code&gt;. We could write:</source>
          <target state="translated">同様に、オブジェクトを変更するコードを書き直して、変更を回避することもできます。たとえば、 &lt;code&gt;colormap&lt;/code&gt; という名前のオブジェクトがあり、 &lt;code&gt;colormap.right&lt;/code&gt; を &lt;code&gt;'blue'&lt;/code&gt; に変更する関数を作成するとします。次のように書くことができます：</target>
        </trans-unit>
        <trans-unit id="6e352e946162df801daa33ab297c25026fd93b28" translate="yes" xml:space="preserve">
          <source>You can also see the filenames and line numbers in the component stack trace. This works by default in &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; projects:</source>
          <target state="translated">コンポーネントのスタックトレースでファイル名と行番号を確認することもできます。これは、&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;プロジェクトでデフォルトで機能します。</target>
        </trans-unit>
        <trans-unit id="44310bf2359ee79a622ac37b32c6721ba10337eb" translate="yes" xml:space="preserve">
          <source>You can also traverse the output to find specific nodes and make assertions about them.</source>
          <target state="translated">また、出力をたどって特定のノードを見つけ、それらについてのアサーションを行うこともできます。</target>
        </trans-unit>
        <trans-unit id="7d16f115884d19dbbe73652d9e5c447e2ecf104b" translate="yes" xml:space="preserve">
          <source>You can also use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt; to define a component:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6クラス&lt;/a&gt;を使用してコンポーネントを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="6fd4f33bcd9d3c0110be7b31954290c1a836db0c" translate="yes" xml:space="preserve">
          <source>You can also use it with the shorthand &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; syntax. For more information, see &lt;a href=&quot;https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html&quot;&gt;React v16.2.0: Improved Support for Fragments&lt;/a&gt;.</source>
          <target state="translated">省略形の &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; 構文で使用することもできます。詳細については、&lt;a href=&quot;https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html&quot;&gt;React v16.2.0：改良されたフラグメントのサポートを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d3aeee99f3a099cb1560c2cd739565a340f73dde" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://github.com/dylanb/react-axe&quot;&gt;react-axe&lt;/a&gt; module to report these accessibility findings directly to the console while developing and debugging.</source>
          <target state="translated">また、&lt;a href=&quot;https://github.com/dylanb/react-axe&quot;&gt;react-axe&lt;/a&gt;モジュールを使用して、開発およびデバッグ中に、これらのアクセシビリティの結果をコンソールに直接報告することもできます。</target>
        </trans-unit>
        <trans-unit id="0eed65ed081006404dbb7accb393e90c7e592705" translate="yes" xml:space="preserve">
          <source>You can also use the self-closing form of the tag if there are no children. So:</source>
          <target state="translated">また、子がいない場合はタグの自閉形を使うこともできます。というわけで。</target>
        </trans-unit>
        <trans-unit id="9295f68bc1efa13ff8ed4a3e2fdaca0db413bd6c" translate="yes" xml:space="preserve">
          <source>You can also write your own integration for a data fetching library, if you&amp;rsquo;d like.</source>
          <target state="translated">必要に応じて、データフェッチライブラリの独自の統合を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="d0e2eed831e6bee471a1b051322603084a6ff5dd" translate="yes" xml:space="preserve">
          <source>You can always refer to our public GitHub repository&amp;rsquo;s &lt;a href=&quot;https://github.com/facebook/react/commits/master&quot;&gt;history&lt;/a&gt; for a comprehensive list of changes.</source>
          <target state="translated">変更の包括的なリストについては、いつでも公開GitHubリポジトリの&lt;a href=&quot;https://github.com/facebook/react/commits/master&quot;&gt;履歴&lt;/a&gt;を参照できます。</target>
        </trans-unit>
        <trans-unit id="b009a9003a97078d2cc35e3df5d168b43b897374" translate="yes" xml:space="preserve">
          <source>You can build collections of elements and &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;include them in JSX&lt;/a&gt; using curly braces &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">要素のコレクションを作成&lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;し、&lt;/a&gt;中括弧 &lt;code&gt;{}&lt;/code&gt; を使用してそれらをJSXに含めることができます。</target>
        </trans-unit>
        <trans-unit id="aef58e0c6c697aada939945a0796364fbd8020a1" translate="yes" xml:space="preserve">
          <source>You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with &lt;code&gt;FilterableProductTable&lt;/code&gt;) or with the ones lower in it (&lt;code&gt;ProductRow&lt;/code&gt;). In simpler examples, it&amp;rsquo;s usually easier to go top-down, and on larger projects, it&amp;rsquo;s easier to go bottom-up and write tests as you build.</source>
          <target state="translated">トップダウンまたはボトムアップで構築できます。つまり、階層の上位にあるコンポーネント（つまり、 &lt;code&gt;FilterableProductTable&lt;/code&gt; で始まる）を構築するか、下位のコンポーネント（ &lt;code&gt;ProductRow&lt;/code&gt; ）を構築することから始められます。単純な例では、通常、トップダウンで実行する方が簡単であり、大規模なプロジェクトでは、ビルド時にボトムアップでテストを作成する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="ced09d20e0733b6dd23b81aeb615198bfbc46731" translate="yes" xml:space="preserve">
          <source>You can compare these two examples to feel the difference:</source>
          <target state="translated">この2つの例を比較して違いを感じてみてください。</target>
        </trans-unit>
        <trans-unit id="96723e62d1953ac566e2ea02b39f6c1b0247dd57" translate="yes" xml:space="preserve">
          <source>You can continue to use the exact same APIs as you always have; they&amp;rsquo;ll continue to work.</source>
          <target state="translated">これまでとまったく同じAPIを引き続き使用できます。彼らは働き続けるでしょう。</target>
        </trans-unit>
        <trans-unit id="568c5b42327ce78962e0349e0bc941c13aa391bb" translate="yes" xml:space="preserve">
          <source>You can control how many loading states are visible at once with the &lt;code&gt;tail&lt;/code&gt; prop. If we specify &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt;, we&amp;rsquo;ll see &lt;em&gt;at most one&lt;/em&gt; fallback at the time. You can play with it &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tail&lt;/code&gt; プロップを使用して、一度に表示できるロード状態の数を制御できます。 &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt; を指定すると、一度に&lt;em&gt;最大1つの&lt;/em&gt;フォールバックが表示さ&lt;em&gt;れ&lt;/em&gt;ます。&lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;ここで&lt;/a&gt;遊ぶことができます。</target>
        </trans-unit>
        <trans-unit id="259f2bd3a3238bf87405bdcfaaa102614b981ebf" translate="yes" xml:space="preserve">
          <source>You can convert a function component like &lt;code&gt;Clock&lt;/code&gt; to a class in five steps:</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; などの関数コンポーネントを5つのステップでクラスに変換できます。</target>
        </trans-unit>
        <trans-unit id="99aa21f209e1d4380b74a754381c1adecc7d6d46" translate="yes" xml:space="preserve">
          <source>You can define default values for your &lt;code&gt;props&lt;/code&gt; by assigning to the special &lt;code&gt;defaultProps&lt;/code&gt; property:</source>
          <target state="translated">特別な &lt;code&gt;defaultProps&lt;/code&gt; プロパティに割り当てることで、 &lt;code&gt;props&lt;/code&gt; デフォルト値を定義できます。</target>
        </trans-unit>
        <trans-unit id="060ad8196b66eae31d457e14f600fdc295c2b991" translate="yes" xml:space="preserve">
          <source>You can enable strict mode for any part of your application. For example:</source>
          <target state="translated">アプリケーションの任意の部分で厳格モードを有効にすることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="31a484513ad8dd340d05d4eedab4cba055bb08f5" translate="yes" xml:space="preserve">
          <source>You can even set the function&amp;rsquo;s &lt;code&gt;displayName&lt;/code&gt; property to include the component you&amp;rsquo;re wrapping:</source>
          <target state="translated">関数の &lt;code&gt;displayName&lt;/code&gt; プロパティを設定して、ラップするコンポーネントを含めることもできます。</target>
        </trans-unit>
        <trans-unit id="4d4cf37b373742281f14985d8f8a9c6a764f4af0" translate="yes" xml:space="preserve">
          <source>You can expect updates to Latest to be extremely stable. Versions follow the semantic versioning scheme. Learn more about our commitment to stability and incremental migration in our &lt;a href=&quot;faq-versioning&quot;&gt;versioning policy&lt;/a&gt;.</source>
          <target state="translated">最新への更新は非常に安定していることが期待できます。バージョンはセマンティックバージョニングスキームに従います。&lt;a href=&quot;faq-versioning&quot;&gt;バージョニングポリシー&lt;/a&gt;で、安定性と段階的な移行への取り組みの詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="43486125276c666e322a5707b38de7e0642f9408" translate="yes" xml:space="preserve">
          <source>You can find instructions for building your app for production below.</source>
          <target state="translated">制作用のアプリを構築するための手順は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b669ecfca0f474a332753750307b5170f4d3d5ab" translate="yes" xml:space="preserve">
          <source>You can have as many such isolated components as you like, and use &lt;code&gt;ReactDOM.render()&lt;/code&gt; to render them to different DOM containers. Gradually, as you convert more of your app to React, you will be able to combine them into larger components, and move some of the &lt;code&gt;ReactDOM.render()&lt;/code&gt; calls up the hierarchy.</source>
          <target state="translated">このような分離されたコンポーネントはいくつでも持つことができ、 &lt;code&gt;ReactDOM.render()&lt;/code&gt; を使用してそれらを異なるDOMコンテナにレンダリングします。徐々に、より多くのアプリをReactに変換するにつれて、それらをより大きなコンポーネントに結合し、 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 呼び出しの一部を階層の上に移動できるようになります。</target>
        </trans-unit>
        <trans-unit id="59a095baf122e4a8f541350370263b19ef77da11" translate="yes" xml:space="preserve">
          <source>You can imagine that in a large app, this same pattern of subscribing to &lt;code&gt;DataSource&lt;/code&gt; and calling &lt;code&gt;setState&lt;/code&gt; will occur over and over again. We want an abstraction that allows us to define this logic in a single place and share it across many components. This is where higher-order components excel.</source>
          <target state="translated">大規模なアプリでは、 &lt;code&gt;DataSource&lt;/code&gt; へのサブスクライブと &lt;code&gt;setState&lt;/code&gt; の呼び出しという同じパターンが繰り返し発生することを想像できます。このロジックを1か所で定義し、多くのコンポーネント間で共有できるようにする抽象化が必要です。これは、高次コンポーネントが優れているところです。</target>
        </trans-unit>
        <trans-unit id="c2607b19c795cb6467d715b76b65c4f83582007c" translate="yes" xml:space="preserve">
          <source>You can instead make this explicit by passing a ref to your custom component and pass that along to the DOM using &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;ref forwarding&lt;/a&gt;.</source>
          <target state="translated">代わりに、カスタムコンポーネントに参照を渡し、&lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;参照転送&lt;/a&gt;を使用してそれをDOMに渡すことで、これを明示的にすることができます。</target>
        </trans-unit>
        <trans-unit id="e58d88ea64ac854e8b852850131003a5b38dfe8b" translate="yes" xml:space="preserve">
          <source>You can learn how to use it from our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting documentation&lt;/a&gt;. You might also want to check out &lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;this article&lt;/a&gt; explaining how to use it in more detail.</source>
          <target state="translated">&lt;a href=&quot;code-splitting#reactlazy&quot;&gt;コード分​​割のドキュメント&lt;/a&gt;から使用方法を学ぶことができます。また、使用方法を詳しく説明した&lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;この記事&lt;/a&gt;もご覧ください。</target>
        </trans-unit>
        <trans-unit id="0405db67bd6f9d08d2f8547c2ca89d3bc11fef3e" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;a href=&quot;conditional-rendering&quot;&gt;conditional rendering&lt;/a&gt; and &lt;a href=&quot;lists-and-keys&quot;&gt;loops&lt;/a&gt; in the corresponding sections.</source>
          <target state="translated">&lt;a href=&quot;conditional-rendering&quot;&gt;条件付きレンダリング&lt;/a&gt;と&lt;a href=&quot;lists-and-keys&quot;&gt;ループの&lt;/a&gt;詳細については、対応するセクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="ebdc3d81678cb41b857c269d907b419fc833fc42" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;useEffect&lt;/code&gt; on a dedicated page: &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.</source>
          <target state="translated">専用ページの&lt;a href=&quot;hooks-effect&quot;&gt;「エフェクトフックの使用&lt;/a&gt;」で、 &lt;code&gt;useEffect&lt;/code&gt; の詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="2190fea105b1a5c2c5132e45309d084e938f0fab" translate="yes" xml:space="preserve">
          <source>You can learn more about all the built-in Hooks on a dedicated page: &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API Reference&lt;/a&gt;.</source>
          <target state="translated">すべての組み込みフックの詳細については、専用ページの&lt;a href=&quot;hooks-reference&quot;&gt;フックAPIリファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="dd76f44fa000769bfbb88ab6451d678fd499b34e" translate="yes" xml:space="preserve">
          <source>You can learn more about custom Hooks on a dedicated page: &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks&lt;/a&gt;.</source>
          <target state="translated">カスタムフックの詳細については、専用ページの作成：&lt;a href=&quot;hooks-custom&quot;&gt;独自のフックの&lt;/a&gt;作成をご覧ください。</target>
        </trans-unit>
        <trans-unit id="44e6a6a3a05e18341e61e8b581459673e8664c2b" translate="yes" xml:space="preserve">
          <source>You can learn more about the State Hook on a dedicated page: &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.</source>
          <target state="translated">ステートフックの詳細については、専用ページの&lt;a href=&quot;hooks-state&quot;&gt;「ステートフックの使用&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="9ded04d381f1d8a8f1862e047aac6e2b430518c7" translate="yes" xml:space="preserve">
          <source>You can learn more about these rules on a dedicated page: &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">これらのルールの詳細については、専用ページ：&lt;a href=&quot;hooks-rules&quot;&gt;フックのルールを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b4a8afdfc0befb4880f75b37590103ef140b8332" translate="yes" xml:space="preserve">
          <source>You can learn more about this in &lt;a href=&quot;https://webpack.js.org/guides/production/&quot;&gt;webpack documentation&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://webpack.js.org/guides/production/&quot;&gt;webpackのドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="6defc311d97882551acc89862aaa8211b5ccb8bf" translate="yes" xml:space="preserve">
          <source>You can map a collection of items to an array of fragments as you would any other type of element as well:</source>
          <target state="translated">他のタイプの要素と同様に、アイテムのコレクションをフラグメントの配列にマップすることができます。</target>
        </trans-unit>
        <trans-unit id="c39e023484eeec5fc7042f79a35e6d4e7bc21cde" translate="yes" xml:space="preserve">
          <source>You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML:</source>
          <target state="translated">異なるタイプの子を混ぜることができるので、JSXの子と文字列リテラルを一緒に使うことができます。これもJSXがHTMLのようなものであるため、これは有効なJSXと有効なHTMLの両方であるということになります。</target>
        </trans-unit>
        <trans-unit id="68923457893fc208ce455a8d754f8df854066e43" translate="yes" xml:space="preserve">
          <source>You can only subscribe to a single context using this API. If you need to read more than one see &lt;a href=&quot;#consuming-multiple-contexts&quot;&gt;Consuming Multiple Contexts&lt;/a&gt;.</source>
          <target state="translated">このAPIを使用してサブスクライブできるのは単一のコンテキストのみです。複数を読む必要がある場合は、&lt;a href=&quot;#consuming-multiple-contexts&quot;&gt;複数のコンテキストの消費を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3c0539a6d8aab194914bf2c1b637a40462054bec" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;createNodeMock&lt;/code&gt; function to &lt;code&gt;TestRenderer.create&lt;/code&gt; as the option, which allows for custom mock refs. &lt;code&gt;createNodeMock&lt;/code&gt; accepts the current element and should return a mock ref object. This is useful when you test a component that relies on refs.</source>
          <target state="translated">あなたは渡すことができ &lt;code&gt;createNodeMock&lt;/code&gt; のに機能を &lt;code&gt;TestRenderer.create&lt;/code&gt; カスタムモック、参考文献を可能オプションとして。 &lt;code&gt;createNodeMock&lt;/code&gt; は現在の要素を受け入れ、モック参照オブジェクトを返す必要があります。これは、参照に依存するコンポーネントをテストするときに役立ちます。</target>
        </trans-unit>
        <trans-unit id="60a31b4af9209c82ad0c032eb8bd56c3135e3e31" translate="yes" xml:space="preserve">
          <source>You can pass a string literal as a prop. These two JSX expressions are equivalent:</source>
          <target state="translated">プロップとして文字列リテラルを渡すことができます。この2つのJSX式は同等です。</target>
        </trans-unit>
        <trans-unit id="98e2514deb58f721583921f9f4558ca15319f866" translate="yes" xml:space="preserve">
          <source>You can pass an array into the &lt;code&gt;value&lt;/code&gt; attribute, allowing you to select multiple options in a &lt;code&gt;select&lt;/code&gt; tag:</source>
          <target state="translated">配列を &lt;code&gt;value&lt;/code&gt; 属性に渡して、 &lt;code&gt;select&lt;/code&gt; タグで複数のオプションを選択できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="6c0dca775a62dc92cd4d4ca42033a80bb40b933d" translate="yes" xml:space="preserve">
          <source>You can pass any JavaScript expression as a prop, by surrounding it with &lt;code&gt;{}&lt;/code&gt;. For example, in this JSX:</source>
          <target state="translated">JavaScript式を &lt;code&gt;{}&lt;/code&gt; で囲むことにより、小道具として渡すことができます。たとえば、このJSXでは次のようになります。</target>
        </trans-unit>
        <trans-unit id="820386db58d5b70925ee607029782118c88bd411" translate="yes" xml:space="preserve">
          <source>You can pass any JavaScript expression as children, by enclosing it within &lt;code&gt;{}&lt;/code&gt;. For example, these expressions are equivalent:</source>
          <target state="translated">JavaScript式を &lt;code&gt;{}&lt;/code&gt; で囲むことにより、子として渡すことができます。たとえば、これらの式は同等です。</target>
        </trans-unit>
        <trans-unit id="2ca332aa888156d7e208d864ef99671f87200fd7" translate="yes" xml:space="preserve">
          <source>You can pass callback refs between components like you can with object refs that were created with &lt;code&gt;React.createRef()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.createRef()&lt;/code&gt; で作成されたオブジェクト参照と同じように、コンポーネント間でコールバック参照を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="184b23ee4cb82f84aaf58aa94da5ac57b911db50" translate="yes" xml:space="preserve">
          <source>You can place a &amp;ldquo;container&amp;rdquo; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; like this &lt;strong&gt;anywhere&lt;/strong&gt; inside the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag. You may have as many independent DOM containers on one page as you need. They are usually empty &amp;mdash; React will replace any existing content inside DOM containers.</source>
          <target state="translated">このような「コンテナー」 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; は、 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; タグ内の&lt;strong&gt;どこにでも配置&lt;/strong&gt;できます。1つのページに必要な数の独立したDOMコンテナを配置できます。通常は空です&amp;mdash; ReactはDOMコンテナー内の既存のコンテンツを置き換えます。</target>
        </trans-unit>
        <trans-unit id="93edf3c48f793906a4695cc4a4c1f501ab4bdbd0" translate="yes" xml:space="preserve">
          <source>You can play with JSX using &lt;a href=&quot;https://babeljs.io/en/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=es2015%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.3&quot;&gt;this online converter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/en/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=es2015%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.3&quot;&gt;このオンラインコンバーター&lt;/a&gt;を使用してJSXで遊ぶことができます。</target>
        </trans-unit>
        <trans-unit id="7d1545332973b55902e4255143d257c96974bde4" translate="yes" xml:space="preserve">
          <source>You can provide more JSX elements as the children. This is useful for displaying nested components:</source>
          <target state="translated">より多くのJSX要素を子として提供することができます。これはネストされたコンポーネントを表示するのに便利です。</target>
        </trans-unit>
        <trans-unit id="65f15691188f600d9d12d5f168ed2e31e352f23e" translate="yes" xml:space="preserve">
          <source>You can put a string between the opening and closing tags and &lt;code&gt;props.children&lt;/code&gt; will just be that string. This is useful for many of the built-in HTML elements. For example:</source>
          <target state="translated">開始タグと終了タグの間に文字列を置くことができ、 &lt;code&gt;props.children&lt;/code&gt; はその文字列になります。これは、組み込みのHTML要素の多くに役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="f565c43f4e7f61294704c4616bb4fff2035deea9" translate="yes" xml:space="preserve">
          <source>You can put any valid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;JavaScript expression&lt;/a&gt; inside the curly braces in JSX. For example, &lt;code&gt;2 + 2&lt;/code&gt;, &lt;code&gt;user.firstName&lt;/code&gt;, or &lt;code&gt;formatName(user)&lt;/code&gt; are all valid JavaScript expressions.</source>
          <target state="translated">JSXでは、中括弧内に有効な&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;JavaScript式を&lt;/a&gt;配置できます。たとえば、 &lt;code&gt;2 + 2&lt;/code&gt; 、 &lt;code&gt;user.firstName&lt;/code&gt; 、または &lt;code&gt;formatName(user)&lt;/code&gt; はすべて有効なJavaScript式です。</target>
        </trans-unit>
        <trans-unit id="dea19bc48d1099e474ed6fa06e3adca5d08b7bb8" translate="yes" xml:space="preserve">
          <source>You can see a demo of this &lt;a href=&quot;https://codesandbox.io/s/admiring-mendeleev-y54mk&quot;&gt;here&lt;/a&gt;. The &amp;ldquo;posts&amp;rdquo; and &amp;ldquo;fun facts&amp;rdquo; responses come within 100ms of each other. But React coalesces them and &amp;ldquo;reveals&amp;rdquo; their Suspense boundaries together.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/admiring-mendeleev-y54mk&quot;&gt;こちらで&lt;/a&gt;デモをご覧いただけます。「投稿」と「おもしろい事実」の回答は、互いに100ミリ秒以内に届きます。しかし、Reactはそれらを合体させ、サスペンス境界を一緒に「明らかに」します。</target>
        </trans-unit>
        <trans-unit id="ecfa9132bdc5d45f7bea98f2b20a650f4c2adcdf" translate="yes" xml:space="preserve">
          <source>You can start seeing how your application will behave: set &lt;code&gt;filterText&lt;/code&gt; to &lt;code&gt;&quot;ball&quot;&lt;/code&gt; and refresh your app. You&amp;rsquo;ll see that the data table is updated correctly.</source>
          <target state="translated">アプリケーションの動作を確認できます &lt;code&gt;filterText&lt;/code&gt; を &lt;code&gt;&quot;ball&quot;&lt;/code&gt; 設定して、アプリを更新します。データテーブルが正しく更新されていることがわかります。</target>
        </trans-unit>
        <trans-unit id="96719fed07645c37bccf1baf5ade2085d5b7d9e4" translate="yes" xml:space="preserve">
          <source>You can test React components similar to testing other JavaScript code.</source>
          <target state="translated">他のJavaScriptコードをテストするのと同じように、Reactコンポーネントをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="319b7a4aae21ffc530a5c776ce1c452ea524854a" translate="yes" xml:space="preserve">
          <source>You can then begin to assert facts about the output.</source>
          <target state="translated">そして、アウトプットについての事実を主張し始めることができます。</target>
        </trans-unit>
        <trans-unit id="d172c0255df0dcbddf210708de9b34e44a7b2d31" translate="yes" xml:space="preserve">
          <source>You can think of the Blocking Mode as a &amp;ldquo;gracefully degraded&amp;rdquo; version of the Concurrent Mode. &lt;strong&gt;As a result, in longer term we should be able to converge and stop thinking about different Modes altogether.&lt;/strong&gt; But for now, Modes are an important migration strategy. They let everyone decide when a migration is worth it, and upgrade at their own pace.</source>
          <target state="translated">ブロッキングモードは、コンカレントモードの「正常に機能が低下した」バージョンと考えることができます。&lt;strong&gt;結果として、より長期的には、異なるモードについてまとめて考えることを止めることができるはずです。&lt;/strong&gt;しかし今のところ、モードは重要な移行戦略です。移行の価値がある時期を全員が決定し、自分のペースでアップグレードできます。</target>
        </trans-unit>
        <trans-unit id="6c64d3564a9301555ca04b03520026aa7c6bddae" translate="yes" xml:space="preserve">
          <source>You can think of the shallowRenderer as a &amp;ldquo;place&amp;rdquo; to render the component you&amp;rsquo;re testing, and from which you can extract the component&amp;rsquo;s output.</source>
          <target state="translated">shallowRendererは、テストするコンポーネントをレンダリングするための「場所」と考えることができ、そこからコンポーネントの出力を抽出できます。</target>
        </trans-unit>
        <trans-unit id="0590e174a395555a3c9bb1cf3a4ffa86c9488267" translate="yes" xml:space="preserve">
          <source>You can try out the new JSX fragment syntax with this &lt;a href=&quot;https://codepen.io/reactjs/pen/VrEbjE?editors=1000&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;https://codepen.io/reactjs/pen/VrEbjE?editors=1000&quot;&gt;CodePenで&lt;/a&gt;新しいJSXフラグメント構文を試すことができます。</target>
        </trans-unit>
        <trans-unit id="206b1d043bff35e73dffc40254662fddd860491d" translate="yes" xml:space="preserve">
          <source>You can try these builds on personal projects or in a branch, but we don&amp;rsquo;t recommend running them in production. At Facebook, we &lt;em&gt;do&lt;/em&gt; run them in production, but that&amp;rsquo;s because we&amp;rsquo;re also there to fix bugs when something breaks. You&amp;rsquo;ve been warned!</source>
          <target state="translated">これらのビルドは個人プロジェクトまたはブランチで試すことができますが、本番環境で実行することはお勧めしません。Facebookではそれらを本番&lt;em&gt;環境で&lt;/em&gt;実行していますが、何かが壊れたときにバグを修正するためにもそこにいるからです。警告されました！</target>
        </trans-unit>
        <trans-unit id="1bf129fcc87d9c8703b3fc987efff35eebff0bb7" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; the same way you&amp;rsquo;d use any other element except that it doesn&amp;rsquo;t support keys or attributes.</source>
          <target state="translated">あなたは使用することができます &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; あなたはそれがキーまたは属性をサポートしていないことを除いて、他の要素を使用したいのと同じ方法。</target>
        </trans-unit>
        <trans-unit id="7fc4bfbc3568b2331ad90a50be1e5e88a5ee3938" translate="yes" xml:space="preserve">
          <source>You can use Jest&amp;rsquo;s snapshot testing feature to automatically save a copy of the JSON tree to a file and check in your tests that it hasn&amp;rsquo;t changed: &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;Learn more about it&lt;/a&gt;.</source>
          <target state="translated">Jestのスナップショットテスト機能を使用して、JSONツリーのコピーをファイルに自動的に保存し、変更されていないことをテストで確認できます。&lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;詳細については、こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4056132b8d01c6d2d7bac67f0daa9dca693db05e" translate="yes" xml:space="preserve">
          <source>You can use an arrow function to wrap around an event handler and pass parameters:</source>
          <target state="translated">矢印関数を使用してイベントハンドラをラップし、パラメータを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="576e418bcc1c573f894bd565b26325d02a2c7944" translate="yes" xml:space="preserve">
          <source>You can use any AJAX library you like with React. Some popular ones are &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;Axios&lt;/a&gt;, &lt;a href=&quot;https://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery AJAX&lt;/a&gt;, and the browser built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;window.fetch&lt;/a&gt;.</source>
          <target state="translated">Reactでは、好きなAJAXライブラリーを使用できます。人気のあるものは&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;Axios&lt;/a&gt;、&lt;a href=&quot;https://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery AJAX&lt;/a&gt;、そしてブラウザに組み込まれた&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;window.fetch&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="071ccad1f37e1a2aa152780b53244d333e2c6010" translate="yes" xml:space="preserve">
          <source>You can use fake timers only in some tests. Above, we enabled them by calling &lt;code&gt;jest.useFakeTimers()&lt;/code&gt;. The main advantage they provide is that your test doesn&amp;rsquo;t actually have to wait five seconds to execute, and you also didn&amp;rsquo;t need to make the component code more convoluted just for testing.</source>
          <target state="translated">一部のテストでのみ偽のタイマーを使用できます。上記では、 &lt;code&gt;jest.useFakeTimers()&lt;/code&gt; を呼び出してそれらを有効にしました。それらが提供する主な利点は、テストが実際に5秒待機してから実行する必要がなく、テストのためだけにコンポーネントコードを複雑にする必要がないことです。</target>
        </trans-unit>
        <trans-unit id="313bb057a2f63bdbdabbce1010d70a283298f2c0" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://www.npmjs.com/package/raf&quot;&gt;raf&lt;/a&gt; package to shim &lt;code&gt;requestAnimationFrame&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/raf&quot;&gt;raf&lt;/a&gt;パッケージを使用して &lt;code&gt;requestAnimationFrame&lt;/code&gt; をシムできます。</target>
        </trans-unit>
        <trans-unit id="d18f7d2685e7d062c1678298785cd06becb18092" translate="yes" xml:space="preserve">
          <source>You can use the State Hook more than once in a single component:</source>
          <target state="translated">State Hookは、1つのコンポーネントで複数回使用することができます。</target>
        </trans-unit>
        <trans-unit id="b13cc97b72a37b2c0f156c7b3969fddf1f026f25" translate="yes" xml:space="preserve">
          <source>You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn&amp;rsquo;t change.</source>
          <target state="translated">変数を使用して要素を格納できます。これにより、コンポーネントの一部を条件付きでレンダリングし、残りの出力は変更しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="1ad2ebdcc22b0a305902796e8d6c0c5dc695b0fc" translate="yes" xml:space="preserve">
          <source>You can verify by inspecting the &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element&quot;&gt;last example&lt;/a&gt; with the browser tools:</source>
          <target state="translated">ブラウザツールで&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element&quot;&gt;最後の例&lt;/a&gt;を調べることで確認できます。</target>
        </trans-unit>
        <trans-unit id="fed7cbf84ae5ac541a4e8a4231d62ef5696a99e1" translate="yes" xml:space="preserve">
          <source>You can wrap a function component with &lt;code&gt;React.memo&lt;/code&gt; to shallowly compare its props:</source>
          <target state="translated">関数コンポーネントを &lt;code&gt;React.memo&lt;/code&gt; でラップして、その小道具を浅く比較できます。</target>
        </trans-unit>
        <trans-unit id="76f54fde37523874b455579c8df068962295d11b" translate="yes" xml:space="preserve">
          <source>You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven&amp;rsquo;t considered. We are excited to see what custom Hooks the React community will come up with.</source>
          <target state="translated">フォームの処理、アニメーション、宣言型サブスクリプション、タイマーなど、さまざまなユースケースをカバーするカスタムフックを記述できます。Reactコミュニティのカスタムフックがどのようなものになるかを楽しみにしています。</target>
        </trans-unit>
        <trans-unit id="43bcb3dd583d6b2dd0d35900294f9bc74472de69" translate="yes" xml:space="preserve">
          <source>You can write to it from inside &lt;code&gt;useEffect&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; 内から書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="47255993d7f3732c79a6c98cd3fe5fc53875788f" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t opt into Concurrent Mode on a per-subtree basis. Instead, to opt in, you have to do it in the place where today you call &lt;code&gt;ReactDOM.render()&lt;/code&gt;.</source>
          <target state="translated">サブツリーごとにコンカレントモードを選択することはできません。代わりに、オプトインするには、今日 &lt;code&gt;ReactDOM.render()&lt;/code&gt; を呼び出す場所で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="c32390cb7781d4c45dceb903ef23ef22e363cf1d" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use Hooks &lt;em&gt;inside&lt;/em&gt; of a class component, but you can definitely mix classes and function components with Hooks in a single tree. Whether a component is a class or a function that uses Hooks is an implementation detail of that component. In the longer term, we expect Hooks to be the primary way people write React components.</source>
          <target state="translated">クラスコンポーネント&lt;em&gt;内&lt;/em&gt;でフック&lt;em&gt;を&lt;/em&gt;使用することはできませんが、クラスと関数コンポーネントを1つのツリー内のフックと確実に混在させることができます。コンポーネントがクラスであるか、フックを使用する関数であるかは、そのコンポーネントの実装の詳細です。長期的には、Reactコンポーネントを書く主な方法がフックであると予想しています。</target>
        </trans-unit>
        <trans-unit id="0dd0330331639f73df7bfd7107d5bd9297f8602e" translate="yes" xml:space="preserve">
          <source>You can, however, &lt;strong&gt;use the &lt;code&gt;ref&lt;/code&gt; attribute inside a function component&lt;/strong&gt; as long as you refer to a DOM element or a class component:</source>
          <target state="translated">ただし、DOM要素またはクラスコンポーネントを参照する限り&lt;strong&gt;、関数コンポーネント内で&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;属性を&lt;/strong&gt;&lt;strong&gt;使用&lt;/strong&gt;できます。</target>
        </trans-unit>
        <trans-unit id="7f38342d82347d389f86bdf83fa1f0ab8b63d28a" translate="yes" xml:space="preserve">
          <source>You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. This often comes up when you want to render a different component based on a prop:</source>
          <target state="translated">React要素の型として一般式を使用することはできません。要素の型を示すために一般式を使いたい場合は、最初に大文字の変数に代入してください。これは、プロップに基づいて別のコンポーネントをレンダリングしたいときによく出てきます。</target>
        </trans-unit>
        <trans-unit id="33243c0a4126f37be4f3131649cc1eacea5c2f2f" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to replace callback refs in your components. They are slightly more flexible, so they will remain as an advanced feature.</source>
          <target state="translated">コンポーネントのコールバック参照を置き換える必要はありません。これらはやや柔軟性があるため、高度な機能として残ります。</target>
        </trans-unit>
        <trans-unit id="5ea32ee627ff275bafe9ffb6dfbbc18214bc629f" translate="yes" xml:space="preserve">
          <source>You have to be careful about the meaning of &lt;code&gt;this&lt;/code&gt; in JSX callbacks. In JavaScript, class methods are not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bound&lt;/a&gt; by default. If you forget to bind &lt;code&gt;this.handleClick&lt;/code&gt; and pass it to &lt;code&gt;onClick&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; when the function is actually called.</source>
          <target state="translated">JSXコールバックでの &lt;code&gt;this&lt;/code&gt; 意味に注意する必要があります。JavaScriptでは、クラスメソッドはデフォルトで&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;バインド&lt;/a&gt;されていません。 &lt;code&gt;this.handleClick&lt;/code&gt; をバインドして &lt;code&gt;onClick&lt;/code&gt; に渡すことを忘れた場合、関数が実際に呼び出されたときに &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="127ac3f6dd7ddcb0012f37436e79376815c0bff1" translate="yes" xml:space="preserve">
          <source>You may &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embed any expressions in JSX&lt;/a&gt; by wrapping them in curly braces. This includes the JavaScript logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator. It can be handy for conditionally including an element:</source>
          <target state="translated">&lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;式&lt;/a&gt;を中括弧で囲むことにより、JSXに任意の式を埋め込むことができます。これには、JavaScriptの論理 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子が含まれます。要素を条件付きで含める場合に便利です。</target>
        </trans-unit>
        <trans-unit id="42a0cc95c37e0601bd484fc3858b0de8b575529a" translate="yes" xml:space="preserve">
          <source>You may also use curly braces to embed a JavaScript expression in an attribute:</source>
          <target state="translated">中括弧を使用して、JavaScriptの式を属性に埋め込むこともできます。</target>
        </trans-unit>
        <trans-unit id="f6d89345f3ccb99c4b8cb79403d5d95c6c80c7c2" translate="yes" xml:space="preserve">
          <source>You may also use custom attributes as long as they&amp;rsquo;re fully lowercase.</source>
          <target state="translated">完全に小文字である限り、カスタム属性を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="75904665efa8694a25758036e4a724ac6e5801a8" translate="yes" xml:space="preserve">
          <source>You may find it valuable to run integration tests against Experimental. This is up to you. However, be advised that Experimental is even less stable than Next. &lt;strong&gt;We do not guarantee any stability between Experimental releases.&lt;/strong&gt;</source>
          <target state="translated">実験に対して統合テストを実行することは価値があるかもしれません。これはあなた次第です。ただし、ExperimentalはNextよりも安定性が低いことに注意してください。&lt;strong&gt;試験的なリリース間の安定性は保証されません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d32c9e3fbc0fdfb2d416e23ef95ad43e35517849" translate="yes" xml:space="preserve">
          <source>You may have noticed similarities between HOCs and a pattern called &lt;strong&gt;container components&lt;/strong&gt;. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.</source>
          <target state="translated">HOCと&lt;strong&gt;コンテナーコンポーネント&lt;/strong&gt;と呼ば&lt;strong&gt;れる&lt;/strong&gt;パターンの類似点に気づいたかもしれません。コンテナコンポーネントは、高レベルの懸念と低レベルの懸念の間で責任を分離する戦略の一部です。コンテナはサブスクリプションや状態などを管理し、UIのレンダリングなどを処理するコンポーネントに小道具を渡します。HOCは、実装の一部としてコンテナーを使用します。HOCは、パラメーター化されたコンテナーコンポーネント定義と考えることができます。</target>
        </trans-unit>
        <trans-unit id="86fc1bfd2853f4054b7a51c82c1449e76256a431" translate="yes" xml:space="preserve">
          <source>You may optionally pass an object as the first argument to &lt;code&gt;setState()&lt;/code&gt; instead of a function:</source>
          <target state="translated">オプションで、関数の代わりにオブジェクトを最初の引数として &lt;code&gt;setState()&lt;/code&gt; に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="ee6c85272ea4b9d75ad324a8fc559394991e1935" translate="yes" xml:space="preserve">
          <source>You may use a different pattern, but keep in mind that we want to execute the cleanup &lt;em&gt;even if a test fails&lt;/em&gt;. Otherwise, tests can become &amp;ldquo;leaky&amp;rdquo;, and one test can change the behavior of another test. That makes them difficult to debug.</source>
          <target state="translated">別のパターンを使用することもできますが&lt;em&gt;、テストが失敗した場合でも&lt;/em&gt;クリーンアップを実行したいことに注意してください。そうしないと、テストが「漏洩」し、1つのテストが別のテストの動作を変更する可能性があります。そのため、デバッグが困難になります。</target>
        </trans-unit>
        <trans-unit id="6c68df6de15e5de9ad7a0e61d3aae233a125ac08" translate="yes" xml:space="preserve">
          <source>You may use quotes to specify string literals as attributes:</source>
          <target state="translated">引用符を使用して、文字列リテラルを属性として指定することができます。</target>
        </trans-unit>
        <trans-unit id="6c4ab2bcc9cce4e4f2f236a0689d5a30836ea67d" translate="yes" xml:space="preserve">
          <source>You might be curious how React knows which component &lt;code&gt;useState&lt;/code&gt; corresponds to since we&amp;rsquo;re not passing anything like &lt;code&gt;this&lt;/code&gt; back to React. We&amp;rsquo;ll answer &lt;a href=&quot;hooks-faq#how-does-react-associate-hook-calls-with-components&quot;&gt;this question&lt;/a&gt; and many others in the FAQ section.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; ようなものをReactに渡さないため、Reactがどのコンポーネントの &lt;code&gt;useState&lt;/code&gt; に対応するかを知りたいと思うかもしれません。&lt;a href=&quot;hooks-faq#how-does-react-associate-hook-calls-with-components&quot;&gt;この質問&lt;/a&gt;と他の多くの質問にFAQセクションで回答します。</target>
        </trans-unit>
        <trans-unit id="39c09441c3e7a9a767a8d286f34ad0922dfcdde2" translate="yes" xml:space="preserve">
          <source>You might be familiar with refs primarily as a way to &lt;a href=&quot;refs-and-the-dom&quot;&gt;access the DOM&lt;/a&gt;. If you pass a ref object to React with &lt;code&gt;&amp;lt;div ref={myRef} /&amp;gt;&lt;/code&gt;, React will set its &lt;code&gt;.current&lt;/code&gt; property to the corresponding DOM node whenever that node changes.</source>
          <target state="translated">あなたは主&lt;a href=&quot;refs-and-the-dom&quot;&gt;にDOM&lt;/a&gt;にアクセスする方法としてrefsに精通しているかもしれません。refオブジェクトをReactに &lt;code&gt;&amp;lt;div ref={myRef} /&amp;gt;&lt;/code&gt; で &lt;code&gt;.current&lt;/code&gt; と、ノードが変更されるたびに、Reactは.currentプロパティを対応するDOMノードに設定します。</target>
        </trans-unit>
        <trans-unit id="843432bbccf637d5c3a245ab223ad53e54801d6b" translate="yes" xml:space="preserve">
          <source>You might be thinking that we&amp;rsquo;d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that &lt;code&gt;useEffect&lt;/code&gt; is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:</source>
          <target state="translated">クリーンアップを実行するには別のエフェクトが必要だとお考えでしょうか。ただし、サブスクリプションを追加および削除するためのコードは非常に密接に関連しているため、 &lt;code&gt;useEffect&lt;/code&gt; はサブスクリプションをまとめるように設計されています。エフェクトが関数を返す場合、Reactはクリーンアップするときにそれを実行します。</target>
        </trans-unit>
        <trans-unit id="af3f101aa60ab2f4218f9c28b6ee51cac9e89fff" translate="yes" xml:space="preserve">
          <source>You might be wondering why we&amp;rsquo;re using a counter here instead of a more realistic example. This is to help us focus on the API while we&amp;rsquo;re still making our first steps with Hooks.</source>
          <target state="translated">ここで、より現実的な例ではなく、なぜカウンターを使用しているのか疑問に思われるかもしれません。これは、フックを使用して最初のステップを実行している間、APIに集中できるようにするためです。</target>
        </trans-unit>
        <trans-unit id="83ba6a9a4f28b7236b5b6943244a0b8d6c86dde5" translate="yes" xml:space="preserve">
          <source>You might be wondering: why is &lt;code&gt;useState&lt;/code&gt; not named &lt;code&gt;createState&lt;/code&gt; instead?</source>
          <target state="translated">疑問に思われるかもしれませんが、なぜ &lt;code&gt;useState&lt;/code&gt; が &lt;code&gt;createState&lt;/code&gt; という名前ではないのですか？</target>
        </trans-unit>
        <trans-unit id="3be6e25b6d0f7c01938be3f1f55926afa3c29409" translate="yes" xml:space="preserve">
          <source>You might find using &lt;code&gt;act()&lt;/code&gt; directly a bit too verbose. To avoid some of the boilerplate, you could use a library like &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;, whose helpers are wrapped with &lt;code&gt;act()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;act()&lt;/code&gt; を直接使用するのは少し冗長すぎるかもしれません。ボイラープレートの一部を回避するには、&lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;などのライブラリを使用できます。そのヘルパーは、 &lt;code&gt;act()&lt;/code&gt; でラップされています。</target>
        </trans-unit>
        <trans-unit id="0db33983cd7798b4c863f844b1e5e18fe94fdbe6" translate="yes" xml:space="preserve">
          <source>You might have noticed the square brackets when we declare a state variable:</source>
          <target state="translated">状態変数を宣言するときに角括弧で囲まれていることに気づくかもしれません。</target>
        </trans-unit>
        <trans-unit id="329e92de263dd0e71122a46b673d8f3a5c8c8351" translate="yes" xml:space="preserve">
          <source>You might have previously known these as &amp;ldquo;stateless components&amp;rdquo;. We&amp;rsquo;re now introducing the ability to use React state from these, so we prefer the name &amp;ldquo;function components&amp;rdquo;.</source>
          <target state="translated">以前はこれらを「ステートレスコンポーネント」と呼んでいたかもしれません。これらからReact状態を使用する機能を導入しているので、「関数コンポーネント」という名前が好まれます。</target>
        </trans-unit>
        <trans-unit id="4ef4a753921a678c61c3979f95fe4cdf4be39d17" translate="yes" xml:space="preserve">
          <source>You might object that fetching &amp;ldquo;at the top level&amp;rdquo; like in this example is impractical. What are we going to do if we navigate to another profile&amp;rsquo;s page? We might want to fetch based on props. The answer to this is &lt;strong&gt;we want to start fetching in the event handlers instead&lt;/strong&gt;. Here is a simplified example of navigating between user&amp;rsquo;s pages:</source>
          <target state="translated">この例のように「トップレベルで」フェッチすることは実用的ではないことに反対するかもしれません。別のプロファイルのページに移動した場合はどうしますか？小道具に基づいてフェッチしたい場合があります。これに対する答え&lt;strong&gt;は、代わりにイベントハンドラでフェッチを開始することです&lt;/strong&gt;。以下は、ユーザーのページ間を移動する簡単な例です。</target>
        </trans-unit>
        <trans-unit id="e076b28b9370ba50b790e58f9f840b591db7ff32" translate="yes" xml:space="preserve">
          <source>You should populate data with AJAX calls in the &lt;a href=&quot;react-component#mounting&quot;&gt;&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/a&gt; lifecycle method. This is so you can use &lt;code&gt;setState&lt;/code&gt; to update your component when the data is retrieved.</source>
          <target state="translated">&lt;a href=&quot;react-component#mounting&quot;&gt; &lt;code&gt;componentDidMount&lt;/code&gt; &lt;/a&gt;ライフサイクルメソッドでデータにAJAX呼び出しを入力する必要があります。これは、データが取得されたときに &lt;code&gt;setState&lt;/code&gt; を使用してコンポーネントを更新できるようにするためです。</target>
        </trans-unit>
        <trans-unit id="0100f35a274466dbd299b52916e0b9bb563005fd" translate="yes" xml:space="preserve">
          <source>You should see a message like:</source>
          <target state="translated">のようなメッセージが表示されるはずです。</target>
        </trans-unit>
        <trans-unit id="13d510fce1888c91efd69e647dbd0b1304d066fb" translate="yes" xml:space="preserve">
          <source>You should use the File API to interact with the files. The following example shows how to create a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref to the DOM node&lt;/a&gt; to access file(s) in a submit handler:</source>
          <target state="translated">ファイルを操作するには、File APIを使用する必要があります。次の例は&lt;a href=&quot;refs-and-the-dom&quot;&gt;、DOMノード&lt;/a&gt;への参照を作成して、送信ハンドラ内のファイルにアクセスする方法を示しています。</target>
        </trans-unit>
        <trans-unit id="d1ca77292c866d9beccf3afb5cd22e409404eefd" translate="yes" xml:space="preserve">
          <source>You will have to provide any event property that you&amp;rsquo;re using in your component (e.g. keyCode, which, etc&amp;hellip;) as React is not creating any of these for you.</source>
          <target state="translated">Reactはこれらを作成しないため、コンポーネントで使用しているイベントプロパティ（keyCodeなど）を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="38e40adba52fc6a8328c5cb7d32f1ed6f48158d5" translate="yes" xml:space="preserve">
          <source>You will need to have &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;window.document&lt;/code&gt; and &lt;code&gt;window.document.createElement&lt;/code&gt; globally available &lt;strong&gt;before&lt;/strong&gt; you import &lt;code&gt;React&lt;/code&gt;. Otherwise React will think it can&amp;rsquo;t access the DOM and methods like &lt;code&gt;setState&lt;/code&gt; won&amp;rsquo;t work.</source>
          <target state="translated">&lt;code&gt;React&lt;/code&gt; をインポートする&lt;strong&gt;前に&lt;/strong&gt;、 &lt;code&gt;window&lt;/code&gt; 、 &lt;code&gt;window.document&lt;/code&gt; 、および &lt;code&gt;window.document.createElement&lt;/code&gt; をグローバルに使用できるよう&lt;strong&gt;に&lt;/strong&gt;する必要があります。そうしないと、ReactはDOMにアクセスできず、 &lt;code&gt;setState&lt;/code&gt; などのメソッドが機能しないと見なします。</target>
        </trans-unit>
        <trans-unit id="178e11c227368aa687fcf840c5bb6cce64f8f141" translate="yes" xml:space="preserve">
          <source>You will not typically invoke &lt;code&gt;React.createFactory()&lt;/code&gt; directly if you are using JSX. See &lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt; to learn more.</source>
          <target state="translated">JSXを使用している場合、通常は &lt;code&gt;React.createFactory()&lt;/code&gt; を直接呼び出すことはありません。詳細については、&lt;a href=&quot;react-without-jsx&quot;&gt;JSX&lt;/a&gt;を使用せずにReactを参照してください。</target>
        </trans-unit>
        <trans-unit id="d6c37686a4d152354398670fa644ad54c4e1c2e0" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see here that we have five components in our app. We&amp;rsquo;ve italicized the data each component represents.</source>
          <target state="translated">アプリに5つのコンポーネントがあることがわかります。各コンポーネントが表すデータを斜体にしました。</target>
        </trans-unit>
        <trans-unit id="ca95950510b4946724893118d47847f0a2b910dc" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see this technique used in the &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;react-motion&lt;/a&gt; API.</source>
          <target state="translated">このテクニックは、&lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;react-motion&lt;/a&gt; APIで使用されています。</target>
        </trans-unit>
        <trans-unit id="1251760a9d7461170b9cdba14cf50e2f7d2632a4" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to a single child for a component. You may pass multiple children, or even have multiple separate &amp;ldquo;slots&amp;rdquo; for children, &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;as documented here&lt;/a&gt;:</source>
          <target state="translated">コンポーネントの子は1つに限定されません。&lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;ここに記載され&lt;/a&gt;ているように、複数の子を渡すことも、子に複数の「スロット」を持たせることもできます。</target>
        </trans-unit>
        <trans-unit id="b2b5019f33196f854492a20c611041c35f250ae6" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations &amp;ldquo;side effects&amp;rdquo; (or &amp;ldquo;effects&amp;rdquo; for short) because they can affect other components and can&amp;rsquo;t be done during rendering.</source>
          <target state="translated">以前にデータのフェッチ、サブスクリプション、または手動でDOMをReactコンポーネントから変更したことがある可能性があります。これらの操作は「副作用」（または略して「効果」）と呼ばれます。これらの操作は他のコンポーネントに影響を与える可能性があり、レンダリング中に実行できないためです。</target>
        </trans-unit>
        <trans-unit id="9a73bce14cb5ed5814b4d3c8caccbf0a4c71d18f" translate="yes" xml:space="preserve">
          <source>Your bundles will end up looking a lot different than this.</source>
          <target state="translated">あなたのバンドルは、これとはかなり異なる外観で終わるでしょう。</target>
        </trans-unit>
        <trans-unit id="ce6353440854dcd821602f8c565c81d1de3f299a" translate="yes" xml:space="preserve">
          <source>Your code might use timer-based functions like &lt;code&gt;setTimeout&lt;/code&gt; to schedule more work in the future. In this example, a multiple choice panel waits for a selection and advances, timing out if a selection isn&amp;rsquo;t made in 5 seconds:</source>
          <target state="translated">コードは、 &lt;code&gt;setTimeout&lt;/code&gt; などのタイマーベースの関数を使用して、将来さらに多くの作業をスケジュールする場合があります。この例では、複数選択パネルは選択を待って進み、5秒以内に選択が行われないとタイムアウトします。</target>
        </trans-unit>
        <trans-unit id="9b44d57e851b7cfb9edddaba0f27c8b365611372" translate="yes" xml:space="preserve">
          <source>Your event handlers will be passed instances of &lt;code&gt;SyntheticEvent&lt;/code&gt;, a cross-browser wrapper around the browser&amp;rsquo;s native event. It has the same interface as the browser&amp;rsquo;s native event, including &lt;code&gt;stopPropagation()&lt;/code&gt; and &lt;code&gt;preventDefault()&lt;/code&gt;, except the events work identically across all browsers.</source>
          <target state="translated">イベントハンドラーには、ブラウザーのネイティブイベントのクロスブラウザーラッパーである &lt;code&gt;SyntheticEvent&lt;/code&gt; のインスタンスが渡されます。イベントはすべてのブラウザーで同じように機能することを除いて、 &lt;code&gt;stopPropagation()&lt;/code&gt; や &lt;code&gt;preventDefault()&lt;/code&gt; を含む、ブラウザーのネイティブイベントと同じインターフェイスを持っています。</target>
        </trans-unit>
        <trans-unit id="417ad6992902ba487e093b897d3f6d549a9842ce" translate="yes" xml:space="preserve">
          <source>Your first inclination may be to use refs to &amp;ldquo;make things happen&amp;rdquo; in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to &amp;ldquo;own&amp;rdquo; that state is at a higher level in the hierarchy. See the &lt;a href=&quot;lifting-state-up&quot;&gt;Lifting State Up&lt;/a&gt; guide for examples of this.</source>
          <target state="translated">最初の傾向は、refを使用してアプリで「物事を起こさせる」ことです。この場合は、少し時間をとって、状態をコンポーネント階層のどこに所有するかについて、より批判的に考えてください。多くの場合、その状態を「所有」する適切な場所は、階層のより高いレベルにあることが明らかになります。この例については、「&lt;a href=&quot;lifting-state-up&quot;&gt;持ち上げ状態アップ」&lt;/a&gt;ガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="8e168dcadd81316b93e30e3fb63c119e3eacea3d" translate="yes" xml:space="preserve">
          <source>aXe, aXe-core and react-axe</source>
          <target state="translated">aXe、aXeコア、リアクターアクセ</target>
        </trans-unit>
        <trans-unit id="30044d924582132945f46916ec2d07125a58cf2d" translate="yes" xml:space="preserve">
          <source>act()</source>
          <target state="translated">act()</target>
        </trans-unit>
        <trans-unit id="ff492a83ee72d534e12a356ac58617fc5344b70b" translate="yes" xml:space="preserve">
          <source>at a Glance</source>
          <target state="translated">一目でわかる</target>
        </trans-unit>
        <trans-unit id="27d975804229db5d33e99922cefc38d130415317" translate="yes" xml:space="preserve">
          <source>can be compiled to this code that does not use JSX:</source>
          <target state="translated">は、JSXを使用しないこのコードにコンパイルすることができます。</target>
        </trans-unit>
        <trans-unit id="75e4aedce48faf384f3535ffeb842e9a0718a25c" translate="yes" xml:space="preserve">
          <source>checked</source>
          <target state="translated">checked</target>
        </trans-unit>
        <trans-unit id="d80a05355eb77272dccf26e73f9d554a520a954d" translate="yes" xml:space="preserve">
          <source>className</source>
          <target state="translated">className</target>
        </trans-unit>
        <trans-unit id="f1808e1fcdfb51765245f7ae10e6d0f7d45dfdb0" translate="yes" xml:space="preserve">
          <source>cloneElement()</source>
          <target state="translated">cloneElement()</target>
        </trans-unit>
        <trans-unit id="d2ac721e1714aa0c2ba51ae76a737a394508c705" translate="yes" xml:space="preserve">
          <source>compiles into:</source>
          <target state="translated">にコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="e04a959dd07839da3d76b649c2746a372ae67d26" translate="yes" xml:space="preserve">
          <source>componentDidCatch()</source>
          <target state="translated">componentDidCatch()</target>
        </trans-unit>
        <trans-unit id="4cbc3930cb5ae51bf4c7c376a47c4a0303cc508f" translate="yes" xml:space="preserve">
          <source>componentDidMount()</source>
          <target state="translated">componentDidMount()</target>
        </trans-unit>
        <trans-unit id="81560e4b9f7ed9f695cb560e570f84260f6da228" translate="yes" xml:space="preserve">
          <source>componentDidUpdate()</source>
          <target state="translated">componentDidUpdate()</target>
        </trans-unit>
        <trans-unit id="040d2c710c56b213bb8d9a190f9d819d99838912" translate="yes" xml:space="preserve">
          <source>componentWillUnmount()</source>
          <target state="translated">componentWillUnmount()</target>
        </trans-unit>
        <trans-unit id="a5cb5262d854a45e4891ceed1de0d0dce3abd1e6" translate="yes" xml:space="preserve">
          <source>constructor()</source>
          <target state="translated">constructor()</target>
        </trans-unit>
        <trans-unit id="6b181ca2ce1831814647e1033acd0415b7894d36" translate="yes" xml:space="preserve">
          <source>createBlockingRoot</source>
          <target state="translated">createBlockingRoot</target>
        </trans-unit>
        <trans-unit id="f4b3ab4f5c383ec52f890d704e0e8f5effedd508" translate="yes" xml:space="preserve">
          <source>createElement()</source>
          <target state="translated">createElement()</target>
        </trans-unit>
        <trans-unit id="6d39c1e12808130963fbdf6fe78aff2f7954e5cd" translate="yes" xml:space="preserve">
          <source>createFactory()</source>
          <target state="translated">createFactory()</target>
        </trans-unit>
        <trans-unit id="225f66482bb6fa2162c71f4678803312729ce679" translate="yes" xml:space="preserve">
          <source>createPortal()</source>
          <target state="translated">createPortal()</target>
        </trans-unit>
        <trans-unit id="3fa4909ead21a618529dabdaf33aa6c9589a71cb" translate="yes" xml:space="preserve">
          <source>createRoot</source>
          <target state="translated">createRoot</target>
        </trans-unit>
        <trans-unit id="b96f7c4dfd5ac22f73a862391a14b9ad9d087ae5" translate="yes" xml:space="preserve">
          <source>dangerouslySetInnerHTML</source>
          <target state="translated">dangerouslySetInnerHTML</target>
        </trans-unit>
        <trans-unit id="4ffa4d174c4a4c8d2e8354a953a93d148fccc03f" translate="yes" xml:space="preserve">
          <source>defaultProps</source>
          <target state="translated">defaultProps</target>
        </trans-unit>
        <trans-unit id="226e8ab97c399ef7e520a8c77ae9ce3fd60b449f" translate="yes" xml:space="preserve">
          <source>displayName</source>
          <target state="translated">displayName</target>
        </trans-unit>
        <trans-unit id="5c7cef6a6a6ef7a482a82974ea4726169eae6264" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jsx-a11y</source>
          <target state="translated">eslint-plugin-jsx-a11y</target>
        </trans-unit>
        <trans-unit id="c230c9b793507553af38b22847c967a1651daabd" translate="yes" xml:space="preserve">
          <source>findAllInRenderedTree()</source>
          <target state="translated">findAllInRenderedTree()</target>
        </trans-unit>
        <trans-unit id="7ebff84a87431408d85d2c3f89d84055a39bd086" translate="yes" xml:space="preserve">
          <source>findDOMNode</source>
          <target state="translated">findDOMNode</target>
        </trans-unit>
        <trans-unit id="d274d46accd6cdefe4324778fc78f215f1e4c91a" translate="yes" xml:space="preserve">
          <source>findDOMNode()</source>
          <target state="translated">findDOMNode()</target>
        </trans-unit>
        <trans-unit id="e9174cad96a72c7e0c1ad1cd53a888fb02ea7804" translate="yes" xml:space="preserve">
          <source>findRenderedComponentWithType()</source>
          <target state="translated">findRenderedComponentWithType()</target>
        </trans-unit>
        <trans-unit id="c9c73f42f55648fc38ef00e038ae1321d85fbc5d" translate="yes" xml:space="preserve">
          <source>findRenderedDOMComponentWithClass()</source>
          <target state="translated">findRenderedDOMComponentWithClass()</target>
        </trans-unit>
        <trans-unit id="325c7573aec2c9a01bf497f8e01ea68e75fcfe2e" translate="yes" xml:space="preserve">
          <source>findRenderedDOMComponentWithTag()</source>
          <target state="translated">findRenderedDOMComponentWithTag()</target>
        </trans-unit>
        <trans-unit id="f634efed29f9466600dce13d06f22a65c4394c9c" translate="yes" xml:space="preserve">
          <source>forceUpdate()</source>
          <target state="translated">forceUpdate()</target>
        </trans-unit>
        <trans-unit id="48c0d6c8247cdebbadbfb27472c725be283719d3" translate="yes" xml:space="preserve">
          <source>getSnapshotBeforeUpdate()</source>
          <target state="translated">getSnapshotBeforeUpdate()</target>
        </trans-unit>
        <trans-unit id="9f9bed174e7ceb8dd32127ea809e17154176a0fe" translate="yes" xml:space="preserve">
          <source>htmlFor</source>
          <target state="translated">htmlFor</target>
        </trans-unit>
        <trans-unit id="2b70ee25b5685a847d42fd561cddbb0347240ffb" translate="yes" xml:space="preserve">
          <source>hydrate()</source>
          <target state="translated">hydrate()</target>
        </trans-unit>
        <trans-unit id="e607f2c2f3a88ee9efc521cc3eb5a8db451bdb56" translate="yes" xml:space="preserve">
          <source>is slightly different in React:</source>
          <target state="translated">はReactでは少し違います。</target>
        </trans-unit>
        <trans-unit id="38913b96ec33406bdc107dc1a67355715c31b42c" translate="yes" xml:space="preserve">
          <source>isCompositeComponent()</source>
          <target state="translated">isCompositeComponent()</target>
        </trans-unit>
        <trans-unit id="2d0f44b4556319617244d8e3c0101188b4e9d334" translate="yes" xml:space="preserve">
          <source>isCompositeComponentWithType()</source>
          <target state="translated">isCompositeComponentWithType()</target>
        </trans-unit>
        <trans-unit id="e5db90c47987aedfcd4e6b88a002a4d096541964" translate="yes" xml:space="preserve">
          <source>isDOMComponent()</source>
          <target state="translated">isDOMComponent()</target>
        </trans-unit>
        <trans-unit id="1ff3f8d3e07c1aa64975ff6c37b27b245fec7a06" translate="yes" xml:space="preserve">
          <source>isElement()</source>
          <target state="translated">isElement()</target>
        </trans-unit>
        <trans-unit id="cda9aaf24e1c261b047f9583d068a59d6146a5c1" translate="yes" xml:space="preserve">
          <source>isElementOfType()</source>
          <target state="translated">isElementOfType()</target>
        </trans-unit>
        <trans-unit id="8d189028ca88af62009de3301ce91b75ee91f71d" translate="yes" xml:space="preserve">
          <source>isValidElement()</source>
          <target state="translated">isValidElement()</target>
        </trans-unit>
        <trans-unit id="031703ceb37d4e467e3b4873c48829fe96e8be85" translate="yes" xml:space="preserve">
          <source>mockComponent()</source>
          <target state="translated">mockComponent()</target>
        </trans-unit>
        <trans-unit id="6346291a5b44a7e5edb37e6ad83b5d6d14b97973" translate="yes" xml:space="preserve">
          <source>of React Terms</source>
          <target state="translated">リアクト用語の</target>
        </trans-unit>
        <trans-unit id="59897a9118de38c1f4300bf9b771b3280b32c69d" translate="yes" xml:space="preserve">
          <source>onChange</source>
          <target state="translated">onChange</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">それともこれか</target>
        </trans-unit>
        <trans-unit id="aa60968734f4f4d402439b0e033649c02834cb03" translate="yes" xml:space="preserve">
          <source>props</source>
          <target state="translated">props</target>
        </trans-unit>
        <trans-unit id="a51a890001a811c94e4fda62e34296855ddfb140" translate="yes" xml:space="preserve">
          <source>props.children</source>
          <target state="translated">props.children</target>
        </trans-unit>
        <trans-unit id="4a8d7ba2ca12dcaf16af003dba0a21a54145f550" translate="yes" xml:space="preserve">
          <source>render()</source>
          <target state="translated">render()</target>
        </trans-unit>
        <trans-unit id="e30b6dae1ced5ea662137753850941aae38407fb" translate="yes" xml:space="preserve">
          <source>renderIntoDocument()</source>
          <target state="translated">renderIntoDocument()</target>
        </trans-unit>
        <trans-unit id="3eeeddfe744d288f2a7cc0b1b5d27869afa633bd" translate="yes" xml:space="preserve">
          <source>renderToNodeStream()</source>
          <target state="translated">renderToNodeStream()</target>
        </trans-unit>
        <trans-unit id="5fb112b72758bd2b1c27c4056814291d3fc57875" translate="yes" xml:space="preserve">
          <source>renderToStaticMarkup()</source>
          <target state="translated">renderToStaticMarkup()</target>
        </trans-unit>
        <trans-unit id="5371d3d06de40c111adfa63626996723a8574fd0" translate="yes" xml:space="preserve">
          <source>renderToStaticNodeStream()</source>
          <target state="translated">renderToStaticNodeStream()</target>
        </trans-unit>
        <trans-unit id="a1e2c92c6bbcd7c635f3fc1dec2fadb6e5d28ee3" translate="yes" xml:space="preserve">
          <source>renderToString()</source>
          <target state="translated">renderToString()</target>
        </trans-unit>
        <trans-unit id="d73fd7553e41429de67252dc32008ee31e7dc96a" translate="yes" xml:space="preserve">
          <source>requestAnimationFrame</source>
          <target state="translated">requestAnimationFrame</target>
        </trans-unit>
        <trans-unit id="5fef477110a77ece862b497872e19102ce62d1d3" translate="yes" xml:space="preserve">
          <source>results in a &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; output of:</source>
          <target state="translated">結果は &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; の出力になります：</target>
        </trans-unit>
        <trans-unit id="b93c8e43f94949f681de9d694b201cebad28cd67" translate="yes" xml:space="preserve">
          <source>scryRenderedComponentsWithType()</source>
          <target state="translated">scryRenderedComponentsWithType()</target>
        </trans-unit>
        <trans-unit id="aebb7ccb3b46e0525adf0006807bf12321942ae4" translate="yes" xml:space="preserve">
          <source>scryRenderedDOMComponentsWithClass()</source>
          <target state="translated">scryRenderedDOMComponentsWithClass()</target>
        </trans-unit>
        <trans-unit id="611b9475f3c4c5708aa2d088c24cb54bdd8d5eac" translate="yes" xml:space="preserve">
          <source>scryRenderedDOMComponentsWithTag()</source>
          <target state="translated">scryRenderedDOMComponentsWithTag()</target>
        </trans-unit>
        <trans-unit id="835f3b50e33719422d6faca2d01d99417afea46b" translate="yes" xml:space="preserve">
          <source>selected</source>
          <target state="translated">selected</target>
        </trans-unit>
        <trans-unit id="612b427e6504ad2778fa6e4e5081fa2cfdfe48b0" translate="yes" xml:space="preserve">
          <source>setState()</source>
          <target state="translated">setState()</target>
        </trans-unit>
        <trans-unit id="ce05a867c6397422a23f2df9528118a63884828f" translate="yes" xml:space="preserve">
          <source>shallowRenderer.getRenderOutput()</source>
          <target state="translated">shallowRenderer.getRenderOutput()</target>
        </trans-unit>
        <trans-unit id="d9683e6218d9950582c31235c789381795b9a6a7" translate="yes" xml:space="preserve">
          <source>shallowRenderer.render()</source>
          <target state="translated">shallowRenderer.render()</target>
        </trans-unit>
        <trans-unit id="470481efa1f485463319f0673bb633affe7ebd19" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate In Action</source>
          <target state="translated">shouldComponentUpdate アクションで</target>
        </trans-unit>
        <trans-unit id="912f2ad5b0b4be590e85fc8aaad17da9d9b8bae5" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate()</source>
          <target state="translated">shouldComponentUpdate()</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="6f21255dfbf5dc0666959c7a4d5ec0f7cb311c84" translate="yes" xml:space="preserve">
          <source>static getDerivedStateFromError()</source>
          <target state="translated">static getDerivedStateFromError()</target>
        </trans-unit>
        <trans-unit id="a8a1daf7425520001825ba5ee0f62272e1942058" translate="yes" xml:space="preserve">
          <source>static getDerivedStateFromProps()</source>
          <target state="translated">static getDerivedStateFromProps()</target>
        </trans-unit>
        <trans-unit id="26ec8d00fb6b55466b3a115f1d559422a7fa7aac" translate="yes" xml:space="preserve">
          <source>style</source>
          <target state="translated">style</target>
        </trans-unit>
        <trans-unit id="ec9c9f0131a2a03ef9592dbbf5b6f941e6f067f8" translate="yes" xml:space="preserve">
          <source>suppressContentEditableWarning</source>
          <target state="translated">suppressContentEditableWarning</target>
        </trans-unit>
        <trans-unit id="8c4c14e070b03ee334f69ae4652b54634b91962e" translate="yes" xml:space="preserve">
          <source>suppressHydrationWarning</source>
          <target state="translated">suppressHydrationWarning</target>
        </trans-unit>
        <trans-unit id="c01f3c9d4dbfd20df94186b9bedc6b8ba8cdbabf" translate="yes" xml:space="preserve">
          <source>testInstance.children</source>
          <target state="translated">testInstance.children</target>
        </trans-unit>
        <trans-unit id="4c915ddcb2a485beede7f30f0a39993ca3eaccfb" translate="yes" xml:space="preserve">
          <source>testInstance.find()</source>
          <target state="translated">testInstance.find()</target>
        </trans-unit>
        <trans-unit id="ef7541e9aa2a73eedf7685db30d9d4b2a52e1346" translate="yes" xml:space="preserve">
          <source>testInstance.findAll()</source>
          <target state="translated">testInstance.findAll()</target>
        </trans-unit>
        <trans-unit id="a18a2aa20f4ff41cfbe29515880a5420b8cb7caf" translate="yes" xml:space="preserve">
          <source>testInstance.findAllByProps()</source>
          <target state="translated">testInstance.findAllByProps()</target>
        </trans-unit>
        <trans-unit id="0563b370095c727ef03938afce647600d255d300" translate="yes" xml:space="preserve">
          <source>testInstance.findAllByType()</source>
          <target state="translated">testInstance.findAllByType()</target>
        </trans-unit>
        <trans-unit id="a80d58798674cc0d4d16f85d332446b150cf2508" translate="yes" xml:space="preserve">
          <source>testInstance.findByProps()</source>
          <target state="translated">testInstance.findByProps()</target>
        </trans-unit>
        <trans-unit id="e6726e57ddc7239270aed690310887f17c4ed5a0" translate="yes" xml:space="preserve">
          <source>testInstance.findByType()</source>
          <target state="translated">testInstance.findByType()</target>
        </trans-unit>
        <trans-unit id="24e32ceafa0199c0e634d8a09f601bf4c75dc6ea" translate="yes" xml:space="preserve">
          <source>testInstance.instance</source>
          <target state="translated">testInstance.instance</target>
        </trans-unit>
        <trans-unit id="6fc49889f4c4cf74fb4892e3812cb5238efc37af" translate="yes" xml:space="preserve">
          <source>testInstance.parent</source>
          <target state="translated">testInstance.parent</target>
        </trans-unit>
        <trans-unit id="991a6b588a17504199fd15ee9a6f4d447180a3a0" translate="yes" xml:space="preserve">
          <source>testInstance.props</source>
          <target state="translated">testInstance.props</target>
        </trans-unit>
        <trans-unit id="59239c90818698c1ff479fb8f72464b55fc9ae0e" translate="yes" xml:space="preserve">
          <source>testInstance.type</source>
          <target state="translated">testInstance.type</target>
        </trans-unit>
        <trans-unit id="9ba87352e263ec108b8cb84015e69b21ec153df3" translate="yes" xml:space="preserve">
          <source>testRenderer.getInstance()</source>
          <target state="translated">testRenderer.getInstance()</target>
        </trans-unit>
        <trans-unit id="321ae1cad7565cf2c094665daccc3a626e875bf6" translate="yes" xml:space="preserve">
          <source>testRenderer.root</source>
          <target state="translated">testRenderer.root</target>
        </trans-unit>
        <trans-unit id="cacb1190f356919021ffa862e4827f65254f8342" translate="yes" xml:space="preserve">
          <source>testRenderer.toJSON()</source>
          <target state="translated">testRenderer.toJSON()</target>
        </trans-unit>
        <trans-unit id="838b9c04859c929c640cb6679ed6e88dee0ad2e2" translate="yes" xml:space="preserve">
          <source>testRenderer.toTree()</source>
          <target state="translated">testRenderer.toTree()</target>
        </trans-unit>
        <trans-unit id="3d1450103c3366cf9be062ef311d80a4b548a39f" translate="yes" xml:space="preserve">
          <source>testRenderer.unmount()</source>
          <target state="translated">testRenderer.unmount()</target>
        </trans-unit>
        <trans-unit id="c93dde1e0b286d37d40077ae8c79ff09c3a8b28d" translate="yes" xml:space="preserve">
          <source>testRenderer.update()</source>
          <target state="translated">testRenderer.update()</target>
        </trans-unit>
        <trans-unit id="2d1c22c80fa325ca4df815d1ebdc1147925b2af3" translate="yes" xml:space="preserve">
          <source>unmountComponentAtNode()</source>
          <target state="translated">unmountComponentAtNode()</target>
        </trans-unit>
        <trans-unit id="0bedb35c3b8a80ac3f44b9bac14dfbc4e37efdb9" translate="yes" xml:space="preserve">
          <source>useCallback</source>
          <target state="translated">useCallback</target>
        </trans-unit>
        <trans-unit id="eae3826cdf2f6c64c219ecbd30dd771505bb87ed" translate="yes" xml:space="preserve">
          <source>useContext</source>
          <target state="translated">useContext</target>
        </trans-unit>
        <trans-unit id="8231dd7a518591bf2d9d957972cf313c1109e75b" translate="yes" xml:space="preserve">
          <source>useDebugValue</source>
          <target state="translated">useDebugValue</target>
        </trans-unit>
        <trans-unit id="3e0fe2934c5acc6440f9c9169e5d9a241b6d23cf" translate="yes" xml:space="preserve">
          <source>useDeferredValue</source>
          <target state="translated">useDeferredValue</target>
        </trans-unit>
        <trans-unit id="b70d205ec49487a219eb853fe1054028bf43991e" translate="yes" xml:space="preserve">
          <source>useDeferredValue Config</source>
          <target state="translated">useDeferredValue Config</target>
        </trans-unit>
        <trans-unit id="26c55908ffcc066654803d696c358e2631cf940d" translate="yes" xml:space="preserve">
          <source>useEffect</source>
          <target state="translated">useEffect</target>
        </trans-unit>
        <trans-unit id="45040bb8abbff5eebf6ea2143e010c489b1650bb" translate="yes" xml:space="preserve">
          <source>useImperativeHandle</source>
          <target state="translated">useImperativeHandle</target>
        </trans-unit>
        <trans-unit id="babcde59d67ee82a21532cbed73f4914eeae6430" translate="yes" xml:space="preserve">
          <source>useLayoutEffect</source>
          <target state="translated">useLayoutEffect</target>
        </trans-unit>
        <trans-unit id="7134ae428d908b7a4b3d2527d83ec7a81d55f99d" translate="yes" xml:space="preserve">
          <source>useMemo</source>
          <target state="translated">useMemo</target>
        </trans-unit>
        <trans-unit id="aba72ff13cf2cb2f8078b149e16a9774c992fe86" translate="yes" xml:space="preserve">
          <source>useReducer</source>
          <target state="translated">useReducer</target>
        </trans-unit>
        <trans-unit id="17ab3e5a1cb289c329720c8fd155c9bc8f22bedc" translate="yes" xml:space="preserve">
          <source>useRef</source>
          <target state="translated">useRef</target>
        </trans-unit>
        <trans-unit id="7aa25205d04ad57a2b7896eb24dd7f3407d332cf" translate="yes" xml:space="preserve">
          <source>useState</source>
          <target state="translated">useState</target>
        </trans-unit>
        <trans-unit id="d7705f0ea90572940d0eb8f6df4eeb064570303d" translate="yes" xml:space="preserve">
          <source>useTransition</source>
          <target state="translated">useTransition</target>
        </trans-unit>
        <trans-unit id="d1eb6757e6abcda4059f5f0fdd80f7ca6d09ab3b" translate="yes" xml:space="preserve">
          <source>useTransition Config</source>
          <target state="translated">ユーストランジション設定</target>
        </trans-unit>
        <trans-unit id="f32b67c7e26342af42efabc674d441dca0a281c5" translate="yes" xml:space="preserve">
          <source>value</source>
          <target state="translated">value</target>
        </trans-unit>
        <trans-unit id="057b6197438cfa301937d3f5cb47577adb242a9e" translate="yes" xml:space="preserve">
          <source>webpack</source>
          <target state="translated">webpack</target>
        </trans-unit>
        <trans-unit id="7ce83ec9cfed7121529d2fe247b4421dd66a5342" translate="yes" xml:space="preserve">
          <source>which results in a correct &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; output of:</source>
          <target state="translated">その結果、正しい &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; 出力が得られます。</target>
        </trans-unit>
        <trans-unit id="aca8ac649e8becdb6a0f2276dad67b03cc039c67" translate="yes" xml:space="preserve">
          <source>⚡️ Effect Hook</source>
          <target state="translated">⚡️ Effect Hook</target>
        </trans-unit>
        <trans-unit id="1cee944946bff8d51e351ab4c7bd42a5de041a84" translate="yes" xml:space="preserve">
          <source>✅</source>
          <target state="translated">✅</target>
        </trans-unit>
        <trans-unit id="f3c3656b9154abf44c13c92e6fda9c4ec21209f2" translate="yes" xml:space="preserve">
          <source>✅ Call Hooks from React function components.</source>
          <target state="translated">✅ Call Hooks from React function components.</target>
        </trans-unit>
        <trans-unit id="17d726472261fbbf511f74b762b9ac0c2abbd8e9" translate="yes" xml:space="preserve">
          <source>✅ Call Hooks from custom Hooks (we&amp;rsquo;ll learn about them &lt;a href=&quot;hooks-custom&quot;&gt;on the next page&lt;/a&gt;).</source>
          <target state="translated">✅ Call Hooks from custom Hooks (we&amp;rsquo;ll learn about them &lt;a href=&quot;hooks-custom&quot;&gt;on the next page&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="05eb764599eda96ea06ff7639bc59541f5e05465" translate="yes" xml:space="preserve">
          <source>✌️ Rules of Hooks</source>
          <target state="translated">✌️ Rules of Hooks</target>
        </trans-unit>
        <trans-unit id="45c8b34a57dcfe0d9f8bd262c7212971fccdb70c" translate="yes" xml:space="preserve">
          <source>💡 Building Your Own Hooks</source>
          <target state="translated">💡 Building Your Own Hooks</target>
        </trans-unit>
        <trans-unit id="aee90788022779419adf70a0034f4341d4663fc9" translate="yes" xml:space="preserve">
          <source>📌 State Hook</source>
          <target state="translated">📌 State Hook</target>
        </trans-unit>
        <trans-unit id="466bf681aeece7094a8988a08d9ebde47be027ac" translate="yes" xml:space="preserve">
          <source>🔌 Other Hooks</source>
          <target state="translated">🔌 Other Hooks</target>
        </trans-unit>
        <trans-unit id="1fee3b4a52f8bbba1ae107f01184ad871cfe4a4b" translate="yes" xml:space="preserve">
          <source>🚫</source>
          <target state="translated">🚫</target>
        </trans-unit>
        <trans-unit id="982828f9c89097fe661e44f5d2fe2056691fa614" translate="yes" xml:space="preserve">
          <source>🚫*</source>
          <target state="translated">🚫*</target>
        </trans-unit>
        <trans-unit id="9cc8c9733dba90ff1738546ec90ea16e4ef8489f" translate="yes" xml:space="preserve">
          <source>🚫**</source>
          <target state="translated">🚫**</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
