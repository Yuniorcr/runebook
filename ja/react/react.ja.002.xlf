<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="">
    <body>
      <group id="">
        <trans-unit id="d8de9356ec83d73b1f5bd25ff7148e61b4571f9a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; component that renders the image of a cat chasing the mouse around the screen. We might use a &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; prop to tell the component the coordinates of the mouse so it knows where to position the image on the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba22bdb002e0f405abcc6c642198532d39f6bf7a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this &lt;code&gt;Counter&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0a42e407f76b6421f57202e0a6b998a33eea86" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this counter component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6829043516c2d5b5543372593d5ecc18cc4a4134" translate="yes" xml:space="preserve">
          <source>For example, maybe you have a complex component that contains a lot of local state that is managed in an ad-hoc way. &lt;code&gt;useState&lt;/code&gt; doesn&amp;rsquo;t make centralizing the update logic any easier so you might prefer to write it as a &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; reducer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18ae5d39ecd3952c9cebace04d8ec7b3336fb23" translate="yes" xml:space="preserve">
          <source>For example, research shows that displaying too many intermediate loading states when transitioning between screens makes a transition feel &lt;em&gt;slower&lt;/em&gt;. This is why Concurrent Mode shows new loading states on a fixed &amp;ldquo;schedule&amp;rdquo; to avoid jarring and too frequent updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78683415bcaad856b1ab7dfe02f23e05fa2ced55" translate="yes" xml:space="preserve">
          <source>For example, say you have a &lt;code&gt;CommentList&lt;/code&gt; component that subscribes to an external data source to render a list of comments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1a629d470f55d2fee2000499a4cacbb9a4833a" translate="yes" xml:space="preserve">
          <source>For example, the HTML:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba76674660b5e537e8b2cdd0ef1d5a91df770a7" translate="yes" xml:space="preserve">
          <source>For example, the following component tracks the mouse position in a web app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f359161b98ba57290664f3cc1ede81cf753231" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as &amp;rdquo;&lt;em&gt;ForwardRef&lt;/em&gt;&amp;rdquo; in the DevTools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4201bd25776812cd7bc0c469c68c4fbd842451" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as MyDisplayName in the DevTools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3069268548855f5d165876787923a3ea3d1da874" translate="yes" xml:space="preserve">
          <source>For example, this code accepts a single name in an uncontrolled component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c55286e50f3215379ff426fa48eb785d76df4a7" translate="yes" xml:space="preserve">
          <source>For example, this code may fail to update the counter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccc1009af6f8f6328943760f3255e5b65c01689" translate="yes" xml:space="preserve">
          <source>For example, this code renders &amp;ldquo;Hello, Sara&amp;rdquo; on the page:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a55dc4cb118bd5e2852ddf3c6b69f2d61b25ed" translate="yes" xml:space="preserve">
          <source>For example, this code will not run as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e989a1227816ccbcfdce9a1ef1f8646c7fe3950" translate="yes" xml:space="preserve">
          <source>For example, this code written with JSX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04fad3363acf285dbccbb82a73f5be8eb678633" translate="yes" xml:space="preserve">
          <source>For example, this component sets the document title after React updates the DOM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7884e8e4fb1aae5ecf12d8317e1f6d9f4593fec2" translate="yes" xml:space="preserve">
          <source>For example, this will not re-render a component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20851a45788a2fdc02ea529e15ac7f8112f9de05" translate="yes" xml:space="preserve">
          <source>For example, to profile a &lt;code&gt;Navigation&lt;/code&gt; component and its descendants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13080b59ca5d53e0ba7b314b267e9b38197f049" translate="yes" xml:space="preserve">
          <source>For example, we can create an &lt;code&gt;App&lt;/code&gt; component that renders &lt;code&gt;Welcome&lt;/code&gt; many times:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ead1eab1f84507539e34706446448f0d28e9f5" translate="yes" xml:space="preserve">
          <source>For example, we could split our component state into &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; objects, and always replace the &lt;code&gt;position&lt;/code&gt; with no need for merging:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d42c3a9b978bb53213888cf10f240637aca3105" translate="yes" xml:space="preserve">
          <source>For example, when adding an element at the end of the children, converting between these two trees works well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3142f55d25c885268e370e43896a3749c9b69c27" translate="yes" xml:space="preserve">
          <source>For example, your state may contain several independent variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331fc234992fd41cfe4aafa1cbadd06d8bfafb82" translate="yes" xml:space="preserve">
          <source>For modal dialogs, ensure that everyone can interact with them by following the &lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;WAI-ARIA Modal Authoring Practices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec096cdc71e0b7a6ca398c02cfc7d40516f822a1" translate="yes" xml:space="preserve">
          <source>For more detail, see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c88366a24fd2ea482dc14d0de87b283bbe87e7a" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;Error Handling in React 16&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db28a2392ea1b7c225c391a0872eaf779d774686" translate="yes" xml:space="preserve">
          <source>For more info, see &lt;a href=&quot;fragments&quot;&gt;the Fragments documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab9916b7ffb2e490bd12d8282c8ddb3d82ffa2a" translate="yes" xml:space="preserve">
          <source>For more information about the &amp;lsquo;function as a child&amp;rsquo; pattern, see &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754ab305ab4f9aeec53763a39090226c0de9d63f" translate="yes" xml:space="preserve">
          <source>For more information about the onChange event, see &lt;a href=&quot;forms&quot;&gt;Forms&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cba5c3c0c27cf5088d9888383d141d07a0f2491" translate="yes" xml:space="preserve">
          <source>For more information on Concurrent Mode, check out the &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode documentation.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9732d78e0ad658ec6be5aa1a8cfda86c791eaa9" translate="yes" xml:space="preserve">
          <source>For more information, check out &lt;a href=&quot;testing-recipes&quot;&gt;Testing Recipes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a38f12036a32191520afa8a2753bdccc47eea0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;forwarding-refs&quot;&gt;forwarding refs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fc1e92e2c893003eb2447d228048e1a7aaf57a" translate="yes" xml:space="preserve">
          <source>For older codebases, Concurrent Mode might be a step too far. This is why we also provide a new &amp;ldquo;Blocking Mode&amp;rdquo; in the experimental React builds. You can try it by substituting &lt;code&gt;createRoot&lt;/code&gt; with &lt;code&gt;createBlockingRoot&lt;/code&gt;. It only offers a &lt;em&gt;small subset&lt;/em&gt; of the Concurrent Mode features, but it is closer to how React works today and can serve as a migration step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770927b3887fe0c354b4fb137b4cc1bdc30fbbb9" translate="yes" xml:space="preserve">
          <source>For other use cases, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;follow the recommendations in this blog post about derived state&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b327cbe7031e739d617d4f75e12fa5fef2acc3b7" translate="yes" xml:space="preserve">
          <source>For the most efficient Browserify production build, install a few plugins:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17194133fbe1957bfdd4b741f2933c9c86f4ba6d" translate="yes" xml:space="preserve">
          <source>For the most efficient Brunch production build, install the &lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt;&lt;code&gt;terser-brunch&lt;/code&gt;&lt;/a&gt; plugin:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ce51b2f939e3558a44b1cb8fdbdf554bc07d90" translate="yes" xml:space="preserve">
          <source>For the most efficient Rollup production build, install a few plugins:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7475cb5e6f5adf915c29f1cdea4e2bdc8ba92aa9" translate="yes" xml:space="preserve">
          <source>For these reasons, we reserve patch releases only for the most critical bugs and security vulnerabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa8c036fd5e3a800041a6a85017b66c2fe68715" translate="yes" xml:space="preserve">
          <source>For this change, we&amp;rsquo;ve provided a &lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt; to automatically migrate your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1bce685a135223c199242bc8c77e474653706f" translate="yes" xml:space="preserve">
          <source>For this reason &lt;code&gt;useDebugValue&lt;/code&gt; accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77cd5d73e371d728872a07b909df96d58e4b7b3" translate="yes" xml:space="preserve">
          <source>Forgetting to handle &lt;code&gt;componentDidUpdate&lt;/code&gt; properly is a common source of bugs in React applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d30ae53e81b25bd47a3ef79f6270bb2aee0a4b4" translate="yes" xml:space="preserve">
          <source>Form Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="955e3f80970e0af47e55f5200545b8b3a318bc97" translate="yes" xml:space="preserve">
          <source>Fortunately, we can explicitly forward refs to the inner &lt;code&gt;FancyButton&lt;/code&gt; component using the &lt;code&gt;React.forwardRef&lt;/code&gt; API. &lt;code&gt;React.forwardRef&lt;/code&gt; accepts a render function that receives &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; parameters and returns a React node. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f601df170026e953bbac95daafb8c35102220f96" translate="yes" xml:space="preserve">
          <source>Forwarding Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98364eb3c7e295c55161e71c692712d164542fd6" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe54eca6f507b141b7575b8953c555c23ecbd348" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order-components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0dcf389f3ad894e637d4cba7ff22af9df9a072" translate="yes" xml:space="preserve">
          <source>Forwarding refs to DOM components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="796f3ca672ebd9bd41a7a01b5a01b8745791f0e8" translate="yes" xml:space="preserve">
          <source>Fragments declared with the explicit &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; syntax may have keys. A use case for this is mapping a collection to an array of fragments &amp;mdash; for example, to create a description list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8065c017db022d1f5ec110b82bbd874c082a88f9" translate="yes" xml:space="preserve">
          <source>Fragments solve this problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bcb0016a5230b33666fdcf36ccabf570e7de70e" translate="yes" xml:space="preserve">
          <source>Frameworks like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt;, &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; and &lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriver&lt;/a&gt; are useful for running &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;end-to-end tests&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9e2789ee767980ad3bc5023d41ac7e306fd5ec" translate="yes" xml:space="preserve">
          <source>Frameworks like Jest also let you save &amp;ldquo;snapshots&amp;rdquo; of data with &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;&lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;&lt;/a&gt;. With these, we can &amp;ldquo;save&amp;rdquo; the rendered component output and ensure that a change to it has to be explicitly committed as a change to the snapshot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149defa1bf170ed878773e58e8f5ff8d5c8a3478" translate="yes" xml:space="preserve">
          <source>From Classes to Hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbed11ef2d053428bd9995e6dc4db90c56f977a2" translate="yes" xml:space="preserve">
          <source>From React&amp;rsquo;s point of view, a component using Hooks is just a regular component. If your testing solution doesn&amp;rsquo;t rely on React internals, testing components with Hooks shouldn&amp;rsquo;t be different from how you normally test components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d07daa800d296a026c49de79bda8bb9f64ea8a" translate="yes" xml:space="preserve">
          <source>From here you could start moving more logic into the component and begin adopting more common React practices. For example, in components it is best not to rely on IDs because the same component can be rendered multiple times. Instead, we will use the &lt;a href=&quot;handling-events&quot;&gt;React event system&lt;/a&gt; and register the click handler directly on the React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732afd30e77a6dc18afd55e03cd71f20b12f519d" translate="yes" xml:space="preserve">
          <source>Fully-Fledged Solutions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ab6dc65e716361136b87c26f6834c3fa7eba19" translate="yes" xml:space="preserve">
          <source>Function and Class Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0437f301087d86e5d06d2280e2674b540deaba5" translate="yes" xml:space="preserve">
          <source>Function components are also able to reference &lt;code&gt;context&lt;/code&gt; if &lt;code&gt;contextTypes&lt;/code&gt; is defined as a property of the function. The following code shows a &lt;code&gt;Button&lt;/code&gt; component written as a function component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f523ab76ca84802a4f7ad409b8b8a11d5ec14d" translate="yes" xml:space="preserve">
          <source>Functional updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68254545bf32d5c6b80d7f1482247c069c365636" translate="yes" xml:space="preserve">
          <source>Functions as Children</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8b995fc31e98c113f50f1e6e4e3cd2d61d6d9d" translate="yes" xml:space="preserve">
          <source>Fundamentally, JSX just provides syntactic sugar for the &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; function. The JSX code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6b62bf07d530cf7754450cf7f4baeba776dcc5" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;React.PureComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; skips prop updates for the whole component subtree. Make sure all the children components are also &amp;ldquo;pure&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bfe330b3c43755e29748c139c92671348a757f" translate="yes" xml:space="preserve">
          <source>Gatsby</source>
          <target state="translated">Gatsby</target>
        </trans-unit>
        <trans-unit id="14837150cbbe37e0d75d8160b89e20cd804e5090" translate="yes" xml:space="preserve">
          <source>Generally speaking, no.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52caaec9d0bac23a32c7ed19ebe70c6cf9d9b6ff" translate="yes" xml:space="preserve">
          <source>Generally speaking, yes, it is OK, and it is often the easiest way to pass parameters to callback functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a76c547269406d92dd91388795bcc92164307d" translate="yes" xml:space="preserve">
          <source>Generally, you don&amp;rsquo;t want to keep the generated javascript in your source control, so be sure to add the build folder to your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75a226127e3ed2978b5f42961dd98a51c54f567" translate="yes" xml:space="preserve">
          <source>Given the code below, we use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; function to take an array of &lt;code&gt;numbers&lt;/code&gt; and double their values. We assign the new array returned by &lt;code&gt;map()&lt;/code&gt; to the variable &lt;code&gt;doubled&lt;/code&gt; and log it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="96136d53d8b75905c13546cd90a5c916cbb29871" translate="yes" xml:space="preserve">
          <source>Glossary and FAQ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f13a545b80f208a5c342a3f09da99fe34c3e60a" translate="yes" xml:space="preserve">
          <source>Glossary of React Terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a8632c801140a5a9de611953f386d1dbbf8845" translate="yes" xml:space="preserve">
          <source>Go to your project folder in the terminal, and paste these two commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d182bef8d5f2839f88903394bb60f7e51fd6c42c" translate="yes" xml:space="preserve">
          <source>Google Chromebook Help - Use the Built-in Screen Reader</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf36c27c78804650761947c87a38f4f6e07ce7e" translate="yes" xml:space="preserve">
          <source>Gradual Adoption Strategy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428e0a93f1ac72bcc666336cd6d935f2d9640d9e" translate="yes" xml:space="preserve">
          <source>Gradual Upgrades via Warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58273e47057ce993d5fd97a4eb4dface99c26929" translate="yes" xml:space="preserve">
          <source>Great! Now when we run our build script the compiler will output the generated javascript to the &lt;code&gt;build&lt;/code&gt; folder. The &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;TypeScript React Starter&lt;/a&gt; provides a &lt;code&gt;tsconfig.json&lt;/code&gt; with a good set of rules to get you started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b257d572f9de8cb600dc9ff344b295b0affeca" translate="yes" xml:space="preserve">
          <source>Grouping by features or routes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7fd6516d065f4d8e30a111bc4d1476d4af19bbe" translate="yes" xml:space="preserve">
          <source>Grouping by file type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02dd6f98e40fbc355cf17dc049baecc28173b57" translate="yes" xml:space="preserve">
          <source>HOCs add features to a component. They shouldn&amp;rsquo;t drastically alter its contract. It&amp;rsquo;s expected that the component returned from a HOC has a similar interface to the wrapped component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063035c50f06bf73e08fe91d42e9d79e9dcc00b0" translate="yes" xml:space="preserve">
          <source>HOCs are common in third-party React libraries, such as Redux&amp;rsquo;s &lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; and Relay&amp;rsquo;s &lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8962b048f87decc8156392f32206c1be5db772" translate="yes" xml:space="preserve">
          <source>HOCs should pass through props that are unrelated to its specific concern. Most HOCs contain a render method that looks something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90574747f52ec1f5009a45ed8d33cb2283639a02" translate="yes" xml:space="preserve">
          <source>HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2d67fd740d7ec7df3d8674c33679652ab92712" translate="yes" xml:space="preserve">
          <source>Handling Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d425f7e27fe0f057871c46f4c72c4a3bd2b0f136" translate="yes" xml:space="preserve">
          <source>Handling Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45618425a820085679577753f54c9b8cd00317e" translate="yes" xml:space="preserve">
          <source>Handling Multiple Inputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af96eff387bd2ffe3a5340f3ed51fac600fd535c" translate="yes" xml:space="preserve">
          <source>Handling events with React elements has some syntactic differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e781a7966802398bc6183dffb3545a19611d53" translate="yes" xml:space="preserve">
          <source>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710df444e674bad2b7f10527830ac10000028b6c" translate="yes" xml:space="preserve">
          <source>Here are some good resources for further reading on when to use &lt;code&gt;props&lt;/code&gt; vs &lt;code&gt;state&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3421fa1b421c70fdf50bc5b3706d1884ec45d9" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;small demo&lt;/a&gt; to get you started. To learn more, check out &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; about data fetching with Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8317f95e08c6543e53027d145f8eddcf023d7fe" translate="yes" xml:space="preserve">
          <source>Here is a step-by-step explanation of what happens in the above example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e83a22ccb4f6fc7030872a422ceee48e5b88b6" translate="yes" xml:space="preserve">
          <source>Here is an &lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;in-depth explanation about why keys are necessary&lt;/a&gt; if you&amp;rsquo;re interested in learning more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469c11af4fb767b071b7bc9fc6660c36d0303d75" translate="yes" xml:space="preserve">
          <source>Here is an example documenting the different validators provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd61c330907127ed38d293d1d4af5a24b4c290e7" translate="yes" xml:space="preserve">
          <source>Here is how we can test it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36728af60fa3c9f7c434352505e9201caca43d44" translate="yes" xml:space="preserve">
          <source>Here we require knowledge of &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;ARIA Roles&lt;/a&gt; as well as &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;ARIA States and Properties&lt;/a&gt;. These are toolboxes filled with HTML attributes that are fully supported in JSX and enable us to construct fully accessible, highly functional React components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9d8cd325a00d9730f610bfeca5652d530f0f8e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a subtree of components. For each one, &lt;code&gt;SCU&lt;/code&gt; indicates what &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned, and &lt;code&gt;vDOMEq&lt;/code&gt; indicates whether the rendered React elements were equivalent. Finally, the circle&amp;rsquo;s color indicates whether the component had to be reconciled or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e5e88093705abf9b440083ab6665499dccb5254" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to setup route-based code splitting into your app using libraries like &lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt; with &lt;code&gt;React.lazy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="983fc3a4301db31eed982a269174f75044f4d44b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the counter example from the &lt;a href=&quot;#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; section, rewritten to use a reducer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccd56b3438af9572583e63a1873615e49b63ab1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what happens when we render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; on the screen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a6a5eadd7c0a89a44b430f4d016d98f4bf2e1e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where the render prop comes in: Instead of hard-coding a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; inside a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, and effectively changing its rendered output, we can provide &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a function prop that it uses to dynamically determine what to render&amp;ndash;a render prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ee35e6fcb6ceeda6ad5733dbfe3081d417836a" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. See the &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; reference guide to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc55606f595a34d3c61c69e9ffbf6a6904254c39" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;useState&lt;/code&gt; is a &lt;em&gt;Hook&lt;/em&gt; (we&amp;rsquo;ll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. &lt;code&gt;useState&lt;/code&gt; returns a pair: the &lt;em&gt;current&lt;/em&gt; state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It&amp;rsquo;s similar to &lt;code&gt;this.setState&lt;/code&gt; in a class, except it doesn&amp;rsquo;t merge the old and new state together. (We&amp;rsquo;ll show an example comparing &lt;code&gt;useState&lt;/code&gt; to &lt;code&gt;this.state&lt;/code&gt; in &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ba3ca71c800446a468a8f1df328896c57eaf85" translate="yes" xml:space="preserve">
          <source>Here, we store the previous value of the &lt;code&gt;row&lt;/code&gt; prop in a state variable so that we can compare:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694a8ab065bc1ddcb8bfd82b16d99febb5b29744" translate="yes" xml:space="preserve">
          <source>Heydon Pickering - ARIA Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9949204d6ccc01e71532e6b5a07e754220b79927" translate="yes" xml:space="preserve">
          <source>Higher-Order Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020cce2b859c795f0df3f5cefeb0457647d208e5" translate="yes" xml:space="preserve">
          <source>Higher-order components come with a few caveats that aren&amp;rsquo;t immediately obvious if you&amp;rsquo;re new to React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="5f4d9480b4df0d6e740642769da4ab963d23e1df" translate="yes" xml:space="preserve">
          <source>Hooks &lt;strong&gt;don&amp;rsquo;t&lt;/strong&gt; work inside classes. But you can use them instead of writing classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6346e065d302bd612cb57acc37b5c4b2d11b5c55" translate="yes" xml:space="preserve">
          <source>Hooks API Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f68a3284889949ad8da40e185f437f9cd788cc" translate="yes" xml:space="preserve">
          <source>Hooks FAQ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6741749abbd97e5aa67270b4114318826ae8ec0d" translate="yes" xml:space="preserve">
          <source>Hooks and Function Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984e9f1dce4f6c473f93ec63fbba28614d61a0c3" translate="yes" xml:space="preserve">
          <source>Hooks are &lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;backwards-compatible&lt;/a&gt;. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1b424d96849c452e8623c3aff21cbd2124f794" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but they impose two additional rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38711e94905b544d78f9780d3bf6f82e5586c52" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but you need to follow two rules when using them. We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12baa054732ac507c2f0e0ac9c1bc905d155c97a" translate="yes" xml:space="preserve">
          <source>Hooks are a more direct way to use the React features you already know &amp;mdash; such as state, lifecycle, context, and refs. They don&amp;rsquo;t fundamentally change how React works, and your knowledge of components, props, and top-down data flow is just as relevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3dffafdaf027921074c093681b6b2fa42d7706d" translate="yes" xml:space="preserve">
          <source>Hooks are called in the same order on every render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6e49743738970df49a4e276c80da3002abd881" translate="yes" xml:space="preserve">
          <source>Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React state and lifecycle features from function components. Hooks don&amp;rsquo;t work inside classes &amp;mdash; they let you use React without classes. (We &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;don&amp;rsquo;t recommend&lt;/a&gt; rewriting your existing components overnight but you can start using Hooks in the new ones if you&amp;rsquo;d like.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0760f5cbbc31d25fdb696fae6c90d049a7e43f" translate="yes" xml:space="preserve">
          <source>Hooks at a Glance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26a024e6656cfd225f9b3faaf69112eb79c72b0" translate="yes" xml:space="preserve">
          <source>Hooks avoid a lot of the overhead that classes require, like the cost of creating class instances and binding event handlers in the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f46f02e8a51698c3e23f41f8d864b3b26080e0" translate="yes" xml:space="preserve">
          <source>Hooks do have a learning curve of their own. If there&amp;rsquo;s something missing in this documentation, &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;raise an issue&lt;/a&gt; and we&amp;rsquo;ll try to help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78aadbe4b447f0e05b05e1acb099273d9660236" translate="yes" xml:space="preserve">
          <source>Hooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd8adc24c90fba774c6fae7ebe2e06da199b06e" translate="yes" xml:space="preserve">
          <source>Hooks offer a powerful and expressive new way to reuse functionality between components. &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt; provides a glimpse of what&amp;rsquo;s possible. &lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;This article&lt;/a&gt; by a React core team member dives deeper into the new capabilities unlocked by Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beee8e71e8faa563add416aa12ae92953a859ef1" translate="yes" xml:space="preserve">
          <source>Hooks solve a wide variety of seemingly unconnected problems in React that we&amp;rsquo;ve encountered over five years of writing and maintaining tens of thousands of components. Whether you&amp;rsquo;re learning React, use it daily, or even prefer a different library with a similar component model, you might recognize some of these problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125ff9caefd47f46f6f9836d25c8aeb5965e4029" translate="yes" xml:space="preserve">
          <source>Hooks synthesize ideas from several different sources:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddd1c044852bd20a73c95243ed31e59f05c49ac" translate="yes" xml:space="preserve">
          <source>Hooks were designed with static typing in mind. Because they&amp;rsquo;re functions, they are easier to type correctly than patterns like higher-order components. The latest Flow and TypeScript React definitions include support for React Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3263600c56483c0a3a486401c7c00425cf496889" translate="yes" xml:space="preserve">
          <source>Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you&amp;rsquo;re used to, remember that code is read far more than it&amp;rsquo;s written, and it&amp;rsquo;s less difficult to read this modular, explicit code. As you start to build large libraries of components, you&amp;rsquo;ll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692095ebf5adc28ef5dd43de59073c7e0f30fed7" translate="yes" xml:space="preserve">
          <source>How About Event Handlers?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6ede7c8218456d272e15d1df527222761a5d58" translate="yes" xml:space="preserve">
          <source>How About try/catch?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f9d04f7128ff4e06c8d87250d8e47453873aca" translate="yes" xml:space="preserve">
          <source>How Can I Learn More About Experimental Features?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b32b4ad6bd37176faffadb32d22a8289534a746" translate="yes" xml:space="preserve">
          <source>How To Use Context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3b1dc4703059a43990fb4f54a82b7ea462210e" translate="yes" xml:space="preserve">
          <source>How can I do data fetching with Hooks?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3eb93766a70bcb23bd57b5f81706e1346cc00b" translate="yes" xml:space="preserve">
          <source>How can I make an AJAX call?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65c5d09d6ca3b416e582fadae15682637bf85c2" translate="yes" xml:space="preserve">
          <source>How can I measure a DOM node?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8a15cb87dd32841f00b87b456991b2721d9c55" translate="yes" xml:space="preserve">
          <source>How can I prevent a function from being called too quickly or too many times in a row?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aec71a52b9be72fd0463ec529f9c780d7f499e0" translate="yes" xml:space="preserve">
          <source>How can I write comments in JSX?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d4d9bc9ea4bb507420dda2c277f59106d4c62f" translate="yes" xml:space="preserve">
          <source>How do I add CSS classes to components?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a15ac345101e045ea595d31734e8063db66661" translate="yes" xml:space="preserve">
          <source>How do I bind a function to a component instance?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa62b3618db8ebfa8f917b302351ed7099483e1f" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;getDerivedStateFromProps&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0572ad330916c3fe730299d4ede58b185b5ca13" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9e955accc6d91168550466054bc2a0652117d7" translate="yes" xml:space="preserve">
          <source>How do I implement getDerivedStateFromProps?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9415649ba2cf6fdc23c48d06f17328a84773eae" translate="yes" xml:space="preserve">
          <source>How do I implement shouldComponentUpdate?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ca0d1ae983bdbef86eee8bd0c53b191176837f" translate="yes" xml:space="preserve">
          <source>How do I pass a parameter to an event handler or callback?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b2ecaed14852353d71b3ff348314158c48bfb1" translate="yes" xml:space="preserve">
          <source>How do I pass an event handler (like onClick) to a component?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b4082736e34d847d56b0cabd7b94a845d15d06" translate="yes" xml:space="preserve">
          <source>How do I update state with values that depend on the current state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1571c2b05260a179a5c52b92711d13ace65d09c2" translate="yes" xml:space="preserve">
          <source>How do lifecycle methods correspond to Hooks?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef86d6c075ad452ca05fc6dfcb095042d6b94c62" translate="yes" xml:space="preserve">
          <source>How do we separate the Receded and the Skeleton states? The difference between them is that the &lt;strong&gt;Receded&lt;/strong&gt; state feels like &amp;ldquo;taking a step back&amp;rdquo; to the user, while the &lt;strong&gt;Skeleton&lt;/strong&gt; state feels like &amp;ldquo;taking a step forward&amp;rdquo; in our progress to show more content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd07e5b2055c72f75ab42f26ab2628f05373053" translate="yes" xml:space="preserve">
          <source>How does React associate Hook calls with components?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03433b6618565d81523f098fea7bbfc849e26f58" translate="yes" xml:space="preserve">
          <source>How is this different from debouncing? Our example has a fixed artificial delay (3ms for every one of 80 items), so there is always a delay, no matter how fast our computer is. However, the &lt;code&gt;useDeferredValue&lt;/code&gt; value only &amp;ldquo;lags behind&amp;rdquo; if the rendering takes a while. There is no minimal lag imposed by React. With a more realistic workload, you can expect the lag to adjust to the user&amp;rsquo;s device. On fast machines, the lag would be smaller or non-existent, and on slow machines, it would be more noticeable. In both cases, the app would remain responsive. That&amp;rsquo;s the advantage of this mechanism over debouncing or throttling, which always impose a minimal delay and can&amp;rsquo;t avoid blocking the thread while rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef20a3ab1615429a9e3caea2dfc9283ba06feb8c" translate="yes" xml:space="preserve">
          <source>How much of my React knowledge stays relevant?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cf9009310d5e4e171575929c85ba93f68d8165" translate="yes" xml:space="preserve">
          <source>How to Approach the Problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772ce99a70283ae35b4e13fa8d26821113684e81" translate="yes" xml:space="preserve">
          <source>How to Read This Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5bdd73691289d5424afb561fb4d4a8c352d85e" translate="yes" xml:space="preserve">
          <source>How to avoid passing callbacks down?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4460bb5cb239f962c6f963dd45f4bfc12fafab4" translate="yes" xml:space="preserve">
          <source>How to create expensive objects lazily?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b7e53bed65fc2a70652cc57c409f8809ebddf6" translate="yes" xml:space="preserve">
          <source>How to get the previous props or state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24f12ba653d001525d8a8bd81fe1cef3fad0860" translate="yes" xml:space="preserve">
          <source>How to memoize calculations?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fb9eef456bcd915cd5640203146790d6c28cff" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from &lt;code&gt;useCallback&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc2a2a6938156221ff27517255883f6fe53d187" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from useCallback?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e42ecde4eca22b2d3b189bcf068d674eeacdb8a" translate="yes" xml:space="preserve">
          <source>How to test components that use Hooks?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da64590fe0ba979539b260ad3ab00d0ecded657" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;useRef()&lt;/code&gt; is useful for more than the &lt;code&gt;ref&lt;/code&gt; attribute. It&amp;rsquo;s &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;handy for keeping any mutable value around&lt;/a&gt; similar to how you&amp;rsquo;d use instance fields in classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f0f95f546c8a3bf04820043025e19f7a76c111" translate="yes" xml:space="preserve">
          <source>However, React also offers an option to use &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3333696f448160f28cb91d4eececaddabcf02145" translate="yes" xml:space="preserve">
          <source>However, React components are declarative and specify &lt;em&gt;what&lt;/em&gt; should be rendered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b9ee92c12009c14589ca7400a64667019fa998" translate="yes" xml:space="preserve">
          <source>However, elements can also represent user-defined components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8914df7a2751ed9a49c0a876b51e78db6ebded98" translate="yes" xml:space="preserve">
          <source>However, in Concurrent Mode there are cases where you might &lt;em&gt;want&lt;/em&gt; to &amp;ldquo;duplicate&amp;rdquo; some data in different state variables. Consider this tiny translation app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58ece91c2a93ff8dda87d95414ebd23f4782a9c" translate="yes" xml:space="preserve">
          <source>However, it also preserves &lt;code&gt;ref&lt;/code&gt;s. This means that if you get a child with a &lt;code&gt;ref&lt;/code&gt; on it, you won&amp;rsquo;t accidentally steal it from your ancestor. You will get the same &lt;code&gt;ref&lt;/code&gt; attached to your new element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dccca1546e00e09348d2ca880b503bbc3782a4f" translate="yes" xml:space="preserve">
          <source>However, it does raise the question of why these releases aren&amp;rsquo;t versioned as patches instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a583f2ca74afad8b48de4866dda319994ca798" translate="yes" xml:space="preserve">
          <source>However, it misses a crucial requirement: the fact that the &lt;code&gt;Clock&lt;/code&gt; sets up a timer and updates the UI every second should be an implementation detail of the &lt;code&gt;Clock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b55a581ed0d44371ffb07796a1f139be740fa1" translate="yes" xml:space="preserve">
          <source>However, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called &lt;a href=&quot;#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt;. It has the same signature as &lt;code&gt;useEffect&lt;/code&gt;, and only differs in when it is fired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66df5c038ad97c79d198f1c4a9bcf642fe39edab" translate="yes" xml:space="preserve">
          <source>However, sometimes it might be helpful to intentionally introduce an inconsistency. We could do it manually by &amp;ldquo;splitting&amp;rdquo; the state like above, but React also offers a built-in Hook for this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684d4b7ace58812c1c1257030e5191e892f4d124" translate="yes" xml:space="preserve">
          <source>However, sometimes it&amp;rsquo;s useful to insert a child into a different location in the DOM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7873b7f443466f38d48c121a13c985ec5c569acf" translate="yes" xml:space="preserve">
          <source>However, sometimes the same data needs to be accessible by many components in the tree, and at different nesting levels. Context lets you &amp;ldquo;broadcast&amp;rdquo; such data, and changes to it, to all components below. Common examples where using context might be simpler than the alternatives include managing the current locale, theme, or a data cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23514e5e71b6ee6ebabf134e94bf282dd4ddd004" translate="yes" xml:space="preserve">
          <source>However, the experience feels really jarring. We were browsing a page, but it got replaced by a loading state right as we were interacting with it. It&amp;rsquo;s disorienting. &lt;strong&gt;Just like before, to avoid showing an undesirable loading state, we can wrap the state update in a transition:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b955a466dd5e01eaf645eec3e93c8799d5ab4f5" translate="yes" xml:space="preserve">
          <source>However, this may be overkill in some cases, like the subscription example from the previous section. We don&amp;rsquo;t need to create a new subscription on every update, only if the &lt;code&gt;source&lt;/code&gt; prop has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54fc10053a808be02d653b28bf41ebcbb425fe4" translate="yes" xml:space="preserve">
          <source>However, this requires you to know exactly which methods need to be copied. You can use &lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;hoist-non-react-statics&lt;/a&gt; to automatically copy all non-React static methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b543d8a8b990abf052de4f376f9d0b9c65f73938" translate="yes" xml:space="preserve">
          <source>However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3ad954f0338c11e6cda950a40addb37e02fd0f" translate="yes" xml:space="preserve">
          <source>However, you might still be wondering why React doesn&amp;rsquo;t just update &lt;code&gt;this.state&lt;/code&gt; immediately without re-rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e059ed18e3f4b02238b502a8f5e588e0008af29" translate="yes" xml:space="preserve">
          <source>Ideally we want to write this once and have the &lt;code&gt;Clock&lt;/code&gt; update itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a176af0e3541b91734625dec4f3b8292439dd1d" translate="yes" xml:space="preserve">
          <source>Ideas</source>
          <target state="translated">Ideas</target>
        </trans-unit>
        <trans-unit id="dbd660e2dd45612fbe7fcb2d52008460403f801b" translate="yes" xml:space="preserve">
          <source>Identify every component that renders something based on that state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c7ee658b9e92f85c8bfec7b6c2a38fb96663d7" translate="yes" xml:space="preserve">
          <source>Identifying components with unsafe lifecycles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634e92551f670791962e82615e588bc9e77eae60" translate="yes" xml:space="preserve">
          <source>Identifying unsafe lifecycles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95633762d757325e688096b23309ad6ed512c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;children&lt;/code&gt; is a &lt;code&gt;Fragment&lt;/code&gt; it will be treated as a single child and not traversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ec8b74463d4b6788285debd449e8a36886f529" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is defined within a component, the following &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; will receive an additional parameter, the &lt;code&gt;context&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7942ea96f993393244bb793ed3444403e13d0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is not defined, then &lt;code&gt;context&lt;/code&gt; will be an empty object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8bc3d5f6a162a81742105b7e5aa8a5814ce785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is not provided, it will be set by default to &lt;code&gt;'blue'&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba93d4ea31d24880e40a17c457b5255600429f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is set to null, it will remain null:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b6d366d7013c823d86f9937f864aa2f4eb5035" translate="yes" xml:space="preserve">
          <source>If a Minor Release Includes No New Features, Why Isn&amp;rsquo;t It a Patch?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7808973984d8e4c597980af26324716a790b3eb9" translate="yes" xml:space="preserve">
          <source>If a component is using multiple mixins and several mixins define the same lifecycle method (i.e. several mixins want to do some cleanup when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on mixins run in the order mixins were listed, followed by a method call on the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97235b567c0265f0d9926f25dc8829579aa2e646" translate="yes" xml:space="preserve">
          <source>If a feature is not documented, they may be accompanied by an &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bc1e73352759548987f8a409ddc10869579747" translate="yes" xml:space="preserve">
          <source>If a release includes non-essential changes &amp;mdash; such as internal refactors, changes to implementation details, performance improvements, or minor bugfixes &amp;mdash; we will bump the minor version even when there are no new features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ff55774a140aca8bdaed69bfb51da5366dacc0" translate="yes" xml:space="preserve">
          <source>If a single element&amp;rsquo;s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the warning by adding &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; to the element. It only works one level deep, and is intended to be an escape hatch. Don&amp;rsquo;t overuse it. Unless it&amp;rsquo;s text content, React still won&amp;rsquo;t attempt to patch it up, so it may remain inconsistent until future updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d556b20cb4547e127f2815074ef2fe4e41710802" translate="yes" xml:space="preserve">
          <source>If a tag is empty, you may close it immediately with &lt;code&gt;/&amp;gt;&lt;/code&gt;, like XML:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b320bf64ff848996f74d77101a47dfdd619e264" translate="yes" xml:space="preserve">
          <source>If after that we still don&amp;rsquo;t use any values from the component scope, it&amp;rsquo;s safe to specify &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6b3e11e3d3c38135418032d8908ab5281f6aca" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;bind&lt;/code&gt; annoys you, there are two ways you can get around this. If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use class fields to correctly bind callbacks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ab379086a708259f83594879dae195d221ed0e" translate="yes" xml:space="preserve">
          <source>If everything passes, great! You can expect that your project will work with the next minor React release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bec09d61efa659eb228a4953584f79786650d2" translate="yes" xml:space="preserve">
          <source>If fetching user details takes three seconds, we&amp;rsquo;ll only &lt;em&gt;start&lt;/em&gt; fetching the posts after three seconds! That&amp;rsquo;s a &amp;ldquo;waterfall&amp;rdquo;: an unintentional &lt;em&gt;sequence&lt;/em&gt; that should have been parallelized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61455d144dae27e035208c57b22d9252594b892f" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s still not clear which type of component you should use for a particular situation, you might find &lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;this article on controlled versus uncontrolled inputs&lt;/a&gt; to be helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a099559eb261307dc775d158033df86e50e770" translate="yes" xml:space="preserve">
          <source>If no array is provided, a new value will be computed on every render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44bfdbf92e17d273381e7b8fb1a3f01879ecf26c" translate="yes" xml:space="preserve">
          <source>If some common scenario is not covered, please let us know on the &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;issue tracker&lt;/a&gt; for the documentation website.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0387b7a09358144d9726581e47b1de8c8b84739d" translate="yes" xml:space="preserve">
          <source>If some component &amp;ldquo;suspends&amp;rdquo;, does the app freeze? How to avoid this?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb69be684ead34368506e903349ff51d28c48c95" translate="yes" xml:space="preserve">
          <source>If some value isn&amp;rsquo;t used for rendering or data flow (for example, a timer ID), you don&amp;rsquo;t have to put it in the state. Such values can be defined as fields on the component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0fa5a864d283d560c5564be4c37fdc16ee5c7f" translate="yes" xml:space="preserve">
          <source>If something breaks unexpectedly, please let us know by &lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;filing an issue&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81b0e7afa3fb271a0976602cc04371ca693d752" translate="yes" xml:space="preserve">
          <source>If something can be derived from either props or state, it probably shouldn&amp;rsquo;t be in the state. For example, instead of storing both &lt;code&gt;celsiusValue&lt;/code&gt; and &lt;code&gt;fahrenheitValue&lt;/code&gt;, we store just the last edited &lt;code&gt;temperature&lt;/code&gt; and its &lt;code&gt;scale&lt;/code&gt;. The value of the other input can always be calculated from them in the &lt;code&gt;render()&lt;/code&gt; method. This lets us clear or apply rounding to the other field without losing any precision in the user input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1eff28de072c228c3fac6f7de4af84285d52c7" translate="yes" xml:space="preserve">
          <source>If something is missing in the documentation or if you found some part confusing, please &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;file an issue for the documentation repository&lt;/a&gt; with your suggestions for improvement, or tweet at the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt;. We love hearing from you!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba9933df2ec0f3c00ec311cb0e316ed0a71e056" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Calculator&lt;/code&gt; owns the shared state, it becomes the &amp;ldquo;source of truth&amp;rdquo; for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both &lt;code&gt;TemperatureInput&lt;/code&gt; components are coming from the same parent &lt;code&gt;Calculator&lt;/code&gt; component, the two inputs will always be in sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1508d0b9f38075d8659f83a363a29e0a2c1eb40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Clock&lt;/code&gt; component is ever removed from the DOM, React calls the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method so the timer is stopped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285cc10d670d67e7a1d042087524d72b3c61948c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref&lt;/code&gt; callback is defined as an inline function, it will get called twice during updates, first with &lt;code&gt;null&lt;/code&gt; and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the &lt;code&gt;ref&lt;/code&gt; callback as a bound method on the class, but note that it shouldn&amp;rsquo;t matter in most cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11443443fa44ef2cec37924f0c1f90e49c7f394" translate="yes" xml:space="preserve">
          <source>If the React element was previously rendered into &lt;code&gt;container&lt;/code&gt;, this will perform an update on it and only mutate the DOM as necessary to reflect the latest React element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68368472358ffa4040481d1ccc81327648d3fb5" translate="yes" xml:space="preserve">
          <source>If the boilerplate code is too unattractive to you, you may enable the &lt;strong&gt;experimental&lt;/strong&gt;&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;Class Properties&lt;/a&gt; syntax proposal with Babel:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1524d0a0bb3f485163f09431911716ee3095bb5" translate="yes" xml:space="preserve">
          <source>If the function you&amp;rsquo;re calling is a pure computation and is safe to call while rendering, you may &lt;strong&gt;call it outside of the effect instead,&lt;/strong&gt; and make the effect depend on the returned value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c76fa2e50dee5e670f91c11fbf1264bff2a124" translate="yes" xml:space="preserve">
          <source>If the new state is computed using the previous state, you can pass a function to &lt;code&gt;setState&lt;/code&gt;. The function will receive the previous value, and return an updated value. Here&amp;rsquo;s an example of a counter component that uses both forms of &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5fb4c02d4fde303749802adf11f045d7e01c08" translate="yes" xml:space="preserve">
          <source>If the only way your component ever changes is when the &lt;code&gt;props.color&lt;/code&gt; or the &lt;code&gt;state.count&lt;/code&gt; variable changes, you could have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; check that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4d632eeb98bbd6eb7a8cf7c7cf0db0d585a084" translate="yes" xml:space="preserve">
          <source>If the optional callback is provided, it will be executed after the component is rendered or updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9825426bb3519158f32e335335bf1288ffbb02ac" translate="yes" xml:space="preserve">
          <source>If the other module fails to load (for example, due to network failure), it will trigger an error. You can handle these errors to show a nice user experience and manage recovery with &lt;a href=&quot;error-boundaries&quot;&gt;Error Boundaries&lt;/a&gt;. Once you&amp;rsquo;ve created your Error Boundary, you can use it anywhere above your lazy components to display an error state when there&amp;rsquo;s a network error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d645637af0f89ddb43e30926c108ad1d42dea97" translate="yes" xml:space="preserve">
          <source>If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. &lt;strong&gt;In most cases, you can attach a ref to the DOM node and avoid using &lt;code&gt;findDOMNode&lt;/code&gt; at all.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2beaac6d52020b7f238083eeeeccbf47e42f3e4b" translate="yes" xml:space="preserve">
          <source>If two or more context values are often used together, you might want to consider creating your own render prop component that provides both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f978898c43c050ba9392e9f7a52dfcd4549f6d" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want some component to delay the transition, we can wrap it in its own &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19013949653b81e2adb86a0553d1ff708b6beb68" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to load this component in our tests, we can mock out the dependency itself to a dummy component, and run our tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc989df7c0d84bfb51075d6a4b04861fa37c52c1" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to stay in the Pending state for too long, our first instinct might be to set &lt;code&gt;timeoutMs&lt;/code&gt; in &lt;code&gt;useTransition&lt;/code&gt; to something smaller, like &lt;code&gt;3000&lt;/code&gt;. You can try this &lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;here&lt;/a&gt;. This lets us escape the prolonged Pending state, but we still don&amp;rsquo;t have anything useful to show!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28361e99b6744be8efafa4d49b562aaade2f3b5" translate="yes" xml:space="preserve">
          <source>If we intentionally &lt;em&gt;want&lt;/em&gt; to show an inconsistent UI for a small period of time, can we do that?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc070f0d7e8042a80001420c3eae7347b4592739" translate="yes" xml:space="preserve">
          <source>If we just wanted to set an interval, we wouldn&amp;rsquo;t need the ref (&lt;code&gt;id&lt;/code&gt; could be local to the effect), but it&amp;rsquo;s useful if we want to clear the interval from an event handler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10129e51e2f781d3b2a1978fc9c0500021cdb2cc" translate="yes" xml:space="preserve">
          <source>If we later edit the Fahrenheit field to be 212, the state of the &lt;code&gt;Calculator&lt;/code&gt; will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef4de5727a1ae42b86ddd7ac75d5b2cb2686cbb" translate="yes" xml:space="preserve">
          <source>If we make our API responses take 5 seconds, &lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;we can confirm&lt;/a&gt; that now React &amp;ldquo;gives up&amp;rdquo; and transitions anyway to the next screen after 3 seconds. This is because we passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to &lt;code&gt;useTransition()&lt;/code&gt;. For example, if we passed &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; instead, it would wait a whole minute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d759d3e1bb1bdd18c1893117d44336d9737a917" translate="yes" xml:space="preserve">
          <source>If we try this code, it might seem like it works at first. However, if we randomize the delay time in our &amp;ldquo;fake API&amp;rdquo; implementation and press the &amp;ldquo;Next&amp;rdquo; button fast enough, we&amp;rsquo;ll see from the console logs that something is going very wrong. &lt;strong&gt;Requests from the previous profiles may sometimes &amp;ldquo;come back&amp;rdquo; after we&amp;rsquo;ve already switched the profile to another ID &amp;mdash; and in that case they can overwrite the new state with a stale response for a different ID.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3a9278266bf705f6dd179c22a52cc57d1c6f99" translate="yes" xml:space="preserve">
          <source>If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd6f78d0df5d6a5d29d430057c8831c6b2afedc" translate="yes" xml:space="preserve">
          <source>If we wanted to wrap the &lt;code&gt;CustomTextInput&lt;/code&gt; above to simulate it being clicked immediately after mounting, we could use a ref to get access to the custom input and call its &lt;code&gt;focusTextInput&lt;/code&gt; method manually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406ca61e719e6f4e1e3008d4b342561469a8b770" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re willing to sacrifice consistency, we could &lt;strong&gt;pass potentially stale data to the components that delay our transition&lt;/strong&gt;. That&amp;rsquo;s what &lt;code&gt;useDeferredValue()&lt;/code&gt; lets us do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9413bd0fc5834a029e8af7dddbd9382c56068a" translate="yes" xml:space="preserve">
          <source>If you already have &lt;code&gt;props&lt;/code&gt; as an object, and you want to pass it in JSX, you can use &lt;code&gt;...&lt;/code&gt; as a &amp;ldquo;spread&amp;rdquo; operator to pass the whole props object. These two components are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8735706de7bdc6d287d2a819b6a76fae1e775b79" translate="yes" xml:space="preserve">
          <source>If you already minify the application scripts, &lt;strong&gt;your site will be production-ready&lt;/strong&gt; if you ensure that the deployed HTML loads the versions of React ending in &lt;code&gt;production.min.js&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd058484ca6af46bd0f0bdc60864ddb7e7bdf9f" translate="yes" xml:space="preserve">
          <source>If you are confident you want to write it by hand, you may compare &lt;code&gt;this.props&lt;/code&gt; with &lt;code&gt;nextProps&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; with &lt;code&gt;nextState&lt;/code&gt; and return &lt;code&gt;false&lt;/code&gt; to tell React the update can be skipped. Note that returning &lt;code&gt;false&lt;/code&gt; does not prevent child components from re-rendering when &lt;em&gt;their&lt;/em&gt; state changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c76b0412bce989363700bf2ef3011d9639d358" translate="yes" xml:space="preserve">
          <source>If you are using a Babel transform like &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-properties&lt;/a&gt; , you can also declare &lt;code&gt;defaultProps&lt;/code&gt; as static property within a React component class. This syntax has not yet been finalized though and will require a compilation step to work within a browser. For more information, see the &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class fields proposal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b66416e2290abd98cf21dbd99025df7c4ba6a0" translate="yes" xml:space="preserve">
          <source>If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use a &lt;strong&gt;static&lt;/strong&gt; class field to initialize your &lt;code&gt;contextType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcd73af03cb4d3e4e3b7c1bd1f74a1bd7b665d0" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t sure whether your build process is set up correctly, you can check it by installing &lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;React Developer Tools for Chrome&lt;/a&gt;. If you visit a site with React in production mode, the icon will have a dark background:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0c664da034e861544cfcdf5f02c8fd40d847b9" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using class fields syntax, you can use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; in the callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bf06802507eba86661f75bc21760f1686e68d8" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t, you&amp;rsquo;ll need to setup bundling yourself. For example, see the &lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;Installation&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;Getting Started&lt;/a&gt; guides on the Webpack docs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3292dd08de71388ad7c0b1a0bf8e95045ff37d" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12886015a122be4810ebe17201bb8cce342272e" translate="yes" xml:space="preserve">
          <source>If you call it on a &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; DOM node, it reads the attributes off of the original DOM node, hides it with an inline style, and then appends a separate DOM node with its own visual representation right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;. Then it fires jQuery events to notify us about the changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f9877110efff3327fdffedf68d4026372380df" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common owner component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80d72886f63f44e90c32f25b0726ec9919167cc" translate="yes" xml:space="preserve">
          <source>If you do have performance issues, by all means, optimize!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842af6389784f4195a6f44b18d1ae6472e5779f0" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t experience the problems described above or don&amp;rsquo;t feel comfortable using JavaScript tools yet, consider &lt;a href=&quot;add-react-to-a-website&quot;&gt;adding React as a plain &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag on an HTML page&lt;/a&gt;, optionally &lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;with JSX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a3d724ce9d7d08105873a53c6f8dacf835179a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a minification step for your scripts, &lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;here&amp;rsquo;s one way to set it up&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169a21de60ad2e2c1ea7fcef1a94d52e1be56808" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59cb0765a73ef01c64e7a89fed250a66bd20f39c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 classes, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead. See &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f856dc1fed776914cf062b3e550d19f3eb8f9429" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 yet, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0b9b7af2dae0cbfcf4257fa36894387d46af3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Relay today, you might have to wait before you can really try Suspense in your app. So far, it&amp;rsquo;s the only implementation that we tested in production and are confident in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332383307eebba5d31fd9d269485dc3ba0b151a2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use a JavaScript bundler and loaded React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, it is already in scope as the &lt;code&gt;React&lt;/code&gt; global.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fce0593a2dfad3e9857ade52faf663322205bd6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use either Create React App or Babel, you can use &lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types&lt;/a&gt; to strip the type annotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb891743d28825149d46e0a3067c093baedd036f" translate="yes" xml:space="preserve">
          <source>If you feel completely stuck, start by keeping all files in a single folder. Eventually it will grow large enough that you will want to separate some files from the rest. By that time you&amp;rsquo;ll have enough knowledge to tell which files you edit together most often. In general, it is a good idea to keep files that often change together close to each other. This principle is called &amp;ldquo;colocation&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df68e6e9e49708727aa3d9b52f358771b20204ab" translate="yes" xml:space="preserve">
          <source>If you feel that the React documentation goes at a faster pace than you&amp;rsquo;re comfortable with, check out &lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;this overview of React by Tania Rascia&lt;/a&gt;. It introduces the most important React concepts in a detailed, beginner-friendly way. Once you&amp;rsquo;re done, give the documentation another try!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d81fbc72ec17b2e89d0c20f4ef89b52ec88b669" translate="yes" xml:space="preserve">
          <source>If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76310cae2aa02095c07fe271a1cb7cd76b5e2f80" translate="yes" xml:space="preserve">
          <source>If you first click &amp;ldquo;Show alert&amp;rdquo; and then increment the counter, the alert will show the &lt;code&gt;count&lt;/code&gt; variable &lt;strong&gt;at the time you clicked the &amp;ldquo;Show alert&amp;rdquo; button&lt;/strong&gt;. This prevents bugs caused by the code assuming props and state don&amp;rsquo;t change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c29ce29fd299ea922160b41c611cec1eecbc8a" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run Flow for the first time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5309b9cba3e5ecb4cc81e27f68ffbda4d5dab96" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run TypeScript for the first time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f39f38f2b3af85590f8b59543c367401e440f4" translate="yes" xml:space="preserve">
          <source>If you get tired of typing &lt;code&gt;React.createElement&lt;/code&gt; so much, one common pattern is to assign a shorthand:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7325f76c86bc8debb6d4b74351284f0958afc1d0" translate="yes" xml:space="preserve">
          <source>If you have a large existing app, or if your app depends on a lot of third-party packages, please don&amp;rsquo;t expect that you can use the Concurrent Mode immediately. &lt;strong&gt;For example, at Facebook we are using Concurrent Mode for the new website, but we&amp;rsquo;re not planning to enable it on the old website.&lt;/strong&gt; This is because our old website still uses unsafe lifecycle methods in the product code, incompatible third-party libraries, and patterns that don&amp;rsquo;t work well with the Concurrent Mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049b884296cbaec372f91838646c82b517badc89" translate="yes" xml:space="preserve">
          <source>If you have an event handler such as &lt;code&gt;onClick&lt;/code&gt; or &lt;code&gt;onScroll&lt;/code&gt; and want to prevent the callback from being fired too quickly, then you can limit the rate at which callback is executed. This can be done by using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c213f4472d12ecabe35b829a19649d2ed0d0411" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed the React DevTools, you can find them here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4eeb14778b01a7164c9500da7ff7d43818dfb4" translate="yes" xml:space="preserve">
          <source>If you imagine a component tree as a waterfall of props, each component&amp;rsquo;s state is like an additional water source that joins it at an arbitrary point but also flows down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827469f1283cc9cfff29c0d19a28165070940429" translate="yes" xml:space="preserve">
          <source>If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15834c075532b4876fc67d3752aa2da60bdf369" translate="yes" xml:space="preserve">
          <source>If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like &lt;code&gt;this.state.isClient&lt;/code&gt;, which you can set to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration. Note that this approach will make your components slower because they have to render twice, so use it with caution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286d3422088a5f59b246609f9ba1c043e52041ac" translate="yes" xml:space="preserve">
          <source>If you intentionally want to read the &lt;em&gt;latest&lt;/em&gt; state from some asynchronous callback, you could keep it in &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;a ref&lt;/a&gt;, mutate it, and read from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e225027ec18fdfd87c9b8442cffb1951bc054fb1" translate="yes" xml:space="preserve">
          <source>If you know that in some situations your component doesn&amp;rsquo;t need to update, you can return &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt; instead, to skip the whole rendering process, including calling &lt;code&gt;render()&lt;/code&gt; on this component and below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91d2eeadcd117626f038d440e0070b4483671a4" translate="yes" xml:space="preserve">
          <source>If you load React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, these top-level APIs are available on the &lt;code&gt;ReactDOM&lt;/code&gt; global. If you use ES6 with npm, you can write &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt;. If you use ES5 with npm, you can write &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93e9d0b0522ffa63fd03295a5cdd6cf8a5e08ca" translate="yes" xml:space="preserve">
          <source>If you look at &lt;code&gt;ProductTable&lt;/code&gt;, you&amp;rsquo;ll see that the table header (containing the &amp;ldquo;Name&amp;rdquo; and &amp;ldquo;Price&amp;rdquo; labels) isn&amp;rsquo;t its own component. This is a matter of preference, and there&amp;rsquo;s an argument to be made either way. For this example, we left it as part of &lt;code&gt;ProductTable&lt;/code&gt; because it is part of rendering the &lt;em&gt;data collection&lt;/em&gt; which is &lt;code&gt;ProductTable&lt;/code&gt;&amp;rsquo;s responsibility. However, if this header grows to be complex (e.g., if we were to add affordances for sorting), it would certainly make sense to make this its own &lt;code&gt;ProductTableHeader&lt;/code&gt; component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d1d424e7e902eeef27e0e70b07d9c861ccdada" translate="yes" xml:space="preserve">
          <source>If you manually configured Babel for your project, you will need to install a special preset for Flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2852832854adc219ab4e001ad21ce5c774975fe9" translate="yes" xml:space="preserve">
          <source>If you miss automatic merging, you can write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, instead &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79521cbe23ba5b60b28726474c0765c13be1ba0" translate="yes" xml:space="preserve">
          <source>If you name the render function, DevTools will also include its name (e.g. &amp;rdquo;&lt;em&gt;ForwardRef(myFunction)&lt;/em&gt;&amp;rdquo;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f30ff0b95e1da79af197894b22f7fa988c3f02" translate="yes" xml:space="preserve">
          <source>If you need to &lt;strong&gt;perform a side effect&lt;/strong&gt; (for example, data fetching or an animation) in response to a change in props, use &lt;a href=&quot;#componentdidupdate&quot;&gt;&lt;code&gt;componentDidUpdate&lt;/code&gt;&lt;/a&gt; lifecycle instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205f3177c868e6b279f403e9745e8dcaeb2d6fd7" translate="yes" xml:space="preserve">
          <source>If you need to catch an error inside event handler, use the regular JavaScript &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a74f7dd4fe0268f156490184fdd512266a1aa6" translate="yes" xml:space="preserve">
          <source>If you need to have access to the parent component in the handler, you also need to bind the function to the component instance (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca64c98be7ac6b3d7e337c9127443df11a919dbf" translate="yes" xml:space="preserve">
          <source>If you need to interact with the browser, perform your work in &lt;code&gt;componentDidMount()&lt;/code&gt; or the other lifecycle methods instead. Keeping &lt;code&gt;render()&lt;/code&gt; pure makes components easier to think about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999ea53a2b5707c7945911f1e76d3cadb698fd97" translate="yes" xml:space="preserve">
          <source>If you need to modify some value in response to user input or a network response, use &lt;code&gt;state&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8943142e15f89aafbe2213a7c4d356ded10b9fca" translate="yes" xml:space="preserve">
          <source>If you need to test a custom Hook, you can do so by creating a component in your test, and using your Hook from it. Then you can test the component you wrote.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1a99a66b2ca1ad147dc87037be4bed83199b9c" translate="yes" xml:space="preserve">
          <source>If you notice that you&amp;rsquo;re getting comfortable with build tools and want them to do more for you, &lt;a href=&quot;create-a-new-react-app&quot;&gt;the next section&lt;/a&gt; describes some of the most popular and approachable toolchains. If not &amp;mdash; those script tags will do just fine!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130609e0ef86c8bb326cdb736a8d5fa6030de201" translate="yes" xml:space="preserve">
          <source>If you now create a file called &lt;code&gt;src/like_button.js&lt;/code&gt; with this &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;JSX starter code&lt;/a&gt;&lt;/strong&gt;, the watcher will create a preprocessed &lt;code&gt;like_button.js&lt;/code&gt; with the plain JavaScript code suitable for the browser. When you edit the source file with JSX, the transform will re-run automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeff73e27684ff93921c75989a38770068d66406" translate="yes" xml:space="preserve">
          <source>If you often find yourself writing code like this, &lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt; package can simplify it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523f123efc70d115d1e9f594fc23ba7ce9678a9f" translate="yes" xml:space="preserve">
          <source>If you pass an empty array (&lt;code&gt;[]&lt;/code&gt;), the props and state inside the effect will always have their initial values. While passing &lt;code&gt;[]&lt;/code&gt; as the second argument is closer to the familiar &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; mental model, there are usually &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;better&lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;solutions&lt;/a&gt; to avoid re-running effects too often. Also, don&amp;rsquo;t forget that React defers running &lt;code&gt;useEffect&lt;/code&gt; until after the browser has painted, so doing extra work is less of a problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6b23abafdc2b9551fe13b784fbb8c555b202cd" translate="yes" xml:space="preserve">
          <source>If you pass no value for a prop, it defaults to &lt;code&gt;true&lt;/code&gt;. These two JSX expressions are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20bd7989c1f9f633f138de90c77630a2841cd72" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4310f49d1554474b642c8b917463ce1122a21130" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e07a9bb649f4c37cacef3f1b08b496d76e7c98" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae91e52cf25cb83ca4d281086a571771ef39b0" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing&lt;/strong&gt;, start with our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18121d1ed0c7e2f4c183167ee82f078e32e932e" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step,&lt;/strong&gt; our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt; is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won&amp;rsquo;t miss anything as you go along.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a1d7a5fd157767ed19cef5074e83cab2e2cd1f" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step&lt;/strong&gt;, start with our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a70d45458110999e3ed23edf11293a04e3c413b" translate="yes" xml:space="preserve">
          <source>If you prefer to set up your own JavaScript toolchain from scratch, &lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;check out this guide&lt;/a&gt; that re-creates some of the Create React App functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6bf88e40be3156ec3b84e97a7685d5e9ea541e" translate="yes" xml:space="preserve">
          <source>If you prefer to use your own text editor, you can also &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;download this HTML file&lt;/a&gt;, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we&amp;rsquo;d only recommend using this for simple demos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d251364ce59ed1632b03eee6d1772a843639a2d0" translate="yes" xml:space="preserve">
          <source>If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0fcad6ece9f5a091fd940a4e69d81e420608bb" translate="yes" xml:space="preserve">
          <source>If you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759d8e9c5a7a89f86b0192bac647a89f30115a0f" translate="yes" xml:space="preserve">
          <source>If you run this code and watch the console logs, you&amp;rsquo;ll notice the sequence is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5efa147e22d5f8a48f15dbde439cdd94297df3a9" translate="yes" xml:space="preserve">
          <source>If you see an error message saying &amp;ldquo;You have mistakenly installed the &lt;code&gt;babel&lt;/code&gt; package&amp;rdquo;, you might have missed &lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;the previous step&lt;/a&gt;. Perform it in the same folder, and then try again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b075833725a23cb77b5ba4dda4642dd74ec1c98a" translate="yes" xml:space="preserve">
          <source>If you see no output, it means that it completed successfully.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6e92cbb0194609294df3744170608e6c63909c" translate="yes" xml:space="preserve">
          <source>If you serve React from a CDN, we recommend to keep the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt;&lt;code&gt;crossorigin&lt;/code&gt;&lt;/a&gt; attribute set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6188f195de25803ee9e3dfbd8d8e12ea147b1a34" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;suppressHydrationWarning&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don&amp;rsquo;t overuse it. You can read more about hydration in the &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83336394d37cf4d7a5b1da0ff1854997645bf222" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, &lt;code&gt;useCallback&lt;/code&gt;, or &lt;code&gt;useImperativeHandle&lt;/code&gt;, it must include all values used inside that participate in the React data flow. That includes props, state, and anything derived from them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faccdb965000ef6d3d72692abf68f01516804384" translate="yes" xml:space="preserve">
          <source>If you try to type or check the box in the current version of the example, you&amp;rsquo;ll see that React ignores your input. This is intentional, as we&amp;rsquo;ve set the &lt;code&gt;value&lt;/code&gt; prop of the &lt;code&gt;input&lt;/code&gt; to always be equal to the &lt;code&gt;state&lt;/code&gt; passed in from &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6678ae603feef4934590c9fa76461843ca5d6683" translate="yes" xml:space="preserve">
          <source>If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56066137d55bf0e7ea681f5b1c777065f8ae4ce8" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade7aaf73be5436c90eadc8335fc3dd6aae134ed" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2699510a2c0fb7e097d079f03709fb5c277aac2f" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;react-test-renderer&lt;/code&gt;, it also provides an &lt;code&gt;act&lt;/code&gt; export that behaves the same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f17ca24abe37d1b86e8f96b92da181d93f0022e" translate="yes" xml:space="preserve">
          <source>If you use Create React App, you can &lt;strong&gt;skip the rest of this page&lt;/strong&gt;. It describes the manual setup which doesn&amp;rsquo;t apply to Create React App users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8c97699e7a184def74f6d4614cb42d1ba5dcbe" translate="yes" xml:space="preserve">
          <source>If you use React 16.2 or lower, or if you need more flexibility than provided by ref forwarding, you can use &lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;this alternative approach&lt;/a&gt; and explicitly pass a ref as a differently named prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a26f616e6ce178a355bc6c9ea84fd7cd247eb1f" translate="yes" xml:space="preserve">
          <source>If you use React 16.3 or higher, we recommend to use &lt;a href=&quot;forwarding-refs&quot;&gt;ref forwarding&lt;/a&gt; for these cases. &lt;strong&gt;Ref forwarding lets components opt into exposing any child component&amp;rsquo;s ref as their own&lt;/strong&gt;. You can find a detailed example of how to expose a child&amp;rsquo;s DOM node to a parent component &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;in the ref forwarding documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9cdf2ae438a9227b0fb23473474b484ea3d6ee" translate="yes" xml:space="preserve">
          <source>If you use React with Web Components (which is uncommon), use the &lt;code&gt;class&lt;/code&gt; attribute instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5e9d5516774b9d626ce5a38d7e13d370bfc3f7" translate="yes" xml:space="preserve">
          <source>If you use Yarn, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102d3b3dd48c9c09e36ebc5686501b3bb694fec8" translate="yes" xml:space="preserve">
          <source>If you use npm, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8118d016218e4b145cd1549aa3d71605952205a" translate="yes" xml:space="preserve">
          <source>If you use server rendering, keep in mind that &lt;em&gt;neither&lt;/em&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt; nor &lt;code&gt;useEffect&lt;/code&gt; can run until the JavaScript is downloaded. This is why React warns when a server-rendered component contains &lt;code&gt;useLayoutEffect&lt;/code&gt;. To fix this, either move that logic to &lt;code&gt;useEffect&lt;/code&gt; (if it isn&amp;rsquo;t necessary for the first render), or delay showing that component until after the client renders (if the HTML looks broken until &lt;code&gt;useLayoutEffect&lt;/code&gt; runs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f4f49dc8d98ed757f120ffbd84c5052c4128e4" translate="yes" xml:space="preserve">
          <source>If you use server-side React rendering, normally there is a warning when the server and the client render different content. However, in some rare cases, it is very hard or impossible to guarantee an exact match. For example, timestamps are expected to differ on the server and on the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4178e978ea6a519b02f6012454f8eaa90a9377" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;what to do when the array changes too often&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b64e4be8855b0be8c046942224485641c321ede" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and what to do when the &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;array values change too often&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4105f95647054b8ce2ef44647d3afb57bb52d64" translate="yes" xml:space="preserve">
          <source>If you use this shorthand form for &lt;code&gt;React.createElement&lt;/code&gt;, it can be almost as convenient to use React without JSX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2291bcdecaf7bcb60d1e8e04c1651f5828fbb6" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; for &lt;strong&gt;re-computing some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1798685fecc6fe21b1daed99365b31b3e0abf4" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a26502e1fe8a2d37c09afc69271006277d32cf" translate="yes" xml:space="preserve">
          <source>If you used classes in React before, this code should look familiar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80346a09a47643908c6e3e6ed53648965736c75" translate="yes" xml:space="preserve">
          <source>If you visit a site with React in development mode, the icon will have a red background:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d195f74ff5d044f82074fc4c274d0cab852a524" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029c59f29056b8c40cf61f9a51a8fb598e52ee51" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;re-compute some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec176e2b65d2b16278f626d01b65a2ecdb160310" translate="yes" xml:space="preserve">
          <source>If you want to access the event properties in an asynchronous way, you should call &lt;code&gt;event.persist()&lt;/code&gt; on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b47497fde239e197e47109c7ac26f42ec5315b4" translate="yes" xml:space="preserve">
          <source>If you want to allow people to take a &lt;code&gt;ref&lt;/code&gt; to your function component, you can use &lt;a href=&quot;forwarding-refs&quot;&gt;&lt;code&gt;forwardRef&lt;/code&gt;&lt;/a&gt; (possibly in conjunction with &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt;), or you can convert the component to a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9774977c9a0cf92ae57d02963964597fc3851501" translate="yes" xml:space="preserve">
          <source>If you want to extend your contrast testing abilities you can use these tools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c61cdf741239e1629cb1394fd5b25ad2e23b07e" translate="yes" xml:space="preserve">
          <source>If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c62cdf54a3c4b69e723af171e44872b6cf5229d" translate="yes" xml:space="preserve">
          <source>If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array (&lt;code&gt;[]&lt;/code&gt;) as a second argument. This tells React that your effect doesn&amp;rsquo;t depend on &lt;em&gt;any&lt;/em&gt; values from props or state, so it never needs to re-run. This isn&amp;rsquo;t handled as a special case &amp;mdash; it follows directly from how the dependencies array always works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9f5e51b60174574056d9954f4502bc83ff6681" translate="yes" xml:space="preserve">
          <source>If you want to test out how some specific JSX is converted into JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5c25e81b4c83c34080d583406db75e5fbd89cb" translate="yes" xml:space="preserve">
          <source>If you want, you can &lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;extract this logic&lt;/a&gt; into a reusable Hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399df8ef1381d54faa0cf11b65366b05a0ec37b9" translate="yes" xml:space="preserve">
          <source>If you worked with React before, you might be familiar with an older API where the &lt;code&gt;ref&lt;/code&gt; attribute is a string, like &lt;code&gt;&quot;textInput&quot;&lt;/code&gt;, and the DOM node is accessed as &lt;code&gt;this.refs.textInput&lt;/code&gt;. We advise against it because string refs have &lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;some issues&lt;/a&gt;, are considered legacy, and &lt;strong&gt;are likely to be removed in one of the future releases&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefdc0d20887310bdbbac46cc25deb537667e418" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d rather play it safe, you have a few options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e8f0a6c71e57b282d77890abf3bb605b7ee301" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re &lt;strong&gt;learning React&lt;/strong&gt; or &lt;strong&gt;creating a new &lt;a href=&quot;glossary#single-page-application&quot;&gt;single-page&lt;/a&gt; app,&lt;/strong&gt; use &lt;a href=&quot;#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c007d618e08aa59cd6a4806d7e82c16701dda7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re benchmarking or experiencing performance problems in your React apps, make sure you&amp;rsquo;re testing with the minified production build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc0f59462da1ba03fb1bccaf4af7f83c2421ae8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;component library&lt;/strong&gt; or &lt;strong&gt;integrating with an existing codebase&lt;/strong&gt;, try &lt;a href=&quot;#more-flexible-toolchains&quot;&gt;More Flexible Toolchains&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3161c887f0931683850b4ab0d55e09441cde098" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;server-rendered website with Node.js,&lt;/strong&gt; try &lt;a href=&quot;#nextjs&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fbb68fe4e24629438d31ddaa72b597eeb2cb3e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;static content-oriented website,&lt;/strong&gt; try &lt;a href=&quot;#gatsby&quot;&gt;Gatsby&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb0145636525588474f0e8276c35e496d1aac96" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from a design background, &lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;these resources&lt;/a&gt; are a great place to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b21a8327f2d695d247dab9ba4c44926f184c95d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from classes, you might be tempted to always call &lt;code&gt;useState()&lt;/code&gt; once and put all state into a single object. You can do it if you&amp;rsquo;d like. Here is an example of a component that follows the mouse movement. We keep its position and size in the local state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe478a8949bbc21442ebfd2295d514e9b9da8e6" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re curious to see more examples of how JSX is converted to JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbf14a41aa9dba4bb37c7ce0040976c3385bce3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re currently using &lt;code&gt;this.refs.textInput&lt;/code&gt; to access refs, we recommend using either the &lt;a href=&quot;#callback-refs&quot;&gt;callback pattern&lt;/a&gt; or the &lt;a href=&quot;#creating-refs&quot;&gt;&lt;code&gt;createRef&lt;/code&gt; API&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c02314892cb9a48617e7c2fdd059a92d98fef42" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with React class lifecycle methods, you can think of &lt;code&gt;useEffect&lt;/code&gt; Hook as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdbd195fffc505b9d49fae18463ec74871e0648" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with the context API before Hooks, &lt;code&gt;useContext(MyContext)&lt;/code&gt; is equivalent to &lt;code&gt;static contextType = MyContext&lt;/code&gt; in a class, or to &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cc84d56c28a1262eb498557fb996376cead69c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitch&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b478957a5f6430e0e6de7b367d98ab11dc6863ad" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re just starting a project, &lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;don&amp;rsquo;t spend more than five minutes&lt;/a&gt; on choosing a file structure. Pick any of the above approaches (or come up with your own) and start writing code! You&amp;rsquo;ll likely want to rethink it anyway after you&amp;rsquo;ve written some real code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02065c0e863b23eb9f215dd9e810ad0fbc822f45" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for a complete solution including validation, keeping track of the visited fields, and handling form submission, &lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;Formik&lt;/a&gt; is one of the popular choices. However, it is built on the same principles of controlled components and managing state &amp;mdash; so don&amp;rsquo;t neglect to learn them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4bea4c5b521a6375a592447c292171386ec893" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re migrating code from a class component, note &lt;code&gt;useLayoutEffect&lt;/code&gt; fires in the same phase as &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, &lt;strong&gt;we recommend starting with &lt;code&gt;useEffect&lt;/code&gt; first&lt;/strong&gt; and only trying &lt;code&gt;useLayoutEffect&lt;/code&gt; if that causes a problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5503753c4ba3a8933fe75a74d026956b4dbf0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to Hooks, you might want to check out &lt;a href=&quot;hooks-overview&quot;&gt;the overview&lt;/a&gt; first. You may also find useful information in the &lt;a href=&quot;hooks-faq&quot;&gt;frequently asked questions&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c7ebc6b49f6dd3625d44bdc17f0c9841de397f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not familiar with this syntax, check out the &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;explanation&lt;/a&gt; in the State Hook documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5174b478727365c84b01ba51be97ccc6bde6c829" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up Webpack yourself, you&amp;rsquo;ll probably want to read Webpack&amp;rsquo;s &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;guide on code splitting&lt;/a&gt;. Your Webpack config should look vaguely &lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;like this&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a795cf4399197efaee67030befff9eb14a55d67d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re the author of a third party React framework, library, developer tool, or similar infrastructure-type project, you can help us keep React stable for your users and the entire React community by periodically running your test suite against the most recent changes. If you&amp;rsquo;re interested, follow these steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d974a28ce0731e8c5b22ec90e221bfa58d8cf7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let&amp;rsquo;s look at a practical example to see why this design helps us create components with fewer bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e2e192cd0c1fbe3f4992433f068147160c96ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d127abe7b8ab646fe461064799810c4bc682187" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, both &lt;code&gt;Object.assign&lt;/code&gt; and the object spread syntax are available by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e78c645e20c8ca2c19f0d386c2f5955c20c8fe1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, please follow &lt;a href=&quot;#create-react-app&quot;&gt;the instructions above&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b82de6f7cc131deac549e5bef7f9e8de5d34f8d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working on a data fetching library, there&amp;rsquo;s a crucial aspect of Render-as-You-Fetch you don&amp;rsquo;t want to miss. &lt;strong&gt;We kick off fetching &lt;em&gt;before&lt;/em&gt; rendering.&lt;/strong&gt; Look at this code example closer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cc1d74837d5c0361acef0611ccd09597783f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a library that tests mostly browser-specific behavior, and requires native browser behavior like layout or real inputs, you could use a framework like &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b3ede746a1b41e135139260bd938036c1b5653" translate="yes" xml:space="preserve">
          <source>If your React component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; function renders the same result given the same props and state, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; for a performance boost in some cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae535fa4a52d95be43cd119d3dce94ee825d2ad" translate="yes" xml:space="preserve">
          <source>If your application renders long lists of data (hundreds or thousands of rows), we recommended using a technique known as &amp;ldquo;windowing&amp;rdquo;. This technique only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0415d8714549e60a664370c6ba10482c3fc92d" translate="yes" xml:space="preserve">
          <source>If your application requires pointer events, we recommend adding a third party pointer event polyfill.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2395816cffe7512d0939e7686c6115bba399430f" translate="yes" xml:space="preserve">
          <source>If your component implements the &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; lifecycle (which is rare), the value it returns will be passed as a third &amp;ldquo;snapshot&amp;rdquo; parameter to &lt;code&gt;componentDidUpdate()&lt;/code&gt;. Otherwise this parameter will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d599f1233ec4f9623c8e348df9de9e2c174bee" translate="yes" xml:space="preserve">
          <source>If your function component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b153be87230d19e0959754d7e8fdb722e18406e" translate="yes" xml:space="preserve">
          <source>If your project is built with &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f76989cbe467f747eafaee915ffd618ee7e8e9e" translate="yes" xml:space="preserve">
          <source>If your project was set up using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, congratulations! The Flow annotations are already being stripped by default so you don&amp;rsquo;t need to do anything else in this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e8d7dcd1b990fee40afd460f8d53442f4e8b92" translate="yes" xml:space="preserve">
          <source>If your update function returns the exact same value, the subsequent rerender will be skipped completely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e9082f9e460ca12ce12808ea1db2401ca59946" translate="yes" xml:space="preserve">
          <source>Image Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bbbb29751f3fd92cc08381c3226ccef034d3b1" translate="yes" xml:space="preserve">
          <source>Imagine that we already have a JSON API and a mock from our designer. The mock looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515dd2117b7986f40a9ea292c49529e087a55c0a" translate="yes" xml:space="preserve">
          <source>Imagine we&amp;rsquo;re navigating between two screens in an app. Sometimes, we might not have enough code and data loaded to show a &amp;ldquo;good enough&amp;rdquo; loading state to the user on the new screen. Transitioning to an empty screen or a large spinner can be a jarring experience. However, it&amp;rsquo;s also common that the necessary code and data doesn&amp;rsquo;t take too long to fetch. &lt;strong&gt;Wouldn&amp;rsquo;t it be nicer if React could stay on the old screen for a little longer, and &amp;ldquo;skip&amp;rdquo; the &amp;ldquo;bad loading state&amp;rdquo; before showing the new screen?&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33a303f56a6bbd06206e5ce4d8446405d3fa4f3" translate="yes" xml:space="preserve">
          <source>Importantly, custom Hooks give you the power to constrain React API if you&amp;rsquo;d like to type them more strictly in some way. React gives you the primitives, but you can combine them in different ways than what we provide out of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389fbb58f34b12bedefc8ca743f17e0f3583836d" translate="yes" xml:space="preserve">
          <source>Importantly, the way you &lt;em&gt;use&lt;/em&gt; React is the same. Concepts like components, props, and state fundamentally work the same way. When you want to update the screen, you set the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1368d43d01a36b5581bb3e9a2be050b9de12c101" translate="yes" xml:space="preserve">
          <source>In CSS, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt;&lt;code&gt;display: contents&lt;/code&gt;&lt;/a&gt; attribute can be used if you don&amp;rsquo;t want the node to be part of the layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b55e065dea1bfb41665c75fc1cc794c8f70a095" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, rendering is not blocking. It is interruptible. This improves the user experience. It also unlocks new features that weren&amp;rsquo;t possible before. Before we look at concrete examples in the &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;next&lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;chapters&lt;/a&gt;, we&amp;rsquo;ll do a high-level overview of new features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ecc95e249a2849c1eb4333865f60656c17be67b" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, the lifecycle methods &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;previously marked&lt;/a&gt; as &amp;ldquo;unsafe&amp;rdquo; actually &lt;em&gt;are&lt;/em&gt; unsafe, and lead to bugs even more than in today&amp;rsquo;s React. We don&amp;rsquo;t recommend trying Concurrent Mode until your app is &lt;a href=&quot;strict-mode&quot;&gt;Strict Mode&lt;/a&gt;-compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ea6a0b5b929f6e4d971d6001063e6cdcc606f8" translate="yes" xml:space="preserve">
          <source>In ES6 classes, you can define the initial state by assigning &lt;code&gt;this.state&lt;/code&gt; in the constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b9508d775e315d9d48d1ac6d2be46507d95cbb" translate="yes" xml:space="preserve">
          <source>In HTML, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; creates a drop-down list. For example, this HTML creates a drop-down list of flavors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6260ccb22bfbbde7ec537c88316f474366bfa99b" translate="yes" xml:space="preserve">
          <source>In HTML, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; element defines its text by its children:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee26a6db634e40e4019da1e44bc2fa5e8708d30" translate="yes" xml:space="preserve">
          <source>In HTML, an &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; lets the user choose one or more files from their device storage to be uploaded to a server or manipulated by JavaScript via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd8882487752794b9ff3cba07ccbd1e6347dd57" translate="yes" xml:space="preserve">
          <source>In HTML, form elements such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with &lt;a href=&quot;react-component#setstate&quot;&gt;&lt;code&gt;setState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451fb8c93e5b83ed15cecd30a84768222971358c" translate="yes" xml:space="preserve">
          <source>In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: &lt;code&gt;props.children&lt;/code&gt;. There are several different ways to pass children:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b47b7c0e900bd9fddd8dd976d3fa0c74ee40520" translate="yes" xml:space="preserve">
          <source>In JavaScript, these two code snippets are &lt;strong&gt;not&lt;/strong&gt; equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896c4ff0b7dad9168327f4c2b1e69fd7b821d242" translate="yes" xml:space="preserve">
          <source>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b509261276a2c24087d4a53dfcbb229d41ff110f" translate="yes" xml:space="preserve">
          <source>In React class components, the &lt;code&gt;render&lt;/code&gt; method itself shouldn&amp;rsquo;t cause side effects. It would be too early &amp;mdash; we typically want to perform our effects &lt;em&gt;after&lt;/em&gt; React has updated the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea30c1cddacc5c2fb8659ad8a3ea7724439494a" translate="yes" xml:space="preserve">
          <source>In React components declared as ES6 classes, methods follow the same semantics as regular ES6 classes. This means that they don&amp;rsquo;t automatically bind &lt;code&gt;this&lt;/code&gt; to the instance. You&amp;rsquo;ll have to explicitly use &lt;code&gt;.bind(this)&lt;/code&gt; in the constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538221c0cbcf54504c0c303253382099a46a923b" translate="yes" xml:space="preserve">
          <source>In React, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; uses a &lt;code&gt;value&lt;/code&gt; attribute instead. This way, a form using a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; can be written very similarly to a form that uses a single-line input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9a3a5e0ceac65aab6602bc1dbe2fe9e493d0fe" translate="yes" xml:space="preserve">
          <source>In React, all DOM properties and attributes (including event handlers) should be camelCased. For example, the HTML attribute &lt;code&gt;tabindex&lt;/code&gt; corresponds to the attribute &lt;code&gt;tabIndex&lt;/code&gt; in React. The exception is &lt;code&gt;aria-*&lt;/code&gt; and &lt;code&gt;data-*&lt;/code&gt; attributes, which should be lowercased. For example, you can keep &lt;code&gt;aria-label&lt;/code&gt; as &lt;code&gt;aria-label&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c511871e368bc7af53ec2e81d4fb957978f940e" translate="yes" xml:space="preserve">
          <source>In React, an &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; is always an uncontrolled component because its value can only be set by a user, and not programmatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7fa02f2469625e763a13cd5609a01cda7c6c08" translate="yes" xml:space="preserve">
          <source>In React, both &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; represent the &lt;em&gt;rendered&lt;/em&gt; values, i.e. what&amp;rsquo;s currently on the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14047f4f0476e66fe99901264ae249589cef260" translate="yes" xml:space="preserve">
          <source>In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called &amp;ldquo;lifting state up&amp;rdquo;. We will remove the local state from the &lt;code&gt;TemperatureInput&lt;/code&gt; and move it into the &lt;code&gt;Calculator&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a53b8bc22280c0c555667af9e91fb2d02153f1e" translate="yes" xml:space="preserve">
          <source>In React, this could instead be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410126e91330d77043a8e4cf7862f0a183679992" translate="yes" xml:space="preserve">
          <source>In React, this is also achieved by composition, where a more &amp;ldquo;specific&amp;rdquo; component renders a more &amp;ldquo;generic&amp;rdquo; one and configures it with props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f50da8ee138f52d6b59eebfb1b47338f96dd4b5" translate="yes" xml:space="preserve">
          <source>In React, this is usually solved by making a component &amp;ldquo;controlled&amp;rdquo;. Just like the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; accepts both a &lt;code&gt;value&lt;/code&gt; and an &lt;code&gt;onChange&lt;/code&gt; prop, so can the custom &lt;code&gt;TemperatureInput&lt;/code&gt; accept both &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;onTemperatureChange&lt;/code&gt; props from its parent &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87275e536b566529b077b0ff131cc019d2d910ed" translate="yes" xml:space="preserve">
          <source>In React, transforming arrays into lists of &lt;a href=&quot;rendering-elements&quot;&gt;elements&lt;/a&gt; is nearly identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e0e1f0e9359d0e312a435e081792d0bfb666a7" translate="yes" xml:space="preserve">
          <source>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18d05ee6185a8ba49d29302bd632b76aa474a54" translate="yes" xml:space="preserve">
          <source>In React, you most likely write your components in a &lt;code&gt;.js&lt;/code&gt; file. In TypeScript we have 2 file extensions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f15ab1b0e75d6b53c4958487bbf30fca20cdcdd" translate="yes" xml:space="preserve">
          <source>In a React class, you would typically set up a subscription in &lt;code&gt;componentDidMount&lt;/code&gt;, and clean it up in &lt;code&gt;componentWillUnmount&lt;/code&gt;. For example, let&amp;rsquo;s say we have a &lt;code&gt;ChatAPI&lt;/code&gt; module that lets us subscribe to a friend&amp;rsquo;s online status. Here&amp;rsquo;s how we might subscribe and display that status using a class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae59876c3b29c0877309b94f02f1bd1dffc61a49" translate="yes" xml:space="preserve">
          <source>In a class component, we would need to add &lt;code&gt;componentDidUpdate&lt;/code&gt; to handle this case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c2ff44f620f5f28854f62d80affff3a499ba93" translate="yes" xml:space="preserve">
          <source>In a class, we initialize the &lt;code&gt;count&lt;/code&gt; state to &lt;code&gt;0&lt;/code&gt; by setting &lt;code&gt;this.state&lt;/code&gt; to &lt;code&gt;{ count: 0 }&lt;/code&gt; in the constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f976be121765c87a20b8cbb91d05fe0f6e68773" translate="yes" xml:space="preserve">
          <source>In a class, we need to call &lt;code&gt;this.setState()&lt;/code&gt; to update the &lt;code&gt;count&lt;/code&gt; state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f4e9921f51af97e4b657670a6fd71ed33571b6" translate="yes" xml:space="preserve">
          <source>In a function component, we have no &lt;code&gt;this&lt;/code&gt;, so we can&amp;rsquo;t assign or read &lt;code&gt;this.state&lt;/code&gt;. Instead, we call the &lt;code&gt;useState&lt;/code&gt; Hook directly inside our component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02a6361f2d8d56c63358f0ea5c054c54d590ac2" translate="yes" xml:space="preserve">
          <source>In a function, we already have &lt;code&gt;setCount&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; as variables so we don&amp;rsquo;t need &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8baa32bfe1b6970407832863578c772af74c5714" translate="yes" xml:space="preserve">
          <source>In a function, we can use &lt;code&gt;count&lt;/code&gt; directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e453bfad87294cd830086d87833eed893f7ed85e" translate="yes" xml:space="preserve">
          <source>In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e54856b0d6dda52097e2ff1d03dbed8218a984" translate="yes" xml:space="preserve">
          <source>In addition to making code reuse and code organization more difficult, we&amp;rsquo;ve found that classes can be a large barrier to learning React. You have to understand how &lt;code&gt;this&lt;/code&gt; works in JavaScript, which is very different from how it works in most languages. You have to remember to bind the event handlers. Without unstable &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;syntax proposals&lt;/a&gt;, the code is very verbose. People can understand props, state, and top-down data flow perfectly well but still struggle with classes. The distinction between function and class components in React and when to use each one leads to disagreements even between experienced React developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289e0d186dd0eceb3a53aed219c7fedfcae512fa" translate="yes" xml:space="preserve">
          <source>In addition, consider that the design of Hooks is more efficient in a couple ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf07c2cb1d9764411791f25d366167bf2c6a4a7d" translate="yes" xml:space="preserve">
          <source>In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt;&lt;code&gt;@testing-library/react-native&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd08e59d935cb13b1f6c01dc28056496f6a9bc4e" translate="yes" xml:space="preserve">
          <source>In applications with many components, it&amp;rsquo;s very important to free up resources taken by the components when they are destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b767eadf5b4139629873d3d67b44c49dd15f7ed" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;e&lt;/code&gt; argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with &lt;code&gt;bind&lt;/code&gt; any further arguments are automatically forwarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1802f47fc0c94f1304e39a33f567229bc6a0fe9" translate="yes" xml:space="preserve">
          <source>In cases where you cannot define the prop statically (e.g. because you need to close over the component&amp;rsquo;s props and/or state) &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; should extend &lt;code&gt;React.Component&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09f5ea2f719cb84240d22955b912b59e89f6fc3" translate="yes" xml:space="preserve">
          <source>In contrast, this function is impure because it changes its own input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9a0d3186492384944825ac9b7292279498c6fb" translate="yes" xml:space="preserve">
          <source>In depth: When and why are &lt;code&gt;setState()&lt;/code&gt; calls batched?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28fdfcba350e9460a5b11538d17a9495f7864ad" translate="yes" xml:space="preserve">
          <source>In depth: Why isn&amp;rsquo;t &lt;code&gt;this.state&lt;/code&gt; updated immediately?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b95b07888beb397c1c34cba846e81f89eafcbe" translate="yes" xml:space="preserve">
          <source>In either case, we &lt;strong&gt;don&amp;rsquo;t recommend this pattern&lt;/strong&gt; and only show it here for completeness. Instead, it is preferable to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;avoid passing callbacks deep down&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d91c5022448dc96b7db04173ff7b2483babe71" translate="yes" xml:space="preserve">
          <source>In fact, if we open the console, we&amp;rsquo;ll see a warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f345dbdd77bde7a2de6d314ebebbeb5d11132d71" translate="yes" xml:space="preserve">
          <source>In fact, this is exactly how React is used at Facebook. This lets us write applications in React piece by piece, and combine them with our existing server-generated templates and other client-side code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdfd80e389f7e74a49541704e05ae80cc6fc69b" translate="yes" xml:space="preserve">
          <source>In general, we &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; bump the major version number for changes to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee266aeffd83dee46d08b5a2d9e5dd0db59bd0ba" translate="yes" xml:space="preserve">
          <source>In general, we don&amp;rsquo;t recommend using this because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt;&lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt;. This behavior is just there so that it matches the behavior of HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1a71609500b2f5f9daba332366828dbac63210" translate="yes" xml:space="preserve">
          <source>In large component trees, an alternative we recommend is to pass down a &lt;code&gt;dispatch&lt;/code&gt; function from &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; via context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba93ca3416f3cbfccc68a69a219fb2048e2dc7a7" translate="yes" xml:space="preserve">
          <source>In many cases it&amp;rsquo;s not possible to break these components into smaller ones because the stateful logic is all over the place. It&amp;rsquo;s also difficult to test them. This is one of the reasons many people prefer to combine React with a separate state management library. However, that often introduces too much abstraction, requires you to jump between different files, and makes reusing components more difficult.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3440d610e4a5c2ec2cdeed99640aaa90c65f21a" translate="yes" xml:space="preserve">
          <source>In more complex cases (such as if one state depends on another state), try moving the state update logic outside the effect with the &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt; Hook&lt;/a&gt;. &lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;This article&lt;/a&gt; offers an example of how you can do this. &lt;strong&gt;The identity of the &lt;code&gt;dispatch&lt;/code&gt; function from &lt;code&gt;useReducer&lt;/code&gt; is always stable&lt;/strong&gt; &amp;mdash; even if the reducer function is declared inside the component and reads its props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3661ac2ed158cad82144227101fb280362b435" translate="yes" xml:space="preserve">
          <source>In most cases you should use controlled components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7abdefe6c187e6dc04e0d7f5c214840047bcdd" translate="yes" xml:space="preserve">
          <source>In most cases, instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand, you can inherit from &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt;. It is equivalent to implementing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; with a shallow comparison of current and previous props and state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbad587d21c37cda62d8252410ab69d53dfcaebf" translate="yes" xml:space="preserve">
          <source>In most cases, jsdom behaves like a regular browser would, but doesn&amp;rsquo;t have features like &lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;layout and navigation&lt;/a&gt;. This is still useful for most web-based component tests, since it runs quicker than having to start up a browser for each test. It also runs in the same process as your tests, so you can write code to examine and assert on the rendered DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1911017bb2356e24f2e7725ec8dd38cb5980645a" translate="yes" xml:space="preserve">
          <source>In most cases, we recommend using &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled components&lt;/a&gt; to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3c1b36b4f10f7bf6d14d76f2b5886538fe9af9" translate="yes" xml:space="preserve">
          <source>In order to solve this issue, React supports a &lt;code&gt;key&lt;/code&gt; attribute. When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. For example, adding a &lt;code&gt;key&lt;/code&gt; to our inefficient example above can make the tree conversion efficient:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6804b7a0eea45b9845222ba70ab59b4cf0b8e7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;connect&lt;/code&gt; is a higher-order function that returns a higher-order component!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f812104a6e940fb1554b3b0a149eca257b5c85" translate="yes" xml:space="preserve">
          <source>In our example, we already have two state variables. The input text is in &lt;code&gt;query&lt;/code&gt;, and we read the translation from &lt;code&gt;resource&lt;/code&gt;. We want changes to the &lt;code&gt;query&lt;/code&gt; state to happen immediately, but changes to the &lt;code&gt;resource&lt;/code&gt; (i.e. fetching a new translation) should trigger a transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e399b2e569c6a0bcf071e62ad256ed5a3d201d7" translate="yes" xml:space="preserve">
          <source>In our experience, code that uses idiomatic React patterns and doesn&amp;rsquo;t rely on external state management solutions is the easiest to get running in the Concurrent Mode. We will describe common problems we&amp;rsquo;ve seen and the solutions to them separately in the coming weeks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a945c86c779350192d3215abb4afd0b7e2b4ebf" translate="yes" xml:space="preserve">
          <source>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d3facfdb5b3a33c51c1e47e735a86dc335c375" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;this.props.children&lt;/code&gt; is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff52786b96cb28b8516c4c77d035f3f94ffa6e3e" translate="yes" xml:space="preserve">
          <source>In particular, the rule enforces that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d696f2b7ef6c0b071645ffc121cc67457984603" translate="yes" xml:space="preserve">
          <source>In practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade1231470ce955a57c66a5a4a65595e2c307122" translate="yes" xml:space="preserve">
          <source>In practice, most React apps only call &lt;code&gt;ReactDOM.render()&lt;/code&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909459ee6d5f8fcf3afdeb0255be50e086b6e528" translate="yes" xml:space="preserve">
          <source>In practice, these assumptions are valid for almost all practical use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0b8aeba59f064eef6dc0b26b57e2face696137" translate="yes" xml:space="preserve">
          <source>In practice, we expect that most apps using Legacy Mode today should be able to migrate at least to the Blocking Mode (if not Concurrent Mode). This fragmentation can be annoying for libraries that aim to support all Modes in the short term. However, gradually moving the ecosystem away from the Legacy Mode will also &lt;em&gt;solve&lt;/em&gt; problems that affect major libraries in the React ecosystem, such as &lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;confusing Suspense behavior when reading layout&lt;/a&gt; and &lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;lack of consistent batching guarantees&lt;/a&gt;. There&amp;rsquo;s a number of bugs that can&amp;rsquo;t be fixed in Legacy Mode without changing semantics, but don&amp;rsquo;t exist in Blocking and Concurrent Modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b279656dca3be237f10a8565147d5f390d7e94e" translate="yes" xml:space="preserve">
          <source>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return &lt;code&gt;null&lt;/code&gt; instead of its render output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a098d464d31796bcdd791f834a68bda2df286c2" translate="yes" xml:space="preserve">
          <source>In rare cases, you may be running a test on a component that uses multiple renderers. For example, you may be running snapshot tests on a component with &lt;code&gt;react-test-renderer&lt;/code&gt;, that internally uses &lt;code&gt;ReactDOM.render&lt;/code&gt; inside a child component to render some content. In this scenario, you can wrap updates with &lt;code&gt;act()&lt;/code&gt;s corresponding to their renderers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d050c85bc701c68bd6d50bf673ea61647fdec4" translate="yes" xml:space="preserve">
          <source>In rare cases, you might want to have access to a child&amp;rsquo;s DOM node from a parent component. This is generally not recommended because it breaks component encapsulation, but it can occasionally be useful for triggering focus or measuring the size or position of a child DOM node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6863ffdd3d1c41a019b99c0ce9ef587c06e42de" translate="yes" xml:space="preserve">
          <source>In some browsers we can easily view the accessibility information for each element in the accessibility tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7f108e140b39155a7e18cc38167a7857627734" translate="yes" xml:space="preserve">
          <source>In some cases formatting a value for display might be an expensive operation. It&amp;rsquo;s also unnecessary unless a Hook is actually inspected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abfe23fc439cd1390e394329a6ecb1eeec14f4b5" translate="yes" xml:space="preserve">
          <source>In some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with &lt;code&gt;prevProps&lt;/code&gt; or &lt;code&gt;prevState&lt;/code&gt; inside &lt;code&gt;componentDidUpdate&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110ae94bd79008897c0972ade096014f8e0302a9" translate="yes" xml:space="preserve">
          <source>In some rare cases you might need to memoize a callback with &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; but the memoization doesn&amp;rsquo;t work very well because the inner function has to be re-created too often. If the function you&amp;rsquo;re memoizing is an event handler and isn&amp;rsquo;t used during rendering, you can use &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref as an instance variable&lt;/a&gt;, and save the last committed value into it manually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1cdbd6853a083ca4623e0db98a09dc4da4738b" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;development&lt;/strong&gt; mode, you can visualize how components mount, update, and unmount, using the performance tools in supported browsers. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b550316b6eedb96eacfc072502ecdd2917564a" translate="yes" xml:space="preserve">
          <source>In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903bb48f1156a6b0ac31b18a1cbe3d5dc1be1cc3" translate="yes" xml:space="preserve">
          <source>In the above component, we have &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;fruit&lt;/code&gt;, and &lt;code&gt;todos&lt;/code&gt; as local variables, and we can update them individually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1e3bc1269742bd242168387646a23702e59a34" translate="yes" xml:space="preserve">
          <source>In the above example, React passes a &lt;code&gt;ref&lt;/code&gt; given to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; element as a second argument to the rendering function inside the &lt;code&gt;React.forwardRef&lt;/code&gt; call. This rendering function passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb9604592cfa6b12895f257ac0c24ea334d72d8" translate="yes" xml:space="preserve">
          <source>In the above example, strict mode checks will &lt;em&gt;not&lt;/em&gt; be run against the &lt;code&gt;Header&lt;/code&gt; and &lt;code&gt;Footer&lt;/code&gt; components. However, &lt;code&gt;ComponentOne&lt;/code&gt; and &lt;code&gt;ComponentTwo&lt;/code&gt;, as well as all of their descendants, will have the checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161b69b6d458031682de9bd001c8a47eb9f053a9" translate="yes" xml:space="preserve">
          <source>In the above examples, it is important to read the &lt;code&gt;scrollHeight&lt;/code&gt; property in &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; because there may be delays between &amp;ldquo;render&amp;rdquo; phase lifecycles (like &lt;code&gt;render&lt;/code&gt;) and &amp;ldquo;commit&amp;rdquo; phase lifecycles (like &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1492c41f81989404e70e8f6aae15b755c6639ac" translate="yes" xml:space="preserve">
          <source>In the beginning, our stated goal was to remove the duplicated logic from the &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt; components. Both of them want to know whether a friend is online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c894c3353cd13202ba9261426d4b8ea1935aef6a" translate="yes" xml:space="preserve">
          <source>In the cron job, update your React packages to the most recent React release in the Next channel, using &lt;code&gt;next&lt;/code&gt; tag on npm. Using the npm cli:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe2f07417c38339db698cf1646bb4c866463cd8" translate="yes" xml:space="preserve">
          <source>In the event of an error, you can render a fallback UI with &lt;code&gt;componentDidCatch()&lt;/code&gt; by calling &lt;code&gt;setState&lt;/code&gt;, but this will be deprecated in a future release. Use &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; to handle fallback rendering instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bc674a950124866a089232847d2007a365dc48" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;Parent&lt;/code&gt; passes its ref callback as an &lt;code&gt;inputRef&lt;/code&gt; prop to the &lt;code&gt;CustomTextInput&lt;/code&gt;, and the &lt;code&gt;CustomTextInput&lt;/code&gt; passes the same function as a special &lt;code&gt;ref&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. As a result, &lt;code&gt;this.inputElement&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt; will be set to the DOM node corresponding to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element in the &lt;code&gt;CustomTextInput&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bb563116bb5963983d968cb91e61df5f00f963" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;kind&lt;/code&gt; prop is safely consumed and &lt;em&gt;is not&lt;/em&gt; passed on to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element in the DOM. All other props are passed via the &lt;code&gt;...other&lt;/code&gt; object making this component really flexible. You can see that it passes an &lt;code&gt;onClick&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c03112f0e316b498156bed257c2771954012e9" translate="yes" xml:space="preserve">
          <source>In the example above, we pass &lt;code&gt;[count]&lt;/code&gt; as the second argument. What does this mean? If the &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;5&lt;/code&gt;, and then our component re-renders with &lt;code&gt;count&lt;/code&gt; still equal to &lt;code&gt;5&lt;/code&gt;, React will compare &lt;code&gt;[5]&lt;/code&gt; from the previous render and &lt;code&gt;[5]&lt;/code&gt; from the next render. Because all items in the array are the same (&lt;code&gt;5 === 5&lt;/code&gt;), React would skip the effect. That&amp;rsquo;s our optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7c3d10a47d45d9cf31357af92cb4eff75e31bc3" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;FancyButton&lt;/code&gt; uses &lt;code&gt;React.forwardRef&lt;/code&gt; to obtain the &lt;code&gt;ref&lt;/code&gt; passed to it, and then forward it to the DOM &lt;code&gt;button&lt;/code&gt; that it renders:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da172bb676090bc853f066f60868863ede80ccc2" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; is rendered depending on the value of the prop called &lt;code&gt;warn&lt;/code&gt;. If the value of the prop is &lt;code&gt;false&lt;/code&gt;, then the component does not render:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9b0d091cbcaeb26aef58746ea16d7326d16599" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;List&lt;/code&gt; component renders a Backbone collection, using the &lt;code&gt;Item&lt;/code&gt; component to render individual items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132775b1447feeefec74e2f18536a9d528215b18" translate="yes" xml:space="preserve">
          <source>In the example below, we declare a variable called &lt;code&gt;name&lt;/code&gt; and then use it inside JSX by wrapping it in curly braces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7dd67cb57a4dc9f027ea3f3b201e027d6f0cf20" translate="yes" xml:space="preserve">
          <source>In the example below, we embed the result of calling a JavaScript function, &lt;code&gt;formatName(user)&lt;/code&gt;, into an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50a991765ef6cc4009766a397d70d227449d563" translate="yes" xml:space="preserve">
          <source>In the example below, we use it to conditionally render a small block of text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bfcd8d3b96478cd697022392b9e4b2c38089ff" translate="yes" xml:space="preserve">
          <source>In the example below, we will create a &lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;stateful component&lt;/a&gt; called &lt;code&gt;LoginControl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b92032c1bbddab0648c95b3163a2986b7e77271" translate="yes" xml:space="preserve">
          <source>In the example below, we will make a copy of the model&amp;rsquo;s attributes to form the initial state. We subscribe to the &lt;code&gt;change&lt;/code&gt; event (and unsubscribe on unmounting), and when it happens, we update the state with the model&amp;rsquo;s current attributes. Finally, we make sure that if the &lt;code&gt;model&lt;/code&gt; prop itself changes, we don&amp;rsquo;t forget to unsubscribe from the old model, and subscribe to the new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63df20cb3c0206857b6eb72aa649ffbe4eec47b7" translate="yes" xml:space="preserve">
          <source>In the examples above we declared a separate &lt;code&gt;listItems&lt;/code&gt; variable and included it in JSX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee218035757e1dcb006cf4b284261900739df97e" translate="yes" xml:space="preserve">
          <source>In the examples above, we only relied on features that are natively supported by the browsers. This is why we used a JavaScript function call to tell React what to display:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4709b211731b0d98acf24cd2d4b4c0e25f437be" translate="yes" xml:space="preserve">
          <source>In the future, the second argument might get added automatically by a build-time transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be1cdda076b922dcae71dadf71ff42ad65b19bd" translate="yes" xml:space="preserve">
          <source>In the long term, we intend Suspense to become the primary way to read asynchronous data from components &amp;mdash; no matter where that data is coming from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067bfddcfac5a573b68db915d05c5417e983d5ef" translate="yes" xml:space="preserve">
          <source>In the past, JavaScript errors inside components used to corrupt React&amp;rsquo;s internal state and cause it to &lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;emit&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;cryptic&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;errors&lt;/a&gt; on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1757c6b2b83b26c148e1fe2455fe52c634722f" translate="yes" xml:space="preserve">
          <source>In the previous Suspense example, we only had one &lt;code&gt;resource&lt;/code&gt;, so we held it in a top-level variable. Now that we have multiple resources, we moved it to the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt;&amp;rsquo;s component state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb97b6fdd583b9cf2c6eeadfbb049b439293e48" translate="yes" xml:space="preserve">
          <source>In the previous approach, we fetched data before we called &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0baea048f9023ac78378921b5cbb9d00932c292" translate="yes" xml:space="preserve">
          <source>In the typical React dataflow, &lt;a href=&quot;components-and-props&quot;&gt;props&lt;/a&gt; are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86357d07cf0dbd879f2bd26a66e1afff5014629" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;shouldComponentUpdate&lt;/code&gt; is just checking if there is any change in &lt;code&gt;props.color&lt;/code&gt; or &lt;code&gt;state.count&lt;/code&gt;. If those values don&amp;rsquo;t change, the component doesn&amp;rsquo;t update. If your component got more complex, you could use a similar pattern of doing a &amp;ldquo;shallow comparison&amp;rdquo; between all the fields of &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; to determine if the component should update. This pattern is common enough that React provides a helper to use this logic - just inherit from &lt;code&gt;React.PureComponent&lt;/code&gt;. So this code is a simpler way to achieve the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baf7530f7f1f0cc2de7e8a95550b370cd39a79c" translate="yes" xml:space="preserve">
          <source>In this code, we&amp;rsquo;ve wrapped our data fetching with &lt;code&gt;startTransition&lt;/code&gt;. This allows us to start fetching the profile data right away, while deferring the render of the next profile page and its associated &lt;code&gt;Spinner&lt;/code&gt; for 2 seconds (the time shown in &lt;code&gt;timeoutMs&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37905846a8f4c106d186eeaf752c69ecc60a20e" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why higher-order components are useful, and how to write your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf9764d5b2c9095bb5b4589f2f63cafc22cfd01" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why render props are useful, and how to write your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600a8bed687912f2e4672cb1492ee6559ff93168" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; waits for both requests but starts them in parallel:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9098805d0375365763e9b4152ec3e31f62f1c1a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;ProfileDetails&lt;/code&gt; is waiting for an asynchronous API call to fetch some data. While we wait for &lt;code&gt;ProfileDetails&lt;/code&gt; and &lt;code&gt;ProfilePhoto&lt;/code&gt;, we will show the &lt;code&gt;Loading...&lt;/code&gt; fallback instead. It is important to note that until all children inside &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; has loaded, we will continue to show the fallback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782491ad80c95f67dcb2debb7f87f060c15672be" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;every item in &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; has an artificial slowdown &amp;mdash; each of them blocks the thread for a few milliseconds&lt;/strong&gt;. We&amp;rsquo;d never do this in a real app, but this helps us simulate what can happen in a deep component tree with no single obvious place to optimize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e713cd57d3c728babeb0c18ce780cd3201c1805" translate="yes" xml:space="preserve">
          <source>In this example, React would unsubscribe from our &lt;code&gt;ChatAPI&lt;/code&gt; when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there&amp;rsquo;s a way to &lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;tell React to skip re-subscribing&lt;/a&gt; if the &lt;code&gt;props.friend.id&lt;/code&gt; we passed to &lt;code&gt;ChatAPI&lt;/code&gt; didn&amp;rsquo;t change.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0484ff678e7e7fe151098cbd0937ebbd00eb82" translate="yes" xml:space="preserve">
          <source>In this example, a parent component that renders &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; would be able to call &lt;code&gt;inputRef.current.focus()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4bb4e68cbd0c4ac7dd0c4d7a725bdc64841434" translate="yes" xml:space="preserve">
          <source>In this example, each time &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; renders, it generates a new function as the value of the &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; prop, thus negating the effect of &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; extending &lt;code&gt;React.PureComponent&lt;/code&gt; in the first place!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a67a59e557a8bb22da36c7b17ee44b1abf8d495" translate="yes" xml:space="preserve">
          <source>In this example, the callback ref will be called only when the component mounts and unmounts, since the rendered &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; component stays present throughout any rerenders. If you want to be notified any time a component resizes, you may want to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt;&lt;code&gt;ResizeObserver&lt;/code&gt;&lt;/a&gt; or a third-party Hook built on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55f1824db5d408d73e18ba03a5505618f145cbb" translate="yes" xml:space="preserve">
          <source>In this example, we manually thread through a &lt;code&gt;color&lt;/code&gt; prop in order to style the &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;Message&lt;/code&gt; components appropriately. Using context, we can pass this through the tree automatically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d3462a96fdf5b6668c86137312037ef5107ef1" translate="yes" xml:space="preserve">
          <source>In this example, we render a component and format the rendered HTML with the &lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/a&gt; package, before saving it as an inline snapshot:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a678be6ef80893f4443dae3189e07dc9af8576" translate="yes" xml:space="preserve">
          <source>In this example, we start data fetching at the load &lt;em&gt;and&lt;/em&gt; every time you press &amp;ldquo;Refresh&amp;rdquo;. We put the result of calling &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; into state so that components below can start reading the new data from the request we just kicked off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e5ce9d2c277949ff6850c2e07a7ce4249ad65e" translate="yes" xml:space="preserve">
          <source>In this example, we started our journey on the &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be16ebf22fd30a0569861e07662b2e8b026b4f83" translate="yes" xml:space="preserve">
          <source>In this guide, we will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d2198505214dcf8ceed2b4c9ee7adaedd5197b" translate="yes" xml:space="preserve">
          <source>In this scenario, you would use a framework like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt; or a library like &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; so you can navigate between multiple routes and assert on side effects not just in the browser, but potentially on the backend as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012fec99829ecc46c7a061a559b55cea20db4530" translate="yes" xml:space="preserve">
          <source>In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2354bfe7189104f2d54a127296a8b8ac4cb54d00" translate="yes" xml:space="preserve">
          <source>In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d7bcb20d79f9f405dc2a045c7b8717d8f1c228" translate="yes" xml:space="preserve">
          <source>In this section, we will learn how to make the &lt;code&gt;Clock&lt;/code&gt; component truly reusable and encapsulated. It will set up its own timer and update itself every second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce38739a991553b55a16fa00b7561acd9e3c69cd" translate="yes" xml:space="preserve">
          <source>In this section, we will show how to add a React component to an existing HTML page. You can follow along with your own website, or create an empty HTML file to practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c457ca26e31df4ff72bf75e4781f7e68170aaedf" translate="yes" xml:space="preserve">
          <source>In those rare cases where you need to apply a HOC dynamically, you can also do it inside a component&amp;rsquo;s lifecycle methods or its constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e74adf3229ab63477c62be5d7146a7e849046e" translate="yes" xml:space="preserve">
          <source>Inclusive Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1042f8600a94d974b83e4d369aaa4b17edb453b8" translate="yes" xml:space="preserve">
          <source>Indicate the human language of page texts as screen reader software uses this to select the correct voice settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a578fd2622c2582fc0bfccfa222e7fbdccd773" translate="yes" xml:space="preserve">
          <source>Initializing &lt;a href=&quot;state-and-lifecycle&quot;&gt;local state&lt;/a&gt; by assigning an object to &lt;code&gt;this.state&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308f934b533308c752b10e77267068798d66f567" translate="yes" xml:space="preserve">
          <source>Inline If with Logical &amp;amp;&amp;amp; Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9001f5844d8678a32c2945ed8a6fb7c63e0e2f" translate="yes" xml:space="preserve">
          <source>Inline If-Else with Conditional Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66528a87a38e1e59da8d23434a47ffa479d5a4ba" translate="yes" xml:space="preserve">
          <source>Inside a loop, it is common to want to pass an extra parameter to an event handler. For example, if &lt;code&gt;id&lt;/code&gt; is the row ID, either of the following would work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4304c63954bdc246b29ab78b7a7b6fb0356bca4f" translate="yes" xml:space="preserve">
          <source>Inside the listener, call &lt;code&gt;setState&lt;/code&gt; whenever the data source changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da0532bc1d42056af8f38805b51309a604715c0" translate="yes" xml:space="preserve">
          <source>Inside these methods, the &lt;code&gt;Calculator&lt;/code&gt; component asks React to re-render itself by calling &lt;code&gt;this.setState()&lt;/code&gt; with the new input value and the current scale of the input we just edited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b9166fcdb7337cee3b47f14be3169cc82acd61" translate="yes" xml:space="preserve">
          <source>Instead of artificially separating &lt;em&gt;technologies&lt;/em&gt; by putting markup and logic in separate files, React &lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separates &lt;em&gt;concerns&lt;/em&gt;&lt;/a&gt; with loosely coupled units called &amp;ldquo;components&amp;rdquo; that contain both. We will come back to components in a &lt;a href=&quot;components-and-props&quot;&gt;further section&lt;/a&gt;, but if you&amp;rsquo;re not yet comfortable putting markup in JS, &lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;this talk&lt;/a&gt; might convince you otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d025bac2dca752df204440cbc1297998e47df835" translate="yes" xml:space="preserve">
          <source>Instead of calling real APIs in all your tests, you can mock requests with dummy data. Mocking data fetching with &amp;ldquo;fake&amp;rdquo; data prevents flaky tests due to an unavailable backend, and makes them run faster. Note: you may still want to run a subset of tests using an &lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;&amp;ldquo;end-to-end&amp;rdquo;&lt;/a&gt; framework that tells whether the whole app is working together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df48b0f4d5bf5819b9914fd6531ebe1dc8a79973" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;useTransition&lt;/code&gt; in every other component, we can build it into our design system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aded08fa023761e3f1e6e5311a0cc3ddf79baf0" translate="yes" xml:space="preserve">
          <source>Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf9d7c83880386192ebfbb360c2c6812d8bcf20" translate="yes" xml:space="preserve">
          <source>Instead of passing a &lt;code&gt;ref&lt;/code&gt; attribute created by &lt;code&gt;createRef()&lt;/code&gt;, you pass a function. The function receives the React component instance or HTML DOM element as its argument, which can be stored and accessed elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c04ebdd8624a1412a2c00e3ee3be737187bc902" translate="yes" xml:space="preserve">
          <source>Instead of showing a spinner, can we add a visual effect like &amp;ldquo;greying out&amp;rdquo; the current screen?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c51eb3d5154be37011a4c79e90fdae3d688bfd" translate="yes" xml:space="preserve">
          <source>Instead, &lt;em&gt;pass the function itself&lt;/em&gt; (without parens):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf33354387d8bc0b95b73e1b637b872d08038c4" translate="yes" xml:space="preserve">
          <source>Instead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14487f72778797d41aa4fbaf38ed77b989f65799" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;setState()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441f654229a4276797437835009f1f108efbc02d" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;useEffect&lt;/code&gt;. The function passed to &lt;code&gt;useEffect&lt;/code&gt; will run after the render is committed to the screen. Think of effects as an escape hatch from React&amp;rsquo;s purely functional world into the imperative world.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5c222edd3cc915db386166adcd08d3c4524ced" translate="yes" xml:space="preserve">
          <source>Instead, we release new features in minor versions. That means that minor releases are often more interesting and compelling than majors, despite their unassuming name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cad89ab27a31a43bc8bcabb4f1530a63711b236" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;d like to share this logic between &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc56bd7b51ec191a2b44a72405da8bdc2c8e271" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll look at Suspense as a logical next step in a sequence of approaches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e78cabfede8d071dad68a99417a1db55165ae4" translate="yes" xml:space="preserve">
          <source>Integrating with DOM Manipulation Plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabcdcb5781cef22218fde185dcc3275b3caf232" translate="yes" xml:space="preserve">
          <source>Integrating with Model Layers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abfc3b773acf5210e59c6612eeb838ec30c6daf" translate="yes" xml:space="preserve">
          <source>Integrating with Other Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323ce191323fe812d9b2285405712a7540e602ee" translate="yes" xml:space="preserve">
          <source>Integrating with Other View Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ead22e923dd75533f31fb755b0096e8335cf4b" translate="yes" xml:space="preserve">
          <source>Integrating with jQuery Chosen Plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f07fcd6fa5d6cf3bce211abaa7f9938b9f8b59" translate="yes" xml:space="preserve">
          <source>Integrating with third-party DOM libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d188e3da39485e86c68a2e47954789d012f3e98a" translate="yes" xml:space="preserve">
          <source>Intentional Loading Sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458622e11438e28a4579aeaa119e2f6a90af7730" translate="yes" xml:space="preserve">
          <source>Interactions can be used to identify the cause of an update, although the API for tracing them is still experimental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6896564dcbd1c525b78f98182de42c4bb2b09515" translate="yes" xml:space="preserve">
          <source>Internally, React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. For many applications, using React will lead to a fast user interface without doing much work to specifically optimize for performance. Nevertheless, there are several ways you can speed up your React application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78abc071449ad0da13e4d5e5a3f22e08fc793563" translate="yes" xml:space="preserve">
          <source>Interruptible Prerendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdb65efee969d707c5e1bc2b4a881568f89c4af" translate="yes" xml:space="preserve">
          <source>Interruptible Rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe91e5b2febdee26a910e78fb467ec00cef2cc7f" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1fa1c8913451a1f429075bf69c1c706857274d" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode (Experimental)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c358e3ea80007355c4cebac6d98e29b8a15fd58" translate="yes" xml:space="preserve">
          <source>Introducing Error Boundaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6752670ac4fd3d43c072341f57aeec0c7e6fa7d6" translate="yes" xml:space="preserve">
          <source>Introducing Hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fc0e820b4798682e759dbf88cc8628f74605fc" translate="yes" xml:space="preserve">
          <source>Introducing JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c770701ef9646b1634d74252668c51159f3855" translate="yes" xml:space="preserve">
          <source>Invokes a function on every immediate child contained within &lt;code&gt;children&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; set to &lt;code&gt;thisArg&lt;/code&gt;. If &lt;code&gt;children&lt;/code&gt; is an array it will be traversed and the function will be called for each child in the array. If children is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, this method will return &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; rather than an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19019a267c68ec0d9a87bbfe53368307773f4e69" translate="yes" xml:space="preserve">
          <source>Is it OK to use arrow functions in render methods?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94bd0fbbd4ff5757505741937dacab45d2007bf" translate="yes" xml:space="preserve">
          <source>Is it passed in from a parent via props? If so, it probably isn&amp;rsquo;t state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b12fb0c98d31f06f2e894073d26a29b446b6105a" translate="yes" xml:space="preserve">
          <source>Is it safe to omit functions from the list of dependencies?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e2fa776e8e49d37a8c66174c7a287fbd5c8891" translate="yes" xml:space="preserve">
          <source>Is the Shadow DOM the same as the Virtual DOM?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118a7d245e14f3d46907f813b32d6d32103aa8e9" translate="yes" xml:space="preserve">
          <source>Is there a recommended way to structure React projects?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431584afff8cf3078b613772134b8cf66a20ffd7" translate="yes" xml:space="preserve">
          <source>Is there something like forceUpdate?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c240e644bcf66edddc303b13a6145795d52277ac" translate="yes" xml:space="preserve">
          <source>Is there something like instance variables?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615079284bccc262002fb9d64da4565ad0ff149a" translate="yes" xml:space="preserve">
          <source>It accepts &lt;code&gt;author&lt;/code&gt; (an object), &lt;code&gt;text&lt;/code&gt; (a string), and &lt;code&gt;date&lt;/code&gt; (a date) as props, and describes a comment on a social media website.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1bc6eb63b54ec080a5b630f4c12685f9a1f7ff" translate="yes" xml:space="preserve">
          <source>It all begins with running one command in your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cb8127bb9bd6695f9f71a7f9270c5ec20060df" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;ReactDOM.render()&lt;/code&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cef424d8853229927def0460dc79c6c0ba401d9" translate="yes" xml:space="preserve">
          <source>It can also be used for larger expressions although it is less obvious what&amp;rsquo;s going on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cbe1ab611653ca85961be292443488b8a02544f" translate="yes" xml:space="preserve">
          <source>It can be tedious to manually calculate the proper color combinations for all cases in your website so instead, you can &lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;calculate an entire accessible color palette with Colorable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62fd02389ef9525bb5984bc2a6e5af4ca327920" translate="yes" xml:space="preserve">
          <source>It can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled components&lt;/a&gt;, an alternative technique for implementing input forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2005e7f27cdc72de843371aaff7b32477d8c91bf" translate="yes" xml:space="preserve">
          <source>It conceptually makes sense for the filter text and checked value to live in &lt;code&gt;FilterableProductTable&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688f0ab18438d6d367169c900008f7481be7690d" translate="yes" xml:space="preserve">
          <source>It displays &amp;ldquo;Hello, world&amp;rdquo; on the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ab860d9c544904ffaab788e02b64e8286beee6" translate="yes" xml:space="preserve">
          <source>It displays a heading saying &amp;ldquo;Hello, world!&amp;rdquo; on the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82647fae753dc8b035e66a8857ffb17ac2da33f" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t suffer from this bug. (But we also didn&amp;rsquo;t make any changes to it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602a6efa84948afcddd9d1b66dd5be71479d7a38" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;only&lt;/strong&gt; safe to omit a function from the dependency list if nothing in it (or the functions called by it) references props, state, or values derived from them. This example has a bug:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ead55f0f98915b5c6f13c05726f2286aab42a96" translate="yes" xml:space="preserve">
          <source>It is an early time for Hooks, and some third-party libraries might not be compatible with Hooks at the moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50466c950e08c88b69e598ab61d92c2dc031d70e" translate="yes" xml:space="preserve">
          <source>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92466150db2416a73798d13e0245efd07871c27a" translate="yes" xml:space="preserve">
          <source>It is common for CSS classes to depend on the component props or state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e283c36c21325ef64876afd9194c0a0cb70a383" translate="yes" xml:space="preserve">
          <source>It is documented in our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting guide&lt;/a&gt;. Note that &lt;code&gt;lazy&lt;/code&gt; components can be deep inside the &lt;code&gt;Suspense&lt;/code&gt; tree &amp;mdash; it doesn&amp;rsquo;t have to wrap every one of them. The best practice is to place &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; where you want to see a loading indicator, but to use &lt;code&gt;lazy()&lt;/code&gt; wherever you want to do code splitting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b84f156dc2b1e8053f6383bcb338d839775393" translate="yes" xml:space="preserve">
          <source>It is equivalent to this ES5 code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b287ce575a54f80be869742a5c4a51c76fe13e" translate="yes" xml:space="preserve">
          <source>It is expected that you use the development mode when working on your app, and the production mode when deploying your app to the users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c952a73f20c5f13e3de4b9d7ef50fbb5a61fc052" translate="yes" xml:space="preserve">
          <source>It is important that we also call &lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; in the &lt;code&gt;remove&lt;/code&gt; method so that React unregisters event handlers and other resources associated with the component tree when it is detached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d368243a184c2b8d827bcbfe71e38225d8ed76" translate="yes" xml:space="preserve">
          <source>It is important to remember that the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same. Just to be clear, rerender in this context means calling &lt;code&gt;render&lt;/code&gt; for all components, it doesn&amp;rsquo;t mean React will unmount and remount them. It will only apply the differences following the rules stated in the previous sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061882208caaee20f8d6caf81dd052b896705df2" translate="yes" xml:space="preserve">
          <source>It is often necessary to update the context from a component that is nested somewhere deeply in the component tree. In this case you can pass a function down through the context to allow consumers to update the context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f2025036d719ebb13936746e156dcb2e46aebc" translate="yes" xml:space="preserve">
          <source>It is safe to embed user input in JSX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4e4c8c699f839e3d4430e49f56a9d08895180e" translate="yes" xml:space="preserve">
          <source>It lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534a38fabcd6aaf35f04bf09e44ca89301bf0ea1" translate="yes" xml:space="preserve">
          <source>It might feel redundant to pass down the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; props through many levels if in the end only the &lt;code&gt;Avatar&lt;/code&gt; component really needs it. It&amp;rsquo;s also annoying that whenever the &lt;code&gt;Avatar&lt;/code&gt; component needs more props from the top, you have to add them at all the intermediate levels too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fb2495198065234962cb4b4d0c32c48a17f7f2" translate="yes" xml:space="preserve">
          <source>It returns an empty string on an invalid &lt;code&gt;temperature&lt;/code&gt;, and it keeps the output rounded to the third decimal place:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9057e6a7d66d1d7c47dc528ed3b3b130a69063f" translate="yes" xml:space="preserve">
          <source>It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6 on your machine. To create a project, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706a32880b71586a8d7aa0ac7d5f1463de4cb7ba" translate="yes" xml:space="preserve">
          <source>It takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether our friend is online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3161055d73426680e8d35bc1e7cbbe8e4104358e" translate="yes" xml:space="preserve">
          <source>It took us only seven lines of code to add this transition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e77ef569a1f7d7c48e0e05eba962af9f6767c1" translate="yes" xml:space="preserve">
          <source>It will render either &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; depending on its current state. It will also render a &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; from the previous example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2155bb73f8bf6451916989b5cbacb97df229da2a" translate="yes" xml:space="preserve">
          <source>It will use &lt;code&gt;this.setState()&lt;/code&gt; to schedule updates to the component local state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02413defbcafdd99d3c520fd9d4aa148536aaf1" translate="yes" xml:space="preserve">
          <source>It works because in JavaScript, &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;expression&lt;/code&gt;, and &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1035dc615a18406c02f413ad0f4e40e484e2b1" translate="yes" xml:space="preserve">
          <source>It would catch both rendering errors &lt;em&gt;and&lt;/em&gt; errors from Suspense data fetching. We can have as many error boundaries as we like but it&amp;rsquo;s best to &lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;be intentional&lt;/a&gt; about their placement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53bef197f2d6ecda97fc0ca21c3fffc1a9ab88e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good idea to get to know React first, before adding in additional libraries. You can build quite complex applications using only React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1069cd6014468c5f2a1a444828d18bfcd86ae157" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a result of several years of research and development, but it&amp;rsquo;s not finished. In the section on &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;adopting Concurrent Mode&lt;/a&gt;, we&amp;rsquo;ll describe how you can try it and what you can expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b97c1e1db1289e7c4f51d01cbfaea288680830c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s difficult to remember which props or state are used by functions outside of the effect. This is why &lt;strong&gt;usually you&amp;rsquo;ll want to declare functions needed by an effect &lt;em&gt;inside&lt;/em&gt; of it.&lt;/strong&gt; Then it&amp;rsquo;s easy to see what values from the component scope that effect depends on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d523ee0a8b2e43fbd774373dabc117b68d15fc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s hard to reuse stateful logic between components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11305e8e0d8ed22ffeb90393f322ef30d355dd4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that just because the pattern is called &amp;ldquo;render props&amp;rdquo; you don&amp;rsquo;t &lt;em&gt;have to use a prop named &lt;code&gt;render&lt;/code&gt; to use this pattern&lt;/em&gt;. In fact, &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&lt;em&gt;any&lt;/em&gt; prop that is a function that a component uses to know what to render is technically a &amp;ldquo;render prop&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbcf3e467e64993c40145b58380cca00dde2358" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not a Hook because it doesn&amp;rsquo;t compose like Hooks do. &lt;code&gt;React.memo&lt;/code&gt; is equivalent to &lt;code&gt;PureComponent&lt;/code&gt;, but it only compares props. (You can also add a second argument to specify a custom comparison function that takes the old and new props. If it returns true, the update is skipped.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218c8c3fba795922b2f79061baba6ea0eea01f6d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that a minor release will not include new features. &lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;This is allowed by semver&lt;/a&gt;, which states &lt;strong&gt;&amp;rdquo;[a minor version] MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes.&amp;rdquo;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed922784aa3b9ce3ee3dfd000c51ce8f2ddc5c7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that in the future React will provide a &lt;code&gt;usePrevious&lt;/code&gt; Hook out of the box since it&amp;rsquo;s a relatively common use case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4411f615cb9a34eac0782d89d41554e9d48dcddd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s typically better to make more specific assertions than to use snapshots. These kinds of tests include implementation details so they break easily, and teams can get desensitized to snapshot breakages. Selectively &lt;a href=&quot;#mocking-modules&quot;&gt;mocking some child components&lt;/a&gt; can help reduce the size of snapshots and keep them readable for the code review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483a41989a3f28face460eaf57d7dae044787b9f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite others components updating), we can do this with trees that take too long to render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b65216aa0540eaf6506a4435bb83e1e7f8f013" translate="yes" xml:space="preserve">
          <source>JAWS in Internet Explorer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="1390ed0a23d1a0f6a989a72f7740422bce623820" translate="yes" xml:space="preserve">
          <source>JSX Children</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a08e455cb80c9325d21ca392ead0811d7f7928f" translate="yes" xml:space="preserve">
          <source>JSX In Depth</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79f80b3f74dfa812404ff28047b6abd93ce00a8" translate="yes" xml:space="preserve">
          <source>JSX Prevents Injection Attacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201092e5747855ff7f46489df7db6fec3735acac" translate="yes" xml:space="preserve">
          <source>JSX Represents Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f821c0797aa66329cd5b6a52d7b985154fb5e626" translate="yes" xml:space="preserve">
          <source>JSX allows &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embedding any expression&lt;/a&gt; in curly braces so we could inline the &lt;code&gt;map()&lt;/code&gt; result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f572ba8add6be836659fce1a76a91186f8683f81" translate="yes" xml:space="preserve">
          <source>JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to &lt;code&gt;React.createElement()&lt;/code&gt; calls which return plain JavaScript objects called &amp;ldquo;React elements&amp;rdquo;. To get a basic introduction to JSX &lt;a href=&quot;introducing-jsx&quot;&gt;see the docs here&lt;/a&gt; and find a more in-depth tutorial on JSX &lt;a href=&quot;jsx-in-depth&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6badf2480a79666ab2a50ef49c41eec53e3e92" translate="yes" xml:space="preserve">
          <source>JSX is an Expression Too</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d41082c94e0ade95a8097ecf33e2cb44acdb09" translate="yes" xml:space="preserve">
          <source>JSX is not a requirement for using React. Using React without JSX is especially convenient when you don&amp;rsquo;t want to set up compilation in your build environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd38b28ee1a9a309326f94891c1df14009e831fa" translate="yes" xml:space="preserve">
          <source>JSX produces React &amp;ldquo;elements&amp;rdquo;. We will explore rendering them to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;. Below, you can find the basics of JSX necessary to get you started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c0788f2156485e43ec1aec3f13813b6ce0ec76" translate="yes" xml:space="preserve">
          <source>JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e557a0ad7b8dd428002b075a12a339460bf81183" translate="yes" xml:space="preserve">
          <source>JSX tags may contain children:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88547a44d266cdafe70fec17001f13058415c5b" translate="yes" xml:space="preserve">
          <source>JavaScript Environment Requirements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191332a52bb73fc079e6c2be8fbab52a7b9b0c79" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Children</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86b0b485fe227f9926cd86119e4d67d9db9cb41" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8262e0b313f4b908f2bfa1fa8c04c78e05342554" translate="yes" xml:space="preserve">
          <source>JavaScript Resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab669d11c2053c3096b0ce975c409719b9ab1f3" translate="yes" xml:space="preserve">
          <source>JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc6b5ae1ed04a526c0403c39f6d892a4884f28f" translate="yes" xml:space="preserve">
          <source>Jest is widely compatible with React projects, supporting features like mocked &lt;a href=&quot;#mocking-modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;#mocking-timers&quot;&gt;timers&lt;/a&gt;, and &lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt; support. &lt;strong&gt;If you use Create React App, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jest is already included out of the box&lt;/a&gt; with useful defaults.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f4f29dc54a0429c9c6356ba883190a57985b95" translate="yes" xml:space="preserve">
          <source>Just because it&amp;rsquo;s possible, doesn&amp;rsquo;t mean that it&amp;rsquo;s the best approach for React apps. We encourage you to use React components when you can. React components are easier to reuse in React applications, and often provide more control over their behavior and appearance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c6c9a90cc15a2b6bbb52187ffa7d5c291abb80" translate="yes" xml:space="preserve">
          <source>Just like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19fb11d1b21bc4e9e11220a38333f6f51bc6998" translate="yes" xml:space="preserve">
          <source>Just like in a real browser, jsdom lets us model user interactions; tests can dispatch events on DOM nodes, and then observe and assert on the side effects of these actions &lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a953b2cc6af815cf1d538af4ea7e0cdd73a8c9" translate="yes" xml:space="preserve">
          <source>Just like with &lt;code&gt;useState&lt;/code&gt;, you can use more than a single effect in a component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0417f986bcfb4e8e2b6c2b20736543a236a42518" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; is composable, like anything in React. For example, you can create a grid by putting several &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; rows inside a &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07019d7742ef51cadec0c4168d9dbc4ff41a327c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;useRef&lt;/code&gt;&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; notify you when its content changes. Mutating the &lt;code&gt;.current&lt;/code&gt; property doesn&amp;rsquo;t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a &lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;callback ref&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa659e6371af8e34371298a054c6fa0b8e3f4e6" translate="yes" xml:space="preserve">
          <source>Keep scrolling down, and you&amp;rsquo;ll find the link to the &lt;a href=&quot;introducing-jsx&quot;&gt;next chapter of this guide&lt;/a&gt; right before the website footer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a277208935542103e33cce1ec94231bfcbe2812" translate="yes" xml:space="preserve">
          <source>Keep using &lt;code&gt;createReactClass&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63562f9dc59d3d173ce1da297fea061eda935fe" translate="yes" xml:space="preserve">
          <source>Keyboard focus and focus outline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a38cea4a8ef2893215c7068a770d00cbeee9f2" translate="yes" xml:space="preserve">
          <source>Keyboard focus refers to the current element in the DOM that is selected to accept input from the keyboard. We see it everywhere as a focus outline similar to that shown in the following image:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea41b7bfa6e4c0a74c593ca76797a28b26b665e" translate="yes" xml:space="preserve">
          <source>Keyed Fragments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="033fe9e03aa157b184cec9c5c36765ae681fc7ed" translate="yes" xml:space="preserve">
          <source>Keys Must Only Be Unique Among Siblings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d08b1dcb85c35147a1b3441c0c392efd3a8241" translate="yes" xml:space="preserve">
          <source>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c207367e515ac72a16c2932ecfa02b3376650bf0" translate="yes" xml:space="preserve">
          <source>Keys only make sense in the context of the surrounding array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b4e388c860748250255ac3aec6577a53bb08ca" translate="yes" xml:space="preserve">
          <source>Keys only need to be unique among sibling elements in the same array. They don&amp;rsquo;t need to be unique across the whole application or even a single component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f269f84d4b420a7eccc734c9f3e4bbe7ec1e654b" translate="yes" xml:space="preserve">
          <source>Keys serve as a hint to React but they don&amp;rsquo;t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb803361f1db02c12313aa22ea43364fef308c9" translate="yes" xml:space="preserve">
          <source>Keys should be stable, predictable, and unique. Unstable keys (like those produced by &lt;code&gt;Math.random()&lt;/code&gt;) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d2b02a27e73ea54e2ad8018f1f566c76419e35" translate="yes" xml:space="preserve">
          <source>Keys used within arrays should be unique among their siblings. However they don&amp;rsquo;t need to be globally unique. We can use the same keys when we produce two different arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b950ddccc3180b1568a4677560f1be2e72ae0d05" translate="yes" xml:space="preserve">
          <source>Knowledge Level Assumptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="087f43dec679500a381105d8177480d92e5bc6f7" translate="yes" xml:space="preserve">
          <source>Labeling</source>
          <target state="translated">Labeling</target>
        </trans-unit>
        <trans-unit id="86ade0000eab7713840cb80442178dbad165e1c7" translate="yes" xml:space="preserve">
          <source>Later, you write a component for subscribing to a single blog post, which follows a similar pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e81f878f11e9186c40f41b370cbeff1223f6553" translate="yes" xml:space="preserve">
          <source>Latest Channel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801295034f8f587a8731684b0829ce3fafe33d56" translate="yes" xml:space="preserve">
          <source>Latest is the channel used for stable React releases. It corresponds to the &lt;code&gt;latest&lt;/code&gt; tag on npm. It is the recommended channel for all React apps that are shipped to real users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09dea8b1934495cf50be92926eded5430df29f58" translate="yes" xml:space="preserve">
          <source>Lazy initial state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa93a4477a941d54e9e6489ff5a7fb43a5339e0" translate="yes" xml:space="preserve">
          <source>Lazy initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c5a8ff2c0a4cee2266af52e69d8ea217bc6355" translate="yes" xml:space="preserve">
          <source>Learn Gatsby from &lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;its official guide&lt;/a&gt; and a &lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;gallery of starter kits&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378cbbf54cbb2e3f3bd201f02c1b946ec3601eba" translate="yes" xml:space="preserve">
          <source>Learn More</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47738a476129c3a8cb6d980e52a9a75eb86f2183" translate="yes" xml:space="preserve">
          <source>Learn Next.js from &lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;its official guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802c853c766c4a1fb751dfe0a5007088efb8fff9" translate="yes" xml:space="preserve">
          <source>Learn React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1aff18b114655a3728004f5ddf84acf496ed61" translate="yes" xml:space="preserve">
          <source>Learn more about it at &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me/react-interaction-tracing&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74783fcd98611ef8c679d0b35c17456b50fdbdab" translate="yes" xml:space="preserve">
          <source>Learn more about setState</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9e1ea32612926012e0f27c2e2d3bc9d3504c65" translate="yes" xml:space="preserve">
          <source>Learn more about the new &lt;code&gt;createRef&lt;/code&gt; API here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12363dec3cec522658520bb14b574d2c38d4a9b" translate="yes" xml:space="preserve">
          <source>Legacy API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde4f866b5827a3ecdb1b59f566920d28fc762d3" translate="yes" xml:space="preserve">
          <source>Legacy API: String Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b92b7804190333f8d5aa0581703f3b2664d74b" translate="yes" xml:space="preserve">
          <source>Legacy Context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673ce3a3969d34565237049f3b8553b6bff614da" translate="yes" xml:space="preserve">
          <source>Legacy Lifecycle Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebe4f64c19e892054a7737b95e642e4103d4505" translate="yes" xml:space="preserve">
          <source>Legacy Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41df52dcff2d5fb3f135df9c40c44c902c43f73" translate="yes" xml:space="preserve">
          <source>Lessons Learned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59538c378635dc8630feb1d884595472a4a714c5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s Get Started!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ad68c13a4560eb3e6da14fe3991a29f25a12c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assign a &lt;code&gt;key&lt;/code&gt; to our list items inside &lt;code&gt;numbers.map()&lt;/code&gt; and fix the missing key issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e35c44c6745b986cc311a397ff72118a2f50c3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s compare how different data fetching strategies deal with this requirement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e9d17f03076a3ad9477b82b07a51d4ce77f838" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get back to our &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;first Suspense demo&lt;/a&gt; where there was just one profile. Currently, it fetches the data only once. We&amp;rsquo;ll add a &amp;ldquo;Refresh&amp;rdquo; button to check for server updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2172c9119c229d11c473d5df9aa8d5d8d41b93a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go over these in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35b4f5f51eb24f390b73104414deef66768949e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go through each one and figure out which one is state. Ask three questions about each piece of data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb2b5e509c3f39d850f9c0bc68afe5b00ce8cbb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now &lt;strong&gt;recap what we learned line by line&lt;/strong&gt; and check our understanding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db586e06ea830a0bf5bd7eba403ec7c7c1d5191" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s quickly recap what&amp;rsquo;s going on and the order in which the methods are called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b731235df3a08f9cefe099e4a2b6bfde68c1ff0c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap the two examples above and see how Concurrent Mode unifies them. &lt;strong&gt;In Concurrent Mode, React can work on several state updates &lt;em&gt;concurrently&lt;/em&gt;&lt;/strong&gt; &amp;mdash; just like branches let different team members work independently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b3965c34758d4b1e54e8fcc6e8e8d971b07cb2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87dc62cffe0ac1c4c5391c6f0828660b4dd4a79a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens when you edit an input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eca8e8ef68c829498c7d9e68354b1472e530462" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s revisit &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;this demo&lt;/a&gt; from the previous page about &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e57dda434c35263f11856e0672be5db88ed7e8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite this example again, but using Suspense only:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68a7b21d6c5f27413fdb9eda1dd97e5fd7b5762" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run through this strategy for our application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ef0e00ecbe33d94c5d49e91e16ab5645be9c88" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that fetching the user details is very fast and only takes 300 milliseconds. Currently, we&amp;rsquo;re waiting a whole second because we need both user details and posts to display a consistent profile page. But what if we want to show the details faster?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4991d5eafd8e8e062c0f087c85c40c1ea2d4cc4e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that this is the API we&amp;rsquo;re striving for with our &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; wrapper React component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2036fedebbcaf2b79f375bedb67a4420e6a7e60a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say there is a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; somewhere in your HTML file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0dc0ebd0f6824d83a50f1aeaa18d1eaaf7cabfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works step by step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e8fb3a23f53b18cf26df347e321256ab7c212c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how we could write this component with Hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6fa6b57cf391318ac0bf024b8e3823314cbcfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see why this matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b577a0e161bcf81a4e96e3f3a99c76d5a54c4977" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at each of the props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23b9ea82a3fd528716ce8cd73af2430db7a55e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take another look at all the changes we&amp;rsquo;ve made since the &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;original example&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5910b527fe0e81b1ac837051111d1cfb45c48766" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, &lt;code&gt;FilterableProductTable&lt;/code&gt; will pass callbacks to &lt;code&gt;SearchBar&lt;/code&gt; that will fire whenever the state should be updated. We can use the &lt;code&gt;onChange&lt;/code&gt; event on the inputs to be notified of it. The callbacks passed by &lt;code&gt;FilterableProductTable&lt;/code&gt; will call &lt;code&gt;setState()&lt;/code&gt;, and the app will be updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e893f82b5ddbd897be82bf493ce9e81174e5eb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f77d8b5f6dfc038e27b746c7a414fe97a3630d" translate="yes" xml:space="preserve">
          <source>Libraries can prevent waterfalls by offering a more centralized way to do data fetching. For example, Relay solves this problem by moving the information about the data a component needs to statically analyzable &lt;em&gt;fragments&lt;/em&gt;, which later get composed into a single query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46000d17b247964f6470d045921aa1d6334b0a4b" translate="yes" xml:space="preserve">
          <source>Libraries like &lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mocha&lt;/a&gt; work well in real browser environments, and could help for tests that explicitly need it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041313632fc218e701e7df8b55493ecd8a5123e5" translate="yes" xml:space="preserve">
          <source>Libraries that use render props include &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt; and &lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40721cc170a6bfccd149edbfe1dc276de96ccd33" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution 4.0 International Public License.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ff789df886ac8c1ebe62bba2f20adc6571666a" translate="yes" xml:space="preserve">
          <source>Lifecycle Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ec3a03bfeda0f665ab03b38f3ed1016d195b0e" translate="yes" xml:space="preserve">
          <source>Lifecycle methods are custom functionality that gets executed during the different phases of a component. There are methods available when the component gets created and inserted into the DOM (&lt;a href=&quot;react-component#mounting&quot;&gt;mounting&lt;/a&gt;), when the component updates, and when the component gets unmounted or removed from the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2783625398c73ad59607a3ac0e2c10a16bd848" translate="yes" xml:space="preserve">
          <source>Lifting State Up</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f96af2feedeafd8240d4e2179b169296b1ab38" translate="yes" xml:space="preserve">
          <source>Lifting state involves writing more &amp;ldquo;boilerplate&amp;rdquo; code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state &amp;ldquo;lives&amp;rdquo; in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6205c7daf26478bf62962f9d33d7bc15dfc34968" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#reactchildrenmap&quot;&gt;&lt;code&gt;React.Children.map()&lt;/code&gt;&lt;/a&gt; but does not return an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7b45e8f4e6108d3cd632f0d9032c3748a2b4eb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbfeab98f1492d3cbd4fe154e243495eb88fd5bc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9229dd48cd84c65e22bacddf9669feed15d9307" translate="yes" xml:space="preserve">
          <source>Like Next, the Experimental channel is a prerelease channel that tracks the master branch of the React repository. Unlike Next, Experimental releases include additional features and APIs that are not ready for wider release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b243b275e73df60e527af74a2a1e22222d9d870a" translate="yes" xml:space="preserve">
          <source>Like any unfamiliar technology, React does have a learning curve. With practice and some patience, you &lt;em&gt;will&lt;/em&gt; get the hang of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b06e3b678326306ca6aedaf4c7b742dbd8cc493" translate="yes" xml:space="preserve">
          <source>Like components, the contract between &lt;code&gt;withSubscription&lt;/code&gt; and the wrapped component is entirely props-based. This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component. This may be useful if you change data-fetching libraries, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8756ee6b18f3a0b99d47c3487ab6bf4153dc005f" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; support &lt;code&gt;defaultChecked&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; supports &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b1d121df3542e14f97acaa2800f9f76542cac7" translate="yes" xml:space="preserve">
          <source>Linting in Flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b64dc10b36fcc65c0d847eaaa62fd7fe512239" translate="yes" xml:space="preserve">
          <source>Lists and Keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110bfe58a1735dfc3135bc1d5e016924d60c0744" translate="yes" xml:space="preserve">
          <source>Live Demo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f00bd7dc65bd809a53f2303fb70b92320c36fa6" translate="yes" xml:space="preserve">
          <source>Live-editing CSS and JS in development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc841064cbfd066e159686f41aef96834b0e8bf6" translate="yes" xml:space="preserve">
          <source>Looking at the now generated &lt;code&gt;tsconfig.json&lt;/code&gt;, you can see that there are many options you can use to configure the compiler. For a detailed description of all the options, check &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f500ff46d146daea76d615ff5daed4f1aeaa0d00" translate="yes" xml:space="preserve">
          <source>MDN HTML elements reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5beafe9207c5520f3ac09a7866f79c87d68f07b" translate="yes" xml:space="preserve">
          <source>MDN Web Docs takes a look at this and describes how we can build &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;keyboard-navigable JavaScript widgets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b1316849f970c5b3e2af20718278c5b7793286" translate="yes" xml:space="preserve">
          <source>Main Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ff3711bd667ed46bace9ec4c6ec8190ecebfcc" translate="yes" xml:space="preserve">
          <source>Major releases can also contain new features, and any release can include bug fixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18f93964d446c1e6ba3cd266eb85e86312f1773" translate="yes" xml:space="preserve">
          <source>Make sure you aren&amp;rsquo;t &lt;em&gt;calling the function&lt;/em&gt; when you pass it to the component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1908a834f7fac54b702b7157c4e6dc90e16f736a" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re familiar with simpler alternatives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e7115a4c3ac435e928084df77c98aa6a10ab0d" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re running the application in the development mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f51d22d8fb5f4e18c7b9a43a14aa00fb1d1d71" translate="yes" xml:space="preserve">
          <source>Managing focus, text selection, or media playback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ee04fb3d96bb1368dfb5a70eed53b537b4cf07" translate="yes" xml:space="preserve">
          <source>Many React users credit reading &lt;a href=&quot;thinking-in-react&quot;&gt;Thinking in React&lt;/a&gt; as the moment React finally &amp;ldquo;clicked&amp;rdquo; for them. It&amp;rsquo;s probably the oldest React walkthrough but it&amp;rsquo;s still just as relevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25207d84725584b98b20c010ae4e867354803e86" translate="yes" xml:space="preserve">
          <source>Maybe.</source>
          <target state="translated">Maybe.</target>
        </trans-unit>
        <trans-unit id="5279878671cef1bbee173e636b630698108458c0" translate="yes" xml:space="preserve">
          <source>Mechanisms to skip to desired content</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ebd3a5b45a9f5adf87a363ab82624e164a1745" translate="yes" xml:space="preserve">
          <source>Media Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fce9fc1bba59eae6ae511090a30e9f9acda79af" translate="yes" xml:space="preserve">
          <source>Migration Step: Blocking Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51e9091bf1aa90a7dc06f8b80d1cf4f79106e04" translate="yes" xml:space="preserve">
          <source>Minor releases are the most common type of release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="e609b515d8887ae3c0a2bcd948b76d5eb888dcae" translate="yes" xml:space="preserve">
          <source>Mocking Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd5e79fcfd93473fe47f93cc81171186377bc01" translate="yes" xml:space="preserve">
          <source>Mocking a rendering surface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9db431c0932c551ce8ea2f4c40d441d4aa97a6" translate="yes" xml:space="preserve">
          <source>Mocking functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3ebffe5140fcd669b91ded83765eee7cd79ed7" translate="yes" xml:space="preserve">
          <source>Mocking modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc6f7ed11adb29245ad928339ee3fe94bf8f96c" translate="yes" xml:space="preserve">
          <source>Mocking timers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ab7c68a15742b6ace6a0b59f0802cd56989f9d" translate="yes" xml:space="preserve">
          <source>More Complex Widgets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1e9c89527fbc96f2921cbe93fbfc11e6a52a9a" translate="yes" xml:space="preserve">
          <source>More Flexible Toolchains</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c42df7c665642f754f240ed7f247eeed80d1ceb3" translate="yes" xml:space="preserve">
          <source>More concretely, &lt;strong&gt;a render prop is a function prop that a component uses to know what to render.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4184dc3093adbdaf5a60e796e014a24e3eb74b2" translate="yes" xml:space="preserve">
          <source>Most React apps will have their files &amp;ldquo;bundled&amp;rdquo; using tools like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Bundling is the process of following imported files and merging them into a single file: a &amp;ldquo;bundle&amp;rdquo;. This bundle can then be included on a webpage to load an entire app at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5a32a23f908873850adbc01e3bfc083647f135" translate="yes" xml:space="preserve">
          <source>Most of the time, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; instead of writing your own &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. It only does a shallow comparison, so you can&amp;rsquo;t use it if the props or state may have been mutated in a way that a shallow comparison would miss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6ec3d67d6c3f4388c5225ce97b912bc6998b9b" translate="yes" xml:space="preserve">
          <source>Most people who use React don&amp;rsquo;t use Web Components, but you may want to, especially if you are using third-party UI components that are written using Web Components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="26ae06ab481b93e012f7ab95465638d5fb60ed34" translate="yes" xml:space="preserve">
          <source>Mounting</source>
          <target state="translated">Mounting</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b20c10dce51324fb107e751c01666324956e394" translate="yes" xml:space="preserve">
          <source>Mouse and pointer events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1e7bad76871046ddf523d9fe663dd3a621512b" translate="yes" xml:space="preserve">
          <source>Move the body of the function into the &lt;code&gt;render()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b29de6bcd589e86e040638485090ea2a9bf182d" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;Profiler&lt;/code&gt; components can be used to measure different parts of an application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e23b3461f95ee737c2d746ec92f09e64df8c67e" translate="yes" xml:space="preserve">
          <source>Multiple Renderers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0479fd15fec4ef8ee834648226853be71fdeda8" translate="yes" xml:space="preserve">
          <source>Mutating HOCs are a leaky abstraction&amp;mdash;the consumer must know how they are implemented in order to avoid conflicts with other HOCs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4fb500f3d1079177a94f12b723a038f9d11e9c" translate="yes" xml:space="preserve">
          <source>Mutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React&amp;rsquo;s &lt;em&gt;render phase&lt;/em&gt;). Doing so will lead to confusing bugs and inconsistencies in the UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298fe7648153e9ef9747060691f787af56551508" translate="yes" xml:space="preserve">
          <source>NVDA in Firefox</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f2f30ba49708ae97f8d92b8a8a72e7ddff53df" translate="yes" xml:space="preserve">
          <source>Named Exports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8223c4ee1ebba2ecb6739e2c07dbe5aef3df91b4" translate="yes" xml:space="preserve">
          <source>Naming Changes from React 15</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41e56840d69bd1bdd31e27707dc3a8b970413df" translate="yes" xml:space="preserve">
          <source>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn&amp;rsquo;t care whether it is defined as a function or a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44dcd3a4ac0c4c177b3fafe8b75ff34a66cc079" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.state&lt;/code&gt; directly, as calling &lt;code&gt;setState()&lt;/code&gt; afterwards may replace the mutation you made. Treat &lt;code&gt;this.state&lt;/code&gt; as if it were immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb61bead103f4e57375ed4a4afb6cfadf7e8a73" translate="yes" xml:space="preserve">
          <source>New Behavior for Uncaught Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9840d3214efbf61f44cf5554641966293bd9f3a1" translate="yes" xml:space="preserve">
          <source>Next Channel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed8ca892cbf39b577e860e50cdb6e102751578f" translate="yes" xml:space="preserve">
          <source>Next, add three &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags to the HTML page right before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cb58c13d37c6cc1855c1dd32d1fed18cfeb93f" translate="yes" xml:space="preserve">
          <source>Next, the &lt;code&gt;render()&lt;/code&gt; method is called and the diff algorithm recurses on the previous result and the new result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e81212e5ac19cfc9b59fe21a631d3753e83f2b5" translate="yes" xml:space="preserve">
          <source>Next, we will create a component called &lt;code&gt;Calculator&lt;/code&gt;. It renders an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; that lets you enter the temperature, and keeps its value in &lt;code&gt;this.state.temperature&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773f24daf1da57217e2f8e8567bf1bc9016af437" translate="yes" xml:space="preserve">
          <source>Next, we will extract a &lt;code&gt;UserInfo&lt;/code&gt; component that renders an &lt;code&gt;Avatar&lt;/code&gt; next to the user&amp;rsquo;s name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d6961628775828349729a4be218018b6d3a3ac" translate="yes" xml:space="preserve">
          <source>Next, we will implement the lifecycle methods. We need to initialize Chosen with the ref to the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node in &lt;code&gt;componentDidMount&lt;/code&gt;, and tear it down in &lt;code&gt;componentWillUnmount&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce34474eda0627488f7dc85176d87bf118e6e53d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add an import for the &lt;code&gt;useTransition&lt;/code&gt; Hook from React:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d7070daf25a2f645c41cd51b24e95c602ef3cd" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll make the &lt;code&gt;Clock&lt;/code&gt; set up its own timer and update itself every second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e778abae94d2dfc988da43bf316d54e5851ca7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll tell the compiler where our source code is and where the output should go.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694fd7bdca2fabcac6a912607368e98378b0b39b" translate="yes" xml:space="preserve">
          <source>Next.js</source>
          <target state="translated">Next.js</target>
        </trans-unit>
        <trans-unit id="aa4786474b1f9c2b27bbf660fd976c2e3f9e0c0b" translate="yes" xml:space="preserve">
          <source>No Breaking Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea583f6afe9b6e25e50f115711dd0b56142fcb36" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-es6&quot;&gt;&amp;ldquo;React Without ES6&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b196a9e021f5013ed7f97aab941425359e880d" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-jsx&quot;&gt;&amp;ldquo;React Without JSX&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9848de506504aee3698fb2303cc082341679f4dc" translate="yes" xml:space="preserve">
          <source>No, they are different. The Shadow DOM is a browser technology designed primarily for scoping variables and CSS in web components. The virtual DOM is a concept implemented by libraries in JavaScript on top of browser APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ec72f282ae4d51f6663dfafe02a89ddbd53865" translate="yes" xml:space="preserve">
          <source>No. In modern browsers, the raw performance of closures compared to classes doesn&amp;rsquo;t differ significantly except in extreme scenarios.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e489b277ff2e842c4240cf5198329ad064dfd60" translate="yes" xml:space="preserve">
          <source>No. There are &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;no plans&lt;/a&gt; to remove classes from React &amp;mdash; we all need to keep shipping products and can&amp;rsquo;t afford rewrites. We recommend trying Hooks in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a407ef4de7c3c16900e064cfde1c40d6f88459c3" translate="yes" xml:space="preserve">
          <source>Normally you should try to avoid all uses of &lt;code&gt;forceUpdate()&lt;/code&gt; and only read from &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99653f5245ac5639a7989484c01146c83245683b" translate="yes" xml:space="preserve">
          <source>Normally you would define a React component as a plain JavaScript class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183009a95c48cc3c8552b8d193bc55733a9da03e" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, &lt;code&gt;props.children&lt;/code&gt; works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as &lt;code&gt;props.children&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190f214c6271f32c16616efc1edf4a598d1724d4" translate="yes" xml:space="preserve">
          <source>Normally, there is a warning when an element with children is also marked as &lt;code&gt;contentEditable&lt;/code&gt;, because it won&amp;rsquo;t work. This attribute suppresses that warning. Don&amp;rsquo;t use this unless you are building a library like &lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js&lt;/a&gt; that manages &lt;code&gt;contentEditable&lt;/code&gt; manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd4b09c96906d68937c9412b6fd82a68a4314a7" translate="yes" xml:space="preserve">
          <source>Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use in new code without making any changes to the existing code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2dec545b1bcbcdd30f45e8128cc1dc979967845" translate="yes" xml:space="preserve">
          <source>Normally, when you return an element from a component&amp;rsquo;s render method, it&amp;rsquo;s mounted into the DOM as a child of the nearest parent node:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36f36a60ec7e988ebd6b0da0589f77cbff203cc" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t mutate local state in React. However, as an escape hatch, you can use an incrementing counter to force a re-render even if the state has not changed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65436a84c77556cccffc3de4f952f08eb5996b2a" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t need to think about this. But it matters for HOCs because it means you can&amp;rsquo;t apply a HOC to a component within the render method of a component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b634d41d383d2c2c85fe24302f5a62774271b079" translate="yes" xml:space="preserve">
          <source>Not all HOCs look the same. Sometimes they accept only a single argument, the wrapped component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b40478626081aff6b6152a5ac2bc60a347ba9e" translate="yes" xml:space="preserve">
          <source>Not all style properties are converted to pixel strings though. Certain ones remain unitless (eg &lt;code&gt;zoom&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;flex&lt;/code&gt;). A complete list of unitless properties can be seen &lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3dce74d24f02b63c13638f91d2e8c790ee44211" translate="yes" xml:space="preserve">
          <source>Not every React release deserves its own blog post, but you can find a detailed changelog for every release in the &lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt;&lt;code&gt;CHANGELOG.md&lt;/code&gt; file in the React repository&lt;/a&gt;, as well as on the &lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b703ebbf1b1cf4f4af246b8831b3304e1ea7b732" translate="yes" xml:space="preserve">
          <source>Note for component library maintainers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f07fc00eca63f479177f8f24ebc20765f4ab58" translate="yes" xml:space="preserve">
          <source>Note how &lt;strong&gt;we have to duplicate the code between these two lifecycle methods in class.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136a652f0357162f7faa10211f6de25fc285e258" translate="yes" xml:space="preserve">
          <source>Note how the logic that sets &lt;code&gt;document.title&lt;/code&gt; is split between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. The subscription logic is also spread between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;. And &lt;code&gt;componentDidMount&lt;/code&gt; contains code for both tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af859993c451cb0b08b7e66c1d591884e0bd7b2b" translate="yes" xml:space="preserve">
          <source>Note how this would work for props, state, or any other calculated value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f0076b98d34a6e29be0cedd7cf07479dcc0f97" translate="yes" xml:space="preserve">
          <source>Note how we also changed the effect dependencies from &lt;code&gt;[]&lt;/code&gt; to &lt;code&gt;[id]&lt;/code&gt; &amp;mdash; because we want the effect to re-run when the &lt;code&gt;id&lt;/code&gt; changes. Otherwise, we wouldn&amp;rsquo;t refetch new data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e67313f6ff24b0ac9427a27eaa56f7a14b86fb" translate="yes" xml:space="preserve">
          <source>Note how we eliminated the &lt;code&gt;if (...)&lt;/code&gt; &amp;ldquo;is loading&amp;rdquo; checks from our components. This doesn&amp;rsquo;t only remove boilerplate code, but it also simplifies making quick design changes. For example, if we wanted profile details and posts to always &amp;ldquo;pop in&amp;rdquo; together, we could delete the &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary between them. Or we could make them independent from each other by giving each &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary. Suspense lets us change the granularity of our loading states and orchestrate their sequencing without invasive changes to our code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a102e3bac932a4b73c9dad4c0a7268f562de444e" translate="yes" xml:space="preserve">
          <source>Note how we pass &lt;code&gt;props&lt;/code&gt; to the base constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2582d2e45f28b6c6e7c9a5f4534087c1aa30ef02" translate="yes" xml:space="preserve">
          <source>Note how we save the timer ID right on &lt;code&gt;this&lt;/code&gt; (&lt;code&gt;this.timerID&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abe7d49c5110b0b495bee7ab2bbbd92a50f878a" translate="yes" xml:space="preserve">
          <source>Note how we used the ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;computed property name&lt;/a&gt; syntax to update the state key corresponding to the given input name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b008f8350f4cfc8fc1ac8218af3644148e094014" translate="yes" xml:space="preserve">
          <source>Note how we were able to move the &lt;code&gt;useState&lt;/code&gt; call for the &lt;code&gt;position&lt;/code&gt; state variable and the related effect into a custom Hook without changing their code. If all state was in a single object, extracting it would be more difficult.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1a921c73e886405b533b71309555191e0dd804" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;SuspenseList&lt;/code&gt; only operates on the closest &lt;code&gt;Suspense&lt;/code&gt; and &lt;code&gt;SuspenseList&lt;/code&gt; components below it. It does not search for boundaries deeper than one level. However, it is possible to nest multiple &lt;code&gt;SuspenseList&lt;/code&gt; components in each other to build grids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5369d72764239c963258ac4860d4222756071b86" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;error boundaries only catch errors in the components below them in the tree&lt;/strong&gt;. An error boundary can&amp;rsquo;t catch an error within itself. If an error boundary fails trying to render the error message, the error will propagate to the closest error boundary above it. This, too, is similar to how catch {} block works in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056385a2ed6637b481ae142bf0a46d9f70a318a3" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;the numbers are relative so components will render faster in production&lt;/strong&gt;. Still, this should help you realize when unrelated UI gets updated by mistake, and how deep and how often your UI updates occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ff4a5e91c66b9d6944b9d99f0d60617bdf219c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;to enable Hooks, all React packages need to be 16.8.0 or higher&lt;/strong&gt;. Hooks won&amp;rsquo;t work if you forget to update, for example, React DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58c552c3d3190dd2fb91ca8e1639154f214426b" translate="yes" xml:space="preserve">
          <source>Note that React assigns no special meaning to the &lt;code&gt;this.el&lt;/code&gt; field. It only works because we have previously assigned this field from a &lt;code&gt;ref&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b82595a068571374ab58a7ca07015bf588a435" translate="yes" xml:space="preserve">
          <source>Note that React may still need to render that specific component again before bailing out. That shouldn&amp;rsquo;t be a concern because React won&amp;rsquo;t unnecessarily go &amp;ldquo;deeper&amp;rdquo; into the tree. If you&amp;rsquo;re doing expensive calculations while rendering, you can optimize them with &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20548fe21065f678631f41f93e7e5b0293cf3638" translate="yes" xml:space="preserve">
          <source>Note that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the rendered React elements, and for C2&amp;rsquo;s subtree and C7, it didn&amp;rsquo;t even have to compare the elements as we bailed out on &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and &lt;code&gt;render&lt;/code&gt; was not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5e25e3c06e2e0a9f837231ef8545ceec20aa21" translate="yes" xml:space="preserve">
          <source>Note that a HOC doesn&amp;rsquo;t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC &lt;em&gt;composes&lt;/em&gt; the original component by &lt;em&gt;wrapping&lt;/em&gt; it in a container component. A HOC is a pure function with zero side-effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e7b7a2953e10e5ee351f37db62af70ce535d29" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;aria-*&lt;/code&gt; HTML attributes are fully supported in JSX. Whereas most DOM properties and attributes in React are camelCased, these attributes should be hyphen-cased (also known as kebab-case, lisp-case, etc) as they are in plain HTML:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7624acea1a9c060576a9f15d678ecc769a9b76e6" translate="yes" xml:space="preserve">
          <source>Note that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c974944cb18d8a4b4d98d26cf2d4b75e73525b1b" translate="yes" xml:space="preserve">
          <source>Note that in the above example we &lt;strong&gt;need&lt;/strong&gt; to keep the function in the dependencies list. This ensures that a change in the &lt;code&gt;productId&lt;/code&gt; prop of &lt;code&gt;ProductPage&lt;/code&gt; automatically triggers a refetch in the &lt;code&gt;ProductDetails&lt;/code&gt; component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15064b1b66df67d34d5a232d98bfeba9ea33bea0" translate="yes" xml:space="preserve">
          <source>Note that rendering &lt;code&gt;lazy&lt;/code&gt; components requires that there&amp;rsquo;s a &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; component higher in the rendering tree. This is how you specify a loading indicator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca9869270c610c84eca37a4188271b709cfb625" translate="yes" xml:space="preserve">
          <source>Note that styles are not autoprefixed. To support older browsers, you need to supply corresponding style properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067b30a981f559502026a96e0fc3941571707473" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;read()&lt;/code&gt; call in this example doesn&amp;rsquo;t &lt;em&gt;start&lt;/em&gt; fetching. It only tries to read the data that is &lt;strong&gt;already being fetched&lt;/strong&gt;. This difference is crucial to creating fast applications with Suspense. We don&amp;rsquo;t want to delay loading data until a component starts rendering. As a data fetching library author, you can enforce this by making it impossible to get a &lt;code&gt;resource&lt;/code&gt; object without also starting a fetch. Every demo on this page using our &amp;ldquo;fake API&amp;rdquo; enforces this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2a771e4fad07ffb446c282efadcd2888cbe8e6" translate="yes" xml:space="preserve">
          <source>Note that the Coconut option is initially selected, because of the &lt;code&gt;selected&lt;/code&gt; attribute. React, instead of using this &lt;code&gt;selected&lt;/code&gt; attribute, uses a &lt;code&gt;value&lt;/code&gt; attribute on the root &lt;code&gt;select&lt;/code&gt; tag. This is more convenient in a controlled component because you only need to update it in one place. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5999130fbdfde82a85986a35fe0795798389c68" translate="yes" xml:space="preserve">
          <source>Note that the above example is demonstrating regular JavaScript behavior and doesn&amp;rsquo;t use error boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cff9e21e25a4670560f3ba3575f47b51bc9f0f" translate="yes" xml:space="preserve">
          <source>Note that the button doesn&amp;rsquo;t care &lt;em&gt;what&lt;/em&gt; state we&amp;rsquo;re updating. It&amp;rsquo;s wrapping &lt;em&gt;any&lt;/em&gt; state updates that happen during its &lt;code&gt;onClick&lt;/code&gt; handler into a transition. Now that our &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; takes care of setting up the transition, the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component doesn&amp;rsquo;t need to set up its own:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b6882327e1c317b3769b724af427c65f26d7de" translate="yes" xml:space="preserve">
          <source>Note that this approach won&amp;rsquo;t work in a loop because Hook calls &lt;a href=&quot;hooks-rules&quot;&gt;can&amp;rsquo;t&lt;/a&gt; be placed inside loops. But you can extract a separate component for the list item, and call &lt;code&gt;useMemo&lt;/code&gt; there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bb49079ffd95590ce09e3d67d7befe22d9e2ab" translate="yes" xml:space="preserve">
          <source>Note that this example is not meant to be exhaustive with regards to working with Backbone, but it should give you an idea for how to approach this in a generic way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41ae3592459d184c8cfe8a8c9a865858f7f5834" translate="yes" xml:space="preserve">
          <source>Note that this method is fired on &lt;em&gt;every&lt;/em&gt; render, regardless of the cause. This is in contrast to &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;, which only fires when the parent causes a re-render and not as a result of a local &lt;code&gt;setState&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293936fb383c744f2f9630271a7efb4989979625" translate="yes" xml:space="preserve">
          <source>Note that this only works if &lt;code&gt;CustomTextInput&lt;/code&gt; is declared as a class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6de8667681c14632896b78b9f59b00902732f9a" translate="yes" xml:space="preserve">
          <source>Note that we defined both &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt;. Many jQuery plugins attach event listeners to the DOM so it&amp;rsquo;s important to detach them in &lt;code&gt;componentWillUnmount&lt;/code&gt;. If the plugin does not provide a method for cleanup, you will probably have to provide your own, remembering to remove any event listeners the plugin registered to prevent memory leaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7bd878200c78bd50ee3d98b684ecb341171678" translate="yes" xml:space="preserve">
          <source>Note that we pass &lt;code&gt;[]&lt;/code&gt; as a dependency array to &lt;code&gt;useCallback&lt;/code&gt;. This ensures that our ref callback doesn&amp;rsquo;t change between the re-renders, and so React won&amp;rsquo;t call it unnecessarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3da62d793b8e6e725893da6d74020b9b0c1d282" translate="yes" xml:space="preserve">
          <source>Note that you can still choose whether to pass the application &lt;em&gt;state&lt;/em&gt; down as props (more explicit) or as context (more convenient for very deep updates). If you use context to pass down the state too, use two different context types &amp;mdash; the &lt;code&gt;dispatch&lt;/code&gt; context never changes, so components that read it don&amp;rsquo;t need to rerender unless they also need the application state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5438c62ee57f24fd4d0711d668e74ee64c6002c5" translate="yes" xml:space="preserve">
          <source>Note that you cannot call &lt;code&gt;this.setState()&lt;/code&gt; here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bcdc977b06fb5be1faf45e2966b7781759aee94" translate="yes" xml:space="preserve">
          <source>Note there are other statically typed languages that compile to JavaScript and are thus React compatible. For example, &lt;a href=&quot;https://fable.io/&quot;&gt;F#/Fable&lt;/a&gt; with &lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react&lt;/a&gt;. Check out their respective sites for more information, and feel free to add more statically typed languages that work with React to this page!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e9b4dc0a682c919374be737463c7b46bbd33ef" translate="yes" xml:space="preserve">
          <source>Note we passed a configuration object to &lt;code&gt;useTransition&lt;/code&gt;. Its &lt;code&gt;timeoutMs&lt;/code&gt; property specifies &lt;strong&gt;how long we&amp;rsquo;re willing to wait for the transition to finish&lt;/strong&gt;. By passing &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt;, we say &amp;ldquo;If the next profile takes more than 3 seconds to load, show the big spinner &amp;mdash; but before that timeout it&amp;rsquo;s okay to keep showing the previous screen&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="3d0510089477e2c3202ca52ed149fc2903a72e31" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bf57ef650f61bb6153e8d1ccb5545722813ea9" translate="yes" xml:space="preserve">
          <source>Notice how we wrapped &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; in an extra &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. This is necessary because Chosen will append another DOM element right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node we passed to it. However, as far as React is concerned, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; always only has a single child. This is how we ensure that React updates won&amp;rsquo;t conflict with the extra DOM node appended by Chosen. It is important that if you modify the DOM outside of React flow, you must ensure React doesn&amp;rsquo;t have a reason to touch those DOM nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4059c045862b5d2fc7b27115084fa8f80b3c32e" translate="yes" xml:space="preserve">
          <source>Notice how when you type into the input, the &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; component suspends, and we see the &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; fallback until we get fresh results. This is not ideal. It would be better if we could see the &lt;em&gt;previous&lt;/em&gt; translation for a bit while we&amp;rsquo;re fetching the next one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41a0eb10d6b00e47a2107e31a6fe602367acaa9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;this.state.value&lt;/code&gt; is initialized in the constructor, so that the text area starts off with some text in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48101c52bcbacc9cc53778eb2bf3edb99dccc8c" translate="yes" xml:space="preserve">
          <source>Notifying the user of errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c404d41fa7846adb181731741a44bd59410207d8" translate="yes" xml:space="preserve">
          <source>Now React knows that the element with key &lt;code&gt;'2014'&lt;/code&gt; is the new one, and the elements with the keys &lt;code&gt;'2015'&lt;/code&gt; and &lt;code&gt;'2016'&lt;/code&gt; have just moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a823d334901d2890efe56f8ef0b2a72eeceac120" translate="yes" xml:space="preserve">
          <source>Now consider the version of this component that uses Hooks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8183f56b4559e51b16e97bdcb7a1243573a8bd1d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say that our chat application also has a contact list, and we want to render names of online users with a green color. We could copy and paste similar logic above into our &lt;code&gt;FriendListItem&lt;/code&gt; component but it wouldn&amp;rsquo;t be ideal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925974ac4f4434d5e39f807c69d3762bcfdfc9e3" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say we want to write some logic that changes &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; when the user moves their mouse. Note how we have to merge these fields into the previous state object manually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4daa5c187fd27dc1d98689209a36560e567ee5" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can do the same with the &lt;code&gt;useEffect&lt;/code&gt; Hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0c36b18073d97246d1ae6fdd941d78bd84aa02" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can use our custom Hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff24b1ed7e4290e5868df543207689b4f4b743a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s turn to the &lt;code&gt;Calculator&lt;/code&gt; component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844b2d5f9df9b2eb6e433eb964cbaab4370de078" translate="yes" xml:space="preserve">
          <source>Now that we know more about effects, these lines should make sense:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0970d0ace9e4ccf49f5bb229273af5230ad8a4" translate="yes" xml:space="preserve">
          <source>Now that we know what the &lt;code&gt;useState&lt;/code&gt; Hook does, our example should make more sense:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8788b2f194e8402d2a42fc02e179198bb60d53" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted this logic to a &lt;code&gt;useFriendStatus&lt;/code&gt; hook, we can &lt;em&gt;just use it:&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad30db96883edc2b1c98cb238c68962796e03d5" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve identified the components in our mock, let&amp;rsquo;s arrange them into a hierarchy. Components that appear within another component in the mock should appear as a child in the hierarchy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb8a97af0340e1169bfb8c33de464ee1f6338c0" translate="yes" xml:space="preserve">
          <source>Now that you have your component hierarchy, it&amp;rsquo;s time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It&amp;rsquo;s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We&amp;rsquo;ll see why.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ab459928ce6ebd5489677a0e93ec9929ee70a3" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component encapsulates all behavior associated with listening for &lt;code&gt;mousemove&lt;/code&gt; events and storing the (x, y) position of the cursor, but it&amp;rsquo;s not yet truly reusable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8290d2b0cd763be0c1cff68b5b8f6a2022e9e2e1" translate="yes" xml:space="preserve">
          <source>Now the clock ticks every second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445b4c42d80c61abe526efe3707111a846581295" translate="yes" xml:space="preserve">
          <source>Now the question is: How can we reuse this behavior in another component? In other words, if another component needs to know about the cursor position, can we encapsulate that behavior so that we can easily share it with that component?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1024ae8f19583bac76078bc0bd6540db20a2ec73" translate="yes" xml:space="preserve">
          <source>Now the subscription will only be recreated when &lt;code&gt;props.source&lt;/code&gt; changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d03c366729e2d81c1e64f36f6b07756f996b09" translate="yes" xml:space="preserve">
          <source>Now typing has a lot less stutter &amp;mdash; although we pay for this by showing the results with a lag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc5b4606d16f6fd9f79e37463ac776146ee84f2" translate="yes" xml:space="preserve">
          <source>Now we can use it from both components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb51804f6cb1c7460d60f186cd080f9b9a70bf5" translate="yes" xml:space="preserve">
          <source>Now we could use it in our component, and let the reducer drive its state management:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe952474b56ef3cb4e5c17adcf45971d3250970" translate="yes" xml:space="preserve">
          <source>Now you can use JSX in any &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag by adding &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attribute to it. Here is &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;an example HTML file with JSX&lt;/a&gt; that you can download and play with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad6204428141993d5d0c80a5aa20caa71f41e56" translate="yes" xml:space="preserve">
          <source>Now you know what Concurrent Mode is all about!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0921c0c4a9937c51a84cd82cfb41ca7387c23e1" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;re all set! We recommend to check out the following resources to learn more about Flow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a49e11731f8fb793b2ecb4306067e3e3083ea67" translate="yes" xml:space="preserve">
          <source>Now, add &lt;code&gt;flow&lt;/code&gt; to the &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; section of your &lt;code&gt;package.json&lt;/code&gt; to be able to use this from the terminal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8086f34489af74ae217e4df5aa3be615d57812e" translate="yes" xml:space="preserve">
          <source>Now, instead of effectively cloning the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component and hard-coding something else in its &lt;code&gt;render&lt;/code&gt; method to solve for a specific use case, we provide a &lt;code&gt;render&lt;/code&gt; prop that &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; can use to dynamically determine what it renders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f73936a74018552ceacc64aa326e02fb6cf0a5b" translate="yes" xml:space="preserve">
          <source>Now, no matter which input you edit, &lt;code&gt;this.state.temperature&lt;/code&gt; and &lt;code&gt;this.state.scale&lt;/code&gt; in the &lt;code&gt;Calculator&lt;/code&gt; get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301eea1e7c8206fb45c541acd3e524bf4a699d97" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;setInterval&lt;/code&gt; callback executes once a second, but each time the inner call to &lt;code&gt;setCount&lt;/code&gt; can use an up-to-date value for &lt;code&gt;count&lt;/code&gt; (called &lt;code&gt;c&lt;/code&gt; in the callback here.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8130cbd3e360ebc980c05ecf896eace815977b" translate="yes" xml:space="preserve">
          <source>Now, this feels a lot better! When we click Next, it gets disabled because clicking it multiple times doesn&amp;rsquo;t make sense. And the new &amp;ldquo;Loading&amp;hellip;&amp;rdquo; tells the user that the app didn&amp;rsquo;t freeze.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f788b2b09588e404d0447b39bd5c7c761184f0" translate="yes" xml:space="preserve">
          <source>Now, when the &lt;code&gt;TemperatureInput&lt;/code&gt; wants to update its temperature, it calls &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7446f170a663a7c78e802aab1ac1a7cb9040dd" translate="yes" xml:space="preserve">
          <source>OK, so we&amp;rsquo;ve identified what the minimal set of app state is. Next, we need to identify which component mutates, or &lt;em&gt;owns&lt;/em&gt;, this state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585a7418eed63f477ec8bd53089988cc7e4a12c6" translate="yes" xml:space="preserve">
          <source>Of course, application UIs are dynamic and change over time. In the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next section&lt;/a&gt;, we will introduce a new concept of &amp;ldquo;state&amp;rdquo;. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3132cb0b79eb69074dc3e62af86660efd5589630" translate="yes" xml:space="preserve">
          <source>Of course, this is possible to fix in this particular example. We could remove the &lt;code&gt;Promise.all()&lt;/code&gt; call, and wait for both Promises separately. However, this approach gets progressively more difficult as the complexity of our data and component tree grows. It&amp;rsquo;s hard to write reliable components when arbitrary parts of the data tree may be missing or stale. So fetching all data for the new screen and &lt;em&gt;then&lt;/em&gt; rendering is often a more practical option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a2711c46e947081b52625c85320ddf4541e19b" translate="yes" xml:space="preserve">
          <source>Of course, two versions of the tree rendering &lt;em&gt;at the same time&lt;/em&gt; is an illusion, just like the idea that all programs run on your computer at the same time is an illusion. An operating system switches between different applications very fast. Similarly, React can switch between the version of the tree you see on the screen and the version that it&amp;rsquo;s &amp;ldquo;preparing&amp;rdquo; to show next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6825e0a32d926930eddf56f84b2970fa58fb08" translate="yes" xml:space="preserve">
          <source>Of the many options, we&amp;rsquo;ll look at &lt;code&gt;rootDir&lt;/code&gt; and &lt;code&gt;outDir&lt;/code&gt;. In its true fashion, the compiler will take in typescript files and generate javascript files. However we don&amp;rsquo;t want to get confused with our source files and the generated output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd20357e3644302dde97b2ad62dcb95ce1daedfd" translate="yes" xml:space="preserve">
          <source>Often, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to &lt;code&gt;useEffect&lt;/code&gt; may return a clean-up function. For example, to create a subscription:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb2d11868ae24a92e334900c6ad022490e23cc8" translate="yes" xml:space="preserve">
          <source>Often, render props and higher-order components render only a single child. We think Hooks are a simpler way to serve this use case. There is still a place for both patterns (for example, a virtual scroller component might have a &lt;code&gt;renderItem&lt;/code&gt; prop, or a visual container component might have its own DOM structure). But in most cases, Hooks will be sufficient and can help reduce nesting in your tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e238d62aafad5d06561c0c307e341349b7b49d0a" translate="yes" xml:space="preserve">
          <source>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let&amp;rsquo;s see how this works in action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a50db4683ea185c93852b3e2a65a8212128837a" translate="yes" xml:space="preserve">
          <source>On Node.js, runners like Jest &lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;support mocking modules&lt;/a&gt;. You could also use libraries like &lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt;&lt;code&gt;mock-require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0710c7b04d45a11f0492b116459fb4abc9eedba3" translate="yes" xml:space="preserve">
          <source>On mount, add a change listener to &lt;code&gt;DataSource&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c91bbc6306c5630c222b9dcf2187c2dc2ae099" translate="yes" xml:space="preserve">
          <source>On the next pages, you&amp;rsquo;ll learn more details about specific topics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d62e4f730620eef1f3de85e2d6c3131a9b4dfea" translate="yes" xml:space="preserve">
          <source>On this page we&amp;rsquo;ve learned about one of the Hooks provided by React, called &lt;code&gt;useState&lt;/code&gt;. We&amp;rsquo;re also sometimes going to refer to it as the &amp;ldquo;State Hook&amp;rdquo;. It lets us add local state to React function components &amp;mdash; which we did for the first time ever!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2cd7a4d0e65ff37df2b337e658e2df9075d64a" translate="yes" xml:space="preserve">
          <source>On this page, we don&amp;rsquo;t assume knowledge of Relay, so we won&amp;rsquo;t be using it for this example. Instead, we&amp;rsquo;ll write something similar manually by combining our data fetching methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb59abe30c04acfe966b6c95ce457faf73c79f0f" translate="yes" xml:space="preserve">
          <source>On this page, we will primarily use function components. However, these testing strategies don&amp;rsquo;t depend on implementation details, and work just as well for class components too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9354d5334212c4fa7c510917e4a36aa72a9176" translate="yes" xml:space="preserve">
          <source>On unmount, remove the change listener.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06dfbc05cf68b1af9ef7e3eb0c666319a41ff504" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re comfortable with the &lt;a href=&quot;index&quot;&gt;main concepts&lt;/a&gt; and played with React a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used React features like &lt;a href=&quot;context&quot;&gt;context&lt;/a&gt; and &lt;a href=&quot;refs-and-the-dom&quot;&gt;refs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26db98adea48b68a169ca2de0e843e2459313e88" translate="yes" xml:space="preserve">
          <source>One caveat is that some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;&amp;ldquo;falsy&amp;rdquo; values&lt;/a&gt;, such as the &lt;code&gt;0&lt;/code&gt; number, are still rendered by React. For example, this code will not behave as you might expect because &lt;code&gt;0&lt;/code&gt; will be printed when &lt;code&gt;props.messages&lt;/code&gt; is an empty array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d29f167487a4fbbd927e887cecef3d212e829f" translate="yes" xml:space="preserve">
          <source>One common confusion is that Web Components use &amp;ldquo;class&amp;rdquo; instead of &amp;ldquo;className&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84c92ddc298e496ea4adc3bf91cf1363cd458a5" translate="yes" xml:space="preserve">
          <source>One common use case is a component wanting to update itself on a time interval. It&amp;rsquo;s easy to use &lt;code&gt;setInterval()&lt;/code&gt;, but it&amp;rsquo;s important to cancel your interval when you don&amp;rsquo;t need it anymore to save memory. React provides &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; that let you know when a component is about to be created or destroyed. Let&amp;rsquo;s create a simple mixin that uses these methods to provide an easy &lt;code&gt;setInterval()&lt;/code&gt; function that will automatically get cleaned up when your component is destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fca79071097d684ed292ccb8f4ce6e063eb595" translate="yes" xml:space="preserve">
          <source>One common way to structure projects is locate CSS, JS, and tests together inside folders grouped by feature or route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3294950b9d1114486b86edac639fe247ba41031e" translate="yes" xml:space="preserve">
          <source>One interesting thing to note about render props is that you can implement most &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (HOC) using a regular component with a render prop. For example, if you would prefer to have a &lt;code&gt;withMouse&lt;/code&gt; HOC instead of a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, you could easily create one using a regular &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a render prop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bb7b23e1cfb796ff7ccb3c5631654a6d5d4429" translate="yes" xml:space="preserve">
          <source>One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. We will introduce components in the &lt;a href=&quot;components-and-props&quot;&gt;next section&lt;/a&gt;. Elements are what components are &amp;ldquo;made of&amp;rdquo;, and we encourage you to read this section before jumping ahead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7588b233fbe6695c0a65bfe0ca7544cc4e57a4ac" translate="yes" xml:space="preserve">
          <source>One might think that this is a problem specific to &lt;code&gt;useEffect&lt;/code&gt; or Hooks. Maybe if we port this code to classes or use convenient syntax like &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;, it will solve the problem?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f348c5b745ab1da4b86972cf956fe2d397217e" translate="yes" xml:space="preserve">
          <source>One of the many great parts of React is how it makes you think about apps as you build them. In this document, we&amp;rsquo;ll walk you through the thought process of building a searchable product data table using React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac2374e3473c6ff21b1231d986c7761ceb4980d" translate="yes" xml:space="preserve">
          <source>One of the problems we outlined in the &lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;Motivation&lt;/a&gt; for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a418baabb2a2970b5f712a2f3fec059c69ada5c1" translate="yes" xml:space="preserve">
          <source>One possible solution to this is to &lt;em&gt;delay the spinner itself&lt;/em&gt; from displaying:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b271b0f7d1b61e9056e53697bfa59e66ec53dabf" translate="yes" xml:space="preserve">
          <source>One rudimentary way to measure the position or size of a DOM node is to use a &lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;callback ref&lt;/a&gt;. React will call that callback whenever the ref gets attached to a different node. Here is a &lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;small demo&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa8706f6009f63753c15a5df17eaaa0d7f204a0" translate="yes" xml:space="preserve">
          <source>One solution to this is to extract the model&amp;rsquo;s attributes as plain data whenever it changes, and keep this logic in a single place. The following is &lt;a href=&quot;higher-order-components&quot;&gt;a higher-order component&lt;/a&gt; that extracts all attributes of a Backbone model into state, passing the data to the wrapped component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b79eb7fa7ae8bb13eed6fa689b5ce8ed867366" translate="yes" xml:space="preserve">
          <source>One way to solve this issue &lt;strong&gt;without context&lt;/strong&gt; is to &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;pass down the &lt;code&gt;Avatar&lt;/code&gt; component itself&lt;/a&gt; so that the intermediate components don&amp;rsquo;t need to know about the &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;avatarSize&lt;/code&gt; props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6299e6ee53c4fc7bdfb602433272b7a519918fc" translate="yes" xml:space="preserve">
          <source>One way we could fix it is by putting them both in a single boundary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05b9709100b2a39470a0603a95728131ccfa2e0" translate="yes" xml:space="preserve">
          <source>Online Playgrounds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c313b91ba43cdce9e6230021dd3cc44332356e" translate="yes" xml:space="preserve">
          <source>Only Call Hooks at the Top Level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980e73ef860f23909c36445661b606d8b3e93697" translate="yes" xml:space="preserve">
          <source>Only Call Hooks from React Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acf9b36b7f149f65b12a00c58b688239df37660" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;at the top level&lt;/strong&gt;. Don&amp;rsquo;t call Hooks inside loops, conditions, or nested functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bacc2bc0cd7f69fa0df071e2e600234a8896fe" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;from React function components&lt;/strong&gt;. Don&amp;rsquo;t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks &amp;mdash; your own custom Hooks. We&amp;rsquo;ll learn about them in a moment.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f87a20c05bef10c0fc20bc0609245bc0128bed" translate="yes" xml:space="preserve">
          <source>Only do this if you couldn&amp;rsquo;t find a better alternative, as relying on mutation makes components less predictable. If there&amp;rsquo;s a specific pattern that doesn&amp;rsquo;t translate well, &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;file an issue&lt;/a&gt; with a runnable example code and we can try to help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28575a6029fc70e57860e000b695cc6f0b3e57e" translate="yes" xml:space="preserve">
          <source>Only ever use CSS that removes this outline, for example by setting &lt;code&gt;outline: 0&lt;/code&gt;, if you are replacing it with another focus outline implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7322dbc7cc37c39174edd21f985b523446462851" translate="yes" xml:space="preserve">
          <source>Only use error boundaries for recovering from unexpected exceptions; &lt;strong&gt;don&amp;rsquo;t try to use them for control flow.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1b25a5af502c4955acf005be6d083dc1a30602" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;this example&lt;/a&gt;. When you press a button, you&amp;rsquo;ll see the Pending state for a second before moving on. This transition feels nice and fluid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82faec880ab06096a12df754c31b316dbff6580b" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;this example&lt;/a&gt; and click &amp;ldquo;Open Profile&amp;rdquo;. You will see several visual states one by one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f911658ce7d859922d5257b0b036abe5292fca9b" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;this starter code&lt;/a&gt;&lt;/strong&gt; and paste it into the file you created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d9ece27ec32d8829711be1a1d3afea9c2dafd2" translate="yes" xml:space="preserve">
          <source>Open the Chrome DevTools &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;Performance&lt;/a&gt;&lt;/strong&gt; tab and press &lt;strong&gt;Record&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45e17e011c01ffe2a91ced4f7a209475dd8d2a0" translate="yes" xml:space="preserve">
          <source>Optimizing Performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db92a3f80d780ad79d58ccf80d95c08e0583866f" translate="yes" xml:space="preserve">
          <source>Optimizing the output for production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebed446427427efeada77fb1de8555c343d3531f" translate="yes" xml:space="preserve">
          <source>Opting into Concurrent Mode introduces semantic changes to how React works. This means that you can&amp;rsquo;t use Concurrent Mode in just a few components. Because of this, some apps may not be able to migrate directly to Concurrent Mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6793ee41543d3424f0cf56f0cf4f4c5c5d0813" translate="yes" xml:space="preserve">
          <source>Optional: &lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;Download the full example (2KB zipped)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3267798d0259e5dd98aa26c31e33223e26cac3" translate="yes" xml:space="preserve">
          <source>Optional: Try React with JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a09e35972dfc007bcd7aa10e05cf800743e8354" translate="yes" xml:space="preserve">
          <source>Or yarn:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160496746ed70b43025c17e2f2433373eef18b6a" translate="yes" xml:space="preserve">
          <source>Other APIs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b361bfb2d40f2fa584dfe16d7abd56931268577" translate="yes" xml:space="preserve">
          <source>Other Build Setups</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718591843f9ba65a328acf7e21cfb68fa2042427" translate="yes" xml:space="preserve">
          <source>Other Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456d2677e518e26ef0d24a4e5e0c50a00c1e8bbd" translate="yes" xml:space="preserve">
          <source>Other Languages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1866d3283a2c6b4f31b7bd94d302109ad919e6f" translate="yes" xml:space="preserve">
          <source>Other Patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670876f3113d937960727ed05a2f82e686590502" translate="yes" xml:space="preserve">
          <source>Other Points for Consideration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8298a228f42e1a844433af47c0c496b7ae9065b" translate="yes" xml:space="preserve">
          <source>Other Screen Readers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a3346524b28d21d18a28316c1731fc127a349f" translate="yes" xml:space="preserve">
          <source>Other Utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4715125742dd4e459dcb1cbb3b644f3692b0c443" translate="yes" xml:space="preserve">
          <source>Other approaches to this, such as composing Promises in a special way, are increasingly difficult to pull off when the loading states are located in different components down the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17f43760c19635a2cfeb450e22843e0fca3cca3" translate="yes" xml:space="preserve">
          <source>Other effects might not have a cleanup phase, and don&amp;rsquo;t return anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe0a2f2b6a088b22020eedfca1f8171b23b1b2a" translate="yes" xml:space="preserve">
          <source>Other libraries might support hooks in the future too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb1c9f1eb4ca77b950c7272aaa7baca69202c49" translate="yes" xml:space="preserve">
          <source>Our &amp;ldquo;Next&amp;rdquo; button click handler sets the state that switches the current profile in the state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d512d8960f76b07e5be884686cf1a1860c585e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Button&lt;/code&gt; component will immediately show the Pending state indicator on click:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5564b57b9c8ed5194280102aa6b272b6ace8690e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Welcome&lt;/code&gt; component returns a &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; element as the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e602677bd730cb72e7da761f1b1f89e01b70c7" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;useTransition()&lt;/code&gt; call returns two values: &lt;code&gt;startTransition&lt;/code&gt; and &lt;code&gt;isPending&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96521a8515cede856d54400c09ad380c0daf2e3" translate="yes" xml:space="preserve">
          <source>Our JSON API returns some data that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef855825370735f30744e8e204330946ef7b36c" translate="yes" xml:space="preserve">
          <source>Our React applications continuously modify the HTML DOM during runtime, sometimes leading to keyboard focus being lost or set to an unexpected element. In order to repair this, we need to programmatically nudge the keyboard focus in the right direction. For example, by resetting keyboard focus to a button that opened a modal window after that modal window is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74299bea00c013faee08bac03735a9e8eb9da361" translate="yes" xml:space="preserve">
          <source>Our first attempt might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfdb46afa859b90b54e6db2005a9424a33bafd62" translate="yes" xml:space="preserve">
          <source>Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7bdd68f3093bdd85231792c356d3a08261c101" translate="yes" xml:space="preserve">
          <source>Our new example starts by importing the &lt;code&gt;useState&lt;/code&gt; Hook from React:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc98859f39fc7662d2321203db3a057fbfc1f78" translate="yes" xml:space="preserve">
          <source>Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbaf73bc5cb4adf782290fa0e9328bf03a93107" translate="yes" xml:space="preserve">
          <source>Our old experiments with functional APIs in the &lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt; repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecead6fae262a6840fa100e15a353465a381857e" translate="yes" xml:space="preserve">
          <source>Over a million developers use React, collectively maintaining millions of components. The Facebook codebase alone has over 50,000 React components. That means we need to make it as easy as possible to upgrade to new versions of React; if we make large changes without a migration path, people will be stuck on old versions. We test these upgrade paths on Facebook itself &amp;ndash; if our team of less than 10 people can update 50,000+ components alone, we hope the upgrade will be manageable for anyone using React. In many cases, we write &lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;automated scripts&lt;/a&gt; to upgrade component syntax, which we then include in the open-source release for everyone to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ee80037726319e2173c25a2b8a820cdf39330c" translate="yes" xml:space="preserve">
          <source>Over the next several months, many libraries will appear with different takes on Suspense APIs. &lt;strong&gt;If you prefer to learn when things are more stable, you might prefer to ignore this work for now, and come back when the Suspense ecosystem is more mature.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b00a214a218165c819825f50d811fd28c59d9c" translate="yes" xml:space="preserve">
          <source>Overall, this makes it so that &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; all work very similarly - they all accept a &lt;code&gt;value&lt;/code&gt; attribute that you can use to implement a controlled component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="ac6ae6a452c9a133b258c63f82756651e2997eaf" translate="yes" xml:space="preserve">
          <source>Package Managers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ec6193c88aaa60a810f707fb624f400dab682a" translate="yes" xml:space="preserve">
          <source>Package managers are tools that allow you to manage dependencies in your project. &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; are two package managers commonly used in React applications. Both of them are clients for the same npm package registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dca5f8363324ed0f27645a7b9839654bdd31f45" translate="yes" xml:space="preserve">
          <source>Parent-Child Coupling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bd5e09f1e5e3ba47a58c7db16fad72304e43c8" translate="yes" xml:space="preserve">
          <source>Pass a &amp;ldquo;create&amp;rdquo; function and an array of dependencies. &lt;code&gt;useMemo&lt;/code&gt; will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd926194677835b376654a809999d830104e7b63" translate="yes" xml:space="preserve">
          <source>Pass a function instead of an object to &lt;code&gt;setState&lt;/code&gt; to ensure the call always uses the most updated version of state (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2780570791c9ee7131760cf13185af6586f6a67f" translate="yes" xml:space="preserve">
          <source>Pass a mocked component module to this method to augment it with useful methods that allow it to be used as a dummy React component. Instead of rendering as usual, the component will become a simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (or other tag if &lt;code&gt;mockTagName&lt;/code&gt; is provided) containing any provided children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdde832b0e4e25e7efa528b27f908118f6bfa769" translate="yes" xml:space="preserve">
          <source>Pass a string as the &lt;code&gt;className&lt;/code&gt; prop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534c9e580a2811b44edf2a15e3bc0f460c0a7212" translate="yes" xml:space="preserve">
          <source>Pass an inline callback and an array of dependencies. &lt;code&gt;useCallback&lt;/code&gt; will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. &lt;code&gt;shouldComponentUpdate&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1ecfde360ca670c99a034b3467938615912d18" translate="yes" xml:space="preserve">
          <source>Pass event handlers and other functions as props to child components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7977cb8dad2d6673088b4722d378da8582b6ab23" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Event Handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7731b6038ead3e4f42010f183a92cc0e8e663535" translate="yes" xml:space="preserve">
          <source>Passing Functions to Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c211ae4a2b3b47216fe468fbd82f27983e4011" translate="yes" xml:space="preserve">
          <source>Passing an update function allows you to access the current state value inside the updater. Since &lt;code&gt;setState&lt;/code&gt; calls are batched, this lets you chain updates and ensure they build on top of each other instead of conflicting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6194136e1fc05bb75b0051025e3237f9608a70" translate="yes" xml:space="preserve">
          <source>People come to React from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you&amp;rsquo;ll find this section helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a454c4946afe6de8abb7a71c3c543078037ceb08" translate="yes" xml:space="preserve">
          <source>Perform the actions you want to profile. Don&amp;rsquo;t record more than 20 seconds or Chrome might hang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1456888f4e0889c6c1362473e30e3fb8f16a2193" translate="yes" xml:space="preserve">
          <source>Performance Optimizations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe33e97d445c1aa01afdea12de2c8a6bf6ef536" translate="yes" xml:space="preserve">
          <source>Phew, that was fast! If some things didn&amp;rsquo;t quite make sense or you&amp;rsquo;d like to learn more in detail, you can read the next pages, starting with the &lt;a href=&quot;hooks-state&quot;&gt;State Hook&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649b0aad2e87bf224c37505fbd45954d6ae44866" translate="yes" xml:space="preserve">
          <source>Play a bit more with the &lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;demo&lt;/a&gt;, and try to imagine it happening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22243b7987a499744ba5d18f9114f54c25fe1f4" translate="yes" xml:space="preserve">
          <source>Please note that browser / screen reader combinations matter. It is recommended that you test your application in the browser best suited to your screen reader of choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61307201646dc8a1687dacab76a450772d3c680" translate="yes" xml:space="preserve">
          <source>Please note that the syntax above is &lt;strong&gt;experimental&lt;/strong&gt; and the syntax may change, or the proposal might not make it into the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84c3942bb67e056a4c3f6552e902c1c6de812f7" translate="yes" xml:space="preserve">
          <source>Pointer Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c36c348e5c25ede527a987ca5d7e15ef86c339" translate="yes" xml:space="preserve">
          <source>Pointer events are not yet supported in every browser (at the time of writing this article, supported browsers include: Chrome, Firefox, Edge, and Internet Explorer). React deliberately does not polyfill support for other browsers because a standard-conform polyfill would significantly increase the bundle size of &lt;code&gt;react-dom&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c88242e813893ab8ad50b7e16808768f9baafb" translate="yes" xml:space="preserve">
          <source>Portals</source>
          <target state="translated">Portals</target>
        </trans-unit>
        <trans-unit id="4b918b44974a1664555fe8092f41a8a9c3c7132e" translate="yes" xml:space="preserve">
          <source>Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029998f5e0e501dc2ec70d705846fadf01f5078f" translate="yes" xml:space="preserve">
          <source>Practical Tutorial</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da325394f7b2561f269c38b5353a62787615dc5" translate="yes" xml:space="preserve">
          <source>Prefer the standard &lt;code&gt;useEffect&lt;/code&gt; when possible to avoid blocking visual updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cfce24dccded60294e74f312a7bb64c4e35de4" translate="yes" xml:space="preserve">
          <source>Preferred: Pending &amp;rarr; Skeleton &amp;rarr; Complete</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1323678aee55ea7816c8e30aa6f1bdb912fb64" translate="yes" xml:space="preserve">
          <source>Press &amp;ldquo;Next&amp;rdquo; a few times. Notice it already feels very different. &lt;strong&gt;Instead of immediately seeing an empty screen on click, we now keep seeing the previous page for a while.&lt;/strong&gt; When the data has loaded, React transitions us to the new screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2165e905ee1367c14a6f33243da7d43b8b7584" translate="yes" xml:space="preserve">
          <source>Preventing Component from Rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efe0b4e061393bdaf49e8a579601b4bd4ce78de" translate="yes" xml:space="preserve">
          <source>Previously, React provided two ways for managing refs: the legacy string ref API and the callback API. Although the string ref API was the more convenient of the two, it had &lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;several downsides&lt;/a&gt; and so our official recommendation was to &lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;use the callback form instead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f508d98b08c23e21ae8ba502e34faaa9bf61dd9" translate="yes" xml:space="preserve">
          <source>Previously, we only encountered React elements that represent DOM tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886739715565d2665d39c8366ec2d10dc344405d" translate="yes" xml:space="preserve">
          <source>Priority-based Rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2e2459a0759f7d2b3b0d9811210079874a39cc" translate="yes" xml:space="preserve">
          <source>Profiler API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f47591c38d90876e84e5a679c6dc16b4b65918a" translate="yes" xml:space="preserve">
          <source>Profiling Components with the Chrome Performance Tab</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9edfd9d87db8eb1b7c2fee04f3c7d3c4f51081d" translate="yes" xml:space="preserve">
          <source>Profiling Components with the DevTools Profiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e01723f7448dcb8aa35875d9f81ee04d125e7e" translate="yes" xml:space="preserve">
          <source>Profiling adds some additional overhead, so &lt;strong&gt;it is disabled in &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;the production build&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a865967da74c8436b8d176a76b2002d968e98151" translate="yes" xml:space="preserve">
          <source>Programmatically managing focus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86cd3058a8d5775df18dce4ea57b680ca5e164b6" translate="yes" xml:space="preserve">
          <source>Progressive Hydration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="351f56a6fefd5127c90506d3e91990f1d7631787" translate="yes" xml:space="preserve">
          <source>Properties:</source>
          <target state="translated">Properties:</target>
        </trans-unit>
        <trans-unit id="2187830d82c3a1f4829ffcf9703990399389ecd1" translate="yes" xml:space="preserve">
          <source>Props Default to &amp;ldquo;True&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2d9ce6b30a5f9172862e1e2a2103f1545aae76" translate="yes" xml:space="preserve">
          <source>Props and composition give you all the flexibility you need to customize a component&amp;rsquo;s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78feac20bb5fc62e7459d810b7135fef805d6854" translate="yes" xml:space="preserve">
          <source>Props are Read-Only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33f3c7f743fb12f6a11e786a2fcb6e13d6efcfa" translate="yes" xml:space="preserve">
          <source>Props in JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8dad475166c2eac08c646b3ebdf3559b8f22bb" translate="yes" xml:space="preserve">
          <source>Props vs State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef11665379e87b4432e89567d3144207597dde64" translate="yes" xml:space="preserve">
          <source>Provide a mechanism to allow users to skip past navigation sections in your application as this assists and speeds up keyboard navigation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65135d5ec4d5950c26be85cdc6405b0542ba4616" translate="yes" xml:space="preserve">
          <source>Putting Research into Production</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee9c42d60235c923278d5e44bad794e0fe45c13" translate="yes" xml:space="preserve">
          <source>Quickly Try JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723a59bfbd4916773b778eea25c500ba0e2055e2" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;componentDidUpdate&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ace34e863de930657650d2da4b04c7f1f377acc" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;useEffect&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c456dc6554aed5954e8c75d3fa6572cdb27a30f" translate="yes" xml:space="preserve">
          <source>Race Conditions with componentDidUpdate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42274756b2dc2c17eaeb7f294f21deef9e594667" translate="yes" xml:space="preserve">
          <source>Race Conditions with useEffect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a22b192ac2fa53d431f80c3ed1ab58049c5282b" translate="yes" xml:space="preserve">
          <source>Race conditions are bugs that happen due to incorrect assumptions about the order in which our code may run. Fetching data in the &lt;code&gt;useEffect&lt;/code&gt; Hook or in class lifecycle methods like &lt;code&gt;componentDidUpdate&lt;/code&gt; often leads to them. Suspense can help here, too &amp;mdash; let&amp;rsquo;s see how.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14755c296af9379808222382bdd6b5de345159dc" translate="yes" xml:space="preserve">
          <source>Rarely Used Lifecycle Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26dd7fe02a64876676c6cbd9aa8708f0a20b47f9" translate="yes" xml:space="preserve">
          <source>Re-render the in-memory tree with a new root element. This simulates a React update at the root. If the new element has the same type and key as the previous element, the tree will be updated; otherwise, it will re-mount a new tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="cec80c2bc8202e23af151e7f74a7ef7ace217cd9" translate="yes" xml:space="preserve">
          <source>React 15 included a very limited support for error boundaries under a different method name: &lt;code&gt;unstable_handleError&lt;/code&gt;. This method no longer works, and you will need to change it to &lt;code&gt;componentDidCatch&lt;/code&gt; in your code starting from the first 16 beta release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d738f325e7c19b6858708f27583b05cb0428fc2" translate="yes" xml:space="preserve">
          <source>React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1051bec19cd5874a397897a7f06cc6437c451c36" translate="yes" xml:space="preserve">
          <source>React 16 prints all errors that occurred during rendering to the console in development, even if the application accidentally swallows them. In addition to the error message and the JavaScript stack, it also provides component stack traces. Now you can see where exactly in the component tree the failure has happened:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e0407bcbcc67abd7c79d5c3bd2fcd47ad42dd9" translate="yes" xml:space="preserve">
          <source>React 16.3 added a third option that offers the convenience of a string ref without any of the downsides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c32dfc45304c45a68c84f0c0ee4c4f05460c24f" translate="yes" xml:space="preserve">
          <source>React 16.6 added a &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; component that lets you &amp;ldquo;wait&amp;rdquo; for some code to load and declaratively specify a loading state (like a spinner) while we&amp;rsquo;re waiting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b645cea94d9f5a02a027aeb84445527c67977cf7" translate="yes" xml:space="preserve">
          <source>React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2fa57c98aa2ff66a34e3804ba4afdbf43f949c" translate="yes" xml:space="preserve">
          <source>React &lt;a href=&quot;react-without-jsx&quot;&gt;doesn&amp;rsquo;t require&lt;/a&gt; using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56b4ec7d4044adf40d8ea846a837d5e5d0e2ec1" translate="yes" xml:space="preserve">
          <source>React DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e17312bf427154aa9521cc18565e992f954d046" translate="yes" xml:space="preserve">
          <source>React DOM Server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6783695eda495767c874d2c12b708f12b9eb5c68" translate="yes" xml:space="preserve">
          <source>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f543b7e06f16286089bf4be437499e1b43b727" translate="yes" xml:space="preserve">
          <source>React DOM efficiently updates the DOM to match &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdeb7ff15e5768ee7e11ab66cd7913eac488847" translate="yes" xml:space="preserve">
          <source>React DOM updates the DOM with the boiling verdict and to match the desired input values. The input we just edited receives its current value, and the other input is updated to the temperature after conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3e9e3b704e86ac0ae2261ed5ae0110bb475463" translate="yes" xml:space="preserve">
          <source>React DOM uses camelCase property naming convention instead of HTML attribute names. For example, &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;code&gt;tabIndex&lt;/code&gt; in JSX. The attribute &lt;code&gt;class&lt;/code&gt; is also written as &lt;code&gt;className&lt;/code&gt; since &lt;code&gt;class&lt;/code&gt; is a reserved word in JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f7152b69ea8b7e6f11fc24d5c27c7549c6acd1" translate="yes" xml:space="preserve">
          <source>React Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a01dc41ed1fa68614175afe8e165764d9609ab0" translate="yes" xml:space="preserve">
          <source>React Must Be in Scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c6dfc0e1dfdf3f794b802a1ba06278b93a1b13" translate="yes" xml:space="preserve">
          <source>React Only Updates What&amp;rsquo;s Necessary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3633a811906ebb40f86bdd77c315e1e2bde36321" translate="yes" xml:space="preserve">
          <source>React Redux since v7.1.0 &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;supports Hooks API&lt;/a&gt; and exposes hooks like &lt;code&gt;useDispatch&lt;/code&gt; or &lt;code&gt;useSelector&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb3fe34bf0fbac0db48c2c52246f7bf4643b58d" translate="yes" xml:space="preserve">
          <source>React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;supports hooks&lt;/a&gt; since v5.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db30dab9afce5ee17ad60f6815d45c7d2775403c" translate="yes" xml:space="preserve">
          <source>React Shallow Renderer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f752bd2488cbb706a191bae6c25ec360c9ae78" translate="yes" xml:space="preserve">
          <source>React Test Renderer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493a1a450ae702c6d46a164382378d365c88d431" translate="yes" xml:space="preserve">
          <source>React Testing Library offers a &lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;more concise helper&lt;/a&gt; for firing events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a37522e503e9a2cee5bb38180398e2a23e1f1f" translate="yes" xml:space="preserve">
          <source>React Top-Level API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e60d7618dece37120d3987205a0d2168962460f" translate="yes" xml:space="preserve">
          <source>React Without ES6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5884fb1f8e40d0ef6cbe86d6584a46690762e1" translate="yes" xml:space="preserve">
          <source>React Without JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe2f9ba8b44464b4bfefd199f9bc13307ee3332" translate="yes" xml:space="preserve">
          <source>React also depends on &lt;code&gt;requestAnimationFrame&lt;/code&gt; (even in test environments).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8f2b9666834dcad7e288b25fd8480664eaad61" translate="yes" xml:space="preserve">
          <source>React also supports another way to set refs called &amp;ldquo;callback refs&amp;rdquo;, which gives more fine-grain control over when refs are set and unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10225c998465dfe979466a99502e0be87e759457" translate="yes" xml:space="preserve">
          <source>React and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;Web Components&lt;/a&gt; are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary. As a developer, you are free to use React in your Web Components, or to use Web Components in React, or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27082daf4244e21a91a723f26657721dc905d29e" translate="yes" xml:space="preserve">
          <source>React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components. This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects. Sometimes it is referred to as a &amp;ldquo;virtual DOM&amp;rdquo;, but it works the same way on React Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610b64665a6a2f5e728c19e6eca03a8b39cdcf07" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Calculator&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method to learn what the UI should look like. The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba853d2a17e24f0bd22d89450b9557d4a2c11971" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Welcome&lt;/code&gt; component with &lt;code&gt;{name: 'Sara'}&lt;/code&gt; as the props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f2ebfc937521d2470061f7e3d9cde73833393e" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; method of the &lt;code&gt;BoilingVerdict&lt;/code&gt; component, passing the temperature in Celsius as its props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3922365ae8f20c0cd2b94600d6dd96e8199f37c" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; methods of the individual &lt;code&gt;TemperatureInput&lt;/code&gt; components with their new props specified by the &lt;code&gt;Calculator&lt;/code&gt;. It learns what their UI should look like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fdfacce7eedd6661f907c10f0f4ea9af876fce" translate="yes" xml:space="preserve">
          <source>React calls the function specified as &lt;code&gt;onChange&lt;/code&gt; on the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In our case, this is the &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8b2d2111896cb2314cfe1f0bde6a55efe40119" translate="yes" xml:space="preserve">
          <source>React can be embedded into other applications thanks to the flexibility of &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1330ed30fca80f90b213d9b6f69f3e0df6ecab7" translate="yes" xml:space="preserve">
          <source>React can be used in any web application. It can be embedded in other applications and, with a little care, other applications can be embedded in React. This guide will examine some of the more common use cases, focusing on integration with &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt;, but the same ideas can be applied to integrating components with any existing code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37e463c6f9b2a55b2880cfa9eafdf5e114306ed" translate="yes" xml:space="preserve">
          <source>React can be used to power animations. See &lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt; and &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt; or &lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Spring&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c793e68bb1fac249aba0ce5f3bec7e5d7023c434" translate="yes" xml:space="preserve">
          <source>React community&amp;rsquo;s experiments with render prop APIs, including &lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Ryan Florence&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/reactions/component&quot;&gt;Reactions Component&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27be082454b7d8bc7b1e13ab663caeb1f2c60981" translate="yes" xml:space="preserve">
          <source>React components are small, reusable pieces of code that return a React element to be rendered to the page. The simplest version of React component is a plain JavaScript function that returns a React element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48861e38df56656ab830494ad258a4d6191d07f5" translate="yes" xml:space="preserve">
          <source>React components can also be defined as functions which can be wrapped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4cc5817b2558aba649764feaed76c372dd8b626" translate="yes" xml:space="preserve">
          <source>React components have their own &amp;ldquo;lifecycle&amp;rdquo;. They may receive props or update state at any point in time. However, each asynchronous request &lt;em&gt;also&lt;/em&gt; has its own &amp;ldquo;lifecycle&amp;rdquo;. It starts when we kick it off, and finishes when we get a response. The difficulty we&amp;rsquo;re experiencing is &amp;ldquo;synchronizing&amp;rdquo; several processes in time that affect each other. This is hard to think about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4222b5a8657725e4a00728011e55a70511e28796" translate="yes" xml:space="preserve">
          <source>React components hide their implementation details, including their rendered output. Other components using &lt;code&gt;FancyButton&lt;/code&gt;&lt;strong&gt;usually will not need to&lt;/strong&gt;&lt;a href=&quot;refs-and-the-dom&quot;&gt;obtain a ref&lt;/a&gt; to the inner &lt;code&gt;button&lt;/code&gt; DOM element. This is good because it prevents components from relying on each other&amp;rsquo;s DOM structure too much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5817ef7548b0234e3521fa7650bb8ea6c27ada2e" translate="yes" xml:space="preserve">
          <source>React components let you split the UI into independent, reusable pieces, and think about each piece in isolation. React components can be defined by subclassing &lt;code&gt;React.Component&lt;/code&gt; or &lt;code&gt;React.PureComponent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8d82c06b82b483efb7cfed08df669ddf86929f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t call &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; with initial props during &lt;a href=&quot;#mounting&quot;&gt;mounting&lt;/a&gt;. It only calls this method if some of component&amp;rsquo;s props may update. Calling &lt;code&gt;this.setState()&lt;/code&gt; generally doesn&amp;rsquo;t trigger &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca31c5026bd08138666663526caeedbe15b5ea02" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t force you to use the ES6 class syntax. If you prefer to avoid it, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module or a similar custom abstraction instead. Take a look at &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b56919404ce18c573bf25676a77e3c0c3ec215" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t have opinions on how you put files into folders. That said there are a few common approaches popular in the ecosystem you may want to consider.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65aea3f2a5c31b29c9426cd1a03d900e3079061c" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle methods, the event handlers don&amp;rsquo;t happen during rendering. So if they throw, React still knows what to display on the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd4db2f190bce0d1cd19887d508e28c6fb7d62f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t offer a way to &amp;ldquo;attach&amp;rdquo; reusable behavior to a component (for example, connecting it to a store). If you&amp;rsquo;ve worked with React for a while, you may be familiar with patterns like &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow. If you look at a typical React application in React DevTools, you will likely find a &amp;ldquo;wrapper hell&amp;rdquo; of components surrounded by layers of providers, consumers, higher-order components, render props, and other abstractions. While we could &lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;filter them out in DevTools&lt;/a&gt;, this points to a deeper underlying problem: React needs a better primitive for sharing stateful logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78ca1328cbe2529b63f5cb261c75fa5b40138a1" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t use the &lt;code&gt;state = initialState&lt;/code&gt; argument convention popularized by Redux. The initial value sometimes needs to depend on props and so is specified from the Hook call instead. If you feel strongly about this, you can call &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; to emulate the Redux behavior, but it&amp;rsquo;s not encouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83294fcb3556b3e4c12f42b28d13fbaa61565e3" translate="yes" xml:space="preserve">
          <source>React elements are &lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;immutable&lt;/a&gt;. Once you create an element, you can&amp;rsquo;t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d7e53a8e0f9d5ea79b7f65c786e10e05c2fc30" translate="yes" xml:space="preserve">
          <source>React elements are the building blocks of React applications. One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. An element describes what you want to see on the screen. React elements are immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6524f58f9d8f8ab1fca2ad781736505d87a9d6ca" translate="yes" xml:space="preserve">
          <source>React elements like &lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; are just objects, so you can pass them as props like any other data. This approach may remind you of &amp;ldquo;slots&amp;rdquo; in other libraries but there are no limitations on what you can pass as props in React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d783a77ced1d87ae35cd28616b7b8dde4c0feec8" translate="yes" xml:space="preserve">
          <source>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
