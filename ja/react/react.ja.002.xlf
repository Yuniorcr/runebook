<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="d8de9356ec83d73b1f5bd25ff7148e61b4571f9a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; component that renders the image of a cat chasing the mouse around the screen. We might use a &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; prop to tell the component the coordinates of the mouse so it knows where to position the image on the screen.</source>
          <target state="translated">たとえば、画面上でマウスを追いかけている猫の画像をレンダリングする &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; コンポーネントがあるとします。我々が使用する可能性のある &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; それが知っているように、スクリーン上に画像を配置する場合にコンポーネントをマウスの座標を指示する小道具を。</target>
        </trans-unit>
        <trans-unit id="ba22bdb002e0f405abcc6c642198532d39f6bf7a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this &lt;code&gt;Counter&lt;/code&gt; component:</source>
          <target state="translated">たとえば、次の &lt;code&gt;Counter&lt;/code&gt; コンポーネントがあるとします。</target>
        </trans-unit>
        <trans-unit id="6f0a42e407f76b6421f57202e0a6b998a33eea86" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this counter component:</source>
          <target state="translated">たとえば、次のカウンタコンポーネントがあるとします。</target>
        </trans-unit>
        <trans-unit id="6829043516c2d5b5543372593d5ecc18cc4a4134" translate="yes" xml:space="preserve">
          <source>For example, maybe you have a complex component that contains a lot of local state that is managed in an ad-hoc way. &lt;code&gt;useState&lt;/code&gt; doesn&amp;rsquo;t make centralizing the update logic any easier so you might prefer to write it as a &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; reducer:</source>
          <target state="translated">たとえば、アドホックな方法で管理される多くのローカル状態を含む複雑なコンポーネントがあるとします。 &lt;code&gt;useState&lt;/code&gt; は、更新ロジックを一元化することを容易にするものではないため、&lt;a href=&quot;https://redux.js.org/&quot;&gt;Reduxの&lt;/a&gt;レデューサーとして記述した方がよい場合があります。</target>
        </trans-unit>
        <trans-unit id="e18ae5d39ecd3952c9cebace04d8ec7b3336fb23" translate="yes" xml:space="preserve">
          <source>For example, research shows that displaying too many intermediate loading states when transitioning between screens makes a transition feel &lt;em&gt;slower&lt;/em&gt;. This is why Concurrent Mode shows new loading states on a fixed &amp;ldquo;schedule&amp;rdquo; to avoid jarring and too frequent updates.</source>
          <target state="translated">たとえば、調査では、画面間の遷移時に中間の読み込み状態が多すぎると、遷移が&lt;em&gt;遅く&lt;/em&gt;感じられることが示されてい&lt;em&gt;ます&lt;/em&gt;。これが、不快で頻繁な更新を避けるために、コンカレントモードが固定の「スケジュール」で新しい読み込み状態を表示する理由です。</target>
        </trans-unit>
        <trans-unit id="78683415bcaad856b1ab7dfe02f23e05fa2ced55" translate="yes" xml:space="preserve">
          <source>For example, say you have a &lt;code&gt;CommentList&lt;/code&gt; component that subscribes to an external data source to render a list of comments:</source>
          <target state="translated">たとえば、外部データソースをサブスクライブしてコメントのリストをレンダリングする &lt;code&gt;CommentList&lt;/code&gt; コンポーネントがあるとします。</target>
        </trans-unit>
        <trans-unit id="1a1a629d470f55d2fee2000499a4cacbb9a4833a" translate="yes" xml:space="preserve">
          <source>For example, the HTML:</source>
          <target state="translated">例えば、HTML。</target>
        </trans-unit>
        <trans-unit id="6ba76674660b5e537e8b2cdd0ef1d5a91df770a7" translate="yes" xml:space="preserve">
          <source>For example, the following component tracks the mouse position in a web app:</source>
          <target state="translated">たとえば、次のコンポーネントは、Web アプリのマウスの位置を追跡します。</target>
        </trans-unit>
        <trans-unit id="e8f359161b98ba57290664f3cc1ede81cf753231" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as &amp;rdquo;&lt;em&gt;ForwardRef&lt;/em&gt;&amp;rdquo; in the DevTools:</source>
          <target state="translated">たとえば、次のコンポーネントはDevToolsで「&lt;em&gt;ForwardRef&lt;/em&gt;」として表示されます。</target>
        </trans-unit>
        <trans-unit id="5c4201bd25776812cd7bc0c469c68c4fbd842451" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as MyDisplayName in the DevTools:</source>
          <target state="translated">例えば、以下のコンポーネントは、DevToolsのMyDisplayNameとして表示されます。</target>
        </trans-unit>
        <trans-unit id="3069268548855f5d165876787923a3ea3d1da874" translate="yes" xml:space="preserve">
          <source>For example, this code accepts a single name in an uncontrolled component:</source>
          <target state="translated">例えば、このコードでは、制御されていないコンポーネント内の単一の名前を受け入れます。</target>
        </trans-unit>
        <trans-unit id="2c55286e50f3215379ff426fa48eb785d76df4a7" translate="yes" xml:space="preserve">
          <source>For example, this code may fail to update the counter:</source>
          <target state="translated">例えば、このコードはカウンタの更新に失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0ccc1009af6f8f6328943760f3255e5b65c01689" translate="yes" xml:space="preserve">
          <source>For example, this code renders &amp;ldquo;Hello, Sara&amp;rdquo; on the page:</source>
          <target state="translated">たとえば、次のコードはページに「Hello、Sara」をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="c3a55dc4cb118bd5e2852ddf3c6b69f2d61b25ed" translate="yes" xml:space="preserve">
          <source>For example, this code will not run as expected:</source>
          <target state="translated">例えば、このコードは期待通りには実行されません。</target>
        </trans-unit>
        <trans-unit id="8e989a1227816ccbcfdce9a1ef1f8646c7fe3950" translate="yes" xml:space="preserve">
          <source>For example, this code written with JSX:</source>
          <target state="translated">例えば、JSXで書かれたこのコード。</target>
        </trans-unit>
        <trans-unit id="f04fad3363acf285dbccbb82a73f5be8eb678633" translate="yes" xml:space="preserve">
          <source>For example, this component sets the document title after React updates the DOM:</source>
          <target state="translated">例えば、このコンポーネントは、ReactがDOMを更新した後にドキュメントのタイトルを設定します。</target>
        </trans-unit>
        <trans-unit id="7884e8e4fb1aae5ecf12d8317e1f6d9f4593fec2" translate="yes" xml:space="preserve">
          <source>For example, this will not re-render a component:</source>
          <target state="translated">例えば、これはコンポーネントを再レンダリングしません。</target>
        </trans-unit>
        <trans-unit id="20851a45788a2fdc02ea529e15ac7f8112f9de05" translate="yes" xml:space="preserve">
          <source>For example, to profile a &lt;code&gt;Navigation&lt;/code&gt; component and its descendants:</source>
          <target state="translated">たとえば、 &lt;code&gt;Navigation&lt;/code&gt; コンポーネントとその子孫のプロファイルを作成するには：</target>
        </trans-unit>
        <trans-unit id="d13080b59ca5d53e0ba7b314b267e9b38197f049" translate="yes" xml:space="preserve">
          <source>For example, we can create an &lt;code&gt;App&lt;/code&gt; component that renders &lt;code&gt;Welcome&lt;/code&gt; many times:</source>
          <target state="translated">たとえば、 &lt;code&gt;Welcome&lt;/code&gt; を何度もレンダリングする &lt;code&gt;App&lt;/code&gt; コンポーネントを作成できます。</target>
        </trans-unit>
        <trans-unit id="f1ead1eab1f84507539e34706446448f0d28e9f5" translate="yes" xml:space="preserve">
          <source>For example, we could split our component state into &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; objects, and always replace the &lt;code&gt;position&lt;/code&gt; with no need for merging:</source>
          <target state="translated">たとえば、コンポーネントの状態を &lt;code&gt;position&lt;/code&gt; と &lt;code&gt;size&lt;/code&gt; オブジェクトに分割し、マージする必要なく常に &lt;code&gt;position&lt;/code&gt; を置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="2d42c3a9b978bb53213888cf10f240637aca3105" translate="yes" xml:space="preserve">
          <source>For example, when adding an element at the end of the children, converting between these two trees works well:</source>
          <target state="translated">例えば、子供の最後に要素を追加する場合は、この2つの木の間で変換するとうまくいきます。</target>
        </trans-unit>
        <trans-unit id="3142f55d25c885268e370e43896a3749c9b69c27" translate="yes" xml:space="preserve">
          <source>For example, your state may contain several independent variables:</source>
          <target state="translated">例えば、あなたの状態はいくつかの独立変数を含んでいるかもしれません。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="331fc234992fd41cfe4aafa1cbadd06d8bfafb82" translate="yes" xml:space="preserve">
          <source>For modal dialogs, ensure that everyone can interact with them by following the &lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;WAI-ARIA Modal Authoring Practices&lt;/a&gt;.</source>
          <target state="translated">モーダルダイアログの場合、すべてのユーザーが&lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;WAI-ARIAモーダルオーサリングプラクティス&lt;/a&gt;に従って対話できることを確認してください。</target>
        </trans-unit>
        <trans-unit id="ec096cdc71e0b7a6ca398c02cfc7d40516f822a1" translate="yes" xml:space="preserve">
          <source>For more detail, see:</source>
          <target state="translated">詳細はこちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="8c88366a24fd2ea482dc14d0de87b283bbe87e7a" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;Error Handling in React 16&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">詳細については、「&lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;React 16でのエラー処理&lt;/em&gt;&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="db28a2392ea1b7c225c391a0872eaf779d774686" translate="yes" xml:space="preserve">
          <source>For more info, see &lt;a href=&quot;fragments&quot;&gt;the Fragments documentation&lt;/a&gt;.</source>
          <target state="translated">詳細については&lt;a href=&quot;fragments&quot;&gt;、フラグメントのドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="4ab9916b7ffb2e490bd12d8282c8ddb3d82ffa2a" translate="yes" xml:space="preserve">
          <source>For more information about the &amp;lsquo;function as a child&amp;rsquo; pattern, see &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;.</source>
          <target state="translated">「子としての機能」パターンの詳細については、&lt;a href=&quot;render-props&quot;&gt;レンダープロップを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="754ab305ab4f9aeec53763a39090226c0de9d63f" translate="yes" xml:space="preserve">
          <source>For more information about the onChange event, see &lt;a href=&quot;forms&quot;&gt;Forms&lt;/a&gt;.</source>
          <target state="translated">onChangeイベントの詳細については、&lt;a href=&quot;forms&quot;&gt;フォームを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0cba5c3c0c27cf5088d9888383d141d07a0f2491" translate="yes" xml:space="preserve">
          <source>For more information on Concurrent Mode, check out the &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode documentation.&lt;/a&gt;</source>
          <target state="translated">並行モードの詳細については、&lt;a href=&quot;concurrent-mode-intro&quot;&gt;並行モードのドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="b9732d78e0ad658ec6be5aa1a8cfda86c791eaa9" translate="yes" xml:space="preserve">
          <source>For more information, check out &lt;a href=&quot;testing-recipes&quot;&gt;Testing Recipes&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;testing-recipes&quot;&gt;テストレシピを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="c4a38f12036a32191520afa8a2753bdccc47eea0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;forwarding-refs&quot;&gt;forwarding refs&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;forwarding-refs&quot;&gt;refの転送を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e5fc1e92e2c893003eb2447d228048e1a7aaf57a" translate="yes" xml:space="preserve">
          <source>For older codebases, Concurrent Mode might be a step too far. This is why we also provide a new &amp;ldquo;Blocking Mode&amp;rdquo; in the experimental React builds. You can try it by substituting &lt;code&gt;createRoot&lt;/code&gt; with &lt;code&gt;createBlockingRoot&lt;/code&gt;. It only offers a &lt;em&gt;small subset&lt;/em&gt; of the Concurrent Mode features, but it is closer to how React works today and can serve as a migration step.</source>
          <target state="translated">古いコードベースの場合、並行モードは一歩遠すぎるかもしれません。これが、実験的なReactビルドで新しい「ブロッキングモード」も提供する理由です。 &lt;code&gt;createRoot&lt;/code&gt; を &lt;code&gt;createBlockingRoot&lt;/code&gt; に置き換えることで試してみることができます。並行モード機能の&lt;em&gt;小さなサブセット&lt;/em&gt;しか提供していませんが、Reactが現在どのように機能しているかに近く、移行ステップとして機能できます。</target>
        </trans-unit>
        <trans-unit id="770927b3887fe0c354b4fb137b4cc1bdc30fbbb9" translate="yes" xml:space="preserve">
          <source>For other use cases, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;follow the recommendations in this blog post about derived state&lt;/a&gt;.</source>
          <target state="translated">その他の使用例について&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;は、このブログ投稿の派生状態に関する推奨事項に従って&lt;/a&gt;ください。</target>
        </trans-unit>
        <trans-unit id="b327cbe7031e739d617d4f75e12fa5fef2acc3b7" translate="yes" xml:space="preserve">
          <source>For the most efficient Browserify production build, install a few plugins:</source>
          <target state="translated">最も効率的なBrowserifyの本番ビルドのために、いくつかのプラグインをインストールします。</target>
        </trans-unit>
        <trans-unit id="17194133fbe1957bfdd4b741f2933c9c86f4ba6d" translate="yes" xml:space="preserve">
          <source>For the most efficient Brunch production build, install the &lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt;&lt;code&gt;terser-brunch&lt;/code&gt;&lt;/a&gt; plugin:</source>
          <target state="translated">最も効率的なBrunchプロダクションビルドのために、&lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt; &lt;code&gt;terser-brunch&lt;/code&gt; &lt;/a&gt;プラグインをインストールします。</target>
        </trans-unit>
        <trans-unit id="a6ce51b2f939e3558a44b1cb8fdbdf554bc07d90" translate="yes" xml:space="preserve">
          <source>For the most efficient Rollup production build, install a few plugins:</source>
          <target state="translated">最も効率的なRollup制作ビルドのために、いくつかのプラグインをインストールします。</target>
        </trans-unit>
        <trans-unit id="7475cb5e6f5adf915c29f1cdea4e2bdc8ba92aa9" translate="yes" xml:space="preserve">
          <source>For these reasons, we reserve patch releases only for the most critical bugs and security vulnerabilities.</source>
          <target state="translated">これらの理由から、私たちは最も重要なバグやセキュリティ上の脆弱性のみを対象にパッチリリースを予約しています。</target>
        </trans-unit>
        <trans-unit id="faa8c036fd5e3a800041a6a85017b66c2fe68715" translate="yes" xml:space="preserve">
          <source>For this change, we&amp;rsquo;ve provided a &lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt; to automatically migrate your code.</source>
          <target state="translated">この変更のために、コードを自動的に移行する&lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt;を提供しました。</target>
        </trans-unit>
        <trans-unit id="4e1bce685a135223c199242bc8c77e474653706f" translate="yes" xml:space="preserve">
          <source>For this reason &lt;code&gt;useDebugValue&lt;/code&gt; accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.</source>
          <target state="translated">このため、 &lt;code&gt;useDebugValue&lt;/code&gt; はフォーマット関数をオプションの2番目のパラメーターとして受け入れます。この関数は、フックが検査された場合にのみ呼び出されます。パラメータとしてデバッグ値を受け取り、フォーマットされた表示値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="d77cd5d73e371d728872a07b909df96d58e4b7b3" translate="yes" xml:space="preserve">
          <source>Forgetting to handle &lt;code&gt;componentDidUpdate&lt;/code&gt; properly is a common source of bugs in React applications.</source>
          <target state="translated">&lt;code&gt;componentDidUpdate&lt;/code&gt; を適切に処理するのを忘れることは、Reactアプリケーションの一般的なバグの原因です。</target>
        </trans-unit>
        <trans-unit id="7d30ae53e81b25bd47a3ef79f6270bb2aee0a4b4" translate="yes" xml:space="preserve">
          <source>Form Events</source>
          <target state="translated">フォームイベント</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="955e3f80970e0af47e55f5200545b8b3a318bc97" translate="yes" xml:space="preserve">
          <source>Fortunately, we can explicitly forward refs to the inner &lt;code&gt;FancyButton&lt;/code&gt; component using the &lt;code&gt;React.forwardRef&lt;/code&gt; API. &lt;code&gt;React.forwardRef&lt;/code&gt; accepts a render function that receives &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; parameters and returns a React node. For example:</source>
          <target state="translated">さいわい、 &lt;code&gt;React.forwardRef&lt;/code&gt; API を使用して、refを内部の &lt;code&gt;FancyButton&lt;/code&gt; コンポーネントに明示的に転送できます。 &lt;code&gt;React.forwardRef&lt;/code&gt; は、 &lt;code&gt;props&lt;/code&gt; および &lt;code&gt;ref&lt;/code&gt; パラメーターを受け取り、Reactノードを返すレンダリング関数を受け入れます。例えば：</target>
        </trans-unit>
        <trans-unit id="f601df170026e953bbac95daafb8c35102220f96" translate="yes" xml:space="preserve">
          <source>Forwarding Refs</source>
          <target state="translated">転送参照</target>
        </trans-unit>
        <trans-unit id="98364eb3c7e295c55161e71c692712d164542fd6" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order components</source>
          <target state="translated">高次成分でのrefの転送</target>
        </trans-unit>
        <trans-unit id="fe54eca6f507b141b7575b8953c555c23ecbd348" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order-components</source>
          <target state="translated">高次成分でのrefの転送</target>
        </trans-unit>
        <trans-unit id="ee0dcf389f3ad894e637d4cba7ff22af9df9a072" translate="yes" xml:space="preserve">
          <source>Forwarding refs to DOM components</source>
          <target state="translated">DOM コンポーネントへの参照の転送</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="796f3ca672ebd9bd41a7a01b5a01b8745791f0e8" translate="yes" xml:space="preserve">
          <source>Fragments declared with the explicit &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; syntax may have keys. A use case for this is mapping a collection to an array of fragments &amp;mdash; for example, to create a description list:</source>
          <target state="translated">明示的な &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; 構文で宣言されたフラグメントには、キーが含まれる場合があります。この使用例は、コレクションをフラグメントの配列にマッピングすることです。たとえば、説明リストを作成します。</target>
        </trans-unit>
        <trans-unit id="8065c017db022d1f5ec110b82bbd874c082a88f9" translate="yes" xml:space="preserve">
          <source>Fragments solve this problem.</source>
          <target state="translated">フラグメントはこの問題を解決します。</target>
        </trans-unit>
        <trans-unit id="3bcb0016a5230b33666fdcf36ccabf570e7de70e" translate="yes" xml:space="preserve">
          <source>Frameworks like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt;, &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; and &lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriver&lt;/a&gt; are useful for running &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;end-to-end tests&lt;/a&gt;.</source>
          <target state="translated">以下のようなフレームワーク&lt;a href=&quot;https://www.cypress.io/&quot;&gt;サイプレス&lt;/a&gt;、&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;人形遣い&lt;/a&gt;と&lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriverをを&lt;/a&gt;実行する場合に便利です&lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;エンドツーエンドのテストを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf9e2789ee767980ad3bc5023d41ac7e306fd5ec" translate="yes" xml:space="preserve">
          <source>Frameworks like Jest also let you save &amp;ldquo;snapshots&amp;rdquo; of data with &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;&lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;&lt;/a&gt;. With these, we can &amp;ldquo;save&amp;rdquo; the rendered component output and ensure that a change to it has to be explicitly committed as a change to the snapshot.</source>
          <target state="translated">Jestのようなフレームワークでは、&lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt; &lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt; &lt;/a&gt;を使用してデータの「スナップショット」を保存することもできます。これらを使用して、レンダリングされたコンポーネント出力を「保存」し、その変更をスナップショットへの変更として明示的にコミットする必要があることを確認できます。</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">よくある質問</target>
        </trans-unit>
        <trans-unit id="149defa1bf170ed878773e58e8f5ff8d5c8a3478" translate="yes" xml:space="preserve">
          <source>From Classes to Hooks</source>
          <target state="translated">クラスからフックまで</target>
        </trans-unit>
        <trans-unit id="bbed11ef2d053428bd9995e6dc4db90c56f977a2" translate="yes" xml:space="preserve">
          <source>From React&amp;rsquo;s point of view, a component using Hooks is just a regular component. If your testing solution doesn&amp;rsquo;t rely on React internals, testing components with Hooks shouldn&amp;rsquo;t be different from how you normally test components.</source>
          <target state="translated">Reactの観点から見ると、フックを使用するコンポーネントは単なる通常のコンポーネントです。テストソリューションがReact内部に依存していない場合、フックを使用したコンポーネントのテストは、通常のコンポーネントのテスト方法と同じであるべきです。</target>
        </trans-unit>
        <trans-unit id="12d07daa800d296a026c49de79bda8bb9f64ea8a" translate="yes" xml:space="preserve">
          <source>From here you could start moving more logic into the component and begin adopting more common React practices. For example, in components it is best not to rely on IDs because the same component can be rendered multiple times. Instead, we will use the &lt;a href=&quot;handling-events&quot;&gt;React event system&lt;/a&gt; and register the click handler directly on the React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">ここから、より多くのロジックをコンポーネントに移動し始め、より一般的なReactプラクティスの採用を開始できます。たとえば、コンポーネントでは、同じコンポーネントを複数回レンダリングできるため、IDに依存しないことが最善です。代わりに、&lt;a href=&quot;handling-events&quot;&gt;Reactイベントシステム&lt;/a&gt;を使用して、React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 要素にクリックハンドラーを直接登録します。</target>
        </trans-unit>
        <trans-unit id="732afd30e77a6dc18afd55e03cd71f20b12f519d" translate="yes" xml:space="preserve">
          <source>Fully-Fledged Solutions</source>
          <target state="translated">本格的なソリューション</target>
        </trans-unit>
        <trans-unit id="d1ab6dc65e716361136b87c26f6834c3fa7eba19" translate="yes" xml:space="preserve">
          <source>Function and Class Components</source>
          <target state="translated">関数とクラス構成要素</target>
        </trans-unit>
        <trans-unit id="a0437f301087d86e5d06d2280e2674b540deaba5" translate="yes" xml:space="preserve">
          <source>Function components are also able to reference &lt;code&gt;context&lt;/code&gt; if &lt;code&gt;contextTypes&lt;/code&gt; is defined as a property of the function. The following code shows a &lt;code&gt;Button&lt;/code&gt; component written as a function component.</source>
          <target state="translated">関数コンポーネントは、 &lt;code&gt;contextTypes&lt;/code&gt; が関数のプロパティとして定義されている場合、 &lt;code&gt;context&lt;/code&gt; を参照することもできます。次のコードは、関数コンポーネントとして記述された &lt;code&gt;Button&lt;/code&gt; コンポーネントを示しています。</target>
        </trans-unit>
        <trans-unit id="73f523ab76ca84802a4f7ad409b8b8a11d5ec14d" translate="yes" xml:space="preserve">
          <source>Functional updates</source>
          <target state="translated">機能アップデート</target>
        </trans-unit>
        <trans-unit id="68254545bf32d5c6b80d7f1482247c069c365636" translate="yes" xml:space="preserve">
          <source>Functions as Children</source>
          <target state="translated">子供としての機能</target>
        </trans-unit>
        <trans-unit id="9b8b995fc31e98c113f50f1e6e4e3cd2d61d6d9d" translate="yes" xml:space="preserve">
          <source>Fundamentally, JSX just provides syntactic sugar for the &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; function. The JSX code:</source>
          <target state="translated">基本的に、JSXは &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; 関数に構文糖を提供するだけです。JSXコード：</target>
        </trans-unit>
        <trans-unit id="4d6b62bf07d530cf7754450cf7f4baeba776dcc5" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;React.PureComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; skips prop updates for the whole component subtree. Make sure all the children components are also &amp;ldquo;pure&amp;rdquo;.</source>
          <target state="translated">さらに、 &lt;code&gt;React.PureComponent&lt;/code&gt; の &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; は、コンポーネントサブツリー全体のプロップの更新をスキップします。すべての子コンポーネントも「純粋」であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="96bfe330b3c43755e29748c139c92671348a757f" translate="yes" xml:space="preserve">
          <source>Gatsby</source>
          <target state="translated">Gatsby</target>
        </trans-unit>
        <trans-unit id="14837150cbbe37e0d75d8160b89e20cd804e5090" translate="yes" xml:space="preserve">
          <source>Generally speaking, no.</source>
          <target state="translated">一般的にはノーです。</target>
        </trans-unit>
        <trans-unit id="52caaec9d0bac23a32c7ed19ebe70c6cf9d9b6ff" translate="yes" xml:space="preserve">
          <source>Generally speaking, yes, it is OK, and it is often the easiest way to pass parameters to callback functions.</source>
          <target state="translated">一般的には、はい、OKで、コールバック関数にパラメータを渡すのが最も簡単な方法であることが多いです。</target>
        </trans-unit>
        <trans-unit id="28a76c547269406d92dd91388795bcc92164307d" translate="yes" xml:space="preserve">
          <source>Generally, you don&amp;rsquo;t want to keep the generated javascript in your source control, so be sure to add the build folder to your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">一般に、生成されたJavaScriptをソース管理に保持したくないので、ビルドフォルダーを &lt;code&gt;.gitignore&lt;/code&gt; に追加してください。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">はじめに</target>
        </trans-unit>
        <trans-unit id="b75a226127e3ed2978b5f42961dd98a51c54f567" translate="yes" xml:space="preserve">
          <source>Given the code below, we use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; function to take an array of &lt;code&gt;numbers&lt;/code&gt; and double their values. We assign the new array returned by &lt;code&gt;map()&lt;/code&gt; to the variable &lt;code&gt;doubled&lt;/code&gt; and log it:</source>
          <target state="translated">以下のコードを前提として、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;関数を使用して &lt;code&gt;numbers&lt;/code&gt; 配列を取得し、その値を2倍にします。私たちは、で返される新しい配列に割り当て &lt;code&gt;map()&lt;/code&gt; 変数に &lt;code&gt;doubled&lt;/code&gt; し、それをログに記録します：</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="96136d53d8b75905c13546cd90a5c916cbb29871" translate="yes" xml:space="preserve">
          <source>Glossary and FAQ</source>
          <target state="translated">用語集・FAQ</target>
        </trans-unit>
        <trans-unit id="2f13a545b80f208a5c342a3f09da99fe34c3e60a" translate="yes" xml:space="preserve">
          <source>Glossary of React Terms</source>
          <target state="translated">React用語集</target>
        </trans-unit>
        <trans-unit id="c8a8632c801140a5a9de611953f386d1dbbf8845" translate="yes" xml:space="preserve">
          <source>Go to your project folder in the terminal, and paste these two commands:</source>
          <target state="translated">ターミナルのプロジェクトフォルダに移動し、以下の2つのコマンドを貼り付けます。</target>
        </trans-unit>
        <trans-unit id="d182bef8d5f2839f88903394bb60f7e51fd6c42c" translate="yes" xml:space="preserve">
          <source>Google Chromebook Help - Use the Built-in Screen Reader</source>
          <target state="translated">Google Chromebookヘルプ-内蔵のスクリーンリーダーを使用する</target>
        </trans-unit>
        <trans-unit id="bcf36c27c78804650761947c87a38f4f6e07ce7e" translate="yes" xml:space="preserve">
          <source>Gradual Adoption Strategy</source>
          <target state="translated">漸進的な採用戦略</target>
        </trans-unit>
        <trans-unit id="428e0a93f1ac72bcc666336cd6d935f2d9640d9e" translate="yes" xml:space="preserve">
          <source>Gradual Upgrades via Warnings</source>
          <target state="translated">警告による段階的なアップグレード</target>
        </trans-unit>
        <trans-unit id="58273e47057ce993d5fd97a4eb4dface99c26929" translate="yes" xml:space="preserve">
          <source>Great! Now when we run our build script the compiler will output the generated javascript to the &lt;code&gt;build&lt;/code&gt; folder. The &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;TypeScript React Starter&lt;/a&gt; provides a &lt;code&gt;tsconfig.json&lt;/code&gt; with a good set of rules to get you started.</source>
          <target state="translated">すごい！ビルドスクリプトを実行すると、コンパイラは生成されたJavaScriptを &lt;code&gt;build&lt;/code&gt; フォルダに出力します。&lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;活字体が反応スターター&lt;/a&gt;提供 &lt;code&gt;tsconfig.json&lt;/code&gt; をあなたが始めるためのルールの良いセットで。</target>
        </trans-unit>
        <trans-unit id="72b257d572f9de8cb600dc9ff344b295b0affeca" translate="yes" xml:space="preserve">
          <source>Grouping by features or routes</source>
          <target state="translated">特徴やルートによるグループ化</target>
        </trans-unit>
        <trans-unit id="b7fd6516d065f4d8e30a111bc4d1476d4af19bbe" translate="yes" xml:space="preserve">
          <source>Grouping by file type</source>
          <target state="translated">ファイルタイプによるグループ分け</target>
        </trans-unit>
        <trans-unit id="b02dd6f98e40fbc355cf17dc049baecc28173b57" translate="yes" xml:space="preserve">
          <source>HOCs add features to a component. They shouldn&amp;rsquo;t drastically alter its contract. It&amp;rsquo;s expected that the component returned from a HOC has a similar interface to the wrapped component.</source>
          <target state="translated">HOCはコンポーネントに機能を追加します。彼らは契約を大幅に変更すべきではありません。HOCから返されたコンポーネントは、ラップされたコンポーネントと同様のインターフェースを持つことが期待されています。</target>
        </trans-unit>
        <trans-unit id="063035c50f06bf73e08fe91d42e9d79e9dcc00b0" translate="yes" xml:space="preserve">
          <source>HOCs are common in third-party React libraries, such as Redux&amp;rsquo;s &lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; and Relay&amp;rsquo;s &lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HOCは、Reduxの&lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;やリレーの&lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt;など、サードパーティのReactライブラリでは一般的です。</target>
        </trans-unit>
        <trans-unit id="5c8962b048f87decc8156392f32206c1be5db772" translate="yes" xml:space="preserve">
          <source>HOCs should pass through props that are unrelated to its specific concern. Most HOCs contain a render method that looks something like this:</source>
          <target state="translated">HOC は、その特定の関心事とは関係のない小道具を通過しなければなりません。ほとんどの HOC には、次のようなレンダーメソッドが含まれています。</target>
        </trans-unit>
        <trans-unit id="90574747f52ec1f5009a45ed8d33cb2283639a02" translate="yes" xml:space="preserve">
          <source>HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:</source>
          <target state="translated">HTML のフォーム要素は、React の他の DOM 要素とは少し異なります。例えば、このプレーン HTML のフォームは単一の名前を受け付けます。</target>
        </trans-unit>
        <trans-unit id="0d2d67fd740d7ec7df3d8674c33679652ab92712" translate="yes" xml:space="preserve">
          <source>Handling Errors</source>
          <target state="translated">エラー処理</target>
        </trans-unit>
        <trans-unit id="d425f7e27fe0f057871c46f4c72c4a3bd2b0f136" translate="yes" xml:space="preserve">
          <source>Handling Events</source>
          <target state="translated">イベントの取り扱い</target>
        </trans-unit>
        <trans-unit id="a45618425a820085679577753f54c9b8cd00317e" translate="yes" xml:space="preserve">
          <source>Handling Multiple Inputs</source>
          <target state="translated">複数入力を扱う</target>
        </trans-unit>
        <trans-unit id="af96eff387bd2ffe3a5340f3ed51fac600fd535c" translate="yes" xml:space="preserve">
          <source>Handling events with React elements has some syntactic differences:</source>
          <target state="translated">React要素でイベントを扱うことは、いくつかの構文上の違いがあります。</target>
        </trans-unit>
        <trans-unit id="d5e781a7966802398bc6183dffb3545a19611d53" translate="yes" xml:space="preserve">
          <source>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</source>
          <target state="translated">React要素でのイベントの処理は、DOM要素でのイベントの処理と非常に似ています。いくつかの構文上の違いがあります。</target>
        </trans-unit>
        <trans-unit id="710df444e674bad2b7f10527830ac10000028b6c" translate="yes" xml:space="preserve">
          <source>Here are some good resources for further reading on when to use &lt;code&gt;props&lt;/code&gt; vs &lt;code&gt;state&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;props&lt;/code&gt; と &lt;code&gt;state&lt;/code&gt; をいつ使用するかについてさらに読むためのリソースをいくつか示します。</target>
        </trans-unit>
        <trans-unit id="2a3421fa1b421c70fdf50bc5b3706d1884ec45d9" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;small demo&lt;/a&gt; to get you started. To learn more, check out &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; about data fetching with Hooks.</source>
          <target state="translated">ここにあなたが始めるための&lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;小さなデモ&lt;/a&gt;があります。詳細については、フックを使用したデータ取得に関する&lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;この記事を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="c8317f95e08c6543e53027d145f8eddcf023d7fe" translate="yes" xml:space="preserve">
          <source>Here is a step-by-step explanation of what happens in the above example:</source>
          <target state="translated">上記の例でどのようなことが起こるのか、ステップバイステップで説明します。</target>
        </trans-unit>
        <trans-unit id="10e83a22ccb4f6fc7030872a422ceee48e5b88b6" translate="yes" xml:space="preserve">
          <source>Here is an &lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;in-depth explanation about why keys are necessary&lt;/a&gt; if you&amp;rsquo;re interested in learning more.</source>
          <target state="translated">ここで&lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;キーが必要である理由についての詳細な説明&lt;/a&gt;あなたがより多くの学習に興味があればで。</target>
        </trans-unit>
        <trans-unit id="469c11af4fb767b071b7bc9fc6660c36d0303d75" translate="yes" xml:space="preserve">
          <source>Here is an example documenting the different validators provided:</source>
          <target state="translated">ここでは、提供されているさまざまなバリデータを説明する例を示します。</target>
        </trans-unit>
        <trans-unit id="dd61c330907127ed38d293d1d4af5a24b4c290e7" translate="yes" xml:space="preserve">
          <source>Here is how we can test it:</source>
          <target state="translated">ここではそのテスト方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="36728af60fa3c9f7c434352505e9201caca43d44" translate="yes" xml:space="preserve">
          <source>Here we require knowledge of &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;ARIA Roles&lt;/a&gt; as well as &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;ARIA States and Properties&lt;/a&gt;. These are toolboxes filled with HTML attributes that are fully supported in JSX and enable us to construct fully accessible, highly functional React components.</source>
          <target state="translated">ここでは、&lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;ARIAロール&lt;/a&gt;と&lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;ARIAの状態とプロパティ&lt;/a&gt;に関する知識が必要です。これらは、JSXで完全にサポートされているHTML属性で満たされたツールボックスであり、完全にアクセス可能な高機能のReactコンポーネントを構築できます。</target>
        </trans-unit>
        <trans-unit id="dc9d8cd325a00d9730f610bfeca5652d530f0f8e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a subtree of components. For each one, &lt;code&gt;SCU&lt;/code&gt; indicates what &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned, and &lt;code&gt;vDOMEq&lt;/code&gt; indicates whether the rendered React elements were equivalent. Finally, the circle&amp;rsquo;s color indicates whether the component had to be reconciled or not.</source>
          <target state="translated">これがコンポーネントのサブツリーです。それぞれについて、 &lt;code&gt;SCU&lt;/code&gt; は &lt;code&gt;shouldComponentUpdate&lt;/code&gt; が何を返したかを示し、 &lt;code&gt;vDOMEq&lt;/code&gt; はレンダリングされたReact要素が同等であるかどうかを示します。最後に、円の色は、コンポーネントを調整する必要があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="3e5e88093705abf9b440083ab6665499dccb5254" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to setup route-based code splitting into your app using libraries like &lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt; with &lt;code&gt;React.lazy&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; を備えた&lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt;などのライブラリを使用して、ルートベースのコード分割をアプリに設定する方法の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="983fc3a4301db31eed982a269174f75044f4d44b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the counter example from the &lt;a href=&quot;#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; section, rewritten to use a reducer:</source>
          <target state="translated">次に、&lt;a href=&quot;#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt;を使用するように書き直された、useStateセクションのカウンターの例を示します。</target>
        </trans-unit>
        <trans-unit id="6ccd56b3438af9572583e63a1873615e49b63ab1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what happens when we render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; on the screen:</source>
          <target state="translated">画面に &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; をレンダリングすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="23a6a5eadd7c0a89a44b430f4d016d98f4bf2e1e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where the render prop comes in: Instead of hard-coding a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; inside a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, and effectively changing its rendered output, we can provide &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a function prop that it uses to dynamically determine what to render&amp;ndash;a render prop.</source>
          <target state="translated">出番小道具をレンダリングここにあります：代わりのハードコーディング &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; 内の &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; コンポーネント、および効果的にレンダリングされた出力を変え、我々は提供することができます &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; それが動的にレンダリングするかを決定するために使用する機能の小道具付き&amp;ndash;レンダリングプロップ。</target>
        </trans-unit>
        <trans-unit id="f2ee35e6fcb6ceeda6ad5733dbfe3081d417836a" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. See the &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; reference guide to learn more.</source>
          <target state="translated">ここで、 &lt;code&gt;e&lt;/code&gt; は合成イベントです。Reactは&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C仕様&lt;/a&gt;に従ってこれらの合成イベントを定義しているため、ブラウザー間の互換性について心配する必要はありません。詳細については、&lt;a href=&quot;events&quot;&gt; &lt;code&gt;SyntheticEvent&lt;/code&gt; &lt;/a&gt;リファレンスガイドをご覧ください。</target>
        </trans-unit>
        <trans-unit id="fc55606f595a34d3c61c69e9ffbf6a6904254c39" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;useState&lt;/code&gt; is a &lt;em&gt;Hook&lt;/em&gt; (we&amp;rsquo;ll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. &lt;code&gt;useState&lt;/code&gt; returns a pair: the &lt;em&gt;current&lt;/em&gt; state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It&amp;rsquo;s similar to &lt;code&gt;this.setState&lt;/code&gt; in a class, except it doesn&amp;rsquo;t merge the old and new state together. (We&amp;rsquo;ll show an example comparing &lt;code&gt;useState&lt;/code&gt; to &lt;code&gt;this.state&lt;/code&gt; in &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.)</source>
          <target state="translated">ここで、 &lt;code&gt;useState&lt;/code&gt; は&lt;em&gt;フックです&lt;/em&gt;（これについては後で説明します）。関数コンポーネント内でこれを呼び出し、ローカル状態を追加します。Reactは、再レンダリング間でこの状態を保持します。 &lt;code&gt;useState&lt;/code&gt; はペアを返します。&lt;em&gt;現在の&lt;/em&gt;状態値とそれを更新できる関数です。この関数は、イベントハンドラーなどから呼び出すことができます。クラスの &lt;code&gt;this.setState&lt;/code&gt; に似ていますが、古い状態と新しい状態をマージしない点が異なります。（私たちは、比較例紹介 &lt;code&gt;useState&lt;/code&gt; をする &lt;code&gt;this.state&lt;/code&gt; に&lt;a href=&quot;hooks-state&quot;&gt;国家のフックを使用します&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="62ba3ca71c800446a468a8f1df328896c57eaf85" translate="yes" xml:space="preserve">
          <source>Here, we store the previous value of the &lt;code&gt;row&lt;/code&gt; prop in a state variable so that we can compare:</source>
          <target state="translated">ここでは、比較できるように、 &lt;code&gt;row&lt;/code&gt; プロップの以前の値を状態変数に格納します。</target>
        </trans-unit>
        <trans-unit id="694a8ab065bc1ddcb8bfd82b16d99febb5b29744" translate="yes" xml:space="preserve">
          <source>Heydon Pickering - ARIA Examples</source>
          <target state="translated">ハイドン・ピッカリング-ARIAの例</target>
        </trans-unit>
        <trans-unit id="9949204d6ccc01e71532e6b5a07e754220b79927" translate="yes" xml:space="preserve">
          <source>Higher-Order Components</source>
          <target state="translated">高次部品</target>
        </trans-unit>
        <trans-unit id="020cce2b859c795f0df3f5cefeb0457647d208e5" translate="yes" xml:space="preserve">
          <source>Higher-order components come with a few caveats that aren&amp;rsquo;t immediately obvious if you&amp;rsquo;re new to React.</source>
          <target state="translated">高次のコンポーネントにはいくつかの注意事項がありますが、Reactに慣れていないとすぐにはわかりません。</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="5f4d9480b4df0d6e740642769da4ab963d23e1df" translate="yes" xml:space="preserve">
          <source>Hooks &lt;strong&gt;don&amp;rsquo;t&lt;/strong&gt; work inside classes. But you can use them instead of writing classes.</source>
          <target state="translated">フック&lt;strong&gt;は&lt;/strong&gt;クラス内で&lt;strong&gt;は&lt;/strong&gt;機能&lt;strong&gt;しません&lt;/strong&gt;。しかし、クラスを書く代わりにそれらを使うことができます。</target>
        </trans-unit>
        <trans-unit id="6346e065d302bd612cb57acc37b5c4b2d11b5c55" translate="yes" xml:space="preserve">
          <source>Hooks API Reference</source>
          <target state="translated">フックス API リファレンス</target>
        </trans-unit>
        <trans-unit id="83f68a3284889949ad8da40e185f437f9cd788cc" translate="yes" xml:space="preserve">
          <source>Hooks FAQ</source>
          <target state="translated">フックFAQ</target>
        </trans-unit>
        <trans-unit id="6741749abbd97e5aa67270b4114318826ae8ec0d" translate="yes" xml:space="preserve">
          <source>Hooks and Function Components</source>
          <target state="translated">フックと関数のコンポーネント</target>
        </trans-unit>
        <trans-unit id="984e9f1dce4f6c473f93ec63fbba28614d61a0c3" translate="yes" xml:space="preserve">
          <source>Hooks are &lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;backwards-compatible&lt;/a&gt;. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:</source>
          <target state="translated">フックは&lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;下位互換性があり&lt;/a&gt;ます。このページでは、経験豊富なReactユーザー向けのフックの概要を説明します。これはペースの速い概要です。混乱した場合は、次のような黄色のボックスを探してください。</target>
        </trans-unit>
        <trans-unit id="de1b424d96849c452e8623c3aff21cbd2124f794" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but they impose two additional rules:</source>
          <target state="translated">フックはJavaScriptの関数ですが、さらに2つのルールを課しています。</target>
        </trans-unit>
        <trans-unit id="c38711e94905b544d78f9780d3bf6f82e5586c52" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but you need to follow two rules when using them. We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically:</source>
          <target state="translated">フックはJavaScript関数ですが、使用するには2つのルールに従う必要があります。これらのルールを自動的に実施するための&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;リンタープラグイン&lt;/a&gt;を提供します。</target>
        </trans-unit>
        <trans-unit id="12baa054732ac507c2f0e0ac9c1bc905d155c97a" translate="yes" xml:space="preserve">
          <source>Hooks are a more direct way to use the React features you already know &amp;mdash; such as state, lifecycle, context, and refs. They don&amp;rsquo;t fundamentally change how React works, and your knowledge of components, props, and top-down data flow is just as relevant.</source>
          <target state="translated">フックは、状態、ライフサイクル、コンテキスト、参照など、すでに知っているReact機能を使用するためのより直接的な方法です。これらはReactの動作を根本的に変えるものではなく、コンポーネント、プロップ、およびトップダウンのデータフローに関する知識も同様に重要です。</target>
        </trans-unit>
        <trans-unit id="b3dffafdaf027921074c093681b6b2fa42d7706d" translate="yes" xml:space="preserve">
          <source>Hooks are called in the same order on every render.</source>
          <target state="translated">フックはすべてのレンダリングで同じ順番で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4f6e49743738970df49a4e276c80da3002abd881" translate="yes" xml:space="preserve">
          <source>Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React state and lifecycle features from function components. Hooks don&amp;rsquo;t work inside classes &amp;mdash; they let you use React without classes. (We &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;don&amp;rsquo;t recommend&lt;/a&gt; rewriting your existing components overnight but you can start using Hooks in the new ones if you&amp;rsquo;d like.)</source>
          <target state="translated">フックは、関数コンポーネントからReactの状態とライフサイクル機能を「フック」するための関数です。フックはクラスの内部では機能しません&amp;mdash;クラスなしでReactを使用できます。（既存のコンポーネントを一晩書き直す&lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;ことはお勧めしません&lt;/a&gt;が、必要に応じて、新しいコンポーネントでフックを使い始めることができます。）</target>
        </trans-unit>
        <trans-unit id="ea0760f5cbbc31d25fdb696fae6c90d049a7e43f" translate="yes" xml:space="preserve">
          <source>Hooks at a Glance</source>
          <target state="translated">一目でわかるフック</target>
        </trans-unit>
        <trans-unit id="d26a024e6656cfd225f9b3faaf69112eb79c72b0" translate="yes" xml:space="preserve">
          <source>Hooks avoid a lot of the overhead that classes require, like the cost of creating class instances and binding event handlers in the constructor.</source>
          <target state="translated">フックは、クラスインスタンスの作成コストやコンストラクタでのイベントハンドラのバインドなど、クラスが必要とする多くのオーバーヘッドを回避します。</target>
        </trans-unit>
        <trans-unit id="c4f46f02e8a51698c3e23f41f8d864b3b26080e0" translate="yes" xml:space="preserve">
          <source>Hooks do have a learning curve of their own. If there&amp;rsquo;s something missing in this documentation, &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;raise an issue&lt;/a&gt; and we&amp;rsquo;ll try to help.</source>
          <target state="translated">フックには独自の学習曲線があります。このドキュメントに何か不足がある場合は&lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;、問題&lt;/a&gt;を提起してください。</target>
        </trans-unit>
        <trans-unit id="e78aadbe4b447f0e05b05e1acb099273d9660236" translate="yes" xml:space="preserve">
          <source>Hooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.</source>
          <target state="translated">フックを使用すると、ライフサイクル メソッドに基づいて強制的に分割するのではなく、どの部分が関連しているか(サブスクリプションの追加や削除など)によってコンポーネント内の副作用を整理することができます。</target>
        </trans-unit>
        <trans-unit id="4fd8adc24c90fba774c6fae7ebe2e06da199b06e" translate="yes" xml:space="preserve">
          <source>Hooks offer a powerful and expressive new way to reuse functionality between components. &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt; provides a glimpse of what&amp;rsquo;s possible. &lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;This article&lt;/a&gt; by a React core team member dives deeper into the new capabilities unlocked by Hooks.</source>
          <target state="translated">フックは、コンポーネント間で機能を再利用するための強力で表現力豊かな新しい方法を提供します。&lt;a href=&quot;hooks-custom&quot;&gt;「独自のフックを構築する」&lt;/a&gt;では、可能なことを垣間見ることができます。Reactコアチームメンバーによる&lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;この記事で&lt;/a&gt;は、フックによって解放された新機能について詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="beee8e71e8faa563add416aa12ae92953a859ef1" translate="yes" xml:space="preserve">
          <source>Hooks solve a wide variety of seemingly unconnected problems in React that we&amp;rsquo;ve encountered over five years of writing and maintaining tens of thousands of components. Whether you&amp;rsquo;re learning React, use it daily, or even prefer a different library with a similar component model, you might recognize some of these problems.</source>
          <target state="translated">フックは、Reactで一見接続されていないように見えるさまざまな問題を解決します。これは、5年間にわたって数万のコンポーネントの作成と保守で発生してきたものです。Reactを学習しているか、毎日使用しているか、または類似のコンポーネントモデルを備えた別のライブラリを好んでいるかにかかわらず、これらの問題のいくつかを認識している場合があります。</target>
        </trans-unit>
        <trans-unit id="125ff9caefd47f46f6f9836d25c8aeb5965e4029" translate="yes" xml:space="preserve">
          <source>Hooks synthesize ideas from several different sources:</source>
          <target state="translated">フックは、いくつかの異なるソースからアイデアを合成します。</target>
        </trans-unit>
        <trans-unit id="9ddd1c044852bd20a73c95243ed31e59f05c49ac" translate="yes" xml:space="preserve">
          <source>Hooks were designed with static typing in mind. Because they&amp;rsquo;re functions, they are easier to type correctly than patterns like higher-order components. The latest Flow and TypeScript React definitions include support for React Hooks.</source>
          <target state="translated">フックは静的型付けを考慮して設計されました。これらは関数であるため、高次コンポーネントのようなパターンよりも正しく入力するのが簡単です。最新のFlowおよびTypeScript React定義には、React Hooksのサポートが含まれています。</target>
        </trans-unit>
        <trans-unit id="3263600c56483c0a3a486401c7c00425cf496889" translate="yes" xml:space="preserve">
          <source>Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you&amp;rsquo;re used to, remember that code is read far more than it&amp;rsquo;s written, and it&amp;rsquo;s less difficult to read this modular, explicit code. As you start to build large libraries of components, you&amp;rsquo;ll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :)</source>
          <target state="translated">うまくいけば、これにより、Reactを使用したコンポーネントとアプリケーションの構築について考える方法がわかります。慣れより少しタイピングが多いかもしれませんが、コードは書かれたよりもはるかに多く読み取られ、このモジュール式の明示的なコードを読み取ることはそれほど難しくないことを覚えておいてください。コンポーネントの大規模なライブラリの構築を開始すると、この明示性とモジュール性が高く評価され、コードの再利用により、コード行が縮小し始めます。:)</target>
        </trans-unit>
        <trans-unit id="692095ebf5adc28ef5dd43de59073c7e0f30fed7" translate="yes" xml:space="preserve">
          <source>How About Event Handlers?</source>
          <target state="translated">イベントハンドラはどうですか?</target>
        </trans-unit>
        <trans-unit id="cb6ede7c8218456d272e15d1df527222761a5d58" translate="yes" xml:space="preserve">
          <source>How About try/catch?</source>
          <target state="translated">トライ/キャッチはどうですか?</target>
        </trans-unit>
        <trans-unit id="10f9d04f7128ff4e06c8d87250d8e47453873aca" translate="yes" xml:space="preserve">
          <source>How Can I Learn More About Experimental Features?</source>
          <target state="translated">実験機能について詳しく知るにはどうしたらいいですか?</target>
        </trans-unit>
        <trans-unit id="6b32b4ad6bd37176faffadb32d22a8289534a746" translate="yes" xml:space="preserve">
          <source>How To Use Context</source>
          <target state="translated">コンテキストの使い方</target>
        </trans-unit>
        <trans-unit id="0d3b1dc4703059a43990fb4f54a82b7ea462210e" translate="yes" xml:space="preserve">
          <source>How can I do data fetching with Hooks?</source>
          <target state="translated">フックを使ってデータを取得するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="5f3eb93766a70bcb23bd57b5f81706e1346cc00b" translate="yes" xml:space="preserve">
          <source>How can I make an AJAX call?</source>
          <target state="translated">どのようにしてAJAX呼び出しを行うことができますか?</target>
        </trans-unit>
        <trans-unit id="d65c5d09d6ca3b416e582fadae15682637bf85c2" translate="yes" xml:space="preserve">
          <source>How can I measure a DOM node?</source>
          <target state="translated">DOM ノードを測定するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="fe8a15cb87dd32841f00b87b456991b2721d9c55" translate="yes" xml:space="preserve">
          <source>How can I prevent a function from being called too quickly or too many times in a row?</source>
          <target state="translated">関数の呼び出しが早すぎたり、連続して何度も呼び出されたりするのを防ぐにはどうしたらいいですか?</target>
        </trans-unit>
        <trans-unit id="6aec71a52b9be72fd0463ec529f9c780d7f499e0" translate="yes" xml:space="preserve">
          <source>How can I write comments in JSX?</source>
          <target state="translated">JSXでコメントを書くにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="83d4d9bc9ea4bb507420dda2c277f59106d4c62f" translate="yes" xml:space="preserve">
          <source>How do I add CSS classes to components?</source>
          <target state="translated">コンポーネントにCSSクラスを追加するには?</target>
        </trans-unit>
        <trans-unit id="81a15ac345101e045ea595d31734e8063db66661" translate="yes" xml:space="preserve">
          <source>How do I bind a function to a component instance?</source>
          <target state="translated">コンポーネントのインスタンスに関数をバインドするには?</target>
        </trans-unit>
        <trans-unit id="aa62b3618db8ebfa8f917b302351ed7099483e1f" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;getDerivedStateFromProps&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; を実装するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="d0572ad330916c3fe730299d4ede58b185b5ca13" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; を実装するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="fb9e955accc6d91168550466054bc2a0652117d7" translate="yes" xml:space="preserve">
          <source>How do I implement getDerivedStateFromProps?</source>
          <target state="translated">getDerivedStateFromPropsを実装するには?</target>
        </trans-unit>
        <trans-unit id="e9415649ba2cf6fdc23c48d06f17328a84773eae" translate="yes" xml:space="preserve">
          <source>How do I implement shouldComponentUpdate?</source>
          <target state="translated">shouldComponentUpdateを実装するには?</target>
        </trans-unit>
        <trans-unit id="d0ca0d1ae983bdbef86eee8bd0c53b191176837f" translate="yes" xml:space="preserve">
          <source>How do I pass a parameter to an event handler or callback?</source>
          <target state="translated">イベントハンドラやコールバックにパラメータを渡すには?</target>
        </trans-unit>
        <trans-unit id="38b2ecaed14852353d71b3ff348314158c48bfb1" translate="yes" xml:space="preserve">
          <source>How do I pass an event handler (like onClick) to a component?</source>
          <target state="translated">イベントハンドラ(onClickなど)をコンポーネントに渡すには?</target>
        </trans-unit>
        <trans-unit id="b0b4082736e34d847d56b0cabd7b94a845d15d06" translate="yes" xml:space="preserve">
          <source>How do I update state with values that depend on the current state?</source>
          <target state="translated">現在の状態に依存する値で状態を更新するには?</target>
        </trans-unit>
        <trans-unit id="1571c2b05260a179a5c52b92711d13ace65d09c2" translate="yes" xml:space="preserve">
          <source>How do lifecycle methods correspond to Hooks?</source>
          <target state="translated">ライフサイクルメソッドはどのようにフックに対応しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="ef86d6c075ad452ca05fc6dfcb095042d6b94c62" translate="yes" xml:space="preserve">
          <source>How do we separate the Receded and the Skeleton states? The difference between them is that the &lt;strong&gt;Receded&lt;/strong&gt; state feels like &amp;ldquo;taking a step back&amp;rdquo; to the user, while the &lt;strong&gt;Skeleton&lt;/strong&gt; state feels like &amp;ldquo;taking a step forward&amp;rdquo; in our progress to show more content.</source>
          <target state="translated">後退状態とスケルトン状態をどのように分離しますか？それらの違いは、&lt;strong&gt;Receded&lt;/strong&gt;状態はユーザーに「一歩戻る」ように感じますが、&lt;strong&gt;Skeleton&lt;/strong&gt;状態はより多くのコンテンツを表示するための進捗状況を「一歩進める」ように感じます。</target>
        </trans-unit>
        <trans-unit id="9cd07e5b2055c72f75ab42f26ab2628f05373053" translate="yes" xml:space="preserve">
          <source>How does React associate Hook calls with components?</source>
          <target state="translated">Reactはどのようにフックの呼び出しをコンポーネントに関連付けるのですか?</target>
        </trans-unit>
        <trans-unit id="03433b6618565d81523f098fea7bbfc849e26f58" translate="yes" xml:space="preserve">
          <source>How is this different from debouncing? Our example has a fixed artificial delay (3ms for every one of 80 items), so there is always a delay, no matter how fast our computer is. However, the &lt;code&gt;useDeferredValue&lt;/code&gt; value only &amp;ldquo;lags behind&amp;rdquo; if the rendering takes a while. There is no minimal lag imposed by React. With a more realistic workload, you can expect the lag to adjust to the user&amp;rsquo;s device. On fast machines, the lag would be smaller or non-existent, and on slow machines, it would be more noticeable. In both cases, the app would remain responsive. That&amp;rsquo;s the advantage of this mechanism over debouncing or throttling, which always impose a minimal delay and can&amp;rsquo;t avoid blocking the thread while rendering.</source>
          <target state="translated">これはデバウンスとどう違うのですか？この例では固定の人工遅延（80アイテムごとに3ミリ秒）があるため、コンピューターの速度に関係なく、常に遅延が発生します。ただし、 &lt;code&gt;useDeferredValue&lt;/code&gt; 値は、レンダリングに時間がかかる場合にのみ「遅れ」ます。Reactによる最小の遅延はありません。より現実的なワークロードでは、遅延がユーザーのデバイスに適応することが期待できます。高速のマシンでは、ラグはより小さくなるか、存在しなくなり、低速のマシンでは、より顕著になります。どちらの場合も、アプリは応答性を維持します。これが、デバウンスやスロットルよりもこのメカニズムの利点であり、常に最小限の遅延を課し、レンダリング中にスレッドのブロックを回避することはできません。</target>
        </trans-unit>
        <trans-unit id="ef20a3ab1615429a9e3caea2dfc9283ba06feb8c" translate="yes" xml:space="preserve">
          <source>How much of my React knowledge stays relevant?</source>
          <target state="translated">私のReactの知識はどれくらい関連性があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="01cf9009310d5e4e171575929c85ba93f68d8165" translate="yes" xml:space="preserve">
          <source>How to Approach the Problem</source>
          <target state="translated">問題へのアプローチ方法</target>
        </trans-unit>
        <trans-unit id="772ce99a70283ae35b4e13fa8d26821113684e81" translate="yes" xml:space="preserve">
          <source>How to Read This Guide</source>
          <target state="translated">このガイドの読み方</target>
        </trans-unit>
        <trans-unit id="5e5bdd73691289d5424afb561fb4d4a8c352d85e" translate="yes" xml:space="preserve">
          <source>How to avoid passing callbacks down?</source>
          <target state="translated">コールバックのダウンをパスしないようにするには?</target>
        </trans-unit>
        <trans-unit id="e4460bb5cb239f962c6f963dd45f4bfc12fafab4" translate="yes" xml:space="preserve">
          <source>How to create expensive objects lazily?</source>
          <target state="translated">高価なものを怠惰に作るには?</target>
        </trans-unit>
        <trans-unit id="b8b7e53bed65fc2a70652cc57c409f8809ebddf6" translate="yes" xml:space="preserve">
          <source>How to get the previous props or state?</source>
          <target state="translated">前の小道具や状態異常の入手方法は?</target>
        </trans-unit>
        <trans-unit id="c24f12ba653d001525d8a8bd81fe1cef3fad0860" translate="yes" xml:space="preserve">
          <source>How to memoize calculations?</source>
          <target state="translated">計算をメモするには?</target>
        </trans-unit>
        <trans-unit id="24fb9eef456bcd915cd5640203146790d6c28cff" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from &lt;code&gt;useCallback&lt;/code&gt;?</source>
          <target state="translated">頻繁に変化する値を &lt;code&gt;useCallback&lt;/code&gt; から読み取る方法は？</target>
        </trans-unit>
        <trans-unit id="ecc2a2a6938156221ff27517255883f6fe53d187" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from useCallback?</source>
          <target state="translated">useCallbackから頻繁に変化する値を読み取るには?</target>
        </trans-unit>
        <trans-unit id="4e42ecde4eca22b2d3b189bcf068d674eeacdb8a" translate="yes" xml:space="preserve">
          <source>How to test components that use Hooks?</source>
          <target state="translated">フックを使用するコンポーネントをテストするには?</target>
        </trans-unit>
        <trans-unit id="9da64590fe0ba979539b260ad3ab00d0ecded657" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;useRef()&lt;/code&gt; is useful for more than the &lt;code&gt;ref&lt;/code&gt; attribute. It&amp;rsquo;s &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;handy for keeping any mutable value around&lt;/a&gt; similar to how you&amp;rsquo;d use instance fields in classes.</source>
          <target state="translated">ただし、 &lt;code&gt;useRef()&lt;/code&gt; は &lt;code&gt;ref&lt;/code&gt; 属性以外にも役立ちます。クラスでインスタンスフィールドを使用する場合と同様に&lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;、変更可能な値を保持する&lt;/a&gt;のに便利です。</target>
        </trans-unit>
        <trans-unit id="65f0f95f546c8a3bf04820043025e19f7a76c111" translate="yes" xml:space="preserve">
          <source>However, React also offers an option to use &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; instead:</source>
          <target state="translated">ただし、Reactには、代わりに&lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt;を使用するオプションもあります。</target>
        </trans-unit>
        <trans-unit id="3333696f448160f28cb91d4eececaddabcf02145" translate="yes" xml:space="preserve">
          <source>However, React components are declarative and specify &lt;em&gt;what&lt;/em&gt; should be rendered:</source>
          <target state="translated">ただし、Reactコンポーネントは宣言型であり、&lt;em&gt;何&lt;/em&gt;をレンダリングする&lt;em&gt;か&lt;/em&gt;を指定します。</target>
        </trans-unit>
        <trans-unit id="e9b9ee92c12009c14589ca7400a64667019fa998" translate="yes" xml:space="preserve">
          <source>However, elements can also represent user-defined components:</source>
          <target state="translated">ただし、要素はユーザー定義のコンポーネントを表すこともできます。</target>
        </trans-unit>
        <trans-unit id="8914df7a2751ed9a49c0a876b51e78db6ebded98" translate="yes" xml:space="preserve">
          <source>However, in Concurrent Mode there are cases where you might &lt;em&gt;want&lt;/em&gt; to &amp;ldquo;duplicate&amp;rdquo; some data in different state variables. Consider this tiny translation app:</source>
          <target state="translated">ただし、並行モードでは、いくつかのデータを異なる状態変数に「複製」し&lt;em&gt;たい&lt;/em&gt;場合があります。この小さな翻訳アプリを考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="d58ece91c2a93ff8dda87d95414ebd23f4782a9c" translate="yes" xml:space="preserve">
          <source>However, it also preserves &lt;code&gt;ref&lt;/code&gt;s. This means that if you get a child with a &lt;code&gt;ref&lt;/code&gt; on it, you won&amp;rsquo;t accidentally steal it from your ancestor. You will get the same &lt;code&gt;ref&lt;/code&gt; attached to your new element.</source>
          <target state="translated">ただし、 &lt;code&gt;ref&lt;/code&gt; も保持されます。これは、 &lt;code&gt;ref&lt;/code&gt; のある子を取得した場合、誤って祖先からそれを盗むことがないことを意味します。新しい要素に同じ &lt;code&gt;ref&lt;/code&gt; 添付されます。</target>
        </trans-unit>
        <trans-unit id="7dccca1546e00e09348d2ca880b503bbc3782a4f" translate="yes" xml:space="preserve">
          <source>However, it does raise the question of why these releases aren&amp;rsquo;t versioned as patches instead.</source>
          <target state="translated">ただし、これらのリリースがパッチとしてバージョン管理されていないのはなぜかという疑問が生じます。</target>
        </trans-unit>
        <trans-unit id="f6a583f2ca74afad8b48de4866dda319994ca798" translate="yes" xml:space="preserve">
          <source>However, it misses a crucial requirement: the fact that the &lt;code&gt;Clock&lt;/code&gt; sets up a timer and updates the UI every second should be an implementation detail of the &lt;code&gt;Clock&lt;/code&gt;.</source>
          <target state="translated">しかし、それは重要な要件ミス：その事実 &lt;code&gt;Clock&lt;/code&gt; タイマー設定をし、毎秒の実装の詳細であるべきUIを更新 &lt;code&gt;Clock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0b55a581ed0d44371ffb07796a1f139be740fa1" translate="yes" xml:space="preserve">
          <source>However, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called &lt;a href=&quot;#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt;. It has the same signature as &lt;code&gt;useEffect&lt;/code&gt;, and only differs in when it is fired.</source>
          <target state="translated">ただし、すべての影響を先送りできるわけではありません。たとえば、ユーザーに表示されるDOMミューテーションは、ユーザーが視覚的な不一致を認識しないように、次のペイントの前に同期的に起動する必要があります。（この違いは、概念的にはパッシブイベントリスナーとアクティブイベントリスナーに似ています。）これらのタイプのエフェクトのために、Reactは&lt;a href=&quot;#uselayouteffect&quot;&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; &lt;/a&gt;と呼ばれる1つの追加のフックを提供します。これは &lt;code&gt;useEffect&lt;/code&gt; と同じシグネチャを持ち、いつ起動されるかのみが異なります。</target>
        </trans-unit>
        <trans-unit id="66df5c038ad97c79d198f1c4a9bcf642fe39edab" translate="yes" xml:space="preserve">
          <source>However, sometimes it might be helpful to intentionally introduce an inconsistency. We could do it manually by &amp;ldquo;splitting&amp;rdquo; the state like above, but React also offers a built-in Hook for this:</source>
          <target state="translated">ただし、意図的に不整合を導入すると役立つ場合があります。上記のように状態を「分割」することで手動で行うこともできますが、Reactにはこのための組み込みフックも用意されています。</target>
        </trans-unit>
        <trans-unit id="684d4b7ace58812c1c1257030e5191e892f4d124" translate="yes" xml:space="preserve">
          <source>However, sometimes it&amp;rsquo;s useful to insert a child into a different location in the DOM:</source>
          <target state="translated">ただし、DOMの別の場所に子を挿入すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="7873b7f443466f38d48c121a13c985ec5c569acf" translate="yes" xml:space="preserve">
          <source>However, sometimes the same data needs to be accessible by many components in the tree, and at different nesting levels. Context lets you &amp;ldquo;broadcast&amp;rdquo; such data, and changes to it, to all components below. Common examples where using context might be simpler than the alternatives include managing the current locale, theme, or a data cache.</source>
          <target state="translated">ただし、ツリー内の多くのコンポーネントから、異なるネストレベルで同じデータにアクセスできる必要がある場合があります。コンテキストを使用すると、このようなデータとその変更を以下のすべてのコンポーネントに「ブロードキャスト」できます。コンテキストの使用が他の方法よりも簡単である一般的な例には、現在のロケール、テーマ、またはデータキャッシュの管理が含まれます。</target>
        </trans-unit>
        <trans-unit id="23514e5e71b6ee6ebabf134e94bf282dd4ddd004" translate="yes" xml:space="preserve">
          <source>However, the experience feels really jarring. We were browsing a page, but it got replaced by a loading state right as we were interacting with it. It&amp;rsquo;s disorienting. &lt;strong&gt;Just like before, to avoid showing an undesirable loading state, we can wrap the state update in a transition:&lt;/strong&gt;</source>
          <target state="translated">しかし、この体験は本当に不快に感じます。私たちはページを閲覧していましたが、ページを操作していたので、ロード状態に置き換えられました。それは見当識障害です。&lt;strong&gt;以前と同様に、望ましくない読み込み状態を表示しないようにするには、状態の更新を遷移にラップします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b955a466dd5e01eaf645eec3e93c8799d5ab4f5" translate="yes" xml:space="preserve">
          <source>However, this may be overkill in some cases, like the subscription example from the previous section. We don&amp;rsquo;t need to create a new subscription on every update, only if the &lt;code&gt;source&lt;/code&gt; prop has changed.</source>
          <target state="translated">ただし、前のセクションのサブスクリプションの例のように、これは過剰な場合があります。 &lt;code&gt;source&lt;/code&gt; プロップが変更された場合にのみ、更新ごとに新しいサブスクリプションを作成する必要はありません。</target>
        </trans-unit>
        <trans-unit id="d54fc10053a808be02d653b28bf41ebcbb425fe4" translate="yes" xml:space="preserve">
          <source>However, this requires you to know exactly which methods need to be copied. You can use &lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;hoist-non-react-statics&lt;/a&gt; to automatically copy all non-React static methods:</source>
          <target state="translated">ただし、これには、どのメソッドをコピーする必要があるかを正確に知る必要があります。あなたは使用することができ&lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;ホイスト非反応-静力学の&lt;/a&gt;すべての非反応する静的メソッドを自動的にコピーするには：</target>
        </trans-unit>
        <trans-unit id="b543d8a8b990abf052de4f376f9d0b9c65f73938" translate="yes" xml:space="preserve">
          <source>However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa.</source>
          <target state="translated">しかし、この2つの入力は互いに同期している必要があります。摂氏入力を更新するとき、華氏入力は変換された温度を反映しなければなりませんし、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="bd3ad954f0338c11e6cda950a40addb37e02fd0f" translate="yes" xml:space="preserve">
          <source>However, you might still be wondering why React doesn&amp;rsquo;t just update &lt;code&gt;this.state&lt;/code&gt; immediately without re-rendering.</source>
          <target state="translated">ただし、なぜReactが再レンダリングせずに &lt;code&gt;this.state&lt;/code&gt; をただちに更新しないのか疑問に思われるかもしれません。</target>
        </trans-unit>
        <trans-unit id="1e059ed18e3f4b02238b502a8f5e588e0008af29" translate="yes" xml:space="preserve">
          <source>Ideally we want to write this once and have the &lt;code&gt;Clock&lt;/code&gt; update itself:</source>
          <target state="translated">理想的には、これを1回記述して、 &lt;code&gt;Clock&lt;/code&gt; 自体を更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a176af0e3541b91734625dec4f3b8292439dd1d" translate="yes" xml:space="preserve">
          <source>Ideas</source>
          <target state="translated">Ideas</target>
        </trans-unit>
        <trans-unit id="dbd660e2dd45612fbe7fcb2d52008460403f801b" translate="yes" xml:space="preserve">
          <source>Identify every component that renders something based on that state.</source>
          <target state="translated">その状態に基づいて何かをレンダリングするすべてのコンポーネントを識別します。</target>
        </trans-unit>
        <trans-unit id="96c7ee658b9e92f85c8bfec7b6c2a38fb96663d7" translate="yes" xml:space="preserve">
          <source>Identifying components with unsafe lifecycles</source>
          <target state="translated">安全でないライフサイクルを持つコンポーネントの特定</target>
        </trans-unit>
        <trans-unit id="634e92551f670791962e82615e588bc9e77eae60" translate="yes" xml:space="preserve">
          <source>Identifying unsafe lifecycles</source>
          <target state="translated">安全でないライフサイクルの識別</target>
        </trans-unit>
        <trans-unit id="c95633762d757325e688096b23309ad6ed512c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;children&lt;/code&gt; is a &lt;code&gt;Fragment&lt;/code&gt; it will be treated as a single child and not traversed.</source>
          <target state="translated">&lt;code&gt;children&lt;/code&gt; が &lt;code&gt;Fragment&lt;/code&gt; である場合、それは単一の子として扱われ、トラバースされません。</target>
        </trans-unit>
        <trans-unit id="d9ec8b74463d4b6788285debd449e8a36886f529" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is defined within a component, the following &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; will receive an additional parameter, the &lt;code&gt;context&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;contextTypes&lt;/code&gt; がコンポーネント内で定義されている場合、次の&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;ライフサイクルメソッド&lt;/a&gt;は、追加のパラメーターである &lt;code&gt;context&lt;/code&gt; オブジェクトを受け取ります。</target>
        </trans-unit>
        <trans-unit id="a7942ea96f993393244bb793ed3444403e13d0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is not defined, then &lt;code&gt;context&lt;/code&gt; will be an empty object.</source>
          <target state="translated">&lt;code&gt;contextTypes&lt;/code&gt; が定義されていない場合、 &lt;code&gt;context&lt;/code&gt; は空のオブジェクトになります。</target>
        </trans-unit>
        <trans-unit id="cb8bc3d5f6a162a81742105b7e5aa8a5814ce785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is not provided, it will be set by default to &lt;code&gt;'blue'&lt;/code&gt;:</source>
          <target state="translated">場合 &lt;code&gt;props.color&lt;/code&gt; が提供されていない、それはにデフォルトで設定される &lt;code&gt;'blue'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba93d4ea31d24880e40a17c457b5255600429f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is set to null, it will remain null:</source>
          <target state="translated">&lt;code&gt;props.color&lt;/code&gt; がnullに設定されている場合、nullのままになります。</target>
        </trans-unit>
        <trans-unit id="a6b6d366d7013c823d86f9937f864aa2f4eb5035" translate="yes" xml:space="preserve">
          <source>If a Minor Release Includes No New Features, Why Isn&amp;rsquo;t It a Patch?</source>
          <target state="translated">マイナーリリースに新機能が含まれていない場合、なぜそれがパッチではないのですか？</target>
        </trans-unit>
        <trans-unit id="7808973984d8e4c597980af26324716a790b3eb9" translate="yes" xml:space="preserve">
          <source>If a component is using multiple mixins and several mixins define the same lifecycle method (i.e. several mixins want to do some cleanup when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on mixins run in the order mixins were listed, followed by a method call on the component.</source>
          <target state="translated">コンポーネントが複数のミキシンを使用していて、複数のミキシンが同じライフサイクルメソッドを定義している場合(つまり、複数のミキシンがコンポーネントが破壊されたときにクリーンアップを行いたい場合)、すべてのライフサイクルメソッドが呼び出されることが保証されています。ミキシンに定義されたメソッドは、ミキシンがリストアップされた順に実行され、その後にコンポーネント上でメソッドが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="97235b567c0265f0d9926f25dc8829579aa2e646" translate="yes" xml:space="preserve">
          <source>If a feature is not documented, they may be accompanied by an &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">機能が文書化されていない場合は、&lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt;が伴う場合があります。</target>
        </trans-unit>
        <trans-unit id="c6bc1e73352759548987f8a409ddc10869579747" translate="yes" xml:space="preserve">
          <source>If a release includes non-essential changes &amp;mdash; such as internal refactors, changes to implementation details, performance improvements, or minor bugfixes &amp;mdash; we will bump the minor version even when there are no new features.</source>
          <target state="translated">リリースに内部のリファクタリング、実装の詳細の変更、パフォーマンスの改善、またはマイナーなバグ修正などの重要でない変更が含まれている場合、新しい機能がない場合でもマイナーバージョンを変更します。</target>
        </trans-unit>
        <trans-unit id="b8ff55774a140aca8bdaed69bfb51da5366dacc0" translate="yes" xml:space="preserve">
          <source>If a single element&amp;rsquo;s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the warning by adding &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; to the element. It only works one level deep, and is intended to be an escape hatch. Don&amp;rsquo;t overuse it. Unless it&amp;rsquo;s text content, React still won&amp;rsquo;t attempt to patch it up, so it may remain inconsistent until future updates.</source>
          <target state="translated">単一の要素の属性またはテキストコンテンツがサーバーとクライアント間で不可避的に異なる場合（タイムスタンプなど）は、要素に &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; を追加することで警告を止めることができます。これは1レベルの深さでのみ機能し、脱出ハッチとして使用することを目的としています。使いすぎないでください。テキストコンテンツでない限り、Reactはパッチを適用しようとはしません。そのため、将来の更新まで一貫性がない可能性があります。</target>
        </trans-unit>
        <trans-unit id="d556b20cb4547e127f2815074ef2fe4e41710802" translate="yes" xml:space="preserve">
          <source>If a tag is empty, you may close it immediately with &lt;code&gt;/&amp;gt;&lt;/code&gt;, like XML:</source>
          <target state="translated">タグが空の場合、XMLのように &lt;code&gt;/&amp;gt;&lt;/code&gt; ですぐに閉じることができます。</target>
        </trans-unit>
        <trans-unit id="3b320bf64ff848996f74d77101a47dfdd619e264" translate="yes" xml:space="preserve">
          <source>If after that we still don&amp;rsquo;t use any values from the component scope, it&amp;rsquo;s safe to specify &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">その後もコンポーネントスコープの値を使用しない場合は、 &lt;code&gt;[]&lt;/code&gt; を指定しても安全です。</target>
        </trans-unit>
        <trans-unit id="5b6b3e11e3d3c38135418032d8908ab5281f6aca" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;bind&lt;/code&gt; annoys you, there are two ways you can get around this. If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use class fields to correctly bind callbacks:</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; を呼び出すと不快に感じる場合、これを回避するには2つの方法があります。実験的な&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;パブリッククラスフィールド構文&lt;/a&gt;を使用している場合は、クラスフィールドを使用してコールバックを正しくバインドできます。</target>
        </trans-unit>
        <trans-unit id="58ab379086a708259f83594879dae195d221ed0e" translate="yes" xml:space="preserve">
          <source>If everything passes, great! You can expect that your project will work with the next minor React release.</source>
          <target state="translated">すべてが合格したら、素晴らしいですね。あなたのプロジェクトが次のマイナーなReactリリースで動作することを期待できます。</target>
        </trans-unit>
        <trans-unit id="c6bec09d61efa659eb228a4953584f79786650d2" translate="yes" xml:space="preserve">
          <source>If fetching user details takes three seconds, we&amp;rsquo;ll only &lt;em&gt;start&lt;/em&gt; fetching the posts after three seconds! That&amp;rsquo;s a &amp;ldquo;waterfall&amp;rdquo;: an unintentional &lt;em&gt;sequence&lt;/em&gt; that should have been parallelized.</source>
          <target state="translated">ユーザーの詳細を取得するのに3秒かかる場合、投稿の取得は3秒後に&lt;em&gt;開始され&lt;/em&gt;ます。それは「ウォーターフォール」です。つまり、並列化されているはずの意図しない&lt;em&gt;シーケンス&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="61455d144dae27e035208c57b22d9252594b892f" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s still not clear which type of component you should use for a particular situation, you might find &lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;this article on controlled versus uncontrolled inputs&lt;/a&gt; to be helpful.</source>
          <target state="translated">特定の状況でどのタイプのコンポーネントを使用する必要があるかがまだ明確でない場合は&lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;、制御された入力と制御されていない入力に関するこの記事&lt;/a&gt;が役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="64a099559eb261307dc775d158033df86e50e770" translate="yes" xml:space="preserve">
          <source>If no array is provided, a new value will be computed on every render.</source>
          <target state="translated">配列が指定されていない場合は、レンダリングのたびに新しい値が計算されます。</target>
        </trans-unit>
        <trans-unit id="44bfdbf92e17d273381e7b8fb1a3f01879ecf26c" translate="yes" xml:space="preserve">
          <source>If some common scenario is not covered, please let us know on the &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;issue tracker&lt;/a&gt; for the documentation website.</source>
          <target state="translated">一般的なシナリオがカバーされていない場合は、ドキュメントWebサイトの&lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;課題追跡&lt;/a&gt;でお知らせください。</target>
        </trans-unit>
        <trans-unit id="0387b7a09358144d9726581e47b1de8c8b84739d" translate="yes" xml:space="preserve">
          <source>If some component &amp;ldquo;suspends&amp;rdquo;, does the app freeze? How to avoid this?</source>
          <target state="translated">一部のコンポーネントが「中断」した場合、アプリはフリーズしますか？これを回避するには？</target>
        </trans-unit>
        <trans-unit id="fb69be684ead34368506e903349ff51d28c48c95" translate="yes" xml:space="preserve">
          <source>If some value isn&amp;rsquo;t used for rendering or data flow (for example, a timer ID), you don&amp;rsquo;t have to put it in the state. Such values can be defined as fields on the component instance.</source>
          <target state="translated">レンダリングまたはデータフローに使用されない値（たとえば、タイマーID）がある場合、その値を状態にする必要はありません。このような値は、コンポーネントインスタンスのフィールドとして定義できます。</target>
        </trans-unit>
        <trans-unit id="bb0fa5a864d283d560c5564be4c37fdc16ee5c7f" translate="yes" xml:space="preserve">
          <source>If something breaks unexpectedly, please let us know by &lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;filing an issue&lt;/a&gt;.</source>
          <target state="translated">何かが予期せず破損した場合は&lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;、問題を報告し&lt;/a&gt;てお知らせください。</target>
        </trans-unit>
        <trans-unit id="e81b0e7afa3fb271a0976602cc04371ca693d752" translate="yes" xml:space="preserve">
          <source>If something can be derived from either props or state, it probably shouldn&amp;rsquo;t be in the state. For example, instead of storing both &lt;code&gt;celsiusValue&lt;/code&gt; and &lt;code&gt;fahrenheitValue&lt;/code&gt;, we store just the last edited &lt;code&gt;temperature&lt;/code&gt; and its &lt;code&gt;scale&lt;/code&gt;. The value of the other input can always be calculated from them in the &lt;code&gt;render()&lt;/code&gt; method. This lets us clear or apply rounding to the other field without losing any precision in the user input.</source>
          <target state="translated">何かが小道具または状態のいずれかから派生できる場合、それはおそらく状態であってはなりません。たとえば、 &lt;code&gt;celsiusValue&lt;/code&gt; と &lt;code&gt;fahrenheitValue&lt;/code&gt; の両方を保存する代わりに、最後に編集された &lt;code&gt;temperature&lt;/code&gt; とその &lt;code&gt;scale&lt;/code&gt; だけを保存します。他の入力の値は、 &lt;code&gt;render()&lt;/code&gt; メソッドで常にそれらから計算できます。これにより、ユーザー入力の精度を失うことなく、他のフィールドに丸めをクリアまたは適用できます。</target>
        </trans-unit>
        <trans-unit id="1e1eff28de072c228c3fac6f7de4af84285d52c7" translate="yes" xml:space="preserve">
          <source>If something is missing in the documentation or if you found some part confusing, please &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;file an issue for the documentation repository&lt;/a&gt; with your suggestions for improvement, or tweet at the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt;. We love hearing from you!</source>
          <target state="translated">ドキュメントに欠けている部分や、混乱している部分がある場合&lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;は、ドキュメントリポジトリに問題を報告&lt;/a&gt;して改善の提案をするか、&lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@ reactjsアカウントで&lt;/a&gt;ツイートしてください。ご連絡をお待ちしております。</target>
        </trans-unit>
        <trans-unit id="9ba9933df2ec0f3c00ec311cb0e316ed0a71e056" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Calculator&lt;/code&gt; owns the shared state, it becomes the &amp;ldquo;source of truth&amp;rdquo; for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both &lt;code&gt;TemperatureInput&lt;/code&gt; components are coming from the same parent &lt;code&gt;Calculator&lt;/code&gt; component, the two inputs will always be in sync.</source>
          <target state="translated">&lt;code&gt;Calculator&lt;/code&gt; が共有状態を所有している場合、それは両方の入力の現在の温度の「真の情報源」になります。両方に、互いに一貫した値を持つように指示できます。両方の &lt;code&gt;TemperatureInput&lt;/code&gt; コンポーネントの小道具は同じ親 &lt;code&gt;Calculator&lt;/code&gt; コンポーネントからのものであるため、2つの入力は常に同期します。</target>
        </trans-unit>
        <trans-unit id="e1508d0b9f38075d8659f83a363a29e0a2c1eb40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Clock&lt;/code&gt; component is ever removed from the DOM, React calls the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method so the timer is stopped.</source>
          <target state="translated">場合は &lt;code&gt;Clock&lt;/code&gt; 部品はこれまでDOMから削除され、通話が反応 &lt;code&gt;componentWillUnmount()&lt;/code&gt; タイマーが停止しているように、ライフサイクルメソッドを。</target>
        </trans-unit>
        <trans-unit id="285cc10d670d67e7a1d042087524d72b3c61948c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref&lt;/code&gt; callback is defined as an inline function, it will get called twice during updates, first with &lt;code&gt;null&lt;/code&gt; and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the &lt;code&gt;ref&lt;/code&gt; callback as a bound method on the class, but note that it shouldn&amp;rsquo;t matter in most cases.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; コールバックがインライン関数として定義されている場合、更新中に2回呼び出されます。最初は &lt;code&gt;null&lt;/code&gt; で、次にDOM要素で呼び出されます。これは、レンダリングのたびに関数の新しいインスタンスが作成されるため、Reactは古い参照をクリアして新しい参照を設定する必要があるためです。これは、 &lt;code&gt;ref&lt;/code&gt; コールバックをクラスのバインドされたメソッドとして定義することで回避できますが、ほとんどの場合問題にはならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a11443443fa44ef2cec37924f0c1f90e49c7f394" translate="yes" xml:space="preserve">
          <source>If the React element was previously rendered into &lt;code&gt;container&lt;/code&gt;, this will perform an update on it and only mutate the DOM as necessary to reflect the latest React element.</source>
          <target state="translated">React要素が以前に &lt;code&gt;container&lt;/code&gt; にレンダリングされていた場合、これにより更新が行われ、最新のReact要素を反映するために必要な場合にのみDOMが変更されます。</target>
        </trans-unit>
        <trans-unit id="f68368472358ffa4040481d1ccc81327648d3fb5" translate="yes" xml:space="preserve">
          <source>If the boilerplate code is too unattractive to you, you may enable the &lt;strong&gt;experimental&lt;/strong&gt;&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;Class Properties&lt;/a&gt; syntax proposal with Babel:</source>
          <target state="translated">ボイラープレートコードが魅力的でない場合は、Babelで&lt;strong&gt;実験的な&lt;/strong&gt;&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;クラスプロパティ&lt;/a&gt;構文の提案を有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="b1524d0a0bb3f485163f09431911716ee3095bb5" translate="yes" xml:space="preserve">
          <source>If the function you&amp;rsquo;re calling is a pure computation and is safe to call while rendering, you may &lt;strong&gt;call it outside of the effect instead,&lt;/strong&gt; and make the effect depend on the returned value.</source>
          <target state="translated">呼び出す関数が純粋な計算であり、レンダリング中に安全に呼び出すことができる場合&lt;strong&gt;は、代わりにエフェクトの外側で呼び出し&lt;/strong&gt;、戻り値に応じてエフェクトを作成できます。</target>
        </trans-unit>
        <trans-unit id="72c76fa2e50dee5e670f91c11fbf1264bff2a124" translate="yes" xml:space="preserve">
          <source>If the new state is computed using the previous state, you can pass a function to &lt;code&gt;setState&lt;/code&gt;. The function will receive the previous value, and return an updated value. Here&amp;rsquo;s an example of a counter component that uses both forms of &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="translated">以前の状態を使用して新しい状態を計算する場合は、関数を &lt;code&gt;setState&lt;/code&gt; に渡すことができます。関数は前の値を受け取り、更新された値を返します。次に、両方の形式の &lt;code&gt;setState&lt;/code&gt; を使用するカウンターコンポーネントの例を示します。</target>
        </trans-unit>
        <trans-unit id="4d5fb4c02d4fde303749802adf11f045d7e01c08" translate="yes" xml:space="preserve">
          <source>If the only way your component ever changes is when the &lt;code&gt;props.color&lt;/code&gt; or the &lt;code&gt;state.count&lt;/code&gt; variable changes, you could have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; check that:</source>
          <target state="translated">あなたのコンポーネントがこれまで変わる唯一の方法は、時にある場合 &lt;code&gt;props.color&lt;/code&gt; または &lt;code&gt;state.count&lt;/code&gt; 変数の変更は、あなたが持っている可能性があり &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ：というチェックを</target>
        </trans-unit>
        <trans-unit id="8d4d632eeb98bbd6eb7a8cf7c7cf0db0d585a084" translate="yes" xml:space="preserve">
          <source>If the optional callback is provided, it will be executed after the component is rendered or updated.</source>
          <target state="translated">オプションのコールバックが提供されている場合、コンポーネントがレンダリングまたは更新された後に実行されます。</target>
        </trans-unit>
        <trans-unit id="9825426bb3519158f32e335335bf1288ffbb02ac" translate="yes" xml:space="preserve">
          <source>If the other module fails to load (for example, due to network failure), it will trigger an error. You can handle these errors to show a nice user experience and manage recovery with &lt;a href=&quot;error-boundaries&quot;&gt;Error Boundaries&lt;/a&gt;. Once you&amp;rsquo;ve created your Error Boundary, you can use it anywhere above your lazy components to display an error state when there&amp;rsquo;s a network error.</source>
          <target state="translated">他のモジュールがロードに失敗した場合（ネットワーク障害などが原因）、エラーが発生します。これらのエラーを処理して、優れたユーザーエクスペリエンスを示し、&lt;a href=&quot;error-boundaries&quot;&gt;エラー境界を&lt;/a&gt;使用して回復を管理できます。エラー境界を作成したら、それを遅延コンポーネントの上の任意の場所で使用して、ネットワークエラーが発生したときにエラー状態を表示できます。</target>
        </trans-unit>
        <trans-unit id="6d645637af0f89ddb43e30926c108ad1d42dea97" translate="yes" xml:space="preserve">
          <source>If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. &lt;strong&gt;In most cases, you can attach a ref to the DOM node and avoid using &lt;code&gt;findDOMNode&lt;/code&gt; at all.&lt;/strong&gt;</source>
          <target state="translated">このコンポーネントがDOMにマウントされている場合、これは対応するネイティブブラウザDOM要素を返します。このメソッドは、フォームフィールド値などのDOMから値を読み取り、DOM測定を実行するのに役立ちます。&lt;strong&gt;ほとんどの場合、DOMノードに参照をアタッチして、 &lt;code&gt;findDOMNode&lt;/code&gt; をまったく使用しないようにすることができます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2beaac6d52020b7f238083eeeeccbf47e42f3e4b" translate="yes" xml:space="preserve">
          <source>If two or more context values are often used together, you might want to consider creating your own render prop component that provides both.</source>
          <target state="translated">2 つ以上のコンテキスト値を一緒に使用することが多い場合は、両方を提供する独自のレンダー プロップ コンポーネントを作成することを検討するとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="d1f978898c43c050ba9392e9f7a52dfcd4549f6d" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want some component to delay the transition, we can wrap it in its own &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary.</source>
          <target state="translated">一部のコンポーネントで遷移を遅らせたくない場合は、それを独自の &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 境界でラップできます。</target>
        </trans-unit>
        <trans-unit id="19013949653b81e2adb86a0553d1ff708b6beb68" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to load this component in our tests, we can mock out the dependency itself to a dummy component, and run our tests:</source>
          <target state="translated">テストでこのコンポーネントをロードしたくない場合は、依存関係自体をダミーコンポーネントにモックアウトして、テストを実行できます。</target>
        </trans-unit>
        <trans-unit id="cc989df7c0d84bfb51075d6a4b04861fa37c52c1" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to stay in the Pending state for too long, our first instinct might be to set &lt;code&gt;timeoutMs&lt;/code&gt; in &lt;code&gt;useTransition&lt;/code&gt; to something smaller, like &lt;code&gt;3000&lt;/code&gt;. You can try this &lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;here&lt;/a&gt;. This lets us escape the prolonged Pending state, but we still don&amp;rsquo;t have anything useful to show!</source>
          <target state="translated">我々はあまりにも長い間保留状態に滞在したくない場合は、私たちの最初の本能は、セットにあるかもしれない &lt;code&gt;timeoutMs&lt;/code&gt; で &lt;code&gt;useTransition&lt;/code&gt; のような、小さいものに &lt;code&gt;3000&lt;/code&gt; 。これを&lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;ここで&lt;/a&gt;試すことができます。これにより、長い保留中の状態を回避できますが、表示する有用なものはまだありません！</target>
        </trans-unit>
        <trans-unit id="b28361e99b6744be8efafa4d49b562aaade2f3b5" translate="yes" xml:space="preserve">
          <source>If we intentionally &lt;em&gt;want&lt;/em&gt; to show an inconsistent UI for a small period of time, can we do that?</source>
          <target state="translated">一貫性のないUI を意図的に&lt;em&gt;短時間&lt;/em&gt;表示し&lt;em&gt;たい&lt;/em&gt;場合は、それを実行できますか？</target>
        </trans-unit>
        <trans-unit id="dc070f0d7e8042a80001420c3eae7347b4592739" translate="yes" xml:space="preserve">
          <source>If we just wanted to set an interval, we wouldn&amp;rsquo;t need the ref (&lt;code&gt;id&lt;/code&gt; could be local to the effect), but it&amp;rsquo;s useful if we want to clear the interval from an event handler:</source>
          <target state="translated">間隔を設定するだけの場合は、ref（ &lt;code&gt;id&lt;/code&gt; はエフェクトに対してローカルである可能性があります）は必要ありませんが、イベントハンドラーから間隔をクリアする場合に便利です。</target>
        </trans-unit>
        <trans-unit id="10129e51e2f781d3b2a1978fc9c0500021cdb2cc" translate="yes" xml:space="preserve">
          <source>If we later edit the Fahrenheit field to be 212, the state of the &lt;code&gt;Calculator&lt;/code&gt; will be:</source>
          <target state="translated">後で華氏フィールドを212に編集すると、 &lt;code&gt;Calculator&lt;/code&gt; の状態は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5ef4de5727a1ae42b86ddd7ac75d5b2cb2686cbb" translate="yes" xml:space="preserve">
          <source>If we make our API responses take 5 seconds, &lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;we can confirm&lt;/a&gt; that now React &amp;ldquo;gives up&amp;rdquo; and transitions anyway to the next screen after 3 seconds. This is because we passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to &lt;code&gt;useTransition()&lt;/code&gt;. For example, if we passed &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; instead, it would wait a whole minute.</source>
          <target state="translated">API応答に5秒かかるように&lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;する&lt;/a&gt;と、Reactが「起動」し、3秒後に次の画面に移行することを確認できます。これは、 &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; を &lt;code&gt;useTransition()&lt;/code&gt; に渡したためです。たとえば、代わりに &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; を渡した場合、1分間待機します。</target>
        </trans-unit>
        <trans-unit id="0d759d3e1bb1bdd18c1893117d44336d9737a917" translate="yes" xml:space="preserve">
          <source>If we try this code, it might seem like it works at first. However, if we randomize the delay time in our &amp;ldquo;fake API&amp;rdquo; implementation and press the &amp;ldquo;Next&amp;rdquo; button fast enough, we&amp;rsquo;ll see from the console logs that something is going very wrong. &lt;strong&gt;Requests from the previous profiles may sometimes &amp;ldquo;come back&amp;rdquo; after we&amp;rsquo;ve already switched the profile to another ID &amp;mdash; and in that case they can overwrite the new state with a stale response for a different ID.&lt;/strong&gt;</source>
          <target state="translated">このコードを試してみると、最初は機能しているように見えるかもしれません。ただし、「偽のAPI」実装で遅延時間をランダム化し、「次へ」ボタンを十分に速く押すと、コンソールログから、何かが非常にうまくいっていないことがわかります。&lt;strong&gt;以前のプロファイルからのリクエストは、プロファイルを別のIDに切り替えた後で「戻ってくる」ことがあります。その場合、別のIDの古い応答で新しい状態を上書きできます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be3a9278266bf705f6dd179c22a52cc57d1c6f99" translate="yes" xml:space="preserve">
          <source>If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions:</source>
          <target state="translated">これをReactで使った場合、1000個の要素を表示するには10億回の比較が必要になります。これはあまりにも高額です。代わりに、Reactは2つの前提条件に基づいて、ヒューリスティックなO(n)アルゴリズムを実装しています。</target>
        </trans-unit>
        <trans-unit id="0bd6f78d0df5d6a5d29d430057c8831c6b2afedc" translate="yes" xml:space="preserve">
          <source>If we wanted to wrap the &lt;code&gt;CustomTextInput&lt;/code&gt; above to simulate it being clicked immediately after mounting, we could use a ref to get access to the custom input and call its &lt;code&gt;focusTextInput&lt;/code&gt; method manually:</source>
          <target state="translated">上記の &lt;code&gt;CustomTextInput&lt;/code&gt; をラップして、マウント直後にクリックされることをシミュレートする場合は、refを使用してカスタム入力にアクセスし、その &lt;code&gt;focusTextInput&lt;/code&gt; メソッドを手動で呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="406ca61e719e6f4e1e3008d4b342561469a8b770" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re willing to sacrifice consistency, we could &lt;strong&gt;pass potentially stale data to the components that delay our transition&lt;/strong&gt;. That&amp;rsquo;s what &lt;code&gt;useDeferredValue()&lt;/code&gt; lets us do:</source>
          <target state="translated">一貫性を犠牲にしてもかまわない場合は、&lt;strong&gt;古くなっている可能性のあるデータを、移行を遅延させるコンポーネントに渡す&lt;/strong&gt;ことができ&lt;strong&gt;ます&lt;/strong&gt;。これが、 &lt;code&gt;useDeferredValue()&lt;/code&gt; で実行できることです。</target>
        </trans-unit>
        <trans-unit id="6c9413bd0fc5834a029e8af7dddbd9382c56068a" translate="yes" xml:space="preserve">
          <source>If you already have &lt;code&gt;props&lt;/code&gt; as an object, and you want to pass it in JSX, you can use &lt;code&gt;...&lt;/code&gt; as a &amp;ldquo;spread&amp;rdquo; operator to pass the whole props object. These two components are equivalent:</source>
          <target state="translated">オブジェクトとして &lt;code&gt;props&lt;/code&gt; がすでにあり、それをJSXで渡したい場合、「スプレッド」演算子として &lt;code&gt;...&lt;/code&gt; を使用して、プロップオブジェクト全体を渡すことができます。これら2つのコンポーネントは同等です。</target>
        </trans-unit>
        <trans-unit id="8735706de7bdc6d287d2a819b6a76fae1e775b79" translate="yes" xml:space="preserve">
          <source>If you already minify the application scripts, &lt;strong&gt;your site will be production-ready&lt;/strong&gt; if you ensure that the deployed HTML loads the versions of React ending in &lt;code&gt;production.min.js&lt;/code&gt;:</source>
          <target state="translated">すでにアプリケーションスクリプトを縮小している場合、デプロイされたHTMLが &lt;code&gt;production.min.js&lt;/code&gt; で終わるバージョンのReactを確実にロードすれば&lt;strong&gt;、サイトは本番&lt;/strong&gt;環境に&lt;strong&gt;対応でき&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1cd058484ca6af46bd0f0bdc60864ddb7e7bdf9f" translate="yes" xml:space="preserve">
          <source>If you are confident you want to write it by hand, you may compare &lt;code&gt;this.props&lt;/code&gt; with &lt;code&gt;nextProps&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; with &lt;code&gt;nextState&lt;/code&gt; and return &lt;code&gt;false&lt;/code&gt; to tell React the update can be skipped. Note that returning &lt;code&gt;false&lt;/code&gt; does not prevent child components from re-rendering when &lt;em&gt;their&lt;/em&gt; state changes.</source>
          <target state="translated">手動で記述したい場合は、 &lt;code&gt;this.props&lt;/code&gt; を &lt;code&gt;nextProps&lt;/code&gt; と、 &lt;code&gt;this.state&lt;/code&gt; を &lt;code&gt;nextState&lt;/code&gt; と比較し、 &lt;code&gt;false&lt;/code&gt; を返してReactに更新をスキップできることを伝えます。 &lt;code&gt;false&lt;/code&gt; を返しても&lt;em&gt;、&lt;/em&gt;状態が変化したときに子コンポーネントが再レンダリングされるのを妨げないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="15c76b0412bce989363700bf2ef3011d9639d358" translate="yes" xml:space="preserve">
          <source>If you are using a Babel transform like &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-properties&lt;/a&gt; , you can also declare &lt;code&gt;defaultProps&lt;/code&gt; as static property within a React component class. This syntax has not yet been finalized though and will require a compilation step to work within a browser. For more information, see the &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class fields proposal&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-propertiesの&lt;/a&gt;ようなBabel変換を使用している場合は、Reactコンポーネントクラス内で &lt;code&gt;defaultProps&lt;/code&gt; を静的プロパティとして宣言することもできます。ただし、この構文はまだ確定されていないため、ブラウザー内で機能するにはコンパイル手順が必要になります。詳細については、&lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;クラスフィールドの提案を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="75b66416e2290abd98cf21dbd99025df7c4ba6a0" translate="yes" xml:space="preserve">
          <source>If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use a &lt;strong&gt;static&lt;/strong&gt; class field to initialize your &lt;code&gt;contextType&lt;/code&gt;.</source>
          <target state="translated">実験的な&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;パブリッククラスフィールド構文&lt;/a&gt;を使用して&lt;strong&gt;いる&lt;/strong&gt;場合は、&lt;strong&gt;静的&lt;/strong&gt;クラスフィールドを使用して、 &lt;code&gt;contextType&lt;/code&gt; を初期化できます。</target>
        </trans-unit>
        <trans-unit id="2bcd73af03cb4d3e4e3b7c1bd1f74a1bd7b665d0" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t sure whether your build process is set up correctly, you can check it by installing &lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;React Developer Tools for Chrome&lt;/a&gt;. If you visit a site with React in production mode, the icon will have a dark background:</source>
          <target state="translated">ビルドプロセスが正しく設定されているかどうかわからない場合は、&lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;React Developer Tools for Chromeを&lt;/a&gt;インストールして確認できます。プロダクションモードでReactを使用してサイトにアクセスすると、アイコンの背景が暗くなります。</target>
        </trans-unit>
        <trans-unit id="eb0c664da034e861544cfcdf5f02c8fd40d847b9" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using class fields syntax, you can use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; in the callback:</source>
          <target state="translated">クラスフィールド構文を使用していない場合は、コールバックで&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;矢印関数&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="38bf06802507eba86661f75bc21760f1686e68d8" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t, you&amp;rsquo;ll need to setup bundling yourself. For example, see the &lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;Installation&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;Getting Started&lt;/a&gt; guides on the Webpack docs.</source>
          <target state="translated">そうでない場合は、バンドリングを自分でセットアップする必要があります。例えば、参照&lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;インストール&lt;/a&gt;と&lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;入門&lt;/a&gt; WebPACKのドキュメントのガイドを。</target>
        </trans-unit>
        <trans-unit id="7e3292dd08de71388ad7c0b1a0bf8e95045ff37d" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.</source>
          <target state="translated">このサーバーレンダリングされたマークアップが既にあるノードで&lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt;を呼び出すと、Reactはそれを保持し、イベントハンドラーのみをアタッチするため、非常にパフォーマンスの高い初回ロードエクスペリエンスを実現できます。</target>
        </trans-unit>
        <trans-unit id="c12886015a122be4810ebe17201bb8cce342272e" translate="yes" xml:space="preserve">
          <source>If you call it on a &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; DOM node, it reads the attributes off of the original DOM node, hides it with an inline style, and then appends a separate DOM node with its own visual representation right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;. Then it fires jQuery events to notify us about the changes.</source>
          <target state="translated">&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; DOMノードで呼び出すと、元のDOMノードから属性を読み取り、インラインスタイルで非表示にしてから、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; の直後に独自の視覚表現を持つ別のDOMノードを追加します。次に、jQueryイベントを発生させて、変更について通知します。</target>
        </trans-unit>
        <trans-unit id="a4f9877110efff3327fdffedf68d4026372380df" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common owner component.</source>
          <target state="translated">状態を所有することに意味のあるコンポーネントが見つからない場合は、状態を保持するためだけに新しいコンポーネントを作成し、共通の所有者コンポーネントの上の階層のどこかに追加します。</target>
        </trans-unit>
        <trans-unit id="e80d72886f63f44e90c32f25b0726ec9919167cc" translate="yes" xml:space="preserve">
          <source>If you do have performance issues, by all means, optimize!</source>
          <target state="translated">パフォーマンスに問題がある場合は、ぜひ最適化してください。</target>
        </trans-unit>
        <trans-unit id="842af6389784f4195a6f44b18d1ae6472e5779f0" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t experience the problems described above or don&amp;rsquo;t feel comfortable using JavaScript tools yet, consider &lt;a href=&quot;add-react-to-a-website&quot;&gt;adding React as a plain &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag on an HTML page&lt;/a&gt;, optionally &lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;with JSX&lt;/a&gt;.</source>
          <target state="translated">上記の問題が発生しない場合、またはJavaScriptツールの使用に慣れていない場合&lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;は&lt;/a&gt;、オプションでJSXを使用し&lt;a href=&quot;add-react-to-a-website&quot;&gt;て、HTMLページ&lt;/a&gt;にReactをプレーンな &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグとして追加することを検討してください。</target>
        </trans-unit>
        <trans-unit id="c3a3d724ce9d7d08105873a53c6f8dacf835179a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a minification step for your scripts, &lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;here&amp;rsquo;s one way to set it up&lt;/a&gt;.</source>
          <target state="translated">スクリプトの縮小手順がない場合は、次の&lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;方法で設定でき&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="169a21de60ad2e2c1ea7fcef1a94d52e1be56808" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</source>
          <target state="translated">Create React Appを使用しない場合は、&lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;このプラグインを&lt;/a&gt;手動でBabel構成に追加できます。これは開発のみを目的としており&lt;strong&gt;、本番環境では無効にする必要が&lt;/strong&gt;あることに注意してください。</target>
        </trans-unit>
        <trans-unit id="59cb0765a73ef01c64e7a89fed250a66bd20f39c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 classes, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead. See &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; for more information.</source>
          <target state="translated">ES6クラスを使用しない場合は、代わりに &lt;code&gt;create-react-class&lt;/code&gt; モジュールを使用できます。詳細については、&lt;a href=&quot;react-without-es6&quot;&gt;ES6&lt;/a&gt;を使用せずにReactを使用するを参照してください。</target>
        </trans-unit>
        <trans-unit id="f856dc1fed776914cf062b3e550d19f3eb8f9429" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 yet, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead:</source>
          <target state="translated">ES6をまだ使用していない場合は、代わりに &lt;code&gt;create-react-class&lt;/code&gt; モジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="4b0b9b7af2dae0cbfcf4257fa36894387d46af3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Relay today, you might have to wait before you can really try Suspense in your app. So far, it&amp;rsquo;s the only implementation that we tested in production and are confident in.</source>
          <target state="translated">今日、Relayを使用しない場合は、アプリでサスペンスを実際に試す前に待たなければならない場合があります。これまでのところ、本番環境でテストし、信頼できる唯一の実装です。</target>
        </trans-unit>
        <trans-unit id="332383307eebba5d31fd9d269485dc3ba0b151a2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use a JavaScript bundler and loaded React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, it is already in scope as the &lt;code&gt;React&lt;/code&gt; global.</source>
          <target state="translated">JavaScriptバンドルを使用せず、 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグからReactをロードした場合、その &lt;code&gt;React&lt;/code&gt; はReactグローバルとしてすでにスコープに含まれています。</target>
        </trans-unit>
        <trans-unit id="6fce0593a2dfad3e9857ade52faf663322205bd6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use either Create React App or Babel, you can use &lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types&lt;/a&gt; to strip the type annotations.</source>
          <target state="translated">Create React AppもBabelも使用しない場合は、&lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types&lt;/a&gt;を使用して型注釈を削除できます。</target>
        </trans-unit>
        <trans-unit id="fb891743d28825149d46e0a3067c093baedd036f" translate="yes" xml:space="preserve">
          <source>If you feel completely stuck, start by keeping all files in a single folder. Eventually it will grow large enough that you will want to separate some files from the rest. By that time you&amp;rsquo;ll have enough knowledge to tell which files you edit together most often. In general, it is a good idea to keep files that often change together close to each other. This principle is called &amp;ldquo;colocation&amp;rdquo;.</source>
          <target state="translated">完全に行き詰まっていると感じた場合は、最初にすべてのファイルを1つのフォルダに保存します。最終的には、一部のファイルを残りのファイルから分離したくなるほど大きくなります。その時までには、どのファイルを一緒に最も頻繁に編集するかを知るのに十分な知識が身に付くでしょう。一般に、一緒に頻繁に変更されるファイルを互いに近くに置くことをお勧めします。この原理は「コロケーション」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="df68e6e9e49708727aa3d9b52f358771b20204ab" translate="yes" xml:space="preserve">
          <source>If you feel that the React documentation goes at a faster pace than you&amp;rsquo;re comfortable with, check out &lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;this overview of React by Tania Rascia&lt;/a&gt;. It introduces the most important React concepts in a detailed, beginner-friendly way. Once you&amp;rsquo;re done, give the documentation another try!</source>
          <target state="translated">Reactのドキュメントが慣れているよりも速いペースで進むと思われる場合は、&lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;このTania RasciaによるReactの概要を&lt;/a&gt;確認してください。初心者にやさしい方法で、Reactの最も重要な概念を紹介します。完了したら、ドキュメントをもう一度試してください。</target>
        </trans-unit>
        <trans-unit id="4d81fbc72ec17b2e89d0c20f4ef89b52ec88b669" translate="yes" xml:space="preserve">
          <source>If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</source>
          <target state="translated">なんらかの理由で基になるブラウザーイベントが必要であることが &lt;code&gt;nativeEvent&lt;/code&gt; 場合は、nativeEvent属性を使用して取得します。すべての &lt;code&gt;SyntheticEvent&lt;/code&gt; オブジェクトには次の属性があります。</target>
        </trans-unit>
        <trans-unit id="76310cae2aa02095c07fe271a1cb7cd76b5e2f80" translate="yes" xml:space="preserve">
          <source>If you first click &amp;ldquo;Show alert&amp;rdquo; and then increment the counter, the alert will show the &lt;code&gt;count&lt;/code&gt; variable &lt;strong&gt;at the time you clicked the &amp;ldquo;Show alert&amp;rdquo; button&lt;/strong&gt;. This prevents bugs caused by the code assuming props and state don&amp;rsquo;t change.</source>
          <target state="translated">最初に[アラートを表示]をクリックしてからカウンターをインクリメントすると、アラートには、[アラートを表示&lt;strong&gt;]ボタンをクリックしたときに&lt;/strong&gt; &lt;code&gt;count&lt;/code&gt; 変数&lt;strong&gt;が表示されます&lt;/strong&gt;。これにより、小道具と状態が変化しないことを前提としたコードによって引き起こされるバグが防止されます。</target>
        </trans-unit>
        <trans-unit id="88c29ce29fd299ea922160b41c611cec1eecbc8a" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run Flow for the first time.</source>
          <target state="translated">上記の手順を踏めば、初めてFlowを実行できるはずです。</target>
        </trans-unit>
        <trans-unit id="c5309b9cba3e5ecb4cc81e27f68ffbda4d5dab96" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run TypeScript for the first time.</source>
          <target state="translated">上記の手順を踏めば、初めてTypeScriptを実行できるはずです。</target>
        </trans-unit>
        <trans-unit id="35f39f38f2b3af85590f8b59543c367401e440f4" translate="yes" xml:space="preserve">
          <source>If you get tired of typing &lt;code&gt;React.createElement&lt;/code&gt; so much, one common pattern is to assign a shorthand:</source>
          <target state="translated">&lt;code&gt;React.createElement&lt;/code&gt; の入力にうんざりしている場合、一般的なパターンの1つは、省略形を割り当てることです。</target>
        </trans-unit>
        <trans-unit id="7325f76c86bc8debb6d4b74351284f0958afc1d0" translate="yes" xml:space="preserve">
          <source>If you have a large existing app, or if your app depends on a lot of third-party packages, please don&amp;rsquo;t expect that you can use the Concurrent Mode immediately. &lt;strong&gt;For example, at Facebook we are using Concurrent Mode for the new website, but we&amp;rsquo;re not planning to enable it on the old website.&lt;/strong&gt; This is because our old website still uses unsafe lifecycle methods in the product code, incompatible third-party libraries, and patterns that don&amp;rsquo;t work well with the Concurrent Mode.</source>
          <target state="translated">既存のアプリが大きい場合、またはアプリが多くのサードパーティパッケージに依存している場合は、同時モードをすぐに使用できるとは期待しないでください。&lt;strong&gt;たとえば、Facebookでは新しいWebサイトに同時モードを使用していますが、古いWebサイトでそれを有効にする予定はありません。&lt;/strong&gt;これは、私たちの古いWebサイトが、製品コードで安全でないライフサイクルメソッド、互換性のないサードパーティライブラリ、および並行モードでうまく機能しないパターンをまだ使用しているためです。</target>
        </trans-unit>
        <trans-unit id="049b884296cbaec372f91838646c82b517badc89" translate="yes" xml:space="preserve">
          <source>If you have an event handler such as &lt;code&gt;onClick&lt;/code&gt; or &lt;code&gt;onScroll&lt;/code&gt; and want to prevent the callback from being fired too quickly, then you can limit the rate at which callback is executed. This can be done by using:</source>
          <target state="translated">&lt;code&gt;onClick&lt;/code&gt; や &lt;code&gt;onScroll&lt;/code&gt; などのイベントハンドラーがあり、コールバックがすぐに起動されないようにしたい場合は、コールバックが実行されるレートを制限できます。これは、以下を使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="4c213f4472d12ecabe35b829a19649d2ed0d0411" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed the React DevTools, you can find them here:</source>
          <target state="translated">React DevToolsをまだインストールしていない場合は、ここで見つけることができます。</target>
        </trans-unit>
        <trans-unit id="6f4eeb14778b01a7164c9500da7ff7d43818dfb4" translate="yes" xml:space="preserve">
          <source>If you imagine a component tree as a waterfall of props, each component&amp;rsquo;s state is like an additional water source that joins it at an arbitrary point but also flows down.</source>
          <target state="translated">コンポーネントツリーを小道具の滝として想像すると、各コンポーネントの状態は、任意のポイントでそれを結合するだけでなく流下する追加の水源のようなものです。</target>
        </trans-unit>
        <trans-unit id="827469f1283cc9cfff29c0d19a28165070940429" translate="yes" xml:space="preserve">
          <source>If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:</source>
          <target state="translated">素朴に実装した場合、最初に要素を挿入するとパフォーマンスが悪くなります。例えば、この2つの木の間で変換するとパフォーマンスが悪くなります。</target>
        </trans-unit>
        <trans-unit id="d15834c075532b4876fc67d3752aa2da60bdf369" translate="yes" xml:space="preserve">
          <source>If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like &lt;code&gt;this.state.isClient&lt;/code&gt;, which you can set to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration. Note that this approach will make your components slower because they have to render twice, so use it with caution.</source>
          <target state="translated">サーバーとクライアントで意図的に異なるものをレンダリングする必要がある場合は、2パスレンダリングを実行できます。クライアント上で異なるものをレンダリングするコンポーネントは、 &lt;code&gt;this.state.isClient&lt;/code&gt; のような状態変数を読み取ることができます。これは、 &lt;code&gt;componentDidMount()&lt;/code&gt; で &lt;code&gt;true&lt;/code&gt; に設定できます。このようにして、最初のレンダーパスはサーバーと同じコンテンツをレンダリングし、不一致を回避しますが、ハイドレーションの直後に追加のパスが同期的に発生します。この方法では、コンポーネントを2回レンダリングする必要があるため、コンポーネントの速度が低下することに注意してください。使用には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="286d3422088a5f59b246609f9ba1c043e52041ac" translate="yes" xml:space="preserve">
          <source>If you intentionally want to read the &lt;em&gt;latest&lt;/em&gt; state from some asynchronous callback, you could keep it in &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;a ref&lt;/a&gt;, mutate it, and read from it.</source>
          <target state="translated">非同期コールバックから&lt;em&gt;最新の&lt;/em&gt;状態を意図的に読み取る場合は、それを&lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;refに&lt;/a&gt;保持し、変更して、そこから読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="e225027ec18fdfd87c9b8442cffb1951bc054fb1" translate="yes" xml:space="preserve">
          <source>If you know that in some situations your component doesn&amp;rsquo;t need to update, you can return &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt; instead, to skip the whole rendering process, including calling &lt;code&gt;render()&lt;/code&gt; on this component and below.</source>
          <target state="translated">一部の状況でコンポーネントを更新する必要がないことがわかっている場合は、代わりに &lt;code&gt;shouldComponentUpdate&lt;/code&gt; から &lt;code&gt;false&lt;/code&gt; を返し、このコンポーネント以降で &lt;code&gt;render()&lt;/code&gt; を呼び出すことを含め、レンダリングプロセス全体をスキップできます。</target>
        </trans-unit>
        <trans-unit id="f91d2eeadcd117626f038d440e0070b4483671a4" translate="yes" xml:space="preserve">
          <source>If you load React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, these top-level APIs are available on the &lt;code&gt;ReactDOM&lt;/code&gt; global. If you use ES6 with npm, you can write &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt;. If you use ES5 with npm, you can write &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグからReactをロードする場合、これらのトップレベルAPIは &lt;code&gt;ReactDOM&lt;/code&gt; グローバルで使用できます。 npmでES6を使用する場合 &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt; 作成できます。 npmでES5を使用する場合は、 &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt; 記述できます。</target>
        </trans-unit>
        <trans-unit id="b93e9d0b0522ffa63fd03295a5cdd6cf8a5e08ca" translate="yes" xml:space="preserve">
          <source>If you look at &lt;code&gt;ProductTable&lt;/code&gt;, you&amp;rsquo;ll see that the table header (containing the &amp;ldquo;Name&amp;rdquo; and &amp;ldquo;Price&amp;rdquo; labels) isn&amp;rsquo;t its own component. This is a matter of preference, and there&amp;rsquo;s an argument to be made either way. For this example, we left it as part of &lt;code&gt;ProductTable&lt;/code&gt; because it is part of rendering the &lt;em&gt;data collection&lt;/em&gt; which is &lt;code&gt;ProductTable&lt;/code&gt;&amp;rsquo;s responsibility. However, if this header grows to be complex (e.g., if we were to add affordances for sorting), it would certainly make sense to make this its own &lt;code&gt;ProductTableHeader&lt;/code&gt; component.</source>
          <target state="translated">あなたが見れば &lt;code&gt;ProductTable&lt;/code&gt; 、あなたは（「名前」と「価格」のラベルを含む）テーブルヘッダは、独自のコンポーネントではないことがわかります。これは好みの問題であり、どちらかの方法で行われるべき議論があります。この例では、 &lt;code&gt;ProductTable&lt;/code&gt; の責任である&lt;em&gt;データコレクション&lt;/em&gt;のレンダリングの一部であるため、 &lt;code&gt;ProductTable&lt;/code&gt; の一部として残しました。ただし、このヘッダーが複雑になる場合（たとえば、並べ替えのためにアフォーダンスを追加する場合）は、これを独自の &lt;code&gt;ProductTableHeader&lt;/code&gt; コンポーネントにすることは当然のことです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8d1d424e7e902eeef27e0e70b07d9c861ccdada" translate="yes" xml:space="preserve">
          <source>If you manually configured Babel for your project, you will need to install a special preset for Flow.</source>
          <target state="translated">プロジェクト用に手動でBabelを設定した場合は、Flow用の特別なプリセットをインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="2852832854adc219ab4e001ad21ce5c774975fe9" translate="yes" xml:space="preserve">
          <source>If you miss automatic merging, you can write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, instead &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</source>
          <target state="translated">自動マージを行わない場合は、オブジェクトの状態の更新をマージするカスタムの &lt;code&gt;useLegacyState&lt;/code&gt; フックを作成できます。ただし、代わり&lt;strong&gt;に、どの値が一緒に変化する傾向があるかに基づいて、状態を複数の状態変数に分割&lt;/strong&gt;する&lt;strong&gt;ことをお勧めします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d79521cbe23ba5b60b28726474c0765c13be1ba0" translate="yes" xml:space="preserve">
          <source>If you name the render function, DevTools will also include its name (e.g. &amp;rdquo;&lt;em&gt;ForwardRef(myFunction)&lt;/em&gt;&amp;rdquo;):</source>
          <target state="translated">レンダー関数に名前を付けると、DevToolsにもその名前が含まれます（例：&amp;rdquo; &lt;em&gt;ForwardRef（myFunction）&lt;/em&gt; &amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="86f30ff0b95e1da79af197894b22f7fa988c3f02" translate="yes" xml:space="preserve">
          <source>If you need to &lt;strong&gt;perform a side effect&lt;/strong&gt; (for example, data fetching or an animation) in response to a change in props, use &lt;a href=&quot;#componentdidupdate&quot;&gt;&lt;code&gt;componentDidUpdate&lt;/code&gt;&lt;/a&gt; lifecycle instead.</source>
          <target state="translated">小道具の変更に応じて&lt;strong&gt;副作用&lt;/strong&gt;（データのフェッチやアニメーションなど）を&lt;strong&gt;実行する&lt;/strong&gt;必要がある場合は、代わりに&lt;a href=&quot;#componentdidupdate&quot;&gt; &lt;code&gt;componentDidUpdate&lt;/code&gt; &lt;/a&gt;ライフサイクルを使用します。</target>
        </trans-unit>
        <trans-unit id="205f3177c868e6b279f403e9745e8dcaeb2d6fd7" translate="yes" xml:space="preserve">
          <source>If you need to catch an error inside event handler, use the regular JavaScript &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; statement:</source>
          <target state="translated">イベントハンドラー内のエラーをキャッチする必要がある場合は、通常のJavaScriptの &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; ステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="70a74f7dd4fe0268f156490184fdd512266a1aa6" translate="yes" xml:space="preserve">
          <source>If you need to have access to the parent component in the handler, you also need to bind the function to the component instance (see below).</source>
          <target state="translated">ハンドラで親コンポーネントにアクセスする必要がある場合は、その関数をコンポーネントのインスタンスにバインドする必要があります (後述)。</target>
        </trans-unit>
        <trans-unit id="ca64c98be7ac6b3d7e337c9127443df11a919dbf" translate="yes" xml:space="preserve">
          <source>If you need to interact with the browser, perform your work in &lt;code&gt;componentDidMount()&lt;/code&gt; or the other lifecycle methods instead. Keeping &lt;code&gt;render()&lt;/code&gt; pure makes components easier to think about.</source>
          <target state="translated">ブラウザーと対話する必要がある場合は、代わりに &lt;code&gt;componentDidMount()&lt;/code&gt; または他のライフサイクルメソッドで作業を実行してください。 &lt;code&gt;render()&lt;/code&gt; を純粋に保つことで、コンポーネントについて考えやすくなります。</target>
        </trans-unit>
        <trans-unit id="999ea53a2b5707c7945911f1e76d3cadb698fd97" translate="yes" xml:space="preserve">
          <source>If you need to modify some value in response to user input or a network response, use &lt;code&gt;state&lt;/code&gt; instead.</source>
          <target state="translated">ユーザー入力またはネットワーク応答に応じて値を変更する必要がある場合は、代わりに &lt;code&gt;state&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="8943142e15f89aafbe2213a7c4d356ded10b9fca" translate="yes" xml:space="preserve">
          <source>If you need to test a custom Hook, you can do so by creating a component in your test, and using your Hook from it. Then you can test the component you wrote.</source>
          <target state="translated">カスタムのHookをテストする必要がある場合は、テストの中にコンポーネントを作成し、そこからHookを使用することでテストを行うことができます。そうすれば、あなたが書いたコンポーネントをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="8f1a99a66b2ca1ad147dc87037be4bed83199b9c" translate="yes" xml:space="preserve">
          <source>If you notice that you&amp;rsquo;re getting comfortable with build tools and want them to do more for you, &lt;a href=&quot;create-a-new-react-app&quot;&gt;the next section&lt;/a&gt; describes some of the most popular and approachable toolchains. If not &amp;mdash; those script tags will do just fine!</source>
          <target state="translated">ビルドツールに慣れてきて、より多くのことを実行してもらいたい場合は&lt;a href=&quot;create-a-new-react-app&quot;&gt;、次のセクションで&lt;/a&gt;最も人気があり、親しみやすいツールチェーンについて説明します。そうでない場合&amp;mdash;それらのスクリプトタグは問題なく機能します。</target>
        </trans-unit>
        <trans-unit id="130609e0ef86c8bb326cdb736a8d5fa6030de201" translate="yes" xml:space="preserve">
          <source>If you now create a file called &lt;code&gt;src/like_button.js&lt;/code&gt; with this &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;JSX starter code&lt;/a&gt;&lt;/strong&gt;, the watcher will create a preprocessed &lt;code&gt;like_button.js&lt;/code&gt; with the plain JavaScript code suitable for the browser. When you edit the source file with JSX, the transform will re-run automatically.</source>
          <target state="translated">この&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;JSXスターターコードを&lt;/a&gt;&lt;/strong&gt; &lt;code&gt;src/like_button.js&lt;/code&gt; してsrc / like_button.jsというファイルを作成すると、ウォッチャーはブラウザーに適したプレーンなJavaScriptコードを使用して、前処理された &lt;code&gt;like_button.js&lt;/code&gt; を作成します。JSXでソースファイルを編集すると、変換は自動的に再実行されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eeff73e27684ff93921c75989a38770068d66406" translate="yes" xml:space="preserve">
          <source>If you often find yourself writing code like this, &lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt; package can simplify it.</source>
          <target state="translated">このようなコードを頻繁に作成している場合は、&lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt;パッケージを使用すると、コードを簡略化できます。</target>
        </trans-unit>
        <trans-unit id="523f123efc70d115d1e9f594fc23ba7ce9678a9f" translate="yes" xml:space="preserve">
          <source>If you pass an empty array (&lt;code&gt;[]&lt;/code&gt;), the props and state inside the effect will always have their initial values. While passing &lt;code&gt;[]&lt;/code&gt; as the second argument is closer to the familiar &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; mental model, there are usually &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;better&lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;solutions&lt;/a&gt; to avoid re-running effects too often. Also, don&amp;rsquo;t forget that React defers running &lt;code&gt;useEffect&lt;/code&gt; until after the browser has painted, so doing extra work is less of a problem.</source>
          <target state="translated">空の配列（ &lt;code&gt;[]&lt;/code&gt; ）を渡すと、エフェクト内の小道具と状態は常に初期値になります。2番目の引数として &lt;code&gt;[]&lt;/code&gt; を渡すと、おなじみの &lt;code&gt;componentDidMount&lt;/code&gt; と &lt;code&gt;componentWillUnmount&lt;/code&gt; メンタルモデルに近づきますが、通常、効果の再実行を避けるための&lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;より良い&lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;解決策&lt;/a&gt;があります。また、ブラウザーがペイントするまでReactが &lt;code&gt;useEffect&lt;/code&gt; の実行を延期することを忘れないでください。そのため、追加の作業を行うことは問題にはなりません。</target>
        </trans-unit>
        <trans-unit id="ec6b23abafdc2b9551fe13b784fbb8c555b202cd" translate="yes" xml:space="preserve">
          <source>If you pass no value for a prop, it defaults to &lt;code&gt;true&lt;/code&gt;. These two JSX expressions are equivalent:</source>
          <target state="translated">プロップに値を渡さない場合、デフォルトは &lt;code&gt;true&lt;/code&gt; です。これら2つのJSX式は同等です。</target>
        </trans-unit>
        <trans-unit id="c20bd7989c1f9f633f138de90c77630a2841cd72" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="translated">クライアントでReactを使用してマークアップをインタラクティブにする場合は、このメソッドを使用しないでください。代わりに、サーバーでは&lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt;を、クライアントではReactDOM.hydrate（）を使用して&lt;a href=&quot;#rendertonodestream&quot;&gt; &lt;code&gt;renderToNodeStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4310f49d1554474b642c8b917463ce1122a21130" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="translated">クライアントでReactを使用してマークアップをインタラクティブにする場合は、このメソッドを使用しないでください。代わりに、サーバーでは&lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt;を、クライアントではReactDOM.hydrate（）を使用して&lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;renderToString&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47e07a9bb649f4c37cacef3f1b08b496d76e7c98" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;実践&lt;/a&gt;&lt;strong&gt;して学び&lt;/strong&gt;たい場合は、実践的なチュートリアルをご覧ください。このチュートリアルでは、Reactで三目並べゲームを作成します。ゲームを作成していないので、スキップしたくなるかもしれませんが、チャンスを与えてください。チュートリアルで学ぶテクニックは&lt;em&gt;、&lt;/em&gt; Reactアプリを構築&lt;em&gt;する&lt;/em&gt;ための基本であり、それを習得することで、より深い理解が得られます。</target>
        </trans-unit>
        <trans-unit id="25ae91e52cf25cb83ca4d281086a571771ef39b0" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing&lt;/strong&gt;, start with our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;実践&lt;/a&gt;&lt;strong&gt;して学び&lt;/strong&gt;たい場合は、実践的なチュートリアルから始めてください。</target>
        </trans-unit>
        <trans-unit id="c18121d1ed0c7e2f4c183167ee82f078e32e932e" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step,&lt;/strong&gt; our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt; is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won&amp;rsquo;t miss anything as you go along.</source>
          <target state="translated">あなたがすることを好む場合は&lt;strong&gt;ステップによって概念のステップを学び、&lt;/strong&gt;私たちの&lt;a href=&quot;index&quot;&gt;主要な概念へのガイドが&lt;/a&gt;開始するのに最適な場所です。その次の章はすべて、前の章で紹介した知識に基づいて構築されているので、進むにつれて何も見落とすことはありません。</target>
        </trans-unit>
        <trans-unit id="51a1d7a5fd157767ed19cef5074e83cab2e2cd1f" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step&lt;/strong&gt;, start with our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ステップごと&lt;/strong&gt;に&lt;strong&gt;概念&lt;/strong&gt;を&lt;strong&gt;学び&lt;/strong&gt;たい場合は&lt;a href=&quot;index&quot;&gt;、主な概念のガイドから&lt;/a&gt;始めてください。</target>
        </trans-unit>
        <trans-unit id="4a70d45458110999e3ed23edf11293a04e3c413b" translate="yes" xml:space="preserve">
          <source>If you prefer to set up your own JavaScript toolchain from scratch, &lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;check out this guide&lt;/a&gt; that re-creates some of the Create React App functionality.</source>
          <target state="translated">独自のJavaScriptツールチェーンを最初からセットアップする場合は、&lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;このガイド&lt;/a&gt;を確認して、Create React App機能の一部を再作成してください。</target>
        </trans-unit>
        <trans-unit id="ce6bf88e40be3156ec3b84e97a7685d5e9ea541e" translate="yes" xml:space="preserve">
          <source>If you prefer to use your own text editor, you can also &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;download this HTML file&lt;/a&gt;, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we&amp;rsquo;d only recommend using this for simple demos.</source>
          <target state="translated">独自のテキストエディタを使用する場合は、&lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;このHTMLファイルをダウンロードして&lt;/a&gt;編集し、ブラウザのローカルファイルシステムから開くこともできます。これは実行時のコード変換が遅いため、単純なデモにのみ使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d251364ce59ed1632b03eee6d1772a843639a2d0" translate="yes" xml:space="preserve">
          <source>If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</source>
          <target state="translated">ここで「プロファイルを開く」を押すと、何かが間違っていることがわかります。今すぐ移行するには、7秒かかります。これは、トリビアAPIが遅すぎるためです。APIを高速化できないとしましょう。この制約でユーザーエクスペリエンスをどのように改善できますか？</target>
        </trans-unit>
        <trans-unit id="ab0fcad6ece9f5a091fd940a4e69d81e420608bb" translate="yes" xml:space="preserve">
          <source>If you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="translated">リデューサーフックから現在の状態と同じ値を返すと、Reactは子をレンダリングしたりエフェクトを発射したりせずに救済されます。（Reactは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt; &lt;code&gt;Object.is&lt;/code&gt; 比較アルゴリズムを&lt;/a&gt;使用します。）</target>
        </trans-unit>
        <trans-unit id="759d8e9c5a7a89f86b0192bac647a89f30115a0f" translate="yes" xml:space="preserve">
          <source>If you run this code and watch the console logs, you&amp;rsquo;ll notice the sequence is:</source>
          <target state="translated">このコードを実行してコンソールログを見ると、シーケンスが次のようになっていることがわかります。</target>
        </trans-unit>
        <trans-unit id="5efa147e22d5f8a48f15dbde439cdd94297df3a9" translate="yes" xml:space="preserve">
          <source>If you see an error message saying &amp;ldquo;You have mistakenly installed the &lt;code&gt;babel&lt;/code&gt; package&amp;rdquo;, you might have missed &lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;the previous step&lt;/a&gt;. Perform it in the same folder, and then try again.</source>
          <target state="translated">「誤って &lt;code&gt;babel&lt;/code&gt; パッケージをインストールしました」というエラーメッセージが表示される場合は&lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;、前の手順を&lt;/a&gt;実行していない可能性があります。同じフォルダーで実行してから、再試行してください。</target>
        </trans-unit>
        <trans-unit id="b075833725a23cb77b5ba4dda4642dd74ec1c98a" translate="yes" xml:space="preserve">
          <source>If you see no output, it means that it completed successfully.</source>
          <target state="translated">出力がない場合は、正常に完了したことを意味します。</target>
        </trans-unit>
        <trans-unit id="0c6e92cbb0194609294df3744170608e6c63909c" translate="yes" xml:space="preserve">
          <source>If you serve React from a CDN, we recommend to keep the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt;&lt;code&gt;crossorigin&lt;/code&gt;&lt;/a&gt; attribute set:</source>
          <target state="translated">CDNからReactを提供する場合は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt; &lt;code&gt;crossorigin&lt;/code&gt; &lt;/a&gt;属性を設定したままにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6188f195de25803ee9e3dfbd8d8e12ea147b1a34" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;suppressHydrationWarning&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don&amp;rsquo;t overuse it. You can read more about hydration in the &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;suppressHydrationWarning&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定した場合、Reactは属性とその要素のコンテンツの不一致について警告しません。これは1レベルの深さでのみ機能し、エスケープハッチとして使用することを目的としています。使いすぎないでください。ハイドレーションの詳細については、&lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; のドキュメントを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83336394d37cf4d7a5b1da0ff1854997645bf222" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, &lt;code&gt;useCallback&lt;/code&gt;, or &lt;code&gt;useImperativeHandle&lt;/code&gt;, it must include all values used inside that participate in the React data flow. That includes props, state, and anything derived from them.</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; 、 &lt;code&gt;useMemo&lt;/code&gt; 、 &lt;code&gt;useCallback&lt;/code&gt; 、または &lt;code&gt;useImperativeHandle&lt;/code&gt; の最後の引数として&lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;依存関係のリスト&lt;/a&gt;を指定する場合、Reactデータフローに参加する内部で使用されるすべての値を含める必要があります。これには、小道具、状態、およびそれらから派生したすべてが含まれます。</target>
        </trans-unit>
        <trans-unit id="faccdb965000ef6d3d72692abf68f01516804384" translate="yes" xml:space="preserve">
          <source>If you try to type or check the box in the current version of the example, you&amp;rsquo;ll see that React ignores your input. This is intentional, as we&amp;rsquo;ve set the &lt;code&gt;value&lt;/code&gt; prop of the &lt;code&gt;input&lt;/code&gt; to always be equal to the &lt;code&gt;state&lt;/code&gt; passed in from &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">サンプルの現在のバージョンでボックスを入力またはチェックしようとすると、Reactが入力を無視することがわかります。 &lt;code&gt;input&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; prop を常に &lt;code&gt;FilterableProductTable&lt;/code&gt; から渡された &lt;code&gt;state&lt;/code&gt; と等しくなるように設定しているため、これは意図的なものです。</target>
        </trans-unit>
        <trans-unit id="6678ae603feef4934590c9fa76461843ca5d6683" translate="yes" xml:space="preserve">
          <source>If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="translated">State Hookを現在の状態と同じ値に更新すると、Reactは子をレンダリングしたりエフェクトを発射したりせずにベイルアウトします。（Reactは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt; &lt;code&gt;Object.is&lt;/code&gt; 比較アルゴリズムを&lt;/a&gt;使用します。）</target>
        </trans-unit>
        <trans-unit id="56066137d55bf0e7ea681f5b1c777065f8ae4ce8" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;, run:</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;を使用する場合は、次を実行します。</target>
        </trans-unit>
        <trans-unit id="ade7aaf73be5436c90eadc8335fc3dd6aae134ed" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;, run:</source>
          <target state="translated">&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;を使用する場合は、以下を実行します。</target>
        </trans-unit>
        <trans-unit id="2699510a2c0fb7e097d079f03709fb5c277aac2f" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;react-test-renderer&lt;/code&gt;, it also provides an &lt;code&gt;act&lt;/code&gt; export that behaves the same way.</source>
          <target state="translated">&lt;code&gt;react-test-renderer&lt;/code&gt; を使用すると、同じように動作する &lt;code&gt;act&lt;/code&gt; エクスポートも提供されます。</target>
        </trans-unit>
        <trans-unit id="2f17ca24abe37d1b86e8f96b92da181d93f0022e" translate="yes" xml:space="preserve">
          <source>If you use Create React App, you can &lt;strong&gt;skip the rest of this page&lt;/strong&gt;. It describes the manual setup which doesn&amp;rsquo;t apply to Create React App users.</source>
          <target state="translated">Create React Appを使用する場合&lt;strong&gt;は、このページの残りの部分をスキップ&lt;/strong&gt;でき&lt;strong&gt;ます&lt;/strong&gt;。Create React Appユーザーには適用されない手動設定について説明します。</target>
        </trans-unit>
        <trans-unit id="4a8c97699e7a184def74f6d4614cb42d1ba5dcbe" translate="yes" xml:space="preserve">
          <source>If you use React 16.2 or lower, or if you need more flexibility than provided by ref forwarding, you can use &lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;this alternative approach&lt;/a&gt; and explicitly pass a ref as a differently named prop.</source>
          <target state="translated">React 16.2以前を使用している場合、またはref転送で提供されるよりも柔軟性が必要な場合は、&lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;この代替アプローチ&lt;/a&gt;を使用して、refを別の名前のpropとして明示的に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="5a26f616e6ce178a355bc6c9ea84fd7cd247eb1f" translate="yes" xml:space="preserve">
          <source>If you use React 16.3 or higher, we recommend to use &lt;a href=&quot;forwarding-refs&quot;&gt;ref forwarding&lt;/a&gt; for these cases. &lt;strong&gt;Ref forwarding lets components opt into exposing any child component&amp;rsquo;s ref as their own&lt;/strong&gt;. You can find a detailed example of how to expose a child&amp;rsquo;s DOM node to a parent component &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;in the ref forwarding documentation&lt;/a&gt;.</source>
          <target state="translated">React 16.3以降を使用している場合、これらのケースでは&lt;a href=&quot;forwarding-refs&quot;&gt;参照転送&lt;/a&gt;を使用することをお勧めします。&lt;strong&gt;参照転送により、コンポーネントは子コンポーネントの参照を独自のものとして公開することを選択できます&lt;/strong&gt;。子のDOMノードを親コンポーネント&lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;に&lt;/a&gt;公開する方法の詳細な例は、参照転送ドキュメントにあります。</target>
        </trans-unit>
        <trans-unit id="0c9cdf2ae438a9227b0fb23473474b484ea3d6ee" translate="yes" xml:space="preserve">
          <source>If you use React with Web Components (which is uncommon), use the &lt;code&gt;class&lt;/code&gt; attribute instead.</source>
          <target state="translated">（一般的ではない）WebコンポーネントでReactを使用する場合は、代わりに &lt;code&gt;class&lt;/code&gt; 属性を使用してください。</target>
        </trans-unit>
        <trans-unit id="ab5e9d5516774b9d626ce5a38d7e13d370bfc3f7" translate="yes" xml:space="preserve">
          <source>If you use Yarn, run:</source>
          <target state="translated">ヤーンを使うなら走る。</target>
        </trans-unit>
        <trans-unit id="102d3b3dd48c9c09e36ebc5686501b3bb694fec8" translate="yes" xml:space="preserve">
          <source>If you use npm, run:</source>
          <target state="translated">npmを使っている場合は、実行してください。</target>
        </trans-unit>
        <trans-unit id="b8118d016218e4b145cd1549aa3d71605952205a" translate="yes" xml:space="preserve">
          <source>If you use server rendering, keep in mind that &lt;em&gt;neither&lt;/em&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt; nor &lt;code&gt;useEffect&lt;/code&gt; can run until the JavaScript is downloaded. This is why React warns when a server-rendered component contains &lt;code&gt;useLayoutEffect&lt;/code&gt;. To fix this, either move that logic to &lt;code&gt;useEffect&lt;/code&gt; (if it isn&amp;rsquo;t necessary for the first render), or delay showing that component until after the client renders (if the HTML looks broken until &lt;code&gt;useLayoutEffect&lt;/code&gt; runs).</source>
          <target state="translated">サーバーレンダリングを使用する場合は、あることに注意してください&lt;em&gt;どちら&lt;/em&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; も &lt;code&gt;useEffect&lt;/code&gt; は JavaScriptがダウンロードされるまで実行することができます。これが、サーバーレンダリングされたコンポーネントに &lt;code&gt;useLayoutEffect&lt;/code&gt; が含まれている場合にReactが警告する理由です。これを修正するには、ロジックを &lt;code&gt;useEffect&lt;/code&gt; に移動するか（最初のレンダリングに必要ない場合）、またはクライアントのレンダリングが完了するまで（HTMLが壊れているように見える場合は &lt;code&gt;useLayoutEffect&lt;/code&gt; が実行されるまで）コンポーネントの表示を遅らせます。</target>
        </trans-unit>
        <trans-unit id="70f4f49dc8d98ed757f120ffbd84c5052c4128e4" translate="yes" xml:space="preserve">
          <source>If you use server-side React rendering, normally there is a warning when the server and the client render different content. However, in some rare cases, it is very hard or impossible to guarantee an exact match. For example, timestamps are expected to differ on the server and on the client.</source>
          <target state="translated">サーバーサイドのReactレンダリングを使用している場合、通常はサーバーとクライアントが異なるコンテンツをレンダリングした場合に警告が表示されます。しかし、まれに、完全に一致することを保証することが非常に難しい場合や不可能な場合があります。例えば、タイムスタンプはサーバーとクライアントで異なることが予想されます。</target>
        </trans-unit>
        <trans-unit id="4b4178e978ea6a519b02f6012454f8eaa90a9377" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;what to do when the array changes too often&lt;/a&gt;.</source>
          <target state="translated">この最適化を使用する場合は、&lt;strong&gt;時間の経過とともに変化し、エフェクトで使用されるコンポーネントスコープ（propsやstateなど）のすべての値&lt;/strong&gt;が配列に含まれていることを確認し&lt;strong&gt;てください&lt;/strong&gt;。それ以外の場合、コードは以前のレンダリングの古い値を参照します。詳細情報&lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;機能に対処する方法&lt;/a&gt;と&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;、配列があまりにも頻繁に変化したときに何をすべきかを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b64e4be8855b0be8c046942224485641c321ede" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and what to do when the &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;array values change too often&lt;/a&gt;.</source>
          <target state="translated">この最適化を使用する場合は、&lt;strong&gt;時間の経過とともに変化し、エフェクトで使用されるコンポーネントスコープ（propsやstateなど）のすべての値&lt;/strong&gt;が配列に含まれていることを確認し&lt;strong&gt;てください&lt;/strong&gt;。それ以外の場合、コードは以前のレンダリングの古い値を参照します。&lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;関数の処理方法と&lt;/a&gt;、&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;配列の値が頻繁に変化する&lt;/a&gt;場合の対処方法について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="d4105f95647054b8ce2ef44647d3afb57bb52d64" translate="yes" xml:space="preserve">
          <source>If you use this shorthand form for &lt;code&gt;React.createElement&lt;/code&gt;, it can be almost as convenient to use React without JSX.</source>
          <target state="translated">&lt;code&gt;React.createElement&lt;/code&gt; にこの省略形を使用すると、JSXなしでReactを使用するのと同じくらい便利になります。</target>
        </trans-unit>
        <trans-unit id="cd2291bcdecaf7bcb60d1e8e04c1651f5828fbb6" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; for &lt;strong&gt;re-computing some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;プロップが変更されたときにのみ一部のデータ&lt;/strong&gt;を&lt;strong&gt;再計算&lt;/strong&gt;するために &lt;code&gt;componentWillReceiveProps&lt;/code&gt; を使用した場合は、&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;代わりにメモ化ヘルパーを使用してください&lt;/a&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa1798685fecc6fe21b1daed99365b31b3e0abf4" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;プロップが変化したときに、&lt;/strong&gt; &lt;code&gt;componentWillReceiveProps&lt;/code&gt; を使用し&lt;strong&gt;て状態&lt;/strong&gt;を&lt;strong&gt;「リセット」した場合は、&lt;/strong&gt;代わりに&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;、&lt;/a&gt; &lt;code&gt;key&lt;/code&gt; コンポーネントを&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;完全に制御する&lt;/a&gt;か、完全に非制御にするかを検討してください。</target>
        </trans-unit>
        <trans-unit id="a3a26502e1fe8a2d37c09afc69271006277d32cf" translate="yes" xml:space="preserve">
          <source>If you used classes in React before, this code should look familiar:</source>
          <target state="translated">以前にReactでクラスを使ったことがある人なら、このコードは見覚えがあるはずです。</target>
        </trans-unit>
        <trans-unit id="f80346a09a47643908c6e3e6ed53648965736c75" translate="yes" xml:space="preserve">
          <source>If you visit a site with React in development mode, the icon will have a red background:</source>
          <target state="translated">開発モードでReactを使用したサイトにアクセスすると、アイコンの背景が赤くなります。</target>
        </trans-unit>
        <trans-unit id="8d195f74ff5d044f82074fc4c274d0cab852a524" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;プロップが変わったときに状態&lt;/strong&gt;を&lt;strong&gt;「リセット」し&lt;/strong&gt;たい場合は、コンポーネントを&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;完全に制御する&lt;/a&gt;か&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;、 &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;完全に非制御にするかを検討してください。</target>
        </trans-unit>
        <trans-unit id="029c59f29056b8c40cf61f9a51a8fb598e52ee51" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;re-compute some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="translated">あなたがしたい場合は&lt;strong&gt;、いくつかのデータを再計算した場合にのみ小道具の変更&lt;/strong&gt;、&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;代わりにメモ化ヘルパーを使用します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec176e2b65d2b16278f626d01b65a2ecdb160310" translate="yes" xml:space="preserve">
          <source>If you want to access the event properties in an asynchronous way, you should call &lt;code&gt;event.persist()&lt;/code&gt; on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.</source>
          <target state="translated">非同期でイベントプロパティにアクセスする場合は、イベントで &lt;code&gt;event.persist()&lt;/code&gt; を呼び出す必要があります。これにより、プールから合成イベントが削除され、ユーザーコードでイベントへの参照を保持できるようになります。</target>
        </trans-unit>
        <trans-unit id="7b47497fde239e197e47109c7ac26f42ec5315b4" translate="yes" xml:space="preserve">
          <source>If you want to allow people to take a &lt;code&gt;ref&lt;/code&gt; to your function component, you can use &lt;a href=&quot;forwarding-refs&quot;&gt;&lt;code&gt;forwardRef&lt;/code&gt;&lt;/a&gt; (possibly in conjunction with &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt;), or you can convert the component to a class.</source>
          <target state="translated">他のユーザーが関数コンポーネントへの &lt;code&gt;ref&lt;/code&gt; を取得できるようにする場合は、&lt;a href=&quot;forwarding-refs&quot;&gt; &lt;code&gt;forwardRef&lt;/code&gt; を&lt;/a&gt;（おそらく&lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt; &lt;code&gt;useImperativeHandle&lt;/code&gt; &lt;/a&gt;と組み合わせて）使用するか、コンポーネントをクラスに変換できます。</target>
        </trans-unit>
        <trans-unit id="9774977c9a0cf92ae57d02963964597fc3851501" translate="yes" xml:space="preserve">
          <source>If you want to extend your contrast testing abilities you can use these tools:</source>
          <target state="translated">コントラストテストの能力を拡張したい場合は、これらのツールを使用することができます。</target>
        </trans-unit>
        <trans-unit id="4c61cdf741239e1629cb1394fd5b25ad2e23b07e" translate="yes" xml:space="preserve">
          <source>If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.</source>
          <target state="translated">コンポーネント間でUI以外の機能を再利用したい場合は、別のJavaScriptモジュールに抽出することをお勧めします。コンポーネントはそれをインポートして、その関数、オブジェクト、またはクラスを拡張せずに使用することができます。</target>
        </trans-unit>
        <trans-unit id="0c62cdf54a3c4b69e723af171e44872b6cf5229d" translate="yes" xml:space="preserve">
          <source>If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array (&lt;code&gt;[]&lt;/code&gt;) as a second argument. This tells React that your effect doesn&amp;rsquo;t depend on &lt;em&gt;any&lt;/em&gt; values from props or state, so it never needs to re-run. This isn&amp;rsquo;t handled as a special case &amp;mdash; it follows directly from how the dependencies array always works.</source>
          <target state="translated">エフェクトを実行して1回だけクリーンアップしたい場合（マウントとアンマウント時に）、2番目の引数として空の配列（ &lt;code&gt;[]&lt;/code&gt; ）を渡すことができます。これは、あなたの効果はに依存しないことリアクト伝え&lt;em&gt;任意の&lt;/em&gt;それが再実行する必要はありませんので、小道具や状態からの値。これは特別なケースとして扱われません&amp;mdash;依存関係配列が常に機能する方法から直接従います。</target>
        </trans-unit>
        <trans-unit id="ff9f5e51b60174574056d9954f4502bc83ff6681" translate="yes" xml:space="preserve">
          <source>If you want to test out how some specific JSX is converted into JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="translated">特定のJSXがJavaScriptにどのように変換されるかをテストしたい場合は&lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;、オンラインBabelコンパイラーを&lt;/a&gt;試すことができます。</target>
        </trans-unit>
        <trans-unit id="ff5c25e81b4c83c34080d583406db75e5fbd89cb" translate="yes" xml:space="preserve">
          <source>If you want, you can &lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;extract this logic&lt;/a&gt; into a reusable Hook:</source>
          <target state="translated">必要に応じて、&lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;このロジック&lt;/a&gt;を再利用可能なフックに抽出できます。</target>
        </trans-unit>
        <trans-unit id="399df8ef1381d54faa0cf11b65366b05a0ec37b9" translate="yes" xml:space="preserve">
          <source>If you worked with React before, you might be familiar with an older API where the &lt;code&gt;ref&lt;/code&gt; attribute is a string, like &lt;code&gt;&quot;textInput&quot;&lt;/code&gt;, and the DOM node is accessed as &lt;code&gt;this.refs.textInput&lt;/code&gt;. We advise against it because string refs have &lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;some issues&lt;/a&gt;, are considered legacy, and &lt;strong&gt;are likely to be removed in one of the future releases&lt;/strong&gt;.</source>
          <target state="translated">以前にReactを使用したことがある場合は、 &lt;code&gt;ref&lt;/code&gt; 属性が &lt;code&gt;&quot;textInput&quot;&lt;/code&gt; などの文字列であり、DOMノードに &lt;code&gt;this.refs.textInput&lt;/code&gt; としてアクセスする古いAPIに慣れているかもしれません。文字列参照には&lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;いくつかの問題があり&lt;/a&gt;、レガシーと見なさ&lt;strong&gt;れており、将来のリリースのいずれかで削除される可能性&lt;/strong&gt;があるため、これはお勧め&lt;strong&gt;しません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="aefdc0d20887310bdbbac46cc25deb537667e418" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d rather play it safe, you have a few options:</source>
          <target state="translated">安全にプレイしたい場合は、いくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="c7e8f0a6c71e57b282d77890abf3bb605b7ee301" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re &lt;strong&gt;learning React&lt;/strong&gt; or &lt;strong&gt;creating a new &lt;a href=&quot;glossary#single-page-application&quot;&gt;single-page&lt;/a&gt; app,&lt;/strong&gt; use &lt;a href=&quot;#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Reactを学習し&lt;/strong&gt;ている場合&lt;strong&gt;、&lt;a href=&quot;glossary#single-page-application&quot;&gt;&lt;/a&gt;&lt;/strong&gt;または&lt;strong&gt;新しい&lt;/strong&gt;&lt;strong&gt;単一ページの&lt;/strong&gt;&lt;strong&gt;アプリを&lt;/strong&gt;&lt;a href=&quot;#create-react-app&quot;&gt;作成している&lt;/a&gt;場合は、Create React Appを使用します。</target>
        </trans-unit>
        <trans-unit id="35c007d618e08aa59cd6a4806d7e82c16701dda7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re benchmarking or experiencing performance problems in your React apps, make sure you&amp;rsquo;re testing with the minified production build.</source>
          <target state="translated">Reactアプリのベンチマークやパフォーマンスの問題が発生している場合は、縮小版の本番ビルドでテストしていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="7fc0f59462da1ba03fb1bccaf4af7f83c2421ae8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;component library&lt;/strong&gt; or &lt;strong&gt;integrating with an existing codebase&lt;/strong&gt;, try &lt;a href=&quot;#more-flexible-toolchains&quot;&gt;More Flexible Toolchains&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;コンポーネントライブラリを&lt;/strong&gt;構築する場合、または&lt;strong&gt;既存のコードベースと統合&lt;/strong&gt;する場合は、&lt;a href=&quot;#more-flexible-toolchains&quot;&gt;より柔軟なツールチェーンを&lt;/a&gt;試してください。</target>
        </trans-unit>
        <trans-unit id="e3161c887f0931683850b4ab0d55e09441cde098" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;server-rendered website with Node.js,&lt;/strong&gt; try &lt;a href=&quot;#nextjs&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Node.jsでサーバーレンダリングされたウェブサイトを&lt;/strong&gt;構築している場合は&lt;strong&gt;、&lt;/strong&gt;&lt;a href=&quot;#nextjs&quot;&gt;Next.jsを&lt;/a&gt;試してください。</target>
        </trans-unit>
        <trans-unit id="1fbb68fe4e24629438d31ddaa72b597eeb2cb3e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;static content-oriented website,&lt;/strong&gt; try &lt;a href=&quot;#gatsby&quot;&gt;Gatsby&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;静的なコンテンツ指向のWebサイトを&lt;/strong&gt;構築して&lt;strong&gt;いる&lt;/strong&gt;場合は&lt;strong&gt;、&lt;/strong&gt;&lt;a href=&quot;#gatsby&quot;&gt;Gatsbyを&lt;/a&gt;試してください。</target>
        </trans-unit>
        <trans-unit id="5cb0145636525588474f0e8276c35e496d1aac96" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from a design background, &lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;these resources&lt;/a&gt; are a great place to get started.</source>
          <target state="translated">デザインのバックグラウンドを持っている場合、&lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;これらのリソース&lt;/a&gt;は始めるのに最適な場所です。</target>
        </trans-unit>
        <trans-unit id="1b21a8327f2d695d247dab9ba4c44926f184c95d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from classes, you might be tempted to always call &lt;code&gt;useState()&lt;/code&gt; once and put all state into a single object. You can do it if you&amp;rsquo;d like. Here is an example of a component that follows the mouse movement. We keep its position and size in the local state:</source>
          <target state="translated">クラスから来ている場合は、常に &lt;code&gt;useState()&lt;/code&gt; を一度呼び出して、すべての状態を単一のオブジェクトに入れるようにしたくなるかもしれません。必要に応じてそれを行うことができます。マウスの動きに追従するコンポーネントの例を次に示します。その位置とサイズをローカルな状態で保持します。</target>
        </trans-unit>
        <trans-unit id="bbe478a8949bbc21442ebfd2295d514e9b9da8e6" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re curious to see more examples of how JSX is converted to JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="translated">JSXがJavaScriptに変換される方法の例をもっと知りたい場合は&lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;、オンラインのBabelコンパイラを&lt;/a&gt;試すことができます。</target>
        </trans-unit>
        <trans-unit id="cdbf14a41aa9dba4bb37c7ce0040976c3385bce3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re currently using &lt;code&gt;this.refs.textInput&lt;/code&gt; to access refs, we recommend using either the &lt;a href=&quot;#callback-refs&quot;&gt;callback pattern&lt;/a&gt; or the &lt;a href=&quot;#creating-refs&quot;&gt;&lt;code&gt;createRef&lt;/code&gt; API&lt;/a&gt; instead.</source>
          <target state="translated">現在 &lt;code&gt;this.refs.textInput&lt;/code&gt; を使用して参照にアクセスしている場合は、代わりに&lt;a href=&quot;#callback-refs&quot;&gt;コールバックパターン&lt;/a&gt;または&lt;a href=&quot;#creating-refs&quot;&gt; &lt;code&gt;createRef&lt;/code&gt; API&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1c02314892cb9a48617e7c2fdd059a92d98fef42" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with React class lifecycle methods, you can think of &lt;code&gt;useEffect&lt;/code&gt; Hook as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; combined.</source>
          <target state="translated">Reactクラスのライフサイクルメソッドに精通している場合は、 &lt;code&gt;useEffect&lt;/code&gt; フックを、 &lt;code&gt;componentDidMount&lt;/code&gt; 、 &lt;code&gt;componentDidUpdate&lt;/code&gt; 、および &lt;code&gt;componentWillUnmount&lt;/code&gt; を組み合わせたものと考えることができます。</target>
        </trans-unit>
        <trans-unit id="2bdbd195fffc505b9d49fae18463ec74871e0648" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with the context API before Hooks, &lt;code&gt;useContext(MyContext)&lt;/code&gt; is equivalent to &lt;code&gt;static contextType = MyContext&lt;/code&gt; in a class, or to &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">フックの前のコンテキストAPIに精通している場合、 &lt;code&gt;useContext(MyContext)&lt;/code&gt; はクラスの &lt;code&gt;static contextType = MyContext&lt;/code&gt; または &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="71cc84d56c28a1262eb498557fb996376cead69c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitch&lt;/a&gt;.</source>
          <target state="translated">Reactをいじりたい場合は、オンラインコードプレイグラウンドを使用できます。&lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;、&lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;、または&lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitchで&lt;/a&gt; Hello Worldテンプレートを試してください。</target>
        </trans-unit>
        <trans-unit id="b478957a5f6430e0e6de7b367d98ab11dc6863ad" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re just starting a project, &lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;don&amp;rsquo;t spend more than five minutes&lt;/a&gt; on choosing a file structure. Pick any of the above approaches (or come up with your own) and start writing code! You&amp;rsquo;ll likely want to rethink it anyway after you&amp;rsquo;ve written some real code.</source>
          <target state="translated">プロジェクトを開始するだけの場合は、ファイル構造の選択に&lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;5分以上費やさない&lt;/a&gt;でください。上記のアプローチのいずれかを選択して（または独自の方法を考え出して）、コードの作成を開始してください！実際のコードを書いた後は、とにかくそれを考え直したくなるでしょう。</target>
        </trans-unit>
        <trans-unit id="02065c0e863b23eb9f215dd9e810ad0fbc822f45" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for a complete solution including validation, keeping track of the visited fields, and handling form submission, &lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;Formik&lt;/a&gt; is one of the popular choices. However, it is built on the same principles of controlled components and managing state &amp;mdash; so don&amp;rsquo;t neglect to learn them.</source>
          <target state="translated">検証、訪問したフィールドの追跡、フォーム&lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;送信の&lt;/a&gt;処理を含む完全なソリューションを探している場合、Formikは人気のある選択肢の1つです。ただし、制御されたコンポーネントと状態の管理と同じ原則に基づいて構築されているため、それらを学ぶことを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="ff4bea4c5b521a6375a592447c292171386ec893" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re migrating code from a class component, note &lt;code&gt;useLayoutEffect&lt;/code&gt; fires in the same phase as &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, &lt;strong&gt;we recommend starting with &lt;code&gt;useEffect&lt;/code&gt; first&lt;/strong&gt; and only trying &lt;code&gt;useLayoutEffect&lt;/code&gt; if that causes a problem.</source>
          <target state="translated">クラスコンポーネントからコードを移行する場合は、 &lt;code&gt;useLayoutEffect&lt;/code&gt; が &lt;code&gt;componentDidMount&lt;/code&gt; および &lt;code&gt;componentDidUpdate&lt;/code&gt; と同じフェーズで発生することに注意してください。しかし、&lt;strong&gt;我々は始まるお勧め &lt;code&gt;useEffect&lt;/code&gt; 最初&lt;/strong&gt;で唯一しよう &lt;code&gt;useLayoutEffect&lt;/code&gt; をそれが問題になる場合。</target>
        </trans-unit>
        <trans-unit id="1c5503753c4ba3a8933fe75a74d026956b4dbf0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to Hooks, you might want to check out &lt;a href=&quot;hooks-overview&quot;&gt;the overview&lt;/a&gt; first. You may also find useful information in the &lt;a href=&quot;hooks-faq&quot;&gt;frequently asked questions&lt;/a&gt; section.</source>
          <target state="translated">フックを初めて使用する場合&lt;a href=&quot;hooks-overview&quot;&gt;は、&lt;/a&gt;最初に概要を確認することをお勧めします。&lt;a href=&quot;hooks-faq&quot;&gt;よくある質問の&lt;/a&gt;セクションにも役立つ情報があります。</target>
        </trans-unit>
        <trans-unit id="83c7ebc6b49f6dd3625d44bdc17f0c9841de397f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not familiar with this syntax, check out the &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;explanation&lt;/a&gt; in the State Hook documentation.</source>
          <target state="translated">この構文に慣れていない場合は、State Hookのドキュメントの&lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;説明&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="5174b478727365c84b01ba51be97ccc6bde6c829" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up Webpack yourself, you&amp;rsquo;ll probably want to read Webpack&amp;rsquo;s &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;guide on code splitting&lt;/a&gt;. Your Webpack config should look vaguely &lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;like this&lt;/a&gt;.</source>
          <target state="translated">自分でWebpackを設定している場合は&lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;、コード分割に関する&lt;/a&gt; Webpackのガイドを読むことをお勧めします。Webpackの構成は、漠然と次の&lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;ようになります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a795cf4399197efaee67030befff9eb14a55d67d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re the author of a third party React framework, library, developer tool, or similar infrastructure-type project, you can help us keep React stable for your users and the entire React community by periodically running your test suite against the most recent changes. If you&amp;rsquo;re interested, follow these steps:</source>
          <target state="translated">サードパーティのReactフレームワーク、ライブラリ、開発者ツール、または同様のインフラストラクチャタイプのプロジェクトの作成者である場合は、最新のものに対して定期的にテストスイートを実行することで、ユーザーおよびReactコミュニティ全体に対してReactを安定させるのに役立ちます。変更。興味がある場合は、次の手順に従ってください。</target>
        </trans-unit>
        <trans-unit id="88d974a28ce0731e8c5b22ec90e221bfa58d8cf7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let&amp;rsquo;s look at a practical example to see why this design helps us create components with fewer bugs.</source>
          <target state="translated">クラスに慣れている場合は、アンマウント中に一度だけではなく、再レンダリングのたびにエフェクトのクリーンアップフェーズが発生する理由に疑問を感じるかもしれません。実用的な例を見て、この設計がバグの少ないコンポーネントの作成に役立つ理由を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d6e2e192cd0c1fbe3f4992433f068147160c96ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</source>
          <target state="translated">あなたが使用している場合&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;のAppリアクト作成し&lt;/a&gt;、&lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt;、&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;ギャツビー&lt;/a&gt;、または同様のツールを、あなたはあなたのアプリケーションをバンドルするボックスのうちWebPACKのセットアップを持っています。</target>
        </trans-unit>
        <trans-unit id="3d127abe7b8ab646fe461064799810c4bc682187" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, both &lt;code&gt;Object.assign&lt;/code&gt; and the object spread syntax are available by default.</source>
          <target state="translated">Create React Appを使用している場合、 &lt;code&gt;Object.assign&lt;/code&gt; とオブジェクトスプレッド構文の両方がデフォルトで使用できます。</target>
        </trans-unit>
        <trans-unit id="0e78c645e20c8ca2c19f0d386c2f5955c20c8fe1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, please follow &lt;a href=&quot;#create-react-app&quot;&gt;the instructions above&lt;/a&gt;.</source>
          <target state="translated">Create React Appを使用している場合は&lt;a href=&quot;#create-react-app&quot;&gt;、上記の手順に&lt;/a&gt;従ってください。</target>
        </trans-unit>
        <trans-unit id="2b82de6f7cc131deac549e5bef7f9e8de5d34f8d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working on a data fetching library, there&amp;rsquo;s a crucial aspect of Render-as-You-Fetch you don&amp;rsquo;t want to miss. &lt;strong&gt;We kick off fetching &lt;em&gt;before&lt;/em&gt; rendering.&lt;/strong&gt; Look at this code example closer:</source>
          <target state="translated">データフェッチライブラリに取り組んでいる場合、Render-as-You-Fetchには見逃せない重要な側面があります。&lt;strong&gt;レンダリングの&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;前に&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;フェッチを&lt;em&gt;開始し&lt;/em&gt;ます。&lt;/strong&gt;このコード例をよく見てください。</target>
        </trans-unit>
        <trans-unit id="52cc1d74837d5c0361acef0611ccd09597783f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a library that tests mostly browser-specific behavior, and requires native browser behavior like layout or real inputs, you could use a framework like &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha.&lt;/a&gt;</source>
          <target state="translated">主にブラウザー固有の動作をテストするライブラリーを作成していて、レイアウトや実際の入力などのネイティブのブラウザー動作が必要な場合は、&lt;a href=&quot;https://mochajs.org/&quot;&gt;mochaの&lt;/a&gt;ようなフレームワークを使用できます。</target>
        </trans-unit>
        <trans-unit id="f1b3ede746a1b41e135139260bd938036c1b5653" translate="yes" xml:space="preserve">
          <source>If your React component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; function renders the same result given the same props and state, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; for a performance boost in some cases.</source>
          <target state="translated">Reactコンポーネントの &lt;code&gt;render()&lt;/code&gt; 関数が同じ小道具と状態で同じ結果をレンダリングする場合、場合によっては &lt;code&gt;React.PureComponent&lt;/code&gt; を使用してパフォーマンスを向上させることができます。</target>
        </trans-unit>
        <trans-unit id="2ae535fa4a52d95be43cd119d3dce94ee825d2ad" translate="yes" xml:space="preserve">
          <source>If your application renders long lists of data (hundreds or thousands of rows), we recommended using a technique known as &amp;ldquo;windowing&amp;rdquo;. This technique only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created.</source>
          <target state="translated">アプリケーションでデータの長いリスト（数百または数千行）をレンダリングする場合は、「ウィンドウ処理」と呼ばれる手法を使用することをお勧めします。この手法では、常に行の小さなサブセットのみがレンダリングされ、コンポーネントの再レンダリングにかかる​​時間と作成されたDOMノードの数を大幅に削減できます。</target>
        </trans-unit>
        <trans-unit id="6b0415d8714549e60a664370c6ba10482c3fc92d" translate="yes" xml:space="preserve">
          <source>If your application requires pointer events, we recommend adding a third party pointer event polyfill.</source>
          <target state="translated">アプリケーションでポインタイベントが必要な場合は、サードパーティのポインタイベントポリフィルを追加することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2395816cffe7512d0939e7686c6115bba399430f" translate="yes" xml:space="preserve">
          <source>If your component implements the &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; lifecycle (which is rare), the value it returns will be passed as a third &amp;ldquo;snapshot&amp;rdquo; parameter to &lt;code&gt;componentDidUpdate()&lt;/code&gt;. Otherwise this parameter will be undefined.</source>
          <target state="translated">コンポーネントが &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; ライフサイクルを実装する場合（これはまれです）、 &lt;code&gt;componentDidUpdate()&lt;/code&gt; が返す値は、3番目の「スナップショット」パラメーターとしてcomponentDidUpdate（）に渡されます。それ以外の場合、このパラメーターは未定義になります。</target>
        </trans-unit>
        <trans-unit id="20d599f1233ec4f9623c8e348df9de9e2c174bee" translate="yes" xml:space="preserve">
          <source>If your function component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</source>
          <target state="translated">関数コンポーネントが同じ &lt;code&gt;React.memo&lt;/code&gt; を指定して同じ結果をレンダリングする場合、結果をメモすることでパフォーマンスを向上させるためにReact.memoの呼び出しにラップすることができます。つまり、Reactはコンポーネントのレンダリングをスキップし、最後にレンダリングされた結果を再利用します。</target>
        </trans-unit>
        <trans-unit id="7b153be87230d19e0959754d7e8fdb722e18406e" translate="yes" xml:space="preserve">
          <source>If your project is built with &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, run:</source>
          <target state="translated">プロジェクトが&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;でビルドされている場合は、以下を実行します。</target>
        </trans-unit>
        <trans-unit id="4f76989cbe467f747eafaee915ffd618ee7e8e9e" translate="yes" xml:space="preserve">
          <source>If your project was set up using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, congratulations! The Flow annotations are already being stripped by default so you don&amp;rsquo;t need to do anything else in this step.</source>
          <target state="translated">プロジェクトが&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;を使用して設定されている場合、おめでとうございます！Flowアノテーションはデフォルトですでに取り除かれているため、このステップで他に何もする必要はありません。</target>
        </trans-unit>
        <trans-unit id="71e8d7dcd1b990fee40afd460f8d53442f4e8b92" translate="yes" xml:space="preserve">
          <source>If your update function returns the exact same value, the subsequent rerender will be skipped completely.</source>
          <target state="translated">更新関数が全く同じ値を返す場合、それ以降のリレンダは完全にスキップされます。</target>
        </trans-unit>
        <trans-unit id="e2e9082f9e460ca12ce12808ea1db2401ca59946" translate="yes" xml:space="preserve">
          <source>Image Events</source>
          <target state="translated">イメージイベント</target>
        </trans-unit>
        <trans-unit id="38bbbb29751f3fd92cc08381c3226ccef034d3b1" translate="yes" xml:space="preserve">
          <source>Imagine that we already have a JSON API and a mock from our designer. The mock looks like this:</source>
          <target state="translated">JSON APIとデザイナーのモックがすでにあるとします。モックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="515dd2117b7986f40a9ea292c49529e087a55c0a" translate="yes" xml:space="preserve">
          <source>Imagine we&amp;rsquo;re navigating between two screens in an app. Sometimes, we might not have enough code and data loaded to show a &amp;ldquo;good enough&amp;rdquo; loading state to the user on the new screen. Transitioning to an empty screen or a large spinner can be a jarring experience. However, it&amp;rsquo;s also common that the necessary code and data doesn&amp;rsquo;t take too long to fetch. &lt;strong&gt;Wouldn&amp;rsquo;t it be nicer if React could stay on the old screen for a little longer, and &amp;ldquo;skip&amp;rdquo; the &amp;ldquo;bad loading state&amp;rdquo; before showing the new screen?&lt;/strong&gt;</source>
          <target state="translated">アプリの2つの画面間を移動しているとしましょう。新しい画面でユーザーに「十分な」読み込み状態を表示するのに十分なコードとデータが読み込まれていない場合があります。空の画面または大きなスピナーへの移行は、不快な体験になる可能性があります。ただし、必要なコードとデータをフェッチするのにそれほど時間がかからないことも一般的です。&lt;strong&gt;Reactが少しの間古い画面に留まり、新しい画面を表示する前に「不良な読み込み状態」を「スキップ」できれば、もっといいと思いませんか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a33a303f56a6bbd06206e5ce4d8446405d3fa4f3" translate="yes" xml:space="preserve">
          <source>Importantly, custom Hooks give you the power to constrain React API if you&amp;rsquo;d like to type them more strictly in some way. React gives you the primitives, but you can combine them in different ways than what we provide out of the box.</source>
          <target state="translated">重要なことに、カスタムフックを使用すると、何らかの方法で厳密に入力したい場合にReact APIを制約できます。Reactはプリミティブを提供しますが、デフォルトで提供されているものとは異なる方法でそれらを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="389fbb58f34b12bedefc8ca743f17e0f3583836d" translate="yes" xml:space="preserve">
          <source>Importantly, the way you &lt;em&gt;use&lt;/em&gt; React is the same. Concepts like components, props, and state fundamentally work the same way. When you want to update the screen, you set the state.</source>
          <target state="translated">重要なことに、Reactの&lt;em&gt;使い方&lt;/em&gt;は同じです。コンポーネント、小道具、状態などの概念は基本的に同じように機能します。画面を更新したいときは状態を設定します。</target>
        </trans-unit>
        <trans-unit id="1368d43d01a36b5581bb3e9a2be050b9de12c101" translate="yes" xml:space="preserve">
          <source>In CSS, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt;&lt;code&gt;display: contents&lt;/code&gt;&lt;/a&gt; attribute can be used if you don&amp;rsquo;t want the node to be part of the layout.</source>
          <target state="translated">CSSでは、ノードをレイアウトの一部にしたくない場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt; &lt;code&gt;display: contents&lt;/code&gt; &lt;/a&gt;属性を使用できます。</target>
        </trans-unit>
        <trans-unit id="4b55e065dea1bfb41665c75fc1cc794c8f70a095" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, rendering is not blocking. It is interruptible. This improves the user experience. It also unlocks new features that weren&amp;rsquo;t possible before. Before we look at concrete examples in the &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;next&lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;chapters&lt;/a&gt;, we&amp;rsquo;ll do a high-level overview of new features.</source>
          <target state="translated">同時モードでは、レンダリングはブロックされません。割り込み可能です。これにより、ユーザーエクスペリエンスが向上します。また、以前は不可能だった新機能も利用できます。&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;次の&lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;章&lt;/a&gt;で具体的な例を見る前に、新機能の概要を説明します。</target>
        </trans-unit>
        <trans-unit id="7ecc95e249a2849c1eb4333865f60656c17be67b" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, the lifecycle methods &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;previously marked&lt;/a&gt; as &amp;ldquo;unsafe&amp;rdquo; actually &lt;em&gt;are&lt;/em&gt; unsafe, and lead to bugs even more than in today&amp;rsquo;s React. We don&amp;rsquo;t recommend trying Concurrent Mode until your app is &lt;a href=&quot;strict-mode&quot;&gt;Strict Mode&lt;/a&gt;-compatible.</source>
          <target state="translated">並行モードでは、&lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;以前&lt;/a&gt;「安全でない」とマークされていたライフサイクルメソッド&lt;em&gt;は&lt;/em&gt;実際に&lt;em&gt;は&lt;/em&gt;安全で&lt;em&gt;は&lt;/em&gt;なく、今日のReactよりも多くのバグを引き起こします。アプリが&lt;a href=&quot;strict-mode&quot;&gt;ストリクトモード&lt;/a&gt;互換になるまで、コンカレントモードを試すことはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="21ea6a0b5b929f6e4d971d6001063e6cdcc606f8" translate="yes" xml:space="preserve">
          <source>In ES6 classes, you can define the initial state by assigning &lt;code&gt;this.state&lt;/code&gt; in the constructor:</source>
          <target state="translated">ES6クラスでは、コンストラクターで &lt;code&gt;this.state&lt;/code&gt; を割り当てることにより、初期状態を定義できます。</target>
        </trans-unit>
        <trans-unit id="74b9508d775e315d9d48d1ac6d2be46507d95cbb" translate="yes" xml:space="preserve">
          <source>In HTML, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; creates a drop-down list. For example, this HTML creates a drop-down list of flavors:</source>
          <target state="translated">HTMLでは、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; はドロップダウンリストを作成します。たとえば、次のHTMLはフレーバーのドロップダウンリストを作成します。</target>
        </trans-unit>
        <trans-unit id="6260ccb22bfbbde7ec537c88316f474366bfa99b" translate="yes" xml:space="preserve">
          <source>In HTML, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; element defines its text by its children:</source>
          <target state="translated">HTMLでは、 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 要素はその子によってテキストを定義します。</target>
        </trans-unit>
        <trans-unit id="cee26a6db634e40e4019da1e44bc2fa5e8708d30" translate="yes" xml:space="preserve">
          <source>In HTML, an &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; lets the user choose one or more files from their device storage to be uploaded to a server or manipulated by JavaScript via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File API&lt;/a&gt;.</source>
          <target state="translated">HTMLでは、 &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; を使用すると、ユーザーはデバイスストレージから1つ以上のファイルを選択してサーバーにアップロードするか、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File APIを&lt;/a&gt;介してJavaScriptで操作できます。</target>
        </trans-unit>
        <trans-unit id="bdd8882487752794b9ff3cba07ccbd1e6347dd57" translate="yes" xml:space="preserve">
          <source>In HTML, form elements such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with &lt;a href=&quot;react-component#setstate&quot;&gt;&lt;code&gt;setState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTMLでは、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; などのフォーム要素は通常、独自の状態を維持し、ユーザー入力に基づいてそれを更新します。Reactでは、変更可能な状態は通常、コンポーネントの状態プロパティに保持され、&lt;a href=&quot;react-component#setstate&quot;&gt; &lt;code&gt;setState()&lt;/code&gt; で&lt;/a&gt;のみ更新されます。</target>
        </trans-unit>
        <trans-unit id="451fb8c93e5b83ed15cecd30a84768222971358c" translate="yes" xml:space="preserve">
          <source>In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: &lt;code&gt;props.children&lt;/code&gt;. There are several different ways to pass children:</source>
          <target state="translated">開始タグと終了タグの両方を含むJSX式では、これらのタグ間のコンテンツは特別なprop： &lt;code&gt;props.children&lt;/code&gt; として渡されます。子供を渡す方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="2b47b7c0e900bd9fddd8dd976d3fa0c74ee40520" translate="yes" xml:space="preserve">
          <source>In JavaScript, these two code snippets are &lt;strong&gt;not&lt;/strong&gt; equivalent:</source>
          <target state="translated">JavaScriptでは、次の2つのコードスニペットは同等ではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="896c4ff0b7dad9168327f4c2b1e69fd7b821d242" translate="yes" xml:space="preserve">
          <source>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</source>
          <target state="translated">Reactアプリでは、コンポーネントがステートフルかステートレスかは、時間の経過とともに変化する可能性があるコンポーネントの実装の詳細とみなされます。ステートフルなコンポーネントの中でステートレスなコンポーネントを使用したり、その逆も可能です。</target>
        </trans-unit>
        <trans-unit id="b509261276a2c24087d4a53dfcbb229d41ff110f" translate="yes" xml:space="preserve">
          <source>In React class components, the &lt;code&gt;render&lt;/code&gt; method itself shouldn&amp;rsquo;t cause side effects. It would be too early &amp;mdash; we typically want to perform our effects &lt;em&gt;after&lt;/em&gt; React has updated the DOM.</source>
          <target state="translated">Reactクラスコンポーネントでは、 &lt;code&gt;render&lt;/code&gt; メソッド自体が副作用を引き起こしてはなりません。早すぎるでしょう。通常&lt;em&gt;、&lt;/em&gt; ReactがDOMを更新した&lt;em&gt;後で&lt;/em&gt;エフェクトを実行したいと考えています。</target>
        </trans-unit>
        <trans-unit id="cea30c1cddacc5c2fb8659ad8a3ea7724439494a" translate="yes" xml:space="preserve">
          <source>In React components declared as ES6 classes, methods follow the same semantics as regular ES6 classes. This means that they don&amp;rsquo;t automatically bind &lt;code&gt;this&lt;/code&gt; to the instance. You&amp;rsquo;ll have to explicitly use &lt;code&gt;.bind(this)&lt;/code&gt; in the constructor:</source>
          <target state="translated">ES6クラスとして宣言されたReactコンポーネントでは、メソッドは通常のES6クラスと同じセマンティクスに従います。この手段は、彼らが自動的に結合しないこと &lt;code&gt;this&lt;/code&gt; インスタンスに。 &lt;code&gt;.bind(this)&lt;/code&gt; 明示的に.bind（this）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="538221c0cbcf54504c0c303253382099a46a923b" translate="yes" xml:space="preserve">
          <source>In React, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; uses a &lt;code&gt;value&lt;/code&gt; attribute instead. This way, a form using a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; can be written very similarly to a form that uses a single-line input:</source>
          <target state="translated">Reactでは、 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; は代わりに &lt;code&gt;value&lt;/code&gt; 属性を使用します。このように、 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; を使用するフォームは、1行の入力を使用するフォームと非常によく似た形で記述できます。</target>
        </trans-unit>
        <trans-unit id="9c9a3a5e0ceac65aab6602bc1dbe2fe9e493d0fe" translate="yes" xml:space="preserve">
          <source>In React, all DOM properties and attributes (including event handlers) should be camelCased. For example, the HTML attribute &lt;code&gt;tabindex&lt;/code&gt; corresponds to the attribute &lt;code&gt;tabIndex&lt;/code&gt; in React. The exception is &lt;code&gt;aria-*&lt;/code&gt; and &lt;code&gt;data-*&lt;/code&gt; attributes, which should be lowercased. For example, you can keep &lt;code&gt;aria-label&lt;/code&gt; as &lt;code&gt;aria-label&lt;/code&gt;.</source>
          <target state="translated">Reactでは、すべてのDOMプロパティと属性（イベントハンドラーを含む）はcamelCasedである必要があります。たとえば、HTML属性 &lt;code&gt;tabindex&lt;/code&gt; は、Reactの属性 &lt;code&gt;tabIndex&lt;/code&gt; に対応しています。例外はある &lt;code&gt;aria-*&lt;/code&gt; と &lt;code&gt;data-*&lt;/code&gt; 小文字にしなければならない属性、。たとえば、 &lt;code&gt;aria-label&lt;/code&gt; を &lt;code&gt;aria-label&lt;/code&gt; として保持できます。</target>
        </trans-unit>
        <trans-unit id="7c511871e368bc7af53ec2e81d4fb957978f940e" translate="yes" xml:space="preserve">
          <source>In React, an &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; is always an uncontrolled component because its value can only be set by a user, and not programmatically.</source>
          <target state="translated">Reactでは、 &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; は常に制御されないコンポーネントです。これは、その値がユーザーによってのみ設定され、プログラムからは設定できないためです。</target>
        </trans-unit>
        <trans-unit id="3c7fa02f2469625e763a13cd5609a01cda7c6c08" translate="yes" xml:space="preserve">
          <source>In React, both &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; represent the &lt;em&gt;rendered&lt;/em&gt; values, i.e. what&amp;rsquo;s currently on the screen.</source>
          <target state="translated">Reactでは、 &lt;code&gt;this.props&lt;/code&gt; と &lt;code&gt;this.state&lt;/code&gt; の両方が&lt;em&gt;レンダリングされた&lt;/em&gt;値、つまり現在画面上にあるものを表します。</target>
        </trans-unit>
        <trans-unit id="f14047f4f0476e66fe99901264ae249589cef260" translate="yes" xml:space="preserve">
          <source>In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called &amp;ldquo;lifting state up&amp;rdquo;. We will remove the local state from the &lt;code&gt;TemperatureInput&lt;/code&gt; and move it into the &lt;code&gt;Calculator&lt;/code&gt; instead.</source>
          <target state="translated">Reactでは、状態の共有は、状態を必要とするコンポーネントの最も近い共通の祖先に状態を移動することによって行われます。これを「状態を持ち上げる」といいます。 &lt;code&gt;TemperatureInput&lt;/code&gt; からローカル状態を削除し、代わりに &lt;code&gt;Calculator&lt;/code&gt; に移動します。</target>
        </trans-unit>
        <trans-unit id="4a53b8bc22280c0c555667af9e91fb2d02153f1e" translate="yes" xml:space="preserve">
          <source>In React, this could instead be:</source>
          <target state="translated">Reactでは、代わりにこれを使うことができます。</target>
        </trans-unit>
        <trans-unit id="410126e91330d77043a8e4cf7862f0a183679992" translate="yes" xml:space="preserve">
          <source>In React, this is also achieved by composition, where a more &amp;ldquo;specific&amp;rdquo; component renders a more &amp;ldquo;generic&amp;rdquo; one and configures it with props:</source>
          <target state="translated">Reactでは、これはコンポジションによっても実現され、より「特定の」コンポーネントがより「一般的な」コンポーネントをレンダリングし、それをプロップで構成します。</target>
        </trans-unit>
        <trans-unit id="5f50da8ee138f52d6b59eebfb1b47338f96dd4b5" translate="yes" xml:space="preserve">
          <source>In React, this is usually solved by making a component &amp;ldquo;controlled&amp;rdquo;. Just like the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; accepts both a &lt;code&gt;value&lt;/code&gt; and an &lt;code&gt;onChange&lt;/code&gt; prop, so can the custom &lt;code&gt;TemperatureInput&lt;/code&gt; accept both &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;onTemperatureChange&lt;/code&gt; props from its parent &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="translated">Reactでは、これは通常、コンポーネントを「制御」することで解決されます。DOMの &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; が &lt;code&gt;value&lt;/code&gt; と &lt;code&gt;onChange&lt;/code&gt; プロップの両方を受け入れるように、カスタムの &lt;code&gt;TemperatureInput&lt;/code&gt; は親の &lt;code&gt;Calculator&lt;/code&gt; から &lt;code&gt;temperature&lt;/code&gt; と &lt;code&gt;onTemperatureChange&lt;/code&gt; プロップの両方を受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="87275e536b566529b077b0ff131cc019d2d910ed" translate="yes" xml:space="preserve">
          <source>In React, transforming arrays into lists of &lt;a href=&quot;rendering-elements&quot;&gt;elements&lt;/a&gt; is nearly identical.</source>
          <target state="translated">Reactでは、配列を&lt;a href=&quot;rendering-elements&quot;&gt;要素の&lt;/a&gt;リストに変換することはほとんど同じです。</target>
        </trans-unit>
        <trans-unit id="28e0e1f0e9359d0e312a435e081792d0bfb666a7" translate="yes" xml:space="preserve">
          <source>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.</source>
          <target state="translated">React では、必要な動作をカプセル化した別個のコンポーネントを作成することができます。そして、アプリケーションの状態に応じて、その一部だけをレンダリングすることができます。</target>
        </trans-unit>
        <trans-unit id="f18d05ee6185a8ba49d29302bd632b76aa474a54" translate="yes" xml:space="preserve">
          <source>In React, you most likely write your components in a &lt;code&gt;.js&lt;/code&gt; file. In TypeScript we have 2 file extensions:</source>
          <target state="translated">Reactでは、ほとんどの場合、コンポーネントを &lt;code&gt;.js&lt;/code&gt; ファイルに記述します。TypeScriptには2つのファイル拡張子があります。</target>
        </trans-unit>
        <trans-unit id="9f15ab1b0e75d6b53c4958487bbf30fca20cdcdd" translate="yes" xml:space="preserve">
          <source>In a React class, you would typically set up a subscription in &lt;code&gt;componentDidMount&lt;/code&gt;, and clean it up in &lt;code&gt;componentWillUnmount&lt;/code&gt;. For example, let&amp;rsquo;s say we have a &lt;code&gt;ChatAPI&lt;/code&gt; module that lets us subscribe to a friend&amp;rsquo;s online status. Here&amp;rsquo;s how we might subscribe and display that status using a class:</source>
          <target state="translated">Reactクラスでは、通常、サブスクリプションを &lt;code&gt;componentDidMount&lt;/code&gt; で設定し、それをcomponentWillUnmountでクリーンアップし &lt;code&gt;componentWillUnmount&lt;/code&gt; 。たとえば、友人のオンラインステータスをサブスクライブできる &lt;code&gt;ChatAPI&lt;/code&gt; モジュールがあるとします。クラスを使用してサブスクライブし、そのステータスを表示する方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ae59876c3b29c0877309b94f02f1bd1dffc61a49" translate="yes" xml:space="preserve">
          <source>In a class component, we would need to add &lt;code&gt;componentDidUpdate&lt;/code&gt; to handle this case:</source>
          <target state="translated">クラスコンポーネントでは、このケースを処理するために &lt;code&gt;componentDidUpdate&lt;/code&gt; を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="92c2ff44f620f5f28854f62d80affff3a499ba93" translate="yes" xml:space="preserve">
          <source>In a class, we initialize the &lt;code&gt;count&lt;/code&gt; state to &lt;code&gt;0&lt;/code&gt; by setting &lt;code&gt;this.state&lt;/code&gt; to &lt;code&gt;{ count: 0 }&lt;/code&gt; in the constructor:</source>
          <target state="translated">クラスでは、コンストラクターで &lt;code&gt;this.state&lt;/code&gt; を &lt;code&gt;{ count: 0 }&lt;/code&gt; に設定することで、 &lt;code&gt;count&lt;/code&gt; 状態を &lt;code&gt;0&lt;/code&gt; に初期化します。</target>
        </trans-unit>
        <trans-unit id="0f976be121765c87a20b8cbb91d05fe0f6e68773" translate="yes" xml:space="preserve">
          <source>In a class, we need to call &lt;code&gt;this.setState()&lt;/code&gt; to update the &lt;code&gt;count&lt;/code&gt; state:</source>
          <target state="translated">クラスでは、 &lt;code&gt;this.setState()&lt;/code&gt; を呼び出して &lt;code&gt;count&lt;/code&gt; 状態を更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="42f4e9921f51af97e4b657670a6fd71ed33571b6" translate="yes" xml:space="preserve">
          <source>In a function component, we have no &lt;code&gt;this&lt;/code&gt;, so we can&amp;rsquo;t assign or read &lt;code&gt;this.state&lt;/code&gt;. Instead, we call the &lt;code&gt;useState&lt;/code&gt; Hook directly inside our component:</source>
          <target state="translated">関数コンポーネントでは &lt;code&gt;this&lt;/code&gt; がないので、 &lt;code&gt;this.state&lt;/code&gt; を割り当てたり読み取ったりすることはできません。代わりに、コンポーネント内で直接 &lt;code&gt;useState&lt;/code&gt; フックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="f02a6361f2d8d56c63358f0ea5c054c54d590ac2" translate="yes" xml:space="preserve">
          <source>In a function, we already have &lt;code&gt;setCount&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; as variables so we don&amp;rsquo;t need &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">関数では、すでに &lt;code&gt;setCount&lt;/code&gt; と &lt;code&gt;count&lt;/code&gt; を変数として持っているので、 &lt;code&gt;this&lt;/code&gt; は必要ありません。</target>
        </trans-unit>
        <trans-unit id="8baa32bfe1b6970407832863578c772af74c5714" translate="yes" xml:space="preserve">
          <source>In a function, we can use &lt;code&gt;count&lt;/code&gt; directly:</source>
          <target state="translated">関数では、 &lt;code&gt;count&lt;/code&gt; を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="e453bfad87294cd830086d87833eed893f7ed85e" translate="yes" xml:space="preserve">
          <source>In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.</source>
          <target state="translated">典型的なReactアプリケーションでは、データはプロップを介してトップダウン(親から子へ)で渡されますが、アプリケーション内の多くのコンポーネントで必要とされる特定のタイプのプロップ(例:ロケール環境設定、UIテーマ)の場合、これは煩雑になります。コンテキストは、このような値をコンポーネント間で共有する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="b9e54856b0d6dda52097e2ff1d03dbed8218a984" translate="yes" xml:space="preserve">
          <source>In addition to making code reuse and code organization more difficult, we&amp;rsquo;ve found that classes can be a large barrier to learning React. You have to understand how &lt;code&gt;this&lt;/code&gt; works in JavaScript, which is very different from how it works in most languages. You have to remember to bind the event handlers. Without unstable &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;syntax proposals&lt;/a&gt;, the code is very verbose. People can understand props, state, and top-down data flow perfectly well but still struggle with classes. The distinction between function and class components in React and when to use each one leads to disagreements even between experienced React developers.</source>
          <target state="translated">コードの再利用とコードの編成をさらに困難にすることに加えて、クラスがReactを学ぶ上での大きな障壁になる可能性があることもわかりました。これがJavaScriptでどの &lt;code&gt;this&lt;/code&gt; 機能するかを理解する必要があります。これは、ほとんどの言語での機能とは大きく異なります。イベントハンドラーをバインドすることを忘れないでください。不安定な&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;構文の提案が&lt;/a&gt;ないと、コードは非常に冗長になります。人々は、小道具、状態、トップダウンのデータフローを完全に理解できますが、それでもクラスに苦労します。 Reactの関数コンポーネントとクラスコンポーネントの違い、およびそれぞれをいつ使用するかにより、経験豊富なReact開発者の間でも意見の相違が生じます。</target>
        </trans-unit>
        <trans-unit id="289e0d186dd0eceb3a53aed219c7fedfcae512fa" translate="yes" xml:space="preserve">
          <source>In addition, consider that the design of Hooks is more efficient in a couple ways:</source>
          <target state="translated">さらに、フックのデザインは、いくつかの方法でより効率的であることを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="cf07c2cb1d9764411791f25d366167bf2c6a4a7d" translate="yes" xml:space="preserve">
          <source>In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt;&lt;code&gt;@testing-library/react-native&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">DOMをシミュレート&lt;em&gt;できない&lt;/em&gt;環境（Node.jsでReact Nativeコンポーネントをテストするなど）では、&lt;a href=&quot;test-utils#simulate&quot;&gt;イベントシミュレーションヘルパー&lt;/a&gt;を使用して要素との相互作用をシミュレートできます。または、&lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt; &lt;code&gt;@testing-library/react-native&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;fireEvent&lt;/code&gt; ヘルパーを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="dd08e59d935cb13b1f6c01dc28056496f6a9bc4e" translate="yes" xml:space="preserve">
          <source>In applications with many components, it&amp;rsquo;s very important to free up resources taken by the components when they are destroyed.</source>
          <target state="translated">多くのコンポーネントを含むアプリケーションでは、コンポーネントが破棄されたときにコンポーネントが使用していたリソースを解放することが非常に重要です。</target>
        </trans-unit>
        <trans-unit id="6b767eadf5b4139629873d3d67b44c49dd15f7ed" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;e&lt;/code&gt; argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with &lt;code&gt;bind&lt;/code&gt; any further arguments are automatically forwarded.</source>
          <target state="translated">どちらの場合も、Reactイベントを表す &lt;code&gt;e&lt;/code&gt; 引数は、IDの後に2番目の引数として渡されます。アロー関数を使用すると、明示的に渡す必要がありますが、 &lt;code&gt;bind&lt;/code&gt; を使用すると、それ以降の引数は自動的に転送されます。</target>
        </trans-unit>
        <trans-unit id="d1802f47fc0c94f1304e39a33f567229bc6a0fe9" translate="yes" xml:space="preserve">
          <source>In cases where you cannot define the prop statically (e.g. because you need to close over the component&amp;rsquo;s props and/or state) &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; should extend &lt;code&gt;React.Component&lt;/code&gt; instead.</source>
          <target state="translated">プロップを静的に定義できない場合（たとえば、コンポーネントのプロップや状態を閉じる必要があるため）、 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; は &lt;code&gt;React.Component&lt;/code&gt; を拡張する必要があります。</target>
        </trans-unit>
        <trans-unit id="d09f5ea2f719cb84240d22955b912b59e89f6fc3" translate="yes" xml:space="preserve">
          <source>In contrast, this function is impure because it changes its own input:</source>
          <target state="translated">これに対して、この関数は自分で入力を変えてしまうので不純です。</target>
        </trans-unit>
        <trans-unit id="ba9a0d3186492384944825ac9b7292279498c6fb" translate="yes" xml:space="preserve">
          <source>In depth: When and why are &lt;code&gt;setState()&lt;/code&gt; calls batched?</source>
          <target state="translated">詳細： &lt;code&gt;setState()&lt;/code&gt; 呼び出しはいつ、なぜバッチ処理されるのですか？</target>
        </trans-unit>
        <trans-unit id="e28fdfcba350e9460a5b11538d17a9495f7864ad" translate="yes" xml:space="preserve">
          <source>In depth: Why isn&amp;rsquo;t &lt;code&gt;this.state&lt;/code&gt; updated immediately?</source>
          <target state="translated">詳細： &lt;code&gt;this.state&lt;/code&gt; がすぐに更新されないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="c1b95b07888beb397c1c34cba846e81f89eafcbe" translate="yes" xml:space="preserve">
          <source>In either case, we &lt;strong&gt;don&amp;rsquo;t recommend this pattern&lt;/strong&gt; and only show it here for completeness. Instead, it is preferable to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;avoid passing callbacks deep down&lt;/a&gt;.</source>
          <target state="translated">どちらの場合も、&lt;strong&gt;このパターンはお勧めしません&lt;/strong&gt;。完全を期すために、ここでのみ示しています。代わりに、&lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;コールバックを深く渡さないように&lt;/a&gt;することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f9d91c5022448dc96b7db04173ff7b2483babe71" translate="yes" xml:space="preserve">
          <source>In fact, if we open the console, we&amp;rsquo;ll see a warning:</source>
          <target state="translated">実際、コンソールを開くと警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="f345dbdd77bde7a2de6d314ebebbeb5d11132d71" translate="yes" xml:space="preserve">
          <source>In fact, this is exactly how React is used at Facebook. This lets us write applications in React piece by piece, and combine them with our existing server-generated templates and other client-side code.</source>
          <target state="translated">実際、これはまさにFacebookでReactが使われている方法です。これにより、Reactでアプリケーションを少しずつ書いて、既存のサーバー生成テンプレートや他のクライアントサイドのコードと組み合わせることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="ffdfd80e389f7e74a49541704e05ae80cc6fc69b" translate="yes" xml:space="preserve">
          <source>In general, we &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; bump the major version number for changes to:</source>
          <target state="translated">一般的に、次の変更についてはメジャーバージョン番号を変更し&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ee266aeffd83dee46d08b5a2d9e5dd0db59bd0ba" translate="yes" xml:space="preserve">
          <source>In general, we don&amp;rsquo;t recommend using this because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt;&lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt;. This behavior is just there so that it matches the behavior of HTML.</source>
          <target state="translated">一般的に、我々はそれはと混同することができますので、これを使用することはお勧めしません&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6オブジェクト速記&lt;/a&gt; &lt;code&gt;{foo}&lt;/code&gt; のために短いです &lt;code&gt;{foo: foo}&lt;/code&gt; ではなく &lt;code&gt;{foo: true}&lt;/code&gt; 。この動作はHTMLの動作と一致するように存在します。</target>
        </trans-unit>
        <trans-unit id="fb1a71609500b2f5f9daba332366828dbac63210" translate="yes" xml:space="preserve">
          <source>In large component trees, an alternative we recommend is to pass down a &lt;code&gt;dispatch&lt;/code&gt; function from &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; via context:</source>
          <target state="translated">大きなコンポーネントツリーでは、代替として、コンテキストを介して&lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;dispatch&lt;/code&gt; 関数を渡すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ba93ca3416f3cbfccc68a69a219fb2048e2dc7a7" translate="yes" xml:space="preserve">
          <source>In many cases it&amp;rsquo;s not possible to break these components into smaller ones because the stateful logic is all over the place. It&amp;rsquo;s also difficult to test them. This is one of the reasons many people prefer to combine React with a separate state management library. However, that often introduces too much abstraction, requires you to jump between different files, and makes reusing components more difficult.</source>
          <target state="translated">多くの場合、ステートフルなロジックが至る所にあるため、これらのコンポーネントをより小さなコンポーネントに分割することは不可能です。それらをテストすることも困難です。これは、多くの人々がReactを個別の状態管理ライブラリと組み合わせることを好む理由の1つです。ただし、これは多くの場合、抽象化を過度に導入し、異なるファイル間をジャンプする必要があり、コンポーネントの再利用をより困難にします。</target>
        </trans-unit>
        <trans-unit id="c3440d610e4a5c2ec2cdeed99640aaa90c65f21a" translate="yes" xml:space="preserve">
          <source>In more complex cases (such as if one state depends on another state), try moving the state update logic outside the effect with the &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt; Hook&lt;/a&gt;. &lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;This article&lt;/a&gt; offers an example of how you can do this. &lt;strong&gt;The identity of the &lt;code&gt;dispatch&lt;/code&gt; function from &lt;code&gt;useReducer&lt;/code&gt; is always stable&lt;/strong&gt; &amp;mdash; even if the reducer function is declared inside the component and reads its props.</source>
          <target state="translated">より複雑なケース（ある状態が別の状態に依存している場合など）では、&lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; Hookを使用&lt;/a&gt;して、状態更新ロジックをエフェクトの外に移動してみてください。&lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;この記事で&lt;/a&gt;は、これを行う方法の例を示します。&lt;strong&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;から&lt;/strong&gt;&lt;strong&gt;の &lt;code&gt;dispatch&lt;/code&gt; 関数のIDは、&lt;/strong&gt;コンポーネント内でレデューサー関数が宣言され、その小道具を読み取る場合でも、&lt;strong&gt;常に安定&lt;/strong&gt;しています。</target>
        </trans-unit>
        <trans-unit id="ea3661ac2ed158cad82144227101fb280362b435" translate="yes" xml:space="preserve">
          <source>In most cases you should use controlled components.</source>
          <target state="translated">ほとんどの場合、制御されたコンポーネントを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4a7abdefe6c187e6dc04e0d7f5c214840047bcdd" translate="yes" xml:space="preserve">
          <source>In most cases, instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand, you can inherit from &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt;. It is equivalent to implementing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; with a shallow comparison of current and previous props and state.</source>
          <target state="translated">ほとんどの場合、代わりに書くの &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 手で、あなたを継承することができます&lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;/a&gt;。これは、現在と以前の小道具と状態を浅く比較して &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; を実装することと同じです。</target>
        </trans-unit>
        <trans-unit id="cbad587d21c37cda62d8252410ab69d53dfcaebf" translate="yes" xml:space="preserve">
          <source>In most cases, jsdom behaves like a regular browser would, but doesn&amp;rsquo;t have features like &lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;layout and navigation&lt;/a&gt;. This is still useful for most web-based component tests, since it runs quicker than having to start up a browser for each test. It also runs in the same process as your tests, so you can write code to examine and assert on the rendered DOM.</source>
          <target state="translated">ほとんどの場合、jsdomは通常のブラウザと同じように動作しますが、&lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;レイアウトやナビゲーション&lt;/a&gt;などの機能はありません。これは、テストごとにブラウザを起動する必要がないので実行速度が速いため、ほとんどのWebベースのコンポーネントテストで引き続き役立ちます。また、テストと同じプロセスで実行されるため、レンダリングされたDOMを調べてアサートするコードを記述できます。</target>
        </trans-unit>
        <trans-unit id="1911017bb2356e24f2e7725ec8dd38cb5980645a" translate="yes" xml:space="preserve">
          <source>In most cases, we recommend using &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled components&lt;/a&gt; to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.</source>
          <target state="translated">ほとんどの場合、&lt;a href=&quot;forms#controlled-components&quot;&gt;制御されたコンポーネント&lt;/a&gt;を使用してフォームを実装することをお勧めします。制御されたコンポーネントでは、フォームデータはReactコンポーネントによって処理されます。代替手段は、フォームデータがDOM自体によって処理される非制御コンポーネントです。</target>
        </trans-unit>
        <trans-unit id="6d3c1b36b4f10f7bf6d14d76f2b5886538fe9af9" translate="yes" xml:space="preserve">
          <source>In order to solve this issue, React supports a &lt;code&gt;key&lt;/code&gt; attribute. When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. For example, adding a &lt;code&gt;key&lt;/code&gt; to our inefficient example above can make the tree conversion efficient:</source>
          <target state="translated">この問題を解決するために、Reactは &lt;code&gt;key&lt;/code&gt; 属性をサポートしています。子にキーがある場合、Reactはそのキーを使用して、元のツリーの子を後続のツリーの子と照合します。たとえば、上記の非効率的な例に &lt;code&gt;key&lt;/code&gt; を追加すると、ツリー変換が効率的になります。</target>
        </trans-unit>
        <trans-unit id="9b6804b7a0eea45b9845222ba70ab59b4cf0b8e7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;connect&lt;/code&gt; is a higher-order function that returns a higher-order component!</source>
          <target state="translated">つまり、 &lt;code&gt;connect&lt;/code&gt; は高次コンポーネントを返す高次関数です！</target>
        </trans-unit>
        <trans-unit id="80f812104a6e940fb1554b3b0a149eca257b5c85" translate="yes" xml:space="preserve">
          <source>In our example, we already have two state variables. The input text is in &lt;code&gt;query&lt;/code&gt;, and we read the translation from &lt;code&gt;resource&lt;/code&gt;. We want changes to the &lt;code&gt;query&lt;/code&gt; state to happen immediately, but changes to the &lt;code&gt;resource&lt;/code&gt; (i.e. fetching a new translation) should trigger a transition.</source>
          <target state="translated">この例では、すでに2つの状態変数があります。入力テキストは &lt;code&gt;query&lt;/code&gt; にあり、翻訳を &lt;code&gt;resource&lt;/code&gt; から読み取ります。私たちは、に変更したい &lt;code&gt;query&lt;/code&gt; 状態がすぐに発生するが、それに変わる &lt;code&gt;resource&lt;/code&gt; の移行をトリガする必要があります（つまり、フェッチA新しい翻訳）。</target>
        </trans-unit>
        <trans-unit id="2e399b2e569c6a0bcf071e62ad256ed5a3d201d7" translate="yes" xml:space="preserve">
          <source>In our experience, code that uses idiomatic React patterns and doesn&amp;rsquo;t rely on external state management solutions is the easiest to get running in the Concurrent Mode. We will describe common problems we&amp;rsquo;ve seen and the solutions to them separately in the coming weeks.</source>
          <target state="translated">私たちの経験では、慣用的なReactパターンを使用し、外部状態管理ソリューションに依存しないコードは、並行モードで実行するのが最も簡単です。これまでに確認した一般的な問題とその解決策については、今後数週間で個別に説明します。</target>
        </trans-unit>
        <trans-unit id="3a945c86c779350192d3215abb4afd0b7e2b4ebf" translate="yes" xml:space="preserve">
          <source>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</source>
          <target state="translated">私たちの経験では、時間の経過とともにUIをどう変えるかではなく、その瞬間にUIがどのように見えるかを考えることで、多くのバグを排除することができました。</target>
        </trans-unit>
        <trans-unit id="33d3facfdb5b3a33c51c1e47e735a86dc335c375" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;this.props.children&lt;/code&gt; is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.</source>
          <target state="translated">特に、 &lt;code&gt;this.props.children&lt;/code&gt; は特別なプロップであり、通常はタグ自体ではなく、JSX式の子タグによって定義されます。</target>
        </trans-unit>
        <trans-unit id="ff52786b96cb28b8516c4c77d035f3f94ffa6e3e" translate="yes" xml:space="preserve">
          <source>In particular, the rule enforces that:</source>
          <target state="translated">特に、ルールではそれを強制しています。</target>
        </trans-unit>
        <trans-unit id="0d696f2b7ef6c0b071645ffc121cc67457984603" translate="yes" xml:space="preserve">
          <source>In practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data:</source>
          <target state="translated">実際には、キーを見つけるのは難しくありません。表示しようとしている要素はすでにユニークなIDを持っている可能性がありますので、キーはあなたのデータから取得することができます。</target>
        </trans-unit>
        <trans-unit id="ade1231470ce955a57c66a5a4a65595e2c307122" translate="yes" xml:space="preserve">
          <source>In practice, most React apps only call &lt;code&gt;ReactDOM.render()&lt;/code&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</source>
          <target state="translated">実際には、ほとんどのReactアプリは &lt;code&gt;ReactDOM.render()&lt;/code&gt; を 1回だけ呼び出します。次のセクションでは、このようなコードが&lt;a href=&quot;state-and-lifecycle&quot;&gt;ステートフルコンポーネントに&lt;/a&gt;カプセル化される方法を学びます。</target>
        </trans-unit>
        <trans-unit id="909459ee6d5f8fcf3afdeb0255be50e086b6e528" translate="yes" xml:space="preserve">
          <source>In practice, these assumptions are valid for almost all practical use cases.</source>
          <target state="translated">実際には、これらの仮定はほぼすべての実用的なユースケースで有効です。</target>
        </trans-unit>
        <trans-unit id="3d0b8aeba59f064eef6dc0b26b57e2face696137" translate="yes" xml:space="preserve">
          <source>In practice, we expect that most apps using Legacy Mode today should be able to migrate at least to the Blocking Mode (if not Concurrent Mode). This fragmentation can be annoying for libraries that aim to support all Modes in the short term. However, gradually moving the ecosystem away from the Legacy Mode will also &lt;em&gt;solve&lt;/em&gt; problems that affect major libraries in the React ecosystem, such as &lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;confusing Suspense behavior when reading layout&lt;/a&gt; and &lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;lack of consistent batching guarantees&lt;/a&gt;. There&amp;rsquo;s a number of bugs that can&amp;rsquo;t be fixed in Legacy Mode without changing semantics, but don&amp;rsquo;t exist in Blocking and Concurrent Modes.</source>
          <target state="translated">実際には、レガシーモードを使用しているほとんどのアプリは、少なくともブロッキングモード（同時モードでない場合）に移行できるはずです。この断片化は、短期的にすべてのモードをサポートすることを目的とするライブラリにとっては煩わしいものになる可能性があります。しかし、徐々に離れレガシーモードから生態系を移動することもします&lt;em&gt;解決&lt;/em&gt;など、生態系を反応させるのに大きな図書館に影響を与える問題&lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;レイアウト読むときサスペンス行動を混乱さ&lt;/a&gt;と&lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;一貫性のあるバッチ処理の保証の欠如を&lt;/a&gt;。セマンティクスを変更せずにレガシーモードで修正できないバグがいくつかありますが、ブロッキングモードと同時モードには存在しません。</target>
        </trans-unit>
        <trans-unit id="6b279656dca3be237f10a8565147d5f390d7e94e" translate="yes" xml:space="preserve">
          <source>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return &lt;code&gt;null&lt;/code&gt; instead of its render output.</source>
          <target state="translated">まれに、コンポーネントが別のコンポーネントによってレンダリングされたとしても、それ自体を非表示にしたい場合があります。これを行うには、レンダー出力の代わりに &lt;code&gt;null&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0a098d464d31796bcdd791f834a68bda2df286c2" translate="yes" xml:space="preserve">
          <source>In rare cases, you may be running a test on a component that uses multiple renderers. For example, you may be running snapshot tests on a component with &lt;code&gt;react-test-renderer&lt;/code&gt;, that internally uses &lt;code&gt;ReactDOM.render&lt;/code&gt; inside a child component to render some content. In this scenario, you can wrap updates with &lt;code&gt;act()&lt;/code&gt;s corresponding to their renderers.</source>
          <target state="translated">まれに、複数のレンダラーを使用するコンポーネントでテストを実行している場合があります。たとえば、子コンポーネント内で &lt;code&gt;ReactDOM.render&lt;/code&gt; を内部的に使用してコンテンツをレンダリングする &lt;code&gt;react-test-renderer&lt;/code&gt; を使用して、コンポーネントでスナップショットテストを実行している場合があります。このシナリオでは、レンダラーに対応する &lt;code&gt;act()&lt;/code&gt; で更新をラップできます。</target>
        </trans-unit>
        <trans-unit id="04d050c85bc701c68bd6d50bf673ea61647fdec4" translate="yes" xml:space="preserve">
          <source>In rare cases, you might want to have access to a child&amp;rsquo;s DOM node from a parent component. This is generally not recommended because it breaks component encapsulation, but it can occasionally be useful for triggering focus or measuring the size or position of a child DOM node.</source>
          <target state="translated">まれに、親コンポーネントから子のDOMノードにアクセスしたい場合があります。これはコンポーネントのカプセル化を壊すため、一般的には推奨されませんが、フォーカスをトリガーしたり、子DOMノードのサイズや位置を測定したりするのに役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="c6863ffdd3d1c41a019b99c0ce9ef587c06e42de" translate="yes" xml:space="preserve">
          <source>In some browsers we can easily view the accessibility information for each element in the accessibility tree:</source>
          <target state="translated">一部のブラウザでは、アクセシビリティツリーの各要素のアクセシビリティ情報を簡単に見ることができます。</target>
        </trans-unit>
        <trans-unit id="ef7f108e140b39155a7e18cc38167a7857627734" translate="yes" xml:space="preserve">
          <source>In some cases formatting a value for display might be an expensive operation. It&amp;rsquo;s also unnecessary unless a Hook is actually inspected.</source>
          <target state="translated">場合によっては、値を表示用にフォーマットするとコストのかかる操作になることがあります。フックが実際に検査されない限り、これも不要です。</target>
        </trans-unit>
        <trans-unit id="abfe23fc439cd1390e394329a6ecb1eeec14f4b5" translate="yes" xml:space="preserve">
          <source>In some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with &lt;code&gt;prevProps&lt;/code&gt; or &lt;code&gt;prevState&lt;/code&gt; inside &lt;code&gt;componentDidUpdate&lt;/code&gt;:</source>
          <target state="translated">場合によっては、レンダリングのたびに効果をクリーンアップまたは適用すると、パフォーマンスの問題が発生することがあります。クラスコンポーネントでは、 &lt;code&gt;prevState&lt;/code&gt; 内で &lt;code&gt;prevProps&lt;/code&gt; またはprevStateとの追加の比較を記述することでこれを解決でき &lt;code&gt;componentDidUpdate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="110ae94bd79008897c0972ade096014f8e0302a9" translate="yes" xml:space="preserve">
          <source>In some rare cases you might need to memoize a callback with &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; but the memoization doesn&amp;rsquo;t work very well because the inner function has to be re-created too often. If the function you&amp;rsquo;re memoizing is an event handler and isn&amp;rsquo;t used during rendering, you can use &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref as an instance variable&lt;/a&gt;, and save the last committed value into it manually:</source>
          <target state="translated">まれに、コールバックを&lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; &lt;/a&gt;でメモする必要がある場合がありますが、内部の関数を頻繁に再作成する必要があるため、メモはうまく機能しません。メモ化する関数がイベントハンドラーであり、レンダリング中に使用されない場合は&lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;、インスタンス変数としてrefを&lt;/a&gt;使用し、最後にコミットされた値を手動で保存できます。</target>
        </trans-unit>
        <trans-unit id="0c1cdbd6853a083ca4623e0db98a09dc4da4738b" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;development&lt;/strong&gt; mode, you can visualize how components mount, update, and unmount, using the performance tools in supported browsers. For example:</source>
          <target state="translated">では&lt;strong&gt;、開発&lt;/strong&gt;モードでは、サポートされているブラウザでパフォーマンスツールを使用して、コンポーネントは、アップデートを実装する方法視覚化、およびアンマウントすることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="f0b550316b6eedb96eacfc072502ecdd2917564a" translate="yes" xml:space="preserve">
          <source>In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Reactレンダリングライフサイクルでは、フォーム要素の &lt;code&gt;value&lt;/code&gt; 属性がDOMの値をオーバーライドします。制御されていないコンポーネントでは、Reactで初期値を指定し、その後の更新は制御しないままにすることがよくあります。このケースを処理するには、 &lt;code&gt;value&lt;/code&gt; の代わりに &lt;code&gt;defaultValue&lt;/code&gt; 属性を指定できます。</target>
        </trans-unit>
        <trans-unit id="903bb48f1156a6b0ac31b18a1cbe3d5dc1be1cc3" translate="yes" xml:space="preserve">
          <source>In the above component, we have &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;fruit&lt;/code&gt;, and &lt;code&gt;todos&lt;/code&gt; as local variables, and we can update them individually:</source>
          <target state="translated">上記のコンポーネントでは、ローカル変数として &lt;code&gt;age&lt;/code&gt; 、 &lt;code&gt;fruit&lt;/code&gt; 、および &lt;code&gt;todos&lt;/code&gt; があり、これらを個別に更新できます。</target>
        </trans-unit>
        <trans-unit id="4d1e3bc1269742bd242168387646a23702e59a34" translate="yes" xml:space="preserve">
          <source>In the above example, React passes a &lt;code&gt;ref&lt;/code&gt; given to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; element as a second argument to the rendering function inside the &lt;code&gt;React.forwardRef&lt;/code&gt; call. This rendering function passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">上記の例では、Reactは &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; 要素に与えられた &lt;code&gt;ref&lt;/code&gt; 2番目の引数として &lt;code&gt;React.forwardRef&lt;/code&gt; 呼び出し内のレンダリング関数に渡します。このレンダリング関数は、 &lt;code&gt;ref&lt;/code&gt; を &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; 要素に渡します。</target>
        </trans-unit>
        <trans-unit id="ccb9604592cfa6b12895f257ac0c24ea334d72d8" translate="yes" xml:space="preserve">
          <source>In the above example, strict mode checks will &lt;em&gt;not&lt;/em&gt; be run against the &lt;code&gt;Header&lt;/code&gt; and &lt;code&gt;Footer&lt;/code&gt; components. However, &lt;code&gt;ComponentOne&lt;/code&gt; and &lt;code&gt;ComponentTwo&lt;/code&gt;, as well as all of their descendants, will have the checks.</source>
          <target state="translated">上記の例では、 &lt;code&gt;Header&lt;/code&gt; および &lt;code&gt;Footer&lt;/code&gt; コンポーネントに対して厳格なモードチェックは実行され&lt;em&gt;ません&lt;/em&gt;。ただし、 &lt;code&gt;ComponentOne&lt;/code&gt; と &lt;code&gt;ComponentTwo&lt;/code&gt; 、およびそれらのすべての子孫にはチェックがあります。</target>
        </trans-unit>
        <trans-unit id="161b69b6d458031682de9bd001c8a47eb9f053a9" translate="yes" xml:space="preserve">
          <source>In the above examples, it is important to read the &lt;code&gt;scrollHeight&lt;/code&gt; property in &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; because there may be delays between &amp;ldquo;render&amp;rdquo; phase lifecycles (like &lt;code&gt;render&lt;/code&gt;) and &amp;ldquo;commit&amp;rdquo; phase lifecycles (like &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;).</source>
          <target state="translated">上記の例では、読み取ることが重要である &lt;code&gt;scrollHeight&lt;/code&gt; の中性 &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; を「レンダリング」フェーズのライフサイクルの間に遅延が存在し得るため（のような &lt;code&gt;render&lt;/code&gt; ）および（等位相のライフサイクル「コミット」 &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; と &lt;code&gt;componentDidUpdate&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="d1492c41f81989404e70e8f6aae15b755c6639ac" translate="yes" xml:space="preserve">
          <source>In the beginning, our stated goal was to remove the duplicated logic from the &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt; components. Both of them want to know whether a friend is online.</source>
          <target state="translated">当初、私たちが述べた目標は、重複したロジックを &lt;code&gt;FriendStatus&lt;/code&gt; および &lt;code&gt;FriendListItem&lt;/code&gt; コンポーネントから削除することでした。どちらも、友達がオンラインかどうかを知りたいと思っています。</target>
        </trans-unit>
        <trans-unit id="c894c3353cd13202ba9261426d4b8ea1935aef6a" translate="yes" xml:space="preserve">
          <source>In the cron job, update your React packages to the most recent React release in the Next channel, using &lt;code&gt;next&lt;/code&gt; tag on npm. Using the npm cli:</source>
          <target state="translated">cronジョブで、npmの &lt;code&gt;next&lt;/code&gt; タグを使用して、ReactパッケージをNextチャネルの最新のReactリリースに更新します。npm cliを使用する：</target>
        </trans-unit>
        <trans-unit id="2fe2f07417c38339db698cf1646bb4c866463cd8" translate="yes" xml:space="preserve">
          <source>In the event of an error, you can render a fallback UI with &lt;code&gt;componentDidCatch()&lt;/code&gt; by calling &lt;code&gt;setState&lt;/code&gt;, but this will be deprecated in a future release. Use &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; to handle fallback rendering instead.</source>
          <target state="translated">エラーが発生した場合は、 &lt;code&gt;setState&lt;/code&gt; を呼び出すことで、 &lt;code&gt;componentDidCatch()&lt;/code&gt; を使用してフォールバックUIをレンダリングできますが、これは将来のリリースで廃止される予定です。代わりに &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; を使用して、フォールバックレンダリングを処理します。</target>
        </trans-unit>
        <trans-unit id="81bc674a950124866a089232847d2007a365dc48" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;Parent&lt;/code&gt; passes its ref callback as an &lt;code&gt;inputRef&lt;/code&gt; prop to the &lt;code&gt;CustomTextInput&lt;/code&gt;, and the &lt;code&gt;CustomTextInput&lt;/code&gt; passes the same function as a special &lt;code&gt;ref&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. As a result, &lt;code&gt;this.inputElement&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt; will be set to the DOM node corresponding to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element in the &lt;code&gt;CustomTextInput&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;Parent&lt;/code&gt; としてのREFコールバックを通過 &lt;code&gt;inputRef&lt;/code&gt; のにプロップ &lt;code&gt;CustomTextInput&lt;/code&gt; 、及び &lt;code&gt;CustomTextInput&lt;/code&gt; は特殊と同じ機能を通過する &lt;code&gt;ref&lt;/code&gt; に属性 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 。結果として、 &lt;code&gt;this.inputElement&lt;/code&gt; に &lt;code&gt;Parent&lt;/code&gt; 対応するDOMノードに設定されます &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; の要素 &lt;code&gt;CustomTextInput&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78bb563116bb5963983d968cb91e61df5f00f963" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;kind&lt;/code&gt; prop is safely consumed and &lt;em&gt;is not&lt;/em&gt; passed on to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element in the DOM. All other props are passed via the &lt;code&gt;...other&lt;/code&gt; object making this component really flexible. You can see that it passes an &lt;code&gt;onClick&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; props.</source>
          <target state="translated">上記の例では、 &lt;code&gt;kind&lt;/code&gt; プロップは安全に消費され、DOMの &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 要素に渡され&lt;em&gt;ません&lt;/em&gt;。他のすべての小道具は &lt;code&gt;...other&lt;/code&gt; オブジェクトを介して渡され、このコンポーネントを本当に柔軟にします。 &lt;code&gt;onClick&lt;/code&gt; と &lt;code&gt;children&lt;/code&gt; 小道具を渡していることがわかります。</target>
        </trans-unit>
        <trans-unit id="50c03112f0e316b498156bed257c2771954012e9" translate="yes" xml:space="preserve">
          <source>In the example above, we pass &lt;code&gt;[count]&lt;/code&gt; as the second argument. What does this mean? If the &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;5&lt;/code&gt;, and then our component re-renders with &lt;code&gt;count&lt;/code&gt; still equal to &lt;code&gt;5&lt;/code&gt;, React will compare &lt;code&gt;[5]&lt;/code&gt; from the previous render and &lt;code&gt;[5]&lt;/code&gt; from the next render. Because all items in the array are the same (&lt;code&gt;5 === 5&lt;/code&gt;), React would skip the effect. That&amp;rsquo;s our optimization.</source>
          <target state="translated">上記の例では、2番目の引数として &lt;code&gt;[count]&lt;/code&gt; を渡します。これは何を意味するのでしょうか？場合は &lt;code&gt;count&lt;/code&gt; ある &lt;code&gt;5&lt;/code&gt; 、その後、私たちのコンポーネントを再描画 &lt;code&gt;count&lt;/code&gt; まだに等しい &lt;code&gt;5&lt;/code&gt; 、リアクト比較します &lt;code&gt;[5]&lt;/code&gt; をレンダリングし、前回から &lt;code&gt;[5]&lt;/code&gt; 次のレンダリングから。配列内のすべての項目が同じ（ &lt;code&gt;5 === 5&lt;/code&gt; ）であるため、Reactは効果をスキップします。それが私たちの最適化です。</target>
        </trans-unit>
        <trans-unit id="b7c3d10a47d45d9cf31357af92cb4eff75e31bc3" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;FancyButton&lt;/code&gt; uses &lt;code&gt;React.forwardRef&lt;/code&gt; to obtain the &lt;code&gt;ref&lt;/code&gt; passed to it, and then forward it to the DOM &lt;code&gt;button&lt;/code&gt; that it renders:</source>
          <target state="translated">以下の例では、 &lt;code&gt;FancyButton&lt;/code&gt; は &lt;code&gt;React.forwardRef&lt;/code&gt; を使用して渡された &lt;code&gt;ref&lt;/code&gt; を取得し、それをレンダリングするDOM &lt;code&gt;button&lt;/code&gt; 転送します。</target>
        </trans-unit>
        <trans-unit id="da172bb676090bc853f066f60868863ede80ccc2" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; is rendered depending on the value of the prop called &lt;code&gt;warn&lt;/code&gt;. If the value of the prop is &lt;code&gt;false&lt;/code&gt;, then the component does not render:</source>
          <target state="translated">以下の例では、 &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; は、 &lt;code&gt;warn&lt;/code&gt; と呼ばれるプロップの値に応じてレンダリングされます。プロパティの値が &lt;code&gt;false&lt;/code&gt; の場合、コンポーネントはレンダリングされません。</target>
        </trans-unit>
        <trans-unit id="4c9b0d091cbcaeb26aef58746ea16d7326d16599" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;List&lt;/code&gt; component renders a Backbone collection, using the &lt;code&gt;Item&lt;/code&gt; component to render individual items.</source>
          <target state="translated">次の例では、 &lt;code&gt;List&lt;/code&gt; コンポーネントがBackboneコレクションをレンダリングし、 &lt;code&gt;Item&lt;/code&gt; コンポーネントを使用して個々のアイテムをレンダリングしています。</target>
        </trans-unit>
        <trans-unit id="132775b1447feeefec74e2f18536a9d528215b18" translate="yes" xml:space="preserve">
          <source>In the example below, we declare a variable called &lt;code&gt;name&lt;/code&gt; and then use it inside JSX by wrapping it in curly braces:</source>
          <target state="translated">以下の例では、 &lt;code&gt;name&lt;/code&gt; という変数を宣言し、中かっこで囲んでJSX内で使用しています。</target>
        </trans-unit>
        <trans-unit id="d7dd67cb57a4dc9f027ea3f3b201e027d6f0cf20" translate="yes" xml:space="preserve">
          <source>In the example below, we embed the result of calling a JavaScript function, &lt;code&gt;formatName(user)&lt;/code&gt;, into an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">以下の例では、我々は、JavaScript関数を呼び出した結果埋め込む &lt;code&gt;formatName(user)&lt;/code&gt; に、 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 要素。</target>
        </trans-unit>
        <trans-unit id="e50a991765ef6cc4009766a397d70d227449d563" translate="yes" xml:space="preserve">
          <source>In the example below, we use it to conditionally render a small block of text.</source>
          <target state="translated">以下の例では、小さなテキストブロックを条件付きでレンダリングするために使用します。</target>
        </trans-unit>
        <trans-unit id="d3bfcd8d3b96478cd697022392b9e4b2c38089ff" translate="yes" xml:space="preserve">
          <source>In the example below, we will create a &lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;stateful component&lt;/a&gt; called &lt;code&gt;LoginControl&lt;/code&gt;.</source>
          <target state="translated">以下の例では、我々が作成されます&lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;ステートフルなコンポーネント&lt;/a&gt;と呼ばれる &lt;code&gt;LoginControl&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="6b92032c1bbddab0648c95b3163a2986b7e77271" translate="yes" xml:space="preserve">
          <source>In the example below, we will make a copy of the model&amp;rsquo;s attributes to form the initial state. We subscribe to the &lt;code&gt;change&lt;/code&gt; event (and unsubscribe on unmounting), and when it happens, we update the state with the model&amp;rsquo;s current attributes. Finally, we make sure that if the &lt;code&gt;model&lt;/code&gt; prop itself changes, we don&amp;rsquo;t forget to unsubscribe from the old model, and subscribe to the new one.</source>
          <target state="translated">以下の例では、モデルの属性のコピーを作成して初期状態を形成します。 &lt;code&gt;change&lt;/code&gt; イベントをサブスクライブ（およびアンマウント時にサブスクライブ解除）し、それが発生すると、モデルの現在の属性で状態を更新します。最後に、 &lt;code&gt;model&lt;/code&gt; 小道具自体が変更された場合は、古いモデルの購読を解除し、新しいモデルを購読することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="63df20cb3c0206857b6eb72aa649ffbe4eec47b7" translate="yes" xml:space="preserve">
          <source>In the examples above we declared a separate &lt;code&gt;listItems&lt;/code&gt; variable and included it in JSX:</source>
          <target state="translated">上記の例では、個別の &lt;code&gt;listItems&lt;/code&gt; 変数を宣言し、それをJSXに含めました。</target>
        </trans-unit>
        <trans-unit id="ee218035757e1dcb006cf4b284261900739df97e" translate="yes" xml:space="preserve">
          <source>In the examples above, we only relied on features that are natively supported by the browsers. This is why we used a JavaScript function call to tell React what to display:</source>
          <target state="translated">上記の例では、ブラウザがネイティブにサポートしている機能のみに頼っています。そのため、Reactに何を表示するかを指示するためにJavaScriptの関数呼び出しを使用しました。</target>
        </trans-unit>
        <trans-unit id="d4709b211731b0d98acf24cd2d4b4c0e25f437be" translate="yes" xml:space="preserve">
          <source>In the future, the second argument might get added automatically by a build-time transformation.</source>
          <target state="translated">将来的には、第二引数はビルド時の変換によって自動的に追加されるようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="8be1cdda076b922dcae71dadf71ff42ad65b19bd" translate="yes" xml:space="preserve">
          <source>In the long term, we intend Suspense to become the primary way to read asynchronous data from components &amp;mdash; no matter where that data is coming from.</source>
          <target state="translated">長期的には、Suspenseがコンポーネントから非同期データを読み取るための主要な方法になることを目指しています。</target>
        </trans-unit>
        <trans-unit id="067bfddcfac5a573b68db915d05c5417e983d5ef" translate="yes" xml:space="preserve">
          <source>In the past, JavaScript errors inside components used to corrupt React&amp;rsquo;s internal state and cause it to &lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;emit&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;cryptic&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;errors&lt;/a&gt; on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.</source>
          <target state="translated">過去には、破損しているに使用されるコンポーネントの内部JavaScriptエラーは、内部の状態を反応させ、それをさせ&lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;発する&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;不可解な&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;エラーを&lt;/a&gt;次のレンダリングに。これらのエラーは常にアプリケーションコードの以前のエラーが原因で発生しましたが、Reactはコンポーネントでエラーを正常に処理する方法を提供していなかったため、エラーから回復できませんでした。</target>
        </trans-unit>
        <trans-unit id="1d1757c6b2b83b26c148e1fe2455fe52c634722f" translate="yes" xml:space="preserve">
          <source>In the previous Suspense example, we only had one &lt;code&gt;resource&lt;/code&gt;, so we held it in a top-level variable. Now that we have multiple resources, we moved it to the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt;&amp;rsquo;s component state:</source>
          <target state="translated">前のサスペンスの例では、 &lt;code&gt;resource&lt;/code&gt; が1つしかないため、最上位の変数に保持しました。複数のリソースがあるので、それを &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; のコンポーネント状態に移動しました。</target>
        </trans-unit>
        <trans-unit id="fbb97b6fdd583b9cf2c6eeadfbb049b439293e48" translate="yes" xml:space="preserve">
          <source>In the previous approach, we fetched data before we called &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="translated">前のアプローチでは、 &lt;code&gt;setState&lt;/code&gt; を呼び出す前にデータをフェッチしました。</target>
        </trans-unit>
        <trans-unit id="c0baea048f9023ac78378921b5cbb9d00932c292" translate="yes" xml:space="preserve">
          <source>In the typical React dataflow, &lt;a href=&quot;components-and-props&quot;&gt;props&lt;/a&gt; are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.</source>
          <target state="translated">典型的なReactデータフローでは、親コンポーネントが子と対話する唯一の方法は&lt;a href=&quot;components-and-props&quot;&gt;プロップ&lt;/a&gt;です。子を変更するには、新しい小道具で再レンダリングします。ただし、通常のデータフロー以外で子を強制的に変更する必要がある場合がいくつかあります。変更される子は、Reactコンポーネントのインスタンスである場合と、DOM要素である場合があります。これらのケースの両方に対して、Reactは脱出ハッチを提供します。</target>
        </trans-unit>
        <trans-unit id="a86357d07cf0dbd879f2bd26a66e1afff5014629" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;shouldComponentUpdate&lt;/code&gt; is just checking if there is any change in &lt;code&gt;props.color&lt;/code&gt; or &lt;code&gt;state.count&lt;/code&gt;. If those values don&amp;rsquo;t change, the component doesn&amp;rsquo;t update. If your component got more complex, you could use a similar pattern of doing a &amp;ldquo;shallow comparison&amp;rdquo; between all the fields of &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; to determine if the component should update. This pattern is common enough that React provides a helper to use this logic - just inherit from &lt;code&gt;React.PureComponent&lt;/code&gt;. So this code is a simpler way to achieve the same thing:</source>
          <target state="translated">このコードでは、 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; は、 &lt;code&gt;props.color&lt;/code&gt; または &lt;code&gt;state.count&lt;/code&gt; に変更があるかどうかを確認しているだけです。これらの値が変更されない場合、コンポーネントは更新されません。コンポーネントがより複雑になった場合は、 &lt;code&gt;props&lt;/code&gt; と &lt;code&gt;state&lt;/code&gt; のすべてのフィールド間で「浅い比較」を行う同様のパターンを使用して、コンポーネントを更新する必要があるかどうかを判断できます。このパターンは、Reactがこのロジックを使用するヘルパーを提供するのに十分一般的です &lt;code&gt;React.PureComponent&lt;/code&gt; から継承するだけです。したがって、このコードは同じことを実現するためのより簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="9baf7530f7f1f0cc2de7e8a95550b370cd39a79c" translate="yes" xml:space="preserve">
          <source>In this code, we&amp;rsquo;ve wrapped our data fetching with &lt;code&gt;startTransition&lt;/code&gt;. This allows us to start fetching the profile data right away, while deferring the render of the next profile page and its associated &lt;code&gt;Spinner&lt;/code&gt; for 2 seconds (the time shown in &lt;code&gt;timeoutMs&lt;/code&gt;).</source>
          <target state="translated">このコードでは、データのフェッチを &lt;code&gt;startTransition&lt;/code&gt; でラップしています。これにより、次のプロファイルページとそれに関連付けられた &lt;code&gt;Spinner&lt;/code&gt; のレンダリングを2秒間延期しながら（ &lt;code&gt;timeoutMs&lt;/code&gt; に表示される時間）、プロファイルデータのフェッチをすぐに開始できます。</target>
        </trans-unit>
        <trans-unit id="a37905846a8f4c106d186eeaf752c69ecc60a20e" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why higher-order components are useful, and how to write your own.</source>
          <target state="translated">このドキュメントでは、高次コンポーネントが役立つ理由と、独自のコンポーネントを作成する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="cbf9764d5b2c9095bb5b4589f2f63cafc22cfd01" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why render props are useful, and how to write your own.</source>
          <target state="translated">このドキュメントでは、レンダープロップが役立つ理由と、独自のプロップを作成する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="600a8bed687912f2e4672cb1492ee6559ff93168" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; waits for both requests but starts them in parallel:</source>
          <target state="translated">この例では、 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; は両方の要求を待機しますが、それらを並行して開始します。</target>
        </trans-unit>
        <trans-unit id="d9098805d0375365763e9b4152ec3e31f62f1c1a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;ProfileDetails&lt;/code&gt; is waiting for an asynchronous API call to fetch some data. While we wait for &lt;code&gt;ProfileDetails&lt;/code&gt; and &lt;code&gt;ProfilePhoto&lt;/code&gt;, we will show the &lt;code&gt;Loading...&lt;/code&gt; fallback instead. It is important to note that until all children inside &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; has loaded, we will continue to show the fallback.</source>
          <target state="translated">この例では、 &lt;code&gt;ProfileDetails&lt;/code&gt; は非同期API呼び出しがデータをフェッチするのを待機しています。 &lt;code&gt;ProfileDetails&lt;/code&gt; と &lt;code&gt;ProfilePhoto&lt;/code&gt; を待つ間、代わりに &lt;code&gt;Loading...&lt;/code&gt; フォールバックを表示します。 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 内のすべての子が読み込まれるまで、フォールバックを表示し続けることに注意してください。</target>
        </trans-unit>
        <trans-unit id="782491ad80c95f67dcb2debb7f87f060c15672be" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;every item in &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; has an artificial slowdown &amp;mdash; each of them blocks the thread for a few milliseconds&lt;/strong&gt;. We&amp;rsquo;d never do this in a real app, but this helps us simulate what can happen in a deep component tree with no single obvious place to optimize.</source>
          <target state="translated">この例では、&lt;strong&gt; &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; の&lt;/strong&gt;&lt;strong&gt;すべてのアイテムに人為的なスローダウンがあります&lt;/strong&gt;。&lt;strong&gt;それぞれが数ミリ秒間スレッドをブロックします&lt;/strong&gt;。実際のアプリでこれを行うことは決してありませんが、これは、最適化する明確な場所が1つもない、深いコンポーネントツリーで何が発生するかをシミュレートするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1e713cd57d3c728babeb0c18ce780cd3201c1805" translate="yes" xml:space="preserve">
          <source>In this example, React would unsubscribe from our &lt;code&gt;ChatAPI&lt;/code&gt; when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there&amp;rsquo;s a way to &lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;tell React to skip re-subscribing&lt;/a&gt; if the &lt;code&gt;props.friend.id&lt;/code&gt; we passed to &lt;code&gt;ChatAPI&lt;/code&gt; didn&amp;rsquo;t change.)</source>
          <target state="translated">この例では、コンポーネントがアンマウントされたとき、および後続のレンダリングによる効果を再実行する前に、Reactは &lt;code&gt;ChatAPI&lt;/code&gt; からサブスクライブ解除します。（必要に応じて、 &lt;code&gt;props.friend.id&lt;/code&gt; に渡した &lt;code&gt;ChatAPI&lt;/code&gt; が変更されなかった場合、&lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;再サブスクライブをスキップ&lt;/a&gt;するようにReactに指示する方法があります。）</target>
        </trans-unit>
        <trans-unit id="be0484ff678e7e7fe151098cbd0937ebbd00eb82" translate="yes" xml:space="preserve">
          <source>In this example, a parent component that renders &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; would be able to call &lt;code&gt;inputRef.current.focus()&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; をレンダリングする親コンポーネントは &lt;code&gt;inputRef.current.focus()&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="7d4bb4e68cbd0c4ac7dd0c4d7a725bdc64841434" translate="yes" xml:space="preserve">
          <source>In this example, each time &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; renders, it generates a new function as the value of the &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; prop, thus negating the effect of &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; extending &lt;code&gt;React.PureComponent&lt;/code&gt; in the first place!</source>
          <target state="translated">この例では、 &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; がレンダリングするたびに、 &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; プロップの値として新しい関数を生成するため、最初に &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; が &lt;code&gt;React.PureComponent&lt;/code&gt; を拡張する効果を無効にします。</target>
        </trans-unit>
        <trans-unit id="1a67a59e557a8bb22da36c7b17ee44b1abf8d495" translate="yes" xml:space="preserve">
          <source>In this example, the callback ref will be called only when the component mounts and unmounts, since the rendered &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; component stays present throughout any rerenders. If you want to be notified any time a component resizes, you may want to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt;&lt;code&gt;ResizeObserver&lt;/code&gt;&lt;/a&gt; or a third-party Hook built on it.</source>
          <target state="translated">この例では、レンダリングされた &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; コンポーネントがすべての再レンダリングを通じて存在し続けるため、コンポーネントがマウントおよびアンマウントするときにのみ、コールバックrefが呼び出されます。コンポーネントのサイズが変更されたときに通知を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt; &lt;code&gt;ResizeObserver&lt;/code&gt; &lt;/a&gt;たい場合は、ResizeObserverまたはその上に構築されたサードパーティのフックを使用できます。</target>
        </trans-unit>
        <trans-unit id="e55f1824db5d408d73e18ba03a5505618f145cbb" translate="yes" xml:space="preserve">
          <source>In this example, we manually thread through a &lt;code&gt;color&lt;/code&gt; prop in order to style the &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;Message&lt;/code&gt; components appropriately. Using context, we can pass this through the tree automatically:</source>
          <target state="translated">この例では、 &lt;code&gt;Button&lt;/code&gt; コンポーネントと &lt;code&gt;Message&lt;/code&gt; コンポーネントを適切にスタイル設定するために、 &lt;code&gt;color&lt;/code&gt; プロップを手動で通しています。コンテキストを使用して、これをツリーに自動的に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="f0d3462a96fdf5b6668c86137312037ef5107ef1" translate="yes" xml:space="preserve">
          <source>In this example, we render a component and format the rendered HTML with the &lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/a&gt; package, before saving it as an inline snapshot:</source>
          <target state="translated">この例では、インラインスナップショットとして保存する前に、コンポーネントをレンダリングし、レンダリングされたHTMLを&lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;/a&gt;パッケージでフォーマットします。</target>
        </trans-unit>
        <trans-unit id="a2a678be6ef80893f4443dae3189e07dc9af8576" translate="yes" xml:space="preserve">
          <source>In this example, we start data fetching at the load &lt;em&gt;and&lt;/em&gt; every time you press &amp;ldquo;Refresh&amp;rdquo;. We put the result of calling &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; into state so that components below can start reading the new data from the request we just kicked off.</source>
          <target state="translated">この例では、ロード時&lt;em&gt;および&lt;/em&gt;「更新」を押すたびにデータのフェッチを開始します。 &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; を呼び出した結果を状態にして、以下のコンポーネントが、開始したリクエストから新しいデータの読み取りを開始できるようにします。</target>
        </trans-unit>
        <trans-unit id="40e5ce9d2c277949ff6850c2e07a7ce4249ad65e" translate="yes" xml:space="preserve">
          <source>In this example, we started our journey on the &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">この例では、 &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt; から出発しました。</target>
        </trans-unit>
        <trans-unit id="be16ebf22fd30a0569861e07662b2e8b026b4f83" translate="yes" xml:space="preserve">
          <source>In this guide, we will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</source>
          <target state="translated">このガイドでは、React アプリの構成要素である要素とコンポーネントを見ていきます。これらをマスターすれば、再利用可能な小さなピースから複雑なアプリを作成することができます。</target>
        </trans-unit>
        <trans-unit id="04d2198505214dcf8ceed2b4c9ee7adaedd5197b" translate="yes" xml:space="preserve">
          <source>In this scenario, you would use a framework like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt; or a library like &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; so you can navigate between multiple routes and assert on side effects not just in the browser, but potentially on the backend as well.</source>
          <target state="translated">このシナリオでは、&lt;a href=&quot;https://www.cypress.io/&quot;&gt;サイプレスの&lt;/a&gt;ようなフレームワークや&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;人形劇の&lt;/a&gt;ようなライブラリを使用して、複数のルート間をナビゲートし、ブラウザーだけでなくバックエンドでも副作用をアサートできるようにします。</target>
        </trans-unit>
        <trans-unit id="012fec99829ecc46c7a061a559b55cea20db4530" translate="yes" xml:space="preserve">
          <source>In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.</source>
          <target state="translated">このセクションでは、Reactに慣れていない開発者が継承に手を伸ばすことが多いいくつかの問題を考え、コンポジションを使って解決する方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="2354bfe7189104f2d54a127296a8b8ac4cb54d00" translate="yes" xml:space="preserve">
          <source>In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.</source>
          <target state="translated">ここでは、所定の温度になると水が沸騰するかどうかを計算する温度計算機を作成します。</target>
        </trans-unit>
        <trans-unit id="83d7bcb20d79f9f405dc2a045c7b8717d8f1c228" translate="yes" xml:space="preserve">
          <source>In this section, we will learn how to make the &lt;code&gt;Clock&lt;/code&gt; component truly reusable and encapsulated. It will set up its own timer and update itself every second.</source>
          <target state="translated">このセクションでは、 &lt;code&gt;Clock&lt;/code&gt; コンポーネントを本当に再利用可能でカプセル化する方法を学びます。独自のタイマーを設定し、毎秒更新します。</target>
        </trans-unit>
        <trans-unit id="ce38739a991553b55a16fa00b7561acd9e3c69cd" translate="yes" xml:space="preserve">
          <source>In this section, we will show how to add a React component to an existing HTML page. You can follow along with your own website, or create an empty HTML file to practice.</source>
          <target state="translated">ここでは、既存のHTMLページにReactコンポーネントを追加する方法を紹介します。ご自身のWebサイトに沿って行っても良いですし、空のHTMLファイルを作成して練習しても良いでしょう。</target>
        </trans-unit>
        <trans-unit id="c457ca26e31df4ff72bf75e4781f7e68170aaedf" translate="yes" xml:space="preserve">
          <source>In those rare cases where you need to apply a HOC dynamically, you can also do it inside a component&amp;rsquo;s lifecycle methods or its constructor.</source>
          <target state="translated">HOCを動的に適用する必要があるまれなケースでは、コンポーネントのライフサイクルメソッドまたはそのコンストラクター内で行うこともできます。</target>
        </trans-unit>
        <trans-unit id="98e74adf3229ab63477c62be5d7146a7e849046e" translate="yes" xml:space="preserve">
          <source>Inclusive Components</source>
          <target state="translated">インクルーシブコンポーネント</target>
        </trans-unit>
        <trans-unit id="1042f8600a94d974b83e4d369aaa4b17edb453b8" translate="yes" xml:space="preserve">
          <source>Indicate the human language of page texts as screen reader software uses this to select the correct voice settings:</source>
          <target state="translated">スクリーン・リーダー・ソフトウェアがこれを使用して正しい音声設定を選択するため、ページ・テキストの人間の言語を表示します。</target>
        </trans-unit>
        <trans-unit id="49a578fd2622c2582fc0bfccfa222e7fbdccd773" translate="yes" xml:space="preserve">
          <source>Initializing &lt;a href=&quot;state-and-lifecycle&quot;&gt;local state&lt;/a&gt; by assigning an object to &lt;code&gt;this.state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this.state&lt;/code&gt; にオブジェクトを割り当てることによる&lt;a href=&quot;state-and-lifecycle&quot;&gt;ローカル状態の&lt;/a&gt;初期化。</target>
        </trans-unit>
        <trans-unit id="308f934b533308c752b10e77267068798d66f567" translate="yes" xml:space="preserve">
          <source>Inline If with Logical &amp;amp;&amp;amp; Operator</source>
          <target state="translated">論理&amp;amp;&amp;amp;演算子を使用したインラインif</target>
        </trans-unit>
        <trans-unit id="bb9001f5844d8678a32c2945ed8a6fb7c63e0e2f" translate="yes" xml:space="preserve">
          <source>Inline If-Else with Conditional Operator</source>
          <target state="translated">条件演算子を使ったインラインIf-Else</target>
        </trans-unit>
        <trans-unit id="66528a87a38e1e59da8d23434a47ffa479d5a4ba" translate="yes" xml:space="preserve">
          <source>Inside a loop, it is common to want to pass an extra parameter to an event handler. For example, if &lt;code&gt;id&lt;/code&gt; is the row ID, either of the following would work:</source>
          <target state="translated">ループ内では、イベントハンドラーに追加のパラメーターを渡したい場合がよくあります。たとえば、 &lt;code&gt;id&lt;/code&gt; が行IDの場合、次のいずれかが機能します。</target>
        </trans-unit>
        <trans-unit id="4304c63954bdc246b29ab78b7a7b6fb0356bca4f" translate="yes" xml:space="preserve">
          <source>Inside the listener, call &lt;code&gt;setState&lt;/code&gt; whenever the data source changes.</source>
          <target state="translated">リスナー内では、データソースが変更されるたびに &lt;code&gt;setState&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1da0532bc1d42056af8f38805b51309a604715c0" translate="yes" xml:space="preserve">
          <source>Inside these methods, the &lt;code&gt;Calculator&lt;/code&gt; component asks React to re-render itself by calling &lt;code&gt;this.setState()&lt;/code&gt; with the new input value and the current scale of the input we just edited.</source>
          <target state="translated">これらのメソッド内で、 &lt;code&gt;Calculator&lt;/code&gt; コンポーネントはReactに、新しい入力値と編集した入力の現在のスケールを使用して &lt;code&gt;this.setState()&lt;/code&gt; を呼び出すことにより、自分自身を再レンダリングするように要求します。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">インスタンスのプロパティ</target>
        </trans-unit>
        <trans-unit id="68b9166fcdb7337cee3b47f14be3169cc82acd61" translate="yes" xml:space="preserve">
          <source>Instead of artificially separating &lt;em&gt;technologies&lt;/em&gt; by putting markup and logic in separate files, React &lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separates &lt;em&gt;concerns&lt;/em&gt;&lt;/a&gt; with loosely coupled units called &amp;ldquo;components&amp;rdquo; that contain both. We will come back to components in a &lt;a href=&quot;components-and-props&quot;&gt;further section&lt;/a&gt;, but if you&amp;rsquo;re not yet comfortable putting markup in JS, &lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;this talk&lt;/a&gt; might convince you otherwise.</source>
          <target state="translated">代わりに、人為的に分離すること&lt;em&gt;の技術を&lt;/em&gt;別々のファイルにマークアップとロジックを置くことによって、リアクト&lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;セパレートの&lt;em&gt;懸念&lt;/em&gt;&lt;/a&gt;の両方を含む「コンポーネント」と呼ばれる疎結合ユニットとを。後の&lt;a href=&quot;components-and-props&quot;&gt;セクション&lt;/a&gt;でコンポーネントに戻りますが、JSでマークアップを配置するのにまだ慣れていない場合は、&lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;この話で&lt;/a&gt;他の方法がわかるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d025bac2dca752df204440cbc1297998e47df835" translate="yes" xml:space="preserve">
          <source>Instead of calling real APIs in all your tests, you can mock requests with dummy data. Mocking data fetching with &amp;ldquo;fake&amp;rdquo; data prevents flaky tests due to an unavailable backend, and makes them run faster. Note: you may still want to run a subset of tests using an &lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;&amp;ldquo;end-to-end&amp;rdquo;&lt;/a&gt; framework that tells whether the whole app is working together.</source>
          <target state="translated">すべてのテストで実際のAPIを呼び出す代わりに、ダミーデータでリクエストを模擬できます。「偽の」データを使用してデータフェッチをモックすると、バックエンドが利用できないために不安定なテストが行​​われなくなり、テストが高速になります。注：アプリ全体が連携しているかどうかを示す&lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;「エンドツーエンド」&lt;/a&gt;フレームワークを使用して、テストのサブセットを実行することもできます。</target>
        </trans-unit>
        <trans-unit id="df48b0f4d5bf5819b9914fd6531ebe1dc8a79973" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;useTransition&lt;/code&gt; in every other component, we can build it into our design system.</source>
          <target state="translated">他のすべてのコンポーネントで &lt;code&gt;useTransition&lt;/code&gt; を実行する代わりに、それを設計システムに組み込むことができます。</target>
        </trans-unit>
        <trans-unit id="8aded08fa023761e3f1e6e5311a0cc3ddf79baf0" translate="yes" xml:space="preserve">
          <source>Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:</source>
          <target state="translated">突然変異の代わりに、HOCは、入力コンポーネントをコンテナコンポーネントで包むことで、コンポジションを使用するべきです。</target>
        </trans-unit>
        <trans-unit id="5cf9d7c83880386192ebfbb360c2c6812d8bcf20" translate="yes" xml:space="preserve">
          <source>Instead of passing a &lt;code&gt;ref&lt;/code&gt; attribute created by &lt;code&gt;createRef()&lt;/code&gt;, you pass a function. The function receives the React component instance or HTML DOM element as its argument, which can be stored and accessed elsewhere.</source>
          <target state="translated">&lt;code&gt;createRef()&lt;/code&gt; で作成された &lt;code&gt;ref&lt;/code&gt; 属性を渡す代わりに、関数を渡します。この関数は、引数としてReactコンポーネントインスタンスまたはHTML DOM要素を受け取ります。これらの引数は、他の場所に保存およびアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8c04ebdd8624a1412a2c00e3ee3be737187bc902" translate="yes" xml:space="preserve">
          <source>Instead of showing a spinner, can we add a visual effect like &amp;ldquo;greying out&amp;rdquo; the current screen?</source>
          <target state="translated">スピナーを表示する代わりに、現在の画面を「グレー表示」するような視覚効果を追加できますか？</target>
        </trans-unit>
        <trans-unit id="54c51eb3d5154be37011a4c79e90fdae3d688bfd" translate="yes" xml:space="preserve">
          <source>Instead, &lt;em&gt;pass the function itself&lt;/em&gt; (without parens):</source>
          <target state="translated">代わりに、（括弧なしで）&lt;em&gt;関数自体を渡します&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6cf33354387d8bc0b95b73e1b637b872d08038c4" translate="yes" xml:space="preserve">
          <source>Instead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.</source>
          <target state="translated">代わりに、結果として生じるコンポーネントが一度だけ作成されるように、コンポーネント定義の外側に HOC を適用します。そうすれば、その同一性はレンダー間で一貫したものになります。いずれにしても、通常はこれが望ましいことです。</target>
        </trans-unit>
        <trans-unit id="14487f72778797d41aa4fbaf38ed77b989f65799" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;setState()&lt;/code&gt;:</source>
          <target state="translated">代わりに、 &lt;code&gt;setState()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="441f654229a4276797437835009f1f108efbc02d" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;useEffect&lt;/code&gt;. The function passed to &lt;code&gt;useEffect&lt;/code&gt; will run after the render is committed to the screen. Think of effects as an escape hatch from React&amp;rsquo;s purely functional world into the imperative world.</source>
          <target state="translated">代わりに、 &lt;code&gt;useEffect&lt;/code&gt; を使用してください。レンダリングが画面にコミットされた後、 &lt;code&gt;useEffect&lt;/code&gt; に渡された関数が実行されます。エフェクトは、Reactの純粋に機能的な世界から命令的な世界への脱出ハッチと考えてください。</target>
        </trans-unit>
        <trans-unit id="6e5c222edd3cc915db386166adcd08d3c4524ced" translate="yes" xml:space="preserve">
          <source>Instead, we release new features in minor versions. That means that minor releases are often more interesting and compelling than majors, despite their unassuming name.</source>
          <target state="translated">その代わりに、私たちは新しい機能をマイナーバージョンでリリースしています。つまり、地味な名前にもかかわらず、マイナーリリースの方がメジャーよりも面白く、説得力のあるものになることが多いのです。</target>
        </trans-unit>
        <trans-unit id="9cad89ab27a31a43bc8bcabb4f1530a63711b236" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;d like to share this logic between &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt;.</source>
          <target state="translated">代わりに、このロジックを &lt;code&gt;FriendStatus&lt;/code&gt; と &lt;code&gt;FriendListItem&lt;/code&gt; で共有します。</target>
        </trans-unit>
        <trans-unit id="1bc56bd7b51ec191a2b44a72405da8bdc2c8e271" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll look at Suspense as a logical next step in a sequence of approaches:</source>
          <target state="translated">代わりに、一連のアプローチの論理的な次のステップとしてサスペンスを検討します。</target>
        </trans-unit>
        <trans-unit id="56e78cabfede8d071dad68a99417a1db55165ae4" translate="yes" xml:space="preserve">
          <source>Integrating with DOM Manipulation Plugins</source>
          <target state="translated">DOM 操作プラグインとの統合</target>
        </trans-unit>
        <trans-unit id="fabcdcb5781cef22218fde185dcc3275b3caf232" translate="yes" xml:space="preserve">
          <source>Integrating with Model Layers</source>
          <target state="translated">モデルレイヤーとの統合</target>
        </trans-unit>
        <trans-unit id="2abfc3b773acf5210e59c6612eeb838ec30c6daf" translate="yes" xml:space="preserve">
          <source>Integrating with Other Libraries</source>
          <target state="translated">他のライブラリとの統合</target>
        </trans-unit>
        <trans-unit id="323ce191323fe812d9b2285405712a7540e602ee" translate="yes" xml:space="preserve">
          <source>Integrating with Other View Libraries</source>
          <target state="translated">他のビューライブラリとの統合</target>
        </trans-unit>
        <trans-unit id="a7ead22e923dd75533f31fb755b0096e8335cf4b" translate="yes" xml:space="preserve">
          <source>Integrating with jQuery Chosen Plugin</source>
          <target state="translated">jQueryとの連携 選ばれたプラグイン</target>
        </trans-unit>
        <trans-unit id="31f07fcd6fa5d6cf3bce211abaa7f9938b9f8b59" translate="yes" xml:space="preserve">
          <source>Integrating with third-party DOM libraries.</source>
          <target state="translated">サードパーティの DOM ライブラリとの統合。</target>
        </trans-unit>
        <trans-unit id="d188e3da39485e86c68a2e47954789d012f3e98a" translate="yes" xml:space="preserve">
          <source>Intentional Loading Sequences</source>
          <target state="translated">意図的なローディングシーケンス</target>
        </trans-unit>
        <trans-unit id="458622e11438e28a4579aeaa119e2f6a90af7730" translate="yes" xml:space="preserve">
          <source>Interactions can be used to identify the cause of an update, although the API for tracing them is still experimental.</source>
          <target state="translated">相互作用は、更新の原因を特定するために使用することができますが、それらをトレースするためのAPIはまだ実験的なものです。</target>
        </trans-unit>
        <trans-unit id="6896564dcbd1c525b78f98182de42c4bb2b09515" translate="yes" xml:space="preserve">
          <source>Internally, React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. For many applications, using React will lead to a fast user interface without doing much work to specifically optimize for performance. Nevertheless, there are several ways you can speed up your React application.</source>
          <target state="translated">内部的には、Reactはいくつかの巧妙なテクニックを使って、UIの更新に必要なコストのかかるDOM操作の数を最小限に抑えています。多くのアプリケーションでは、Reactを使用することで、特にパフォーマンスを最適化するために多くの作業をしなくても、高速なユーザーインターフェースを実現することができます。それでも、Reactアプリケーションを高速化する方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="78abc071449ad0da13e4d5e5a3f22e08fc793563" translate="yes" xml:space="preserve">
          <source>Interruptible Prerendering</source>
          <target state="translated">割り込み可能なプリレンダリング</target>
        </trans-unit>
        <trans-unit id="5bdb65efee969d707c5e1bc2b4a881568f89c4af" translate="yes" xml:space="preserve">
          <source>Interruptible Rendering</source>
          <target state="translated">割り込み可能なレンダリング</target>
        </trans-unit>
        <trans-unit id="fe91e5b2febdee26a910e78fb467ec00cef2cc7f" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode</source>
          <target state="translated">コンカレントモードの導入</target>
        </trans-unit>
        <trans-unit id="8d1fa1c8913451a1f429075bf69c1c706857274d" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode (Experimental)</source>
          <target state="translated">コンカレントモードの導入(実験</target>
        </trans-unit>
        <trans-unit id="2c358e3ea80007355c4cebac6d98e29b8a15fd58" translate="yes" xml:space="preserve">
          <source>Introducing Error Boundaries</source>
          <target state="translated">エラー境界の導入</target>
        </trans-unit>
        <trans-unit id="6752670ac4fd3d43c072341f57aeec0c7e6fa7d6" translate="yes" xml:space="preserve">
          <source>Introducing Hooks</source>
          <target state="translated">フックの紹介</target>
        </trans-unit>
        <trans-unit id="99fc0e820b4798682e759dbf88cc8628f74605fc" translate="yes" xml:space="preserve">
          <source>Introducing JSX</source>
          <target state="translated">JSXの紹介</target>
        </trans-unit>
        <trans-unit id="f9c770701ef9646b1634d74252668c51159f3855" translate="yes" xml:space="preserve">
          <source>Invokes a function on every immediate child contained within &lt;code&gt;children&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; set to &lt;code&gt;thisArg&lt;/code&gt;. If &lt;code&gt;children&lt;/code&gt; is an array it will be traversed and the function will be called for each child in the array. If children is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, this method will return &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; rather than an array.</source>
          <target state="translated">内に含まれるすべての直接の子の機能を呼び出します &lt;code&gt;children&lt;/code&gt; を持つ &lt;code&gt;this&lt;/code&gt; にセット &lt;code&gt;thisArg&lt;/code&gt; 。 &lt;code&gt;children&lt;/code&gt; が配列の場合、それがトラバースされ、関数は配列内の子ごとに呼び出されます。childrenが &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; の場合、このメソッドは配列ではなく &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="19019a267c68ec0d9a87bbfe53368307773f4e69" translate="yes" xml:space="preserve">
          <source>Is it OK to use arrow functions in render methods?</source>
          <target state="translated">レンダーメソッドで矢印関数を使用しても大丈夫ですか?</target>
        </trans-unit>
        <trans-unit id="b94bd0fbbd4ff5757505741937dacab45d2007bf" translate="yes" xml:space="preserve">
          <source>Is it passed in from a parent via props? If so, it probably isn&amp;rsquo;t state.</source>
          <target state="translated">親から小道具を介して渡されますか？もしそうなら、それはおそらく状態ではありません。</target>
        </trans-unit>
        <trans-unit id="b12fb0c98d31f06f2e894073d26a29b446b6105a" translate="yes" xml:space="preserve">
          <source>Is it safe to omit functions from the list of dependencies?</source>
          <target state="translated">依存関係のリストから関数を省略しても大丈夫ですか?</target>
        </trans-unit>
        <trans-unit id="36e2fa776e8e49d37a8c66174c7a287fbd5c8891" translate="yes" xml:space="preserve">
          <source>Is the Shadow DOM the same as the Virtual DOM?</source>
          <target state="translated">Shadow DOM は Virtual DOM と同じですか?</target>
        </trans-unit>
        <trans-unit id="118a7d245e14f3d46907f813b32d6d32103aa8e9" translate="yes" xml:space="preserve">
          <source>Is there a recommended way to structure React projects?</source>
          <target state="translated">Reactプロジェクトを構成するための推奨される方法はありますか?</target>
        </trans-unit>
        <trans-unit id="431584afff8cf3078b613772134b8cf66a20ffd7" translate="yes" xml:space="preserve">
          <source>Is there something like forceUpdate?</source>
          <target state="translated">forceUpdateのようなものはありますか?</target>
        </trans-unit>
        <trans-unit id="c240e644bcf66edddc303b13a6145795d52277ac" translate="yes" xml:space="preserve">
          <source>Is there something like instance variables?</source>
          <target state="translated">インスタンス変数のようなものがあるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="615079284bccc262002fb9d64da4565ad0ff149a" translate="yes" xml:space="preserve">
          <source>It accepts &lt;code&gt;author&lt;/code&gt; (an object), &lt;code&gt;text&lt;/code&gt; (a string), and &lt;code&gt;date&lt;/code&gt; (a date) as props, and describes a comment on a social media website.</source>
          <target state="translated">&lt;code&gt;author&lt;/code&gt; （オブジェクト）、 &lt;code&gt;text&lt;/code&gt; （文字列）、 &lt;code&gt;date&lt;/code&gt; （日付）を小道具として受け入れ、ソーシャルメディアWebサイトでのコメントを記述します。</target>
        </trans-unit>
        <trans-unit id="fe1bc6eb63b54ec080a5b630f4c12685f9a1f7ff" translate="yes" xml:space="preserve">
          <source>It all begins with running one command in your terminal.</source>
          <target state="translated">すべては、ターミナルで1つのコマンドを実行することから始まります。</target>
        </trans-unit>
        <trans-unit id="c3cb8127bb9bd6695f9f71a7f9270c5ec20060df" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;ReactDOM.render()&lt;/code&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">これは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt; &lt;code&gt;setInterval()&lt;/code&gt; &lt;/a&gt;コールバックから &lt;code&gt;ReactDOM.render()&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="2cef424d8853229927def0460dc79c6c0ba401d9" translate="yes" xml:space="preserve">
          <source>It can also be used for larger expressions although it is less obvious what&amp;rsquo;s going on:</source>
          <target state="translated">何が起こっているのかは明らかではありませんが、より大きな式にも使用できます。</target>
        </trans-unit>
        <trans-unit id="0cbe1ab611653ca85961be292443488b8a02544f" translate="yes" xml:space="preserve">
          <source>It can be tedious to manually calculate the proper color combinations for all cases in your website so instead, you can &lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;calculate an entire accessible color palette with Colorable&lt;/a&gt;.</source>
          <target state="translated">Webサイトのすべてのケースで適切な色の組み合わせを手動で計算するのは面倒なので、代わりに&lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;Colorableを使用してアクセス可能なカラーパレット全体&lt;/a&gt;を計算できます。</target>
        </trans-unit>
        <trans-unit id="d62fd02389ef9525bb5984bc2a6e5af4ca327920" translate="yes" xml:space="preserve">
          <source>It can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled components&lt;/a&gt;, an alternative technique for implementing input forms.</source>
          <target state="translated">データを変更し、Reactコンポーネントを介してすべての入力状態をパイプするすべての方法に対してイベントハンドラーを記述する必要があるため、制御されたコンポーネントを使用するのは面倒な場合があります。これは、既存のコードベースをReactに変換する場合、またはReactアプリケーションを非Reactライブラリと統合する場合に特に煩わしくなります。このような状況では、&lt;a href=&quot;uncontrolled-components&quot;&gt;制御&lt;/a&gt;されていないコンポーネントをチェックアウトすることもできます。これは、入力フォームを実装するための代替手法です。</target>
        </trans-unit>
        <trans-unit id="2005e7f27cdc72de843371aaff7b32477d8c91bf" translate="yes" xml:space="preserve">
          <source>It conceptually makes sense for the filter text and checked value to live in &lt;code&gt;FilterableProductTable&lt;/code&gt;</source>
          <target state="translated">フィルターテキストとチェックされた値が &lt;code&gt;FilterableProductTable&lt;/code&gt; に存在することは概念的に意味があります</target>
        </trans-unit>
        <trans-unit id="688f0ab18438d6d367169c900008f7481be7690d" translate="yes" xml:space="preserve">
          <source>It displays &amp;ldquo;Hello, world&amp;rdquo; on the page.</source>
          <target state="translated">ページに「Hello、world」と表示されます。</target>
        </trans-unit>
        <trans-unit id="52ab860d9c544904ffaab788e02b64e8286beee6" translate="yes" xml:space="preserve">
          <source>It displays a heading saying &amp;ldquo;Hello, world!&amp;rdquo; on the page.</source>
          <target state="translated">「Hello、world！」という見出しが表示されます ページ上。</target>
        </trans-unit>
        <trans-unit id="e82647fae753dc8b035e66a8857ffb17ac2da33f" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t suffer from this bug. (But we also didn&amp;rsquo;t make any changes to it.)</source>
          <target state="translated">このバグの影響は受けません。（ただし、変更も加えていません。）</target>
        </trans-unit>
        <trans-unit id="602a6efa84948afcddd9d1b66dd5be71479d7a38" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;only&lt;/strong&gt; safe to omit a function from the dependency list if nothing in it (or the functions called by it) references props, state, or values derived from them. This example has a bug:</source>
          <target state="translated">ある&lt;strong&gt;だけ&lt;/strong&gt;、その中には何も（あるいはそれによって呼び出される関数）場合、依存関係のリストから機能を省略する参照の小道具、状態、またはそれらに由来する値が安全。この例にはバグがあります：</target>
        </trans-unit>
        <trans-unit id="6ead55f0f98915b5c6f13c05726f2286aab42a96" translate="yes" xml:space="preserve">
          <source>It is an early time for Hooks, and some third-party libraries might not be compatible with Hooks at the moment.</source>
          <target state="translated">Hooksにはまだ早い時期で、サードパーティ製のライブラリの中には、今のところHooksと互換性がないものもあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="50466c950e08c88b69e598ab61d92c2dc031d70e" translate="yes" xml:space="preserve">
          <source>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</source>
          <target state="translated">JSXと呼ばれるもので、JavaScriptの構文拡張です。UIがどのように見えるべきかを記述するためにReactと一緒に使うことをお勧めします。JSXというとテンプレート言語を思い浮かべるかもしれませんが、JavaScriptのフルパワーを備えています。</target>
        </trans-unit>
        <trans-unit id="92466150db2416a73798d13e0245efd07871c27a" translate="yes" xml:space="preserve">
          <source>It is common for CSS classes to depend on the component props or state:</source>
          <target state="translated">CSSクラスがコンポーネントのpropsや状態に依存するのはよくあることです。</target>
        </trans-unit>
        <trans-unit id="7e283c36c21325ef64876afd9194c0a0cb70a383" translate="yes" xml:space="preserve">
          <source>It is documented in our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting guide&lt;/a&gt;. Note that &lt;code&gt;lazy&lt;/code&gt; components can be deep inside the &lt;code&gt;Suspense&lt;/code&gt; tree &amp;mdash; it doesn&amp;rsquo;t have to wrap every one of them. The best practice is to place &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; where you want to see a loading indicator, but to use &lt;code&gt;lazy()&lt;/code&gt; wherever you want to do code splitting.</source>
          <target state="translated">&lt;a href=&quot;code-splitting#reactlazy&quot;&gt;コード分​​割ガイドに&lt;/a&gt;記載されています。 &lt;code&gt;lazy&lt;/code&gt; コンポーネントは &lt;code&gt;Suspense&lt;/code&gt; ツリーの奥深くにある可能性があることに注意してください。コンポーネントのすべてをラップする必要はありません。ベストプラクティスは、 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; をローディングインジケーターを表示する場所に配置することですが、コード分割を実行する場所には必ず &lt;code&gt;lazy()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f9b84f156dc2b1e8053f6383bcb338d839775393" translate="yes" xml:space="preserve">
          <source>It is equivalent to this ES5 code:</source>
          <target state="translated">このES5のコードに相当します。</target>
        </trans-unit>
        <trans-unit id="e8b287ce575a54f80be869742a5c4a51c76fe13e" translate="yes" xml:space="preserve">
          <source>It is expected that you use the development mode when working on your app, and the production mode when deploying your app to the users.</source>
          <target state="translated">アプリの作業時には開発モードを、ユーザーにアプリをデプロイする際には本番モードを使用することが想定されています。</target>
        </trans-unit>
        <trans-unit id="c952a73f20c5f13e3de4b9d7ef50fbb5a61fc052" translate="yes" xml:space="preserve">
          <source>It is important that we also call &lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; in the &lt;code&gt;remove&lt;/code&gt; method so that React unregisters event handlers and other resources associated with the component tree when it is detached.</source>
          <target state="translated">&lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; を &lt;code&gt;remove&lt;/code&gt; メソッドで呼び出すことも重要です。これにより、コンポーネントツリーがデタッチされたときに、Reactがコンポーネントハンドラーに関連付けられたイベントハンドラーやその他のリソースの登録を解除します。</target>
        </trans-unit>
        <trans-unit id="32d368243a184c2b8d827bcbfe71e38225d8ed76" translate="yes" xml:space="preserve">
          <source>It is important to remember that the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same. Just to be clear, rerender in this context means calling &lt;code&gt;render&lt;/code&gt; for all components, it doesn&amp;rsquo;t mean React will unmount and remount them. It will only apply the differences following the rules stated in the previous sections.</source>
          <target state="translated">調整アルゴリズムは実装の詳細であることを覚えておくことは重要です。Reactはすべてのアクションでアプリ全体を再レンダリングできます。最終結果は同じになります。明確に &lt;code&gt;render&lt;/code&gt; ために、このコンテキストでの再レンダリングとは、すべてのコンポーネントに対してレンダリングを呼び出すことを意味します。それは、Reactがそれらのコンポーネントをアンマウントして再マウントすることを意味するものではありません。これは、前のセクションで説明されているルールに従った違いのみを適用します。</target>
        </trans-unit>
        <trans-unit id="061882208caaee20f8d6caf81dd052b896705df2" translate="yes" xml:space="preserve">
          <source>It is often necessary to update the context from a component that is nested somewhere deeply in the component tree. In this case you can pass a function down through the context to allow consumers to update the context:</source>
          <target state="translated">コンポーネントツリーのどこか深いところにあるネストしたコンポーネントからコンテキストを更新する必要があることがよくあります。この場合、コンテキストを介して関数を渡すことで、 コンシューマがコンテキストを更新できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="68f2025036d719ebb13936746e156dcb2e46aebc" translate="yes" xml:space="preserve">
          <source>It is safe to embed user input in JSX:</source>
          <target state="translated">JSXにユーザー入力を埋め込んでも大丈夫です。</target>
        </trans-unit>
        <trans-unit id="aa4e4c8c699f839e3d4430e49f56a9d08895180e" translate="yes" xml:space="preserve">
          <source>It lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:</source>
          <target state="translated">これにより、レデューサの外で初期状態を計算するロジックを抽出することができます。これは、アクションに反応して後から状態をリセットするのにも便利です。</target>
        </trans-unit>
        <trans-unit id="534a38fabcd6aaf35f04bf09e44ca89301bf0ea1" translate="yes" xml:space="preserve">
          <source>It might feel redundant to pass down the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; props through many levels if in the end only the &lt;code&gt;Avatar&lt;/code&gt; component really needs it. It&amp;rsquo;s also annoying that whenever the &lt;code&gt;Avatar&lt;/code&gt; component needs more props from the top, you have to add them at all the intermediate levels too.</source>
          <target state="translated">最終的に &lt;code&gt;Avatar&lt;/code&gt; コンポーネントだけが本当にそれを必要とする場合、 &lt;code&gt;user&lt;/code&gt; と &lt;code&gt;avatarSize&lt;/code&gt; の小道具を多くのレベルで渡すことは冗長に感じるかもしれません。また、 &lt;code&gt;Avatar&lt;/code&gt; コンポーネントが上から追加の小道具を必要とするときはいつでも、すべての中間レベルでもそれらを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="50fb2495198065234962cb4b4d0c32c48a17f7f2" translate="yes" xml:space="preserve">
          <source>It returns an empty string on an invalid &lt;code&gt;temperature&lt;/code&gt;, and it keeps the output rounded to the third decimal place:</source>
          <target state="translated">無効な &lt;code&gt;temperature&lt;/code&gt; では空の文字列を返し、出力を小数点以下第3位に四捨五入します。</target>
        </trans-unit>
        <trans-unit id="e9057e6a7d66d1d7c47dc528ed3b3b130a69063f" translate="yes" xml:space="preserve">
          <source>It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6 on your machine. To create a project, run:</source>
          <target state="translated">最新のJavaScript機能を使用できるように開発環境をセットアップし、優れた開発者エクスペリエンスを提供し、アプリを本番用に最適化します。マシンにNode&amp;gt; = 8.10およびnpm&amp;gt; = 5.6が必要です。プロジェクトを作成するには、次を実行します。</target>
        </trans-unit>
        <trans-unit id="706a32880b71586a8d7aa0ac7d5f1463de4cb7ba" translate="yes" xml:space="preserve">
          <source>It takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether our friend is online.</source>
          <target state="translated">引数として &lt;code&gt;friendID&lt;/code&gt; を取り、友人がオンラインかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="3161055d73426680e8d35bc1e7cbbe8e4104358e" translate="yes" xml:space="preserve">
          <source>It took us only seven lines of code to add this transition:</source>
          <target state="translated">このトランジションを追加するのにかかったコードはわずか7行でした。</target>
        </trans-unit>
        <trans-unit id="45e77ef569a1f7d7c48e0e05eba962af9f6767c1" translate="yes" xml:space="preserve">
          <source>It will render either &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; depending on its current state. It will also render a &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; from the previous example:</source>
          <target state="translated">現在の状態に応じて、 &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; のいずれかをレンダリングします。また、前の例の &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="2155bb73f8bf6451916989b5cbacb97df229da2a" translate="yes" xml:space="preserve">
          <source>It will use &lt;code&gt;this.setState()&lt;/code&gt; to schedule updates to the component local state:</source>
          <target state="translated">&lt;code&gt;this.setState()&lt;/code&gt; を使用して、コンポーネントのローカル状態の更新をスケジュールします。</target>
        </trans-unit>
        <trans-unit id="d02413defbcafdd99d3c520fd9d4aa148536aaf1" translate="yes" xml:space="preserve">
          <source>It works because in JavaScript, &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;expression&lt;/code&gt;, and &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">JavaScriptで、ので、それは動作します &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; 常にに評価 &lt;code&gt;expression&lt;/code&gt; 、および &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; 常にあると評価 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df1035dc615a18406c02f413ad0f4e40e484e2b1" translate="yes" xml:space="preserve">
          <source>It would catch both rendering errors &lt;em&gt;and&lt;/em&gt; errors from Suspense data fetching. We can have as many error boundaries as we like but it&amp;rsquo;s best to &lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;be intentional&lt;/a&gt; about their placement.</source>
          <target state="translated">レンダリングエラー&lt;em&gt;と&lt;/em&gt;サスペンスデータフェッチからのエラーの両方をキャッチします。エラー境界はいくつでも設定できますが、その配置については&lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;意図的に行う&lt;/a&gt;のが最善です。</target>
        </trans-unit>
        <trans-unit id="d53bef197f2d6ecda97fc0ca21c3fffc1a9ab88e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good idea to get to know React first, before adding in additional libraries. You can build quite complex applications using only React.</source>
          <target state="translated">ライブラリを追加する前に、まずReactについて理解しておくことをお勧めします。Reactのみを使用して、非常に複雑なアプリケーションを構築できます。</target>
        </trans-unit>
        <trans-unit id="1069cd6014468c5f2a1a444828d18bfcd86ae157" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a result of several years of research and development, but it&amp;rsquo;s not finished. In the section on &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;adopting Concurrent Mode&lt;/a&gt;, we&amp;rsquo;ll describe how you can try it and what you can expect.</source>
          <target state="translated">数年にわたる研究開発の成果ですが、まだ完成していません。&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;並行モードの採用&lt;/a&gt;に関するセクションでは、それを試す方法と期待できることについて説明します。</target>
        </trans-unit>
        <trans-unit id="5b97c1e1db1289e7c4f51d01cbfaea288680830c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s difficult to remember which props or state are used by functions outside of the effect. This is why &lt;strong&gt;usually you&amp;rsquo;ll want to declare functions needed by an effect &lt;em&gt;inside&lt;/em&gt; of it.&lt;/strong&gt; Then it&amp;rsquo;s easy to see what values from the component scope that effect depends on:</source>
          <target state="translated">エフェクト以外の機能で使用されている小道具や状態を思い出すことは困難です。これが&lt;strong&gt;通常、&lt;em&gt;内部&lt;/em&gt;のエフェクトに必要な関数を宣言する必要&lt;/strong&gt;がある理由&lt;strong&gt;です&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;次に、コンポーネントスコープのどの値が影響するかを簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="12d523ee0a8b2e43fbd774373dabc117b68d15fc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s hard to reuse stateful logic between components</source>
          <target state="translated">コンポーネント間でステートフルなロジックを再利用するのは難しい</target>
        </trans-unit>
        <trans-unit id="e11305e8e0d8ed22ffeb90393f322ef30d355dd4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that just because the pattern is called &amp;ldquo;render props&amp;rdquo; you don&amp;rsquo;t &lt;em&gt;have to use a prop named &lt;code&gt;render&lt;/code&gt; to use this pattern&lt;/em&gt;. In fact, &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&lt;em&gt;any&lt;/em&gt; prop that is a function that a component uses to know what to render is technically a &amp;ldquo;render prop&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">パターンが「レンダープロップ」と呼ばれ&lt;em&gt;ているからと &lt;code&gt;render&lt;/code&gt; &lt;/em&gt;いっ&lt;em&gt;て、&lt;/em&gt;&lt;em&gt;このパターンを使用&lt;/em&gt;&lt;em&gt;するためにrender&lt;/em&gt;&lt;em&gt;という名前のプロップを使用する&lt;/em&gt;必要がないことを覚えておくことが重要です。実際には、&lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&lt;em&gt;任意の&lt;/em&gt;コンポーネントの用途はレンダリングするかを知ることの関数である小道具は技術的には「レンダリング小道具」です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abbcf3e467e64993c40145b58380cca00dde2358" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not a Hook because it doesn&amp;rsquo;t compose like Hooks do. &lt;code&gt;React.memo&lt;/code&gt; is equivalent to &lt;code&gt;PureComponent&lt;/code&gt;, but it only compares props. (You can also add a second argument to specify a custom comparison function that takes the old and new props. If it returns true, the update is skipped.)</source>
          <target state="translated">フックのように構成しないため、フックではありません。 &lt;code&gt;React.memo&lt;/code&gt; はPureComponentと同等 &lt;code&gt;PureComponent&lt;/code&gt; 、プロップを比較するだけです。（2番目の引数を追加して、新旧の小道具を受け取るカスタム比較関数を指定することもできます。それがtrueを返す場合、更新はスキップされます。）</target>
        </trans-unit>
        <trans-unit id="218c8c3fba795922b2f79061baba6ea0eea01f6d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that a minor release will not include new features. &lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;This is allowed by semver&lt;/a&gt;, which states &lt;strong&gt;&amp;rdquo;[a minor version] MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes.&amp;rdquo;&lt;/strong&gt;</source>
          <target state="translated">マイナーリリースに新機能が含まれない可能性があります。&lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;これはsemver&lt;/a&gt;で許可されています。これは&lt;strong&gt;、プライベートコード内に大幅な新機能または改善が導入された場合に、[[マイナーバージョン]が増加する可能性があることを示しています。パッチレベルの変更が含まれる場合があります。」&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ed922784aa3b9ce3ee3dfd000c51ce8f2ddc5c7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that in the future React will provide a &lt;code&gt;usePrevious&lt;/code&gt; Hook out of the box since it&amp;rsquo;s a relatively common use case.</source>
          <target state="translated">比較的一般的なユースケースであるため、将来的にReactが &lt;code&gt;usePrevious&lt;/code&gt; フックを提供する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4411f615cb9a34eac0782d89d41554e9d48dcddd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s typically better to make more specific assertions than to use snapshots. These kinds of tests include implementation details so they break easily, and teams can get desensitized to snapshot breakages. Selectively &lt;a href=&quot;#mocking-modules&quot;&gt;mocking some child components&lt;/a&gt; can help reduce the size of snapshots and keep them readable for the code review.</source>
          <target state="translated">通常、スナップショットを使用するよりも、より具体的なアサーションを作成する方が適切です。これらの種類のテストには実装の詳細が含まれているため、簡単に破損し、チームはスナップショットの破損に鈍感になる可能性があります。&lt;a href=&quot;#mocking-modules&quot;&gt;一部の子コンポーネントを&lt;/a&gt;選択的にモックすることで、スナップショットのサイズを削減し、コードレビューで読みやすく保つことができます。</target>
        </trans-unit>
        <trans-unit id="483a41989a3f28face460eaf57d7dae044787b9f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite others components updating), we can do this with trees that take too long to render.</source>
          <target state="translated">注目に値するのは、 &lt;code&gt;useDeferredValue&lt;/code&gt; がデータのフェッチに役立つ&lt;em&gt;だけで&lt;/em&gt;はないことです。また、高価なコンポーネントツリーが原因でインタラクション（入力の入力など）が遅くなる場合にも役立ちます。フェッチに時間がかかりすぎる値を「据え置き」できる（そして、他のコンポーネントが更新されているにもかかわらず古い値を表示できる）ように、レンダリングに時間がかかりすぎるツリーでこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="55b65216aa0540eaf6506a4435bb83e1e7f8f013" translate="yes" xml:space="preserve">
          <source>JAWS in Internet Explorer</source>
          <target state="translated">Internet ExplorerでのJAWS</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="1390ed0a23d1a0f6a989a72f7740422bce623820" translate="yes" xml:space="preserve">
          <source>JSX Children</source>
          <target state="translated">JSXの子供たち</target>
        </trans-unit>
        <trans-unit id="5a08e455cb80c9325d21ca392ead0811d7f7928f" translate="yes" xml:space="preserve">
          <source>JSX In Depth</source>
          <target state="translated">JSXインデプス</target>
        </trans-unit>
        <trans-unit id="d79f80b3f74dfa812404ff28047b6abd93ce00a8" translate="yes" xml:space="preserve">
          <source>JSX Prevents Injection Attacks</source>
          <target state="translated">JSXはインジェクション攻撃を防ぐ</target>
        </trans-unit>
        <trans-unit id="201092e5747855ff7f46489df7db6fec3735acac" translate="yes" xml:space="preserve">
          <source>JSX Represents Objects</source>
          <target state="translated">JSXはオブジェクトを表現する</target>
        </trans-unit>
        <trans-unit id="f821c0797aa66329cd5b6a52d7b985154fb5e626" translate="yes" xml:space="preserve">
          <source>JSX allows &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embedding any expression&lt;/a&gt; in curly braces so we could inline the &lt;code&gt;map()&lt;/code&gt; result:</source>
          <target state="translated">JSXでは、中かっこに&lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;任意の式&lt;/a&gt;を埋め込むことができるため、 &lt;code&gt;map()&lt;/code&gt; の結果をインライン化できます。</target>
        </trans-unit>
        <trans-unit id="f572ba8add6be836659fce1a76a91186f8683f81" translate="yes" xml:space="preserve">
          <source>JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to &lt;code&gt;React.createElement()&lt;/code&gt; calls which return plain JavaScript objects called &amp;ldquo;React elements&amp;rdquo;. To get a basic introduction to JSX &lt;a href=&quot;introducing-jsx&quot;&gt;see the docs here&lt;/a&gt; and find a more in-depth tutorial on JSX &lt;a href=&quot;jsx-in-depth&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">JSXはJavaScriptの構文拡張です。これはテンプレート言語に似ていますが、JavaScriptの全機能を備えています。JSXは、「React要素」と呼ばれるプレーンなJavaScriptオブジェクトを返す &lt;code&gt;React.createElement()&lt;/code&gt; 呼び出しにコンパイルされます。JSXの基本的な紹介を取得するに&lt;a href=&quot;introducing-jsx&quot;&gt;は、ここのドキュメントを参照し、&lt;/a&gt; JSXに関するより詳細なチュートリアルをここで見つけて&lt;a href=&quot;jsx-in-depth&quot;&gt;ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a6badf2480a79666ab2a50ef49c41eec53e3e92" translate="yes" xml:space="preserve">
          <source>JSX is an Expression Too</source>
          <target state="translated">JSXは式すぎる</target>
        </trans-unit>
        <trans-unit id="a7d41082c94e0ade95a8097ecf33e2cb44acdb09" translate="yes" xml:space="preserve">
          <source>JSX is not a requirement for using React. Using React without JSX is especially convenient when you don&amp;rsquo;t want to set up compilation in your build environment.</source>
          <target state="translated">JSXはReactを使用するための要件ではありません。JSXなしでReactを使用すると、ビルド環境でコンパイルを設定したくない場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="dd38b28ee1a9a309326f94891c1df14009e831fa" translate="yes" xml:space="preserve">
          <source>JSX produces React &amp;ldquo;elements&amp;rdquo;. We will explore rendering them to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;. Below, you can find the basics of JSX necessary to get you started.</source>
          <target state="translated">JSXはReactの「要素」を生成します。&lt;a href=&quot;rendering-elements&quot;&gt;次のセクション&lt;/a&gt;では、DOMへのレンダリングについて説明します。以下に、始めるために必要なJSXの基本を示します。</target>
        </trans-unit>
        <trans-unit id="e5c0788f2156485e43ec1aec3f13813b6ce0ec76" translate="yes" xml:space="preserve">
          <source>JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing:</source>
          <target state="translated">JSXは行頭と行末の空白を削除します。また、空白行も削除されます。タグに隣接する改行は削除され、文字列リテラルの途中で発生する改行は1つのスペースに凝縮されます。つまり、これらはすべて同じものにレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="e557a0ad7b8dd428002b075a12a339460bf81183" translate="yes" xml:space="preserve">
          <source>JSX tags may contain children:</source>
          <target state="translated">JSXタグには子が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="c88547a44d266cdafe70fec17001f13058415c5b" translate="yes" xml:space="preserve">
          <source>JavaScript Environment Requirements</source>
          <target state="translated">JavaScriptの環境要件</target>
        </trans-unit>
        <trans-unit id="191332a52bb73fc079e6c2be8fbab52a7b9b0c79" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Children</source>
          <target state="translated">子としての JavaScript 式</target>
        </trans-unit>
        <trans-unit id="f86b0b485fe227f9926cd86119e4d67d9db9cb41" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Props</source>
          <target state="translated">小道具としての JavaScript 式</target>
        </trans-unit>
        <trans-unit id="8262e0b313f4b908f2bfa1fa8c04c78e05342554" translate="yes" xml:space="preserve">
          <source>JavaScript Resources</source>
          <target state="translated">JavaScriptリソース</target>
        </trans-unit>
        <trans-unit id="3ab669d11c2053c3096b0ce975c409719b9ab1f3" translate="yes" xml:space="preserve">
          <source>JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates:</source>
          <target state="translated">JavaScript の式は、他のタイプの子と混合することができます。これは文字列テンプレートの代わりに便利なことが多いです。</target>
        </trans-unit>
        <trans-unit id="fdc6b5ae1ed04a526c0403c39f6d892a4884f28f" translate="yes" xml:space="preserve">
          <source>Jest is widely compatible with React projects, supporting features like mocked &lt;a href=&quot;#mocking-modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;#mocking-timers&quot;&gt;timers&lt;/a&gt;, and &lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt; support. &lt;strong&gt;If you use Create React App, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jest is already included out of the box&lt;/a&gt; with useful defaults.&lt;/strong&gt;</source>
          <target state="translated">JestはReactプロジェクトと幅広く互換性があり、モック&lt;a href=&quot;#mocking-modules&quot;&gt;モジュール&lt;/a&gt;や&lt;a href=&quot;#mocking-timers&quot;&gt;タイマー&lt;/a&gt;などの機能、および&lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; &lt;/a&gt;サポートをサポートしています。&lt;strong&gt;Create React Appを使用する場合、&lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jestはすでに&lt;/a&gt;デフォルトで便利な状態で含まれています。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrainsは、Reactコミュニティ専用のいくつかのツールを開発および保守しています&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;。Reactバインディング&lt;/a&gt;と&lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlinアプリ&lt;/a&gt;です。後者は、ビルド構成のないKotlinでReactアプリのビルドを開始するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="26f4f29dc54a0429c9c6356ba883190a57985b95" translate="yes" xml:space="preserve">
          <source>Just because it&amp;rsquo;s possible, doesn&amp;rsquo;t mean that it&amp;rsquo;s the best approach for React apps. We encourage you to use React components when you can. React components are easier to reuse in React applications, and often provide more control over their behavior and appearance.</source>
          <target state="translated">それが可能だからといって、それがReactアプリにとって最善のアプローチであるとは限りません。できる限りReactコンポーネントを使用することをお勧めします。Reactコンポーネントは、Reactアプリケーションでの再利用が容易で、多くの場合、それらの動作と外観をより細かく制御できます。</target>
        </trans-unit>
        <trans-unit id="59c6c9a90cc15a2b6bbb52187ffa7d5c291abb80" translate="yes" xml:space="preserve">
          <source>Just like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="translated">JavaScriptの場合と同様に、あなたとあなたのチームがより読みやすくすることに基づいて適切なスタイルを選択するのはあなた次第です。また、条件が複雑になりすぎた場合は&lt;a href=&quot;components-and-props#extracting-components&quot;&gt;、コンポーネント&lt;/a&gt;を抽出するのに適したタイミングかもしれません。</target>
        </trans-unit>
        <trans-unit id="e19fb11d1b21bc4e9e11220a38333f6f51bc6998" translate="yes" xml:space="preserve">
          <source>Just like in a real browser, jsdom lets us model user interactions; tests can dispatch events on DOM nodes, and then observe and assert on the side effects of these actions &lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="translated">実際のブラウザーと同じように、jsdomを使用してユーザーの対話をモデル化できます。テストでは、DOMノードでイベントをディスパッチし、これらのアクションの副作用を観察してアサートできます&lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;（例）&lt;/small&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04a953b2cc6af815cf1d538af4ea7e0cdd73a8c9" translate="yes" xml:space="preserve">
          <source>Just like with &lt;code&gt;useState&lt;/code&gt;, you can use more than a single effect in a component:</source>
          <target state="translated">&lt;code&gt;useState&lt;/code&gt; と同様に、コンポーネントで複数のエフェクトを使用できます。</target>
        </trans-unit>
        <trans-unit id="0417f986bcfb4e8e2b6c2b20736543a236a42518" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; is composable, like anything in React. For example, you can create a grid by putting several &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; rows inside a &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; は、Reactの他のコンポーネントと同じように構成可能であることを覚えておいてください。たとえば、 &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; テーブル内に複数の &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 行を配置することにより、グリッドを作成できます。</target>
        </trans-unit>
        <trans-unit id="07019d7742ef51cadec0c4168d9dbc4ff41a327c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;useRef&lt;/code&gt;&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; notify you when its content changes. Mutating the &lt;code&gt;.current&lt;/code&gt; property doesn&amp;rsquo;t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a &lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;callback ref&lt;/a&gt; instead.</source>
          <target state="translated">内容が変更されても、 &lt;code&gt;useRef&lt;/code&gt; &lt;em&gt;は&lt;/em&gt;通知&lt;em&gt;しない&lt;/em&gt;ことに注意&lt;em&gt;し&lt;/em&gt;てください。変異 &lt;code&gt;.current&lt;/code&gt; プロパティは、再レンダリングはありません。ReactがrefをDOMノードにアタッチまたはデタッチするときにコードを実行する場合は、代わりに&lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;コールバックref&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="2fa659e6371af8e34371298a054c6fa0b8e3f4e6" translate="yes" xml:space="preserve">
          <source>Keep scrolling down, and you&amp;rsquo;ll find the link to the &lt;a href=&quot;introducing-jsx&quot;&gt;next chapter of this guide&lt;/a&gt; right before the website footer.</source>
          <target state="translated">下にスクロールし続けると&lt;a href=&quot;introducing-jsx&quot;&gt;、このガイドの次の章&lt;/a&gt;へのリンクがWebサイトのフッターの直前に表示されます。</target>
        </trans-unit>
        <trans-unit id="4a277208935542103e33cce1ec94231bfcbe2812" translate="yes" xml:space="preserve">
          <source>Keep using &lt;code&gt;createReactClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;createReactClass&lt;/code&gt; を使い続けます。</target>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="translated">キーボードイベント</target>
        </trans-unit>
        <trans-unit id="a63562f9dc59d3d173ce1da297fea061eda935fe" translate="yes" xml:space="preserve">
          <source>Keyboard focus and focus outline</source>
          <target state="translated">キーボードのフォーカスとフォーカスの概要</target>
        </trans-unit>
        <trans-unit id="71a38cea4a8ef2893215c7068a770d00cbeee9f2" translate="yes" xml:space="preserve">
          <source>Keyboard focus refers to the current element in the DOM that is selected to accept input from the keyboard. We see it everywhere as a focus outline similar to that shown in the following image:</source>
          <target state="translated">キーボードフォーカスとは、キーボードからの入力を受け入れるために選択されている DOM 内の現在の要素を指します。次の画像に示すようなフォーカスのアウトラインとして、いたるところで目にすることができます。</target>
        </trans-unit>
        <trans-unit id="7ea41b7bfa6e4c0a74c593ca76797a28b26b665e" translate="yes" xml:space="preserve">
          <source>Keyed Fragments</source>
          <target state="translated">キー付きフラグメント</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="033fe9e03aa157b184cec9c5c36765ae681fc7ed" translate="yes" xml:space="preserve">
          <source>Keys Must Only Be Unique Among Siblings</source>
          <target state="translated">鍵は兄弟の中で唯一ユニークなものでなければならない</target>
        </trans-unit>
        <trans-unit id="58d08b1dcb85c35147a1b3441c0c392efd3a8241" translate="yes" xml:space="preserve">
          <source>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:</source>
          <target state="translated">キーは、どの項目が変更されたか、追加されたか、削除されたかをReactが識別するのに役立ちます。キーは配列内の要素に与えられ、要素に安定したアイデンティティを与える必要があります。</target>
        </trans-unit>
        <trans-unit id="c207367e515ac72a16c2932ecfa02b3376650bf0" translate="yes" xml:space="preserve">
          <source>Keys only make sense in the context of the surrounding array.</source>
          <target state="translated">キーは周囲の配列のコンテキストでのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="21b4e388c860748250255ac3aec6577a53bb08ca" translate="yes" xml:space="preserve">
          <source>Keys only need to be unique among sibling elements in the same array. They don&amp;rsquo;t need to be unique across the whole application or even a single component.</source>
          <target state="translated">キーは、同じ配列内の兄弟要素間でのみ一意である必要があります。アプリケーション全体または単一のコンポーネント全体で一意である必要はありません。</target>
        </trans-unit>
        <trans-unit id="f269f84d4b420a7eccc734c9f3e4bbe7ec1e654b" translate="yes" xml:space="preserve">
          <source>Keys serve as a hint to React but they don&amp;rsquo;t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:</source>
          <target state="translated">キーはReactのヒントになりますが、コンポーネントに渡されません。コンポーネントに同じ値が必要な場合は、別の名前の小道具として明示的に渡します。</target>
        </trans-unit>
        <trans-unit id="4eb803361f1db02c12313aa22ea43364fef308c9" translate="yes" xml:space="preserve">
          <source>Keys should be stable, predictable, and unique. Unstable keys (like those produced by &lt;code&gt;Math.random()&lt;/code&gt;) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.</source>
          <target state="translated">キーは安定していて、予測可能で、一意である必要があります。不安定なキー（ &lt;code&gt;Math.random()&lt;/code&gt; によって生成されるものなど）は、多くのコンポーネントインスタンスとDOMノードを不必要に再作成し、パフォーマンスの低下と子コンポーネントの状態の損失を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="46d2b02a27e73ea54e2ad8018f1f566c76419e35" translate="yes" xml:space="preserve">
          <source>Keys used within arrays should be unique among their siblings. However they don&amp;rsquo;t need to be globally unique. We can use the same keys when we produce two different arrays:</source>
          <target state="translated">配列内で使用されるキーは、兄弟間で一意である必要があります。ただし、グローバルに一意である必要はありません。2つの異なる配列を生成するときに、同じキーを使用できます。</target>
        </trans-unit>
        <trans-unit id="b950ddccc3180b1568a4677560f1be2e72ae0d05" translate="yes" xml:space="preserve">
          <source>Knowledge Level Assumptions</source>
          <target state="translated">知識レベルの仮定</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="087f43dec679500a381105d8177480d92e5bc6f7" translate="yes" xml:space="preserve">
          <source>Labeling</source>
          <target state="translated">Labeling</target>
        </trans-unit>
        <trans-unit id="86ade0000eab7713840cb80442178dbad165e1c7" translate="yes" xml:space="preserve">
          <source>Later, you write a component for subscribing to a single blog post, which follows a similar pattern:</source>
          <target state="translated">その後、似たようなパターンに沿って、1つのブログ記事を購読するためのコンポーネントを書きます。</target>
        </trans-unit>
        <trans-unit id="4e81f878f11e9186c40f41b370cbeff1223f6553" translate="yes" xml:space="preserve">
          <source>Latest Channel</source>
          <target state="translated">最新のチャンネル</target>
        </trans-unit>
        <trans-unit id="801295034f8f587a8731684b0829ce3fafe33d56" translate="yes" xml:space="preserve">
          <source>Latest is the channel used for stable React releases. It corresponds to the &lt;code&gt;latest&lt;/code&gt; tag on npm. It is the recommended channel for all React apps that are shipped to real users.</source>
          <target state="translated">最新は、安定したReactリリースに使用されるチャネルです。npm の &lt;code&gt;latest&lt;/code&gt; タグに対応しています。これは、実際のユーザーに出荷されるすべてのReactアプリに推奨されるチャネルです。</target>
        </trans-unit>
        <trans-unit id="09dea8b1934495cf50be92926eded5430df29f58" translate="yes" xml:space="preserve">
          <source>Lazy initial state</source>
          <target state="translated">怠惰な初期状態</target>
        </trans-unit>
        <trans-unit id="0aa93a4477a941d54e9e6489ff5a7fb43a5339e0" translate="yes" xml:space="preserve">
          <source>Lazy initialization</source>
          <target state="translated">怠惰な初期化</target>
        </trans-unit>
        <trans-unit id="e1c5a8ff2c0a4cee2266af52e69d8ea217bc6355" translate="yes" xml:space="preserve">
          <source>Learn Gatsby from &lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;its official guide&lt;/a&gt; and a &lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;gallery of starter kits&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;公式ガイド&lt;/a&gt;と&lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;スターターキットのギャラリー&lt;/a&gt;からギャツビーを学びましょう。</target>
        </trans-unit>
        <trans-unit id="378cbbf54cbb2e3f3bd201f02c1b946ec3601eba" translate="yes" xml:space="preserve">
          <source>Learn More</source>
          <target state="translated">詳細はこちら</target>
        </trans-unit>
        <trans-unit id="47738a476129c3a8cb6d980e52a9a75eb86f2183" translate="yes" xml:space="preserve">
          <source>Learn Next.js from &lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;its official guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;公式ガイド&lt;/a&gt;からNext.jsを学んでください。</target>
        </trans-unit>
        <trans-unit id="802c853c766c4a1fb751dfe0a5007088efb8fff9" translate="yes" xml:space="preserve">
          <source>Learn React</source>
          <target state="translated">リアクトを学ぶ</target>
        </trans-unit>
        <trans-unit id="6c1aff18b114655a3728004f5ddf84acf496ed61" translate="yes" xml:space="preserve">
          <source>Learn more about it at &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me/react-interaction-tracing&lt;/a&gt;</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me / react-interaction-tracingを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="74783fcd98611ef8c679d0b35c17456b50fdbdab" translate="yes" xml:space="preserve">
          <source>Learn more about setState</source>
          <target state="translated">setState の詳細はこちら</target>
        </trans-unit>
        <trans-unit id="3d9e1ea32612926012e0f27c2e2d3bc9d3504c65" translate="yes" xml:space="preserve">
          <source>Learn more about the new &lt;code&gt;createRef&lt;/code&gt; API here.</source>
          <target state="translated">新しい &lt;code&gt;createRef&lt;/code&gt; API について詳しくは、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="d12363dec3cec522658520bb14b574d2c38d4a9b" translate="yes" xml:space="preserve">
          <source>Legacy API</source>
          <target state="translated">レガシーAPI</target>
        </trans-unit>
        <trans-unit id="dde4f866b5827a3ecdb1b59f566920d28fc762d3" translate="yes" xml:space="preserve">
          <source>Legacy API: String Refs</source>
          <target state="translated">レガシー API。文字列参照</target>
        </trans-unit>
        <trans-unit id="e5b92b7804190333f8d5aa0581703f3b2664d74b" translate="yes" xml:space="preserve">
          <source>Legacy Context</source>
          <target state="translated">レガシーコンテキスト</target>
        </trans-unit>
        <trans-unit id="673ce3a3969d34565237049f3b8553b6bff614da" translate="yes" xml:space="preserve">
          <source>Legacy Lifecycle Methods</source>
          <target state="translated">レガシーライフサイクル手法</target>
        </trans-unit>
        <trans-unit id="0ebe4f64c19e892054a7737b95e642e4103d4505" translate="yes" xml:space="preserve">
          <source>Legacy Mode</source>
          <target state="translated">レガシーモード</target>
        </trans-unit>
        <trans-unit id="e41df52dcff2d5fb3f135df9c40c44c902c43f73" translate="yes" xml:space="preserve">
          <source>Lessons Learned</source>
          <target state="translated">学んだこと</target>
        </trans-unit>
        <trans-unit id="59538c378635dc8630feb1d884595472a4a714c5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s Get Started!</source>
          <target state="translated">始めましょう！</target>
        </trans-unit>
        <trans-unit id="83ad68c13a4560eb3e6da14fe3991a29f25a12c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assign a &lt;code&gt;key&lt;/code&gt; to our list items inside &lt;code&gt;numbers.map()&lt;/code&gt; and fix the missing key issue.</source>
          <target state="translated">&lt;code&gt;numbers.map()&lt;/code&gt; 内のリスト項目に &lt;code&gt;key&lt;/code&gt; を割り当て、欠落しているキーの問題を修正しましょう。</target>
        </trans-unit>
        <trans-unit id="62e35c44c6745b986cc311a397ff72118a2f50c3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s compare how different data fetching strategies deal with this requirement.</source>
          <target state="translated">さまざまなデータフェッチ戦略がこの要件にどのように対処するかを比較してみましょう。</target>
        </trans-unit>
        <trans-unit id="45e9d17f03076a3ad9477b82b07a51d4ce77f838" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get back to our &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;first Suspense demo&lt;/a&gt; where there was just one profile. Currently, it fetches the data only once. We&amp;rsquo;ll add a &amp;ldquo;Refresh&amp;rdquo; button to check for server updates.</source>
          <target state="translated">プロファイルが1つしかない&lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;最初のサスペンスデモに&lt;/a&gt;戻りましょう。現在、データの取得は1回だけです。サーバーの更新を確認するための「更新」ボタンを追加します。</target>
        </trans-unit>
        <trans-unit id="f2172c9119c229d11c473d5df9aa8d5d8d41b93a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go over these in detail.</source>
          <target state="translated">これらについて詳しく見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="c35b4f5f51eb24f390b73104414deef66768949e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go through each one and figure out which one is state. Ask three questions about each piece of data:</source>
          <target state="translated">それぞれを調べて、どれが状態かを調べましょう。各データについて3つの質問をします。</target>
        </trans-unit>
        <trans-unit id="efb2b5e509c3f39d850f9c0bc68afe5b00ce8cbb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now &lt;strong&gt;recap what we learned line by line&lt;/strong&gt; and check our understanding.</source>
          <target state="translated">レッツ・今、&lt;strong&gt;私たちは行ずつ学んだことを復習&lt;/strong&gt;し、理解を確認してください。</target>
        </trans-unit>
        <trans-unit id="2db586e06ea830a0bf5bd7eba403ec7c7c1d5191" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s quickly recap what&amp;rsquo;s going on and the order in which the methods are called:</source>
          <target state="translated">何が起こっているのか、メソッドが呼び出される順序を簡単にまとめましょう。</target>
        </trans-unit>
        <trans-unit id="b731235df3a08f9cefe099e4a2b6bfde68c1ff0c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap the two examples above and see how Concurrent Mode unifies them. &lt;strong&gt;In Concurrent Mode, React can work on several state updates &lt;em&gt;concurrently&lt;/em&gt;&lt;/strong&gt; &amp;mdash; just like branches let different team members work independently:</source>
          <target state="translated">上記の2つの例を要約して、コンカレントモードがそれらをどのように統合するかを見てみましょう。&lt;strong&gt;並行モードでは、Reactは複数の状態更新に&lt;em&gt;同時に&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;取り組むことができます&lt;/strong&gt; &amp;mdash;ブランチが異なるチームメンバーが独立して作業できるように：</target>
        </trans-unit>
        <trans-unit id="27b3965c34758d4b1e54e8fcc6e8e8d971b07cb2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens in this example:</source>
          <target state="translated">この例で何が起こるかを要約してみましょう：</target>
        </trans-unit>
        <trans-unit id="87dc62cffe0ac1c4c5391c6f0828660b4dd4a79a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens when you edit an input:</source>
          <target state="translated">入力を編集するとどうなるかを要約してみましょう。</target>
        </trans-unit>
        <trans-unit id="3eca8e8ef68c829498c7d9e68354b1472e530462" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s revisit &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;this demo&lt;/a&gt; from the previous page about &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt;に関する前のページの&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;このデモ&lt;/a&gt;をもう一度見てみましょう。</target>
        </trans-unit>
        <trans-unit id="31e57dda434c35263f11856e0672be5db88ed7e8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite this example again, but using Suspense only:</source>
          <target state="translated">この例をもう一度書き直してみましょう。ただし、サスペンスのみを使用します。</target>
        </trans-unit>
        <trans-unit id="e68a7b21d6c5f27413fdb9eda1dd97e5fd7b5762" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run through this strategy for our application:</source>
          <target state="translated">アプリケーションのこの戦略を実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="85ef0e00ecbe33d94c5d49e91e16ab5645be9c88" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that fetching the user details is very fast and only takes 300 milliseconds. Currently, we&amp;rsquo;re waiting a whole second because we need both user details and posts to display a consistent profile page. But what if we want to show the details faster?</source>
          <target state="translated">ユーザーの詳細のフェッチは非常に高速で、たった300ミリ秒しかかからないとしましょう。現在、一貫したプロファイルページを表示するにはユーザーの詳細と投稿の両方が必要なので、1秒ほどお待ちください。しかし、詳細をより速く表示したい場合はどうでしょうか？</target>
        </trans-unit>
        <trans-unit id="4991d5eafd8e8e062c0f087c85c40c1ea2d4cc4e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that this is the API we&amp;rsquo;re striving for with our &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; wrapper React component:</source>
          <target state="translated">これが、 &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; ラッパーのReactコンポーネントで目指しているAPIだとしましょう。</target>
        </trans-unit>
        <trans-unit id="2036fedebbcaf2b79f375bedb67a4420e6a7e60a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say there is a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; somewhere in your HTML file:</source>
          <target state="translated">HTMLファイルのどこかに &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="e0dc0ebd0f6824d83a50f1aeaa18d1eaaf7cabfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works step by step.</source>
          <target state="translated">これが段階的にどのように機能するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="65e8fb3a23f53b18cf26df347e321256ab7c212c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how we could write this component with Hooks.</source>
          <target state="translated">フックを使用してこのコンポーネントを作成する方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="af6fa6b57cf391318ac0bf024b8e3823314cbcfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see why this matters.</source>
          <target state="translated">これが重要な理由を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="b577a0e161bcf81a4e96e3f3a99c76d5a54c4977" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at each of the props:</source>
          <target state="translated">各小道具を詳しく見てみましょう：</target>
        </trans-unit>
        <trans-unit id="a23b9ea82a3fd528716ce8cd73af2430db7a55e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take another look at all the changes we&amp;rsquo;ve made since the &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;original example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;元の例&lt;/a&gt;以降に行ったすべての変更をもう一度見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5910b527fe0e81b1ac837051111d1cfb45c48766" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, &lt;code&gt;FilterableProductTable&lt;/code&gt; will pass callbacks to &lt;code&gt;SearchBar&lt;/code&gt; that will fire whenever the state should be updated. We can use the &lt;code&gt;onChange&lt;/code&gt; event on the inputs to be notified of it. The callbacks passed by &lt;code&gt;FilterableProductTable&lt;/code&gt; will call &lt;code&gt;setState()&lt;/code&gt;, and the app will be updated.</source>
          <target state="translated">私たちが何をしたいのか考えてみましょう。ユーザーがフォームを変更するたびに、ユーザー入力を反映するように状態を更新することを確認します。コンポーネントは自身の状態のみを更新する必要があるため、 &lt;code&gt;FilterableProductTable&lt;/code&gt; はコールバックを &lt;code&gt;SearchBar&lt;/code&gt; に渡し、SearchBarは状態が更新されるたびに起動します。入力で &lt;code&gt;onChange&lt;/code&gt; イベントを使用して、通知を受けることができます。 &lt;code&gt;FilterableProductTable&lt;/code&gt; によって渡されるコールバックは &lt;code&gt;setState()&lt;/code&gt; を呼び出し、アプリが更新されます。</target>
        </trans-unit>
        <trans-unit id="1e893f82b5ddbd897be82bf493ce9e81174e5eb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try that:</source>
          <target state="translated">それを試してみましょう：</target>
        </trans-unit>
        <trans-unit id="b5f77d8b5f6dfc038e27b746c7a414fe97a3630d" translate="yes" xml:space="preserve">
          <source>Libraries can prevent waterfalls by offering a more centralized way to do data fetching. For example, Relay solves this problem by moving the information about the data a component needs to statically analyzable &lt;em&gt;fragments&lt;/em&gt;, which later get composed into a single query.</source>
          <target state="translated">ライブラリは、データのフェッチを一元化する方法を提供することにより、ウォーターフォールを防ぐことができます。たとえば、Relayは、コンポーネントが静的に分析可能&lt;em&gt;なフラグメントに&lt;/em&gt;必要なデータに関する情報を移動することでこの問題を解決し、&lt;em&gt;フラグメント&lt;/em&gt;は後で単一のクエリに構成されます。</target>
        </trans-unit>
        <trans-unit id="46000d17b247964f6470d045921aa1d6334b0a4b" translate="yes" xml:space="preserve">
          <source>Libraries like &lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mocha&lt;/a&gt; work well in real browser environments, and could help for tests that explicitly need it.</source>
          <target state="translated">&lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mochaの&lt;/a&gt;ようなライブラリーは実際のブラウザー環境でうまく機能し、明示的にそれを必要とするテストに役立つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="041313632fc218e701e7df8b55493ecd8a5123e5" translate="yes" xml:space="preserve">
          <source>Libraries that use render props include &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt; and &lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik&lt;/a&gt;.</source>
          <target state="translated">レンダープロップを使用するライブラリには、&lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt;、&lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt;、&lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik&lt;/a&gt;などがあります。</target>
        </trans-unit>
        <trans-unit id="40721cc170a6bfccd149edbfe1dc276de96ccd33" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution 4.0 International Public License.</source>
          <target state="translated">クリエイティブ・コモンズ表示4.0国際パブリック・ライセンスの下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="17ff789df886ac8c1ebe62bba2f20adc6571666a" translate="yes" xml:space="preserve">
          <source>Lifecycle Methods</source>
          <target state="translated">ライフサイクルメソッド</target>
        </trans-unit>
        <trans-unit id="17ec3a03bfeda0f665ab03b38f3ed1016d195b0e" translate="yes" xml:space="preserve">
          <source>Lifecycle methods are custom functionality that gets executed during the different phases of a component. There are methods available when the component gets created and inserted into the DOM (&lt;a href=&quot;react-component#mounting&quot;&gt;mounting&lt;/a&gt;), when the component updates, and when the component gets unmounted or removed from the DOM.</source>
          <target state="translated">ライフサイクルメソッドは、コンポーネントのさまざまなフェーズで実行されるカスタム機能です。コンポーネントが作成されてDOMに挿入されたとき（&lt;a href=&quot;react-component#mounting&quot;&gt;Mounting&lt;/a&gt;）、コンポーネントが更新されたとき、およびコンポーネントがDOMからアンマウントまたは削除されたときに使用できるメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="fe2783625398c73ad59607a3ac0e2c10a16bd848" translate="yes" xml:space="preserve">
          <source>Lifting State Up</source>
          <target state="translated">リフトアップ状態</target>
        </trans-unit>
        <trans-unit id="60f96af2feedeafd8240d4e2179b169296b1ab38" translate="yes" xml:space="preserve">
          <source>Lifting state involves writing more &amp;ldquo;boilerplate&amp;rdquo; code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state &amp;ldquo;lives&amp;rdquo; in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.</source>
          <target state="translated">状態を解除するには、双方向バインディングアプローチよりも多くの「ボイラープレート」コードを記述する必要がありますが、利点として、バグを見つけて特定するための作業が少なくて済みます。一部のコンポーネントではどの状態も「存続」し、そのコンポーネントだけで状態を変更できるため、バグの表面積が大幅に減少します。さらに、ユーザー入力を拒否または変換するカスタムロジックを実装できます。</target>
        </trans-unit>
        <trans-unit id="6205c7daf26478bf62962f9d33d7bc15dfc34968" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#reactchildrenmap&quot;&gt;&lt;code&gt;React.Children.map()&lt;/code&gt;&lt;/a&gt; but does not return an array.</source>
          <target state="translated">&lt;a href=&quot;#reactchildrenmap&quot;&gt; &lt;code&gt;React.Children.map()&lt;/code&gt; &lt;/a&gt;と似ていますが、配列は返しません。</target>
        </trans-unit>
        <trans-unit id="1a7b45e8f4e6108d3cd632f0d9032c3748a2b4eb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">&lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt; &lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt; &lt;/a&gt;と同様ですが、結果が1つあることを期待してその1つの結果を返すか、1つ以外に一致する数がある場合は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="fbfeab98f1492d3cbd4fe154e243495eb88fd5bc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">&lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt; &lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt; &lt;/a&gt;と同様ですが、結果が1つあることを期待してその1つの結果を返すか、1つ以外に一致する数がある場合は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="f9229dd48cd84c65e22bacddf9669feed15d9307" translate="yes" xml:space="preserve">
          <source>Like Next, the Experimental channel is a prerelease channel that tracks the master branch of the React repository. Unlike Next, Experimental releases include additional features and APIs that are not ready for wider release.</source>
          <target state="translated">Next と同様に、Experimental チャンネルは React リポジトリのマスターブランチを追跡するプレリリースチャンネルです。Next とは異なり、Experimental のリリースには、まだ広くリリースする準備ができていない追加機能や API が含まれています。</target>
        </trans-unit>
        <trans-unit id="b243b275e73df60e527af74a2a1e22222d9d870a" translate="yes" xml:space="preserve">
          <source>Like any unfamiliar technology, React does have a learning curve. With practice and some patience, you &lt;em&gt;will&lt;/em&gt; get the hang of it.</source>
          <target state="translated">慣れていないテクノロジーと同様に、Reactにも学習曲線があります。練習と忍耐があれば、コツをつかむこと&lt;em&gt;が&lt;/em&gt;できます。</target>
        </trans-unit>
        <trans-unit id="3b06e3b678326306ca6aedaf4c7b742dbd8cc493" translate="yes" xml:space="preserve">
          <source>Like components, the contract between &lt;code&gt;withSubscription&lt;/code&gt; and the wrapped component is entirely props-based. This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component. This may be useful if you change data-fetching libraries, for example.</source>
          <target state="translated">コンポーネントと同様に、 &lt;code&gt;withSubscription&lt;/code&gt; とラップされたコンポーネント間のコントラクトは完全にプロップベースです。これにより、ラップされたコンポーネントに同じプロップが提供されている限り、HOCを別のHOCと簡単に交換できます。これは、たとえば、データ取得ライブラリを変更する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8756ee6b18f3a0b99d47c3487ab6bf4153dc005f" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; support &lt;code&gt;defaultChecked&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; supports &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="translated">同様に、 &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; は &lt;code&gt;defaultChecked&lt;/code&gt; をサポートし、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; は &lt;code&gt;defaultValue&lt;/code&gt; をサポートします。</target>
        </trans-unit>
        <trans-unit id="64b1d121df3542e14f97acaa2800f9f76542cac7" translate="yes" xml:space="preserve">
          <source>Linting in Flow</source>
          <target state="translated">流れの中のリンティング</target>
        </trans-unit>
        <trans-unit id="f3b64dc10b36fcc65c0d847eaaa62fd7fe512239" translate="yes" xml:space="preserve">
          <source>Lists and Keys</source>
          <target state="translated">リストとキー</target>
        </trans-unit>
        <trans-unit id="110bfe58a1735dfc3135bc1d5e016924d60c0744" translate="yes" xml:space="preserve">
          <source>Live Demo</source>
          <target state="translated">ライブデモ</target>
        </trans-unit>
        <trans-unit id="5f00bd7dc65bd809a53f2303fb70b92320c36fa6" translate="yes" xml:space="preserve">
          <source>Live-editing CSS and JS in development.</source>
          <target state="translated">開発中のCSSやJSのライブエディット。</target>
        </trans-unit>
        <trans-unit id="dc841064cbfd066e159686f41aef96834b0e8bf6" translate="yes" xml:space="preserve">
          <source>Looking at the now generated &lt;code&gt;tsconfig.json&lt;/code&gt;, you can see that there are many options you can use to configure the compiler. For a detailed description of all the options, check &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">生成された &lt;code&gt;tsconfig.json&lt;/code&gt; を見ると、コンパイラーの構成に使用できる多くのオプションがあることがわかります。すべてのオプションの詳細については、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;ここを&lt;/a&gt;チェックしてください。</target>
        </trans-unit>
        <trans-unit id="f500ff46d146daea76d615ff5daed4f1aeaa0d00" translate="yes" xml:space="preserve">
          <source>MDN HTML elements reference</source>
          <target state="translated">MDN HTML要素参照</target>
        </trans-unit>
        <trans-unit id="d5beafe9207c5520f3ac09a7866f79c87d68f07b" translate="yes" xml:space="preserve">
          <source>MDN Web Docs takes a look at this and describes how we can build &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;keyboard-navigable JavaScript widgets&lt;/a&gt;.</source>
          <target state="translated">MDN Web Docsはこれを見て、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;キーボード操作可能なJavaScriptウィジェットを&lt;/a&gt;構築する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="48b1316849f970c5b3e2af20718278c5b7793286" translate="yes" xml:space="preserve">
          <source>Main Concepts</source>
          <target state="translated">主なコンセプト</target>
        </trans-unit>
        <trans-unit id="02ff3711bd667ed46bace9ec4c6ec8190ecebfcc" translate="yes" xml:space="preserve">
          <source>Major releases can also contain new features, and any release can include bug fixes.</source>
          <target state="translated">メジャーリリースは新機能を含むこともでき、どのリリースもバグフィックスを含むことができます。</target>
        </trans-unit>
        <trans-unit id="f18f93964d446c1e6ba3cd266eb85e86312f1773" translate="yes" xml:space="preserve">
          <source>Make sure you aren&amp;rsquo;t &lt;em&gt;calling the function&lt;/em&gt; when you pass it to the component:</source>
          <target state="translated">コンポーネントに渡すとき&lt;em&gt;に関数を呼び出さ&lt;/em&gt;ない&lt;em&gt;ようにして&lt;/em&gt;ください。</target>
        </trans-unit>
        <trans-unit id="1908a834f7fac54b702b7157c4e6dc90e16f736a" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re familiar with simpler alternatives:</source>
          <target state="translated">より簡単な代替案に慣れていることを確認してください：</target>
        </trans-unit>
        <trans-unit id="90e7115a4c3ac435e928084df77c98aa6a10ab0d" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re running the application in the development mode.</source>
          <target state="translated">アプリケーションを開発モードで実行していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="16f51d22d8fb5f4e18c7b9a43a14aa00fb1d1d71" translate="yes" xml:space="preserve">
          <source>Managing focus, text selection, or media playback.</source>
          <target state="translated">フォーカス、テキスト選択、またはメディア再生を管理します。</target>
        </trans-unit>
        <trans-unit id="63ee04fb3d96bb1368dfb5a70eed53b537b4cf07" translate="yes" xml:space="preserve">
          <source>Many React users credit reading &lt;a href=&quot;thinking-in-react&quot;&gt;Thinking in React&lt;/a&gt; as the moment React finally &amp;ldquo;clicked&amp;rdquo; for them. It&amp;rsquo;s probably the oldest React walkthrough but it&amp;rsquo;s still just as relevant.</source>
          <target state="translated">多くのReactユーザーは、Reactがようやく「クリック」した瞬間として&lt;a href=&quot;thinking-in-react&quot;&gt;Thinking in React&lt;/a&gt;を読んだと信じています。それはおそらく最も古いReactウォークスルーですが、それでも関連性は同じです。</target>
        </trans-unit>
        <trans-unit id="25207d84725584b98b20c010ae4e867354803e86" translate="yes" xml:space="preserve">
          <source>Maybe.</source>
          <target state="translated">Maybe.</target>
        </trans-unit>
        <trans-unit id="5279878671cef1bbee173e636b630698108458c0" translate="yes" xml:space="preserve">
          <source>Mechanisms to skip to desired content</source>
          <target state="translated">目的のコンテンツにスキップする仕組み</target>
        </trans-unit>
        <trans-unit id="80ebd3a5b45a9f5adf87a363ab82624e164a1745" translate="yes" xml:space="preserve">
          <source>Media Events</source>
          <target state="translated">メディアイベント</target>
        </trans-unit>
        <trans-unit id="2fce9fc1bba59eae6ae511090a30e9f9acda79af" translate="yes" xml:space="preserve">
          <source>Migration Step: Blocking Mode</source>
          <target state="translated">移行ステップ。ブロッキングモード</target>
        </trans-unit>
        <trans-unit id="c51e9091bf1aa90a7dc06f8b80d1cf4f79106e04" translate="yes" xml:space="preserve">
          <source>Minor releases are the most common type of release.</source>
          <target state="translated">マイナーリリースが一般的です。</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="e609b515d8887ae3c0a2bcd948b76d5eb888dcae" translate="yes" xml:space="preserve">
          <source>Mocking Modules</source>
          <target state="translated">モッキングモジュール</target>
        </trans-unit>
        <trans-unit id="5fd5e79fcfd93473fe47f93cc81171186377bc01" translate="yes" xml:space="preserve">
          <source>Mocking a rendering surface</source>
          <target state="translated">レンダリングサーフェスのモック</target>
        </trans-unit>
        <trans-unit id="9f9db431c0932c551ce8ea2f4c40d441d4aa97a6" translate="yes" xml:space="preserve">
          <source>Mocking functions</source>
          <target state="translated">モッキング機能</target>
        </trans-unit>
        <trans-unit id="7e3ebffe5140fcd669b91ded83765eee7cd79ed7" translate="yes" xml:space="preserve">
          <source>Mocking modules</source>
          <target state="translated">モジュールのモッキング</target>
        </trans-unit>
        <trans-unit id="dfc6f7ed11adb29245ad928339ee3fe94bf8f96c" translate="yes" xml:space="preserve">
          <source>Mocking timers</source>
          <target state="translated">モッキングタイマー</target>
        </trans-unit>
        <trans-unit id="c5ab7c68a15742b6ace6a0b59f0802cd56989f9d" translate="yes" xml:space="preserve">
          <source>More Complex Widgets</source>
          <target state="translated">より複雑なウィジェット</target>
        </trans-unit>
        <trans-unit id="ae1e9c89527fbc96f2921cbe93fbfc11e6a52a9a" translate="yes" xml:space="preserve">
          <source>More Flexible Toolchains</source>
          <target state="translated">より柔軟なツールチェーン</target>
        </trans-unit>
        <trans-unit id="c42df7c665642f754f240ed7f247eeed80d1ceb3" translate="yes" xml:space="preserve">
          <source>More concretely, &lt;strong&gt;a render prop is a function prop that a component uses to know what to render.&lt;/strong&gt;</source>
          <target state="translated">より具体的には&lt;strong&gt;、レンダープロップは、コンポーネントが何をレンダリングするかを知るために使用する関数プロップです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4184dc3093adbdaf5a60e796e014a24e3eb74b2" translate="yes" xml:space="preserve">
          <source>Most React apps will have their files &amp;ldquo;bundled&amp;rdquo; using tools like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Bundling is the process of following imported files and merging them into a single file: a &amp;ldquo;bundle&amp;rdquo;. This bundle can then be included on a webpage to load an entire app at once.</source>
          <target state="translated">ほとんどのReactアプリは、&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;、&lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt;、&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;などのツールを使用してファイルを「バンドル」します。バンドルとは、インポートされたファイルを追跡し、それらを単一のファイル「バンドル」にマージするプロセスです。その後、このバンドルをWebページに含めて、アプリ全体を一度にロードできます。</target>
        </trans-unit>
        <trans-unit id="7f5a32a23f908873850adbc01e3bfc083647f135" translate="yes" xml:space="preserve">
          <source>Most of the time, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; instead of writing your own &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. It only does a shallow comparison, so you can&amp;rsquo;t use it if the props or state may have been mutated in a way that a shallow comparison would miss.</source>
          <target state="translated">ほとんどの場合、独自の &lt;code&gt;shouldComponentUpdate&lt;/code&gt; を作成する代わりに &lt;code&gt;React.PureComponent&lt;/code&gt; を使用できます。浅い比較だけを行うので、浅い比較が失敗するような方法で小道具または状態が変更された可能性がある場合は使用できません。</target>
        </trans-unit>
        <trans-unit id="0d6ec3d67d6c3f4388c5225ce97b912bc6998b9b" translate="yes" xml:space="preserve">
          <source>Most people who use React don&amp;rsquo;t use Web Components, but you may want to, especially if you are using third-party UI components that are written using Web Components.</source>
          <target state="translated">Reactを使用するほとんどの人はWebコンポーネントを使用しませんが、特にWebコンポーネントを使用して作成されたサードパーティのUIコンポーネントを使用している場合は、使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="26ae06ab481b93e012f7ab95465638d5fb60ed34" translate="yes" xml:space="preserve">
          <source>Mounting</source>
          <target state="translated">Mounting</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="translated">マウスイベント</target>
        </trans-unit>
        <trans-unit id="7b20c10dce51324fb107e751c01666324956e394" translate="yes" xml:space="preserve">
          <source>Mouse and pointer events</source>
          <target state="translated">マウスとポインタのイベント</target>
        </trans-unit>
        <trans-unit id="4d1e7bad76871046ddf523d9fe663dd3a621512b" translate="yes" xml:space="preserve">
          <source>Move the body of the function into the &lt;code&gt;render()&lt;/code&gt; method.</source>
          <target state="translated">関数の本体を &lt;code&gt;render()&lt;/code&gt; メソッドに移動します。</target>
        </trans-unit>
        <trans-unit id="7b29de6bcd589e86e040638485090ea2a9bf182d" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;Profiler&lt;/code&gt; components can be used to measure different parts of an application:</source>
          <target state="translated">複数の &lt;code&gt;Profiler&lt;/code&gt; コンポーネントを使用して、アプリケーションのさまざまな部分を測定できます。</target>
        </trans-unit>
        <trans-unit id="8e23b3461f95ee737c2d746ec92f09e64df8c67e" translate="yes" xml:space="preserve">
          <source>Multiple Renderers</source>
          <target state="translated">複数のレンダラ</target>
        </trans-unit>
        <trans-unit id="b0479fd15fec4ef8ee834648226853be71fdeda8" translate="yes" xml:space="preserve">
          <source>Mutating HOCs are a leaky abstraction&amp;mdash;the consumer must know how they are implemented in order to avoid conflicts with other HOCs.</source>
          <target state="translated">変異HOCは漏れやすい抽象概念です。消費者は、他のHOCとの競合を回避するために、それらがどのように実装されているかを知る必要があります。</target>
        </trans-unit>
        <trans-unit id="6b4fb500f3d1079177a94f12b723a038f9d11e9c" translate="yes" xml:space="preserve">
          <source>Mutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React&amp;rsquo;s &lt;em&gt;render phase&lt;/em&gt;). Doing so will lead to confusing bugs and inconsistencies in the UI.</source>
          <target state="translated">ミューテーション、サブスクリプション、タイマー、ロギング、およびその他の副作用は、関数コンポーネントの本体の内部では許可されていません（Reactの&lt;em&gt;レンダリングフェーズ&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;）。これを行うと、UIの混乱したバグや不整合が発生します。</target>
        </trans-unit>
        <trans-unit id="298fe7648153e9ef9747060691f787af56551508" translate="yes" xml:space="preserve">
          <source>NVDA in Firefox</source>
          <target state="translated">FirefoxのNVDA</target>
        </trans-unit>
        <trans-unit id="88f2f30ba49708ae97f8d92b8a8a72e7ddff53df" translate="yes" xml:space="preserve">
          <source>Named Exports</source>
          <target state="translated">名目輸出</target>
        </trans-unit>
        <trans-unit id="8223c4ee1ebba2ecb6739e2c07dbe5aef3df91b4" translate="yes" xml:space="preserve">
          <source>Naming Changes from React 15</source>
          <target state="translated">React 15 からの命名の変更点</target>
        </trans-unit>
        <trans-unit id="e41e56840d69bd1bdd31e27707dc3a8b970413df" translate="yes" xml:space="preserve">
          <source>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn&amp;rsquo;t care whether it is defined as a function or a class.</source>
          <target state="translated">親コンポーネントと子コンポーネントのどちらも、特定のコンポーネントがステートフルかステートレスかを認識できません。また、コンポーネントが関数として定義されているか、クラスとして定義されているかを気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="c44dcd3a4ac0c4c177b3fafe8b75ff34a66cc079" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.state&lt;/code&gt; directly, as calling &lt;code&gt;setState()&lt;/code&gt; afterwards may replace the mutation you made. Treat &lt;code&gt;this.state&lt;/code&gt; as if it were immutable.</source>
          <target state="translated">&lt;code&gt;this.state&lt;/code&gt; を直接変更しないでください。 &lt;code&gt;setState()&lt;/code&gt; を呼び出すと、行った変更が置き換えられる可能性があります。 &lt;code&gt;this.state&lt;/code&gt; を不変であるかのように扱います。</target>
        </trans-unit>
        <trans-unit id="2cb61bead103f4e57375ed4a4afb6cfadf7e8a73" translate="yes" xml:space="preserve">
          <source>New Behavior for Uncaught Errors</source>
          <target state="translated">捕まえられなかったエラーの新しい挙動</target>
        </trans-unit>
        <trans-unit id="9840d3214efbf61f44cf5554641966293bd9f3a1" translate="yes" xml:space="preserve">
          <source>Next Channel</source>
          <target state="translated">次のチャンネル</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">次のステップ</target>
        </trans-unit>
        <trans-unit id="0ed8ca892cbf39b577e860e50cdb6e102751578f" translate="yes" xml:space="preserve">
          <source>Next, add three &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags to the HTML page right before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">次に、3つの &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグをHTMLページの終了 &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; タグの直前に追加します。</target>
        </trans-unit>
        <trans-unit id="87cb58c13d37c6cc1855c1dd32d1fed18cfeb93f" translate="yes" xml:space="preserve">
          <source>Next, the &lt;code&gt;render()&lt;/code&gt; method is called and the diff algorithm recurses on the previous result and the new result.</source>
          <target state="translated">次に、 &lt;code&gt;render()&lt;/code&gt; メソッドが呼び出され、diffアルゴリズムが前の結果と新しい結果で再帰します。</target>
        </trans-unit>
        <trans-unit id="3e81212e5ac19cfc9b59fe21a631d3753e83f2b5" translate="yes" xml:space="preserve">
          <source>Next, we will create a component called &lt;code&gt;Calculator&lt;/code&gt;. It renders an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; that lets you enter the temperature, and keeps its value in &lt;code&gt;this.state.temperature&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;Calculator&lt;/code&gt; というコンポーネントを作成します。温度を入力できる &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; をレンダリングし、その値を &lt;code&gt;this.state.temperature&lt;/code&gt; に保持します。</target>
        </trans-unit>
        <trans-unit id="773f24daf1da57217e2f8e8567bf1bc9016af437" translate="yes" xml:space="preserve">
          <source>Next, we will extract a &lt;code&gt;UserInfo&lt;/code&gt; component that renders an &lt;code&gt;Avatar&lt;/code&gt; next to the user&amp;rsquo;s name:</source>
          <target state="translated">次に、ユーザー名の横に &lt;code&gt;Avatar&lt;/code&gt; を表示する &lt;code&gt;UserInfo&lt;/code&gt; コンポーネントを抽出します。</target>
        </trans-unit>
        <trans-unit id="72d6961628775828349729a4be218018b6d3a3ac" translate="yes" xml:space="preserve">
          <source>Next, we will implement the lifecycle methods. We need to initialize Chosen with the ref to the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node in &lt;code&gt;componentDidMount&lt;/code&gt;, and tear it down in &lt;code&gt;componentWillUnmount&lt;/code&gt;:</source>
          <target state="translated">次に、ライフサイクルメソッドを実装します。Chosenを、 &lt;code&gt;componentDidMount&lt;/code&gt; の &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; ノードへの参照で初期化し、componentWillUnmountで破棄する必要があり &lt;code&gt;componentWillUnmount&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce34474eda0627488f7dc85176d87bf118e6e53d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add an import for the &lt;code&gt;useTransition&lt;/code&gt; Hook from React:</source>
          <target state="translated">次に、Reactからの &lt;code&gt;useTransition&lt;/code&gt; フックのインポートを追加します。</target>
        </trans-unit>
        <trans-unit id="00d7070daf25a2f645c41cd51b24e95c602ef3cd" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll make the &lt;code&gt;Clock&lt;/code&gt; set up its own timer and update itself every second.</source>
          <target state="translated">次に、 &lt;code&gt;Clock&lt;/code&gt; 独自のタイマーを設定し、毎秒更新します。</target>
        </trans-unit>
        <trans-unit id="83e778abae94d2dfc988da43bf316d54e5851ca7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll tell the compiler where our source code is and where the output should go.</source>
          <target state="translated">次に、コンパイラーにソースコードの場所と出力先を指定します。</target>
        </trans-unit>
        <trans-unit id="694fd7bdca2fabcac6a912607368e98378b0b39b" translate="yes" xml:space="preserve">
          <source>Next.js</source>
          <target state="translated">Next.js</target>
        </trans-unit>
        <trans-unit id="aa4786474b1f9c2b27bbf660fd976c2e3f9e0c0b" translate="yes" xml:space="preserve">
          <source>No Breaking Changes</source>
          <target state="translated">ブレイキングの変更はありません</target>
        </trans-unit>
        <trans-unit id="ea583f6afe9b6e25e50f115711dd0b56142fcb36" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-es6&quot;&gt;&amp;ldquo;React Without ES6&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="translated">番号！詳しくは、&lt;a href=&quot;react-without-es6&quot;&gt;「ES6を使用せずに反応&lt;/a&gt;する」をご覧ください。</target>
        </trans-unit>
        <trans-unit id="65b196a9e021f5013ed7f97aab941425359e880d" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-jsx&quot;&gt;&amp;ldquo;React Without JSX&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="translated">番号！詳細については、&lt;a href=&quot;react-without-jsx&quot;&gt;「JSXなしのReact」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9848de506504aee3698fb2303cc082341679f4dc" translate="yes" xml:space="preserve">
          <source>No, they are different. The Shadow DOM is a browser technology designed primarily for scoping variables and CSS in web components. The virtual DOM is a concept implemented by libraries in JavaScript on top of browser APIs.</source>
          <target state="translated">いいえ、それらは違います。Shadow DOMは、主にWebコンポーネントの変数やCSSをスコープするために設計されたブラウザ技術です。仮想DOMは、ブラウザAPIの上にJavaScriptのライブラリによって実装された概念です。</target>
        </trans-unit>
        <trans-unit id="e4ec72f282ae4d51f6663dfafe02a89ddbd53865" translate="yes" xml:space="preserve">
          <source>No. In modern browsers, the raw performance of closures compared to classes doesn&amp;rsquo;t differ significantly except in extreme scenarios.</source>
          <target state="translated">いいえ。最新のブラウザでは、クラスと比較したクロージャの未加工のパフォーマンスは、極端なシナリオを除いて、大きな違いはありません。</target>
        </trans-unit>
        <trans-unit id="0e489b277ff2e842c4240cf5198329ad064dfd60" translate="yes" xml:space="preserve">
          <source>No. There are &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;no plans&lt;/a&gt; to remove classes from React &amp;mdash; we all need to keep shipping products and can&amp;rsquo;t afford rewrites. We recommend trying Hooks in new code.</source>
          <target state="translated">いいえ。Reactからクラスを削除する&lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;計画&lt;/a&gt;はありません。私たちは全員、製品を出荷し続ける必要があり、書き換えを行う余裕がありません。新しいコードでフックを試すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a407ef4de7c3c16900e064cfde1c40d6f88459c3" translate="yes" xml:space="preserve">
          <source>Normally you should try to avoid all uses of &lt;code&gt;forceUpdate()&lt;/code&gt; and only read from &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="translated">通常は、 &lt;code&gt;forceUpdate()&lt;/code&gt; のすべての使用を避けて、render（）の &lt;code&gt;this.props&lt;/code&gt; および &lt;code&gt;this.state&lt;/code&gt; からのみ読み取る必要があり &lt;code&gt;render()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99653f5245ac5639a7989484c01146c83245683b" translate="yes" xml:space="preserve">
          <source>Normally you would define a React component as a plain JavaScript class:</source>
          <target state="translated">通常、ReactコンポーネントをプレーンなJavaScriptクラスとして定義します。</target>
        </trans-unit>
        <trans-unit id="183009a95c48cc3c8552b8d193bc55733a9da03e" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, &lt;code&gt;props.children&lt;/code&gt; works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as &lt;code&gt;props.children&lt;/code&gt;:</source>
          <target state="translated">通常、JSXに挿入されたJavaScript式は、文字列、React要素、またはそれらのリストに評価されます。ただし、 &lt;code&gt;props.children&lt;/code&gt; は、Reactがレンダリング方法を認識している種類だけでなく、あらゆる種類のデータを渡すことができるという点で、他のpropと同じように機能します。たとえば、カスタムコンポーネントがある場合、コールバックを &lt;code&gt;props.children&lt;/code&gt; として受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="190f214c6271f32c16616efc1edf4a598d1724d4" translate="yes" xml:space="preserve">
          <source>Normally, there is a warning when an element with children is also marked as &lt;code&gt;contentEditable&lt;/code&gt;, because it won&amp;rsquo;t work. This attribute suppresses that warning. Don&amp;rsquo;t use this unless you are building a library like &lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js&lt;/a&gt; that manages &lt;code&gt;contentEditable&lt;/code&gt; manually.</source>
          <target state="translated">通常、子を持つ要素も &lt;code&gt;contentEditable&lt;/code&gt; としてマークされていると、機能しないため警告が表示されます。この属性はその警告を抑制します。あなたのようなライブラリー構築されなければ、これを使用しないでください&lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js&lt;/a&gt;管理 &lt;code&gt;contentEditable&lt;/code&gt; を手動で。</target>
        </trans-unit>
        <trans-unit id="0cd4b09c96906d68937c9412b6fd82a68a4314a7" translate="yes" xml:space="preserve">
          <source>Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use in new code without making any changes to the existing code.</source>
          <target state="translated">通常、Reactに機能を追加すると、すぐに使い始めることができます。FragmentsやContext、さらにはHooksなどがそのような機能の例です。既存のコードに変更を加えることなく、新しいコードで使用することができます。</target>
        </trans-unit>
        <trans-unit id="a2dec545b1bcbcdd30f45e8128cc1dc979967845" translate="yes" xml:space="preserve">
          <source>Normally, when you return an element from a component&amp;rsquo;s render method, it&amp;rsquo;s mounted into the DOM as a child of the nearest parent node:</source>
          <target state="translated">通常、コンポーネントのrenderメソッドから要素を返すと、最も近い親ノードの子としてDOMにマウントされます。</target>
        </trans-unit>
        <trans-unit id="b36f36a60ec7e988ebd6b0da0589f77cbff203cc" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t mutate local state in React. However, as an escape hatch, you can use an incrementing counter to force a re-render even if the state has not changed:</source>
          <target state="translated">通常、Reactでローカル状態を変更しないでください。ただし、エスケープハッチとして、状態が変化していなくても、インクリメントカウンターを使用して強制的に再レン​​ダリングできます。</target>
        </trans-unit>
        <trans-unit id="65436a84c77556cccffc3de4f952f08eb5996b2a" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t need to think about this. But it matters for HOCs because it means you can&amp;rsquo;t apply a HOC to a component within the render method of a component:</source>
          <target state="translated">通常、これについて考える必要はありません。ただし、コンポーネントのrenderメソッド内でコンポーネントにHOCを適用できないことを意味するため、HOCにとって重要です。</target>
        </trans-unit>
        <trans-unit id="b634d41d383d2c2c85fe24302f5a62774271b079" translate="yes" xml:space="preserve">
          <source>Not all HOCs look the same. Sometimes they accept only a single argument, the wrapped component:</source>
          <target state="translated">すべてのHOCが同じように見えるわけではありません。場合によっては、ラップされたコンポーネントという単一の引数だけを受け付けることもあります。</target>
        </trans-unit>
        <trans-unit id="81b40478626081aff6b6152a5ac2bc60a347ba9e" translate="yes" xml:space="preserve">
          <source>Not all style properties are converted to pixel strings though. Certain ones remain unitless (eg &lt;code&gt;zoom&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;flex&lt;/code&gt;). A complete list of unitless properties can be seen &lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">ただし、すべてのスタイルプロパティがピクセル文字列に変換されるわけではありません。特定のものは単位なしのままです（ &lt;code&gt;zoom&lt;/code&gt; 、 &lt;code&gt;order&lt;/code&gt; 、 &lt;code&gt;flex&lt;/code&gt; ）。単位のないプロパティの完全なリストは、&lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;こちらにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3dce74d24f02b63c13638f91d2e8c790ee44211" translate="yes" xml:space="preserve">
          <source>Not every React release deserves its own blog post, but you can find a detailed changelog for every release in the &lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt;&lt;code&gt;CHANGELOG.md&lt;/code&gt; file in the React repository&lt;/a&gt;, as well as on the &lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="translated">すべてのReactリリースが独自のブログ投稿に値するわけではありません&lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt;が、Reactリポジトリの&lt;/a&gt; &lt;code&gt;CHANGELOG.md&lt;/code&gt; ファイルおよび&lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;リリース&lt;/a&gt;ページで、すべてのリリースの詳細な変更ログを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b703ebbf1b1cf4f4af246b8831b3304e1ea7b732" translate="yes" xml:space="preserve">
          <source>Note for component library maintainers</source>
          <target state="translated">コンポーネントライブラリメンテナへの注意事項</target>
        </trans-unit>
        <trans-unit id="61f07fc00eca63f479177f8f24ebc20765f4ab58" translate="yes" xml:space="preserve">
          <source>Note how &lt;strong&gt;we have to duplicate the code between these two lifecycle methods in class.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クラス内のこれら2つのライフサイクルメソッド間でコードを複製する&lt;/strong&gt;方法&lt;strong&gt;に&lt;/strong&gt;注意してください&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="136a652f0357162f7faa10211f6de25fc285e258" translate="yes" xml:space="preserve">
          <source>Note how the logic that sets &lt;code&gt;document.title&lt;/code&gt; is split between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. The subscription logic is also spread between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;. And &lt;code&gt;componentDidMount&lt;/code&gt; contains code for both tasks.</source>
          <target state="translated">&lt;code&gt;document.title&lt;/code&gt; を設定するロジックがどのように &lt;code&gt;componentDidMount&lt;/code&gt; と &lt;code&gt;componentDidUpdate&lt;/code&gt; に分割されているかに注意してください。サブスクリプションロジックも、 &lt;code&gt;componentDidMount&lt;/code&gt; と &lt;code&gt;componentWillUnmount&lt;/code&gt; の間で分散されます。また、 &lt;code&gt;componentDidMount&lt;/code&gt; には、両方のタスクのコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="af859993c451cb0b08b7e66c1d591884e0bd7b2b" translate="yes" xml:space="preserve">
          <source>Note how this would work for props, state, or any other calculated value.</source>
          <target state="translated">これが小道具、状態、またはその他の計算された値に対してどのように機能するかに注意してください。</target>
        </trans-unit>
        <trans-unit id="81f0076b98d34a6e29be0cedd7cf07479dcc0f97" translate="yes" xml:space="preserve">
          <source>Note how we also changed the effect dependencies from &lt;code&gt;[]&lt;/code&gt; to &lt;code&gt;[id]&lt;/code&gt; &amp;mdash; because we want the effect to re-run when the &lt;code&gt;id&lt;/code&gt; changes. Otherwise, we wouldn&amp;rsquo;t refetch new data.</source>
          <target state="translated">我々はまた、から効果の依存関係をどのように変化するかを注意 &lt;code&gt;[]&lt;/code&gt; の &lt;code&gt;[id]&lt;/code&gt; 、我々は再実行したときに効果たいので- &lt;code&gt;id&lt;/code&gt; 変更を。それ以外の場合は、新しいデータを再フェッチしません。</target>
        </trans-unit>
        <trans-unit id="66e67313f6ff24b0ac9427a27eaa56f7a14b86fb" translate="yes" xml:space="preserve">
          <source>Note how we eliminated the &lt;code&gt;if (...)&lt;/code&gt; &amp;ldquo;is loading&amp;rdquo; checks from our components. This doesn&amp;rsquo;t only remove boilerplate code, but it also simplifies making quick design changes. For example, if we wanted profile details and posts to always &amp;ldquo;pop in&amp;rdquo; together, we could delete the &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary between them. Or we could make them independent from each other by giving each &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary. Suspense lets us change the granularity of our loading states and orchestrate their sequencing without invasive changes to our code.</source>
          <target state="translated">コンポーネントから &lt;code&gt;if (...)&lt;/code&gt; &amp;ldquo; is loading&amp;rdquo;チェックを削除したことに注意してください。これは定型コードを削除するだけでなく、設計変更を迅速に行うことも簡単にします。たとえば、プロファイルの詳細と投稿を常に一緒に「ポップイン」したい場合、それらの間の &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 境界を削除できます。または、それぞれ&lt;em&gt;に独自の&lt;/em&gt; &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 境界を与えることにより、それらを互いに独立させることができます。Suspenseを使用すると、コードに侵襲的な変更を加えることなく、読み込み状態の粒度を変更し、シーケンスを調整できます。</target>
        </trans-unit>
        <trans-unit id="a102e3bac932a4b73c9dad4c0a7268f562de444e" translate="yes" xml:space="preserve">
          <source>Note how we pass &lt;code&gt;props&lt;/code&gt; to the base constructor:</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; を基本コンストラクターに渡す方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="2582d2e45f28b6c6e7c9a5f4534087c1aa30ef02" translate="yes" xml:space="preserve">
          <source>Note how we save the timer ID right on &lt;code&gt;this&lt;/code&gt; (&lt;code&gt;this.timerID&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; タイマーIDを保存する方法に注意してください（ &lt;code&gt;this.timerID&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7abe7d49c5110b0b495bee7ab2bbbd92a50f878a" translate="yes" xml:space="preserve">
          <source>Note how we used the ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;computed property name&lt;/a&gt; syntax to update the state key corresponding to the given input name:</source>
          <target state="translated">ES6で&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;計算されたプロパティ名の&lt;/a&gt;構文を使用して、指定された入力名に対応する状態キーを更新する方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="b008f8350f4cfc8fc1ac8218af3644148e094014" translate="yes" xml:space="preserve">
          <source>Note how we were able to move the &lt;code&gt;useState&lt;/code&gt; call for the &lt;code&gt;position&lt;/code&gt; state variable and the related effect into a custom Hook without changing their code. If all state was in a single object, extracting it would be more difficult.</source>
          <target state="translated">コードを変更せずに、 &lt;code&gt;position&lt;/code&gt; 状態変数の &lt;code&gt;useState&lt;/code&gt; 呼び出しと関連するエフェクトをカスタムフックに移動できたことに注意してください。すべての状態が単一のオブジェクト内にある場合、それを抽出することはより困難になります。</target>
        </trans-unit>
        <trans-unit id="4b1a921c73e886405b533b71309555191e0dd804" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;SuspenseList&lt;/code&gt; only operates on the closest &lt;code&gt;Suspense&lt;/code&gt; and &lt;code&gt;SuspenseList&lt;/code&gt; components below it. It does not search for boundaries deeper than one level. However, it is possible to nest multiple &lt;code&gt;SuspenseList&lt;/code&gt; components in each other to build grids.</source>
          <target state="translated">&lt;code&gt;SuspenseList&lt;/code&gt; は、その下の最も近い &lt;code&gt;Suspense&lt;/code&gt; および &lt;code&gt;SuspenseList&lt;/code&gt; コンポーネントでのみ動作することに注意してください。1レベルより深い境界は検索しません。ただし、グリッドを構築するために複数の &lt;code&gt;SuspenseList&lt;/code&gt; コンポーネントを相互にネストすることは可能です。</target>
        </trans-unit>
        <trans-unit id="5369d72764239c963258ac4860d4222756071b86" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;error boundaries only catch errors in the components below them in the tree&lt;/strong&gt;. An error boundary can&amp;rsquo;t catch an error within itself. If an error boundary fails trying to render the error message, the error will propagate to the closest error boundary above it. This, too, is similar to how catch {} block works in JavaScript.</source>
          <target state="translated">&lt;strong&gt;エラー境界は、ツリーの下のコンポーネントの下のエラーのみをキャッチする&lt;/strong&gt;ことに注意して&lt;strong&gt;ください&lt;/strong&gt;。エラー境界は、それ自体でエラーをキャッチすることはできません。エラー境界がエラーメッセージのレンダリングに失敗した場合、エラーはその上の最も近いエラー境界に伝播します。これも、JavaScriptでcatch {}ブロックが機能する方法に似ています。</target>
        </trans-unit>
        <trans-unit id="056385a2ed6637b481ae142bf0a46d9f70a318a3" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;the numbers are relative so components will render faster in production&lt;/strong&gt;. Still, this should help you realize when unrelated UI gets updated by mistake, and how deep and how often your UI updates occur.</source>
          <target state="translated">注意&lt;strong&gt;数字は相対的なものであるので、部品が速く生産でレンダリングされます&lt;/strong&gt;。それでも、これは、無関係なUIが誤って更新されたとき、およびUIの更新がどのくらい深くて頻繁に発生するかを理解するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="89ff4a5e91c66b9d6944b9d99f0d60617bdf219c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;to enable Hooks, all React packages need to be 16.8.0 or higher&lt;/strong&gt;. Hooks won&amp;rsquo;t work if you forget to update, for example, React DOM.</source>
          <target state="translated">&lt;strong&gt;フックを有効にするには、すべてのReactパッケージが16.8.0以降である必要があることに&lt;/strong&gt;注意し&lt;strong&gt;て&lt;/strong&gt;ください。React DOMなどの更新を忘れると、フックは機能しません。</target>
        </trans-unit>
        <trans-unit id="a58c552c3d3190dd2fb91ca8e1639154f214426b" translate="yes" xml:space="preserve">
          <source>Note that React assigns no special meaning to the &lt;code&gt;this.el&lt;/code&gt; field. It only works because we have previously assigned this field from a &lt;code&gt;ref&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="translated">Reactは &lt;code&gt;this.el&lt;/code&gt; フィールドに特別な意味を割り当てないことに注意してください。以前に &lt;code&gt;render()&lt;/code&gt; メソッドの &lt;code&gt;ref&lt;/code&gt; からこのフィールドを割り当てたため、機能します。</target>
        </trans-unit>
        <trans-unit id="47b82595a068571374ab58a7ca07015bf588a435" translate="yes" xml:space="preserve">
          <source>Note that React may still need to render that specific component again before bailing out. That shouldn&amp;rsquo;t be a concern because React won&amp;rsquo;t unnecessarily go &amp;ldquo;deeper&amp;rdquo; into the tree. If you&amp;rsquo;re doing expensive calculations while rendering, you can optimize them with &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="translated">Reactは、救済する前に、その特定のコンポーネントを再度レンダリングする必要があることに注意してください。Reactが不必要にツリーに「深く」入り込むことはないため、これは問題になりません。レンダリング中に高額な計算を行う場合は、 &lt;code&gt;useMemo&lt;/code&gt; を使用して最適化できます。</target>
        </trans-unit>
        <trans-unit id="20548fe21065f678631f41f93e7e5b0293cf3638" translate="yes" xml:space="preserve">
          <source>Note that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the rendered React elements, and for C2&amp;rsquo;s subtree and C7, it didn&amp;rsquo;t even have to compare the elements as we bailed out on &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and &lt;code&gt;render&lt;/code&gt; was not called.</source>
          <target state="translated">ReactはC6に対してDOM変異を行うだけでよいことに注意してください。これは不可避でした。C8の場合は、レンダリングされたReact要素を比較することで救済され、C2のサブツリーとC7の場合は、 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; で救済されたために要素を比較 &lt;code&gt;render&lt;/code&gt; もなく、renderは呼び出されませんでした。</target>
        </trans-unit>
        <trans-unit id="cd5e25e3c06e2e0a9f837231ef8545ceec20aa21" translate="yes" xml:space="preserve">
          <source>Note that a HOC doesn&amp;rsquo;t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC &lt;em&gt;composes&lt;/em&gt; the original component by &lt;em&gt;wrapping&lt;/em&gt; it in a container component. A HOC is a pure function with zero side-effects.</source>
          <target state="translated">HOCは入力コンポーネントを変更せず、その動作をコピーするために継承を使用しないことに注意してください。むしろ、A HOC &lt;em&gt;構成する&lt;/em&gt;ことにより、元のコンポーネント&lt;em&gt;包装&lt;/em&gt;コンテナコンポーネントでそれを。HOCは、副作用のない純粋な関数です。</target>
        </trans-unit>
        <trans-unit id="b0e7b7a2953e10e5ee351f37db62af70ce535d29" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;aria-*&lt;/code&gt; HTML attributes are fully supported in JSX. Whereas most DOM properties and attributes in React are camelCased, these attributes should be hyphen-cased (also known as kebab-case, lisp-case, etc) as they are in plain HTML:</source>
          <target state="translated">JSXでは、すべての &lt;code&gt;aria-*&lt;/code&gt; HTML属性が完全にサポートされていることに注意してください。ReactのほとんどのDOMプロパティと属性はcamelCasedですが、これらの属性はプレーンHTMLにあるため、ハイフン（大文字、小文字、lispケースなどとも呼ばれます）で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="7624acea1a9c060576a9f15d678ecc769a9b76e6" translate="yes" xml:space="preserve">
          <source>Note that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes.</source>
          <target state="translated">親コンポーネントによってコンポーネントが再レンダリングされる場合、propsが変更されていなくてもこのメソッドが呼び出されることに注意してください。変更のみを処理したい場合は、現在の値と次の値を比較するようにしてください。</target>
        </trans-unit>
        <trans-unit id="c974944cb18d8a4b4d98d26cf2d4b75e73525b1b" translate="yes" xml:space="preserve">
          <source>Note that in the above example we &lt;strong&gt;need&lt;/strong&gt; to keep the function in the dependencies list. This ensures that a change in the &lt;code&gt;productId&lt;/code&gt; prop of &lt;code&gt;ProductPage&lt;/code&gt; automatically triggers a refetch in the &lt;code&gt;ProductDetails&lt;/code&gt; component.</source>
          <target state="translated">上記の例では、関数を依存関係リストに保持する&lt;strong&gt;必要&lt;/strong&gt;があることに注意してください。これにより、 &lt;code&gt;productId&lt;/code&gt; 変更されると、 &lt;code&gt;ProductDetails&lt;/code&gt; コンポーネントの &lt;code&gt;ProductPage&lt;/code&gt; 自動的にトリガーされます。</target>
        </trans-unit>
        <trans-unit id="15064b1b66df67d34d5a232d98bfeba9ea33bea0" translate="yes" xml:space="preserve">
          <source>Note that rendering &lt;code&gt;lazy&lt;/code&gt; components requires that there&amp;rsquo;s a &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; component higher in the rendering tree. This is how you specify a loading indicator.</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; コンポーネントをレンダリングするには、レンダリングツリーの上位に &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; コンポーネントが存在する必要があることに注意してください。これは、ローディングインジケーターを指定する方法です。</target>
        </trans-unit>
        <trans-unit id="bca9869270c610c84eca37a4188271b709cfb625" translate="yes" xml:space="preserve">
          <source>Note that styles are not autoprefixed. To support older browsers, you need to supply corresponding style properties:</source>
          <target state="translated">スタイルは自動接頭辞ではないことに注意してください。古いブラウザをサポートするには、対応するスタイルのプロパティを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="067b30a981f559502026a96e0fc3941571707473" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;read()&lt;/code&gt; call in this example doesn&amp;rsquo;t &lt;em&gt;start&lt;/em&gt; fetching. It only tries to read the data that is &lt;strong&gt;already being fetched&lt;/strong&gt;. This difference is crucial to creating fast applications with Suspense. We don&amp;rsquo;t want to delay loading data until a component starts rendering. As a data fetching library author, you can enforce this by making it impossible to get a &lt;code&gt;resource&lt;/code&gt; object without also starting a fetch. Every demo on this page using our &amp;ldquo;fake API&amp;rdquo; enforces this.</source>
          <target state="translated">この例の &lt;code&gt;read()&lt;/code&gt; 呼び出しはフェッチを&lt;em&gt;開始&lt;/em&gt;しないことに注意してください。&lt;strong&gt;すでにフェッチされている&lt;/strong&gt;データの読み取りのみを試み&lt;strong&gt;ます&lt;/strong&gt;。この違いは、Suspenseで高速アプリケーションを作成するために重要です。コンポーネントがレンダリングを開始するまでデータの読み込みを遅らせたくありません。データフェッチライブラリの作成者は、フェッチを開始しないと &lt;code&gt;resource&lt;/code&gt; オブジェクトを取得できないようにすることで、これを強制できます。 「偽のAPI」を使用するこのページのすべてのデモは、これを実施します。</target>
        </trans-unit>
        <trans-unit id="dd2a771e4fad07ffb446c282efadcd2888cbe8e6" translate="yes" xml:space="preserve">
          <source>Note that the Coconut option is initially selected, because of the &lt;code&gt;selected&lt;/code&gt; attribute. React, instead of using this &lt;code&gt;selected&lt;/code&gt; attribute, uses a &lt;code&gt;value&lt;/code&gt; attribute on the root &lt;code&gt;select&lt;/code&gt; tag. This is more convenient in a controlled component because you only need to update it in one place. For example:</source>
          <target state="translated">&lt;code&gt;selected&lt;/code&gt; 属性のため、最初にCoconutオプションが選択されていることに注意してください。Reactは、この &lt;code&gt;selected&lt;/code&gt; 属性を使用する代わりに、ルート &lt;code&gt;select&lt;/code&gt; タグの &lt;code&gt;value&lt;/code&gt; 属性を使用します。これは、1つの場所で更新するだけでよいため、制御されたコンポーネントではより便利です。例えば：</target>
        </trans-unit>
        <trans-unit id="d5999130fbdfde82a85986a35fe0795798389c68" translate="yes" xml:space="preserve">
          <source>Note that the above example is demonstrating regular JavaScript behavior and doesn&amp;rsquo;t use error boundaries.</source>
          <target state="translated">上記の例は通常のJavaScriptの動作を示しており、エラー境界を使用していないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="61cff9e21e25a4670560f3ba3575f47b51bc9f0f" translate="yes" xml:space="preserve">
          <source>Note that the button doesn&amp;rsquo;t care &lt;em&gt;what&lt;/em&gt; state we&amp;rsquo;re updating. It&amp;rsquo;s wrapping &lt;em&gt;any&lt;/em&gt; state updates that happen during its &lt;code&gt;onClick&lt;/code&gt; handler into a transition. Now that our &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; takes care of setting up the transition, the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component doesn&amp;rsquo;t need to set up its own:</source>
          <target state="translated">ボタンは気にしないことに注意してください&lt;em&gt;どのような&lt;/em&gt;私たちです更新述べます。これは、 &lt;code&gt;onClick&lt;/code&gt; ハンドラー中に発生&lt;em&gt;する&lt;/em&gt;状態の更新を遷移にラップし&lt;em&gt;ます&lt;/em&gt;。今、私たちのことを &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; トランジションを設定するの面倒を、 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; コンポーネントは、独自に設定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="23b6882327e1c317b3769b724af427c65f26d7de" translate="yes" xml:space="preserve">
          <source>Note that this approach won&amp;rsquo;t work in a loop because Hook calls &lt;a href=&quot;hooks-rules&quot;&gt;can&amp;rsquo;t&lt;/a&gt; be placed inside loops. But you can extract a separate component for the list item, and call &lt;code&gt;useMemo&lt;/code&gt; there.</source>
          <target state="translated">フック呼び出し&lt;a href=&quot;hooks-rules&quot;&gt;は&lt;/a&gt;ループ内に配置できないため、このアプローチはループでは機能しないことに注意してください。ただし、リスト項目の個別のコンポーネントを抽出し、そこで &lt;code&gt;useMemo&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="d3bb49079ffd95590ce09e3d67d7befe22d9e2ab" translate="yes" xml:space="preserve">
          <source>Note that this example is not meant to be exhaustive with regards to working with Backbone, but it should give you an idea for how to approach this in a generic way:</source>
          <target state="translated">この例は、Backboneでの作業に関して網羅的なものではありませんが、一般的な方法でこれにどのようにアプローチするかのアイデアを与えてくれるはずです。</target>
        </trans-unit>
        <trans-unit id="c41ae3592459d184c8cfe8a8c9a865858f7f5834" translate="yes" xml:space="preserve">
          <source>Note that this method is fired on &lt;em&gt;every&lt;/em&gt; render, regardless of the cause. This is in contrast to &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;, which only fires when the parent causes a re-render and not as a result of a local &lt;code&gt;setState&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、原因に関係なく、&lt;em&gt;すべての&lt;/em&gt;レンダリングで発生することに注意してください。これは &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt; とは対照的です。UNSAFE_componentWillReceivePropsは、ローカルの &lt;code&gt;setState&lt;/code&gt; の結果としてではなく、親が再レンダリングを引き起こしたときにのみ起動します。</target>
        </trans-unit>
        <trans-unit id="293936fb383c744f2f9630271a7efb4989979625" translate="yes" xml:space="preserve">
          <source>Note that this only works if &lt;code&gt;CustomTextInput&lt;/code&gt; is declared as a class:</source>
          <target state="translated">これは、 &lt;code&gt;CustomTextInput&lt;/code&gt; がクラスとして宣言されている場合にのみ機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="d6de8667681c14632896b78b9f59b00902732f9a" translate="yes" xml:space="preserve">
          <source>Note that we defined both &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt;. Many jQuery plugins attach event listeners to the DOM so it&amp;rsquo;s important to detach them in &lt;code&gt;componentWillUnmount&lt;/code&gt;. If the plugin does not provide a method for cleanup, you will probably have to provide your own, remembering to remove any event listeners the plugin registered to prevent memory leaks.</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; と &lt;code&gt;componentWillUnmount&lt;/code&gt; の両方の&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;ライフサイクルメソッド&lt;/a&gt;を定義したことに注意してください。多くのjQueryプラグインはイベントリスナーをDOMにアタッチするため、それらを &lt;code&gt;componentWillUnmount&lt;/code&gt; でデタッチすることが重要です。プラグインがクリーンアップの方法を提供しない場合、おそらくメモリリークを防ぐためにプラグインが登録したイベントリスナーを削除することを忘れずに、独自の方法を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e7bd878200c78bd50ee3d98b684ecb341171678" translate="yes" xml:space="preserve">
          <source>Note that we pass &lt;code&gt;[]&lt;/code&gt; as a dependency array to &lt;code&gt;useCallback&lt;/code&gt;. This ensures that our ref callback doesn&amp;rsquo;t change between the re-renders, and so React won&amp;rsquo;t call it unnecessarily.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; を依存配列として &lt;code&gt;useCallback&lt;/code&gt; に渡すことに注意してください。これにより、refコールバックが再レンダリング間で変更されないことが保証されるため、Reactが不必要にそれを呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="f3da62d793b8e6e725893da6d74020b9b0c1d282" translate="yes" xml:space="preserve">
          <source>Note that you can still choose whether to pass the application &lt;em&gt;state&lt;/em&gt; down as props (more explicit) or as context (more convenient for very deep updates). If you use context to pass down the state too, use two different context types &amp;mdash; the &lt;code&gt;dispatch&lt;/code&gt; context never changes, so components that read it don&amp;rsquo;t need to rerender unless they also need the application state.</source>
          <target state="translated">アプリケーションの&lt;em&gt;状態&lt;/em&gt;を小道具（より明示的）として渡すか、コンテキスト（非常に深い更新に便利）として渡すかを選択できることに注意してください。コンテキストを使用して状態を渡す場合も、2つの異なるコンテキストタイプを使用します。 &lt;code&gt;dispatch&lt;/code&gt; コンテキストは変更されないため、それを読み取るコンポーネントは、アプリケーションの状態も必要としない限り、再レンダリングする必要はありません。</target>
        </trans-unit>
        <trans-unit id="5438c62ee57f24fd4d0711d668e74ee64c6002c5" translate="yes" xml:space="preserve">
          <source>Note that you cannot call &lt;code&gt;this.setState()&lt;/code&gt; here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; returns.</source>
          <target state="translated">ここでは &lt;code&gt;this.setState()&lt;/code&gt; を呼び出せないことに注意してください。 &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; が戻る前にReactコンポーネントへの更新をトリガーするような他のこと（Reduxアクションをディスパッチするなど）もしないでください。</target>
        </trans-unit>
        <trans-unit id="9bcdc977b06fb5be1faf45e2966b7781759aee94" translate="yes" xml:space="preserve">
          <source>Note there are other statically typed languages that compile to JavaScript and are thus React compatible. For example, &lt;a href=&quot;https://fable.io/&quot;&gt;F#/Fable&lt;/a&gt; with &lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react&lt;/a&gt;. Check out their respective sites for more information, and feel free to add more statically typed languages that work with React to this page!</source>
          <target state="translated">JavaScriptにコンパイルされるため、Reactと互換性のある静的型付き言語が他にもあることに注意してください。たとえば、&lt;a href=&quot;https://fable.io/&quot;&gt;F＃/ Fable&lt;/a&gt;と&lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react&lt;/a&gt;。詳細については、それぞれのサイトを確認してください。また、Reactで動作する静的に型付けされた言語をこのページに自由に追加してください。</target>
        </trans-unit>
        <trans-unit id="04e9b4dc0a682c919374be737463c7b46bbd33ef" translate="yes" xml:space="preserve">
          <source>Note we passed a configuration object to &lt;code&gt;useTransition&lt;/code&gt;. Its &lt;code&gt;timeoutMs&lt;/code&gt; property specifies &lt;strong&gt;how long we&amp;rsquo;re willing to wait for the transition to finish&lt;/strong&gt;. By passing &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt;, we say &amp;ldquo;If the next profile takes more than 3 seconds to load, show the big spinner &amp;mdash; but before that timeout it&amp;rsquo;s okay to keep showing the previous screen&amp;rdquo;.</source>
          <target state="translated">設定オブジェクトを &lt;code&gt;useTransition&lt;/code&gt; に渡したことに注意してください。その &lt;code&gt;timeoutMs&lt;/code&gt; プロパティ&lt;strong&gt;は、遷移が終了するまで待機する時間を&lt;/strong&gt;指定し&lt;strong&gt;ます&lt;/strong&gt;。 &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; を渡すことで、「次のプロファイルの読み込みに3秒以上かかる場合、大きなスピナーを表示します。ただし、タイムアウトする前に、前の画面を表示し続けても問題ありません」と言います。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="3d0510089477e2c3202ca52ed149fc2903a72e31" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; と &lt;code&gt;componentWillUnmount&lt;/code&gt; が互いにミラーリングする必要があることに注意してください。ライフサイクルメソッドでは、概念的には両方のコードが同じ効果に関連している場合でも、このロジックを分割する必要があります。</target>
        </trans-unit>
        <trans-unit id="87bf57ef650f61bb6153e8d1ccb5545722813ea9" translate="yes" xml:space="preserve">
          <source>Notice how we wrapped &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; in an extra &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. This is necessary because Chosen will append another DOM element right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node we passed to it. However, as far as React is concerned, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; always only has a single child. This is how we ensure that React updates won&amp;rsquo;t conflict with the extra DOM node appended by Chosen. It is important that if you modify the DOM outside of React flow, you must ensure React doesn&amp;rsquo;t have a reason to touch those DOM nodes.</source>
          <target state="translated">&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; を追加の &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; で囲んだことに注目してください。これは、Chosenが渡した &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; ノードの直後に別のDOM要素を追加するために必要です。ただし、Reactに関する限り、 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; には常に単一の子しかありません。これは、Reactの更新がChosenによって追加された追加のDOMノードと競合しないようにする方法です。Reactフロー外でDOMを変更する場合は、ReactがそれらのDOMノードに触れる理由がないことを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="f4059c045862b5d2fc7b27115084fa8f80b3c32e" translate="yes" xml:space="preserve">
          <source>Notice how when you type into the input, the &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; component suspends, and we see the &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; fallback until we get fresh results. This is not ideal. It would be better if we could see the &lt;em&gt;previous&lt;/em&gt; translation for a bit while we&amp;rsquo;re fetching the next one.</source>
          <target state="translated">入力を入力すると、 &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; コンポーネントが一時停止し、新しい結果が得られるまで &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; フォールバックが表示されることに注意してください。これは理想的ではありません。次の翻訳をフェッチしている間、&lt;em&gt;前の&lt;/em&gt;翻訳を少しの間見ることができれば、より良いでしょう。</target>
        </trans-unit>
        <trans-unit id="e41a0eb10d6b00e47a2107e31a6fe602367acaa9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;this.state.value&lt;/code&gt; is initialized in the constructor, so that the text area starts off with some text in it.</source>
          <target state="translated">ことに注意してください &lt;code&gt;this.state.value&lt;/code&gt; は、コンストラクタで初期化されるので、そのテキストエリアは、その中にいくつかのテキストで始まります。</target>
        </trans-unit>
        <trans-unit id="c48101c52bcbacc9cc53778eb2bf3edb99dccc8c" translate="yes" xml:space="preserve">
          <source>Notifying the user of errors</source>
          <target state="translated">エラーの通知</target>
        </trans-unit>
        <trans-unit id="c404d41fa7846adb181731741a44bd59410207d8" translate="yes" xml:space="preserve">
          <source>Now React knows that the element with key &lt;code&gt;'2014'&lt;/code&gt; is the new one, and the elements with the keys &lt;code&gt;'2015'&lt;/code&gt; and &lt;code&gt;'2016'&lt;/code&gt; have just moved.</source>
          <target state="translated">これでReact は、キー &lt;code&gt;'2014'&lt;/code&gt; の要素が新しい要素であり、キー &lt;code&gt;'2015'&lt;/code&gt; と &lt;code&gt;'2016'&lt;/code&gt; の要素が移動したことを認識しました。</target>
        </trans-unit>
        <trans-unit id="a823d334901d2890efe56f8ef0b2a72eeceac120" translate="yes" xml:space="preserve">
          <source>Now consider the version of this component that uses Hooks:</source>
          <target state="translated">次に、フックを使用するこのコンポーネントのバージョンを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="8183f56b4559e51b16e97bdcb7a1243573a8bd1d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say that our chat application also has a contact list, and we want to render names of online users with a green color. We could copy and paste similar logic above into our &lt;code&gt;FriendListItem&lt;/code&gt; component but it wouldn&amp;rsquo;t be ideal:</source>
          <target state="translated">ここで、チャットアプリケーションにも連絡先リストがあり、オンラインユーザーの名前を緑色で表示するとします。上記の同様のロジックを &lt;code&gt;FriendListItem&lt;/code&gt; コンポーネントにコピーして貼り付けることもできますが、理想的ではありません。</target>
        </trans-unit>
        <trans-unit id="925974ac4f4434d5e39f807c69d3762bcfdfc9e3" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say we want to write some logic that changes &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; when the user moves their mouse. Note how we have to merge these fields into the previous state object manually:</source>
          <target state="translated">ここで、ユーザーがマウスを動かすと &lt;code&gt;left&lt;/code&gt; と &lt;code&gt;top&lt;/code&gt; が変わるロジックを記述したいとします。これらのフィールドを以前の状態オブジェクトに手動でマージする方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="6e4daa5c187fd27dc1d98689209a36560e567ee5" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can do the same with the &lt;code&gt;useEffect&lt;/code&gt; Hook.</source>
          <target state="translated">次に、 &lt;code&gt;useEffect&lt;/code&gt; フックを使用して同じことを行う方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3f0c36b18073d97246d1ae6fdd941d78bd84aa02" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can use our custom Hook.</source>
          <target state="translated">次に、カスタムフックの使用方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4ff24b1ed7e4290e5868df543207689b4f4b743a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s turn to the &lt;code&gt;Calculator&lt;/code&gt; component.</source>
          <target state="translated">それでは、 &lt;code&gt;Calculator&lt;/code&gt; コンポーネントを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="844b2d5f9df9b2eb6e433eb964cbaab4370de078" translate="yes" xml:space="preserve">
          <source>Now that we know more about effects, these lines should make sense:</source>
          <target state="translated">今では、効果についての詳細がわかっているので、これらのラインは意味があるはずです。</target>
        </trans-unit>
        <trans-unit id="9b0970d0ace9e4ccf49f5bb229273af5230ad8a4" translate="yes" xml:space="preserve">
          <source>Now that we know what the &lt;code&gt;useState&lt;/code&gt; Hook does, our example should make more sense:</source>
          <target state="translated">これで、 &lt;code&gt;useState&lt;/code&gt; フックが何を行うかがわかったので、次の例はもっと理解できるはずです。</target>
        </trans-unit>
        <trans-unit id="8a8788b2f194e8402d2a42fc02e179198bb60d53" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted this logic to a &lt;code&gt;useFriendStatus&lt;/code&gt; hook, we can &lt;em&gt;just use it:&lt;/em&gt;</source>
          <target state="translated">このロジックを &lt;code&gt;useFriendStatus&lt;/code&gt; フックに抽出したので、次のよう&lt;em&gt;に使用&lt;/em&gt;でき&lt;em&gt;ます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ad30db96883edc2b1c98cb238c68962796e03d5" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve identified the components in our mock, let&amp;rsquo;s arrange them into a hierarchy. Components that appear within another component in the mock should appear as a child in the hierarchy:</source>
          <target state="translated">モック内のコンポーネントを特定したので、それらを階層に配置してみましょう。モック内の別のコンポーネント内に表示されるコンポーネントは、階層内の子として表示されます。</target>
        </trans-unit>
        <trans-unit id="5fb8a97af0340e1169bfb8c33de464ee1f6338c0" translate="yes" xml:space="preserve">
          <source>Now that you have your component hierarchy, it&amp;rsquo;s time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It&amp;rsquo;s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We&amp;rsquo;ll see why.</source>
          <target state="translated">これでコンポーネント階層ができたので、今度はアプリを実装します。最も簡単な方法は、データモデルを取得してUIをレンダリングするが、対話性がないバージョンを構築することです。静的なバージョンを構築するには多くのタイピングが必要であり、何も考える必要がないため、これらのプロセスを分離するのが最善です。インタラクティブ機能を追加するには、多くのタイピングではなく、多くの考えが必要です。その理由を見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="48ab459928ce6ebd5489677a0e93ec9929ee70a3" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component encapsulates all behavior associated with listening for &lt;code&gt;mousemove&lt;/code&gt; events and storing the (x, y) position of the cursor, but it&amp;rsquo;s not yet truly reusable.</source>
          <target state="translated">現在、 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; コンポーネントは、 &lt;code&gt;mousemove&lt;/code&gt; イベントの待機とカーソルの（x、y）位置の格納に関連するすべての動作をカプセル化していますが、まだ真に再利用可能ではありません。</target>
        </trans-unit>
        <trans-unit id="8290d2b0cd763be0c1cff68b5b8f6a2022e9e2e1" translate="yes" xml:space="preserve">
          <source>Now the clock ticks every second.</source>
          <target state="translated">今や時計は1秒ごとに時を刻んでいる。</target>
        </trans-unit>
        <trans-unit id="445b4c42d80c61abe526efe3707111a846581295" translate="yes" xml:space="preserve">
          <source>Now the question is: How can we reuse this behavior in another component? In other words, if another component needs to know about the cursor position, can we encapsulate that behavior so that we can easily share it with that component?</source>
          <target state="translated">この動作を他のコンポーネントで再利用するにはどうすればよいか?言い換えれば、他のコンポーネントがカーソルの位置を知る必要がある場合、その動作をカプセル化して、そのコンポーネントと簡単に共有できるようにすることができるでしょうか?</target>
        </trans-unit>
        <trans-unit id="1024ae8f19583bac76078bc0bd6540db20a2ec73" translate="yes" xml:space="preserve">
          <source>Now the subscription will only be recreated when &lt;code&gt;props.source&lt;/code&gt; changes.</source>
          <target state="translated">これで、サブスクリプションは &lt;code&gt;props.source&lt;/code&gt; が変更されたときにのみ再作成されます。</target>
        </trans-unit>
        <trans-unit id="54d03c366729e2d81c1e64f36f6b07756f996b09" translate="yes" xml:space="preserve">
          <source>Now typing has a lot less stutter &amp;mdash; although we pay for this by showing the results with a lag.</source>
          <target state="translated">これでタイピングのスタッターが大幅に減少しました。ただし、ラグを付けて結果を表示することでこれを支払います。</target>
        </trans-unit>
        <trans-unit id="dcc5b4606d16f6fd9f79e37463ac776146ee84f2" translate="yes" xml:space="preserve">
          <source>Now we can use it from both components:</source>
          <target state="translated">これで両方のコンポーネントから使えるようになりました。</target>
        </trans-unit>
        <trans-unit id="1eb51804f6cb1c7460d60f186cd080f9b9a70bf5" translate="yes" xml:space="preserve">
          <source>Now we could use it in our component, and let the reducer drive its state management:</source>
          <target state="translated">これをコンポーネントで使用し、レデューサに状態管理をさせることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="4fe952474b56ef3cb4e5c17adcf45971d3250970" translate="yes" xml:space="preserve">
          <source>Now you can use JSX in any &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag by adding &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attribute to it. Here is &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;an example HTML file with JSX&lt;/a&gt; that you can download and play with.</source>
          <target state="translated">これで、 &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; 属性を追加することにより、任意の &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグでJSXを使用できます。以下は&lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;、&lt;/a&gt;ダウンロードして使用できるJSXを含むHTMLファイルの例です。</target>
        </trans-unit>
        <trans-unit id="8ad6204428141993d5d0c80a5aa20caa71f41e56" translate="yes" xml:space="preserve">
          <source>Now you know what Concurrent Mode is all about!</source>
          <target state="translated">これでコンカレントモードの意味がわかりましたね!</target>
        </trans-unit>
        <trans-unit id="a0921c0c4a9937c51a84cd82cfb41ca7387c23e1" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;re all set! We recommend to check out the following resources to learn more about Flow:</source>
          <target state="translated">これで準備は完了です。フローの詳細については、次のリソースを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8a49e11731f8fb793b2ecb4306067e3e3083ea67" translate="yes" xml:space="preserve">
          <source>Now, add &lt;code&gt;flow&lt;/code&gt; to the &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; section of your &lt;code&gt;package.json&lt;/code&gt; to be able to use this from the terminal:</source>
          <target state="translated">次に、 &lt;code&gt;package.json&lt;/code&gt; の &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; セクションに &lt;code&gt;flow&lt;/code&gt; を追加して、ターミナルからこれを使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="c8086f34489af74ae217e4df5aa3be615d57812e" translate="yes" xml:space="preserve">
          <source>Now, instead of effectively cloning the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component and hard-coding something else in its &lt;code&gt;render&lt;/code&gt; method to solve for a specific use case, we provide a &lt;code&gt;render&lt;/code&gt; prop that &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; can use to dynamically determine what it renders.</source>
          <target state="translated">さて、代わりに効果的クローニングの &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; その内の他のコンポーネントとハードコーディング何か &lt;code&gt;render&lt;/code&gt; 、特定のユースケースのために解決する方法を、私たちは提供 &lt;code&gt;render&lt;/code&gt; という小道具を &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 動的にそれがレンダリングするかを決定するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="2f73936a74018552ceacc64aa326e02fb6cf0a5b" translate="yes" xml:space="preserve">
          <source>Now, no matter which input you edit, &lt;code&gt;this.state.temperature&lt;/code&gt; and &lt;code&gt;this.state.scale&lt;/code&gt; in the &lt;code&gt;Calculator&lt;/code&gt; get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it.</source>
          <target state="translated">これで、編集する入力に関係なく、 &lt;code&gt;Calculator&lt;/code&gt; &lt;code&gt;this.state.temperature&lt;/code&gt; と &lt;code&gt;this.state.scale&lt;/code&gt; が更新されます。入力の1つは値をそのまま取得するため、ユーザー入力は保持され、他の入力値は常にそれに基づいて再計算されます。</target>
        </trans-unit>
        <trans-unit id="301eea1e7c8206fb45c541acd3e524bf4a699d97" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;setInterval&lt;/code&gt; callback executes once a second, but each time the inner call to &lt;code&gt;setCount&lt;/code&gt; can use an up-to-date value for &lt;code&gt;count&lt;/code&gt; (called &lt;code&gt;c&lt;/code&gt; in the callback here.)</source>
          <target state="translated">これで、 &lt;code&gt;setInterval&lt;/code&gt; コールバックは1秒に1回実行されますが、 &lt;code&gt;setCount&lt;/code&gt; への内部呼び出しで &lt;code&gt;count&lt;/code&gt; に最新の値を使用できます（ここでは、コールバックでは &lt;code&gt;c&lt;/code&gt; と呼びます）。</target>
        </trans-unit>
        <trans-unit id="9e8130cbd3e360ebc980c05ecf896eace815977b" translate="yes" xml:space="preserve">
          <source>Now, this feels a lot better! When we click Next, it gets disabled because clicking it multiple times doesn&amp;rsquo;t make sense. And the new &amp;ldquo;Loading&amp;hellip;&amp;rdquo; tells the user that the app didn&amp;rsquo;t freeze.</source>
          <target state="translated">さて、これはずっと気分が良いです！[次へ]をクリックすると、複数回クリックしても意味がないため、無効になります。また、新しい「読み込み中...」は、アプリがフリーズしなかったことをユーザーに通知します。</target>
        </trans-unit>
        <trans-unit id="b0f788b2b09588e404d0447b39bd5c7c761184f0" translate="yes" xml:space="preserve">
          <source>Now, when the &lt;code&gt;TemperatureInput&lt;/code&gt; wants to update its temperature, it calls &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt;:</source>
          <target state="translated">これで、 &lt;code&gt;TemperatureInput&lt;/code&gt; が温度を更新する必要がある場合、 &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="7e7446f170a663a7c78e802aab1ac1a7cb9040dd" translate="yes" xml:space="preserve">
          <source>OK, so we&amp;rsquo;ve identified what the minimal set of app state is. Next, we need to identify which component mutates, or &lt;em&gt;owns&lt;/em&gt;, this state.</source>
          <target state="translated">OK、これでアプリの状態の最小セットが何であるかがわかりました。次に、この状態を変更または&lt;em&gt;所有する&lt;/em&gt;コンポーネントを特定する必要があります。</target>
        </trans-unit>
        <trans-unit id="585a7418eed63f477ec8bd53089988cc7e4a12c6" translate="yes" xml:space="preserve">
          <source>Of course, application UIs are dynamic and change over time. In the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next section&lt;/a&gt;, we will introduce a new concept of &amp;ldquo;state&amp;rdquo;. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</source>
          <target state="translated">もちろん、アプリケーションUIは動的であり、時間とともに変化します。では&lt;a href=&quot;state-and-lifecycle&quot;&gt;次のセクションで&lt;/a&gt;、私たちは、「状態」の新しい概念を紹介します。Stateにより、Reactコンポーネントは、このルールに違反することなく、ユーザーアクション、ネットワークレスポンスなどに応じて、時間の経過とともに出力を変更できます。</target>
        </trans-unit>
        <trans-unit id="3132cb0b79eb69074dc3e62af86660efd5589630" translate="yes" xml:space="preserve">
          <source>Of course, this is possible to fix in this particular example. We could remove the &lt;code&gt;Promise.all()&lt;/code&gt; call, and wait for both Promises separately. However, this approach gets progressively more difficult as the complexity of our data and component tree grows. It&amp;rsquo;s hard to write reliable components when arbitrary parts of the data tree may be missing or stale. So fetching all data for the new screen and &lt;em&gt;then&lt;/em&gt; rendering is often a more practical option.</source>
          <target state="translated">もちろん、これはこの特定の例で修正することが可能です。 &lt;code&gt;Promise.all()&lt;/code&gt; 呼び出しを削除して、両方のPromiseを個別に待つことができます。ただし、データとコンポーネントツリーの複雑さが増すにつれて、このアプローチは次第に難しくなります。データツリーの任意の部分が欠落しているか古くなっている可能性がある場合、信頼性の高いコンポーネントを記述することは困難です。そのため、新しい画面のすべてのデータをフェッチして&lt;em&gt;から&lt;/em&gt;レンダリングする方が実際的なオプションです。</target>
        </trans-unit>
        <trans-unit id="a4a2711c46e947081b52625c85320ddf4541e19b" translate="yes" xml:space="preserve">
          <source>Of course, two versions of the tree rendering &lt;em&gt;at the same time&lt;/em&gt; is an illusion, just like the idea that all programs run on your computer at the same time is an illusion. An operating system switches between different applications very fast. Similarly, React can switch between the version of the tree you see on the screen and the version that it&amp;rsquo;s &amp;ldquo;preparing&amp;rdquo; to show next.</source>
          <target state="translated">もちろん、&lt;em&gt;同時に&lt;/em&gt; 2つのバージョンのツリーレンダリングは幻想です。これは、すべてのプログラムが同時にコンピューター上で実行されるというのは幻想であるのと同じです。オペレーティングシステムは、さまざまなアプリケーションを非常に高速に切り替えます。同様に、Reactは画面に表示されるツリーのバージョンと、次に表示するために「準備中」のバージョンを切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="4d6825e0a32d926930eddf56f84b2970fa58fb08" translate="yes" xml:space="preserve">
          <source>Of the many options, we&amp;rsquo;ll look at &lt;code&gt;rootDir&lt;/code&gt; and &lt;code&gt;outDir&lt;/code&gt;. In its true fashion, the compiler will take in typescript files and generate javascript files. However we don&amp;rsquo;t want to get confused with our source files and the generated output.</source>
          <target state="translated">多くのオプションのうち、 &lt;code&gt;rootDir&lt;/code&gt; と &lt;code&gt;outDir&lt;/code&gt; を見ていきます。本来の方法では、コンパイラーはtypescriptファイルを取り込んでjavascriptファイルを生成します。ただし、ソースファイルと生成された出力と混同したくありません。</target>
        </trans-unit>
        <trans-unit id="dd20357e3644302dde97b2ad62dcb95ce1daedfd" translate="yes" xml:space="preserve">
          <source>Often, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to &lt;code&gt;useEffect&lt;/code&gt; may return a clean-up function. For example, to create a subscription:</source>
          <target state="translated">多くの場合、エフェクトは、サブスクリプションやタイマーIDなど、コンポーネントが画面を離れる前にクリーンアップする必要があるリソースを作成します。これを行うには、 &lt;code&gt;useEffect&lt;/code&gt; に渡された関数がクリーンアップ関数を返す場合があります。たとえば、サブスクリプションを作成するには：</target>
        </trans-unit>
        <trans-unit id="2eb2d11868ae24a92e334900c6ad022490e23cc8" translate="yes" xml:space="preserve">
          <source>Often, render props and higher-order components render only a single child. We think Hooks are a simpler way to serve this use case. There is still a place for both patterns (for example, a virtual scroller component might have a &lt;code&gt;renderItem&lt;/code&gt; prop, or a visual container component might have its own DOM structure). But in most cases, Hooks will be sufficient and can help reduce nesting in your tree.</source>
          <target state="translated">多くの場合、レンダープロップと高次コンポーネントは単一の子のみをレンダリングします。フックは、このユースケースに対応するためのより簡単な方法だと思います。まだ両方のパターンの場所があります（たとえば、仮想スクローラーコンポーネントに &lt;code&gt;renderItem&lt;/code&gt; プロップがあるか、ビジュアルコンテナーコンポーネントに独自のDOM構造がある場合があります）。しかし、ほとんどの場合、フックで十分であり、ツリーのネストを減らすのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="e238d62aafad5d06561c0c307e341349b7b49d0a" translate="yes" xml:space="preserve">
          <source>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let&amp;rsquo;s see how this works in action.</source>
          <target state="translated">多くの場合、いくつかのコンポーネントは同じ変化するデータを反映する必要があります。共有状態を最も近い共通の祖先まで上げることをお勧めします。これが実際にどのように機能するか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="2a50db4683ea185c93852b3e2a65a8212128837a" translate="yes" xml:space="preserve">
          <source>On Node.js, runners like Jest &lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;support mocking modules&lt;/a&gt;. You could also use libraries like &lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt;&lt;code&gt;mock-require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Node.jsでは、Jestのようなランナーが&lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;モッキングモジュールをサポートしています&lt;/a&gt;。&lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt; &lt;code&gt;mock-require&lt;/code&gt; の&lt;/a&gt;ようなライブラリを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="0710c7b04d45a11f0492b116459fb4abc9eedba3" translate="yes" xml:space="preserve">
          <source>On mount, add a change listener to &lt;code&gt;DataSource&lt;/code&gt;.</source>
          <target state="translated">マウント時に、変更リスナーを &lt;code&gt;DataSource&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="82c91bbc6306c5630c222b9dcf2187c2dc2ae099" translate="yes" xml:space="preserve">
          <source>On the next pages, you&amp;rsquo;ll learn more details about specific topics:</source>
          <target state="translated">次のページでは、特定のトピックに関する詳細を学習します。</target>
        </trans-unit>
        <trans-unit id="9d62e4f730620eef1f3de85e2d6c3131a9b4dfea" translate="yes" xml:space="preserve">
          <source>On this page we&amp;rsquo;ve learned about one of the Hooks provided by React, called &lt;code&gt;useState&lt;/code&gt;. We&amp;rsquo;re also sometimes going to refer to it as the &amp;ldquo;State Hook&amp;rdquo;. It lets us add local state to React function components &amp;mdash; which we did for the first time ever!</source>
          <target state="translated">このページでは、 &lt;code&gt;useState&lt;/code&gt; と呼ばれる、Reactが提供するフックの1つについて学びました。また、これを「状態フック」と呼ぶこともあります。これにより、React関数コンポーネントにローカル状態を追加できるようになりました&amp;mdash;これは初めてです！</target>
        </trans-unit>
        <trans-unit id="0c2cd7a4d0e65ff37df2b337e658e2df9075d64a" translate="yes" xml:space="preserve">
          <source>On this page, we don&amp;rsquo;t assume knowledge of Relay, so we won&amp;rsquo;t be using it for this example. Instead, we&amp;rsquo;ll write something similar manually by combining our data fetching methods:</source>
          <target state="translated">このページでは、Relayの知識を前提としていないため、この例では使用しません。代わりに、データフェッチメソッドを組み合わせて、同様の何かを手動で記述します。</target>
        </trans-unit>
        <trans-unit id="fb59abe30c04acfe966b6c95ce457faf73c79f0f" translate="yes" xml:space="preserve">
          <source>On this page, we will primarily use function components. However, these testing strategies don&amp;rsquo;t depend on implementation details, and work just as well for class components too.</source>
          <target state="translated">このページでは、主に関数コンポーネントを使用します。ただし、これらのテスト戦略は実装の詳細に依存せず、クラスコンポーネントに対しても同様に機能します。</target>
        </trans-unit>
        <trans-unit id="4d9354d5334212c4fa7c510917e4a36aa72a9176" translate="yes" xml:space="preserve">
          <source>On unmount, remove the change listener.</source>
          <target state="translated">アンマウント時に、変更リスナーを削除します。</target>
        </trans-unit>
        <trans-unit id="06dfbc05cf68b1af9ef7e3eb0c666319a41ff504" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re comfortable with the &lt;a href=&quot;index&quot;&gt;main concepts&lt;/a&gt; and played with React a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used React features like &lt;a href=&quot;context&quot;&gt;context&lt;/a&gt; and &lt;a href=&quot;refs-and-the-dom&quot;&gt;refs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;主な概念に&lt;/a&gt;慣れ、Reactを少し試してみると、より高度なトピックに興味を持つかもしれません。このセクションでは、&lt;a href=&quot;context&quot;&gt;コンテキスト&lt;/a&gt;や&lt;a href=&quot;refs-and-the-dom&quot;&gt;参照&lt;/a&gt;など、あまり使用されていない強力なReact機能を紹介します。</target>
        </trans-unit>
        <trans-unit id="26db98adea48b68a169ca2de0e843e2459313e88" translate="yes" xml:space="preserve">
          <source>One caveat is that some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;&amp;ldquo;falsy&amp;rdquo; values&lt;/a&gt;, such as the &lt;code&gt;0&lt;/code&gt; number, are still rendered by React. For example, this code will not behave as you might expect because &lt;code&gt;0&lt;/code&gt; will be printed when &lt;code&gt;props.messages&lt;/code&gt; is an empty array:</source>
          <target state="translated">注意点の1つは、 &lt;code&gt;0&lt;/code&gt; の数値など、一部の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;「偽の」値&lt;/a&gt;が依然としてReactによってレンダリングされることです。たとえば、 &lt;code&gt;props.messages&lt;/code&gt; が空の配列の場合は &lt;code&gt;0&lt;/code&gt; が出力されるため、このコードは期待どおりに動作しません。</target>
        </trans-unit>
        <trans-unit id="92d29f167487a4fbbd927e887cecef3d212e829f" translate="yes" xml:space="preserve">
          <source>One common confusion is that Web Components use &amp;ldquo;class&amp;rdquo; instead of &amp;ldquo;className&amp;rdquo;.</source>
          <target state="translated">よくある混乱の1つは、Webコンポーネントが「className」ではなく「class」を使用することです。</target>
        </trans-unit>
        <trans-unit id="d84c92ddc298e496ea4adc3bf91cf1363cd458a5" translate="yes" xml:space="preserve">
          <source>One common use case is a component wanting to update itself on a time interval. It&amp;rsquo;s easy to use &lt;code&gt;setInterval()&lt;/code&gt;, but it&amp;rsquo;s important to cancel your interval when you don&amp;rsquo;t need it anymore to save memory. React provides &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; that let you know when a component is about to be created or destroyed. Let&amp;rsquo;s create a simple mixin that uses these methods to provide an easy &lt;code&gt;setInterval()&lt;/code&gt; function that will automatically get cleaned up when your component is destroyed.</source>
          <target state="translated">一般的な使用例の1つは、一定の間隔で自分自身を更新したいコンポーネントです。 &lt;code&gt;setInterval()&lt;/code&gt; を使用するのは簡単ですが、メモリを節約するために不要になった場合は間隔をキャンセルすることが重要です。 Reactは、コンポーネントが作成または破棄されようとしているときに通知する&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;ライフサイクルメソッド&lt;/a&gt;を提供します。これらのメソッドを使用して、コンポーネントが破棄されたときに自動的にクリーンアップされる簡単な &lt;code&gt;setInterval()&lt;/code&gt; 関数を提供する単純なミックスインを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="91fca79071097d684ed292ccb8f4ce6e063eb595" translate="yes" xml:space="preserve">
          <source>One common way to structure projects is locate CSS, JS, and tests together inside folders grouped by feature or route.</source>
          <target state="translated">プロジェクトを構成する一般的な方法の一つは、CSS、JS、テストを機能やルートでグループ化したフォルダ内にまとめて配置することです。</target>
        </trans-unit>
        <trans-unit id="3294950b9d1114486b86edac639fe247ba41031e" translate="yes" xml:space="preserve">
          <source>One interesting thing to note about render props is that you can implement most &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (HOC) using a regular component with a render prop. For example, if you would prefer to have a &lt;code&gt;withMouse&lt;/code&gt; HOC instead of a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, you could easily create one using a regular &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a render prop:</source>
          <target state="translated">レンダープロップについて注目すべき1つの興味深い点は、レンダープロップを備えた通常のコンポーネントを使用して、ほとんどの&lt;a href=&quot;higher-order-components&quot;&gt;高次コンポーネント&lt;/a&gt;（HOC）を実装できることです。たとえば、 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; コンポーネントの代わりに &lt;code&gt;withMouse&lt;/code&gt; HOC を使用したい場合は、通常の &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; とレンダープロップを使用して簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="89bb7b23e1cfb796ff7ccb3c5631654a6d5d4429" translate="yes" xml:space="preserve">
          <source>One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. We will introduce components in the &lt;a href=&quot;components-and-props&quot;&gt;next section&lt;/a&gt;. Elements are what components are &amp;ldquo;made of&amp;rdquo;, and we encourage you to read this section before jumping ahead.</source>
          <target state="translated">要素を、より広く知られている「コンポーネント」の概念と混同するかもしれません。&lt;a href=&quot;components-and-props&quot;&gt;次のセクションで&lt;/a&gt;コンポーネントを紹介します。要素とは、コンポーネントを「構成」する要素であり、先に進む前にこのセクションを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="7588b233fbe6695c0a65bfe0ca7544cc4e57a4ac" translate="yes" xml:space="preserve">
          <source>One might think that this is a problem specific to &lt;code&gt;useEffect&lt;/code&gt; or Hooks. Maybe if we port this code to classes or use convenient syntax like &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;, it will solve the problem?</source>
          <target state="translated">これは、 &lt;code&gt;useEffect&lt;/code&gt; またはフックに固有の問題であると考えるかもしれません。このコードをクラスに移植したり、 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; などの便利な構文を使用したりすると、問題が解決するでしょうか？</target>
        </trans-unit>
        <trans-unit id="c0f348c5b745ab1da4b86972cf956fe2d397217e" translate="yes" xml:space="preserve">
          <source>One of the many great parts of React is how it makes you think about apps as you build them. In this document, we&amp;rsquo;ll walk you through the thought process of building a searchable product data table using React.</source>
          <target state="translated">Reactの多くの素晴らしい部分の1つは、アプリを作成するときにアプリについてどのように考えるかです。このドキュメントでは、Reactを使用して検索可能な製品データテーブルを作成する思考プロセスについて説明します。</target>
        </trans-unit>
        <trans-unit id="7ac2374e3473c6ff21b1231d986c7761ceb4980d" translate="yes" xml:space="preserve">
          <source>One of the problems we outlined in the &lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;Motivation&lt;/a&gt; for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:</source>
          <target state="translated">フックの&lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;動機&lt;/a&gt;で概説した問題の1つは、クラスのライフサイクルメソッドに関連のないロジックが含まれていることが多いが、関連するロジックがいくつかのメソッドに分割されることです。前の例のカウンターとフレンドステータスインジケーターロジックを組み合わせたコンポーネントを次に示します。</target>
        </trans-unit>
        <trans-unit id="a418baabb2a2970b5f712a2f3fec059c69ada5c1" translate="yes" xml:space="preserve">
          <source>One possible solution to this is to &lt;em&gt;delay the spinner itself&lt;/em&gt; from displaying:</source>
          <target state="translated">これに対する1つの可能な解決策は&lt;em&gt;、スピナー自体の&lt;/em&gt;表示を&lt;em&gt;遅らせること&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="b271b0f7d1b61e9056e53697bfa59e66ec53dabf" translate="yes" xml:space="preserve">
          <source>One rudimentary way to measure the position or size of a DOM node is to use a &lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;callback ref&lt;/a&gt;. React will call that callback whenever the ref gets attached to a different node. Here is a &lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;small demo&lt;/a&gt;:</source>
          <target state="translated">DOMノードの位置またはサイズを測定する基本的な方法の1つは、&lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;コールバックref&lt;/a&gt;を使用することです。refが別のノードにアタッチされると、Reactはそのコールバックを呼び出します。ここに&lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;小さなデモがあり&lt;/a&gt;ます：</target>
        </trans-unit>
        <trans-unit id="6fa8706f6009f63753c15a5df17eaaa0d7f204a0" translate="yes" xml:space="preserve">
          <source>One solution to this is to extract the model&amp;rsquo;s attributes as plain data whenever it changes, and keep this logic in a single place. The following is &lt;a href=&quot;higher-order-components&quot;&gt;a higher-order component&lt;/a&gt; that extracts all attributes of a Backbone model into state, passing the data to the wrapped component.</source>
          <target state="translated">これに対する1つの解決策は、モデルの属性が変更されるたびにプレーンデータとして抽出し、このロジックを1か所に保持することです。以下は&lt;a href=&quot;higher-order-components&quot;&gt;、&lt;/a&gt;バックボーンモデルのすべての属性を状態に抽出して、ラップされたコンポーネントにデータを渡す高次コンポーネントです。</target>
        </trans-unit>
        <trans-unit id="58b79eb7fa7ae8bb13eed6fa689b5ce8ed867366" translate="yes" xml:space="preserve">
          <source>One way to solve this issue &lt;strong&gt;without context&lt;/strong&gt; is to &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;pass down the &lt;code&gt;Avatar&lt;/code&gt; component itself&lt;/a&gt; so that the intermediate components don&amp;rsquo;t need to know about the &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;avatarSize&lt;/code&gt; props:</source>
          <target state="translated">&lt;strong&gt;コンテキストなしで&lt;/strong&gt;この問題を解決する1つの方法は、中間コンポーネントが &lt;code&gt;user&lt;/code&gt; または &lt;code&gt;avatarSize&lt;/code&gt; プロップについて知る必要がないように&lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;、 &lt;code&gt;Avatar&lt;/code&gt; コンポーネント自体&lt;/a&gt;を渡すことです。</target>
        </trans-unit>
        <trans-unit id="c6299e6ee53c4fc7bdfb602433272b7a519918fc" translate="yes" xml:space="preserve">
          <source>One way we could fix it is by putting them both in a single boundary:</source>
          <target state="translated">一つの方法としては、両方を一つの境界線にすることで解決することができます。</target>
        </trans-unit>
        <trans-unit id="c05b9709100b2a39470a0603a95728131ccfa2e0" translate="yes" xml:space="preserve">
          <source>Online Playgrounds</source>
          <target state="translated">オンラインの遊び場</target>
        </trans-unit>
        <trans-unit id="68c313b91ba43cdce9e6230021dd3cc44332356e" translate="yes" xml:space="preserve">
          <source>Only Call Hooks at the Top Level</source>
          <target state="translated">トップレベルのコールフックのみ</target>
        </trans-unit>
        <trans-unit id="980e73ef860f23909c36445661b606d8b3e93697" translate="yes" xml:space="preserve">
          <source>Only Call Hooks from React Functions</source>
          <target state="translated">React関数からフックを呼び出すだけ</target>
        </trans-unit>
        <trans-unit id="5acf9b36b7f149f65b12a00c58b688239df37660" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;at the top level&lt;/strong&gt;. Don&amp;rsquo;t call Hooks inside loops, conditions, or nested functions.</source>
          <target state="translated">&lt;strong&gt;トップレベルで&lt;/strong&gt;のみフック&lt;strong&gt;を&lt;/strong&gt;呼び出し&lt;strong&gt;ます&lt;/strong&gt;。ループ、条件、またはネストされた関数内でフックを呼び出さないでください。</target>
        </trans-unit>
        <trans-unit id="c8bacc2bc0cd7f69fa0df071e2e600234a8896fe" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;from React function components&lt;/strong&gt;. Don&amp;rsquo;t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks &amp;mdash; your own custom Hooks. We&amp;rsquo;ll learn about them in a moment.)</source>
          <target state="translated">&lt;strong&gt;React関数コンポーネントからのみ&lt;/strong&gt;フック&lt;strong&gt;を&lt;/strong&gt;呼び出し&lt;strong&gt;ます&lt;/strong&gt;。通常のJavaScript関数からフックを呼び出さないでください。（フックを呼び出すための有効な場所は他に1つだけあります&amp;mdash;独自のカスタムフックです。それらについてはすぐに説明します。）</target>
        </trans-unit>
        <trans-unit id="78f87a20c05bef10c0fc20bc0609245bc0128bed" translate="yes" xml:space="preserve">
          <source>Only do this if you couldn&amp;rsquo;t find a better alternative, as relying on mutation makes components less predictable. If there&amp;rsquo;s a specific pattern that doesn&amp;rsquo;t translate well, &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;file an issue&lt;/a&gt; with a runnable example code and we can try to help.</source>
          <target state="translated">ミューテーションに依存するとコンポーネントの予測性が低下するため、より良い代替案が見つからない場合にのみ、これを実行してください。うまく翻訳できない特定のパターンがある場合は、実行可能なサンプルコードを&lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;使用して問題&lt;/a&gt;を報告してください。</target>
        </trans-unit>
        <trans-unit id="c28575a6029fc70e57860e000b695cc6f0b3e57e" translate="yes" xml:space="preserve">
          <source>Only ever use CSS that removes this outline, for example by setting &lt;code&gt;outline: 0&lt;/code&gt;, if you are replacing it with another focus outline implementation.</source>
          <target state="translated">このアウトラインを削除するCSSは、たとえば、 &lt;code&gt;outline: 0&lt;/code&gt; 設定して、別のフォーカスアウトライン実装に置き換える場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="7322dbc7cc37c39174edd21f985b523446462851" translate="yes" xml:space="preserve">
          <source>Only use error boundaries for recovering from unexpected exceptions; &lt;strong&gt;don&amp;rsquo;t try to use them for control flow.&lt;/strong&gt;</source>
          <target state="translated">予期しない例外から回復するためにのみエラー境界を使用します。&lt;strong&gt;制御フローに使用しないでください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b1b25a5af502c4955acf005be6d083dc1a30602" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;this example&lt;/a&gt;. When you press a button, you&amp;rsquo;ll see the Pending state for a second before moving on. This transition feels nice and fluid.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;この例を&lt;/a&gt;開きます。ボタンを押すと、先に進む前に1秒間Pending状態が表示されます。この移行は心地よく滑らかに感じられます。</target>
        </trans-unit>
        <trans-unit id="82faec880ab06096a12df754c31b316dbff6580b" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;this example&lt;/a&gt; and click &amp;ldquo;Open Profile&amp;rdquo;. You will see several visual states one by one:</source>
          <target state="translated">開き、&lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;この例を&lt;/a&gt;して「開くプロフィール」をクリックしてください。いくつかの視覚的な状態が1つずつ表示されます。</target>
        </trans-unit>
        <trans-unit id="f911658ce7d859922d5257b0b036abe5292fca9b" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;this starter code&lt;/a&gt;&lt;/strong&gt; and paste it into the file you created.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;このスターターコード&lt;/a&gt;&lt;/strong&gt;を開き&lt;strong&gt;、&lt;/strong&gt;作成したファイルに貼り付けます。</target>
        </trans-unit>
        <trans-unit id="55d9ece27ec32d8829711be1a1d3afea9c2dafd2" translate="yes" xml:space="preserve">
          <source>Open the Chrome DevTools &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;Performance&lt;/a&gt;&lt;/strong&gt; tab and press &lt;strong&gt;Record&lt;/strong&gt;.</source>
          <target state="translated">Chrome DevToolsの[ &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;パフォーマンス&lt;/a&gt;&lt;/strong&gt; ]タブを開き、[ &lt;strong&gt;録音&lt;/strong&gt; ]を押します。</target>
        </trans-unit>
        <trans-unit id="a45e17e011c01ffe2a91ced4f7a209475dd8d2a0" translate="yes" xml:space="preserve">
          <source>Optimizing Performance</source>
          <target state="translated">パフォーマンスの最適化</target>
        </trans-unit>
        <trans-unit id="db92a3f80d780ad79d58ccf80d95c08e0583866f" translate="yes" xml:space="preserve">
          <source>Optimizing the output for production.</source>
          <target state="translated">生産のための出力を最適化します。</target>
        </trans-unit>
        <trans-unit id="ebed446427427efeada77fb1de8555c343d3531f" translate="yes" xml:space="preserve">
          <source>Opting into Concurrent Mode introduces semantic changes to how React works. This means that you can&amp;rsquo;t use Concurrent Mode in just a few components. Because of this, some apps may not be able to migrate directly to Concurrent Mode.</source>
          <target state="translated">並行モードにオプトインすると、Reactの動作方法に意味上の変更が導入されます。これは、いくつかのコンポーネントでコンカレントモードを使用できないことを意味します。このため、一部のアプリはコンカレントモードに直接移行できない場合があります。</target>
        </trans-unit>
        <trans-unit id="eb6793ee41543d3424f0cf56f0cf4f4c5c5d0813" translate="yes" xml:space="preserve">
          <source>Optional: &lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;Download the full example (2KB zipped)&lt;/a&gt;</source>
          <target state="translated">オプション：&lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;サンプル全体をダウンロード（2KB圧縮）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee3267798d0259e5dd98aa26c31e33223e26cac3" translate="yes" xml:space="preserve">
          <source>Optional: Try React with JSX</source>
          <target state="translated">オプションです。JSXでReactを試してみる</target>
        </trans-unit>
        <trans-unit id="3a09e35972dfc007bcd7aa10e05cf800743e8354" translate="yes" xml:space="preserve">
          <source>Or yarn:</source>
          <target state="translated">それか毛糸。</target>
        </trans-unit>
        <trans-unit id="160496746ed70b43025c17e2f2433373eef18b6a" translate="yes" xml:space="preserve">
          <source>Other APIs</source>
          <target state="translated">その他のAPI</target>
        </trans-unit>
        <trans-unit id="1b361bfb2d40f2fa584dfe16d7abd56931268577" translate="yes" xml:space="preserve">
          <source>Other Build Setups</source>
          <target state="translated">その他のビルドセットアップ</target>
        </trans-unit>
        <trans-unit id="718591843f9ba65a328acf7e21cfb68fa2042427" translate="yes" xml:space="preserve">
          <source>Other Events</source>
          <target state="translated">その他のイベント</target>
        </trans-unit>
        <trans-unit id="456d2677e518e26ef0d24a4e5e0c50a00c1e8bbd" translate="yes" xml:space="preserve">
          <source>Other Languages</source>
          <target state="translated">その他の言語</target>
        </trans-unit>
        <trans-unit id="b1866d3283a2c6b4f31b7bd94d302109ad919e6f" translate="yes" xml:space="preserve">
          <source>Other Patterns</source>
          <target state="translated">その他のパターン</target>
        </trans-unit>
        <trans-unit id="670876f3113d937960727ed05a2f82e686590502" translate="yes" xml:space="preserve">
          <source>Other Points for Consideration</source>
          <target state="translated">その他の検討事項</target>
        </trans-unit>
        <trans-unit id="c8298a228f42e1a844433af47c0c496b7ae9065b" translate="yes" xml:space="preserve">
          <source>Other Screen Readers</source>
          <target state="translated">その他のスクリーンリーダー</target>
        </trans-unit>
        <trans-unit id="a6a3346524b28d21d18a28316c1731fc127a349f" translate="yes" xml:space="preserve">
          <source>Other Utilities</source>
          <target state="translated">その他のユーティリティ</target>
        </trans-unit>
        <trans-unit id="4715125742dd4e459dcb1cbb3b644f3692b0c443" translate="yes" xml:space="preserve">
          <source>Other approaches to this, such as composing Promises in a special way, are increasingly difficult to pull off when the loading states are located in different components down the tree.</source>
          <target state="translated">他のアプローチ、例えばPromisesを特別な方法で構成するなどの方法では、ロード状態がツリーの下の異なるコンポーネントに位置している場合、これを実現することはますます困難になっています。</target>
        </trans-unit>
        <trans-unit id="b17f43760c19635a2cfeb450e22843e0fca3cca3" translate="yes" xml:space="preserve">
          <source>Other effects might not have a cleanup phase, and don&amp;rsquo;t return anything.</source>
          <target state="translated">その他の効果にはクリーンアップフェーズがなく、何も返されない場合があります。</target>
        </trans-unit>
        <trans-unit id="efe0a2f2b6a088b22020eedfca1f8171b23b1b2a" translate="yes" xml:space="preserve">
          <source>Other libraries might support hooks in the future too.</source>
          <target state="translated">他のライブラリも将来的にはフックをサポートするかもしれません。</target>
        </trans-unit>
        <trans-unit id="fbb1c9f1eb4ca77b950c7272aaa7baca69202c49" translate="yes" xml:space="preserve">
          <source>Our &amp;ldquo;Next&amp;rdquo; button click handler sets the state that switches the current profile in the state:</source>
          <target state="translated">「次へ」ボタンのクリックハンドラーは、現在のプロファイルを状態に切り替える状態を設定します。</target>
        </trans-unit>
        <trans-unit id="d8d512d8960f76b07e5be884686cf1a1860c585e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Button&lt;/code&gt; component will immediately show the Pending state indicator on click:</source>
          <target state="translated">当社の &lt;code&gt;Button&lt;/code&gt; コンポーネントは、すぐにクリックで保留状態インジケータが表示されます：</target>
        </trans-unit>
        <trans-unit id="5564b57b9c8ed5194280102aa6b272b6ace8690e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Welcome&lt;/code&gt; component returns a &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; element as the result.</source>
          <target state="translated">当社 &lt;code&gt;Welcome&lt;/code&gt; コンポーネント戻り、A &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; 結果として要素。</target>
        </trans-unit>
        <trans-unit id="24e602677bd730cb72e7da761f1b1f89e01b70c7" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;useTransition()&lt;/code&gt; call returns two values: &lt;code&gt;startTransition&lt;/code&gt; and &lt;code&gt;isPending&lt;/code&gt;.</source>
          <target state="translated">私たちの &lt;code&gt;useTransition()&lt;/code&gt; 呼び出しは、 &lt;code&gt;startTransition&lt;/code&gt; と &lt;code&gt;isPending&lt;/code&gt; の 2つの値を返します。</target>
        </trans-unit>
        <trans-unit id="b96521a8515cede856d54400c09ad380c0daf2e3" translate="yes" xml:space="preserve">
          <source>Our JSON API returns some data that looks like this:</source>
          <target state="translated">私たちのJSON APIは、次のようなデータを返します。</target>
        </trans-unit>
        <trans-unit id="bef855825370735f30744e8e204330946ef7b36c" translate="yes" xml:space="preserve">
          <source>Our React applications continuously modify the HTML DOM during runtime, sometimes leading to keyboard focus being lost or set to an unexpected element. In order to repair this, we need to programmatically nudge the keyboard focus in the right direction. For example, by resetting keyboard focus to a button that opened a modal window after that modal window is closed.</source>
          <target state="translated">当社の React アプリケーションは、実行時に HTML DOM を継続的に変更しているため、キーボードフォーカスが失われたり、予期しない要素に設定されたりすることがあります。これを修復するには、キーボードフォーカスを正しい方向にプログラム的に誘導する必要があります。例えば、モーダルウィンドウを閉じた後に、モーダルウィンドウを開いたボタンにキーボードフォーカスをリセットします。</target>
        </trans-unit>
        <trans-unit id="74299bea00c013faee08bac03735a9e8eb9da361" translate="yes" xml:space="preserve">
          <source>Our first attempt might look like this:</source>
          <target state="translated">最初の試みは次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="cfdb46afa859b90b54e6db2005a9424a33bafd62" translate="yes" xml:space="preserve">
          <source>Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</source>
          <target state="translated">私たちの目標は、フックがクラスのすべてのユースケースをできるだけ早くカバーすることです。珍しい &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; と &lt;code&gt;componentDidCatch&lt;/code&gt; のライフサイクルに相当するフックはまだありませんが、すぐに追加する予定です。</target>
        </trans-unit>
        <trans-unit id="6f7bdd68f3093bdd85231792c356d3a08261c101" translate="yes" xml:space="preserve">
          <source>Our new example starts by importing the &lt;code&gt;useState&lt;/code&gt; Hook from React:</source>
          <target state="translated">新しい例では、Reactから &lt;code&gt;useState&lt;/code&gt; フックをインポートすることから始めます。</target>
        </trans-unit>
        <trans-unit id="1fc98859f39fc7662d2321203db3a057fbfc1f78" translate="yes" xml:space="preserve">
          <source>Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.</source>
          <target state="translated">私たちの新しい要件は、摂氏入力に加えて華氏入力を提供し、それらが同期されていることです。</target>
        </trans-unit>
        <trans-unit id="bdbaf73bc5cb4adf782290fa0e9328bf03a93107" translate="yes" xml:space="preserve">
          <source>Our old experiments with functional APIs in the &lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt; repository.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt;リポジトリーで機能APIを使った以前の実験。</target>
        </trans-unit>
        <trans-unit id="ecead6fae262a6840fa100e15a353465a381857e" translate="yes" xml:space="preserve">
          <source>Over a million developers use React, collectively maintaining millions of components. The Facebook codebase alone has over 50,000 React components. That means we need to make it as easy as possible to upgrade to new versions of React; if we make large changes without a migration path, people will be stuck on old versions. We test these upgrade paths on Facebook itself &amp;ndash; if our team of less than 10 people can update 50,000+ components alone, we hope the upgrade will be manageable for anyone using React. In many cases, we write &lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;automated scripts&lt;/a&gt; to upgrade component syntax, which we then include in the open-source release for everyone to use.</source>
          <target state="translated">100万人を超える開発者がReactを使用して、何百万ものコンポーネントをまとめて維持しています。Facebookのコードベースだけでも、50,000以上のReactコンポーネントがあります。つまり、Reactの新しいバージョンにできるだけ簡単にアップグレードできるようにする必要があります。移行パスなしで大きな変更を行うと、人々は古いバージョンに行き詰まります。私たちはFacebook自体でこれらのアップグレードパスをテストします。10人未満のチームが50,000以上のコンポーネントを単独で更新できる場合、Reactを使用するすべての人がアップグレードを管理できることを願っています。多くの場合、コンポーネントの構文をアップグレードするための&lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;自動スクリプト&lt;/a&gt;を記述し、それをオープンソースリリースに組み込んで、誰もが使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="67ee80037726319e2173c25a2b8a820cdf39330c" translate="yes" xml:space="preserve">
          <source>Over the next several months, many libraries will appear with different takes on Suspense APIs. &lt;strong&gt;If you prefer to learn when things are more stable, you might prefer to ignore this work for now, and come back when the Suspense ecosystem is more mature.&lt;/strong&gt;</source>
          <target state="translated">今後数か月の間に、多くのライブラリがSuspense APIの異なるテイクで表示されます。&lt;strong&gt;物事がより安定しているときに学習したい場合は、今のところこの作業を無視して、サスペンスエコシステムがより成熟したときに戻ってくることをお勧めします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33b00a214a218165c819825f50d811fd28c59d9c" translate="yes" xml:space="preserve">
          <source>Overall, this makes it so that &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; all work very similarly - they all accept a &lt;code&gt;value&lt;/code&gt; attribute that you can use to implement a controlled component.</source>
          <target state="translated">全体として、これにより &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; はすべて非常によく似た動作をします。これらはすべて、制御されたコンポーネントの実装に使用できる &lt;code&gt;value&lt;/code&gt; 属性を受け入れます。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="ac6ae6a452c9a133b258c63f82756651e2997eaf" translate="yes" xml:space="preserve">
          <source>Package Managers</source>
          <target state="translated">パッケージマネージャー</target>
        </trans-unit>
        <trans-unit id="20ec6193c88aaa60a810f707fb624f400dab682a" translate="yes" xml:space="preserve">
          <source>Package managers are tools that allow you to manage dependencies in your project. &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; are two package managers commonly used in React applications. Both of them are clients for the same npm package registry.</source>
          <target state="translated">パッケージマネージャーは、プロジェクトの依存関係を管理できるツールです。&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;と&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;は、Reactアプリケーションで一般的に使用される2つのパッケージマネージャーです。どちらも同じnpmパッケージレジストリのクライアントです。</target>
        </trans-unit>
        <trans-unit id="7dca5f8363324ed0f27645a7b9839654bdd31f45" translate="yes" xml:space="preserve">
          <source>Parent-Child Coupling</source>
          <target state="translated">親子のカップリング</target>
        </trans-unit>
        <trans-unit id="60bd5e09f1e5e3ba47a58c7db16fad72304e43c8" translate="yes" xml:space="preserve">
          <source>Pass a &amp;ldquo;create&amp;rdquo; function and an array of dependencies. &lt;code&gt;useMemo&lt;/code&gt; will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.</source>
          <target state="translated">「作成」関数と依存関係の配列を渡します。 &lt;code&gt;useMemo&lt;/code&gt; は、依存関係の1つが変更された場合にのみ、メモされた値を再計算します。この最適化は、すべてのレンダリングでの高価な計算を回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="dd926194677835b376654a809999d830104e7b63" translate="yes" xml:space="preserve">
          <source>Pass a function instead of an object to &lt;code&gt;setState&lt;/code&gt; to ensure the call always uses the most updated version of state (see below).</source>
          <target state="translated">オブジェクトの代わりに関数を &lt;code&gt;setState&lt;/code&gt; に渡して、呼び出しが常に最新バージョンの状態を使用するようにします（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="2780570791c9ee7131760cf13185af6586f6a67f" translate="yes" xml:space="preserve">
          <source>Pass a mocked component module to this method to augment it with useful methods that allow it to be used as a dummy React component. Instead of rendering as usual, the component will become a simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (or other tag if &lt;code&gt;mockTagName&lt;/code&gt; is provided) containing any provided children.</source>
          <target state="translated">モックされたコンポーネントモジュールをこのメソッドに渡して、ダミーのReactコンポーネントとして使用できる便利なメソッドを追加します。コンポーネントは通常のようにレンダリングされるのではなく、提供された子を含む単純な &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; （または &lt;code&gt;mockTagName&lt;/code&gt; が提供されている場合は他のタグ）になります。</target>
        </trans-unit>
        <trans-unit id="fdde832b0e4e25e7efa528b27f908118f6bfa769" translate="yes" xml:space="preserve">
          <source>Pass a string as the &lt;code&gt;className&lt;/code&gt; prop:</source>
          <target state="translated">文字列を &lt;code&gt;className&lt;/code&gt; プロップとして渡します。</target>
        </trans-unit>
        <trans-unit id="534c9e580a2811b44edf2a15e3bc0f460c0a7212" translate="yes" xml:space="preserve">
          <source>Pass an inline callback and an array of dependencies. &lt;code&gt;useCallback&lt;/code&gt; will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. &lt;code&gt;shouldComponentUpdate&lt;/code&gt;).</source>
          <target state="translated">インラインコールバックと依存関係の配列を渡します。 &lt;code&gt;useCallback&lt;/code&gt; は、依存関係の1つが変更された場合にのみ変更されるコールバックのメモ化されたバージョンを返します。これは、参照の等価性に依存する不要なレンダリングを回避するためにコールバックを最適化された子コンポーネントに渡すときに役立ちます（たとえば &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b1ecfde360ca670c99a034b3467938615912d18" translate="yes" xml:space="preserve">
          <source>Pass event handlers and other functions as props to child components:</source>
          <target state="translated">イベントハンドラなどの関数を子コンポーネントに小道具として渡します。</target>
        </trans-unit>
        <trans-unit id="7977cb8dad2d6673088b4722d378da8582b6ab23" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Event Handlers</source>
          <target state="translated">イベントハンドラへの引数の渡し方</target>
        </trans-unit>
        <trans-unit id="7731b6038ead3e4f42010f183a92cc0e8e663535" translate="yes" xml:space="preserve">
          <source>Passing Functions to Components</source>
          <target state="translated">コンポーネントへの関数の受け渡し</target>
        </trans-unit>
        <trans-unit id="47c211ae4a2b3b47216fe468fbd82f27983e4011" translate="yes" xml:space="preserve">
          <source>Passing an update function allows you to access the current state value inside the updater. Since &lt;code&gt;setState&lt;/code&gt; calls are batched, this lets you chain updates and ensure they build on top of each other instead of conflicting:</source>
          <target state="translated">更新関数を渡すと、アップデータ内の現在の状態値にアクセスできます。 &lt;code&gt;setState&lt;/code&gt; 呼び出しはバッチ処理されるので、これにより、更新を連鎖させて、競合するのではなく、互いの上に構築することができます。</target>
        </trans-unit>
        <trans-unit id="9a6194136e1fc05bb75b0051025e3237f9608a70" translate="yes" xml:space="preserve">
          <source>People come to React from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you&amp;rsquo;ll find this section helpful.</source>
          <target state="translated">人々はさまざまなバックグラウンドからさまざまな学習スタイルでReactを利用しています。より理論的または実用的なアプローチを好むかどうかにかかわらず、このセクションがお役に立てば幸いです。</target>
        </trans-unit>
        <trans-unit id="a454c4946afe6de8abb7a71c3c543078037ceb08" translate="yes" xml:space="preserve">
          <source>Perform the actions you want to profile. Don&amp;rsquo;t record more than 20 seconds or Chrome might hang.</source>
          <target state="translated">プロファイルするアクションを実行します。20秒を超えて録画しないでください。Chromeがハングする可能性があります。</target>
        </trans-unit>
        <trans-unit id="1456888f4e0889c6c1362473e30e3fb8f16a2193" translate="yes" xml:space="preserve">
          <source>Performance Optimizations</source>
          <target state="translated">パフォーマンスの最適化</target>
        </trans-unit>
        <trans-unit id="afe33e97d445c1aa01afdea12de2c8a6bf6ef536" translate="yes" xml:space="preserve">
          <source>Phew, that was fast! If some things didn&amp;rsquo;t quite make sense or you&amp;rsquo;d like to learn more in detail, you can read the next pages, starting with the &lt;a href=&quot;hooks-state&quot;&gt;State Hook&lt;/a&gt; documentation.</source>
          <target state="translated">ふew、それは速かった！まったく意味がわからないものや、詳細を知りたい場合は、&lt;a href=&quot;hooks-state&quot;&gt;State Hookの&lt;/a&gt;ドキュメントから始めて、次のページを読むことができます。</target>
        </trans-unit>
        <trans-unit id="649b0aad2e87bf224c37505fbd45954d6ae44866" translate="yes" xml:space="preserve">
          <source>Play a bit more with the &lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;demo&lt;/a&gt;, and try to imagine it happening.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;デモ&lt;/a&gt;でもう少し遊んで、それが起こっていることを想像してみてください。</target>
        </trans-unit>
        <trans-unit id="e22243b7987a499744ba5d18f9114f54c25fe1f4" translate="yes" xml:space="preserve">
          <source>Please note that browser / screen reader combinations matter. It is recommended that you test your application in the browser best suited to your screen reader of choice.</source>
          <target state="translated">ブラウザとスクリーンリーダーの組み合わせは重要です。お使いのスクリーンリーダーに最適なブラウザでアプリケーションをテストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e61307201646dc8a1687dacab76a450772d3c680" translate="yes" xml:space="preserve">
          <source>Please note that the syntax above is &lt;strong&gt;experimental&lt;/strong&gt; and the syntax may change, or the proposal might not make it into the language.</source>
          <target state="translated">上記の構文は&lt;strong&gt;実験的なもので&lt;/strong&gt;あり、構文が変更されたり、提案が言語にならない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a84c3942bb67e056a4c3f6552e902c1c6de812f7" translate="yes" xml:space="preserve">
          <source>Pointer Events</source>
          <target state="translated">ポインターイベント</target>
        </trans-unit>
        <trans-unit id="51c36c348e5c25ede527a987ca5d7e15ef86c339" translate="yes" xml:space="preserve">
          <source>Pointer events are not yet supported in every browser (at the time of writing this article, supported browsers include: Chrome, Firefox, Edge, and Internet Explorer). React deliberately does not polyfill support for other browsers because a standard-conform polyfill would significantly increase the bundle size of &lt;code&gt;react-dom&lt;/code&gt;.</source>
          <target state="translated">ポインターイベントは、すべてのブラウザーでまだサポートされていません（この記事の執筆時点で、サポートされているブラウザーには、Chrome、Firefox、Edge、およびInternet Explorerが含まれます）。標準準拠のポリフィルでは、 &lt;code&gt;react-dom&lt;/code&gt; のバンドルサイズが大幅に増加するため、Reactは他のブラウザのサポートを意図的にポリフィルしません。</target>
        </trans-unit>
        <trans-unit id="a0c88242e813893ab8ad50b7e16808768f9baafb" translate="yes" xml:space="preserve">
          <source>Portals</source>
          <target state="translated">Portals</target>
        </trans-unit>
        <trans-unit id="4b918b44974a1664555fe8092f41a8a9c3c7132e" translate="yes" xml:space="preserve">
          <source>Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.</source>
          <target state="translated">ポータルは、親コンポーネントの DOM 階層の外側に存在する DOM ノードに子をレンダリングする第一級の方法を提供します。</target>
        </trans-unit>
        <trans-unit id="029998f5e0e501dc2ec70d705846fadf01f5078f" translate="yes" xml:space="preserve">
          <source>Practical Tutorial</source>
          <target state="translated">実践チュートリアル</target>
        </trans-unit>
        <trans-unit id="0da325394f7b2561f269c38b5353a62787615dc5" translate="yes" xml:space="preserve">
          <source>Prefer the standard &lt;code&gt;useEffect&lt;/code&gt; when possible to avoid blocking visual updates.</source>
          <target state="translated">視覚的な更新がブロックされないように、可能な場合は標準の &lt;code&gt;useEffect&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="87cfce24dccded60294e74f312a7bb64c4e35de4" translate="yes" xml:space="preserve">
          <source>Preferred: Pending &amp;rarr; Skeleton &amp;rarr; Complete</source>
          <target state="translated">優先：保留中&amp;rarr;スケルトン&amp;rarr;完了</target>
        </trans-unit>
        <trans-unit id="fb1323678aee55ea7816c8e30aa6f1bdb912fb64" translate="yes" xml:space="preserve">
          <source>Press &amp;ldquo;Next&amp;rdquo; a few times. Notice it already feels very different. &lt;strong&gt;Instead of immediately seeing an empty screen on click, we now keep seeing the previous page for a while.&lt;/strong&gt; When the data has loaded, React transitions us to the new screen.</source>
          <target state="translated">「次へ」を数回押します。それはすでに非常に異なっていると感じていることに注意してください。&lt;strong&gt;クリックするとすぐに空の画面が表示されるのではなく、しばらく前のページが表示され続けます。&lt;/strong&gt;データが読み込まれると、Reactは新しい画面に遷移します。</target>
        </trans-unit>
        <trans-unit id="ef2165e905ee1367c14a6f33243da7d43b8b7584" translate="yes" xml:space="preserve">
          <source>Preventing Component from Rendering</source>
          <target state="translated">コンポーネントのレンダリングを防止する</target>
        </trans-unit>
        <trans-unit id="3efe0b4e061393bdaf49e8a579601b4bd4ce78de" translate="yes" xml:space="preserve">
          <source>Previously, React provided two ways for managing refs: the legacy string ref API and the callback API. Although the string ref API was the more convenient of the two, it had &lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;several downsides&lt;/a&gt; and so our official recommendation was to &lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;use the callback form instead&lt;/a&gt;.</source>
          <target state="translated">以前は、Reactは参照を管理するための2つの方法を提供していました。レガシー文字列参照APIとコールバックAPIです。文字列参照APIは2つの方法の方が便利でしたが、&lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;いくつかの欠点&lt;/a&gt;があった&lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;ため、代わりにコールバックフォーム&lt;/a&gt;を使用することを正式に推奨しました。</target>
        </trans-unit>
        <trans-unit id="5f508d98b08c23e21ae8ba502e34faaa9bf61dd9" translate="yes" xml:space="preserve">
          <source>Previously, we only encountered React elements that represent DOM tags:</source>
          <target state="translated">以前は、DOMタグを表すReact要素にしか遭遇しませんでした。</target>
        </trans-unit>
        <trans-unit id="886739715565d2665d39c8366ec2d10dc344405d" translate="yes" xml:space="preserve">
          <source>Priority-based Rendering</source>
          <target state="translated">優先度ベースのレンダリング</target>
        </trans-unit>
        <trans-unit id="bb2e2459a0759f7d2b3b0d9811210079874a39cc" translate="yes" xml:space="preserve">
          <source>Profiler API</source>
          <target state="translated">プロファイラAPI</target>
        </trans-unit>
        <trans-unit id="5f47591c38d90876e84e5a679c6dc16b4b65918a" translate="yes" xml:space="preserve">
          <source>Profiling Components with the Chrome Performance Tab</source>
          <target state="translated">Chrome パフォーマンス タブを使用したコンポーネントのプロファイリング</target>
        </trans-unit>
        <trans-unit id="e9edfd9d87db8eb1b7c2fee04f3c7d3c4f51081d" translate="yes" xml:space="preserve">
          <source>Profiling Components with the DevTools Profiler</source>
          <target state="translated">DevTools Profilerによるコンポーネントのプロファイリング</target>
        </trans-unit>
        <trans-unit id="38e01723f7448dcb8aa35875d9f81ee04d125e7e" translate="yes" xml:space="preserve">
          <source>Profiling adds some additional overhead, so &lt;strong&gt;it is disabled in &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;the production build&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">プロファイリングによりオーバーヘッドが追加されるため&lt;strong&gt;&lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;、本番ビルド&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;では無効になり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a865967da74c8436b8d176a76b2002d968e98151" translate="yes" xml:space="preserve">
          <source>Programmatically managing focus</source>
          <target state="translated">プログラムでフォーカスを管理</target>
        </trans-unit>
        <trans-unit id="86cd3058a8d5775df18dce4ea57b680ca5e164b6" translate="yes" xml:space="preserve">
          <source>Progressive Hydration</source>
          <target state="translated">進行性の水分補給</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="351f56a6fefd5127c90506d3e91990f1d7631787" translate="yes" xml:space="preserve">
          <source>Properties:</source>
          <target state="translated">Properties:</target>
        </trans-unit>
        <trans-unit id="2187830d82c3a1f4829ffcf9703990399389ecd1" translate="yes" xml:space="preserve">
          <source>Props Default to &amp;ldquo;True&amp;rdquo;</source>
          <target state="translated">小道具のデフォルトは「真」</target>
        </trans-unit>
        <trans-unit id="9c2d9ce6b30a5f9172862e1e2a2103f1545aae76" translate="yes" xml:space="preserve">
          <source>Props and composition give you all the flexibility you need to customize a component&amp;rsquo;s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.</source>
          <target state="translated">小道具と構成により、コンポーネントの外観と動作を明示的かつ安全な方法でカスタマイズするために必要なすべての柔軟性が得られます。コンポーネントは、プリミティブ値、React要素、関数などの任意の小道具を受け入れる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="78feac20bb5fc62e7459d810b7135fef805d6854" translate="yes" xml:space="preserve">
          <source>Props are Read-Only</source>
          <target state="translated">小道具は読み取り専用</target>
        </trans-unit>
        <trans-unit id="b33f3c7f743fb12f6a11e786a2fcb6e13d6efcfa" translate="yes" xml:space="preserve">
          <source>Props in JSX</source>
          <target state="translated">JSXでの小道具</target>
        </trans-unit>
        <trans-unit id="5e8dad475166c2eac08c646b3ebdf3559b8f22bb" translate="yes" xml:space="preserve">
          <source>Props vs State</source>
          <target state="translated">プロップス vs ステート</target>
        </trans-unit>
        <trans-unit id="ef11665379e87b4432e89567d3144207597dde64" translate="yes" xml:space="preserve">
          <source>Provide a mechanism to allow users to skip past navigation sections in your application as this assists and speeds up keyboard navigation.</source>
          <target state="translated">ユーザーがアプリケーション内のナビゲーションセクションを過去にスキップできるように、キーボードナビゲーションを支援し、高速化するメカニズムを提供してください。</target>
        </trans-unit>
        <trans-unit id="65135d5ec4d5950c26be85cdc6405b0542ba4616" translate="yes" xml:space="preserve">
          <source>Putting Research into Production</source>
          <target state="translated">研究の生産への投入</target>
        </trans-unit>
        <trans-unit id="4ee9c42d60235c923278d5e44bad794e0fe45c13" translate="yes" xml:space="preserve">
          <source>Quickly Try JSX</source>
          <target state="translated">JSXを素早く試す</target>
        </trans-unit>
        <trans-unit id="723a59bfbd4916773b778eea25c500ba0e2055e2" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;componentDidUpdate&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;componentDidUpdate&lt;/code&gt; による競合状態</target>
        </trans-unit>
        <trans-unit id="8ace34e863de930657650d2da4b04c7f1f377acc" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;useEffect&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; を使用した競合状態</target>
        </trans-unit>
        <trans-unit id="5c456dc6554aed5954e8c75d3fa6572cdb27a30f" translate="yes" xml:space="preserve">
          <source>Race Conditions with componentDidUpdate</source>
          <target state="translated">componentDidUpdateでのレース条件</target>
        </trans-unit>
        <trans-unit id="42274756b2dc2c17eaeb7f294f21deef9e594667" translate="yes" xml:space="preserve">
          <source>Race Conditions with useEffect</source>
          <target state="translated">useEffectを使用したレース条件</target>
        </trans-unit>
        <trans-unit id="7a22b192ac2fa53d431f80c3ed1ab58049c5282b" translate="yes" xml:space="preserve">
          <source>Race conditions are bugs that happen due to incorrect assumptions about the order in which our code may run. Fetching data in the &lt;code&gt;useEffect&lt;/code&gt; Hook or in class lifecycle methods like &lt;code&gt;componentDidUpdate&lt;/code&gt; often leads to them. Suspense can help here, too &amp;mdash; let&amp;rsquo;s see how.</source>
          <target state="translated">競合状態は、コードが実行される順序についての誤った仮定が原因で発生するバグです。 &lt;code&gt;useEffect&lt;/code&gt; フック、または &lt;code&gt;componentDidUpdate&lt;/code&gt; などのクラスライフサイクルメソッドでデータをフェッチすると、多くの場合、それらが発生します。ここでもサスペンスが役立ちます&amp;mdash;方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="14755c296af9379808222382bdd6b5de345159dc" translate="yes" xml:space="preserve">
          <source>Rarely Used Lifecycle Methods</source>
          <target state="translated">稀に使用されるライフサイクル手法</target>
        </trans-unit>
        <trans-unit id="26dd7fe02a64876676c6cbd9aa8708f0a20b47f9" translate="yes" xml:space="preserve">
          <source>Re-render the in-memory tree with a new root element. This simulates a React update at the root. If the new element has the same type and key as the previous element, the tree will be updated; otherwise, it will re-mount a new tree.</source>
          <target state="translated">新しいルート要素でインメモリツリーを再レンダーします。これは、ルートでのReact更新をシミュレートします。新しい要素が前の要素と同じ型とキーを持っている場合は、ツリーが更新されますが、そうでない場合は新しいツリーを再マウントします。</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="cec80c2bc8202e23af151e7f74a7ef7ace217cd9" translate="yes" xml:space="preserve">
          <source>React 15 included a very limited support for error boundaries under a different method name: &lt;code&gt;unstable_handleError&lt;/code&gt;. This method no longer works, and you will need to change it to &lt;code&gt;componentDidCatch&lt;/code&gt; in your code starting from the first 16 beta release.</source>
          <target state="translated">React 15には、異なるメソッド名の下でのエラー境界の非常に限られたサポートが含まれていました： &lt;code&gt;unstable_handleError&lt;/code&gt; 。このメソッドは機能しなくなったため、最初の16ベータリリース以降、コード内で &lt;code&gt;componentDidCatch&lt;/code&gt; に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="5d738f325e7c19b6858708f27583b05cb0428fc2" translate="yes" xml:space="preserve">
          <source>React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">React 16は、コレクションタイプ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Setに&lt;/a&gt;依存します。これらをネイティブで提供していない可能性のある古いブラウザーやデバイス（IE &amp;lt;11など）や、準拠していない実装（IE 11など）をサポートしている場合は、&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;や&lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel&lt;/a&gt;などのバンドルアプリケーションにグローバルポリフィルを含めることを検討してください。-ポリフィル。</target>
        </trans-unit>
        <trans-unit id="1051bec19cd5874a397897a7f06cc6437c451c36" translate="yes" xml:space="preserve">
          <source>React 16 prints all errors that occurred during rendering to the console in development, even if the application accidentally swallows them. In addition to the error message and the JavaScript stack, it also provides component stack traces. Now you can see where exactly in the component tree the failure has happened:</source>
          <target state="translated">React 16 は、アプリケーションが誤ってエラーを飲み込んでしまった場合でも、レンダリング中に発生したすべてのエラーを開発中のコンソールに表示します。エラーメッセージと JavaScript スタックに加えて、コンポーネントスタックのトレースも提供します。これで、コンポーネントツリーのどこで障害が発生したかを正確に知ることができます。</target>
        </trans-unit>
        <trans-unit id="30e0407bcbcc67abd7c79d5c3bd2fcd47ad42dd9" translate="yes" xml:space="preserve">
          <source>React 16.3 added a third option that offers the convenience of a string ref without any of the downsides:</source>
          <target state="translated">React 16.3では、デメリットのない文字列参照の利便性を提供する3つ目のオプションが追加されました。</target>
        </trans-unit>
        <trans-unit id="3c32dfc45304c45a68c84f0c0ee4c4f05460c24f" translate="yes" xml:space="preserve">
          <source>React 16.6 added a &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; component that lets you &amp;ldquo;wait&amp;rdquo; for some code to load and declaratively specify a loading state (like a spinner) while we&amp;rsquo;re waiting:</source>
          <target state="translated">React 16.6に &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; コンポーネントが追加されました。これにより、コードが読み込まれるのを「待ち」、待機中に読み込み状態（スピナーなど）を宣言的に指定できます。</target>
        </trans-unit>
        <trans-unit id="b645cea94d9f5a02a027aeb84445527c67977cf7" translate="yes" xml:space="preserve">
          <source>React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</source>
          <target state="translated">React 16.8.0はフックをサポートする最初のリリースです。アップグレードするときは、React DOMを含むすべてのパッケージを忘れずに更新してください。React Nativeは&lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;、React Nativeの0.59リリース&lt;/a&gt;以降、フックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="5a2fa57c98aa2ff66a34e3804ba4afdbf43f949c" translate="yes" xml:space="preserve">
          <source>React &lt;a href=&quot;react-without-jsx&quot;&gt;doesn&amp;rsquo;t require&lt;/a&gt; using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</source>
          <target state="translated">React &lt;a href=&quot;react-without-jsx&quot;&gt;は&lt;/a&gt; JSXを使用する必要はありませんが、JavaScriptコード内でUIを操作する際の視覚的な補助として、JSXが役立つと感じています。また、Reactがより有用なエラーおよび警告メッセージを表示できるようにします。</target>
        </trans-unit>
        <trans-unit id="e56b4ec7d4044adf40d8ea846a837d5e5d0e2ec1" translate="yes" xml:space="preserve">
          <source>React DOM</source>
          <target state="translated">リアクトDOM</target>
        </trans-unit>
        <trans-unit id="0e17312bf427154aa9521cc18565e992f954d046" translate="yes" xml:space="preserve">
          <source>React DOM Server</source>
          <target state="translated">React DOM サーバー</target>
        </trans-unit>
        <trans-unit id="6783695eda495767c874d2c12b708f12b9eb5c68" translate="yes" xml:space="preserve">
          <source>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</source>
          <target state="translated">React DOMは、要素とその子を前のものと比較し、DOMを目的の状態にするために必要なDOMの更新のみを適用します。</target>
        </trans-unit>
        <trans-unit id="c0f543b7e06f16286089bf4be437499e1b43b727" translate="yes" xml:space="preserve">
          <source>React DOM efficiently updates the DOM to match &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">React DOMは、 &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; に一致するようにDOMを効率的に更新します。</target>
        </trans-unit>
        <trans-unit id="9fdeb7ff15e5768ee7e11ab66cd7913eac488847" translate="yes" xml:space="preserve">
          <source>React DOM updates the DOM with the boiling verdict and to match the desired input values. The input we just edited receives its current value, and the other input is updated to the temperature after conversion.</source>
          <target state="translated">React DOMでは、沸騰した評定値と希望する入力値を一致させるようにDOMを更新しています。先ほど編集した入力は現在の値を受け取り、他の入力は変換後の温度に更新されます。</target>
        </trans-unit>
        <trans-unit id="1b3e9e3b704e86ac0ae2261ed5ae0110bb475463" translate="yes" xml:space="preserve">
          <source>React DOM uses camelCase property naming convention instead of HTML attribute names. For example, &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;code&gt;tabIndex&lt;/code&gt; in JSX. The attribute &lt;code&gt;class&lt;/code&gt; is also written as &lt;code&gt;className&lt;/code&gt; since &lt;code&gt;class&lt;/code&gt; is a reserved word in JavaScript:</source>
          <target state="translated">React DOMは、HTML属性名の代わりにcamelCaseプロパティの命名規則を使用します。たとえば、JSX では &lt;code&gt;tabindex&lt;/code&gt; は &lt;code&gt;tabIndex&lt;/code&gt; になります。属性 &lt;code&gt;class&lt;/code&gt; とも書かれている &lt;code&gt;className&lt;/code&gt; のため、 &lt;code&gt;class&lt;/code&gt; JavaScriptで予約語です。</target>
        </trans-unit>
        <trans-unit id="64f7152b69ea8b7e6f11fc24d5c27c7549c6acd1" translate="yes" xml:space="preserve">
          <source>React Documentation</source>
          <target state="translated">React ドキュメント</target>
        </trans-unit>
        <trans-unit id="3a01dc41ed1fa68614175afe8e165764d9609ab0" translate="yes" xml:space="preserve">
          <source>React Must Be in Scope</source>
          <target state="translated">Reactはスコープ内になければならない</target>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="translated">リアクトネイティブ</target>
        </trans-unit>
        <trans-unit id="a2c6dfc0e1dfdf3f794b802a1ba06278b93a1b13" translate="yes" xml:space="preserve">
          <source>React Only Updates What&amp;rsquo;s Necessary</source>
          <target state="translated">必要なものだけを更新して反応する</target>
        </trans-unit>
        <trans-unit id="3633a811906ebb40f86bdd77c315e1e2bde36321" translate="yes" xml:space="preserve">
          <source>React Redux since v7.1.0 &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;supports Hooks API&lt;/a&gt; and exposes hooks like &lt;code&gt;useDispatch&lt;/code&gt; or &lt;code&gt;useSelector&lt;/code&gt;.</source>
          <target state="translated">v7.1.0以降のReact Redux &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;はフックAPI&lt;/a&gt;をサポートし、 &lt;code&gt;useDispatch&lt;/code&gt; や &lt;code&gt;useSelector&lt;/code&gt; などのフックを公開しています。</target>
        </trans-unit>
        <trans-unit id="3bb3fe34bf0fbac0db48c2c52246f7bf4643b58d" translate="yes" xml:space="preserve">
          <source>React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;supports hooks&lt;/a&gt; since v5.1.</source>
          <target state="translated">React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;は&lt;/a&gt; v5.1以降のフックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="db30dab9afce5ee17ad60f6815d45c7d2775403c" translate="yes" xml:space="preserve">
          <source>React Shallow Renderer</source>
          <target state="translated">Reactシャローレンダラー</target>
        </trans-unit>
        <trans-unit id="59f752bd2488cbb706a191bae6c25ec360c9ae78" translate="yes" xml:space="preserve">
          <source>React Test Renderer</source>
          <target state="translated">Reactテストレンダラ</target>
        </trans-unit>
        <trans-unit id="493a1a450ae702c6d46a164382378d365c88d431" translate="yes" xml:space="preserve">
          <source>React Testing Library offers a &lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;more concise helper&lt;/a&gt; for firing events.</source>
          <target state="translated">React Testing Libraryは、イベントを&lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;起動する&lt;/a&gt;ためのより簡潔なヘルパーを提供します。</target>
        </trans-unit>
        <trans-unit id="a3a37522e503e9a2cee5bb38180398e2a23e1f1f" translate="yes" xml:space="preserve">
          <source>React Top-Level API</source>
          <target state="translated">ReactトップレベルAPI</target>
        </trans-unit>
        <trans-unit id="8e60d7618dece37120d3987205a0d2168962460f" translate="yes" xml:space="preserve">
          <source>React Without ES6</source>
          <target state="translated">ES6なしでリアクト</target>
        </trans-unit>
        <trans-unit id="cd5884fb1f8e40d0ef6cbe86d6584a46690762e1" translate="yes" xml:space="preserve">
          <source>React Without JSX</source>
          <target state="translated">JSXなしでReactする</target>
        </trans-unit>
        <trans-unit id="9fe2f9ba8b44464b4bfefd199f9bc13307ee3332" translate="yes" xml:space="preserve">
          <source>React also depends on &lt;code&gt;requestAnimationFrame&lt;/code&gt; (even in test environments).</source>
          <target state="translated">Reactは &lt;code&gt;requestAnimationFrame&lt;/code&gt; にも依存します（テスト環境でも）。</target>
        </trans-unit>
        <trans-unit id="7d8f2b9666834dcad7e288b25fd8480664eaad61" translate="yes" xml:space="preserve">
          <source>React also supports another way to set refs called &amp;ldquo;callback refs&amp;rdquo;, which gives more fine-grain control over when refs are set and unset.</source>
          <target state="translated">Reactは、「コールバック参照」と呼ばれる参照を設定する別の方法もサポートしています。これにより、参照の設定と設定解除をより細かく制御できます。</target>
        </trans-unit>
        <trans-unit id="10225c998465dfe979466a99502e0be87e759457" translate="yes" xml:space="preserve">
          <source>React and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;Web Components&lt;/a&gt; are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary. As a developer, you are free to use React in your Web Components, or to use Web Components in React, or both.</source>
          <target state="translated">Reactおよび&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;Webコンポーネント&lt;/a&gt;は、さまざまな問題を解決するために構築されています。Webコンポーネントは再利用可能なコンポーネントの強力なカプセル化を提供し、ReactはDOMとデータの同期を維持する宣言型ライブラリを提供します。2つの目標は相補的です。開発者は、WebコンポーネントでReactを使用するか、ReactでWebコンポーネントを使用するか、またはその両方を自由に行えます。</target>
        </trans-unit>
        <trans-unit id="27082daf4244e21a91a723f26657721dc905d29e" translate="yes" xml:space="preserve">
          <source>React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components. This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects. Sometimes it is referred to as a &amp;ldquo;virtual DOM&amp;rdquo;, but it works the same way on React Native.</source>
          <target state="translated">Reactは、レンダリングされたUIの内部表現を構築および維持します。これには、コンポーネントから返すReact要素が含まれています。この表現により、JavaScriptオブジェクトの操作よりも遅くなる可能性があるため、ReactはDOMノードの作成や、必要以上に既存のノードへのアクセスを回避できます。「仮想DOM」と呼ばれることもありますが、React Nativeでも同じように機能します。</target>
        </trans-unit>
        <trans-unit id="610b64665a6a2f5e728c19e6eca03a8b39cdcf07" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Calculator&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method to learn what the UI should look like. The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here.</source>
          <target state="translated">Reactは &lt;code&gt;Calculator&lt;/code&gt; コンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドを呼び出して、UIの外観を学習します。両方の入力の値は、現在の温度とアクティブなスケールに基づいて再計算されます。ここで温度変換を行います。</target>
        </trans-unit>
        <trans-unit id="ba853d2a17e24f0bd22d89450b9557d4a2c11971" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Welcome&lt;/code&gt; component with &lt;code&gt;{name: 'Sara'}&lt;/code&gt; as the props.</source>
          <target state="translated">Reactは &lt;code&gt;{name: 'Sara'}&lt;/code&gt; を小道具として &lt;code&gt;Welcome&lt;/code&gt; コンポーネントを呼び出します。</target>
        </trans-unit>
        <trans-unit id="d6f2ebfc937521d2470061f7e3d9cde73833393e" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; method of the &lt;code&gt;BoilingVerdict&lt;/code&gt; component, passing the temperature in Celsius as its props.</source>
          <target state="translated">Reactは &lt;code&gt;BoilingVerdict&lt;/code&gt; コンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドを呼び出し、摂氏の温度を小道具として渡します。</target>
        </trans-unit>
        <trans-unit id="f3922365ae8f20c0cd2b94600d6dd96e8199f37c" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; methods of the individual &lt;code&gt;TemperatureInput&lt;/code&gt; components with their new props specified by the &lt;code&gt;Calculator&lt;/code&gt;. It learns what their UI should look like.</source>
          <target state="translated">Reactは、 &lt;code&gt;Calculator&lt;/code&gt; で指定された新しいプロパティを使用して、個々の &lt;code&gt;TemperatureInput&lt;/code&gt; コンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドを呼び出します。UIの外観を学習します。</target>
        </trans-unit>
        <trans-unit id="36fdfacce7eedd6661f907c10f0f4ea9af876fce" translate="yes" xml:space="preserve">
          <source>React calls the function specified as &lt;code&gt;onChange&lt;/code&gt; on the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In our case, this is the &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component.</source>
          <target state="translated">Reactは、DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; で &lt;code&gt;onChange&lt;/code&gt; として指定された関数を呼び出します。私たちの場合、これは &lt;code&gt;TemperatureInput&lt;/code&gt; コンポーネントの &lt;code&gt;handleChange&lt;/code&gt; メソッドです。</target>
        </trans-unit>
        <trans-unit id="bd8b2d2111896cb2314cfe1f0bde6a55efe40119" translate="yes" xml:space="preserve">
          <source>React can be embedded into other applications thanks to the flexibility of &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; の&lt;/a&gt;柔軟性により、Reactを他のアプリケーションに埋め込むことができます。</target>
        </trans-unit>
        <trans-unit id="e1330ed30fca80f90b213d9b6f69f3e0df6ecab7" translate="yes" xml:space="preserve">
          <source>React can be used in any web application. It can be embedded in other applications and, with a little care, other applications can be embedded in React. This guide will examine some of the more common use cases, focusing on integration with &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt;, but the same ideas can be applied to integrating components with any existing code.</source>
          <target state="translated">ReactはどのWebアプリケーションでも使用できます。他のアプリケーションに組み込むことができ、少し注意して、他のアプリケーションをReactに組み込むことができます。このガイドでは、&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;と&lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt;との統合に焦点を当てて、より一般的な使用例をいくつか調べますが、コンポーネントを既存のコードと統合する場合にも同じ考え方を適用できます。</target>
        </trans-unit>
        <trans-unit id="d37e463c6f9b2a55b2880cfa9eafdf5e114306ed" translate="yes" xml:space="preserve">
          <source>React can be used to power animations. See &lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt; and &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt; or &lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Spring&lt;/a&gt;, for example.</source>
          <target state="translated">Reactを使用してアニメーションを強化できます。たとえば、&lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt;および&lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt;または&lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Springを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c793e68bb1fac249aba0ce5f3bec7e5d7023c434" translate="yes" xml:space="preserve">
          <source>React community&amp;rsquo;s experiments with render prop APIs, including &lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Ryan Florence&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/reactions/component&quot;&gt;Reactions Component&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Ryan Florence&lt;/a&gt;の&lt;a href=&quot;https://github.com/reactions/component&quot;&gt;Reactions Component&lt;/a&gt;を含むレンダープロップAPIを使用したReactコミュニティの実験。</target>
        </trans-unit>
        <trans-unit id="27be082454b7d8bc7b1e13ab663caeb1f2c60981" translate="yes" xml:space="preserve">
          <source>React components are small, reusable pieces of code that return a React element to be rendered to the page. The simplest version of React component is a plain JavaScript function that returns a React element:</source>
          <target state="translated">React コンポーネントは、ページにレンダリングされる React 要素を返す、再利用可能な小さなコードです。Reactコンポーネントの最も単純なバージョンは、React要素を返すプレーンなJavaScript関数です。</target>
        </trans-unit>
        <trans-unit id="48861e38df56656ab830494ad258a4d6191d07f5" translate="yes" xml:space="preserve">
          <source>React components can also be defined as functions which can be wrapped:</source>
          <target state="translated">Reactコンポーネントは、ラップできる関数として定義することもできます。</target>
        </trans-unit>
        <trans-unit id="e4cc5817b2558aba649764feaed76c372dd8b626" translate="yes" xml:space="preserve">
          <source>React components have their own &amp;ldquo;lifecycle&amp;rdquo;. They may receive props or update state at any point in time. However, each asynchronous request &lt;em&gt;also&lt;/em&gt; has its own &amp;ldquo;lifecycle&amp;rdquo;. It starts when we kick it off, and finishes when we get a response. The difficulty we&amp;rsquo;re experiencing is &amp;ldquo;synchronizing&amp;rdquo; several processes in time that affect each other. This is hard to think about.</source>
          <target state="translated">Reactコンポーネントには独自の「ライフサイクル」があります。彼らはいつでも小道具を受け取ったり状態を更新したりできます。ただし、各非同期リクエストに&lt;em&gt;も&lt;/em&gt;独自の「ライフサイクル」があります。それは私たちがそれを開始したときに始まり、私たちが応答を得たときに終了します。私たちが直面している問題は、互いに影響を与えるいくつかのプロセスを時間内に「同期化」することです。これは考えるのが難しいです。</target>
        </trans-unit>
        <trans-unit id="4222b5a8657725e4a00728011e55a70511e28796" translate="yes" xml:space="preserve">
          <source>React components hide their implementation details, including their rendered output. Other components using &lt;code&gt;FancyButton&lt;/code&gt;&lt;strong&gt;usually will not need to&lt;/strong&gt;&lt;a href=&quot;refs-and-the-dom&quot;&gt;obtain a ref&lt;/a&gt; to the inner &lt;code&gt;button&lt;/code&gt; DOM element. This is good because it prevents components from relying on each other&amp;rsquo;s DOM structure too much.</source>
          <target state="translated">Reactコンポーネントは、レンダリングされた出力を含め、実装の詳細を隠します。 &lt;code&gt;FancyButton&lt;/code&gt; を使用する他のコンポーネント&lt;strong&gt;は通常&lt;/strong&gt;、内部 &lt;code&gt;button&lt;/code&gt; DOM要素への&lt;a href=&quot;refs-and-the-dom&quot;&gt;参照&lt;/a&gt;を取得する&lt;strong&gt;必要はありません&lt;/strong&gt;。これは、コンポーネントが互いのDOM構造に過度に依存するのを防ぐため、優れています。</target>
        </trans-unit>
        <trans-unit id="5817ef7548b0234e3521fa7650bb8ea6c27ada2e" translate="yes" xml:space="preserve">
          <source>React components let you split the UI into independent, reusable pieces, and think about each piece in isolation. React components can be defined by subclassing &lt;code&gt;React.Component&lt;/code&gt; or &lt;code&gt;React.PureComponent&lt;/code&gt;.</source>
          <target state="translated">Reactコンポーネントを使用すると、UIを独立した再利用可能な部分に分割し、各部分を分離して考えることができます。Reactコンポーネントは、 &lt;code&gt;React.Component&lt;/code&gt; または &lt;code&gt;React.PureComponent&lt;/code&gt; をサブクラス化することによって定義できます。</target>
        </trans-unit>
        <trans-unit id="ca8d82c06b82b483efb7cfed08df669ddf86929f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t call &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; with initial props during &lt;a href=&quot;#mounting&quot;&gt;mounting&lt;/a&gt;. It only calls this method if some of component&amp;rsquo;s props may update. Calling &lt;code&gt;this.setState()&lt;/code&gt; generally doesn&amp;rsquo;t trigger &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt;.</source>
          <target state="translated">Reactは、&lt;a href=&quot;#mounting&quot;&gt;マウント&lt;/a&gt;中に初期プロップで &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; を呼び出しません。コンポーネントの小道具の一部が更新される場合にのみ、このメソッドを呼び出します。呼び出し &lt;code&gt;this.setState()&lt;/code&gt; 、一般的にトリガされません &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca31c5026bd08138666663526caeedbe15b5ea02" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t force you to use the ES6 class syntax. If you prefer to avoid it, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module or a similar custom abstraction instead. Take a look at &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; to learn more.</source>
          <target state="translated">Reactは、ES6クラス構文を使用することを強制しません。回避したい場合は、代わりに &lt;code&gt;create-react-class&lt;/code&gt; モジュールまたは同様のカスタム抽象化を使用できます。詳細については、&lt;a href=&quot;react-without-es6&quot;&gt;ES6&lt;/a&gt;を使用せずにReactを使用するをご覧ください。</target>
        </trans-unit>
        <trans-unit id="74b56919404ce18c573bf25676a77e3c0c3ec215" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t have opinions on how you put files into folders. That said there are a few common approaches popular in the ecosystem you may want to consider.</source>
          <target state="translated">Reactは、ファイルをフォルダーに配置する方法について意見を持っていません。とはいえ、エコシステムで人気のあるいくつかの一般的なアプローチについて検討する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="65aea3f2a5c31b29c9426cd1a03d900e3079061c" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle methods, the event handlers don&amp;rsquo;t happen during rendering. So if they throw, React still knows what to display on the screen.</source>
          <target state="translated">Reactは、イベントハンドラーのエラーから回復するためにエラー境界を必要としません。renderメソッドやライフサイクルメソッドとは異なり、イベントハンドラーはレンダリング中には発生しません。したがって、それらがスローされた場合でも、Reactは画面に何を表示するかを認識しています。</target>
        </trans-unit>
        <trans-unit id="8fd4db2f190bce0d1cd19887d508e28c6fb7d62f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t offer a way to &amp;ldquo;attach&amp;rdquo; reusable behavior to a component (for example, connecting it to a store). If you&amp;rsquo;ve worked with React for a while, you may be familiar with patterns like &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow. If you look at a typical React application in React DevTools, you will likely find a &amp;ldquo;wrapper hell&amp;rdquo; of components surrounded by layers of providers, consumers, higher-order components, render props, and other abstractions. While we could &lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;filter them out in DevTools&lt;/a&gt;, this points to a deeper underlying problem: React needs a better primitive for sharing stateful logic.</source>
          <target state="translated">Reactは、再利用可能な動作をコンポーネントに「アタッチ」する方法（たとえば、コンポーネントをストアに接続するなど）を提供していません。 Reactをしばらく使用していた場合は、これを解決しようとする&lt;a href=&quot;render-props&quot;&gt;レンダープロップ&lt;/a&gt;や&lt;a href=&quot;higher-order-components&quot;&gt;高次コンポーネント&lt;/a&gt;などのパターンに精通している可能性があります。ただし、これらのパターンでは、コンポーネントを使用するときにコンポーネントを再構築する必要があります。これにより、コードが扱いにくくなり、コードの追跡が難しくなる場合があります。 React DevToolsで典型的なReactアプリケーションを見ると、プロバイダー、コンシューマー、高次コンポーネント、レンダープロップ、およびその他の抽象化のレイヤーに囲まれたコンポーネントの「ラッパー地獄」が見つかるでしょう。&lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;DevTools&lt;/a&gt;でそれらを除外することもできますが、これは根本的な問題を示しています。Reactはステートフルロジックを共有するためのより優れたプリミティブを必要としています。</target>
        </trans-unit>
        <trans-unit id="f78ca1328cbe2529b63f5cb261c75fa5b40138a1" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t use the &lt;code&gt;state = initialState&lt;/code&gt; argument convention popularized by Redux. The initial value sometimes needs to depend on props and so is specified from the Hook call instead. If you feel strongly about this, you can call &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; to emulate the Redux behavior, but it&amp;rsquo;s not encouraged.</source>
          <target state="translated">Reactは、Reduxによって普及した &lt;code&gt;state = initialState&lt;/code&gt; 引数規則を使用しません。初期値は小道具に依存する必要がある場合があるため、代わりにフック呼び出しから指定されます。これについて強く感じる場合は、 &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; を呼び出してReduxの動作をエミュレートできますが、お勧めしません。</target>
        </trans-unit>
        <trans-unit id="d83294fcb3556b3e4c12f42b28d13fbaa61565e3" translate="yes" xml:space="preserve">
          <source>React elements are &lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;immutable&lt;/a&gt;. Once you create an element, you can&amp;rsquo;t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</source>
          <target state="translated">React要素は&lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;不変&lt;/a&gt;です。要素を作成すると、その子や属性を変更することはできません。要素は、映画の1つのフレームのようなものです。特定の時点でのUIを表します。</target>
        </trans-unit>
        <trans-unit id="72d7e53a8e0f9d5ea79b7f65c786e10e05c2fc30" translate="yes" xml:space="preserve">
          <source>React elements are the building blocks of React applications. One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. An element describes what you want to see on the screen. React elements are immutable.</source>
          <target state="translated">React要素は、Reactアプリケーションのビルディングブロックです。要素を、より広く知られている「コンポーネント」の概念と混同するかもしれません。要素は、画面に表示したいものを記述します。React要素は不変です。</target>
        </trans-unit>
        <trans-unit id="6524f58f9d8f8ab1fca2ad781736505d87a9d6ca" translate="yes" xml:space="preserve">
          <source>React elements like &lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; are just objects, so you can pass them as props like any other data. This approach may remind you of &amp;ldquo;slots&amp;rdquo; in other libraries but there are no limitations on what you can pass as props in React.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; などのReact要素は単なるオブジェクトなので、他のデータと同様に小道具として渡すことができます。このアプローチは他のライブラリの「スロット」を思い出させるかもしれませんが、Reactで小道具として渡すことができるものに制限はありません。</target>
        </trans-unit>
        <trans-unit id="d783a77ced1d87ae35cd28616b7b8dde4c0feec8" translate="yes" xml:space="preserve">
          <source>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</source>
          <target state="translated">React は、レンダリングロジックが他の UI ロジックと本質的に結合しているという事実を受け入れています:イベントがどのように処理されるか、時間の経過とともに状態がどのように変化するか、表示のためにデータがどのように準備されるか。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
