<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="translated">A &lt;code&gt;RawWaker&lt;/code&gt; タスクエグゼキュータの実装を作成することができ&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;カスタマイズウェークアップ動作を提供します。</target>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">A &lt;code&gt;String&lt;/code&gt; だけの内容のように、大きさに成長することができ、その内容を変更することができます &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 、あなたがより多くのデータをプッシュする場合は、それに。さらに、 &lt;code&gt;+&lt;/code&gt; 演算子または &lt;code&gt;format!&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 値を連結するマクロ。</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">あ &lt;code&gt;String&lt;/code&gt; のラッパーである &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 。リスト8-14の適切にエンコードされたUTF-8サンプル文字列のいくつかを見てみましょう。まず、これ：</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">A &lt;code&gt;String&lt;/code&gt; いくつかのバイトへのポインタ、長さ、及び容量：3つのコンポーネントで構成されています。ポインタは、 &lt;code&gt;String&lt;/code&gt; がデータを格納するために使用する内部バッファを指します。長さは現在バッファに格納されているバイト数であり、容量はバイト単位のバッファのサイズです。そのため、長さは常に容量以下になります。</target>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">A &lt;code&gt;SystemTimeError&lt;/code&gt; がから返され&lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt;及び&lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt;の方法&lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt;第2のシステム時間よりも時間的に後の時点を表すときはいつでも &lt;code&gt;self&lt;/code&gt; メソッド呼び出しのを。</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A &lt;code&gt;ThreadId&lt;/code&gt; いずれかを作成するスレッドごとに一意の値を有する不透明なオブジェクトです。 &lt;code&gt;ThreadId&lt;/code&gt; は、スレッドのシステム指定の識別子に対応しているとは限りません。A &lt;code&gt;ThreadId&lt;/code&gt; から取得でき&lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; Aのメソッド&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">A &lt;code&gt;TypeId&lt;/code&gt; 現在のどの帰タイプに対してのみ利用可能である &lt;code&gt;'static&lt;/code&gt; が、この制限は、将来的に除去することができます。</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">あ &lt;code&gt;TypeId&lt;/code&gt; タイプのグローバル一意識別子を表します。</target>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">A &lt;code&gt;Vec&lt;/code&gt; とは、可変することができます。一方、スライスは読み取り専用オブジェクトです。スライスを取得するには、 &lt;code&gt;&amp;amp;&lt;/code&gt; を。例：</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">あ &lt;code&gt;Waker&lt;/code&gt; 実行される準備ができていること、その実行者に通知することによって、タスクを起床のハンドルです。</target>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタは、内の値を一時的に参照を保持するのに有用である&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;の寿命を延長することなく。また、相互に所有している参照ではどちらの&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;も削除できないため、&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインタ間の循環参照を防ぐためにも使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への &lt;code&gt;Weak&lt;/code&gt; ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタは、内の値を一時的に参照を保持するのに有用である&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; の&lt;/a&gt;寿命を延長することなく。また、相互に所有している参照ではどちらの&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;も削除できないため、&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインター間の循環参照を防ぐためにも使用されます。たとえば、ツリーには親ノードから子への強力な&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターがあり、 &lt;code&gt;Weak&lt;/code&gt; から子への弱いポインターがあります。</target>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、通常、最も内側に関連している &lt;code&gt;loop&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 又は &lt;code&gt;while&lt;/code&gt; 囲むループ &lt;code&gt;break&lt;/code&gt; 発現が、A&lt;a href=&quot;loop-expr#loop-labels&quot;&gt;ラベルが&lt;/a&gt;影響を受ける囲むループを指定するために使用することができます。例：</target>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、ループの本体で許可されており、フォームのいずれか有している &lt;code&gt;break&lt;/code&gt; 、 &lt;code&gt;break 'label&lt;/code&gt; 又は（&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;下記参照&lt;/a&gt;） &lt;code&gt;break EXPR&lt;/code&gt; 又は &lt;code&gt;break 'label EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">引数付きの &lt;code&gt;break&lt;/code&gt; ステートメントが非 &lt;code&gt;loop&lt;/code&gt; ループに現れました。</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">ラベルなしの &lt;code&gt;break&lt;/code&gt; ステートメントがラベル付きブロック内に表示されました。</target>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; が変化することはありません一定の値を表しています。一方がかかる場合 &lt;code&gt;&amp;amp;&lt;/code&gt; 定数への参照を、次いで一つは値を含むいくつかのメモリ位置へのポインタを取っています。通常、これは完全に問題ありません。ほとんどの値は共有 &lt;code&gt;&amp;amp;&lt;/code&gt; ポインタを介して変更できませんが、内部の可変性により可能です。つまり、定数値が変更される可能性があります。一方、 &lt;code&gt;static&lt;/code&gt; は明示的に単一のメモリ位置であり、自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 式は、実装によって提供される要素上ループのシンタックス構造である &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; 。イテレータが値を生成し、その値に指定された名前が付けられ、ループの本体が実行されると、制御は &lt;code&gt;for&lt;/code&gt; ループの先頭に戻ります。イテレータが空の場合、 &lt;code&gt;for&lt;/code&gt; 式は完了します。</target>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">A &lt;code&gt;for&lt;/code&gt; ループ膨張示すように：</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 式は、継続的にその本体の実行を繰り返し： &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 、関連のない表現 &lt;code&gt;break&lt;/code&gt; 式が発散して型を持ってさ&lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;loop&lt;/code&gt; 関連含む発現&lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 式（S）が&lt;/a&gt;終了することができる、との値と互換性が入力しておく必要があり &lt;code&gt;break&lt;/code&gt; 式（S）です。</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; scrutinee式があるかどうかに応じて、異なった動作を&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式または値式&lt;/a&gt;。 scrutinee式が&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value式の&lt;/a&gt;場合、最初に一時的な場所で評価され、結果の値は、一致が見つかるまで腕のパターンと順次比較されます。一致するパターンを持つ最初のアームが &lt;code&gt;match&lt;/code&gt; の分岐ターゲットとして選択され、パターンによってバインドされたすべての変数がアームのブロックのローカル変数に割り当てられ、コントロールがブロックに入ります。</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 式は、で構成されている&lt;em&gt;武器&lt;/em&gt;。アームは、&lt;em&gt;パターン&lt;/em&gt;と、 &lt;code&gt;match&lt;/code&gt; 式の先頭に指定された値がそのアームのパターンに適合する場合に実行されるコードで構成されます。Rustは &lt;code&gt;match&lt;/code&gt; 指定された値を取得し、各腕のパターンを順に調べます。 &lt;code&gt;match&lt;/code&gt; 構築物およびパターンは、あなたがあなたのコードが発生し、あなたがそれらすべてを扱うことになるかもしれないさまざまな状況を表現してみましょうルスト強力な機能です。これらの機能については、それぞれ第6章と第18章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; タイプは、他の、互換性のない表現ヒントで注釈しました。</target>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;タイプは、&lt;/em&gt;と呼ばれる他のタイプの不均一な生成物である&lt;em&gt;フィールド&lt;/em&gt;タイプの。&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; ループに相当する &lt;code&gt;loop&lt;/code&gt; を含む発現&lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 式を&lt;/a&gt;次のように。</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">A &lt;code&gt;while let&lt;/code&gt; ループと意味的に類似している &lt;code&gt;while&lt;/code&gt; ループが、それはキーワード予期条件式の代わりに &lt;code&gt;let&lt;/code&gt; 、パターンが続く &lt;code&gt;=&lt;/code&gt; 、&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutineeの&lt;/a&gt;発現およびブロック発現。scrutineeの値がパターンに一致する場合、ループ本体ブロックが実行され、制御はパターンマッチングステートメントに戻ります。それ以外の場合、while式は完了します。</target>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; ループは、ブールループ条件式を評価することによって始まります。ループ条件式の評価が &lt;code&gt;true&lt;/code&gt; の場合、ループ本体ブロックが実行され、制御はループ条件式に戻ります。ループ条件式が &lt;code&gt;false&lt;/code&gt; と評価されると、 &lt;code&gt;while&lt;/code&gt; 式が完了します。</target>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;24ビットコードポイントエスケープ&lt;/em&gt;と開始 &lt;code&gt;U+0075&lt;/code&gt; （ &lt;code&gt;u&lt;/code&gt; ）六のまで続いて&lt;em&gt;進数字が&lt;/em&gt;括弧に囲まれた &lt;code&gt;U+007B&lt;/code&gt; （ &lt;code&gt;{&lt;/code&gt; ）と &lt;code&gt;U+007D&lt;/code&gt; （ &lt;code&gt;}&lt;/code&gt; ）。これは、提供された16進値に等しいUnicodeコードポイントを示します。</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">&lt;em&gt;7ビットのコードポイントエスケープが&lt;/em&gt;始まる &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）とちょうど二つ続いて&lt;em&gt;進数字&lt;/em&gt;の値までと &lt;code&gt;0x7F&lt;/code&gt; の。これは、指定された16進値に等しい値を持つASCII文字を示します。 Unicodeコードポイントを意味するのか、バイト値を意味するのかが不明確であるため、これより高い値は許可されません。</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;let&lt;/code&gt; 文は、&lt;/em&gt;一連の新しい導入し&lt;a href=&quot;variables&quot;&gt;た変数&lt;/a&gt;で与えられ、&lt;a href=&quot;patterns&quot;&gt;パターンを&lt;/a&gt;。パターンの後にはオプションで型注釈が続き、オプションで初期化子式が続きます。型注釈が指定されていない場合、コンパイラーは型を推論するか、十分な型情報が明確な推論に利用できない場合はエラーを通知します。変数宣言によって導入された変数は、宣言の時点から、それを囲むブロックスコープの終わりまで表示されます。</target>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;match&lt;/code&gt; 表現&lt;/em&gt;パターンに分岐します。発生するマッチングの正確な形式は、&lt;a href=&quot;../patterns&quot;&gt;パターン&lt;/a&gt;によって異なります。 &lt;code&gt;match&lt;/code&gt; 発現が有する&lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutineeの&lt;/a&gt;発現&lt;/em&gt;パターンと比較する値です。scrutinee式とパターンは同じ型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">&lt;em&gt;バイナリリテラル&lt;/em&gt;文字列で始まる &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;0b&lt;/code&gt; ）とは二進数字および下線の（少なくとも一桁で）任意の混合物として継続します。</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">&lt;em&gt;ブロック式&lt;/em&gt;、または&lt;em&gt;ブロック&lt;/em&gt;、アイテム、および変数宣言のための制御フロー式と匿名名前空間の範囲です。制御フロー式として、ブロックはそのコンポーネントの非項目宣言ステートメントを順番に実行し、次にその最後のオプションの式を実行します。匿名の名前空間スコープとして、アイテム宣言はブロック自体のスコープ内のみにあり、 &lt;code&gt;let&lt;/code&gt; ステートメントによって宣言された変数は、次のステートメントからブロックの終わりまでスコープ内にあります。</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;バイトエスケープ&lt;/em&gt;エスケープが始まる &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）とちょうど二つ続いて&lt;em&gt;進数字&lt;/em&gt;。これは、提供された16進値に等しいバイトを示します。</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;バイトリテラルは、&lt;/em&gt;（単一のASCII文字である &lt;code&gt;U+0000&lt;/code&gt; に &lt;code&gt;U+007F&lt;/code&gt; の範囲）またはシングル&lt;em&gt;エスケープ&lt;/em&gt;文字によって先行 &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）と &lt;code&gt;U+0027&lt;/code&gt; の文字によって（単一引用符）、及び続く &lt;code&gt;U+0027&lt;/code&gt; 。文字 &lt;code&gt;U+0027&lt;/code&gt; がリテラル内にある場合&lt;em&gt;は&lt;/em&gt;、先行する &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）文字で&lt;em&gt;エスケープ&lt;/em&gt;する必要があります。これは、 &lt;code&gt;u8&lt;/code&gt; 符号なし8ビット整数&lt;em&gt;リテラル&lt;/em&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">&lt;em&gt;呼び出し式は&lt;/em&gt;括弧で囲まれた式リストに続く表現で構成されています。関数を呼び出し、0個以上の入力変数を提供します。関数が最終的に戻ると、式は完了します。以下のための&lt;a href=&quot;../types/function-item&quot;&gt;非関数型&lt;/a&gt;、式f（...）のいずれかの方法を使用して&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt;かどうかが異なる特性、これらは、参照による型、変更可能な参照、または所有権をそれぞれ取得します。必要に応じて、自動借用が行われます。 Rustは、必要に応じて &lt;code&gt;f&lt;/code&gt; を自動的に逆参照します。呼び出し式の例：</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;文字リテラルは&lt;/em&gt; 2内に封入された単一のUnicode文字である &lt;code&gt;U+0027&lt;/code&gt; を除いて（単一引用符）文字 &lt;code&gt;U+0027&lt;/code&gt; する必要があり、それ自体、&lt;em&gt;エスケープ&lt;/em&gt;先行によって &lt;code&gt;U+005C&lt;/code&gt; の文字（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;閉鎖式は&lt;/em&gt;クロージャを定義し、単一式で、値として表します。クロージャ式は、式が続く反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターンの&lt;/a&gt;パイプ記号区切り（ &lt;code&gt;|&lt;/code&gt; ）リストです。オプションで、型の注釈をパラメーターの型または戻り値の型に追加できます。戻り型がある場合、クロージャーの本体に使用される式は通常の&lt;a href=&quot;block-expr&quot;&gt;ブロックで&lt;/a&gt;なければなりません。クロージャ式は、最初の &lt;code&gt;|&lt;/code&gt; の前に &lt;code&gt;move&lt;/code&gt; キーワードで始まることもあります。。</target>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">&lt;em&gt;短所リストは&lt;/em&gt; Lispのプログラミング言語とその方言から来たデータ構造です。Lispでは、 &lt;code&gt;cons&lt;/code&gt; 関数（「構築関数」の略）は、2つの引数（通常は単一の値と別のペア）から新しいペアを構築します。ペアを含むこれらのペアはリストを形成します。</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">&lt;em&gt;constのコンテキストは&lt;/em&gt;、次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;一定の項目は&lt;/em&gt;任意に命名される&lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;定数値&lt;/a&gt;&lt;/em&gt;プログラム内の特定のメモリ位置に関連付けられていません。定数は、使用される場所に基本的にインライン化されます。つまり、使用されると、関連するコンテキストに直接コピーされます。同じ定数への参照は、必ずしも同じメモリアドレスへの参照を保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;クレートは&lt;/em&gt;、コンパイルおよびリンク、ならびにバージョニング、分布およびランタイムローディングの単位です。クレートには、ネストされた&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;スコープの&lt;em&gt;ツリー&lt;/em&gt;が含まれています。このツリーの最上位レベルは（モジュール内のパスの観点から）匿名のモジュールであり、クレート内のアイテムには、クレートのモジュールツリー内の位置を示す正規の&lt;a href=&quot;paths&quot;&gt;モジュールパスがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">A &lt;em&gt;小数リテラル&lt;/em&gt;ピリオドが続く &lt;code&gt;U+002E&lt;/code&gt; （ &lt;code&gt;.&lt;/code&gt; ）。これには、オプションで、別の10進リテラルが続き、オプションで&lt;em&gt;指数が付き&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;小数リテラル&lt;/em&gt;で始まり&lt;em&gt;進数字&lt;/em&gt;との任意の混合物を継続&lt;em&gt;進数字&lt;/em&gt;と&lt;em&gt;アンダー&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;宣言文は、&lt;/em&gt;一つ以上の紹介です&lt;em&gt;名前を&lt;/em&gt;囲む文ブロックに。宣言された名前は、新しい変数または新しい&lt;a href=&quot;items&quot;&gt;項目を&lt;/a&gt;表す場合があります。</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">&lt;em&gt;フィールド表現は&lt;/em&gt;、単一のドットと続く発現から成る&lt;a href=&quot;../identifiers&quot;&gt;識別子&lt;/a&gt;直ちに（後者は常に括弧式リストが続かない場合、&lt;a href=&quot;method-call-expr&quot;&gt;メソッド呼び出し式&lt;/a&gt;）。フィールド式は、&lt;a href=&quot;../items/structs&quot;&gt;構造体&lt;/a&gt;または&lt;a href=&quot;../items/unions&quot;&gt;共用&lt;/a&gt;体のフィールドを示します。構造体に格納されている関数を呼び出すには、フィールド式を括弧で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">&lt;em&gt;浮動小数点リテラルは、&lt;/em&gt;二つの形式のうちの1つを有します。</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">&lt;em&gt;関数は、&lt;/em&gt;から成る&lt;a href=&quot;../expressions/block-expr&quot;&gt;ブロック&lt;/a&gt;名とパラメータのセットと共に、。名前を除いて、これらはすべてオプションです。関数はキーワード &lt;code&gt;fn&lt;/code&gt; で宣言されます。関数は、一連の&lt;em&gt;入力&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;変数&lt;/em&gt;&lt;/a&gt;をパラメーターとして宣言できます。これにより、呼び出し元は関数に引数を渡し、関数は完了時に関数が呼び出し元に返す値の&lt;em&gt;出力&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;型&lt;/em&gt;&lt;/a&gt;を宣言します。</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">&lt;em&gt;一般的な機能は、&lt;/em&gt;一つ以上のことができます&lt;em&gt;パラメータ化された型は、&lt;/em&gt;その署名に表示されます。各型パラメーターは、山かっこで囲まれ、コンマで区切られたリストで、関数名に続いて明示的に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;ハッシュマップは&lt;/em&gt;、あなたが特定のキーと値を関連付けることができます。これは、&lt;em&gt;map&lt;/em&gt;と呼ばれるより一般的なデータ構造の特定の実装です。</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">&lt;em&gt;六角リテラル&lt;/em&gt;文字列で始まる &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;0x&lt;/code&gt; ）と進数字と下線の（少なくとも一桁で）任意の混合物として継続します。</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">&lt;em&gt;リテラル式は、&lt;/em&gt;のいずれかから成る&lt;a href=&quot;../tokens#literals&quot;&gt;リテラル&lt;/a&gt;前述した形態。数値、文字、文字列、またはブール値を直接記述します。</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">&lt;em&gt;ローカル変数&lt;/em&gt;（または&lt;em&gt;スタックローカル&lt;/em&gt;割り当て）は、スタックのメモリ内に割り当てられた値を直接、保持しています。値はスタックフレームの一部です。</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">&lt;em&gt;一致ガードが&lt;/em&gt;追加され &lt;code&gt;if&lt;/code&gt; におけるパターンの後に指定された条件 &lt;code&gt;match&lt;/code&gt; そのアームを選択するためにも、パターンマッチングと共に、一致しなければならないアーム。マッチガードは、パターンだけで許可するよりも複雑なアイデアを表現するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;メソッド呼び出しは、&lt;/em&gt;式（から成る&lt;em&gt;受信機&lt;/em&gt;の単一のドットは、発現経路セグメント、および括弧式リストが続きます）。メソッド呼び出しは、特定の特性の関連&lt;a href=&quot;../items/associated-items#methods&quot;&gt;メソッド&lt;/a&gt;に解決されます。左側の正確な &lt;code&gt;self&lt;/code&gt; 型がわかっている場合は静的にメソッドにディスパッチされ、左側の式が間接&lt;a href=&quot;../types/trait-object&quot;&gt;特性オブジェクトの&lt;/a&gt;場合は動的にディスパッチされます。</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">&lt;em&gt;モジュール項目は&lt;/em&gt;モジュール、括弧で囲まれた名前が付けられ、キーワードの接頭辞である &lt;code&gt;mod&lt;/code&gt; 。モジュール項目は、新しい名前の付いたモジュールをクレートを構成するモジュールのツリーに導入します。モジュールは任意にネストできます。</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">&lt;em&gt;数値リテラルは、&lt;/em&gt;のいずれかである&lt;em&gt;整数リテラル&lt;/em&gt;または&lt;em&gt;浮動小数点リテラル&lt;/em&gt;。2種類のリテラルを認識するための文法が混在しています。</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">&lt;em&gt;パスは、&lt;/em&gt;一つ以上の経路セグメントのシーケンスである&lt;em&gt;論理的&lt;/em&gt;名前空間修飾子（によって分離 &lt;code&gt;::&lt;/code&gt; ）。パスが1つのセグメントのみで構成されている場合、パスは、ローカルコントロールスコープ内の&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;または&lt;a href=&quot;variables&quot;&gt;変数&lt;/a&gt;を参照します。パスに複数のセグメントがある場合、それは常にアイテムを参照します。</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">&lt;em&gt;場所発現は、&lt;/em&gt;メモリ位置を表す式です。これらの式は、&lt;a href=&quot;expressions/path-expr&quot;&gt;パス&lt;/a&gt;ローカル変数を参照し、&lt;a href=&quot;items/static-items&quot;&gt;静的変数&lt;/a&gt;、&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;逆参照&lt;/a&gt;（ &lt;code&gt;*expr&lt;/code&gt; ）、&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;配列のインデックスの&lt;/a&gt;式（ &lt;code&gt;expr[expr]&lt;/code&gt; ）、&lt;a href=&quot;expressions/field-expr&quot;&gt;フィールド&lt;/a&gt;参照（ &lt;code&gt;expr.f&lt;/code&gt; ）と括弧場所表現。他のすべての式は値式です。</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">&lt;em&gt;ポインタは、&lt;/em&gt;メモリ内のアドレスが含まれている変数のための一般的な概念です。このアドレスは、他のいくつかのデータを参照または「ポイント」します。Rustで最も一般的な種類のポインタはリファレンスです。これは、第4章で学習しました。リファレンスは &lt;code&gt;&amp;amp;&lt;/code&gt; 記号で示され、それらが指す値を借ります。データを参照する以外に特別な機能はありません。また、オーバーヘッドがなく、私たちが最もよく使用する種類のポインターです。</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">&lt;em&gt;相対パスは、&lt;/em&gt;現在のモジュールから始まり、使用する &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;super&lt;/code&gt; 、または現在のモジュール内の識別子。</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">&lt;em&gt;スカラー&lt;/em&gt;型は、単一の値を表します。Rustには、整数、浮動小数点数、ブール、文字の4つの主要なスカラー型があります。他のプログラミング言語からこれらを認識できます。Rustでどのように機能するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;ステートメントは、&lt;/em&gt;の構成要素である&lt;a href=&quot;expressions/block-expr&quot;&gt;ブロック&lt;/a&gt;ターン外側の構成要素である、&lt;a href=&quot;expressions&quot;&gt;発現&lt;/a&gt;又は&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;静的項目は&lt;/em&gt;同様である&lt;a href=&quot;constant-items&quot;&gt;定数&lt;/a&gt;、プログラムにおける正確なメモリロケーションを表すことを除いて、。 staticへのすべての参照は、同じメモリ位置を参照しています。静的アイテムには &lt;code&gt;static&lt;/code&gt; ライフタイムがあり、Rustプログラムの他のすべてのライフタイムよりも長く存続します。&lt;a href=&quot;../interior-mutability&quot;&gt;内部で可変&lt;/a&gt;でないタイプを含む非 &lt;code&gt;mut&lt;/code&gt; 静的項目は、読み取り専用メモリに配置できます。静的アイテムは、プログラムの終了時に&lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;を呼び出しません。</target>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;文字列リテラルは&lt;/em&gt; 2で囲まれた任意のUnicode文字のシーケンスである &lt;code&gt;U+0022&lt;/code&gt; を除いて、（二重引用符）文字 &lt;code&gt;U+0022&lt;/code&gt; する必要があり、それ自体、&lt;em&gt;エスケープ&lt;/em&gt;直前で &lt;code&gt;U+005C&lt;/code&gt; の文字（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">&lt;em&gt;文字列のスライスは、&lt;/em&gt;の一部への参照である &lt;code&gt;String&lt;/code&gt; 、それは次のようになります。</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">&lt;em&gt;文字列は、&lt;/em&gt;文字の集合です。前に &lt;code&gt;String&lt;/code&gt; 型について説明しましたが、この章ではそれについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">&lt;em&gt;構造体の式は、&lt;/em&gt;構造体または共用体の値を作成します。これは、&lt;a href=&quot;../items/structs&quot;&gt;構造体&lt;/a&gt;または&lt;a href=&quot;../items/unions&quot;&gt;共用&lt;/a&gt;体アイテムへのパスと、それに続くアイテムのフィールドの値で構成されます。構造体式には、構造体、タプル、ユニットの3つの形式があります。</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;構造体は&lt;/em&gt;、公称である&lt;a href=&quot;../types/struct&quot;&gt;構造体型&lt;/a&gt;キーワードで定義された &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">&lt;em&gt;構造体&lt;/em&gt;、または&lt;em&gt;構造は&lt;/em&gt;、あなたが意味のあるグループを構成する複数の関連値に名前を付け、一緒にパッケージ化することができますカスタムデータ型です。オブジェクト指向言語に精通している場合、&lt;em&gt;構造体&lt;/em&gt;はオブジェクトのデータ属性のようなものです。この章では、タプルと構造体を比較対照し、構造体の使用方法を示し、メソッドと関連関数を定義して、構造体のデータに関連付けられた動作を指定する方法について説明します。構造体と列挙型（第6章で説明）は、Rustのコンパイル時の型チェックを最大限に活用するためにプログラムのドメインで新しい型を作成するための構成要素です。</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">&lt;em&gt;テストでは、二重の&lt;/em&gt;テスト中に、別のタイプの代わりに使用するタイプのための一般的なプログラミングの概念です。&lt;em&gt;モックオブジェクト&lt;/em&gt;は、テスト中に発生したことを記録する特定のタイプのテストダブルであり、正しいアクションが行われたことをアサートできます。</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">&lt;em&gt;スレッドプールが&lt;/em&gt;待っていると、タスクを処理する準備ができている生成されたスレッドのグループです。プログラムは新しいタスクを受け取ると、プール内のスレッドの1つをタスクに割り当て、そのスレッドがタスクを処理します。プール内の残りのスレッドは、最初のスレッドの処理中に発生する他のタスクを処理するために使用できます。最初のスレッドがタスクの処理を完了すると、アイドルスレッドのプールに戻され、新しいタスクを処理する準備が整います。スレッドプールを使用すると、接続を同時に処理できるため、サーバーのスループットが向上します。</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">&lt;em&gt;形質実装は&lt;/em&gt;、オプションのジェネリック型宣言が続いていることを除いて、固有の実装のように定義され&lt;a href=&quot;traits&quot;&gt;た形質&lt;/a&gt;キーワードが続く &lt;code&gt;for&lt;/code&gt; 。公称タイプへのパスが続きます。</target>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;形質オブジェクトは&lt;/em&gt;特性のセットを実装する他のタイプの不透明な値です。一連の特性は、&lt;a href=&quot;../items/traits#object-safety&quot;&gt;オブジェクトセーフの&lt;/a&gt;&lt;em&gt;基本特性&lt;/em&gt;と任意の数の&lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;自動特性で構成され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">&lt;em&gt;トレイトは&lt;/em&gt;型が実装できるという抽象インタフェースを記述します。このインターフェースは、次の3種類の&lt;a href=&quot;associated-items&quot;&gt;関連アイテム&lt;/a&gt;で構成されています。</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">&lt;em&gt;特徴は&lt;/em&gt;、特定のタイプがあり、他のタイプと共有することができた機能について錆コンパイラに指示します。トレイトを使用して、共有される動作を抽象的な方法で定義できます。特性境界を使用して、ジェネリックが特定の動作をする任意のタイプになるように指定できます。</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;タプルインデックスが&lt;/em&gt;いずれかである &lt;code&gt;0&lt;/code&gt; 、又はから始まり&lt;em&gt;ゼロでない小数の桁&lt;/em&gt;と0個以上の桁を続けます。タプルインデックスは、&lt;a href=&quot;types/tuple&quot;&gt;タプル&lt;/a&gt;、&lt;a href=&quot;items/structs&quot;&gt;タプル構造体&lt;/a&gt;、&lt;a href=&quot;items/enumerations&quot;&gt;タプルバリアント&lt;/a&gt;のフィールドを参照するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;em&gt;タプル構造体は&lt;/em&gt;、公称で&lt;a href=&quot;../types/tuple&quot;&gt;タプルタイプ&lt;/a&gt;もキーワードで定義され、 &lt;code&gt;struct&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">&lt;em&gt;タプルの構造体の&lt;/em&gt;タイプは、フィールドが匿名であること以外は、単に構造体型のようなものです。</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">&lt;em&gt;タイプの別名は&lt;/em&gt;既存の新しい名前を定義する&lt;a href=&quot;../types&quot;&gt;タイプ&lt;/a&gt;。タイプエイリアスはキーワード &lt;code&gt;type&lt;/code&gt; 宣言されます。すべての値には単一の特定のタイプがありますが、いくつかの異なる特性を実装したり、いくつかの異なるタイプ制約と互換性がある場合があります。</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">&lt;em&gt;型の式&lt;/em&gt;で定義されている&lt;em&gt;タイプの&lt;/em&gt;文法規則は、上記の型を参照するための構文です。以下を参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;ユニオン型は&lt;/em&gt;、公称、異種C状組合の名前で示され&lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; アイテム&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">&lt;em&gt;ユニット状の構造体は、&lt;/em&gt;全体のフィールドのリストをオフに残すことによって定義された任意のフィールドなしで構造体です。このような構造体は、同じ名前の型の定数を暗黙的に定義します。例えば：</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">&lt;em&gt;ユニット状の構造体の&lt;/em&gt;タイプは、それがフィールドを持っていないことを除いて、構造体型のようなものです。関連する&lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct式&lt;/a&gt;によって構築される1つの値は、そのような型に存在する唯一の値です。</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">&lt;em&gt;使用宣言は、&lt;/em&gt;他のいくつかのと同義一つ以上のローカル名のバインディングを作成&lt;a href=&quot;../paths&quot;&gt;パスを&lt;/a&gt;。通常、 &lt;code&gt;use&lt;/code&gt; 宣言は、モジュール項目を参照するために必要なパスを短くするために使用されます。これらの宣言は、通常は上部にある&lt;a href=&quot;modules&quot;&gt;モジュール&lt;/a&gt;および&lt;a href=&quot;../expressions/block-expr&quot;&gt;ブロックに&lt;/a&gt;表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">&lt;em&gt;値式は、&lt;/em&gt;実際の値を表す式です。</target>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;変数は、&lt;/em&gt;スタックフレームの構成要素、いずれかの名前の関数のパラメータ、匿名で&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;の一時的な&lt;/a&gt;、または名前のローカル変数。</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">&lt;em&gt;ベクターは、&lt;/em&gt;あなたが隣同士に値の可変数を格納することができます。</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">&lt;em&gt;空白のエスケープは、&lt;/em&gt;文字の一つである &lt;code&gt;U+006E&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; ）、 &lt;code&gt;U+0072&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; ）、または &lt;code&gt;U+0074&lt;/code&gt; （ &lt;code&gt;t&lt;/code&gt; ユニコード値表す） &lt;code&gt;U+000A&lt;/code&gt; （LF）、 &lt;code&gt;U+000D&lt;/code&gt; （CR）または &lt;code&gt;U+0009&lt;/code&gt; （HT）それぞれ。</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">&lt;em&gt;空白のエスケープは、&lt;/em&gt;文字の一つである &lt;code&gt;U+006E&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; ）、 &lt;code&gt;U+0072&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; ）、または &lt;code&gt;U+0074&lt;/code&gt; （ &lt;code&gt;t&lt;/code&gt; バイト値を表す） &lt;code&gt;0x0A&lt;/code&gt; （ASCII LF）、 &lt;code&gt;0x0D&lt;/code&gt; の（ASCII CR）または &lt;code&gt;0x09&lt;/code&gt; の（ASCII HTを）それぞれ。</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">&lt;em&gt;ワークスペースは、&lt;/em&gt;同じ共有パッケージのセットです&lt;em&gt;Cargo.lock&lt;/em&gt;と出力ディレクトリを。ワークスペースを使用してプロジェクトを作成してみましょう。簡単なコードを使用して、ワークスペースの構造に集中できるようにします。ワークスペースを構成する方法はいくつかあります。 1つの一般的な方法を示します。バイナリと2つのライブラリを含むワークスペースがあります。主な機能を提供するバイナリは、2つのライブラリに依存します。 1つのライブラリは &lt;code&gt;add_one&lt;/code&gt; 関数を提供し、2番目のライブラリは &lt;code&gt;add_two&lt;/code&gt; 関数を提供します。これらの3つの木枠は、同じワークスペースの一部になります。まず、ワークスペース用の新しいディレクトリを作成します。</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">&lt;strong&gt;マルチ&lt;/strong&gt;同時に複数のハードウェアスレッドを実行するシステムは、マルチスレッドのシナリオでは、同期化に対処するプリミティブの二種類を使用することができます。</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">&lt;strong&gt;送信&lt;/strong&gt;チャネルの受信側がデータを受信することはないことができることを意味している、切断された場合の動作にのみ失敗する可能性があります。エラーには、ペイロードとして送信されるデータが含まれているため、回復できます。</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">&lt;strong&gt;単一のプロセッサ&lt;/strong&gt;命令を実行する&lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;アウトオブオーダー&lt;/a&gt;：現代CPUは可能である&lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;スーパースカラー&lt;/a&gt;実行、すなわち、複数の命令は、マシンコードがシーケンシャルプロセスを記述していても、同時に実行されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">代わりにBツリーは、各ノードに連続した配列のB-1から2B-1の要素を含めます。これにより、割り当て数をB倍に削減し、検索のキャッシュ効率を向上させます。ただし、これは平均して&lt;em&gt;より多くの&lt;/em&gt;比較を行う必要があることを意味します。比較の正確な数は、使用するノード検索戦略によって異なります。最適なキャッシュ効率のために、ノードを線形的に検索することができます。最適な比較のために、バイナリサーチを使用してノードを検索できます。妥協案として、iの選択について最初はすべてのi &lt;sup&gt;番目の&lt;/sup&gt;要素のみをチェックする線形検索を実行することもできます。</target>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">HTTP リクエストの詳細</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">条件変数</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">Rust のバイナリまたはライブラリ。</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">Rust プログラムは、各ホワイトスペース要素がスペース 1 文字などの他の合法的なホワイトスペース要素で置き換えられている場合、同一の意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Rustソースファイルはモジュールを記述します。その名前と場所（現在のクレートのモジュールツリー内）は、ソースファイルの外部から定義されます。参照するソースファイルの明示的な&lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt;アイテム、または木枠自体。すべてのソースファイルはモジュールですが、すべてのモジュールが独自のソースファイルを必要とするわけではありません。&lt;a href=&quot;items/modules&quot;&gt;モジュール定義&lt;/a&gt;は1つのファイル内にネストできます。</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">エラーを伝播するためのショートカット： &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; オペレーター</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">TCP ソケットサーバで、接続をリッスンします。</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">ローカルとリモートのソケット間の TCP ストリーム。</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">リファクタリングのタッチ</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">ラスト・スタンダード・ライブラリーを巡る</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">UDP ソケットです。</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">UTF-8でエンコードされた成長可能な文字列。</target>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">Unix データグラムソケット。</target>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">Unix ストリームソケット。</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">内部変異性のユースケース モックオブジェクト</target>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C:&lt;/code&gt; や &lt;code&gt;\server\share&lt;/code&gt; などのWindowsパスプレフィックス。</target>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">バリアは、複数のスレッドがいくつかの計算の開始を同期させることを可能にします。</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バリアは、&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;を呼び出す &lt;code&gt;n&lt;/code&gt; -1スレッドをブロックし、 &lt;code&gt;n&lt;/code&gt; 番目のスレッドが&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; を&lt;/a&gt;呼び出すと、すべてのスレッドを一度に起動します。</target>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">基本的な例です。</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; タイプの基本的な文字列宣言：</target>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">バイナリはエントリポイントを1つだけ持つことができ、デフォルトではそのエントリポイントは関数 &lt;code&gt;main()&lt;/code&gt; です。そのような機能が複数ある場合は、名前を変更してください。</target>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">サポートされていない型でバイナリ操作が試みられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">縛りが何かに影を落としていた。</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">別のブロック表現の末尾表現としてのブロック表現。</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">&lt;a href=&quot;../unsafety&quot;&gt;安全でない操作&lt;/a&gt;を許可するために、コードのブロックの前に &lt;code&gt;unsafe&lt;/code&gt; キーワードを付けることができます。例：</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">コードのブロックの前に &lt;code&gt;unsafe&lt;/code&gt; キーワードを付けると、安全で &lt;code&gt;unsafe&lt;/code&gt; 関数を呼び出したり、安全な関数内で生のポインタを逆参照したりできます。</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">ブログ記事は空の下書きから始まります。</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">スレッド間で安全に共有できるブール型。</target>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">内部変異性を含む定数の借用が試みられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">借りた変数がクロージャで使用されていました。誤ったコードの例。</target>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">ブロードキャストアドレスでは、&lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919で&lt;/a&gt;定義されているように、すべてのオクテットが255に設定されています。</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">狭すぎるバッファ。</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Read::read_vectored&lt;/code&gt; 使用されるバッファタイプ。</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Write::write_vectored&lt;/code&gt; 使用されるバッファタイプ。</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">HashMap内のキーと値のペアが格納される場所を計算するためのビルダーです。</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">様々なマナーでディレクトリを作成するために使用されるビルダーです。</target>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">&lt;code&gt;park&lt;/code&gt; への呼び出しは、スレッドが永久にパークされたままであることを保証するものではなく、呼び出し側はこの可能性に備える必要があります。</target>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">細いポインターと太いポインターの間にキャストを入れようとした。</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; へのキャストが &lt;code&gt;u8&lt;/code&gt; 以外のタイプで試行されました。</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">サイズのないタイプへのキャストを試みました。</target>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">プログラミングのチャネルには、送信機と受信機の2つの半分があります。トランスミッターの半分はゴム製のアヒルを川に入れる上流の場所であり、レシーバーの半分はゴム製のアヒルが下流に到達する場所です。コードの一部では、送信するデータを使用してトランスミッターのメソッドを呼び出し、別の部分では、受信側で到着メッセージを確認します。トランスミッターまたはレシーバーの半分がドロップされると、チャネルは&lt;em&gt;閉じられた&lt;/em&gt;と言います。</target>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">文字の種類。</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">浮動小数点数の分類。</target>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">クローンオンライトのスマートポインタ。</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">クロージャー式は、パラメーターのリストを、パラメーターに続く式にマップする関数を示します。&lt;a href=&quot;../statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; バインディング&lt;/a&gt;と同様に、パラメーターは反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターン&lt;/a&gt;であり、その型注釈はオプションであり、指定されない場合はコンテキストから推測されます。各クロージャー式には、一意の匿名型があります。</target>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">閉鎖はある&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;、それが独特の不変または可変参照することにより任意の値をキャプチャしていない場合は、コピーまたは移動することによって、それはキャプチャすべての値がある場合、&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;、それぞれ。</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">閉鎖はされて&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;一意でない不変の参照で撮影したすべての変数がある場合&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;、および独自の不変または可変の参照、コピー、または移動で撮影したすべての値がされて&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">キャプチャーされたすべての変数が&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; の&lt;/a&gt;場合、クロージャーは&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">クロージャまたはジェネレータは、それ自身の型を参照するように構築されました。</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">クロージャーを使用したが、期待した形質を実装していなかった。</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">キャプチャされた変数の外に移動しないクロージャーは&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; を&lt;/a&gt;実装し、変更可能な参照によって呼び出せることを示します。</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">キャプチャされた変数を変更または移動しないクロージャーは&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; を&lt;/a&gt;実装し、共有参照から呼び出すことができることを示します。</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">想定される強制の場所は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">メッセージをストリームにフォーマットするために必要なメソッドのコレクション。</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">一般的な例は、 &lt;code&gt;Iterator&lt;/code&gt; の &lt;code&gt;collect&lt;/code&gt; メソッドです。これには &lt;code&gt;FromIterator&lt;/code&gt; がバインドされたジェネリック型パラメーターがあり、 &lt;code&gt;char&lt;/code&gt; イテレーターの場合、 &lt;code&gt;Vec&lt;/code&gt; や &lt;code&gt;String&lt;/code&gt; などによって実装されます。文字列の文字を逆にする次のスニペットを考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">型のクラスの共通インタフェース。</target>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">よくある誤解は、「ユニキャストリンクローカルアドレスは &lt;code&gt;fe80::&lt;/code&gt; 始まる」と考えることですが、&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291は&lt;/a&gt;実際にはこれらのアドレスに対してより厳密な形式を定義しています。</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">エラーを示すために戻り値を使用する際の一般的な問題は、戻り値を無視しやすいため、エラーの処理に失敗することです。&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;#[must_use]&lt;/code&gt; 属性で注釈が付けられます。これにより、結果値が無視されたときにコンパイラーが警告を発行します。これにより、エラーが発生する可能性があるが、それ以外の場合は有用な値を返さない関数で、&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; が&lt;/a&gt;特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">オブジェクトを明示的に複製する能力の共通の特徴。</target>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 一般的な使用法！文字列の連結と補間です。同じ規則が&lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;も使用されます！そして&lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;文字列の目的の宛先に応じて、マクロ。</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">この機能の一般的な用途は、 &lt;code&gt;drop&lt;/code&gt; が呼び出されたときに &lt;code&gt;panicking&lt;/code&gt; をチェックすることにより、安全でないコードを記述するときに共有リソースを汚染することです。</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">機能をテストする一般的な方法は、テスト対象のコードの結果を、コードが返すと予想される値と比較して、それらが等しいことを確認することです。 &lt;code&gt;assert!&lt;/code&gt; を使用してこれを行うことができます！マクロを使用し、 &lt;code&gt;==&lt;/code&gt; 演算子を使用して式を渡します。ただし、これは非常に一般的なテストであるため、標準ライブラリには、 &lt;code&gt;assert_eq!&lt;/code&gt; というマクロのペアが用意されています。そして &lt;code&gt;assert_ne!&lt;/code&gt; -このテストをより便利に実行するため。これらのマクロは、2つの引数が等しいか等しくないかをそれぞれ比較します。また、アサーションが失敗した場合は2つの値を出力する&lt;em&gt;ため&lt;/em&gt;、テストが失敗した&lt;em&gt;理由を&lt;/em&gt;簡単に確認できます。逆に、 &lt;code&gt;assert!&lt;/code&gt; マクロは、それが &lt;code&gt;false&lt;/code&gt; になったことのみを示します値 &lt;code&gt;==&lt;/code&gt; 表現、しないように値をリード &lt;code&gt;false&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; を使用する一般的な方法は、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; と組み合わせることです。 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 使用すると、一部のデータの複数の所有者を持つことができますが、そのデータへの不変のアクセスのみが可能であることを思い出してください。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を保持するRc &amp;lt;T&amp;gt;がある場合、複数の所有者&lt;em&gt;を&lt;/em&gt;持つことができ、変更できる値を取得できます！&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">環境変数があるかどうかに関わらず、このマクロを使用してもコンパイル時のエラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">コンパイラのメモリフェンス。</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">コンパイラ専用のメモリバリア。</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">設定オプション。このオプションが設定されている場合は真、設定されていない場合は偽となります。</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">借用ルールの結果として、不変の値がある場合、それを可変に借用することはできません。たとえば、次のコードはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; と書かれた、ヒープに割り当てられたコンテンツを含む連続した拡張可能な配列型。</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; と記述されているが「ベクトル」と発音される、連続する拡張可能な配列型。</target>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">呼び出し側に &lt;code&gt;io::Result&lt;/code&gt; をバブリングする便利な関数：</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; の実装に委任する便利な実装</target>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">クレートは、ECMA-335 CLIモデルの&lt;em&gt;アセンブリ&lt;/em&gt;、SML / NJ Compilation Managerの&lt;em&gt;ライブラリ&lt;/em&gt;、Owens and Flattモジュールシステムの&lt;em&gt;ユニット&lt;/em&gt;、またはMesaの&lt;em&gt;構成&lt;/em&gt;に多少似てい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">クレートは、グローバルに利用可能な「ヘルパーモジュール」を必要としますが、そのヘルパーモジュールをパブリックAPIとして公開したくありません。これを達成するためには、クレートの階層のルートはプライベートモジュールを持ち、そのモジュールは内部的に &quot;公開API &quot;を持ちます。クレート全体がルートの子孫であるため、ローカルのクレート全体が2番目のケースでこのプライベートモジュールにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; &lt;a href=&quot;items/functions&quot;&gt;関数&lt;/a&gt;を含むクレートは、実行可能ファイルにコンパイルできます。 &lt;code&gt;main&lt;/code&gt; 関数が存在する場合、それは引数を取ってはならず、&lt;a href=&quot;trait-bounds&quot;&gt;トレイトまたはライフタイムの境界を&lt;/a&gt;宣言してはならず、&lt;a href=&quot;items/generics#where-clauses&quot;&gt;where句&lt;/a&gt;があってはならず、戻り値の型は次のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">クレートは、関連する機能をスコープにグループ化するため、機能は複数のプロジェクト間で簡単に共有できます。たとえば、&lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;第2章で&lt;/a&gt;使用した &lt;code&gt;rand&lt;/code&gt; クレートは、乱数を生成する機能を提供します。 &lt;code&gt;rand&lt;/code&gt; クレートをプロジェクトのスコープに含めることで、この機能を自分のプロジェクトで使用できます。 &lt;code&gt;rand&lt;/code&gt; クレートが提供するすべての機能は、クレートの名前 &lt;code&gt;rand&lt;/code&gt; を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">クロス ク レ イ ト の opt-out trait が、 struct 型でも enum 型でもないものに実装 さ れていました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインタ間のサイクルが割り当て解除されることはありません。このため、&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;はサイクルを中断するために使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Arc&lt;/code&gt; ポインター間のサイクルが割り当て解除されることはありません。このため、&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;はサイクルを中断するために使用されます。たとえば、ツリーには、親ノードから子への強い &lt;code&gt;Arc&lt;/code&gt; ポインターと、子から親への&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">スレッドがパニックになると、データ構造が一時的に無効な状態になります。</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">デフォルトの構成は &lt;code&gt;Command::new(program)&lt;/code&gt; を使用して生成できます。ここで、 &lt;code&gt;program&lt;/code&gt; は実行するプログラムへのパスを提供します。追加のビルダーメソッドを使用すると、スポーン前に構成を変更できます（たとえば、引数を追加することで）。</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">実装された形質にないメソッドの定義が形質の実装で与えられました。</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">型定義に含まれていない &lt;code&gt;enum&lt;/code&gt; 型の判別式。</target>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">何も文書化されていない文書コメントが見つかりました。</target>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">方向を反転させたダブルエンドのイテレータ。</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">成長可能なリングバッファを用いて実装されたダブルエンドキュー。</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">所有ノードを持つ二重リンクリスト。</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; のドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; の要素に対するドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の要素のドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対するドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の項目のドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">動的サイズ型(DST)とは、統計的に知られているサイズやアラインメントを持たない型のことです。</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">連続するシーケンス &lt;code&gt;[T]&lt;/code&gt; への動的サイズのビュー。</target>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">削除されたフィーチャという名前のフィーチャ属性。</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">コンパイラのコマンドライン・フラグで禁止されていた機能の名前を付けたフィーチャ属性。</target>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">（少なくとも）&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;順序付けセマンティクスを持つフェンス 'A'は、（少なくとも）&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;セマンティクスを持つフェンス 'B'と同期します。操作XとYが存在する場合にのみ、両方とも何らかのアトミックオブジェクト 'M'で動作します。つまり、AはXの前にシーケンスされ、YはBの前に同期され、YはMへの変更を観察します。これにより、AとBの間で発生前の依存関係が提供されます。</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;両方のセマンティクスを持つことに加えて、&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;順序を持つフェンスは、他の&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;操作またはフェンス、あるいはその両方のグローバルプログラム順序に参加します。</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">フィールドアクセスは、そのフィールドの場所を参照する&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式&lt;/a&gt;です。サブ式が&lt;a href=&quot;../expressions#mutability&quot;&gt;mutableの&lt;/a&gt;場合、フィールド式も変更可能です。</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">行外のモジュールにファイルが見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Rustが &lt;code&gt;String&lt;/code&gt; にインデックスを付けて文字を取得することを許可しない最後の理由は、インデックス付け操作が常に一定の時間（O（1））を要すると予想されるためです。ただし、Rustはコンテンツを最初からインデックスまで順番に調べて、有効な文字の数を判断する必要があるため、 &lt;code&gt;String&lt;/code&gt; でそのパフォーマンスを保証することはできません。</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">有限異種シーケンス &lt;code&gt;(T, U, ..)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[T; N]&lt;/code&gt; で表される固定サイズの配列 N]、要素タイプ &lt;code&gt;T&lt;/code&gt; および非負のコンパイル時定数サイズ &lt;code&gt;N&lt;/code&gt; の場合。</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">forループは以下のブロック式と等価です。</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">フォーマット文字列はすべての引数を使用する必要があり、そうでない場合はコンパイル時エラーとなります。フォーマット文字列では、同じ引数を複数回参照することができます。</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 属性で注釈が付けられた関数には、 &lt;code&gt;ignore&lt;/code&gt; 属性で注釈を付けることもできます。&lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; 属性が&lt;/em&gt;テストとしてその機能を実行しないようにテストハーネスを伝えます。テストモードでもコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; を返す &lt;code&gt;test&lt;/code&gt; 属性で注釈が付けられた関数は、 &lt;code&gt;should_panic&lt;/code&gt; 属性で注釈を付けることもできます。&lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt;&lt;em&gt;属性は、&lt;/em&gt;テストはそれだけであれば、実際にパニックを渡すことができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">コンパイル時に式の値を知る必要があるため、const の初期化式では関数呼び出しは許可されません。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">externブロックで宣言された関数は暗黙的に &lt;code&gt;unsafe&lt;/code&gt; はありません。関数ポインターに強制型変換されると、externブロックで宣言された関数の型は &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; 、ここで &lt;code&gt;'l1&lt;/code&gt; 、... &lt;code&gt;'lm&lt;/code&gt; はその存続期間パラメーター、 &lt;code&gt;A1&lt;/code&gt; 、...、 &lt;code&gt;An&lt;/code&gt; はそのパラメーターの宣言されたタイプ、 &lt;code&gt;R&lt;/code&gt; は宣言された戻りタイプです。</target>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">関数または関数ポインタ。</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">関数シグネチャは、関数が持つパラメータの数とタイプを宣言する必要があります。一方、マクロは可変数のパラメーターを取ることができます。1つの引数で &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; を呼び出すか、2つの引数で &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; を呼び出すことができます。また、マクロは、コンパイラーがコードの意味を解釈する前に展開されるため、たとえば、マクロは特定の型に特性を実装できます。関数は実行できません。実行時に呼び出され、コンパイル時に特性を実装する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">パラメータを持つ、または1から100までの数値のみを返す関数は、 &lt;code&gt;i32&lt;/code&gt; ではなく &lt;code&gt;Guess&lt;/code&gt; を受け取るか返すことをシグネチャで宣言でき、本体で追加のチェックを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">オプティマイザに不透明な関数で、ベンチマークが出力を使用するふりをしてデッドコードの排除を回避できるようにします。</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 属性を持つ関数が型パラメーターで宣言されました。</target>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">未来とは、まだ計算が終わっていないかもしれない値のことです。この種の「非同期値」は、値が利用可能になるのを待つ間、スレッドが有用な作業を続けることを可能にします。</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">未来は非同期計算を表します。</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">借用データへの &lt;code&gt;Clone&lt;/code&gt; の一般化。</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">ジェネリック関数も同様に扱わなければなりません。</target>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">一般的な型は、角括弧ではなく括弧を使って記述しました。例えば</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">1つ以上の関連付けられたタイプに特定の割り当てがある総称タイプ（例： &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">ゲスい音符 👻👻👻👻</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">与えられた Matcher M は 3 つの集合に写ります。FIRST(M),LAST(M),FOLLOW(M)です.</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">この手法が役立つ状況の良い例は、オペレーターのオーバーロードです。&lt;em&gt;演算子のオーバーロード&lt;/em&gt;とは、特定の状況での演算子（ &lt;code&gt;+&lt;/code&gt; など）の動作をカスタマイズすることです。</target>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が無人の場合は実行できない安全でない関数のガード：これは静的にパニックするか、何もしません。</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">子プロセスの標準入力 (stdin)へのハンドル。</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">子プロセスの標準出力 (stdout)へのハンドル。</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">子プロセスの標準エラーへのハンドル。</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">スレッドへのハンドル。</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">現在のプロセスのグローバル標準出力ストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">プロセスの標準エラーストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">プロセスの標準入力ストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">線形プロービングとロビンフッドのバケツ盗みを用いて実装されたハッシュマップ。</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">二次プロービングとSIMDルックアップを用いて実装されたハッシュマップ。</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;()&lt;/code&gt; である &lt;code&gt;HashMap&lt;/code&gt; として実装されたハッシュセット。</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">ハッシュ可能なタイプ。</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">逆順化のためのヘルパー構造体です。</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">インデックス操作に使用されるヘルパー形質。</target>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">lang項目を再定義しました。</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; によって提供される多数の構造は、I / Oを反復するさまざまな方法のためのものです。たとえば、&lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; は行&lt;/a&gt;を分割するために使用されます。</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の共通部分に要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の共通部分に要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の対称的な違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の対称的な違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の和集合で要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の和集合で要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">ライブラリ開発者は、ライブラリにリンクするクレートに機能を公開する必要があります。最初のケースの結果として、これは、外部で使用できるものはすべて、ルートから宛先アイテムまでの &lt;code&gt;pub&lt;/code&gt; なければならないことを意味します。チェーン内のプライベートアイテムは、外部アクセスを許可しません。</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">ライフタイムは、関連付けられたタイプのバインディングでのみ表示され、形質への入力タイプでは表示されません。</target>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">ライフタイムバインドが満たされていなかった。</target>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">ライフタイム名は、同じスコープ内で複数回宣言することはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">ライフタイム名が別のライフタイム名の影になっています。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">リンク名が空の名前で与えられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">name パラメータを指定せずにリンクを使用しました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">lintチェック属性は、外側のスコープまたは &lt;code&gt;-F&lt;/code&gt; オプションを指定したコマンドラインで属性として設定された &lt;code&gt;forbid&lt;/code&gt; ディレクティブによって無効にされました。</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">lintチェックは、到達できないコードや省略されたドキュメントなど、潜在的に望ましくないコーディングパターンを示します。糸くずの属性は、 &lt;code&gt;allow&lt;/code&gt; 、 &lt;code&gt;warn&lt;/code&gt; 、 &lt;code&gt;deny&lt;/code&gt; 、および &lt;code&gt;forbid&lt;/code&gt; 使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt;属性が適用されるエンティティの糸くずのレベルを変更するために糸くず名のリストを指定する構文を。</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">使用可能な外部langアイテムのリストは、 &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; にあります。例：</target>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">I/Oエラーの一般的なカテゴリを指定したリスト。</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">各要素、つまり &lt;code&gt;[x, y, z]&lt;/code&gt; のリスト。</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">リテラルは、トークンのシーケンスではなく単一のトークンで構成される式であり、名前やその他の評価ルールで参照するのではなく、評価する値を直接かつ直接示します。リテラルは&lt;a href=&quot;const_eval#constant-expressions&quot;&gt;定数式の&lt;/a&gt;形式であるため、コンパイル時に（主に）評価されます。</target>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">リテラルをサポートしない組み込み属性でリテラルが使用されました。</target>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stderr&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdin&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdout&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">ロックされた標準入力は &lt;code&gt;BufRead&lt;/code&gt; を実装します：</target>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">ループ式にはオプションで&lt;em&gt;ラベルを付ける&lt;/em&gt;ことができます。ラベルは、 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; ように、ループ式の前に存続期間として書き込まれます。}、 &lt;code&gt;'bar: while false {}&lt;/code&gt; 、 &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; 。ラベルが存在する場合、このループ内にネストされたラベル付きの &lt;code&gt;break&lt;/code&gt; および &lt;code&gt;continue&lt;/code&gt; 式は、このループを終了するか、制御を先頭に戻す場合があります。&lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break式&lt;/a&gt;と&lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue式を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">非可逆デコーダーは、 &lt;code&gt;Err&lt;/code&gt; の結果を置換文字に置き換えることで取得できます。</target>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">マクロ呼び出しはコンパイル時にマクロを実行し、呼び出しをマクロの結果に置き換えます。マクロは、次のような状況で呼び出されることがあります。</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">インポート用にリストアップされたマクロが見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">CPU機能がx86 / x86-64プラットフォームで使用可能かどうかを&lt;em&gt;実行時&lt;/em&gt;にテストするマクロ。</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">コンパイラの主な目標は、どのような成果物でもライブラリが二度以上現れないようにすることです。例えば、ダイナミック・ライブラリ B と C がそれぞれライブラリ A に静的にリンクされている場合、A のコピーが 2 つあるため、クレートは B と C を一緒にリンクすることができません。</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">B-Treeをベースにした地図。</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">共有参照が巻き戻しセーフとみなされる型を表すマーカー形質。</target>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">ことを表現するマーカー形質 &lt;code&gt;ReverseSearcher&lt;/code&gt; のために使用することができる &lt;code&gt;DoubleEndedIterator&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Rustで「パニックセーフ」タイプを表すマーカー形質。</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unpin&lt;/code&gt; を実装しないマーカータイプ。</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">単調に減少しないクロックの測定値。不透明で、 &lt;code&gt;Duration&lt;/code&gt; でのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">システムクロックの測定値で、ファイルシステムや他のプロセスのような外部エンティティとの通信に便利です。</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 属性を使用して標準ライブラリのデフォルトとして登録できるメモリアロケータ。</target>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">メタ変数は、マッチャーで行われたのとまったく同じ数、種類、および繰り返しのネストのネスト順で出現する必要があります。したがって、マッチャー &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 場合、転写者 &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; 、 &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; 、および &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; は、 &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; はすべて不正ですが、識別子のコンマ区切りリストをセミコロン区切りリストに置き換えます。</target>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">内部の型が完全にわかっていない生のポインタに対してメソッドが呼び出されました。</target>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">別の形質項目が予想される場合にメソッドが実装されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">モジュールは &lt;code&gt;std::fmt::Write&lt;/code&gt; と &lt;code&gt;std::io::Write&lt;/code&gt; 両方をインポートして、 &lt;code&gt;write!&lt;/code&gt; を呼び出すことができます！オブジェクトは通常両方を実装していないため、どちらかを実装しているオブジェクトに対して。ただし、モジュールは修飾された特性をインポートして、名前が競合しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">借りてきたデータを扱うためのモジュール。</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">プロセスを扱うためのモジュール。</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">モジュールは、0個以上の&lt;a href=&quot;../items&quot;&gt;アイテムの&lt;/a&gt;コンテナです。</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">ボディのないモジュールは外部ファイルからロードされます。モジュールに &lt;code&gt;path&lt;/code&gt; 属性がない場合、ファイル&lt;a href=&quot;../paths&quot;&gt;へのパス&lt;/a&gt;は論理モジュールパスを反映します。祖先モジュールのパスコンポーネントはディレクトリであり、モジュールのコンテンツは、モジュールの名前と &lt;code&gt;.rs&lt;/code&gt; 拡張子が付いたファイルにあります。たとえば、次のモジュール構造は、この対応するファイルシステム構造を持つことができます。</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">より複雑な例。</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">クロージャーを使った、より複雑なパターン。</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&amp;amp;String&lt;/code&gt; 値と &lt;code&gt;&amp;amp;str&lt;/code&gt; 値の両方で同じ関数を使用できるため、経験豊富なRustaceanはリスト4-9に示す署名を代わりに記述します。</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">のより現実的な使用法 &lt;code&gt;!&lt;/code&gt; このコードにあります：</target>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">変形可能なバインディング、参照、またはポインタ。</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリのサブ範囲に対する可変イテレータ。</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; の要素に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の要素に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリに対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; の値に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の値に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">動的にチェックされた借用ルールを備えた、ミュータブルなメモリロケーション</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">変形可能なメモリの位置。</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">可変参照は &lt;code&gt;&amp;amp;mut&lt;/code&gt; で作成できます。</target>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">共有データの保護に有用な相互排除プリミティブ</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">名前のついた住所。</target>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">負の実装とは、ある型が特定の形質を実装できないようにすることです。形質を使用できないことは常に安全な操作であるため、負の実装は常に安全であり、安全でないことをマークする必要はありません。</target>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">親プロセスと子プロセスを接続するために、新しいパイプを配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">新しいスレッドは、&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt;タイプを介して生成される前に構成できます。これにより、現在、子スレッドの名前とスタックサイズを設定できます。</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">新しいスレッドは、&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;関数を使用して生成できます。</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">ノードはその親ノードを参照できますが、その親を所有していません。リスト15-28では、 &lt;code&gt;main&lt;/code&gt; を更新してこの新しい定義を使用するため、 &lt;code&gt;leaf&lt;/code&gt; ノードは親 &lt;code&gt;branch&lt;/code&gt; を参照する方法を持っています：</target>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">定数式の中に非定数値が使われていました。</target>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">この型はすでにデフォルトではない実装がなされているので、これ以上の特化はできません。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">パス内の非最終的なコンポーネントはディレクトリではありません。</target>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">非raw &lt;em&gt;バイト文字列リテラル&lt;/em&gt;は、一連のASCII文字と&lt;em&gt;エスケープであり&lt;/em&gt;、先頭に文字 &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）と &lt;code&gt;U+0022&lt;/code&gt; （二重引用符）が続き、その後に文字 &lt;code&gt;U+0022&lt;/code&gt; が続きます。文字 &lt;code&gt;U+0022&lt;/code&gt; がリテラル内にある場合&lt;em&gt;は&lt;/em&gt;、先行する &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）文字で&lt;em&gt;エスケープ&lt;/em&gt;する必要があります。または、&lt;em&gt;バイト文字列リテラルは&lt;/em&gt;、以下で定義する&lt;em&gt;生のバイト文字&lt;/em&gt;列リテラルにすることもできます。長さ &lt;code&gt;n&lt;/code&gt; のバイト文字列リテラルの型は &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">root ではないモジュールが、別の木箱からマクロをインポートしようとします。</target>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">存在しないインターフェイスが要求されたか、要求されたアドレスがローカルではありませんでした。</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">通常の成分、例えば、及び &lt;code&gt;b&lt;/code&gt; で &lt;code&gt;a/b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">サイズがゼロのタイプとサイズがゼロのレイアウトに関する注意： &lt;code&gt;Alloc&lt;/code&gt; トレイトの多くのメソッドは、割り当てリクエストがゼロ以外のサイズでなければならないことを述べています。そうしないと、未定義の動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">溢れ出た時のパニック。</target>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">パラメータに誤りがありました。</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">指定されたパスの親は存在しません。（ディレクトリーとそのすべての欠落している親を同時に作成するには、&lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt;関数を使用します。）</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">特定のインスタンス &lt;code&gt;RandomState&lt;/code&gt; は&lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;の同じインスタンスを作成しますが、2つの異なる &lt;code&gt;RandomState&lt;/code&gt; インスタンスによって作成されたハッシャーが同じ値に対して同じ結果を生成することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">特定のパターン &lt;code&gt;_&lt;/code&gt; は何にでも一致しますが、変数にバインドされることはないため、最後の一致アームでよく使用されます。 &lt;code&gt;_&lt;/code&gt; あなたは、たとえば、指定されていない任意の値を無視したいときパターンが役立ちます。私たちは、取り上げる &lt;code&gt;_&lt;/code&gt; で詳細に模様&lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;「のパターンで値を無視する」&lt;/a&gt;この章で後述します。</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">パスは2つの形をとることができます。</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">パターンa &lt;code&gt;..=&lt;/code&gt; bは常にa&amp;le;bでなければなりません。たとえば、範囲パターン &lt;code&gt;10..=0&lt;/code&gt; するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">パターンは、照合される値によって照合されない可能性がある場合、&lt;em&gt;反駁&lt;/em&gt;可能であると言われます。一方、&lt;em&gt;反論できない&lt;/em&gt;パターンは常に、照合対象の値と一致します。例：</target>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">列挙バリアントに対してマッチするために使用されるパターンは、列挙バリアントの各フィールドに対してサブパターンを提供しなければなりません。このエラーは、パターンがバリアントから誤った数のフィールドを抽出しようとしたことを示します。</target>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">ピン留めされたポインター。</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">番組の期間中に有効な場所。</target>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">プラグイン/クレートが宣言されていますが、見つかりません。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">ヒープ割り当てのためのポインタ型。</target>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Once&lt;/code&gt; 毒された：</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">ただし、汚染されたミューテックスは、基礎となるデータへのすべてのアクセスを妨げるものではありません。&lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; の&lt;/a&gt;タイプがあり&lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; の&lt;/a&gt;そうでなければ成功したロックに返却されていたガードを返します方法を。これにより、ロックが無効化されていても、データにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; をUTF-16バイトスライスから変換するときに発生する可能性のあるエラー値。</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; をUTF-8バイトベクトルから変換するときに発生する可能性のあるエラー値。</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">プラットフォーム固有のコードを便利に書くための前置き。</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">バイナリヒープで実装された優先度キュー。</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">私物が範囲外で使用されていました。</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">私物を範囲外で使用していました。</target>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">パブリック型のパラメータ・バウンドでプライベートな形質が使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">プライベート型がパブリック型シグネチャで使用されていました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">プロセスビルダは、新しいプロセスをどのように生成するかを細かく制御することができます。</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">記憶の順序を簡単に復習します。</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">ワークアウトプランに多様性をもたらす乱数</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">上下の境界を含む範囲（ &lt;code&gt;start..=end&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">上のみを境界とする範囲（ &lt;code&gt;..end&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;..=end&lt;/code&gt; のみを含む範囲（.. = end）。</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">下側のみを含む範囲（ &lt;code&gt;start..&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">生の識別子は通常の識別子に似ていますが、先頭に &lt;code&gt;r#&lt;/code&gt; が付いています。（ &lt;code&gt;r#&lt;/code&gt; 接頭辞は実際の識別子の一部として含まれていないことに注意してください。）通常の識別子とは異なり、未加工の識別子は、 &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; について上記にリストしたものを除いて、任意の厳密なキーワードまたは予約済みキーワードです。</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">スレッド間で安全に共有できる生ポインタ型。</target>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">常にEOFにいるリーダー。</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">1バイトを何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も....</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">リーダーライターロック</target>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">参照は、参照するデータよりも長い寿命を持っています。</target>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">参照は、ある所有価値の借用を表します。値に &lt;code&gt;&amp;amp;&lt;/code&gt; または &lt;code&gt;&amp;amp;mut&lt;/code&gt; 演算子を使用するか、 &lt;code&gt;ref&lt;/code&gt; または &lt;code&gt;ref mut&lt;/code&gt; パターンを使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">ファイルシステム上で開いているファイルへの参照。</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">現在のディレクトリへの参照、つまり &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">親ディレクトリへの参照、すなわち、 &lt;code&gt;..&lt;/code&gt; .。</target>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">正規の浮動小数点数。</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">通常の参照はポインタの一種であり、ポインタを考える1つの方法は、別の場所に格納されている値への矢印と考えることです。リスト15-6では、 &lt;code&gt;i32&lt;/code&gt; への参照を作成します値、逆参照演算子を使用してデータへの参照を追跡しています。</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">関連する概念はスコープです。コードが記述されているネストされたコンテキストには、「スコープ内」として定義された一連の名前があります。コードの読み取り、書き込み、およびコンパイルを行う場合、プログラマーとコンパイラーは、特定の場所の特定の名前が変数、関数、構造体、列挙型、モジュール、定数、またはその他のアイテムを参照しているかどうか、およびそのアイテムの意味を知る必要があります。スコープを作成して、スコープ内またはスコープ外の名前を変更できます。同じスコープ内に同じ名前の2つのアイテムを含めることはできません。名前の競合を解決するためのツールが利用可能です。</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">繰り返し表現 &lt;code&gt;[x; N]&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; の &lt;code&gt;N&lt;/code&gt; 個のコピーを持つ配列を生成します。 &lt;code&gt;x&lt;/code&gt; のタイプは&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; で&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">return 文が関数本体の外にありました。</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">文字列パターンの逆引き検索。</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">scrutineeは、 &lt;code&gt;match&lt;/code&gt; 式および類似のパターンマッチング構成で一致する式です。たとえば、 &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; 場合、式 &lt;code&gt;x&lt;/code&gt; がスクランチです。</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">文字列パターンの探索者。</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">ストリームの終端を越えたシークは許可されていますが、動作は実装によって定義されています。</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">B-Treeをベースにした集合。</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">同様のエラーはE0201です。違いは、宣言ブロックが1つあるかどうかです。このエラーを回避するには、各 &lt;code&gt;fn&lt;/code&gt; を指定する必要がありますに一意の名前を。</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">同様のルールは、ミュータブル参照とイミュータブル参照の組み合わせにも存在します。このコードはエラーになります。</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">簡単な例です。</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;返す単純な関数は、次のように定義して使用できます。</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">シンプルなスピンロック。</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">簡単な回避策は、代わりにヘルパーメソッドを使用することです。</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">巻き戻しが安全であることを保証するための型のシンプルなラッパーです。</target>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">単一の（任意の）スレッドは、この関数から&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt;ときにis_leaderから &lt;code&gt;true&lt;/code&gt; を返す&lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt;を受け取り、他のすべてのスレッドは&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;false&lt;/code&gt; を返す結果を受け取ります。</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">1つの&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;が複数のバイトとしてエンコードされる場合があります。このメソッドは、バイトシーケンス全体が正常に書き込まれた場合にのみ成功します。このメソッドは、すべてのデータが書き込まれるか、エラーが発生するまで戻りません。</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">単一の&lt;em&gt;10進リテラルと&lt;/em&gt;それに続く&lt;em&gt;指数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">パスの単一コンポーネント。</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">シングルスレッドの参照カウントポインタ。'Rc' は 'Reference Counted' の略です。</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">スライスは、タイプ &lt;code&gt;T&lt;/code&gt; の要素のシーケンスへの「ビュー」を表す&lt;a href=&quot;../dynamically-sized-types&quot;&gt;動的サイズのタイプ&lt;/a&gt;です。スライスタイプは &lt;code&gt;[T]&lt;/code&gt; と表記されます。ます。</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">スライスは、 &lt;code&gt;[T]&lt;/code&gt; と書かれた、連続したシーケンスへの動的なサイズのビューです。</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">パスのスライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; と&lt;/a&gt;同様）。</target>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">バッファに何も読み込まないというちょっと悲しい例。</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">ソケットアドレスが既に他の場所で使用されているため、ソケットアドレスをバインドできなかった。</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">定義のいくぶん意外な結果は、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; が &lt;code&gt;Sync&lt;/code&gt; である場合（ &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Sync&lt;/code&gt; の場合）、非同期のミューテーションを提供する可能性があるように見えます。トリック（つまり共有参照の後ろに可変基準点である &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; ）読み取り専用になり、それがあたかも &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; 。したがって、データ競合のリスクはありません。</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">ソースファイルには&lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;シバン&lt;/em&gt;&lt;/a&gt;（SHEBANGプロダクション）を含めることができます。これは、このファイルの実行に使用するプログラムをオペレーティングシステムに示します。それは本質的にソースファイルを実行可能なスクリプトとして扱うのに役立ちます。シバンはファイルの先頭でのみ発生します（ただし、オプションの&lt;em&gt;UTF8BOMの&lt;/em&gt;後に発生します）。コンパイラーによって無視されます。例えば：</target>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">I / O操作に特化した&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;タイプ。</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">スレッド専用の&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;タイプ。</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; のスプライシングイテレータ。</target>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">安定性属性が標準ライブラリ以外で使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">ステートメントは、コンピュータにアクションを実行するように命令するプログラミング言語の最小のスタンドアロン要素です。</target>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">現在使用しているCPUのアーキテクチャを記述した文字列。</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">使用中の特定のオペレーティングシステムを説明する文字列。値の例は &lt;code&gt;linux&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの「左」は、そのバイト文字列の最初の位置を意味します。「左から右」ではなく「右から左」であるアラビア語やヘブライ語のような言語の場合、これは左側ではなく&lt;em&gt;右側に&lt;/em&gt;なります。</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの「右」は、そのバイト文字列の最後の位置を意味します。「右から左へ」というよりも、アラビア語やヘブライ語のような言語は「右に左」、これは次のようになります&lt;em&gt;、左&lt;/em&gt;サイド、右ではありません。</target>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの &lt;code&gt;end&lt;/code&gt; は、そのバイト文字列の最後の位置を意味します。英語やロシア語のような左から右への言語の場合はこれが右側になり、アラビア語やヘブライ語のような右から左への言語の場合はこれが左側になります。</target>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの &lt;code&gt;start&lt;/code&gt; は、そのバイト文字列の最初の位置を意味します。英語やロシア語のような左から右への言語の場合、これは左側になり、アラビア語やヘブライ語のような右から左への言語の場合、これは右側になります。</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">文字列リテラルは、最終的なバイナリに直接格納される文字列であるため、 &lt;code&gt;'static&lt;/code&gt; 期間」有効です。</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">文字列のパターン。</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">文字列スライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;）はバイト（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）で構成され、バイトスライス（&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt;）はバイトで構成されているため、この関数は2つの間で変換を行います。ただし、すべてのバイトスライスが有効な文字列スライスであるとは限りません。&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;では、有効なUTF-8である必要があります。 &lt;code&gt;from_utf8()&lt;/code&gt; は、バイトが有効なUTF-8であることを確認してから、変換を行います。</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">文字列スライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;）はバイト（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）で構成され、バイトのベクトル（&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;）はバイトで構成されているため、この関数はこの2つの間で変換を行います。ただし、すべてのバイトスライスが有効な &lt;code&gt;String&lt;/code&gt; であるとは限りません &lt;code&gt;String&lt;/code&gt; では、有効なUTF-8である必要があります。 &lt;code&gt;from_utf8()&lt;/code&gt; は、バイトが有効なUTF-8であることを確認してから、変換を行います。</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">文字列スライスは、Rustで最もプリミティブな文字列型であり、 &lt;code&gt;str&lt;/code&gt; として記述されます。それは、可変または共有の借用形式でよく見られます。共有文字列のスライスタイプは &lt;code&gt;&amp;amp;str&lt;/code&gt; で、可変文字列のスライスタイプは &lt;code&gt;&amp;amp;mut str&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">構造体は &lt;code&gt;Copy&lt;/code&gt; にすることができ、&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;Copy&lt;/code&gt; であるため、 &lt;code&gt;Point&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; の対象になります。対照的に、考慮</target>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">プライベート フィールドを持つ構造体コンストラクタが呼び出されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">パニックの場所に関する情報を含む構造体。</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">構造体式は、構文 &lt;code&gt;..&lt;/code&gt; の後に関数の更新を示す式が続くことができます。 &lt;code&gt;..&lt;/code&gt; （ベース）に続く式は、形成される新しい構造体型と同じ構造体型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">中括弧で囲まれたフィールドを持つ構造式では、個々のフィールドの値を任意の順序で指定することができます。フィールド名はコロンで値から分離されます。</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">括弧で囲まれたフィールドを持つ構造体式は、タプル構造体を構築します。完全を期すために特定の式としてここにリストされていますが、タプル構造体のコンストラクターへの&lt;a href=&quot;call-expr&quot;&gt;呼び出し式&lt;/a&gt;と同等です。例えば：</target>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">構造体パターンは、そのサブパターンの1つが再可換可能な場合に再可換可能となります。</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">パニックに関する情報を提供する構造体。</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt;実装に役立つ構造体。</target>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">構造体を参照することでアクセス可能な単一フィールドを持つ構造体。</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">構造体を参照することで変更可能な単一フィールドを持つ構造体。</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">無サイズタイプを含む複数のフィールドを持つ構造体を実装することはできません &lt;code&gt;CoerceUnsized&lt;/code&gt; を。これは、構造体の型の1つを構造体の別の型に強制変換しようとしている場合にのみ発生します。この場合、 &lt;code&gt;T&lt;/code&gt; から &lt;code&gt;U&lt;/code&gt; に &lt;code&gt;CoerceUnsized&lt;/code&gt; を実装しようとします。これらは両方とも、構造体が取る型です。&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;無サイズタイプは&lt;/a&gt;、コンパイラがコンパイル時の長さや配置を知っていないことをどのようなタイプです。サイズなしの型を含む構造体もサイズなしです。</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">表現ヒント &lt;code&gt;repr(transparent)&lt;/code&gt; を持つ構造体には、サイズがゼロであることが保証されていないゼロまたは複数のフィールドがありました。</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">無サイズタイプを含むフィールドのない構造体を実装することはできません &lt;code&gt;CoerceUnsized&lt;/code&gt; を。&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;無サイズタイプは&lt;/a&gt;、コンパイラがコンパイル時の長さや配置を知っていないことをどのようなタイプです。サイズなしの型を含む構造体もサイズなしです。</target>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 表現ヒントを含む構造体、列挙型、または共用体には、サイズがゼロではないフィールドが含まれています。</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">Unix ドメインソケットサーバを表す構造体。</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">各ファイルタイプのアクセサを含むファイルのタイプを表す構造。&lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt;メソッドによって返されます。</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">Windows のパスプレフィックスと、そのパースされていない文字列表現をラップした構造体。</target>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">送信が成功したのは、チャネルのもう一方の端がまだハングアップしていないと判断された場合です。送信の失敗は、対応する受信者の割り当てがすでに解除されている場合です。&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; の&lt;/a&gt;戻り値はデータが受信されないことを意味しますが、&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; の&lt;/a&gt;戻り値はデータが受信されることを意味し&lt;em&gt;ない&lt;/em&gt;ことに注意してください。この関数が&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; を&lt;/a&gt;返した直後に、対応するレシーバーが電話を切る可能性があります。</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">サフィックスは、リテラルの主要部分の直後にある (空白を含まない)非表示の識別子です。</target>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">1回限りのグローバル初期化を実行するために使用できる同期プリミティブ。FFIまたは関連機能の1回限りの初期化に役立ちます。このタイプは、&lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt;値または同等の&lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt;コンストラクターでのみ構築できます。</target>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">同期の境界チャネル。&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; の&lt;/a&gt;関数は戻ります &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; 保留中のメッセージのためのストレージは、固定サイズの予め割り当てられたバッファであるタプル。すべての送信は、使用可能なバッファー・スペースができるまでブロックすることにより&lt;strong&gt;同期&lt;/strong&gt;されます。0の境界が許可されることに注意してください。これにより、チャネルは「ランデブー」チャネルになり、各送信者はメッセージを受信者にアトミックにハンドオフします。</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">構文的な生産</target>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">スレッドは、その&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt;を介して値を返すこともできます。これを使用して、非同期計算を行うことができます（ただし、将来はより適切かもしれません）。</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">その内容を所有するスレッドのローカルストレージキー。</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">慌てずに終了したスレッドは正常に終了したとみなされます。</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">スレッドローカルキーはそれが含む値を所有し、スレッドが終了すると値を破棄します。これは&lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt;作成されます！マクロであり、 &lt;code&gt;'static&lt;/code&gt; （借用ポインタなし）の任意の値を含めることができます。これは、アクセッサ関数を提供&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;、収率その指定閉鎖に値への共有参照。変更可能な借用が許可されている場合、一意性を保証する方法がないため、スレッドローカルキーは値への共有アクセスのみを許可します。ほとんどの値は、&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;型または&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;型を通じて&lt;strong&gt;内部の&lt;/strong&gt;可変性のある形式を利用したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">スレッドセーフな参照カウントポインタ。'Arc' は 'Atomically Reference Counted' の略です。</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">レキサーによって生成されたトークン</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">末尾のスラッシュは正規化され、 &lt;code&gt;/a/b&lt;/code&gt; と &lt;code&gt;/a/b/&lt;/code&gt; は同等です。</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">バインドされた形質 &lt;code&gt;?Sized&lt;/code&gt; 上に結合特性の反対で &lt;code&gt;Sized&lt;/code&gt; ：我々はこれを読んでいました「 &lt;code&gt;T&lt;/code&gt; かであってもなくてもよい &lt;code&gt;Sized&lt;/code&gt; 。」この構文は &lt;code&gt;Sized&lt;/code&gt; でのみ使用でき、他のトレイトでは使用できません。</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">形質は本体に複数のメソッドを持つことができます:メソッドのシグネチャは1行に1つずつ表示され、各行はセミコロンで終わります。</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">データを借りるための特徴。</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">値を &lt;code&gt;String&lt;/code&gt; に変換するための特性。</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; の&lt;/a&gt;インスタンスを作成するための特性。</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; の動作をカスタマイズするための特性 オペレーター。</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">型に有用なデフォルト値を与えるための特徴。</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">任意のバイトストリームをハッシュ化するための特徴。</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数に任意の戻り値の型を実装するための特性。</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">データを変異的に借用するための形質。</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">バイト指向のシンクであるオブジェクトの特徴。</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;値に変換または解決できるオブジェクトの特性。</target>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">形質の実装は、オーファンチェックが失敗するか、実装インスタンスが重複している場合、支離滅裂なものとみなされます。</target>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">形質とは、型が提供しなければならない機能を記述するために使用される言語項目です。これにより、型はその動作について特定の約束をすることができます。</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">形質はのために実装することができる &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; と同様クレートに &lt;code&gt;T&lt;/code&gt; 、&lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;孤立規則は&lt;/a&gt;、他の一般的なタイプの防止します。</target>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">特性オブジェクトは、完全に定義された単一の特性に対して定義されます。通常のデフォルトパラメータを使用すると、このパラメータを置き換えるだけで済みます。ただし、デフォルトパラメータが &lt;code&gt;Self&lt;/code&gt; の場合、特性は具象タイプごとに変化します。つまり、 &lt;code&gt;i32&lt;/code&gt; は &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; を実装することが期待され、 &lt;code&gt;bool&lt;/code&gt; は &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; を実装することが期待されます。、など...これらの型は、完全に定義された特性の実装を共有しません。代わりに、実装ごとに異なるパラメーターを使用して、特性の実装を共有します。これは、特性オブジェクトを機能させるために必要なものと一致しないため、許可されていません。デフォルトのパラメータの値を明示的に指定して特性を具体化すると、この問題が修正されます。修正例：</target>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">生のファイル記述子からオブジェクトを構築する能力を表す形質。</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">オブジェクトを使用し、その未加工の &lt;code&gt;HANDLE&lt;/code&gt; の所有権を取得する機能を表現する特性。</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">オブジェクトを消費し、その生の所有権を取得する能力を表現する特性 &lt;code&gt;SOCKET&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">オブジェクトを消費し、その生のファイル記述子の所有権を取得する能力を表す形質。</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">基底オブジェクトから生の unix ファイル記述子を抽出するための形質。</target>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">透明な構造体、列挙型、または共用体は、含まれているデータとまったく同じように表現されることになっています。配置要件が異なるサイズがゼロのフィールドは、このプロパティと競合する可能性があります。上記の例では、 &lt;code&gt;f32&lt;/code&gt; の配置要件が小さい場合でも、 &lt;code&gt;Wrapper&lt;/code&gt; を32バイトに配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">シグマを使ったトリッキーな例。</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; の使い方の簡単な例、</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">タプル&lt;em&gt;型&lt;/em&gt;は、タプルの&lt;em&gt;要素&lt;/em&gt;と呼ばれる他の型の異種製品です。名義はなく、構造的に型付けされています。</target>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">タプルは、さまざまな型を持つ他の値を1つの複合型にまとめる一般的な方法です。タプルは長さが固定されており、一度宣言するとサイズが大きくなったり小さくなったりすることはありません。</target>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">タプル構造体パターンは、そのサブパターンの1つが再可換可能な場合に再可換可能となります。</target>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">ポイズンされる可能性のあるロックメソッドの結果の型のエイリアス。</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">ノンブロッキング・ロック・メソッドの結果の型のエイリアス。</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">型エイリアスを使用すると、繰り返しを減らすことでこのコードを管理しやすくなります。リスト19-25では、詳細なタイプのために &lt;code&gt;Thunk&lt;/code&gt; という名前のエイリアスを導入し、タイプのすべての使用をより短いエイリアスで置き換えることができます。 &lt;code&gt;Thunk&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">enum 型への型のエイリアスは、コンストラクタを修飾するためには使用できません。</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; として注釈が付けられた型は、すべての表現の懸念を別の型に委譲するため、表現のヒントを追加することは矛盾します。いずれかを削除します &lt;code&gt;transparent&lt;/code&gt; ヒントまたは他のヒントを。</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">型は複数の固有の実装を持つこともできます。実装型は、元の型定義と同じ木枠内で定義されなければなりません。</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">タイプは、実装することができます &lt;code&gt;Copy&lt;/code&gt; そのすべてのコンポーネントが実装する場合は &lt;code&gt;Copy&lt;/code&gt; 。たとえば、この構造体は &lt;code&gt;Copy&lt;/code&gt; に。</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">型キャスト式は二項演算子で示されます &lt;code&gt;as&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">実装するタイプ &lt;code&gt;Try&lt;/code&gt; をは、成功/失敗の二分法に関してそれを表示するための標準的な方法を持つです。この特性により、既存のインスタンスから成功または失敗の値を抽出することと、成功または失敗の値から新しいインスタンスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">タイムアウトにより条件変数の時限待ちが返されたかどうかを示す型。</target>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">ロックを取得したときに必ず返すことができるエラーの種類。</target>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">型またはモジュールが複数回定義されている。</target>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">既存のパラメータの影になる型パラメータが宣言されました。このエラーの例です。</target>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; を参照する型パラメーターデフォルト値で指定されていません。誤ったコードの例：</target>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">所有されている、C互換のヌル終端文字列を表す型で、途中にヌルバイトを含まない。</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">いくつかのバリエーションのいずれかになるタイプ。</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">プラットフォームネイティブの文字列を表現することができますが、Rustの文字列と安価に相互変換可能な型です。</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">他の型で構成されている型。</target>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">動的型付けをエミュレートするための型。</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; に渡されるバッファを条件付きで初期化するために使用されるタイプメソッドに。</target>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">型の動作は、その型に対して呼び出すことができるメソッドで構成されています。これらのすべての型で同じメソッドを呼び出すことができる場合、異なる型は同じ動作を共有します。特性定義は、メソッドシグネチャをグループ化して、目的を達成するために必要な一連の動作を定義する方法です。</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共用体アクセスは、共用体の内容をアクセスされたフィールドのタイプに変換します。変換は予期しない動作または未定義の動作を引き起こす可能性があるため、unionフィールドから読み取るか、&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; を&lt;/a&gt;実装していないフィールドに書き込むには、 &lt;code&gt;unsafe&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">労働組合宣言はを除いて、構造体の宣言と同じ構文を使用して &lt;code&gt;union&lt;/code&gt; の代わりに &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">&lt;code&gt;#[repr(C)]&lt;/code&gt; で宣言された共用体ターゲットプラットフォーム用のC言語における等価C組合宣言と同じサイズと配向を有するであろう。ユニオンのサイズは、そのすべてのフィールドの最大サイズのサイズに合わせて丸められ、そのすべてのフィールドの最大サイズの位置合わせになります。これらの最大値は、さまざまなフィールドから取得される場合があります。</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">実行中のスレッドの一意の識別子。</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">ユニット構造体の式は、ユニット構造体の項目へのパスにすぎません。これは、ユニット構造体の値の暗黙の定数を指します。単位構造体の値は、フィールドレス構造体式で構築することもできます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">認識されていない表現属性が使用されていました。</target>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">空きエントリー。</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;char&lt;/code&gt; サロゲート以上である &lt;code&gt;char::MAX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">&lt;a href=&quot;../items/unions&quot;&gt;労働組合の&lt;/a&gt;価値タイプのこの構文を使用して作成することもできますが、フィールドを1つだけ指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">ユニオン型の値は、構造体型に使用されるのと同じ構文を使用して作成することができますが、正確に 1 つのフィールドを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;falseを&lt;/strong&gt;表す&lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値&lt;strong&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;trueを&lt;/strong&gt;表す&lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値&lt;strong&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型の値は、&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt;（つまり、サロゲートではないコードポイント）であり、0x0000〜0xD7FFまたは0xE000〜0x10FFFFの範囲の32ビットの符号なしワードとして表されます。A &lt;code&gt;[char]&lt;/code&gt; 効果的にUCS-4 / UTF-32の文字列です。</target>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 型の値はUnicode文字列であり、UTF-8コードポイントのシーケンスを保持する8ビットの符号なしバイトの配列として表されます。以来 &lt;code&gt;str&lt;/code&gt; がある&lt;a href=&quot;../dynamically-sized-types&quot;&gt;動的にサイズタイプ&lt;/a&gt;、そうではない&lt;em&gt;最初のクラスの&lt;/em&gt;型が、唯一のような、ポインタ型を介してインスタンス化することができる &lt;code&gt;&amp;amp;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ）または &lt;code&gt;true&lt;/code&gt; （ &lt;code&gt;1&lt;/code&gt; ）以外の値。</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">値がコピーされていない固定サイズの配列から移動されました。</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">借りたままの状態で値が動いた。</target>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">値が移動されました。しかし、コンパイル時にそのサイズがわからなかったため、既知のサイズの値しか移動できません。</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">値は変異的に借りた後に使用されました。</target>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">固定された値は、その型が &lt;code&gt;Unpin&lt;/code&gt; を実装しない限り、永久に固定されたままである必要があります。</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">入力値を使用する値から値への変換。&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">変数に値が代入されていて、それが移動されていない場合は初期化されます。他のすべてのメモリ位置は、初期化されていないものとみなされます。このようなメモリを初期化せずに作成できるのは、安全ではない Rust だけです。</target>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">変数が複数回 mutable として借用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">非常に一般的な入力源は標準入力です。</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">&lt;code&gt;Balance&lt;/code&gt; 非常にシンプルな実装2つのサイドを持つ構造体のそれぞれに変更可能で不変のインデックスを付けることができます。</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">地図上の1つの項目のビューで、空席または占有されている場合があります。</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; の空のエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の空のエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の空のエントリのビュー。&lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 内の占有されたエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; で占有されているエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 内の占有されたエントリのビュー。&lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; の&lt;/a&gt;一部です列挙型の。</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; の&lt;/a&gt;動作を指定する仮想関数ポインターテーブル（vtable）。</target>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">不要なときに可視性修飾子が使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">while-letパターンはパターンに一致しようとし、一致が成功した場合は本文に入ります。一致に反論できない場合（一致に失敗しない場合）、代わりに &lt;code&gt;loop&lt;/code&gt; 内で通常の &lt;code&gt;let&lt;/code&gt; バインディングを使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">この問題を回避するには、形質を struct でラップし、その上に Drop を実装する方法があります。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">作業用のバージョンがあるだろう。</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; のラッパー</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">コンパイラが &lt;code&gt;T&lt;/code&gt; を自動的に呼び出すことを禁止するラッパーのデストラクタを。</target>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; からの可変借用値のラッパータイプ。</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; の初期化されていないインスタンスを構築するラッパータイプ。</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">データを空虚な場所に移動させるライタ。</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">ヤンク&lt;em&gt;は&lt;/em&gt;コードを削除&lt;em&gt;しません&lt;/em&gt;。たとえば、ヤンク機能は誤ってアップロードされたシークレットを削除することを目的としていません。その場合は、これらのシークレットをすぐにリセットする必要があります。</target>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI、リンク、シンボル、FFI</target>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">Linux用ではない &lt;code&gt;armv5te&lt;/code&gt; のようなARMプラットフォームには、アトミックがまったくありません。</target>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">&lt;code&gt;thumbv6m&lt;/code&gt; を備えた ARMターゲットには、アトミック操作はまったくありません。</target>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">アスキー .</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">アスキーバイトリテラル</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">アスキーエスケープ</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII文字の「A」から「Z」は「a」から「z」にマッピングされますが、非ASCII文字は変更されません。</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 文字 'a' から 'z' は 'A' から 'Z' にマップされますが、非 ASCII 文字は変更されません。</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE .</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR .</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING .</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">メモリ割り当てエラーまたは失敗でアボート</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">プロセスの実行を中止します。</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">抽象的な戻り値の型</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">（書かれた抽象戻り値の型 &lt;code&gt;impl Trait&lt;/code&gt; いくつかの形質について &lt;code&gt;Trait&lt;/code&gt; ）のみの機能と固有のimplの戻り値の型として許可されています。</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">抽象構文木</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">このリスナーからの新しい着信接続を受け入れます。</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">コマンドライン引数の受け入れ</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; の&lt;/a&gt;順序を受け入れます。</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">このリスナーへの新しい着信接続を受け入れます。</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">キーとそのハッシュでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">ハッシュでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">キーでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">パック構造体のフィールドにアクセスします。</target>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">パックされた構造体のメンバに参照でアクセスします。</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">変異可能な静的変数へのアクセスまたは変更</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">このエラーの原因となった基礎となるUTF-8エラーにアクセスします。</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">配列要素へのアクセス</target>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">ハッシュマップ内の値へのアクセス</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">&lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; の&lt;/a&gt;フィールドへのアクセス以外の、フィールドへのアクセス。</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">隣接するアクセス &lt;code&gt;u8&lt;/code&gt; として &lt;code&gt;u16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f91f22939adae86de60c33d3fdb16972e0fb724" translate="yes" xml:space="preserve">
          <source>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It&amp;rsquo;s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that&amp;rsquo;s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</source>
          <target state="translated">ヒープ内のデータへのアクセスは、スタック上のデータへのアクセスよりも遅くなります。これは、ポインタをたどってそこに到達する必要があるためです。最近のプロセッサは、メモリ内のジャンプが少ないほど高速です。類推を続けて、多くのテーブルから注文を受けるレストランのサーバーを考えてみましょう。次のテーブルに進む前に、1つのテーブルですべての注文を取得するのが最も効率的です。テーブルAからの注文、テーブルBからの注文、次にAからの注文、そしてBからの注文は、処理が非常に遅くなります。同様に、プロセッサは、（ヒープ上にある可能性があるため）遠くにあるのではなく、（スタック上にあるように）他のデータに近いデータを処理する場合に、より適切に機能します。ヒープに大量のスペースを割り当てると、時間がかかる場合があります。</target>
        </trans-unit>
        <trans-unit id="c20e5fc2ccd1b37aea7b882c463d596e55833b83" translate="yes" xml:space="preserve">
          <source>Accessing or Modifying a Mutable Static Variable</source>
          <target state="translated">Mutable 静的変数へのアクセスと変更</target>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="translated">Accuracy</target>
        </trans-unit>
        <trans-unit id="edc1ea5ed2dafd896f3493beb6ccad4cc0bfdeb7" translate="yes" xml:space="preserve">
          <source>Accurately documenting your packages will help other users know how and when to use them, so it&amp;rsquo;s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, &lt;code&gt;//&lt;/code&gt;. Rust also has a particular kind of comment for documentation, known conveniently as a &lt;em&gt;documentation comment&lt;/em&gt;, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to &lt;em&gt;use&lt;/em&gt; your crate as opposed to how your crate is &lt;em&gt;implemented&lt;/em&gt;.</source>
          <target state="translated">パッケージを正確に文書化すると、他のユーザーがパッケージをいつどのように使用するかを知るのに役立ちます。そのため、文書を書く時間を費やす価値があります。第3章では、2つのスラッシュ &lt;code&gt;//&lt;/code&gt; を使用してRustコードにコメントを付ける方法について説明しました。錆としても便利知らドキュメンテーションコメントの特定の種類、持っている&lt;em&gt;ドキュメンテーションコメント&lt;/em&gt; HTMLドキュメントを生成します。HTMLには、クレートの&lt;em&gt;実装&lt;/em&gt;方法ではなく、クレートの&lt;em&gt;使用&lt;/em&gt;方法を知りたいプログラマー向けのパブリックAPIアイテムのドキュメントコメントの内容が表示されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6568c1be017add88e3d012e02f41ac58f3e66045" translate="yes" xml:space="preserve">
          <source>Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier.</source>
          <target state="translated">Acquire-ロックを取得するためのバリア。それ以降の読み書きは、バリアの後で行われます。</target>
        </trans-unit>
        <trans-unit id="af0f8ed1129c9ddf2134ed1c81b67a9bcb444f5a" translate="yes" xml:space="preserve">
          <source>Acquires a mutable reference to the owned form of the data.</source>
          <target state="translated">データの所有形態への変異可能な参照を取得します。</target>
        </trans-unit>
        <trans-unit id="ff3bc67bc303cd10ada41c07bb7edfd939dc9318" translate="yes" xml:space="preserve">
          <source>Acquires a mutex, blocking the current thread until it is able to do so.</source>
          <target state="translated">ミューテックスを取得し、現在のスレッドをブロックします。</target>
        </trans-unit>
        <trans-unit id="220a887115abad65ad7317817bfb97307bde3f84" translate="yes" xml:space="preserve">
          <source>Acquires a reference to the value in this TLS key.</source>
          <target state="translated">このTLSキーの値への参照を取得します。</target>
        </trans-unit>
        <trans-unit id="b36ce9a1808b77b91f2783ae64622ebad2a9cac9" translate="yes" xml:space="preserve">
          <source>Acquires the underlying &lt;code&gt;*mut&lt;/code&gt; pointer.</source>
          <target state="translated">基礎となる &lt;code&gt;*mut&lt;/code&gt; ポインタを取得します。</target>
        </trans-unit>
        <trans-unit id="d4158950a66bbaeb08dff05a2933261e57fba1be" translate="yes" xml:space="preserve">
          <source>Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons. Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.</source>
          <target state="translated">現在の実行ファイルのパスを取得することは、プラットフォーム固有の操作であり、多くの理由で失敗する可能性があります。いくつかのエラーには、ファイルシステム操作の失敗や一般的なシステムコールの失敗が含まれますが、これらに限定されるものではありません。</target>
        </trans-unit>
        <trans-unit id="6d8f12c840c97a885d954c4ab3f89cfe39b2655d" translate="yes" xml:space="preserve">
          <source>Active and inert attributes</source>
          <target state="translated">アクティブ属性と不活性属性</target>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="876182ad9012a6c08f789f1f68ad82ee5e8c99b7" translate="yes" xml:space="preserve">
          <source>Adaptor to chain together two readers.</source>
          <target state="translated">2台のリーダーを連結するためのアダプター。</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="ca240252f7070cde72a7b776f50be32f04f2fc0d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;reject&lt;/code&gt; method that changes the post&amp;rsquo;s state from &lt;code&gt;PendingReview&lt;/code&gt; back to &lt;code&gt;Draft&lt;/code&gt;.</source>
          <target state="translated">投稿の状態を &lt;code&gt;PendingReview&lt;/code&gt; から &lt;code&gt;Draft&lt;/code&gt; に戻す &lt;code&gt;reject&lt;/code&gt; メソッドを追加します。</target>
        </trans-unit>
        <trans-unit id="a0a1e3ef1e8493d789dbbf3d73ecb2a795cba8db" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="translated">検索結果にクレートとともに表示されるため、1〜2文の説明を追加してください。以下のために &lt;code&gt;license&lt;/code&gt; フィールド、あなたが与える必要がある&lt;em&gt;ライセンス識別子値を&lt;/em&gt;。&lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundationのソフトウェアパッケージのデータ交換（SPDX）は、&lt;/a&gt;この値に使用できる識別子を示しています。たとえば、MITライセンスを使用してクレートにライセンスを付与したことを指定するには、 &lt;code&gt;MIT&lt;/code&gt; 識別子を追加します。</target>
        </trans-unit>
        <trans-unit id="c8594387539a0f2f7158c8875d4643cbc796d8e9" translate="yes" xml:space="preserve">
          <source>Add a getter function:</source>
          <target state="translated">ゲッター関数を追加します。</target>
        </trans-unit>
        <trans-unit id="c563aa838f46cc2ef90bbf765435b526485acbf0" translate="yes" xml:space="preserve">
          <source>Add constraints that must be upheld to use an item.</source>
          <target state="translated">項目を使用するために支持されなければならない制約を追加します。</target>
        </trans-unit>
        <trans-unit id="32aaebe9976898d3881c1a85d7d471c975e08486" translate="yes" xml:space="preserve">
          <source>Add more documentation to &lt;code&gt;ThreadPool&lt;/code&gt; and its public methods.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; とそのパブリックメソッドにドキュメントを追加します。</target>
        </trans-unit>
        <trans-unit id="eac54db7026ed63754bb1e0481266ad4560b6f6c" translate="yes" xml:space="preserve">
          <source>Add tests of the library&amp;rsquo;s functionality.</source>
          <target state="translated">ライブラリの機能のテストを追加します。</target>
        </trans-unit>
        <trans-unit id="584510db3cf556aee671c49783907c6c03f2abe4" translate="yes" xml:space="preserve">
          <source>Add the size of the field.</source>
          <target state="translated">フィールドのサイズを追加します。</target>
        </trans-unit>
        <trans-unit id="e0ef2ba9581371a273c725b4584816d08df6e970" translate="yes" xml:space="preserve">
          <source>Add::add</source>
          <target state="translated">Add::add</target>
        </trans-unit>
        <trans-unit id="bd166591010a18220168b51497b0b5e84b157433" translate="yes" xml:space="preserve">
          <source>AddAssign</source>
          <target state="translated">AddAssign</target>
        </trans-unit>
        <trans-unit id="6eecef84103332763bac0f11d9776217926be6a9" translate="yes" xml:space="preserve">
          <source>AddAssign::add_assign</source>
          <target state="translated">AddAssign::add_assign</target>
        </trans-unit>
        <trans-unit id="47bc308a358cb72c871f66d0703a1751fa8c3e13" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;rand&lt;/code&gt; as a dependency in &lt;em&gt;Cargo.toml&lt;/em&gt; tells Cargo to download the &lt;code&gt;rand&lt;/code&gt; package and any dependencies from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and make &lt;code&gt;rand&lt;/code&gt; available to our project.</source>
          <target state="translated">追加 &lt;code&gt;rand&lt;/code&gt; 中に依存関係として&lt;em&gt;Cargo.tomlを&lt;/em&gt;ダウンロードして貨物を伝え &lt;code&gt;rand&lt;/code&gt; パッケージとの依存関係&lt;a href=&quot;https://crates.io/&quot;&gt;crates.ioを&lt;/a&gt;して作る &lt;code&gt;rand&lt;/code&gt; 私たちのプロジェクトに利用できます。</target>
        </trans-unit>
        <trans-unit id="6951b086bf1e29a4acfdba85666aa713fe81534c" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;use&lt;/code&gt; and a path in a scope is similar to creating a symbolic link in the filesystem. By adding &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; in the crate root, &lt;code&gt;hosting&lt;/code&gt; is now a valid name in that scope, just as though the &lt;code&gt;hosting&lt;/code&gt; module had been defined in the crate root. Paths brought into scope with &lt;code&gt;use&lt;/code&gt; also check privacy, like any other paths.</source>
          <target state="translated">スコープに &lt;code&gt;use&lt;/code&gt; とパスを追加することは、ファイルシステムにシンボリックリンクを作成することに似ています。追加することにより &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; クレートのルートには、 &lt;code&gt;hosting&lt;/code&gt; ちょうどかのように、今、その範囲内で有効な名前である &lt;code&gt;hosting&lt;/code&gt; モジュールはクレートのルートで定義されていました。他のパスと同様に、 &lt;code&gt;use&lt;/code&gt; 伴ってスコープに入れられたパスはプライバシーもチェックします。</target>
        </trans-unit>
        <trans-unit id="311633e0da4d8767a76b5d94813ce0272b9cb8a9" translate="yes" xml:space="preserve">
          <source>Adding Custom Failure Messages</source>
          <target state="translated">カスタムの失敗メッセージを追加する</target>
        </trans-unit>
        <trans-unit id="eb99698d7e26927ef9425258511b7fbda34cd647" translate="yes" xml:space="preserve">
          <source>Adding Metadata to a New Crate</source>
          <target state="translated">新しいクレートにメタデータを追加する</target>
        </trans-unit>
        <trans-unit id="6ff96d15a4dfd75cd1b39329a2970688120a37e4" translate="yes" xml:space="preserve">
          <source>Adding Useful Functionality with Derived Traits</source>
          <target state="translated">派生形質による有用な機能の追加</target>
        </trans-unit>
        <trans-unit id="b2524eeb321c4f1026793239c00d8c1b31c32e31" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; field to your type tells the compiler that your type acts as though it stores a value of type &lt;code&gt;T&lt;/code&gt;, even though it doesn't really. This information is used when computing certain safety properties.</source>
          <target state="translated">型に &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; フィールドを追加すると、コンパイラは、型 &lt;code&gt;T&lt;/code&gt; の値を格納しているかのように動作することをコンパイラに通知します。この情報は、特定の安全特性を計算するときに使用されます。</target>
        </trans-unit>
        <trans-unit id="b87a48eb56569132271d6219a87c7a5229e982a0" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;Self: Sized&lt;/code&gt; bound to these methods will generally make this compile.</source>
          <target state="translated">&lt;code&gt;Self: Sized&lt;/code&gt; 追加：これらのメソッドにバインドされたサイズは、通常、これをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="88b9f27e251e16ee893bec092535b944c26b4aa9" translate="yes" xml:space="preserve">
          <source>Adding a Reference from a Child to Its Parent</source>
          <target state="translated">子から親への参照の追加</target>
        </trans-unit>
        <trans-unit id="23ab42376e070f08194bffa94071c8449a58479a" translate="yes" xml:space="preserve">
          <source>Adding a Test to a Workspace</source>
          <target state="translated">ワークスペースへのテストの追加</target>
        </trans-unit>
        <trans-unit id="fd0c9f4d15902bc297e9dbf8af8d2743194e970b" translate="yes" xml:space="preserve">
          <source>Adding a field of type &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indicates that your type owns data of type &lt;code&gt;T&lt;/code&gt;. This in turn implies that when your type is dropped, it may drop one or more instances of the type &lt;code&gt;T&lt;/code&gt;. This has bearing on the Rust compiler's &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;drop check&lt;/a&gt; analysis.</source>
          <target state="translated">タイプ &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; フィールドを追加すると、そのタイプがタイプ &lt;code&gt;T&lt;/code&gt; のデータを所有することを示します。これは、タイプがドロップされると、タイプ &lt;code&gt;T&lt;/code&gt; のインスタンスを1つ以上ドロップする可能性があることを意味します。これは、Rustコンパイラの&lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;ドロップチェック&lt;/a&gt;分析に関係しています。</target>
        </trans-unit>
        <trans-unit id="2e98bb73927df33c08944823ebcc88b767156500" translate="yes" xml:space="preserve">
          <source>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running &lt;code&gt;cargo test&lt;/code&gt; will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don&amp;rsquo;t work because the code has changed since the documentation was written. If we run &lt;code&gt;cargo test&lt;/code&gt; with the documentation for the &lt;code&gt;add_one&lt;/code&gt; function from Listing 14-1, we will see a section in the test results like this:</source>
          <target state="translated">ドキュメントのコメントにサンプルコードブ​​ロックを追加すると、ライブラリの使用方法を示すのに役立ちます。これを行うと、さらにボーナスがあります。 &lt;code&gt;cargo test&lt;/code&gt; を実行すると、ドキュメント内のコード例がテストとして実行されます。例付きのドキュメントに勝るものはありません。しかし、ドキュメントが作成されてからコードが変更されたために機能しない例よりも悪いことはありません。リスト14-1の &lt;code&gt;add_one&lt;/code&gt; 関数のドキュメントを使用して &lt;code&gt;cargo test&lt;/code&gt; を実行すると、テスト結果に次のようなセクションが表示されます。</target>
        </trans-unit>
        <trans-unit id="ceb9b506f927db7479477e625a150623510cf2aa" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; Method that Changes the Behavior of &lt;code&gt;content&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; の動作を変更 &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; メソッドを追加する</target>
        </trans-unit>
        <trans-unit id="718d273106ffd821ac0c7d93c2d34d8556d7365d" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;break&lt;/code&gt; line after &lt;code&gt;You win!&lt;/code&gt; makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;You win!&lt;/code&gt; 後に &lt;code&gt;break&lt;/code&gt; ラインを追加します！ユーザーがシークレット番号を正しく推測すると、プログラムがループを終了します。ループは &lt;code&gt;main&lt;/code&gt; の最後の部分であるため、ループを終了することはプログラムを終了することも意味します。</target>
        </trans-unit>
        <trans-unit id="097cf74b7fb2e319a4766446302ea478dcd635f5" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;mut&lt;/code&gt; keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; キーワードを追加すると、可変参照が逆参照されます。可変性は参照の可変性と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="c8217392646c4b940c031f95cbb65a4bfa731556" translate="yes" xml:space="preserve">
          <source>Addition assignment</source>
          <target state="translated">追加課題</target>
        </trans-unit>
        <trans-unit id="b078f9f7ba47f896a06212df108079bcbb1553ff" translate="yes" xml:space="preserve">
          <source>Additional functionality for numerics.</source>
          <target state="translated">数値の追加機能。</target>
        </trans-unit>
        <trans-unit id="2ffc443f11be980490aef62083275ee8c11f674b" translate="yes" xml:space="preserve">
          <source>Additional implementors</source>
          <target state="translated">追加の実装者</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">追加情報</target>
        </trans-unit>
        <trans-unit id="0c05d0c23b9a6f9971368dd97467c0d0e294ca18" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 渡される追加パラメーター！名前付きパラメータまたは位置パラメータが使用されていない限り、指定された順序でフォーマット文字列内の &lt;code&gt;{}&lt;/code&gt; を置き換えます。詳細については、&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dc3992de92a20dddf33d6770f13a67c41e82f34f" translate="yes" xml:space="preserve">
          <source>Additionally, a type &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; can implement &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; or &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;. This allows it to provide a unsized coercion to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">また、タイプ &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; を実装することができる &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; とき &lt;code&gt;T&lt;/code&gt; 器具 &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; または &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 。これにより、 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; サイズ変更しない強制を提供できます。</target>
        </trans-unit>
        <trans-unit id="30e7a03e650ce2c7f3e6f58657d0e770d7ebbede" translate="yes" xml:space="preserve">
          <source>Additionally, even though &lt;code&gt;$crate&lt;/code&gt; allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke &lt;code&gt;call_foo!()&lt;/code&gt; from outside its crate will fail because &lt;code&gt;foo()&lt;/code&gt; is not public.</source>
          <target state="translated">さらに、 &lt;code&gt;$crate&lt;/code&gt; 使用すると、展開時にマクロが自身のクレート内のアイテムを参照できるようになりますが、その使用は可視性に影響を与えません。参照されるアイテムまたはマクロは、呼び出しサイトから表示されている必要があります。次の例では、 &lt;code&gt;foo()&lt;/code&gt; がパブリックでないため、クレートの外側から &lt;code&gt;call_foo!()&lt;/code&gt; を呼び出そうとしても失敗します。</target>
        </trans-unit>
        <trans-unit id="45cbb93035ac4b5290adcbd441c337adab3295a5" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">さらに、 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;でない場合、 &lt;code&gt;drop_in_place&lt;/code&gt; を呼び出した後にポイント先の値を使用すると、未定義の動作が発生する可能性があります。 &lt;code&gt;*to_drop = foo&lt;/code&gt; は、値が再度ドロップされるため、使用としてカウントされることに注意してください。&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;を使用すると、データを削除せずにデータを上書きできます。</target>
        </trans-unit>
        <trans-unit id="74bd1999d14b1334b93c7bef28b699b66b0d25fc" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">さらに、 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;でない場合、 &lt;code&gt;drop_in_place&lt;/code&gt; を呼び出した後にポイント先の値を使用すると、未定義の動作が発生する可能性があります。 &lt;code&gt;*to_drop = foo&lt;/code&gt; は、値が再度ドロップされるため、使用としてカウントされることに注意してください。&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;を使用すると、データを削除せずにデータを上書きできます。</target>
        </trans-unit>
        <trans-unit id="90a70db7c7bfc77bbf274f46c324d605b6ac9ac3" translate="yes" xml:space="preserve">
          <source>Additionally, it does not drop &lt;code&gt;src&lt;/code&gt;. Semantically, &lt;code&gt;src&lt;/code&gt; is moved into the location pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">さらに、それは &lt;code&gt;src&lt;/code&gt; を落としません。意味的には、 &lt;code&gt;src&lt;/code&gt; は &lt;code&gt;dst&lt;/code&gt; が指す場所に移動されます。</target>
        </trans-unit>
        <trans-unit id="a5ab7ed4a3b0357f6baec92b0d45381b0f7726c3" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">さらに、Unixでは、&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt;トレイトを実装します。これは、引数を消費し、&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; の&lt;/a&gt;ベクトルを取得または生成する&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt;メソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="8bb517701cd0832c45c67c28da4b399a605014b6" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows:ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides a &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;from_wide&lt;/code&gt;&lt;/a&gt; method. The result of this method is an &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; which can be round-tripped to a Windows string losslessly.</source>
          <target state="translated">さらに、Windowsでは&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;std::os::windows:ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt;トレイトを実装し、&lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;from_wide&lt;/code&gt; &lt;/a&gt;メソッドを提供します。このメソッドの結果は、ロスレスでWindows文字列にラウンドトリップできる&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0f7d5354cdb11e461595056b1602a23178a20138" translate="yes" xml:space="preserve">
          <source>Additionally, taking a job off the channel queue involves mutating the &lt;code&gt;receiver&lt;/code&gt;, so the threads need a safe way to share and modify &lt;code&gt;receiver&lt;/code&gt;; otherwise, we might get race conditions (as covered in Chapter 16).</source>
          <target state="translated">また、チャネルキューから仕事を取ることは変異が含ま &lt;code&gt;receiver&lt;/code&gt; スレッドが共有および変更する安全な方法必要があるので、 &lt;code&gt;receiver&lt;/code&gt; 。そうしないと、競合状態になる可能性があります（第16章で説明）。</target>
        </trans-unit>
        <trans-unit id="0eb5702e98a03d052d40c8aabb340aee4d2332a4" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt; types depend on the kind of computer your program is running on: 64 bits if you&amp;rsquo;re on a 64-bit architecture and 32 bits if you&amp;rsquo;re on a 32-bit architecture.</source>
          <target state="translated">さらに、 &lt;code&gt;isize&lt;/code&gt; と &lt;code&gt;usize&lt;/code&gt; あなたは32ビットアーキテクチャにしている場合は、64ビットアーキテクチャおよび32ビットにしている場合は64ビット：種類は、あなたのプログラムを実行しているコンピュータの種類によって異なります。</target>
        </trans-unit>
        <trans-unit id="e3aa1d01d453f95734172c24dd2caadad96e569f" translate="yes" xml:space="preserve">
          <source>Additionally, the caller must ensure that writing &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes to the given region of memory results in a valid value of &lt;code&gt;T&lt;/code&gt;. Using a region of memory typed as a &lt;code&gt;T&lt;/code&gt; that contains an invalid value of &lt;code&gt;T&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">さらに、呼び出し元は、 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; バイトをメモリの特定の領域に書き込むと、 &lt;code&gt;T&lt;/code&gt; の有効な値になることを確認する必要があります。無効な &lt;code&gt;T&lt;/code&gt; の値を含む &lt;code&gt;T&lt;/code&gt; として型指定されたメモリ領域を使用すると、動作が未定義になります。</target>
        </trans-unit>
        <trans-unit id="f3d0f5351803248ec3d677cec08967bab902a3b1" translate="yes" xml:space="preserve">
          <source>Additionally, the length of the string will be recalculated from the pointer.</source>
          <target state="translated">さらに、文字列の長さはポインタから再計算されます。</target>
        </trans-unit>
        <trans-unit id="5c93e6fb82861fecd56783e8c74a9dcd85037abd" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get accessed through any other pointer.</source>
          <target state="translated">また、寿命 &lt;code&gt;'a&lt;/code&gt; が返さが任意に選択され、必ずしもデータの実際の寿命を反映するものではありません。この存続期間中、このポインターが指すメモリーが他のポインターを介してアクセスされないようにするのは、呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="6e203e0080d407af9cc4130e8b5859f062bfa85b" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get written to outside of &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">また、寿命 &lt;code&gt;'a&lt;/code&gt; が返さが任意に選択され、必ずしもデータの実際の寿命を反映するものではありません。この存続期間中、このポインターが指すメモリーが &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; 外部に書き込まれないようにするのは、呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="cb09e099663e4fdfec9970e8541bfc0bbcb8c136" translate="yes" xml:space="preserve">
          <source>Additionally, the return value of this function is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt; which is a type alias of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;(), &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;std::fmt::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Formatting implementations should ensure that they propagate errors from the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; (e.g., when calling &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a result because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.</source>
          <target state="translated">さらに、この関数の戻り値は&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;(), &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;std::fmt::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; の型エイリアスである&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;です。フォーマッティング実装は、&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;からのエラーを確実に伝播する必要があります（たとえば、&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; を&lt;/a&gt;呼び出すとき）。ただし、誤ってエラーを返すことはありません。つまり、フォーマットの実装は、渡された&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; が&lt;/a&gt;エラーを返します。これは、関数のシグネチャが示唆するかもしれないこととは対照的に、文字列の書式設定は間違いのない操作であるためです。基になるストリームへの書き込みが失敗する可能性があるため、この関数は結果を返すだけであり、エラーがスタックで発生したという事実を伝搬する方法を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="c51e0d7d6467942093ff85910240899ecb3312bc" translate="yes" xml:space="preserve">
          <source>Additionally, we can&amp;rsquo;t yet provide the &lt;code&gt;hello_macro&lt;/code&gt; function with default implementation that will print the name of the type the trait is implemented on: Rust doesn&amp;rsquo;t have reflection capabilities, so it can&amp;rsquo;t look up the type&amp;rsquo;s name at runtime. We need a macro to generate code at compile time.</source>
          <target state="translated">さらに、特性が実装されている型の名前を出力するデフォルトの実装を &lt;code&gt;hello_macro&lt;/code&gt; 関数に提供することはまだできません。Rustにはリフレクション機能がないため、実行時に型の名前を検索できません。コンパイル時にコードを生成するマクロが必要です。</target>
        </trans-unit>
        <trans-unit id="009b5112bedb7bc7f35022f14f637dbf23e46083" translate="yes" xml:space="preserve">
          <source>Additionally, you&amp;rsquo;ll need a linker of some kind. It&amp;rsquo;s likely one is already installed, but when you try to compile a Rust program and get errors indicating that a linker could not execute, that means a linker isn&amp;rsquo;t installed on your system and you&amp;rsquo;ll need to install one manually. C compilers usually come with the correct linker. Check your platform&amp;rsquo;s documentation for how to install a C compiler. Also, some common Rust packages depend on C code and will need a C compiler. Therefore, it might be worth installing one now.</source>
          <target state="translated">さらに、何らかのリンカーが必要になります。おそらく既にインストールされている可能性がありますが、Rustプログラムをコンパイルしようとして、リンカーが実行できなかったことを示すエラーが発生した場合は、システムにリンカーがインストールされていないため、手動でインストールする必要があります。Cコンパイラには通常、正しいリンカが付属しています。Cコンパイラのインストール方法については、プラットフォームのドキュメントを確認してください。また、一部の一般的なRustパッケージはCコードに依存しており、Cコンパイラが必要になります。したがって、今すぐインストールする価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e8f6c433136e97e0a25822d00a70a971083e0df2" translate="yes" xml:space="preserve">
          <source>AddrParseError</source>
          <target state="translated">AddrParseError</target>
        </trans-unit>
        <trans-unit id="4db89e8ded7777748645ac21edd601141065b25a" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow</source>
          <target state="translated">AddrParseError::borrow</target>
        </trans-unit>
        <trans-unit id="ba5e2e5b2d73d903fb597da8809d6182f967fe26" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow_mut</source>
          <target state="translated">AddrParseError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eec3364cb0e6e631bd766aeee8473eb3c5d8b783" translate="yes" xml:space="preserve">
          <source>AddrParseError::cause</source>
          <target state="translated">AddrParseError::cause</target>
        </trans-unit>
        <trans-unit id="c8650de9923d2b7b74fd1fb851b3c0ddd4117148" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone</source>
          <target state="translated">AddrParseError::clone</target>
        </trans-unit>
        <trans-unit id="53ddfe6ad8c3351ba945f5b6cd6f647e3fa91325" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_from</source>
          <target state="translated">AddrParseError::clone_from</target>
        </trans-unit>
        <trans-unit id="08355c15003499e28a7411918357d4a2f001b709" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_into</source>
          <target state="translated">AddrParseError::clone_into</target>
        </trans-unit>
        <trans-unit id="25cb3b50c76347b7f6a85db7c339595baf0f003c" translate="yes" xml:space="preserve">
          <source>AddrParseError::description</source>
          <target state="translated">AddrParseError::description</target>
        </trans-unit>
        <trans-unit id="10b9b968cc3bf94f7c5c39dea8bf21d7dd54888c" translate="yes" xml:space="preserve">
          <source>AddrParseError::eq</source>
          <target state="translated">AddrParseError::eq</target>
        </trans-unit>
        <trans-unit id="49cf29f6a6f46e91fe5234ee3c02c53e59ab7578" translate="yes" xml:space="preserve">
          <source>AddrParseError::fmt</source>
          <target state="translated">AddrParseError::fmt</target>
        </trans-unit>
        <trans-unit id="60405d6d13708e4d85c176a98cb4377bfb7ee9d7" translate="yes" xml:space="preserve">
          <source>AddrParseError::from</source>
          <target state="translated">AddrParseError::from</target>
        </trans-unit>
        <trans-unit id="dbfcfd8a7eba25880c9888cb8208fce8e37c895d" translate="yes" xml:space="preserve">
          <source>AddrParseError::into</source>
          <target state="translated">AddrParseError::into</target>
        </trans-unit>
        <trans-unit id="81cea92a5c59d76a750c2dc91be0b6bebf9c1c4f" translate="yes" xml:space="preserve">
          <source>AddrParseError::ne</source>
          <target state="translated">AddrParseError::ne</target>
        </trans-unit>
        <trans-unit id="85b81474bbc6034c17600e25b324b8f7ff89e65b" translate="yes" xml:space="preserve">
          <source>AddrParseError::source</source>
          <target state="translated">AddrParseError::source</target>
        </trans-unit>
        <trans-unit id="ba1fd539045fde8129efbfd52fe6aba361392170" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_owned</source>
          <target state="translated">AddrParseError::to_owned</target>
        </trans-unit>
        <trans-unit id="e2552e76eca8011ad4e06db73e14e51d90cd4e86" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_string</source>
          <target state="translated">AddrParseError::to_string</target>
        </trans-unit>
        <trans-unit id="ff5f57540e8ea426311cdc19ccc6971134dcdb7f" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_from</source>
          <target state="translated">AddrParseError::try_from</target>
        </trans-unit>
        <trans-unit id="bec376def9a1123d4f124dfc1a6840567151a145" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_into</source>
          <target state="translated">AddrParseError::try_into</target>
        </trans-unit>
        <trans-unit id="26c560bba3044ee670c8f3ee436e252e0e2dad89" translate="yes" xml:space="preserve">
          <source>AddrParseError::type_id</source>
          <target state="translated">AddrParseError::type_id</target>
        </trans-unit>
        <trans-unit id="5cf7a9b41ce47d27a30e791bbfb6bec2ca816fcf" translate="yes" xml:space="preserve">
          <source>Address to pointer cast</source>
          <target state="translated">ポインタキャスト先のアドレス</target>
        </trans-unit>
        <trans-unit id="d7aa7412717eb74583761a8560faa539aaf27874" translate="yes" xml:space="preserve">
          <source>Address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">アドレスタイプは、&lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt;トレイトの任意の実装者にすることができます。具体的な例については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5a1149884af3cef69504ddd9428373fea25aa2ca" translate="yes" xml:space="preserve">
          <source>Addresses returned by the operating system that are not IP addresses are silently ignored.</source>
          <target state="translated">オペレーティングシステムが返すIPアドレスではないアドレスは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="5915abc490110180d1540b6234219f020e04a70a" translate="yes" xml:space="preserve">
          <source>Adds a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method to an iterator. See its documentation for more information.</source>
          <target state="translated">&lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt;メソッドをイテレータに追加します。詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c870f816a116db65c4b82439ff891f426f80ff41" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;usize&lt;/code&gt;, returning &lt;code&gt;None&lt;/code&gt; on overflow.</source>
          <target state="translated">&lt;code&gt;usize&lt;/code&gt; を追加し、オーバーフロー時に &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="31cf127eab5bb935c2abe6cc6bba90f4ae0b71a3" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the list output.</source>
          <target state="translated">リスト出力に新しいエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="15cb5f7efe200723c3b721e295fbebc13dfc9e31" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the map output.</source>
          <target state="translated">マップ出力に新しいエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="0ef3b59a4597ecf10372b8f11eb26c1a52f2f272" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the set output.</source>
          <target state="translated">セット出力に新しいエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="60f1cf0bd8c4a027b017ecaa893cb9c74c91f78b" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated struct output.</source>
          <target state="translated">生成された struct 出力に新しいフィールドを追加します。</target>
        </trans-unit>
        <trans-unit id="b8fafafece871a01042ed5a0ab5c6c9b2e80442c" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated tuple struct output.</source>
          <target state="translated">生成されたタプル構造体の出力に新しいフィールドを追加します。</target>
        </trans-unit>
        <trans-unit id="0b002c9af6c57cafdfe28d411ed57cf85e2ebe81" translate="yes" xml:space="preserve">
          <source>Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value.</source>
          <target state="translated">値をセットに追加し、指定した値と等しい値があればそれを置き換えます。置き換えた値を返します。</target>
        </trans-unit>
        <trans-unit id="82f4c899437f1a62750b1776b4b1b6599530f1e6" translate="yes" xml:space="preserve">
          <source>Adds a value to the set.</source>
          <target state="translated">セットに値を追加します。</target>
        </trans-unit>
        <trans-unit id="f1a3f6979754c5ca7c9e4122b44f7541e9636107" translate="yes" xml:space="preserve">
          <source>Adds an argument to pass to the program.</source>
          <target state="translated">プログラムに渡す引数を追加します。</target>
        </trans-unit>
        <trans-unit id="658707171b5a956fa506d45ca2578865d314c2a0" translate="yes" xml:space="preserve">
          <source>Adds an element first in the list.</source>
          <target state="translated">リストの最初に要素を追加します。</target>
        </trans-unit>
        <trans-unit id="969d7672cd1e94e2e3f766816cef88b15855a861" translate="yes" xml:space="preserve">
          <source>Adds multiple arguments to pass to the program.</source>
          <target state="translated">プログラムに渡す複数の引数を追加します。</target>
        </trans-unit>
        <trans-unit id="68adca23d26862cb362a13d5d500e729dc911a8b" translate="yes" xml:space="preserve">
          <source>Adds one to this step, returning the result.</source>
          <target state="translated">このステップに1つ追加し、結果を返します。</target>
        </trans-unit>
        <trans-unit id="0151250bd8bdb46ad8abec9aa6c7d2adc6f4d3c2" translate="yes" xml:space="preserve">
          <source>Adds or updates multiple environment variable mappings.</source>
          <target state="translated">複数の環境変数のマッピングを追加または更新します。</target>
        </trans-unit>
        <trans-unit id="c1ea158bb2722c6d5db848a523c49d2d1b4ef996" translate="yes" xml:space="preserve">
          <source>Adds support for special Unix file types such as block/character devices, pipes, and sockets.</source>
          <target state="translated">ブロック/文字デバイス、パイプ、ソケットなどの特殊な Unix ファイルタイプのサポートを追加しました。</target>
        </trans-unit>
        <trans-unit id="671bf2741316962d688bf4f15b0556af370525fd" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the list output.</source>
          <target state="translated">エントリのイテレータの内容をリスト出力に追加します。</target>
        </trans-unit>
        <trans-unit id="6172d9346f85a8afb18c30e9f6e11792ac6685f3" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the map output.</source>
          <target state="translated">エントリのイテレータの内容をマップ出力に追加します。</target>
        </trans-unit>
        <trans-unit id="45f4916d90bbb31a57ac59c642d372fc8465632a" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the set output.</source>
          <target state="translated">エントリのイテレータの内容をセット出力に追加します。</target>
        </trans-unit>
        <trans-unit id="64dedb52a39f499be5ddacaf33bea0b6af530c2b" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value.</source>
          <target state="translated">現在の値に追加し、前の値を返します。</target>
        </trans-unit>
        <trans-unit id="fec400f1cdf6c0803479c71a8ae238f9468f9b58" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この固有の安定したバージョンで利用可能である &lt;code&gt;std::sync::atomic&lt;/code&gt; を介した種類 &lt;code&gt;fetch_add&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be9a5a4d4b7398c45da8fcba5bded3bbc8f71847" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この組み込み関数の安定化されたバージョンは、 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、fetch_addメソッドを介して &lt;code&gt;std::sync::atomic&lt;/code&gt; タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8510188bc5ebdc1c7bffee425e4b31fab3c7278" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この組み込み関数の安定化バージョンは、 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、fetch_addメソッドを介して &lt;code&gt;std::sync::atomic&lt;/code&gt; タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d050db3800c7dd71e5057e0d9def9358e61a419" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この組み込み関数の安定化されたバージョンは、 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、fetch_addメソッドを介して &lt;code&gt;std::sync::atomic&lt;/code&gt; タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1973476bdfd162d29c3bf0eb0f1911803377eae3" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この固有の安定したバージョンで利用可能である &lt;code&gt;std::sync::atomic&lt;/code&gt; を介した種類 &lt;code&gt;fetch_add&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2ed5841682a101d798c6152b62dca74cfea4b15" translate="yes" xml:space="preserve">
          <source>Advance to the next arg.</source>
          <target state="translated">次のargに進む。</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高度な機能</target>
        </trans-unit>
        <trans-unit id="7f4668d91bf23526ef1f05a0e7de95630615e93b" translate="yes" xml:space="preserve">
          <source>Advanced Functions and Closures</source>
          <target state="translated">高度な機能とクロージャ</target>
        </trans-unit>
        <trans-unit id="d5d49bfe71b011aa5e9e308b0bd9089c84c3c245" translate="yes" xml:space="preserve">
          <source>Advanced Traits</source>
          <target state="translated">高度な特性</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">高度なタイプ</target>
        </trans-unit>
        <trans-unit id="9b4509b6a0eecdabec69457f9e139e56f305f9a7" translate="yes" xml:space="preserve">
          <source>Advanced functions and closures: function pointers and returning closures</source>
          <target state="translated">高度な関数とクロージャ:関数ポインタと戻り値のクロージャ</target>
        </trans-unit>
        <trans-unit id="9c622feb39e22136f98cc1cfffb6cc56c0cb6ac7" translate="yes" xml:space="preserve">
          <source>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</source>
          <target state="translated">高度な形質:関連付けられた型、デフォルトの型パラメータ、完全修飾構文、スーパー形質、形質に関連したニュータイプパターン</target>
        </trans-unit>
        <trans-unit id="d050af08a92ff2ff0056bb035493a0f2f1620de8" translate="yes" xml:space="preserve">
          <source>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</source>
          <target state="translated">高度な型:newtype パターン、型のエイリアス、never 型、動的なサイズの型についての詳細</target>
        </trans-unit>
        <trans-unit id="bc73315bb680ddc61259cb6b2cc7f603f7017af5" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value.</source>
          <target state="translated">イテレータを進め、次の値を返します。</target>
        </trans-unit>
        <trans-unit id="47778efc70c16f19b03a33e09324cdfef37b8397" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5c10d1dad50204036d6641dc96f179feac3c880" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0d17cb524aa65c6531ab7f58b22a2915be47179" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2af190b4bf87220daaa7fcdfebb435d1dda577b1" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ff050bc0f28af247ba9f7e987965071e370a8f" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc5df98fcac936e0dd69b6d3ac4bff062078ea9f" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;#[test]&lt;/code&gt; we add the &lt;code&gt;#[ignore]&lt;/code&gt; line to the test we want to exclude. Now when we run our tests, &lt;code&gt;it_works&lt;/code&gt; runs, but &lt;code&gt;expensive_test&lt;/code&gt; doesn&amp;rsquo;t:</source>
          <target state="translated">&lt;code&gt;#[test]&lt;/code&gt; の後に、除外するテストに &lt;code&gt;#[ignore]&lt;/code&gt; 行を追加します。我々はテストを実行すると、 &lt;code&gt;it_works&lt;/code&gt; が実行されますが、 &lt;code&gt;expensive_test&lt;/code&gt; はしません。</target>
        </trans-unit>
        <trans-unit id="471c4d510c078cce605f07ee5e3b57ac50f1448c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;crate&lt;/code&gt;, we include each of the successive modules until we make our way to &lt;code&gt;add_to_waitlist&lt;/code&gt;. You can imagine a filesystem with the same structure, and we&amp;rsquo;d specify the path &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; to run the &lt;code&gt;add_to_waitlist&lt;/code&gt; program; using the &lt;code&gt;crate&lt;/code&gt; name to start from the crate root is like using &lt;code&gt;/&lt;/code&gt; to start from the filesystem root in your shell.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; 後、 &lt;code&gt;add_to_waitlist&lt;/code&gt; に進むまで、連続する各モジュールを含めます。同じ構造のファイルシステムを想像できます &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; &lt;code&gt;add_to_waitlist&lt;/code&gt; プログラムを実行するには、パス/ front_of_house / hosting / add_to_waitlistを指定します。 &lt;code&gt;crate&lt;/code&gt; 名を使用してクレートルートから開始するのは、 &lt;code&gt;/&lt;/code&gt; を使用してシェルのファイルシステムルートから開始するのと同じです。</target>
        </trans-unit>
        <trans-unit id="72900f50989a74635a45f599f7af957665be760a" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;skip_while()&lt;/code&gt;'s job is over, and the rest of the elements are yielded.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; が返された後、 &lt;code&gt;skip_while()&lt;/code&gt; のジョブは終了し、残りの要素が生成されます。</target>
        </trans-unit>
        <trans-unit id="a8fe2c79e763fccf582bfde64f2cf9442ce9db7c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;take_while()&lt;/code&gt;'s job is over, and the rest of the elements are ignored.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; が返された後、 &lt;code&gt;take_while()&lt;/code&gt; のジョブは終了し、残りの要素は無視されます。</target>
        </trans-unit>
        <trans-unit id="d9d86d37284d13e516ed39f67cc2c963b4451b66" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;leaf&lt;/code&gt; is created, its &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; has a strong count of 1 and a weak count of 0. In the inner scope, we create &lt;code&gt;branch&lt;/code&gt; and associate it with &lt;code&gt;leaf&lt;/code&gt;, at which point when we print the counts, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; will have a strong count of 1 and a weak count of 1 (for &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; with a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt;). When we print the counts in &lt;code&gt;leaf&lt;/code&gt;, we&amp;rsquo;ll see it will have a strong count of 2, because &lt;code&gt;branch&lt;/code&gt; now has a clone of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; of &lt;code&gt;leaf&lt;/code&gt; stored in &lt;code&gt;branch.children&lt;/code&gt;, but will still have a weak count of 0.</source>
          <target state="translated">&lt;code&gt;leaf&lt;/code&gt; が作成された後、その &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; は1の強いカウントと0の弱いカウントを持ちます。内部スコープで &lt;code&gt;branch&lt;/code&gt; を作成し、それを &lt;code&gt;leaf&lt;/code&gt; に関連付けます。この時点で、カウントを出力するとき、 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; &lt;code&gt;branch&lt;/code&gt; 内のカウントは強いカウント1と弱いカウント1になります（ &lt;code&gt;leaf.parent&lt;/code&gt; が &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; &lt;code&gt;branch&lt;/code&gt; を指している場合）。我々はカウントを印刷するとき &lt;code&gt;leaf&lt;/code&gt; 、我々はので、それは、2の強力な数を持っています表示されます &lt;code&gt;branch&lt;/code&gt; 今のクローンがある &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; の &lt;code&gt;leaf&lt;/code&gt; に保存されている &lt;code&gt;branch.children&lt;/code&gt; を、ただしカウントは0のままです。</target>
        </trans-unit>
        <trans-unit id="4cde8475e322a79219c56c165831cd534e7a6b56" translate="yes" xml:space="preserve">
          <source>After an iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, future calls may or may not yield &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; again. &lt;code&gt;fuse()&lt;/code&gt; adapts an iterator, ensuring that after a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is given, it will always return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; forever.</source>
          <target state="translated">イテレータが&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返した後は、今後の呼び出しで&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; が&lt;/a&gt;再び生成される場合と生成されない場合があります。 &lt;code&gt;fuse()&lt;/code&gt; はイテレータを適応させ、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;が指定された後は常に永久に&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;を返すようにします。</target>
        </trans-unit>
        <trans-unit id="568e22b9792d58baafe078fb9cf96ab4d0418d3f" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;fold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">イテレータのすべての要素にこのクロージャを適用した後、 &lt;code&gt;fold()&lt;/code&gt; はアキュムレータを返します。</target>
        </trans-unit>
        <trans-unit id="c5c6fbc1d802b5c2313fc5d60dee8a9485ff2828" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;rfold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">このクロージャーをイテレーターのすべてのエレメントに適用した後、 &lt;code&gt;rfold()&lt;/code&gt; はアキュムレーターを戻します。</target>
        </trans-unit>
        <trans-unit id="bc617f1ae4108d460b1173f3a7067fe06a8d7ed6" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="translated">この関数を呼び出した後、呼び出し元は以前に &lt;code&gt;Box&lt;/code&gt; によって管理されていたメモリを担当します。特に、呼び出し元は、 &lt;code&gt;Box&lt;/code&gt; で使用される&lt;a href=&quot;index#memory-layout&quot;&gt;メモリレイアウト&lt;/a&gt;を考慮して、 &lt;code&gt;T&lt;/code&gt; を適切に破棄し、メモリを解放する必要があります。これを行う最も簡単な方法は、&lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt;関数を使用して生のポインターを &lt;code&gt;Box&lt;/code&gt; に戻し、 &lt;code&gt;Box&lt;/code&gt; デストラクタがクリーンアップを実行できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="47bfd04ad6639821cf514c2ef1fb0d7b6f63839d" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory. The easiest way to do so is to convert the &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; pointer into a raw pointer and back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">この関数を呼び出した後、呼び出し元は以前に &lt;code&gt;Box&lt;/code&gt; によって管理されていたメモリを担当します。特に、呼び出し元は &lt;code&gt;T&lt;/code&gt; を適切に破棄し、メモリを解放する必要があります。そうするための最も簡単な方法は、変換することである &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; に生のポインタと背中にポインタ &lt;code&gt;Box&lt;/code&gt; と&lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt;機能。</target>
        </trans-unit>
        <trans-unit id="3d10c7bbc7ba580c584a70857a59b76ef027af83" translate="yes" xml:space="preserve">
          <source>After calling this function, the raw pointer is owned by the resulting &lt;code&gt;Box&lt;/code&gt;. Specifically, the &lt;code&gt;Box&lt;/code&gt; destructor will call the destructor of &lt;code&gt;T&lt;/code&gt; and free the allocated memory. For this to be safe, the memory must have been allocated in accordance with the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt; .</source>
          <target state="translated">この関数を呼び出した後、生のポインタは結果の &lt;code&gt;Box&lt;/code&gt; によって所有されます。具体的には、 &lt;code&gt;Box&lt;/code&gt; デストラクタは &lt;code&gt;T&lt;/code&gt; のデストラクタを呼び出し、割り当てられたメモリを解放します。これを安全にするには、 &lt;code&gt;Box&lt;/code&gt; が使用する&lt;a href=&quot;index#memory-layout&quot;&gt;メモリレイアウト&lt;/a&gt;に従ってメモリを割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="ef76ea7ae2deed3f017eb7251cbd0d7c334a7aaf" translate="yes" xml:space="preserve">
          <source>After changing &lt;code&gt;println!&lt;/code&gt; to &lt;code&gt;eprintln!&lt;/code&gt;, let&amp;rsquo;s run the program again in the same way, without any arguments and redirecting standard output with &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 変更した後！ &lt;code&gt;eprintln!&lt;/code&gt; 、引数なしで標準出力を &lt;code&gt;&amp;gt;&lt;/code&gt; でリダイレクトして、同じ方法でもう一度プログラムを実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="93133f68d39862996d0135a231d1905a95e950c2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; をソケットアドレスに&lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;作成した後、着信TCP接続をリッスンします。これらは、&lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;を呼び出すか、&lt;a href=&quot;#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt;イテレータを反復することによって受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="422e2b7f3798df18a9e41b4f6d8230c5f7fbaae2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">作成した後 &lt;code&gt;TcpStream&lt;/code&gt; いずれかの方法で&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;、リモートホストへのINGのか&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;の接続INGの&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; を&lt;/a&gt;、データを送信できる&lt;a href=&quot;../io/trait.read&quot;&gt;読書&lt;/a&gt;と&lt;a href=&quot;../io/trait.write&quot;&gt;書く&lt;/a&gt;ことに。</target>
        </trans-unit>
        <trans-unit id="b9be232588db8403f71ee1411aa554678f33dfa7" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">作成後 &lt;code&gt;UdpSocket&lt;/code&gt; によって&lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;ソケットアドレスにINGのは、データをすることができる&lt;a href=&quot;#method.send_to&quot;&gt;に送信&lt;/a&gt;及び&lt;a href=&quot;#method.recv_from&quot;&gt;から受信した&lt;/a&gt;他のソケットアドレス。</target>
        </trans-unit>
        <trans-unit id="3fc506cb877752d66797eaa2996ad1bfc89765b7" translate="yes" xml:space="preserve">
          <source>After creating a new &lt;code&gt;Job&lt;/code&gt; instance using the closure we get in &lt;code&gt;execute&lt;/code&gt;, we send that job down the sending end of the channel. We&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can&amp;rsquo;t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use &lt;code&gt;unwrap&lt;/code&gt; is that we know the failure case won&amp;rsquo;t happen, but the compiler doesn&amp;rsquo;t know that.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; で取得したクロージャーを使用して新しい &lt;code&gt;Job&lt;/code&gt; インスタンスを作成した後、そのジョブをチャネルの送信側に送信します。送信が失敗した場合のために、 &lt;code&gt;send&lt;/code&gt; に &lt;code&gt;unwrap&lt;/code&gt; を呼び出します。これは、たとえば、すべてのスレッドの実行を停止した場合、つまり受信側が新しいメッセージの受信を停止した場合に発生する可能性があります。現時点では、スレッドの実行を停止することはできません。プールが存在する限り、スレッドは実行を継続します。 &lt;code&gt;unwrap&lt;/code&gt; を使用する理由は、失敗のケースが発生しないことはわかっていますが、コンパイラはそれを知らないためです。</target>
        </trans-unit>
        <trans-unit id="458779f7008edf7b181827b22b99edf77f39bc41" translate="yes" xml:space="preserve">
          <source>After dropping the lock, we can print the mutex value and see that we were able to change the inner &lt;code&gt;i32&lt;/code&gt; to 6.</source>
          <target state="translated">ロックを削除した後、mutex値を出力して、内部の &lt;code&gt;i32&lt;/code&gt; を6 に変更できたことを確認できます。</target>
        </trans-unit>
        <trans-unit id="04760e628105c26e60bea171285ea7fc05de2cc2" translate="yes" xml:space="preserve">
          <source>After implementing the trait, we can call the methods on instances of &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; in the same way we call regular methods, like this:</source>
          <target state="translated">トレイトを実装した後、次のように通常のメソッドを呼び出すのと同じ方法で、 &lt;code&gt;NewsArticle&lt;/code&gt; と &lt;code&gt;Tweet&lt;/code&gt; のインスタンスのメソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="5a81464f303d05310b655ad576139ba2eadc374a" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-22.</source>
          <target state="translated">18章で &lt;code&gt;while let&lt;/code&gt; ループについて学んだ後、リスト20-22で示されるようになぜワーカースレッドコードを書かなかったのか疑問に思われるかもしれません。</target>
        </trans-unit>
        <trans-unit id="56e7d653965ec5efdfa2c953ebd2075ad09eb04a" translate="yes" xml:space="preserve">
          <source>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the &lt;code&gt;|&lt;/code&gt; operator, the arm would have matched and the program would have printed &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">コードの実行後、優先順位の動作は明らかです。一致ガードが、 &lt;code&gt;|&lt;/code&gt; を使用して指定された値のリストの最後の値にのみ適用された場合 オペレータ、腕は一致し、プログラムは &lt;code&gt;yes&lt;/code&gt; を出力します。</target>
        </trans-unit>
        <trans-unit id="6918a63768fd69dd2401af6cba199a57c7c6b4f3" translate="yes" xml:space="preserve">
          <source>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it&amp;rsquo;s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</source>
          <target state="translated">しばらくして、ナイトリーリリースを使用するRust開発者が新機能を試すことができるようになったら、チームメンバーはその機能と、その機能が毎晩どのように機能するかについて話し合い、安定したRustにするかどうかを決定します。決定が前進する場合は、機能ゲートが削除され、機能は安定していると見なされます。Rustの新しい安定版リリースに列車を乗せます。</target>
        </trans-unit>
        <trans-unit id="780f735c7776bf172259bb14b7f1d801e95b8329" translate="yes" xml:space="preserve">
          <source>After that statement, we&amp;rsquo;ve again added a temporary &lt;code&gt;println!&lt;/code&gt; statement that prints the value of &lt;code&gt;contents&lt;/code&gt; after the file is read, so we can check that the program is working so far.</source>
          <target state="translated">そのステートメントの後で、一時的な &lt;code&gt;println!&lt;/code&gt; 再び追加しました！ファイルが読み込まれた後に &lt;code&gt;contents&lt;/code&gt; の値を出力するステートメント。これにより、プログラムがこれまでに動作していることを確認できます。</target>
        </trans-unit>
        <trans-unit id="96e831200e66693625317e3844fc1e89f068a7a9" translate="yes" xml:space="preserve">
          <source>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the &lt;code&gt;Summary&lt;/code&gt; trait will have the method &lt;code&gt;summarize&lt;/code&gt; defined with this signature exactly.</source>
          <target state="translated">メソッドシグネチャの後、中かっこ内に実装を提供する代わりに、セミコロンを使用します。この特性を実装する各タイプは、メソッドの本体に独自のカスタム動作を提供する必要があります。コンパイラが有する任意のタイプのことを強制します &lt;code&gt;Summary&lt;/code&gt; 形質は、メソッドがあります &lt;code&gt;summarize&lt;/code&gt; まさにこの署名で定義します。</target>
        </trans-unit>
        <trans-unit id="fd61e6cd4b0dca5587c3bdc8b19a36c54df5d01a" translate="yes" xml:space="preserve">
          <source>After the parameters, we place curly brackets that hold the body of the closure&amp;mdash;these are optional if the closure body is a single expression. The end of the closure, after the curly brackets, needs a semicolon to complete the &lt;code&gt;let&lt;/code&gt; statement. The value returned from the last line in the closure body (&lt;code&gt;num&lt;/code&gt;) will be the value returned from the closure when it&amp;rsquo;s called, because that line doesn&amp;rsquo;t end in a semicolon; just as in function bodies.</source>
          <target state="translated">パラメーターの後に、クロージャーの本体を保持する中括弧を配置します。クロージャーの本体が単一の式である場合、これらはオプションです。中括弧の後のクロージャの終わりでは、 &lt;code&gt;let&lt;/code&gt; ステートメントを完了するためにセミコロンが必要です。クロージャー本体の最後の行（ &lt;code&gt;num&lt;/code&gt; ）から返される値は、呼び出されたときにクロージャーから返される値になります。これは、その行がセミコロンで終わっていないためです。関数本体と同じように。</target>
        </trans-unit>
        <trans-unit id="3409f581311196341ada32cc2fb23895a79e2d64" translate="yes" xml:space="preserve">
          <source>After the request line, the remaining lines starting from &lt;code&gt;Host:&lt;/code&gt; onward are headers. &lt;code&gt;GET&lt;/code&gt; requests have no body.</source>
          <target state="translated">リクエスト行の後の、 &lt;code&gt;Host:&lt;/code&gt; 以降の残りの行はヘッダーです。 &lt;code&gt;GET&lt;/code&gt; リクエストには本文がありません。</target>
        </trans-unit>
        <trans-unit id="94ada77990e54a7199b314d48e7c28b8866c26f5" translate="yes" xml:space="preserve">
          <source>After these two lines, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;foobar&lt;/code&gt;. The &lt;code&gt;push_str&lt;/code&gt; method takes a string slice because we don&amp;rsquo;t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&amp;rsquo;t able to use &lt;code&gt;s2&lt;/code&gt; after appending its contents to &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">これらの2行の後、 &lt;code&gt;s&lt;/code&gt; には &lt;code&gt;foobar&lt;/code&gt; が含まれます。 &lt;code&gt;push_str&lt;/code&gt; の我々は、必ずしもパラメータの所有権を取得したくないので、この方法では、文字列のスライスを取ります。たとえば、リスト8-16のコードは、コンテンツを &lt;code&gt;s1&lt;/code&gt; に追加した後で &lt;code&gt;s2&lt;/code&gt; を使用できなかった場合は残念であることを示しています。</target>
        </trans-unit>
        <trans-unit id="d28bc7bf7124bb617821696b52f238bf37faf9be" translate="yes" xml:space="preserve">
          <source>After they have been consumed, the rest of the elements are yielded. Rather than overriding this method directly, instead override the &lt;code&gt;nth&lt;/code&gt; method.</source>
          <target state="translated">それらが消費された後、残りの要素が生成されます。このメソッドを直接オーバーライドするのではなく、代わりに &lt;code&gt;nth&lt;/code&gt; メソッドをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="17378b2abc480d099ee902b5db16470e7091ec08" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed a copy of &lt;code&gt;libc&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on &lt;code&gt;libc&lt;/code&gt; to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">レジストリを更新した後、Cargoは &lt;code&gt;[dependencies]&lt;/code&gt; セクションをチェックして、まだ持っていないクレートをダウンロードします。この場合、依存関係として &lt;code&gt;rand&lt;/code&gt; のみをリストしましたが、機能するために &lt;code&gt;rand&lt;/code&gt; は &lt;code&gt;libc&lt;/code&gt; に依存しているため、Cargoは &lt;code&gt;libc&lt;/code&gt; のコピーも取得しました。クレートをダウンロードした後、Rustはそれらをコンパイルしてから、利用可能な依存関係を使用してプロジェクトをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="9d98c1489e41fbd88598871e5f8d212bbc3f78c5" translate="yes" xml:space="preserve">
          <source>After we define &lt;code&gt;summarize_author&lt;/code&gt;, we can call &lt;code&gt;summarize&lt;/code&gt; on instances of the &lt;code&gt;Tweet&lt;/code&gt; struct, and the default implementation of &lt;code&gt;summarize&lt;/code&gt; will call the definition of &lt;code&gt;summarize_author&lt;/code&gt; that we&amp;rsquo;ve provided. Because we&amp;rsquo;ve implemented &lt;code&gt;summarize_author&lt;/code&gt;, the &lt;code&gt;Summary&lt;/code&gt; trait has given us the behavior of the &lt;code&gt;summarize&lt;/code&gt; method without requiring us to write any more code.</source>
          <target state="translated">我々が定義した後 &lt;code&gt;summarize_author&lt;/code&gt; を、我々は呼び出すことができます &lt;code&gt;summarize&lt;/code&gt; のインスタンスに &lt;code&gt;Tweet&lt;/code&gt; 構造体、およびデフォルトの実装で &lt;code&gt;summarize&lt;/code&gt; の定義を呼び出します &lt;code&gt;summarize_author&lt;/code&gt; 私たちが提供したことを。私たちが実施してきたので &lt;code&gt;summarize_author&lt;/code&gt; を、 &lt;code&gt;Summary&lt;/code&gt; トレイトは、私たちの行動与えている &lt;code&gt;summarize&lt;/code&gt; いずれかのより多くのコードを書くために私たちを必要とせずに方法を。</target>
        </trans-unit>
        <trans-unit id="2556b8fd31ff1260ec94fc2ed10873de0af61a38" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve acquired the lock, we can treat the return value, named &lt;code&gt;num&lt;/code&gt; in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; is not an &lt;code&gt;i32&lt;/code&gt;, so we &lt;em&gt;must&lt;/em&gt; acquire the lock to be able to use the &lt;code&gt;i32&lt;/code&gt; value. We can&amp;rsquo;t forget; the type system won&amp;rsquo;t let us access the inner &lt;code&gt;i32&lt;/code&gt; otherwise.</source>
          <target state="translated">ロックを取得したら、戻り値（この場合は &lt;code&gt;num&lt;/code&gt; )を内部のデータへの変更可能な参照として扱うことができます。我々は、の値を使用する前にロックを取得することを型システム性を保証 &lt;code&gt;m&lt;/code&gt; ： &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; ない &lt;code&gt;i32&lt;/code&gt; 我々は、&lt;em&gt;しなければならない&lt;/em&gt;使用できるようにロックを取得 &lt;code&gt;i32&lt;/code&gt; 値。忘れられない。それ以外の場合、型システムは内部の &lt;code&gt;i32&lt;/code&gt; にアクセスできません。</target>
        </trans-unit>
        <trans-unit id="eea76bdbc5658f7fad1ad625716859e45f8c384f" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created &lt;em&gt;tests/common/mod.rs&lt;/em&gt;, we can use it from any of the integration test files as a module. Here&amp;rsquo;s an example of calling the &lt;code&gt;setup&lt;/code&gt; function from the &lt;code&gt;it_adds_two&lt;/code&gt; test in &lt;em&gt;tests/integration_test.rs&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;tests / common / mod.rs&lt;/em&gt;を作成した後、任意の統合テストファイルからそれをモジュールとして使用できます。次に示すのは、&lt;em&gt;tests / integration_test.rsの&lt;/em&gt; &lt;code&gt;it_adds_two&lt;/code&gt; テストから &lt;code&gt;setup&lt;/code&gt; 関数を呼び出す例です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43dc84fb12e1a579a9d73c911c37d0ab1b82a9f5" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created the lists in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we add 10 to the value in &lt;code&gt;value&lt;/code&gt;. We do this by calling &lt;code&gt;borrow_mut&lt;/code&gt; on &lt;code&gt;value&lt;/code&gt;, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;Where&amp;rsquo;s the &lt;code&gt;-&amp;gt;&lt;/code&gt; Operator?&amp;rdquo;&lt;/a&gt;) to dereference the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to the inner &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; value. The &lt;code&gt;borrow_mut&lt;/code&gt; method returns a &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, and we use the dereference operator on it and change the inner value.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; のリストを作成したら、valueの値に10を追加し &lt;code&gt;value&lt;/code&gt; 。私たちは、呼び出すことによってこれを行う &lt;code&gt;borrow_mut&lt;/code&gt; 上の &lt;code&gt;value&lt;/code&gt; （セクションを参照してください我々は、第5章で説明した自動逆参照機能を使用して、&lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;「どこだ &lt;code&gt;-&amp;gt;&lt;/code&gt; 演算子？」&lt;/a&gt;逆参照する） &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 内部に &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 値を。 &lt;code&gt;borrow_mut&lt;/code&gt; の方法は返し &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; スマートポインタを、私たちはそれに間接参照演算子を使用し、内側の値を変更します。</target>
        </trans-unit>
        <trans-unit id="b18bd157b258782bdf4328d729095843e56901f9" translate="yes" xml:space="preserve">
          <source>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler&amp;rsquo;s code so the borrow checker could infer the lifetimes in these situations and wouldn&amp;rsquo;t need explicit annotations.</source>
          <target state="translated">多くのRustコードを記述した後、Rustチームは、Rustプログラマーが特定の状況で同じライフタイムアノテーションを何度も入力していることを発見しました。これらの状況は予測可能であり、いくつかの確定的なパターンに従っていました。開発者はこれらのパターンをコンパイラーのコードにプログラムしたので、借用チェッカーはこれらの状況で寿命を推測でき、明示的な注釈は必要ありません。</target>
        </trans-unit>
        <trans-unit id="8911f4e8942ad7726d100e32781ae750b7e4baf7" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve installed Rust via &lt;code&gt;rustup&lt;/code&gt;, updating to the latest version is easy. From your shell, run the following update script:</source>
          <target state="translated">&lt;code&gt;rustup&lt;/code&gt; を使用してRustをインストールした後は、最新バージョンに簡単に更新できます。シェルから、次の更新スクリプトを実行します。</target>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="translated">After:</target>
        </trans-unit>
        <trans-unit id="1d0c9f96248d537407790c171b6d4f7cd1fd7157" translate="yes" xml:space="preserve">
          <source>Again, this is the simplest implementation of the &lt;code&gt;execute&lt;/code&gt; method: it does nothing, but we&amp;rsquo;re trying only to make our code compile. Let&amp;rsquo;s check it again:</source>
          <target state="translated">繰り返しますが、これは &lt;code&gt;execute&lt;/code&gt; メソッドの最も単純な実装です。何もしませんが、コードをコンパイルすることだけを試みています。もう一度確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="7b6d0c4005bedf77e43140c67158dc3c2786f272" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;re using &lt;code&gt;thread::spawn&lt;/code&gt; to create a new thread and then using &lt;code&gt;move&lt;/code&gt; to move &lt;code&gt;tx&lt;/code&gt; into the closure so the spawned thread owns &lt;code&gt;tx&lt;/code&gt;. The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</source>
          <target state="translated">ここでも、 &lt;code&gt;thread::spawn&lt;/code&gt; を使用して新しいスレッドを作成し、 &lt;code&gt;move&lt;/code&gt; を使用して &lt;code&gt;tx&lt;/code&gt; をクロージャーに移動しているため、生成されたスレッドは &lt;code&gt;tx&lt;/code&gt; を所有しています。生成されたスレッドは、チャネルを介してメッセージを送信できるように、チャネルの送信側を所有する必要があります。</target>
        </trans-unit>
        <trans-unit id="42935bf9ba7e07a25a52edfb6e2d38809a0c1bab" translate="yes" xml:space="preserve">
          <source>Again, you need not specify the full type if the compiler can infer it:</source>
          <target state="translated">繰り返しになりますが、コンパイラが推測できる場合は完全な型を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="3cc0e9834230ccbe94275d501fa3b8e31c8d1c62" translate="yes" xml:space="preserve">
          <source>Aha! The first error message indicates that &lt;code&gt;counter&lt;/code&gt; is moved into the closure for the thread associated with &lt;code&gt;handle&lt;/code&gt;. That move is preventing us from capturing &lt;code&gt;counter&lt;/code&gt; when we try to call &lt;code&gt;lock&lt;/code&gt; on it and store the result in &lt;code&gt;num2&lt;/code&gt; in the second thread! So Rust is telling us that we can&amp;rsquo;t move ownership of &lt;code&gt;counter&lt;/code&gt; into multiple threads. This was hard to see earlier because our threads were in a loop, and Rust can&amp;rsquo;t point to different threads in different iterations of the loop. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">ああ！最初のエラーメッセージは、 &lt;code&gt;counter&lt;/code&gt; が、 &lt;code&gt;handle&lt;/code&gt; に関連付けられたスレッドのクロージャーに移動したことを示しています。その移動により、 &lt;code&gt;lock&lt;/code&gt; を呼び出してその結果を2番目のスレッドの &lt;code&gt;num2&lt;/code&gt; に保存しようと &lt;code&gt;counter&lt;/code&gt; ときに、カウンターをキャプチャできなくなります。したがって、Rustは、 &lt;code&gt;counter&lt;/code&gt; の所有権を複数のスレッドに移動することはできないと言っています。私たちのスレッドはループ内にあったため、これを以前に確認することは困難でした。また、Rustはループの異なる反復で異なるスレッドを指すことができません。第15章で説明した複数所有者メソッドを使用して、コンパイラエラーを修正しましょう。</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="6c230b19ce360dc47ab1f803ec5d75221398ff9e" translate="yes" xml:space="preserve">
          <source>Alignment::borrow</source>
          <target state="translated">Alignment::borrow</target>
        </trans-unit>
        <trans-unit id="77b6c3d761057550ac535096603085a4ab21f25d" translate="yes" xml:space="preserve">
          <source>Alignment::borrow_mut</source>
          <target state="translated">Alignment::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d45a68b20b4cc6114f5421add49178bf870ce27b" translate="yes" xml:space="preserve">
          <source>Alignment::fmt</source>
          <target state="translated">Alignment::fmt</target>
        </trans-unit>
        <trans-unit id="0912a9a905355e3a6df915cce4fce3e26fba4e82" translate="yes" xml:space="preserve">
          <source>Alignment::from</source>
          <target state="translated">Alignment::from</target>
        </trans-unit>
        <trans-unit id="14750a6b1eb92c0620b2d52bd702a109608e9cb3" translate="yes" xml:space="preserve">
          <source>Alignment::into</source>
          <target state="translated">Alignment::into</target>
        </trans-unit>
        <trans-unit id="b06fe916f5f193304938aca87ce9baf4fe4a81c0" translate="yes" xml:space="preserve">
          <source>Alignment::try_from</source>
          <target state="translated">Alignment::try_from</target>
        </trans-unit>
        <trans-unit id="7e4c9d31924344ef62791e3f5778cc0b64650841" translate="yes" xml:space="preserve">
          <source>Alignment::try_into</source>
          <target state="translated">Alignment::try_into</target>
        </trans-unit>
        <trans-unit id="f8d85378f8bd14502ad4a535bf35eace323f7be0" translate="yes" xml:space="preserve">
          <source>Alignment::type_id</source>
          <target state="translated">Alignment::type_id</target>
        </trans-unit>
        <trans-unit id="1f13dd31cf3795018ba8cb51097f5cee92e51d26" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;items&quot;&gt;item declarations&lt;/a&gt; accept outer attributes while &lt;a href=&quot;items/external-blocks&quot;&gt;external blocks&lt;/a&gt;, &lt;a href=&quot;items/functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt;, and &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt; accept inner attributes.</source>
          <target state="translated">すべての&lt;a href=&quot;items&quot;&gt;項目宣言&lt;/a&gt;は外部属性を受け入れますが、&lt;a href=&quot;items/external-blocks&quot;&gt;外部ブロック&lt;/a&gt;、&lt;a href=&quot;items/functions&quot;&gt;関数&lt;/a&gt;、&lt;a href=&quot;items/implementations&quot;&gt;実装&lt;/a&gt;、および&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;は内部属性を受け入れます。</target>
        </trans-unit>
        <trans-unit id="e7edfb23f380c12b821737c77295267e0d55adfa" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;if&lt;/code&gt; expressions start with the keyword &lt;code&gt;if&lt;/code&gt;, which is followed by a condition. In this case, the condition checks whether or not the variable &lt;code&gt;number&lt;/code&gt; has a value less than 5. The block of code we want to execute if the condition is true is placed immediately after the condition inside curly brackets. Blocks of code associated with the conditions in &lt;code&gt;if&lt;/code&gt; expressions are sometimes called &lt;em&gt;arms&lt;/em&gt;, just like the arms in &lt;code&gt;match&lt;/code&gt; expressions that we discussed in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section of Chapter 2.</source>
          <target state="translated">すべての &lt;code&gt;if&lt;/code&gt; 式はキーワード &lt;code&gt;if&lt;/code&gt; で始まり、その後に条件が続きます。この場合、条件は変数 &lt;code&gt;number&lt;/code&gt; が5未満の値であるかどうかをチェックします。条件がtrueの場合に実行するコードのブロックは、中括弧内の条件の直後に配置されます。第2章の&lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;「推測とシークレット番号の比較」&lt;/a&gt;セクションで説明した &lt;code&gt;match&lt;/code&gt; 表現の&lt;em&gt;腕&lt;/em&gt;と同じように、 &lt;code&gt;if&lt;/code&gt; 式がarmと呼ばれることもある条件に関連付けられたコードのブロック。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d770608aae868ce44cc837cd9b78c8161bf1b4b" translate="yes" xml:space="preserve">
          <source>All ASCII</source>
          <target state="translated">すべてのアスキー</target>
        </trans-unit>
        <trans-unit id="941b268ba2f8b2e2bf50827de379fcc106a7ae00" translate="yes" xml:space="preserve">
          <source>All Rust compiler versions support any edition that existed prior to that compiler&amp;rsquo;s release, and they can link crates of any supported editions together. Edition changes only affect the way the compiler initially parses code. Therefore, if you&amp;rsquo;re using Rust 2015 and one of your dependencies uses Rust 2018, your project will compile and be able to use that dependency. The opposite situation, where your project uses Rust 2018 and a dependency uses Rust 2015, works as well.</source>
          <target state="translated">すべてのRustコンパイラバージョンは、そのコンパイラのリリース前に存在していたエディションをサポートし、サポートされているエディションのクレートをリンクできます。エディションの変更は、コンパイラーが最初にコードを解析する方法にのみ影響します。したがって、Rust 2015を使用していて、依存関係の1つがRust 2018を使用している場合、プロジェクトはコンパイルされ、その依存関係を使用できます。プロジェクトがRust 2018を使用し、依存関係がRust 2015を使用するという反対の状況も同様に機能します。</target>
        </trans-unit>
        <trans-unit id="7652c7eeda6497653864c68957d9fcd32bd3f053" translate="yes" xml:space="preserve">
          <source>All Unicode</source>
          <target state="translated">すべてのユニコード</target>
        </trans-unit>
        <trans-unit id="47de5609df925352bb65b1c68fe6d11ef3c5f11f" translate="yes" xml:space="preserve">
          <source>All Unicode characters contained in the raw string body represent themselves, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">生の文字列本体に含まれるすべてのUnicode文字は、それ自体、文字 &lt;code&gt;U+0022&lt;/code&gt; （二重引用符）（生の文字列リテラルの開始に使用されたのと同じ数以上の &lt;code&gt;U+0023&lt;/code&gt; （ &lt;code&gt;#&lt;/code&gt; ）文字が続く場合を除く）または &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）には特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="8a1ba3bb13e8cd072a280ba55ff12cd4ec0faacf" translate="yes" xml:space="preserve">
          <source>All access to a static is safe, but there are a number of restrictions on statics:</source>
          <target state="translated">スタティックへのアクセスはすべて安全ですが、スタティックにはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="cc4193fdbde0490cb6df1ff9fd4927655f61fac3" translate="yes" xml:space="preserve">
          <source>All access to the inner value through methods is &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">メソッドによる内部値へのアクセスはすべて &lt;code&gt;unsafe&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="ceb9b59e717209dd478129622af76401fc92a7ef" translate="yes" xml:space="preserve">
          <source>All accesses performed by functions in this module are &lt;em&gt;non-atomic&lt;/em&gt; in the sense of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic operations&lt;/a&gt; used to synchronize between threads. This means it is undefined behavior to perform two concurrent accesses to the same location from different threads unless both accesses only read from memory. Notice that this explicitly includes &lt;a href=&quot;fn.read_volatile&quot;&gt;&lt;code&gt;read_volatile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;/code&gt;&lt;/a&gt;: Volatile accesses cannot be used for inter-thread synchronization.</source>
          <target state="translated">このモジュールの関数によって実行されるすべてのアクセスは、スレッド間の同期に使用される&lt;a href=&quot;../sync/atomic/index&quot;&gt;アトミック操作&lt;/a&gt;の意味で&lt;em&gt;非アトミック&lt;/em&gt;です。つまり、両方のアクセスがメモリからの読み取りのみでない限り、異なるスレッドから同じ場所への2つの同時アクセスを実行することは未定義の動作です。これには、&lt;a href=&quot;fn.read_volatile&quot;&gt; &lt;code&gt;read_volatile&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;fn.write_volatile&quot;&gt; &lt;code&gt;write_volatile&lt;/code&gt; が&lt;/a&gt;明示的に含まれていることに注意してください。揮発性アクセスは、スレッド間同期には使用できません。</target>
        </trans-unit>
        <trans-unit id="5d3e246179e6158acb2b336b6eaaa6c3cd96b12d" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take O(n) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="translated">すべての償却コストは、容量が枯渇したときにサイズ変更が必要になる可能性があるためのものです。サイズ変更が発生した場合、O(n)の時間がかかります。私たちのコレクションは自動的に縮小することはないので、除去作業は償却されません。十分に大規模な一連の作業については、作業ごとの平均コストは決定論的に与えられたコストと等しくなります。</target>
        </trans-unit>
        <trans-unit id="ad40505a1a509d19ac8713b0e6d72bf2f8406439" translate="yes" xml:space="preserve">
          <source>All associated functions must either have a &lt;code&gt;where Self: Sized&lt;/code&gt; bound, or</source>
          <target state="translated">関連するすべての関数には、 &lt;code&gt;where Self: Sized&lt;/code&gt; 境界、または</target>
        </trans-unit>
        <trans-unit id="15061bca973f1e3bdfd6bc4220f487a4d9f0fa2e" translate="yes" xml:space="preserve">
          <source>All atomic types in this module are guaranteed to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;lock-free&lt;/a&gt; if they're available. This means they don't internally acquire a global mutex. Atomic types and operations are not guaranteed to be wait-free. This means that operations like &lt;code&gt;fetch_or&lt;/code&gt; may be implemented with a compare-and-swap loop.</source>
          <target state="translated">このモジュールのすべてのアトミック型は、利用可能であれば&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;ロックフリーである&lt;/a&gt;ことが保証されています。つまり、内部的にグローバルミューテックスを取得しません。原子のタイプと操作は、待機なしであることが保証されていません。つまり、 &lt;code&gt;fetch_or&lt;/code&gt; などの操作は、比較とスワップのループを使用して実装できます。</target>
        </trans-unit>
        <trans-unit id="290ed2d52fa06b05e83bf6a12f1d4aa3dca7ba7c" translate="yes" xml:space="preserve">
          <source>All binaries installed with &lt;code&gt;cargo install&lt;/code&gt; are stored in the installation root&amp;rsquo;s &lt;em&gt;bin&lt;/em&gt; folder. If you installed Rust using &lt;em&gt;rustup.rs&lt;/em&gt; and don&amp;rsquo;t have any custom configurations, this directory will be &lt;em&gt;$HOME/.cargo/bin&lt;/em&gt;. Ensure that directory is in your &lt;code&gt;$PATH&lt;/code&gt; to be able to run programs you&amp;rsquo;ve installed with &lt;code&gt;cargo install&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo install&lt;/code&gt; されるすべてのバイナリは、インストールルートの&lt;em&gt;bin&lt;/em&gt;フォルダに格納されます。&lt;em&gt;rustup.rs&lt;/em&gt;を使用してRustをインストールし、カスタム構成がない場合、このディレクトリは&lt;em&gt;$ HOME / .cargo / binになり&lt;/em&gt;ます。 &lt;code&gt;cargo install&lt;/code&gt; したプログラムを実行できるように、ディレクトリが &lt;code&gt;$PATH&lt;/code&gt; にあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="33d170f2503ad727df2773d3d501af5a7c6f33f7" translate="yes" xml:space="preserve">
          <source>All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; which are banned since they are short-circuiting.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; を除くすべてのブール演算子 それらは短絡しているため禁止されています。</target>
        </trans-unit>
        <trans-unit id="1797e85af758baa0954345dbaa6c305b8c789f74" translate="yes" xml:space="preserve">
          <source>All bytes read from this source will be appended to the specified buffer &lt;code&gt;buf&lt;/code&gt;. This function will continuously call &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; to append more data to &lt;code&gt;buf&lt;/code&gt; until &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; returns either &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt; or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind.</source>
          <target state="translated">このソースから読み取られたすべてのバイトは、指定されたバッファー &lt;code&gt;buf&lt;/code&gt; に追加されます。この関数は、連続的に呼ぶ&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;ために多くのデータ追加する &lt;code&gt;buf&lt;/code&gt; をするまで&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;戻りいずれか&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;または非誤差&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;種類。</target>
        </trans-unit>
        <trans-unit id="792e4e8c3b4454b76d09b3a55c5244a2a04987c6" translate="yes" xml:space="preserve">
          <source>All calls to &lt;code&gt;write&lt;/code&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="translated">返されたインスタンスに &lt;code&gt;write&lt;/code&gt; すべての呼び出しは &lt;code&gt;Ok(buf.len())&lt;/code&gt; を返し、バッファーの内容は検査されません。</target>
        </trans-unit>
        <trans-unit id="163ac7eae61cfe370b91ace9f314d434af91aec2" translate="yes" xml:space="preserve">
          <source>All characters contained in the raw string body represent their ASCII encoding, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">未加工文字列の本文に含まれるすべての文字は、ASCIIエンコーディングを表します。文字 &lt;code&gt;U+0022&lt;/code&gt; （二重引用符）（その後に、未加工文字列リテラルの開始に使用されたのと同じ数の &lt;code&gt;U+0023&lt;/code&gt; （ &lt;code&gt;#&lt;/code&gt; ）文字が続く場合を除く）または &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）には特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="43d6b6384605c36d010e25334a7b59d1666b30b5" translate="yes" xml:space="preserve">
          <source>All closure types implement &lt;a href=&quot;../special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;. Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</source>
          <target state="translated">すべてのクロージャタイプは&lt;a href=&quot;../special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; を&lt;/a&gt;実装します。さらに、クロージャタイプは、格納するキャプチャのタイプによって許可されている場合、次の特性を実装します。</target>
        </trans-unit>
        <trans-unit id="a34254512b20b7c3c4f4d4cb8623d62bc5f25917" translate="yes" xml:space="preserve">
          <source>All crates have a &lt;em&gt;prelude&lt;/em&gt; that automatically inserts names from a specific module, the &lt;em&gt;prelude module&lt;/em&gt;, into scope of each &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; and an &lt;a href=&quot;items/extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; into the crate root module. By default, the &lt;em&gt;standard prelude&lt;/em&gt; is used. The linked crate is &lt;a href=&quot;../std/index&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;../std/prelude/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">すべてのクレートには、特定のモジュールからの名前である&lt;em&gt;プレリュードモジュール&lt;/em&gt;を各&lt;a href=&quot;items/modules&quot;&gt;モジュールの&lt;/a&gt;スコープに自動的に挿入する&lt;em&gt;プレリュード&lt;/em&gt;があり、&lt;a href=&quot;items/extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt;がクレートルートモジュールに挿入されます。デフォルトでは、&lt;em&gt;標準のプレリュード&lt;/em&gt;が使用されます。リンクされたクレートは&lt;a href=&quot;../std/index&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;で、preludeモジュールは&lt;a href=&quot;../std/prelude/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt;です。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80e6d9f67f0a7d01f6edd0112ce6e32390cc7b99" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在ブロックされているすべての&lt;a href=&quot;../io/trait.read&quot;&gt;読み取り&lt;/a&gt;と将来の読み取りは&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="a6d40cb983863467fc229fa6f4b9f265ef62418a" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.write&quot;&gt;writes&lt;/a&gt; will return an error.</source>
          <target state="translated">現在ブロックされているすべての&lt;a href=&quot;../io/trait.write&quot;&gt;書き込み&lt;/a&gt;と今後の書き込みはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="b5ad10491502eb3084d1fb833cddef2d6e97c099" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="translated">スタックに格納されるすべてのデータは、既知の固定サイズでなければなりません。コンパイル時に不明なサイズまたは変更される可能性のあるサイズのデータ​​は、代わりにヒープに格納する必要があります。ヒープはあまり整理されていません。ヒープにデータを配置すると、一定量のスペースが要求されます。オペレーティングシステムは、十分な大きさのヒープ内の空の場所を見つけ、使用中としてマークし、その場所のアドレスである&lt;em&gt;ポインタ&lt;/em&gt;を返します。このプロセスは&lt;em&gt;、ヒープ&lt;/em&gt;への&lt;em&gt;割り当て&lt;/em&gt;と呼ば&lt;em&gt;れ、&lt;/em&gt;単に&lt;em&gt;割り当てる&lt;/em&gt;ことと略されることもあります。スタックに値をプッシュすることは、割り当てとは見なされません。ポインタは既知の固定サイズであるため、スタックにポインタを格納できますが、実際のデータが必要な場合は、ポインタに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="c3ab61183db153bdcb93b3db49372bcfa15c64d0" translate="yes" xml:space="preserve">
          <source>All elements of arrays are always initialized, and access to an array is always bounds-checked in safe methods and operators.</source>
          <target state="translated">配列のすべての要素は常に初期化され、配列へのアクセスは常に安全なメソッドと演算子で境界チェックされます。</target>
        </trans-unit>
        <trans-unit id="7fbb5676d98408c23a91ee3e50ae6931e19803d3" translate="yes" xml:space="preserve">
          <source>All elements of slices are always initialized, and access to a slice is always bounds-checked in safe methods and operators.</source>
          <target state="translated">スライスのすべての要素は常に初期化され、スライスへのアクセスは常に安全なメソッドと演算子で境界チェックされます。</target>
        </trans-unit>
        <trans-unit id="833e88d98de8f4240c961bc71bc4ebdf6caf04e8" translate="yes" xml:space="preserve">
          <source>All five array values appear in the terminal, as expected. Even though &lt;code&gt;index&lt;/code&gt; will reach a value of &lt;code&gt;5&lt;/code&gt; at some point, the loop stops executing before trying to fetch a sixth value from the array.</source>
          <target state="translated">予想どおり、5つの配列値すべてがターミナルに表示されます。 &lt;code&gt;index&lt;/code&gt; がある時点で値 &lt;code&gt;5&lt;/code&gt; に到達しても、ループは配列から6番目の値をフェッチしようとする前に実行を停止します。</target>
        </trans-unit>
        <trans-unit id="e11d83f6e553be6952611c97ac05bbc3817eeae9" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="translated">4つのタイプのループはすべて、&lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 式&lt;/a&gt;、&lt;a href=&quot;loop-expr#continue-expressions&quot;&gt; &lt;code&gt;continue&lt;/code&gt; 式&lt;/a&gt;、および&lt;a href=&quot;loop-expr#loop-labels&quot;&gt;ラベルを&lt;/a&gt;サポートしています。 &lt;code&gt;loop&lt;/code&gt; のみが&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;重要な値への評価を&lt;/a&gt;サポートしています。</target>
        </trans-unit>
        <trans-unit id="0615d0c10f128d4e7e9a656552c9285eca738194" translate="yes" xml:space="preserve">
          <source>All function items implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">すべての関数項目は、&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;実装します。</target>
        </trans-unit>
        <trans-unit id="c77d0720d55ff4ece3326614a73ddde6503e3179" translate="yes" xml:space="preserve">
          <source>All implementations of &lt;code&gt;Unsize&lt;/code&gt; are provided automatically by the compiler.</source>
          <target state="translated">&lt;code&gt;Unsize&lt;/code&gt; のすべての実装は、コンパイラによって自動的に提供されます。</target>
        </trans-unit>
        <trans-unit id="94282a18d174676690037624bae4b4b406cb02ee" translate="yes" xml:space="preserve">
          <source>All iterators implement a trait named &lt;code&gt;Iterator&lt;/code&gt; that is defined in the standard library. The definition of the trait looks like this:</source>
          <target state="translated">すべての反復子は、標準ライブラリで定義されている &lt;code&gt;Iterator&lt;/code&gt; という名前の特性を実装します。トレイトの定義は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7da42c45b54f4237c99325204711121b9f08beec" translate="yes" xml:space="preserve">
          <source>All kinds of ASCII whitespace are considered:</source>
          <target state="translated">すべての種類のASCIIホワイトスペースを考慮しています。</target>
        </trans-unit>
        <trans-unit id="3e530c202d9d3c48672f8f7b98a14e41befed3be" translate="yes" xml:space="preserve">
          <source>All kinds of whitespace are considered:</source>
          <target state="translated">あらゆる種類のホワイトスペースが考慮されています。</target>
        </trans-unit>
        <trans-unit id="9c42bdece20642dd1d10ab718ff507235d349b8d" translate="yes" xml:space="preserve">
          <source>All layouts have an associated non-negative size and a power-of-two alignment.</source>
          <target state="translated">すべてのレイアウトは、関連する非負のサイズと2乗のアライメントを持っています。</target>
        </trans-unit>
        <trans-unit id="32f70044558e382c5ebf59ec68e9d711cc2cb7b2" translate="yes" xml:space="preserve">
          <source>All of the coefficients get stored in registers, which means accessing the values is very fast. There are no bounds checks on the array access at runtime. All these optimizations that Rust is able to apply make the resulting code extremely efficient. Now that you know this, you can use iterators and closures without fear! They make code seem like it&amp;rsquo;s higher level but don&amp;rsquo;t impose a runtime performance penalty for doing so.</source>
          <target state="translated">すべての係数はレジスタに格納されます。つまり、値へのアクセスは非常に高速です。実行時の配列アクセスには境界チェックはありません。Rustが適用できるこれらすべての最適化により、結果のコードは非常に効率的になります。これがわかったので、イテレーターとクロージャーを恐れずに使用できます！それらはコードをより高いレベルのように見せますが、そうするために実行時のパフォーマンスのペナルティを課しません。</target>
        </trans-unit>
        <trans-unit id="17dabbf042cc2454dd1f0ba98c8b7c6f3be65ec5" translate="yes" xml:space="preserve">
          <source>All of the logic that manages the counts and value dropping is built into &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; and their implementations of the &lt;code&gt;Drop&lt;/code&gt; trait. By specifying that the relationship from a child to its parent should be a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; reference in the definition of &lt;code&gt;Node&lt;/code&gt;, you&amp;rsquo;re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.</source>
          <target state="translated">カウントと値のドロップを管理するすべてのロジックは、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; とそれらの &lt;code&gt;Drop&lt;/code&gt; トレイトの実装に組み込まれています。子からその親への関係が &lt;code&gt;Node&lt;/code&gt; の定義で &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 参照になるように指定することにより、参照サイクルとメモリリークを作成せずに、親ノードを子ノードにポイントでき、その逆も可能です。</target>
        </trans-unit>
        <trans-unit id="469c3254d30ae896569972fb8c0f6e762f31a91d" translate="yes" xml:space="preserve">
          <source>All of the standard collections provide several iterators for performing bulk manipulation of their contents. The three primary iterators almost every collection should provide are &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;iter_mut&lt;/code&gt;, and &lt;code&gt;into_iter&lt;/code&gt;. Some of these are not provided on collections where it would be unsound or unreasonable to provide them.</source>
          <target state="translated">すべての標準コレクションには、コンテンツの一括操作を実行するためのいくつかの反復子が用意されています。ほとんどすべてのコレクションが提供する必要がある3つの主要なイテレータは、 &lt;code&gt;iter&lt;/code&gt; 、 &lt;code&gt;iter_mut&lt;/code&gt; 、および &lt;code&gt;into_iter&lt;/code&gt; です。これらのいくつかは、それらを提供することが不健全または不合理であるコレクションでは提供されません。</target>
        </trans-unit>
        <trans-unit id="7c09f50beeaa399a934ba76d5cc5d913f4961d31" translate="yes" xml:space="preserve">
          <source>All of these are valid &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">これらはすべて有効な &lt;code&gt;String&lt;/code&gt; 値です。</target>
        </trans-unit>
        <trans-unit id="3488f647e2016335e532591f4617d056149f656a" translate="yes" xml:space="preserve">
          <source>All of these method calls are possible because we specified how the &lt;code&gt;next&lt;/code&gt; method works, and the standard library provides default implementations for other methods that call &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; メソッドの動作方法を指定したため、これらのメソッド呼び出しはすべて可能であり、標準ライブラリは、 &lt;code&gt;next&lt;/code&gt; を呼び出す他のメソッドのデフォルト実装を提供します。</target>
        </trans-unit>
        <trans-unit id="2a8409870b71900361c6e9ce41cc4d8b31f5a720" translate="yes" xml:space="preserve">
          <source>All options are initially set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">すべてのオプションは、最初は &lt;code&gt;false&lt;/code&gt; に設定されています。</target>
        </trans-unit>
        <trans-unit id="cec813890e4d07a2defc7bce522b39b7b6522a4d" translate="yes" xml:space="preserve">
          <source>All other arguments given to the &lt;code&gt;inline&lt;/code&gt; attribute will return this error. Example:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 属性に他のすべての引数を指定すると、このエラーが返されます。例：</target>
        </trans-unit>
        <trans-unit id="110d2b10be35d17317e6c561cf91a4fabbf8e826" translate="yes" xml:space="preserve">
          <source>All other characters are given hexadecimal Unicode escapes; see &lt;a href=&quot;#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">他のすべての文字には、16進数のUnicodeエスケープが与えられます。&lt;a href=&quot;#method.escape_unicode&quot;&gt; &lt;code&gt;escape_unicode&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f76ce538d07b9974a525f600e48b7f5dff4ae16c" translate="yes" xml:space="preserve">
          <source>All other fragment specifiers have no restrictions.</source>
          <target state="translated">他のすべてのフラグメント指定子には制限はありません。</target>
        </trans-unit>
        <trans-unit id="fef84ba857bf1c83a92f8d5a5b2d52afc2b3c691" translate="yes" xml:space="preserve">
          <source>All pointers (except for the null pointer) are valid for all operations of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="translated">すべてのポインター（ヌルポインターを除く）は、&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;サイズがゼロの&lt;/a&gt;すべての操作に有効です。</target>
        </trans-unit>
        <trans-unit id="bcec8da89ce19312f810d6e8b0a4c1c994af8c3f" translate="yes" xml:space="preserve">
          <source>All pointers in Rust are explicit first-class values. They can be moved or copied, stored into data structs, and returned from functions.</source>
          <target state="translated">Rust のすべてのポインタは明示的なファーストクラス値です。これらは移動やコピー、データ構造体への格納、関数からの戻り値として使用できます。</target>
        </trans-unit>
        <trans-unit id="6a33c45e166bf3f976aac4c7eec793b7d8946ca1" translate="yes" xml:space="preserve">
          <source>All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave notes, or &lt;em&gt;comments&lt;/em&gt;, in their source code that the compiler will ignore but people reading the source code may find useful.</source>
          <target state="translated">すべてのプログラマーはコードを理解しやすくするよう努めていますが、追加の説明が必要な場合もあります。このような場合、プログラマーはソースコードにメモまたは&lt;em&gt;コメントを&lt;/em&gt;残しますが、コンパイラーは無視しますが、ソースコードを読んでいる人には便利です。</target>
        </trans-unit>
        <trans-unit id="aa0c879bcf5cab9e7f4749d5ede013d5bf918c1f" translate="yes" xml:space="preserve">
          <source>All programs have to manage the way they use a computer&amp;rsquo;s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it&amp;rsquo;s running.</source>
          <target state="translated">すべてのプログラムは、実行中にコンピュータのメモリを使用する方法を管理する必要があります。一部の言語には、プログラムの実行時に使用されなくなったメモリを常に探すガベージコレクションがあります。他の言語では、プログラマは明示的にメモリを割り当てて解放する必要があります。Rustは3番目のアプローチを使用します。メモリーは、コンパイラーがコンパイル時にチェックする一連のルールを持つ所有権のシステムを通じて管理されます。所有権機能は、プログラムの実行中にプログラムの速度を低下させることはありません。</target>
        </trans-unit>
        <trans-unit id="cf610b10a23cb06f62489f071586a11ed04b1ece" translate="yes" xml:space="preserve">
          <source>All reads from the returned reader will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">返されたリーダーからのすべての読み取りは&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="5edadac5bb39f603d58e3300e69ef3e103ed0e48" translate="yes" xml:space="preserve">
          <source>All reads from this reader will succeed by filling the specified buffer with the given byte.</source>
          <target state="translated">このリーダーからのすべての読み取りは、指定されたバイトで指定されたバッファを埋めることで成功します。</target>
        </trans-unit>
        <trans-unit id="8042ca5a8b0159faa7d15d89ddf16924d0bee8ca" translate="yes" xml:space="preserve">
          <source>All results of &lt;code&gt;next()&lt;/code&gt; need to be identical to the results of &lt;code&gt;next_back()&lt;/code&gt; in reverse order.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; の結果はすべて、逆の順序で &lt;code&gt;next_back()&lt;/code&gt; の結果と同一である必要があります。</target>
        </trans-unit>
        <trans-unit id="051b0a6da7e5a99366866472afe4cedd9c4ae587" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">次の&lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt;文法に準拠するすべての文字列は、&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="8c2330d9e11176797f3b69c4b492614aa87568d1" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">次の&lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt;文法に準拠するすべての文字列は、&lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="d19c4500c8b81bcefce226435a932d9bd67dd1d4" translate="yes" xml:space="preserve">
          <source>All supertraits must also be object safe.</source>
          <target state="translated">すべてのスーパーシステムは、オブジェクトの安全性も確保しなければなりません。</target>
        </trans-unit>
        <trans-unit id="3834b26accc0c7926a85719d5492f93bbdde2cd6" translate="yes" xml:space="preserve">
          <source>All the Places Patterns Can Be Used</source>
          <target state="translated">パターンが使える場所はすべて</target>
        </trans-unit>
        <trans-unit id="70ddc33f2c0eb4587fa8e2cac6e8f77be9184d95" translate="yes" xml:space="preserve">
          <source>All the code we&amp;rsquo;ve discussed so far has had Rust&amp;rsquo;s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn&amp;rsquo;t enforce these memory safety guarantees: it&amp;rsquo;s called &lt;em&gt;unsafe Rust&lt;/em&gt; and works just like regular Rust, but gives us extra superpowers.</source>
          <target state="translated">これまでに説明したすべてのコードには、コンパイル時にRustのメモリの安全性が保証されています。ただし、Rustの内部には、これらのメモリの安全性を保証しない第2の言語が隠されています。これは&lt;em&gt;安全でないRust&lt;/em&gt;と呼ばれ、通常のRustと同じように機能しますが、追加の超能力を提供します。</target>
        </trans-unit>
        <trans-unit id="5d094a6ebf518b356f6cc88f0daffccbeaa88d1a" translate="yes" xml:space="preserve">
          <source>All the floating point types, such as &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; などのすべての浮動小数点型。</target>
        </trans-unit>
        <trans-unit id="49768c9761f944e57fd8b28ffb7ccca3ce0255bf" translate="yes" xml:space="preserve">
          <source>All the integer types, such as &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u32&lt;/code&gt; などのすべての整数型。</target>
        </trans-unit>
        <trans-unit id="7aad067d2eb4fd66349ef7460833027940768e31" translate="yes" xml:space="preserve">
          <source>All the traits in &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; except &lt;a href=&quot;fmt/trait.pointer&quot;&gt;&lt;code&gt;Pointer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fmt/trait.pointer&quot;&gt; &lt;code&gt;Pointer&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt;を除く&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;すべての特性</target>
        </trans-unit>
        <trans-unit id="5fbc378a4bea0c74a504553c4655c69b13216d43" translate="yes" xml:space="preserve">
          <source>All tokens have an associated &lt;code&gt;Span&lt;/code&gt;. A &lt;code&gt;Span&lt;/code&gt; is an opaque value that cannot be modified but can be manufactured. &lt;code&gt;Span&lt;/code&gt;s represent an extent of source code within a program and are primarily used for error reporting. You can modify the &lt;code&gt;Span&lt;/code&gt; of any token.</source>
          <target state="translated">すべてのトークンには &lt;code&gt;Span&lt;/code&gt; が関連付けられています。A &lt;code&gt;Span&lt;/code&gt; 変更することができないが、製造することができる不透明な値です。 &lt;code&gt;Span&lt;/code&gt; は、プログラム内のソースコードの範囲を表し、主にエラー報告に使用されます。あなたは修正することができます &lt;code&gt;Span&lt;/code&gt; 任意のトークンスパンをできます。</target>
        </trans-unit>
        <trans-unit id="c4b7c6a0fbafa4ae17e0c283d126acf9c731f848" translate="yes" xml:space="preserve">
          <source>All traits define an implicit type parameter &lt;code&gt;Self&lt;/code&gt; that refers to &quot;the type that is implementing this interface&quot;. Traits may also contain additional type parameters. These type parameters, including &lt;code&gt;Self&lt;/code&gt;, may be constrained by other traits and so forth &lt;a href=&quot;generics&quot;&gt;as usual&lt;/a&gt;.</source>
          <target state="translated">すべての特性は、「このインターフェースを実装している型」を参照する暗黙の型パラメーター &lt;code&gt;Self&lt;/code&gt; を定義します。トレイトには、追加の型パラメーターも含まれる場合があります。 &lt;code&gt;Self&lt;/code&gt; を含むこれらの型パラメーターは、他の特性などによって制約される場合があります。&lt;a href=&quot;generics&quot;&gt;通常どおり&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6af2c7840468532a887d826478745d410145630" translate="yes" xml:space="preserve">
          <source>All type parameters have an implicit bound of &lt;code&gt;Sized&lt;/code&gt;. The special syntax &lt;code&gt;?Sized&lt;/code&gt; can be used to remove this bound if it's not appropriate.</source>
          <target state="translated">すべての型パラメーターには、 &lt;code&gt;Sized&lt;/code&gt; の暗黙の境界があります。特別な構文 &lt;code&gt;?Sized&lt;/code&gt; を使用して、適切でない場合にこの境界を削除できます。</target>
        </trans-unit>
        <trans-unit id="687bde44d55450fc7926f1ddbef8c12777b88228" translate="yes" xml:space="preserve">
          <source>All user-defined composite types (&lt;code&gt;struct&lt;/code&gt;s, &lt;code&gt;enum&lt;/code&gt;s, and &lt;code&gt;union&lt;/code&gt;s) have a &lt;em&gt;representation&lt;/em&gt; that specifies what the layout is for the type. The possible representations for a type are:</source>
          <target state="translated">すべてのユーザー定義の複合型（ &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 、および &lt;code&gt;union&lt;/code&gt; ）には、その型のレイアウトを指定する&lt;em&gt;表現&lt;/em&gt;があります。タイプの可能な表現は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b66aa8bf38f6384faa05e5ba7a817e6473b9a5b6" translate="yes" xml:space="preserve">
          <source>All values have an alignment and size.</source>
          <target state="translated">すべての値には整列とサイズがあります。</target>
        </trans-unit>
        <trans-unit id="6b3bc16295776314b52aa5587d61ce1888ff84c1" translate="yes" xml:space="preserve">
          <source>Alloc</source>
          <target state="translated">Alloc</target>
        </trans-unit>
        <trans-unit id="73c626eee3cffa40774dfe1fcb9f6b9bd69dc64f" translate="yes" xml:space="preserve">
          <source>Alloc::alloc</source>
          <target state="translated">Alloc::alloc</target>
        </trans-unit>
        <trans-unit id="58fa8f803498e5ec9addefde8bfd45a79dbec5ed" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_array</source>
          <target state="translated">Alloc::alloc_array</target>
        </trans-unit>
        <trans-unit id="b50e7d6a8a9d06e47daea96c8b2aea5c45efb165" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_excess</source>
          <target state="translated">Alloc::alloc_excess</target>
        </trans-unit>
        <trans-unit id="889b443e61594610d30213145f921f146db36832" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_one</source>
          <target state="translated">Alloc::alloc_one</target>
        </trans-unit>
        <trans-unit id="a34261c2be453348710c37c58e7b9c83398884d8" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_zeroed</source>
          <target state="translated">Alloc::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="7d3d2688c4fd76b53fe3390539a364662ab17d4b" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc</source>
          <target state="translated">Alloc::dealloc</target>
        </trans-unit>
        <trans-unit id="640d5625de8ef766306d60749a2169115e55e156" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_array</source>
          <target state="translated">Alloc::dealloc_array</target>
        </trans-unit>
        <trans-unit id="7053fc65b9dd32b26e961ddd07f10fe845724b56" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_one</source>
          <target state="translated">Alloc::dealloc_one</target>
        </trans-unit>
        <trans-unit id="c1a3b352f967fd646042d5ec8feb84a7842b4835" translate="yes" xml:space="preserve">
          <source>Alloc::grow_in_place</source>
          <target state="translated">Alloc::grow_in_place</target>
        </trans-unit>
        <trans-unit id="b0c3031aac44345a0cd3601e017910c7886cd822" translate="yes" xml:space="preserve">
          <source>Alloc::realloc</source>
          <target state="translated">Alloc::realloc</target>
        </trans-unit>
        <trans-unit id="50682f5a6557029f4ae580a726dd0a2a8ee83c83" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_array</source>
          <target state="translated">Alloc::realloc_array</target>
        </trans-unit>
        <trans-unit id="71b9b4276801f0c0a766cb281400a5a34452c7e1" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_excess</source>
          <target state="translated">Alloc::realloc_excess</target>
        </trans-unit>
        <trans-unit id="caed8ad7c332dd652a64a2f5a64ee5adce448144" translate="yes" xml:space="preserve">
          <source>Alloc::shrink_in_place</source>
          <target state="translated">Alloc::shrink_in_place</target>
        </trans-unit>
        <trans-unit id="4bdde8e404d1e339cdf8e89ef42138d76fb64cb5" translate="yes" xml:space="preserve">
          <source>Alloc::usable_size</source>
          <target state="translated">Alloc::usable_size</target>
        </trans-unit>
        <trans-unit id="74f9a2a318fbafb57c2a318b7f97cd7f558235f5" translate="yes" xml:space="preserve">
          <source>AllocErr</source>
          <target state="translated">AllocErr</target>
        </trans-unit>
        <trans-unit id="81a1e8e44229166f6c5d59b8b5cdfbd7de11a910" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow</source>
          <target state="translated">AllocErr::borrow</target>
        </trans-unit>
        <trans-unit id="cab0d29cfc07f03d441e5891d8fdae354b136ec1" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow_mut</source>
          <target state="translated">AllocErr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c63e5f5e71fd2207c8a6514237ae70d9dca95cf3" translate="yes" xml:space="preserve">
          <source>AllocErr::cause</source>
          <target state="translated">AllocErr::cause</target>
        </trans-unit>
        <trans-unit id="09ff0aa0e6ca318ce203b20e17f08354650229f1" translate="yes" xml:space="preserve">
          <source>AllocErr::clone</source>
          <target state="translated">AllocErr::clone</target>
        </trans-unit>
        <trans-unit id="777d6911608c872b31c4bdb18d3b776c08a9b8f5" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_from</source>
          <target state="translated">AllocErr::clone_from</target>
        </trans-unit>
        <trans-unit id="b678a089fb922c246660ee4daaf38a5251355da7" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_into</source>
          <target state="translated">AllocErr::clone_into</target>
        </trans-unit>
        <trans-unit id="5df229543f81998e9da115264fa06013a927adb1" translate="yes" xml:space="preserve">
          <source>AllocErr::description</source>
          <target state="translated">AllocErr::description</target>
        </trans-unit>
        <trans-unit id="d2cf0a94fd5cf29c79c5284616875b84972fb312" translate="yes" xml:space="preserve">
          <source>AllocErr::eq</source>
          <target state="translated">AllocErr::eq</target>
        </trans-unit>
        <trans-unit id="5881f4abcdbf06d5924b4a78a521cc0027e69523" translate="yes" xml:space="preserve">
          <source>AllocErr::fmt</source>
          <target state="translated">AllocErr::fmt</target>
        </trans-unit>
        <trans-unit id="270a3da0beb21d444fb57d0c363b8a08cfe0f022" translate="yes" xml:space="preserve">
          <source>AllocErr::from</source>
          <target state="translated">AllocErr::from</target>
        </trans-unit>
        <trans-unit id="98b28dbbeacbc8b3f7530e8cbb0f5369608cd809" translate="yes" xml:space="preserve">
          <source>AllocErr::into</source>
          <target state="translated">AllocErr::into</target>
        </trans-unit>
        <trans-unit id="039711c278e014b513a0be997690fca2416f8474" translate="yes" xml:space="preserve">
          <source>AllocErr::ne</source>
          <target state="translated">AllocErr::ne</target>
        </trans-unit>
        <trans-unit id="ffa94c7186e9f5d1d7bf9c63828fb87e4a775ad5" translate="yes" xml:space="preserve">
          <source>AllocErr::source</source>
          <target state="translated">AllocErr::source</target>
        </trans-unit>
        <trans-unit id="0aeb755570b957275d6d9d5317212dc6a6535090" translate="yes" xml:space="preserve">
          <source>AllocErr::to_owned</source>
          <target state="translated">AllocErr::to_owned</target>
        </trans-unit>
        <trans-unit id="0e17e4e80e3c6af6ed45e6c032cf33d55d346e46" translate="yes" xml:space="preserve">
          <source>AllocErr::to_string</source>
          <target state="translated">AllocErr::to_string</target>
        </trans-unit>
        <trans-unit id="3e40fc0676c76a71ca131dafb97f38662652bfbf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_from</source>
          <target state="translated">AllocErr::try_from</target>
        </trans-unit>
        <trans-unit id="34d1124cc06e84256717b819e1f63b955e0350bf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_into</source>
          <target state="translated">AllocErr::try_into</target>
        </trans-unit>
        <trans-unit id="663b204a54c41c16c072ee135d91fa4be49de349" translate="yes" xml:space="preserve">
          <source>AllocErr::type_id</source>
          <target state="translated">AllocErr::type_id</target>
        </trans-unit>
        <trans-unit id="4893c8174f6c1eabc41e7843e70d7ebcff1b1f84" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;layout&lt;/code&gt; 説明に従ってメモリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="cd02c9bc4eedba216d90a16d722506e0ce680a8a" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;. &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">指定された &lt;code&gt;layout&lt;/code&gt; 説明に従ってメモリを割り当てます。&lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74c59d8374e4ee1d975ce714a71b5fcdbb7aacac" translate="yes" xml:space="preserve">
          <source>Allocate memory with the global allocator.</source>
          <target state="translated">グローバルアロケータでメモリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="cfb8411e19f0f79e91b6b66f6609da2b9991a1e5" translate="yes" xml:space="preserve">
          <source>Allocate zero-initialized memory with the global allocator.</source>
          <target state="translated">グローバルアロケータを使用して、ゼロ初期化されたメモリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="1bfdf7915bd5c3db982b39e0a3309425f8ee260d" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; の &lt;code&gt;n&lt;/code&gt; 個のインスタンスを保持するのに適したブロックを割り当てます。</target>
        </trans-unit>
        <trans-unit id="c63c156459af2e92bb9b73d7f0f9844433b5dc2f" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; の &lt;code&gt;n&lt;/code&gt; 個のインスタンスを保持するのに適したブロックを割り当てます。&lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed375cd7b209e0c5769df096531bae03a872bbbb" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のインスタンスを保持するのに適したブロックを割り当てます。</target>
        </trans-unit>
        <trans-unit id="02c72ac7d36294390fedc764c2754fe1636d64b1" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のインスタンスを保持するのに適したブロックを割り当てます。&lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76e23de7e691468d4d99aac266130e3bc34f2ea4" translate="yes" xml:space="preserve">
          <source>Allocates an empty &lt;code&gt;PathBuf&lt;/code&gt;.</source>
          <target state="translated">空の &lt;code&gt;PathBuf&lt;/code&gt; を割り当てますます。</target>
        </trans-unit>
        <trans-unit id="f9ce219d6c4b42c1f87ab6030532c065b1fec11f" translate="yes" xml:space="preserve">
          <source>Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.</source>
          <target state="translated">ヒープにメモリを割り当ててから、 &lt;code&gt;x&lt;/code&gt; を配置しますをします。</target>
        </trans-unit>
        <trans-unit id="e910169c58168ed4f75b19228b519cfb61699e61" translate="yes" xml:space="preserve">
          <source>Allow generic type parameter to be a dynamically sized type</source>
          <target state="translated">汎用型パラメータが動的なサイズの型であることを許可する</target>
        </trans-unit>
        <trans-unit id="40680c6330eab7e25541ffbe63efc1d14385635b" translate="yes" xml:space="preserve">
          <source>Allow users to add text content only when a post is in the &lt;code&gt;Draft&lt;/code&gt; state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">投稿が &lt;code&gt;Draft&lt;/code&gt; 状態の場合にのみ、ユーザーがテキストコンテンツを追加できるようにします。ヒント：変更を担当したコンテンツではなくについて変更される可能性があります何のために責任を負う状態オブジェクト持っている &lt;code&gt;Post&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cb50b4ef5745cf62353aeff34203276011ef50f" translate="yes" xml:space="preserve">
          <source>Allowing Access from Multiple Threads with &lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt; 複数のスレッドからのアクセスを許可する</target>
        </trans-unit>
        <trans-unit id="fae2d8f4c50be8a20cdea347ace493568595fcd3" translate="yes" xml:space="preserve">
          <source>Allowing Multiple Guesses with Looping</source>
          <target state="translated">ループを使った複数の推測を可能にする</target>
        </trans-unit>
        <trans-unit id="7db289670d5f2b576ba5fbc25cdc4ef16295c536" translate="yes" xml:space="preserve">
          <source>Allowing Transference of Ownership Between Threads with &lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt;</source>
          <target state="translated">スレッド間の所有権の譲渡を許可する &lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb09e5f22f3b7d16947a2ecaccff480c6609f901" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="translated">ほとんどの場合、&lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;代わりに &lt;code&gt;Vec&lt;/code&gt; またはVecDequeを使用することをお&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;ます。一般に、アレイベースのコンテナはより高速で、メモリ効率が高く、CPUキャッシュをより有効に利用します。</target>
        </trans-unit>
        <trans-unit id="96a3f97ad5d3ab3ce2ee9333276a6a44f6055cf9" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;code&gt;VecDeque&lt;/code&gt; instead of &lt;code&gt;LinkedList&lt;/code&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;VecDeque&lt;/code&gt; 代わりに &lt;code&gt;Vec&lt;/code&gt; またはVecDequeを使用することをお &lt;code&gt;LinkedList&lt;/code&gt; ます。一般に、アレイベースのコンテナはより高速で、メモリ効率が高く、CPUキャッシュをより有効に利用します。</target>
        </trans-unit>
        <trans-unit id="30066ada2ed0aa1faf9262f27c4ed17333b52206" translate="yes" xml:space="preserve">
          <source>Along the way, we&amp;rsquo;ll show how to make our command line tool use features of the terminal that many command line tools use. We&amp;rsquo;ll read the value of an environment variable to allow the user to configure the behavior of our tool. We&amp;rsquo;ll also print error messages to the standard error console stream (&lt;code&gt;stderr&lt;/code&gt;) instead of standard output (&lt;code&gt;stdout&lt;/code&gt;), so, for example, the user can redirect successful output to a file while still seeing error messages onscreen.</source>
          <target state="translated">途中で、多くのコマンドラインツールが使用するターミナルの機能をコマンドラインツールで使用する方法を示します。環境変数の値を読み取り、ユーザーがツールの動作を構成できるようにします。エラーメッセージは、標準出力（ &lt;code&gt;stdout&lt;/code&gt; ）ではなく、標準エラーコンソールストリーム（ &lt;code&gt;stderr&lt;/code&gt; ）にも出力します。）ため、たとえば、ユーザーは画面にエラーメッセージを表示したまま、正常な出力をファイルにリダイレクトできます。</target>
        </trans-unit>
        <trans-unit id="2cbf8cd5d5a46820a0f6ab73279f92ce571b3bc8" translate="yes" xml:space="preserve">
          <source>Along with being made public via &lt;code&gt;pub&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; can also have an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; added for use in FFI.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; は、 &lt;code&gt;pub&lt;/code&gt; を介して公開されるだけでなく、FFIで使用するために&lt;a href=&quot;keyword.extern&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt;追加することもできます。</target>
        </trans-unit>
        <trans-unit id="569f87a8387e1554badafba00588c85d0f8bf792" translate="yes" xml:space="preserve">
          <source>Along with the newtype pattern, Rust provides the ability to declare a &lt;em&gt;type alias&lt;/em&gt; to give an existing type another name. For this we use the &lt;code&gt;type&lt;/code&gt; keyword. For example, we can create the alias &lt;code&gt;Kilometers&lt;/code&gt; to &lt;code&gt;i32&lt;/code&gt; like so:</source>
          <target state="translated">Rustには、newtypeパターンに加えて、&lt;em&gt;型エイリアス&lt;/em&gt;を宣言して既存の型に別の名前を付ける機能があります。これには、 &lt;code&gt;type&lt;/code&gt; キーワードを使用します。たとえば、次のように &lt;code&gt;i32&lt;/code&gt; に &lt;code&gt;Kilometers&lt;/code&gt; というエイリアスを作成できます。</target>
        </trans-unit>
        <trans-unit id="6444cb062f09d53622baea0cd17deb96b9dc9f75" translate="yes" xml:space="preserve">
          <source>Also discussed were the &lt;code&gt;Deref&lt;/code&gt; and &lt;code&gt;Drop&lt;/code&gt; traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">また、スマートポインターの多くの機能を可能にする &lt;code&gt;Deref&lt;/code&gt; と &lt;code&gt;Drop&lt;/code&gt; トレイトについても説明しました。メモリリークを引き起こす可能性がある参照サイクルと、 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; を使用してそれらを防ぐ方法を探りました。</target>
        </trans-unit>
        <trans-unit id="d6fc1b2f8caf81c693f670285ed3e30e58c8f202" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Iterator&lt;/code&gt; provides a default implementation of methods such as &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; which call &lt;code&gt;next&lt;/code&gt; internally. However, it is also possible to write a custom implementation of methods like &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; if an iterator can compute them more efficiently without calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;Iterator&lt;/code&gt; は &lt;code&gt;nth&lt;/code&gt; や &lt;code&gt;fold&lt;/code&gt; など、 &lt;code&gt;next&lt;/code&gt; 内部的に呼び出すメソッドのデフォルト実装を提供することにも注意してください。ただし、イテレータが &lt;code&gt;next&lt;/code&gt; を呼び出さなくてもより効率的に計算できる場合は、 &lt;code&gt;nth&lt;/code&gt; や &lt;code&gt;fold&lt;/code&gt; などのメソッドのカスタム実装を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="2a7fb665b167f214e0e11085759c66fc45c5b538" translate="yes" xml:space="preserve">
          <source>Also note that Cargo build scripts can learn about this feature through &lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;environment variables&lt;/a&gt;. In a build script you can detect the linkage via:</source>
          <target state="translated">Cargoビルドスクリプトは、&lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;環境変数&lt;/a&gt;を通じてこの機能について学習できることにも注意してください。ビルドスクリプトでは、次の方法でリンケージを検出できます。</target>
        </trans-unit>
        <trans-unit id="729f1c9440272260f81d5cd373556bbc830572f8" translate="yes" xml:space="preserve">
          <source>Also note that the values we get from the calls to &lt;code&gt;next&lt;/code&gt; are immutable references to the values in the vector. The &lt;code&gt;iter&lt;/code&gt; method produces an iterator over immutable references. If we want to create an iterator that takes ownership of &lt;code&gt;v1&lt;/code&gt; and returns owned values, we can call &lt;code&gt;into_iter&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;. Similarly, if we want to iterate over mutable references, we can call &lt;code&gt;iter_mut&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;next&lt;/code&gt; の呼び出しから取得する値は、ベクター内の値への不変の参照であることにも注意してください。 &lt;code&gt;iter&lt;/code&gt; 方法は不変の参照反復子を生成します。 &lt;code&gt;v1&lt;/code&gt; の所有権を取得して所有値を返すイテレーターを作成する場合は、 &lt;code&gt;iter&lt;/code&gt; の代わりに &lt;code&gt;into_iter&lt;/code&gt; を呼び出すことができます。同様に、可変参照を反復処理したい場合は、 &lt;code&gt;iter&lt;/code&gt; の代わりに &lt;code&gt;iter_mut&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="ce251a63845ba69b5ad2fd9f201455284f4f01ee" translate="yes" xml:space="preserve">
          <source>Also note that we switched the type of the &lt;code&gt;t&lt;/code&gt; parameter from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;&amp;amp;T&lt;/code&gt;. Because the type might not be &lt;code&gt;Sized&lt;/code&gt;, we need to use it behind some kind of pointer. In this case, we&amp;rsquo;ve chosen a reference.</source>
          <target state="translated">また、 &lt;code&gt;t&lt;/code&gt; パラメータのタイプを &lt;code&gt;T&lt;/code&gt; から &lt;code&gt;&amp;amp;T&lt;/code&gt; に切り替えたことにも注意してください。タイプが &lt;code&gt;Sized&lt;/code&gt; ない可能性があるためである種のポインターの背後で使用する必要があります。この例では、参照を選択しました。</target>
        </trans-unit>
        <trans-unit id="19148a1d1c1b97af52ac182d255aa33cc3c9304e" translate="yes" xml:space="preserve">
          <source>Also of note is the special syntax for &lt;code&gt;Fn&lt;/code&gt; traits (e.g. &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt;). Those interested in the technical details of this can refer to &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;the relevant section in the &lt;em&gt;Rustonomicon&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">また、 &lt;code&gt;Fn&lt;/code&gt; トレイトの特別な構文（ &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt; ）にも注意してください。これの技術的な詳細に興味がある人&lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;は、&lt;em&gt;ラストノミコンの&lt;/em&gt;&lt;/a&gt;関連セクションを参照できます。</target>
        </trans-unit>
        <trans-unit id="9d4cb652a8b78bec628c1d26d0df6d4c9f7c28ed" translate="yes" xml:space="preserve">
          <source>Also, if the type of the expression to the left of the dot is a pointer, it is automatically dereferenced as many times as necessary to make the field access possible. In cases of ambiguity, we prefer fewer autoderefs to more.</source>
          <target state="translated">また、ドットの左にある式の型がポインタの場合は、フィールドアクセスを可能にするために必要な回数だけ自動的に派生されます。曖昧な場合には、自動参照は多めよりも少なめの方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="56542ee08fdcb89c559a45ec666da5ba100aa6fa" translate="yes" xml:space="preserve">
          <source>Also, it allocates temporary storage half the size of &lt;code&gt;self&lt;/code&gt;, but for short slices a non-allocating insertion sort is used instead.</source>
          <target state="translated">また、それは &lt;code&gt;self&lt;/code&gt; の半分のサイズの一時ストレージを割り当てますが、短いスライスの場合は、代わりに非割り当て挿入ソートが使用されます。</target>
        </trans-unit>
        <trans-unit id="71671f4bb484f8a1e973c0578cc13715a3aa2105" translate="yes" xml:space="preserve">
          <source>Also, note that because &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; has a private field, the struct needs to provide a public associated function that constructs an instance of &lt;code&gt;Breakfast&lt;/code&gt; (we&amp;rsquo;ve named it &lt;code&gt;summer&lt;/code&gt; here). If &lt;code&gt;Breakfast&lt;/code&gt; didn&amp;rsquo;t have such a function, we couldn&amp;rsquo;t create an instance of &lt;code&gt;Breakfast&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because we couldn&amp;rsquo;t set the value of the private &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; にはプライベートフィールドがあるため、構造体は &lt;code&gt;Breakfast&lt;/code&gt; インスタンスを構築するパブリック関連関数を提供する必要があることに注意してください（ここでは &lt;code&gt;summer&lt;/code&gt; と名付けています）。場合 &lt;code&gt;Breakfast&lt;/code&gt; 、このような機能を持っていなかった、我々はのインスタンス作成できませんでした &lt;code&gt;Breakfast&lt;/code&gt; で &lt;code&gt;eat_at_restaurant&lt;/code&gt; 我々は民間の値が設定されていない可能性があるため、 &lt;code&gt;seasonal_fruit&lt;/code&gt; のフィールドを &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="477dbb63bb02aa6d30fe03da09f8465ff169a963" translate="yes" xml:space="preserve">
          <source>Also, note that the function body is wrapped in curly brackets, &lt;code&gt;{}&lt;/code&gt;. Rust requires these around all function bodies. It&amp;rsquo;s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between.</source>
          <target state="translated">また、関数本体は中括弧 &lt;code&gt;{}&lt;/code&gt; で囲まれていることに注意してください。。Rustはすべての関数本体の周りにこれらを必要とします。開始中かっこを関数宣言と同じ行に配置し、その間にスペースを1つ追加するのが適切なスタイルです。</target>
        </trans-unit>
        <trans-unit id="8c50010a52d6913ce8428bd39d3014c723f0db3d" translate="yes" xml:space="preserve">
          <source>Also, please be aware that this method is only for special circumstances and is usually not what you want. In case of doubt, use &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">また、この方法は特別な状況でのみ使用するものであり、通常は望ましい方法ではないことに注意してください。疑問がある場合は、代わりに&lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="2edbd5a08a0137666e61eca4932691fdf6681fd9" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;bool&lt;/code&gt; implements the &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait, we don't have to worry about the move semantics (just like the integer and float primitives).</source>
          <target state="translated">また、 &lt;code&gt;bool&lt;/code&gt; は&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;トレイトを実装しているので、（整数プリミティブやフロートプリミティブのように）移動セマンティクスについて心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="a9b0dcda2ee36870b49794f990ce3f2eb9803892" translate="yes" xml:space="preserve">
          <source>Alternatively there can be exactly two expressions inside the brackets, separated by a semi-colon. The expression after the &lt;code&gt;;&lt;/code&gt; must be a have type &lt;code&gt;usize&lt;/code&gt; and be a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, such as a &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; or a &lt;a href=&quot;../items/constant-items&quot;&gt;constant item&lt;/a&gt;. &lt;code&gt;[a; b]&lt;/code&gt; creates an array containing &lt;code&gt;b&lt;/code&gt; copies of the value of &lt;code&gt;a&lt;/code&gt;. If the expression after the semi-colon has a value greater than 1 then this requires that the type of &lt;code&gt;a&lt;/code&gt; is &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">または、セミコロンで区切られた括弧内に正確に2つの式がある場合もあります。の後の式 &lt;code&gt;;&lt;/code&gt; 型が &lt;code&gt;usize&lt;/code&gt; で、&lt;a href=&quot;../tokens#literals&quot;&gt;リテラル&lt;/a&gt;や&lt;a href=&quot;../items/constant-items&quot;&gt;定数項目&lt;/a&gt;などの&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;定数式&lt;/a&gt;である必要があります。 &lt;code&gt;[a; b]&lt;/code&gt; B]を含有する配列を作成し &lt;code&gt;b&lt;/code&gt; の値のコピー。セミコロンの後の式の値が1より大きい場合、 &lt;code&gt;a&lt;/code&gt; のタイプは&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;である必要があります。 &lt;code&gt;a&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="3c2b342df42a5ce80106fad6cca3ec251f8df3e4" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; has alignment 1 for all &lt;code&gt;T&lt;/code&gt;, so you can use it if you need to keep the field for some reason:</source>
          <target state="translated">または、 &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; はすべての &lt;code&gt;T&lt;/code&gt; に対して配置1を持っているため、何らかの理由でフィールドを保持する必要がある場合は、それを使用できます。</target>
        </trans-unit>
        <trans-unit id="38449305205a0baadf0d931713ad745060ac7795" translate="yes" xml:space="preserve">
          <source>Alternatively, a paren-less version of the attribute may be used to hint the compiler about inlining opportunity:</source>
          <target state="translated">あるいは、インライン化の機会についてコンパイラにヒントを与えるために、属性の親を持たないバージョンを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="d329c92752ab59bc5a187b9f641894d29c9fd208" translate="yes" xml:space="preserve">
          <source>Alternatively, define a trait locally and implement that instead:</source>
          <target state="translated">あるいは、ローカルに形質を定義し、それを代わりに実装することもできます。</target>
        </trans-unit>
        <trans-unit id="30596c4d15742cc562b249b398f8c80c1a13a17f" translate="yes" xml:space="preserve">
          <source>Alternatively, if the type parameter was intentionally inserted, it must be used. A simple fix is shown below:</source>
          <target state="translated">あるいは、typeパラメータが意図的に挿入されている場合は、それを使用しなければなりません。簡単な修正方法を以下に示します。</target>
        </trans-unit>
        <trans-unit id="7c8d494311629dbdec7e4dda72d552e11aace0ec" translate="yes" xml:space="preserve">
          <source>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt;:</source>
          <target state="translated">あるいは、構造体の定義を制御しない場合、または変更可能な共有所有権が本当に必要な場合は、 &lt;code&gt;Rc&lt;/code&gt; および &lt;code&gt;RefCell&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="0a59d2fc84eff79b213967bc64daab09652e8ccb" translate="yes" xml:space="preserve">
          <source>Alternatively, if your type implements &lt;code&gt;Clone&lt;/code&gt; and you need to own the value, consider borrowing and then cloning:</source>
          <target state="translated">あるいは、タイプが &lt;code&gt;Clone&lt;/code&gt; を実装していて、その値を所有する必要がある場合は、借用してから複製することを検討してください。</target>
        </trans-unit>
        <trans-unit id="ed9c6950d0598f33adea6619e4f5e3230fd020da" translate="yes" xml:space="preserve">
          <source>Alternatively, move the other attributes to the contained type:</source>
          <target state="translated">あるいは、他の属性を含まれる型に移動させます。</target>
        </trans-unit>
        <trans-unit id="b5cf6202d850db2d8b7a0068cf052fbe7d132528" translate="yes" xml:space="preserve">
          <source>Alternatively, split the pattern:</source>
          <target state="translated">または、パターンを分割します。</target>
        </trans-unit>
        <trans-unit id="9b111c2948f7df0faec47eb57a97f3c7f99e8980" translate="yes" xml:space="preserve">
          <source>Alternatively, we can consider using the &lt;code&gt;Cell&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt; types to achieve interior mutability through a shared reference. Our example's &lt;code&gt;mutable&lt;/code&gt; function could be redefined as below:</source>
          <target state="translated">あるいは、 &lt;code&gt;Cell&lt;/code&gt; および &lt;code&gt;RefCell&lt;/code&gt; タイプを使用して、共有参照を通じて内部の可変性を実現することを検討できます。この例の &lt;code&gt;mutable&lt;/code&gt; 関数は、次のように再定義できます。</target>
        </trans-unit>
        <trans-unit id="754e721e3e9779de9d32c607142b98694b9bb365" translate="yes" xml:space="preserve">
          <source>Alternatively, we can move out of &lt;code&gt;fancy_num&lt;/code&gt; into a second &lt;code&gt;fancy_num&lt;/code&gt;:</source>
          <target state="translated">あるいは、 &lt;code&gt;fancy_num&lt;/code&gt; から2番目の &lt;code&gt;fancy_num&lt;/code&gt; に移動することもできます。</target>
        </trans-unit>
        <trans-unit id="da767a10b83371c7ea419ae14469880fbc9efc2b" translate="yes" xml:space="preserve">
          <source>Alternatively, wrapping trait objects requires something like the following:</source>
          <target state="translated">あるいは、 trait オブジェクトをラップするには、以下のようなものが必要です。</target>
        </trans-unit>
        <trans-unit id="980127d7c92391c13b6615bd3076240a03531f1c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can add the following line to your &lt;em&gt;~/.bash_profile&lt;/em&gt;:</source>
          <target state="translated">または、次の行を&lt;em&gt;〜/ .bash_profileに&lt;/em&gt;追加できます。</target>
        </trans-unit>
        <trans-unit id="53009511a1501672faf73d204dc3eb7eb0e15f4c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct. For example, &lt;code&gt;NewType&lt;/code&gt; is a newtype over &lt;code&gt;Foo&lt;/code&gt; in &lt;code&gt;struct NewType(Foo)&lt;/code&gt;. Example:</source>
          <target state="translated">または、新しいタイプを作成することもできます。 newtypeはラッピングタプル構造体です。例えば、 &lt;code&gt;NewType&lt;/code&gt; 上のnewtypeある &lt;code&gt;Foo&lt;/code&gt; における &lt;code&gt;struct NewType(Foo)&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="f44934b9e6665fc0ff65386cfc3a7e7022fcb44e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can obtain a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice from a &lt;code&gt;CString&lt;/code&gt; with the &lt;a href=&quot;#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt; method. Slices produced in this way do &lt;em&gt;not&lt;/em&gt; contain the trailing nul terminator. This is useful when you will be calling an extern function that takes a &lt;code&gt;*const u8&lt;/code&gt; argument which is not necessarily nul-terminated, plus another argument with the length of the string &amp;mdash; like C's &lt;code&gt;strndup()&lt;/code&gt;. You can of course get the slice's length with its &lt;a href=&quot;../primitive.slice#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">または、&lt;a href=&quot;#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt;メソッドを使用して、 &lt;code&gt;CString&lt;/code&gt; から &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; スライスを取得することもできます。この方法で作成されたスライスには、末尾のヌルターミネーター&lt;em&gt;は&lt;/em&gt;含まれませ&lt;em&gt;ん&lt;/em&gt;。これは、必ずしもヌル文字で終了しているわけではない &lt;code&gt;*const u8&lt;/code&gt; 引数と、Cの &lt;code&gt;strndup()&lt;/code&gt; などの文字列の長さを持つ別の引数を取るextern関数を呼び出す場合に便利です。もちろん、&lt;a href=&quot;../primitive.slice#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;メソッドを使用してスライスの長さを取得できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="fb4db1dca17b4c832ac69c83b18f73ad9aa68bf9" translate="yes" xml:space="preserve">
          <source>Although Rust will let you bind &lt;code&gt;Sized&lt;/code&gt; to a trait, you won't be able to use it to form a trait object later:</source>
          <target state="translated">Rust では &lt;code&gt;Sized&lt;/code&gt; をトレイトにバインドできますが、後でそれを使用してトレイトオブジェクトを形成することはできません。</target>
        </trans-unit>
        <trans-unit id="18938413590ec4f421c089a648f9b8a820edd657" translate="yes" xml:space="preserve">
          <source>Although UDP is a connectionless protocol, this implementation provides an interface to set an address where data should be sent and received from. After setting a remote address with &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;, data can be sent to and received from that address with &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">UDPはコネクションレス型プロトコルですが、この実装は、データを送受信するアドレスを設定するためのインターフェースを提供します。&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;を使用してリモートアドレスを設定した後、&lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;を使用してそのアドレスとの間でデータを送受信できます。</target>
        </trans-unit>
        <trans-unit id="6138cf1c64fdfba340547fa72a908d945fa65b3f" translate="yes" xml:space="preserve">
          <source>Although a &lt;code&gt;SystemTime&lt;/code&gt; cannot be directly inspected, the &lt;a href=&quot;constant.unix_epoch&quot;&gt;&lt;code&gt;UNIX_EPOCH&lt;/code&gt;&lt;/a&gt; constant is provided in this module as an anchor in time to learn information about a &lt;code&gt;SystemTime&lt;/code&gt;. By calculating the duration from this fixed point in time, a &lt;code&gt;SystemTime&lt;/code&gt; can be converted to a human-readable time, or perhaps some other string representation.</source>
          <target state="translated">が &lt;code&gt;SystemTime&lt;/code&gt; 直接検査することができない、&lt;a href=&quot;constant.unix_epoch&quot;&gt; &lt;code&gt;UNIX_EPOCH&lt;/code&gt; の&lt;/a&gt;定数はに関する情報を学ぶために時間内にアンカーとして、このモジュールで提供されて &lt;code&gt;SystemTime&lt;/code&gt; 。この固定された時点から期間を計算することにより、 &lt;code&gt;SystemTime&lt;/code&gt; は人間が読み取れる時間、またはおそらく他の文字列表現に変換できます。</target>
        </trans-unit>
        <trans-unit id="9bf2565395a043df30a2266cce3b26bdd4f8ff03" translate="yes" xml:space="preserve">
          <source>Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is the idiomatic way to bring a function into scope with &lt;code&gt;use&lt;/code&gt;. Bringing the function&amp;rsquo;s parent module into scope with &lt;code&gt;use&lt;/code&gt; so we have to specify the parent module when calling the function makes it clear that the function isn&amp;rsquo;t locally defined while still minimizing repetition of the full path. The code in Listing 7-13 is unclear as to where &lt;code&gt;add_to_waitlist&lt;/code&gt; is defined.</source>
          <target state="translated">リスト7-11と7-13はどちらも同じタスクを実行しますが、リスト7-11は、 &lt;code&gt;use&lt;/code&gt; を使用して関数をスコープに入れる慣用的な方法です。範囲の中に、関数の親モジュールを持ち込み &lt;code&gt;use&lt;/code&gt; 機能を呼び出すと、それはまだ完全なパスの繰り返しを最小限に抑えながら機能はローカルに定義されていないことを明確にするとき、我々は親モジュールを指定する必要がありますので。コードリスト7-13のコードは、 &lt;code&gt;add_to_waitlist&lt;/code&gt; が定義されている場所が不明確です。</target>
        </trans-unit>
        <trans-unit id="af1566b2870173a676122bd4c9750a25b9287966" translate="yes" xml:space="preserve">
          <source>Although functional programming languages use cons lists frequently, the cons list isn&amp;rsquo;t a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is a better choice to use. Other, more complex recursive data types &lt;em&gt;are&lt;/em&gt; useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.</source>
          <target state="translated">関数型プログラミング言語はconsリストを頻繁に使用しますが、consリストはRustで一般的に使用されるデータ構造ではありません。ほとんどの場合、Rustにアイテムのリストがある場合、 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; を使用することをお勧めします。その他、より複雑な再帰データ型&lt;em&gt;は&lt;/em&gt;さまざまな状況で役立ちます&lt;em&gt;が&lt;/em&gt;、コンスリストから始めると、ボックスを使用して、それほど気を散らすことなく再帰データ型を定義できます。</target>
        </trans-unit>
        <trans-unit id="d04af4e6b5ccd4c4682747098fc1db0b02dbd661" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;::&lt;/code&gt; token is allowed before the generics arguments, it is not required because there is no ambiguity like there is in &lt;em&gt;PathInExpression&lt;/em&gt;.</source>
          <target state="translated">が &lt;code&gt;::&lt;/code&gt; トークンがジェネリック医薬品の引数の前に許可されているではありのようなあいまいがないため、これは必須ではありません&lt;em&gt;PathInExpression&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7bf75499d3d552ee0a87d1fa70ed0a0e35bd067e" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;let&lt;/code&gt; is pointless here, it illustrates the meaning of &lt;code&gt;!&lt;/code&gt;. Since &lt;code&gt;x&lt;/code&gt; is never assigned a value (because &lt;code&gt;return&lt;/code&gt; returns from the entire function), &lt;code&gt;x&lt;/code&gt; can be given type &lt;code&gt;!&lt;/code&gt;. We could also replace &lt;code&gt;return 123&lt;/code&gt; with a &lt;code&gt;panic!&lt;/code&gt; or a never-ending &lt;code&gt;loop&lt;/code&gt; and this code would still be valid.</source>
          <target state="translated">ここでは &lt;code&gt;let&lt;/code&gt; は無意味ですが、 &lt;code&gt;!&lt;/code&gt; の意味を示しています。。以来 &lt;code&gt;x&lt;/code&gt; が値を割り当てられることはありません（ので、 &lt;code&gt;return&lt;/code&gt; 関数全体からのリターン）は、 &lt;code&gt;x&lt;/code&gt; がタイプを与えることができます &lt;code&gt;!&lt;/code&gt; 。 &lt;code&gt;return 123&lt;/code&gt; を &lt;code&gt;panic!&lt;/code&gt; 置き換えることもできます！または終了しない &lt;code&gt;loop&lt;/code&gt; とこのコードはまだ有効です。</target>
        </trans-unit>
        <trans-unit id="6e8ecdea30a2a1885eeb369d7e2426712a189f17" translate="yes" xml:space="preserve">
          <source>Although the SipHash algorithm is considered to be generally strong, it is not intended for cryptographic purposes. As such, all cryptographic uses of this implementation are &lt;em&gt;strongly discouraged&lt;/em&gt;.</source>
          <target state="translated">SipHashアルゴリズムは一般的に強力であると考えられていますが、暗号化を目的としたものではありません。そのため、この実装の暗号化の使用はすべて&lt;em&gt;お勧めできません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f07ca613351cf8dcbbc0ccd12d8ef0d4721b46b7" translate="yes" xml:space="preserve">
          <source>Although the number of keys and values is growable, each key can only have one value associated with it at a time. When you want to change the data in a hash map, you have to decide how to handle the case when a key already has a value assigned. You could replace the old value with the new value, completely disregarding the old value. You could keep the old value and ignore the new value, only adding the new value if the key &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; already have a value. Or you could combine the old value and the new value. Let&amp;rsquo;s look at how to do each of these!</source>
          <target state="translated">キーと値の数は増やすことができますが、各キーには一度に1つの値しか関連付けることができません。ハッシュマップのデータを変更する場合は、キーに既に値が割り当てられている場合の処理​​方法を決定する必要があります。古い値を完全に無視して、古い値を新しい値に置き換えることができます。古い値を保持して新しい値を無視し、キーにまだ値&lt;em&gt;がない&lt;/em&gt;場合にのみ新しい値を追加することができます。または、古い値と新しい値を組み合わせることができます。これらのそれぞれを行う方法を見てみましょう！</target>
        </trans-unit>
        <trans-unit id="d281e954555c8484110a6fecba9e6260dd297fe7" translate="yes" xml:space="preserve">
          <source>Although this code has the same behavior as Listing 9-5, it doesn&amp;rsquo;t contain any &lt;code&gt;match&lt;/code&gt; expressions and is cleaner to read. Come back to this example after you&amp;rsquo;ve read Chapter 13, and look up the &lt;code&gt;unwrap_or_else&lt;/code&gt; method in the standard library documentation. Many more of these methods can clean up huge nested &lt;code&gt;match&lt;/code&gt; expressions when you&amp;rsquo;re dealing with errors.</source>
          <target state="translated">このコードの動作はリスト9-5と同じですが、 &lt;code&gt;match&lt;/code&gt; 式が含まれておらず、読みやすくなっています。第13章を読んだ後、この例に戻って、標準ライブラリのドキュメントで &lt;code&gt;unwrap_or_else&lt;/code&gt; メソッドを調べてください。これらのメソッドの多くは、エラーを処理するときに、ネストされた巨大な &lt;code&gt;match&lt;/code&gt; 式をクリーンアップできます。</target>
        </trans-unit>
        <trans-unit id="db0fe462f2aa334b05d61f387c6225bd0bc5a2b6" translate="yes" xml:space="preserve">
          <source>Although this code works, duplicating code is tedious and error prone. We also have to update the code in multiple places when we want to change it.</source>
          <target state="translated">このコードはうまくいくのですが、コードを複製するのは面倒ですし、エラーになりやすいです。また、コードを変更したいときには複数の場所で更新しなければなりません。</target>
        </trans-unit>
        <trans-unit id="094096c8e8871948579e001659d96f6f0cd91ded" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; instead and new &lt;code&gt;impl&lt;/code&gt;s can omit it.</source>
          <target state="translated">これを使用してもコンパイル警告は発生しませんが、新しいコードでは代わりに&lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;を使用する必要があり、新しい &lt;code&gt;impl&lt;/code&gt; は省略できます。</target>
        </trans-unit>
        <trans-unit id="ce3c8369369ce1fe72325205b70eb3e2961e011c" translate="yes" xml:space="preserve">
          <source>Although you can&amp;rsquo;t remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency. This is useful when a crate version is broken for one reason or another. In such situations, Cargo supports &lt;em&gt;yanking&lt;/em&gt; a crate version.</source>
          <target state="translated">以前のバージョンのクレートを削除することはできませんが、将来のプロジェクトで新しい依存関係として追加されないようにすることができます。これは、何らかの理由でクレートバージョンが壊れている場合に役立ちます。このような状況では、Cargoはクレートバージョンの&lt;em&gt;ヤンクを&lt;/em&gt;サポートします。</target>
        </trans-unit>
        <trans-unit id="a876dd4a0d144d06dda24f474bedf4412b3d4b86" translate="yes" xml:space="preserve">
          <source>Always empty bottom type for diverging functions</source>
          <target state="translated">発散機能は常に空のボトムタイプ</target>
        </trans-unit>
        <trans-unit id="30044213367fd946b86a46fbbf0f3c415f92d7bc" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;Err&lt;/code&gt; on arithmetic overflow.</source>
          <target state="translated">算術オーバーフローで常に &lt;code&gt;Err&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="81c2dadc15a7e41133f5895d6079a63549a2abb5" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;needle&lt;/code&gt; is an empty slice:</source>
          <target state="translated">&lt;code&gt;needle&lt;/code&gt; が空のスライスの場合、常に &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0d0ce480d587247832892434b17dbf1b556a5191" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.add(count)&lt;/code&gt; instead when possible, because &lt;code&gt;add&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="translated">常に使用 &lt;code&gt;.add(count)&lt;/code&gt; ので、代わりに、可能な場合、 &lt;code&gt;add&lt;/code&gt; 良く最適化するために、コンパイラができます。</target>
        </trans-unit>
        <trans-unit id="2dbc1421ee3e3a275bd2bb6e8f64943056afdc31" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.offset(count)&lt;/code&gt; instead when possible, because &lt;code&gt;offset&lt;/code&gt; allows the compiler to optimize better. If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">可能な場合は、代わりに常に &lt;code&gt;.offset(count)&lt;/code&gt; を使用してください。 &lt;code&gt;offset&lt;/code&gt; 使用すると、コンパイラーの最適化が向上します。オブジェクトの境界を越える必要がある場合は、ポインタを整数にキャストして、そこで計算を行います。</target>
        </trans-unit>
        <trans-unit id="701562825affe99f99fee809f333cf1e955284e4" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.sub(count)&lt;/code&gt; instead when possible, because &lt;code&gt;sub&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="translated">可能な場合は、代わりに常に &lt;code&gt;.sub(count)&lt;/code&gt; を使用してください。これは、 &lt;code&gt;sub&lt;/code&gt; がコンパイラーの最適化を向上させるためです。</target>
        </trans-unit>
        <trans-unit id="9fda5d5730cef377a6f455b42dbcfb53fb2ca5ca" translate="yes" xml:space="preserve">
          <source>Among other causes, &lt;code&gt;ParseIntError&lt;/code&gt; can be thrown because of leading or trailing whitespace in the string e.g., when it is obtained from the standard input. Using the &lt;a href=&quot;../primitive.str#method.trim&quot;&gt;&lt;code&gt;str.trim()&lt;/code&gt;&lt;/a&gt; method ensures that no whitespace remains before parsing.</source>
          <target state="translated">他の原因の中でも、 &lt;code&gt;ParseIntError&lt;/code&gt; は、文字列の先頭または末尾の空白が原因でスローされる可能性があります（標準入力から取得された場合など）。&lt;a href=&quot;../primitive.str#method.trim&quot;&gt; &lt;code&gt;str.trim()&lt;/code&gt; &lt;/a&gt;メソッドを使用すると、解析前に空白が残っていないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="f82aa4d4f03b38410c80f80025c8644ba744b247" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing a string that contains a letter.</source>
          <target state="translated">他の原因の中で、このバリアントは文字を含む文字列を解析する際に構築されます。</target>
        </trans-unit>
        <trans-unit id="e8d19d51f5faed38ee6324a9eb71c292315da9f7" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing an empty string.</source>
          <target state="translated">他の原因の中で、このバリアントは空の文字列を解析するときに構築されます。</target>
        </trans-unit>
        <trans-unit id="1692574d1eb8d1443991c925dc8e2acd8ed2cbd7" translate="yes" xml:space="preserve">
          <source>An &quot;or&quot; pattern was used where the variable bindings are not consistently bound across patterns.</source>
          <target state="translated">変数バインディングがパターン間で一貫してバインドされていない場合には、「または」パターンが使用されました。</target>
        </trans-unit>
        <trans-unit id="43d68d3a293f07f835d90c6279bf8faa22ceb0c8" translate="yes" xml:space="preserve">
          <source>An &amp;lsquo;abstract syntax tree&amp;rsquo;, or &amp;lsquo;AST&amp;rsquo;, is an intermediate representation of the structure of the program when the compiler is compiling it.</source>
          <target state="translated">「抽象構文ツリー」または「AST」は、コンパイラーがプログラムをコンパイルするときのプログラムの構造の中間表現です。</target>
        </trans-unit>
        <trans-unit id="db2d4110f56313292c834e1861a95c89c601039f" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">アン&lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="c2d78c88964f9736a45223d8f771f07ad6bd857e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">アン&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="0a7f0956daf2ce936a64a4b1e04b5752d5af8c85" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt; declares both the type and a number of &lt;em&gt;variants&lt;/em&gt;, each of which is independently named and has the syntax of a struct, tuple struct or unit-like struct.</source>
          <target state="translated">&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 項目は、&lt;/a&gt;タイプと数の両方を宣言&lt;em&gt;バリアント&lt;/em&gt;独立名前と構造体、タプル構造体または構造体ユニット状の構文を有するその各々を、。</target>
        </trans-unit>
        <trans-unit id="eccb90f6f9e2e1cba49165645ca18ce97f7c3bdc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">アン&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="ee613500276e22e6ef67273653d1676ba809144c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; that is not a member of an &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt;, such as a &lt;em&gt;free function&lt;/em&gt; or a &lt;em&gt;free const&lt;/em&gt;. Contrast to an &lt;a href=&quot;glossary#associated-item&quot;&gt;associated item&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;のメンバーではない&lt;a href=&quot;items/implementations&quot;&gt;実装&lt;/a&gt;のような、&lt;em&gt;フリー機能&lt;/em&gt;又は&lt;em&gt;フリーCONST&lt;/em&gt;。&lt;a href=&quot;glossary#associated-item&quot;&gt;関連するアイテムと&lt;/a&gt;対比。</target>
        </trans-unit>
        <trans-unit id="dcdff555d3629a9d75bb0e2e48e4c4243e57c8c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt; that applies to a nominal type, not to a trait-type pair. &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/implementations&quot;&gt;実装&lt;/a&gt;ではないトレイト型のペアに、名目上のタイプに適用されます。&lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;もっと&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f864e2f214828c68972804234bf4534f4526fce2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; initialized to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">アン&lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; は&lt;/a&gt;に初期化 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36aa4d3dbc6bef64eda94b67a998204c02c9bc40" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Err&lt;/code&gt; will be returned if an error occurs while flushing the buffer.</source>
          <target state="translated">アン &lt;code&gt;Err&lt;/code&gt; バッファをフラッシュ中にエラーが発生した場合に返されます。</target>
        </trans-unit>
        <trans-unit id="08eb1e2f2f021298ee3677019a6bda280ed6f694" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Ordering&lt;/code&gt; is the result of a comparison between two values.</source>
          <target state="translated">&lt;code&gt;Ordering&lt;/code&gt; 2つの値の間の比較の結果です。</target>
        </trans-unit>
        <trans-unit id="001eb435d69650fbb2db42365be5918489730c71" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;RwLock&lt;/code&gt;, like &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;, will become poisoned on a panic. Note, however, that an &lt;code&gt;RwLock&lt;/code&gt; may only be poisoned if a panic occurs while it is locked exclusively (write mode). If a panic occurs in any reader, then the lock will not be poisoned.</source>
          <target state="translated">アン &lt;code&gt;RwLock&lt;/code&gt; 、のような&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;、パニックに毒になるだろう。ただし、 &lt;code&gt;RwLock&lt;/code&gt; は、排他的にロックされている（書き込みモード）ときにパニックが発生した場合にのみポイズニングされる可能性があることに注意してください。リーダーでパニックが発生した場合、ロックは無効化されません。</target>
        </trans-unit>
        <trans-unit id="5247e633cc3100e9500337757cb3044553bdf55d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; with a discriminant must specify a &lt;code&gt;#[repr(inttype)]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 判別式では、指定しなければなりません &lt;code&gt;#[repr(inttype)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21ec5e4c1f77a0601ab37f0e8a98cf223a18e608" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is equivalent to a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows:</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 式は同等です&lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; の式&lt;/a&gt;は次のよう：</target>
        </trans-unit>
        <trans-unit id="2ca624a02ac8519763d7ccacb2b0ad8dad16c279" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is semantically similar to an &lt;code&gt;if&lt;/code&gt; expression but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt; and a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression. If the value of the scrutinee matches the pattern, the corresponding block will execute. Otherwise, flow proceeds to the following &lt;code&gt;else&lt;/code&gt; block if it exists. Like &lt;code&gt;if&lt;/code&gt; expressions, &lt;code&gt;if let&lt;/code&gt; expressions have a value determined by the block that is evaluated.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 式は、意味的に似ている &lt;code&gt;if&lt;/code&gt; 表現が、条件式の代わりに、それはキーワードが期待し &lt;code&gt;let&lt;/code&gt; パターン、続い &lt;code&gt;=&lt;/code&gt; と&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutineeの&lt;/a&gt;表現。 scrutineeの値がパターンと一致する場合、対応するブロックが実行されます。それ以外の場合、フローは次の &lt;code&gt;else&lt;/code&gt; ブロックに進みます（存在する場合）。同様に &lt;code&gt;if&lt;/code&gt; 式、 &lt;code&gt;if let&lt;/code&gt; 式が評価されたブロックによって決定された値を持っています。</target>
        </trans-unit>
        <trans-unit id="eee510cf708477f86b4dc6237cd892de065d1aca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression allows you to branch your code depending on conditions. You provide a condition and then state, &amp;ldquo;If this condition is met, run this block of code. If the condition is not met, do not run this block of code.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 式は条件に応じてコードを分岐することができます。条件を指定してから、「この条件が満たされている場合は、このコードブロックを実行します。条件が満たされていない場合は、このコードブロックを実行しないでください。」</target>
        </trans-unit>
        <trans-unit id="23bc01de0e1b8681253f7b567d2d01b7869caf61" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression is a conditional branch in program control. The form of an &lt;code&gt;if&lt;/code&gt; expression is a condition expression, followed by a consequent block, any number of &lt;code&gt;else if&lt;/code&gt; conditions and blocks, and an optional trailing &lt;code&gt;else&lt;/code&gt; block. The condition expressions must have type &lt;code&gt;bool&lt;/code&gt;. If a condition expression evaluates to &lt;code&gt;true&lt;/code&gt;, the consequent block is executed and any subsequent &lt;code&gt;else if&lt;/code&gt; or &lt;code&gt;else&lt;/code&gt; block is skipped. If a condition expression evaluates to &lt;code&gt;false&lt;/code&gt;, the consequent block is skipped and any subsequent &lt;code&gt;else if&lt;/code&gt; condition is evaluated. If all &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else if&lt;/code&gt; conditions evaluate to &lt;code&gt;false&lt;/code&gt; then any &lt;code&gt;else&lt;/code&gt; block is executed. An if expression evaluates to the same value as the executed block, or &lt;code&gt;()&lt;/code&gt; if no block is evaluated. An &lt;code&gt;if&lt;/code&gt; expression must have the same type in all situations.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 式がプログラム制御で条件分岐です。 &lt;code&gt;if&lt;/code&gt; 式の形式は条件式であり、その後に続くブロック、任意の数の &lt;code&gt;else if&lt;/code&gt; 条件とブロック、およびオプションの後続する &lt;code&gt;else&lt;/code&gt; ブロックが続きます。条件式のタイプは &lt;code&gt;bool&lt;/code&gt; でなければなりません。条件式が &lt;code&gt;true&lt;/code&gt; と評価された場合、結果のブロックが実行され、後続の &lt;code&gt;else if&lt;/code&gt; または &lt;code&gt;else&lt;/code&gt; ブロックはスキップされます。条件式が &lt;code&gt;false&lt;/code&gt; と評価された場合、後続のブロックはスキップされ、後続の &lt;code&gt;else if&lt;/code&gt; 条件が評価されます。すべての &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;else if&lt;/code&gt; 条件は &lt;code&gt;false&lt;/code&gt; と評価され、 &lt;code&gt;else&lt;/code&gt; ブロックが実行されます。if式は、実行されたブロックと同じ値に評価されます。ブロックが評価されない場合は &lt;code&gt;()&lt;/code&gt; になります。 &lt;code&gt;if&lt;/code&gt; 式がすべての状況で同じ型を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="8f0d0db502cd02811b94f8110c6b6a57d9c4d08b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block has the type &lt;code&gt;()&lt;/code&gt;, so this is a type error. To resolve it, add an &lt;code&gt;else&lt;/code&gt; block having the same type as the &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 無し式 &lt;code&gt;else&lt;/code&gt; ブロックタイプを有する &lt;code&gt;()&lt;/code&gt; 、これは型エラーです。これを解決するには、追加 &lt;code&gt;else&lt;/code&gt; と同じ種類のブロック &lt;code&gt;if&lt;/code&gt; ブロックを。</target>
        </trans-unit>
        <trans-unit id="86c2bbd51b64dbea789df858c004c474818f64aa" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type expands to a recursive type.</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; の種類は、再帰型に拡張されます。</target>
        </trans-unit>
        <trans-unit id="714f0cd77b96bfb041f113fa02745f0b3de0da54" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type must be expandable to a concrete type that contains no &lt;code&gt;impl Trait&lt;/code&gt; types. For example the following example tries to create an &lt;code&gt;impl Trait&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; that is equal to &lt;code&gt;[T, T]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; タイプには含まれていない具体的なタイプに拡張可能でなければならない &lt;code&gt;impl Trait&lt;/code&gt; 種類を。たとえば、次の例では、 &lt;code&gt;[T, T]&lt;/code&gt; 等しい &lt;code&gt;impl Trait&lt;/code&gt; タイプ &lt;code&gt;T&lt;/code&gt; を作成しようとしています。</target>
        </trans-unit>
        <trans-unit id="ee4fc89f6e27033dd75c8304209d0e35cd3688c5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl&lt;/code&gt; for a &lt;code&gt;#[marker]&lt;/code&gt; trait tried to override an associated item.</source>
          <target state="translated">&lt;code&gt;#[marker]&lt;/code&gt; トレイトの &lt;code&gt;impl&lt;/code&gt; は、関連付けられたアイテムをオーバーライドしようとしました。</target>
        </trans-unit>
        <trans-unit id="6d1073354ecc9c5e7785479d7d2a13da928ab63a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;0&lt;/code&gt; の &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; のビット幅を返します。</target>
        </trans-unit>
        <trans-unit id="80f05b7296f4e1950e87afc07c23f9e722a69148" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 値が &lt;code&gt;0&lt;/code&gt; のビット幅戻ります &lt;code&gt;T&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="534dc31a67cf35753f9f6ff5f73b65cd1ba58ab5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;array&lt;/a&gt; expression&lt;/em&gt; can be written by enclosing zero or more comma-separated expressions of uniform type in square brackets. This produces and array containing each of these values in the order they are written.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;配列の&lt;/a&gt;発現は、&lt;/em&gt;角括弧内に均一型のゼロまたはそれ以上のカンマで区切られた式を囲んで書くことができます。これにより、これらの各値が書き込まれた順序で格納された配列が生成されます。</target>
        </trans-unit>
        <trans-unit id="32616f8cb6d3bd819da208e9fcccc36635a05f1e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;code&gt;extern crate&lt;/code&gt; declaration&lt;/em&gt; specifies a dependency on an external crate. The external crate is then bound into the declaring scope as the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; provided in the &lt;code&gt;extern crate&lt;/code&gt; declaration. The &lt;code&gt;as&lt;/code&gt; clause can be used to bind the imported crate to a different name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;extern crate&lt;/code&gt; 宣言は、&lt;/em&gt;外部クレートへの依存性を指定します。次に、外部クレートは、 &lt;code&gt;extern crate&lt;/code&gt; 宣言で提供された&lt;a href=&quot;../identifiers&quot;&gt;識別子&lt;/a&gt;として宣言スコープにバインドされます。句は、別の名前にインポートクレートを結合するために使用することができます。 &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13494e1cedf4f5c5ecdcb7c07e83d0cd9827df20" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;absolute path&lt;/em&gt; starts from a crate root by using a crate name or a literal &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;絶対パスは、&lt;/em&gt;クレート名またはリテラル使用して、クレートルートから開始 &lt;code&gt;crate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86fdc788150826ae707ba926f5a66e96063c57f9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;assignment expression&lt;/em&gt; consists of a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; followed by an equals sign (&lt;code&gt;=&lt;/code&gt;) and a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;. Such an expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;代入式は、&lt;/em&gt;から成る&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所発現&lt;/a&gt;等号が続く（ &lt;code&gt;=&lt;/code&gt; ）と&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;値式&lt;/a&gt;。このような式には常に&lt;a href=&quot;../types/tuple&quot;&gt; &lt;code&gt;unit&lt;/code&gt; タイプがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ca56087cc708820efe9481bf7313fdab4a040e22" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant declaration&lt;/em&gt; declares a signature for associated constant definitions. It is written as &lt;code&gt;const&lt;/code&gt;, then an identifier, then &lt;code&gt;:&lt;/code&gt;, then a type, finished by a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;関連定数宣言が&lt;/em&gt;関連付けられた定数定義の署名を宣言する。それは &lt;code&gt;const&lt;/code&gt; 、次に識別子、次に &lt;code&gt;:&lt;/code&gt; 、次にタイプとして書かれ、 &lt;code&gt;;&lt;/code&gt; で終了します。。</target>
        </trans-unit>
        <trans-unit id="ec29836d6b0ec5f807474f5934209d4fe8c7bb83" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant definition&lt;/em&gt; defines a constant associated with a type. It is written the same as a &lt;a href=&quot;constant-items&quot;&gt;constant item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;関連する定数の定義は、&lt;/em&gt;タイプに関連付けられた定数を定義します。&lt;a href=&quot;constant-items&quot;&gt;定数項目&lt;/a&gt;と同じように書かれています。</target>
        </trans-unit>
        <trans-unit id="c9d2944c74176d8d6fa13f7d573ee85d9e742d32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function declaration&lt;/em&gt; declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;関連関数宣言は&lt;/em&gt;、関連する関数定義のシグネチャを宣言する。関数本体が &lt;code&gt;;&lt;/code&gt; に置き換えられることを除いて、関数項目として記述されます。。</target>
        </trans-unit>
        <trans-unit id="dce2c17d462060e477f166e6bcfabaf54ef17987" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function definition&lt;/em&gt; defines a function associated with another type. It is written the same as a &lt;a href=&quot;../types/function-item&quot;&gt;function item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;関連した関数の定義は&lt;/em&gt;、他のタイプに関連付けられた機能を定義します。&lt;a href=&quot;../types/function-item&quot;&gt;関数アイテム&lt;/a&gt;と同じように書かれています。</target>
        </trans-unit>
        <trans-unit id="ddd6d9f2bd71f652e6f6a519a466ea3ae43a3bff" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type declaration&lt;/em&gt; declares a signature for associated type definitions. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, and finally an optional list of trait bounds.</source>
          <target state="translated">&lt;em&gt;関連するタイプ宣言が&lt;/em&gt;関連付けられているタイプ定義のための署名を宣言する。これは &lt;code&gt;type&lt;/code&gt; 、次に&lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;、最後にオプションの特性境界のリストとして記述されます。</target>
        </trans-unit>
        <trans-unit id="9bd2e844486eba2a5ee0638c6e470984a319e1bf" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type definition&lt;/em&gt; defines a type alias on another type. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, then an &lt;code&gt;=&lt;/code&gt;, and finally a &lt;a href=&quot;../types#type-expressions&quot;&gt;type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;関連する型定義は&lt;/em&gt;、他の種類のタイプの別名を定義します。 &lt;code&gt;type&lt;/code&gt; 、&lt;a href=&quot;../identifiers&quot;&gt;識別子&lt;/a&gt;、 &lt;code&gt;=&lt;/code&gt; の順に記述され、最後に&lt;a href=&quot;../types#type-expressions&quot;&gt;タイプ&lt;/a&gt;が記述されます。</target>
        </trans-unit>
        <trans-unit id="335c18325b2749c2db5132eb57bce1ffbfa512dc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute&lt;/em&gt; is a general, free-form metadatum that is interpreted according to name, convention, and language and compiler version. Attributes are modeled on Attributes in &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, with the syntax coming from &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C#).</source>
          <target state="translated">&lt;em&gt;属性には、&lt;/em&gt;名前、慣習、言語とコンパイラのバージョンに応じて解釈される一般的な、自由形式のmetadatumです。属性は&lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335の&lt;/a&gt;属性に基づいてモデル化され、構文は&lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt;（C＃）から取得されます。</target>
        </trans-unit>
        <trans-unit id="fe8d0e2999c5dfed50da51262f087365afa14a25" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumerated type&lt;/em&gt; is a nominal, heterogeneous disjoint union type, denoted by the name of an &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt;. &lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;em&gt;列挙型は、&lt;/em&gt;の名前で示され、名目、異種のばらばらの共用体型である&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; アイテム&lt;/a&gt;。&lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="519b32460e4cf24cbf7584ec56a2b57870f1cdef" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumeration&lt;/em&gt;, also referred to as &lt;em&gt;enum&lt;/em&gt; is a simultaneous definition of a nominal &lt;a href=&quot;../types/enum&quot;&gt;enumerated type&lt;/a&gt; as well as a set of &lt;em&gt;constructors&lt;/em&gt;, that can be used to create or pattern-match values of the corresponding enumerated type.</source>
          <target state="translated">&lt;em&gt;列挙&lt;/em&gt;とも呼ばれる、&lt;em&gt;列挙は、&lt;/em&gt;公称の同時定義で&lt;a href=&quot;../types/enum&quot;&gt;列挙型&lt;/a&gt;と同様のセット&lt;em&gt;コンストラクタ&lt;/em&gt;対応する列挙型の又はパターンマッチ値を作成するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="670995bec677d5fc81f3189dbec41d6de7da346c" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;example term&lt;/em&gt; is an example of a term being defined.</source>
          <target state="translated">&lt;em&gt;例えば、この用語は、&lt;/em&gt;定義される用語の例です。</target>
        </trans-unit>
        <trans-unit id="03f2bd4498afb61074c0d1568fbae87b71b0a6a3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;expression statement&lt;/em&gt; is one that evaluates an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; and ignores its result. As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.</source>
          <target state="translated">&lt;em&gt;式文は、&lt;/em&gt;評価1で&lt;a href=&quot;expressions&quot;&gt;表現し&lt;/a&gt;、その結果を無視します。原則として、式ステートメントの目的は、式の評価の効果をトリガーすることです。</target>
        </trans-unit>
        <trans-unit id="111aa957a35f04452bf335357f4b5845abfce6b9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;implementation&lt;/em&gt; is an item that associates items with an &lt;em&gt;implementing type&lt;/em&gt;. Implementations are defined with the keyword &lt;code&gt;impl&lt;/code&gt; and contain functions that belong to an instance of the type that is being implemented or to the type statically.</source>
          <target state="translated">&lt;em&gt;実装が&lt;/em&gt;持つアイテムに関連付けアイテムです&lt;em&gt;実装タイプを&lt;/em&gt;。実装はキーワード &lt;code&gt;impl&lt;/code&gt; で定義され、実装される型のインスタンスまたは静的に型に属する関数を含みます。</target>
        </trans-unit>
        <trans-unit id="26714676268e63e4c19e025e4e919231c94ab7b4" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer literal&lt;/em&gt; has one of four forms:</source>
          <target state="translated">&lt;em&gt;整数リテラルは、&lt;/em&gt; 4つの形式のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="3b04f25de241c42aa4cc17d61d52253aec0db163" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer&lt;/em&gt; is a number without a fractional component. We used one integer type in Chapter 2, the &lt;code&gt;u32&lt;/code&gt; type. This type declaration indicates that the value it&amp;rsquo;s associated with should be an unsigned integer (signed integer types start with &lt;code&gt;i&lt;/code&gt;, instead of &lt;code&gt;u&lt;/code&gt;) that takes up 32 bits of space. Table 3-1 shows the built-in integer types in Rust. Each variant in the Signed and Unsigned columns (for example, &lt;code&gt;i16&lt;/code&gt;) can be used to declare the type of an integer value.</source>
          <target state="translated">&lt;em&gt;整数&lt;/em&gt;分数成分を含まない数です。第2章では、1つの整数型、 &lt;code&gt;u32&lt;/code&gt; 型を使用しました。この型宣言は、関連付けられている値が32ビットのスペースを占める符号なし整数（ &lt;code&gt;u&lt;/code&gt; の代わりに &lt;code&gt;i&lt;/code&gt; で始まる符号付き整数型）であることを示しています。表3-1は、Rustの組み込み整数型を示しています。 Signed列とUnsigned列の各バリアント（たとえば、 &lt;code&gt;i16&lt;/code&gt; ）を使用して、整数値の型を宣言できます。</target>
        </trans-unit>
        <trans-unit id="c86645edb5b5b0c86e3d214a4daf335142eb0487" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item declaration statement&lt;/em&gt; has a syntactic form identical to an &lt;a href=&quot;items&quot;&gt;item declaration&lt;/a&gt; within a &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt;. Declaring an item within a statement block restricts its scope to the block containing the statement. The item is not given a &lt;a href=&quot;paths#canonical-paths&quot;&gt;canonical path&lt;/a&gt; nor are any sub-items it may declare. The exception to this is that associated items defined by &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</source>
          <target state="translated">&lt;em&gt;アイテムの宣言文は、&lt;/em&gt;同一の構文形式有する&lt;a href=&quot;items&quot;&gt;アイテム宣言&lt;/a&gt;内の&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;。ステートメントブロック内でアイテムを宣言すると、そのスコープはステートメントを含むブロックに制限されます。アイテムには&lt;a href=&quot;paths#canonical-paths&quot;&gt;正規のパスが&lt;/a&gt;与えられておらず、宣言できるサブアイテムもありません。これの例外は、&lt;a href=&quot;items/implementations&quot;&gt;実装&lt;/a&gt;によって定義された関連項目は、項目と、該当する場合は特性にアクセスできる限り、外部スコープで引き続きアクセスできることです。それ以外の点は、モジュール内でアイテムを宣言することと同じ意味です。</target>
        </trans-unit>
        <trans-unit id="7cb6bea3f24f939f1296c8f5c8b195169146ee81" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item&lt;/em&gt; is a component of a crate. Items are organized within a crate by a nested set of &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. Every crate has a single &quot;outermost&quot; anonymous module; all further items within the crate have &lt;a href=&quot;paths&quot;&gt;paths&lt;/a&gt; within the module tree of the crate.</source>
          <target state="translated">&lt;em&gt;アイテムは、&lt;/em&gt;クレートの構成要素です。アイテムは、ネストされた&lt;a href=&quot;items/modules&quot;&gt;モジュールの&lt;/a&gt;セットによってクレート内で編成されます。すべてのクレートには、単一の「最も外側の」匿名モジュールがあります。クレート内のすべてのアイテムには、クレートのモジュールツリー内の&lt;a href=&quot;paths&quot;&gt;パス&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="8df47e4537a8816a2744d87425d00def520f575a" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;octal literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+006F&lt;/code&gt; (&lt;code&gt;0o&lt;/code&gt;) and continues as any mixture (with at least one digit) of octal digits and underscores.</source>
          <target state="translated">&lt;em&gt;進リテラル&lt;/em&gt;文字列で始まる &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+006F&lt;/code&gt; （ &lt;code&gt;0o&lt;/code&gt; ）と進数字と下線の（少なくとも一桁で）任意の混合物として継続します。</target>
        </trans-unit>
        <trans-unit id="a141d1e8af86d54f8339e504d3e1c56051728a15" translate="yes" xml:space="preserve">
          <source>An Example Program Using Structs</source>
          <target state="translated">構造体を用いたプログラム例</target>
        </trans-unit>
        <trans-unit id="5aefcb56dc6b861369f867948d8b3b7d49377bfe" translate="yes" xml:space="preserve">
          <source>An I/O Project: Building a Command Line Program</source>
          <target state="translated">I/Oプロジェクト。コマンドラインプログラムの構築</target>
        </trans-unit>
        <trans-unit id="0827868381963388a6304543297f7f95e42e9164" translate="yes" xml:space="preserve">
          <source>An IP address, either IPv4 or IPv6.</source>
          <target state="translated">IPv4またはIPv6のいずれかのIPアドレス。</target>
        </trans-unit>
        <trans-unit id="ac4cbc9b22ca704cfdd900cac5407adcf23c5edb" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing an unspecified address: 0.0.0.0</source>
          <target state="translated">不特定のアドレスを表すIPv4アドレス。0.0.0.0</target>
        </trans-unit>
        <trans-unit id="d2e22ab3badaaaa01e7375dd220a2065ca03f949" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing the broadcast address: 255.255.255.255</source>
          <target state="translated">ブロードキャストアドレスを表すIPv4アドレス。255.255.255.255</target>
        </trans-unit>
        <trans-unit id="5f0e70a5e365495e2ae4d74f302988b1f303a907" translate="yes" xml:space="preserve">
          <source>An IPv4 address with the address pointing to localhost: 127.0.0.1.</source>
          <target state="translated">localhostを指すIPv4アドレス:127.0.0.0.1。</target>
        </trans-unit>
        <trans-unit id="c9d68f8900e66f00bfbfd5b6cf93e7f299173890" translate="yes" xml:space="preserve">
          <source>An IPv4 address.</source>
          <target state="translated">IPv4アドレス。</target>
        </trans-unit>
        <trans-unit id="5bb8e3b87105ecbe9c8ed2a2e3a9821088df2706" translate="yes" xml:space="preserve">
          <source>An IPv4 socket address.</source>
          <target state="translated">IPv4 ソケットアドレス。</target>
        </trans-unit>
        <trans-unit id="a30848e04ae8ee9ab468ffa0929f622538606ceb" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing localhost: &lt;code&gt;::1&lt;/code&gt;.</source>
          <target state="translated">localhost：:: &lt;code&gt;::1&lt;/code&gt; 表すIPv6アドレス。</target>
        </trans-unit>
        <trans-unit id="2e145c57ced7f65d6f3f83ddc10fbd40d1da4596" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing the unspecified address: &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">未指定のアドレスを表すIPv6アドレス &lt;code&gt;::&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ee7dda9f630704f82008f3562e22d445246045b1" translate="yes" xml:space="preserve">
          <source>An IPv6 address.</source>
          <target state="translated">IPv6アドレス。</target>
        </trans-unit>
        <trans-unit id="51d9d6e575aa92d12e0b2c0fb0d5fdcf4923ff85" translate="yes" xml:space="preserve">
          <source>An IPv6 socket address.</source>
          <target state="translated">IPv6 ソケットアドレス。</target>
        </trans-unit>
        <trans-unit id="bb7fb098f948c20be5364a0797d6630c8f71fe36" translate="yes" xml:space="preserve">
          <source>An RAII implementation of a &quot;scoped lock&quot; of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.</source>
          <target state="translated">ミューテックスの「スコープ付きロック」のRAII実装。この構造体がドロップされると(スコープから外れると)ロックは解除されます。</target>
        </trans-unit>
        <trans-unit id="445fdaee68caea7b120e9af421a1f499e812ae92" translate="yes" xml:space="preserve">
          <source>An additional advantage of using Cargo is that the commands are the same no matter which operating system you&amp;rsquo;re working on. So, at this point, we&amp;rsquo;ll no longer provide specific instructions for Linux and macOS versus Windows.</source>
          <target state="translated">Cargoを使用するもう1つの利点は、作業しているオペレーティングシステムに関係なく、コマンドが同じであることです。そのため、現時点では、LinuxおよびmacOSとWindowsの具体的な手順は提供しません。</target>
        </trans-unit>
        <trans-unit id="71d51fdd16cd827000271f90af417efeb9cea05f" translate="yes" xml:space="preserve">
          <source>An address associated with a Unix socket.</source>
          <target state="translated">Unix ソケットに関連付けられたアドレス。</target>
        </trans-unit>
        <trans-unit id="13ebc470b9c08ca083e04f253e5b3a814fa55f28" translate="yes" xml:space="preserve">
          <source>An anchor in time which can be used to create new &lt;code&gt;SystemTime&lt;/code&gt; instances or learn about where in time a &lt;code&gt;SystemTime&lt;/code&gt; lies.</source>
          <target state="translated">新しい &lt;code&gt;SystemTime&lt;/code&gt; インスタンスを作成したり、 &lt;code&gt;SystemTime&lt;/code&gt; がどこにあるかを知るために使用できる時間のアンカー。</target>
        </trans-unit>
        <trans-unit id="65f427918d6366c3545d7bcd1528880b6655f86b" translate="yes" xml:space="preserve">
          <source>An array is a fixed-size sequence of &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. The array type is written as &lt;code&gt;[T; N]&lt;/code&gt;. The size is an expression that evaluates to a &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配列は、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;N&lt;/code&gt; 個の要素の固定サイズのシーケンスです。配列タイプは &lt;code&gt;[T; N]&lt;/code&gt; N]。サイズは、&lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt; &lt;code&gt;usize&lt;/code&gt; に&lt;/a&gt;評価される式です。</target>
        </trans-unit>
        <trans-unit id="d98f60a77f0bbfa809e448ded22428fbfae4e33e" translate="yes" xml:space="preserve">
          <source>An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:</source>
          <target state="translated">配列は、スタック上に割り当てられたメモリの1つの塊です。このようにインデックスを使って配列の要素にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="a7bac5ec811f30188ce6fd849b796ac2d30ffddc" translate="yes" xml:space="preserve">
          <source>An array itself is not iterable:</source>
          <target state="translated">配列自体は反復可能ではありません。</target>
        </trans-unit>
        <trans-unit id="f510f3fd4950ebae5518ce0880fd83877599bc5e" translate="yes" xml:space="preserve">
          <source>An array or slice pattern required more elements than were present in the matched array.</source>
          <target state="translated">配列またはスライスパターンは、一致した配列に存在する要素よりも多くの要素を必要とします。</target>
        </trans-unit>
        <trans-unit id="005f7187c479dcce2321a163ab284d4855025280" translate="yes" xml:space="preserve">
          <source>An array or slice pattern was matched against some other type.</source>
          <target state="translated">配列またはスライスパターンが他のタイプとマッチしました。</target>
        </trans-unit>
        <trans-unit id="910b39cfa9beb5c32b52af8b271e7bb38ba1d4da" translate="yes" xml:space="preserve">
          <source>An array without a fixed length was pattern-matched.</source>
          <target state="translated">長さが固定されていない配列がパターンマッチされていました。</target>
        </trans-unit>
        <trans-unit id="9f6ee782e8b3dacab5901a68a88743cdf8f6df8d" translate="yes" xml:space="preserve">
          <source>An array, sometimes also called a fixed-size array or an inline array, is a value describing a collection of elements, each selected by an index that can be computed at run time by the program. It occupies a contiguous region of memory.</source>
          <target state="translated">配列は、固定サイズ配列やインライン配列と呼ばれることもありますが、要素の集合を表す値であり、それぞれが実行時にプログラムによって計算できるインデックスによって選択されます。これはメモリの連続した領域を占有します。</target>
        </trans-unit>
        <trans-unit id="704af6b84f8ec0b7b57fdf7ea0ff93aa51a032a6" translate="yes" xml:space="preserve">
          <source>An associated const was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">別の形質項目が期待されていたときに、関連付けられた const が実装されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="ac10e51ff90ef78acbd226706348e7754e0cff2c" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter), but an implementation of the trait declared the same function to be static.</source>
          <target state="translated">トレイトに関連付けられた関数はメソッド（つまり、 &lt;code&gt;self&lt;/code&gt; パラメータを取る）として定義されましたが、トレイトの実装は同じ関数を静的であると宣言しました。</target>
        </trans-unit>
        <trans-unit id="825b9fd38095eee93e418cc09ae8f9ace5e1f868" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be static, but an implementation of the trait declared the same function to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter).</source>
          <target state="translated">トレイトに関連付けられた関数は静的であると定義されましたが、トレイトの実装は同じ関数をメソッドとして宣言しました（つまり、 &lt;code&gt;self&lt;/code&gt; パラメータを取るため）。</target>
        </trans-unit>
        <trans-unit id="1035c9277b00c3deebef8eabfe1b836a5766b141" translate="yes" xml:space="preserve">
          <source>An associated item is an item that is associated with another item. Associated items are defined in &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; and declared in &lt;a href=&quot;items/traits&quot;&gt;traits&lt;/a&gt;. Only functions, constants, and type aliases can be associated. Contrast to a &lt;a href=&quot;glossary#free-item&quot;&gt;free item&lt;/a&gt;.</source>
          <target state="translated">関連アイテムは、別のアイテムに関連付けられているアイテムです。関連する項目は&lt;a href=&quot;items/implementations&quot;&gt;実装&lt;/a&gt;で定義され、&lt;a href=&quot;items/traits&quot;&gt;特性&lt;/a&gt;で宣言されます。関数、定数、および型エイリアスのみを関連付けることができます。&lt;a href=&quot;glossary#free-item&quot;&gt;無料のアイテム&lt;/a&gt;とは対照的です。</target>
        </trans-unit>
        <trans-unit id="9116723797d95c7e68863b40ba3626f52a6ce11f" translate="yes" xml:space="preserve">
          <source>An associated type binding was done outside of the type parameter declaration and &lt;code&gt;where&lt;/code&gt; clause. Erroneous code example:</source>
          <target state="translated">関連する型バインディングが、型パラメーター宣言と &lt;code&gt;where&lt;/code&gt; 句の外で行われました。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="01d78cadc098f0f8d19a172d639f50a5e45d007b" translate="yes" xml:space="preserve">
          <source>An associated type was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">別の形質項目が予想される場合に、関連付けられた型が実装されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="ca2d4322730aa4a674f88f33ea28a7a44379f38a" translate="yes" xml:space="preserve">
          <source>An asterisk &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">アスタリスク &lt;code&gt;.*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fcbf33b833d8349f917a7e3318533a910b1e01c0" translate="yes" xml:space="preserve">
          <source>An asynchronous, infinitely buffered channel. The &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(Sender, Receiver)&lt;/code&gt; tuple where all sends will be &lt;strong&gt;asynchronous&lt;/strong&gt; (they never block). The channel conceptually has an infinite buffer.</source>
          <target state="translated">非同期で無限にバッファリングされるチャネル。&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;機能が返されます &lt;code&gt;(Sender, Receiver)&lt;/code&gt; のすべてがされる送信タプル&lt;strong&gt;非同期に&lt;/strong&gt;（彼らはブロックしません）。チャネルには、概念的には無限のバッファーがあります。</target>
        </trans-unit>
        <trans-unit id="f387b126eb53d62fa04e8482ab5a1aac01b56bf6" translate="yes" xml:space="preserve">
          <source>An atomic fence.</source>
          <target state="translated">原子フェンス。</target>
        </trans-unit>
        <trans-unit id="a37a15efc349a5896258ef2d831759eaab050729" translate="yes" xml:space="preserve">
          <source>An atomic integer initialized to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; に初期化されるアトミック整数。</target>
        </trans-unit>
        <trans-unit id="ae4be8bb4563b5c446bf4ec14a3a559fbf234d0d" translate="yes" xml:space="preserve">
          <source>An attempt to implement the &lt;code&gt;Copy&lt;/code&gt; trait for a struct failed because one of the fields does not implement &lt;code&gt;Copy&lt;/code&gt;. To fix this, you must implement &lt;code&gt;Copy&lt;/code&gt; for the mentioned field. Note that this may not be possible, as in the example of</source>
          <target state="translated">フィールドの1つが &lt;code&gt;Copy&lt;/code&gt; を実装していないため、構造体に &lt;code&gt;Copy&lt;/code&gt; トレイトを実装しようとして失敗しました。これを修正するには、上記のフィールドに &lt;code&gt;Copy&lt;/code&gt; を実装する必要があります。の例のように、これは可能でない場合があることに注意してください</target>
        </trans-unit>
        <trans-unit id="b71c2935e96e5f7fe3e3f35ad00fd7b30920019f" translate="yes" xml:space="preserve">
          <source>An attempt to index into a type which doesn't implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait was performed.</source>
          <target state="translated">&lt;code&gt;std::ops::Index&lt;/code&gt; トレイトを実装していない型にインデックスを付ける試みが行われました。</target>
        </trans-unit>
        <trans-unit id="8febb37ae18b2d657b2615e5b330d2a55118441d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a concrete specialization of a generic type. An example is shown below:</source>
          <target state="translated">ジェネリック型の具体的な特殊化に &lt;code&gt;Drop&lt;/code&gt; を実装する試みが行われました。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="09ba79d4404f5653d6f77e24331c8ba336aac40d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a specialization of a generic type. An example is shown below:</source>
          <target state="translated">ジェネリック型の特殊化に &lt;code&gt;Drop&lt;/code&gt; を実装する試みが行われました。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="c55e6f81b7dc27d46319cedb33bad7716f5297f4" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement Drop on a trait, which is not allowed: only structs and enums can implement Drop. An example causing this error:</source>
          <target state="translated">Trait に Drop を実装しようとしましたが、これは許可されていません。このエラーの原因となった例。</target>
        </trans-unit>
        <trans-unit id="e153b913d67d75c58662cead8cf242032c80e00b" translate="yes" xml:space="preserve">
          <source>An attempt was made to mutate data using a non-mutable reference. This commonly occurs when attempting to assign to a non-mutable reference of a mutable reference (&lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt;).</source>
          <target state="translated">変更不可能な参照を使用してデータを変更しようとしました。これは一般に、変更可能な参照（ &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; ）の変更不可能な参照に割り当てようとすると発生します。</target>
        </trans-unit>
        <trans-unit id="adb3222e10ca68a4902e2fef67ce06d659218b60" translate="yes" xml:space="preserve">
          <source>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</source>
          <target state="translated">関連する型を取得しようと試みましたが、型があいまいでした。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="89de6efbf294db50ea9580038de7bf4a99c6cc2d" translate="yes" xml:space="preserve">
          <source>An attempted conversion that consumes &lt;code&gt;self&lt;/code&gt;, which may or may not be expensive.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; を消費する変換の試み。費用がかかる場合とそうでない場合があります。</target>
        </trans-unit>
        <trans-unit id="863f680a55f734bd0dbbca55a32cd8aa13a2d823" translate="yes" xml:space="preserve">
          <source>An attribute is either active or inert. During attribute processing, &lt;em&gt;active attributes&lt;/em&gt; remove themselves from the thing they are on while &lt;em&gt;inert attributes&lt;/em&gt; stay on.</source>
          <target state="translated">属性はアクティブまたは非アクティブです。属性の処理中に、&lt;em&gt;アクティブな属性は&lt;/em&gt;、彼らがいる間にあるものから身を削除する&lt;em&gt;不活性属性&lt;/em&gt;にご滞在を。</target>
        </trans-unit>
        <trans-unit id="8f22761bfa3bdfb0003204a934bf1010c9716a93" translate="yes" xml:space="preserve">
          <source>An empty buffer returned indicates that the stream has reached EOF.</source>
          <target state="translated">返された空のバッファは、ストリームがEOFに達したことを示します。</target>
        </trans-unit>
        <trans-unit id="dc01027756efda949405e0e59c0d834ec342e061" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">空のイテレータは &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="442cf9396651f26f54eeff92f4dde433d7f72454" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">空のイテレータは &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e3ba001b1a53998b8d224cd77e4663359ef99e71" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the one value of the type.</source>
          <target state="translated">空のイテレータは、型の1つの値を返します。</target>
        </trans-unit>
        <trans-unit id="54261d577d85895bf8c09d3febd150e6fae82418" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the zero value of the type.</source>
          <target state="translated">空のイテレータは、型のゼロ値を返します。</target>
        </trans-unit>
        <trans-unit id="95f62854280c7cd5daf0c2b6b4a29d4a8c72ac30" translate="yes" xml:space="preserve">
          <source>An endpoint of a range of keys.</source>
          <target state="translated">キーの範囲の終点。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
