<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="ee713135dbae7e11e49962ea65b30c33678861ed" translate="yes" xml:space="preserve">
          <source>An entity already exists, often a file.</source>
          <target state="translated">実体は既に存在しており、多くの場合はファイルです。</target>
        </trans-unit>
        <trans-unit id="2db4e2025a972767c9444bca8e88e9a77524203e" translate="yes" xml:space="preserve">
          <source>An entity was not found, often a file.</source>
          <target state="translated">実体が見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="c5a4a196ff419cb4ace58ac8718f985652b454f9" translate="yes" xml:space="preserve">
          <source>An enum with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one variants.</source>
          <target state="translated">表現ヒント &lt;code&gt;repr(transparent)&lt;/code&gt; を持つ列挙型には、0個以上のバリアントがありました。</target>
        </trans-unit>
        <trans-unit id="3dc999ff5594fd4673ff8dbd7678f9024bdecf27" translate="yes" xml:space="preserve">
          <source>An enumeration of possible errors associated with a &lt;a href=&quot;type.trylockresult&quot;&gt;&lt;code&gt;TryLockResult&lt;/code&gt;&lt;/a&gt; which can occur while trying to acquire a lock, from the &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on an &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">関連付けられた可能性のあるエラーの列挙&lt;a href=&quot;type.trylockresult&quot;&gt; &lt;code&gt;TryLockResult&lt;/code&gt; &lt;/a&gt;から、ロックを取得しようとしたときに発生する可能性が&lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; の&lt;/a&gt;上の方法&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt;のメソッド&lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09fd334e73fd76483600e0a3e0818465278a8c4f" translate="yes" xml:space="preserve">
          <source>An error indicating invalid UTF-8 when converting a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;を&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;に変換するときに無効なUTF-8を示すエラー。</target>
        </trans-unit>
        <trans-unit id="7e00442ed63dafefaa24c2855dc12cc641d5d806" translate="yes" xml:space="preserve">
          <source>An error indicating that a nul byte was not in the expected position.</source>
          <target state="translated">nul バイトが期待された位置になかったことを示すエラー。</target>
        </trans-unit>
        <trans-unit id="607c0a59f40344c6d402da3d92f1e4d75c5c8d03" translate="yes" xml:space="preserve">
          <source>An error indicating that an interior nul byte was found.</source>
          <target state="translated">内部のヌルバイトが見つかったことを示すエラーです。</target>
        </trans-unit>
        <trans-unit id="2239ba3f9f1a9c04aabf258d44bc7c635e911959" translate="yes" xml:space="preserve">
          <source>An error of the &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is non-fatal and the read operation should be retried if there is nothing else to do.</source>
          <target state="translated">&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;種類のエラーは致命的ではないため、他に何もすることがない場合は、読み取り操作を再試行する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff800591cb202807f317ec28fbc572d02357615d" translate="yes" xml:space="preserve">
          <source>An error of the &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is non-fatal and the write operation should be retried if there is nothing else to do.</source>
          <target state="translated">&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;種類のエラーは致命的ではないため、他に何もすることがない場合は、書き込み操作を再試行する必要があります。</target>
        </trans-unit>
        <trans-unit id="b6ad7c556d901c0beffc94b348b6d4d9e1e99f53" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.localkey#method.try_with&quot;&gt;&lt;code&gt;LocalKey::try_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.localkey#method.try_with&quot;&gt; &lt;code&gt;LocalKey::try_with&lt;/code&gt; &lt;/a&gt;によって返されたエラー。</target>
        </trans-unit>
        <trans-unit id="4a2bb23cc4bff912e225e8d82c808ebe1116d273" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.refcell#method.try_borrow&quot;&gt;&lt;code&gt;RefCell::try_borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.refcell#method.try_borrow&quot;&gt; &lt;code&gt;RefCell::try_borrow&lt;/code&gt; &lt;/a&gt;によって返されたエラー。</target>
        </trans-unit>
        <trans-unit id="49b49c608a0a48a5c64a8db743785c3d4f2cbc87" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.refcell#method.try_borrow_mut&quot;&gt;&lt;code&gt;RefCell::try_borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.refcell#method.try_borrow_mut&quot;&gt; &lt;code&gt;RefCell::try_borrow_mut&lt;/code&gt; &lt;/a&gt;返されたエラー。</target>
        </trans-unit>
        <trans-unit id="6a9d323634dc21ac2ba61947c9f4ada5b0523975" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;code&gt;into_inner&lt;/code&gt; which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.</source>
          <target state="translated">バッファーの書き込み中に発生したエラーと、状態からの回復に使用できるバッファー付きライターオブジェクトを組み合わせた &lt;code&gt;into_inner&lt;/code&gt; によって返されるエラー。</target>
        </trans-unit>
        <trans-unit id="408e9c71ed3bc2aa80ae9ddbf31a37ecbe128d0c" translate="yes" xml:space="preserve">
          <source>An error returned from &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt;&lt;code&gt;Path::strip_prefix&lt;/code&gt;&lt;/a&gt; if the prefix was not found.</source>
          <target state="translated">プレフィックスが見つからなかった場合、&lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt; &lt;code&gt;Path::strip_prefix&lt;/code&gt; &lt;/a&gt;からエラーが返されました。</target>
        </trans-unit>
        <trans-unit id="788504f3aa85eadb6d0636b88bca37c397dba8e3" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; function on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;関数から返されたエラー。</target>
        </trans-unit>
        <trans-unit id="9fec5ed88196e94f3e7939be6668b9ce8dfe54d0" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;Sender::send&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;SyncSender::send&lt;/code&gt;&lt;/a&gt; function on &lt;strong&gt;channel&lt;/strong&gt;s.</source>
          <target state="translated">&lt;strong&gt;チャネル&lt;/strong&gt; sの&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;Sender::send&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;SyncSender::send&lt;/code&gt; &lt;/a&gt;関数から返されたエラー。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b947bf8292263975edc2c833eac5521f6b3d5e94" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;code&gt;duration_since&lt;/code&gt; and &lt;code&gt;elapsed&lt;/code&gt; methods on &lt;code&gt;SystemTime&lt;/code&gt;, used to learn how far in the opposite direction a system time lies.</source>
          <target state="translated">返されたエラー &lt;code&gt;duration_since&lt;/code&gt; と &lt;code&gt;elapsed&lt;/code&gt; の方法 &lt;code&gt;SystemTime&lt;/code&gt; どこまで反対方向のシステム時刻の嘘を学ぶために使用されます、。</target>
        </trans-unit>
        <trans-unit id="f51f86543e577fd1d558ef170de94a1b52743f0b" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because a call to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returned &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; の&lt;/a&gt;呼び出しが&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; を&lt;/a&gt;返したため、操作を完了できなかったときにエラーが返されました。</target>
        </trans-unit>
        <trans-unit id="b05482ca3068a6de89ef72655084867c49191841" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because an &quot;end of file&quot; was reached prematurely.</source>
          <target state="translated">ファイルの終了」が早まったため、操作を完了できなかった場合にエラーが返されました。</target>
        </trans-unit>
        <trans-unit id="9c4fdb1f9f1ace5ab60797b01c282f3c5da7046e" translate="yes" xml:space="preserve">
          <source>An error returned when parsing a &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;../primitive.bool#method.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt; fails</source>
          <target state="translated">解析時にエラーが返された &lt;code&gt;bool&lt;/code&gt; 使用して&lt;a href=&quot;../primitive.bool#method.from_str&quot;&gt; &lt;code&gt;from_str&lt;/code&gt; が&lt;/a&gt;失敗しました</target>
        </trans-unit>
        <trans-unit id="01956aad1d91d0a3eaa910ec372ba76608859bfc" translate="yes" xml:space="preserve">
          <source>An error that can be returned when decoding UTF-16 code points.</source>
          <target state="translated">UTF-16のコードポイントをデコードする際に返ってくるエラーです。</target>
        </trans-unit>
        <trans-unit id="3533bcb297f1b2a750fb10891e22e5dd49940449" translate="yes" xml:space="preserve">
          <source>An error when parsing a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; の解析時のエラー。</target>
        </trans-unit>
        <trans-unit id="a8c4d17e195207f5a989ac26b5a78606dcbba09d" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing a char.</source>
          <target state="translated">char を解析する際に返されるエラー。</target>
        </trans-unit>
        <trans-unit id="6080f2ccd647721dacbdd21e9d94b2a3bec77e1f" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing a float.</source>
          <target state="translated">float を解析する際に返されるエラー。</target>
        </trans-unit>
        <trans-unit id="8d76e3522dda33b8ed78bf99a4c5562182d54f08" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing an IP address or a socket address.</source>
          <target state="translated">IP アドレスまたはソケットアドレスを解析する際に返されるエラー。</target>
        </trans-unit>
        <trans-unit id="c7b106b5fd117686f0aceb67097fd3cef2a189bf" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing an integer.</source>
          <target state="translated">整数を解析する際に返されるエラー。</target>
        </trans-unit>
        <trans-unit id="1d7c5a9fd1d469b89a9d56899ca1f50026a1dd32" translate="yes" xml:space="preserve">
          <source>An example implementation for a domain in which two books are considered the same book if their ISBN matches, even if the formats differ:</source>
          <target state="translated">フォーマットが異なっていても、ISBNが一致していれば、2冊の本が同じ本とみなされるドメインの実装例。</target>
        </trans-unit>
        <trans-unit id="68ff7c567c0520a3da56cf3b0e9741fe24004f8f" translate="yes" xml:space="preserve">
          <source>An example implementation of the trait:</source>
          <target state="translated">形質の例示的な実装。</target>
        </trans-unit>
        <trans-unit id="28b14342433cafd1cb0863789fedb01f7530bff9" translate="yes" xml:space="preserve">
          <source>An example is a generic struct holding a function pointer. In this case, the implementation of &lt;code&gt;Clone&lt;/code&gt; cannot be &lt;code&gt;derive&lt;/code&gt;d, but can be implemented as:</source>
          <target state="translated">例は、関数ポインタを保持する一般的な構造体です。この場合、 &lt;code&gt;Clone&lt;/code&gt; の実装を &lt;code&gt;derive&lt;/code&gt; ことはできませんが、次のように実装できます。</target>
        </trans-unit>
        <trans-unit id="da1a4e43cf80966a8d5beb99e7207867287f3da9" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;use&lt;/code&gt; declarations:</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; 宣言の例：</target>
        </trans-unit>
        <trans-unit id="f512d81d83647ae47cd90bcb76d95f7b8768001b" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;for&lt;/code&gt; loop over the contents of an array:</source>
          <target state="translated">配列の内容 &lt;code&gt;for&lt;/code&gt; ループの例：</target>
        </trans-unit>
        <trans-unit id="fee9699f2c385a5203b6e01e13cf6011f2fcd8a4" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;match&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 式の例：</target>
        </trans-unit>
        <trans-unit id="cfd1afa80d53786d32ba47458c2ed4379f4003bf" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;return&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 式の例：</target>
        </trans-unit>
        <trans-unit id="9c5bf1e5202001a02f36098e504bd7cb0fe28030" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;struct&lt;/code&gt; item and its use:</source>
          <target state="translated">例 &lt;code&gt;struct&lt;/code&gt; 項目とその使用：</target>
        </trans-unit>
        <trans-unit id="3c2199ab0dce170bc0714704fc232fd68c69b281" translate="yes" xml:space="preserve">
          <source>An example of a &lt;em&gt;recursive&lt;/em&gt; type and its use:</source>
          <target state="translated">例&lt;em&gt;再帰&lt;/em&gt;種類とその使用：</target>
        </trans-unit>
        <trans-unit id="0f62525fdcd99f7d466515d9585c0c13357e1b2b" translate="yes" xml:space="preserve">
          <source>An example of a common associated function is a &lt;code&gt;new&lt;/code&gt; function that returns a value of the type the associated function is associated with.</source>
          <target state="translated">一般的な関連関数の例は、関連関数が関連付けられている型の値を返す &lt;code&gt;new&lt;/code&gt; 関数です。</target>
        </trans-unit>
        <trans-unit id="6a351aa1ff4672ddb51a26e9d5f1e845614b350b" translate="yes" xml:space="preserve">
          <source>An example of a for loop over a series of integers:</source>
          <target state="translated">整数列に対するforループの例。</target>
        </trans-unit>
        <trans-unit id="9bcd2ce89adc17fbe7648c05a09884aa0d701978" translate="yes" xml:space="preserve">
          <source>An example of a module:</source>
          <target state="translated">モジュールの例。</target>
        </trans-unit>
        <trans-unit id="8e8435c013addb39ce3eb498c3c558d414e6f6ad" translate="yes" xml:space="preserve">
          <source>An example of a necessary use of parentheses is when calling a function pointer that is a member of a struct:</source>
          <target state="translated">括弧の使用が必要な例としては、構造体のメンバである関数ポインタを呼び出す場合があります。</target>
        </trans-unit>
        <trans-unit id="056ff1cdb43a917deab8c9dc0f118b2d9dd496e8" translate="yes" xml:space="preserve">
          <source>An example of a non-&lt;code&gt;Send&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. If two threads attempt to clone &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;s that point to the same reference-counted value, they might try to update the reference count at the same time, which is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; doesn't use atomic operations. Its cousin &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;sync::Arc&lt;/code&gt;&lt;/a&gt; does use atomic operations (incurring some overhead) and thus is &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">非 &lt;code&gt;Send&lt;/code&gt; タイプの例は、参照カウントポインター&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt;です。 2つのスレッドが同じ参照カウント値を指す&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;のクローンを作成しようとすると、それらは同時に参照カウントを更新しようとする可能性があります。これは、&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;がアトミック操作を使用しないため、&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定義の&lt;/a&gt;動作です。その従兄弟の&lt;a href=&quot;../sync/struct.arc&quot;&gt; &lt;code&gt;sync::Arc&lt;/code&gt; &lt;/a&gt;はアトミック操作を使用し（オーバーヘッドが発生します）、したがって &lt;code&gt;Send&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="e38ec369f62f9a0e9cf71faa19b5cb843376b06e" translate="yes" xml:space="preserve">
          <source>An example of a parenthesized expression:</source>
          <target state="translated">括弧で囲まれた式の例。</target>
        </trans-unit>
        <trans-unit id="f06523b9f614521a822acb49c6502314b5223a29" translate="yes" xml:space="preserve">
          <source>An example of a trait object:</source>
          <target state="translated">形質オブジェクトの例。</target>
        </trans-unit>
        <trans-unit id="f97a42d4af253ea16c2f098f9cd1358538ff9ccc" translate="yes" xml:space="preserve">
          <source>An example of a trait that can&amp;rsquo;t be derived is &lt;code&gt;Display&lt;/code&gt;, which handles formatting for end users. You should always consider the appropriate way to display a type to an end user. What parts of the type should an end user be allowed to see? What parts would they find relevant? What format of the data would be most relevant to them? The Rust compiler doesn&amp;rsquo;t have this insight, so it can&amp;rsquo;t provide appropriate default behavior for you.</source>
          <target state="translated">派生できない特性の例は、エンドユーザーのフォーマットを処理する &lt;code&gt;Display&lt;/code&gt; です。エンドユーザーにタイプを表示する適切な方法を常に検討する必要があります。エンドユーザーに表示を許可する必要があるのは、タイプのどの部分ですか？彼らはどの部分に関連があると思いますか？それらに最も関連するデータの形式は何ですか？Rustコンパイラーにはこの洞察がないため、適切なデフォルトの動作を提供できません。</target>
        </trans-unit>
        <trans-unit id="b2a6dc626aff375aa4d434c66ea264d4dc08b800" translate="yes" xml:space="preserve">
          <source>An example of a trait whose methods are not object safe is the standard library&amp;rsquo;s &lt;code&gt;Clone&lt;/code&gt; trait. The signature for the &lt;code&gt;clone&lt;/code&gt; method in the &lt;code&gt;Clone&lt;/code&gt; trait looks like this:</source>
          <target state="translated">メソッドがオブジェクトセーフではないトレイトの例は、標準ライブラリの &lt;code&gt;Clone&lt;/code&gt; トレイトです。 &lt;code&gt;Clone&lt;/code&gt; トレイトの &lt;code&gt;clone&lt;/code&gt; メソッドのシグネチャは次のようになります。</target>
        </trans-unit>
        <trans-unit id="5e81f6611106899f0be7f5a0792978a45ad55dd8" translate="yes" xml:space="preserve">
          <source>An example of a tuple type and its use:</source>
          <target state="translated">タプル型の例とその使用例。</target>
        </trans-unit>
        <trans-unit id="363c341cbe13044b212571253c8a33caae78cd45" translate="yes" xml:space="preserve">
          <source>An example of an &lt;code&gt;as&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 式の例：</target>
        </trans-unit>
        <trans-unit id="a2db905e306fb4833044bdd9885bb27ab8f76d7f" translate="yes" xml:space="preserve">
          <source>An example of an &lt;code&gt;enum&lt;/code&gt; item and its use:</source>
          <target state="translated">例 &lt;code&gt;enum&lt;/code&gt; 項目とその使用：</target>
        </trans-unit>
        <trans-unit id="9260a714aba6105dd14cba9d58f3d41f31de6503" translate="yes" xml:space="preserve">
          <source>An example of an empty type is &lt;code&gt;enum Empty { }&lt;/code&gt;. So, the following will work:</source>
          <target state="translated">空の型の例は、 &lt;code&gt;enum Empty { }&lt;/code&gt; です。したがって、以下が機能します：</target>
        </trans-unit>
        <trans-unit id="ff969b10a01ab50464488192aa66638be2ebf171" translate="yes" xml:space="preserve">
          <source>An example of combining the above rules of &lt;code&gt;path&lt;/code&gt; attributes on inline modules and nested modules within (applies to both mod-rs and non-mod-rs files):</source>
          <target state="translated">インラインモジュールとネストされたモジュールの &lt;code&gt;path&lt;/code&gt; 属性の上記のルールを組み合わせた例（mod-rsファイルとnon-mod-rsファイルの両方に適用）：</target>
        </trans-unit>
        <trans-unit id="6e09c1385fee93fd5fa2b4010458a4fc489b7a97" translate="yes" xml:space="preserve">
          <source>An example of implementing the formatting traits would look like:</source>
          <target state="translated">フォーマットの特徴を実装する例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="fa098562087edb062353d3aa89708207a19b395b" translate="yes" xml:space="preserve">
          <source>An example of matching non-exhaustively on the above enum is provided below:</source>
          <target state="translated">上記の列挙に対して非網羅的にマッチングする例を以下に示す。</target>
        </trans-unit>
        <trans-unit id="7ef19768d994b2224d1f41bd49faef1709c5e7ef" translate="yes" xml:space="preserve">
          <source>An example of panic:</source>
          <target state="translated">パニックの例。</target>
        </trans-unit>
        <trans-unit id="884b0dfdd5d082bb94960ecce28dc9f3e6d384f8" translate="yes" xml:space="preserve">
          <source>An example of re-exporting:</source>
          <target state="translated">再輸出の例。</target>
        </trans-unit>
        <trans-unit id="708c005211a8b1e93ec9aac2ad4a16e9c3bc2bc3" translate="yes" xml:space="preserve">
          <source>An example of this error:</source>
          <target state="translated">このエラーの例。</target>
        </trans-unit>
        <trans-unit id="64eb812bfe0819a20f7b7755d2742025cd360a65" translate="yes" xml:space="preserve">
          <source>An example of what will and will not work for &lt;code&gt;use&lt;/code&gt; items:</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; アイテムで機能することと機能しないことの例：</target>
        </trans-unit>
        <trans-unit id="8365f135946b3f7b044d8cfd3fa7997f776027f4" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Clone&lt;/code&gt; is required is when calling the &lt;code&gt;to_vec&lt;/code&gt; method on a slice. The slice doesn&amp;rsquo;t own the type instances it contains, but the vector returned from &lt;code&gt;to_vec&lt;/code&gt; will need to own its instances, so &lt;code&gt;to_vec&lt;/code&gt; calls &lt;code&gt;clone&lt;/code&gt; on each item. Thus, the type stored in the slice must implement &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; が必要な場合の例は、スライスで &lt;code&gt;to_vec&lt;/code&gt; メソッドを呼び出す場合です。スライスはそれが含む型インスタンスを所有していませんが、 &lt;code&gt;to_vec&lt;/code&gt; から返されたベクターはそのインスタンスを所有する必要があるため、 &lt;code&gt;to_vec&lt;/code&gt; は各アイテムで &lt;code&gt;clone&lt;/code&gt; を呼び出します。したがって、スライスに格納される型は &lt;code&gt;Clone&lt;/code&gt; を実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="aaf3c4aa1a7d59f2304836782308596d0ae75f64" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Eq&lt;/code&gt; is required is for keys in a &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; so the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; can tell whether two keys are the same.</source>
          <target state="translated">場合の例 &lt;code&gt;Eq&lt;/code&gt; 必要であるがのキーのためのものである &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; ので &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 2つのキーが同じであるかどうかを伝えることができます。</target>
        </trans-unit>
        <trans-unit id="e410ff694a089e824c24843049bae108ce880220" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Hash&lt;/code&gt; is required is in storing keys in a &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; to store data efficiently.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; が必要な場合の例は、データを効率的に格納するために &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; にキーを格納する場合です。</target>
        </trans-unit>
        <trans-unit id="13874d9be8af151d397c4923d18c3e3bb505d451" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Ord&lt;/code&gt; is required is when storing values in a &lt;code&gt;BTreeSet&amp;lt;T&amp;gt;&lt;/code&gt;, a data structure that stores data based on the sort order of the values.</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; が必要な場合の例は、値のソート順に基づいてデータを格納するデータ構造である &lt;code&gt;BTreeSet&amp;lt;T&amp;gt;&lt;/code&gt; に値を格納する場合です。</target>
        </trans-unit>
        <trans-unit id="f42b2c8e58eff03a7089947fa8ffae92137b9b5f" translate="yes" xml:space="preserve">
          <source>An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It&amp;rsquo;s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 items:</source>
          <target state="translated">ベクトルではなく配列を使用する場合の例として、月の名前を知る必要があるプログラムがあります。このようなプログラムで月数を追加または削除する必要が生じる可能性は非常に低いため、配列には常に12項目が含まれることがわかっているため、配列を使用できます。</target>
        </trans-unit>
        <trans-unit id="bd0712d619a2d60e4c146e231ccdfbad8aba4743" translate="yes" xml:space="preserve">
          <source>An example of where you would want to only accept &lt;code&gt;fn&lt;/code&gt; and not closures is when interfacing with external code that doesn&amp;rsquo;t have closures: C functions can accept functions as arguments, but C doesn&amp;rsquo;t have closures.</source>
          <target state="translated">クロージャーではなく &lt;code&gt;fn&lt;/code&gt; のみを受け入れたい場合の例は、クロージャーを持たない外部コードとインターフェースする場合です。C関数は引数として関数を受け入れることができますが、Cにはクロージャーがありません。</target>
        </trans-unit>
        <trans-unit id="e73f9f6c8b4fbcf9f4fd470408b5fff3f081d3b9" translate="yes" xml:space="preserve">
          <source>An example using a closure:</source>
          <target state="translated">クロージャを使用した例。</target>
        </trans-unit>
        <trans-unit id="6d3969065ec2f88aef65174e1f6ffa620b0c83f2" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;Binop&lt;/code&gt; is defined as a function pointer type:</source>
          <target state="translated">&lt;code&gt;Binop&lt;/code&gt; が関数ポインター型として定義されている例：</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="9b338a4ae7f343a1618fa43d10bfc2df436ea62d" translate="yes" xml:space="preserve">
          <source>An exclusive bound.</source>
          <target state="translated">排他的な束縛。</target>
        </trans-unit>
        <trans-unit id="0a0f5c759335e3ef134a90149eb082ea59cf661b" translate="yes" xml:space="preserve">
          <source>An executing Rust program consists of a collection of native OS threads, each with their own stack and local state. Threads can be named, and provide some built-in support for low-level synchronization.</source>
          <target state="translated">実行中のRustプログラムは、ネイティブOSのスレッドのコレクションで構成されており、それぞれが独自のスタックとローカルステートを持っています。スレッドは名前を付けることができ、低レベルの同期化のためのいくつかの組み込みサポートを提供します。</target>
        </trans-unit>
        <trans-unit id="12c993ee363617797c480ae0e7fa61fa88f7540e" translate="yes" xml:space="preserve">
          <source>An explicit conversion from a &lt;code&gt;&amp;amp;str&lt;/code&gt; to a String is done as follows:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; からStringへの明示的な変換は、次のように行われます。</target>
        </trans-unit>
        <trans-unit id="9863ad7a484538312614b219ee23d089bab88f2a" translate="yes" xml:space="preserve">
          <source>An expression enclosed in parentheses evaluates to the result of the enclosed expression. Parentheses can be used to explicitly specify evaluation order within an expression.</source>
          <target state="translated">括弧で囲まれた式は、括弧で囲まれた式の結果として評価されます。括弧を使用して、式内の評価順序を明示的に指定することができます。</target>
        </trans-unit>
        <trans-unit id="b0b2d07f6ff343f37bbb2da0dbd07ed7ea53cb5d" translate="yes" xml:space="preserve">
          <source>An expression is a combination of values, constants, variables, operators and functions that evaluate to a single value, with or without side-effects.</source>
          <target state="translated">式とは、値、定数、変数、演算子、関数の組み合わせで、副作用の有無にかかわらず、1つの値に評価されるものです。</target>
        </trans-unit>
        <trans-unit id="8a470e20ec20f9f17fbbac4266c615aa43cc21c3" translate="yes" xml:space="preserve">
          <source>An expression may have two roles: it always produces a &lt;em&gt;value&lt;/em&gt;, and it may have &lt;em&gt;effects&lt;/em&gt; (otherwise known as &quot;side effects&quot;). An expression &lt;em&gt;evaluates to&lt;/em&gt; a value, and has effects during &lt;em&gt;evaluation&lt;/em&gt;. Many expressions contain sub-expressions (operands). The meaning of each kind of expression dictates several things:</source>
          <target state="translated">式には2つの役割があります。それは常に&lt;em&gt;値を&lt;/em&gt;生成する&lt;em&gt;ことと&lt;/em&gt;、&lt;em&gt;影響&lt;/em&gt;（別の方法として「副作用」として知られること）を持つことです。式は値に&lt;em&gt;評価され&lt;/em&gt;、&lt;em&gt;評価&lt;/em&gt;中に影響を与えます。多くの式にはサブ式（オペランド）が含まれています。それぞれの種類の表現の意味は、いくつかのことを指示します。</target>
        </trans-unit>
        <trans-unit id="894873bc5f587b4733b17f7dfb18b0f3059d2176" translate="yes" xml:space="preserve">
          <source>An expression that consists of only a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt; or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement. The type of &lt;a href=&quot;expressions&quot;&gt;&lt;em&gt;ExpressionWithBlock&lt;/em&gt;&lt;/a&gt; expressions when used as statements must be the unit type.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;ブロック式&lt;/a&gt;または制御フロー式のみで構成される式は、ステートメントが許可されているコンテキストで使用される場合、末尾のセミコロンを省略できます。これにより、スタンドアロンのステートメントとして解析されるか、別の式の一部として解析されるかのあいまいさが生じる可能性があります。この場合、ステートメントとして解析されます。ステートメントとして使用する場合の&lt;a href=&quot;expressions&quot;&gt;&lt;em&gt;ExpressionWithBlock&lt;/em&gt;&lt;/a&gt;式のタイプは、ユニットタイプである必要があります。</target>
        </trans-unit>
        <trans-unit id="3db9b6e5300ec2a35e045cae789d7d65bc1644c2" translate="yes" xml:space="preserve">
          <source>An extension trait for concatenating slices</source>
          <target state="translated">スライスを連結するための拡張形質</target>
        </trans-unit>
        <trans-unit id="12147a5a52fb5c2a1b9d7472abd1e716e6699134" translate="yes" xml:space="preserve">
          <source>An external crate dependency can be declared without binding its name in scope by using an underscore with the form &lt;code&gt;extern crate foo as _&lt;/code&gt;. This may be useful for crates that only need to be linked, but are never referenced, and will avoid being reported as unused.</source>
          <target state="translated">外部クレート依存関係は、 &lt;code&gt;extern crate foo as _&lt;/code&gt; の形式でアンダースコアを使用することにより、スコープ内でその名前をバインドせずに宣言できます。これは、リンクする必要があるだけで参照されないクレートに役立ち、未使用として報告されないようにします。</target>
        </trans-unit>
        <trans-unit id="af0969299b70206aefe5265b359a29ba784a7b81" translate="yes" xml:space="preserve">
          <source>An feature unstable in &lt;code&gt;const&lt;/code&gt; contexts was used.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; コンテキストで不安定な機能が使用されました。</target>
        </trans-unit>
        <trans-unit id="67fba469014e18ca2e89e6de19c923fe7de4bee7" translate="yes" xml:space="preserve">
          <source>An identifier is any nonempty ASCII string of the following form:</source>
          <target state="translated">識別子は、以下の形式の空でないASCII文字列です。</target>
        </trans-unit>
        <trans-unit id="c175628788a43110a89b193ae816462d4cf2d2a4" translate="yes" xml:space="preserve">
          <source>An identifier is bound more than once in a pattern.</source>
          <target state="translated">識別子はパターン内で複数回バインドされます。</target>
        </trans-unit>
        <trans-unit id="804d52ee70392ba486d9daf55c4a0571322cd6a0" translate="yes" xml:space="preserve">
          <source>An identifier was used like a function name or a value was expected and the identifier exists but it belongs to a different namespace.</source>
          <target state="translated">識別子が関数名のように使われていたか、値が期待されていて、識別子は存在するが別の名前空間に属していた。</target>
        </trans-unit>
        <trans-unit id="a9dd54d260c1e67a0aa0b597f6cdb8722318da30" translate="yes" xml:space="preserve">
          <source>An identity function.</source>
          <target state="translated">アイデンティティ関数。</target>
        </trans-unit>
        <trans-unit id="f4072cccbc13fd032256ab05516201c0d8df3e68" translate="yes" xml:space="preserve">
          <source>An if-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding instead. For instance:</source>
          <target state="translated">if-letパターンはパターンの照合を試み、照合が成功した場合は本文に入ります。一致に反論できない場合（一致に失敗しない場合）、代わりに通常の &lt;code&gt;let&lt;/code&gt; バインディングを使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="4ba45e243c916e58a2890a2d541b968fddd22dd8" translate="yes" xml:space="preserve">
          <source>An implementation can take type and lifetime parameters, which can be used in the rest of the implementation. Type parameters declared for an implementation must be used at least once in either the trait or the implementing type of an implementation. Implementation parameters are written directly after the &lt;code&gt;impl&lt;/code&gt; keyword.</source>
          <target state="translated">実装は、残りの実装で使用できるタイプと存続期間のパラメーターを取ることができます。実装に対して宣言された型パラメーターは、実装の特性または実装タイプのいずれかで少なくとも1回使用する必要があります。実装パラメーターは、 &lt;code&gt;impl&lt;/code&gt; キーワードの直後に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="5c1c04198ba70d5ee214d020749cca1de7fc7d00" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Alloc&lt;/code&gt; can allocate, reallocate, and deallocate arbitrary blocks of data described via &lt;code&gt;Layout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Alloc&lt;/code&gt; の実装は、 &lt;code&gt;Layout&lt;/code&gt; を介して記述されたデータの任意のブロックを割り当て、再割り当て、および割り当て解除できます。</target>
        </trans-unit>
        <trans-unit id="99623634884bf4add6cdc497873712ce416c8fd4" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAnd&lt;/code&gt; for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; ラッパー用の &lt;code&gt;BitAnd&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="0e2ff6912f2ce30546aa9104a9c9d196708332bf" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAnd&lt;/code&gt; for a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; のラッパー用の &lt;code&gt;BitAnd&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="5f6dfa411cba86305e5e9cd742f9f63d63776e67" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAndAssign&lt;/code&gt; that lifts the &lt;code&gt;&amp;amp;=&lt;/code&gt; operator to a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;BitAndAssign&lt;/code&gt; リフト &lt;code&gt;&amp;amp;=&lt;/code&gt; ラッパーにオペレータを &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3e86b6af5dd68737dcc690c4ff3a487a1934868" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitOr&lt;/code&gt; for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; ラッパー用の &lt;code&gt;BitOr&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="e8149ba6d1631c707939091192745b37494deb7b" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitOr&lt;/code&gt; for a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; のラッパー用の &lt;code&gt;BitOr&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="ce43f6aba41bb7af32e0d6e55432c6b3ca8d7e1a" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitXor&lt;/code&gt; that lifts &lt;code&gt;^&lt;/code&gt; to a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; を &lt;code&gt;bool&lt;/code&gt; のラッパーに引き上げる &lt;code&gt;BitXor&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="65cb4db18d08218407844613de42d9029080f521" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitXor&lt;/code&gt; trait for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; ラッパー用の &lt;code&gt;BitXor&lt;/code&gt; トレイトの実装。</target>
        </trans-unit>
        <trans-unit id="b5b904d460aff616075d9ff33295d995d4012b99" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Neg&lt;/code&gt; for &lt;code&gt;Sign&lt;/code&gt;, which allows the use of &lt;code&gt;-&lt;/code&gt; to negate its value.</source>
          <target state="translated">&lt;code&gt;Neg&lt;/code&gt; for &lt;code&gt;Sign&lt;/code&gt; の実装。これにより、 &lt;code&gt;-&lt;/code&gt; を使用してその値を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="873b42d4cd981f821fbfc718a707b146669b45da" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Not&lt;/code&gt; for &lt;code&gt;Answer&lt;/code&gt;, which enables the use of &lt;code&gt;!&lt;/code&gt; to invert its value.</source>
          <target state="translated">&lt;code&gt;Not&lt;/code&gt; for &lt;code&gt;Answer&lt;/code&gt; の実装。これにより、 &lt;code&gt;!&lt;/code&gt; その値を反転します。</target>
        </trans-unit>
        <trans-unit id="b6ef2365698efd5099fd68eb5d996513953b40b7" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shl&lt;/code&gt; that lifts the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operation on integers to a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;Shl&lt;/code&gt; リフト &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ラッパーに整数に対する操作を &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e679f132f9bdc673ab7525c566b308cef626454" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shl&lt;/code&gt; that spins a vector leftward by a given amount.</source>
          <target state="translated">指定された量だけベクトルを左にスピンする &lt;code&gt;Shl&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="4b9ea2f9d110fb7b7d2e508e8eb895f2a6c76af4" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;ShlAssign&lt;/code&gt; for a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;ShlAssign&lt;/code&gt; ラッパーのため &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdc99f650e402a714069613aef9bb0ab1a03fe00" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shr&lt;/code&gt; that lifts the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operation on integers to a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;Shr&lt;/code&gt; リフト &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ラッパーに整数に対する操作を &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00b6c1f0f935bcc3f078a1d4c1fb779815701d8c" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shr&lt;/code&gt; that spins a vector rightward by a given amount.</source>
          <target state="translated">指定された量だけベクトルを右にスピンする &lt;code&gt;Shr&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="fef3f9c26a074ccf18bb7e56e8695a2a73f26459" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;ShrAssign&lt;/code&gt; for a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;ShrAssign&lt;/code&gt; ラッパーのため &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0109084bf6e2896150bb542f8a8637f2cff32f1" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;poll&lt;/code&gt; should strive to return quickly, and should not block. Returning quickly prevents unnecessarily clogging up threads or event loops. If it is known ahead of time that a call to &lt;code&gt;poll&lt;/code&gt; may end up taking awhile, the work should be offloaded to a thread pool (or something similar) to ensure that &lt;code&gt;poll&lt;/code&gt; can return quickly.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; の実装は、迅速に戻るよう努めるべきであり、妨害してはなりません。すばやく戻ることで、スレッドやイベントループが不必要に詰まるのを防ぎます。 &lt;code&gt;poll&lt;/code&gt; 呼び出しに時間がかかることが事前にわかっている場合は、 &lt;code&gt;poll&lt;/code&gt; を迅速に返すことができるように、作業をスレッドプール（または類似のもの）にオフロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="350059cec8495b6fd084c91dd06a8c1a8c6277a2" translate="yes" xml:space="preserve">
          <source>An implementation of SipHash 2-4.</source>
          <target state="translated">SipHash 2-4の実装。</target>
        </trans-unit>
        <trans-unit id="a7c410f2271131f6e26f4c1a6c01fb2def54994c" translate="yes" xml:space="preserve">
          <source>An import was unresolved.</source>
          <target state="translated">インポートが解決されませんでした。</target>
        </trans-unit>
        <trans-unit id="29610251a6990ca267c18a3b17be65ef65d80c1f" translate="yes" xml:space="preserve">
          <source>An important part of the process of learning Rust is learning how to read the error messages the compiler displays: these will guide you toward working code. As such, we&amp;rsquo;ll provide many examples that don&amp;rsquo;t compile along with the error message the compiler will show you in each situation. Know that if you enter and run a random example, it may not compile! Make sure you read the surrounding text to see whether the example you&amp;rsquo;re trying to run is meant to error. Ferris will also help you distinguish code that isn&amp;rsquo;t meant to work:</source>
          <target state="translated">Rustを学習するプロセスの重要な部分は、コンパイラが表示するエラーメッセージの読み方を学ぶことです。これらは、コードを機能させるためのガイドになります。そのため、コンパイルできない多くの例と、コンパイラがそれぞれの状況で表示するエラーメッセージを提供します。ランダムな例を入力して実行すると、コンパイルされない可能性があることに注意してください。周囲のテキストを読んで、実行しようとしている例がエラーを意味するものかどうかを確認してください。Ferrisは、機能しないコードを区別するのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="9068331ccd5e98287382db124205efdfb79f7cfb" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that the type &lt;code&gt;fmt::Error&lt;/code&gt; should not be confused with &lt;a href=&quot;../io/struct.error&quot;&gt;&lt;code&gt;std::io::Error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;std::error::Error&lt;/code&gt;&lt;/a&gt;, which you may also have in scope.</source>
          <target state="translated">覚えておくべき重要なことは、タイプ &lt;code&gt;fmt::Error&lt;/code&gt; を&lt;a href=&quot;../io/struct.error&quot;&gt; &lt;code&gt;std::io::Error&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../error/trait.error&quot;&gt; &lt;code&gt;std::error::Error&lt;/code&gt; &lt;/a&gt;と混同しないでください。これらもスコープ内にある可能性があります。</target>
        </trans-unit>
        <trans-unit id="8f9e81cf6c354fdfd3e66804e1f412009da97856" translate="yes" xml:space="preserve">
          <source>An inclusive bound.</source>
          <target state="translated">インクルーシブバインド。</target>
        </trans-unit>
        <trans-unit id="192433a73b5ee226652b56c2bf60e3939daf0558" translate="yes" xml:space="preserve">
          <source>An inclusive range needs an end in order to &lt;em&gt;include&lt;/em&gt; it. If you just need a start and no end, use a non-inclusive range (with &lt;code&gt;..&lt;/code&gt;):</source>
          <target state="translated">包含範囲に&lt;em&gt;は、&lt;/em&gt;それを&lt;em&gt;含める&lt;/em&gt;ために終了が必要です。開始のみで終了なしが必要な場合は、（ &lt;code&gt;..&lt;/code&gt; で）非包含範囲を使用します。</target>
        </trans-unit>
        <trans-unit id="50920c083a024a331ce9d74584285d9788301b90" translate="yes" xml:space="preserve">
          <source>An inclusive range was used with no end.</source>
          <target state="translated">インクルーシブな範囲をエンドレスで使用していました。</target>
        </trans-unit>
        <trans-unit id="387b0473c559329b38860546da1e2cce85651e8f" translate="yes" xml:space="preserve">
          <source>An incompatible cast was attempted.</source>
          <target state="translated">相性の悪いキャストが試みられた。</target>
        </trans-unit>
        <trans-unit id="c9900f693c2e1b5744366ed3318b36a718fcf770" translate="yes" xml:space="preserve">
          <source>An infinite endpoint. Indicates that there is no bound in this direction.</source>
          <target state="translated">無限の終点。この方向に境界がないことを示す。</target>
        </trans-unit>
        <trans-unit id="f2f7f4bb84396a832ec236ff6b02e7c811f6141c" translate="yes" xml:space="preserve">
          <source>An inherent implementation is defined as the sequence of the &lt;code&gt;impl&lt;/code&gt; keyword, generic type declarations, a path to a nominal type, a where clause, and a bracketed set of associable items.</source>
          <target state="translated">固有の実装は、 &lt;code&gt;impl&lt;/code&gt; キーワードのシーケンス、ジェネリック型宣言、名義型へのパス、where句、および関連付けられた一連の関連付けられた項目として定義されます。</target>
        </trans-unit>
        <trans-unit id="eaca7587ab66134ebcc5c9d98dddc7a6d1b623fb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;DirEntry&lt;/code&gt; represents an entry inside of a directory on the filesystem. Each entry can be inspected via methods to learn about the full path or possibly other metadata through per-platform extension traits.</source>
          <target state="translated">&lt;code&gt;DirEntry&lt;/code&gt; のインスタンスは、ファイルシステム上のディレクトリ内のエントリを表します。各エントリをメソッドで検査して、プラットフォームごとの拡張機能の特性を介して、フルパスまたは場合によっては他のメタデータについて知ることができます。</target>
        </trans-unit>
        <trans-unit id="1fbc585e6de8e6bcaf356cf9f8023d57041f924e" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Layout&lt;/code&gt; describes a particular layout of memory. You build a &lt;code&gt;Layout&lt;/code&gt; up as an input to give to an allocator.</source>
          <target state="translated">&lt;code&gt;Layout&lt;/code&gt; のインスタンスは、メモリの特定のレイアウトを記述します。アロケーターに与える入力として &lt;code&gt;Layout&lt;/code&gt; 作成します。</target>
        </trans-unit>
        <trans-unit id="b190fdcf2cbfcbc1313cacaba62570eb78c828a4" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;code&gt;File&lt;/code&gt; can be read and/or written depending on what options it was opened with. Files also implement &lt;a href=&quot;../io/trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; to alter the logical cursor that the file contains internally.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; のインスタンスは、それを開いたときのオプションに応じて、読み取りまたは書き込み、あるいはその両方を行うことができます。ファイルは、ファイルに内部に含まれている論理カーソルを変更するための&lt;a href=&quot;../io/trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;も実装します。</target>
        </trans-unit>
        <trans-unit id="f4459da0411b29eac8078029351bbb76f00d3282" translate="yes" xml:space="preserve">
          <source>An integer &lt;code&gt;.N&lt;/code&gt;:</source>
          <target state="translated">整数 &lt;code&gt;.N&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="908da2eafc06fe6ced0bd1b3ca560bd9a2e72aa4" translate="yes" xml:space="preserve">
          <source>An integer or name followed by dollar sign &lt;code&gt;.N$&lt;/code&gt;:</source>
          <target state="translated">整数または名前とそれに続くドル記号 &lt;code&gt;.N$&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d652b1aec455b9a1399356989d1b6e7890b6c2cf" translate="yes" xml:space="preserve">
          <source>An integer that is known not to equal zero.</source>
          <target state="translated">ゼロと等しくないことがわかっている整数。</target>
        </trans-unit>
        <trans-unit id="23e972eabcd349c601672f385dadf7a600ee560a" translate="yes" xml:space="preserve">
          <source>An integer type which can be safely shared between threads.</source>
          <target state="translated">スレッド間で安全に共有できる整数型。</target>
        </trans-unit>
        <trans-unit id="7738cea88357f8684a294b13f985119f27bc796a" translate="yes" xml:space="preserve">
          <source>An intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout</source>
          <target state="translated">ユーザーがワークアウトを要求する際に指定する強度番号で、低強度のワークアウトか高強度のワークアウトのどちらを希望するかを示すために使用します。</target>
        </trans-unit>
        <trans-unit id="ff8d693a0bfcced7e1e8e51c1bf01052178e048b" translate="yes" xml:space="preserve">
          <source>An interface for dealing with iterators.</source>
          <target state="translated">イテレータを扱うためのインターフェイス。</target>
        </trans-unit>
        <trans-unit id="22e5648e52f9b0472e117269511bde8fb3cbbf6f" translate="yes" xml:space="preserve">
          <source>An internet socket address, either IPv4 or IPv6.</source>
          <target state="translated">IPv4 または IPv6 のいずれかのインターネットソケットアドレス。</target>
        </trans-unit>
        <trans-unit id="854d43a414a4b60a4e76077619d9f002787508df" translate="yes" xml:space="preserve">
          <source>An intrinsic is a function available for use in a given programming language whose implementation is handled specially by the compiler. In order to fix this error, just declare a function.</source>
          <target state="translated">内部関数とは、指定されたプログラミング言語で使用可能な関数のことで、その実装はコンパイラによって特別に処理されます。このエラーを修正するには、関数を宣言するだけです。</target>
        </trans-unit>
        <trans-unit id="d4ed3f185066b7aaf4eec2eeca59086039ee692c" translate="yes" xml:space="preserve">
          <source>An intrinsic was declared without being a function.</source>
          <target state="translated">関数ではなく、本質的なものが宣言されていました。</target>
        </trans-unit>
        <trans-unit id="4c83eebd7c224b0a142aede3c5ec04a66d472405" translate="yes" xml:space="preserve">
          <source>An invalid &lt;code&gt;self&lt;/code&gt; import was made.</source>
          <target state="translated">無効な &lt;code&gt;self&lt;/code&gt; インポートが行われました。</target>
        </trans-unit>
        <trans-unit id="82555301e5ea450f3a2a3340087105706f32de3a" translate="yes" xml:space="preserve">
          <source>An invalid cast was attempted.</source>
          <target state="translated">無効なキャストが試みられました。</target>
        </trans-unit>
        <trans-unit id="b45ca9e360736d39967051ef73e9a974697dc538" translate="yes" xml:space="preserve">
          <source>An invalid lint attribute has been given. Erroneous code example:</source>
          <target state="translated">無効な lint 属性が指定されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="a410192aae8c1c9efe2c778af8302870ee71f57b" translate="yes" xml:space="preserve">
          <source>An item usage is ambiguous.</source>
          <target state="translated">項目の使い方が曖昧です。</target>
        </trans-unit>
        <trans-unit id="b44509fac7828279e76e0b5a94ab5171cb157956" translate="yes" xml:space="preserve">
          <source>An iterator able to yield elements from both ends.</source>
          <target state="translated">両端から要素を生成できるイテレータ。</target>
        </trans-unit>
        <trans-unit id="a79f20c0e35d15b48bb2797970d35b63c3629a31" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator.</source>
          <target state="translated">内部状態を保持し、新しいイテレーターを生成する、&lt;a href=&quot;#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; に&lt;/a&gt;似たイテレーターアダプター。</target>
        </trans-unit>
        <trans-unit id="4f7d60e521538ea62f876d5c70c545dc3addec69" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;fold&lt;/code&gt; ]に類似した、内部状態を保持して新しいイテレーターを生成するイテレーターアダプター。&lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a650dc159a2fda49c7766be96685d0f790f13a0" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;fold&lt;/code&gt; ]に類似した、内部状態を保持して新しいイテレーターを生成するイテレーターアダプター。&lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e898bdaf274bb7754df65ccfb97b6bd04568d2d" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;fold&lt;/code&gt; ]に類似した、内部状態を保持して新しいイテレーターを生成するイテレーターアダプター。&lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2996431c0507a4a842fe331c88d08e4bb45dcce" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;fold&lt;/code&gt; ]に類似した、内部状態を保持して新しいイテレーターを生成するイテレーターアダプター。&lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae7a2ef58596a8f574790d9946d5c7b0d3e0427f" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;fold&lt;/code&gt; ]に類似した、内部状態を保持して新しいイテレーターを生成するイテレーターアダプター。&lt;a href=&quot;trait.iterator#method.scan&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ad9db34c1f6ac7b97514886d275ac1277b33c65" translate="yes" xml:space="preserve">
          <source>An iterator for stepping iterators by a custom amount.</source>
          <target state="translated">カスタム量でステッピングするためのイテレータ。</target>
        </trans-unit>
        <trans-unit id="fb45f260d1289d4ddcd0c03f93e3cf026ce37b59" translate="yes" xml:space="preserve">
          <source>An iterator has a method, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, which when called, returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt;. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;Some(Item)&lt;/code&gt; as long as there are elements, and once they've all been exhausted, will return &lt;code&gt;None&lt;/code&gt; to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; again may or may not eventually start returning &lt;code&gt;Some(Item)&lt;/code&gt; again at some point.</source>
          <target state="translated">イテレータにはメソッド&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;があり、呼び出されると&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt; を返します。&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;は、要素が存在する限り、 &lt;code&gt;Some(Item)&lt;/code&gt; を返します。要素がすべて使い果たされると、 &lt;code&gt;None&lt;/code&gt; を返し、反復が終了したことを示します。個々のイテレータは反復を再開することを選択する場合があるため、&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; を&lt;/a&gt;再度呼び出すと、ある時点で最終的に &lt;code&gt;Some(Item)&lt;/code&gt; が返されるようになる場合とそうでない場合があります。</target>
        </trans-unit>
        <trans-unit id="e31522f53dadc02b86f505f8fd01b611f6643e8b" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.</source>
          <target state="translated">イテレータ内の各項目にフォールリブル関数を適用し、最初のエラーで停止してそのエラーを返すイテレータメソッド。</target>
        </trans-unit>
        <trans-unit id="eacb362cba384eacfe624626c78db089eba4406f" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../../../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの各項目に誤りのある関数を適用し、最初のエラーで停止してそのエラーを返すイテレータメソッド。&lt;a href=&quot;../../../iter/trait.iterator#method.try_for_each&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca00c28d4b5a3134e86a3f660b2fa54093267401" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの各項目に誤りのある関数を適用し、最初のエラーで停止してそのエラーを返すイテレータメソッド。&lt;a href=&quot;../../iter/trait.iterator#method.try_for_each&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1489bd41c8525121e45484ed737c4171e974de0" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの各項目に誤りのある関数を適用し、最初のエラーで停止してそのエラーを返すイテレータメソッド。&lt;a href=&quot;../iter/trait.iterator#method.try_for_each&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33c934134cacb66bd994968f86b620a631318b91" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの各項目に誤りのある関数を適用し、最初のエラーで停止してそのエラーを返すイテレータメソッド。&lt;a href=&quot;iter/trait.iterator#method.try_for_each&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19bfdbf913f10e6bc3776600b92d9135c032b4bf" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの各項目に誤りのある関数を適用し、最初のエラーで停止してそのエラーを返すイテレータメソッド。&lt;a href=&quot;trait.iterator#method.try_for_each&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b59c2e3f2042ddc5a53ef66ef4d7b79f1fb5301" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value.</source>
          <target state="translated">関数が正常に返される限り関数を適用し、1 つの最終的な値を生成するイテレータメソッド。</target>
        </trans-unit>
        <trans-unit id="117fd8070a23ba82f744d90c448b1e5813b4d282" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../../../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数が正常に終了する限り関数を適用し、単一の最終値を生成する反復子メソッド。&lt;a href=&quot;../../../iter/trait.iterator#method.try_fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ee1c8bd3a25e2ebef94ba8c0d6405c27ca7226b" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数が正常に終了する限り関数を適用し、単一の最終値を生成する反復子メソッド。&lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c658b3e624db269551bf93242408ef5c42e5fea9" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数が正常に終了する限り関数を適用し、単一の最終値を生成する反復子メソッド。&lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a5362af3855236bb52258529c3514119a249eab" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数が正常に終了する限り関数を適用し、単一の最終値を生成する反復子メソッド。&lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="22eb23eabd6f5888b0f6233654a7d6b3279d1ac7" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数が正常に終了する限り関数を適用し、単一の最終値を生成する反復子メソッド。&lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d551693bdcaedeac0547d596669a3c5c5179447" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value.</source>
          <target state="translated">関数を適用し、単一の最終値を生成するイテレータメソッド。</target>
        </trans-unit>
        <trans-unit id="31400216ecaba12666aff645bec4ca26c5ba43ea" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数を適用して単一の最終値を生成する反復子メソッド。&lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="958c160388552a918125f55bba9e086f54f71484" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数を適用して単一の最終値を生成する反復子メソッド。&lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5eddc2fc826e92b735803187068d19d4e441542e" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数を適用して単一の最終値を生成する反復子メソッド。&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062b8bbee99bc123d00bd6ddb37a2091ecaee57f" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数を適用して単一の最終値を生成する反復子メソッド。&lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="760ff7a591ac95e16cd7be5b9667ba1c820bc96e" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">関数を適用して単一の最終値を生成する反復子メソッド。&lt;a href=&quot;trait.iterator#method.fold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4cfaa2271cf9f33fe50ead23cff9cf9b29c2c97" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back.</source>
          <target state="translated">イテレータの要素を、後ろから始まる単一の最終的な値に縮小するイテレータメソッド。</target>
        </trans-unit>
        <trans-unit id="c9c712bf49f750f238c96785e7e704d976a72f0e" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">反復子の要素を後ろから開始して単一の最終値に減らす反復子メソッド。&lt;a href=&quot;../../iter/trait.doubleendediterator#method.rfold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b44201682fdbcad5c8da77522b47e4b7fc4a3dc1" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;../iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">反復子の要素を後ろから開始して単一の最終値に減らす反復子メソッド。&lt;a href=&quot;../iter/trait.doubleendediterator#method.rfold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc53bae551d78289c9703ed2a397d1c3b35f285e" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">反復子の要素を後ろから開始して単一の最終値に減らす反復子メソッド。&lt;a href=&quot;iter/trait.doubleendediterator#method.rfold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="836f4f2e3fffc61e14c382d8890f27b7a367beeb" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">反復子の要素を後ろから開始して単一の最終値に減らす反復子メソッド。&lt;a href=&quot;trait.doubleendediterator#method.rfold&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2acafc012d5ccce6e7696757b55337a6d4029a3" translate="yes" xml:space="preserve">
          <source>An iterator of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt; over the string encoded as UTF-16.</source>
          <target state="translated">UTF-16としてエンコードされた文字列に対する&lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;のイテレータ。</target>
        </trans-unit>
        <trans-unit id="143fd7db785baccd8bb8346c04f451192a09006a" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and its ancestors.</source>
          <target state="translated">&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;とその祖先に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="554dfaab9d83066a6b95354b7620556448cb3449" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;a href=&quot;trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;に対するイテレータ</target>
        </trans-unit>
        <trans-unit id="aef63e9607a8ec1f5f596fca15621080fd76af72" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;code&gt;u8&lt;/code&gt; values of a reader.</source>
          <target state="translated">リーダーの &lt;code&gt;u8&lt;/code&gt; 値に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="34e3362281b15b977d0a61ac8c5fcd00a6511c9c" translate="yes" xml:space="preserve">
          <source>An iterator over a mutable reference to the &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;バリアントへの変更可能な参照に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="c74c624cf35ae570735e4b7f11b57db582409878" translate="yes" xml:space="preserve">
          <source>An iterator over a mutable reference to the &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;バリアントへの変更可能な参照に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="f4de84f3b1b68ec9fb8cadcc939ec573f412a94a" translate="yes" xml:space="preserve">
          <source>An iterator over a reference to the &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;バリアントへの参照に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="8cd69f81931caab64a8dceae843c42a8b1faa3e1" translate="yes" xml:space="preserve">
          <source>An iterator over a reference to the &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;バリアントへの参照に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="6d2aa423fb037ba3e42490b4a4869e7a989a8b38" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">（重複しない）チャンク（一度に &lt;code&gt;chunk_size&lt;/code&gt; 要素）内のスライスの反復子。スライスの先頭から開始します。</target>
        </trans-unit>
        <trans-unit id="51ba4c3e078709e91115e94720e3b32e5a3519a2" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the end of the slice.</source>
          <target state="translated">（重複しない）チャンク（一度に &lt;code&gt;chunk_size&lt;/code&gt; 要素）内のスライスの反復子。スライスの最後から開始します。</target>
        </trans-unit>
        <trans-unit id="b727a794715c05c6c1c0cd0cd6149d40bd7c3a04" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">（重複しない）可変チャンク（一度に &lt;code&gt;chunk_size&lt;/code&gt; 要素）内のスライスの反復子。スライスの先頭から開始します。</target>
        </trans-unit>
        <trans-unit id="590e04be01e914183b27d18dc8eff4e3ae5668f0" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the end of the slice.</source>
          <target state="translated">（重複しない）可変チャンク（一度に &lt;code&gt;chunk_size&lt;/code&gt; 要素）内のスライスの反復子。スライスの最後から開始します。</target>
        </trans-unit>
        <trans-unit id="68ad6606a48079fe489aab3faf8c6e3a26b992ca" translate="yes" xml:space="preserve">
          <source>An iterator over a snapshot of the environment variables of this process.</source>
          <target state="translated">このプロセスの環境変数のスナップショット上のイテレータ。</target>
        </trans-unit>
        <trans-unit id="a94e3f24bb1eb1ba2fd58ebddc9b4d9dba8309a8" translate="yes" xml:space="preserve">
          <source>An iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリのサブ範囲のイテレータ。</target>
        </trans-unit>
        <trans-unit id="d03569c5a9963027ad22996c9e0b70fb1554a87f" translate="yes" xml:space="preserve">
          <source>An iterator over a sub-range of items in a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 内のアイテムのサブ範囲の反復子。</target>
        </trans-unit>
        <trans-unit id="f19c5dd669fe6f36f81a65798f7219d0079a694d" translate="yes" xml:space="preserve">
          <source>An iterator over incoming connections to a &lt;a href=&quot;struct.unixlistener&quot;&gt;&lt;code&gt;UnixListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.unixlistener&quot;&gt; &lt;code&gt;UnixListener&lt;/code&gt; &lt;/a&gt;への着信接続に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="4d7488e2fccb6b43b42e67c9ea07cad9428b393b" translate="yes" xml:space="preserve">
          <source>An iterator over messages on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;a href=&quot;struct.receiver#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.receiver#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;によって作成された、&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;上のメッセージに対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="034a20701e995ae32aa63104e2d5dff0ab5db4e6" translate="yes" xml:space="preserve">
          <source>An iterator over overlapping subslices of length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">長さ &lt;code&gt;size&lt;/code&gt; の重複するサブスライスに対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="ba3bd9fb0e96735ece0b2069d478b585f0d8e7fe" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.</source>
          <target state="translated">述語関数にマッチする要素で区切られたサブスライスを対象としたイテレータ.</target>
        </trans-unit>
        <trans-unit id="24b57b67d67808582aa0647134f85aea733abfd0" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.</source>
          <target state="translated">述語関数にマッチする要素で区切られたサブスライスのイテレータ。</target>
        </trans-unit>
        <trans-unit id="7f751853b227571562b0215c1381b97b30029d0a" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.</source>
          <target state="translated">述語関数にマッチする要素で区切られたサブスライスのイテレータ。</target>
        </trans-unit>
        <trans-unit id="6a41aa74d34fd0ce2985da917544c4f35cf020f9" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function.</source>
          <target state="translated">述語関数にマッチする要素で区切られたサブスライス上のイテレータ。</target>
        </trans-unit>
        <trans-unit id="e1f02e8fb3b3f7adf4ed8a711ed0b9c2ca4cda3e" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of &lt;code&gt;self&lt;/code&gt;, separated by characters matched by a pattern and yielded in reverse order.</source>
          <target state="translated">パターンに一致する文字で区切られ、逆の順序で生成される、 &lt;code&gt;self&lt;/code&gt; の部分文字列の反復子。</target>
        </trans-unit>
        <trans-unit id="61c715ce9520941f9108744caef70fb9d86c6529" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">パターンで区切られた、指定された文字列スライスの部分文字列の反復子。最大 &lt;code&gt;n&lt;/code&gt; 個のアイテムを返すように制限されています。</target>
        </trans-unit>
        <trans-unit id="44ffc34ab178359db4b3169f249d963fd153689b" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</source>
          <target state="translated">与えられた文字列スライスの部分文字列を、パターンにマッチした文字で区切って逆順に並べるイテレータ。</target>
        </trans-unit>
        <trans-unit id="f65e61a07278abe6a5b629cd21c031c73243b0de" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</source>
          <target state="translated">指定された文字列スライスの部分文字列を、パターンにマッチした文字で区切ってイテレータします。</target>
        </trans-unit>
        <trans-unit id="537813cfc78da0abdca4b435c9341ecf42939302" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">文字列の末尾から開始してパターンで区切られた、この文字列スライスの部分文字列の反復子。最大 &lt;code&gt;n&lt;/code&gt; 個のアイテムを返すように制限されています。</target>
        </trans-unit>
        <trans-unit id="02d9a6b83a0665db88c523e6eaff227f1f6e5ae9" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by characters matched by a pattern.</source>
          <target state="translated">パターンにマッチした文字で区切られた、この文字列スライスの部分文字列に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="0ef8a4c9f98576b84451f0afffc7c456b9562b40" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s of a string slice, and their positions.</source>
          <target state="translated">文字列スライスの&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;とその位置の反復子。</target>
        </trans-unit>
        <trans-unit id="6dbafa08f3b2b12e80351b71ca200a8528053590" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s of a string slice.</source>
          <target state="translated">文字列スライスの&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;のイテレータ。</target>
        </trans-unit>
        <trans-unit id="94f1d147d9aa55e9343a89220481dd294b3c1ca7" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;s of a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slices.</source>
          <target state="translated">&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;スライスとしての&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt;の反復子。</target>
        </trans-unit>
        <trans-unit id="81b7c7eac770fb32d5f49a8fa6788046e188a635" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;s of a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt;のイテレータ。</target>
        </trans-unit>
        <trans-unit id="0046da9ead2fd2c36a6a2fa82a2d2ece3e53ebf5" translate="yes" xml:space="preserve">
          <source>An iterator over the arguments of a process, yielding a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; value for each argument.</source>
          <target state="translated">プロセスの引数の反復子。各引数の&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;値を生成します。</target>
        </trans-unit>
        <trans-unit id="ebb5d1c5d63504b0108ad325cad0bf7d2676c9ed" translate="yes" xml:space="preserve">
          <source>An iterator over the arguments of a process, yielding an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; value for each argument.</source>
          <target state="translated">プロセスの引数に対するイテレータ。各引数の&lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;値を生成します。</target>
        </trans-unit>
        <trans-unit id="db156c74a7f7733ec8d2fb32dcfb0fa41d392992" translate="yes" xml:space="preserve">
          <source>An iterator over the bytes of a string slice.</source>
          <target state="translated">文字列スライスのバイトに対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="e870ff1a2a9d31100b2ac9cb6ffbae140349bbde" translate="yes" xml:space="preserve">
          <source>An iterator over the contents of an instance of &lt;code&gt;BufRead&lt;/code&gt; split on a particular byte.</source>
          <target state="translated">特定のバイトで分割された &lt;code&gt;BufRead&lt;/code&gt; のインスタンスの内容に対する反復子。</target>
        </trans-unit>
        <trans-unit id="df77d35e2c4e122e560661a4bc012ddb30bf89c7" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within &lt;code&gt;self&lt;/code&gt;, yielded in reverse order along with the index of the match.</source>
          <target state="translated">一致のインデックスとともに逆の順序で生成された、 &lt;code&gt;self&lt;/code&gt; 内のパターンの素の一致に対する反復子。</target>
        </trans-unit>
        <trans-unit id="f7d549ea470a7ac3f5b7f05549ca71296a3cf479" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within the given string slice.</source>
          <target state="translated">与えられた文字列スライス内のパターンの不連続マッチに対するイテレータ.</target>
        </trans-unit>
        <trans-unit id="4e8c4e320605a2ab4ab8ef1e11e40919b14ac665" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</source>
          <target state="translated">この文字列スライス内のパターンの不連続マッチとマッチの開始位置のインデックスのイテレータ。</target>
        </trans-unit>
        <trans-unit id="bf644211cc86eb9babefe771489adf416b34d943" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.</source>
          <target state="translated">この文字列スライス内のパターンの不連続マッチを逆順に処理するイテレータです。</target>
        </trans-unit>
        <trans-unit id="a4b7288e219c65d73a3e6a54b4428c628926ca26" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; の要素に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="60a4b99de7b2aa615fb862b4ef6662bf265a07b3" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; の要素の反復子。</target>
        </trans-unit>
        <trans-unit id="2f97f18a1c5aa5746176c6f51c4eafd84be2fce3" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の要素のイテレータ。</target>
        </trans-unit>
        <trans-unit id="91db6e4ce90dbed18c33044e96c535db60789527" translate="yes" xml:space="preserve">
          <source>An iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリに対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="89075f098d105168914ad089684eab6ab82bd15c" translate="yes" xml:space="preserve">
          <source>An iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="6598ccbf021650c51246c68845640e9702eed23d" translate="yes" xml:space="preserve">
          <source>An iterator over the escaped version of a byte.</source>
          <target state="translated">バイトのエスケープされたバージョンのイテレータ。</target>
        </trans-unit>
        <trans-unit id="56eb86799cc14570dbdb72543cfaf21c05c1abe2" translate="yes" xml:space="preserve">
          <source>An iterator over the items of a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の項目のイテレータ。</target>
        </trans-unit>
        <trans-unit id="d5fd2e8685f9eef9092473bf82703d995770cb96" translate="yes" xml:space="preserve">
          <source>An iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; のアイテムのイテレータ。</target>
        </trans-unit>
        <trans-unit id="c8ce67dcd74b8165190d1c5586f09c2e5112934e" translate="yes" xml:space="preserve">
          <source>An iterator over the keys of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のキーのイテレータ。</target>
        </trans-unit>
        <trans-unit id="6ab13d3c24ccbf1b667994220cf1ff47151b518f" translate="yes" xml:space="preserve">
          <source>An iterator over the keys of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のキーに対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="bdb3c68f21440272514f422ef05c2d524b30604a" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of a string, as string slices.</source>
          <target state="translated">文字列の行を文字列スライスとして扱うイテレータ。</target>
        </trans-unit>
        <trans-unit id="47a35066a39c1ed7b30ce9f4878b660c0a1e7474" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of a string.</source>
          <target state="translated">文字列の行の上のイテレータ。</target>
        </trans-unit>
        <trans-unit id="4cce7f5b74c3be64996357d548c448d7d2f4462a" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of an instance of &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BufRead&lt;/code&gt; のインスタンスの行に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="a3ce41435c2e05d485713b80e3d67f84041531ab" translate="yes" xml:space="preserve">
          <source>An iterator over the non-ASCII-whitespace substrings of a string, separated by any amount of ASCII whitespace.</source>
          <target state="translated">文字列の非ASCII空白の部分文字列を、任意の量のASCII空白で区切ってイテレータします。</target>
        </trans-unit>
        <trans-unit id="98639edcf075ef0bbd56694e6fd8f3ab5801fa3b" translate="yes" xml:space="preserve">
          <source>An iterator over the non-whitespace substrings of a string, separated by any amount of whitespace.</source>
          <target state="translated">文字列の空白以外の部分文字列を、任意の量の空白で区切ってイテレータします。</target>
        </trans-unit>
        <trans-unit id="f6d3a015ca8e0813b9d2a570221365ce0bb7b9f3" translate="yes" xml:space="preserve">
          <source>An iterator over the subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;, starting from the end of the slice.</source>
          <target state="translated">スライスの最後から開始して、 &lt;code&gt;pred&lt;/code&gt; に一致する要素で区切られたベクトルのサブスライスの反復子。</target>
        </trans-unit>
        <trans-unit id="82456e1206b372bf7ea9d2f45cb440546d002943" translate="yes" xml:space="preserve">
          <source>An iterator over the subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; に一致する要素で区切られたベクトルのサブスライスの反復子。</target>
        </trans-unit>
        <trans-unit id="551626c835c28af1e23d1b77fa736e5fca587fd5" translate="yes" xml:space="preserve">
          <source>An iterator over the value in &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;バリアントの値に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="2ad0a62fd20b029d94f3ea06e170d6042fc65d39" translate="yes" xml:space="preserve">
          <source>An iterator over the value in a &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;バリアントの値に対するイテレータ。</target>
        </trans-unit>
        <trans-unit id="06914df7e2feff75ffe46782ed50136c93cfaa1b" translate="yes" xml:space="preserve">
          <source>An iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; の値のイテレータ。</target>
        </trans-unit>
        <trans-unit id="25879aa8de242e212254e6f312a25f5c0bfcd32b" translate="yes" xml:space="preserve">
          <source>An iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の値の反復子。</target>
        </trans-unit>
        <trans-unit id="28ebf2a599d5ab4a921fbe241809a3d3600be3e5" translate="yes" xml:space="preserve">
          <source>An iterator produced by &lt;code&gt;repeat_with()&lt;/code&gt; is not a &lt;code&gt;DoubleEndedIterator&lt;/code&gt;. If you need &lt;code&gt;repeat_with()&lt;/code&gt; to return a &lt;code&gt;DoubleEndedIterator&lt;/code&gt;, please open a GitHub issue explaining your use case.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; によって生成された反復子は &lt;code&gt;DoubleEndedIterator&lt;/code&gt; ではありません。あなたが必要な場合 &lt;code&gt;repeat_with()&lt;/code&gt; を返すように &lt;code&gt;DoubleEndedIterator&lt;/code&gt; を、あなたのユースケースを説明するGitHubの問題を開いてください。</target>
        </trans-unit>
        <trans-unit id="c51b3a9a86a32de916b3441f5cc928b34139d94d" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on LinkedList.</source>
          <target state="translated">&lt;code&gt;drain_filter&lt;/code&gt; でdrain_filterを呼び出して作成された反復子。</target>
        </trans-unit>
        <trans-unit id="d90f64072c9b86fb5e160826e11d54a35519d306" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on Vec.</source>
          <target state="translated">Vecで &lt;code&gt;drain_filter&lt;/code&gt; を呼び出すことによって生成されるイテレータ。</target>
        </trans-unit>
        <trans-unit id="e2f38bdab7ee3f88662413a8d0762d07987cc9e4" translate="yes" xml:space="preserve">
          <source>An iterator that always continues to yield &lt;code&gt;None&lt;/code&gt; when exhausted.</source>
          <target state="translated">使い尽くされたときに常に &lt;code&gt;None&lt;/code&gt; を生成し続ける反復子。</target>
        </trans-unit>
        <trans-unit id="d75b48632d15091a831b75304f768ce72229865c" translate="yes" xml:space="preserve">
          <source>An iterator that attempts to yield all pending values for a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;a href=&quot;struct.receiver#method.try_iter&quot;&gt;&lt;code&gt;try_iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.receiver#method.try_iter&quot;&gt; &lt;code&gt;try_iter&lt;/code&gt; &lt;/a&gt;によって作成された、&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; の&lt;/a&gt;保留中のすべての値を生成しようとする反復子。</target>
        </trans-unit>
        <trans-unit id="0c0e45d489e23ad54f254e3c451b03c3ad3633b8" translate="yes" xml:space="preserve">
          <source>An iterator that calls a function with a reference to each element before yielding it.</source>
          <target state="translated">各要素を参照して関数を呼び出してからそれを返すイテレータ。</target>
        </trans-unit>
        <trans-unit id="51a9a929e3e766e1bc15473a2edf034711e9603a" translate="yes" xml:space="preserve">
          <source>An iterator that clones the elements of an underlying iterator.</source>
          <target state="translated">基礎となるイテレータの要素をクローンするイテレータ。</target>
        </trans-unit>
        <trans-unit id="d2287777325ba0f8a82eefc9f82886c5e6c0375c" translate="yes" xml:space="preserve">
          <source>An iterator that copies the elements of an underlying iterator.</source>
          <target state="translated">基礎となるイテレータの要素をコピーするイテレータ。</target>
        </trans-unit>
        <trans-unit id="11b5eb68a058f133076c97a53287f7350b19b4ed" translate="yes" xml:space="preserve">
          <source>An iterator that decodes UTF-16 encoded code points from an iterator of &lt;code&gt;u16&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;u16&lt;/code&gt; のイテレータからUTF-16エンコードされたコードポイントをデコードするイテレータ。</target>
        </trans-unit>
        <trans-unit id="a7c2f22f759edefd0c02e7989a0830d2b9927824" translate="yes" xml:space="preserve">
          <source>An iterator that filters the elements of &lt;code&gt;iter&lt;/code&gt; with &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; の要素を &lt;code&gt;predicate&lt;/code&gt; でフィルタリングするイテレータ。</target>
        </trans-unit>
        <trans-unit id="538c0bdbb5f2579b6454154f638e3b2235b91db1" translate="yes" xml:space="preserve">
          <source>An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.</source>
          <target state="translated">イテレータ化できるモノのイテレータで1レベルのネストをフラットにするイテレータ。</target>
        </trans-unit>
        <trans-unit id="9dbf52f6fb3a5236b83ac424b9036cbd60fd5a39" translate="yes" xml:space="preserve">
          <source>An iterator that infinitely &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;s connections on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; で&lt;/a&gt;の接続を無限に&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;イテレータ。</target>
        </trans-unit>
        <trans-unit id="81a5d4ccf76ade25979b7f90350112e1ade77257" translate="yes" xml:space="preserve">
          <source>An iterator that iterates two other iterators simultaneously.</source>
          <target state="translated">他の2つのイテレータを同時に反復処理するイテレータ。</target>
        </trans-unit>
        <trans-unit id="ca3c41a43b14bf4c961d798c07db548fe5c4306e" translate="yes" xml:space="preserve">
          <source>An iterator that knows its exact length.</source>
          <target state="translated">正確な長さを知っているイテレータ。</target>
        </trans-unit>
        <trans-unit id="fd413348f096597213f95708520a2a2ee8e8c6ff" translate="yes" xml:space="preserve">
          <source>An iterator that maps each element to an iterator, and yields the elements of the produced iterators.</source>
          <target state="translated">各要素をイテレータにマッピングし、生成されたイテレータの要素を生成するイテレータ。</target>
        </trans-unit>
        <trans-unit id="e00fb1707b378038f217f0122cb5c2c693a99ce9" translate="yes" xml:space="preserve">
          <source>An iterator that maps the values of &lt;code&gt;iter&lt;/code&gt; with &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; の値を &lt;code&gt;f&lt;/code&gt; でマップするイテレータ。</target>
        </trans-unit>
        <trans-unit id="c89c4d0277ad0dbe70fcef9f7526e1d26306d3c4" translate="yes" xml:space="preserve">
          <source>An iterator that moves out of a vector.</source>
          <target state="translated">ベクトルの外に移動するイテレータ。</target>
        </trans-unit>
        <trans-unit id="5d780c4556be41e5ade58ccb90a4cb9745c8a4a0" translate="yes" xml:space="preserve">
          <source>An iterator that only accepts elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返す間、要素のみを受け入れるイテレータ。</target>
        </trans-unit>
        <trans-unit id="ca756e17e11dd720fde75ad3acbb4dc61da5a0b9" translate="yes" xml:space="preserve">
          <source>An iterator that only iterates over the first &lt;code&gt;n&lt;/code&gt; iterations of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; の最初の &lt;code&gt;n&lt;/code&gt; 回の反復のみを反復する反復子。</target>
        </trans-unit>
        <trans-unit id="473994edf3f2b12636ecfbae9c0cf95e9976442a" translate="yes" xml:space="preserve">
          <source>An iterator that rejects elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返す間、要素を拒否する反復子。</target>
        </trans-unit>
        <trans-unit id="0464de53ba73fee454800ae2dd5fef9380113b90" translate="yes" xml:space="preserve">
          <source>An iterator that repeats an element endlessly.</source>
          <target state="translated">要素を無限に繰り返すイテレータ。</target>
        </trans-unit>
        <trans-unit id="7f0331c06c1f3247687712e4a8fa91faa255da79" translate="yes" xml:space="preserve">
          <source>An iterator that repeats elements of type &lt;code&gt;A&lt;/code&gt; endlessly by applying the provided closure &lt;code&gt;F: FnMut() -&amp;gt; A&lt;/code&gt;.</source>
          <target state="translated">提供されたクロージャー &lt;code&gt;F: FnMut() -&amp;gt; A&lt;/code&gt; 適用することにより、タイプ &lt;code&gt;A&lt;/code&gt; の要素を無限に繰り返すイテレーター。</target>
        </trans-unit>
        <trans-unit id="4f71391fe387efdecec312046c6dd55bbf198321" translate="yes" xml:space="preserve">
          <source>An iterator that repeats endlessly.</source>
          <target state="translated">無限に繰り返すイテレータ。</target>
        </trans-unit>
        <trans-unit id="905426af2dba7f51c454090a12d4200524fdd44c" translate="yes" xml:space="preserve">
          <source>An iterator that reports an accurate length using size_hint.</source>
          <target state="translated">size_hintを使用して正確な長さを報告するイテレータ。</target>
        </trans-unit>
        <trans-unit id="6e8e68927103c8756bd8e724310ac62f637e383b" translate="yes" xml:space="preserve">
          <source>An iterator that skips over &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; の &lt;code&gt;n&lt;/code&gt; 個の要素をスキップするイテレータ。</target>
        </trans-unit>
        <trans-unit id="cc8fdbf15929bf39a9148cd3ad1f02b7e2f3e8e1" translate="yes" xml:space="preserve">
          <source>An iterator that splits an environment variable into paths according to platform-specific conventions.</source>
          <target state="translated">プラットフォーム固有の規約に従って環境変数をパスに分割するイテレータ。</target>
        </trans-unit>
        <trans-unit id="57ccd12f7079988974d92028c7ca992c2e3dc8d6" translate="yes" xml:space="preserve">
          <source>An iterator that strings two iterators together.</source>
          <target state="translated">2つのイテレータを文字列化したイテレータ。</target>
        </trans-unit>
        <trans-unit id="277e34f21de2c1bcf08658ea7180ea41a724c7da" translate="yes" xml:space="preserve">
          <source>An iterator that uses &lt;code&gt;f&lt;/code&gt; to both filter and map elements from &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; を使用して、 &lt;code&gt;iter&lt;/code&gt; の要素をフィルタリングおよびマップするイテレーター。</target>
        </trans-unit>
        <trans-unit id="290a4df52520d8c2cd218b2c5a66207c17bd76b5" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;None&lt;/code&gt; forever after the underlying iterator yields &lt;code&gt;None&lt;/code&gt; once.</source>
          <target state="translated">基礎となるイテレーターが &lt;code&gt;None&lt;/code&gt; を 1回生成した後、 &lt;code&gt;None&lt;/code&gt; を永続的に生成するイテレーター。</target>
        </trans-unit>
        <trans-unit id="8077f46e4926a9ba2fe0c3a0111f99b3bfd0cee7" translate="yes" xml:space="preserve">
          <source>An iterator that yields a single element of type &lt;code&gt;A&lt;/code&gt; by applying the provided closure &lt;code&gt;F: FnOnce() -&amp;gt; A&lt;/code&gt;.</source>
          <target state="translated">提供されたクロージャー &lt;code&gt;F: FnOnce() -&amp;gt; A&lt;/code&gt; 適用してタイプ &lt;code&gt;A&lt;/code&gt; の単一の要素を生成するイテレーター。</target>
        </trans-unit>
        <trans-unit id="f74ed23fee03be7f9726d86e04759a8cdc7c98f8" translate="yes" xml:space="preserve">
          <source>An iterator that yields an element exactly once.</source>
          <target state="translated">要素を正確に一度だけ返すイテレータ。</target>
        </trans-unit>
        <trans-unit id="d839e72a6966bc49a09991c75f6ebb8c0f577f86" translate="yes" xml:space="preserve">
          <source>An iterator that yields nothing.</source>
          <target state="translated">何も得られないイテレータ。</target>
        </trans-unit>
        <trans-unit id="5c4e0833b181576427135eb9c8df2d3b1200509f" translate="yes" xml:space="preserve">
          <source>An iterator that yields the current count and the element during iteration.</source>
          <target state="translated">現在のカウントと反復中の要素を返すイテレータ。</target>
        </trans-unit>
        <trans-unit id="13cc9cc84ea0ac8db6860e2d362f3768df8c56c8" translate="yes" xml:space="preserve">
          <source>An iterator that yields the literal escape code of a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; のリテラルエスケープコードを生成するイテレータ。</target>
        </trans-unit>
        <trans-unit id="f37b0b305dd49cedb47e6f8dfa5f3a2bdad3bf67" translate="yes" xml:space="preserve">
          <source>An iterator to maintain state while iterating another iterator.</source>
          <target state="translated">別のイテレータを反復しながら状態を維持するイテレータ。</target>
        </trans-unit>
        <trans-unit id="47ba4cac2215dd1a04b338eb0e4a94df69cf3c0f" translate="yes" xml:space="preserve">
          <source>An iterator visiting all elements in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a T&lt;/code&gt;.</source>
          <target state="translated">すべての要素を任意の順序で訪問する反復子。イテレータ要素のタイプは &lt;code&gt;&amp;amp;'a T&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7550894b7d1bb85e45b801eaeed48efa989854c0" translate="yes" xml:space="preserve">
          <source>An iterator visiting all key-value pairs in arbitrary order, with mutable references to the values. The iterator element type is &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a mut V)&lt;/code&gt;.</source>
          <target state="translated">すべてのキーと値のペアを任意の順序で訪問し、値への可変参照を使用する反復子。イテレーター要素のタイプは &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a mut V)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1b08b2653f7dcb8dc940ed24069740a24ab5b76a" translate="yes" xml:space="preserve">
          <source>An iterator visiting all key-value pairs in arbitrary order. The iterator element type is &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a V)&lt;/code&gt;.</source>
          <target state="translated">すべてのキーと値のペアを任意の順序で訪問する反復子。イテレーター要素のタイプは &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a V)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a52b26a20f6e5a2edebe10f6f90cf9507490a85c" translate="yes" xml:space="preserve">
          <source>An iterator visiting all keys in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a K&lt;/code&gt;.</source>
          <target state="translated">すべてのキーを任意の順序で訪問する反復子。イテレーター要素のタイプは &lt;code&gt;&amp;amp;'a K&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cee3468b8b5e0fdd5a440c2d5df35c4c2db2ae90" translate="yes" xml:space="preserve">
          <source>An iterator visiting all values in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a V&lt;/code&gt;.</source>
          <target state="translated">すべての値を任意の順序で訪問する反復子。イテレータ要素のタイプは &lt;code&gt;&amp;amp;'a V&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7ae307f212519994d8b694a5d942377f4aec4823" translate="yes" xml:space="preserve">
          <source>An iterator visiting all values mutably in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a mut V&lt;/code&gt;.</source>
          <target state="translated">すべての値を任意の順序で変更可能に訪問する反復子。イテレーター要素のタイプは &lt;code&gt;&amp;amp;'a mut V&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="211d7c1adc8a12b57341be994e857003e54c6bbd" translate="yes" xml:space="preserve">
          <source>An iterator where each iteration calls the provided closure &lt;code&gt;F: FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">各反復が提供されたクロージャー &lt;code&gt;F: FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; 呼び出すイテレーター。</target>
        </trans-unit>
        <trans-unit id="c53ddbd1d3e296430ed20afa68efda72ca0ded32" translate="yes" xml:space="preserve">
          <source>An iterator with a &lt;code&gt;peek()&lt;/code&gt; that returns an optional reference to the next element.</source>
          <target state="translated">次の要素へのオプションの参照を返す &lt;code&gt;peek()&lt;/code&gt; を持つイテレータ。</target>
        </trans-unit>
        <trans-unit id="c9cd5154a20293338cfe2c0c0c884bc897a9a0cb" translate="yes" xml:space="preserve">
          <source>An new iterator where each successive item is computed based on the preceding one.</source>
          <target state="translated">各連続した項目が前の項目に基づいて計算される新しいイテレータ.</target>
        </trans-unit>
        <trans-unit id="767a832ec64e700730e273e825321e36a3ef86e1" translate="yes" xml:space="preserve">
          <source>An occupied entry.</source>
          <target state="translated">占有されたエントリ。</target>
        </trans-unit>
        <trans-unit id="678664bfa424da9fc0ca21e4760f29b4b952648d" translate="yes" xml:space="preserve">
          <source>An optional item</source>
          <target state="translated">オプション項目</target>
        </trans-unit>
        <trans-unit id="d7f5308e6f605cdab4dbb8b387f9c93de98d0922" translate="yes" xml:space="preserve">
          <source>An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">次の場合、注文は合計注文になります（すべての &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; の場合）：</target>
        </trans-unit>
        <trans-unit id="e7c75396d6933448cc7456d6beaf9cf648ea0ef5" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is equal to another.</source>
          <target state="translated">比較された値が別の値と等しい順序。</target>
        </trans-unit>
        <trans-unit id="09dba8210b3d0ce590a3a5f065b62a6a8ab493fb" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is greater than another.</source>
          <target state="translated">比較される値が他の値よりも大きい順序。</target>
        </trans-unit>
        <trans-unit id="a2c8ca4c96fc50eebfe4b351916be57d1bf56d8c" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is less than another.</source>
          <target state="translated">比較される値が他の値よりも小さい順序。</target>
        </trans-unit>
        <trans-unit id="38792f39e0fa160ba176220b302fc6518c1e2555" translate="yes" xml:space="preserve">
          <source>An owned permission to join on a thread (block on its termination).</source>
          <target state="translated">スレッドへの参加を許可する所有権(終了時にブロック)。</target>
        </trans-unit>
        <trans-unit id="8c3512dc7441f7c48feb0adfb2813ca8cbecd465" translate="yes" xml:space="preserve">
          <source>An owned, mutable path (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">所有された変更可能なパス（&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; に&lt;/a&gt;似ています）。</target>
        </trans-unit>
        <trans-unit id="e84205a36cc39374bcb7d05c1b1547f37b9b5189" translate="yes" xml:space="preserve">
          <source>An owning iterator over messages on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;strong&gt;Receiver::into_iter&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Receiver :: into_iter&lt;/strong&gt;によって作成された、&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;上のメッセージに対する所有イテレータ。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83bd664b01b4716a8aced24a8192a6358972a99f" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; の要素に対する所有イテレータ。</target>
        </trans-unit>
        <trans-unit id="34718a674d09c2eb637513ac6f89289f300970ef" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; の要素に対する所有イテレータ。</target>
        </trans-unit>
        <trans-unit id="f6f353b2a400a09971f91285403f6b780ae991c4" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の要素に対する所有イテレータ。</target>
        </trans-unit>
        <trans-unit id="77a86a6c2dd3031f17c5e8abfe6100f81887dd42" translate="yes" xml:space="preserve">
          <source>An owning iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリに対する所有イテレータ。</target>
        </trans-unit>
        <trans-unit id="209ab8cbe2152f0b0d82c7256751114f7cd068b9" translate="yes" xml:space="preserve">
          <source>An owning iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対する所有イテレータ。</target>
        </trans-unit>
        <trans-unit id="ef6f78f2a2dbde9b33ceeac921bd77fbb502b5bc" translate="yes" xml:space="preserve">
          <source>An owning iterator over the items of a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の項目に対する所有イテレータ。</target>
        </trans-unit>
        <trans-unit id="427fdeccedc75e2673269080f0ce6c0924e6c1bd" translate="yes" xml:space="preserve">
          <source>An owning iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; のアイテムに対する所有イテレータ。</target>
        </trans-unit>
        <trans-unit id="b9b2d7fe27e12071feb7334cad3f7f83e9e84aa2" translate="yes" xml:space="preserve">
          <source>An unary operator was used on a type which doesn't implement it.</source>
          <target state="translated">単項演算子が実装されていない型で使用されました。</target>
        </trans-unit>
        <trans-unit id="dcb71e1bf306a3b27e4be98207d51ae66d320fdd" translate="yes" xml:space="preserve">
          <source>An unbounded range (&lt;code&gt;..&lt;/code&gt;).</source>
          <target state="translated">無制限の範囲（ &lt;code&gt;..&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3caad6b327abced5bae6f8ff205241ca33ed53ab" translate="yes" xml:space="preserve">
          <source>An unchecked assertion allows a program in an inconsistent state to keep running, which might have unexpected consequences but does not introduce unsafety as long as this only happens in safe code. The performance cost of assertions, is however, not measurable in general. Replacing &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;debug_assert!&lt;/code&gt; is thus only encouraged after thorough profiling, and more importantly, only in safe code!</source>
          <target state="translated">チェックされていないアサーションは、不整合な状態のプログラムが実行を継続できるようにします。これは予期しない結果をもたらす可能性がありますが、これが安全なコードでのみ発生する限り、安全ではありません。ただし、アサーションのパフォーマンスコストは一般に測定できません。&lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt;置き換える！ &lt;code&gt;debug_assert!&lt;/code&gt; したがって、徹底的なプロファイリングの後にのみ、そしてさらに重要なことに、安全なコードでのみ推奨されます！</target>
        </trans-unit>
        <trans-unit id="490b1d248ac38d604233cacff667b31a463976df" translate="yes" xml:space="preserve">
          <source>An undeclared label was used.</source>
          <target state="translated">宣言されていないラベルが使用されていました。</target>
        </trans-unit>
        <trans-unit id="fc0bdd57bc131e7f23a48af9227bf2c7b9e2b4dd" translate="yes" xml:space="preserve">
          <source>An undeclared type or module was used.</source>
          <target state="translated">未申告のタイプまたはモジュールが使用されました。</target>
        </trans-unit>
        <trans-unit id="2dbef161c3305374da24ca6e3ae9cdc7bdefe6b4" translate="yes" xml:space="preserve">
          <source>An unknown &quot;kind&quot; was specified for a link attribute. Erroneous code example:</source>
          <target state="translated">リンク属性に未知の &quot;種類&quot; が指定されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="a5956e957dc8b784f0e077b9955dd790db201d80" translate="yes" xml:space="preserve">
          <source>An unknown argument was given to the &lt;code&gt;inline&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 属性に不明な引数が指定されました。</target>
        </trans-unit>
        <trans-unit id="9a99f6d07dc4d8ba35aa89128cc34d06dd11ce0f" translate="yes" xml:space="preserve">
          <source>An unknown external lang item was used. Erroneous code example:</source>
          <target state="translated">未知の外部言語項目が使用されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="1356f6d3a3c2ce1216defe8b6863fd5e9393d5fa" translate="yes" xml:space="preserve">
          <source>An unknown field was specified into a structure.</source>
          <target state="translated">未知のフィールドが構造体に指定されていました。</target>
        </trans-unit>
        <trans-unit id="672bd73128faa09c7f440466e9f29739ad4de42d" translate="yes" xml:space="preserve">
          <source>An unknown field was specified into an enum's structure variant.</source>
          <target state="translated">未知のフィールドが enum の構造体バリアントに指定されました。</target>
        </trans-unit>
        <trans-unit id="e8a840a4e189fb8e18f90b5fe877d384d51d1d3c" translate="yes" xml:space="preserve">
          <source>An unknown lint was used on the command line.</source>
          <target state="translated">コマンドラインで不明なリントが使用されていました。</target>
        </trans-unit>
        <trans-unit id="d472ec49c42739263d3ec941f6cf5b5468a2d3b2" translate="yes" xml:space="preserve">
          <source>An unknown meta item was used.</source>
          <target state="translated">未知のメタ項目が使用されていました。</target>
        </trans-unit>
        <trans-unit id="a940cccd136dc43c95bcfd2c10667fe77e672634" translate="yes" xml:space="preserve">
          <source>An unknown predicate was used inside the &lt;code&gt;cfg&lt;/code&gt; attribute.</source>
          <target state="translated">不明な述語が &lt;code&gt;cfg&lt;/code&gt; 属性内で使用されました。</target>
        </trans-unit>
        <trans-unit id="c12ae2fbe23adbaee9a27dcd9a18b88d8f9167df" translate="yes" xml:space="preserve">
          <source>An unnamed address:</source>
          <target state="translated">名前のない住所。</target>
        </trans-unit>
        <trans-unit id="3386e5166859dc07663dec10855432efda42e389" translate="yes" xml:space="preserve">
          <source>An unpoisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">無毒な &lt;code&gt;Once&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9a03f5a8f224f5f2ce3d5df647878dfe5aac207b" translate="yes" xml:space="preserve">
          <source>An unresolved name was used.</source>
          <target state="translated">未解決の名前が使われていました。</target>
        </trans-unit>
        <trans-unit id="c801b4c85f18e94f7cb6ce228ae449c345e89b49" translate="yes" xml:space="preserve">
          <source>An unstable feature was used.</source>
          <target state="translated">不安定な機能が使われていました。</target>
        </trans-unit>
        <trans-unit id="ad604b2507c78bd47c93ad249e197a918e7208ca" translate="yes" xml:space="preserve">
          <source>An unsupported representation was attempted on a zero-variant enum.</source>
          <target state="translated">サポートされていない表現がゼロ変数列挙で試みられました。</target>
        </trans-unit>
        <trans-unit id="999140d65b2dddb09bc1533f2a2a2de632081b87" translate="yes" xml:space="preserve">
          <source>Anatomy of a Rust Program</source>
          <target state="translated">ラストプログラムの解剖学</target>
        </trans-unit>
        <trans-unit id="f96afdd93db8b2e4f4aa8b97a7ac6e4f106649a9" translate="yes" xml:space="preserve">
          <source>Ancestors</source>
          <target state="translated">Ancestors</target>
        </trans-unit>
        <trans-unit id="a69185f73b3266ea2ea0196235a7920d98b23569" translate="yes" xml:space="preserve">
          <source>Ancestors::all</source>
          <target state="translated">Ancestors::all</target>
        </trans-unit>
        <trans-unit id="5d0f93422db0f668490adf089654ecece89c57a9" translate="yes" xml:space="preserve">
          <source>Ancestors::any</source>
          <target state="translated">Ancestors::any</target>
        </trans-unit>
        <trans-unit id="c4d070344a11e561f295e6e7e6205f761d5798b6" translate="yes" xml:space="preserve">
          <source>Ancestors::borrow</source>
          <target state="translated">Ancestors::borrow</target>
        </trans-unit>
        <trans-unit id="a84c8539090bc4c2974d99b05a787e636ebe0acb" translate="yes" xml:space="preserve">
          <source>Ancestors::borrow_mut</source>
          <target state="translated">Ancestors::borrow_mut</target>
        </trans-unit>
        <trans-unit id="334238f85474f459cc0ffaef3421caf90b07c6e6" translate="yes" xml:space="preserve">
          <source>Ancestors::by_ref</source>
          <target state="translated">Ancestors::by_ref</target>
        </trans-unit>
        <trans-unit id="6fdc4e3375706d83d8aecc92a22ee70bff5dfab4" translate="yes" xml:space="preserve">
          <source>Ancestors::chain</source>
          <target state="translated">Ancestors::chain</target>
        </trans-unit>
        <trans-unit id="dce0f9cae4b8d7222a0b11c873b249cd98da26b3" translate="yes" xml:space="preserve">
          <source>Ancestors::clone</source>
          <target state="translated">Ancestors::clone</target>
        </trans-unit>
        <trans-unit id="31848f144e07d27fc7390a8c92d56ab88474c213" translate="yes" xml:space="preserve">
          <source>Ancestors::clone_from</source>
          <target state="translated">Ancestors::clone_from</target>
        </trans-unit>
        <trans-unit id="35f7611233faafb5be9d7d385104097f21e72511" translate="yes" xml:space="preserve">
          <source>Ancestors::clone_into</source>
          <target state="translated">Ancestors::clone_into</target>
        </trans-unit>
        <trans-unit id="0d02f4a4459ad43a2bc9f83a20b48ce81eb5eefc" translate="yes" xml:space="preserve">
          <source>Ancestors::cloned</source>
          <target state="translated">Ancestors::cloned</target>
        </trans-unit>
        <trans-unit id="67ff55ec2d9537e58736a03fd50c337049b761f0" translate="yes" xml:space="preserve">
          <source>Ancestors::cmp</source>
          <target state="translated">Ancestors::cmp</target>
        </trans-unit>
        <trans-unit id="0d35d199d39196de0523350cd24a1241424fa231" translate="yes" xml:space="preserve">
          <source>Ancestors::collect</source>
          <target state="translated">Ancestors::collect</target>
        </trans-unit>
        <trans-unit id="4865b6ff2a1901685d10435c12cf071b254d3a62" translate="yes" xml:space="preserve">
          <source>Ancestors::copied</source>
          <target state="translated">Ancestors::copied</target>
        </trans-unit>
        <trans-unit id="f28d6b4a44e14f0d15c4f132d556116c210c1c84" translate="yes" xml:space="preserve">
          <source>Ancestors::count</source>
          <target state="translated">Ancestors::count</target>
        </trans-unit>
        <trans-unit id="a6a740680e9008614345c582b8e1985861829875" translate="yes" xml:space="preserve">
          <source>Ancestors::cycle</source>
          <target state="translated">Ancestors::cycle</target>
        </trans-unit>
        <trans-unit id="0810bcf20fe4de2312f283ad13e930eaa61b0c30" translate="yes" xml:space="preserve">
          <source>Ancestors::enumerate</source>
          <target state="translated">Ancestors::enumerate</target>
        </trans-unit>
        <trans-unit id="f443387bf4a86a6cc1330d9f2c4d3b913b1c1dd0" translate="yes" xml:space="preserve">
          <source>Ancestors::eq</source>
          <target state="translated">Ancestors::eq</target>
        </trans-unit>
        <trans-unit id="796eb87c3af9fac554be5d4ec57ca702d510701f" translate="yes" xml:space="preserve">
          <source>Ancestors::filter</source>
          <target state="translated">Ancestors::filter</target>
        </trans-unit>
        <trans-unit id="d1822e4ea409150f5e23e24201bc84ef25560137" translate="yes" xml:space="preserve">
          <source>Ancestors::filter_map</source>
          <target state="translated">Ancestors::filter_map</target>
        </trans-unit>
        <trans-unit id="1e6cc0ef677409077aa639becd452ada01ece8d8" translate="yes" xml:space="preserve">
          <source>Ancestors::find</source>
          <target state="translated">Ancestors::find</target>
        </trans-unit>
        <trans-unit id="657aafc8bbaf8304573fbc00e24419ba040782a9" translate="yes" xml:space="preserve">
          <source>Ancestors::find_map</source>
          <target state="translated">Ancestors::find_map</target>
        </trans-unit>
        <trans-unit id="beeb7e3fb0fbc04618a5300c980c6f59ed075dcd" translate="yes" xml:space="preserve">
          <source>Ancestors::flat_map</source>
          <target state="translated">Ancestors::flat_map</target>
        </trans-unit>
        <trans-unit id="47bd10eda5c1ca25f0cc303ef197cbc1220d1b53" translate="yes" xml:space="preserve">
          <source>Ancestors::flatten</source>
          <target state="translated">Ancestors::flatten</target>
        </trans-unit>
        <trans-unit id="a456cec1879b2b70a77233841a841755191a8a86" translate="yes" xml:space="preserve">
          <source>Ancestors::fmt</source>
          <target state="translated">Ancestors::fmt</target>
        </trans-unit>
        <trans-unit id="1f02f420430d3894ec9ecddf11dd94365e77ac19" translate="yes" xml:space="preserve">
          <source>Ancestors::fold</source>
          <target state="translated">Ancestors::fold</target>
        </trans-unit>
        <trans-unit id="3ca5818636166fd5b398f8e40a922c894b0abbb6" translate="yes" xml:space="preserve">
          <source>Ancestors::for_each</source>
          <target state="translated">Ancestors::for_each</target>
        </trans-unit>
        <trans-unit id="4264a030cb324bfbad2fa80a46e42c679803a0c3" translate="yes" xml:space="preserve">
          <source>Ancestors::from</source>
          <target state="translated">Ancestors::from</target>
        </trans-unit>
        <trans-unit id="32047f73315575a8e50a462155406bb910ceed17" translate="yes" xml:space="preserve">
          <source>Ancestors::fuse</source>
          <target state="translated">Ancestors::fuse</target>
        </trans-unit>
        <trans-unit id="41f1796019df27f1dc523c24819d1254f099c660" translate="yes" xml:space="preserve">
          <source>Ancestors::ge</source>
          <target state="translated">Ancestors::ge</target>
        </trans-unit>
        <trans-unit id="f1594f0c385b82f3427f45ed26a50d1dac4fa05e" translate="yes" xml:space="preserve">
          <source>Ancestors::gt</source>
          <target state="translated">Ancestors::gt</target>
        </trans-unit>
        <trans-unit id="dd54e2ff77b477361ff6376d5b04afaad6a7ef21" translate="yes" xml:space="preserve">
          <source>Ancestors::inspect</source>
          <target state="translated">Ancestors::inspect</target>
        </trans-unit>
        <trans-unit id="1bc8d1bb95f4aedebacf2a84051d097086c1cc75" translate="yes" xml:space="preserve">
          <source>Ancestors::into</source>
          <target state="translated">Ancestors::into</target>
        </trans-unit>
        <trans-unit id="6f7bdf57cf985a0498067e483576359d43c33000" translate="yes" xml:space="preserve">
          <source>Ancestors::into_iter</source>
          <target state="translated">Ancestors::into_iter</target>
        </trans-unit>
        <trans-unit id="e4f570f8f86838a0b2f0996de24967465582d845" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted</source>
          <target state="translated">Ancestors::is_sorted</target>
        </trans-unit>
        <trans-unit id="8fa7773f21437bd02461103d0f128fe2f328180a" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted_by</source>
          <target state="translated">Ancestors::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="da156b45c81720439526b87f492a4b80dde53f7a" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted_by_key</source>
          <target state="translated">Ancestors::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6bf6d1d6ec433eb2498f88c1821e2e8d204490c9" translate="yes" xml:space="preserve">
          <source>Ancestors::last</source>
          <target state="translated">Ancestors::last</target>
        </trans-unit>
        <trans-unit id="6182ceed3235394e0830f635f2568ba50e3e7bb2" translate="yes" xml:space="preserve">
          <source>Ancestors::le</source>
          <target state="translated">Ancestors::le</target>
        </trans-unit>
        <trans-unit id="ba00a013a0f8fd57e29b01f66afccf088e1d0023" translate="yes" xml:space="preserve">
          <source>Ancestors::lt</source>
          <target state="translated">Ancestors::lt</target>
        </trans-unit>
        <trans-unit id="b588193780984cc7ebdb2f28a2c09aad1660160a" translate="yes" xml:space="preserve">
          <source>Ancestors::map</source>
          <target state="translated">Ancestors::map</target>
        </trans-unit>
        <trans-unit id="aa73ed60029c8667bd3541a6cd43b17d298a34bc" translate="yes" xml:space="preserve">
          <source>Ancestors::max</source>
          <target state="translated">Ancestors::max</target>
        </trans-unit>
        <trans-unit id="ab6d430bbae01a6904e8639546e74aa743ec4546" translate="yes" xml:space="preserve">
          <source>Ancestors::max_by</source>
          <target state="translated">Ancestors::max_by</target>
        </trans-unit>
        <trans-unit id="3f9a117ba2cfb9ce3093457ddf5a2896b25c3699" translate="yes" xml:space="preserve">
          <source>Ancestors::max_by_key</source>
          <target state="translated">Ancestors::max_by_key</target>
        </trans-unit>
        <trans-unit id="d86ac9020bc2e94f4de10dd0521bc6648555300a" translate="yes" xml:space="preserve">
          <source>Ancestors::min</source>
          <target state="translated">Ancestors::min</target>
        </trans-unit>
        <trans-unit id="d1a3237b0f7d1400e70026876d1a9e1edfd954fb" translate="yes" xml:space="preserve">
          <source>Ancestors::min_by</source>
          <target state="translated">Ancestors::min_by</target>
        </trans-unit>
        <trans-unit id="4a76ef60a157a414e53965e7b20bdb80a42a93c5" translate="yes" xml:space="preserve">
          <source>Ancestors::min_by_key</source>
          <target state="translated">Ancestors::min_by_key</target>
        </trans-unit>
        <trans-unit id="5d2760f02e37aabc523ea5766e6897c5ccc56a0b" translate="yes" xml:space="preserve">
          <source>Ancestors::ne</source>
          <target state="translated">Ancestors::ne</target>
        </trans-unit>
        <trans-unit id="94b5fbd4a6186842bbae09888725d74af29ff76c" translate="yes" xml:space="preserve">
          <source>Ancestors::next</source>
          <target state="translated">Ancestors::next</target>
        </trans-unit>
        <trans-unit id="061044f738cb0378794d00307372b84bda535007" translate="yes" xml:space="preserve">
          <source>Ancestors::nth</source>
          <target state="translated">Ancestors::nth</target>
        </trans-unit>
        <trans-unit id="104a8aab4cf5a11201b887398168f2f5e1f87087" translate="yes" xml:space="preserve">
          <source>Ancestors::partial_cmp</source>
          <target state="translated">Ancestors::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bed7abfd1f96e21405eb173c4d15c03b456d92a5" translate="yes" xml:space="preserve">
          <source>Ancestors::partition</source>
          <target state="translated">Ancestors::partition</target>
        </trans-unit>
        <trans-unit id="84cd0d32c4daeda367ba0a2ae2e2b6a7ff4841da" translate="yes" xml:space="preserve">
          <source>Ancestors::peekable</source>
          <target state="translated">Ancestors::peekable</target>
        </trans-unit>
        <trans-unit id="b4ddc60ef630227f7ade5b8c560fef259500316e" translate="yes" xml:space="preserve">
          <source>Ancestors::position</source>
          <target state="translated">Ancestors::position</target>
        </trans-unit>
        <trans-unit id="7a31ee815f86cdd427869f86ea4e16e837ac74a5" translate="yes" xml:space="preserve">
          <source>Ancestors::product</source>
          <target state="translated">Ancestors::product</target>
        </trans-unit>
        <trans-unit id="b560f4cdd9c918e68c647f28819fc526f4443425" translate="yes" xml:space="preserve">
          <source>Ancestors::rev</source>
          <target state="translated">Ancestors::rev</target>
        </trans-unit>
        <trans-unit id="2d6150b963da3a5f8bb4fbcf3bede9ac1d149eac" translate="yes" xml:space="preserve">
          <source>Ancestors::rposition</source>
          <target state="translated">Ancestors::rposition</target>
        </trans-unit>
        <trans-unit id="33695d4fc7bd02cc81076a7f065f59ae331ce9d8" translate="yes" xml:space="preserve">
          <source>Ancestors::scan</source>
          <target state="translated">Ancestors::scan</target>
        </trans-unit>
        <trans-unit id="a71e116d1152775af982054ee8766888b8c17bf5" translate="yes" xml:space="preserve">
          <source>Ancestors::size_hint</source>
          <target state="translated">Ancestors::size_hint</target>
        </trans-unit>
        <trans-unit id="1492747daf21eb6d17932ae78e4e1bb6900ec817" translate="yes" xml:space="preserve">
          <source>Ancestors::skip</source>
          <target state="translated">Ancestors::skip</target>
        </trans-unit>
        <trans-unit id="7ccb1c50d003cbcf82f746c7c89b476d0db40ef9" translate="yes" xml:space="preserve">
          <source>Ancestors::skip_while</source>
          <target state="translated">Ancestors::skip_while</target>
        </trans-unit>
        <trans-unit id="2d680c75e7e0a20bba67113ba634c0b9819ec275" translate="yes" xml:space="preserve">
          <source>Ancestors::step_by</source>
          <target state="translated">Ancestors::step_by</target>
        </trans-unit>
        <trans-unit id="bb4081cc4c0735468e080f3f00abdd7bfc4c7b73" translate="yes" xml:space="preserve">
          <source>Ancestors::sum</source>
          <target state="translated">Ancestors::sum</target>
        </trans-unit>
        <trans-unit id="b184ac7bf98e724a647631566c8e7b44261ba11d" translate="yes" xml:space="preserve">
          <source>Ancestors::take</source>
          <target state="translated">Ancestors::take</target>
        </trans-unit>
        <trans-unit id="551d6d8baae9a0ead4f49097f5951591191f29fd" translate="yes" xml:space="preserve">
          <source>Ancestors::take_while</source>
          <target state="translated">Ancestors::take_while</target>
        </trans-unit>
        <trans-unit id="f38b2d2e57427d6c5d34e24a9e37978f181043c7" translate="yes" xml:space="preserve">
          <source>Ancestors::to_owned</source>
          <target state="translated">Ancestors::to_owned</target>
        </trans-unit>
        <trans-unit id="bd8e948ee34c84cdc8f1385bf9b2d83abdbf9fb4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_fold</source>
          <target state="translated">Ancestors::try_fold</target>
        </trans-unit>
        <trans-unit id="46ad3f23b6a14805c5bb02a0abccbaa9ad1f0c58" translate="yes" xml:space="preserve">
          <source>Ancestors::try_for_each</source>
          <target state="translated">Ancestors::try_for_each</target>
        </trans-unit>
        <trans-unit id="f18ea48cefb527612333927e42f98b5493e80a96" translate="yes" xml:space="preserve">
          <source>Ancestors::try_from</source>
          <target state="translated">Ancestors::try_from</target>
        </trans-unit>
        <trans-unit id="f07951de2fcfeba585ae159316c166c38d8606b4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_into</source>
          <target state="translated">Ancestors::try_into</target>
        </trans-unit>
        <trans-unit id="0008829b37e7881a29a429bd8ff5a7a5ef753374" translate="yes" xml:space="preserve">
          <source>Ancestors::type_id</source>
          <target state="translated">Ancestors::type_id</target>
        </trans-unit>
        <trans-unit id="04f137aff1969f866b7d2666a9252de9e0efa21b" translate="yes" xml:space="preserve">
          <source>Ancestors::unzip</source>
          <target state="translated">Ancestors::unzip</target>
        </trans-unit>
        <trans-unit id="55dbfc2c3d770eaac08b3c73d87bccce57c4f78d" translate="yes" xml:space="preserve">
          <source>Ancestors::zip</source>
          <target state="translated">Ancestors::zip</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="42b71964be13234f4cbc3e386af8045e5f37b66e" translate="yes" xml:space="preserve">
          <source>And &lt;em&gt;src/front_of_house.rs&lt;/em&gt; gets the definitions from the body of the &lt;code&gt;front_of_house&lt;/code&gt; module, as shown in Listing 7-22.</source>
          <target state="translated">そして、&lt;em&gt;SRC / front_of_house.rsは、&lt;/em&gt;本体から定義を取得 &lt;code&gt;front_of_house&lt;/code&gt; のリスト7-22に示すように、モジュール。</target>
        </trans-unit>
        <trans-unit id="a66dda047400c5c52222e76fafe04295868d79a8" translate="yes" xml:space="preserve">
          <source>And a very common source of output is standard output:</source>
          <target state="translated">そして、ごく一般的な出力源は標準出力です。</target>
        </trans-unit>
        <trans-unit id="b91a984e8eba980f8ed5afc44476d8d32720a1d5" translate="yes" xml:space="preserve">
          <source>And finally, let&amp;rsquo;s make sure that we don&amp;rsquo;t get any lines when we search for a word that isn&amp;rsquo;t anywhere in the poem, such as &amp;ldquo;monomorphization&amp;rdquo;:</source>
          <target state="translated">そして最後に、詩のどこにもない単語を検索するときに「モノモーフィゼーション」などの行を取得しないようにします。</target>
        </trans-unit>
        <trans-unit id="8ddbbced7930dcaf198948383ed803d74e9323cf" translate="yes" xml:space="preserve">
          <source>And finally, the standard library exports a number of standard macros, and &lt;a href=&quot;#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.</source>
          <target state="translated">そして最後に、標準ライブラリはいくつかの標準マクロをエクスポート&lt;a href=&quot;#macros&quot;&gt;し、このページに一覧表示します&lt;/a&gt;（技術的には、すべての標準マクロが標準ライブラリによって定義されているわけではありません-一部はコンパイラによって定義されています-それらはここでも同じようにドキュメント化されています）。 。プレリュードと同様に、標準マクロはデフォルトですべてのクレートにインポートされます。</target>
        </trans-unit>
        <trans-unit id="01c604c6cbed200d9271efd93c6961cdbaa99ebc" translate="yes" xml:space="preserve">
          <source>And now let's give working examples:</source>
          <target state="translated">そして、ここでは実際に働いている例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="076add01b447af4a01e4ff6b95c8cd6d23f8bbbe" translate="yes" xml:space="preserve">
          <source>And now some working examples:</source>
          <target state="translated">そして今、いくつかの作業例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="965c5135f65b1edbef655afbf975cd109690bf20" translate="yes" xml:space="preserve">
          <source>And so, our final result, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">そして、最終的な結果は &lt;code&gt;6&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8576d009cd19a7310431c770ccd6d0477a9a38f5" translate="yes" xml:space="preserve">
          <source>And the expected output would look like the following, because both dimensions of &lt;code&gt;rect2&lt;/code&gt; are smaller than the dimensions of &lt;code&gt;rect1&lt;/code&gt; but &lt;code&gt;rect3&lt;/code&gt; is wider than &lt;code&gt;rect1&lt;/code&gt;:</source>
          <target state="translated">両方の寸法いるためと予想される出力は、次のようになり &lt;code&gt;rect2&lt;/code&gt; の寸法よりも小さい &lt;code&gt;rect1&lt;/code&gt; が、 &lt;code&gt;rect3&lt;/code&gt; がより広くなっている &lt;code&gt;rect1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="304a9abb7c8dbb46b1cac5f34e7d81eb70527d19" translate="yes" xml:space="preserve">
          <source>And the following is the same example, except using &lt;a href=&quot;generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;.</source>
          <target state="translated">また、次の例も同じですが、&lt;a href=&quot;generics#where-clauses&quot;&gt;where句&lt;/a&gt;を使用しています。</target>
        </trans-unit>
        <trans-unit id="913d407459e0226b150e7a70e74b4001bb096c87" translate="yes" xml:space="preserve">
          <source>And then usage on the derive macro on a struct:</source>
          <target state="translated">そして、構造体上での派生マクロの使用法。</target>
        </trans-unit>
        <trans-unit id="16869e8d4badcf1212b889f654db64e52cba8e49" translate="yes" xml:space="preserve">
          <source>And then using said derive macro:</source>
          <target state="translated">そして、その導出マクロを使って</target>
        </trans-unit>
        <trans-unit id="fde456d658fb04a2082b8789148df9b0dd8dabdb" translate="yes" xml:space="preserve">
          <source>And then we use it a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">そして、それをバイナリクレートにして「42」を標準出力に出力しています。</target>
        </trans-unit>
        <trans-unit id="843c5d94071a4fae0f20d3e75ea70e29673c03d4" translate="yes" xml:space="preserve">
          <source>And we can call this function with either variant:</source>
          <target state="translated">そして、この関数をどちらかのバリアントで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="406aea8920a159db743c7e055df50170c501f68e" translate="yes" xml:space="preserve">
          <source>And we&amp;rsquo;re done&amp;mdash;all of Listing 17-11 now works! We&amp;rsquo;ve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">これで完了です。リスト17-11のすべてが機能します。ブログ投稿ワークフローのルールを使用して状態パターンを実装しました。ルールに関連するロジックは、 &lt;code&gt;Post&lt;/code&gt; 全体に分散するのではなく、状態オブジェクトに存在します。</target>
        </trans-unit>
        <trans-unit id="d71a2256704824ddf84d5c0504e7d9d40555e056" translate="yes" xml:space="preserve">
          <source>And you make a hard link of the program:</source>
          <target state="translated">そして、プログラムのハードリンクを作るんですね。</target>
        </trans-unit>
        <trans-unit id="1a652f499d8171d97dc8db68df0dbf0a99d7c3f2" translate="yes" xml:space="preserve">
          <source>AndAnd</source>
          <target state="translated">AndAnd</target>
        </trans-unit>
        <trans-unit id="bcffbb2710fb4ff9f2236988e5b2ed04ecff3723" translate="yes" xml:space="preserve">
          <source>AndEq</source>
          <target state="translated">AndEq</target>
        </trans-unit>
        <trans-unit id="c4af9f801ba386b4d95b5962fd0aee793823a0c6" translate="yes" xml:space="preserve">
          <source>Anonymous type parameters</source>
          <target state="translated">匿名型パラメータ</target>
        </trans-unit>
        <trans-unit id="f739dc0ff02bf7ebdbbaf543c53bc8d5f32aa9b9" translate="yes" xml:space="preserve">
          <source>Another aspect commonly associated with OOP is the idea of &lt;em&gt;encapsulation&lt;/em&gt;, which means that the implementation details of an object aren&amp;rsquo;t accessible to code using that object. Therefore, the only way to interact with an object is through its public API; code using the object shouldn&amp;rsquo;t be able to reach into the object&amp;rsquo;s internals and change data or behavior directly. This enables the programmer to change and refactor an object&amp;rsquo;s internals without needing to change the code that uses the object.</source>
          <target state="translated">一般にOOPに関連するもう1つの側面は、&lt;em&gt;カプセル化&lt;/em&gt;の概念です。つまり、オブジェクトの実装の詳細には、そのオブジェクトを使用するコードからアクセスできません。したがって、オブジェクトと対話する唯一の方法は、そのパブリックAPIを使用することです。オブジェクトを使用するコードは、オブジェクトの内部に到達して、データや動作を直接変更できないようにする必要があります。これにより、プログラマは、オブジェクトを使用するコードを変更する必要なく、オブジェクトの内部を変更およびリファクタリングできます。</target>
        </trans-unit>
        <trans-unit id="3244c196f26eb3ebda5753ab0aa6df5308b053cc" translate="yes" xml:space="preserve">
          <source>Another case that causes this error is when a type is imported into a parent module. To fix this, you can follow the suggestion and use File directly or &lt;code&gt;use super::File;&lt;/code&gt; which will import the types from the parent namespace. An example that causes this error is below:</source>
          <target state="translated">このエラーの原因となるもう1つのケースは、型が親モジュールにインポートされた場合です。これを修正するには、提案に従ってFileを直接 &lt;code&gt;use super::File;&lt;/code&gt; するか、super :: Fileを使用します。親名前空間から型をインポートします。このエラーの原因となる例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="f5177285c1540f1a230a9212d6ad08c740059bb0" translate="yes" xml:space="preserve">
          <source>Another case where this error is emitted is when a value is expected, but something else is found:</source>
          <target state="translated">このエラーが出るもう一つのケースは、値が期待されていたのに何か別のものが見つかった場合です。</target>
        </trans-unit>
        <trans-unit id="583bae5ce904e4cf097b6105871c304a4243a347" translate="yes" xml:space="preserve">
          <source>Another common use case for hash maps is to look up a key&amp;rsquo;s value and then update it based on the old value. For instance, Listing 8-26 shows code that counts how many times each word appears in some text. We use a hash map with the words as keys and increment the value to keep track of how many times we&amp;rsquo;ve seen that word. If it&amp;rsquo;s the first time we&amp;rsquo;ve seen a word, we&amp;rsquo;ll first insert the value 0.</source>
          <target state="translated">ハッシュマップのもう1つの一般的な使用例は、キーの値を検索し、古い値に基づいて更新することです。たとえば、リスト8-26は、各単語がテキストに出現する回数をカウントするコードを示しています。単語をキーとしてハッシュマップを使用し、値を増分して、その単語を何回目にしたかを追跡します。単語を初めて見た場合は、最初に値0を挿入します。</target>
        </trans-unit>
        <trans-unit id="dc4154c9de58b2e0fcab49a95a24b663a485fc7b" translate="yes" xml:space="preserve">
          <source>Another crate that depends on this library would need &lt;code&gt;use&lt;/code&gt; statements that bring the items from &lt;code&gt;art&lt;/code&gt; into scope, specifying the module structure that&amp;rsquo;s currently defined. Listing 14-4 shows an example of a crate that uses the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; items from the &lt;code&gt;art&lt;/code&gt; crate:</source>
          <target state="translated">このライブラリに依存する別のクレートでは、 &lt;code&gt;art&lt;/code&gt; のアイテムをスコープに入れ、現在定義されているモジュール構造を指定 &lt;code&gt;use&lt;/code&gt; ステートメントを使用する必要があります。リスト14-4は、 &lt;code&gt;PrimaryColor&lt;/code&gt; と &lt;code&gt;art&lt;/code&gt; クレートの &lt;code&gt;mix&lt;/code&gt; アイテムを使用するクレートの例を示しています。</target>
        </trans-unit>
        <trans-unit id="36e9fb79f8131b77a6b5deaea1a5127794ef21b6" translate="yes" xml:space="preserve">
          <source>Another data type that does not have ownership is the &lt;em&gt;slice&lt;/em&gt;. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</source>
          <target state="translated">所有権を持たないもう1つのデータ型は&lt;em&gt;スライス&lt;/em&gt;です。スライスを使用すると、コレクション全体ではなく、コレクション内の隣接する要素のシーケンスを参照できます。</target>
        </trans-unit>
        <trans-unit id="2188fdee49af653aee0e28e4ac63dee8849194f0" translate="yes" xml:space="preserve">
          <source>Another detail to note is that Rust can&amp;rsquo;t protect you from all kinds of logic errors when you use &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. Recall in Chapter 15 that using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; came with the risk of creating reference cycles, where two &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; values refer to each other, causing memory leaks. Similarly, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; comes with the risk of creating &lt;em&gt;deadlocks&lt;/em&gt;. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you&amp;rsquo;re interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;MutexGuard&lt;/code&gt; offers useful information.</source>
          <target state="translated">もう1つ注意すべき点は、Ruteは &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; を使用する場合、あらゆる種類の論理エラーから保護できるわけではないことです。第15章では、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を使用すると参照サイクルが作成され、2つの &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 値が相互に参照してメモリリークを引き起こすリスクがあったことを思い出してください。同様に、 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; は&lt;em&gt;デッドロック&lt;/em&gt;を作成するリスクが伴います&lt;em&gt;&lt;/em&gt;。これらは、操作が2つのリソースをロックする必要があり、2つのスレッドがそれぞれロックの1つを取得していて、それらが互いを永久に待機させる場合に発生します。デッドロックに興味がある場合は、デッドロックを持つRustプログラムを作成してみてください。次に、ミューテックスのデッドロック緩和戦略を任意の言語で調査し、Rustでの実装に取り​​掛かります。 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; および &lt;code&gt;MutexGuard&lt;/code&gt; の標準ライブラリAPIドキュメントには、役立つ情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="a89f510396bf7e7d6ce47105d5094f9ffdc43c0a" translate="yes" xml:space="preserve">
          <source>Another difference between constants and static variables is that static variables can be mutable. Accessing and modifying mutable static variables is &lt;em&gt;unsafe&lt;/em&gt;. Listing 19-10 shows how to declare, access, and modify a mutable static variable named &lt;code&gt;COUNTER&lt;/code&gt;.</source>
          <target state="translated">定数と静的変数のもう1つの違いは、静的変数が可変である可能性があることです。変更可能な静的変数へのアクセスと変更は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。リスト19-10は &lt;code&gt;COUNTER&lt;/code&gt; という名前の変更可能な静的変数を宣言、アクセス、変更する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="7e6b390982d432e5d51ecddfefa741ac598bed4a" translate="yes" xml:space="preserve">
          <source>Another downside is that we&amp;rsquo;ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods on the &lt;code&gt;State&lt;/code&gt; trait that return &lt;code&gt;self&lt;/code&gt;; however, this would violate object safety, because the trait doesn&amp;rsquo;t know what the concrete &lt;code&gt;self&lt;/code&gt; will be exactly. We want to be able to use &lt;code&gt;State&lt;/code&gt; as a trait object, so we need its methods to be object safe.</source>
          <target state="translated">もう1つの欠点は、ロジックが重複していることです。一部の重複を排除するために、 &lt;code&gt;request_review&lt;/code&gt; のデフォルトの実装を作成し、 &lt;code&gt;State&lt;/code&gt; トレイトで &lt;code&gt;self&lt;/code&gt; を返すメソッドを &lt;code&gt;approve&lt;/code&gt; する場合があります。ただし、特性は具体的な &lt;code&gt;self&lt;/code&gt; が正確に何であるかを知らないため、これはオブジェクトの安全性に違反します。 &lt;code&gt;State&lt;/code&gt; を特性オブジェクトとして使用できるようにしたいので、そのメソッドはオブジェクトセーフである必要があります。</target>
        </trans-unit>
        <trans-unit id="0b90ca84780d33c44fc3e74f14be69eb7fd048f1" translate="yes" xml:space="preserve">
          <source>Another erroneous code example:</source>
          <target state="translated">別の誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="b9c6fc1e93014c21a06c17d750322f830024d1b0" translate="yes" xml:space="preserve">
          <source>Another example of a complex NT is &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt;, which matches any fragment of the form &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; where &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; occurs at least once. Note that this complex NT does not have a dedicated separator token.</source>
          <target state="translated">複雑なNTの別の例は &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt; 、これは &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; 形式の任意のフラグメントに一致します。こんにちは&amp;lt;expr&amp;gt;; ...ここで &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; 少なくとも1回発生します。この複雑なNTには専用のセパレータートークンがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="93c5ab10f51e34387707bf7df6173ca28d162973" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; タイプの別の例は、参照カウントポインター&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt;です。参照&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を指定すると、新しい&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;複製して、非アトミックな方法で参照カウントを変更できます。</target>
        </trans-unit>
        <trans-unit id="5d9b32be0b7923daf9aadae8867f04bd738917c6" translate="yes" xml:space="preserve">
          <source>Another example showing how to keep &lt;code&gt;Cow&lt;/code&gt; in a struct:</source>
          <target state="translated">&lt;code&gt;Cow&lt;/code&gt; を構造体に留めておく方法を示す別の例：</target>
        </trans-unit>
        <trans-unit id="73dbef5057ac390e03a6e177bceb38dfa0e2cca7" translate="yes" xml:space="preserve">
          <source>Another implication of the 4-byte fixed size of a &lt;code&gt;char&lt;/code&gt; is that per-&lt;code&gt;char&lt;/code&gt; processing can end up using a lot more memory:</source>
          <target state="translated">4バイトの固定サイズの別の意味合い &lt;code&gt;char&lt;/code&gt; がパーということである &lt;code&gt;char&lt;/code&gt; 型の処理がより多くのメモリを使用して終了することができます：</target>
        </trans-unit>
        <trans-unit id="8ab43d76c6773436cfee7acbc8b6406943d7ca07" translate="yes" xml:space="preserve">
          <source>Another important difference between macros and functions is that you must define macros or bring them into scope &lt;em&gt;before&lt;/em&gt; you call them in a file, as opposed to functions you can define anywhere and call anywhere.</source>
          <target state="translated">マクロと関数のもう1つの重要な違いは、どこでも定義してどこからでも呼び出すことができる関数とは対照的に、ファイルで呼び出す&lt;em&gt;前に&lt;/em&gt;マクロを定義するか、マクロをスコープ&lt;em&gt;に&lt;/em&gt;含める必要があることです。</target>
        </trans-unit>
        <trans-unit id="6f8bbe73702fb41924bac262bfb8595f3c660f2c" translate="yes" xml:space="preserve">
          <source>Another indicator that shows there&amp;rsquo;s room for improvement is the &lt;code&gt;config&lt;/code&gt; part of &lt;code&gt;parse_config&lt;/code&gt;, which implies that the two values we return are related and are both part of one configuration value. We&amp;rsquo;re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we could put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.</source>
          <target state="translated">改善の余地があります示すことが別の指標である &lt;code&gt;config&lt;/code&gt; の一部 &lt;code&gt;parse_config&lt;/code&gt; 我々は戻り二つの値が関連しており、一つの構成値の両方の一部であることを意味します。現在のところ、2つの値をタプルにグループ化する以外の方法では、データの構造でこの意味を伝えていません。 2つの値を1つの構造体に入れ、各構造体フィールドに意味のある名前を付けることができます。そうすることで、このコードの将来のメンテナーが、異なる値が互いにどのように関連しているか、およびそれらの目的が何であるかを理解しやすくなります。</target>
        </trans-unit>
        <trans-unit id="00e0685682ab1fea96a488f384eaf2fdca89f82c" translate="yes" xml:space="preserve">
          <source>Another kind of generic that we&amp;rsquo;ve already been using is called &lt;em&gt;lifetimes&lt;/em&gt;. Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be. Let&amp;rsquo;s look at how lifetimes do that.</source>
          <target state="translated">すでに使用しているもう1つのジェネリックは、&lt;em&gt;ライフタイム&lt;/em&gt;と呼ばれます。ライフタイムは、型が希望する動作をすることを保証するのではなく、必要な限り参照が有効であることを保証します。生涯がそれをどのように行うかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="310cbb5c9fbbbdff4450ff99ffebe8e97470ef1e" translate="yes" xml:space="preserve">
          <source>Another method, &lt;code&gt;expect&lt;/code&gt;, which is similar to &lt;code&gt;unwrap&lt;/code&gt;, lets us also choose the &lt;code&gt;panic!&lt;/code&gt; error message. Using &lt;code&gt;expect&lt;/code&gt; instead of &lt;code&gt;unwrap&lt;/code&gt; and providing good error messages can convey your intent and make tracking down the source of a panic easier. The syntax of &lt;code&gt;expect&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;unwrap&lt;/code&gt; に似た別の方法である &lt;code&gt;expect&lt;/code&gt; は、 &lt;code&gt;panic!&lt;/code&gt; も選択できるようにします！エラーメッセージ。 &lt;code&gt;unwrap&lt;/code&gt; の代わりに &lt;code&gt;expect&lt;/code&gt; を使用して適切なエラーメッセージを提供すると、意図が伝わり、パニックの原因を突き止めやすくなります。 &lt;code&gt;expect&lt;/code&gt; の構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f5499cba2c47a56c76648e5bfb00e8274cd4700a" translate="yes" xml:space="preserve">
          <source>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust&amp;rsquo;s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call &lt;em&gt;letters&lt;/em&gt;).</source>
          <target state="translated">UTF-8のもう1つのポイントは、Rustの観点から文字列を見るには、実際には3つの関連する方法があることです：バイト、スカラー値、および書記素クラスター（&lt;em&gt;文字&lt;/em&gt;と呼ばれるものに最も近いもの）。</target>
        </trans-unit>
        <trans-unit id="81bb35319cfe55cae7a1b6f8b640c268f984543f" translate="yes" xml:space="preserve">
          <source>Another problem you might be facing is this: suppose you've overloaded the &lt;code&gt;+&lt;/code&gt; operator for some type &lt;code&gt;Foo&lt;/code&gt; by implementing the &lt;code&gt;std::ops::Add&lt;/code&gt; trait for &lt;code&gt;Foo&lt;/code&gt;, but you find that using &lt;code&gt;+=&lt;/code&gt; does not work, as in this example:</source>
          <target state="translated">あなたが直面するかもしれないもう一つの問題はこれです：あなたが過負荷にきたと仮定 &lt;code&gt;+&lt;/code&gt; のいくつかのタイプのためにオペレータ &lt;code&gt;Foo&lt;/code&gt; 実装することにより、 &lt;code&gt;std::ops::Add&lt;/code&gt; するために形質を &lt;code&gt;Foo&lt;/code&gt; のが、あなたが使用していることを見つける &lt;code&gt;+=&lt;/code&gt; は、この例のように、仕事をしません：</target>
        </trans-unit>
        <trans-unit id="aac5c18dffed07c8f0aa7695dfba8d6c18e4b19b" translate="yes" xml:space="preserve">
          <source>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn&amp;rsquo;t let you do unsafe operations, you couldn&amp;rsquo;t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let&amp;rsquo;s explore what we can do with unsafe Rust and how to do it.</source>
          <target state="translated">Rustが安全でない代替エゴを持っているもう1つの理由は、基盤となるコンピューターハードウェアが本質的に安全でないためです。 Rustが安全でない操作を許可しないと、特定のタスクを実行できません。 Rustは、オペレーティングシステムと直接対話したり、独自のオペレーティングシステムを作成したりするなど、低レベルのシステムプログラミングを実行できるようにする必要があります。低レベルシステムプログラミングでの作業は、言語の目標の1つです。安全でないRustを使用して何ができるか、そしてそれを行う方法を探りましょう。</target>
        </trans-unit>
        <trans-unit id="ea0e4d862c74d436d68a36a2f5a91a9f7ba71ea8" translate="yes" xml:space="preserve">
          <source>Another shortcut for struct instantiation is available, used when you need to make a new struct that has the same values as most of a previous struct of the same type, called struct update syntax:</source>
          <target state="translated">構造体のインスタンス化のための別のショートカットがあり、構造体更新構文と呼ばれる、同じ型の以前の構造体のほとんどと同じ値を持つ新しい構造体を作成する必要がある場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="f3ef4925d92f67dd0f9c6ef4b106d217ff19945f" translate="yes" xml:space="preserve">
          <source>Another situation where this might be encountered is when spawning threads:</source>
          <target state="translated">もう一つの状況は、スレッドをスポーンするときに発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="34208ffcc5dda542066ff03ecbdd472bf7d5f1c2" translate="yes" xml:space="preserve">
          <source>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don&amp;rsquo;t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want &lt;code&gt;Cons&lt;/code&gt; variants to own their list, so reorganizing the data structure isn&amp;rsquo;t possible. Let&amp;rsquo;s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</source>
          <target state="translated">参照サイクルを回避するための別の解決策は、一部の参照が所有権を表し、一部の参照が所有権を表さないようにデータ構造を再編成することです。その結果、いくつかの所有権関係といくつかの非所有権関係で構成されるサイクルがあり、値を削除できるかどうかには所有権関係のみが影響します。リスト15-25では、 &lt;code&gt;Cons&lt;/code&gt; バリアントが常にリストを所有するようにしたいので、データ構造を再編成することはできません。親ノードと子ノードで構成されるグラフを使用した例を見て、所有権以外の関係が参照循環を防ぐ適切な方法であるかどうかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="561d97b6164c78f724fabd7e84d16f2ca6a5f05e" translate="yes" xml:space="preserve">
          <source>Another style of doc comment, &lt;code&gt;//!&lt;/code&gt;, adds documentation to the item that contains the comments rather than adding documentation to the items following the comments. We typically use these doc comments inside the crate root file (&lt;em&gt;src/lib.rs&lt;/em&gt; by convention) or inside a module to document the crate or the module as a whole.</source>
          <target state="translated">別のスタイルのドキュメントコメント、 &lt;code&gt;//!&lt;/code&gt; 、コメントに続くアイテムにドキュメントを追加するのではなく、コメントを含むアイテムにドキュメントを追加します。通常、これらのdocコメントは、クレートのルートファイル（&lt;em&gt;慣例&lt;/em&gt;により&lt;em&gt;src / lib.rs&lt;/em&gt;）内またはモジュール内で使用して、クレートまたはモジュール全体を文書化します。</target>
        </trans-unit>
        <trans-unit id="bfe5186a552091b0c590be070139e735a13d8759" translate="yes" xml:space="preserve">
          <source>Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</source>
          <target state="translated">newtypeパターンのもう一つの用途は、型の実装の詳細を抽象化することです。例えば、利用可能な機能を制限するためにnewtypeを直接使用した場合、newtypeはプライベート内部型のAPIとは異なるパブリックAPIを公開することができます。</target>
        </trans-unit>
        <trans-unit id="5796386c80b53dfd4fee86ac2eb96a8dcc028b10" translate="yes" xml:space="preserve">
          <source>Another useful feature of &lt;code&gt;impl&lt;/code&gt; blocks is that we&amp;rsquo;re allowed to define functions within &lt;code&gt;impl&lt;/code&gt; blocks that &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; take &lt;code&gt;self&lt;/code&gt; as a parameter. These are called &lt;em&gt;associated functions&lt;/em&gt; because they&amp;rsquo;re associated with the struct. They&amp;rsquo;re still functions, not methods, because they don&amp;rsquo;t have an instance of the struct to work with. You&amp;rsquo;ve already used the &lt;code&gt;String::from&lt;/code&gt; associated function.</source>
          <target state="translated">別の便利な機能 &lt;code&gt;impl&lt;/code&gt; ブロックは、我々は内の関数を定義することが許されているということです &lt;code&gt;impl&lt;/code&gt; ブロック&lt;em&gt;しません&lt;/em&gt;取る &lt;code&gt;self&lt;/code&gt; パラメータとして。これらは、構造体に関連付けられているため、&lt;em&gt;関連関数&lt;/em&gt;と呼ばれます。それらは、機能する構造体のインスタンスを持たないため、メソッドではなく機能のままです。 &lt;code&gt;String::from&lt;/code&gt; 関連関数をすでに使用しています。</target>
        </trans-unit>
        <trans-unit id="30235cc37ef7579d4a5373609eca2f1e91e01f9f" translate="yes" xml:space="preserve">
          <source>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</source>
          <target state="translated">マッチアームのもう一つの便利な機能は、パターンにマッチした値の部分にバインドできることです。このようにして、列挙バリアントから値を抽出することができます。</target>
        </trans-unit>
        <trans-unit id="03644769062de97f25c38104b0372355c4a77983" translate="yes" xml:space="preserve">
          <source>Another way is to do away with the associated type in &lt;code&gt;Maker&lt;/code&gt; and use an input type parameter instead:</source>
          <target state="translated">もう1つの方法は、 &lt;code&gt;Maker&lt;/code&gt; で関連する型を取り除き、代わりに入力型パラメーターを使用することです。</target>
        </trans-unit>
        <trans-unit id="ccc69aa411fffd31870708506663671f3a6766b5" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">ハッシュマップを作成する別の方法は、タプルのベクトルに対して &lt;code&gt;collect&lt;/code&gt; メソッドを使用することです。この場合、各タプルはキーとその値で構成されます。 &lt;code&gt;collect&lt;/code&gt; 方法は、以下を含むコレクション・タイプの数、にデータを収集し &lt;code&gt;HashMap&lt;/code&gt; 。たとえば、2つの別々のベクトルにチーム名と初期スコアがある場合、 &lt;code&gt;zip&lt;/code&gt; メソッドを使用して、「Blue」が10とペアになっているタプルのベクトルを作成できます。次に、リスト8-21に示すように、 &lt;code&gt;collect&lt;/code&gt; メソッドを使用して、タプルのベクトルをハッシュマップに変換します。</target>
        </trans-unit>
        <trans-unit id="56bc825abe2ef1255ee87da2e4f261c23258e491" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">&lt;code&gt;flat_map()&lt;/code&gt; についての別の考え方：&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;のクロージャは各要素に対して1つのアイテムを返し、 &lt;code&gt;flat_map()&lt;/code&gt; のクロージャは各要素に対してイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="590fe2daae703b4f29d9d514cb7fe9863489ba23" translate="yes" xml:space="preserve">
          <source>Another way to access union fields is to use pattern matching. Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field. Since pattern matching is like reading the union with a particular field, it has to be placed in &lt;code&gt;unsafe&lt;/code&gt; blocks as well.</source>
          <target state="translated">ユニオンフィールドにアクセスする別の方法は、パターンマッチングを使用することです。ユニオンフィールドのパターンマッチングでは、構造体パターンと同じ構文を使用しますが、パターンではフィールドを1つだけ指定する必要があります。パターンマッチングは、特定のフィールドでユニオンを読み取るようなものなので、 &lt;code&gt;unsafe&lt;/code&gt; でないブロックにも配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="1b9e5f7972ceab35649387701cac506db165c92f" translate="yes" xml:space="preserve">
          <source>Another way to have a collection of multiple values is with an &lt;em&gt;array&lt;/em&gt;. Unlike a tuple, every element of an array must have the same type. Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.</source>
          <target state="translated">複数の値のコレクションを作成する別の方法は、&lt;em&gt;配列を使用すること&lt;/em&gt;です。タプルとは異なり、配列のすべての要素は同じ型でなければなりません。Rustの配列はタプルのように固定長であるため、Rustの配列は他のいくつかの言語の配列とは異なります。</target>
        </trans-unit>
        <trans-unit id="6b16dbbf7d35ba29c07c44408e5ca0fc777803bb" translate="yes" xml:space="preserve">
          <source>Another way to provide the compiler with enough information, is to specify the generic type parameter:</source>
          <target state="translated">コンパイラに十分な情報を提供するもう一つの方法は、汎用型パラメータを指定することです。</target>
        </trans-unit>
        <trans-unit id="9b14c4635b7e156ee560ca02ddafb5c338efe01a" translate="yes" xml:space="preserve">
          <source>Another way we could implement &lt;code&gt;largest&lt;/code&gt; is for the function to return a reference to a &lt;code&gt;T&lt;/code&gt; value in the slice. If we change the return type to &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;T&lt;/code&gt;, thereby changing the body of the function to return a reference, we wouldn&amp;rsquo;t need the &lt;code&gt;Clone&lt;/code&gt; or &lt;code&gt;Copy&lt;/code&gt; trait bounds and we could avoid heap allocations. Try implementing these alternate solutions on your own!</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 値を実装できるもう1つの方法は、関数がスライス内の &lt;code&gt;T&lt;/code&gt; 値への参照を返すことです。我々は戻り値の型を変更した場合は &lt;code&gt;&amp;amp;T&lt;/code&gt; の代わりに &lt;code&gt;T&lt;/code&gt; これにより、参照を返すように関数の本体を変更し、我々は必要はありません &lt;code&gt;Clone&lt;/code&gt; または &lt;code&gt;Copy&lt;/code&gt; 形質境界を、私たちは、ヒープ割り当てを避けることができます。これらの代替ソリューションを自分で実装してみてください！</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="28a9dd9802c2f2d457b2df1a706228a0fe1e9650" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">どれ &lt;code&gt;BuildHasherDefault&lt;/code&gt; はある&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;ゼロ・サイズ&lt;/a&gt;。&lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;で作成できます。&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;BuildHasherDefault&lt;/code&gt; を使用する場合、適切な&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;インスタンス自体を実装するため、これを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="61c0cc711bc6806236220ae14adf5485763a3373" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;enum&lt;/code&gt; value consumes as much memory as the largest variant for its corresponding &lt;code&gt;enum&lt;/code&gt; type, as well as the size needed to store a discriminant.</source>
          <target state="translated">任意の &lt;code&gt;enum&lt;/code&gt; それに対応するための最大の変種として多くのメモリとしての価値が消費 &lt;code&gt;enum&lt;/code&gt; タイプと同様に、判別式を格納するのに必要なサイズ。</target>
        </trans-unit>
        <trans-unit id="6ab54097a9523b84f57f773009ba255a131e3917" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;with_capacity&lt;/code&gt; constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. See collection-specific documentation for details. In general, use &lt;code&gt;with_capacity&lt;/code&gt; when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.</source>
          <target state="translated">どれ &lt;code&gt;with_capacity&lt;/code&gt; のコンストラクタは、要素の指定された数のための十分なスペースを割り当てるコレクションを指示します。理想的には、これはまさにその多くの要素に対するものですが、実装の詳細によってはこれを防ぐことができます。詳細については、コレクション固有のドキュメントを参照してください。一般に、挿入される要素の数が正確にわかっている場合、または少なくともその数に適切な上限がある場合は、 &lt;code&gt;with_capacity&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0b673eb46a7f5984769da2ecfe123198574739d4" translate="yes" xml:space="preserve">
          <source>Any I/O error not part of this list.</source>
          <target state="translated">このリストに含まれない任意の I/O エラー。</target>
        </trans-unit>
        <trans-unit id="6867ac894a456ea99c7c6870f309c422acaaf4df" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of the variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">どのIPアドレスもバージョン4かバージョン6のどちらかになりますが、同時に両方になることはありません。IP アドレスのこの性質は enum データ構造を適切なものにしています。バージョン4もバージョン6も基本的にはIPアドレスなので、コードがどのような種類のIPアドレスにも適用される状況を扱う場合には、それらは同じ型として扱われるべきです。</target>
        </trans-unit>
        <trans-unit id="771cc11d8125e00769bce8eb3a9472fcb3c21cb2" translate="yes" xml:space="preserve">
          <source>Any character in the 'printable ASCII' range &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; inclusive is not escaped.</source>
          <target state="translated">「印刷可能なASCII」の範囲 &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; を含む文字はエスケープされません。</target>
        </trans-unit>
        <trans-unit id="3e6eb82cfd1ccce10703d68820085fb1a0e36401" translate="yes" xml:space="preserve">
          <source>Any characters, except this sequence</source>
          <target state="translated">このシーケンス以外の任意の文字</target>
        </trans-unit>
        <trans-unit id="4cd23fb2001ef303a1bdb9cc4bb51ec0898b0bb8" translate="yes" xml:space="preserve">
          <source>Any characters, except those listed</source>
          <target state="translated">記載されている文字以外の任意の文字</target>
        </trans-unit>
        <trans-unit id="de99d379f5705cbf09c5d5e30200a62d7427ee91" translate="yes" xml:space="preserve">
          <source>Any excess capacity is removed:</source>
          <target state="translated">余った容量は削除されます。</target>
        </trans-unit>
        <trans-unit id="4eba9dcc5c9c9c3a4fc6d9f7d5233af8a7847a24" translate="yes" xml:space="preserve">
          <source>Any kind of aggregate constructor (array, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, tuple, ...)</source>
          <target state="translated">あらゆる種類の集約コンストラクター（配列、 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 、タプルなど）</target>
        </trans-unit>
        <trans-unit id="a2d418110b6f755d1311536fe4acdfee5af1facd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error.</source>
          <target state="translated">任意のサフィックスを持つリテラル (文字列、整数など)はトークンとして有効であり、エラーを発生させることなくマクロに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="4cbac428240bad16fb03767cc5cca3e5e71622e2" translate="yes" xml:space="preserve">
          <source>Any non-Unicode sequences are replaced with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">非Unicodeシーケンスは&lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; に&lt;/a&gt;置き換えられます。</target>
        </trans-unit>
        <trans-unit id="3df46fe98310c858bb458ed2bc6017d791596b12" translate="yes" xml:space="preserve">
          <source>Any of the characters in the range</source>
          <target state="translated">範囲内の任意の文字</target>
        </trans-unit>
        <trans-unit id="df4bb3c1fbc6102d5b31f44ab7298372090f0684" translate="yes" xml:space="preserve">
          <source>Any of the characters listed</source>
          <target state="translated">記載されているキャラクターのいずれか</target>
        </trans-unit>
        <trans-unit id="e1fe17e124adf671f41a6bcdb30bc09a9767a019" translate="yes" xml:space="preserve">
          <source>Any of the methods provided by a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; trait implemented by &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a type parameter, methods provided by trait bounds on &lt;code&gt;T&lt;/code&gt; are looked up first. Then all remaining methods in scope are looked up.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; によって実装される&lt;a href=&quot;../visibility-and-privacy&quot;&gt;目に見える&lt;/a&gt;特性によって提供されるメソッドのいずれか。場合 &lt;code&gt;T&lt;/code&gt; は、タイプパラメータである、上で形質境界によって提供される方法 &lt;code&gt;T&lt;/code&gt; は、最初に検索されます。次に、スコープ内の残りのすべてのメソッドが検索されます。</target>
        </trans-unit>
        <trans-unit id="e19f15fb75a4bf5f47bda7e931808400dd6bf097" translate="yes" xml:space="preserve">
          <source>Any other changes attempted on a post should have no effect. For example, if we try to approve a draft blog post before we&amp;rsquo;ve requested a review, the post should remain an unpublished draft.</source>
          <target state="translated">投稿に対して行われたその他の変更は影響を与えません。たとえば、レビューをリクエストする前に下書きのブログ投稿を承認しようとした場合、その投稿は未公開の下書きのままにしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="d6894150447e47d12e66ba741e1dc8f000de5b10" translate="yes" xml:space="preserve">
          <source>Any other chars are given hex escapes of the form '\xNN'.</source>
          <target state="translated">他の文字は '\xNN' という形式のヘックスエスケープが与えられます。</target>
        </trans-unit>
        <trans-unit id="c7e7ce7ad0344363614031d689f8048423505a67" translate="yes" xml:space="preserve">
          <source>Any resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state. However, it does not guarantee that pointers to this memory will remain valid.</source>
          <target state="translated">ヒープメモリやファイルハンドルなど、値が管理するリソースは、到達不可能な状態で永遠に残ります。しかし、このメモリへのポインタが有効なままであることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="4582f1278b61140a4c03b6946eaab9c9e43377c3" translate="yes" xml:space="preserve">
          <source>Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">数値以外のリテラルトークンにはサフィックスを付けることはできません。</target>
        </trans-unit>
        <trans-unit id="972a6afc1089fd19efd410e0369cd9e91a4ef0f3" translate="yes" xml:space="preserve">
          <source>Any time a type or function is provided by the standard library and you&amp;rsquo;re not sure what it does or how to use it, use the application programming interface (API) documentation to find out!</source>
          <target state="translated">型または関数が標準ライブラリによって提供されていて、その機能や使用方法がわからない場合は、アプリケーションプログラミングインターフェイス（API）のドキュメントを使用して調べてください。</target>
        </trans-unit>
        <trans-unit id="76deb7250dd43b06f05ef65522ed5c978849b0e5" translate="yes" xml:space="preserve">
          <source>Any type composed entirely of &lt;code&gt;Send&lt;/code&gt; types is automatically marked as &lt;code&gt;Send&lt;/code&gt; as well. Almost all primitive types are &lt;code&gt;Send&lt;/code&gt;, aside from raw pointers, which we&amp;rsquo;ll discuss in Chapter 19.</source>
          <target state="translated">完全に &lt;code&gt;Send&lt;/code&gt; タイプで構成されるタイプはすべて、自動的に &lt;code&gt;Send&lt;/code&gt; としてもマークされます。ほぼすべてのプリミティブ型は &lt;code&gt;Send&lt;/code&gt; ですが、これについては第19章で説明する生のポインタを除きます。</target>
        </trans-unit>
        <trans-unit id="af69a2cb47235b6ee090b2e8285120ce18b240b2" translate="yes" xml:space="preserve">
          <source>Any type parameter or lifetime parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; のタイプパラメータまたはライフタイムパラメータは、次の基準の少なくとも1つを満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="07027ef0df88ca520ae158040613bfcdb04fbd90" translate="yes" xml:space="preserve">
          <source>Any types with interior mutability must also use the &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;cell::UnsafeCell&lt;/code&gt;&lt;/a&gt; wrapper around the value(s) which can be mutated through a shared reference. Failing to doing this is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. For example, &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt;-ing from &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is invalid.</source>
          <target state="translated">内部で変更可能なタイプでは、共有参照を介して変更できる値の周りに&lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;cell::UnsafeCell&lt;/code&gt; &lt;/a&gt;ラッパーも使用する必要があります。これを実行し&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;ない&lt;/a&gt;と、未定義の動作になります。例えば、&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt;から-ing &lt;code&gt;&amp;amp;T&lt;/code&gt; に &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 無効です。</target>
        </trans-unit>
        <trans-unit id="4098bab2016a26a2da921c6a4c090c6509eb5934" translate="yes" xml:space="preserve">
          <source>Any use other than with &lt;code&gt;if&lt;/code&gt; statements will probably not have an effect.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; ステートメント以外で使用しても、おそらく効果はありません。</target>
        </trans-unit>
        <trans-unit id="910dd93279c47bcced2d261d2b21071bc5cf465a" translate="yes" xml:space="preserve">
          <source>Any::downcast_mut</source>
          <target state="translated">Any::downcast_mut</target>
        </trans-unit>
        <trans-unit id="3142933cd2ff31b31d3f631fe20ea508e96ad05b" translate="yes" xml:space="preserve">
          <source>Any::downcast_ref</source>
          <target state="translated">Any::downcast_ref</target>
        </trans-unit>
        <trans-unit id="47853f41e226da1c34d9eedcdb8b975ed79ec7bc" translate="yes" xml:space="preserve">
          <source>Any::fmt</source>
          <target state="translated">Any::fmt</target>
        </trans-unit>
        <trans-unit id="63f0fc770b243d87075e5d22567fc12df96b560f" translate="yes" xml:space="preserve">
          <source>Any::is</source>
          <target state="translated">Any::is</target>
        </trans-unit>
        <trans-unit id="153b1345e60af7ce7872d3438b64b0f7f8addb2c" translate="yes" xml:space="preserve">
          <source>Any::type_id</source>
          <target state="translated">Any::type_id</target>
        </trans-unit>
        <trans-unit id="4cde3fadbf976f0b359d3c2a1968c555ccde759f" translate="yes" xml:space="preserve">
          <source>Anyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by the Rust team, which is comprised of many topic subteams. There&amp;rsquo;s a full list of the teams &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;on Rust&amp;rsquo;s website&lt;/a&gt;, which includes teams for each area of the project: language design, compiler implementation, infrastructure, documentation, and more. The appropriate team reads the proposal and the comments, writes some comments of their own, and eventually, there&amp;rsquo;s consensus to accept or reject the feature.</source>
          <target state="translated">Rustを改善するために誰でもRFCを作成でき、提案は多くのトピックサブチームで構成されるRustチームによってレビューおよび議論されます。&lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;RustのWebサイトには&lt;/a&gt;、言語の設計、コンパイラーの実装、インフラストラクチャ、ドキュメントなど、プロジェクトの各領域のチームを含むチームの完全なリストがあります。適切なチームが提案とコメントを読み、独自のコメントをいくつか書き込みます。最終的には、機能を受け入れるか拒否するかについてのコンセンサスがあります。</target>
        </trans-unit>
        <trans-unit id="53fc70bfdc4b06ea1c2fe17e53fbb9c43726838e" translate="yes" xml:space="preserve">
          <source>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</source>
          <target state="translated">一般的な型パラメータを持つメソッドや関数とは別に、構造体や形質の型パラメータが推論できない場合に、このエラーが発生することがあります。その場合、すべての候補が同じ戻り値の型を持っているため、型アノテーションを使用することができない場合があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="56e2c591df0fef929570597dca64284006730141" translate="yes" xml:space="preserve">
          <source>Appending to a String with &lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; と &lt;code&gt;push&lt;/code&gt; を使用して文字列に追加する</target>
        </trans-unit>
        <trans-unit id="f3f60044b06335eb6c4230e3c39f5e0218445878" translate="yes" xml:space="preserve">
          <source>Appendix</source>
          <target state="translated">Appendix</target>
        </trans-unit>
        <trans-unit id="4c40c194c9cdc4d680691d4aa8fa1913dc98b2c3" translate="yes" xml:space="preserve">
          <source>Appendix A, &amp;ldquo;Keywords,&amp;rdquo; also explains the new raw identifiers feature that enables code written in the 2015 Edition and the 2018 Edition to interoperate.</source>
          <target state="translated">付録A「キーワード」では、2015 Editionと2018 Editionで記述されたコードの相互運用を可能にする新しい未加工識別子機能についても説明しています。</target>
        </trans-unit>
        <trans-unit id="8415247b515164394b09f1335fc5dabc83b9e17a" translate="yes" xml:space="preserve">
          <source>Appendix A: Keywords</source>
          <target state="translated">付録A:キーワード</target>
        </trans-unit>
        <trans-unit id="540243de89d6ff78feccd1151f1eeb23d45eae75" translate="yes" xml:space="preserve">
          <source>Appendix B: Operators and Symbols</source>
          <target state="translated">付録B:オペレータと記号</target>
        </trans-unit>
        <trans-unit id="e440a4e5c41dd9d1d57a9a1afc26c19786ef345a" translate="yes" xml:space="preserve">
          <source>Appendix C: Derivable Traits</source>
          <target state="translated">付録C:派生形質</target>
        </trans-unit>
        <trans-unit id="41116b5529dd9b48afe443e282c8edc6aed9a707" translate="yes" xml:space="preserve">
          <source>Appendix D - Useful Development Tools</source>
          <target state="translated">付録D-便利な開発ツール</target>
        </trans-unit>
        <trans-unit id="707523bd94a1c061f370a00dc35452edc4f5ca2b" translate="yes" xml:space="preserve">
          <source>Appendix D is now titled &amp;ldquo;Useful Development Tools&amp;rdquo; and covers recently released tools that help you write Rust code.</source>
          <target state="translated">付録Dのタイトルは「便利な開発ツール」になり、Rustコードの記述に役立つ最近リリースされたツールについて説明しています。</target>
        </trans-unit>
        <trans-unit id="e50a67316708bcdc8cd3a1c83a15ee617b6e1717" translate="yes" xml:space="preserve">
          <source>Appendix E - Editions</source>
          <target state="translated">付録E-エディション</target>
        </trans-unit>
        <trans-unit id="db95e2a46f6e17f889e1ec8cb84b232b2ac6a554" translate="yes" xml:space="preserve">
          <source>Appendix F: Translations of the Book</source>
          <target state="translated">付録F:本の翻訳</target>
        </trans-unit>
        <trans-unit id="cd9cd2e1d4c917e818f77ba2a0d93ffcdf7874d2" translate="yes" xml:space="preserve">
          <source>Appendix G - How Rust is Made and &amp;ldquo;Nightly Rust&amp;rdquo;</source>
          <target state="translated">付録G-錆の作り方と「毎晩錆び」</target>
        </trans-unit>
        <trans-unit id="7ea8d3526ea6b8af40ac97da94b0ad40d6cea127" translate="yes" xml:space="preserve">
          <source>Appendix chapters providing rationale and references to languages that influenced the design.</source>
          <target state="translated">デザインに影響を与えた言語の根拠と参照を提供する付録の章。</target>
        </trans-unit>
        <trans-unit id="0d6a0bfa8816321ae3291d75b6bf84f8077fe48b" translate="yes" xml:space="preserve">
          <source>Appendix: Macro Follow-Set Ambiguity Formal Specification</source>
          <target state="translated">付録 マクロフォローセットの曖昧さ 形式的な仕様</target>
        </trans-unit>
        <trans-unit id="54e814d184dccc0b7473b24d35812b283adff9c0" translate="yes" xml:space="preserve">
          <source>Appends a given string slice onto the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">指定された文字列スライスをこの &lt;code&gt;String&lt;/code&gt; の最後に追加します。</target>
        </trans-unit>
        <trans-unit id="bd5ef47a12f2696c33dc462f202e22f6e229647a" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a collection.</source>
          <target state="translated">コレクションの後ろに要素を追加します。</target>
        </trans-unit>
        <trans-unit id="ddf4cf8edbc5fa033e85502f0a84bfe8b2914aec" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a list.</source>
          <target state="translated">リストの後ろに要素を追加します。</target>
        </trans-unit>
        <trans-unit id="9427717eceb820f7ae4720310e1343f09df153f2" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of the &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の後ろに要素を追加します。</target>
        </trans-unit>
        <trans-unit id="373311f9bb46882cd119d03cfc2b6fa19fdf5ba3" translate="yes" xml:space="preserve">
          <source>Appends the given &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;をこの &lt;code&gt;String&lt;/code&gt; の最後に追加します。</target>
        </trans-unit>
        <trans-unit id="f88d43733a3d3b030bf7286e9ed4c303cc3a7d2b" translate="yes" xml:space="preserve">
          <source>Application Binary Interface (ABI)</source>
          <target state="translated">アプリケーションバイナリインタフェース(ABI)</target>
        </trans-unit>
        <trans-unit id="bed8e79e380caf3902110314a704f53a22b3ecbe" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or computes a default (if not).</source>
          <target state="translated">含まれている値に関数を適用し(あれば)、デフォルト値を計算します(なければ)。</target>
        </trans-unit>
        <trans-unit id="ef8795473614177b83e201e3db900beeef41c1e2" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or returns the provided default (if not).</source>
          <target state="translated">含まれる値に関数を適用し(あれば)、指定されたデフォルト値を返します(なければ)。</target>
        </trans-unit>
        <trans-unit id="a6be2123eb22e6f1506885d0c1439a3655475eac" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result.</source>
          <target state="translated">イテレータの要素に関数を適用し、最初の非ゼロの結果を返します。</target>
        </trans-unit>
        <trans-unit id="2f579750efee0b6f5e959f71ab15df216a9fb1b9" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7da1899028718ec8a07b6c08455d63f4e3489b90" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f3002a1274a5209b380bd8bf18387ed22cf040f" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67cbbc3631a3803076e70ec9a10a8358879f6e02" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8819d96feaef2f02cd8965c68d9eb2580ebfc977" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ff8e99aa0f8295d1776562bee993cb0a364606b" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function.</source>
          <target state="translated">「？」を適用します オペレーター。 &lt;code&gt;Ok(t)&lt;/code&gt; の戻り値は、実行が正常に継続する必要があることを意味し、 &lt;code&gt;?&lt;/code&gt; 値 &lt;code&gt;t&lt;/code&gt; です。 &lt;code&gt;Err(e)&lt;/code&gt; の戻り値は、実行が最も内側の外側の &lt;code&gt;catch&lt;/code&gt; に分岐するか、関数から戻る必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="d771dbfeb7c050dea75fe4d6749833e3ae20e4ae" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">「？」を適用します オペレーター。 &lt;code&gt;Ok(t)&lt;/code&gt; の戻り値は、実行が正常に継続する必要があることを意味し、 &lt;code&gt;?&lt;/code&gt; 値 &lt;code&gt;t&lt;/code&gt; です。 &lt;code&gt;Err(e)&lt;/code&gt; の戻り値は、実行が最も内側の外側の &lt;code&gt;catch&lt;/code&gt; に分岐するか、関数から戻る必要があることを意味します。&lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e15c6fd69af4acca9c9f459c798f3ae0c37890f" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10.</source>
          <target state="translated">ベース10の有効数字のおおよその数。</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="59cfa485c658b8f9969a88c2eb92540fdf722cfd" translate="yes" xml:space="preserve">
          <source>Arc::as_ref</source>
          <target state="translated">Arc::as_ref</target>
        </trans-unit>
        <trans-unit id="2f1c5ec3613e810179b1dde9e1ff629a07f45de3" translate="yes" xml:space="preserve">
          <source>Arc::borrow</source>
          <target state="translated">Arc::borrow</target>
        </trans-unit>
        <trans-unit id="e6381920a9fbe9f6076603c436d6eef9b74e1f24" translate="yes" xml:space="preserve">
          <source>Arc::borrow_mut</source>
          <target state="translated">Arc::borrow_mut</target>
        </trans-unit>
        <trans-unit id="de0c16869f1a3fad5d726dc3e3fba2293f156861" translate="yes" xml:space="preserve">
          <source>Arc::clamp</source>
          <target state="translated">Arc::clamp</target>
        </trans-unit>
        <trans-unit id="9fa492e8fa6e20e1b52a4de7403dbe55ec1b79bf" translate="yes" xml:space="preserve">
          <source>Arc::clone</source>
          <target state="translated">Arc::clone</target>
        </trans-unit>
        <trans-unit id="39cf0d205cd739521ce28938f9a2250155c1bac4" translate="yes" xml:space="preserve">
          <source>Arc::clone_from</source>
          <target state="translated">Arc::clone_from</target>
        </trans-unit>
        <trans-unit id="773d06cfd159d4606ff3014fee5f9931067cf220" translate="yes" xml:space="preserve">
          <source>Arc::clone_into</source>
          <target state="translated">Arc::clone_into</target>
        </trans-unit>
        <trans-unit id="7561059135cbd0c5fbb5238091fd429a9e1b09c1" translate="yes" xml:space="preserve">
          <source>Arc::cmp</source>
          <target state="translated">Arc::cmp</target>
        </trans-unit>
        <trans-unit id="b73ea8e602ed4ab4007a418f3f6cee6a05a73996" translate="yes" xml:space="preserve">
          <source>Arc::default</source>
          <target state="translated">Arc::default</target>
        </trans-unit>
        <trans-unit id="cdd18aaa5e1ccdcb1656e6b3c539ea6dd22d2613" translate="yes" xml:space="preserve">
          <source>Arc::deref</source>
          <target state="translated">Arc::deref</target>
        </trans-unit>
        <trans-unit id="3d5ef1d21d6636272bbb1c82a7af354e776cadde" translate="yes" xml:space="preserve">
          <source>Arc::downcast</source>
          <target state="translated">Arc::downcast</target>
        </trans-unit>
        <trans-unit id="8f4a9849100a7720ad47a02d98c3cc428143986f" translate="yes" xml:space="preserve">
          <source>Arc::downgrade</source>
          <target state="translated">Arc::downgrade</target>
        </trans-unit>
        <trans-unit id="4d05d06001426353e874710f4e01911168266628" translate="yes" xml:space="preserve">
          <source>Arc::drop</source>
          <target state="translated">Arc::drop</target>
        </trans-unit>
        <trans-unit id="d616628ce7e2e600feb8196c85f5e01fa37ae824" translate="yes" xml:space="preserve">
          <source>Arc::eq</source>
          <target state="translated">Arc::eq</target>
        </trans-unit>
        <trans-unit id="541daae394114016fc018c7425373988b033cde5" translate="yes" xml:space="preserve">
          <source>Arc::fmt</source>
          <target state="translated">Arc::fmt</target>
        </trans-unit>
        <trans-unit id="c5939b1aa685e46bfb67eeb83668be8ab9a5dab1" translate="yes" xml:space="preserve">
          <source>Arc::from</source>
          <target state="translated">Arc::from</target>
        </trans-unit>
        <trans-unit id="dea799f19377ba936fa669465a1dea313ae3aa7a" translate="yes" xml:space="preserve">
          <source>Arc::from_raw</source>
          <target state="translated">Arc::from_raw</target>
        </trans-unit>
        <trans-unit id="6910e0ecb20317c068e1ba9e8ebf007d417f95a2" translate="yes" xml:space="preserve">
          <source>Arc::ge</source>
          <target state="translated">Arc::ge</target>
        </trans-unit>
        <trans-unit id="7e24d2d9f75e2ea02439ac0bd0d3b07ceaa736e4" translate="yes" xml:space="preserve">
          <source>Arc::get_mut</source>
          <target state="translated">Arc::get_mut</target>
        </trans-unit>
        <trans-unit id="e94b486a276abc7bcb5888a4d6fc97a6fa8eebaa" translate="yes" xml:space="preserve">
          <source>Arc::gt</source>
          <target state="translated">Arc::gt</target>
        </trans-unit>
        <trans-unit id="f233cce03a62c687a1d4be5e670e3be37d179359" translate="yes" xml:space="preserve">
          <source>Arc::hash</source>
          <target state="translated">Arc::hash</target>
        </trans-unit>
        <trans-unit id="963937d635066d272a6f67596279f6b16956abdb" translate="yes" xml:space="preserve">
          <source>Arc::hash_slice</source>
          <target state="translated">Arc::hash_slice</target>
        </trans-unit>
        <trans-unit id="2b8954f29938fa3429d664d59b2922996301d34a" translate="yes" xml:space="preserve">
          <source>Arc::into</source>
          <target state="translated">Arc::into</target>
        </trans-unit>
        <trans-unit id="24e83cc9b0b264818fc7b3695d912fc8e4d9e845" translate="yes" xml:space="preserve">
          <source>Arc::into_raw</source>
          <target state="translated">Arc::into_raw</target>
        </trans-unit>
        <trans-unit id="921d5aa53e181c2612da9bf23381db35c63bd321" translate="yes" xml:space="preserve">
          <source>Arc::into_raw_non_null</source>
          <target state="translated">Arc::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="f3473006930ab6b55f7aef32c93c0af0f87e7790" translate="yes" xml:space="preserve">
          <source>Arc::le</source>
          <target state="translated">Arc::le</target>
        </trans-unit>
        <trans-unit id="34b95793d03cc8c6cef222cea98c6e99dc74e9e2" translate="yes" xml:space="preserve">
          <source>Arc::lt</source>
          <target state="translated">Arc::lt</target>
        </trans-unit>
        <trans-unit id="eab1ca96353cac811bc765a502fbbe1723278950" translate="yes" xml:space="preserve">
          <source>Arc::make_mut</source>
          <target state="translated">Arc::make_mut</target>
        </trans-unit>
        <trans-unit id="0a9a2e87881627fae4b58af4ea1e4cdaa0c36395" translate="yes" xml:space="preserve">
          <source>Arc::max</source>
          <target state="translated">Arc::max</target>
        </trans-unit>
        <trans-unit id="431ba8a8a73b16f867d8367c027605d9a9f25a4e" translate="yes" xml:space="preserve">
          <source>Arc::min</source>
          <target state="translated">Arc::min</target>
        </trans-unit>
        <trans-unit id="a700586ffae96fc24dca7f29fd88b64a47bae03d" translate="yes" xml:space="preserve">
          <source>Arc::ne</source>
          <target state="translated">Arc::ne</target>
        </trans-unit>
        <trans-unit id="1311cfe952a5208cf9ab108dab2eb693395bbca1" translate="yes" xml:space="preserve">
          <source>Arc::new</source>
          <target state="translated">Arc::new</target>
        </trans-unit>
        <trans-unit id="2c2d4efc7b27aae2edec462666037bcaf500cae7" translate="yes" xml:space="preserve">
          <source>Arc::partial_cmp</source>
          <target state="translated">Arc::partial_cmp</target>
        </trans-unit>
        <trans-unit id="41a523a445899356c297537c4b72fff018176305" translate="yes" xml:space="preserve">
          <source>Arc::pin</source>
          <target state="translated">Arc::pin</target>
        </trans-unit>
        <trans-unit id="1d09dbe8f647daf2ca429c9d36141d61d7d2799f" translate="yes" xml:space="preserve">
          <source>Arc::ptr_eq</source>
          <target state="translated">Arc::ptr_eq</target>
        </trans-unit>
        <trans-unit id="ec8427607c6875d57c1cbb7ae116c8a1b2bc9f8b" translate="yes" xml:space="preserve">
          <source>Arc::strong_count</source>
          <target state="translated">Arc::strong_count</target>
        </trans-unit>
        <trans-unit id="12f7dc5817d10cbbabc6ff3c697a1ca67ff339d5" translate="yes" xml:space="preserve">
          <source>Arc::to_owned</source>
          <target state="translated">Arc::to_owned</target>
        </trans-unit>
        <trans-unit id="dd1da4e8925e8953dfb4aef0354dd388c867af08" translate="yes" xml:space="preserve">
          <source>Arc::to_string</source>
          <target state="translated">Arc::to_string</target>
        </trans-unit>
        <trans-unit id="b36b4607ae74c4708612a87739b787ab550df768" translate="yes" xml:space="preserve">
          <source>Arc::try_from</source>
          <target state="translated">Arc::try_from</target>
        </trans-unit>
        <trans-unit id="450b59e4892b86614294b44b39674630d4067a1f" translate="yes" xml:space="preserve">
          <source>Arc::try_into</source>
          <target state="translated">Arc::try_into</target>
        </trans-unit>
        <trans-unit id="8cc0a8e7a4fa3ddf0be44f0e2f8210b7538bff4d" translate="yes" xml:space="preserve">
          <source>Arc::try_unwrap</source>
          <target state="translated">Arc::try_unwrap</target>
        </trans-unit>
        <trans-unit id="e60b417105d1b796fbb9108c579b5a5a3f60ab78" translate="yes" xml:space="preserve">
          <source>Arc::type_id</source>
          <target state="translated">Arc::type_id</target>
        </trans-unit>
        <trans-unit id="6623270e41b383306513b26dd0972d02a62dabdc" translate="yes" xml:space="preserve">
          <source>Arc::weak_count</source>
          <target state="translated">Arc::weak_count</target>
        </trans-unit>
        <trans-unit id="bcef6163f2366764b97712c1e02d4e8de8728060" translate="yes" xml:space="preserve">
          <source>Archimedes' constant (&amp;pi;)</source>
          <target state="translated">アルキメデスの定数（&amp;pi;）</target>
        </trans-unit>
        <trans-unit id="02d36a6ada7ba4a678771b24dc19a1d26e06d584" translate="yes" xml:space="preserve">
          <source>Are allowed to be null</source>
          <target state="translated">nullであることが許されています。</target>
        </trans-unit>
        <trans-unit id="7bcd778277bf4c00f69bda3256c3718425635b4a" translate="yes" xml:space="preserve">
          <source>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</source>
          <target state="translated">同じ場所への不変型と変異型の両方のポインタ、または複数の変異型ポインタを持つことで、借用ルールを無視することができます。</target>
        </trans-unit>
        <trans-unit id="79232b3ded8b7d0b1c86ea5d989ec5b302602c26" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t guaranteed to point to valid memory</source>
          <target state="translated">有効なメモリを指すことが保証されていません</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="11997e344b54f51ca26eed6c34abb35c17719846" translate="yes" xml:space="preserve">
          <source>Args::all</source>
          <target state="translated">Args::all</target>
        </trans-unit>
        <trans-unit id="834e48f2681bde9c6de2a1d6fe4ea459480940da" translate="yes" xml:space="preserve">
          <source>Args::any</source>
          <target state="translated">Args::any</target>
        </trans-unit>
        <trans-unit id="852de3f0c6270398ac654986a4377df5f50c393c" translate="yes" xml:space="preserve">
          <source>Args::borrow</source>
          <target state="translated">Args::borrow</target>
        </trans-unit>
        <trans-unit id="8aa2c84655d80e6196471b5bce3e6eb8f9d79f61" translate="yes" xml:space="preserve">
          <source>Args::borrow_mut</source>
          <target state="translated">Args::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6235293cd6910b3c74977e8687ec90afadb03077" translate="yes" xml:space="preserve">
          <source>Args::by_ref</source>
          <target state="translated">Args::by_ref</target>
        </trans-unit>
        <trans-unit id="4438640d50dfd08974f7aac6bf0d2aecb461c3f5" translate="yes" xml:space="preserve">
          <source>Args::chain</source>
          <target state="translated">Args::chain</target>
        </trans-unit>
        <trans-unit id="fd443c43e63db2a659b5f263c42823b6b670bd44" translate="yes" xml:space="preserve">
          <source>Args::cloned</source>
          <target state="translated">Args::cloned</target>
        </trans-unit>
        <trans-unit id="46277936c8445a042e94cc3a26942468f91253e9" translate="yes" xml:space="preserve">
          <source>Args::cmp</source>
          <target state="translated">Args::cmp</target>
        </trans-unit>
        <trans-unit id="48dd95fc8d6a07728f5a1cf7809d55524bf20034" translate="yes" xml:space="preserve">
          <source>Args::collect</source>
          <target state="translated">Args::collect</target>
        </trans-unit>
        <trans-unit id="9d0c9a3a72db97b3f6cab2b952f231796f20a50c" translate="yes" xml:space="preserve">
          <source>Args::copied</source>
          <target state="translated">Args::copied</target>
        </trans-unit>
        <trans-unit id="4fbeb4376f2e8b5f2155e6dbdec8f0740c8c04c9" translate="yes" xml:space="preserve">
          <source>Args::count</source>
          <target state="translated">Args::count</target>
        </trans-unit>
        <trans-unit id="4a06de4989ebe4016d146a0bb3c59a627e816965" translate="yes" xml:space="preserve">
          <source>Args::cycle</source>
          <target state="translated">Args::cycle</target>
        </trans-unit>
        <trans-unit id="dbd2a1eb1e566bd90b7919caa38a19ccb4685bdf" translate="yes" xml:space="preserve">
          <source>Args::enumerate</source>
          <target state="translated">Args::enumerate</target>
        </trans-unit>
        <trans-unit id="d22f2ebcc4f66631a8b99dffd5e42317b95a23c3" translate="yes" xml:space="preserve">
          <source>Args::eq</source>
          <target state="translated">Args::eq</target>
        </trans-unit>
        <trans-unit id="825fef0560348f1a6b9c4b27b6c58018c4f453ef" translate="yes" xml:space="preserve">
          <source>Args::filter</source>
          <target state="translated">Args::filter</target>
        </trans-unit>
        <trans-unit id="ab08ac4972fbd0c43add6cedcff53d5b9d40bc35" translate="yes" xml:space="preserve">
          <source>Args::filter_map</source>
          <target state="translated">Args::filter_map</target>
        </trans-unit>
        <trans-unit id="86056472eedb8eee7dbef63077919c7204cfa67b" translate="yes" xml:space="preserve">
          <source>Args::find</source>
          <target state="translated">Args::find</target>
        </trans-unit>
        <trans-unit id="e877bf0f63fb53fe48a38a7b49bdba91724d4dc9" translate="yes" xml:space="preserve">
          <source>Args::find_map</source>
          <target state="translated">Args::find_map</target>
        </trans-unit>
        <trans-unit id="09774b60a814c8b4104b1538a3d2232fe023f569" translate="yes" xml:space="preserve">
          <source>Args::flat_map</source>
          <target state="translated">Args::flat_map</target>
        </trans-unit>
        <trans-unit id="5eeb63d240af1b2ec0ce621fdcebe38dd652ee35" translate="yes" xml:space="preserve">
          <source>Args::flatten</source>
          <target state="translated">Args::flatten</target>
        </trans-unit>
        <trans-unit id="2824f41303961ce133138bbb9cdb7c73c49c034e" translate="yes" xml:space="preserve">
          <source>Args::fmt</source>
          <target state="translated">Args::fmt</target>
        </trans-unit>
        <trans-unit id="bdc321df53c7563363bb091073cc745371fec866" translate="yes" xml:space="preserve">
          <source>Args::fold</source>
          <target state="translated">Args::fold</target>
        </trans-unit>
        <trans-unit id="0bfb713bd78f482e7b1b8ccad2fb85c3059b45d0" translate="yes" xml:space="preserve">
          <source>Args::for_each</source>
          <target state="translated">Args::for_each</target>
        </trans-unit>
        <trans-unit id="bf62c774de1d7877320ea0fd8f640a1da6f668ae" translate="yes" xml:space="preserve">
          <source>Args::from</source>
          <target state="translated">Args::from</target>
        </trans-unit>
        <trans-unit id="4b2d02be4c99f1b285f809b3bada4d6e1d5de2c4" translate="yes" xml:space="preserve">
          <source>Args::fuse</source>
          <target state="translated">Args::fuse</target>
        </trans-unit>
        <trans-unit id="e9d47e65f07958eb4c539e9aa4794d4c91301d74" translate="yes" xml:space="preserve">
          <source>Args::ge</source>
          <target state="translated">Args::ge</target>
        </trans-unit>
        <trans-unit id="41716a498dc92ecead97571d6a7701faab3446af" translate="yes" xml:space="preserve">
          <source>Args::gt</source>
          <target state="translated">Args::gt</target>
        </trans-unit>
        <trans-unit id="ffe407b598fd64603f4cdfacf4c22332227c8373" translate="yes" xml:space="preserve">
          <source>Args::inspect</source>
          <target state="translated">Args::inspect</target>
        </trans-unit>
        <trans-unit id="4982b89e7bce55b901b94270e4e00a5ac09ba3e0" translate="yes" xml:space="preserve">
          <source>Args::into</source>
          <target state="translated">Args::into</target>
        </trans-unit>
        <trans-unit id="2fc7d02ccfe30c7d6decfb090f0a5dcabb2e0c43" translate="yes" xml:space="preserve">
          <source>Args::into_iter</source>
          <target state="translated">Args::into_iter</target>
        </trans-unit>
        <trans-unit id="0cc324954d5e5cfc9f0640a45fd39c06463171c8" translate="yes" xml:space="preserve">
          <source>Args::is_empty</source>
          <target state="translated">Args::is_empty</target>
        </trans-unit>
        <trans-unit id="9320ccfba6fb85da2cd8f4ea07146d9e90d55e69" translate="yes" xml:space="preserve">
          <source>Args::is_sorted</source>
          <target state="translated">Args::is_sorted</target>
        </trans-unit>
        <trans-unit id="18a7ac322b2479e407afbb8da7a0d6e559099523" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by</source>
          <target state="translated">Args::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d806d23a84355aca10dbfd0171313e44075d284" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by_key</source>
          <target state="translated">Args::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="c6efefb9b080afb608e934c39e299c62aaaa6fc0" translate="yes" xml:space="preserve">
          <source>Args::last</source>
          <target state="translated">Args::last</target>
        </trans-unit>
        <trans-unit id="04a547ce59955db8d408e3c98a9edc55fc1c82e5" translate="yes" xml:space="preserve">
          <source>Args::le</source>
          <target state="translated">Args::le</target>
        </trans-unit>
        <trans-unit id="f88c3621988f7c3fdb34fd16f1e9ea82cfbcea71" translate="yes" xml:space="preserve">
          <source>Args::len</source>
          <target state="translated">Args::len</target>
        </trans-unit>
        <trans-unit id="01c7bcbbd63e3d113fbbd64d77442cb638b835d1" translate="yes" xml:space="preserve">
          <source>Args::lt</source>
          <target state="translated">Args::lt</target>
        </trans-unit>
        <trans-unit id="039581be23b84f6e55f8a2add1bc6bfa811639f2" translate="yes" xml:space="preserve">
          <source>Args::map</source>
          <target state="translated">Args::map</target>
        </trans-unit>
        <trans-unit id="994f671b6e95e4ae34dd6e2c082281ea8ea61313" translate="yes" xml:space="preserve">
          <source>Args::max</source>
          <target state="translated">Args::max</target>
        </trans-unit>
        <trans-unit id="74a4e2d3f00af26f6a0ad2245e073d3b5a0cd3d2" translate="yes" xml:space="preserve">
          <source>Args::max_by</source>
          <target state="translated">Args::max_by</target>
        </trans-unit>
        <trans-unit id="deb310f6f85b56ebc7fe38e266f44493563fc6cf" translate="yes" xml:space="preserve">
          <source>Args::max_by_key</source>
          <target state="translated">Args::max_by_key</target>
        </trans-unit>
        <trans-unit id="dde4047d67a5b16733c51e9703c57fbdf575a4e4" translate="yes" xml:space="preserve">
          <source>Args::min</source>
          <target state="translated">Args::min</target>
        </trans-unit>
        <trans-unit id="403ed2480b700e9a65c715919e29b948e24f4b97" translate="yes" xml:space="preserve">
          <source>Args::min_by</source>
          <target state="translated">Args::min_by</target>
        </trans-unit>
        <trans-unit id="61041884b34bb5182aa5504e5448d5bac7a830ec" translate="yes" xml:space="preserve">
          <source>Args::min_by_key</source>
          <target state="translated">Args::min_by_key</target>
        </trans-unit>
        <trans-unit id="254900be5bd6dab1a3e1e8f2d8135ce517862048" translate="yes" xml:space="preserve">
          <source>Args::ne</source>
          <target state="translated">Args::ne</target>
        </trans-unit>
        <trans-unit id="d7cb929a8cedef153a932b274a4aba45b153fd66" translate="yes" xml:space="preserve">
          <source>Args::next</source>
          <target state="translated">Args::next</target>
        </trans-unit>
        <trans-unit id="2dcb9f5424d93dea8b755e44bed8488448308f48" translate="yes" xml:space="preserve">
          <source>Args::next_back</source>
          <target state="translated">Args::next_back</target>
        </trans-unit>
        <trans-unit id="7117eeb7949ae721ac3782d5eedc483a09ccac61" translate="yes" xml:space="preserve">
          <source>Args::nth</source>
          <target state="translated">Args::nth</target>
        </trans-unit>
        <trans-unit id="920bfede689288166976e1de3db01783fca343a2" translate="yes" xml:space="preserve">
          <source>Args::nth_back</source>
          <target state="translated">Args::nth_back</target>
        </trans-unit>
        <trans-unit id="827560f3761313e8fff14e1e90ac372f2bcfaccc" translate="yes" xml:space="preserve">
          <source>Args::partial_cmp</source>
          <target state="translated">Args::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fd69506fed5f2e3f675c8f01ed77c7a8573ed9f" translate="yes" xml:space="preserve">
          <source>Args::partition</source>
          <target state="translated">Args::partition</target>
        </trans-unit>
        <trans-unit id="0f80b2cd77c5343960cc6f37513564b206a6f770" translate="yes" xml:space="preserve">
          <source>Args::peekable</source>
          <target state="translated">Args::peekable</target>
        </trans-unit>
        <trans-unit id="d35d46b1d259e3d81a7c87e03f05934ae588d4a7" translate="yes" xml:space="preserve">
          <source>Args::position</source>
          <target state="translated">Args::position</target>
        </trans-unit>
        <trans-unit id="4ed9e8e605899d2c4c96340af8f07ac7b263210f" translate="yes" xml:space="preserve">
          <source>Args::product</source>
          <target state="translated">Args::product</target>
        </trans-unit>
        <trans-unit id="eb295f32cccde70f35d8df7df01c50708f27bd93" translate="yes" xml:space="preserve">
          <source>Args::rev</source>
          <target state="translated">Args::rev</target>
        </trans-unit>
        <trans-unit id="98d2de96a420de7658219d3f9bda5b24ca2443f7" translate="yes" xml:space="preserve">
          <source>Args::rfind</source>
          <target state="translated">Args::rfind</target>
        </trans-unit>
        <trans-unit id="3cc34e3e8eb1da327b82585d5a13fd8b2bb5890e" translate="yes" xml:space="preserve">
          <source>Args::rfold</source>
          <target state="translated">Args::rfold</target>
        </trans-unit>
        <trans-unit id="3a7a7236e75fdfae5572db48f2aad6e6378da2eb" translate="yes" xml:space="preserve">
          <source>Args::rposition</source>
          <target state="translated">Args::rposition</target>
        </trans-unit>
        <trans-unit id="9fc0f79d5cd6405747d8f5be32af5064749f81b9" translate="yes" xml:space="preserve">
          <source>Args::scan</source>
          <target state="translated">Args::scan</target>
        </trans-unit>
        <trans-unit id="12148001c865165a5de07ba3c727c97aab92c761" translate="yes" xml:space="preserve">
          <source>Args::size_hint</source>
          <target state="translated">Args::size_hint</target>
        </trans-unit>
        <trans-unit id="1189df09a529d4be32c97dfca9793d84611fd824" translate="yes" xml:space="preserve">
          <source>Args::skip</source>
          <target state="translated">Args::skip</target>
        </trans-unit>
        <trans-unit id="764acccc052619da2c47813fd259dab289d9bd67" translate="yes" xml:space="preserve">
          <source>Args::skip_while</source>
          <target state="translated">Args::skip_while</target>
        </trans-unit>
        <trans-unit id="904035ea6ead93ad6bd21ffe6010b797797cfccb" translate="yes" xml:space="preserve">
          <source>Args::step_by</source>
          <target state="translated">Args::step_by</target>
        </trans-unit>
        <trans-unit id="d5a7f219c1fc0a0f719ef62e5e91b056ae17a132" translate="yes" xml:space="preserve">
          <source>Args::sum</source>
          <target state="translated">Args::sum</target>
        </trans-unit>
        <trans-unit id="27af1223e3252d8316e5510ef65c11dd18e7e048" translate="yes" xml:space="preserve">
          <source>Args::take</source>
          <target state="translated">Args::take</target>
        </trans-unit>
        <trans-unit id="70510b85e050ccfd0ca156b8552398d830c8ca29" translate="yes" xml:space="preserve">
          <source>Args::take_while</source>
          <target state="translated">Args::take_while</target>
        </trans-unit>
        <trans-unit id="29671ebf88bfe467b330af20810dd95f14bee716" translate="yes" xml:space="preserve">
          <source>Args::try_fold</source>
          <target state="translated">Args::try_fold</target>
        </trans-unit>
        <trans-unit id="11314668861a5fe3812661a0778a42dd4d60ecc6" translate="yes" xml:space="preserve">
          <source>Args::try_for_each</source>
          <target state="translated">Args::try_for_each</target>
        </trans-unit>
        <trans-unit id="a3e7a43251306d98977b3648cb61a36b6b67f71f" translate="yes" xml:space="preserve">
          <source>Args::try_from</source>
          <target state="translated">Args::try_from</target>
        </trans-unit>
        <trans-unit id="ea7b4151424c750739941030cbfa813500f83861" translate="yes" xml:space="preserve">
          <source>Args::try_into</source>
          <target state="translated">Args::try_into</target>
        </trans-unit>
        <trans-unit id="a09bc59807578d3bfcb3f5e6f7f7b11ca71a5fda" translate="yes" xml:space="preserve">
          <source>Args::try_rfold</source>
          <target state="translated">Args::try_rfold</target>
        </trans-unit>
        <trans-unit id="ef5ea75da51804787206df18b378f5490fe6418b" translate="yes" xml:space="preserve">
          <source>Args::type_id</source>
          <target state="translated">Args::type_id</target>
        </trans-unit>
        <trans-unit id="3e828aa1b5449d683bef869c26ce0986ec45e670" translate="yes" xml:space="preserve">
          <source>Args::unzip</source>
          <target state="translated">Args::unzip</target>
        </trans-unit>
        <trans-unit id="468f2b4280fd073d79df60860923a06807813556" translate="yes" xml:space="preserve">
          <source>Args::zip</source>
          <target state="translated">Args::zip</target>
        </trans-unit>
        <trans-unit id="08a635e24e7197ec936245f74886d0fae256f6f3" translate="yes" xml:space="preserve">
          <source>ArgsOs</source>
          <target state="translated">ArgsOs</target>
        </trans-unit>
        <trans-unit id="1699d7288d57eee287607a5a8cf4daa06cbf36b5" translate="yes" xml:space="preserve">
          <source>ArgsOs::all</source>
          <target state="translated">ArgsOs::all</target>
        </trans-unit>
        <trans-unit id="1845d364695de9046a1a2e308d836950518c8379" translate="yes" xml:space="preserve">
          <source>ArgsOs::any</source>
          <target state="translated">ArgsOs::any</target>
        </trans-unit>
        <trans-unit id="b88db8b95877207b42c5e88cfc5b222b32d38f42" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow</source>
          <target state="translated">ArgsOs::borrow</target>
        </trans-unit>
        <trans-unit id="6883c744eb4014b5c2b448f2adc1b25a04e5fc9e" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow_mut</source>
          <target state="translated">ArgsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="54a7160bba6f31fb20a2a3b6f79944613335629e" translate="yes" xml:space="preserve">
          <source>ArgsOs::by_ref</source>
          <target state="translated">ArgsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="45e9d062b28c81d2586823abf5265cf79f0f53c3" translate="yes" xml:space="preserve">
          <source>ArgsOs::chain</source>
          <target state="translated">ArgsOs::chain</target>
        </trans-unit>
        <trans-unit id="06a86328c3295b9577a55fd6532e3d512a4376ad" translate="yes" xml:space="preserve">
          <source>ArgsOs::cloned</source>
          <target state="translated">ArgsOs::cloned</target>
        </trans-unit>
        <trans-unit id="aa33a26c7a85d39e633ece2b7ab215364fa8c21f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cmp</source>
          <target state="translated">ArgsOs::cmp</target>
        </trans-unit>
        <trans-unit id="4444bf776c1fcbbef6e3005b548a29289b32ecc4" translate="yes" xml:space="preserve">
          <source>ArgsOs::collect</source>
          <target state="translated">ArgsOs::collect</target>
        </trans-unit>
        <trans-unit id="efa527796ad53e7b95c87dfbab81f527bd59777a" translate="yes" xml:space="preserve">
          <source>ArgsOs::copied</source>
          <target state="translated">ArgsOs::copied</target>
        </trans-unit>
        <trans-unit id="cf8617f607b90e848c8eda2dcecf733646bd740b" translate="yes" xml:space="preserve">
          <source>ArgsOs::count</source>
          <target state="translated">ArgsOs::count</target>
        </trans-unit>
        <trans-unit id="9774f0ee5373559d8ebaf6e270d32276c2460f0f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cycle</source>
          <target state="translated">ArgsOs::cycle</target>
        </trans-unit>
        <trans-unit id="0c42cc7e9e0e5f5dcbc76f351e7fb1817634bb40" translate="yes" xml:space="preserve">
          <source>ArgsOs::enumerate</source>
          <target state="translated">ArgsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="d5b0b5b450101b6daed6089615021285ab2aa9bc" translate="yes" xml:space="preserve">
          <source>ArgsOs::eq</source>
          <target state="translated">ArgsOs::eq</target>
        </trans-unit>
        <trans-unit id="22ebb6f40c3d512ac39613bf4969beaa463bb89c" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter</source>
          <target state="translated">ArgsOs::filter</target>
        </trans-unit>
        <trans-unit id="ec9b19d64b96da14ed417d0d212d3d54ea4a4759" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter_map</source>
          <target state="translated">ArgsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="f90d91bcb86730d9c77f4746181813b55b242a5f" translate="yes" xml:space="preserve">
          <source>ArgsOs::find</source>
          <target state="translated">ArgsOs::find</target>
        </trans-unit>
        <trans-unit id="8c42c2da49296751bd09d90e62d79798dd8f5449" translate="yes" xml:space="preserve">
          <source>ArgsOs::find_map</source>
          <target state="translated">ArgsOs::find_map</target>
        </trans-unit>
        <trans-unit id="8ae8230900a56717520df737b9d2946aa58958f4" translate="yes" xml:space="preserve">
          <source>ArgsOs::flat_map</source>
          <target state="translated">ArgsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="582b0a8882844e707b1b16686981fe8a3215c0f7" translate="yes" xml:space="preserve">
          <source>ArgsOs::flatten</source>
          <target state="translated">ArgsOs::flatten</target>
        </trans-unit>
        <trans-unit id="42a3165a3645e00a5c082e56522288eb3545955a" translate="yes" xml:space="preserve">
          <source>ArgsOs::fmt</source>
          <target state="translated">ArgsOs::fmt</target>
        </trans-unit>
        <trans-unit id="c973a490f8d75776d7cc21ebc26d8640412d8da5" translate="yes" xml:space="preserve">
          <source>ArgsOs::fold</source>
          <target state="translated">ArgsOs::fold</target>
        </trans-unit>
        <trans-unit id="521243a10a5ee6932b3c00a38bb64a1066346423" translate="yes" xml:space="preserve">
          <source>ArgsOs::for_each</source>
          <target state="translated">ArgsOs::for_each</target>
        </trans-unit>
        <trans-unit id="b3beb1c32ac134bd58a5525cb75b6818caadc2e7" translate="yes" xml:space="preserve">
          <source>ArgsOs::from</source>
          <target state="translated">ArgsOs::from</target>
        </trans-unit>
        <trans-unit id="0467b6e7a5907960746adb88f1797855273e5e38" translate="yes" xml:space="preserve">
          <source>ArgsOs::fuse</source>
          <target state="translated">ArgsOs::fuse</target>
        </trans-unit>
        <trans-unit id="8d918573a70aed631b8ef7e464f6978aeac45512" translate="yes" xml:space="preserve">
          <source>ArgsOs::ge</source>
          <target state="translated">ArgsOs::ge</target>
        </trans-unit>
        <trans-unit id="ed7bd18154ad5939e8306b095fe2d6551d9c5960" translate="yes" xml:space="preserve">
          <source>ArgsOs::gt</source>
          <target state="translated">ArgsOs::gt</target>
        </trans-unit>
        <trans-unit id="f6ab996f18c666c657723e3d6b826e9d4f34afa4" translate="yes" xml:space="preserve">
          <source>ArgsOs::inspect</source>
          <target state="translated">ArgsOs::inspect</target>
        </trans-unit>
        <trans-unit id="118a0e4c62985069de5d564f7e5aeaefdb4f3eee" translate="yes" xml:space="preserve">
          <source>ArgsOs::into</source>
          <target state="translated">ArgsOs::into</target>
        </trans-unit>
        <trans-unit id="6fe469f351f3d71c45f5b8b8a01a85ba417f2962" translate="yes" xml:space="preserve">
          <source>ArgsOs::into_iter</source>
          <target state="translated">ArgsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="52e21117a73746309084ded1b85082f14e2f4f3c" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_empty</source>
          <target state="translated">ArgsOs::is_empty</target>
        </trans-unit>
        <trans-unit id="bc22f51d728c32072e58dab02dc3f74a273221da" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted</source>
          <target state="translated">ArgsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="6ce480c601285e3d630fdd46e557dfb3c792fc47" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by</source>
          <target state="translated">ArgsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="1bd6484be8e79119af4f357c6727e9cce127bfb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by_key</source>
          <target state="translated">ArgsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2960d55410634dcaa01ebfd4efb87d3210b4b30b" translate="yes" xml:space="preserve">
          <source>ArgsOs::last</source>
          <target state="translated">ArgsOs::last</target>
        </trans-unit>
        <trans-unit id="49cd1005a59ab868a13fc3b698fa037af9e3cc25" translate="yes" xml:space="preserve">
          <source>ArgsOs::le</source>
          <target state="translated">ArgsOs::le</target>
        </trans-unit>
        <trans-unit id="9662bed516b84aec77303964e4aba365d517a6ce" translate="yes" xml:space="preserve">
          <source>ArgsOs::len</source>
          <target state="translated">ArgsOs::len</target>
        </trans-unit>
        <trans-unit id="a4fd3a509313cc726b4eb5e364e66dd0311cbccc" translate="yes" xml:space="preserve">
          <source>ArgsOs::lt</source>
          <target state="translated">ArgsOs::lt</target>
        </trans-unit>
        <trans-unit id="b4ee6f488be886ab0828730edfa187e1158ffbf4" translate="yes" xml:space="preserve">
          <source>ArgsOs::map</source>
          <target state="translated">ArgsOs::map</target>
        </trans-unit>
        <trans-unit id="ae8b8dee55299bdeb6e240152d7d260302e580f0" translate="yes" xml:space="preserve">
          <source>ArgsOs::max</source>
          <target state="translated">ArgsOs::max</target>
        </trans-unit>
        <trans-unit id="f393dc70d5755703ad87bcd703e01acde42fd52e" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by</source>
          <target state="translated">ArgsOs::max_by</target>
        </trans-unit>
        <trans-unit id="c3d12b23ad084b94bc1bb5877f3a0e669b6dcbe5" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by_key</source>
          <target state="translated">ArgsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="1877909fb92070e732d578d5a61015d6567d1c05" translate="yes" xml:space="preserve">
          <source>ArgsOs::min</source>
          <target state="translated">ArgsOs::min</target>
        </trans-unit>
        <trans-unit id="1b9560ee3684ef678a7f2060396e14192ebd977a" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by</source>
          <target state="translated">ArgsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce07e6453a52864ecbf5f176d284c9622c84c927" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by_key</source>
          <target state="translated">ArgsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="77abc8099c1b361ea642538729c1cfa9c4ad2af8" translate="yes" xml:space="preserve">
          <source>ArgsOs::ne</source>
          <target state="translated">ArgsOs::ne</target>
        </trans-unit>
        <trans-unit id="94df206ce16974feea2fee745eeb9bededb98233" translate="yes" xml:space="preserve">
          <source>ArgsOs::next</source>
          <target state="translated">ArgsOs::next</target>
        </trans-unit>
        <trans-unit id="0b4bd6a54c1bdb1cb1c37909c4bbdf8ee8eedba4" translate="yes" xml:space="preserve">
          <source>ArgsOs::next_back</source>
          <target state="translated">ArgsOs::next_back</target>
        </trans-unit>
        <trans-unit id="32001a37fe7fa6c38a9dab6e3ccac83215a6af0b" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth</source>
          <target state="translated">ArgsOs::nth</target>
        </trans-unit>
        <trans-unit id="eed0fe5e0346646ed8f493e45f87707e6ef665d0" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth_back</source>
          <target state="translated">ArgsOs::nth_back</target>
        </trans-unit>
        <trans-unit id="76d2262b3586a0b114f133d396c15e36cdbd64ee" translate="yes" xml:space="preserve">
          <source>ArgsOs::partial_cmp</source>
          <target state="translated">ArgsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c88ee3f44d1aaf87a7e7075664272abea7e57c22" translate="yes" xml:space="preserve">
          <source>ArgsOs::partition</source>
          <target state="translated">ArgsOs::partition</target>
        </trans-unit>
        <trans-unit id="b772163bfba047ed1ad9679588037cc0b2a982a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::peekable</source>
          <target state="translated">ArgsOs::peekable</target>
        </trans-unit>
        <trans-unit id="28f42c15452e45ff29cd38077309d81cd1bf23ef" translate="yes" xml:space="preserve">
          <source>ArgsOs::position</source>
          <target state="translated">ArgsOs::position</target>
        </trans-unit>
        <trans-unit id="9c54799fe9d66e9fe809d53c0ad35f91d0345b2d" translate="yes" xml:space="preserve">
          <source>ArgsOs::product</source>
          <target state="translated">ArgsOs::product</target>
        </trans-unit>
        <trans-unit id="24d0c67c7635532e04027af92577d329d52e0d8d" translate="yes" xml:space="preserve">
          <source>ArgsOs::rev</source>
          <target state="translated">ArgsOs::rev</target>
        </trans-unit>
        <trans-unit id="9a893fd65a1fd7e4f90c4c16dad18ae09e1e6440" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfind</source>
          <target state="translated">ArgsOs::rfind</target>
        </trans-unit>
        <trans-unit id="2473c6d05109d83b7921dc7c8d9e3fd3e1540366" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfold</source>
          <target state="translated">ArgsOs::rfold</target>
        </trans-unit>
        <trans-unit id="61e2d2493b8b480b1c184877bc7c4508f85f3e68" translate="yes" xml:space="preserve">
          <source>ArgsOs::rposition</source>
          <target state="translated">ArgsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f7c9d7d4183c0e1185d8f756359b7aa52e99dec6" translate="yes" xml:space="preserve">
          <source>ArgsOs::scan</source>
          <target state="translated">ArgsOs::scan</target>
        </trans-unit>
        <trans-unit id="be9f72e6896d64043f92118bf0351dd06875451e" translate="yes" xml:space="preserve">
          <source>ArgsOs::size_hint</source>
          <target state="translated">ArgsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="dfcbf514097e12c73f97a48d644499d52e01f449" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip</source>
          <target state="translated">ArgsOs::skip</target>
        </trans-unit>
        <trans-unit id="b5cea38564a840936b5adf617a54cb9e1705e9a4" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip_while</source>
          <target state="translated">ArgsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="bd31eff15f1513280f3660b278f44b8403fe5bb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::step_by</source>
          <target state="translated">ArgsOs::step_by</target>
        </trans-unit>
        <trans-unit id="b896b50f4e9946df9f811558add55e6c7f4d9c0e" translate="yes" xml:space="preserve">
          <source>ArgsOs::sum</source>
          <target state="translated">ArgsOs::sum</target>
        </trans-unit>
        <trans-unit id="55f7ee9ef7a277d1da50d3847c5267d10c02f3d6" translate="yes" xml:space="preserve">
          <source>ArgsOs::take</source>
          <target state="translated">ArgsOs::take</target>
        </trans-unit>
        <trans-unit id="67ae1d83993d54c201cebc7e961a4745875403a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::take_while</source>
          <target state="translated">ArgsOs::take_while</target>
        </trans-unit>
        <trans-unit id="6feaa7bb16a2f86b2de35c4152c898840e5c73a7" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_fold</source>
          <target state="translated">ArgsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="4de4927e12902d929342841a0f0a05adc02a2b88" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_for_each</source>
          <target state="translated">ArgsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="ef2e8777c2c6780af369e18d8923c4a5b07b73cc" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_from</source>
          <target state="translated">ArgsOs::try_from</target>
        </trans-unit>
        <trans-unit id="dde21f1986a82cfe6d32ebda71aaf8cffb865725" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_into</source>
          <target state="translated">ArgsOs::try_into</target>
        </trans-unit>
        <trans-unit id="752061f583e2a023f82e25f293fbc12638874e24" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_rfold</source>
          <target state="translated">ArgsOs::try_rfold</target>
        </trans-unit>
        <trans-unit id="9cea18d9f52cf4e66c35caae6f3a3d7426f8ebf1" translate="yes" xml:space="preserve">
          <source>ArgsOs::type_id</source>
          <target state="translated">ArgsOs::type_id</target>
        </trans-unit>
        <trans-unit id="dcc7a51ed1d3dac6d37f7b6f7415fe425b54aac1" translate="yes" xml:space="preserve">
          <source>ArgsOs::unzip</source>
          <target state="translated">ArgsOs::unzip</target>
        </trans-unit>
        <trans-unit id="0477d6e4f174e07114d3143d029569031152c407" translate="yes" xml:space="preserve">
          <source>ArgsOs::zip</source>
          <target state="translated">ArgsOs::zip</target>
        </trans-unit>
        <trans-unit id="bd7faaad666e01c1bc85c0559542193db97f87bb" translate="yes" xml:space="preserve">
          <source>Argument and element separator</source>
          <target state="translated">引数と要素のセパレータ</target>
        </trans-unit>
        <trans-unit id="0e653d9296c0f3183cfcfa59576a82649ae7862d" translate="yes" xml:space="preserve">
          <source>Argument types</source>
          <target state="translated">引数の種類</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a3115a849e9a8fd08f66c020b31248aefac3bb62" translate="yes" xml:space="preserve">
          <source>Arguments for function calls</source>
          <target state="translated">関数呼び出しの引数</target>
        </trans-unit>
        <trans-unit id="60b48e4141151169e113485ecab80a4bb3c30bdc" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;ok_or&lt;/code&gt; に渡される引数は熱心に評価されます。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b34ba4a25e5cb9253c52e9c96f12b4a3b5b442c1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">渡された、 &lt;code&gt;or&lt;/code&gt; 熱心に評価される引数。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="81e7e0f40306bc29fb2793ce221652d077995d0b" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; に渡される引数は熱心に評価されます。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ca682bb604cd951faf7e687e9dc577ccfb4ccbcc" translate="yes" xml:space="preserve">
          <source>Arguments::borrow</source>
          <target state="translated">Arguments::borrow</target>
        </trans-unit>
        <trans-unit id="02b0d59380fa1adbbfa0a4e488839d014c6a84b9" translate="yes" xml:space="preserve">
          <source>Arguments::borrow_mut</source>
          <target state="translated">Arguments::borrow_mut</target>
        </trans-unit>
        <trans-unit id="beee63977406683694c63c877a281368e8498185" translate="yes" xml:space="preserve">
          <source>Arguments::clone</source>
          <target state="translated">Arguments::clone</target>
        </trans-unit>
        <trans-unit id="9b4336ed72fcc8790d465ff622f1ee33ef64dd5f" translate="yes" xml:space="preserve">
          <source>Arguments::clone_from</source>
          <target state="translated">Arguments::clone_from</target>
        </trans-unit>
        <trans-unit id="9f534ce31b28796358e33f058c8f30771441c413" translate="yes" xml:space="preserve">
          <source>Arguments::clone_into</source>
          <target state="translated">Arguments::clone_into</target>
        </trans-unit>
        <trans-unit id="e2264984672013569ff3cb5667d1fb059d3a9aff" translate="yes" xml:space="preserve">
          <source>Arguments::fmt</source>
          <target state="translated">Arguments::fmt</target>
        </trans-unit>
        <trans-unit id="e6967e42010df585387f1e1ee0a1ddd2861644a6" translate="yes" xml:space="preserve">
          <source>Arguments::from</source>
          <target state="translated">Arguments::from</target>
        </trans-unit>
        <trans-unit id="f7110cbfaa9d19f7a1a5d2f96c337419907bb156" translate="yes" xml:space="preserve">
          <source>Arguments::into</source>
          <target state="translated">Arguments::into</target>
        </trans-unit>
        <trans-unit id="f71fad745c8ecba4adbbf940ce0a934c1bbb9409" translate="yes" xml:space="preserve">
          <source>Arguments::to_owned</source>
          <target state="translated">Arguments::to_owned</target>
        </trans-unit>
        <trans-unit id="2f1106daf75575ebf9ff5096d88d4bd32bee8e3a" translate="yes" xml:space="preserve">
          <source>Arguments::to_string</source>
          <target state="translated">Arguments::to_string</target>
        </trans-unit>
        <trans-unit id="44514fad8f521c67acba588fe00d7592016a908f" translate="yes" xml:space="preserve">
          <source>Arguments::try_from</source>
          <target state="translated">Arguments::try_from</target>
        </trans-unit>
        <trans-unit id="8bb902c723ba932ded5aa3da8d68330e0bd8dfdd" translate="yes" xml:space="preserve">
          <source>Arguments::try_into</source>
          <target state="translated">Arguments::try_into</target>
        </trans-unit>
        <trans-unit id="93c384146f511c59251c10079f21618fcc345340" translate="yes" xml:space="preserve">
          <source>Arguments::type_id</source>
          <target state="translated">Arguments::type_id</target>
        </trans-unit>
        <trans-unit id="52ed5399cec328eed1c4d10b234f6d54945d8379" translate="yes" xml:space="preserve">
          <source>Arithmetic addition</source>
          <target state="translated">算術加算</target>
        </trans-unit>
        <trans-unit id="b6a2b173c28c2d32e0f07c5865706f1a0af1dc82" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and assignment</source>
          <target state="translated">算数の足し算と代入</target>
        </trans-unit>
        <trans-unit id="481206dd7e4055d67971a43266f17dd6c8acf74d" translate="yes" xml:space="preserve">
          <source>Arithmetic and Logical Binary Operators</source>
          <target state="translated">算術演算子と論理二項演算子</target>
        </trans-unit>
        <trans-unit id="ba8c163933eb964b78854dfa7b1e1313a4ece109" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operators on integers</source>
          <target state="translated">整数上の算術演算子と比較演算子</target>
        </trans-unit>
        <trans-unit id="3a2ccea0b8aef06fcf5a90ab7c705782be897b40" translate="yes" xml:space="preserve">
          <source>Arithmetic division</source>
          <target state="translated">算術分割</target>
        </trans-unit>
        <trans-unit id="dfc8f592565726eb9a5251995ebe9c35af2683f2" translate="yes" xml:space="preserve">
          <source>Arithmetic division and assignment</source>
          <target state="translated">算術の除算と代入</target>
        </trans-unit>
        <trans-unit id="5e0f6d1b7afc18895e08ec06673e25445eca9bd9" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication</source>
          <target state="translated">算術の掛け算</target>
        </trans-unit>
        <trans-unit id="aed641007b737ba787b84c11db1a76f81a7265ec" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication and assignment</source>
          <target state="translated">算数の掛け算と代入</target>
        </trans-unit>
        <trans-unit id="9501694b83625ba1c4c32e0300c7e3ef0ea5895a" translate="yes" xml:space="preserve">
          <source>Arithmetic negation</source>
          <target state="translated">算術否定</target>
        </trans-unit>
        <trans-unit id="4b7e345ffd8cb02b4c25248f3c2916dd526e2269" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder</source>
          <target state="translated">算術残数</target>
        </trans-unit>
        <trans-unit id="4af14fe332c2fec7e550537a659d27f7672cf52b" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder and assignment</source>
          <target state="translated">算術の余白と代入</target>
        </trans-unit>
        <trans-unit id="54604a8945847efcfbb8925458787851115f9296" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction</source>
          <target state="translated">算術減算</target>
        </trans-unit>
        <trans-unit id="40c2d180ceb1daebfda27a7dc052bf6e18437123" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction and assignment</source>
          <target state="translated">算数の引き算と代入</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="1fd516c87a7c389dccca9649a7b656d2f047d85d" translate="yes" xml:space="preserve">
          <source>Arity refers to the number of arguments a function or operator takes. For some examples, &lt;code&gt;f(2, 3)&lt;/code&gt; and &lt;code&gt;g(4, 6)&lt;/code&gt; have arity 2, while &lt;code&gt;h(8, 2, 6)&lt;/code&gt; has arity 3. The &lt;code&gt;!&lt;/code&gt; operator has arity 1.</source>
          <target state="translated">アリティは、関数または演算子が取る引数の数を指します。いくつかの例については、 &lt;code&gt;f(2, 3)&lt;/code&gt; 及び &lt;code&gt;g(4, 6)&lt;/code&gt; しながら、アリティ2を持っている &lt;code&gt;h(8, 2, 6)&lt;/code&gt; アリティ3.有します &lt;code&gt;!&lt;/code&gt; オペレーターはアリティ1を持っています。</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e88a1d916bd09fa0781281dd0639410541b1c200" translate="yes" xml:space="preserve">
          <source>Array Layout</source>
          <target state="translated">配列レイアウト</target>
        </trans-unit>
        <trans-unit id="811e7deb41b753134a124c771bc129d2aad4f69f" translate="yes" xml:space="preserve">
          <source>Array and array index expressions</source>
          <target state="translated">配列と配列インデックス式</target>
        </trans-unit>
        <trans-unit id="0844515b5a634fa1753332ae502ec5bc059c9bf4" translate="yes" xml:space="preserve">
          <source>Array and slice indexing expressions</source>
          <target state="translated">配列とスライスのインデキシング式</target>
        </trans-unit>
        <trans-unit id="1c901b7185d5b71317418dac8afa7a9edb10a639" translate="yes" xml:space="preserve">
          <source>Array expression attributes</source>
          <target state="translated">配列式の属性</target>
        </trans-unit>
        <trans-unit id="ff659441b84e2964045ca09a8c18a08d44b84a61" translate="yes" xml:space="preserve">
          <source>Array expressions</source>
          <target state="translated">配列表現</target>
        </trans-unit>
        <trans-unit id="b4a857fc21bf592938e9dd2ec1d467878b6cf83e" translate="yes" xml:space="preserve">
          <source>Array literal</source>
          <target state="translated">配列リテラル</target>
        </trans-unit>
        <trans-unit id="4935b8502c9911035c4038af29553fcfde8b5706" translate="yes" xml:space="preserve">
          <source>Array literal containing &lt;code&gt;len&lt;/code&gt; copies of &lt;code&gt;expr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; の &lt;code&gt;len&lt;/code&gt; 個のコピーを含む配列リテラル</target>
        </trans-unit>
        <trans-unit id="235f924c7c3818aed78845bd2de8791d4d3ba101" translate="yes" xml:space="preserve">
          <source>Array literals with repeating syntax, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. The repeated sub-expression is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">構文が繰り返される配列リテラル &lt;code&gt;[U; n]&lt;/code&gt; 配列のタイプは[U; n]。繰り返される部分式は、タイプ &lt;code&gt;U&lt;/code&gt; への強制型変換の強制型サイトです。</target>
        </trans-unit>
        <trans-unit id="41d08ca772cf664e0e365d09949f5835931ea185" translate="yes" xml:space="preserve">
          <source>Array literals, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. Each sub-expression in the array literal is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">配列リテラル &lt;code&gt;[U; n]&lt;/code&gt; 配列のタイプは[U; n]。配列リテラルの各部分式は、 &lt;code&gt;U&lt;/code&gt; 型を強制するための強制サイトです。</target>
        </trans-unit>
        <trans-unit id="ea9dbd560327931c17a47c31880f0fcea2d052f4" translate="yes" xml:space="preserve">
          <source>Array to pointer cast</source>
          <target state="translated">ポインタキャスト先の配列</target>
        </trans-unit>
        <trans-unit id="45de270a590c4d4b0320d8105310eb72bc4364df" translate="yes" xml:space="preserve">
          <source>Array type containing &lt;code&gt;len&lt;/code&gt; instances of &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">含むアレイ型 &lt;code&gt;len&lt;/code&gt; のインスタンス &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51a7c3ed1d5f017cc725067fca3064cb604b7344" translate="yes" xml:space="preserve">
          <source>Array type length expressions</source>
          <target state="translated">配列型の長さ表現</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="51fa61d38d898a29b7f71e858ac412133bb4aa78" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">項目タイプも &lt;code&gt;Clone&lt;/code&gt; を実装する場合、すべてのサイズの配列タイプ（例： &lt;code&gt;[i32; 123456]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c11c5b2f8cc2056c662bde9d8e7265077775fda2" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">すべてのサイズの配列タイプ（アイテムタイプが &lt;code&gt;Copy&lt;/code&gt; も実装している場合）（例： &lt;code&gt;[i32; 123456]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="aa557f1be66399eaf12f2be07d75660861cacf56" translate="yes" xml:space="preserve">
          <source>Arrays are laid out so that the &lt;code&gt;nth&lt;/code&gt; element of the array is offset from the start of the array by &lt;code&gt;n * the size of the type&lt;/code&gt; bytes. An array of &lt;code&gt;[T; n]&lt;/code&gt; has a size of &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; and the same alignment of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">配列は、配列の &lt;code&gt;nth&lt;/code&gt; 要素が配列の先頭から &lt;code&gt;n * the size of the type&lt;/code&gt; バイトのサイズだけオフセットされるようにレイアウトされます。 &lt;code&gt;[T; n]&lt;/code&gt; の配列n]のサイズは &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; で、 &lt;code&gt;T&lt;/code&gt; と同じ配置です。</target>
        </trans-unit>
        <trans-unit id="02fe2a892020ef77103f56bebff06ee9353b3385" translate="yes" xml:space="preserve">
          <source>Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn&amp;rsquo;t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that &lt;em&gt;is&lt;/em&gt; allowed to grow or shrink in size. If you&amp;rsquo;re unsure whether to use an array or a vector, you should probably use a vector. Chapter 8 discusses vectors in more detail.</source>
          <target state="translated">配列は、ヒープではなくスタックにデータを割り当てたい場合（スタックとヒープについては第4章で詳しく説明します）、または常に固定数の要素があることを確認する場合に便利です。ただし、配列はベクトル型ほど柔軟ではありません。ベクターは、標準ライブラリで提供同様のコレクション型である&lt;em&gt;されて&lt;/em&gt;サイズが拡大または縮小することができました。配列とベクトルのどちらを使用するかわからない場合は、おそらくベクトルを使用する必要があります。第8章では、ベクトルについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="3b3785f54b6fb9b400ea9ab57c87c42e59186241" translate="yes" xml:space="preserve">
          <source>Arrays coerce to &lt;a href=&quot;primitive.slice&quot;&gt;slices (&lt;code&gt;[T]&lt;/code&gt;)&lt;/a&gt;, so a slice method may be called on an array. Indeed, this provides most of the API for working with arrays. Slices have a dynamic size and do not coerce to arrays.</source>
          <target state="translated">配列は&lt;a href=&quot;primitive.slice&quot;&gt;スライス（ &lt;code&gt;[T]&lt;/code&gt; ）&lt;/a&gt;に強制変換されるため、配列に対してスライスメソッドを呼び出すことができます。実際、これは配列を操作するためのほとんどのAPIを提供します。スライスは動的なサイズを持ち、配列に強制されません。</target>
        </trans-unit>
        <trans-unit id="a5463b6c378c5a1ce536679177693788d8a488ef" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;. This works because &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits are specially known to the compiler.</source>
          <target state="translated">配列&lt;em&gt;任意の&lt;/em&gt;サイズは、&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;要素の型である場合、&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;要素の型がある場合は&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;。これは、&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;特性がコンパイラーに特に知られているために機能します。</target>
        </trans-unit>
        <trans-unit id="e22eb391f81362ae0eac8c4cd60b81a4562599d8" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the following traits if the element type allows it:</source>
          <target state="translated">0 から 32 までのサイズ(含む)の配列は、要素の型が許可している場合には、以下の特性を実装します。</target>
        </trans-unit>
        <trans-unit id="2be2422a9ce4d7fe654319fa259c94897e3e7b46" translate="yes" xml:space="preserve">
          <source>As IANA assigns new addresses, this method will be updated. This may result in non-reserved addresses being treated as reserved in code that relies on an outdated version of this method.</source>
          <target state="translated">IANAが新しいアドレスを割り当てると、このメソッドは更新されます。これにより、このメソッドの古いバージョンに依存しているコードでは、予約されていないアドレスが予約されたものとして扱われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e9f144fd6603397ae748bc2c2b95fde2038ac9c" translate="yes" xml:space="preserve">
          <source>As a companion to &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; this trait allows a type to borrow as an underlying type by providing a mutable reference. See &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on borrowing as another type.</source>
          <target state="translated">&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;コンパニオンとして、このトレイトは、変更可能な参照を提供することにより、型が基になる型として借用できるようにします。別のタイプとしての借用の詳細については、&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f044338e83e2522cd461ee6d84f7c5ea2e52e486" translate="yes" xml:space="preserve">
          <source>As a consequence, the hash map breaks if a &lt;code&gt;K&lt;/code&gt; wrapping a &lt;code&gt;Q&lt;/code&gt; value produces a different hash than &lt;code&gt;Q&lt;/code&gt;. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:</source>
          <target state="translated">その結果、もしハッシュマップブレーク &lt;code&gt;K&lt;/code&gt; ラップ &lt;code&gt;Q&lt;/code&gt; 値がより異なるハッシュ生成 &lt;code&gt;Q&lt;/code&gt; を。たとえば、文字列をラップするが大文字と小文字を区別せずにASCII文字を比較する型があるとします。</target>
        </trans-unit>
        <trans-unit id="21e6ec20b4bccf73414453b9c7ceac9ffa2614a2" translate="yes" xml:space="preserve">
          <source>As a data collection, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; owns both keys and values. If the key&amp;rsquo;s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key&amp;rsquo;s data. For instance, if the key is a string, then it is likely stored with the hash map as a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, while it should be possible to search using a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;insert&lt;/code&gt; needs to operate on a &lt;code&gt;String&lt;/code&gt; while &lt;code&gt;get&lt;/code&gt; needs to be able to use a &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">データコレクションとして、&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt;はキーと値の両方を所有します。ただし、キーの実際のデータが何らかの管理タイプにラップされている場合でも、キーのデータへの参照を使用して値を検索することは可能です。たとえば、キーが文字列の場合、ハッシュマップとともに&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;として格納される可能性がありますが、&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;を使用して検索することは可能です。したがって、 &lt;code&gt;insert&lt;/code&gt; は &lt;code&gt;String&lt;/code&gt; を操作する必要があり、 &lt;code&gt;get&lt;/code&gt; は &lt;code&gt;&amp;amp;str&lt;/code&gt; を使用できる必要があります。</target>
        </trans-unit>
        <trans-unit id="72b018e0e36049ad8edb2d9275fa43ffbd253ac2" translate="yes" xml:space="preserve">
          <source>As a first example of ownership, we&amp;rsquo;ll look at the &lt;em&gt;scope&lt;/em&gt; of some variables. A scope is the range within a program for which an item is valid. Let&amp;rsquo;s say we have a variable that looks like this:</source>
          <target state="translated">所有権の最初の例として、いくつかの変数の&lt;em&gt;スコープ&lt;/em&gt;を見てみましょう。スコープは、アイテムが有効であるプログラム内の範囲です。次のような変数があるとします。</target>
        </trans-unit>
        <trans-unit id="0024a0a24aed0a7ac58334f18eea8263ecf48ec1" translate="yes" xml:space="preserve">
          <source>As a language, Rust cares a &lt;em&gt;lot&lt;/em&gt; about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can&amp;rsquo;t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</source>
          <target state="translated">言語としては、錆が気に&lt;em&gt;多くのことを&lt;/em&gt;あなたのコードの安定性について。私たちは、Rustをあなたが構築できる強固な基盤にしたいと考えています。物事が絶えず変化している場合、それは不可能です。同時に、新しい機能を試すことができない場合、重要な欠陥がリリースされてから変更できなくなるまで、その欠陥を見つけられない可能性があります。</target>
        </trans-unit>
        <trans-unit id="c7163ba6f2bf3417c3c81c5ac8d3af7e28902510" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; when a conversion to a type outside the current crate is required.</source>
          <target state="translated">ライブラリの作者として、あなたは常に実装好むはずです&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;ではなく&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;、など&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;より大きな柔軟性を提供し、同等の提供&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;自由のための実装を、感謝します標準ライブラリの包括的な実装。現在のクレート外の型への変換が必要な場合にのみ、&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; を&lt;/a&gt;実装します。</target>
        </trans-unit>
        <trans-unit id="ff562238e6519efc127fd0f82f8c3d4cbe94172e" translate="yes" xml:space="preserve">
          <source>As a more concise alternative, you can use a &lt;code&gt;for&lt;/code&gt; loop and execute some code for each item in a collection. A &lt;code&gt;for&lt;/code&gt; loop looks like the code in Listing 3-5.</source>
          <target state="translated">より簡潔な代替手段として、 &lt;code&gt;for&lt;/code&gt; ループを使用して、コレクション内の各アイテムに対していくつかのコードを実行できます。 &lt;code&gt;for&lt;/code&gt; コードリスト3-5のコードのようなループに見えます。</target>
        </trans-unit>
        <trans-unit id="4b5b050c97f5fa423f8a999dca4b012b9c78134c" translate="yes" xml:space="preserve">
          <source>As a result of this code, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;lol&lt;/code&gt;.</source>
          <target state="translated">このコードの結果として、 &lt;code&gt;s&lt;/code&gt; には &lt;code&gt;lol&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="0f98a89f1abd2dd1d5bfe499fd5b56372a5800c2" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">その結果、このメソッドは &lt;code&gt;fe80:0:0:1::&lt;/code&gt; や &lt;code&gt;fe81::&lt;/code&gt; アドレスをユニキャストリンクローカルアドレスと&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt;ますが、is_unicast_link_local_strict（）はそうではありません。RFCに完全に準拠した厳密な検証が必要な場合は、&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="486c7c23286a7b0e1299ccac2ee0a869b3e82ee5" translate="yes" xml:space="preserve">
          <source>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</source>
          <target state="translated">文字列スライスはバイト列で構成されているので、バイト単位で文字列スライスを反復処理することができます。このメソッドはそのようなイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="13230333554cf4f41cab6ad4fc5190eeee2538f2" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、文字列スライスを&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;反復できます。このメソッドは、これらの&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;の反復子とそれらのバイト位置を返します。</target>
        </trans-unit>
        <trans-unit id="437cfa80202d923ee25f6cf5ad0fd2f02cfb01ea" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、文字列スライスを&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;反復できます。このメソッドは、そのようなイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="fb40adb4e231d6bdd9f0bd0f9320f4357a2e82ae" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、文字列スライスを&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;反復できます。このメソッドは、これらの&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;の反復子とそれらのバイト位置を返します。</target>
        </trans-unit>
        <trans-unit id="bf66f1c269d4394c9cb4445fd4fd600e640f2992" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、文字列スライスを&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;反復できます。このメソッドは、そのようなイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="b4d78aa978dc16456ba4fafe0a526ad6183e3881" translate="yes" xml:space="preserve">
          <source>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '&amp;eacute;' character is one Unicode code point while 'é' is two Unicode code points:</source>
          <target state="translated">いつものように、「文字」に対する人間の直感は、Unicodeの定義にマッピングされない場合があることを覚えておいてください。たとえば、似ているように見えても、「&amp;eacute;」文字は1つのUnicodeコードポイントであり、「&amp;eacute;」は2つのUnicodeコードポイントです。</target>
        </trans-unit>
        <trans-unit id="8d82369403176e5c690373478594ff76e764a9ef" translate="yes" xml:space="preserve">
          <source>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not &lt;em&gt;simultaneous&lt;/em&gt; ones:</source>
          <target state="translated">いつものように、中かっこを使用して新しいスコープを作成し、複数の可変参照を許可することができます。&lt;em&gt;同時&lt;/em&gt;参照ではありません。</target>
        </trans-unit>
        <trans-unit id="c5be02ef05f525885a914931855842d0bd0941ea" translate="yes" xml:space="preserve">
          <source>As an example of how to use a mutex, let&amp;rsquo;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</source>
          <target state="translated">mutexの使用方法の例として、リスト16-12に示すように、シングルスレッドコンテキストでmutexを使用することから始めましょう。</target>
        </trans-unit>
        <trans-unit id="0a2b1532710f708a62d9bd14aa059c7176218c09" translate="yes" xml:space="preserve">
          <source>As an example of methods on a trait, consider the following:</source>
          <target state="translated">形質に関するメソッドの例として、次のように考えてみてください。</target>
        </trans-unit>
        <trans-unit id="46ce22c9bcccaee92580f06aedfeeb7db04850fe" translate="yes" xml:space="preserve">
          <source>As an example of where you could use either a closure defined inline or a named function, let&amp;rsquo;s look at a use of &lt;code&gt;map&lt;/code&gt;. To use the &lt;code&gt;map&lt;/code&gt; function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</source>
          <target state="translated">インラインで定義されたクロージャーまたは名前付き関数を使用できる例として、 &lt;code&gt;map&lt;/code&gt; の使用法を見てみましょう。 &lt;code&gt;map&lt;/code&gt; 関数を使用して数値のベクトルを文字列のベクトルに変換するには、次のようにクロージャを使用できます。</target>
        </trans-unit>
        <trans-unit id="37540a09808abda7d1579f892bfd40fb102faf8d" translate="yes" xml:space="preserve">
          <source>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</source>
          <target state="translated">例として、リスト11-10にはパラメータの値を表示して10を返すおバカな関数のほかに、テストが合格した場合と失敗した場合のテストがあります。</target>
        </trans-unit>
        <trans-unit id="53691b327422875e6972393627946b878398498e" translate="yes" xml:space="preserve">
          <source>As an example, a macro matcher like &lt;code&gt;$i:expr [ , ]&lt;/code&gt; could in theory be accepted in Rust today, since &lt;code&gt;[,]&lt;/code&gt; cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because &lt;code&gt;[&lt;/code&gt; can start trailing expressions, &lt;code&gt;[&lt;/code&gt; is not a character which can safely be ruled out as coming after an expression. If &lt;code&gt;[,]&lt;/code&gt; were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like &lt;code&gt;$i:expr,&lt;/code&gt; or &lt;code&gt;$i:expr;&lt;/code&gt; would be legal, however, because &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; are legal expression separators. The specific rules are:</source>
          <target state="translated">一例として、のようなマクロマッチャー &lt;code&gt;$i:expr [ , ]&lt;/code&gt; 理論的には今日ルーストに受け入れられる可能性は、以来、 &lt;code&gt;[,]&lt;/code&gt; 、法的表現の一部にすることはできませんので、解析は、常に明確なことでしょう。ただし、 &lt;code&gt;[&lt;/code&gt; は後続の式を開始できるため、 &lt;code&gt;[&lt;/code&gt; は式の後に来ると安全に除外できる文字ではありません。 &lt;code&gt;[,]&lt;/code&gt; が新しいバージョンのRustで受け入れられた場合、このマッチャーはあいまいになるか、誤って解析され、機能するコードが壊れます。 &lt;code&gt;$i:expr,&lt;/code&gt; や &lt;code&gt;$i:expr;&lt;/code&gt; などのマッチャー。なぜなら、しかし、法的になり &lt;code&gt;,&lt;/code&gt; と &lt;code&gt;;&lt;/code&gt; 正しい式の区切り文字です。具体的なルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3c5226f2d8790540dbbe88f9ad68f2409b55a32e" translate="yes" xml:space="preserve">
          <source>As an example, change the &lt;em&gt;src/main.rs&lt;/em&gt; file in your &lt;em&gt;loops&lt;/em&gt; directory to look like this:</source>
          <target state="translated">例として、&lt;em&gt;loops&lt;/em&gt;ディレクトリの&lt;em&gt;src / main.rs&lt;/em&gt;ファイルを&lt;em&gt;次の&lt;/em&gt;ように変更します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0fd43eedc8fb375dd6813798e9b7e3996a0f09" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our &lt;code&gt;enum&lt;/code&gt; by changing the &lt;code&gt;Quarter&lt;/code&gt; variant to include a &lt;code&gt;UsState&lt;/code&gt; value stored inside it, which we&amp;rsquo;ve done here in Listing 6-4.</source>
          <target state="translated">例として、列挙型バリアントの1つを変更して、その中にデータを保持しましょう。米国は、1999年から2008年まで、一方の50州のそれぞれに異なるデザインの区画を作りました。他のコインには州のデザインがありません。そのため、この追加の価値を持つのは四半期のみです。リスト6-4で行ったように、 &lt;code&gt;Quarter&lt;/code&gt; バリアントを変更して内部に格納されている &lt;code&gt;UsState&lt;/code&gt; 値を含めることで、この情報を &lt;code&gt;enum&lt;/code&gt; 追加できます。</target>
        </trans-unit>
        <trans-unit id="d430493784bb7c38b9bfd2132c640f18ef8a2cfc" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s say we want to implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which the orphan rule prevents us from doing directly because the &lt;code&gt;Display&lt;/code&gt; trait and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type are defined outside our crate. We can make a &lt;code&gt;Wrapper&lt;/code&gt; struct that holds an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;; then we can implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; and use the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; value, as shown in Listing 19-23.</source>
          <target state="translated">例として、我々は実装したいとしましょう &lt;code&gt;Display&lt;/code&gt; に &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ので、直接やってから孤児がルール防止たちを、 &lt;code&gt;Display&lt;/code&gt; 特性と &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 型は、当社のクレートの外部で定義されています。 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; インスタンスを保持する &lt;code&gt;Wrapper&lt;/code&gt; 構造体を作成できます。次に、リスト19-23に示すように、 &lt;code&gt;Wrapper&lt;/code&gt; に &lt;code&gt;Display&lt;/code&gt; を実装し、 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 値を使用できます。</target>
        </trans-unit>
        <trans-unit id="0a293358ddd19b42df03eeb78c691469d4c0e122" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s write a library crate that provides the functionality of a restaurant. We&amp;rsquo;ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code.</source>
          <target state="translated">例として、レストランの機能を提供する図書館の箱を書いてみましょう。関数のシグネチャを定義しますが、実際にコードにレストランを実装するのではなく、コードの構成に集中するために、関数の本体を空のままにします。</target>
        </trans-unit>
        <trans-unit id="5e1d4bdb076d3e495d340c82a90a7bc9edd4704c" translate="yes" xml:space="preserve">
          <source>As an example, rather than using a list whose items know only about the next item, we&amp;rsquo;ll create a tree whose items know about their children items &lt;em&gt;and&lt;/em&gt; their parent items.</source>
          <target state="translated">例として、次のアイテムのみを知っているアイテムのリストを使用するのではなく、アイテムが子アイテム&lt;em&gt;と&lt;/em&gt;親アイテムを知っているツリーを作成します。</target>
        </trans-unit>
        <trans-unit id="84057f7bc04baf2d73dfbd111ea89a20d0d17089" translate="yes" xml:space="preserve">
          <source>As an example, recall the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; marker traits we discussed in the &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo;Extensible Concurrency with the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; types. If we implement a type that contains a type that is not &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, such as raw pointers, and we want to mark that type as &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, we must use &lt;code&gt;unsafe&lt;/code&gt;. Rust can&amp;rsquo;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">例として、第16章の&lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;「&lt;/a&gt; &lt;code&gt;Sync&lt;/code&gt; および &lt;code&gt;Send&lt;/code&gt; 特性による拡張可能な同時実行性」セクションで説明した &lt;code&gt;Sync&lt;/code&gt; および &lt;code&gt;Send&lt;/code&gt; マーカー特性を思い出してください。型が完全に &lt;code&gt;Send&lt;/code&gt; および &lt;code&gt;Sync&lt;/code&gt; 型で構成されている場合、コンパイラーはこれらの特性を自動的に実装します。rawポインターなど、 &lt;code&gt;Send&lt;/code&gt; または &lt;code&gt;Sync&lt;/code&gt; ではない型を含む型を実装し、その型を &lt;code&gt;Send&lt;/code&gt; または &lt;code&gt;Sync&lt;/code&gt; としてマークする場合は、 &lt;code&gt;unsafe&lt;/code&gt; ないものを使用する必要があります。 Rustは、私たちのタイプが、スレッド間で安全に送信できる、または複数のスレッドからアクセスできるという保証が守られていることを確認できません。したがって、これらのチェックを手動で実行し、そのように &lt;code&gt;unsafe&lt;/code&gt; で示す必要があります。</target>
        </trans-unit>
        <trans-unit id="38a88a1bad47211ae1a10e5bfcee84726e1f325e" translate="yes" xml:space="preserve">
          <source>As an example, say we write a function called &lt;code&gt;add_two&lt;/code&gt; that adds 2 to whatever number is passed to it. This function&amp;rsquo;s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you&amp;rsquo;ve learned so far to ensure that, for instance, we aren&amp;rsquo;t passing a &lt;code&gt;String&lt;/code&gt; value or an invalid reference to this function. But Rust &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That&amp;rsquo;s where tests come in.</source>
          <target state="translated">例として、渡された数値に2を加算する &lt;code&gt;add_two&lt;/code&gt; という関数を作成するとします。この関数のシグネチャは、整数をパラメータとして受け入れ、整数を結果として返します。その関数を実装してコンパイルすると、Rustはこれまでに学んだすべての型チェックと借用チェックを実行して、たとえば、この関数に &lt;code&gt;String&lt;/code&gt; 値や無効な参照を渡していないことを確認します。しかし、Rust &lt;em&gt;は&lt;/em&gt;、この関数が意図したとおりに機能することを確認&lt;em&gt;できません&lt;/em&gt;。たとえば、パラメータープラス10またはパラメーターマイナス50ではなく、パラメータープラス2を返します。それがテストの出番です。</target>
        </trans-unit>
        <trans-unit id="0c46b40f3e5f774d5bd6d946904f04146f347849" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</source>
          <target state="translated">例として、パターン &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; と干し草の &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; は、ストリーム &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt; 2、5 ）、Reject（5、8 ）]を生成します。</target>
        </trans-unit>
        <trans-unit id="f6b604f8510907ca9fe9178dfcf2a6874e95e6b5" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</source>
          <target state="translated">例として、パターン &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; と干し草 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; は、ストリーム &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="877bff60769fbc36114e44fb0843def0fdaa302f" translate="yes" xml:space="preserve">
          <source>As an iterator:</source>
          <target state="translated">イテレータとして</target>
        </trans-unit>
        <trans-unit id="04b8526b20e002ad597cb978c8868c4ab1a90f67" translate="yes" xml:space="preserve">
          <source>As another example, suppose we have a &lt;code&gt;Maker&lt;/code&gt; trait and want to establish a type &lt;code&gt;FooMaker&lt;/code&gt; that makes &lt;code&gt;Foo&lt;/code&gt;s:</source>
          <target state="translated">別の例として、 &lt;code&gt;Maker&lt;/code&gt; トレイトがあり、 &lt;code&gt;Foo&lt;/code&gt; を作成するタイプ &lt;code&gt;FooMaker&lt;/code&gt; を確立するとします。</target>
        </trans-unit>
        <trans-unit id="5213c1c4f3b10c9c56042b19c8c0157b715adba7" translate="yes" xml:space="preserve">
          <source>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a &lt;code&gt;buffer&lt;/code&gt; slice of data, an array of 12 &lt;code&gt;coefficients&lt;/code&gt;, and an amount by which to shift data in &lt;code&gt;qlp_shift&lt;/code&gt;. We&amp;rsquo;ve declared the variables within this example but not given them any values; although this code doesn&amp;rsquo;t have much meaning outside of its context, it&amp;rsquo;s still a concise, real-world example of how Rust translates high-level ideas to low-level code.</source>
          <target state="translated">別の例として、次のコードはオーディオデコーダーから取得されます。デコードアルゴリズムは、線形予測の数学演算を使用して、以前のサンプルの線形関数に基づいて将来の値を推定します。このコードは、反復子チェーンを使用して、スコープ内の3つの変数（データの &lt;code&gt;buffer&lt;/code&gt; スライス、12個の &lt;code&gt;coefficients&lt;/code&gt; 配列、および &lt;code&gt;qlp_shift&lt;/code&gt; でデータをシフトする量）について計算を行います。この例では変数を宣言していますが、値は指定していません。このコードはコンテキスト外ではあまり意味がありませんが、Rustが高レベルのアイデアを低レベルのコードに変換する方法の簡潔で現実的な例です。</target>
        </trans-unit>
        <trans-unit id="ceca2c634722fa77d0d672657c5578a7251142a0" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../i32/index&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">説明したように、&lt;a href=&quot;../i32/index&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt; 実装します。</target>
        </trans-unit>
        <trans-unit id="0958482afe9fd3c8317c6c0d343e311be75015c7" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&amp;rsquo;s required methods. The &lt;code&gt;Deref&lt;/code&gt; trait, provided by the standard library, requires us to implement one method named &lt;code&gt;deref&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt; and returns a reference to the inner data. Listing 15-10 contains an implementation of &lt;code&gt;Deref&lt;/code&gt; to add to the definition of &lt;code&gt;MyBox&lt;/code&gt;:</source>
          <target state="translated">第10章で説明したように、トレイトを実装するには、トレイトに必要なメソッドの実装を提供する必要があります。 &lt;code&gt;Deref&lt;/code&gt; トレイト、標準ライブラリで提供さは、1つのという名前のメソッドを実装するために私たちを必要と &lt;code&gt;deref&lt;/code&gt; 借りていること &lt;code&gt;self&lt;/code&gt; を返す内部のデータを参照します。 15-10のリストの実装が含まれ &lt;code&gt;Deref&lt;/code&gt; 定義に追加する &lt;code&gt;MyBox&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d5f5ed3e00ea3332f0559aed11908528d1ba499a" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 17, the &lt;code&gt;take&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; takes the &lt;code&gt;Some&lt;/code&gt; variant out and leaves &lt;code&gt;None&lt;/code&gt; in its place. We&amp;rsquo;re using &lt;code&gt;if let&lt;/code&gt; to destructure the &lt;code&gt;Some&lt;/code&gt; and get the thread; then we call &lt;code&gt;join&lt;/code&gt; on the thread. If a worker&amp;rsquo;s thread is already &lt;code&gt;None&lt;/code&gt;, we know that worker has already had its thread cleaned up, so nothing happens in that case.</source>
          <target state="translated">第17章で説明した &lt;code&gt;take&lt;/code&gt; 、 &lt;code&gt;Option&lt;/code&gt; のtakeメソッドは、 &lt;code&gt;Some&lt;/code&gt; バリアントを &lt;code&gt;None&lt;/code&gt; し、代わりにNoneを残します。私たちは、使用している &lt;code&gt;if let&lt;/code&gt; destructureする &lt;code&gt;Some&lt;/code&gt; スレッドを取得します。次に、スレッドで &lt;code&gt;join&lt;/code&gt; を呼び出します。ワーカーのスレッドが既に &lt;code&gt;None&lt;/code&gt; である場合、ワーカーは既にそのスレッドをクリーンアップしているため、その場合は何も起こりません。</target>
        </trans-unit>
        <trans-unit id="9fd5d9a215556134ab45028a161d57190ff678d3" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 6, we use patterns in the arms of &lt;code&gt;match&lt;/code&gt; expressions. Formally, &lt;code&gt;match&lt;/code&gt; expressions are defined as the keyword &lt;code&gt;match&lt;/code&gt;, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&amp;rsquo;s pattern, like this:</source>
          <target state="translated">第6章で説明したように、 &lt;code&gt;match&lt;/code&gt; 式の腕の中でパターンを使用します。形式的に、 &lt;code&gt;match&lt;/code&gt; 式は、キーワード &lt;code&gt;match&lt;/code&gt; 、一致する値、およびパターンと、値がそのアームのパターンに一致する場合に実行される式で構成される1つ以上の一致アームとして定義されます。</target>
        </trans-unit>
        <trans-unit id="b597a68d9b285f7d308e42a0c9a8b37ad1bf7193" translate="yes" xml:space="preserve">
          <source>As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:</source>
          <target state="translated">裏で何が起こっているかについては、最適化を有効にすると、最終的に生成されたマシンコードはコードとは大きく異なるものに見えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e7061cd66862cc7d4e84cb20891d413f4dbad19d" translate="yes" xml:space="preserve">
          <source>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</source>
          <target state="translated">関数としては、構文を返すか、パニックになるか、無限にループする必要があります。返される構文は、手続き的なマクロの種類に応じて、構文を置き換えるか、追加します。パニックはコンパイラによって捕捉され、コンパイラ エラーになります。エンドレスループはコンパイラによって捕捉されず、コンパイラがハングアップします。</target>
        </trans-unit>
        <trans-unit id="fd8f9685a0be8d16b4d260e66976648f0f435f12" translate="yes" xml:space="preserve">
          <source>As humans, we can look at this code and see that &lt;code&gt;string1&lt;/code&gt; is longer than &lt;code&gt;string2&lt;/code&gt; and therefore &lt;code&gt;result&lt;/code&gt; will contain a reference to &lt;code&gt;string1&lt;/code&gt;. Because &lt;code&gt;string1&lt;/code&gt; has not gone out of scope yet, a reference to &lt;code&gt;string1&lt;/code&gt; will still be valid for the &lt;code&gt;println!&lt;/code&gt; statement. However, the compiler can&amp;rsquo;t see that the reference is valid in this case. We&amp;rsquo;ve told Rust that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</source>
          <target state="translated">人間として、このコードを見ると、 &lt;code&gt;string1&lt;/code&gt; が &lt;code&gt;string2&lt;/code&gt; よりも長いため、 &lt;code&gt;result&lt;/code&gt; には &lt;code&gt;string1&lt;/code&gt; への参照が含まれていることがわかります。ので &lt;code&gt;string1&lt;/code&gt; のはまだ範囲を出ていない、参照 &lt;code&gt;string1&lt;/code&gt; がまだのために有効になります &lt;code&gt;println!&lt;/code&gt; ステートメント。ただし、この場合、コンパイラは参照が有効であることを認識できません。 &lt;code&gt;longest&lt;/code&gt; 関数によって返される参照の有効期間は、渡される参照の有効期間の短い方と同じであることをRustに伝えました。したがって、借用チェッカーは、リスト10-24のコードが無効な参照である可能性があることを許可しません。</target>
        </trans-unit>
        <trans-unit id="6d9f4910be4026effcf198634df42e1c4041dff1" translate="yes" xml:space="preserve">
          <source>As in most other programming languages, a Boolean type in Rust has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Booleans are one byte in size. The Boolean type in Rust is specified using &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">他のほとんどのプログラミング言語と同様に、Rustのブール型には、 &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; の 2つの値があります。ブール値のサイズは1バイトです。Rustのブール型は &lt;code&gt;bool&lt;/code&gt; を使用して指定されます。例えば：</target>
        </trans-unit>
        <trans-unit id="a025b290deb94845050bfa62909fd15fe5ae74be" translate="yes" xml:space="preserve">
          <source>As long as your command line parsing logic is small, it can remain in &lt;em&gt;main.rs&lt;/em&gt;.</source>
          <target state="translated">コマンドライン解析ロジックが小さい限り、&lt;em&gt;main.rsに&lt;/em&gt;残すことができます。</target>
        </trans-unit>
        <trans-unit id="8323a3696731d93f0a84dafc08f2d32df5ef0903" translate="yes" xml:space="preserve">
          <source>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: &lt;em&gt;unit tests&lt;/em&gt; and &lt;em&gt;integration tests&lt;/em&gt;. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</source>
          <target state="translated">この章の冒頭で述べたように、テストは複雑な分野であり、人によって使用する用語や構成は異なります。 Rustコミュニティは、テストを2つの主要なカテゴリ（&lt;em&gt;単体テスト&lt;/em&gt;と&lt;em&gt;統合テスト）の&lt;/em&gt;観点から考えてい&lt;em&gt;ます&lt;/em&gt;。単体テストは小規模で集中的で、一度に1つのモジュールを分離してテストし、プライベートインターフェイスをテストできます。統合テストは完全にライブラリの外部にあり、他の外部コードと同じようにコードを使用します。パブリックインターフェイスのみを使用し、テストごとに複数のモジュールを実行する可能性があります。</target>
        </trans-unit>
        <trans-unit id="10eda87545057c2aa683c0bbfe8990122953ece6" translate="yes" xml:space="preserve">
          <source>As mentioned before, trait objects contain pointers to method tables. So, if we have:</source>
          <target state="translated">前述したように、 trait オブジェクトにはメソッドテーブルへのポインタが含まれています。ですから、もしあれば</target>
        </trans-unit>
        <trans-unit id="4761017ad6dee318134842b138bc05d35199a594" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;read_line&lt;/code&gt; puts what the user types into the string we&amp;rsquo;re passing it, but it also returns a value&amp;mdash;in this case, an &lt;a href=&quot;../std/io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. Rust has a number of types named &lt;code&gt;Result&lt;/code&gt; in its standard library: a generic &lt;a href=&quot;../std/result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; as well as specific versions for submodules, such as &lt;code&gt;io::Result&lt;/code&gt;.</source>
          <target state="translated">前述のように、 &lt;code&gt;read_line&lt;/code&gt; は、ユーザーが入力した文字列を、渡す文字列に入れますが、値（この場合は&lt;a href=&quot;../std/io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;も返します。Rustの標準ライブラリには、 &lt;code&gt;Result&lt;/code&gt; という名前のタイプがいくつかあります。一般的な&lt;a href=&quot;../std/result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;と、 &lt;code&gt;io::Result&lt;/code&gt; などのサブモジュールの特定のバージョンです。</target>
        </trans-unit>
        <trans-unit id="3f7435a393907a8b1c4a2fc1b69a43772076a5c5" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</source>
          <target state="translated">前述したように、Rust が並行処理を処理する方法のほとんどが言語の一部であるため、多くの並行処理ソリューションはクレートとして実装されています。これらのクレートは標準ライブラリよりも急速に進化していますので、マルチスレッドの状況で使用するための最新のクレートをオンラインで検索するようにしてください。</target>
        </trans-unit>
        <trans-unit id="a6f8e14141b394aeafb54cb0af5563e56c04e70c" translate="yes" xml:space="preserve">
          <source>As mentioned in Chapter 2, by default variables are immutable. This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you still have the option to make your variables mutable. Let&amp;rsquo;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</source>
          <target state="translated">第2章で述べたように、デフォルトでは変数は不変です。これは、Rustが提供する安全性と同時実行性を活用した方法でコードを記述するためにRustが提供するナッジの1つです。ただし、変数を変更可能にするオプションはまだあります。Rustが不変性を支持するように勧める方法と理由、そしてなぜオプトアウトしたいのかを探ってみましょう。</target>
        </trans-unit>
        <trans-unit id="7641c8a38df92f9203220e805ba01b7f30732a0c" translate="yes" xml:space="preserve">
          <source>As mentioned in the module documentation, threads are usually made to communicate using &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt;, here is how it usually looks.</source>
          <target state="translated">モジュールのドキュメントで述べられているように、スレッドは通常、&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt;を使用して通信するように作られています。</target>
        </trans-unit>
        <trans-unit id="fad7d9a9d62e3d2756844c471849a76502954355" translate="yes" xml:space="preserve">
          <source>As non-Rust calling conventions do not support unwinding, unwinding past the end of an extern function will cause the process to abort. In LLVM, this is implemented by executing an illegal instruction.</source>
          <target state="translated">非Rustの呼び出し規約はアンワインドをサポートしていないため、外部関数の終わりを過ぎたアンワインドは、プロセスを中止させる原因となります。LLVMでは、これは不正な命令を実行することによって実装されています。</target>
        </trans-unit>
        <trans-unit id="10482a83c62e485259adbe51b49060ecef064cde" translate="yes" xml:space="preserve">
          <source>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using &lt;strong&gt;transmute&lt;/strong&gt; to convert a fn item into a fn pointer.</source>
          <target state="translated">上記のように、強制とは、ほとんどのコードがこの区別に関係する必要がないことを意味します。ただし、&lt;strong&gt;transmute&lt;/strong&gt;を使用してfnアイテムをfnポインターに変換するときに違いを確認できます。</target>
        </trans-unit>
        <trans-unit id="78cffef75c7264e29f3831c1d70df7b7db90b085" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;code&gt;Sync&lt;/code&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;code&gt;Sync&lt;/code&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;code&gt;Sync&lt;/code&gt; for their container to be &lt;code&gt;Sync&lt;/code&gt;.)</source>
          <target state="translated">ご&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;、u8や&lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt;などのプリミティブ型はすべて &lt;code&gt;Sync&lt;/code&gt; であり、タプル、構造体、列挙型などのそれらを含む単純な集約型も同様です。基本的な &lt;code&gt;Sync&lt;/code&gt; タイプのその他の例には、 &lt;code&gt;&amp;amp;T&lt;/code&gt; のような「不変」タイプや、&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、およびその他のほとんどのコレクションタイプなど、単純に継承された可変性のタイプがあります。（ジェネリックパラメータは、する必要が &lt;code&gt;Sync&lt;/code&gt; であることを彼らのコンテナの &lt;code&gt;Sync&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="e3262fa97dd64c6174eeff7f6dc1bf92e0938ab9" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;, the whole &lt;code&gt;FEC0::/10&lt;/code&gt; prefix is deprecated. New software must not support site-local addresses.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;に従って、 &lt;code&gt;FEC0::/10&lt;/code&gt; プレフィックス全体が非推奨になりました。新しいソフトウェアはサイトローカルアドレスをサポートしてはなりません。</target>
        </trans-unit>
        <trans-unit id="51aa8d67495f62b66ef894735fcf63e6606dac28" translate="yes" xml:space="preserve">
          <source>As shown in the example above, &lt;code&gt;for&lt;/code&gt; loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the same tag to &lt;code&gt;break&lt;/code&gt; breaks the tagged loop, which is useful for inner loops. It is definitely not a goto.</source>
          <target state="translated">上記の例に示すように、 &lt;code&gt;for&lt;/code&gt; ループは（他のすべてのループとともに）ライフタイムと同様の構文を使用してタグ付けできます（実際には視覚的にのみ類似しており、完全に異なります）。同じタグを &lt;code&gt;break&lt;/code&gt; 与えると、タグ付きループが壊れます。これは、内部ループに役立ちます。後藤ではありません。</target>
        </trans-unit>
        <trans-unit id="c276f971f322ddf36b0d0a39caeff0e860e6ee88" translate="yes" xml:space="preserve">
          <source>As stated in the User Datagram Protocol's specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;, UDP is an unordered, unreliable protocol; refer to &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; for TCP primitives.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;のUser Datagram Protocolの仕様で述べられているように、UDPは順序付けされておらず、信頼性の低いプロトコルです。TCPプリミティブについては、&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="54d4fd727ce2657161522c6ae3a06633673c9cbd" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">文字列スライスはバイトのスライスなので、生のポインタは&lt;a href=&quot;primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; を指し&lt;/a&gt;ます。このポインターは、文字列スライスの最初のバイトを指します。</target>
        </trans-unit>
        <trans-unit id="b757bf93c530db10fdab40d9aeca4c3f17d50ad1" translate="yes" xml:space="preserve">
          <source>As such, the &lt;code&gt;from_utf8&lt;/code&gt; family of functions and methods for both &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;fn.from_utf8&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s make use of this error, for example.</source>
          <target state="translated">そのため、 &lt;code&gt;from_utf8&lt;/code&gt; &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;fn.from_utf8&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;の両方の関数とメソッドのfrom_utf8ファミリは、このエラーを利用します。</target>
        </trans-unit>
        <trans-unit id="a7bae3aa148344b33c64086da16dba6a42474602" translate="yes" xml:space="preserve">
          <source>As the author of a data structure you get to decide for each field whether pinning &quot;propagates&quot; to this field or not. Pinning that propagates is also called &quot;structural&quot;, because it follows the structure of the type. In the following subsections, we describe the considerations that have to be made for either choice.</source>
          <target state="translated">データ構造体の作成者として、各フィールドに対してピン留めを「伝播」するかどうかを決定することができます。伝搬するピン留めは、型の構造に従うので、「構造的」とも呼ばれます。以下の小節では、どちらを選択するかについての考慮事項を説明します。</target>
        </trans-unit>
        <trans-unit id="0b86e5cf0a558c007bb8a3eed83a07619a169108" translate="yes" xml:space="preserve">
          <source>As the error message indicates, only &lt;code&gt;u8&lt;/code&gt; can be cast into &lt;code&gt;char&lt;/code&gt;. Example:</source>
          <target state="translated">エラーメッセージが示すように、 &lt;code&gt;u8&lt;/code&gt; のみを &lt;code&gt;char&lt;/code&gt; にキャストできます。例：</target>
        </trans-unit>
        <trans-unit id="6c037f01ab1e44c1b49068f96530e00f210988e8" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code likely wants to use &lt;a href=&quot;#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.from_le_bytes&quot;&gt;&lt;code&gt;from_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate instead.</source>
          <target state="translated">ターゲットプラットフォームのネイティブエンディアンが使用されているため、移植可能なコードでは、代わりに適切に&lt;a href=&quot;#method.from_be_bytes&quot;&gt; &lt;code&gt;from_be_bytes&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#method.from_le_bytes&quot;&gt; &lt;code&gt;from_le_bytes&lt;/code&gt; &lt;/a&gt;を使用する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1c8bfefec8dafcbb055c2ea433ad31a56feecccd" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code should use &lt;a href=&quot;#method.to_be_bytes&quot;&gt;&lt;code&gt;to_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.to_le_bytes&quot;&gt;&lt;code&gt;to_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate, instead.</source>
          <target state="translated">ターゲットプラットフォームのネイティブエンディアンが使用されるため、移植可能なコードでは、代わりに&lt;a href=&quot;#method.to_be_bytes&quot;&gt; &lt;code&gt;to_be_bytes&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#method.to_le_bytes&quot;&gt; &lt;code&gt;to_le_bytes&lt;/code&gt; &lt;/a&gt;を適切に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c2aae14d23e6b4a7f032b38d8e95a4d1b336b019" translate="yes" xml:space="preserve">
          <source>As this is the only method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">これはこの特性の唯一の方法であるため、&lt;a href=&quot;trait.extend&quot;&gt;特性レベルの&lt;/a&gt;ドキュメントには詳細が含まれています。</target>
        </trans-unit>
        <trans-unit id="f292830332806677ad0b0527bf74ceadc350e53c" translate="yes" xml:space="preserve">
          <source>As usual, this output tells us exactly what has gone wrong.</source>
          <target state="translated">いつものように、この出力は何が間違っていたのかを正確に教えてくれます。</target>
        </trans-unit>
        <trans-unit id="6d6b5c58bde3c21428520a679924eb54e0901d4d" translate="yes" xml:space="preserve">
          <source>As we did with structs, we can define enums to hold generic data types in their variants. Let&amp;rsquo;s take another look at the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum that the standard library provides, which we used in Chapter 6:</source>
          <target state="translated">構造体で行ったように、列挙型を定義して、バリアントに汎用データ型を保持できます。第6章で使用した、標準ライブラリが提供する &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 列挙型をもう一度見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c9b62e53d822366f9040eaf9632aa096cd8d407c" translate="yes" xml:space="preserve">
          <source>As we saw when we printed the vector, the program&amp;rsquo;s name takes up the first value in the vector at &lt;code&gt;args[0]&lt;/code&gt;, so we&amp;rsquo;re starting at index &lt;code&gt;1&lt;/code&gt;. The first argument &lt;code&gt;minigrep&lt;/code&gt; takes is the string we&amp;rsquo;re searching for, so we put a reference to the first argument in the variable &lt;code&gt;query&lt;/code&gt;. The second argument will be the filename, so we put a reference to the second argument in the variable &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">ベクトルを出力したときに見たように、プログラムの名前は &lt;code&gt;args[0]&lt;/code&gt; にあるベクトルの最初の値を占めるため、インデックス &lt;code&gt;1&lt;/code&gt; から始めます。 &lt;code&gt;minigrep&lt;/code&gt; が取る最初の引数は検索する文字列なので、変数 &lt;code&gt;query&lt;/code&gt; に最初の引数への参照を置きます。2番目の引数はファイル名になるため、2番目の引数への参照を変数 &lt;code&gt;filename&lt;/code&gt; に入れます。</target>
        </trans-unit>
        <trans-unit id="387526bcd86a3d932ce8d276666fe3de9ea36fb2" translate="yes" xml:space="preserve">
          <source>As well as overloading the unary &lt;code&gt;*&lt;/code&gt; operator, &lt;a href=&quot;../std/ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; are also used in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">同様に単項オーバーロードとして &lt;code&gt;*&lt;/code&gt; 演算子を、&lt;a href=&quot;../std/ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; は&lt;/a&gt;またで使用されている&lt;a href=&quot;expressions/method-call-expr&quot;&gt;方法の分解能&lt;/a&gt;及び&lt;a href=&quot;type-coercions#coercion-types&quot;&gt;DEREF型変換&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00f0078e7027bdd5fb06a3cdb9f947f1a54e08c1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;, this is unsafe because it cannot verify the validity of the returned pointer, nor can it ensure that the lifetime &lt;code&gt;'a&lt;/code&gt; returned is indeed a valid lifetime for the contained data.</source>
          <target state="translated">同じように&lt;a href=&quot;#method.as_ref&quot;&gt; &lt;code&gt;as_ref&lt;/code&gt; &lt;/a&gt;それが返されたポインタの有効性を検証することができない、またそれが生涯ことを確認することができるので、これは安全ではありません &lt;code&gt;'a&lt;/code&gt; が返さが実際に含まれているデータのための有効期間です。</target>
        </trans-unit>
        <trans-unit id="e824f1a2f05ba862631703f190681d4c2dd2b70b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;underscore imports&lt;/a&gt;, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</source>
          <target state="translated">&lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;アンダースコアのインポート&lt;/a&gt;と同様に、マクロは同じスコープ内で同じ名前のない定数を2回以上安全に出力できます。たとえば、次の場合はエラーが発生しないはずです。</target>
        </trans-unit>
        <trans-unit id="4c083e9f314596dd1da24d21de9af221cdf99253" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;let&lt;/code&gt; bindings, function arguments are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, so any pattern that is valid in a let binding is also valid as an argument:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; バインディングと同様に、関数の引数は反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターン&lt;/a&gt;であるため、letバインディングで有効なパターンはすべて引数としても有効です。</target>
        </trans-unit>
        <trans-unit id="021860f0b9c701b01e24f471ef9064ff787c7fc6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;split()&lt;/code&gt;, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</source>
          <target state="translated">同様に &lt;code&gt;split()&lt;/code&gt; 最初または最後の要素が一致した場合、空のスライスが反復子によって返される最初（または最後）の項目であろう。</target>
        </trans-unit>
        <trans-unit id="a311c5a68716dfa8ec04c201fd72e1f6bf20977d" translate="yes" xml:space="preserve">
          <source>As with any variable, if we want to be able to change its value, we need to make it mutable using the &lt;code&gt;mut&lt;/code&gt; keyword, as discussed in Chapter 3. The numbers we place inside are all of type &lt;code&gt;i32&lt;/code&gt;, and Rust infers this from the data, so we don&amp;rsquo;t need the &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; annotation.</source>
          <target state="translated">他の変数と同様に、その値を変更できるようにするには、第3章で説明したように、 &lt;code&gt;mut&lt;/code&gt; キーワードを使用して変数を可変にする必要があります。内部に配置する数値はすべて &lt;code&gt;i32&lt;/code&gt; 型であり、Rustはこれをデータなので、 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; アノテーションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="4275e8a23f25e311b7879f2ca06bcf06be2ae3c3" translate="yes" xml:space="preserve">
          <source>As with many types, we create a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; using the associated function &lt;code&gt;new&lt;/code&gt;. To access the data inside the mutex, we use the &lt;code&gt;lock&lt;/code&gt; method to acquire the lock. This call will block the current thread so it can&amp;rsquo;t do any work until it&amp;rsquo;s our turn to have the lock.</source>
          <target state="translated">多くの型と同様に、関連する関数 &lt;code&gt;new&lt;/code&gt; を使用して &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; を作成します。mutex内のデータにアクセスするには、 &lt;code&gt;lock&lt;/code&gt; メソッドを使用してロックを取得します。この呼び出しは現在のスレッドをブロックするので、ロックを取得する番になるまで、作業を実行できません。</target>
        </trans-unit>
        <trans-unit id="35a5907e5dda02884b0d94275e42a50fca56e187" translate="yes" xml:space="preserve">
          <source>As with regular variables, we specify mutability using the &lt;code&gt;mut&lt;/code&gt; keyword. Any code that reads or writes from &lt;code&gt;COUNTER&lt;/code&gt; must be within an &lt;code&gt;unsafe&lt;/code&gt; block. This code compiles and prints &lt;code&gt;COUNTER: 3&lt;/code&gt; as we would expect because it&amp;rsquo;s single threaded. Having multiple threads access &lt;code&gt;COUNTER&lt;/code&gt; would likely result in data races.</source>
          <target state="translated">通常の変数と同様に、 &lt;code&gt;mut&lt;/code&gt; キーワードを使用して可変性を指定します。 &lt;code&gt;COUNTER&lt;/code&gt; から読み取りまたは書き込みを行うコードは、 &lt;code&gt;unsafe&lt;/code&gt; ブロック内にある必要があります。このコードは、シングルスレッドなので、予想どおり &lt;code&gt;COUNTER: 3&lt;/code&gt; をコンパイルして出力します。複数のスレッドが &lt;code&gt;COUNTER&lt;/code&gt; にアクセスすると、データの競合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1fb7b19ef9483e218deb8b0d1a3f5269874b86ed" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">同様&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;タイプ、 &lt;code&gt;HashSet&lt;/code&gt; のは、要素が実装する必要&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性を。これは、 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; を使用して頻繁に実現できます。これらを自分で実装する場合、次のプロパティが保持されていることが重要です。</target>
        </trans-unit>
        <trans-unit id="c568bda8aab01e836f5470185110a68fb4739aa1" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">同様&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;タイプ、 &lt;code&gt;HashSet&lt;/code&gt; のは、要素が実装する必要&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性を。これは、 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; を使用して頻繁に実現できます。これらを自分で実装する場合、次のプロパティが保持されていることが重要です。</target>
        </trans-unit>
        <trans-unit id="ae28ea4c57639b6218be246b12eabdfb50b7b74a" translate="yes" xml:space="preserve">
          <source>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</source>
          <target state="translated">変数の場合と同じように、厳密に必要以上に冗長であることを犠牲にして明示性と明快さを高めたい場合、型のアノテーションを追加できます。リスト13-5で定義したクロージャのための型のアノテーションはリスト13-7で示される定義のようになります。</target>
        </trans-unit>
        <trans-unit id="96c2069203f702eae6427926792a296cebb74618" translate="yes" xml:space="preserve">
          <source>As you add more integration tests, you might want to make more than one file in the &lt;em&gt;tests&lt;/em&gt; directory to help organize them; for example, you can group the test functions by the functionality they&amp;rsquo;re testing. As mentioned earlier, each file in the &lt;em&gt;tests&lt;/em&gt; directory is compiled as its own separate crate.</source>
          <target state="translated">統合テストをさらに追加する場合、それらを整理するために、&lt;em&gt;tests&lt;/em&gt;ディレクトリに複数のファイルを作成することができます。たとえば、テストする機能ごとにテスト関数をグループ化できます。前述のように、&lt;em&gt;tests&lt;/em&gt;ディレクトリの各ファイルは、独自のクレートとしてコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="064638b9138d50bf7a76d4f1fb8907e6d00d4af4" translate="yes" xml:space="preserve">
          <source>As you also learned in Chapter 1, &lt;code&gt;println!&lt;/code&gt; is a macro that prints a string to the screen:</source>
          <target state="translated">第1章でも学習したように、 &lt;code&gt;println!&lt;/code&gt; 画面に文字列を出力するマクロです：</target>
        </trans-unit>
        <trans-unit id="cfbf1a7efc3caed67bc7e41bd453d7589ffb22d8" translate="yes" xml:space="preserve">
          <source>As you can see in the signature of &lt;code&gt;spawn&lt;/code&gt; there are two constraints on both the closure given to &lt;code&gt;spawn&lt;/code&gt; and its return value, let's explain them:</source>
          <target state="translated">あなたはの署名で見ることができるように &lt;code&gt;spawn&lt;/code&gt; に与えられたクロージャの両方に2つの制約がある &lt;code&gt;spawn&lt;/code&gt; し、その戻り値は、のは、それらを説明しましょう：</target>
        </trans-unit>
        <trans-unit id="0420fe0c9530d1e1d147961f14b139b3fe83e9e2" translate="yes" xml:space="preserve">
          <source>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use &lt;code&gt;rustup override&lt;/code&gt; in that project&amp;rsquo;s directory to set the nightly toolchain as the one &lt;code&gt;rustup&lt;/code&gt; should use when you&amp;rsquo;re in that directory:</source>
          <target state="translated">ご覧のように、安定したツールチェーンがデフォルトです。ほとんどのRustユーザーはほとんどの場合、安定版を使用しています。ほとんどの場合は安定版を使用することをお勧めしますが、最先端の機能に関心があるため、特定のプロジェクトでは毎晩使用します。そのためには、そのプロジェクトのディレクトリで &lt;code&gt;rustup override&lt;/code&gt; を使用して、そのディレクトリにいるときに &lt;code&gt;rustup&lt;/code&gt; が使用する必要があるナイトリーツールチェーンを設定できます。</target>
        </trans-unit>
        <trans-unit id="9d87736b18e618ced4be36c042766a61a7024b14" translate="yes" xml:space="preserve">
          <source>As you can see, this will return the expected, valid items.</source>
          <target state="translated">ご覧のように、これは期待された有効なアイテムを返します。</target>
        </trans-unit>
        <trans-unit id="2afcd0df9449bfb1b32a67c779124a1b65363260" translate="yes" xml:space="preserve">
          <source>As you can see, using the parent modules distinguishes the two &lt;code&gt;Result&lt;/code&gt; types. If instead we specified &lt;code&gt;use std::fmt::Result&lt;/code&gt; and &lt;code&gt;use std::io::Result&lt;/code&gt;, we&amp;rsquo;d have two &lt;code&gt;Result&lt;/code&gt; types in the same scope and Rust wouldn&amp;rsquo;t know which one we meant when we used &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">ご覧のとおり、親モジュールを使用すると、2つの &lt;code&gt;Result&lt;/code&gt; タイプが区別されます。代わりに &lt;code&gt;use std::fmt::Result&lt;/code&gt; と &lt;code&gt;use std::io::Result&lt;/code&gt; を指定した場合、同じスコープ内に2つの &lt;code&gt;Result&lt;/code&gt; タイプがあり、Rustは &lt;code&gt;Result&lt;/code&gt; を使用したときにどちらが意図されているかを認識しません。</target>
        </trans-unit>
        <trans-unit id="20722bacbfbb971e3e58847f05a0049adb3a009e" translate="yes" xml:space="preserve">
          <source>As you can see, we&amp;rsquo;ve moved everything into a loop from the guess input prompt onward. Be sure to indent the lines inside the loop another four spaces each and run the program again. Notice that there is a new problem because the program is doing exactly what we told it to do: ask for another guess forever! It doesn&amp;rsquo;t seem like the user can quit!</source>
          <target state="translated">ご覧のとおり、すべてを推測入力プロンプトからループに移動しています。ループ内の行をそれぞれ4つずつインデントして、プログラムを再度実行してください。プログラムが実行するように指示したとおりにプログラムが実行しているため、新しい問題があることに注意してください。永遠に別の推測を求めてください！ユーザーが終了できるようではありません！</target>
        </trans-unit>
        <trans-unit id="ac1ee84193bb1d8e87992969494a2311a45eebb9" translate="yes" xml:space="preserve">
          <source>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, &lt;code&gt;{Self}&lt;/code&gt; will substitute to the type (in this case, &lt;code&gt;bool&lt;/code&gt;) that we tried to use.</source>
          <target state="translated">ご覧のとおり、特定の状況で実際の型（通常のフォーマット文字列構文を使用）に置き換えるために、中括弧で型パラメーターを指定できます。さらに、 &lt;code&gt;{Self}&lt;/code&gt; は、使用しようとしたタイプ（この場合は &lt;code&gt;bool&lt;/code&gt; ）に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="b2e9ae4479b0983efbf6a5f5ed8ba7b27ba6777d" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">ご覧のように、(レイアウト、安全性、所有権を除いて)組合は多くの面で構造体と全く同じように動作します。これは、Rust言語の多くの未言及の側面(プライバシー、名前解決、型推論、ジェネリック、形質実装、固有の実装、コヒーレンス、パターンチェックなど)にも当てはまります。</target>
        </trans-unit>
        <trans-unit id="b701fb6519447ef85d48d0e79a042ed086034a11" translate="yes" xml:space="preserve">
          <source>As you learned in Chapter 16, &lt;code&gt;thread::spawn&lt;/code&gt; will create a new thread and then run the code in the closure in the new thread. If you run this code and load &lt;em&gt;/sleep&lt;/em&gt; in your browser, then &lt;em&gt;/&lt;/em&gt; in two more browser tabs, you&amp;rsquo;ll indeed see that the requests to &lt;em&gt;/&lt;/em&gt; don&amp;rsquo;t have to wait for &lt;em&gt;/sleep&lt;/em&gt; to finish. But as we mentioned, this will eventually overwhelm the system because you&amp;rsquo;d be making new threads without any limit.</source>
          <target state="translated">第16章で学習したように、 &lt;code&gt;thread::spawn&lt;/code&gt; は新しいスレッドを作成し、新しいスレッドのクロージャーでコードを実行します。あなたはこのコードとロード実行した場合&lt;em&gt;/睡眠を&lt;/em&gt;お使いのブラウザで、その後&lt;em&gt;/&lt;/em&gt; 2以上のブラウザのタブで、あなたは確かに要求することを確認できます&lt;em&gt;/&lt;/em&gt;を待つ必要はありません&lt;em&gt;/スリープ&lt;/em&gt;仕上げにします。しかし、前述したように、制限なしで新しいスレッドを作成するため、これは最終的にシステムを圧倒します。</target>
        </trans-unit>
        <trans-unit id="f4d2e2ae7d1d7339cbe38cf89981448ff9804651" translate="yes" xml:space="preserve">
          <source>As you might have guessed, &lt;code&gt;continue&lt;/code&gt; has a &lt;code&gt;!&lt;/code&gt; value. That is, when Rust computes the type of &lt;code&gt;guess&lt;/code&gt;, it looks at both match arms, the former with a value of &lt;code&gt;u32&lt;/code&gt; and the latter with a &lt;code&gt;!&lt;/code&gt; value. Because &lt;code&gt;!&lt;/code&gt; can never have a value, Rust decides that the type of &lt;code&gt;guess&lt;/code&gt; is &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">ご想像のとおり、 &lt;code&gt;continue&lt;/code&gt; には &lt;code&gt;!&lt;/code&gt; 値。つまり、Rustが &lt;code&gt;guess&lt;/code&gt; のタイプを計算するとき、両方のマッチアームを調べます。前者は &lt;code&gt;u32&lt;/code&gt; の値を持ち、後者は &lt;code&gt;!&lt;/code&gt; 値。なぜなら &lt;code&gt;!&lt;/code&gt; Rustは値を持つことができないため、 &lt;code&gt;guess&lt;/code&gt; のタイプは &lt;code&gt;u32&lt;/code&gt; であると判断します。</target>
        </trans-unit>
        <trans-unit id="467cfe4dd8e4d010791398ae5c6bd0fbee6d53ca" translate="yes" xml:space="preserve">
          <source>As you might suspect, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is a smart pointer. More accurately, the call to &lt;code&gt;lock&lt;/code&gt;&lt;em&gt;returns&lt;/em&gt; a smart pointer called &lt;code&gt;MutexGuard&lt;/code&gt;, wrapped in a &lt;code&gt;LockResult&lt;/code&gt; that we handled with the call to &lt;code&gt;unwrap&lt;/code&gt;. The &lt;code&gt;MutexGuard&lt;/code&gt; smart pointer implements &lt;code&gt;Deref&lt;/code&gt; to point at our inner data; the smart pointer also has a &lt;code&gt;Drop&lt;/code&gt; implementation that releases the lock automatically when a &lt;code&gt;MutexGuard&lt;/code&gt; goes out of scope, which happens at the end of the inner scope in Listing 16-12. As a result, we don&amp;rsquo;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</source>
          <target state="translated">ご &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; とおり、Mutex &amp;lt;T&amp;gt;はスマートポインターです。より正確には、への呼び出し &lt;code&gt;lock&lt;/code&gt; &lt;em&gt;返す&lt;/em&gt;と呼ばれるスマートポインタ &lt;code&gt;MutexGuard&lt;/code&gt; に包まれ、 &lt;code&gt;LockResult&lt;/code&gt; 我々はへの呼び出しで処理することを &lt;code&gt;unwrap&lt;/code&gt; 。 &lt;code&gt;MutexGuard&lt;/code&gt; スマートポインタを実装 &lt;code&gt;Deref&lt;/code&gt; 私たちの内部データを指すように。スマートポインターには、 &lt;code&gt;MutexGuard&lt;/code&gt; の実行時にロックを自動的に解放する &lt;code&gt;Drop&lt;/code&gt; 実装もあります。リスト16-12の内側のスコープの最後で発生するスコープ外。その結果、ロックの解放が自動的に行われるため、ロックの解放を忘れ、他のスレッドがミューテックスを使用するのをブロックするリスクがありません。</target>
        </trans-unit>
        <trans-unit id="e4e495363e711b35cf1aef444d4c023b03ec561b" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, &lt;code&gt;cargo new&lt;/code&gt; generates a &amp;ldquo;Hello, world!&amp;rdquo; program for you. Check out the &lt;em&gt;src/main.rs&lt;/em&gt; file:</source>
          <target state="translated">第1章で見たように、 &lt;code&gt;cargo new&lt;/code&gt; は「Hello、world！」を生成します。あなたのためのプログラム。&lt;em&gt;src / main.rs&lt;/em&gt;ファイルを確認します。</target>
        </trans-unit>
        <trans-unit id="acce671b7472bf5e5eaabe31a3ccfe6aca667c9d" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, the &lt;code&gt;main&lt;/code&gt; function is the entry point into the program:</source>
          <target state="translated">第1章で見たように、 &lt;code&gt;main&lt;/code&gt; 機能はプログラムへのエントリポイントです。</target>
        </trans-unit>
        <trans-unit id="1b995f5c38439d41d9506c07ed8d2188c4fc0f99" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</source>
          <target state="translated">第6章で見たように、パターンとリテラルを直接一致させることができます。次のコードはいくつかの例を示しています。</target>
        </trans-unit>
        <trans-unit id="fa0b472a10784179b99aa6fee609e3cfddb9cc55" translate="yes" xml:space="preserve">
          <source>As you saw in Listing 17-15, we can write methods that use the syntax &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, which allows the method to take ownership of a &lt;code&gt;Self&lt;/code&gt; value stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. That&amp;rsquo;s exactly what we want to do here, but unfortunately Rust won&amp;rsquo;t let us: the part of Rust that implements behavior when a closure is called isn&amp;rsquo;t implemented using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. So Rust doesn&amp;rsquo;t yet understand that it could use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in this situation to take ownership of the closure and move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">リスト17-15で見たように、構文 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; を使用するメソッドを書くことができます。これにより、メソッドは &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 格納されている &lt;code&gt;Self&lt;/code&gt; 値の所有権を取得できます。これがまさにここでしたいことですが、残念ながらRustは許可しません。Rustのクロージャーが呼び出されたときに動作を実装する部分は、 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; を使用して実装されていません。したがって、Rustは、この状況でクロージャの所有権を取得してクロージャを &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; から移動するために、 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; を使用できることをまだ理解していません。</target>
        </trans-unit>
        <trans-unit id="5d8ebbcc7fc2cf4e602d0e1985852befad2da85e" translate="yes" xml:space="preserve">
          <source>As you saw in the guessing game tutorial in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is &lt;em&gt;shadowed&lt;/em&gt; by the second, which means that the second variable&amp;rsquo;s value is what appears when the variable is used. We can shadow a variable by using the same variable&amp;rsquo;s name and repeating the use of the &lt;code&gt;let&lt;/code&gt; keyword as follows:</source>
          <target state="translated">第2章の&lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;「推測と秘密の番号の比較」&lt;/a&gt;セクションの推測ゲームチュートリアルで見たように、以前の変数と同じ名前で新しい変数を宣言でき、新しい変数は以前の変数をシャドウします。錆びついた人は、最初の変数は2番目の変数によって&lt;em&gt;隠さ&lt;/em&gt;れていると言います。つまり、2番目の変数の値は、変数が使用されたときに表示されるものです。同じ変数の名前を使用し、次のように &lt;code&gt;let&lt;/code&gt; キーワードの使用を繰り返すことで、変数をシャドウできます。</target>
        </trans-unit>
        <trans-unit id="c47b398566173be1e06632198f7039025f10ae00" translate="yes" xml:space="preserve">
          <source>As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you&amp;rsquo;ll clarify where to find code that implements a particular feature and where to go to change how a feature works.</source>
          <target state="translated">大規模なプログラムを作成する場合、プログラム全体を頭の中で追跡することが不可能になるため、コードを編成することが重要になります。関連する機能をグループ化し、個別の機能を持つコードを分離することで、特定の機能を実装するコードの場所と、機能の動作を変更する場所を明確にします。</target>
        </trans-unit>
        <trans-unit id="a48835105e35976d30850d6478e3e8cb37ac0bc5" translate="yes" xml:space="preserve">
          <source>As your project grows, consider using a workspace: it&amp;rsquo;s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between them easier if they are often changed at the same time.</source>
          <target state="translated">プロジェクトが成長するにつれて、ワークスペースの使用を検討してください。1つの大きなコードの塊よりも小さな個々のコンポーネントを理解する方が簡単です。さらに、ワークスペースにクレートを保持すると、頻繁に同時に変更される場合に、クレート間の調整が容易になります。</target>
        </trans-unit>
        <trans-unit id="db2e27ecee3ef7df382d73da5185cf2c81a313eb" translate="yes" xml:space="preserve">
          <source>AsMut</source>
          <target state="translated">AsMut</target>
        </trans-unit>
        <trans-unit id="9dee5144fa49d1023659054cfeb7b935d110f729" translate="yes" xml:space="preserve">
          <source>AsMut::as_mut</source>
          <target state="translated">AsMut::as_mut</target>
        </trans-unit>
        <trans-unit id="fa6cbff29c8fee2a75af18139d6ec5d8bb30e951" translate="yes" xml:space="preserve">
          <source>AsRawFd</source>
          <target state="translated">AsRawFd</target>
        </trans-unit>
        <trans-unit id="bf4b7b3bd11f76d54ac78e508bf69a1df97a73ab" translate="yes" xml:space="preserve">
          <source>AsRawHandle</source>
          <target state="translated">AsRawHandle</target>
        </trans-unit>
        <trans-unit id="bcb7263b347977861cfead462a0183ddbacb93a0" translate="yes" xml:space="preserve">
          <source>AsRawSocket</source>
          <target state="translated">AsRawSocket</target>
        </trans-unit>
        <trans-unit id="ecb4ad32c0bbcb0030bdba05dd0126fda307a2ef" translate="yes" xml:space="preserve">
          <source>AsRef</source>
          <target state="translated">AsRef</target>
        </trans-unit>
        <trans-unit id="ce713a708d26f349ef9d3da2c64c32c52ede1f28" translate="yes" xml:space="preserve">
          <source>AsRef::as_ref</source>
          <target state="translated">AsRef::as_ref</target>
        </trans-unit>
        <trans-unit id="a4ef661b82f652f581223b25a6824dec40ae544d" translate="yes" xml:space="preserve">
          <source>AsciiExt</source>
          <target state="translated">AsciiExt</target>
        </trans-unit>
        <trans-unit id="46e0dda46ad92722f1539fd012c3778f39c3b187" translate="yes" xml:space="preserve">
          <source>AsciiExt::eq_ignore_ascii_case</source>
          <target state="translated">AsciiExt::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="afaf433bc6efc0517fc1bdeb6f7c5eafce3e74d4" translate="yes" xml:space="preserve">
          <source>AsciiExt::is_ascii</source>
          <target state="translated">AsciiExt::is_ascii</target>
        </trans-unit>
        <trans-unit id="a117348e90cbeb6580ea282ea76b737d649c0ce2" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_lowercase</source>
          <target state="translated">AsciiExt::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="014f8e9aa886e527dbae3bd8a29a0232814779eb" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_uppercase</source>
          <target state="translated">AsciiExt::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="ac47518e69af0774bb76855d1ba4fd45ba076dbb" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_lowercase</source>
          <target state="translated">AsciiExt::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e04741744413a75fb42c855cb8f9068dc93b7a29" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_uppercase</source>
          <target state="translated">AsciiExt::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="f99c599e0e3924b919cda05ade321af8f7909739" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly brackets, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">閉じ中かっこを除いて、これまでに追加したコードで説明する行は次の1つだけです。</target>
        </trans-unit>
        <trans-unit id="ccfa1ea33000ed1fdc5e32d6d85a1f23b351c53c" translate="yes" xml:space="preserve">
          <source>Asked how long the string is, you might say 12. However, Rust&amp;rsquo;s answer is 24: that&amp;rsquo;s the number of bytes it takes to encode &amp;ldquo;Здравствуйте&amp;rdquo; in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string&amp;rsquo;s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:</source>
          <target state="translated">文字列の長さを尋ねると、12と言うかもしれません。ただし、Rustの答えは24です。これは、「Здравствуйте」をUTF-8でエンコードするのに必要なバイト数です。これは、その文字列の各Unicodeスカラー値が2バイトのストレージを必要とするためです。したがって、文字列のバイトへのインデックスは、常に有効なUnicodeスカラー値と相関するとは限りません。実例として、次の無効なRustコードを検討してください。</target>
        </trans-unit>
        <trans-unit id="e7689cb162bee3d282a7b39ef7b90263d73428fa" translate="yes" xml:space="preserve">
          <source>Assert the results are what you expect.</source>
          <target state="translated">結果は期待通りだと断言します。</target>
        </trans-unit>
        <trans-unit id="14ec22b40bdfb6faadf461156fa13c1003c498f7" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe</source>
          <target state="translated">AssertUnwindSafe</target>
        </trans-unit>
        <trans-unit id="b22e5cc4bce8496592970be5b25d370d67581697" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow</source>
          <target state="translated">AssertUnwindSafe::borrow</target>
        </trans-unit>
        <trans-unit id="e9b2629172195580950a107f4837fef269c6587e" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow_mut</source>
          <target state="translated">AssertUnwindSafe::borrow_mut</target>
        </trans-unit>
        <trans-unit id="65951f8f36689c68821ae0439274d4a0186d7055" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::call_once</source>
          <target state="translated">AssertUnwindSafe::call_once</target>
        </trans-unit>
        <trans-unit id="846bd763b3f520ae6051ff0597c886f310c2c6ea" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref</source>
          <target state="translated">AssertUnwindSafe::deref</target>
        </trans-unit>
        <trans-unit id="0f7f2436811897e328934158a966a543668732f9" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref_mut</source>
          <target state="translated">AssertUnwindSafe::deref_mut</target>
        </trans-unit>
        <trans-unit id="df50057fe584f587876a9e064fa1ae0b0acfbda2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::fmt</source>
          <target state="translated">AssertUnwindSafe::fmt</target>
        </trans-unit>
        <trans-unit id="d34a0fd3c126015a7f7ea1d7a1780f16da8c0c7f" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::from</source>
          <target state="translated">AssertUnwindSafe::from</target>
        </trans-unit>
        <trans-unit id="bc1f4df4473c05cd44c2d50adf3e2f9062513d4c" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::into</source>
          <target state="translated">AssertUnwindSafe::into</target>
        </trans-unit>
        <trans-unit id="3b850d0a322410d738f80adc8cf728ee8170ee1d" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::poll</source>
          <target state="translated">AssertUnwindSafe::poll</target>
        </trans-unit>
        <trans-unit id="daed5606c5d5daf7eeeb4806493948f969bf4f99" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_from</source>
          <target state="translated">AssertUnwindSafe::try_from</target>
        </trans-unit>
        <trans-unit id="eb82a427dc920b4169ca7e00269601d2ac319ce2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_into</source>
          <target state="translated">AssertUnwindSafe::try_into</target>
        </trans-unit>
        <trans-unit id="9f7d994301cc07488a1ff2b7d4c3da5dab748286" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::type_id</source>
          <target state="translated">AssertUnwindSafe::type_id</target>
        </trans-unit>
        <trans-unit id="caf84242142f24165f73b39c5c6b3d3bc20e5c26" translate="yes" xml:space="preserve">
          <source>Assertions are always checked in both debug and release builds, and cannot be disabled. See &lt;a href=&quot;macro.debug_assert&quot;&gt;&lt;code&gt;debug_assert!&lt;/code&gt;&lt;/a&gt; for assertions that are not enabled in release builds by default.</source>
          <target state="translated">アサーションは常にデバッグビルドとリリースビルドの両方でチェックされ、無効にすることはできません。&lt;a href=&quot;macro.debug_assert&quot;&gt; &lt;code&gt;debug_assert!&lt;/code&gt; &lt;/a&gt;参照してください！デフォルトではリリースビルドで有効になっていないアサーション用。</target>
        </trans-unit>
        <trans-unit id="e17cdfab7869a902dcf07cf1a4cdf602ea080d95" translate="yes" xml:space="preserve">
          <source>Asserts that a boolean expression is &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">実行時にブール式が &lt;code&gt;true&lt;/code&gt; であることを表明します。</target>
        </trans-unit>
        <trans-unit id="2cab5457990719d367e9e18b69d1f9cf567a9ba6" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">2つの式が互いに等しいことを表明します（&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="ebf68c5dd99f7adc415f813d7cd9a9965b251c70" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other.</source>
          <target state="translated">2つの式が互いに等しいことを主張する。</target>
        </trans-unit>
        <trans-unit id="c856365534a0e73e93b9d798530cb553f48e1b9c" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">2つの式が互いに等しくないことを表明します（&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="4b3283be054a95811542a229062df29f52cd4b0a" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other.</source>
          <target state="translated">2つの式が互いに等しくないことを主張する。</target>
        </trans-unit>
        <trans-unit id="6a70c6eb716321451f69851e0a0b3e6de46cfe0a" translate="yes" xml:space="preserve">
          <source>Assignment expressions</source>
          <target state="translated">代入表現</target>
        </trans-unit>
        <trans-unit id="db7b4a247e0cd4b439f9a236f4dd17ca687d0c37" translate="yes" xml:space="preserve">
          <source>Assignment of &lt;code&gt;A + B&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt; might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.</source>
          <target state="translated">割り当て &lt;code&gt;A + B&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; は、それが印刷されるまでの合計は決して更新しないばかりグローバル変数で、一時的な場所に保存することができるので、削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="fb5a2f19ac5c2fbe53a27d32c54a5315d8390b9c" translate="yes" xml:space="preserve">
          <source>Assignment/equivalence</source>
          <target state="translated">Assignment/equivalence</target>
        </trans-unit>
        <trans-unit id="1ec71ff0ba20c7a0026ccba467326b673793511e" translate="yes" xml:space="preserve">
          <source>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</source>
          <target state="translated">マッチングに副作用を持たせることはできないため、パターンガードでは代入は許可されていません。副作用は、マッチしたオブジェクトやマッチが依存する環境を変更する可能性があり、マッチが完全ではありません。例えば、以下のようなものは、割り当てが許可されている場合、どのアームにもマッチしません。</target>
        </trans-unit>
        <trans-unit id="681eeaa9b3a793bf0806817da80c3be3c3a0567b" translate="yes" xml:space="preserve">
          <source>Assigns a new value to the memory behind the pinned reference.</source>
          <target state="translated">固定された参照の後ろのメモリに新しい値を割り当てます。</target>
        </trans-unit>
        <trans-unit id="b443e8292f53b80a70f9ceabc76037bb4e254686" translate="yes" xml:space="preserve">
          <source>Associated Constants</source>
          <target state="translated">関連する定数</target>
        </trans-unit>
        <trans-unit id="aea3ba1170590168c2a8d38c0934f41a1081bd96" translate="yes" xml:space="preserve">
          <source>Associated Constants Examples</source>
          <target state="translated">関連定数の例</target>
        </trans-unit>
        <trans-unit id="eb724e00631164f5e2c7a1805aa66c501706a7b7" translate="yes" xml:space="preserve">
          <source>Associated Functions</source>
          <target state="translated">関連機能</target>
        </trans-unit>
        <trans-unit id="b9d6b786d3dce88371ca3fec1b3f0f5dcc494947" translate="yes" xml:space="preserve">
          <source>Associated Items</source>
          <target state="translated">関連項目</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">関連するタイプ</target>
        </trans-unit>
        <trans-unit id="d854ee9b0fbbb41a1a8293a522b3a7fd759f3935" translate="yes" xml:space="preserve">
          <source>Associated Types Container Example</source>
          <target state="translated">関連づけられたタイプ コンテナの例</target>
        </trans-unit>
        <trans-unit id="6176d44495c67b15b26948f8a03f37c611fcd9c1" translate="yes" xml:space="preserve">
          <source>Associated constants, functions, and types</source>
          <target state="translated">関連する定数、関数、型</target>
        </trans-unit>
        <trans-unit id="bf8fe32d8bff33aaf1adf4d6ce640603da967659" translate="yes" xml:space="preserve">
          <source>Associated functions and methods</source>
          <target state="translated">関連する機能とメソッド</target>
        </trans-unit>
        <trans-unit id="ca7658fbd81144f975e114c63e67d2067128142d" translate="yes" xml:space="preserve">
          <source>Associated functions are often used for constructors that will return a new instance of the struct. For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square &lt;code&gt;Rectangle&lt;/code&gt; rather than having to specify the same value twice:</source>
          <target state="translated">関連する関数は、構造体の新しいインスタンスを返すコンストラクターによく使用されます。たとえば、1つの寸法パラメーターを持つ関連付けられた関数を提供し、それを幅と高さの両方として使用できるため、同じ値を2回指定する必要がなく、正方形の &lt;code&gt;Rectangle&lt;/code&gt; 簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="1d8027bfb0422adf6fa755c7366da969f12a3f99" translate="yes" xml:space="preserve">
          <source>Associated functions whose first parameter is named &lt;code&gt;self&lt;/code&gt; are called &lt;em&gt;methods&lt;/em&gt; and may be invoked using the &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;method call operator&lt;/a&gt;, for example, &lt;code&gt;x.foo()&lt;/code&gt;, as well as the usual function call notation.</source>
          <target state="translated">その最初のパラメータと命名された関連機能 &lt;code&gt;self&lt;/code&gt; 呼び出される&lt;em&gt;方法&lt;/em&gt;と使用して呼び出すことができる&lt;a href=&quot;../expressions/method-call-expr&quot;&gt;メソッド呼び出しオペレータ&lt;/a&gt;、例えば、 &lt;code&gt;x.foo()&lt;/code&gt; 、ならびに通常の関数呼び出し表記。</target>
        </trans-unit>
        <trans-unit id="50f4dee25317e303fd0eeee4d556e246ef57db0b" translate="yes" xml:space="preserve">
          <source>Associated item</source>
          <target state="translated">関連項目</target>
        </trans-unit>
        <trans-unit id="4627f0f1df7ed7ad7efce2d0583317bf3d8df511" translate="yes" xml:space="preserve">
          <source>Associated item for a type that cannot be directly named (e.g., &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt;, &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt;, etc.)</source>
          <target state="translated">直接名前を付けることができないタイプに関連付けられたアイテム（例： &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt; 、 &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt; など）</target>
        </trans-unit>
        <trans-unit id="f0dda5ab7ff2aba410ad872aa8c289173200dd02" translate="yes" xml:space="preserve">
          <source>Associated items are useful when the associated item logically is related to the associating item. For example, the &lt;code&gt;is_some&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; is intrinsically related to Options, so should be associated.</source>
          <target state="translated">関連アイテムは、関連アイテムが関連アイテムに論理的に関連している場合に役立ちます。たとえば、 &lt;code&gt;Option&lt;/code&gt; の &lt;code&gt;is_some&lt;/code&gt; メソッドは本質的にOptionsに関連しているため、関連付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="13ba4a748e2d8dab765ce941e0df6910e63030e1" translate="yes" xml:space="preserve">
          <source>Associated searcher for this pattern</source>
          <target state="translated">このパターンに関連する検索者</target>
        </trans-unit>
        <trans-unit id="ce35cedae86fe81ca2cf2bcb725660816d309811" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; られた型としてのPattern &amp;lt;'a &amp;gt;&amp;gt; :: Searcher。</target>
        </trans-unit>
        <trans-unit id="e195d76e814dc3f6b09416fe019701da4141e61f" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 関連タイプ。</target>
        </trans-unit>
        <trans-unit id="da9f3600b580da18821fb0932aa55c1e82dc8484" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 関連タイプ。</target>
        </trans-unit>
        <trans-unit id="470b87bc44e9aa3c27db7ff27c851ded51a493f4" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 関連タイプ。</target>
        </trans-unit>
        <trans-unit id="4b2aeb71be1e33f6aef873e1957563d04f8d17e0" translate="yes" xml:space="preserve">
          <source>Associated types from &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">&lt;code&gt;Trait&lt;/code&gt; 関連タイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="b94fe8e8235a5eac0ea7986a3bc24833e5f55164" translate="yes" xml:space="preserve">
          <source>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</source>
          <target state="translated">関連づけられた型はジェネリックと似たような概念のように思われるかもしれませんが、後者では、関数が扱える型を指定せずに関数を定義することができます。ではなぜ連想型を使うのでしょうか?</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="434de15a9f2e5951652f37ae43c858535ba0b678" translate="yes" xml:space="preserve">
          <source>Assume there are two files in the same directory with the following contents:</source>
          <target state="translated">同じディレクトリに以下の内容のファイルが2つあるとします。</target>
        </trans-unit>
        <trans-unit id="9c07290f30084dee9d612cccf40372822beeda08" translate="yes" xml:space="preserve">
          <source>Assumes that the slice is sorted by the key, for instance with &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">たとえば、同じキー抽出関数を使用して&lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt;を使用して、スライスがキーでソートされていると仮定します。</target>
        </trans-unit>
        <trans-unit id="c924c9518b3ab961e095e1c3fb8fc583399ec253" translate="yes" xml:space="preserve">
          <source>Assuming there&amp;rsquo;s a file named &lt;code&gt;foo.txt&lt;/code&gt; with contents &lt;code&gt;abcdef\n&lt;/code&gt;, create two handles, seek one of them, and read the remaining bytes from the other handle:</source>
          <target state="translated">内容が &lt;code&gt;abcdef\n&lt;/code&gt; &lt;code&gt;foo.txt&lt;/code&gt; という名前のファイルがあると想定して、2つのハンドルを作成し、そのうちの1つを探し、残りのバイトを他のハンドルから読み取ります。</target>
        </trans-unit>
        <trans-unit id="31936e0a0d8572ee4060f19296edebc34a7f6f8c" translate="yes" xml:space="preserve">
          <source>Asterisk glob imports will import items imported with &lt;code&gt;_&lt;/code&gt; in their unnameable form.</source>
          <target state="translated">アスタリスクglobインポートは、名前が &lt;code&gt;_&lt;/code&gt; でインポートされたアイテムを名前のない形式でインポートします。</target>
        </trans-unit>
        <trans-unit id="c318095156a540e68b8cc7d9ad9ab72fce83a154" translate="yes" xml:space="preserve">
          <source>Asynchronous values.</source>
          <target state="translated">非同期の値。</target>
        </trans-unit>
        <trans-unit id="0855009c46728a5c8cb9aa53860e3b38d932c17a" translate="yes" xml:space="preserve">
          <source>At</source>
          <target state="translated">At</target>
        </trans-unit>
        <trans-unit id="d9cacf1832e8829a2c65089757588eeeacfc9330" translate="yes" xml:space="preserve">
          <source>At all times, you must avoid data races. If multiple threads have access to the same &lt;code&gt;UnsafeCell&lt;/code&gt;, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</source>
          <target state="translated">常に、データの競合を回避する必要があります。複数のスレッドが同じ &lt;code&gt;UnsafeCell&lt;/code&gt; にアクセスできる場合、すべての書き込みは他のすべてのアクセスと適切に発生する前に関係している（またはアトミックを使用する）必要があります。</target>
        </trans-unit>
        <trans-unit id="c68169e0fac1472856a75bc093cd4e904a65d3b5" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; (but not both of) one mutable reference or any number of immutable references.</source>
          <target state="translated">いつでも、1つ（両方ではない）の可変参照または任意の数の不変参照の&lt;em&gt;いずれか&lt;/em&gt;を持つことができます。</target>
        </trans-unit>
        <trans-unit id="97c27bc0fbd95b57400fcf731e3e7a7d89c5cf2f" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; one mutable reference &lt;em&gt;or&lt;/em&gt; any number of immutable references.</source>
          <target state="translated">いつでも&lt;em&gt;、&lt;/em&gt; 1つの変更可能な参照&lt;em&gt;または&lt;/em&gt;任意の数の不変の参照を持つことができます。</target>
        </trans-unit>
        <trans-unit id="b790d9edc1873ab13071956060a912cd284deda5" translate="yes" xml:space="preserve">
          <source>At compile time each implementation of &lt;code&gt;Trait&lt;/code&gt; will produce a table containing the various methods (and other items) related to the implementation.</source>
          <target state="translated">コンパイル時に、 &lt;code&gt;Trait&lt;/code&gt; の各実装は、実装に関連するさまざまなメソッド（およびその他の項目）を含むテーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="26e37b1b35b52ad10610ea1ef12403fe61f658c6" translate="yes" xml:space="preserve">
          <source>At compile time, Rust needs to know how much space a type takes up. One type whose size can&amp;rsquo;t be known at compile time is a &lt;em&gt;recursive type&lt;/em&gt;, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn&amp;rsquo;t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</source>
          <target state="translated">コンパイル時に、Rustは型が占めるスペースを知る必要があります。コンパイル時にサイズがわからない型の1つは&lt;em&gt;再帰型&lt;/em&gt;で、値はそれ自体の一部として同じ型の別の値を持つことができます。この値のネストは理論的には無限に続く可能性があるため、Rustは再帰型の値に必要なスペースの量を知りません。ただし、ボックスには既知のサイズがあるため、再帰型定義にボックスを挿入することで、再帰型を使用できます。</target>
        </trans-unit>
        <trans-unit id="b2f9b5afe99b75e0f39f01ec88be93443b074a9d" translate="yes" xml:space="preserve">
          <source>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the &lt;code&gt;Rc::strong_count&lt;/code&gt; function. This function is named &lt;code&gt;strong_count&lt;/code&gt; rather than &lt;code&gt;count&lt;/code&gt; because the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type also has a &lt;code&gt;weak_count&lt;/code&gt;; we&amp;rsquo;ll see what &lt;code&gt;weak_count&lt;/code&gt; is used for in the &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;Preventing Reference Cycles: Turning an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">参照カウントが変更されるプログラムの各ポイントで、参照カウントを &lt;code&gt;Rc::strong_count&lt;/code&gt; ます。これは、Rc :: strong_count関数を呼び出すことで取得できます。この関数は、指定され &lt;code&gt;strong_count&lt;/code&gt; ではなく &lt;code&gt;count&lt;/code&gt; ので、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; タイプもあり &lt;code&gt;weak_count&lt;/code&gt; を。&lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;「参照サイクルの防止：&lt;/a&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 変える」セクションで、 &lt;code&gt;weak_count&lt;/code&gt; の使用目的を確認します。</target>
        </trans-unit>
        <trans-unit id="f2afe7e487c0f1c732676abe97c30fdb7bfd5600" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">最初はメモリがまったく割り当てられていませんが、文字列に追加すると、容量が適切に増加します。代わりに&lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt;メソッドを使用して、最初に正しい容量を割り当てる場合：</target>
        </trans-unit>
        <trans-unit id="0295e56a89c227419234a744fcdff39f54bbbd31" translate="yes" xml:space="preserve">
          <source>At its simplest, a test in Rust is a function that&amp;rsquo;s annotated with the &lt;code&gt;test&lt;/code&gt; attribute. Attributes are metadata about pieces of Rust code; one example is the &lt;code&gt;derive&lt;/code&gt; attribute we used with structs in Chapter 5. To change a function into a test function, add &lt;code&gt;#[test]&lt;/code&gt; on the line before &lt;code&gt;fn&lt;/code&gt;. When you run your tests with the &lt;code&gt;cargo test&lt;/code&gt; command, Rust builds a test runner binary that runs the functions annotated with the &lt;code&gt;test&lt;/code&gt; attribute and reports on whether each test function passes or fails.</source>
          <target state="translated">最も簡単に言うと、Rustの &lt;code&gt;test&lt;/code&gt; はtest属性で注釈が付けられた関数です。属性は、Rustコードの断片に関するメタデータです。1つの例は、第5章の構造体で使用した &lt;code&gt;derive&lt;/code&gt; 属性です。関数をテスト関数に変更するには、 &lt;code&gt;fn&lt;/code&gt; の前の行に &lt;code&gt;#[test]&lt;/code&gt; を追加します。Rustは、 &lt;code&gt;cargo test&lt;/code&gt; コマンドを使用してテストを実行すると、 &lt;code&gt;test&lt;/code&gt; 属性で注釈が付けられた関数を実行するテストランナーバイナリを構築し、各テスト関数が成功したか失敗したかを報告します。</target>
        </trans-unit>
        <trans-unit id="37583ea386b39553438667ee1326a11884d8ac4d" translate="yes" xml:space="preserve">
          <source>At least one of either &lt;code&gt;Self&lt;/code&gt; or a generic type parameter of the trait must meet the following grammar, where &lt;code&gt;C&lt;/code&gt; is a nominal type defined within the containing crate:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; または特性のジェネリック型パラメーターの少なくとも1つは、次の文法を満たしている必要があります &lt;code&gt;C&lt;/code&gt; は、含まれているクレート内で定義されている名義型です。</target>
        </trans-unit>
        <trans-unit id="6340eab1a988a949757faf0b3ab2c9f1d577f929" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is being used to write to the data.</source>
          <target state="translated">ポインタのうち少なくとも1つは、データへの書き込みに使用されています。</target>
        </trans-unit>
        <trans-unit id="e2c9357843faff292144d5026ce32c57e9298ff6" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be &quot;contained&quot; to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</source>
          <target state="translated">現在のところ、借方がスコープ内にある間に発生したイールドを持つことは許されていません。このエラーを解決するためには、borrowをイールドと重ならない小さなスコープに「含める」か、別の方法で削除しなければなりません。そのため、例えば、先ほどの例では借用を削除して整数を値で格納することで解決することができます。</target>
        </trans-unit>
        <trans-unit id="880cb1d1611d41944fc45c1105942f35a2cea331" translate="yes" xml:space="preserve">
          <source>At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</source>
          <target state="translated">この章の最初に、ベクターは同じ型の値しか格納できないと述べました。これは不便な場合があります。幸いなことに、列挙型のバリアントは同じ列挙型の下で定義されているので、異なる型の要素をベクトルに格納する必要があるときは、列挙型を定義して使用することができます!</target>
        </trans-unit>
        <trans-unit id="b0f9f410d4d3f041a8bbac0598dae49519ac5a0f" translate="yes" xml:space="preserve">
          <source>At the moment the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks have a lot of repetition: they&amp;rsquo;re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let&amp;rsquo;s make the code more concise by pulling out those differences into separate &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">現時点では、 &lt;code&gt;if&lt;/code&gt; ブロックと &lt;code&gt;else&lt;/code&gt; ブロックには多くの繰り返しがあります。これらは両方とも、ファイルの読み取りとファイルのコンテンツのストリームへの書き込みを行っています。唯一の違いは、ステータス行とファイル名です。コード別々にそれらの違いを引き出すことにより、より簡潔にしてみましょう &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;else&lt;/code&gt; ステータス行や変数にファイル名の値を代入します行を。次に、これらの変数を無条件にコードで使用して、ファイルを読み取り、応答を書き込みます。リスト20-9は、大きな &lt;code&gt;if&lt;/code&gt; ブロックと &lt;code&gt;else&lt;/code&gt; ブロックを置き換えた後のコードを示しています。</target>
        </trans-unit>
        <trans-unit id="1f16df13b8f4c863b823dc86f56453377891952c" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; function. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">現在、すべての出力を &lt;code&gt;println!&lt;/code&gt; を使用してターミナルに書き込んでいます！関数。ほとんどの端末は2種類の出力を提供します。一般情報の&lt;em&gt;標準出力&lt;/em&gt;（ &lt;code&gt;stdout&lt;/code&gt; ）とエラーメッセージの&lt;em&gt;標準エラー&lt;/em&gt;（ &lt;code&gt;stderr&lt;/code&gt; ）です。この違いにより、ユーザーはプログラムの正常な出力をファイルに送信することを選択できますが、エラーメッセージは画面に表示されます。</target>
        </trans-unit>
        <trans-unit id="3818ff95eb637709816bb6cd777c917a43bae444" translate="yes" xml:space="preserve">
          <source>At the time of this writing, an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; is under development. If you want to stick to a standard style across Rust projects, &lt;code&gt;rustfmt&lt;/code&gt; will format your code in a particular style. The Rust team plans to eventually include this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;. So depending on when you read this book, it might already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">この記事の執筆時点では、 &lt;code&gt;rustfmt&lt;/code&gt; と呼ばれる自動フォーマッターツールが開発中です。Rustプロジェクト全体で標準スタイルを使用したい場合、 &lt;code&gt;rustfmt&lt;/code&gt; は特定のスタイルでコードをフォーマットします。Rustチームは、このツールを &lt;code&gt;rustc&lt;/code&gt; のような標準のRustディストリビューションに含める予定です。したがって、この本をいつ読むかによっては、すでにコンピュータにインストールされている場合があります。詳細については、オンラインドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="1eca2e64861fbf60436be0df95a81ecf4dd4db51" translate="yes" xml:space="preserve">
          <source>At the time of this writing, two Rust editions are available: Rust 2015 and Rust 2018. This book is written using Rust 2018 edition idioms.</source>
          <target state="translated">この記事を書いている時点では、2つのRust版があります。Rust 2015版とRust 2018版です。本書はRust 2018版の熟語を使って書かれています。</target>
        </trans-unit>
        <trans-unit id="d0b83ac2e98214df1ca34576f6616d27aede53ff" translate="yes" xml:space="preserve">
          <source>At the time, we said not to worry about the inefficient &lt;code&gt;clone&lt;/code&gt; calls because we would remove them in the future. Well, that time is now!</source>
          <target state="translated">現時点では、非効率的な &lt;code&gt;clone&lt;/code&gt; 呼び出しについては将来削除する予定なので、心配しないでください。さて、その時は今です！</target>
        </trans-unit>
        <trans-unit id="bf023d508177d86413d3379134e446a32a09142c" translate="yes" xml:space="preserve">
          <source>At the time, we skipped over some details in this code. In Chapter 6 in &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;The &lt;code&gt;match&lt;/code&gt; Control Flow Operator&amp;rdquo;&lt;/a&gt; section, we discussed that &lt;code&gt;match&lt;/code&gt; arms must all return the same type. So, for example, the following code doesn&amp;rsquo;t work:</source>
          <target state="translated">現時点では、このコードの一部の詳細はスキップしました。第6章&lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;「 &lt;code&gt;match&lt;/code&gt; 制御フロー演算子」&lt;/a&gt;セクションで、 &lt;code&gt;match&lt;/code&gt; アームはすべて同じ型を返す必要があることを説明しました。したがって、たとえば、次のコードは機能しません。</target>
        </trans-unit>
        <trans-unit id="7ade322c88e63df6a4a8c865c0fa8c7d63812d90" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cargo build&lt;/code&gt; should complete successfully in both &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt;. Let&amp;rsquo;s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your &lt;em&gt;projects&lt;/em&gt; directory using &lt;code&gt;cargo new pancakes&lt;/code&gt;. We need to add &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; as dependencies in the &lt;code&gt;pancakes&lt;/code&gt; crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;. If you&amp;rsquo;re publishing your versions of &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, they would be regular dependencies; if not, you can specify them as &lt;code&gt;path&lt;/code&gt; dependencies as follows:</source>
          <target state="translated">この時点で、 &lt;code&gt;cargo build&lt;/code&gt; は &lt;code&gt;hello_macro&lt;/code&gt; と &lt;code&gt;hello_macro_derive&lt;/code&gt; の両方で正常に完了するはずです。これらのクレートをリスト19-30のコードに接続して、手続き型マクロの動作を見てみましょう！ &lt;code&gt;cargo new pancakes&lt;/code&gt; を使用して、&lt;em&gt;プロジェクト&lt;/em&gt;ディレクトリに新しいバイナリプロジェクトを作成します。 &lt;code&gt;pancakes&lt;/code&gt; クレートの&lt;em&gt;Cargo.tomlの&lt;/em&gt;依存関係として &lt;code&gt;hello_macro&lt;/code&gt; と &lt;code&gt;hello_macro_derive&lt;/code&gt; を追加する必要があります。あなたがあなたのバージョンの公開している場合 &lt;code&gt;hello_macro&lt;/code&gt; と &lt;code&gt;hello_macro_derive&lt;/code&gt; に&lt;a href=&quot;https://crates.io/&quot;&gt;crates.ioを&lt;/a&gt;、彼らは定期的な依存関係になります。そうでない場合は、次のように指定できます&lt;em&gt;&lt;/em&gt; &lt;code&gt;path&lt;/code&gt; 依存関係は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b945ef4a755c9f52a155f619e7f39f1e0b11da63" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;tic-tac-toe&lt;/code&gt;. With all of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; characters, it&amp;rsquo;s difficult to see what&amp;rsquo;s going on. For more complicated string combining, we can use the &lt;code&gt;format!&lt;/code&gt; macro:</source>
          <target state="translated">この時点で、 &lt;code&gt;s&lt;/code&gt; は &lt;code&gt;tic-tac-toe&lt;/code&gt; になります。 &lt;code&gt;+&lt;/code&gt; と &lt;code&gt;&quot;&lt;/code&gt; の文字がすべてあると、何が起こっているのかを確認するのが難しくなります。より複雑な文字列の組み合わせには、 &lt;code&gt;format!&lt;/code&gt; マクロを使用できます。</target>
        </trans-unit>
        <trans-unit id="bad906bb2d4d513518792ef63a17dbb628e284cd" translate="yes" xml:space="preserve">
          <source>At this point, the first part of the game is done: we&amp;rsquo;re getting input from the keyboard and then printing it.</source>
          <target state="translated">この時点で、ゲームの最初の部分が完了しました。キーボードから入力を取得し、それを印刷しています。</target>
        </trans-unit>
        <trans-unit id="645fa0bc97b2e92b8b41b6c72b5e6804e2731419" translate="yes" xml:space="preserve">
          <source>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we&amp;rsquo;ll build on top of this understanding by introducing the &lt;code&gt;String&lt;/code&gt; type.</source>
          <target state="translated">この時点で、スコープと変数が有効になるタイミングの関係は、他のプログラミング言語と同様です。次に、 &lt;code&gt;String&lt;/code&gt; 型を導入することにより、この理解に基づいて構築します。</target>
        </trans-unit>
        <trans-unit id="440b2812ba3e248d39262c445df6cb473f1a4cf8" translate="yes" xml:space="preserve">
          <source>At this point, we can build the workspace by running &lt;code&gt;cargo build&lt;/code&gt;. The files in your &lt;em&gt;add&lt;/em&gt; directory should look like this:</source>
          <target state="translated">この時点で、 &lt;code&gt;cargo build&lt;/code&gt; を実行してワークスペースを構築できます。&lt;em&gt;追加&lt;/em&gt;ディレクトリ内のファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="7be13e6f2293ee19341faecbce38cbce6581638c" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in [Chapter 13][ch13], where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">この時点で、同じ機能を維持するためにテストをパスし続けながら、検索機能の実装をリファクタリングする機会を検討できます。検索機能のコードはそれほど悪くはありませんが、反復子のいくつかの便利な機能を利用していません。[Chapter 13] [ch13]でこの例に戻り、イテレータを詳細に検討し、それを改善する方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="12d2e7392939d54c75dd7be38b3f433458f57624" translate="yes" xml:space="preserve">
          <source>At this point, when we call &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt;, deref coercion will take effect on the &lt;code&gt;&amp;amp;&lt;/code&gt; and the &lt;code&gt;Box&lt;/code&gt; so the &lt;code&gt;content&lt;/code&gt; method will ultimately be called on the type that implements the &lt;code&gt;State&lt;/code&gt; trait. That means we need to add &lt;code&gt;content&lt;/code&gt; to the &lt;code&gt;State&lt;/code&gt; trait definition, and that is where we&amp;rsquo;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</source>
          <target state="translated">この時点で、 &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; で &lt;code&gt;content&lt;/code&gt; を呼び出すと、deref強制が &lt;code&gt;&amp;amp;&lt;/code&gt; と &lt;code&gt;Box&lt;/code&gt; で有効になるため、 &lt;code&gt;content&lt;/code&gt; メソッドは最終的に &lt;code&gt;State&lt;/code&gt; トレイトを実装する型で呼び出されます。これは、 &lt;code&gt;State&lt;/code&gt; トレイト定義に &lt;code&gt;content&lt;/code&gt; を追加する必要があることを意味します。リスト17-18に示すように、ここに、どの状態にあるかに応じてどのコンテンツを返すかというロジックを配置します。</target>
        </trans-unit>
        <trans-unit id="41d03c60eead1f80179e902c1b4d9814280d6245" translate="yes" xml:space="preserve">
          <source>At this point, when we try to get a reference to the parent of &lt;code&gt;leaf&lt;/code&gt; by using the &lt;code&gt;upgrade&lt;/code&gt; method, we get a &lt;code&gt;None&lt;/code&gt; value. We see this in the output from the first &lt;code&gt;println!&lt;/code&gt; statement:</source>
          <target state="translated">この時点で、 &lt;code&gt;upgrade&lt;/code&gt; メソッドを使用して &lt;code&gt;leaf&lt;/code&gt; の親への参照を取得しようとすると、 &lt;code&gt;None&lt;/code&gt; 値が取得されます。これは、最初の &lt;code&gt;println!&lt;/code&gt; 出力で確認できます。ステートメント：</target>
        </trans-unit>
        <trans-unit id="3822c3ca41678f3e73f1513ee4103e0d10a48e3d" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.3.15&lt;/code&gt;.</source>
          <target state="translated">この時点で、&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルにも変更が加えられ、現在使用している &lt;code&gt;rand&lt;/code&gt; クレートのバージョンが &lt;code&gt;0.3.15&lt;/code&gt; であることがわかります。</target>
        </trans-unit>
        <trans-unit id="ace63d2aec4c0fa2eb5be485664adddc5d8c8911" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve seen several ways of using patterns, but patterns don&amp;rsquo;t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We&amp;rsquo;ll discuss these two concepts next.</source>
          <target state="translated">この時点で、パターンを使用するいくつかの方法を見てきましたが、パターンは、使用できるすべての場所で同じように機能するわけではありません。一部の場所では、パターンは反駁できないものでなければなりません。他の状況では、彼らは反駁することができます。次に、これらの2つの概念について説明します。</target>
        </trans-unit>
        <trans-unit id="e19eb30ab901969b293ab5f50d80d0816b9dd309" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve successfully built the guessing game. Congratulations!</source>
          <target state="translated">この時点で、推測ゲームの構築に成功しました。おめでとう！</target>
        </trans-unit>
        <trans-unit id="632731832807bd949f8afaff185b846c11bff1a6" translate="yes" xml:space="preserve">
          <source>Atomic Reference Counting with &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; による原子参照カウント</target>
        </trans-unit>
        <trans-unit id="81578fbf1ea44596108fd645f27e6431bf82318a" translate="yes" xml:space="preserve">
          <source>Atomic memory orderings</source>
          <target state="translated">原子記憶の順序付け</target>
        </trans-unit>
        <trans-unit id="7d5338021e809e34d20a6b06646a458b5152b9dc" translate="yes" xml:space="preserve">
          <source>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement &lt;code&gt;AtomicI8&lt;/code&gt;. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</source>
          <target state="translated">アトミック操作は、より大きなサイズのアトミックを使用して命令層で実装できます。たとえば、一部のプラットフォームでは、4バイトのアトミック命令を使用して &lt;code&gt;AtomicI8&lt;/code&gt; を実装しています。このエミュレーションはコードの正確さに影響を与えるべきではないことに注意してください。これは注意すべきことです。</target>
        </trans-unit>
        <trans-unit id="8e24008909c0fc6f23ca4f4f874bb53512815caa" translate="yes" xml:space="preserve">
          <source>Atomic operations with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics can also synchronize with a fence.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;セマンティクスによるアトミック操作もフェンスと同期できます。</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">原子型</target>
        </trans-unit>
        <trans-unit id="bd540eaa28be66ef79bdb0e6dc9e7f21a135c077" translate="yes" xml:space="preserve">
          <source>Atomic types may be stored in static variables, initialized using the constant initializers like &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt;&lt;code&gt;AtomicBool::new&lt;/code&gt;&lt;/a&gt;. Atomic statics are often used for lazy global initialization.</source>
          <target state="translated">原子型は静的変数に格納され、&lt;a href=&quot;struct.atomicbool#method.new&quot;&gt; &lt;code&gt;AtomicBool::new&lt;/code&gt; &lt;/a&gt;ような定数初期化子を使用して初期化されます。原子統計は、遅延グローバル初期化によく使用されます。</target>
        </trans-unit>
        <trans-unit id="af8191cce263e5511ffa70b9167ccc44038ee579" translate="yes" xml:space="preserve">
          <source>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</source>
          <target state="translated">アトミック型は、スレッド間のプリミティブな共有メモリ通信を提供し、他の並行型の構成要素となります。</target>
        </trans-unit>
        <trans-unit id="bdcc7b682e49710ce243d11d666d0605dd24412a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">原子変数はスレッド間で安全に共有できます（それらは&lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;を実装します）が、それ自体は共有のメカニズムを提供せず、錆の&lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;スレッドモデル&lt;/a&gt;に従います。アトミック変数を共有する最も一般的な方法は、それを&lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;（アトミック参照でカウントされる共有ポインター）に配置することです。</target>
        </trans-unit>
        <trans-unit id="6674d00db7a2e69964175c1325e3eccae698e4d3" translate="yes" xml:space="preserve">
          <source>AtomicBool</source>
          <target state="translated">AtomicBool</target>
        </trans-unit>
        <trans-unit id="c3f581e842f52532b7b151cdbc4ce7233b954e8c" translate="yes" xml:space="preserve">
          <source>AtomicI16</source>
          <target state="translated">AtomicI16</target>
        </trans-unit>
        <trans-unit id="29b774c369d481cc7134a7a13427afa21b7fc9cd" translate="yes" xml:space="preserve">
          <source>AtomicI32</source>
          <target state="translated">AtomicI32</target>
        </trans-unit>
        <trans-unit id="d734b8bd0031516fdc53fb6831e8dec9b067b165" translate="yes" xml:space="preserve">
          <source>AtomicI64</source>
          <target state="translated">AtomicI64</target>
        </trans-unit>
        <trans-unit id="e94562e900680db9e18fda42ce322ce7a5e558bf" translate="yes" xml:space="preserve">
          <source>AtomicI8</source>
          <target state="translated">AtomicI8</target>
        </trans-unit>
        <trans-unit id="c2cc2ca63393294d4014028c732f15eca926e7a2" translate="yes" xml:space="preserve">
          <source>AtomicIsize</source>
          <target state="translated">AtomicIsize</target>
        </trans-unit>
        <trans-unit id="7bc45caa3c8c7a6bbad87dd4b67403e414361ce1" translate="yes" xml:space="preserve">
          <source>AtomicPtr</source>
          <target state="translated">AtomicPtr</target>
        </trans-unit>
        <trans-unit id="17a70c0c14e8b2c47d91d2253122896320428148" translate="yes" xml:space="preserve">
          <source>AtomicU16</source>
          <target state="translated">AtomicU16</target>
        </trans-unit>
        <trans-unit id="8840103173e424948e002b5ffec50c44e404d250" translate="yes" xml:space="preserve">
          <source>AtomicU32</source>
          <target state="translated">AtomicU32</target>
        </trans-unit>
        <trans-unit id="32ac2d92ec899ed90a2638fc480a4297cef99b45" translate="yes" xml:space="preserve">
          <source>AtomicU64</source>
          <target state="translated">AtomicU64</target>
        </trans-unit>
        <trans-unit id="a496370705e1f84302673bc11932128de26a2fea" translate="yes" xml:space="preserve">
          <source>AtomicU8</source>
          <target state="translated">AtomicU8</target>
        </trans-unit>
        <trans-unit id="9d9469a55330492f15842defa35b0f1ef07cac12" translate="yes" xml:space="preserve">
          <source>AtomicUsize</source>
          <target state="translated">AtomicUsize</target>
        </trans-unit>
        <trans-unit id="48c5fb201c75414dd3666a318d954dd873099b2d" translate="yes" xml:space="preserve">
          <source>Atomically makes the handle's token available if it is not already.</source>
          <target state="translated">ハンドルのトークンがまだ存在しない場合は、そのトークンを利用可能な状態にします。</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="fe4c2e56ace1dd5cd16118bb6ad5e5256c61db83" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; を具象型にダウンキャストしてみます。</target>
        </trans-unit>
        <trans-unit id="92df3d44a91e7d67c064d6d725fec8b2e940cc64" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; を具象型にダウンキャストしてみます。</target>
        </trans-unit>
        <trans-unit id="886d23c3fa7b51635fa7bbdd282f2babcd6cb45c" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the box to a concrete type.</source>
          <target state="translated">箱をコンクリートタイプにダウンキャストしてみます。</target>
        </trans-unit>
        <trans-unit id="175cf296f94bed8278b4e811c5245f622f67f97c" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.</source>
          <target state="translated">値がまだ利用可能でない場合、現在のタスクをウェイクアップ用に登録して、未来を最終的な値に解決しようとします。</target>
        </trans-unit>
        <trans-unit id="0b1794f780a4845e82f1aa618849777a9e5b6e42" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将来を最終的な値に解決することを試み、値がまだ利用できない場合は、現在のタスクをウェイクアップに登録します。&lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55136df45140cab2915451715291fdde1ced9b25" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将来を最終的な値に解決することを試み、値がまだ利用できない場合は、現在のタスクをウェイクアップに登録します。&lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="856e8b63203e04805b09dd95b9d3481ff3097c22" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an item whereas an extern crate with this name has already been imported.</source>
          <target state="translated">この名前の外部クレートが既にインポートされているアイテムをインポートしようとしました。</target>
        </trans-unit>
        <trans-unit id="5fc738aa7f6254311ae3614b150f4fe1cec8fe27" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</source>
          <target state="translated">重要でない値をインポートしようとしました。これは、形質からメソッドをインポートしようとしたときに起こる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2c61d256e7903ca5ede61e01fd8467962bbb349b" translate="yes" xml:space="preserve">
          <source>Attempted to access a field on a primitive type.</source>
          <target state="translated">プリミティブ型のフィールドにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="a54332e7df630f85a467d7ec89246d77c007b643" translate="yes" xml:space="preserve">
          <source>Attempted to access a method like a field.</source>
          <target state="translated">フィールドのようなメソッドにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="48f28400d9c83d5af115ff62dc11ba5e26ca8457" translate="yes" xml:space="preserve">
          <source>Attempted to access a non-existent field in a struct.</source>
          <target state="translated">構造体に存在しないフィールドにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="03b41486da885815831596a9c99e4264efdf5d06" translate="yes" xml:space="preserve">
          <source>Attempted to access a private field on a struct.</source>
          <target state="translated">構造体のプライベート・フィールドにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="a1ad3c1a31bd1ae534677401ea798535b99a38e5" translate="yes" xml:space="preserve">
          <source>Attempted to call something which isn't a function nor a method.</source>
          <target state="translated">関数でもメソッドでもないものを呼ぼうとしました。</target>
        </trans-unit>
        <trans-unit id="eef4156ee856f3204829c854633733e0594d2319" translate="yes" xml:space="preserve">
          <source>Attempted to dereference a variable which cannot be dereferenced.</source>
          <target state="translated">参照元にできない変数を参照元に戻そうとしました。</target>
        </trans-unit>
        <trans-unit id="1372db0ea32a319cb23e92d2e2d51b6cd2d1a4fb" translate="yes" xml:space="preserve">
          <source>Attempted to pass an invalid type of variable into a variadic function.</source>
          <target state="translated">無効な型の変数を可変関数に渡そうとしました。</target>
        </trans-unit>
        <trans-unit id="7adfef6b18f86865559fc727494e616e0b3f7f80" translate="yes" xml:space="preserve">
          <source>Attempting to compile now gives us the following output:</source>
          <target state="translated">コンパイルしようとすると、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="e83036683d0914f18e7de7ebbb8a14c9db8b6c5c" translate="yes" xml:space="preserve">
          <source>Attempting to compile this code results in this type error:</source>
          <target state="translated">このコードをコンパイルしようとすると、このタイプのエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="71aec9a6c07f86af18ab65ed514253e4a11e1117" translate="yes" xml:space="preserve">
          <source>Attempting to create a &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; iterator from an improperly formatted socket address &lt;code&gt;&amp;amp;str&lt;/code&gt; (missing the port):</source>
          <target state="translated">不適切な形式のソケットアドレス &lt;code&gt;&amp;amp;str&lt;/code&gt; （ポートがない）から&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;イテレータを作成しようとしています：</target>
        </trans-unit>
        <trans-unit id="baf8e0e513c1e7d75d1c56986d1f69437e36903e" translate="yes" xml:space="preserve">
          <source>Attempting to create a trait object for a non object-safe trait will trigger this error.</source>
          <target state="translated">オブジェクトセーフでない形質に対して形質オブジェクトを作成しようとすると、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="fcaf285fe223ac76c6b6f3a248ca791f9480d826" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this lock.</source>
          <target state="translated">このロックを取得しようとします。</target>
        </trans-unit>
        <trans-unit id="ed9809bcb2ab4f39482ae3c8ecc3990c35b19e02" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this rwlock with shared read access.</source>
          <target state="translated">共有読み取りアクセスでこの rwlock を取得しようとします。</target>
        </trans-unit>
        <trans-unit id="aa06f6d37e15f994598953d5d55e85873c353cbb" translate="yes" xml:space="preserve">
          <source>Attempts to collect the exit status of the child if it has already exited.</source>
          <target state="translated">子プロセスが既に終了している場合に、その子プロセスの終了状況を収集しようとします。</target>
        </trans-unit>
        <trans-unit id="2067ade47b4e19fcd748b5622bcd5a578000fa70" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; に適合するように、 &lt;code&gt;ptr&lt;/code&gt; によって参照される割り当てを拡張しようとします。</target>
        </trans-unit>
        <trans-unit id="1f0524b8bf45261cb2e5192b808b5a4a85102e03" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; に適合するように、 &lt;code&gt;ptr&lt;/code&gt; によって参照される割り当てを拡張しようとします。&lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14aa482507a26cdd1d3724ec04b0d14909b4ce76" translate="yes" xml:space="preserve">
          <source>Attempts to lock this rwlock with exclusive write access.</source>
          <target state="translated">この rwlock を排他的な書き込みアクセスでロックしようとします。</target>
        </trans-unit>
        <trans-unit id="3e149a02e4c5943a78110a9fe37e7dfdc1377a23" translate="yes" xml:space="preserve">
          <source>Attempts to open a file in read-only mode.</source>
          <target state="translated">読み取り専用モードでファイルを開こうとします。</target>
        </trans-unit>
        <trans-unit id="ce00391cd1170f4f9f1ed2dc7adb3e45ca14e46a" translate="yes" xml:space="preserve">
          <source>Attempts to return a pending value on this receiver without blocking.</source>
          <target state="translated">ブロッキングせずに、この受信機で保留中の値を返そうとする。</target>
        </trans-unit>
        <trans-unit id="88500c10aaa3c7978ed8857be5643440673d4380" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel without blocking.</source>
          <target state="translated">ブロックせずにこのチャンネルに値を送信しようとします。</target>
        </trans-unit>
        <trans-unit id="44fed3b4d1c2db46234c4d30a1056c0ccd124c87" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel, returning it back if it could not be sent.</source>
          <target state="translated">このチャネルに値を送信しようとし、送信できなかった場合はそれを返します。</target>
        </trans-unit>
        <trans-unit id="6da3e262b2372fb386666634b5d39f9d3f7bb80a" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; に適合するように、 &lt;code&gt;ptr&lt;/code&gt; によって参照される割り当てを縮小しようとします。</target>
        </trans-unit>
        <trans-unit id="d9dd72c543bd49d83f78f0fdf1367b07147238f9" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; に適合するように、 &lt;code&gt;ptr&lt;/code&gt; によって参照される割り当てを縮小しようとします。&lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d431ee47732f5fda5d822308d953fb6c4ab546af" translate="yes" xml:space="preserve">
          <source>Attempts to sync all OS-internal metadata to disk.</source>
          <target state="translated">OS内部のすべてのメタデータをディスクに同期しようとします。</target>
        </trans-unit>
        <trans-unit id="e1a28bf0ca8943d3102fb17a5f930dbd42c32e93" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタを&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;にアップグレードし、成功した場合は値の有効期間を延長しようとします。</target>
        </trans-unit>
        <trans-unit id="c10f653d6058260dd8df6597f6fc625f0e90a7a2" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインターを&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;にアップグレードし、成功した場合は値の有効期間を延長しようとします。</target>
        </trans-unit>
        <trans-unit id="4ed9981b4c97d4946f7cc66f3d69625251a285c0" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if &lt;code&gt;deadline&lt;/code&gt; is reached.</source>
          <target state="translated">このレシーバーの値を待機しようとし、対応するチャネルがハングアップした場合、または &lt;code&gt;deadline&lt;/code&gt; に達した場合にエラーを返します。</target>
        </trans-unit>
        <trans-unit id="eea7708f089d17a724b4fe150c8a5b22b7b7cd15" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">このレシーバーの値を待機しようとし、対応するチャネルがハングアップした場合、または &lt;code&gt;timeout&lt;/code&gt; を超えて待機した場合にエラーを返します。</target>
        </trans-unit>
        <trans-unit id="c5624ed9b3f4c32e9214ed479d11bee18fe54f2a" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.</source>
          <target state="translated">この受信機で値の待ち受けを試み、対応するチャンネルがハングアップした場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="66681ba198baa628940b6e0e8d1d21d555ae1a8d" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer.</source>
          <target state="translated">バッファ全体をこのライタに書き込もうとします。</target>
        </trans-unit>
        <trans-unit id="50c44c33216c75388385c7158cbb2db3b18cd276" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バッファ全体をこのライターに書き込もうとします。&lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb65a661c9940f60efcdfd42e570120d00134516" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バッファ全体をこのライターに書き込もうとします。&lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7537ca8f100350d628ddd2455b7d2b9261e91786" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バッファ全体をこのライターに書き込もうとします。&lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a079954569cfca76bb04671c6eef0de6f2845b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バッファ全体をこのライターに書き込もうとします。&lt;a href=&quot;trait.write#method.write_all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4550331cd75411aa797d05589ea44d59948931" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset.</source>
          <target state="translated">指定したオフセットから始まるバッファ全体の書き込みを試みます。</target>
        </trans-unit>
        <trans-unit id="bd08d9b38e39a23845ecac7733a7135e68b5844b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">指定されたオフセットから開始してバッファー全体を書き込もうとします。&lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63578c033690b22f88448dc9020fc65119c91cf5" translate="yes" xml:space="preserve">
          <source>Attribute contains same meta item more than once.</source>
          <target state="translated">属性に同じメタ項目が複数回含まれています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
