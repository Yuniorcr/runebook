<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="47babee6888e0103956b5d6fb324645bab23db7a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::gt</source>
          <target state="translated">NonZeroI8::gt</target>
        </trans-unit>
        <trans-unit id="93874d53399c77a41bf9531800d5f0fa474a4cda" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash</source>
          <target state="translated">NonZeroI8::hash</target>
        </trans-unit>
        <trans-unit id="29013108ddf40e18600983e97e9034bd5257369c" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash_slice</source>
          <target state="translated">NonZeroI8::hash_slice</target>
        </trans-unit>
        <trans-unit id="037dc348d54512f4eac4bc525c27d1f766b25a1a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::into</source>
          <target state="translated">NonZeroI8::into</target>
        </trans-unit>
        <trans-unit id="0515501fa1d050e6a321477214d1c4d9c56b0a91" translate="yes" xml:space="preserve">
          <source>NonZeroI8::le</source>
          <target state="translated">NonZeroI8::le</target>
        </trans-unit>
        <trans-unit id="7cad17cf5fce8924f80e26fc0cc84eaa9e833005" translate="yes" xml:space="preserve">
          <source>NonZeroI8::lt</source>
          <target state="translated">NonZeroI8::lt</target>
        </trans-unit>
        <trans-unit id="90330e65e0da907071c3c4c3d6a116bb84c932c4" translate="yes" xml:space="preserve">
          <source>NonZeroI8::max</source>
          <target state="translated">NonZeroI8::max</target>
        </trans-unit>
        <trans-unit id="e20ad8db00b5d962f11dd424a9bc3a6c8e774305" translate="yes" xml:space="preserve">
          <source>NonZeroI8::min</source>
          <target state="translated">NonZeroI8::min</target>
        </trans-unit>
        <trans-unit id="73e8e9fd3f901d81ee2336d6e8ea9cf220fba88b" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ne</source>
          <target state="translated">NonZeroI8::ne</target>
        </trans-unit>
        <trans-unit id="af45d6c29f79e266eb5d7ab85309f358f8208a69" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new</source>
          <target state="translated">NonZeroI8::new</target>
        </trans-unit>
        <trans-unit id="81a02f698c1e4f2332bb4e3e7c3edf4ff27a1c50" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new_unchecked</source>
          <target state="translated">NonZeroI8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2686fbb343af79a855c02e59fa60522e101b42ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::partial_cmp</source>
          <target state="translated">NonZeroI8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cd75ff5beac899fb4e419778f9513cbe1ad0b2a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_owned</source>
          <target state="translated">NonZeroI8::to_owned</target>
        </trans-unit>
        <trans-unit id="2b4fc6493819df1f404760f50612536b8bbfc7bd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_string</source>
          <target state="translated">NonZeroI8::to_string</target>
        </trans-unit>
        <trans-unit id="44995331a911be947ba3e877e13ce380ef4d9378" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_from</source>
          <target state="translated">NonZeroI8::try_from</target>
        </trans-unit>
        <trans-unit id="c6edd8a860f42d4c84935088ebf51ade98d95115" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_into</source>
          <target state="translated">NonZeroI8::try_into</target>
        </trans-unit>
        <trans-unit id="694926ab4cd6b261f66a7c4ea43bd5a538ca07a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::type_id</source>
          <target state="translated">NonZeroI8::type_id</target>
        </trans-unit>
        <trans-unit id="39eb2a5ae94e10b055d94f86300fae4bd3a2c861" translate="yes" xml:space="preserve">
          <source>NonZeroIsize</source>
          <target state="translated">NonZeroIsize</target>
        </trans-unit>
        <trans-unit id="4075b4a43affee6576128660a15087ef7d46f01c" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow</source>
          <target state="translated">NonZeroIsize::borrow</target>
        </trans-unit>
        <trans-unit id="ec545959e67fee5329d2293a10abf7982b0e5d27" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow_mut</source>
          <target state="translated">NonZeroIsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a61bacb1affb3b3a864b9054448b3c878abd8923" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clamp</source>
          <target state="translated">NonZeroIsize::clamp</target>
        </trans-unit>
        <trans-unit id="191e1ee11e03e2904eddf99c3224190191357bac" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone</source>
          <target state="translated">NonZeroIsize::clone</target>
        </trans-unit>
        <trans-unit id="5dc48b7609417f7ce614e10e63d58e556492bcf9" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_from</source>
          <target state="translated">NonZeroIsize::clone_from</target>
        </trans-unit>
        <trans-unit id="d38a3dead1294ded03ccb72c57ad049cf009cb60" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_into</source>
          <target state="translated">NonZeroIsize::clone_into</target>
        </trans-unit>
        <trans-unit id="ca7ed6d7cb5393e8a7ba6e95fd43e5b4d5bb7809" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::cmp</source>
          <target state="translated">NonZeroIsize::cmp</target>
        </trans-unit>
        <trans-unit id="2fe615f032ce982861bba71b45a232958641a0cd" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::eq</source>
          <target state="translated">NonZeroIsize::eq</target>
        </trans-unit>
        <trans-unit id="d9ec29b8a341c99081d89a3bd91dc15ff5f6812f" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::fmt</source>
          <target state="translated">NonZeroIsize::fmt</target>
        </trans-unit>
        <trans-unit id="817a465d80d81fe1b61c88aca0859799182b0ced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from</source>
          <target state="translated">NonZeroIsize::from</target>
        </trans-unit>
        <trans-unit id="d2cfcb21d317b6fab455622f5d899c19b4caab20" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from_str</source>
          <target state="translated">NonZeroIsize::from_str</target>
        </trans-unit>
        <trans-unit id="955b4cb4cf6dd3e94857ccb753d3fe4d1fb111bb" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ge</source>
          <target state="translated">NonZeroIsize::ge</target>
        </trans-unit>
        <trans-unit id="94dfb4eb2acf5d4199e2494aa3141f234b7ec552" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::get</source>
          <target state="translated">NonZeroIsize::get</target>
        </trans-unit>
        <trans-unit id="ee800c8db94226df90984d0310a1c3b583e90f13" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::gt</source>
          <target state="translated">NonZeroIsize::gt</target>
        </trans-unit>
        <trans-unit id="36fffe56efef4816a331398e4562a265e92bfb10" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash</source>
          <target state="translated">NonZeroIsize::hash</target>
        </trans-unit>
        <trans-unit id="cf00fd8ca399a52d34e9a8feac17a1b26fe0bcee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash_slice</source>
          <target state="translated">NonZeroIsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="882f34faf603e4c98fc372332977f902076ab5a0" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::into</source>
          <target state="translated">NonZeroIsize::into</target>
        </trans-unit>
        <trans-unit id="0d24785358cfb27caebb3a32bf5c7678cb2e30ee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::le</source>
          <target state="translated">NonZeroIsize::le</target>
        </trans-unit>
        <trans-unit id="f8f7c7c85f4aab3786722bfd2d7aefb8b686bd6e" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::lt</source>
          <target state="translated">NonZeroIsize::lt</target>
        </trans-unit>
        <trans-unit id="19c94dc6fa11f95d35e7c7c4f115e86acb80fc00" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::max</source>
          <target state="translated">NonZeroIsize::max</target>
        </trans-unit>
        <trans-unit id="9bf079159116a040501bb2bee238b98de390d6b7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::min</source>
          <target state="translated">NonZeroIsize::min</target>
        </trans-unit>
        <trans-unit id="78420580500ef47e7d9c63e510686240542d08c3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ne</source>
          <target state="translated">NonZeroIsize::ne</target>
        </trans-unit>
        <trans-unit id="9b5caea647537e28a582a1b68216f403a92bdea7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new</source>
          <target state="translated">NonZeroIsize::new</target>
        </trans-unit>
        <trans-unit id="f92bdba42fa66b6909fc4ad5b38b7d0a8808cced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new_unchecked</source>
          <target state="translated">NonZeroIsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2b55347d5d71b451caf945bb5b1b4cacc28afc98" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::partial_cmp</source>
          <target state="translated">NonZeroIsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="717d7fcf3dd2db66a5b657bdcd5df3b72e3ca14d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_owned</source>
          <target state="translated">NonZeroIsize::to_owned</target>
        </trans-unit>
        <trans-unit id="1a88ee49d5b8865561ef951ccbe17add31975cf3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_string</source>
          <target state="translated">NonZeroIsize::to_string</target>
        </trans-unit>
        <trans-unit id="aeed335ba630cd0f02972d3792f625986e0da579" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_from</source>
          <target state="translated">NonZeroIsize::try_from</target>
        </trans-unit>
        <trans-unit id="3b703381eaac2b4d7c2b865c4b56d5e07385cb0d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_into</source>
          <target state="translated">NonZeroIsize::try_into</target>
        </trans-unit>
        <trans-unit id="cfd236d892fc65a9056aca980b3c2a0c1b08fc90" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::type_id</source>
          <target state="translated">NonZeroIsize::type_id</target>
        </trans-unit>
        <trans-unit id="0044d6a252510995bf93ecb1dd199ad6280b0298" translate="yes" xml:space="preserve">
          <source>NonZeroU128</source>
          <target state="translated">NonZeroU128</target>
        </trans-unit>
        <trans-unit id="d33cdcef0f6bce3ae4d1c100820f29fb8e8de6be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow</source>
          <target state="translated">NonZeroU128::borrow</target>
        </trans-unit>
        <trans-unit id="3f647fdd084e34cb19c62fa95a5df0d0b02f7830" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow_mut</source>
          <target state="translated">NonZeroU128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6dd84c262632c4ce99cd20fd6d4cce46ad766f6c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clamp</source>
          <target state="translated">NonZeroU128::clamp</target>
        </trans-unit>
        <trans-unit id="54a6620faedc0c0d7296506b17b24167c833f343" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone</source>
          <target state="translated">NonZeroU128::clone</target>
        </trans-unit>
        <trans-unit id="361f908936891415e62dbb126d73b91cdd535809" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_from</source>
          <target state="translated">NonZeroU128::clone_from</target>
        </trans-unit>
        <trans-unit id="95b289a7b3408284866f730f49c7cefc4940ea32" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_into</source>
          <target state="translated">NonZeroU128::clone_into</target>
        </trans-unit>
        <trans-unit id="939d6fc64a58c3aad5a29fd29b5cb1ddf18ffa03" translate="yes" xml:space="preserve">
          <source>NonZeroU128::cmp</source>
          <target state="translated">NonZeroU128::cmp</target>
        </trans-unit>
        <trans-unit id="e3d76ecf73e9d2bddfdc690dd3583c65cb4e8c6b" translate="yes" xml:space="preserve">
          <source>NonZeroU128::eq</source>
          <target state="translated">NonZeroU128::eq</target>
        </trans-unit>
        <trans-unit id="cf1f402d3b803071978d5c02ef20145ad5e75f93" translate="yes" xml:space="preserve">
          <source>NonZeroU128::fmt</source>
          <target state="translated">NonZeroU128::fmt</target>
        </trans-unit>
        <trans-unit id="1cb47e3de5cf28c31000e229db50c161ce7a7c28" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from</source>
          <target state="translated">NonZeroU128::from</target>
        </trans-unit>
        <trans-unit id="04a3a610d61c54fe04e5c4fb7dc3736c9608563d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from_str</source>
          <target state="translated">NonZeroU128::from_str</target>
        </trans-unit>
        <trans-unit id="b8dacf31071a7dcf6913c1d5f60e1467a0c7b52c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ge</source>
          <target state="translated">NonZeroU128::ge</target>
        </trans-unit>
        <trans-unit id="bc070e9b4c11812f956c2c3942dbeeb60e1907d7" translate="yes" xml:space="preserve">
          <source>NonZeroU128::get</source>
          <target state="translated">NonZeroU128::get</target>
        </trans-unit>
        <trans-unit id="bf61b92a5979f684a74d24d35e7223a980f74915" translate="yes" xml:space="preserve">
          <source>NonZeroU128::gt</source>
          <target state="translated">NonZeroU128::gt</target>
        </trans-unit>
        <trans-unit id="66888226d70c2e49258374545510affc0bdd95ec" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash</source>
          <target state="translated">NonZeroU128::hash</target>
        </trans-unit>
        <trans-unit id="11f423a193c168fdc5ff7611f300ac57dfd70171" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash_slice</source>
          <target state="translated">NonZeroU128::hash_slice</target>
        </trans-unit>
        <trans-unit id="b29bc2e8eba682c97ef473e0bd889b9b87439b43" translate="yes" xml:space="preserve">
          <source>NonZeroU128::into</source>
          <target state="translated">NonZeroU128::into</target>
        </trans-unit>
        <trans-unit id="dd97daae9ce7a0b9ab85c6cf73bd03826d2dacad" translate="yes" xml:space="preserve">
          <source>NonZeroU128::le</source>
          <target state="translated">NonZeroU128::le</target>
        </trans-unit>
        <trans-unit id="4c5ffedb155e243e75eb535bd12d40831e3c5755" translate="yes" xml:space="preserve">
          <source>NonZeroU128::lt</source>
          <target state="translated">NonZeroU128::lt</target>
        </trans-unit>
        <trans-unit id="cefe09ff65521779b9f59c83b8f0425d577bc41f" translate="yes" xml:space="preserve">
          <source>NonZeroU128::max</source>
          <target state="translated">NonZeroU128::max</target>
        </trans-unit>
        <trans-unit id="66bc9dddfd54e67077a2f3098f5b87831d049d31" translate="yes" xml:space="preserve">
          <source>NonZeroU128::min</source>
          <target state="translated">NonZeroU128::min</target>
        </trans-unit>
        <trans-unit id="1af4ac1a95b7f36c718aa21d748fb13ce2e824ee" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ne</source>
          <target state="translated">NonZeroU128::ne</target>
        </trans-unit>
        <trans-unit id="774e6ffc8823e6223f1ffa87fab102416ea1637d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new</source>
          <target state="translated">NonZeroU128::new</target>
        </trans-unit>
        <trans-unit id="80588590ec2ef5a265edf292dba20ca05ed9ff1d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new_unchecked</source>
          <target state="translated">NonZeroU128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="4f33be7cbf8c678c8187f371f4f5d027a69d0647" translate="yes" xml:space="preserve">
          <source>NonZeroU128::partial_cmp</source>
          <target state="translated">NonZeroU128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="3dea4243dcea470ba4d4f180f81f6eecca14e04e" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_owned</source>
          <target state="translated">NonZeroU128::to_owned</target>
        </trans-unit>
        <trans-unit id="24acde94eff6342ff2fba2e9d267a2fdb25acd94" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_string</source>
          <target state="translated">NonZeroU128::to_string</target>
        </trans-unit>
        <trans-unit id="b21ef37ea8ca3269318a2c852c86163df43432be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_from</source>
          <target state="translated">NonZeroU128::try_from</target>
        </trans-unit>
        <trans-unit id="6c546400526ea1ed6ea89201862535a6549699f1" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_into</source>
          <target state="translated">NonZeroU128::try_into</target>
        </trans-unit>
        <trans-unit id="5b4b31430f7adfc4f26872a558ae35d43d7da9ff" translate="yes" xml:space="preserve">
          <source>NonZeroU128::type_id</source>
          <target state="translated">NonZeroU128::type_id</target>
        </trans-unit>
        <trans-unit id="70d9b595abe5e850f484266bc477e3d70b58c790" translate="yes" xml:space="preserve">
          <source>NonZeroU16</source>
          <target state="translated">NonZeroU16</target>
        </trans-unit>
        <trans-unit id="a2e830bdc612e459ecbf94a5d900db9adf22d552" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow</source>
          <target state="translated">NonZeroU16::borrow</target>
        </trans-unit>
        <trans-unit id="84a81450427618c9efd99c6046bdcfcb15a8f7bb" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow_mut</source>
          <target state="translated">NonZeroU16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4eb94e8343ecdde314f21ae1472878c2e5be4f43" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clamp</source>
          <target state="translated">NonZeroU16::clamp</target>
        </trans-unit>
        <trans-unit id="4f9cad5198a59312536b10433f5195716121d4f5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone</source>
          <target state="translated">NonZeroU16::clone</target>
        </trans-unit>
        <trans-unit id="d8ef4ec4d957a02aaa882335c6f3d0a67035a3c7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_from</source>
          <target state="translated">NonZeroU16::clone_from</target>
        </trans-unit>
        <trans-unit id="3808aec2130dc48a153e5a520294b26744b3e702" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_into</source>
          <target state="translated">NonZeroU16::clone_into</target>
        </trans-unit>
        <trans-unit id="9d0062487248621e89b96fe5bf643abe821bb17a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::cmp</source>
          <target state="translated">NonZeroU16::cmp</target>
        </trans-unit>
        <trans-unit id="41a2d5bd4797b2d1eb6b20161786347a9f0dd370" translate="yes" xml:space="preserve">
          <source>NonZeroU16::eq</source>
          <target state="translated">NonZeroU16::eq</target>
        </trans-unit>
        <trans-unit id="4e58083d69fb5df5404d73e024559cb858948a6f" translate="yes" xml:space="preserve">
          <source>NonZeroU16::fmt</source>
          <target state="translated">NonZeroU16::fmt</target>
        </trans-unit>
        <trans-unit id="f40fdab8202fbcb58f6fbdbc2b16303b0de2f1ee" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from</source>
          <target state="translated">NonZeroU16::from</target>
        </trans-unit>
        <trans-unit id="97bb49319fe5098129502422bda785cd16c5234a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from_str</source>
          <target state="translated">NonZeroU16::from_str</target>
        </trans-unit>
        <trans-unit id="12e676e778fbbdbfffb5d2b98fabd5a4306c10e5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ge</source>
          <target state="translated">NonZeroU16::ge</target>
        </trans-unit>
        <trans-unit id="1313691aadbfef04a5d2c70132da7c9072b9834a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::get</source>
          <target state="translated">NonZeroU16::get</target>
        </trans-unit>
        <trans-unit id="e4a7103dfe5dfdaccf5405172a6bfb6564cbb39e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::gt</source>
          <target state="translated">NonZeroU16::gt</target>
        </trans-unit>
        <trans-unit id="4843257888dce95e20cf1eaff515263fe997bf35" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash</source>
          <target state="translated">NonZeroU16::hash</target>
        </trans-unit>
        <trans-unit id="b9c900dd5aa52134650740a33c407b05339dc782" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash_slice</source>
          <target state="translated">NonZeroU16::hash_slice</target>
        </trans-unit>
        <trans-unit id="83aabdee7d487ec9cb728178e573f802394226b4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::into</source>
          <target state="translated">NonZeroU16::into</target>
        </trans-unit>
        <trans-unit id="7970d0eb118d83ab0b72df82542034727ba2a453" translate="yes" xml:space="preserve">
          <source>NonZeroU16::le</source>
          <target state="translated">NonZeroU16::le</target>
        </trans-unit>
        <trans-unit id="2e5e858925d50659f9b1b6d9aae3740085d6d25b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::lt</source>
          <target state="translated">NonZeroU16::lt</target>
        </trans-unit>
        <trans-unit id="5d3b1652b96c8f150360a583d2605f47b1963560" translate="yes" xml:space="preserve">
          <source>NonZeroU16::max</source>
          <target state="translated">NonZeroU16::max</target>
        </trans-unit>
        <trans-unit id="1e4034b09df30190832a52072bcf8af6041bbf4d" translate="yes" xml:space="preserve">
          <source>NonZeroU16::min</source>
          <target state="translated">NonZeroU16::min</target>
        </trans-unit>
        <trans-unit id="815e8d53bff937d8e0463d3319f42f6179bc0760" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ne</source>
          <target state="translated">NonZeroU16::ne</target>
        </trans-unit>
        <trans-unit id="23ac83515dc8fab41df4280bc33fe4bc456b4ff2" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new</source>
          <target state="translated">NonZeroU16::new</target>
        </trans-unit>
        <trans-unit id="bb140336d169ad21d933a68a3d8746b26d1b8b72" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new_unchecked</source>
          <target state="translated">NonZeroU16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d8dd3cac934926e6de446e12a7408c3a4890b68e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::partial_cmp</source>
          <target state="translated">NonZeroU16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="93b1877253643b0a75cda9a47fc455fc67b284f7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_owned</source>
          <target state="translated">NonZeroU16::to_owned</target>
        </trans-unit>
        <trans-unit id="450d0b2017abf1787e4b40c9180053f5f1c5d6b5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_string</source>
          <target state="translated">NonZeroU16::to_string</target>
        </trans-unit>
        <trans-unit id="565d7bfa4f368119e8eb8c597666eee168d3ec36" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_from</source>
          <target state="translated">NonZeroU16::try_from</target>
        </trans-unit>
        <trans-unit id="c9ffda0c65ec9d2c6dac8e1259fd7cb09818b7a4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_into</source>
          <target state="translated">NonZeroU16::try_into</target>
        </trans-unit>
        <trans-unit id="35a3919e55cf0455983744e7e8ab659cda957d3b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::type_id</source>
          <target state="translated">NonZeroU16::type_id</target>
        </trans-unit>
        <trans-unit id="027b94edf209f9b339fcc3f9fcbe95bea73b0fff" translate="yes" xml:space="preserve">
          <source>NonZeroU32</source>
          <target state="translated">NonZeroU32</target>
        </trans-unit>
        <trans-unit id="19103157b2dd994e271093d37a26558f253c1df5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow</source>
          <target state="translated">NonZeroU32::borrow</target>
        </trans-unit>
        <trans-unit id="d5900a35010072cf8f8a0e31e3295500e147138f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow_mut</source>
          <target state="translated">NonZeroU32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a3d0eea5bcf469a951789307713538f7dd48cc64" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clamp</source>
          <target state="translated">NonZeroU32::clamp</target>
        </trans-unit>
        <trans-unit id="ca9c328d071b73e6fec77d280d2dec16c6afe8be" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone</source>
          <target state="translated">NonZeroU32::clone</target>
        </trans-unit>
        <trans-unit id="4d0cce4f0af9fe9b58667070ea3aae8608af18fc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_from</source>
          <target state="translated">NonZeroU32::clone_from</target>
        </trans-unit>
        <trans-unit id="beeb1f8a7db4e17dce219e3b75ed85a27a214ce6" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_into</source>
          <target state="translated">NonZeroU32::clone_into</target>
        </trans-unit>
        <trans-unit id="66de3d60d49a5fd2460c7fce4fc4af569dea2ea8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::cmp</source>
          <target state="translated">NonZeroU32::cmp</target>
        </trans-unit>
        <trans-unit id="b9a64d225fbd880a1d363e7928600204954c435d" translate="yes" xml:space="preserve">
          <source>NonZeroU32::eq</source>
          <target state="translated">NonZeroU32::eq</target>
        </trans-unit>
        <trans-unit id="d198043d6e6b2dcbdbd140d6e9a9832d41ef00b0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::fmt</source>
          <target state="translated">NonZeroU32::fmt</target>
        </trans-unit>
        <trans-unit id="f99dcfdc314e32f70a453660a94f7ab9fd67185e" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from</source>
          <target state="translated">NonZeroU32::from</target>
        </trans-unit>
        <trans-unit id="298799838c58c16143fcd9e2418534b329517ba2" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from_str</source>
          <target state="translated">NonZeroU32::from_str</target>
        </trans-unit>
        <trans-unit id="6cd1cc0b365f1d3d480575dcbc2de54dae6a1d17" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ge</source>
          <target state="translated">NonZeroU32::ge</target>
        </trans-unit>
        <trans-unit id="1dbe40ea77f784440de6e51cfcfb8778482bc067" translate="yes" xml:space="preserve">
          <source>NonZeroU32::get</source>
          <target state="translated">NonZeroU32::get</target>
        </trans-unit>
        <trans-unit id="e88628f83bc918c532752959c92d4ac82adbf0fd" translate="yes" xml:space="preserve">
          <source>NonZeroU32::gt</source>
          <target state="translated">NonZeroU32::gt</target>
        </trans-unit>
        <trans-unit id="7104f6c9a14d29e93513632fa9934f8edd1d6e95" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash</source>
          <target state="translated">NonZeroU32::hash</target>
        </trans-unit>
        <trans-unit id="ed57c71253659bc0210251e89d76fbd4f29b25de" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash_slice</source>
          <target state="translated">NonZeroU32::hash_slice</target>
        </trans-unit>
        <trans-unit id="708299fe453aae6d855b8d5980451e3d6fa01e3f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::into</source>
          <target state="translated">NonZeroU32::into</target>
        </trans-unit>
        <trans-unit id="18cade9c6a5784c63e5e9e3cd947c01187616ffa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::le</source>
          <target state="translated">NonZeroU32::le</target>
        </trans-unit>
        <trans-unit id="258acfab28050bc7bb168cbfd4ef30a6d48665c5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::lt</source>
          <target state="translated">NonZeroU32::lt</target>
        </trans-unit>
        <trans-unit id="030aea2e6963a8f4da13cbc262733cb19ce4afc3" translate="yes" xml:space="preserve">
          <source>NonZeroU32::max</source>
          <target state="translated">NonZeroU32::max</target>
        </trans-unit>
        <trans-unit id="ec7f1e7d4f631759d2fa095faa8ca43552f8684a" translate="yes" xml:space="preserve">
          <source>NonZeroU32::min</source>
          <target state="translated">NonZeroU32::min</target>
        </trans-unit>
        <trans-unit id="1339b30fe6c5981bffbab3f00e68cdd9c9f8a0bc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ne</source>
          <target state="translated">NonZeroU32::ne</target>
        </trans-unit>
        <trans-unit id="0d42ac2122a8ce6e542130048262c73787d65cfa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new</source>
          <target state="translated">NonZeroU32::new</target>
        </trans-unit>
        <trans-unit id="53b766be632e74846603297c0e0ac6f9ccfdb9cc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new_unchecked</source>
          <target state="translated">NonZeroU32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="8d058b61ea076257a2a74125c037a43db242bed9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::partial_cmp</source>
          <target state="translated">NonZeroU32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="daeb2592a753cbd5361feb58a583b78797b11fc9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_owned</source>
          <target state="translated">NonZeroU32::to_owned</target>
        </trans-unit>
        <trans-unit id="60aaf34cff920dc42256dc10eec23c5ea806feec" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_string</source>
          <target state="translated">NonZeroU32::to_string</target>
        </trans-unit>
        <trans-unit id="73f9e4f2ad5073070910a47ac63d54b649f8d6e8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_from</source>
          <target state="translated">NonZeroU32::try_from</target>
        </trans-unit>
        <trans-unit id="63d1c4723bc8f38b153bb0f2590c96abef27a5d0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_into</source>
          <target state="translated">NonZeroU32::try_into</target>
        </trans-unit>
        <trans-unit id="97923d854095a52b24576bacbd79fc9ba83145d4" translate="yes" xml:space="preserve">
          <source>NonZeroU32::type_id</source>
          <target state="translated">NonZeroU32::type_id</target>
        </trans-unit>
        <trans-unit id="ff9af574bd71ecdb8a94e5c11d8cb03c995c903e" translate="yes" xml:space="preserve">
          <source>NonZeroU64</source>
          <target state="translated">NonZeroU64</target>
        </trans-unit>
        <trans-unit id="9174928c781d84aa02c125b176a43aa320ff0a5d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow</source>
          <target state="translated">NonZeroU64::borrow</target>
        </trans-unit>
        <trans-unit id="84bb893e16a6e53a0c100c76ec3f68a95e3e668d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow_mut</source>
          <target state="translated">NonZeroU64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcf340d75d4265672f320969bda5046bdb409e81" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clamp</source>
          <target state="translated">NonZeroU64::clamp</target>
        </trans-unit>
        <trans-unit id="183552bd8482c37ff61fe2a742c9ddb1ea0ca355" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone</source>
          <target state="translated">NonZeroU64::clone</target>
        </trans-unit>
        <trans-unit id="0eb415342585f28f35047e6cd3c2974cdbbe66bd" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_from</source>
          <target state="translated">NonZeroU64::clone_from</target>
        </trans-unit>
        <trans-unit id="6ab29e679c166bbe4bda6532e91d9eeb91acad3c" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_into</source>
          <target state="translated">NonZeroU64::clone_into</target>
        </trans-unit>
        <trans-unit id="a63a17006148383604de4d3fcb995f84d18aaa77" translate="yes" xml:space="preserve">
          <source>NonZeroU64::cmp</source>
          <target state="translated">NonZeroU64::cmp</target>
        </trans-unit>
        <trans-unit id="9de4084186275b67715c01bdf2631108a20373b3" translate="yes" xml:space="preserve">
          <source>NonZeroU64::eq</source>
          <target state="translated">NonZeroU64::eq</target>
        </trans-unit>
        <trans-unit id="f701376286f75acabb93bc338425e6cae42fdba1" translate="yes" xml:space="preserve">
          <source>NonZeroU64::fmt</source>
          <target state="translated">NonZeroU64::fmt</target>
        </trans-unit>
        <trans-unit id="e6c78a21f2934d9a2da92dd578a35b8157419529" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from</source>
          <target state="translated">NonZeroU64::from</target>
        </trans-unit>
        <trans-unit id="546bd47a252bfe7b85af380602d87da22806650f" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from_str</source>
          <target state="translated">NonZeroU64::from_str</target>
        </trans-unit>
        <trans-unit id="9aadba2a2b721871fd6af482b4623eee945bd2ca" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ge</source>
          <target state="translated">NonZeroU64::ge</target>
        </trans-unit>
        <trans-unit id="23badb59c2bf64bbfd600b89c65d6464f288c34e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::get</source>
          <target state="translated">NonZeroU64::get</target>
        </trans-unit>
        <trans-unit id="70ba0bfc2ee5de3dc8d77e5c800ac26d942aad60" translate="yes" xml:space="preserve">
          <source>NonZeroU64::gt</source>
          <target state="translated">NonZeroU64::gt</target>
        </trans-unit>
        <trans-unit id="1be0d3fa424fa8f1c9033db1563822faa87d86bc" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash</source>
          <target state="translated">NonZeroU64::hash</target>
        </trans-unit>
        <trans-unit id="9ef89b20cd332d28440efb1ab8c800e464dbc0c5" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash_slice</source>
          <target state="translated">NonZeroU64::hash_slice</target>
        </trans-unit>
        <trans-unit id="9cf4c75c1bac7fde4346dcdbc35fda963e585282" translate="yes" xml:space="preserve">
          <source>NonZeroU64::into</source>
          <target state="translated">NonZeroU64::into</target>
        </trans-unit>
        <trans-unit id="7376c3fefec318f3031bdc950d6f8f2a3089d974" translate="yes" xml:space="preserve">
          <source>NonZeroU64::le</source>
          <target state="translated">NonZeroU64::le</target>
        </trans-unit>
        <trans-unit id="9c3837210065694f326259c4c009fcf151ab8938" translate="yes" xml:space="preserve">
          <source>NonZeroU64::lt</source>
          <target state="translated">NonZeroU64::lt</target>
        </trans-unit>
        <trans-unit id="e88a4e86bb9a247b011285115d5e4adc34155d05" translate="yes" xml:space="preserve">
          <source>NonZeroU64::max</source>
          <target state="translated">NonZeroU64::max</target>
        </trans-unit>
        <trans-unit id="3ca2447656d5c5bf7e39124b2a8d6630ff253464" translate="yes" xml:space="preserve">
          <source>NonZeroU64::min</source>
          <target state="translated">NonZeroU64::min</target>
        </trans-unit>
        <trans-unit id="bf2706867bfa59da3e12e574c1c7a042c0c7fa0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ne</source>
          <target state="translated">NonZeroU64::ne</target>
        </trans-unit>
        <trans-unit id="2fb761a04a1a28848d5bbb8c94562514f64738e6" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new</source>
          <target state="translated">NonZeroU64::new</target>
        </trans-unit>
        <trans-unit id="a84ebe37c16ccdf34c145d075dd2d1ae8e718fd7" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new_unchecked</source>
          <target state="translated">NonZeroU64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="424d3fd0d71ac1783106c5f073cedfafd2433e33" translate="yes" xml:space="preserve">
          <source>NonZeroU64::partial_cmp</source>
          <target state="translated">NonZeroU64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="689c6172e5e5fa7d743f6d9ea54feb2a2c45360e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_owned</source>
          <target state="translated">NonZeroU64::to_owned</target>
        </trans-unit>
        <trans-unit id="0f770ca97d17ac208580e4663b1cb35d1585cd0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_string</source>
          <target state="translated">NonZeroU64::to_string</target>
        </trans-unit>
        <trans-unit id="b3edffffa9ccb083ef6dc98f9a91d2ee62a6a140" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_from</source>
          <target state="translated">NonZeroU64::try_from</target>
        </trans-unit>
        <trans-unit id="2309bbba28296004c54d80642075d1ce6e4cf120" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_into</source>
          <target state="translated">NonZeroU64::try_into</target>
        </trans-unit>
        <trans-unit id="ddce3cce76f837592f485e87ab5ddde6cfce8cd0" translate="yes" xml:space="preserve">
          <source>NonZeroU64::type_id</source>
          <target state="translated">NonZeroU64::type_id</target>
        </trans-unit>
        <trans-unit id="93acae18872d78f1044f122c7fa386b8e0790d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8</source>
          <target state="translated">NonZeroU8</target>
        </trans-unit>
        <trans-unit id="6ff1a3cea907e661f3495c1cde07624988c92d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow</source>
          <target state="translated">NonZeroU8::borrow</target>
        </trans-unit>
        <trans-unit id="63abe3b6e90de29270a227a14eb1cd95090ba8b5" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow_mut</source>
          <target state="translated">NonZeroU8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="803a11a99b517fd90ac23a43eefbdfca5457f48a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clamp</source>
          <target state="translated">NonZeroU8::clamp</target>
        </trans-unit>
        <trans-unit id="5c11d86db1fbb6b9b9c0d8f7f4a28a4bf6afbb24" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone</source>
          <target state="translated">NonZeroU8::clone</target>
        </trans-unit>
        <trans-unit id="670ad8364fc1871b9629299e869bcbacc5da96b2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_from</source>
          <target state="translated">NonZeroU8::clone_from</target>
        </trans-unit>
        <trans-unit id="6c6784a6e074a57a017f865c39fe9469883e2de8" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_into</source>
          <target state="translated">NonZeroU8::clone_into</target>
        </trans-unit>
        <trans-unit id="693fb00ea40fa5aabc302b79d7c8e3718e6c8088" translate="yes" xml:space="preserve">
          <source>NonZeroU8::cmp</source>
          <target state="translated">NonZeroU8::cmp</target>
        </trans-unit>
        <trans-unit id="2158bd65bbc659ddb6d6412bd01916cb5d982ed3" translate="yes" xml:space="preserve">
          <source>NonZeroU8::eq</source>
          <target state="translated">NonZeroU8::eq</target>
        </trans-unit>
        <trans-unit id="3c80d10814d815cf1d99f1b13a12df65b0875877" translate="yes" xml:space="preserve">
          <source>NonZeroU8::fmt</source>
          <target state="translated">NonZeroU8::fmt</target>
        </trans-unit>
        <trans-unit id="7deaab84759c8ba54fbc5d91e72a59bd1aeb6577" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from</source>
          <target state="translated">NonZeroU8::from</target>
        </trans-unit>
        <trans-unit id="2756bc8cdd2a9198a79f5cf73b9e1d572f0f1491" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from_str</source>
          <target state="translated">NonZeroU8::from_str</target>
        </trans-unit>
        <trans-unit id="96e3274a26e461fa91c098ddcfa2558cac9c4747" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ge</source>
          <target state="translated">NonZeroU8::ge</target>
        </trans-unit>
        <trans-unit id="922117f87c8142145cb8b8abbabb7402b5e2bc53" translate="yes" xml:space="preserve">
          <source>NonZeroU8::get</source>
          <target state="translated">NonZeroU8::get</target>
        </trans-unit>
        <trans-unit id="9d9dcce691d917ac54e2661132eb0950cc45d9a7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::gt</source>
          <target state="translated">NonZeroU8::gt</target>
        </trans-unit>
        <trans-unit id="86ed98098229a654859aa731e5195157190e73cb" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash</source>
          <target state="translated">NonZeroU8::hash</target>
        </trans-unit>
        <trans-unit id="cb3adb90e777f04027a60a7879f9d135f08d1607" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash_slice</source>
          <target state="translated">NonZeroU8::hash_slice</target>
        </trans-unit>
        <trans-unit id="b79391b251df236d1d6289790b5260179dbdacc9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::into</source>
          <target state="translated">NonZeroU8::into</target>
        </trans-unit>
        <trans-unit id="349980dfec87decceb14ada089c45ad6b63c099a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::le</source>
          <target state="translated">NonZeroU8::le</target>
        </trans-unit>
        <trans-unit id="d736ad9511ba8ef5fa21ea6939ea1822c7d2dcb0" translate="yes" xml:space="preserve">
          <source>NonZeroU8::lt</source>
          <target state="translated">NonZeroU8::lt</target>
        </trans-unit>
        <trans-unit id="a284bcab69108d0fe7e56d5c4b3448e94a95b9b7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::max</source>
          <target state="translated">NonZeroU8::max</target>
        </trans-unit>
        <trans-unit id="5a9a87bf0c351a8fa498461781bb9417c3bc85f9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::min</source>
          <target state="translated">NonZeroU8::min</target>
        </trans-unit>
        <trans-unit id="950681f0c85136301d4d8bc7bd384530cbe0ad13" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ne</source>
          <target state="translated">NonZeroU8::ne</target>
        </trans-unit>
        <trans-unit id="32bcfbfa6acfd6ddd32e20022619e9223f40a94f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new</source>
          <target state="translated">NonZeroU8::new</target>
        </trans-unit>
        <trans-unit id="c65bae8471e01bcbc9a0141783aef01900f64a4c" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new_unchecked</source>
          <target state="translated">NonZeroU8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="60e3a745d7919f9cebc4387f60a9049fdd9960a9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::partial_cmp</source>
          <target state="translated">NonZeroU8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="814facf57cfd7397aa0ec4ff5934741dc1504d0a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_owned</source>
          <target state="translated">NonZeroU8::to_owned</target>
        </trans-unit>
        <trans-unit id="b5e9e73145a1a10790ac2c4b4ee56c85d1e6f97f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_string</source>
          <target state="translated">NonZeroU8::to_string</target>
        </trans-unit>
        <trans-unit id="2b735ce2d45697df8d25226cb8808f268d9dad27" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_from</source>
          <target state="translated">NonZeroU8::try_from</target>
        </trans-unit>
        <trans-unit id="2b02b5ef9beb40480c74f9952d3ce821f4d69911" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_into</source>
          <target state="translated">NonZeroU8::try_into</target>
        </trans-unit>
        <trans-unit id="8c0fc32ec166f66886b38f57ea7d3cb7a7835fe2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::type_id</source>
          <target state="translated">NonZeroU8::type_id</target>
        </trans-unit>
        <trans-unit id="b35788d3f6ffc592ab0774878cef29486e7e5bd4" translate="yes" xml:space="preserve">
          <source>NonZeroUsize</source>
          <target state="translated">NonZeroUsize</target>
        </trans-unit>
        <trans-unit id="c419d78f65ceafa9adf9a16c8a0459bf66be0bb0" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow</source>
          <target state="translated">NonZeroUsize::borrow</target>
        </trans-unit>
        <trans-unit id="c7ac97a8de687d7597163c213da2788ada2700d7" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow_mut</source>
          <target state="translated">NonZeroUsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d423dc3c41f93a9c06c0e4ce6ae7fc621e805056" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clamp</source>
          <target state="translated">NonZeroUsize::clamp</target>
        </trans-unit>
        <trans-unit id="47e7faa665db9da3adc8893ed9e5dcaa815fe4b2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone</source>
          <target state="translated">NonZeroUsize::clone</target>
        </trans-unit>
        <trans-unit id="cb938c36bd0b3049477f6ad99f18c0d0ed6bf26f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_from</source>
          <target state="translated">NonZeroUsize::clone_from</target>
        </trans-unit>
        <trans-unit id="030e5620dfbf55afbbfe2d9c96c1e322152959d2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_into</source>
          <target state="translated">NonZeroUsize::clone_into</target>
        </trans-unit>
        <trans-unit id="a38099d022e9104d990e7e4e2d00982504357f0e" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::cmp</source>
          <target state="translated">NonZeroUsize::cmp</target>
        </trans-unit>
        <trans-unit id="57469c189c9f0d01b944369669232584fcab48be" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::eq</source>
          <target state="translated">NonZeroUsize::eq</target>
        </trans-unit>
        <trans-unit id="a3e007978854dfec2ea17781a918799b74afb325" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::fmt</source>
          <target state="translated">NonZeroUsize::fmt</target>
        </trans-unit>
        <trans-unit id="f78a5853c07aa978500a70738e411232664860cc" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from</source>
          <target state="translated">NonZeroUsize::from</target>
        </trans-unit>
        <trans-unit id="7712061538648151dde34c4415be3b5d61f5877b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from_str</source>
          <target state="translated">NonZeroUsize::from_str</target>
        </trans-unit>
        <trans-unit id="f4728f09de22bd70d445970426411f10a0225b43" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ge</source>
          <target state="translated">NonZeroUsize::ge</target>
        </trans-unit>
        <trans-unit id="b1cdf6cf2409f8c0f48ff7b3ba56ccc5ce5115e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::get</source>
          <target state="translated">NonZeroUsize::get</target>
        </trans-unit>
        <trans-unit id="a20bd2dec9d5657f43798c2c990e62953392115c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::gt</source>
          <target state="translated">NonZeroUsize::gt</target>
        </trans-unit>
        <trans-unit id="801d8bc95574bf029e7d684d2cf3f771b60cd725" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash</source>
          <target state="translated">NonZeroUsize::hash</target>
        </trans-unit>
        <trans-unit id="6e0922eea57f8699c098adb3c035a1605d38f3df" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash_slice</source>
          <target state="translated">NonZeroUsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="fb7586f1fe5330ac7ebbf29da06f142f1a81f679" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::into</source>
          <target state="translated">NonZeroUsize::into</target>
        </trans-unit>
        <trans-unit id="2236d0a73fe65fdff9ad7360c0db597b0672828c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::le</source>
          <target state="translated">NonZeroUsize::le</target>
        </trans-unit>
        <trans-unit id="9347ed4b41dd70587e1703f7c2e07851b56cb2e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::lt</source>
          <target state="translated">NonZeroUsize::lt</target>
        </trans-unit>
        <trans-unit id="751ac4d697954b225e6f1616e4b4e0881bb6a41f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::max</source>
          <target state="translated">NonZeroUsize::max</target>
        </trans-unit>
        <trans-unit id="00f9ea1a8ab80868d5583ca29a5d8f2c152f6d4b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::min</source>
          <target state="translated">NonZeroUsize::min</target>
        </trans-unit>
        <trans-unit id="a3adc830a3d6e8e1f76b36c1da867853c22f3352" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ne</source>
          <target state="translated">NonZeroUsize::ne</target>
        </trans-unit>
        <trans-unit id="b482e2411d650436386f31aaaee9d529c27faf6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new</source>
          <target state="translated">NonZeroUsize::new</target>
        </trans-unit>
        <trans-unit id="0a63ca14c98c0ba3afecce88c1ee164dbbe678b5" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new_unchecked</source>
          <target state="translated">NonZeroUsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d2e829a9fc8b73a5ec3a806953ba65e782b63e4f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::partial_cmp</source>
          <target state="translated">NonZeroUsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="0fc32bf985ee7be65f7708751121df22adec3ee2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_owned</source>
          <target state="translated">NonZeroUsize::to_owned</target>
        </trans-unit>
        <trans-unit id="368109929572f9725530c9b5e66c0770d0254f6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_string</source>
          <target state="translated">NonZeroUsize::to_string</target>
        </trans-unit>
        <trans-unit id="87d57ca9ccbaaeab13b116376180c23efda524d3" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_from</source>
          <target state="translated">NonZeroUsize::try_from</target>
        </trans-unit>
        <trans-unit id="f36d6ccda72162b66595cff5afa6abcccb3ef47a" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_into</source>
          <target state="translated">NonZeroUsize::try_into</target>
        </trans-unit>
        <trans-unit id="661478a23cc64b875358e2c7f6262c9eb208bcf8" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::type_id</source>
          <target state="translated">NonZeroUsize::type_id</target>
        </trans-unit>
        <trans-unit id="36aa77cbc45a62a558a375b317bc9b3804badfce" translate="yes" xml:space="preserve">
          <source>NoneError</source>
          <target state="translated">NoneError</target>
        </trans-unit>
        <trans-unit id="8def7b12f8f65fd01050dafd05df50f8287c0655" translate="yes" xml:space="preserve">
          <source>NoneError::borrow</source>
          <target state="translated">NoneError::borrow</target>
        </trans-unit>
        <trans-unit id="411f23ffccc2c350e97a02f83bb00bb04a9c1832" translate="yes" xml:space="preserve">
          <source>NoneError::borrow_mut</source>
          <target state="translated">NoneError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a4d6154b1c340d1443c5a20d251329f398af2e11" translate="yes" xml:space="preserve">
          <source>NoneError::clamp</source>
          <target state="translated">NoneError::clamp</target>
        </trans-unit>
        <trans-unit id="555a6fa6139d1928ed4e7fa787af07b254f8f631" translate="yes" xml:space="preserve">
          <source>NoneError::clone</source>
          <target state="translated">NoneError::clone</target>
        </trans-unit>
        <trans-unit id="b7be3f1dfae027d0e36e44675d36fbd402d1e26e" translate="yes" xml:space="preserve">
          <source>NoneError::clone_from</source>
          <target state="translated">NoneError::clone_from</target>
        </trans-unit>
        <trans-unit id="dc67355563b52eb89e32ff38b5504d3dd52d77c9" translate="yes" xml:space="preserve">
          <source>NoneError::clone_into</source>
          <target state="translated">NoneError::clone_into</target>
        </trans-unit>
        <trans-unit id="65e99ec3e2a6e151575264b82499d7f2e38008ff" translate="yes" xml:space="preserve">
          <source>NoneError::cmp</source>
          <target state="translated">NoneError::cmp</target>
        </trans-unit>
        <trans-unit id="0611d16ae0dbf1df9ec05c20e45d31816b7a33e3" translate="yes" xml:space="preserve">
          <source>NoneError::eq</source>
          <target state="translated">NoneError::eq</target>
        </trans-unit>
        <trans-unit id="ddc77b796895a55df93a0b820a464b4aa338d41d" translate="yes" xml:space="preserve">
          <source>NoneError::fmt</source>
          <target state="translated">NoneError::fmt</target>
        </trans-unit>
        <trans-unit id="f69f3c5a7bc9e57ba1c80a5b7f03fced9bacf61f" translate="yes" xml:space="preserve">
          <source>NoneError::from</source>
          <target state="translated">NoneError::from</target>
        </trans-unit>
        <trans-unit id="ea4b13c4f12ac04af5fe2cbffa33fc963c8d5a26" translate="yes" xml:space="preserve">
          <source>NoneError::ge</source>
          <target state="translated">NoneError::ge</target>
        </trans-unit>
        <trans-unit id="80a0b1216e8cf201b9e9391df5c095172374f508" translate="yes" xml:space="preserve">
          <source>NoneError::gt</source>
          <target state="translated">NoneError::gt</target>
        </trans-unit>
        <trans-unit id="3cade823dfb903a695b6582abf8a0356daee7927" translate="yes" xml:space="preserve">
          <source>NoneError::hash</source>
          <target state="translated">NoneError::hash</target>
        </trans-unit>
        <trans-unit id="2c1acaeb04c59b2f4a9a10620721a7a1d4aa42f7" translate="yes" xml:space="preserve">
          <source>NoneError::hash_slice</source>
          <target state="translated">NoneError::hash_slice</target>
        </trans-unit>
        <trans-unit id="46b77ff1d8e23b12f242a6cf68b6e7dd11a9e430" translate="yes" xml:space="preserve">
          <source>NoneError::into</source>
          <target state="translated">NoneError::into</target>
        </trans-unit>
        <trans-unit id="ba9c0b7fd1b90ee18de8e25f5e5340671555fa67" translate="yes" xml:space="preserve">
          <source>NoneError::le</source>
          <target state="translated">NoneError::le</target>
        </trans-unit>
        <trans-unit id="41e697d230de0c7c6e3ccd553c26214e3ef30472" translate="yes" xml:space="preserve">
          <source>NoneError::lt</source>
          <target state="translated">NoneError::lt</target>
        </trans-unit>
        <trans-unit id="02bc1b16e164540afd825f0ab014879760deedcf" translate="yes" xml:space="preserve">
          <source>NoneError::max</source>
          <target state="translated">NoneError::max</target>
        </trans-unit>
        <trans-unit id="03ed85d18288e8c6efca69c28f3c605bc8004901" translate="yes" xml:space="preserve">
          <source>NoneError::min</source>
          <target state="translated">NoneError::min</target>
        </trans-unit>
        <trans-unit id="0cf87dcf59fc2d8f60cce9e0913e3c5ea01c71c6" translate="yes" xml:space="preserve">
          <source>NoneError::ne</source>
          <target state="translated">NoneError::ne</target>
        </trans-unit>
        <trans-unit id="88b27454a88f2b6d19dafb3a30b27e9e4799a66b" translate="yes" xml:space="preserve">
          <source>NoneError::partial_cmp</source>
          <target state="translated">NoneError::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d76800607ec208e0e9251b9a3a41ceabc49a331f" translate="yes" xml:space="preserve">
          <source>NoneError::to_owned</source>
          <target state="translated">NoneError::to_owned</target>
        </trans-unit>
        <trans-unit id="a3e3b0d2121e13d536f0151b0514e0d6c2c50efe" translate="yes" xml:space="preserve">
          <source>NoneError::try_from</source>
          <target state="translated">NoneError::try_from</target>
        </trans-unit>
        <trans-unit id="b6f9326f4f9275b1c9ee9bf38430eb240361bf0b" translate="yes" xml:space="preserve">
          <source>NoneError::try_into</source>
          <target state="translated">NoneError::try_into</target>
        </trans-unit>
        <trans-unit id="2ed007421edc30616530d31dc1a9b886d8f905b6" translate="yes" xml:space="preserve">
          <source>NoneError::type_id</source>
          <target state="translated">NoneError::type_id</target>
        </trans-unit>
        <trans-unit id="59bdf32f963e32403610f535ed38d94ab9fa57b3" translate="yes" xml:space="preserve">
          <source>Nonequality comparison</source>
          <target state="translated">無品質比較</target>
        </trans-unit>
        <trans-unit id="19eddb0e70179b2e619be3068cd8376966632800" translate="yes" xml:space="preserve">
          <source>Nor will this:</source>
          <target state="translated">これもそうだろう。</target>
        </trans-unit>
        <trans-unit id="9b417a21d4e30df48f9cabc1eb07b9ff439a8913" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="translated">通常、ここでは、代わりに&lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;を使用してコンテンツを正しくドロップし、メモリをリークしません。</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="7531cdd8037edc1069a4fd743641ffecf0edfa83" translate="yes" xml:space="preserve">
          <source>Not Equal</source>
          <target state="translated">イコールではない</target>
        </trans-unit>
        <trans-unit id="f8548a3657bfc32a33e876b215b140f301134c05" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN).</source>
          <target state="translated">ノット・ア・ナンバー(NaN)。</target>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="translated">等しくない</target>
        </trans-unit>
        <trans-unit id="a2b674143c807a9d4d57ac721ad16bfa7f8e15e8" translate="yes" xml:space="preserve">
          <source>Not finding the pattern:</source>
          <target state="translated">パターンが見つからない</target>
        </trans-unit>
        <trans-unit id="ba8cbd3db6c5866f33c337f17d9969faf64a68a8" translate="yes" xml:space="preserve">
          <source>Not have any type parameters (although lifetime parameters are allowed), and</source>
          <target state="translated">型パラメータを持たない(ライフタイムパラメータは許可されているが)。</target>
        </trans-unit>
        <trans-unit id="fcaef0deabf89559da493cc8fdbfb1b73c922bc5" translate="yes" xml:space="preserve">
          <source>Not having to worry about incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn&amp;rsquo;t an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, you &lt;em&gt;can&lt;/em&gt; safely assume that the value isn&amp;rsquo;t null. This was a deliberate design decision for Rust to limit null&amp;rsquo;s pervasiveness and increase the safety of Rust code.</source>
          <target state="translated">nullでない値を誤って想定することを心配する必要がないことで、コードの信頼性を高めることができます。 nullの可能性がある値を取得するには、その値のタイプを &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; にして明示的にオプトインする必要があります。次に、その値を使用する場合、値がnullの場合を明示的に処理する必要があります。どこでも値がないタイプがあるという &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 、あなたが&lt;em&gt;することができ&lt;/em&gt;、安全に値がnullでないことを前提としています。これは、Rustがnullの普及を制限し、Rustコードの安全性を向上させるための意図的な設計決定でした。</target>
        </trans-unit>
        <trans-unit id="c51294854fb6314b2caed8c3d6d50e7adbd261e2" translate="yes" xml:space="preserve">
          <source>Not running destructors</source>
          <target state="translated">デストラクタを実行しない</target>
        </trans-unit>
        <trans-unit id="b24fd225d5f013f2fa70d00cf4c24dafb25feaf7" translate="yes" xml:space="preserve">
          <source>Not running destructors in Rust is safe even if it has a type that isn't &lt;code&gt;'static&lt;/code&gt;. &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt;&lt;/a&gt; provides a wrapper to prevent a variable or field from being dropped automatically.</source>
          <target state="translated">Rustでデストラクタを実行しないことは、それが &lt;code&gt;'static&lt;/code&gt; でないタイプであっても安全です。&lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt; &lt;/a&gt;は、変数またはフィールドが自動的にドロップされないようにするラッパーを提供します。</target>
        </trans-unit>
        <trans-unit id="0c7cc856a7f3d9cb5a50a65d04097b3b7b8538aa" translate="yes" xml:space="preserve">
          <source>Not that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">この関数も初期値がNaNであればNaNを返すというわけではありません。</target>
        </trans-unit>
        <trans-unit id="c78919f021b1d754a66fe9891819ec98d0a80ddf" translate="yes" xml:space="preserve">
          <source>Not::not</source>
          <target state="translated">Not::not</target>
        </trans-unit>
        <trans-unit id="67e3ba0677bb45d7937c81385c061373c31498a8" translate="yes" xml:space="preserve">
          <source>Notable exception is made for situations where any of the directories specified in the &lt;code&gt;path&lt;/code&gt; could not be created as it was being created concurrently. Such cases are considered to be successful. That is, calling &lt;code&gt;create_dir_all&lt;/code&gt; concurrently from multiple threads or processes is guaranteed not to fail due to a race condition with itself.</source>
          <target state="translated">同時に作成されたため、 &lt;code&gt;path&lt;/code&gt; 指定されたディレクトリのいずれかを作成できなかった場合は、顕著な例外が発生します。このようなケースは成功したと見なされます。つまり、複数のスレッドまたはプロセスから &lt;code&gt;create_dir_all&lt;/code&gt; を同時に呼び出すと、それ自体との競合状態が原因で失敗しないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">特に、この関数は &lt;code&gt;flag&lt;/code&gt; パラメータを無視します。</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">特に：&lt;a href=&quot;variables&quot;&gt;変数&lt;/a&gt;、関数パラメーター、&lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt;および&lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;アイテムは、 &lt;code&gt;Sized&lt;/code&gt; する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">注1:イテレータが最後まで消費されない場合でも、要素範囲は削除されます。</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">注1:イテレータが部分的にしか消費されない場合や、全く消費されない場合でも、要素範囲は削除されます。</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">注1:イテレータの最初の要素は、与えられたステップに関係なく常に返されます。</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">注2： &lt;code&gt;Drain&lt;/code&gt; 値がドロップされないが、それが保持する借用が期限切れになる場合（たとえば、 &lt;code&gt;mem::forget&lt;/code&gt; 原因で）、デックから削除される要素の数は不定です。</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">注2： &lt;code&gt;Drain&lt;/code&gt; 値がリークされた場合、ベクターから削除される要素の数は不定です。</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">注2：無視された要素がプルされる時間は固定されていません。 &lt;code&gt;StepBy&lt;/code&gt; は、 &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; ように動作しますが、 &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; ように動作することもできます。どちらの方法を使用してもかまいません。パフォーマンス上の理由から、一部のイテレータの変更。 2番目の方法は、イテレータを先に進め、より多くのアイテムを消費する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">リスト19-1と19-3 では、 &lt;code&gt;num&lt;/code&gt; が格納されている同じメモリ位置を指す &lt;code&gt;*const i32&lt;/code&gt; と &lt;code&gt;*mut i32&lt;/code&gt; の rawポインターを作成したことにも注意してください。代わりに、 &lt;code&gt;num&lt;/code&gt; への不変で可変の参照を作成しようとした場合、Rustの所有権ルールでは、不変の参照と同時に可変の参照が許可されないため、コードはコンパイルされません。生のポインタを使用すると、同じ場所への可変ポインタと不変ポインタを作成し、可変ポインタを介してデータを変更できます。これにより、データ競合が発生する可能性があります。注意してください！</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">また、この形式の文脈では、「トークン」という用語に&lt;em&gt;は&lt;/em&gt;通常&lt;em&gt;、&lt;/em&gt;単純なNTが&lt;em&gt;含まれ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">しかし、注意してください。</target>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">ロケールに関する注意事項</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">＆Anyは、値が指定された具象型であるかどうかのテストに限定されており、型が特性を実装しているかどうかのテストには使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">たとえば、&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; sはこのプリミティブを使用して実装されることに注意してください。実際、ブロックしている &lt;code&gt;send&lt;/code&gt; または &lt;code&gt;recv&lt;/code&gt; を呼び出すと、チャネルが利用できない場合にそれらが生成されます。</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;を実装し、&lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; を&lt;/a&gt;実装することに注意してください。</target>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">そのノート &lt;code&gt;(T,)&lt;/code&gt; 常に型の要素を含む1組のタイプ意味 &lt;code&gt;T&lt;/code&gt; を。カンマは構文の明確化に必要です。</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">ことを注意 &lt;code&gt;CoerceUnsized&lt;/code&gt; が主のようなスマートポインタで使用されている &lt;code&gt;Box&lt;/code&gt; 、 &lt;code&gt;Rc&lt;/code&gt; とし、 &lt;code&gt;Arc&lt;/code&gt; 彼らがで指している無サイズの型を強制できることをマークできるようにします。</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; はシングルスレッドシナリオでのみ使用されることに注意してください。第16章で並行性について説明するときは、マルチスレッドプログラムで参照カウントを行う方法について説明します。</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">&lt;code&gt;Rhs&lt;/code&gt; はデフォルトで &lt;code&gt;Self&lt;/code&gt; ですが、これは必須ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rhs&lt;/code&gt; はデフォルトで &lt;code&gt;Self&lt;/code&gt; ですが、これは必須ではないことに注意してください。たとえば、&lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; 実装し、 &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; 形式の操作を許可します。</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rhs&lt;/code&gt; はデフォルトで &lt;code&gt;Self&lt;/code&gt; ですが、これは必須ではないことに注意してください。たとえば、&lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; 実装し、 &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; 形式の操作を許可します。</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">なお、 &lt;code&gt;T&lt;/code&gt; は必ずしも実装していない&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;、そうでないとしてもクローンとリセットすることができますので &lt;code&gt;self.buf&lt;/code&gt; 。しかし、 &lt;code&gt;replace&lt;/code&gt; の元の値の関連付けを解除するために使用することができ &lt;code&gt;self.buf&lt;/code&gt; から &lt;code&gt;self&lt;/code&gt; それを返すことができるように、：</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">なお、 &lt;code&gt;T&lt;/code&gt; は必ずしも実装していない&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;、そうでないとしてもクローンとリセットすることができますので &lt;code&gt;self.buf&lt;/code&gt; 。しかし &lt;code&gt;take&lt;/code&gt; の元の値の関連付けを解除するために使用することができ &lt;code&gt;self.buf&lt;/code&gt; から &lt;code&gt;self&lt;/code&gt; それを返すことができるように、：</target>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">また、 &lt;code&gt;drain_filter&lt;/code&gt; を使用すると、保持するか削除するかに関係なく、フィルタークロージャー内のすべての要素を変更できます。</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">&lt;code&gt;drain_filter&lt;/code&gt; を使用すると、保持するか削除するかに関係なく、フィルタークロージャー内のすべての要素を変更できます。</target>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">なお、 &lt;code&gt;ptr::drop_in_place&lt;/code&gt; すでに、これは不要で使用して、ワークロードがdrop_in_place呼び出しのいくつかの小さな数に低減することができそうだとすれば、このチェックを実行します。特に、スライスをdrop_in_placeできることに注意してください。これにより、すべての値に対して1つのneeds_dropチェックが実行されます。</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">注意 &lt;code&gt;query&lt;/code&gt; 今ある &lt;code&gt;String&lt;/code&gt; を呼び出すためではなく、文字列スライス &lt;code&gt;to_lowercase&lt;/code&gt; すると、既存のデータを参照するのではなく、新しいデータを作成します。たとえば、クエリが &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; であるとします。その文字列スライスには使用する小文字の &lt;code&gt;u&lt;/code&gt; または &lt;code&gt;t&lt;/code&gt; が含まれていないため、 &lt;code&gt;&quot;rust&quot;&lt;/code&gt; を含む新しい &lt;code&gt;String&lt;/code&gt; を割り当てる必要があります。我々が通過すると &lt;code&gt;query&lt;/code&gt; の引数として &lt;code&gt;contains&lt;/code&gt; 今の方法を、私たちはの署名ので、アンパサンドを追加する必要が &lt;code&gt;contains&lt;/code&gt; 、文字列のスライスを取るように定義されています。</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">引数に無効なUnicodeが含まれていると、 &lt;code&gt;std::env::args&lt;/code&gt; がパニックになることに注意してください。プログラムが無効なUnicodeを含む引数を受け入れる必要がある場合は、代わりに &lt;code&gt;std::env::args_os&lt;/code&gt; 使用してください。この関数は、 &lt;code&gt;String&lt;/code&gt; 値ではなく &lt;code&gt;OsString&lt;/code&gt; 値を生成するイテレータを返します。ここでは、簡素化のために &lt;code&gt;std::env::args&lt;/code&gt; を使用することにしました &lt;code&gt;OsString&lt;/code&gt; 値はプラットフォームごとに異なり、 &lt;code&gt;String&lt;/code&gt; 値よりも操作が複雑だからです。</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; は4つのペアしか生成しないことに注意してください。いずれかの入力反復子が &lt;code&gt;None&lt;/code&gt; を返すと &lt;code&gt;zip&lt;/code&gt; がNoneを返すため、理論上の5番目のペア &lt;code&gt;(5, None)&lt;/code&gt; は決して生成され &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">Rustには、オプションの関数引数や可変関数の概念がないことに注意してください(C-FFIを除く)。</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">スレッドローカルストレージに格納されている型のデストラクタが確実に実行されるように「最善の努力」がなされていますが、すべてのプラットフォームがスレッドローカルストレージのすべての型に対してデストラクタが実行されることを保証できるわけではないことに注意してください。例えば、デストラクタが実行されない多くの既知の注意点があります。</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">注ことを &lt;code&gt;()&lt;/code&gt; -returning &lt;code&gt;main&lt;/code&gt; 正常終了で暗黙のうちに結果は、soからこれを返すする必要はありません &lt;code&gt;main&lt;/code&gt; あなたはまた、他の可能なコードを返却していない限りは。</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">キャプチャは変数を移動するか借りるかのどちらかになりますが、この状況ではクロージャが変数を借りていることに注意してください。キャプチャについての詳細は http://rustbyexample.com/fn/closures/capture.html を参照してください。</target>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">マッチャーは単なるトークンツリーであることに注意してください。上記の「シンプルNT」は、メタ変数NTです。したがって、これは非反復です。たとえば、 &lt;code&gt;$foo:ty&lt;/code&gt; は単純なNTですが、 &lt;code&gt;$($foo:ty)+&lt;/code&gt; は複雑なNTです。</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">参照のスコープは、それが導入された場所から始まり、その参照が最後に使用されたときまで続くことに注意してください。たとえば、不変参照の最後の使用は、可変参照が導入される前に発生するため、このコードはコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">送信が成功して&lt;em&gt;も&lt;/em&gt;、このチャネルにバッファが存在する場合、受信者がデータを確認できるとは限り&lt;em&gt;ませ&lt;/em&gt;ん。アイテムは、受信側が後で受信できるように内部バッファーにエンキューされます。ただし、バッファサイズが0の場合、チャネルはランデブーチャネルになり、この関数が成功を返す場合、レシーバは実際にデータを受信したことを保証します。</target>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">一部のタイプではアライメントが実装されない場合があることに注意してください。特に、 &lt;code&gt;Debug&lt;/code&gt; トレイトには一般的に実装されていません。パディングが確実に適用される良い方法は、入力をフォーマットしてから、この結果の文字列を使用して出力をパディングすることです。</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">すべての&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;は有効な&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;であり、 &lt;code&gt;as&lt;/code&gt; を使用して1にキャストできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">返された要素を含め、末尾と返された要素の間のすべての要素が消費されることに注意してください。これは、同じイテレータで &lt;code&gt;nth_back(0)&lt;/code&gt; を複数回呼び出すと、異なる要素が返されることも意味します。</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">先行するすべての要素と返された要素は、イテレータから消費されることに注意してください。つまり、先行する要素は破棄され、同じイテレータで &lt;code&gt;nth(0)&lt;/code&gt; を複数回呼び出すと、異なる要素が返されます。</target>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">使用しているRustコンパイラのバージョンを更新しても、コンパイルされた&lt;em&gt;The Rust Programming Language&lt;/em&gt;の最初の印刷のコードは、プロジェクトの&lt;em&gt;Cargo.toml&lt;/em&gt;で &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; なしで引き続きコンパイルされることに注意してください。これは、Rustの下位互換性の保証です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">内部バッファに残っているデータは失われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">この関数は決して戻りませんし、プロセスを終了するので、現在のスタックや他のスレッドのスタック上のデストラクタは実行されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">この関数は決して戻りませんし、プロセスを終了するので、現在のスタックや他のスレッドのスタック上のデストラクタは実行されないことに注意してください。クリーンなシャットダウンが必要な場合は、実行するデストラクタがなくなった時点でのみこの関数を呼び出すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">リスト10-13では &lt;code&gt;Summary&lt;/code&gt; トレイトと &lt;code&gt;NewsArticle&lt;/code&gt; と &lt;code&gt;Tweet&lt;/code&gt; タイプを同じ&lt;em&gt;lib.rs&lt;/em&gt;で定義したため、これらはすべて同じスコープ内にあることに注意してください。この&lt;em&gt;lib.rs&lt;/em&gt;は、 &lt;code&gt;aggregator&lt;/code&gt; と呼ばれるクレート用で、他の誰かがクレートの機能を使用して、ライブラリのスコープ内で定義された構造体に &lt;code&gt;Summary&lt;/code&gt; トレイトを実装したいとします。彼らは最初にその特性をその範囲に持ってくる必要があります。それらは、 &lt;code&gt;use aggregator::Summary;&lt;/code&gt; 指定することでそうします。すると、そのタイプの &lt;code&gt;Summary&lt;/code&gt; を実装できるようになります。 &lt;code&gt;Summary&lt;/code&gt; 別のクレートがトレイトを実装するには、トレイトもパブリックトレイトである必要があります。これは、リスト10-12で &lt;code&gt;trait&lt;/code&gt; 前に &lt;code&gt;pub&lt;/code&gt; キーワードを配置したためです。</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">&lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; を定義するために1つのジェネリック型のみを使用しているため、この定義は、 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 構造体が一部の型 &lt;code&gt;T&lt;/code&gt; に対してジェネリックであり、フィールド &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は&lt;em&gt;、&lt;/em&gt;その型にかかわらず、同じ型であることに注意してください多分。リスト10-7のように、異なるタイプの値を持つ &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; インスタンスを作成すると、コードはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">落下することを注意 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; を呼び出すことはありません &lt;code&gt;T&lt;/code&gt; のドロップコードを。 &lt;code&gt;T&lt;/code&gt; が初期化された場合にTが確実に削除されるようにするのは、ユーザーの責任です。</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">メソッド呼び出しのderef強制により、トレイトメソッドを呼び出すだけで、所有値に対してだけでなく参照に対しても動作するように動作します。ここで説明する実装は、最終的な型 &lt;code&gt;T&lt;/code&gt; が型パラメーターであるか、ローカルで認識されていない一般的なコンテキスト向けです。</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">空の配列 &lt;code&gt;[T; 0]&lt;/code&gt; は、要素タイプ &lt;code&gt;T&lt;/code&gt; と同じ配置要件を持っています。また、サイズがゼロのタイプの配置がデータフィールドの配置以下の場合でも、エラーは控えめに報告されます。</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">環境変数名は、Windowsでは大文字小文字を区別しませんが、その他のプラットフォームでは大文字小文字を区別することに注意してください。</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">場合でも、そのノート &lt;code&gt;T&lt;/code&gt; が大き有し &lt;code&gt;0&lt;/code&gt; 、ポインタがNULLであると適切に位置合わせしなければなりません。</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のサイズが &lt;code&gt;0&lt;/code&gt; であっても、ポインターはNULL以外でなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">場合でも、という注意 &lt;code&gt;T&lt;/code&gt; はサイズがある &lt;code&gt;0&lt;/code&gt; を、ポインタが非NULLかつ適切に整列させる必要があります。</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">効果的にコピーされたサイズ（ &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ）が &lt;code&gt;0&lt;/code&gt; の場合でも、ポインターはNULLでなく、適切に配置されている必要があります。</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">効果的にコピーされたサイズ（ &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ）が &lt;code&gt;0&lt;/code&gt; である場合でも、ポインターはNULLでなく、適切に位置合わせされている必要があります。</target>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">標準ライブラリに &lt;code&gt;IpAddr&lt;/code&gt; の定義が含まれている場合でも、標準ライブラリの定義をスコープに入れていないため、競合なしに独自の定義を作成して使用できます。型をスコープに組み込む方法については、第7章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">一部のアトミック操作もサポートしない将来のプラットフォームが追加される可能性があることに注意してください。最大限に移植可能なコードは、どのアトミック型が使用されるかに注意する必要があります。 &lt;code&gt;AtomicUsize&lt;/code&gt; と &lt;code&gt;AtomicIsize&lt;/code&gt; は一般的に最も移植性がありますが、それでもどこでも利用できるわけではありません。参考までに、 &lt;code&gt;std&lt;/code&gt; ライブラリにはポインターサイズのアトミックが必要ですが、 &lt;code&gt;core&lt;/code&gt; は必要ありません。</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">enumバリアントコンストラクターの汎用引数は、enumの後にではなく、バリアントの後に移動することに注意してください。たとえば、 &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; ではなく、Option :: &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; と記述します。</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">ここで、&lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;の呼び出しは明確にするためのものであることに注意してください。これは、指定された値での処理が完了したため、破棄する必要があることを示しています。</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">場合は、その注意 &lt;code&gt;Self::Item&lt;/code&gt; あるだけで &lt;code&gt;PartialOrd&lt;/code&gt; はなく、 &lt;code&gt;Ord&lt;/code&gt; 、上記の定義は、この関数が返すことを意味し &lt;code&gt;false&lt;/code&gt; 2つの連続項目は比較できない場合。</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; と &lt;code&gt;to&lt;/code&gt; の両方が同じファイルを指している場合、この操作によってファイルが切り捨てられる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">関数が複数の型の引数を取り、そのうちのいくつかをコンパイラに推論させたい場合は、型のプレースホルダを使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; または &lt;code&gt;const&lt;/code&gt; アイテムに関数またはクロージャの参照が含まれている場合、それらに参照が含まれている場合、コンパイラは最初に標準の省略ルールを試します。通常のルールでライフタイムを解決できない場合は、エラーになります。例として：</target>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">Rust では、構造体に unsize 型を含むフィールドが構造体の最後の唯一の unsize 型フィールドである場合にのみ、構造体に unsize 型を含めることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">一部の言語とテストフレームワークでは、2つの値が等しいことをアサートする関数のパラメーターは「 &lt;code&gt;expected&lt;/code&gt; 値」および「 &lt;code&gt;actual&lt;/code&gt; 値」と呼ばれ、引数を指定する順序が重要であることに注意してください。ただし、Rustでは、これらは &lt;code&gt;left&lt;/code&gt; および &lt;code&gt;right&lt;/code&gt; と呼ばれ、期待する値とテスト対象のコードが生成する値を指定する順序は重要ではありません。このテストでは、アサーションを &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; として記述できます。これにより、 &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; ことを示すエラーメッセージが表示されます。` （left == right） `で、 &lt;code&gt;left&lt;/code&gt; は &lt;code&gt;5&lt;/code&gt; 、 &lt;code&gt;right&lt;/code&gt; は &lt;code&gt;4&lt;/code&gt; でした。</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">他の属性を配置するためだけに別の &lt;code&gt;struct&lt;/code&gt; を導入すると、表現に意図しない副作用が生じる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">ネイティブ動的依存関係を静的ライブラリにリンクすることは不可能であり、この場合、リンクされていないすべてのネイティブ動的依存関係について警告が表示されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">同じメソッドのオーバーライド実装からデフォルト実装を呼び出すことはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">ストリームの長さは時間の経過とともに変化する可能性があることに注意してください (例えば、データがファイルに追加された場合など)。そのため、このメソッドを複数回コールしても毎回同じ長さを返すとは限りません。</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">正の整数を否定するとオーバーフローすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">他の正規化は行われないことに注意してください。特に、 &lt;code&gt;a/c&lt;/code&gt; と &lt;code&gt;a/b/../c&lt;/code&gt; は区別されます。これは、 &lt;code&gt;b&lt;/code&gt; がシンボリックリンクである可能性があるためです（その親は &lt;code&gt;a&lt;/code&gt; ではありません）。</target>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">すべてのプラットフォームがこのフィールドの更新をファイルのメタデータに保持するわけではないことに注意してください。たとえば、Windowsにはファイルへのアクセス時にこの時間の更新を無効にするオプションがあり、Linuxにも同様に &lt;code&gt;noatime&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">この出力のどこに &lt;code&gt;I got the value 4&lt;/code&gt; ないことがわかります。これは、合格したテストの実行時に出力される値です。その出力はキャプチャされました。失敗したテストの出力である &lt;code&gt;I got the value 8&lt;/code&gt; は、テストの要約出力のセクションに表示されます。これは、テストの失敗の原因も示しています。</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; への複数の呼び出しでは、ウェイクアップを受信するようにスケジュールする必要があるのは、最新の呼び出しに渡された&lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;からの&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;のみであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">&lt;code&gt;CannotReallocInPlace&lt;/code&gt; を &lt;code&gt;handle_alloc_error&lt;/code&gt; 関数に渡すことはできないことに注意してください。クライアントは、中止せずに &lt;code&gt;grow_in_place&lt;/code&gt; の障害から回復できるか、中止に頼る前に別の再割り当てメソッドにフォールバックすることが期待されています。</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">&lt;code&gt;CannotReallocInPlace&lt;/code&gt; を &lt;code&gt;handle_alloc_error&lt;/code&gt; 関数に渡すことはできないことに注意してください。クライアントは、中止せずに &lt;code&gt;shrink_in_place&lt;/code&gt; の障害から回復できるか、中止に頼る前に別の再割り当てメソッドにフォールバックすることが期待されています。</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">Rust のパニックは常にアンワインドによって実装されているわけではなく、プロセスを中止することによって実装されている場合があることに注意してください。パニックがこのように実装されている場合、この関数が呼び出されると、この関数はプロセスを中止し、巻き戻しは行われません。</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">このブロックの一部が使用されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">固定と &lt;code&gt;Unpin&lt;/code&gt; は、ポイントされた型 &lt;code&gt;P::Target&lt;/code&gt; にのみ影響し、 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; ラップされたポインター型 &lt;code&gt;P&lt;/code&gt; 自体には影響しないことに注意してください。たとえば、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; が &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;Unpin&lt;/code&gt; であるかどうかは、Pin &amp;lt;Box &amp;lt;T &amp;gt;&amp;gt;の動作には影響しません（ここで、 &lt;code&gt;T&lt;/code&gt; はポイントされた型です）。</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">読み込みを行うと、未読の部分を指すようにスライスが更新されることに注意してください。EOFに達するとスライスは空になります。</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt;と同様に、短い読み取りで返ることはエラーではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt;と同様に、短い書き込みを返すことはエラーではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">&lt;code&gt;File::read&lt;/code&gt; と同様に、短い読み取りで返ることはエラーではないことに注意してください。そのような短い読み取りから戻ったとき、ファイルポインタは引き続き更新されます。</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">&lt;code&gt;File::write&lt;/code&gt; と同様に、短い書き込みを返すことはエラーではないことに注意してください。そのような短い書き込みから戻ったとき、ファイルポインタは引き続き更新されます。</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一部のプラットフォームでは、これを&lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt;に関して単純に実装する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">stdoutはデフォルトでラインバッファリングされることが多いため、出力がすぐに出力されるように&lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt;を使用する必要がある場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">Rustの安全性の保証により、このモジュールで同期プリミティブを使用しない場合、グローバル（静的）変数にアクセスするには &lt;code&gt;unsafe&lt;/code&gt; コードが必要になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; と &lt;code&gt;||&lt;/code&gt; に注意してください。演算子はショートサーキットです。つまり、結果に寄与する場合にのみ、2番目のオペランドを評価します。この動作は特性によって強制できないため、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; オーバーロード可能な演算子としてはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 演算子は、コードで &lt;code&gt;*&lt;/code&gt; を使用するたびに、 &lt;code&gt;deref&lt;/code&gt; メソッドの呼び出しに置き換えられ、次に &lt;code&gt;*&lt;/code&gt; 演算子の呼び出しが1回だけ置き換えられることに注意してください。 &lt;code&gt;*&lt;/code&gt; 演算子の置換は無限に再帰しないため、結果として、 &lt;code&gt;i32&lt;/code&gt; 型のデータになり、 &lt;code&gt;assert_eq!&lt;/code&gt; の &lt;code&gt;5&lt;/code&gt; に一致します。リスト15-9で。</target>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FromFn&lt;/code&gt; イテレーターはクロージャーの動作についての想定を行わないため、保守的に&lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; を&lt;/a&gt;実装したり、&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt;をデフォルト &lt;code&gt;(0, None)&lt;/code&gt; からオーバーライドしたりしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">&lt;code&gt;PrimaryColor&lt;/code&gt; と &lt;code&gt;SecondaryColor&lt;/code&gt; タイプはフロントページにリストされておらず、 &lt;code&gt;mix&lt;/code&gt; 機能もないことに注意してください。それらを表示するには、 &lt;code&gt;kinds&lt;/code&gt; と &lt;code&gt;utils&lt;/code&gt; をクリックする必要があります。</target>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">異なるタプル構造体のインスタンスであるため、 &lt;code&gt;black&lt;/code&gt; と &lt;code&gt;origin&lt;/code&gt; 値は異なるタイプであることに注意してください。構造体内のフィールドは同じタイプですが、定義する各構造は独自のタイプです。たとえば、 &lt;code&gt;Color&lt;/code&gt; タイプのパラメーターを受け取る関数は、両方のタイプが3つの &lt;code&gt;i32&lt;/code&gt; 値で構成されている場合でも、 &lt;code&gt;Point&lt;/code&gt; を引数として受け取ることはできません。それ以外の場合、タプル構造体インスタンスはタプルのように動作します。インスタンスを個別の部分に分解したり、を使用したりできます &lt;code&gt;.&lt;/code&gt; その後に、個々の値にアクセスするためのインデックスが続きます。</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">&lt;code&gt;internal_adder&lt;/code&gt; 関数は &lt;code&gt;pub&lt;/code&gt; としてマークされていないことに注意してください。ただし、テストはRustコードであり、 &lt;code&gt;tests&lt;/code&gt; モジュールは単なる別のモジュールであるため、 &lt;code&gt;internal_adder&lt;/code&gt; をテストのスコープに入れて呼び出すことができます。プライベート関数をテストする必要があると思わない場合、Rustにはテストを強制するものはありません。</target>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;mod common;&lt;/code&gt; あることに注意してください。宣言は、リスト7-25で示したモジュール宣言と同じです。次に、テスト関数で &lt;code&gt;common::setup()&lt;/code&gt; 関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">&lt;em&gt;src / lib.rs&lt;/em&gt;の &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; ステートメントも変更されていないことに注意してください。また、 &lt;code&gt;use&lt;/code&gt; によって、クレートの一部としてコンパイルされるファイルに影響はありません。 &lt;code&gt;mod&lt;/code&gt; キーワードは、モジュールを宣言し、錆は、そのモジュールに入るコードのモジュールと同じ名前のファイルを検索します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">Rust構文は、 &lt;code&gt;-1i8&lt;/code&gt; を単一の整数リテラルではなく、整数リテラル &lt;code&gt;1i8&lt;/code&gt; への&lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;単項マイナス演算子の&lt;/a&gt;適用と見なすことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">アロケータがコレクションに要求するよりも多くのスペースを与える場合があることに注意してください。したがって、容量を正確に最小にすることはできません。今後の挿入が予想される場合は、&lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt;を優先してください。</target>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">アロケータがコレクションに要求するよりも多くのスペースを与える場合があることに注意してください。したがって、容量が正確に最小であるとは限りません。今後の挿入が予想される場合は、 &lt;code&gt;reserve&lt;/code&gt; を優先してください。</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">アロケータはコレクションに要求以上のスペースを与えることがあることに注意してください。したがって、容量は正確に最小になるように頼ることはできません。将来の挿入が予想される場合はリザーブを優先します。</target>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">待機時間は単調な時計で測定され、システム時刻の変更の影響を受けないように最善の努力が払われていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">待機時間は単調なクロックで測定され、システム時間に加えられた変更の影響を受けないことを保証するために最善の努力がなされていることに注意してください。この機能は、偽のウェイクアップの影響を受けやすくなっています。通常、条件変数にはブール述語が関連付けられており、偽のウェイクアップから保護するために、この関数が戻るたびに述語を常にチェックする必要があります。さらに、偽の目覚めにもかかわらず、タイムアウトが一定の期間を超えないことが一般に望ましく、したがって、睡眠期間は、眠った量だけ減らされる。または、 &lt;code&gt;wait_timeout_until&lt;/code&gt; メソッドを使用して、スプリアスウェイクに関係なく、合計タイムアウトで条件が満たされるまで待機します。</target>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; の容量は変化しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">インスタンス全体が変更可能でなければならないことに注意してください。Rustでは、特定のフィールドのみを変更可能としてマークすることはできません。他の式と同様に、構造体の新しいインスタンスを関数本体の最後の式として作成し、その新しいインスタンスを暗黙的に返すことができます。</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">ここでのエラーはジェネリック関数の定義にあることに注意してください： &lt;code&gt;Debug&lt;/code&gt; を実装するパラメーターでのみ呼び出しますが、コンパイラーは関数を拒否します：関数はすべての可能な入力タイプで機能する必要があります。この例をコンパイルするには、受け入れるジェネリック型を制限する必要があります。</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">入力されたトークンの展開結果は、将来的に変更される可能性があるので注意が必要です。出力に依存している場合は注意が必要です。</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">最も内側のオブジェクトが境界を設定するため、 &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; は引き続き &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">小文字の点字の「i」はラテン語と同じであることに注意してください。したがって</target>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">マクロはデバッグツールとして使用することを目的としているため、バージョン管理でこのマクロを長期間使用しないでください。バージョン管理に追加する必要があるデバッグ出力が関係する使用例は、デバッグなどのマクロが適切に機能します&lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt;クレートから。</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">テストの出力とテスト結果はインターリーブされることに注意してください。その理由は、前のセクションで説明したように、テストが並行して実行されているためです。使用してみてください &lt;code&gt;--test-threads=1&lt;/code&gt; オプションと &lt;code&gt;--nocapture&lt;/code&gt; フラグを、出力ルックスは、その後、好きなものを参照してください！</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">ポインター値は &lt;code&gt;T&lt;/code&gt; への有効なポインターを表す可能性があることに注意してください。これは、「まだ初期化されていない」センチネル値として使用してはならないことを意味します。遅延割り当てされる型は、他の方法で初期化を追跡する必要があります。</target>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">メインスレッドのスタックサイズはRustによって決定され&lt;em&gt;ない&lt;/em&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">標準ライブラリ（ &lt;code&gt;std&lt;/code&gt; ）も、パッケージの外部にあるクレートであることに注意してください。標準ライブラリはRust言語に付属しているため、&lt;em&gt;Cargo.toml&lt;/em&gt;を変更して &lt;code&gt;std&lt;/code&gt; を含める必要はありません。ただし、そこからアイテムをパッケージのスコープに移動するために、それを &lt;code&gt;use&lt;/code&gt; して参照する必要があります。たとえば、 &lt;code&gt;HashMap&lt;/code&gt; では次の行を使用します。</target>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">AsRefとAsMutという形質は、固定サイズの配列ではないかもしれない型に対して同様のメソッドを提供することに注意してください。実装者は、代わりにこれらの形質を好むべきです。</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; のタイプは &lt;code&gt;temp&lt;/code&gt; のタイプから推測できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">とき基礎となるが、イテレータはまだ進んでいることに注意してください&lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt;次の要素を取得するためには、：初めて呼び出され&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;の基本的なイテレータで呼び出され、したがって、任意の副作用（次の値をフェッチ以外のすなわち何でも）&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;メソッドが発生します。</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">戻り値のユーティリティでは、 &lt;code&gt;align&lt;/code&gt; は、割り当てられたメモリブロック全体の開始アドレスの配置以下である必要があります。この制約を満たす1つの方法は、 &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; を確実にすることです。</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">enumのバリアントはその識別子の下で名前空間になっていることに注意してください。2つのコロンを使用して2つを区切ります。これが便利な理由は、 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; と &lt;code&gt;IpAddrKind::V6&lt;/code&gt; 両方の値が同じタイプ &lt;code&gt;IpAddrKind&lt;/code&gt; になっているためです。次に、たとえば、任意の &lt;code&gt;IpAddrKind&lt;/code&gt; を取る関数を定義できます。</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; のみを使用することと、アンダースコアで始まる名前を使用することの間には微妙な違いがあることに注意してください。構文 &lt;code&gt;_x&lt;/code&gt; はまだ値を変数にバインドしますが、 &lt;code&gt;_&lt;/code&gt; はまったくバインドしません。この区別が重要であるケースを示すために、リスト18-21はエラーを提供します。</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">ファイルがすぐに削除される保証はないことに注意してください(例えば、プラットフォームによっては、他のオープンファイル記述子によって、すぐに削除できない場合があります)。</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">2つの &lt;code&gt;Match&lt;/code&gt; の間に複数の &lt;code&gt;Reject&lt;/code&gt; が存在する可能性があることに注意してください。それらを1つに結合する必要はありません。</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">これらの出力は、複数が指定されている場合、コンパイラーが再コンパイルせずに各形式の出力を一度に生成するという意味でスタック可能であることに注意してください。ただし、これは同じ方法で指定された出力にのみ適用されます。 &lt;code&gt;crate_type&lt;/code&gt; 属性のみが指定されている場合、それらはすべて構築されますが、1つ以上の &lt;code&gt;--crate-type&lt;/code&gt; コマンドラインフラグが指定されている場合、それらの出力のみが構築されます。</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これらの要件は、トレイト自体が対称的かつ推移的に実装される必要があることを意味します &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; および &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; 場合、 &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; および &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">これらの要件は、トレイト自体が対称的かつ推移的に実装される必要があることを意味します &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; および &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; 場合、 &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; および &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;let&lt;/code&gt; ステートメントは、 &lt;code&gt;expensive_closure&lt;/code&gt; に無名関数の&lt;em&gt;定義&lt;/em&gt;が含まれ、無名関数を呼び出した&lt;em&gt;結果の値&lt;/em&gt;は含まれないことを意味することに注意してください。ある時点で呼び出すコードを定義し、そのコードを保存して、後で呼び出したいので、クロージャーを使用していることを思い出してください。呼び出したいコードは、今では &lt;code&gt;expensive_closure&lt;/code&gt; に保存されています。</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">このアプローチでは、ライフタイム &lt;code&gt;'a&lt;/code&gt; の Sへの参照が必要です。より短い何もない &lt;code&gt;'a&lt;/code&gt; ：十分です短い寿命は後にすることを暗示する &lt;code&gt;demo&lt;/code&gt; （！などデストラクタなど）仕上げは、何かを実行するにはアクセスでき &lt;code&gt;s.data&lt;/code&gt; をその短い生涯の終了後、再び違反 &lt;code&gt;&amp;amp;mut&lt;/code&gt; の -borrowの排他的にアクセス。</target>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">これはOS文字列形式の文字列のバイト数を返さ&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">これは（ &lt;code&gt;transmute&lt;/code&gt; とは異なり） &lt;code&gt;v&lt;/code&gt; を移動しないことに注意してください。デストラクタが呼び出されないようにする場合は、 &lt;code&gt;mem::forget(v)&lt;/code&gt; 呼び出しが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">この例では、 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; ではなく &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を使用していることに注意してください。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; は、シングルスレッドシナリオ用です。マルチスレッドの状況で &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; 性を共有する必要がある場合は、RwLock &amp;lt;T&amp;gt;または &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">この例はまだコンパイルされないことに注意してください。その理由を少し後で説明します。</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">この関数&lt;strong&gt;は&lt;/strong&gt; Rustの&lt;strong&gt;すべてのパニック&lt;/strong&gt;を&lt;strong&gt;キャッチしない場合があることに&lt;/strong&gt;注意してください。Rustのパニックは常に巻き戻しによって実装されるとは限りませんが、プロセスを中止することによっても実装できます。この関数&lt;em&gt;は&lt;/em&gt;巻き戻しのパニック&lt;em&gt;のみを&lt;/em&gt;キャッチし、プロセスを中止するパニックはキャッチしません。</target>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">この関数は異なっていることに注意してください &lt;code&gt;as&lt;/code&gt; 保存しようとする試み鋳造、&lt;em&gt;数値&lt;/em&gt;値ではなく、ビット単位の値。</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">この関数は、代わりにスライスの操作に特化している&lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;を除いて、extendと同じです。Rustが特殊化された場合、この関数は非推奨になる可能性があります（まだ使用可能です）。</target>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">この関数はスプリアスウェイクアップの影響を受けやすいことに注意してください。条件変数は通常、それらに関連付けられたブール値の述語を持ち、この関数が戻るたびに述語を常にチェックして、スプリアスなウェイクアップから保護しなければなりません。</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">この関数は、解決が実行されている間、現在のスレッドをブロックする可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">これはWindows-1252別名コードページ1252 と&lt;em&gt;も&lt;/em&gt;異なることに注意してください。これは、句読点やさまざまなラテン文字に一部（すべてではない）の空白を割り当てるスーパーセットISO / IEC 8859-1です。</target>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">これがあることに注意し&lt;em&gt;ていない&lt;/em&gt;左回転と同じ。左シフトラッピングのRHSは、LHSからシフトアウトされたビットがもう一方の端に返されるのではなく、型の範囲に制限されます。プリミティブ整数型はすべて &lt;code&gt;rotate_left&lt;/code&gt; 関数を実装しますが、これは代わりに必要な機能です。</target>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">これは右回転と同じでは&lt;em&gt;ない&lt;/em&gt;ことに注意してください。右シフトラッピングのRHSは、LHSからシフトアウトされたビットがもう一方の端に返されるのではなく、型の範囲に制限されます。プリミティブ整数型はすべて &lt;code&gt;rotate_right&lt;/code&gt; 関数を実装しますが、これは代わりに必要な機能です。</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">これは、ISO/IEC 8859-1 a.k.a.ISO 8859-1(ハイフンが1つ少ない)とは異なることに注意してください。ISO-8859-1 (IANA のもの)は、C0 および C1 制御コードにそれらを割り当てます。</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">これはまだ完全にはサポートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">このリストは、将来的に明確化されていくにつれて、時間の経過とともに修正されていく可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">IPv6ソケットには影響がない場合がありますのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ではなく &lt;code&gt;&amp;amp;self&lt;/code&gt; を取る場合でも、基になるファイルの内容を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ではなく &lt;code&gt;&amp;amp;self&lt;/code&gt; を取る場合でも、基礎となるファイルの権限を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">このメソッドは、返されたレイアウトの配置が異なるかどうかに関係なく、全体のサイズにパディングを追加しないことに注意してください。言い換えれば、 &lt;code&gt;K&lt;/code&gt; は、サイズ16を有し、 &lt;code&gt;K.align_to(32)&lt;/code&gt; であろう&lt;em&gt;まだ&lt;/em&gt;サイズ16を有します。</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">このメソッドは、文字列</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">この方法は、ベクタの割り当てられた容量には影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">このような構造であることを注意&lt;strong&gt;しない&lt;/strong&gt; &lt;code&gt;repr(C)&lt;/code&gt; とFFI機能の署名に配置することは推奨されません。代わりに、FFI関数の安全なラッパーは、安全でない&lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; &lt;/a&gt;コンストラクターを利用して、他のコンシューマーに安全なインターフェイスを提供できます。</target>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">このテクニックは、マッチした表現の腕にも使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">これにより、過剰な容量がなくなることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; とは異なり、この関数はstdinを削除しようとしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">配列式とは異なり、この構文は&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;を実装するすべての要素をサポートし、要素の数は定数である必要はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">非サイズ化型は、その長さやvtableなどではなく、生データポインタのみを考慮するため、多くの可能性のあるNULLポインタを持っていることに注意してください。したがって、NULLである2つのポインタは、互いに等しい比較ができない場合があります。</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">この方法で &lt;code&gt;self&lt;/code&gt; を使用することは、将来必要なくなるかもしれないことに注意してください。Rust開発者が排除するために取り組んでいるのは、言語の不整合です。</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; は型エイリアスを導入するだけなので、 &lt;code&gt;type&lt;/code&gt; キーワードを使用してもここでは機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">手動で指定された判別器を持たない variant は上から下に 0 から始まる番号が付けられているので、一見無関係に見える variant との衝突が起こる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">ここで型注釈を追加したことに注意してください。このベクトルには値を挿入していないため、Rustはどのような種類の要素を格納するかを認識していません。これは重要なポイントです。ベクトルはジェネリックを使用して実装されます。ジェネリックを独自の型で使用する方法については、第10章で説明します。現時点では、標準ライブラリによって提供される &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 型は任意の型を保持でき、特定のベクトルが特定の型を保持する場合、型は山カッコ内に指定します。リスト7-1では、 &lt;code&gt;v&lt;/code&gt; の &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; が &lt;code&gt;i32&lt;/code&gt; 型の要素を保持することをRustに伝えました。</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">ブール値を保持する &lt;code&gt;case_sensitive&lt;/code&gt; フィールドを追加したことに注意してください。次に、リスト12-22に示すように、 &lt;code&gt;run&lt;/code&gt; 関数で &lt;code&gt;case_sensitive&lt;/code&gt; フィールドの値を確認し、それを使用して &lt;code&gt;search&lt;/code&gt; 関数と &lt;code&gt;search_case_insensitive&lt;/code&gt; 関数のどちらを呼び出すかを決定する必要があります。これはまだコンパイルされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">結果の &lt;code&gt;split_at_mut&lt;/code&gt; 関数を &lt;code&gt;unsafe&lt;/code&gt; としてマークする必要はなく、安全なRustからこの関数を呼び出すことができることに注意してください。 &lt;code&gt;unsafe&lt;/code&gt; 方法で安全でないコードを使用する関数の実装により、この関数がアクセスできるデータから有効なポインタのみを作成するため、安全でないコードに対する安全な抽象化を作成しました。</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; を &lt;code&gt;impl&lt;/code&gt; の直後に宣言する必要があることに注意してください。これを使用して、タイプ &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; メソッドを実装していることを指定できます。 &lt;code&gt;T&lt;/code&gt; を &lt;code&gt;impl&lt;/code&gt; の後にジェネリック型として宣言することにより、Rustは &lt;code&gt;Point&lt;/code&gt; の山括弧内の型が具象型ではなくジェネリック型であることを識別できます。</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;to_string&lt;/code&gt; という名前の使用可能な関数が複数あるため、&lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;「高度な特性」の&lt;/a&gt;セクションで前述した完全修飾構文を使用する必要があることに注意してください。ここでは、 &lt;code&gt;ToString&lt;/code&gt; トレイトで定義されている &lt;code&gt;to_string&lt;/code&gt; 関数を使用しています。これは、標準ライブラリが &lt;code&gt;Display&lt;/code&gt; を実装するすべての型に対して実装しています。</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">第10章で説明したように、このメソッドには有効期間アノテーションが必要です。 &lt;code&gt;post&lt;/code&gt; への参照を引数として取り、その &lt;code&gt;post&lt;/code&gt; 一部への参照を返すため、返される参照の有効期間は、 &lt;code&gt;post&lt;/code&gt; 引数の存続期間。</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">最初に、標準ライブラリのコレクション部分の &lt;code&gt;HashMap&lt;/code&gt; を &lt;code&gt;use&lt;/code&gt; する必要があることに注意してください。3つの一般的なコレクションのうち、これは最も使用頻度が低いため、プレリュードで自動的にスコープに組み込まれる機能には含まれていません。また、ハッシュマップは標準ライブラリからのサポートが少なくなっています。たとえば、それらを構築するための組み込みマクロはありません。</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">左側に &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 必要だったことに注意してください。これは、代わりに、たとえば&lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;に収集できるためです。</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">&lt;code&gt;v1_iter&lt;/code&gt; を変更可能にする必要があることに注意してください。イテレーターで &lt;code&gt;next&lt;/code&gt; メソッドを呼び出すと、イテレーターがシーケンス内の場所を追跡するために使用する内部状態が変更されます。つまり、このコードはイテレータを&lt;em&gt;消費する&lt;/em&gt;か、使い果たします。 &lt;code&gt;next&lt;/code&gt; を呼び出すたびに、イテレータのアイテムがすべて消費されます。 &lt;code&gt;for&lt;/code&gt; ループを使用するときに &lt;code&gt;v1_iter&lt;/code&gt; を変更可能にする必要はありませんでした。ループが &lt;code&gt;v1_iter&lt;/code&gt; の所有権を取得し、舞台裏で変更可能にするためです。</target>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">&lt;code&gt;longest&lt;/code&gt; 関数がパラメーターの所有権を取得することを望まないため、関数が参照である文字列スライスを取得することに注意してください。私たちは、関数がのスライス受け入れることを可能にしたい &lt;code&gt;String&lt;/code&gt; （タイプが変数に格納された &lt;code&gt;string1&lt;/code&gt; （可変のものです）だけでなく、文字列リテラル &lt;code&gt;string2&lt;/code&gt; 含まれているが）。</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;tests&lt;/code&gt; モジュール内に新しい行を追加したことに注意してください &lt;code&gt;use super::*;&lt;/code&gt; 。 &lt;code&gt;tests&lt;/code&gt; モジュールは、私たちは第7章で取り上げ通常の可視性の規則は次の定期的なモジュールである&lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;「プライバシー境界としてモジュール」&lt;/a&gt;のセクションを。ので &lt;code&gt;tests&lt;/code&gt; モジュールは、内部モジュールであり、我々は内部のモジュールのスコープに外側のモジュールにテスト中のコードを持参する必要があります。ここではグロブを使用しているため、外部モジュールで定義したものはすべて、この &lt;code&gt;tests&lt;/code&gt; モジュールで使用できます。</target>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">古いテストの &lt;code&gt;contents&lt;/code&gt; も編集したことに注意してください。 &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; というテキストを含む新しい行を追加しました。大文字と小文字を区別して検索する場合は、クエリ &lt;code&gt;&quot;duct&quot;&lt;/code&gt; と一致しない大文字のDを使用します。このように古いテストを変更することで、すでに実装されている大文字と小文字を区別する検索機能を誤って壊さないようにすることができます。このテストは今はパスするはずですが、大文字と小文字を区別しない検索に取り組んでいる間はパスし続けるはずです。</target>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">結合が発生する場合、&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;は一般に&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;よりも高速になり、&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;は一般に&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;よりも高速になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Rustでは環境変数への同時アクセスは安全ですが、一部のプラットフォームでは、環境を検査するための本質的に安全ではないスレッドセーフではないAPIしか公開していないことに注意してください。その結果、安全ではない外部FFI関数の呼び出しを監査する際には、外部環境へのアクセスがRust内のアクセスと適切に同期されているかどうかを確認するために、特に注意が必要です。</target>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">&lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; の内容を変更または変更可能にエイリアス化しても問題ないことに注意してください（インバリアントを他の方法で適用する場合）、複数の &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; エイリアスを持つことは未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">この関数を使うと、メインスレッドの実行が終了したかどうかに関わらず、メインスレッドが終了すると新しいスレッドが停止することに注意してください。このプログラムからの出力は毎回少し違うかもしれませんが、以下のような感じになります。</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">書き込みを行うと、まだ書き込まれていない部分を指すようにスライスが更新されることに注意してください。完全に上書きされた場合、スライスは空になります。</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">&lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;は使用できないことに注意してください。&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;返さない関数の演算子。代わりに、&lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt;を呼び出すか、戻り値を &lt;code&gt;match&lt;/code&gt; して、考えられるエラーをキャッチできます。</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">。なお、読み取りと書き込みの方法が必要ですが、 &lt;code&gt;&amp;amp;mut File&lt;/code&gt; 理由のためのインタフェースで、&lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;のホルダー &lt;code&gt;&amp;amp;File&lt;/code&gt; はまだどちらか取る方法で、ファイルを変更することができます &lt;code&gt;&amp;amp;File&lt;/code&gt; または基礎OSのオブジェクトを取得し、ファイルを変更することによって、そのように。さらに、多くのオペレーティングシステムでは、異なるプロセスによるファイルの同時変更が可能です。 &lt;code&gt;&amp;amp;File&lt;/code&gt; を保持することは、ファイルが変更されないことを意味すると想定しないでください。</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">&lt;code&gt;$crate&lt;/code&gt; は現在のクレートを参照するため、非マクロ項目を参照する場合は完全修飾モジュールパスで使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">同様に、なお &lt;code&gt;Option&lt;/code&gt; 列挙型、 &lt;code&gt;Result&lt;/code&gt; 、我々は指定する必要はありませんので、列挙型とその亜種は、前奏曲によってスコープ化されている &lt;code&gt;Result::&lt;/code&gt; 前に、 &lt;code&gt;Ok&lt;/code&gt; し、 &lt;code&gt;Err&lt;/code&gt; でバリアント &lt;code&gt;match&lt;/code&gt; 腕。</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">これ&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;は将来変更される可能性があることに&lt;/a&gt;注意してください。</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">そのノートとは異なり &lt;code&gt;repeat&lt;/code&gt; 、 &lt;code&gt;repeat_packed&lt;/code&gt; の繰り返しインスタンスことを保証するものではありません。 &lt;code&gt;self&lt;/code&gt; の特定のインスタンス場合でも、適切に配置され &lt;code&gt;self&lt;/code&gt; 適切に配置されます。つまり、 &lt;code&gt;repeat_packed&lt;/code&gt; によって返されたレイアウトを使用して配列を割り当てる場合、配列内のすべての要素が適切に配置されるとは限りません。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">そのことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">プリミティブ&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt;（「スライス」とも呼ばれる）のドキュメントに注意してください。&lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;多くのメソッド呼び出しは、実際には、それぞれ&lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref型強制による&lt;/a&gt;&lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; の&lt;/a&gt;メソッドの呼び出しです。</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">実装者への注意事項</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">実装者への注意：これが &lt;code&gt;Ok(ptr)&lt;/code&gt; を返す場合、 &lt;code&gt;ptr&lt;/code&gt; は「現在割り当てられている」と &lt;code&gt;dealloc&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; がサイズがゼロのタイプで&lt;em&gt;あっても&lt;/em&gt;、 &lt;code&gt;realloc&lt;/code&gt; やdeallocなどのメソッドへの入力として受け入れられる必要があります。つまり、 &lt;code&gt;Alloc&lt;/code&gt; 実装がサイズがゼロの &lt;code&gt;ptr&lt;/code&gt; を返すことができる方法でこのメソッドをオーバーライドする場合、そのような値を入力として受け入れるには、すべての再割り当ておよび割り当て解除メソッドを同様にオーバーライドする必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ここで2つの詳細に注意してください。最初に、インデックス値 &lt;code&gt;2&lt;/code&gt; を使用して3番目の要素を取得します。ベクトルには、ゼロから始まる番号でインデックスが付けられます。次に、3番目の要素を取得する2つの方法は、参照を提供する &lt;code&gt;&amp;amp;&lt;/code&gt; および &lt;code&gt;[]&lt;/code&gt; を使用する方法と、引数として渡されたインデックスを使用して &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; を提供する &lt;code&gt;get&lt;/code&gt; メソッドを使用する方法です。</target>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">注、 &lt;code&gt;OsString&lt;/code&gt; と &lt;code&gt;OsStr&lt;/code&gt; は、内部で必ずしもプラットフォームにフォームのネイティブの文字列を保持していません。Unixでは、文字列は8ビット値のシーケンスとして保存されますが、Windowsでは、前述のように文字列は16ビット値に基づいて保存されますが、実際には、文字列は8ビット値のシーケンスとして保存され、 UTF-8の厳密なバリアント。これは、容量と長さの値を処理するときに理解するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">ただし、インスタントが&lt;strong&gt;安定&lt;/strong&gt;しているとは限りません。言い換えると、基礎となるクロックの各ティックは同じ長さではない可能性があります（たとえば、いくつかの秒は他よりも長い場合があります）。インスタントは前方にジャンプしたり、時間の遅れ（減速または加速）を経験したりしますが、後退することはありません。</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">ただし、同じ名前のアイテムは、重複しない固有の &lt;code&gt;impl&lt;/code&gt; ブロックで許可されています。</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">ただし、これは危険な特性ではないため、この特性が提供する簡潔な契約はありません。代わりに、壊れた不変条件が発生する可能性があり、 &lt;code&gt;catch_unwind&lt;/code&gt; する必要がある可能性があることをcatch_unwindのユーザーに警告するための「スピードバンプ」のようなものです。</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">多くの場合、 &lt;code&gt;str&lt;/code&gt; の &lt;code&gt;.parse()&lt;/code&gt; メソッドがより適切です。</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;Pin&lt;/code&gt; はターゲットへの &lt;code&gt;Deref&lt;/code&gt; も実装します。これは、内部値にアクセスするために使用できます。ただし、 &lt;code&gt;Deref&lt;/code&gt; は、 &lt;code&gt;Pin&lt;/code&gt; 自体の寿命ではなく、 &lt;code&gt;Pin&lt;/code&gt; の借用期間のみ存続する参照を提供します。この方法では、 &lt;code&gt;Pin&lt;/code&gt; を元の &lt;code&gt;Pin&lt;/code&gt; と同じ寿命のリファレンスに変えることができます。</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;Pin&lt;/code&gt; はデータに &lt;code&gt;DerefMut&lt;/code&gt; も実装します。これは、内部値にアクセスするために使用できます。ただし、 &lt;code&gt;DerefMut&lt;/code&gt; は、 &lt;code&gt;Pin&lt;/code&gt; 自体の寿命ではなく、 &lt;code&gt;Pin&lt;/code&gt; の借用期間のみ存続するリファレンスを提供します。この方法では、 &lt;code&gt;Pin&lt;/code&gt; を元の &lt;code&gt;Pin&lt;/code&gt; と同じ寿命のリファレンスに変えることができます。</target>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">注： &lt;code&gt;fold()&lt;/code&gt; 、および反復子全体をトラバースする同様のメソッドは、結果が有限時間で決定可能な特性であっても、無限イテレーターで終了しない場合があります。</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">注： &lt;code&gt;move&lt;/code&gt; クロージャーは、moveによって変数をキャプチャしても、&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; を&lt;/a&gt;実装する場合があります。これは、クロージャタイプによって実装される特性は、クロージャがキャプチャする方法ではなく、キャプチャする値をどのように処理するかによって決定されるためです。</target>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">注： &lt;code&gt;rustc&lt;/code&gt; は現在、ツール「clippy」と「rustfmt」を認識しています。</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">注： &lt;code&gt;rustc&lt;/code&gt; には、各ターゲットおよびCPUに対して有効になっているデフォルトの機能セットがあります。CPUは、&lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt;フラグで選択できます。&lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt;フラグを使用して、クレート全体で個々の機能を有効または無効にできます。</target>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">注：HaskellやRustなどの厳格なコンパイラーを備えた言語について耳にするかもしれないことわざは、「コードがコンパイルされれば機能する」ということです。しかし、このことわざは普遍的には真実ではありません。私たちのプロジェクトはコンパイルされますが、まったく何もしません！実際の完全なプロジェクトを構築している場合は、ユニットテストを記述して、コードがコンパイルされ&lt;em&gt;、&lt;/em&gt;必要な動作をしていることを確認する良い機会です。</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">注:Rust は他の言語と同様にインタプリタやコンパイラで実装することができますが、既存の実装はコンパイラのみであり、言語は常にコンパイルされるように設計されています。これらの理由から、このセクションではコンパイラを想定しています。</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">注：表現がアイテムの属性であるため、表現はジェネリックパラメーターに依存しません。同じ名前の2つのタイプは、同じ表現を持っています。たとえば、 &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; と &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; どちらも同じ表現です。</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">注：制御フロー式として、ブロック式が式ステートメントの外部式である場合、セミコロンが直後に続かない限り、予期されるタイプは &lt;code&gt;()&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">注意:lintsを除いて、関数項目には外部属性のみを使用するのが慣用的です。</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">注：明確にするために、コードベースがRust 1.26以下でのコンパイルをサポートしていない限り、特性オブジェクトでは常に &lt;code&gt;dyn&lt;/code&gt; キーワードを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">注： &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; タイプの実装の詳細については、https：//doc.rust-lang.org/stable/nomicon/vec.htmlの「The Rustonomicon」を参照してください。</target>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">注：簡単にするため、我々は問題の多くを参照してくださいよ&lt;em&gt;、同時&lt;/em&gt;ではなく言って、より正確なものよりも、&lt;em&gt;同時および/または並列&lt;/em&gt;。この本が並行性および/または並列性に関するものであった場合、より具体的になります。この章では、精神的に置き換えてください&lt;em&gt;同時および/または平行&lt;/em&gt;我々が使用する時はいつでも&lt;em&gt;同時&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">注：関数は、 &lt;code&gt;Fn&lt;/code&gt; トレイトの3つすべてを実装することもできます。環境から値を取得する必要がない場合は、 &lt;code&gt;Fn&lt;/code&gt; トレイトを実装するものが必要なクロージャーではなく、関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">注：Gitは一般的なバージョン管理システムです。 &lt;code&gt;--vcs&lt;/code&gt; フラグを使用すると、 &lt;code&gt;cargo new&lt;/code&gt; に変更して、異なるバージョン管理システムを使用するか、バージョン管理システムを使用しないようにすることができます。使用可能なオプションを確認するには、 &lt;code&gt;cargo new --help&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">注：歴史的に、場所式は&lt;em&gt;左辺値&lt;/em&gt;と呼ばれ、値式は&lt;em&gt;右辺&lt;/em&gt;値と呼ばれてい&lt;em&gt;ました&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">注： &lt;code&gt;PeekMut&lt;/code&gt; 値がリークしている場合は、ヒープが不整合な状態になっている可能性があります。</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">注：何らかの理由で &lt;code&gt;rustup&lt;/code&gt; を使用したくない場合は&lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;、Rustのインストールページ&lt;/a&gt;で他のオプションを確認してください。</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">注：C ++では、アイテムのライフタイムの終わりにリソースを割り当て解除するこのパターンは、「&lt;em&gt;リソース獲得は初期化（RAII）」&lt;/em&gt;と呼ばれることがあります。Rust の &lt;code&gt;drop&lt;/code&gt; 機能は、RAIIパターンを使用したことがあればおなじみです。</target>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">注：一般に、融合イテレーターが必要な場合は、汎用境界で &lt;code&gt;FusedIterator&lt;/code&gt; を使用しないでください。代わりに、&lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt;を呼び出すだけです。イテレーターがすでに融合されている場合、追加の&lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt;ラッパーは何もせず、パフォーマンスが低下しません。</target>
        </trans-unit>
        <trans-unit id="3a4be906ba1df5fea075ac60c84354ab807a7ba2" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;code&gt;Err&lt;/code&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;SeekFrom::Current(n)&lt;/code&gt; でシークするエッジケースで、 &lt;code&gt;n&lt;/code&gt; から内部バッファー長を引いたものが &lt;code&gt;i64&lt;/code&gt; をオーバーフローすると、1回ではなく2回のシークが実行されます。2番目のシークが &lt;code&gt;Err&lt;/code&gt; を返す場合、基になるリーダーは、 &lt;code&gt;SeekFrom::Current(0)&lt;/code&gt; &lt;code&gt;seek&lt;/code&gt; を呼び出した場合と同じ位置に残ります。</target>
        </trans-unit>
        <trans-unit id="ffeb95a03330faff30434eb464fab2ecfe395aa0" translate="yes" xml:space="preserve">
          <source>Note: It is idiomatic to use a &lt;a href=&quot;../statements#let-statements&quot;&gt;let statement&lt;/a&gt; with a pattern of &lt;code&gt;_&lt;/code&gt; when a must-used value is purposely discarded.</source>
          <target state="translated">注：使用する必要のある値を意図的に破棄する場合、 &lt;code&gt;_&lt;/code&gt; のパターンで&lt;a href=&quot;../statements#let-statements&quot;&gt;letステートメント&lt;/a&gt;を使用するのは慣用的です。</target>
        </trans-unit>
        <trans-unit id="a98353ad4c2ea48db43b41e0a837834f6a8b30a0" translate="yes" xml:space="preserve">
          <source>Note: Lifetimes can be and usually are elided with this shorthand.</source>
          <target state="translated">注:寿命はこの速記法で省略されることがあり、通常は省略されます。</target>
        </trans-unit>
        <trans-unit id="9458a465758bdea1aa806edbdf38d0829ff7abbc" translate="yes" xml:space="preserve">
          <source>Note: Multiple matches using the &lt;code&gt;|&lt;/code&gt; operator can cause the pattern guard and the side effects it has to execute multiple times. For example:</source>
          <target state="translated">注： &lt;code&gt;|&lt;/code&gt; を使用した複数の一致 演算子は、パターンガードとそれが複数回実行する必要がある副作用を引き起こす可能性があります。例えば：</target>
        </trans-unit>
        <trans-unit id="b48aac9382dceff2ad2732e0844fc1d124e5afbe" translate="yes" xml:space="preserve">
          <source>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the &lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;&amp;ldquo;Storing UTF-8 Encoded Text with Strings&amp;rdquo;&lt;/a&gt; section of Chapter 8.</source>
          <target state="translated">注：文字列スライス範囲のインデックスは、有効なUTF-8文字の境界で発生する必要があります。マルチバイト文字の途中に文字列スライスを作成しようとすると、プログラムはエラーで終了します。文字列スライスを導入するために、このセクションではASCIIのみを想定しています。UTF-8処理の詳細については、第8章の&lt;a href=&quot;ch08-02-strings#storing-utf-8-encoded-text-with-strings&quot;&gt;「文字列を含むUTF-8エンコードテキストの保存」&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="d0300d6a8e919cca08e1ab2c8db38b624e4574c2" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../../std/vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; standard library type provides a heap-allocated resizable array type.</source>
          <target state="translated">注：&lt;a href=&quot;../../std/vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;標準ライブラリタイプは、ヒープに割り当てられたサイズ変更可能な配列タイプを提供します。</target>
        </trans-unit>
        <trans-unit id="29d2f706dbf0a3794fd072f42986f2a9c440ff62" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;//&lt;/code&gt; syntax starts a comment that continues until the end of the line. Rust ignores everything in comments, which are discussed in more detail in Chapter 3.</source>
          <target state="translated">注： &lt;code&gt;//&lt;/code&gt; 構文は、行の終わりまで続くコメントを開始します。Rustはコメントのすべてを無視します。コメントについては第3章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="187085942721c7c78a8ec180c1642f4ed13694fc" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;2..=9&lt;/code&gt; is a &lt;a href=&quot;../patterns#range-patterns&quot;&gt;Range Pattern&lt;/a&gt;, not a &lt;a href=&quot;range-expr&quot;&gt;Range Expression&lt;/a&gt;. Thus, only those types of ranges supported by range patterns can be used in match arms.</source>
          <target state="translated">注： &lt;code&gt;2..=9&lt;/code&gt; は&lt;a href=&quot;../patterns#range-patterns&quot;&gt;範囲パターン&lt;/a&gt;ではなく、&lt;a href=&quot;range-expr&quot;&gt;範囲式&lt;/a&gt;です。したがって、範囲パターンでサポートされているタイプの範囲のみをマッチアームで使用できます。</target>
        </trans-unit>
        <trans-unit id="f039047f79b4edcb39be10eb9b4e9a5ff0260001" translate="yes" xml:space="preserve">
          <source>Note: The actual definition of the &lt;code&gt;vec!&lt;/code&gt; macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don&amp;rsquo;t include here to make the example simpler.</source>
          <target state="translated">注： &lt;code&gt;vec!&lt;/code&gt; の実際の定義！標準ライブラリのマクロには、正しい量のメモリを事前に割り当てるためのコードが含まれています。このコードは、例を簡単にするためにここでは含めない最適化です。</target>
        </trans-unit>
        <trans-unit id="130fc90f1f7559f295e76dc148708d583a3eb9e9" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 1048576.</source>
          <target state="translated">注： &lt;code&gt;rustc&lt;/code&gt; のデフォルトは1048576です。</target>
        </trans-unit>
        <trans-unit id="a3d9efde740053cef26656af7a7f6ab7316f24e6" translate="yes" xml:space="preserve">
          <source>Note: The default in &lt;code&gt;rustc&lt;/code&gt; is 64.</source>
          <target state="translated">注： &lt;code&gt;rustc&lt;/code&gt; のデフォルトは64です。</target>
        </trans-unit>
        <trans-unit id="8180c8df8ae11541f19b00a561591d13760a8ee6" translate="yes" xml:space="preserve">
          <source>Note: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">注意:イテレータが最後まで消費されない場合でも、要素範囲は削除されます。</target>
        </trans-unit>
        <trans-unit id="9f4fea507ec4e68a49f42af2c77e67668a288392" translate="yes" xml:space="preserve">
          <source>Note: The enum representation in C is implementation defined, so this is really a &quot;best guess&quot;. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</source>
          <target state="translated">注意:C の enum 表現は実装で定義されているので、これは実際には「最善の推測」です。特に、対象となるC言語のコードが特定のフラグでコンパイルされている場合、これは正しくないかもしれません。</target>
        </trans-unit>
        <trans-unit id="4cee4fb70834d29d39a99e3fa46a091ae845a20c" translate="yes" xml:space="preserve">
          <source>Note: The examples above used to be (erroneously) accepted by the compiler, but this was since corrected. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;issue #33685&lt;/a&gt; for more details.</source>
          <target state="translated">注：上記の例はコンパイラーによって（誤って）受け入れられていましたが、これは修正されました。詳細については、&lt;a href=&quot;https://github.com/rust-lang/rust/issues/33685&quot;&gt;問題＃33685&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="daadbb2b1b33b48dcd9e6359e7eecc90c0e80c1e" translate="yes" xml:space="preserve">
          <source>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust&amp;rsquo;s having no null values. However, if we try to use a variable before giving it a value, we&amp;rsquo;ll get a compile-time error, which shows that Rust indeed does not allow null values.</source>
          <target state="translated">注：リスト10-17、10-18、および10-24の例では、初期値を指定せずに変数を宣言しているため、変数名は外部スコープに存在します。一見すると、これはRustのnull値がないことに矛盾しているように見えるかもしれません。ただし、値を指定する前に変数を使用しようとすると、コンパイル時エラーが発生します。これは、Rustが実際にnull値を許可していないことを示しています。</target>
        </trans-unit>
        <trans-unit id="50e01f1ed4a46f62a5d14f0b5fa9d8b4796d1c64" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">注：許可される戻り型の実装は、不安定な&lt;a href=&quot;../../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt;特性によって決定されます。</target>
        </trans-unit>
        <trans-unit id="788f6375fff581af876a714c5f38068ea6a94a60" translate="yes" xml:space="preserve">
          <source>Note: The implementation of which return types are allowed is determined by the unstable &lt;a href=&quot;../std/process/trait.termination&quot;&gt;&lt;code&gt;Termination&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">注：許可される戻り型の実装は、不安定な&lt;a href=&quot;../std/process/trait.termination&quot;&gt; &lt;code&gt;Termination&lt;/code&gt; &lt;/a&gt;特性によって決定されます。</target>
        </trans-unit>
        <trans-unit id="40b1e975f4973c7f7bd859ba82ec6ff70298303a" translate="yes" xml:space="preserve">
          <source>Note: The lint checks supported by &lt;code&gt;rustc&lt;/code&gt; can be found via &lt;code&gt;rustc -W help&lt;/code&gt;, along with their default settings and are documented in the &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustc book&lt;/a&gt;.</source>
          <target state="translated">注： &lt;code&gt;rustc&lt;/code&gt; でサポートされているlintチェックは、rustc &lt;code&gt;rustc -W help&lt;/code&gt; とそのデフォルト設定で確認でき、&lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/index.html&quot;&gt;rustcブックに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="5df3cfb866cdb5ad3722ea9687c561d88d29727a" translate="yes" xml:space="preserve">
          <source>Note: The next section assumes you&amp;rsquo;ve read the earlier section &lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;&amp;ldquo;Using the Newtype Pattern to Implement External Traits on External Types.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">注：次のセクションは、前のセクション&lt;a href=&quot;ch19-03-advanced-traits#using-the-newtype-pattern-to-implement-external-traits-on-external-types&quot;&gt;「Newtypeパターンを使用して外部型に外部特性を実装する」を&lt;/a&gt;読んでいることを前提としています。</target>
        </trans-unit>
        <trans-unit id="7007864547a1ff842641db1454a617feb860ba4c" translate="yes" xml:space="preserve">
          <source>Note: The opposite of referencing by using &lt;code&gt;&amp;amp;&lt;/code&gt; is &lt;em&gt;dereferencing&lt;/em&gt;, which is accomplished with the dereference operator, &lt;code&gt;*&lt;/code&gt;. We&amp;rsquo;ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</source>
          <target state="translated">注： &lt;code&gt;&amp;amp;&lt;/code&gt; を使用した参照の反対は&lt;em&gt;逆参照です&lt;/em&gt;。これは逆参照演算子 &lt;code&gt;*&lt;/code&gt; を使用して実行されます。第8章では逆参照演算子のいくつかの使用法を示し、第15章では逆参照の詳細について説明します。</target>
        </trans-unit>
        <trans-unit id="a0cacc6a55793cf1996cae56b2d43488d313d554" translate="yes" xml:space="preserve">
          <source>Note: The semicolon following a statement is not a part of the statement itself. They are invalid when using the &lt;code&gt;stmt&lt;/code&gt; macro matcher.</source>
          <target state="translated">注：ステートメントに続くセミコロンは、ステートメント自体の一部ではありません。 &lt;code&gt;stmt&lt;/code&gt; マクロマッチャーを使用する場合は無効です。</target>
        </trans-unit>
        <trans-unit id="ebd41440d85e280e6b8e0940e9eb1baf556c6663" translate="yes" xml:space="preserve">
          <source>Note: The test mode is enabled by passing the &lt;code&gt;--test&lt;/code&gt; argument to &lt;code&gt;rustc&lt;/code&gt; or using &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">注：テストモードを有効にするには、-- &lt;code&gt;--test&lt;/code&gt; 引数を &lt;code&gt;rustc&lt;/code&gt; に渡すか、 &lt;code&gt;cargo test&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a7281566219ec90e2a7e767d6f73d5379e3c0db2" translate="yes" xml:space="preserve">
          <source>Note: This algorithm can produce zero-sized structs. This differs from C where structs without data still have a size of one byte.</source>
          <target state="translated">注意:このアルゴリズムは、ゼロサイズの構造体を生成できます。これは、データのない構造体が 1 バイトのサイズを持つ C とは異なります。</target>
        </trans-unit>
        <trans-unit id="84916df8964c95c521b7aa5c595fc0771cbfc9af" translate="yes" xml:space="preserve">
          <source>Note: This book assumes basic familiarity with the command line. Rust makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. Many IDEs now have some degree of Rust support; check the IDE&amp;rsquo;s documentation for details. Recently, the Rust team has been focusing on enabling great IDE support, and progress has been made rapidly on that front!</source>
          <target state="translated">注：この本は、コマンドラインの基本的な知識があることを前提としています。Rustは、編集やツール、またはコードの場所について特別な要求をしません。そのため、コマンドラインではなく統合開発環境（IDE）を使用したい場合は、お好みのIDEを使用してください。現在、多くのIDEはある程度のRustをサポートしています。詳細については、IDEのドキュメントを確認してください。最近、Rustチームは優れたIDEサポートの有効化に力を入れており、その面で急速に進歩しています！</target>
        </trans-unit>
        <trans-unit id="5ac1eb98b0f589191a31e26db76121648795b41e" translate="yes" xml:space="preserve">
          <source>Note: This edition of the book is the same as &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language&lt;/a&gt; available in print and ebook format from &lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;.</source>
          <target state="translated">注：本のこの版は、&lt;a href=&quot;https://nostarch.com/&quot;&gt;No Starch Press&lt;/a&gt;から印刷および電子ブック形式で入手可能な&lt;a href=&quot;https://nostarch.com/rust&quot;&gt;The Rust Programming Language&lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="12f5db48053663ec58249f015893f0934fb3f9cb" translate="yes" xml:space="preserve">
          <source>Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be used to get a string slice under normal circumstances. Use &lt;code&gt;as_slice&lt;/code&gt; instead.</source>
          <target state="translated">注：この例は、 &lt;code&gt;&amp;amp;str&lt;/code&gt; の内部を示しています。 &lt;code&gt;unsafe&lt;/code&gt; を使用して、通常の状況で文字列スライスを取得することはできません。代わりに &lt;code&gt;as_slice&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="71c5367b5e1ca4ccf0bf834db2cd4b500fbdeb5c" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw &lt;code&gt;[T]&lt;/code&gt; type, not pointers (&lt;code&gt;&amp;amp;[T]&lt;/code&gt;, &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;, etc.) to slices.</source>
          <target state="translated">注：これは、スライスへのポインター（ &lt;code&gt;&amp;amp;[T]&lt;/code&gt; 、 &lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt; など）ではなく、生の &lt;code&gt;[T]&lt;/code&gt; タイプに関するものです。</target>
        </trans-unit>
        <trans-unit id="53274b0feb8252b3f7e0516cd656e66a12715d39" translate="yes" xml:space="preserve">
          <source>Note: This is about the raw trait object types, not pointers (&lt;code&gt;&amp;amp;Trait&lt;/code&gt;, &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, etc.) to trait objects.</source>
          <target state="translated">注：これは、生の特性オブジェクトタイプに関するものであり、特性オブジェクトへのポインタ（ &lt;code&gt;&amp;amp;Trait&lt;/code&gt; 、 &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; など）ではありません。</target>
        </trans-unit>
        <trans-unit id="3efbe622a99893d160a87ba1b5dbe54cdc04b646" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in argument position&quot;.</source>
          <target state="translated">注:これはよく「引数位置での impl Trait」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="ebd18dc0abe826773a124050720a5e27942c51e0" translate="yes" xml:space="preserve">
          <source>Note: This is often called &quot;impl Trait in return position&quot;.</source>
          <target state="translated">注:これはよく「戻り位置での impl Trait」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="dcf4aae415a3e26a6bf431396708d40ea1b5d658" translate="yes" xml:space="preserve">
          <source>Note: This macro can be used in &lt;code&gt;no_std&lt;/code&gt; setups as well. In a &lt;code&gt;no_std&lt;/code&gt; setup you are responsible for the implementation details of the components.</source>
          <target state="translated">注：このマクロは、 &lt;code&gt;no_std&lt;/code&gt; セットアップでも使用できます。で &lt;code&gt;no_std&lt;/code&gt; セットアップあなたは、コンポーネントの実装の詳細を担当しています。</target>
        </trans-unit>
        <trans-unit id="3ba312fede1a13f53566373763f2cc827d3cc6a0" translate="yes" xml:space="preserve">
          <source>Note: This may call the function multiple times if the value has been changed from other threads in the meantime, as long as the function returns &lt;code&gt;Some(_)&lt;/code&gt;, but the function will have been applied but once to the stored value.</source>
          <target state="translated">注：関数が &lt;code&gt;Some(_)&lt;/code&gt; を返す限り、値が他のスレッドから変更されている間は、関数が複数回呼び出される可能性がありますが、関数は適用されますが、格納された値に1回適用されます。</target>
        </trans-unit>
        <trans-unit id="239a5948be38f752de16eb5b0ffe5444c5d1e29d" translate="yes" xml:space="preserve">
          <source>Note: This section is a placeholder for more comprehensive reference material.</source>
          <target state="translated">注:このセクションは、より包括的な参考資料のプレースホルダです。</target>
        </trans-unit>
        <trans-unit id="5b012ed05fd45d1a0619d2a532517a96144ac5c9" translate="yes" xml:space="preserve">
          <source>Note: This section is described more in terms of the compiler than of the language.</source>
          <target state="translated">注:このセクションでは、言語よりもコンパイラの観点から説明しています。</target>
        </trans-unit>
        <trans-unit id="3b7a991aa3513a216522c1b812051b6fd94ca027" translate="yes" xml:space="preserve">
          <source>Note: Though you should not rely on this, all pointers to</source>
          <target state="translated">注:これに頼るべきではありませんが、すべてのポインタは</target>
        </trans-unit>
        <trans-unit id="ccec92c826b382bbeb8d0f3b3ce8f2aff5320851" translate="yes" xml:space="preserve">
          <source>Note: Traits are similar to a feature often called &lt;em&gt;interfaces&lt;/em&gt; in other languages, although with some differences.</source>
          <target state="translated">注：特性は、いくつかの違いはあり&lt;em&gt;ますが&lt;/em&gt;、他の言語では&lt;em&gt;インターフェース&lt;/em&gt;と呼ばれることが多い機能に似ています。</target>
        </trans-unit>
        <trans-unit id="0ff8579bff78c963092559227a81a969d9708ad7" translate="yes" xml:space="preserve">
          <source>Note: Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement &lt;a href=&quot;../special-types-and-traits#drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; and then not using that type and being the final expression of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block expression&lt;/a&gt; that is not used.</source>
          <target state="translated">注：値を含む単純な何もしない式は、lintに違反しません。例としては、&lt;a href=&quot;../special-types-and-traits#drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;を実装しない型に値をラップしてから、その型を使用しないことや、使用されない&lt;a href=&quot;../expressions/block-expr&quot;&gt;ブロック式の&lt;/a&gt;最終式にすることなどがあります。</target>
        </trans-unit>
        <trans-unit id="eb186d5904a6ce9b777e0cf94b3203a9889bfac8" translate="yes" xml:space="preserve">
          <source>Note: Using primitive values when a complex type would be more appropriate is an anti-pattern known as &lt;em&gt;primitive obsession&lt;/em&gt;.</source>
          <target state="translated">注：複合型がより適切である場合にプリミティブ値を使用することは、&lt;em&gt;プリミティブオブセッションと&lt;/em&gt;呼ばれるアンチパターンです。</target>
        </trans-unit>
        <trans-unit id="04993cf7d2f50288aed55f19ed2ebc1756b87d27" translate="yes" xml:space="preserve">
          <source>Note: We&amp;rsquo;re implementing a cons list that holds only &lt;code&gt;i32&lt;/code&gt; values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</source>
          <target state="translated">注：この例では、 &lt;code&gt;i32&lt;/code&gt; 値のみを保持するconsリストを実装しています。第10章で説明したように、ジェネリックを使用して実装し、任意のタイプの値を格納できるconsリストタイプを定義することができます。</target>
        </trans-unit>
        <trans-unit id="9a9063f50fe88aae84e6d578aa20b9af4873e66f" translate="yes" xml:space="preserve">
          <source>Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.</source>
          <target state="translated">注:サイズのない強制力の定義とその実装は安定していますが、形質自体はまだ安定していないため、安定したRustで直接使用することはできません。</target>
        </trans-unit>
        <trans-unit id="2dfa6e64910004aadc24cb034a538f296b64dc2f" translate="yes" xml:space="preserve">
          <source>Note: Windows Portability Consideration</source>
          <target state="translated">参考:Windowsの移植性についての考察</target>
        </trans-unit>
        <trans-unit id="54ec2a3d57d83413137977409179cfe79c9797ac" translate="yes" xml:space="preserve">
          <source>Note: You won&amp;rsquo;t just know which traits to use and which methods and functions to call from a crate. Instructions for using a crate are in each crate&amp;rsquo;s documentation. Another neat feature of Cargo is that you can run the &lt;code&gt;cargo doc --open&lt;/code&gt; command, which will build documentation provided by all of your dependencies locally and open it in your browser. If you&amp;rsquo;re interested in other functionality in the &lt;code&gt;rand&lt;/code&gt; crate, for example, run &lt;code&gt;cargo doc --open&lt;/code&gt; and click &lt;code&gt;rand&lt;/code&gt; in the sidebar on the left.</source>
          <target state="translated">注：どのトレイトを使用するか、どのメソッドと関数をクレートから呼び出すかはわかりません。クレートの使用方法は、各クレートのドキュメントに記載されています。 Cargoのもう1つの優れた機能は、 &lt;code&gt;cargo doc --open&lt;/code&gt; コマンドを実行できることです。これにより、すべての依存関係によってローカルで提供されるドキュメントがビルドされ、ブラウザーで開きます。たとえば、 &lt;code&gt;rand&lt;/code&gt; クレートの他の機能に興味がある場合は、 &lt;code&gt;cargo doc --open&lt;/code&gt; を実行して、左側のサイドバーで &lt;code&gt;rand&lt;/code&gt; をクリックします。</target>
        </trans-unit>
        <trans-unit id="fa7e98c548306a32db0bad3d57bbd3a5f699aa40" translate="yes" xml:space="preserve">
          <source>Note: if you open &lt;em&gt;/sleep&lt;/em&gt; in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</source>
          <target state="translated">注：複数のブラウザーウィンドウで&lt;em&gt;/ sleep&lt;/em&gt;を同時に開いた場合、5秒間隔で一度に1つずつ読み込まれる可能性があります。一部のWebブラウザーは、キャッシュ上の理由から、同じ要求の複数のインスタンスを順番に実行します。この制限は、当社のWebサーバーが原因ではありません。</target>
        </trans-unit>
        <trans-unit id="94be0b88d71e4f4b09ff423fbdb3966a642ec68a" translate="yes" xml:space="preserve">
          <source>Note: only extended grapheme codepoints that begin the string will be escaped.</source>
          <target state="translated">注意:文字列の先頭にある拡張書記素コードポイントのみがエスケープされます。</target>
        </trans-unit>
        <trans-unit id="59ba94b4a0ce80567a5f66bf9563fcdf82240def" translate="yes" xml:space="preserve">
          <source>Note: the lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print &quot;In trait impl!&quot;, because &lt;code&gt;&amp;amp;self&lt;/code&gt; methods are looked up first, the trait method is found before the struct's &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method is found.</source>
          <target state="translated">注：検索はタイプごとに順番に行われるため、予期しない結果になる場合があります。以下のコードは、「In trait impl！」を出力します。 &lt;code&gt;&amp;amp;self&lt;/code&gt; メソッドが最初に検索されるため、構造体の &lt;code&gt;&amp;amp;mut self&lt;/code&gt; メソッドが検出される前に、traitメソッドが検出されます。</target>
        </trans-unit>
        <trans-unit id="c7cb38696a69ae9af0ae23e81e9d982ddfe77188" translate="yes" xml:space="preserve">
          <source>Note: the value returned by this method is unspecified after the range has been iterated to exhaustion.</source>
          <target state="translated">注意:このメソッドが返す値は、範囲を反復して使い切った後では不定です。</target>
        </trans-unit>
        <trans-unit id="aa3e5b7333a9df0d2dc6ac8acfc43125fde51982" translate="yes" xml:space="preserve">
          <source>Note: there&amp;rsquo;s one big difference between the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we&amp;rsquo;re about to build and the real &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: our version will not store its data on the heap. We are focusing this example on &lt;code&gt;Deref&lt;/code&gt;, so where the data is actually stored is less important than the pointer-like behavior.</source>
          <target state="translated">注：作成しようとしている &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; タイプと実際の &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 間には大きな違いが1つあります。このバージョンでは、データがヒープに格納されません。この例では &lt;code&gt;Deref&lt;/code&gt; に焦点を当てているため、データが実際に格納される場所は、ポインターのような動作ほど重要ではありません。</target>
        </trans-unit>
        <trans-unit id="0c580688b8d6e9090963bfacda97bc90a713c687" translate="yes" xml:space="preserve">
          <source>Note: this error code is no longer emitted by the compiler.</source>
          <target state="translated">注意:このエラー・コードは、もはやコンパイラからは発行されません。</target>
        </trans-unit>
        <trans-unit id="de79d60b5ae69ae8de10ccab3addf181d505537b" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注：これは関連する関数です。 &lt;code&gt;b.into_raw()&lt;/code&gt; 、b.into_raw（）ではなく &lt;code&gt;Box::into_raw(b)&lt;/code&gt; として呼び出す必要があります。これは、内部型のメソッドと競合しないようにするためです。</target>
        </trans-unit>
        <trans-unit id="9801006a2ac0b25e680ddaebb4a6a97fc9bd8dc1" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; instead of &lt;code&gt;b.into_raw_non_null()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注：これは関連する関数です。 &lt;code&gt;b.into_raw_non_null()&lt;/code&gt; 、b.into_raw_non_null（）ではなく &lt;code&gt;Box::into_raw_non_null(b)&lt;/code&gt; として呼び出す必要があります。これは、内部型のメソッドと競合しないようにするためです。</target>
        </trans-unit>
        <trans-unit id="b61290dcffaed8f71df5ea3435ea91289cbca703" translate="yes" xml:space="preserve">
          <source>Note: this is an associated function, which means that you have to call it as &lt;code&gt;Box::leak(b)&lt;/code&gt; instead of &lt;code&gt;b.leak()&lt;/code&gt;. This is so that there is no conflict with a method on the inner type.</source>
          <target state="translated">注：これは関連する関数です。 &lt;code&gt;b.leak()&lt;/code&gt; 、b.leak（）ではなく &lt;code&gt;Box::leak(b)&lt;/code&gt; として呼び出す必要があります。これは、内部型のメソッドと競合しないようにするためです。</target>
        </trans-unit>
        <trans-unit id="855408558daaf89b8b3b6445b95d7c1b8fc7ac9c" translate="yes" xml:space="preserve">
          <source>Note: while this type is unstable, the functionality it provides can be accessed through the &lt;a href=&quot;index#functions&quot;&gt;free functions in &lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注：この型は不安定ですが、それが提供する機能には&lt;a href=&quot;index#functions&quot;&gt;、 &lt;code&gt;alloc&lt;/code&gt; の&lt;/a&gt;無料の関数を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9ea884e20e19e59213993b5d483a5cae6c6deb6b" translate="yes" xml:space="preserve">
          <source>Notes about side effects</source>
          <target state="translated">副作用についての注意点</target>
        </trans-unit>
        <trans-unit id="0665801607b97f01a2cf09fef56752d404c94329" translate="yes" xml:space="preserve">
          <source>Notes and Safety</source>
          <target state="translated">注意事項と安全性</target>
        </trans-unit>
        <trans-unit id="5367ad0070e3b4dc018a1e98ba396857c9a89c8b" translate="yes" xml:space="preserve">
          <source>Notes that contain useful information about the state of the book or point out useful, but mostly out of scope, information are in blockquotes that start with the word &quot;Note:&quot; in &lt;strong&gt;bold&lt;/strong&gt;.</source>
          <target state="translated">本の状態に関する有用な情報が含まれている、または有用であると指摘されているが、主に範囲外の注記は、&lt;strong&gt;太字の&lt;/strong&gt;「注記：」で始まるブロック引用符で囲まれてい&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="343e2ff0e712d5880f73c89d0629c959a0cbc677" translate="yes" xml:space="preserve">
          <source>Nothing in Rust prevents a trait from having a method with the same name as another trait&amp;rsquo;s method, nor does Rust prevent you from implementing both traits on one type. It&amp;rsquo;s also possible to implement a method directly on the type with the same name as methods from traits.</source>
          <target state="translated">Rustには、トレイトが別のトレイトのメソッドと同じ名前のメソッドを持つことを妨げるものや、Rustが1つのタイプに両方のトレイトを実装することを妨げるものはありません。トレイトのメソッドと同じ名前のメソッドを直接型に実装することもできます。</target>
        </trans-unit>
        <trans-unit id="85a8ab9caff8306933eb7dd48f9cd08900551077" translate="yes" xml:space="preserve">
          <source>Notice in Listing 16-1 that the closure we pass to &lt;code&gt;thread::spawn&lt;/code&gt; takes no arguments: we&amp;rsquo;re not using any data from the main thread in the spawned thread&amp;rsquo;s code. To use data from the main thread in the spawned thread, the spawned thread&amp;rsquo;s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won&amp;rsquo;t yet work, as you&amp;rsquo;ll see in a moment.</source>
          <target state="translated">リスト16-1で、 &lt;code&gt;thread::spawn&lt;/code&gt; 渡すクロージャは引数を取らないことに注意してください。生成されたスレッドのコードでは、メインスレッドからのデータを使用していません。生成されたスレッドでメインスレッドからのデータを使用するには、生成されたスレッドのクロージャが必要な値をキャプチャする必要があります。リスト16-3は、メインスレッドでベクターを作成し、それをスポーンされたスレッドで使用する試みを示しています。ただし、これはすぐには機能しません。</target>
        </trans-unit>
        <trans-unit id="753a2ed5c1b14367e2086b1d9e2763add33258b6" translate="yes" xml:space="preserve">
          <source>Notice one interesting aspect of this particular execution: the &lt;code&gt;ThreadPool&lt;/code&gt; sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish. In the meantime, each of the workers received the termination messages. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all received the termination message and were able to shut down.</source>
          <target state="translated">この特定の実行の興味深い側面に注目してください &lt;code&gt;ThreadPool&lt;/code&gt; は終了メッセージをチャネルに送信し、ワーカーがメッセージを受信する前に、ワーカー0に参加しようとしました。ワーカー0はまだ終了メッセージを受信して​​いないため、メインスレッドは待機をブロックしましたワーカー0が終了します。その間、各ワーカーは終了メッセージを受け取りました。ワーカー0が終了すると、メインスレッドは残りのワーカーが終了するのを待ちました。その時点で、彼らはすべて終了メッセージを受け取り、シャットダウンすることができました。</target>
        </trans-unit>
        <trans-unit id="d88bd61c5288b6b4a4fab344b4f64355a8809dd2" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; has a &lt;code&gt;From&lt;/code&gt; instance for &lt;code&gt;&amp;amp;T&lt;/code&gt;. However, this does not change the fact that mutating through a (pointer derived from a) shared reference is undefined behavior unless the mutation happens inside an &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. The same goes for creating a mutable reference from a shared reference. When using this &lt;code&gt;From&lt;/code&gt; instance without an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;, it is your responsibility to ensure that &lt;code&gt;as_mut&lt;/code&gt; is never called, and &lt;code&gt;as_ptr&lt;/code&gt; is never used for mutation.</source>
          <target state="translated">&lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; は &lt;code&gt;&amp;amp;T&lt;/code&gt; の &lt;code&gt;From&lt;/code&gt; インスタンスがあることに注意してください。ただし、これは、変更が&lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;内で発生しない限り、共有参照（aから派生したポインター）による変更が未定義の動作であるという事実を変更しません。共有参照から変更可能な参照を作成する場合も同様です。 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; なしでこの &lt;code&gt;From&lt;/code&gt; インスタンスを使用する場合、 &lt;code&gt;as_mut&lt;/code&gt; が呼び出されないこと、および &lt;code&gt;as_ptr&lt;/code&gt; が変更に使用されないことを確認するのはユーザーの責任です。</target>
        </trans-unit>
        <trans-unit id="a4555814d84e265a1a37b6f84e64a162ac1d207e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;x&lt;/code&gt; is stack-allocated by &lt;code&gt;foo()&lt;/code&gt;. By default, Rust captures closed-over data by reference. This means that once &lt;code&gt;foo()&lt;/code&gt; returns, &lt;code&gt;x&lt;/code&gt; no longer exists. An attempt to access &lt;code&gt;x&lt;/code&gt; within the closure would thus be unsafe.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; は &lt;code&gt;foo()&lt;/code&gt; によってスタックに割り当てられることに注意してください。デフォルトでは、Rustは参照によって閉じられたデータをキャプチャします。つまり、 &lt;code&gt;foo()&lt;/code&gt; が戻ると、 &lt;code&gt;x&lt;/code&gt; は存在しなくなります。したがって、クロージャー内で &lt;code&gt;x&lt;/code&gt; にアクセスする試みは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="0e90ccdac3be23d4ae5fee41e5c9c069831f7aa8" translate="yes" xml:space="preserve">
          <source>Notice that being unblocked does not imply any synchronization with someone that unparked this thread, it could also be spurious. For example, it would be a valid, but inefficient, implementation to make both &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; return immediately without doing anything.</source>
          <target state="translated">ブロックが解除されても、このスレッドのパークを解除した誰かとの同期を意味するものではないことに注意してください。また、偽の可能性もあります。たとえば、何もせずに&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;とパーク&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;両方をすぐに返すことは、有効ですが非効率な実装です。</target>
        </trans-unit>
        <trans-unit id="a7aa95fb880edfba626d059a08ec359fcae43db0" translate="yes" xml:space="preserve">
          <source>Notice that in the case of &lt;code&gt;compare_and_swap&lt;/code&gt;, it is possible that the operation ends up not performing any store and hence it has just &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. However, &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; will never perform &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; accesses.</source>
          <target state="translated">&lt;code&gt;compare_and_swap&lt;/code&gt; の場合、操作がストアを実行せず、したがって&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;順序付けしているだけである可能性があることに注意してください。ただし、&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquirerelease&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;アクセスを実行しません。</target>
        </trans-unit>
        <trans-unit id="d68951af70c1b2b14c8581375aa37ef775c2c882" translate="yes" xml:space="preserve">
          <source>Notice that the code panicked with the message &lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt;. This is how &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; handles violations of the borrowing rules at runtime.</source>
          <target state="translated">&lt;code&gt;already borrowed: BorrowMutError&lt;/code&gt; れたメッセージBorrowMutErrorでコードがパニックになっていることに注意してください。これは、 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; が実行時に借用ルールの違反を処理する方法です。</target>
        </trans-unit>
        <trans-unit id="e6e01b202ce551c042845c38802ff1f31e6bfcd1" translate="yes" xml:space="preserve">
          <source>Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call &lt;code&gt;drop_in_place&lt;/code&gt; manually.</source>
          <target state="translated">パックされた構造体をドロップすると、コンパイラーがこのコピーを自動的に実行することに注意してください。つまり、 &lt;code&gt;drop_in_place&lt;/code&gt; を手動で呼び出さない限り、通常はそのような問題を心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="90e25cc098640b84fbba68a414a9fbb480dff45c" translate="yes" xml:space="preserve">
          <source>Notice that the first value in the vector is &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt;, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It&amp;rsquo;s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we&amp;rsquo;ll ignore it and save only the two arguments we need.</source>
          <target state="translated">ベクトルの最初の値は &lt;code&gt;&quot;target/debug/minigrep&quot;&lt;/code&gt; であることに注意してください。これはバイナリの名前です。これはCの引数リストの動作と一致し、プログラムは実行時に呼び出された名前をプログラムに使用できます。プログラムを呼び出すために使用されたコマンドラインエイリアスに基づいてメッセージに出力したり、プログラムの動作を変更したりする場合に備えて、プログラム名にアクセスできると便利です。ただし、この章では、この章を無視して、必要な2つの引数のみを保存します。</target>
        </trans-unit>
        <trans-unit id="a69330b1430c6944224f92b74bbe0967131daf2e" translate="yes" xml:space="preserve">
          <source>Notice that the only type we&amp;rsquo;re interacting with from the crate is the &lt;code&gt;Post&lt;/code&gt; type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in&amp;mdash;draft, waiting for review, or published. Changing from one state to another will be managed internally within the &lt;code&gt;Post&lt;/code&gt; type. The states change in response to the methods called by our library&amp;rsquo;s users on the &lt;code&gt;Post&lt;/code&gt; instance, but they don&amp;rsquo;t have to manage the state changes directly. Also, users can&amp;rsquo;t make a mistake with the states, like publishing a post before it&amp;rsquo;s reviewed.</source>
          <target state="translated">クレートからやり取りしている唯一のタイプは &lt;code&gt;Post&lt;/code&gt; タイプです。このタイプは状態パターンを使用し、投稿が取り得るさまざまな状態（ドラフト、レビュー待ち、または公開済み）を表す3つの状態オブジェクトの1つになる値を保持します。ある状態から別の状態への変更は &lt;code&gt;Post&lt;/code&gt; タイプ内で内部的に管理されます。状態は、 &lt;code&gt;Post&lt;/code&gt; インスタンスでライブラリのユーザーによって呼び出されたメソッドに応じて変化しますが、状態の変化を直接管理する必要はありません。また、ユーザーはレビュー前に投稿を公開するなど、状態を間違えることはありません。</target>
        </trans-unit>
        <trans-unit id="a7d5a7d44a98e57a3adf5c0193845ed9098d4a93" translate="yes" xml:space="preserve">
          <source>Notice that the workspace has only one &lt;em&gt;Cargo.lock&lt;/em&gt; file at the top level of the workspace rather than having a &lt;em&gt;Cargo.lock&lt;/em&gt; in each crate&amp;rsquo;s directory. This ensures that all crates are using the same version of all dependencies. If we add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;em&gt;adder/Cargo.toml&lt;/em&gt; and &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; files, Cargo will resolve both of those to one version of &lt;code&gt;rand&lt;/code&gt; and record that in the one &lt;em&gt;Cargo.lock&lt;/em&gt;. Making all crates in the workspace use the same dependencies means the crates in the workspace will always be compatible with each other. Let&amp;rsquo;s add the &lt;code&gt;rand&lt;/code&gt; crate to the &lt;code&gt;[dependencies]&lt;/code&gt; section in the &lt;em&gt;add-one/Cargo.toml&lt;/em&gt; file to be able to use the &lt;code&gt;rand&lt;/code&gt; crate in the &lt;code&gt;add-one&lt;/code&gt; crate:</source>
          <target state="translated">ワークスペースのトップレベルには、各クレートのディレクトリに&lt;em&gt;Cargo.lockがあるの&lt;/em&gt;ではなく、ワークスペースの&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルが1つしかないことに注意してください。これにより、すべてのクレートがすべての依存関係の同じバージョンを使用することが保証されます。我々は追加する場合は &lt;code&gt;rand&lt;/code&gt; にクレートを&lt;em&gt;加算器/ Cargo.toml&lt;/em&gt;と&lt;em&gt;アドオン1 / Cargo.tomlの&lt;/em&gt;ファイルを、貨物のいずれのバージョンにそれらの両方を解決します &lt;code&gt;rand&lt;/code&gt; 1のそれとレコード&lt;em&gt;Cargo.lock&lt;/em&gt;。ワークスペース内のすべてのクレートに同じ依存関係を使用させると、ワークスペース内のクレートは常に相互に互換性があります。さんが追加してみましょう &lt;code&gt;rand&lt;/code&gt; にクレートを &lt;code&gt;[dependencies]&lt;/code&gt; セクション&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;add-one / Cargo.toml&lt;/em&gt;ファイルを使用して、 &lt;code&gt;add-one&lt;/code&gt; クレートで &lt;code&gt;rand&lt;/code&gt; クレートを使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="d099748c8a2369f6e0484b9fb1916260cb072d44" translate="yes" xml:space="preserve">
          <source>Notice that this guarantee does &lt;em&gt;not&lt;/em&gt; mean that memory does not leak! It is still completely okay not ever to call &lt;code&gt;drop&lt;/code&gt; on a pinned element (e.g., you can still call &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). In the example of the doubly-linked list, that element would just stay in the list. However you may not free or reuse the storage &lt;em&gt;without calling &lt;code&gt;drop&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">この保証はメモリがリークし&lt;em&gt;ない&lt;/em&gt;ことを意味し&lt;em&gt;ない&lt;/em&gt;ことに注意してください！ピン留めされた要素で &lt;code&gt;drop&lt;/code&gt; を呼び出さなくても完全に問題はありません（たとえば、 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;../mem/fn.forget&quot;&gt; &lt;code&gt;mem::forget&lt;/code&gt; &lt;/a&gt;を呼び出すことができます）。二重リンクリストの例では、その要素はリストに残ります。ただし、&lt;em&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/em&gt;&lt;em&gt;を呼び出さず&lt;/em&gt;にストレージ&lt;em&gt;を&lt;/em&gt;解放または再利用することはできません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8e96d92ae370594b0a23d663a0a9b44ba5cff77" translate="yes" xml:space="preserve">
          <source>Notice that this time we didn&amp;rsquo;t see output indicating that Cargo was compiling &lt;code&gt;hello_cargo&lt;/code&gt;. Cargo figured out that the files hadn&amp;rsquo;t changed, so it just ran the binary. If you had modified your source code, Cargo would have rebuilt the project before running it, and you would have seen this output:</source>
          <target state="translated">今回は、Cargoが &lt;code&gt;hello_cargo&lt;/code&gt; をコンパイルしていることを示す出力が表示されなかったことに注意してください。Cargoはファイルが変更されていないことを理解したため、バイナリを実行しました。ソースコードを変更した場合、Cargoは実行前にプロジェクトを再ビルドし、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="6af1b53e3b0f26b23d98afe8cfa1fff0e78676da" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; load operation!</source>
          <target state="translated">ロードとストアを組み合わせる操作にこの順序を使用すると、&lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;ロード操作につながることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a34cbcc2842b5a9803de21bbd3cea40bd2f9faf2" translate="yes" xml:space="preserve">
          <source>Notice that using this ordering for an operation that combines loads and stores leads to a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;&lt;code&gt;Relaxed&lt;/code&gt;&lt;/a&gt; store operation!</source>
          <target state="translated">ロードとストアを組み合わせる操作にこの順序を使用すると、&lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt; &lt;code&gt;Relaxed&lt;/code&gt; &lt;/a&gt;ストア操作につながることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1648ed9eef01e81103715c2fb558bce27eedcadf" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t include the &lt;code&gt;unsafe&lt;/code&gt; keyword in this code. We can create raw pointers in safe code; we just can&amp;rsquo;t dereference raw pointers outside an unsafe block, as you&amp;rsquo;ll see in a bit.</source>
          <target state="translated">このコードには &lt;code&gt;unsafe&lt;/code&gt; キーワードが含まれていないことに注意してください。安全なコードで生のポインタを作成できます。後でわかるように、安全でないブロックの外で生のポインターを逆参照することはできません。</target>
        </trans-unit>
        <trans-unit id="111ab81f0256d10482ec4d240e310c1571a40527" translate="yes" xml:space="preserve">
          <source>Notice that we need an explicit lifetime &lt;code&gt;'a&lt;/code&gt; defined in the signature of &lt;code&gt;search&lt;/code&gt; and used with the &lt;code&gt;contents&lt;/code&gt; argument and the return value. Recall in &lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;Chapter 10&lt;/a&gt; that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument &lt;code&gt;contents&lt;/code&gt; (rather than the argument &lt;code&gt;query&lt;/code&gt;).</source>
          <target state="translated">私たちは、明示的な寿命が必要であることに注意してください &lt;code&gt;'a&lt;/code&gt; の署名で定義され &lt;code&gt;search&lt;/code&gt; と一緒に使用 &lt;code&gt;contents&lt;/code&gt; 引数と戻り値。ライフタイムパラメータは、戻り値のライフタイムに接続する引数のライフタイムを指定することを&lt;a href=&quot;ch10-03-lifetime-syntax&quot;&gt;第10章で&lt;/a&gt;思い出してください。この場合、返されるベクトルには、（引数 &lt;code&gt;query&lt;/code&gt; ではなく）引数 &lt;code&gt;contents&lt;/code&gt; スライスを参照する文字列スライスを含める必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="fd9233164b7146f50abe145b0977e2ddba8ac9ff" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;ve split the code into the &lt;code&gt;hello_macro_derive&lt;/code&gt; function, which is responsible for parsing the &lt;code&gt;TokenStream&lt;/code&gt;, and the &lt;code&gt;impl_hello_macro&lt;/code&gt; function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (&lt;code&gt;hello_macro_derive&lt;/code&gt; in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (&lt;code&gt;impl_hello_macro&lt;/code&gt; in this case) will be different depending on your procedural macro&amp;rsquo;s purpose.</source>
          <target state="translated">私たちは、コードに分割したことに注意してください &lt;code&gt;hello_macro_derive&lt;/code&gt; 解析するための責任がある機能、 &lt;code&gt;TokenStream&lt;/code&gt; を、そして &lt;code&gt;impl_hello_macro&lt;/code&gt; より便利な手続きマクロを書くこの作る：構文木を変換するための責任がある機能を、。外部関数（この場合は &lt;code&gt;hello_macro_derive&lt;/code&gt; ）のコードは、表示または作成するほとんどすべての手続き型マクロクレートで同じです。内部関数の本体（この場合は &lt;code&gt;impl_hello_macro&lt;/code&gt; )で指定するコードは、プロシージャマクロの目的に応じて異なります。</target>
        </trans-unit>
        <trans-unit id="8966a5e7726edf21a4dc24ce7e3b95ed94980ac9" translate="yes" xml:space="preserve">
          <source>Notice there isn&amp;rsquo;t any code after the last line that begins with &lt;code&gt;//!&lt;/code&gt;. Because we started the comments with &lt;code&gt;//!&lt;/code&gt; instead of &lt;code&gt;///&lt;/code&gt;, we&amp;rsquo;re documenting the item that contains this comment rather than an item that follows this comment. In this case, the item that contains this comment is the &lt;em&gt;src/lib.rs&lt;/em&gt; file, which is the crate root. These comments describe the entire crate.</source>
          <target state="translated">&lt;code&gt;//!&lt;/code&gt; で始まる最後の行の後にコードがないことに注意してください。。 &lt;code&gt;//!&lt;/code&gt; でコメントを始めたからです。 &lt;code&gt;///&lt;/code&gt; の代わりに、このコメントに続く項目ではなく、このコメントを含む項目を文書化しています。この場合、このコメントを含むアイテムは、クレートルートである&lt;em&gt;src / lib.rs&lt;/em&gt;ファイルです。これらのコメントはクレート全体を説明しています。</target>
        </trans-unit>
        <trans-unit id="fcd0fb110f9fe32ec66824d300336739072d5b34" translate="yes" xml:space="preserve">
          <source>Notice this definition uses some new syntax: &lt;code&gt;type Item&lt;/code&gt; and &lt;code&gt;Self::Item&lt;/code&gt;, which are defining an &lt;em&gt;associated type&lt;/em&gt; with this trait. We&amp;rsquo;ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the &lt;code&gt;Iterator&lt;/code&gt; trait requires that you also define an &lt;code&gt;Item&lt;/code&gt; type, and this &lt;code&gt;Item&lt;/code&gt; type is used in the return type of the &lt;code&gt;next&lt;/code&gt; method. In other words, the &lt;code&gt;Item&lt;/code&gt; type will be the type returned from the iterator.</source>
          <target state="translated">この定義はいくつかの新しい構文を使用していることに注意してください： &lt;code&gt;type Item&lt;/code&gt; と &lt;code&gt;Self::Item&lt;/code&gt; 、このトレイトに&lt;em&gt;関連付けられたタイプ&lt;/em&gt;を定義しています。関連付けられた型については第19章で詳しく説明します。現時点では、このコードでは、 &lt;code&gt;Iterator&lt;/code&gt; トレイトを実装するには &lt;code&gt;Item&lt;/code&gt; タイプも定義する必要があり、この &lt;code&gt;Item&lt;/code&gt; タイプは &lt;code&gt;next&lt;/code&gt; 方法。つまり、 &lt;code&gt;Item&lt;/code&gt; タイプはイテレータから返されるタイプになります。</target>
        </trans-unit>
        <trans-unit id="e0aa323f0e9e9e9d80a8d3d6a7b2a9db9ba76843" translate="yes" xml:space="preserve">
          <source>Now all the instances of &lt;code&gt;Point&lt;/code&gt; shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</source>
          <target state="translated">これで、示された &lt;code&gt;Point&lt;/code&gt; すべてのインスタンスが許可されます！定義ではジェネリック型パラメーターをいくつでも使用できますが、数が多すぎるとコードが読みにくくなります。コードに多くのジェネリック型が必要な場合は、コードを小さな部分に再構築する必要があることを示している可能性があります。</target>
        </trans-unit>
        <trans-unit id="23eaa14436421a3e3cff4560bf4fb71eb52f11da" translate="yes" xml:space="preserve">
          <source>Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</source>
          <target state="translated">これで、この関数シグネチャ内のすべての参照が寿命を持つようになり、コンパイラはプログラマーがこの関数シグネチャ内の寿命をアノテーションすることなく解析を続けることができます。</target>
        </trans-unit>
        <trans-unit id="6e1a1d010dc9ab9a0953fedbe299c3c77ffa1062" translate="yes" xml:space="preserve">
          <source>Now an example of &lt;code&gt;bool&lt;/code&gt; cast to integer type:</source>
          <target state="translated">整数型への &lt;code&gt;bool&lt;/code&gt; キャストの例：</target>
        </trans-unit>
        <trans-unit id="d65b9b0f422f439e94c8e42e9b963ca1e3008607" translate="yes" xml:space="preserve">
          <source>Now consider this twist where we add a call to &lt;code&gt;rev&lt;/code&gt;. This version will print &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt;. Note that the letters are reversed, but the values of the counter still go in order. This is because &lt;code&gt;map()&lt;/code&gt; is still being called lazily on each item, but we are popping items off the back of the vector now, instead of shifting them from the front.</source>
          <target state="translated">次に、 &lt;code&gt;rev&lt;/code&gt; への呼び出しを追加するこのひねりを考えます。このバージョンは &lt;code&gt;('c', 1), ('b', 2), ('a', 3)&lt;/code&gt; ます。文字が逆になっていることに注意してください。ただし、カウンタの値は順番どおりです。これは、 &lt;code&gt;map()&lt;/code&gt; が各アイテムで遅延して呼び出されているためです。ただし、アイテムを前面からシフトするのではなく、ベクターの背面からポップしているためです。</target>
        </trans-unit>
        <trans-unit id="3a875ba4bda66efea86acc1d83b8c4cd40356ff2" translate="yes" xml:space="preserve">
          <source>Now enter the code in Listing 20-1 in &lt;em&gt;src/main.rs&lt;/em&gt; to start. This code will listen at the address &lt;code&gt;127.0.0.1:7878&lt;/code&gt; for incoming TCP streams. When it gets an incoming stream, it will print &lt;code&gt;Connection established!&lt;/code&gt;.</source>
          <target state="translated">次に、リスト20-1のコードを&lt;em&gt;src / main.rsに入力&lt;/em&gt;して開始します。このコードは、アドレス &lt;code&gt;127.0.0.1:7878&lt;/code&gt; で着信TCPストリームをリッスンします。着信ストリームを取得すると、 &lt;code&gt;Connection established!&lt;/code&gt; ことを出力します！。</target>
        </trans-unit>
        <trans-unit id="dc71b87d7408d245b3b0aa3a92982cb74fc6ac9f" translate="yes" xml:space="preserve">
          <source>Now everything in the program should work as expected. Let&amp;rsquo;s try it:</source>
          <target state="translated">これで、プログラムのすべてが期待どおりに機能するはずです。試してみよう：</target>
        </trans-unit>
        <trans-unit id="d7f4763863038d188ed1914c2142e2e561d22201" translate="yes" xml:space="preserve">
          <source>Now if we change either the function or the example so the &lt;code&gt;assert_eq!&lt;/code&gt; in the example panics and run &lt;code&gt;cargo test&lt;/code&gt; again, we&amp;rsquo;ll see that the doc tests catch that the example and the code are out of sync with each other!</source>
          <target state="translated">ここで、関数または例を変更すると、 &lt;code&gt;assert_eq!&lt;/code&gt; 例のパニックで再度 &lt;code&gt;cargo test&lt;/code&gt; を実行すると、docテストが例とコードが互いに同期していないことをキャッチしていることがわかります！</target>
        </trans-unit>
        <trans-unit id="2e5aa4ec7130600ff4ecc4d4f5150848ff00d36e" translate="yes" xml:space="preserve">
          <source>Now it's possible to create at least one instance of &lt;code&gt;Foo&lt;/code&gt;: &lt;code&gt;Foo { x: None }&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;Foo&lt;/code&gt; のインスタンスを少なくとも1つ作成できます： &lt;code&gt;Foo { x: None }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57dee911ce426e019e30db0fccc486981ac3d8d4" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add the code in Listing 20-7 to the &lt;code&gt;else&lt;/code&gt; block to return a response with the status code 404, which signals that the content for the request was not found. We&amp;rsquo;ll also return some HTML for a page to render in the browser indicating the response to the end user.</source>
          <target state="translated">次に、リスト20-7のコードを &lt;code&gt;else&lt;/code&gt; ブロックに追加して、リクエストのコンテンツが見つからなかったことを示すステータスコード404の応答を返します。また、ブラウザでレンダリングするページのHTMLを返し、エンドユーザーへの応答を示します。</target>
        </trans-unit>
        <trans-unit id="82511279c647b8b87ee818b8d44458ab76617b1f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s compile this &amp;ldquo;Hello, world!&amp;rdquo; program and run it in the same step using the &lt;code&gt;cargo run&lt;/code&gt; command:</source>
          <target state="translated">では、この「Hello、world！」をコンパイルしましょう。プログラムを実行し、 &lt;code&gt;cargo run&lt;/code&gt; コマンドを使用して同じステップで実行します。</target>
        </trans-unit>
        <trans-unit id="8863ee5075a8246e730bfe40012862faba75a02b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s consider the second call of &lt;code&gt;plus_one&lt;/code&gt; in Listing 6-5, where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. We enter the &lt;code&gt;match&lt;/code&gt; and compare to the first arm.</source>
          <target state="translated">ここで、リスト6-5 の &lt;code&gt;plus_one&lt;/code&gt; の2番目の呼び出しについて考えてみましょう。ここで、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;None&lt;/code&gt; です。私たちは、入力した &lt;code&gt;match&lt;/code&gt; し、第一アームと比較します。</target>
        </trans-unit>
        <trans-unit id="b8300b290a67f9ed128322c21050dab12f2d0aa0" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s examine lifetime annotations in the context of the &lt;code&gt;longest&lt;/code&gt; function. As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime. We&amp;rsquo;ll name the lifetime &lt;code&gt;'a&lt;/code&gt; and then add it to each reference, as shown in Listing 10-22.</source>
          <target state="translated">次に、 &lt;code&gt;longest&lt;/code&gt; 関数のコンテキストでライフタイムアノテーションを調べてみましょう。ジェネリック型パラメーターと同様に、関数名とパラメーターリストの間の山かっこ内にジェネリックライフタイムパラメーターを宣言する必要があります。このシグネチャで表現したい制約は、パラメーター内のすべての参照と戻り値のライフタイムが同じでなければならないことです。リスト10-22で示されるように、ライフタイムを &lt;code&gt;'a&lt;/code&gt; とし、それを各参照に追加します。</target>
        </trans-unit>
        <trans-unit id="4d1d28eae4c7f65ed347f71ad22936c83ed0eb43" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:</source>
          <target state="translated">次に、コンパイラーに頼って、変更が必要な他の場所を見つけましょう。このコードをチェックすると、2つのエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="89a2cc6c6da74e574a540dd470febae8d113a245" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the &lt;code&gt;String&lt;/code&gt; version:</source>
          <target state="translated">次に、 &lt;code&gt;String&lt;/code&gt; バージョンを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="aaee68df203c11b18152dd8afe26709ec73580c1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at the pattern in the body of the code associated with this arm: &lt;code&gt;temp_vec.push()&lt;/code&gt; within &lt;code&gt;$()*&lt;/code&gt; is generated for each part that matches &lt;code&gt;$()&lt;/code&gt; in the pattern zero or more times depending on how many times the pattern matches. The &lt;code&gt;$x&lt;/code&gt; is replaced with each expression matched. When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the code generated that replaces this macro call will be the following:</source>
          <target state="translated">次に、このアームに関連付けられたコードの本文にあるパターンを見てみましょう。 &lt;code&gt;$()*&lt;/code&gt; 内の &lt;code&gt;temp_vec.push()&lt;/code&gt; &lt;code&gt;$()&lt;/code&gt; は、パターン内の$（）に0回以上一致する各パーツに対して生成されます。パターンマッチ。 &lt;code&gt;$x&lt;/code&gt; マッチしたそれぞれの式に置き換えられます。このマクロを &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; 呼び出すと、、このマクロ呼び出しを置き換える生成コードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="80b98c3dc4276471e5dedcfc50a6872d575390db" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what&amp;rsquo;s different when we build and run the Hello, world! program with Cargo! From your &lt;em&gt;hello_cargo&lt;/em&gt; directory, build your project by entering the following command:</source>
          <target state="translated">次に、Hello、world！をビルドして実行するときの違いを見てみましょう。カーゴとのプログラム！&lt;em&gt;hello_cargo&lt;/em&gt;ディレクトリから、次のコマンドを入力してプロジェクトをビルドします。</target>
        </trans-unit>
        <trans-unit id="5b581411bc505a7c21b9a362d12d054fb0134b63" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the test:</source>
          <target state="translated">次にテストを実行しましょう：</target>
        </trans-unit>
        <trans-unit id="f0501637a3932ce5ddf54dd291b5e0f5788b9a63" translate="yes" xml:space="preserve">
          <source>Now open &lt;em&gt;src/main.rs&lt;/em&gt; and take a look:</source>
          <target state="translated">次に&lt;em&gt;src / main.rs&lt;/em&gt;を開いて見てください：</target>
        </trans-unit>
        <trans-unit id="b399f29f23b6c286984286dd9b48d3e844228cb4" translate="yes" xml:space="preserve">
          <source>Now open the &lt;em&gt;main.rs&lt;/em&gt; file you just created and enter the code in Listing 1-1.</source>
          <target state="translated">作成した&lt;em&gt;main.rs&lt;/em&gt;ファイルを開き、コードリスト1-1のコードを入力します。</target>
        </trans-unit>
        <trans-unit id="d981ccfedbc387139591c6429e1ab6bbb51ae547" translate="yes" xml:space="preserve">
          <source>Now our code more clearly conveys that &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the &lt;code&gt;config&lt;/code&gt; instance in the fields named for their purpose.</source>
          <target state="translated">これで、コードにより、 &lt;code&gt;query&lt;/code&gt; と &lt;code&gt;filename&lt;/code&gt; が関連していること、およびその目的がプログラムの動作を構成することであることをより明確に伝えることができます。これらの値を使用して任意のコードがでそれらを見つけるために知っている &lt;code&gt;config&lt;/code&gt; 、その目的のためにという名前のフィールドにインスタンス。</target>
        </trans-unit>
        <trans-unit id="e98906bcddd6edae414bc05f0060b41c04becc18" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;cargo test&lt;/code&gt; in the top-level &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">次に、最上位の&lt;em&gt;add&lt;/em&gt;ディレクトリで &lt;code&gt;cargo test&lt;/code&gt; を実行します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7999991a01bc3db0ab51179e8f7d5b7ea1e4709" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;search&lt;/code&gt; function is working and tested, we need to call &lt;code&gt;search&lt;/code&gt; from our &lt;code&gt;run&lt;/code&gt; function. We need to pass the &lt;code&gt;config.query&lt;/code&gt; value and the &lt;code&gt;contents&lt;/code&gt; that &lt;code&gt;run&lt;/code&gt; reads from the file to the &lt;code&gt;search&lt;/code&gt; function. Then &lt;code&gt;run&lt;/code&gt; will print each line returned from &lt;code&gt;search&lt;/code&gt;:</source>
          <target state="translated">今という &lt;code&gt;search&lt;/code&gt; 機能が動作してテストされ、我々は呼び出す必要があり &lt;code&gt;search&lt;/code&gt; 当社から &lt;code&gt;run&lt;/code&gt; 機能。 &lt;code&gt;config.query&lt;/code&gt; 値と、 &lt;code&gt;run&lt;/code&gt; 読み取った &lt;code&gt;contents&lt;/code&gt; をファイルから &lt;code&gt;search&lt;/code&gt; 関数に渡す必要があります。次に &lt;code&gt;run&lt;/code&gt; は &lt;code&gt;search&lt;/code&gt; から返された各行を出力します。</target>
        </trans-unit>
        <trans-unit id="03229adf31a42bdb64eb9cba521d26f0154223d5" translate="yes" xml:space="preserve">
          <source>Now that the closure has its own copy of the data, there's no need to worry about safety.</source>
          <target state="translated">今では閉鎖がデータのコピーを独自に持っているので、安全性の心配はありません。</target>
        </trans-unit>
        <trans-unit id="80c8ae661a453d666a29851514f9590667d50328" translate="yes" xml:space="preserve">
          <source>Now that we have a library crate in the workspace, we can have the binary crate &lt;code&gt;adder&lt;/code&gt; depend on the library crate &lt;code&gt;add-one&lt;/code&gt;. First, we&amp;rsquo;ll need to add a path dependency on &lt;code&gt;add-one&lt;/code&gt; to &lt;em&gt;adder/Cargo.toml&lt;/em&gt;.</source>
          <target state="translated">今、私たちは、ワークスペース内のライブラリクレートを持っていることを、我々はバイナリクレート持つことができる &lt;code&gt;adder&lt;/code&gt; ライブラリクレートに依存 &lt;code&gt;add-one&lt;/code&gt; 。まず、 &lt;code&gt;add-one&lt;/code&gt; のパス依存関係を&lt;em&gt;adder / Cargo.toml&lt;/em&gt;に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="e1d03746f7af11550c4dab530f554fdd12c9b9be" translate="yes" xml:space="preserve">
          <source>Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the &lt;code&gt;ThreadPool&lt;/code&gt; struct before returning it. But how do we &amp;ldquo;store&amp;rdquo; a thread? Let&amp;rsquo;s take another look at the &lt;code&gt;thread::spawn&lt;/code&gt; signature:</source>
          <target state="translated">これで、プールに保存する有効な数のスレッドがあることを確認する方法ができたので、それらのスレッドを作成して、それを返す前に &lt;code&gt;ThreadPool&lt;/code&gt; 構造体に保存できます。しかし、どのようにしてスレッドを「保存」するのでしょうか。 &lt;code&gt;thread::spawn&lt;/code&gt; シグネチャをもう一度見てみましょう。</target>
        </trans-unit>
        <trans-unit id="bda29c679c337b77198a68eb0c281ffe77fd4dfe" translate="yes" xml:space="preserve">
          <source>Now that we have an external dependency, Cargo fetches the latest versions of everything from the &lt;em&gt;registry&lt;/em&gt;, which is a copy of data from &lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</source>
          <target state="translated">これで外部依存関係ができたので、Cargoはすべての最新バージョンを&lt;em&gt;レジストリ&lt;/em&gt;からフェッチし&lt;em&gt;ます&lt;/em&gt;。これは、&lt;a href=&quot;https://crates.io/&quot;&gt;Crates.io&lt;/a&gt;からのデータのコピーです。Crates.ioには、Rustエコシステムの人々がオープンソースのRustプロジェクトを投稿して、他のユーザーが使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="3228f1351fbe40c57701ca17a80dd025a6bfe94f" translate="yes" xml:space="preserve">
          <source>Now that we have the code to turn the annotated Rust code from a &lt;code&gt;TokenStream&lt;/code&gt; into a &lt;code&gt;DeriveInput&lt;/code&gt; instance, let&amp;rsquo;s generate the code that implements the &lt;code&gt;HelloMacro&lt;/code&gt; trait on the annotated type, as shown in Listing 19-33.</source>
          <target state="translated">今から注釈付き錆コードをオンにするコードがあること &lt;code&gt;TokenStream&lt;/code&gt; に &lt;code&gt;DeriveInput&lt;/code&gt; のインスタンスを、のコードを生成させることが実装 &lt;code&gt;HelloMacro&lt;/code&gt; のリスト19-33で示されるように注釈付きの型の特性、。</target>
        </trans-unit>
        <trans-unit id="a05d1adf4441c02b17aff2e4ed6b1b6d76dccfa3" translate="yes" xml:space="preserve">
          <source>Now that we have the context, let&amp;rsquo;s get to the algorithm. The function &lt;code&gt;generate_workout&lt;/code&gt; in Listing 13-3 contains the business logic of the app that we&amp;rsquo;re most concerned with in this example. The rest of the code changes in this example will be made to this function.</source>
          <target state="translated">コンテキストができたので、アルゴリズムに進みましょう。コードリスト13-3の &lt;code&gt;generate_workout&lt;/code&gt; 関数には、この例で最も関心の高いアプリのビジネスロジックが含まれています。この例の残りのコード変更は、この関数に対して行われます。</target>
        </trans-unit>
        <trans-unit id="d0d7185e0fbe1a274eebe89e5b39be3986c2db0a" translate="yes" xml:space="preserve">
          <source>Now that we have user input and a random number, we can compare them. That step is shown in Listing 2-4. Note that this code won&amp;rsquo;t compile quite yet, as we will explain.</source>
          <target state="translated">これでユーザー入力と乱数が得られたので、それらを比較できます。リスト2-4にそのステップを示します。説明するように、このコードはまだ完全にはコンパイルされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="38f50db14e5d3025086efbe8bea15a9ba8ef6b08" translate="yes" xml:space="preserve">
          <source>Now that we know what the browser is asking for, let&amp;rsquo;s send back some data!</source>
          <target state="translated">ブラウザが何を要求しているかがわかったところで、データを送り返しましょう！</target>
        </trans-unit>
        <trans-unit id="e92484795e9a806e19045c8bd7479798242a92b0" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined the desired behavior using the &lt;code&gt;Summary&lt;/code&gt; trait, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the &lt;code&gt;Summary&lt;/code&gt; trait on the &lt;code&gt;NewsArticle&lt;/code&gt; struct that uses the headline, the author, and the location to create the return value of &lt;code&gt;summarize&lt;/code&gt;. For the &lt;code&gt;Tweet&lt;/code&gt; struct, we define &lt;code&gt;summarize&lt;/code&gt; as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</source>
          <target state="translated">これで、 &lt;code&gt;Summary&lt;/code&gt; トレイトを使用して目的の動作を定義したので、メディアアグリゲーターのタイプにそれを実装できます。10-13ショーの実装リスト &lt;code&gt;Summary&lt;/code&gt; の特性 &lt;code&gt;NewsArticle&lt;/code&gt; の見出し、作成者、の戻り値を作成する場所使用する構造体 &lt;code&gt;summarize&lt;/code&gt; 。以下のために &lt;code&gt;Tweet&lt;/code&gt; 構造体、我々は定義 &lt;code&gt;summarize&lt;/code&gt; usernameはつぶやきの内容はすでに280文字に制限されているとすると、つぶやきのテキスト全体が続くよう。</target>
        </trans-unit>
        <trans-unit id="847c864456f96a628c83e8df1e38c081c9008635" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve defined threads in Rust, let&amp;rsquo;s explore how to use the thread-related API provided by the standard library.</source>
          <target state="translated">Rustでスレッドを定義したので、標準ライブラリによって提供されるスレッド関連のAPIの使用方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="87dd1868af24eb68dc999a15f4b71b72a52c4914" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; by the standard library. For example, in addition to &lt;code&gt;push&lt;/code&gt;, a &lt;code&gt;pop&lt;/code&gt; method removes and returns the last element. Let&amp;rsquo;s move on to the next collection type: &lt;code&gt;String&lt;/code&gt;!</source>
          <target state="translated">ベクトルの最も一般的な使用方法のいくつかを説明したので、標準ライブラリによって &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 定義されている多くの便利なメソッドすべてについて、APIドキュメントを確認してください。たとえば、 &lt;code&gt;push&lt;/code&gt; に加えて、 &lt;code&gt;pop&lt;/code&gt; メソッドは最後の要素を削除して返します。次のコレクション型である &lt;code&gt;String&lt;/code&gt; に移りましょう。</target>
        </trans-unit>
        <trans-unit id="2ec4c24a317d3f7bc3c352fa146805708f0bd185" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve discussed the details of calling &lt;code&gt;panic!&lt;/code&gt; or returning &lt;code&gt;Result&lt;/code&gt;, let&amp;rsquo;s return to the topic of how to decide which is appropriate to use in which cases.</source>
          <target state="translated">これで、 &lt;code&gt;panic!&lt;/code&gt; の呼び出しの詳細について説明しました。または &lt;code&gt;Result&lt;/code&gt; を返す場合は、どの場合にどちらを使用するのが適切かを判断する方法のトピックに戻りましょう。</target>
        </trans-unit>
        <trans-unit id="dcf9675ca650b7816e93bbac61987240fde0e1c1" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve examined &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and some of the characteristics of smart pointers, let&amp;rsquo;s look at a few other smart pointers defined in the standard library.</source>
          <target state="translated">今、私たちが検討してきたことを &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; とスマートポインタの特性のいくつかを、他のいくつかのスマートポインタで見てみましょうは、標準ライブラリで定義されています。</target>
        </trans-unit>
        <trans-unit id="1275cf5c5193957df5e8d9870d52448402e96389" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve explored how variables work, let&amp;rsquo;s look at more data types they can have.</source>
          <target state="translated">変数のしくみを説明したので、変数が持つことができるデータ型をさらに見てみましょう。</target>
        </trans-unit>
        <trans-unit id="b53e79d7c3785836a15f4ecfc6aac9abee118b76" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted the logic into &lt;em&gt;src/lib.rs&lt;/em&gt; and left the argument collecting and error handling in &lt;em&gt;src/main.rs&lt;/em&gt;, it&amp;rsquo;s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line. Feel free to write some tests for the functionality in the &lt;code&gt;Config::new&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; functions on your own.</source>
          <target state="translated">ロジックを&lt;em&gt;src / lib.rsに&lt;/em&gt;抽出し、引数の収集とエラー処理を&lt;em&gt;src / main.rsに残したので&lt;/em&gt;、コードのコア機能のテストを作成する方がはるかに簡単です。コマンドラインからバイナリを呼び出さなくても、さまざまな引数で関数を直接呼び出して戻り値を確認できます。 &lt;code&gt;Config::new&lt;/code&gt; 機能のテストを記述して、自分で関数を &lt;code&gt;run&lt;/code&gt; してください。</target>
        </trans-unit>
        <trans-unit id="2a08eff4bb167e5da1e95f954b1304af56f21965" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve finished refactoring the configuration parsing, let&amp;rsquo;s turn to the program&amp;rsquo;s logic. As we stated in &lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;&amp;ldquo;Separation of Concerns for Binary Projects&amp;rdquo;&lt;/a&gt;, we&amp;rsquo;ll extract a function named &lt;code&gt;run&lt;/code&gt; that will hold all the logic currently in the &lt;code&gt;main&lt;/code&gt; function that isn&amp;rsquo;t involved with setting up configuration or handling errors. When we&amp;rsquo;re done, &lt;code&gt;main&lt;/code&gt; will be concise and easy to verify by inspection, and we&amp;rsquo;ll be able to write tests for all the other logic.</source>
          <target state="translated">構成の解析のリファクタリングが完了したので、プログラムのロジックに移りましょう。&lt;a href=&quot;#separation-of-concerns-for-binary-projects&quot;&gt;「バイナリプロジェクトの懸念の分離」で&lt;/a&gt;述べたように、 &lt;code&gt;run&lt;/code&gt; と名付けられた関数を抽出します。この関数は、現在 &lt;code&gt;main&lt;/code&gt; 関数内にあり、構成のセットアップやエラーの処理に関係しないすべてのロジックを保持します。完了すると、 &lt;code&gt;main&lt;/code&gt; は簡潔になり、検査によって検証しやすくなり、他のすべてのロジックのテストを作成できるようになります。</target>
        </trans-unit>
        <trans-unit id="67636ff52e1a7401207e61d89497c3656085f595" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve improved the expressiveness of our I/O project, let&amp;rsquo;s look at some more features of &lt;code&gt;cargo&lt;/code&gt; that will help us share the project with the world.</source>
          <target state="translated">I / Oプロジェクトの表現力が向上したので、プロジェクトを世界と共有するのに役立つ &lt;code&gt;cargo&lt;/code&gt; 機能をいくつか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="f8c732cbf77e2073635c5b38e31310fafb9b6c1e" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve introduced iterators, we can demonstrate a common use of closures that capture their environment by using the &lt;code&gt;filter&lt;/code&gt; iterator adaptor. The &lt;code&gt;filter&lt;/code&gt; method on an iterator takes a closure that takes each item from the iterator and returns a Boolean. If the closure returns &lt;code&gt;true&lt;/code&gt;, the value will be included in the iterator produced by &lt;code&gt;filter&lt;/code&gt;. If the closure returns &lt;code&gt;false&lt;/code&gt;, the value won&amp;rsquo;t be included in the resulting iterator.</source>
          <target state="translated">イテレーターを紹介したので、 &lt;code&gt;filter&lt;/code&gt; イテレーターアダプターを使用して、環境をキャプチャするクロージャーの一般的な使用方法を示すことができます。イテレーターの &lt;code&gt;filter&lt;/code&gt; メソッドは、イテレーターから各項目を取得してブール値を返すクロージャーを取得します。クロージャが &lt;code&gt;true&lt;/code&gt; を返す場合、値は &lt;code&gt;filter&lt;/code&gt; によって生成された反復子に含まれます。クロージャーが &lt;code&gt;false&lt;/code&gt; を返す場合、値は結果のイテレーターに含まれません。</target>
        </trans-unit>
        <trans-unit id="0f5c8cc4166bf098c054b91aa56eafdd80a280aa" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve looked at how channels work, let&amp;rsquo;s look at a different method of concurrency.</source>
          <target state="translated">チャネルがどのように機能するかを見てきましたので、並行性の別の方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="67653a6049372ba09d60cbd375a44f6c3cccaf9a" translate="yes" xml:space="preserve">
          <source>Now that we've got an idea of what unwind safety is in Rust, it's also important to understand what this trait represents. As mentioned above, one way to witness broken invariants is through the &lt;code&gt;catch_unwind&lt;/code&gt; function in this module as it allows catching a panic and then re-using the environment of the closure.</source>
          <target state="translated">Rustの巻き戻しの安全性について理解したところで、この特性が何を表しているのかを理解することも重要です。上記のように、壊れた不変条件を確認する1つの方法は、このモジュールの &lt;code&gt;catch_unwind&lt;/code&gt; 関数を使用することです。パニックをキャッチして、クロージャーの環境を再利用できるからです。</target>
        </trans-unit>
        <trans-unit id="d02969884890c4347910c461b721cc439357c5a4" translate="yes" xml:space="preserve">
          <source>Now that you have an account, let&amp;rsquo;s say you have a crate you want to publish. Before publishing, you&amp;rsquo;ll need to add some metadata to your crate by adding it to the &lt;code&gt;[package]&lt;/code&gt; section of the crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">アカウントを作成したので、公開したいクレートがあるとしましょう。公開する前に、クレートの&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルの &lt;code&gt;[package]&lt;/code&gt; セクションにメタデータを追加して、クレートにメタデータを追加する必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09f54035802dcb8ec1dd44caa3ea32209f58c20d" translate="yes" xml:space="preserve">
          <source>Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we&amp;rsquo;ve annotated the types of the values that are returned from these functions for extra clarity.</source>
          <target state="translated">ベクトルの作成、更新、破棄の方法を理解したところで、次はその内容の読み方を理解することです。ベクトルに格納された値を参照するには、2つの方法があります。例では、わかりやすくするために、これらの関数から返される値の型に注釈を付けています。</target>
        </trans-unit>
        <trans-unit id="81f4f18161b98344a0f7e41a60ca860036728be7" translate="yes" xml:space="preserve">
          <source>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types.</source>
          <target state="translated">これで、形質を定義して実装する方法がわかったので、次は形質を使って、さまざまな型を受け入れる関数を定義する方法を探ってみましょう。</target>
        </trans-unit>
        <trans-unit id="abb4d086b7b2c677929b00ae06d7123ecd180a15" translate="yes" xml:space="preserve">
          <source>Now that you know how to specify the behavior you want to use using the generic type parameter&amp;rsquo;s bounds, let&amp;rsquo;s return to Listing 10-5 to fix the definition of the &lt;code&gt;largest&lt;/code&gt; function that uses a generic type parameter! Last time we tried to run that code, we received this error:</source>
          <target state="translated">ジェネリック型パラメーターの境界を使用して使用する動作を指定する方法を理解したので、リスト10-5に戻り、ジェネリック型パラメーターを使用する &lt;code&gt;largest&lt;/code&gt; 関数の定義を修正しましょう。前回そのコードを実行しようとしたときに、次のエラーを受け取りました。</target>
        </trans-unit>
        <trans-unit id="e396981103292f81034753c73fe592831d9392a8" translate="yes" xml:space="preserve">
          <source>Now that you know several ways to write tests, let&amp;rsquo;s look at what is happening when we run our tests and explore the different options we can use with &lt;code&gt;cargo test&lt;/code&gt;.</source>
          <target state="translated">テストを作成するいくつかの方法がわかったところで、テストを実行したときに何が起こっているのかを見て、 &lt;code&gt;cargo test&lt;/code&gt; 使用できるさまざまなオプションを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e62f4573546a99a0fd5e85dde630775910ab5fc8" translate="yes" xml:space="preserve">
          <source>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let&amp;rsquo;s explore generic lifetimes of parameters and return values in the context of functions.</source>
          <target state="translated">参照のライフタイムがどこにあるか、そしてRustがライフタイムを分析して参照が常に有効であることを確認する方法を理解したところで、関数のコンテキストでパラメーターと戻り値の一般的なライフタイムを調べてみましょう。</target>
        </trans-unit>
        <trans-unit id="30a6477678dd7180d7e0d481486280f7e98fefae" translate="yes" xml:space="preserve">
          <source>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let&amp;rsquo;s cover all the syntax we can use to create patterns.</source>
          <target state="translated">パターンの使用場所と、反駁可能なパターンと反駁できないパターンの違いがわかったところで、パターンの作成に使用できるすべての構文について説明します。</target>
        </trans-unit>
        <trans-unit id="31528a068a5d3a841cff61741fee15a1c0b2479f" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve added the &lt;code&gt;rand&lt;/code&gt; crate to &lt;em&gt;Cargo.toml&lt;/em&gt;, let&amp;rsquo;s start using &lt;code&gt;rand&lt;/code&gt;. The next step is to update &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 2-3.</source>
          <target state="translated">今、あなたが追加したことを &lt;code&gt;rand&lt;/code&gt; にクレートを&lt;em&gt;Cargo.toml&lt;/em&gt;、の使用を開始しましょう &lt;code&gt;rand&lt;/code&gt; 。リスト2-3に示すように、次のステップは&lt;em&gt;src / main.rs&lt;/em&gt;を更新することです。</target>
        </trans-unit>
        <trans-unit id="25f40b5e485b1b15ed8e4d216ebb9b698b979c06" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you&amp;rsquo;re ready to publish! Publishing a crate uploads a specific version to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; for others to use.</source>
          <target state="translated">アカウントを作成し、APIトークンを保存し、クレートの名前を選択し、必要なメタデータを指定したので、公開する準備ができました！クレートを&lt;a href=&quot;https://crates.io/&quot;&gt;公開すると&lt;/a&gt;、他のユーザーが使用できるように特定のバージョンがcrates.ioにアップロードされます。</target>
        </trans-unit>
        <trans-unit id="920c59c826e17db818f515c07dfec7c798d59ee0" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve installed Rust, let&amp;rsquo;s write your first Rust program. It&amp;rsquo;s traditional when learning a new language to write a little program that prints the text &lt;code&gt;Hello, world!&lt;/code&gt; to the screen, so we&amp;rsquo;ll do the same here!</source>
          <target state="translated">Rustをインストールしたので、最初のRustプログラムを作成しましょう。新しい言語を学ぶときに、テキスト &lt;code&gt;Hello, world!&lt;/code&gt; を出力する小さなプログラムを書くことは伝統的です。画面に表示されるので、ここでも同じようにします。</target>
        </trans-unit>
        <trans-unit id="da83ac95984492a0d09f569c59cd96503f2138e1" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen how to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, let&amp;rsquo;s dig into how it works!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 使用方法を確認したので、それがどのように機能するかを詳しく見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3226e5056b022a9871764bceba61de34cf95da11" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen useful ways that the standard library uses generics with the &lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; enums, we&amp;rsquo;ll talk about how generics work and how you can use them in your code.</source>
          <target state="translated">標準ライブラリが &lt;code&gt;Option&lt;/code&gt; および &lt;code&gt;Result&lt;/code&gt; 列挙でジェネリックを使用する便利な方法を見てきましたので、ジェネリックがどのように機能するか、およびジェネリックをコードでどのように使用できるかについて説明します。</target>
        </trans-unit>
        <trans-unit id="c62551adf3df866d6c2e2a8e1a359461a03ffa45" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve seen what the test results look like in different scenarios, let&amp;rsquo;s look at some macros other than &lt;code&gt;panic!&lt;/code&gt; that are useful in tests.</source>
          <target state="translated">さまざまなシナリオでテスト結果がどのように見えるかを確認したので、 &lt;code&gt;panic!&lt;/code&gt; 以外のいくつかのマクロを見てみましょう！テストで役立ちます。</target>
        </trans-unit>
        <trans-unit id="b7ef50d26b9af16e9b7dc94b8c74f1d0f89a5d4f" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; using a pattern in the &lt;code&gt;let&lt;/code&gt; statement, as discussed in Chapter 18.</source>
          <target state="translated">今 &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;else&lt;/code&gt; ブロックは、唯一のタプルのステータス行とファイル名に適切な値を返します。次に、構造化を使用して、第18章で説明した &lt;code&gt;let&lt;/code&gt; に、letステートメントのパターンを使用して、これら2つの値を &lt;code&gt;status_line&lt;/code&gt; および &lt;code&gt;filename&lt;/code&gt; に割り当てます。</target>
        </trans-unit>
        <trans-unit id="4c7125187714db67fed394d49d485e2e00abd4cb" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;search&lt;/code&gt; function should return only the lines that contain &lt;code&gt;query&lt;/code&gt;, and our test should pass. Let&amp;rsquo;s run the test:</source>
          <target state="translated">これで、 &lt;code&gt;search&lt;/code&gt; 関数は &lt;code&gt;query&lt;/code&gt; を含む行のみを返し、テストに合格するはずです。テストを実行してみましょう：</target>
        </trans-unit>
        <trans-unit id="522023e5be1135a608b1cd7f8c8337b4cfc43235" translate="yes" xml:space="preserve">
          <source>Now the code will compile! Let&amp;rsquo;s look at the absolute and the relative path and double-check why adding the &lt;code&gt;pub&lt;/code&gt; keyword lets us use these paths in &lt;code&gt;add_to_waitlist&lt;/code&gt; with respect to the privacy rules.</source>
          <target state="translated">これでコードがコンパイルされます！絶対パスと相対パスを見て、 &lt;code&gt;pub&lt;/code&gt; キーワードを追加すると、プライバシールールに関して &lt;code&gt;add_to_waitlist&lt;/code&gt; でこれらのパスを使用できる理由を再確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="9b0d5ba9ad57069914ace4b7ba7c228161663abb" translate="yes" xml:space="preserve">
          <source>Now the entire program should work! Let&amp;rsquo;s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, &amp;ldquo;frog&amp;rdquo;:</source>
          <target state="translated">これでプログラム全体が機能するはずです！まず、エミリーディキンソンの詩「カエル」から正確に1行を返す単語で試してみましょう。</target>
        </trans-unit>
        <trans-unit id="14d34886bdb2d79a108c1eb310a74fea56db9de1" translate="yes" xml:space="preserve">
          <source>Now the expensive calculation is called in only one place, and we&amp;rsquo;re only executing that code where we need the results.</source>
          <target state="translated">高価な計算が1か所で呼び出され、結果が必要な場所でのみそのコードを実行しています。</target>
        </trans-unit>
        <trans-unit id="e22993365c1cb308452dac73cf5565235b2c67e8" translate="yes" xml:space="preserve">
          <source>Now the program is getting interesting! There&amp;rsquo;s a lot going on in this little line. Notice that this is a &lt;code&gt;let&lt;/code&gt; statement, which is used to create a &lt;em&gt;variable&lt;/em&gt;. Here&amp;rsquo;s another example:</source>
          <target state="translated">今、プログラムは面白くなっています！この小さな行にはたくさんのことが起こっています。これは、&lt;em&gt;変数の&lt;/em&gt;作成に使用される &lt;code&gt;let&lt;/code&gt; ステートメントであることに注意してください。次に別の例を示します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b5e26741b88a54ad8284d61f9e2e51ca7f82268" translate="yes" xml:space="preserve">
          <source>Now the signature indicates that the function data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Alternatively, you could change the body to not return data from &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">これで、シグネチャは、関数データが &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; から借用したことを示しています。または、本体を変更して &lt;code&gt;y&lt;/code&gt; からデータを返さないようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="c1198ca2a8c86240e1af84c3d28743f89fded1ad" translate="yes" xml:space="preserve">
          <source>Now we can start seeing the advantages of the state pattern: the &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; is the same no matter its &lt;code&gt;state&lt;/code&gt; value. Each state is responsible for its own rules.</source>
          <target state="translated">今、私たちは状態パターンの利点を見始めることができます。 &lt;code&gt;request_review&lt;/code&gt; の上のメソッド &lt;code&gt;Post&lt;/code&gt; その問題では同じノーである &lt;code&gt;state&lt;/code&gt; 値を。各州は独自のルールを担当しています。</target>
        </trans-unit>
        <trans-unit id="0ea1cd6e6626b68365f6c8947fa55d16ff141954" translate="yes" xml:space="preserve">
          <source>Now we get a warning and an error. Ignoring the warning for a moment, the error occurs because we don&amp;rsquo;t have an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt;. Recall from the &lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;&amp;ldquo;Creating a Similar Interface for a Finite Number of Threads&amp;rdquo;&lt;/a&gt; section that we decided our thread pool should have an interface similar to &lt;code&gt;thread::spawn&lt;/code&gt;. In addition, we&amp;rsquo;ll implement the &lt;code&gt;execute&lt;/code&gt; function so it takes the closure it&amp;rsquo;s given and gives it to an idle thread in the pool to run.</source>
          <target state="translated">警告とエラーが表示されます。少しの間警告を無視すると、 &lt;code&gt;ThreadPool&lt;/code&gt; に &lt;code&gt;execute&lt;/code&gt; メソッドがないためエラーが発生します。スレッドプールに &lt;code&gt;thread::spawn&lt;/code&gt; と同様のインターフェイスが必要であると判断した&lt;a href=&quot;#creating-a-similar-interface-for-a-finite-number-of-threads&quot;&gt;「有限数のスレッド用の同様のインターフェイスの作成」&lt;/a&gt;セクションを思い出してください。さらに、 &lt;code&gt;execute&lt;/code&gt; 関数を実装して、指定されたクロージャーを受け取り、プール内のアイドルスレッドに渡して実行します。</target>
        </trans-unit>
        <trans-unit id="d7705a7f1894fbc9d3a536be0dfea4d6af32a807" translate="yes" xml:space="preserve">
          <source>Now we need to bring the code we moved to &lt;em&gt;src/lib.rs&lt;/em&gt; into the scope of the binary crate in &lt;em&gt;src/main.rs&lt;/em&gt;, as shown in Listing 12-14.</source>
          <target state="translated">次に、リスト12-14に示すように、&lt;em&gt;src / lib.rs&lt;/em&gt;に移動したコードを&lt;em&gt;src / main.rs&lt;/em&gt;のバイナリクレートのスコープに&lt;em&gt;含める&lt;/em&gt;必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b54fd4c3b5f78dc6afcacc14a208e5f25a781f43" translate="yes" xml:space="preserve">
          <source>Now we need to update the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt;: if the state is &lt;code&gt;Published&lt;/code&gt;, we want to return the value in the post&amp;rsquo;s &lt;code&gt;content&lt;/code&gt; field; otherwise, we want to return an empty string slice, as shown in Listing 17-17:</source>
          <target state="translated">次に、 &lt;code&gt;Post&lt;/code&gt; の &lt;code&gt;content&lt;/code&gt; メソッドを更新する必要があります。状態が &lt;code&gt;Published&lt;/code&gt; の場合、投稿の &lt;code&gt;content&lt;/code&gt; フィールドに値を返します。それ以外の場合は、リスト17-17に示すように、空の文字列スライスを返します。</target>
        </trans-unit>
        <trans-unit id="6174f1c624d6e6d6e079aee3674396394f363d5b" translate="yes" xml:space="preserve">
          <source>Now we see the error onscreen and &lt;em&gt;output.txt&lt;/em&gt; contains nothing, which is the behavior we expect of command line programs.</source>
          <target state="translated">画面にエラーが表示され、&lt;em&gt;output.txtに&lt;/em&gt;は何も含まれていません。これは、コマンドラインプログラムで想定されている動作です。</target>
        </trans-unit>
        <trans-unit id="cdda59c39165af59e97381c7390ecfef3d12a8f6" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add functionality to read the file that is specified in the &lt;code&gt;filename&lt;/code&gt; command line argument. First, we need a sample file to test it with: the best kind of file to use to make sure &lt;code&gt;minigrep&lt;/code&gt; is working is one with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called &lt;em&gt;poem.txt&lt;/em&gt; at the root level of your project, and enter the poem &amp;ldquo;I&amp;rsquo;m Nobody! Who are you?&amp;rdquo;</source>
          <target state="translated">次に、 &lt;code&gt;filename&lt;/code&gt; コマンドライン引数で指定されたファイルを読み取る機能を追加します。最初に、テストするためのサンプルファイルが必要です &lt;code&gt;minigrep&lt;/code&gt; が機能していることを確認するために使用する最適な種類のファイルは、複数の行に少量のテキストがあり、いくつかの単語が繰り返されているファイルです。リスト12-3には、うまく機能するEmily Dickinsonの詩があります。プロジェクトのルートレベルに&lt;em&gt;poem.txt&lt;/em&gt;というファイルを作成し、「I'm Nobody！あなたは誰？&quot;</target>
        </trans-unit>
        <trans-unit id="dd1d31103e62a1ec520be0bcddbbbdb89e976849" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll add some types that implement the &lt;code&gt;Draw&lt;/code&gt; trait. We&amp;rsquo;ll provide the &lt;code&gt;Button&lt;/code&gt; type. Again, actually implementing a GUI library is beyond the scope of this book, so the &lt;code&gt;draw&lt;/code&gt; method won&amp;rsquo;t have any useful implementation in its body. To imagine what the implementation might look like, a &lt;code&gt;Button&lt;/code&gt; struct might have fields for &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt;, as shown in Listing 17-7:</source>
          <target state="translated">次に、 &lt;code&gt;Draw&lt;/code&gt; トレイトを実装する型をいくつか追加します。 &lt;code&gt;Button&lt;/code&gt; タイプを提供します。繰り返しますが、実際にGUIライブラリを実装することはこの本の範囲を超えているため、 &lt;code&gt;draw&lt;/code&gt; メソッドの本体には便利な実装がありません。リスト17-7に示すように、実装がどのように見えるかを想像するために、 &lt;code&gt;Button&lt;/code&gt; 構造体には &lt;code&gt;width&lt;/code&gt; 、 &lt;code&gt;height&lt;/code&gt; 、および &lt;code&gt;label&lt;/code&gt; のフィールドがある場合があります。</target>
        </trans-unit>
        <trans-unit id="e57698dd0ca960cc0b20cbcaaf7560d2276dfedc" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement sending data in response to a client request. Responses have the following format:</source>
          <target state="translated">次に、クライアント要求に応答してデータを送信することを実装します。応答の形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="faa7223d94f8959f76182c7251992c3581bab825" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll implement the &lt;code&gt;Drop&lt;/code&gt; trait to call &lt;code&gt;join&lt;/code&gt; on each of the threads in the pool so they can finish the requests they&amp;rsquo;re working on before closing. Then we&amp;rsquo;ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we&amp;rsquo;ll modify our server to accept only two requests before gracefully shutting down its thread pool.</source>
          <target state="translated">次に、 &lt;code&gt;Drop&lt;/code&gt; トレイトを実装して、プール内の各スレッドで &lt;code&gt;join&lt;/code&gt; を呼び出し、閉じている前に作業中のリクエストを完了できるようにします。次に、新しいリクエストの受け入れを停止してシャットダウンする必要があるスレッドを通知する方法を実装します。このコードの動作を確認するために、スレッドプールを正常にシャットダウンする前に、2つの要求のみを受け入れるようにサーバーを変更します。</target>
        </trans-unit>
        <trans-unit id="f36ce7a9b5e2c1e7eedfaeab844cfb65b78a49c0" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll tackle the problem that the closures given to &lt;code&gt;thread::spawn&lt;/code&gt; do absolutely nothing. Currently, we get the closure we want to execute in the &lt;code&gt;execute&lt;/code&gt; method. But we need to give &lt;code&gt;thread::spawn&lt;/code&gt; a closure to run when we create each &lt;code&gt;Worker&lt;/code&gt; during the creation of the &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;thread::spawn&lt;/code&gt; 指定されたクロージャーがまったく何もしないという問題に取り組みます。現在、 &lt;code&gt;execute&lt;/code&gt; メソッドで実行するクロージャーを取得しています。ただし、 &lt;code&gt;ThreadPool&lt;/code&gt; の作成中に各 &lt;code&gt;Worker&lt;/code&gt; を作成するときに実行するクロージャーを &lt;code&gt;thread::spawn&lt;/code&gt; に与える必要があります。</target>
        </trans-unit>
        <trans-unit id="0ff72d33ea4877ceb607d0497b7819ecb5fe8345" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll work on fixing our error handling. Recall that attempting to access the values in the &lt;code&gt;args&lt;/code&gt; vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:</source>
          <target state="translated">次に、エラー処理の修正に取り組みます。インデックス1またはインデックス2で &lt;code&gt;args&lt;/code&gt; ベクトルの値にアクセスしようとすると、ベクトルに含まれるアイテムが3つ未満の場合、プログラムがパニックを起こすことを思い出してください。引数なしでプログラムを実行してみてください。次のようになります。</target>
        </trans-unit>
        <trans-unit id="13208408fb234a6274c662e0cea2839eb0d4df4f" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;re tracking a starting &lt;em&gt;and&lt;/em&gt; an ending index, and we have even more values that were calculated from data in a particular state but aren&amp;rsquo;t tied to that state at all. We now have three unrelated variables floating around that need to be kept in sync.</source>
          <target state="translated">ここで、開始インデックス&lt;em&gt;と&lt;/em&gt;終了インデックスを追跡しています。特定の状態のデータから計算されたが、その状態にまったく関連付けられていない値がさらにあります。これで、同期を保つ必要のある3つの無関係な変数が浮かんでいます。</target>
        </trans-unit>
        <trans-unit id="e2c6d85ff7e11c55ebfacf4a5ea15b76883f9037" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;first_word&lt;/code&gt;, we get back a single value that is tied to the underlying data. The value is made up of a reference to the starting point of the slice and the number of elements in the slice.</source>
          <target state="translated">ここで、 &lt;code&gt;first_word&lt;/code&gt; を呼び出すと、基になるデータに関連付けられている単一の値が返されます。値は、スライスの開始点への参照とスライス内の要素数で構成されます。</target>
        </trans-unit>
        <trans-unit id="ae56f18fed45d04e5e1b1341584607fec330d0c6" translate="yes" xml:space="preserve">
          <source>Now when we run the program, we won&amp;rsquo;t get any errors, and we&amp;rsquo;ll see the following output:</source>
          <target state="translated">プログラムを実行すると、エラーは発生せず、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="a1e40e49d7c93a75ee26e23465f603f6bbef3e57" translate="yes" xml:space="preserve">
          <source>Now when we run the test, we&amp;rsquo;ll get a more informative error message:</source>
          <target state="translated">テストを実行すると、より有益なエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="77f2a1a56e2b0bc8d28e09777d58b6d63d25bdc8" translate="yes" xml:space="preserve">
          <source>Now you know how the newtype pattern is used in relation to traits; it&amp;rsquo;s also a useful pattern even when traits are not involved. Let&amp;rsquo;s switch focus and look at some advanced ways to interact with Rust&amp;rsquo;s type system.</source>
          <target state="translated">これで、特性に関連してnewtypeパターンがどのように使用されるかがわかりました。これは、特性が関係していない場合でも有用なパターンです。フォーカスを切り替えて、Rustの型システムとやり取りするいくつかの高度な方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="698e184c44b77b78a4f0259358fd0568a9ef42f1" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;foo()&lt;/code&gt; can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call &lt;code&gt;foo()&lt;/code&gt; on types implementing that trait that aren't behind trait objects.</source>
          <target state="translated">さて、 &lt;code&gt;foo()&lt;/code&gt; もはや形質オブジェクトで呼び出さないことができますが、あなたは今形質オブジェクトを作るために許可され、それは、任意のオブジェクト・安全なメソッドを呼び出すことができるようになります。そのような境界があっても、特性オブジェクトの背後にない特性を実装する型で &lt;code&gt;foo()&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e2eab767e7fabf7d41783d8a69e9cbea73a62c87" translate="yes" xml:space="preserve">
          <source>Now, every time you call &lt;code&gt;rustc&lt;/code&gt; or &lt;code&gt;cargo&lt;/code&gt; inside of &lt;em&gt;~/projects/needs-nightly&lt;/em&gt;, &lt;code&gt;rustup&lt;/code&gt; will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!</source>
          <target state="translated">これで、&lt;em&gt;〜/ projects / needs-nightly&lt;/em&gt;内で &lt;code&gt;rustc&lt;/code&gt; または &lt;code&gt;cargo&lt;/code&gt; を呼び出すたびに、 &lt;code&gt;rustup&lt;/code&gt; はデフォルトの安定したRustではなく、毎晩のRustを使用していることを確認します。これは、Rustプロジェクトがたくさんあるときに便利です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e79236607753f413c66ac854a24fa640c09a981f" translate="yes" xml:space="preserve">
          <source>Now, if we have the following code:</source>
          <target state="translated">さて、以下のようなコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="8bfc390ee5863dbfd9bc2b1fac71150d32bafb63" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try to share a value between multiple threads using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. Note that the next few examples will have compiler errors, and we&amp;rsquo;ll use those errors to learn more about using &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and how Rust helps us use it correctly. Listing 16-13 has our starting example:</source>
          <target state="translated">ここで、 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; を使用して複数のスレッド間で値を共有してみましょう。10個のスレッドをスピンアップし、それぞれにカウンター値を1ずつ増加させるため、カウンターは0から10に変化します。次のいくつかの例ではコンパイラエラーが発生することに注意してください。これらのエラーを使用して、使用の詳細を学習します &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; とRustがそれを正しく使用するのにどのように役立つか。リスト16-13は最初の例です：</target>
        </trans-unit>
        <trans-unit id="4684dc088b34ae2083e2057208489a24262c5c09" translate="yes" xml:space="preserve">
          <source>Now, run this program using &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;cargo run&lt;/code&gt; を使用してこのプログラムを実行します。</target>
        </trans-unit>
        <trans-unit id="5f63a9b785af57bd0365b9cf3f0ad0d87a3314b8" translate="yes" xml:space="preserve">
          <source>Now, the alias &lt;code&gt;Kilometers&lt;/code&gt; is a &lt;em&gt;synonym&lt;/em&gt; for &lt;code&gt;i32&lt;/code&gt;; unlike the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; types we created in Listing 19-15, &lt;code&gt;Kilometers&lt;/code&gt; is not a separate, new type. Values that have the type &lt;code&gt;Kilometers&lt;/code&gt; will be treated the same as values of type &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">現在、エイリアス &lt;code&gt;Kilometers&lt;/code&gt; は &lt;code&gt;i32&lt;/code&gt; の&lt;em&gt;同義語&lt;/em&gt;です。リスト19-15で作成した &lt;code&gt;Millimeters&lt;/code&gt; &lt;code&gt;Meters&lt;/code&gt; とメーターのタイプとは異なり、 &lt;code&gt;Kilometers&lt;/code&gt; は独立した新しいタイプではありません。タイプが &lt;code&gt;Kilometers&lt;/code&gt; の値は、タイプ &lt;code&gt;i32&lt;/code&gt; の値と同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="89254150c2be7dc87d0a9f78d979708d51af3c47" translate="yes" xml:space="preserve">
          <source>Now, we can go further. Here are some erroneous code examples:</source>
          <target state="translated">さて、さらに先に進むことができます。誤ったコード例を紹介します。</target>
        </trans-unit>
        <trans-unit id="0a10d92135d2873e2b02f8fce9c6f1692a0cbb60" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;?&lt;/code&gt; instead of &lt;code&gt;match&lt;/code&gt;, and the return type makes a lot more sense: if the loop ever stops, it means that an error occurred. We don't even have to wrap the loop in an &lt;code&gt;Ok&lt;/code&gt; because &lt;code&gt;!&lt;/code&gt; coerces to &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; automatically.</source>
          <target state="translated">これで使用できます &lt;code&gt;?&lt;/code&gt; &lt;code&gt;match&lt;/code&gt; の代わりに、戻り値の型はより理にかなっています。ループが停止する場合は、エラーが発生したことを意味します。私たちも、ループをラップする必要はありません &lt;code&gt;Ok&lt;/code&gt; 理由 &lt;code&gt;!&lt;/code&gt; &lt;code&gt;Result&amp;lt;!, ConnectionError&amp;gt;&lt;/code&gt; 自動的に強制します。</target>
        </trans-unit>
        <trans-unit id="00574ee534bf3b794cc8e985f367f79be7646f65" translate="yes" xml:space="preserve">
          <source>Now, when the server disconnects, we exit the loop with an error instead of panicking. While it might be intuitive to simply return the error, we might want to wrap it in a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">これで、サーバーが切断すると、パニックする代わりにエラーでループを終了します。単純にエラーを返すのは直感的かもしれませんが、代わりに&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt;ラップすることもできます。</target>
        </trans-unit>
        <trans-unit id="63f5d491af12e32408bf602e1dfb4af7a20ca44f" translate="yes" xml:space="preserve">
          <source>Now, without changing any of the code, let&amp;rsquo;s build the project, as shown in Listing 2-2.</source>
          <target state="translated">コードを変更せずに、リスト2-2に示すようにプロジェクトをビルドします。</target>
        </trans-unit>
        <trans-unit id="335506e2ff8a4e3e39e5a5e2b3fc6bf1463c0bb5" translate="yes" xml:space="preserve">
          <source>Now, you get all of the default values. Rust implements &lt;code&gt;Default&lt;/code&gt; for various primitives types.</source>
          <target state="translated">これで、すべてのデフォルト値が取得されます。Rust はさまざまなプリミティブタイプに &lt;code&gt;Default&lt;/code&gt; を実装します。</target>
        </trans-unit>
        <trans-unit id="019a7808328d4c7ef510130b49858e7cc7a93df4" translate="yes" xml:space="preserve">
          <source>NulError</source>
          <target state="translated">NulError</target>
        </trans-unit>
        <trans-unit id="0cb22fef16057827ecc4973a05f1f48159ecfb08" translate="yes" xml:space="preserve">
          <source>NulError::borrow</source>
          <target state="translated">NulError::borrow</target>
        </trans-unit>
        <trans-unit id="093c6ad11b2674276a386aef18e019c41e18c73d" translate="yes" xml:space="preserve">
          <source>NulError::borrow_mut</source>
          <target state="translated">NulError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2212c8b5028758465c03e3f70e4f2b53155ddf4f" translate="yes" xml:space="preserve">
          <source>NulError::cause</source>
          <target state="translated">NulError::cause</target>
        </trans-unit>
        <trans-unit id="29768f5bfd32a963dcb296b9cb20f40a82c74df5" translate="yes" xml:space="preserve">
          <source>NulError::clone</source>
          <target state="translated">NulError::clone</target>
        </trans-unit>
        <trans-unit id="11102afce6dc8292dc39655665283f8191fb13f1" translate="yes" xml:space="preserve">
          <source>NulError::clone_from</source>
          <target state="translated">NulError::clone_from</target>
        </trans-unit>
        <trans-unit id="f533f8602af54aaa16eff696d1575d42e14848a1" translate="yes" xml:space="preserve">
          <source>NulError::clone_into</source>
          <target state="translated">NulError::clone_into</target>
        </trans-unit>
        <trans-unit id="dbdb7cc3a8e4e6691a99909b0fc53de13cd8f2d3" translate="yes" xml:space="preserve">
          <source>NulError::description</source>
          <target state="translated">NulError::description</target>
        </trans-unit>
        <trans-unit id="90a567cb98b0dcdd50aff9ea97e9fff9eaab566d" translate="yes" xml:space="preserve">
          <source>NulError::eq</source>
          <target state="translated">NulError::eq</target>
        </trans-unit>
        <trans-unit id="5a4bafcb93f1795790aaa47109d1e73bf1dc48ee" translate="yes" xml:space="preserve">
          <source>NulError::fmt</source>
          <target state="translated">NulError::fmt</target>
        </trans-unit>
        <trans-unit id="fea70f345cef208acafc3c691d14a34ddbaffb2c" translate="yes" xml:space="preserve">
          <source>NulError::from</source>
          <target state="translated">NulError::from</target>
        </trans-unit>
        <trans-unit id="c667a60cc8a552cdd2774d6820e70ba3a6f7fa11" translate="yes" xml:space="preserve">
          <source>NulError::into</source>
          <target state="translated">NulError::into</target>
        </trans-unit>
        <trans-unit id="30b7683d9cdd43993a6fc1126ff7ee715887f7b2" translate="yes" xml:space="preserve">
          <source>NulError::into_vec</source>
          <target state="translated">NulError::into_vec</target>
        </trans-unit>
        <trans-unit id="0a051a00c0c437269ea80583c284491216e4bda7" translate="yes" xml:space="preserve">
          <source>NulError::ne</source>
          <target state="translated">NulError::ne</target>
        </trans-unit>
        <trans-unit id="2853d8c78438f77254b0a497c86fde1fc17dc043" translate="yes" xml:space="preserve">
          <source>NulError::nul_position</source>
          <target state="translated">NulError::nul_position</target>
        </trans-unit>
        <trans-unit id="266ad98111087a4df9e19e655c096e1306270de2" translate="yes" xml:space="preserve">
          <source>NulError::source</source>
          <target state="translated">NulError::source</target>
        </trans-unit>
        <trans-unit id="5a34a4566a411696ebf16a2b9ec49441272c8c0b" translate="yes" xml:space="preserve">
          <source>NulError::to_owned</source>
          <target state="translated">NulError::to_owned</target>
        </trans-unit>
        <trans-unit id="657290a7e7bc42a0480eee65c34175ba47172560" translate="yes" xml:space="preserve">
          <source>NulError::to_string</source>
          <target state="translated">NulError::to_string</target>
        </trans-unit>
        <trans-unit id="d1202df6e66660732652af8ec880ff1ae89ff7c3" translate="yes" xml:space="preserve">
          <source>NulError::try_from</source>
          <target state="translated">NulError::try_from</target>
        </trans-unit>
        <trans-unit id="1d16960d944bfade9db6cf467b0e67afd7e5faaf" translate="yes" xml:space="preserve">
          <source>NulError::try_into</source>
          <target state="translated">NulError::try_into</target>
        </trans-unit>
        <trans-unit id="1f3e1c8599374779dd8128ca0f06731901b2e4e4" translate="yes" xml:space="preserve">
          <source>NulError::type_id</source>
          <target state="translated">NulError::type_id</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="a7321f8049c14a666fefc1ca42149346db408d7b" translate="yes" xml:space="preserve">
          <source>Null-unchecked version</source>
          <target state="translated">ヌルチェック版</target>
        </trans-unit>
        <trans-unit id="2276df81ba459368e74bc9d4361d3c8cfd09f1df" translate="yes" xml:space="preserve">
          <source>Nullable pointers</source>
          <target state="translated">ヌル可能なポインタ</target>
        </trans-unit>
        <trans-unit id="c25cad253b19d0908d73f07b038e8b9aad37e183" translate="yes" xml:space="preserve">
          <source>Number literals</source>
          <target state="translated">数値リテラル</target>
        </trans-unit>
        <trans-unit id="bcec75d4dad01d7ef8298e79673d17da682b5ff9" translate="yes" xml:space="preserve">
          <source>Number of significant digits in base 2.</source>
          <target state="translated">ベースの有効桁数 2.</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="21e67f90f74a7a640f48c34557cd9804c3bb16bf" translate="yes" xml:space="preserve">
          <source>Numeric Operations</source>
          <target state="translated">数値演算</target>
        </trans-unit>
        <trans-unit id="46e7eddaee58aa04d38eef7cd137db7696751094" translate="yes" xml:space="preserve">
          <source>Numeric cast</source>
          <target state="translated">数値キャスト</target>
        </trans-unit>
        <trans-unit id="5fc7eba5de8d1ad8c7f788326b72adec568ef6c6" translate="yes" xml:space="preserve">
          <source>Numeric literal of specific type</source>
          <target state="translated">特定の型の数値リテラル</target>
        </trans-unit>
        <trans-unit id="1569010f07b1014b3cf4df2495e2025b598353cd" translate="yes" xml:space="preserve">
          <source>Numeric type</source>
          <target state="translated">数値型</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">数値型</target>
        </trans-unit>
        <trans-unit id="448f04fec46467e790879ea8707bb67f916a6de0" translate="yes" xml:space="preserve">
          <source>Numeric values used in this type don't have portable meanings, and different platforms may mask different amounts of them.</source>
          <target state="translated">この型で使用される数値は移植性のある意味を持たず、異なるプラットフォームでは異なる量をマスクすることがあります。</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="41a98fdd88fe9c4cdb77aa3ef162d2e340554b26" translate="yes" xml:space="preserve">
          <source>O(1)~</source>
          <target state="translated">O(1)~</target>
        </trans-unit>
        <trans-unit id="aae47a530dc867303fbce9c5d00c60595dd72df2" translate="yes" xml:space="preserve">
          <source>O(1)~*</source>
          <target state="translated">O(1)~*</target>
        </trans-unit>
        <trans-unit id="21c63d891edf29bd0dc5694a68dc0fe5e6523174" translate="yes" xml:space="preserve">
          <source>O(log n)</source>
          <target state="translated">オー(対数n)</target>
        </trans-unit>
        <trans-unit id="eed5a0c9d789f93df61247fbcb2bb3a3c20ad0c2" translate="yes" xml:space="preserve">
          <source>O(m)*</source>
          <target state="translated">O(m)*</target>
        </trans-unit>
        <trans-unit id="0a498ed9d22d1c99ae0662d3eb2e582169c852e2" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))</source>
          <target state="translated">O(min(i,n-i))</target>
        </trans-unit>
        <trans-unit id="dede0f12fa78bfb74f3fa2188214d44df32644d9" translate="yes" xml:space="preserve">
          <source>O(min(i, n-i))*</source>
          <target state="translated">O(min(i,n-i))*</target>
        </trans-unit>
        <trans-unit id="1eb19fcfc5873ac1d44e4d58ddd8518a66a4491a" translate="yes" xml:space="preserve">
          <source>O(n+m)</source>
          <target state="translated">O(n+m)</target>
        </trans-unit>
        <trans-unit id="c8fadbf37575cb84317acb6f8d4f3d46463f8753" translate="yes" xml:space="preserve">
          <source>O(n-i)</source>
          <target state="translated">O(n-i)</target>
        </trans-unit>
        <trans-unit id="cc8b4f2a60d0d1f3741e6ca4292cce74adf6d07a" translate="yes" xml:space="preserve">
          <source>O(n-i)*</source>
          <target state="translated">O(n-i)*</target>
        </trans-unit>
        <trans-unit id="40df041793dd78f66b71a0840b6daf38640d0a3a" translate="yes" xml:space="preserve">
          <source>OCT_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;]</source>
          <target state="translated">OCT_DIGIT：[ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;7&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="2458dc9d400f320af963a0c090896d1bb8a3eafb" translate="yes" xml:space="preserve">
          <source>OCT_LITERAL :</source>
          <target state="translated">OCT_LITERAL .</target>
        </trans-unit>
        <trans-unit id="7eefb54fc6fa85bcfd8cad8fd3e002943372f832" translate="yes" xml:space="preserve">
          <source>ONCE_INIT</source>
          <target state="translated">ONCE_INIT</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="c616ed05e5cb0d4373e277ab3e8348ce34b627e9" translate="yes" xml:space="preserve">
          <source>OS-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt;に対するOS固有の拡張機能。</target>
        </trans-unit>
        <trans-unit id="d40770bb8444e5820c3f38469b205f65cc11cae4" translate="yes" xml:space="preserve">
          <source>OS-specific functionality.</source>
          <target state="translated">OS固有の機能。</target>
        </trans-unit>
        <trans-unit id="a6c434024b24606a906b9f03f39592fffa3be309" translate="yes" xml:space="preserve">
          <source>OUTER_BLOCK_DOC :</source>
          <target state="translated">OUTER_BLOCK_DOC .</target>
        </trans-unit>
        <trans-unit id="0bb940376a39f5fb9ff8c9b1c3a635c5bc777eb9" translate="yes" xml:space="preserve">
          <source>OUTER_LINE_DOC :</source>
          <target state="translated">OUTER_LINE_DOC .</target>
        </trans-unit>
        <trans-unit id="497044c1c5d284e50b6c69945072ebc9add34281" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming Features of Rust</source>
          <target state="translated">Rustのオブジェクト指向プログラミング機能</target>
        </trans-unit>
        <trans-unit id="1cd60d3a8e30cd469c24d35e86095d88eed38ea9" translate="yes" xml:space="preserve">
          <source>Object Safety</source>
          <target state="translated">オブジェクトの安全性</target>
        </trans-unit>
        <trans-unit id="907637cc210857e2030448d19632670732a6954a" translate="yes" xml:space="preserve">
          <source>Object Safety Is Required for Trait Objects</source>
          <target state="translated">形質物体には物体の安全性が求められる</target>
        </trans-unit>
        <trans-unit id="bca6b9d231b55a9e6e8a10f5e5322c009f386439" translate="yes" xml:space="preserve">
          <source>Object safe traits</source>
          <target state="translated">オブジェクトの安全な特性</target>
        </trans-unit>
        <trans-unit id="c0123c00fdac3367f93d574c1f48635a32708f0d" translate="yes" xml:space="preserve">
          <source>Object safe traits can be the base trait of a &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;. A trait is &lt;em&gt;object safe&lt;/em&gt; if it has the following qualities (defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255&lt;/a&gt;):</source>
          <target state="translated">オブジェクトセーフトレイトは、&lt;a href=&quot;../types/trait-object&quot;&gt;トレイトオブジェクトの&lt;/a&gt;基本トレイトにできます。トレイトは、次の品質（&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;RFC 255で&lt;/a&gt;定義）を持つ場合、&lt;em&gt;オブジェクトセーフ&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="23297e036939da16d72f8c944d8900bfb5bf3104" translate="yes" xml:space="preserve">
          <source>Object-oriented programming (OOP) is a way of modeling programs. Objects came from Simula in the 1960s. Those objects influenced Alan Kay&amp;rsquo;s programming architecture in which objects pass messages to each other. He coined the term &lt;em&gt;object-oriented programming&lt;/em&gt; in 1967 to describe this architecture. Many competing definitions describe what OOP is; some definitions would classify Rust as object oriented, but other definitions would not. In this chapter, we&amp;rsquo;ll explore certain characteristics that are commonly considered object oriented and how those characteristics translate to idiomatic Rust. We&amp;rsquo;ll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust&amp;rsquo;s strengths instead.</source>
          <target state="translated">オブジェクト指向プログラミング（OOP）は、プログラムをモデル化する方法の1つです。オブジェクトは1960年代にSimulaから来ました。これらのオブジェクトは、オブジェクトが相互にメッセージを渡すアランケイのプログラミングアーキテクチャに影響を与えました。彼は1967年に&lt;em&gt;オブジェクト指向プログラミング&lt;/em&gt;という用語を作り、このアーキテクチャを説明しました。多くの競合する定義はOOPとは何かを説明しています。 Rustをオブジェクト指向として分類する定義もあれば、そうでない定義もあります。この章では、一般にオブジェクト指向と見なされている特定の特性と、それらの特性がどのように慣用的なRustに変換されるかについて説明します。次に、Rustにオブジェクト指向のデザインパターンを実装する方法を示し、Rustの長所の一部を使用してソリューションを実装する場合とそうでない場合のトレードオフについて説明します。</target>
        </trans-unit>
        <trans-unit id="93a2f7998a1b0abd936ff0b0c2f570cbbedd6635" translate="yes" xml:space="preserve">
          <source>Object-oriented programs are made up of objects. An &lt;em&gt;object&lt;/em&gt; packages both data and the procedures that operate on that data. The procedures are typically called &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;operations&lt;/em&gt;.</source>
          <target state="translated">オブジェクト指向プログラムはオブジェクトで構成されています。&lt;em&gt;オブジェクトは&lt;/em&gt;、データとそのデータを操作手順の両方をパッケージ化します。手順は通常、&lt;em&gt;メソッド&lt;/em&gt;または&lt;em&gt;操作&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="69fa88294fcaac54902a4347d53a07e91ef5771c" translate="yes" xml:space="preserve">
          <source>Objects Contain Data and Behavior</source>
          <target state="translated">オブジェクトにはデータと振る舞いが含まれています</target>
        </trans-unit>
        <trans-unit id="d206d3fa18be5581f351f10db48f9bf4a1014628" translate="yes" xml:space="preserve">
          <source>Objects that can be stepped over in both directions.</source>
          <target state="translated">両方向に踏ん張れる物体。</target>
        </trans-unit>
        <trans-unit id="b899f01274e7bc44fb14d411dd765a15a7787c5f" translate="yes" xml:space="preserve">
          <source>Occasionally it may be desirable not to expose in an API that there is mutation happening &quot;under the hood&quot;. This may be because logically the operation is immutable, but e.g., caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">場合によっては、「内部」で起こっている突然変異があることをAPIで公開しないことが望ましい場合があります。これは、論理的には操作が不変である可能性がありますが、たとえば、キャッシングにより実装は強制的に変更を実行します。または、最初は &lt;code&gt;&amp;amp;self&lt;/code&gt; を取るように定義されていた特性メソッドを実装するために突然変異を採用する必要があるため。</target>
        </trans-unit>
        <trans-unit id="473e728a2f59da64c670799897819b1d614ba35f" translate="yes" xml:space="preserve">
          <source>OccupiedEntry</source>
          <target state="translated">OccupiedEntry</target>
        </trans-unit>
        <trans-unit id="9d9953ee64c9a9ed960498f1a51e79c8aae9c8dd" translate="yes" xml:space="preserve">
          <source>Occurrences of &lt;code&gt;.&lt;/code&gt; are normalized away, except if they are at the beginning of the path. For example, &lt;code&gt;a/./b&lt;/code&gt;, &lt;code&gt;a/b/&lt;/code&gt;, &lt;code&gt;a/b/.&lt;/code&gt; and &lt;code&gt;a/b&lt;/code&gt; all have &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as components, but &lt;code&gt;./a/b&lt;/code&gt; starts with an additional &lt;a href=&quot;enum.component#variant.CurDir&quot;&gt;&lt;code&gt;CurDir&lt;/code&gt;&lt;/a&gt; component.</source>
          <target state="translated">の出現 &lt;code&gt;.&lt;/code&gt; パスの先頭にある場合を除いて、正規化されます。たとえば、 &lt;code&gt;a/./b&lt;/code&gt; 、 &lt;code&gt;a/b/&lt;/code&gt; 、 &lt;code&gt;a/b/.&lt;/code&gt; 及び &lt;code&gt;a/b&lt;/code&gt; すべて持っていると &lt;code&gt;b&lt;/code&gt; 成分としての、しかし &lt;code&gt;./a/b&lt;/code&gt; 追加で始まり&lt;a href=&quot;enum.component#variant.CurDir&quot;&gt; &lt;code&gt;CurDir&lt;/code&gt; &lt;/a&gt;コンポーネント。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="e6f02e23e2b227ac6699b92be300da464d475a6e" translate="yes" xml:space="preserve">
          <source>Octal integer</source>
          <target state="translated">八進整数</target>
        </trans-unit>
        <trans-unit id="d04577406c042a11b4da7bb39486816308c607a6" translate="yes" xml:space="preserve">
          <source>Octal::fmt</source>
          <target state="translated">Octal::fmt</target>
        </trans-unit>
        <trans-unit id="615b20b5b110a1806177c985ebbca57031daa785" translate="yes" xml:space="preserve">
          <source>Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.</source>
          <target state="translated">もちろん、どのコレクションが正しい使い方なのかを知っていても、すぐに正しい使い方ができるわけではありません。ここでは、一般的な標準コレクションを効率的かつ正しく使うための簡単なヒントをいくつか紹介します。特定のコレクションの使い方に興味がある場合は、ドキュメントを参照して詳細な説明とコード例を確認してください。</target>
        </trans-unit>
        <trans-unit id="2cbe09e34f3d1d91d444d3537b55bb92b3326aea" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;a href=&quot;fn.stdout&quot;&gt;&lt;code&gt;io::stdout&lt;/code&gt;&lt;/a&gt; directly is less common than something like &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">もちろん、&lt;a href=&quot;fn.stdout&quot;&gt; &lt;code&gt;io::stdout&lt;/code&gt; &lt;/a&gt;直接使用するのは、&lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;ようなものよりも一般的ではありません。。</target>
        </trans-unit>
        <trans-unit id="35d478ea3e054425d68cac2b881bb4303c629df5" translate="yes" xml:space="preserve">
          <source>Often, you&amp;rsquo;ll want to combine two existing strings. One way is to use the &lt;code&gt;+&lt;/code&gt; operator, as shown in Listing 8-18.</source>
          <target state="translated">多くの場合、2つの既存の文字列を組み合わせる必要があります。リスト8-18に示すように、1つの方法は &lt;code&gt;+&lt;/code&gt; 演算子を使用することです。</target>
        </trans-unit>
        <trans-unit id="6b1d4e18544489b4eaf442b238d12d6d0846066b" translate="yes" xml:space="preserve">
          <source>On Linux systems, if this is compiled as &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Linuxシステムで、これが &lt;code&gt;foo&lt;/code&gt; としてコンパイルされている場合：</target>
        </trans-unit>
        <trans-unit id="81c83f6982dcc0359616815ff2d1c2e0f9aa8bfa" translate="yes" xml:space="preserve">
          <source>On Linux, macOS, and PowerShell on Windows, you can see the executable by entering the &lt;code&gt;ls&lt;/code&gt; command in your shell. On Linux and macOS, you&amp;rsquo;ll see two files. With PowerShell on Windows, you&amp;rsquo;ll see the same three files that you would see using CMD.</source>
          <target state="translated">Linux、macOS、およびWindows上のPowerShellでは、シェルに &lt;code&gt;ls&lt;/code&gt; コマンドを入力して実行可能ファイルを表示できます。LinuxおよびmacOSでは、2つのファイルが表示されます。Windows上のPowerShellを使用すると、CMDを使用した場合と同じ3つのファイルが表示されます。</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="translated">Linuxで。</target>
        </trans-unit>
        <trans-unit id="28f964279968ee11e024ad4734a1849f6d567b40" translate="yes" xml:space="preserve">
          <source>On Redox this always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Redoxでは、これは常に &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2c27c55a04c34d1416124c71c1487f965daf5e2b" translate="yes" xml:space="preserve">
          <source>On Unix</source>
          <target state="translated">Unixでは</target>
        </trans-unit>
        <trans-unit id="f580d63739e00a5c78d3db723e0a54f4eebdec61" translate="yes" xml:space="preserve">
          <source>On Unix platforms, calling this method corresponds to calling &lt;code&gt;fcntl&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;. On Windows calling this method corresponds to calling &lt;code&gt;ioctlsocket&lt;/code&gt;&lt;code&gt;FIONBIO&lt;/code&gt;.</source>
          <target state="translated">Unixプラットフォームでは、このメソッドの呼び出しは &lt;code&gt;fcntl&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; の呼び出しに対応します。Windowsでは、このメソッドの呼び出しは &lt;code&gt;ioctlsocket&lt;/code&gt; &lt;code&gt;FIONBIO&lt;/code&gt; の呼び出しに対応しています。</target>
        </trans-unit>
        <trans-unit id="368e8ed37eeed58c150496b19476b91dc7031ee8" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times.</source>
          <target state="translated">Unixプラットフォームでは、基礎となるシステムコールは、スプリアスなウェイクアップやシグナルハンドラによって中断されることがあります。少なくとも指定された期間だけスリープが発生するようにするために、この関数はそのシステムコールを複数回呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="5d8d403cb28547a9afda373b97085e009420f7cc" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the underlying syscall may be interrupted by a spurious wakeup or signal handler. To ensure the sleep occurs for at least the specified duration, this function may invoke that system call multiple times. Platforms which do not support nanosecond precision for sleeping will have &lt;code&gt;dur&lt;/code&gt; rounded up to the nearest granularity of time they can sleep for.</source>
          <target state="translated">Unixプラットフォームでは、基になるsyscallが偽のウェイクアップまたはシグナルハンドラーによって中断される場合があります。スリープが少なくとも指定された期間発生することを保証するために、この関数はそのシステムコールを複数回呼び出す場合があります。必要があります睡眠のためのナノ秒の精度をサポートしていないプラットフォーム &lt;code&gt;dur&lt;/code&gt; 、彼らがために眠ることができる時間の最寄りの粒度に切り上げ。</target>
        </trans-unit>
        <trans-unit id="f15b383f304eefe4931d61a084a59f34627760f4" translate="yes" xml:space="preserve">
          <source>On Unix systems shell usually expands unquoted arguments with glob patterns (such as &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;). On Windows this is not done, and such arguments are passed as-is.</source>
          <target state="translated">Unixシステムでは、シェルは通常、引用符で囲まれていない引数をグロブパターン（ &lt;code&gt;*&lt;/code&gt; や &lt;code&gt;?&lt;/code&gt; など）で展開します。Windowsではこれは行われず、そのような引数はそのまま渡されます。</target>
        </trans-unit>
        <trans-unit id="73ed9ce935220230672af1ba06994403c22fd01d" translate="yes" xml:space="preserve">
          <source>On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well.</source>
          <target state="translated">pthread ベースの TLS が使用されている Unix システムでは、メインスレッドが終了してもデストラクタはメインスレッド上の TLS 値に対して実行されません。同様にメインスレッドが終了した直後にアプリケーションが終了することに注意してください。</target>
        </trans-unit>
        <trans-unit id="fb3ee6950e481b93ea06bd207e97b8f1a208a9e6" translate="yes" xml:space="preserve">
          <source>On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.</source>
          <target state="translated">Unixシステムでは、文字列はしばしばゼロではないバイトの任意のシーケンスであり、多くの場合はUTF-8として解釈されます。</target>
        </trans-unit>
        <trans-unit id="ade1ebaf1f97bbb67b44937124b853209f01a0de" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which augments it with two methods, &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt;&lt;code&gt;from_bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;. These do inexpensive conversions from and to UTF-8 byte slices.</source>
          <target state="translated">Unixでは、&lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt;トレイトを実装し、&lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.from_bytes&quot;&gt; &lt;code&gt;from_bytes&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; の&lt;/a&gt; 2つのメソッドを追加します。これらは、UTF-8バイトスライスとの間で安価な変換を行います。</target>
        </trans-unit>
        <trans-unit id="947b55450ee1839446a5472dd42bc83b983d60aa" translate="yes" xml:space="preserve">
          <source>On Unix, a path has a root if it begins with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">Unixでは、パスが &lt;code&gt;/&lt;/code&gt; で始まる場合、パスにはルートがあります。</target>
        </trans-unit>
        <trans-unit id="3bd3b4c86524e4799caf099ecd37af36c6672deb" translate="yes" xml:space="preserve">
          <source>On Unix, a path is absolute if it starts with the root, so &lt;code&gt;is_absolute&lt;/code&gt; and &lt;a href=&quot;#method.has_root&quot;&gt;&lt;code&gt;has_root&lt;/code&gt;&lt;/a&gt; are equivalent.</source>
          <target state="translated">UNIXでは、パスがルートで始まる場合は絶対パスであるため、 &lt;code&gt;is_absolute&lt;/code&gt; と&lt;a href=&quot;#method.has_root&quot;&gt; &lt;code&gt;has_root&lt;/code&gt; &lt;/a&gt;は同等です。</target>
        </trans-unit>
        <trans-unit id="8c49b23a9e8913d5f28e887403c1dd64ea25f5f0" translate="yes" xml:space="preserve">
          <source>On Unix, this will return &lt;code&gt;None&lt;/code&gt; if the process was terminated by a signal; &lt;code&gt;std::os::unix&lt;/code&gt; provides an extension trait for extracting the signal and other details from the &lt;code&gt;ExitStatus&lt;/code&gt;.</source>
          <target state="translated">Unixでは、プロセスがシグナルによって終了した場合、 &lt;code&gt;None&lt;/code&gt; を返します。 &lt;code&gt;std::os::unix&lt;/code&gt; は、 &lt;code&gt;ExitStatus&lt;/code&gt; から信号やその他の詳細を抽出するための拡張特性を提供します。</target>
        </trans-unit>
        <trans-unit id="08103bc8083664f610de1cd76da40c7342e367bf" translate="yes" xml:space="preserve">
          <source>On Windows</source>
          <target state="translated">Windowsの場合</target>
        </trans-unit>
        <trans-unit id="340634e7ba37ae9abb46e394a10f468ca07b5406" translate="yes" xml:space="preserve">
          <source>On Windows and most Unix platforms this function is free (no extra system calls needed), but some Unix platforms may require the equivalent call to &lt;code&gt;symlink_metadata&lt;/code&gt; to learn about the target file type.</source>
          <target state="translated">WindowsおよびほとんどのUnixプラットフォームでは、この関数は無料です（追加のシステムコールは必要ありません）。ただし、一部のUnixプラットフォームでは、ターゲットファイルタイプについて学習するために、 &lt;code&gt;symlink_metadata&lt;/code&gt; への同等の呼び出しが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="dc05b2580f0d12742976994a81fdd3a92daa9627" translate="yes" xml:space="preserve">
          <source>On Windows this function is cheap to call (no extra system calls needed), but on Unix platforms this function is the equivalent of calling &lt;code&gt;symlink_metadata&lt;/code&gt; on the path.</source>
          <target state="translated">Windowsでは、この関数の呼び出しは安価です（追加のシステムコールは必要ありません）が、UNIXプラットフォームでは、この関数はパスで &lt;code&gt;symlink_metadata&lt;/code&gt; を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="96488f7f2e398f8d620db102c3767404f52cec35" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows::ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt;&lt;code&gt;OsStrExt&lt;/code&gt;&lt;/a&gt; trait, which provides an &lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; method. This provides an iterator that can be &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;ed into a vector of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windowsでは、&lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;std::os::windows::ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstrext&quot;&gt; &lt;code&gt;OsStrExt&lt;/code&gt; &lt;/a&gt;トレイトを実装し、&lt;a href=&quot;../os/windows/ffi/trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt;メソッドを提供します。これは、&lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; の&lt;/a&gt;ベクトルに&lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;できる反復子を提供します。</target>
        </trans-unit>
        <trans-unit id="9af64d7ebac16f152870c457029381910a90ad98" translate="yes" xml:space="preserve">
          <source>On Windows, a path has a root if it:</source>
          <target state="translated">Windowsでは、パスはルートを持っています。</target>
        </trans-unit>
        <trans-unit id="23aad31490e7c68a187977dea619fd53f62cad2c" translate="yes" xml:space="preserve">
          <source>On Windows, a path is absolute if it has a prefix and starts with the root: &lt;code&gt;c:\windows&lt;/code&gt; is absolute, while &lt;code&gt;c:temp&lt;/code&gt; and &lt;code&gt;\temp&lt;/code&gt; are not.</source>
          <target state="translated">Windowsでは、パスにプレフィックスがあり、ルートで始まる場合は絶対パスです &lt;code&gt;c:\windows&lt;/code&gt; は絶対パスですが、 &lt;code&gt;c:temp&lt;/code&gt; と &lt;code&gt;\temp&lt;/code&gt; は絶対パスではありません。</target>
        </trans-unit>
        <trans-unit id="76c59bd2f582fcbc4571a1c46e5718df63ea4def" translate="yes" xml:space="preserve">
          <source>On Windows, a symbolic link knows whether it is a file or directory.</source>
          <target state="translated">Windowsでは、シンボリックリンクはそれがファイルかディレクトリかを知っています。</target>
        </trans-unit>
        <trans-unit id="21bc0d515b3e6fb7f3d9412e9a760b756bd52140" translate="yes" xml:space="preserve">
          <source>On Windows, enter the command &lt;code&gt;.\main.exe&lt;/code&gt; instead of &lt;code&gt;./main&lt;/code&gt;:</source>
          <target state="translated">Windowsでは、コマンドを入力してください &lt;code&gt;.\main.exe&lt;/code&gt; 代わりの &lt;code&gt;./main&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bd7a73ca0a18d815fd6e51cfa03502575932403d" translate="yes" xml:space="preserve">
          <source>On Windows, go to &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; and follow the instructions for installing Rust. At some point in the installation, you&amp;rsquo;ll receive a message explaining that you&amp;rsquo;ll also need the C++ build tools for Visual Studio 2013 or later. The easiest way to acquire the build tools is to install &lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;Build Tools for Visual Studio 2019&lt;/a&gt;. The tools are in the Other Tools and Frameworks section.</source>
          <target state="translated">Windowsでは、&lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;https：//www.rust-lang.org/tools/installにアクセスし&lt;/a&gt;、Rustのインストール手順に従います。インストールのある時点で、Visual Studio 2013以降のC ++ビルドツールも必要になることを説明するメッセージが表示されます。ビルドツールを取得する最も簡単な方法は&lt;a href=&quot;https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019&quot;&gt;、Visual Studio 2019用のビルドツール&lt;/a&gt;をインストールすることです。ツールは、「その他のツールとフレームワーク」セクションにあります。</target>
        </trans-unit>
        <trans-unit id="f9e96b3ce49cbd593ce10eba431579916c1beb4e" translate="yes" xml:space="preserve">
          <source>On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.</source>
          <target state="translated">Windows では、 文字列はしばしば 0 以外の 16 ビ ッ ト 値の任意の列で、 有効な場合には UTF-16 として解釈されます。</target>
        </trans-unit>
        <trans-unit id="e57ac5776aebf69e1a4091e5f62bdd9bd9a59609" translate="yes" xml:space="preserve">
          <source>On Windows, this converts the path to use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;extended length path&lt;/a&gt; syntax, which allows your program to use longer path names, but means you can only join backslash-delimited paths to it, and it may be incompatible with other applications (if passed to the application on the command-line, or written to a file another application may read).</source>
          <target state="translated">Windowsでは、これによりパスが&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath&quot;&gt;拡張パス&lt;/a&gt;構文を使用するように変換されます。これにより、プログラムでより長いパス名を使用できるようになりますが、バックスラッシュで区切られたパスのみを結合でき、他のアプリケーションと互換性がない場合があります（コマンドラインでのアプリケーション、または別のアプリケーションが読み取る可能性があるファイルへの書き込み）。</target>
        </trans-unit>
        <trans-unit id="22cfd134aef9e5447e4029c33c01913e82dca29d" translate="yes" xml:space="preserve">
          <source>On Windows, you must specify whether a symbolic link points to a file or directory. Use &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; to create a symbolic link to a file, or &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; to create a symbolic link to a directory. Additionally, the process must have &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; in order to be able to create a symbolic link.</source>
          <target state="translated">Windowsでは、シンボリックリンクがファイルまたはディレクトリを指すかどうかを指定する必要があります。使用 &lt;code&gt;os::windows::fs::symlink_file&lt;/code&gt; ファイルへのシンボリックリンクを作成するために、または &lt;code&gt;os::windows::fs::symlink_dir&lt;/code&gt; ディレクトリへのシンボリックリンクを作成します。さらに、シンボリックリンクを作成できるようにするには、プロセスに &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windowsで。</target>
        </trans-unit>
        <trans-unit id="2d943049f7275605af2957c0729af75e15804644" translate="yes" xml:space="preserve">
          <source>On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">構造体パターン上に、フィールドは（タプル構造体の場合）名、インデックスによって参照されているまたは使用によって無視します &lt;code&gt;..&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc5ae395985a077524b266fc2c058a9c41f9a6c9" translate="yes" xml:space="preserve">
          <source>On a technical level, Rust inserts</source>
          <target state="translated">技術的なレベルでは、Rustが挿入されます。</target>
        </trans-unit>
        <trans-unit id="1b348ad01b675597a26bee9f6007707cf4e88f3f" translate="yes" xml:space="preserve">
          <source>On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run.</source>
          <target state="translated">すべてのプラットフォームで、TLS が破壊中に他の TLS スロットを再初期化することは可能です。いくつかのプラットフォームでは、破壊されたスロットの再初期化を防ぐことで、 これが無限に起こらないようにしていますが、 すべてのプラットフォームがこのガードを持っているわけではありません。ガードしていないプラットフォームは、一般的に合成制限を持っていて、その時点でこれ以上デストラクタを実行しません。</target>
        </trans-unit>
        <trans-unit id="d799d2a3d45a2a27a645560d44031039269d8400" translate="yes" xml:space="preserve">
          <source>On all platforms, the newline is the LINE FEED character (&lt;code&gt;\n&lt;/code&gt;/&lt;code&gt;U+000A&lt;/code&gt;) alone (no additional CARRIAGE RETURN (&lt;code&gt;\r&lt;/code&gt;/&lt;code&gt;U+000D&lt;/code&gt;).</source>
          <target state="translated">すべてのプラットフォームで、改行はLINE FEED文字（ &lt;code&gt;\n&lt;/code&gt; / &lt;code&gt;U+000A&lt;/code&gt; ）のみです（追加のCARRIAGE RETURN（ &lt;code&gt;\r&lt;/code&gt; / &lt;code&gt;U+000D&lt;/code&gt; ）はありません）。</target>
        </trans-unit>
        <trans-unit id="8026d1566cfb33142845deb08dc55be0e48c8b84" translate="yes" xml:space="preserve">
          <source>On arithmetic overflow, returns &lt;code&gt;LayoutErr&lt;/code&gt;.</source>
          <target state="translated">算術オーバーフローでは、 &lt;code&gt;LayoutErr&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="62056a56ee350ef2ac48d7878ee0e8c05c6cdab9" translate="yes" xml:space="preserve">
          <source>On big endian this is a no-op. On little endian the bytes are swapped.</source>
          <target state="translated">ビッグエンディアンでは、これは無効です。リトルエンディアンでは、バイトはスワップされます。</target>
        </trans-unit>
        <trans-unit id="3209db243d37f470d1d7cfe42ce3d766b7bc29ef" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;CString&lt;/code&gt; is returned.</source>
          <target state="translated">失敗すると、元の &lt;code&gt;CString&lt;/code&gt; の所有権が返されます。</target>
        </trans-unit>
        <trans-unit id="4c9afd72e5fc07b12e4a58aab05b5a861ccfe991" translate="yes" xml:space="preserve">
          <source>On failure, ownership of the original &lt;code&gt;OsString&lt;/code&gt; is returned.</source>
          <target state="translated">失敗すると、元の &lt;code&gt;OsString&lt;/code&gt; の所有権が返されます。</target>
        </trans-unit>
        <trans-unit id="3818a4eb5a3ae2432429a2be6f00d2b57327ad67" translate="yes" xml:space="preserve">
          <source>On iteration, the closure will be applied to each element of the iterator and the return value from the closure, an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;, is yielded by the iterator.</source>
          <target state="translated">反復時に、クロージャーはイテレーターの各要素に適用され、クロージャーからの戻り値である&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;はイテレーターによって生成されます。</target>
        </trans-unit>
        <trans-unit id="7ac8ec0fd24d5e212f6e7881f085d7af49a49607" translate="yes" xml:space="preserve">
          <source>On little endian this is a no-op. On big endian the bytes are swapped.</source>
          <target state="translated">リトルエンディアンでは、これは無効です。ビッグエンディアンでは、バイトはスワップされます。</target>
        </trans-unit>
        <trans-unit id="5d4ddcfc8d324d93f4c94125de45c5742f4d5101" translate="yes" xml:space="preserve">
          <source>On non-pointer types &lt;code&gt;*x&lt;/code&gt; is equivalent to &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; in an &lt;a href=&quot;../expressions#mutability&quot;&gt;immutable place expression context&lt;/a&gt; and &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; in a mutable place expression context.</source>
          <target state="translated">非ポインタ型に &lt;code&gt;*x&lt;/code&gt; に相当し、 &lt;code&gt;*std::ops::Deref::deref(&amp;amp;x)&lt;/code&gt; における&lt;a href=&quot;../expressions#mutability&quot;&gt;不変場所発現コンテキスト&lt;/a&gt;及び &lt;code&gt;*std::ops::DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; 可変の場所で式のコンテキスト。</target>
        </trans-unit>
        <trans-unit id="152e667068d08065574b6f3ea75735b1ef22f81c" translate="yes" xml:space="preserve">
          <source>On panic, this macro will print the values of the expressions with their debug representations.</source>
          <target state="translated">パニック時には、このマクロは式の値をデバッグ表現で表示します。</target>
        </trans-unit>
        <trans-unit id="a0e8d873b690ac84365bcb6ce9a48ba9ac4a73cf" translate="yes" xml:space="preserve">
          <source>On some system, calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or similar is necessary for the OS to release resources. A process that terminated but has not been waited on is still around as a &quot;zombie&quot;. Leaving too many zombies around may exhaust global resources (for example process IDs).</source>
          <target state="translated">一部のシステムでは、OSがリソースを解放するために、&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;などの呼び出しが必要です。終了したが待機されていないプロセスは、まだ「ゾンビ」として存在しています。ゾンビを残しすぎると、グローバルリソース（たとえば、プロセスID）を使い果たす可能性があります。</target>
        </trans-unit>
        <trans-unit id="f95b6f9f5ca3589fe7d076155399faa6b71dbbbe" translate="yes" xml:space="preserve">
          <source>On success this function will not return, and otherwise it will return an error indicating why the exec (or another part of the setup of the &lt;code&gt;Command&lt;/code&gt;) failed.</source>
          <target state="translated">成功した場合、この関数は戻りません。それ以外の場合、exec（または &lt;code&gt;Command&lt;/code&gt; のセットアップの別の部分）が失敗した理由を示すエラーを返します。</target>
        </trans-unit>
        <trans-unit id="85ee4aa1b293e333458ae17de2dc9971adc5a07b" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read and the address from whence the data came.</source>
          <target state="translated">成功すると、読み込んだバイト数と、データがどこから来たかを示すアドレスを返します。</target>
        </trans-unit>
        <trans-unit id="4ea0ccaabe0c9b1fbc90341ab5a04d65215e560d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes read.</source>
          <target state="translated">成功すると、読み込んだバイト数を返します。</target>
        </trans-unit>
        <trans-unit id="bc5a49aba56a5b26329959ae0e37a7391cbb54ed" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes written.</source>
          <target state="translated">成功すると、書き込まれたバイト数を返します。</target>
        </trans-unit>
        <trans-unit id="f9b7167ab1cb81802d4cc93ff38048bd7cd2f218" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes copied is returned and it is equal to the length of the &lt;code&gt;to&lt;/code&gt; file as reported by &lt;code&gt;metadata&lt;/code&gt;.</source>
          <target state="translated">成功すると、コピーされた合計バイト数が返さ &lt;code&gt;to&lt;/code&gt; ます。これは、 &lt;code&gt;metadata&lt;/code&gt; によって報告されたtoファイルの長さと同じです。</target>
        </trans-unit>
        <trans-unit id="a6bfa6f8c514698639a06b222dc94c1639495b9f" translate="yes" xml:space="preserve">
          <source>On success, the total number of bytes that were copied from &lt;code&gt;reader&lt;/code&gt; to &lt;code&gt;writer&lt;/code&gt; is returned.</source>
          <target state="translated">成功すると、 &lt;code&gt;reader&lt;/code&gt; から &lt;code&gt;writer&lt;/code&gt; コピーされた合計バイト数が返されます。</target>
        </trans-unit>
        <trans-unit id="43a00d4716ce2886f17dadaa3b0e2204d940167a" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Screen&lt;/code&gt; struct, we&amp;rsquo;ll define a method named &lt;code&gt;run&lt;/code&gt; that will call the &lt;code&gt;draw&lt;/code&gt; method on each of its &lt;code&gt;components&lt;/code&gt;, as shown in Listing 17-5:</source>
          <target state="translated">リスト17-5に示すように、 &lt;code&gt;Screen&lt;/code&gt; 構造体で、各 &lt;code&gt;components&lt;/code&gt; &lt;code&gt;draw&lt;/code&gt; メソッドを呼び出す &lt;code&gt;run&lt;/code&gt; という名前のメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="417a01b51fb2fc402d7ff9e7a38ed36ddb3ab97a" translate="yes" xml:space="preserve">
          <source>On the first line of &lt;code&gt;main&lt;/code&gt;, we call &lt;code&gt;env::args&lt;/code&gt;, and we immediately use &lt;code&gt;collect&lt;/code&gt; to turn the iterator into a vector containing all the values produced by the iterator. We can use the &lt;code&gt;collect&lt;/code&gt; function to create many kinds of collections, so we explicitly annotate the type of &lt;code&gt;args&lt;/code&gt; to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, &lt;code&gt;collect&lt;/code&gt; is one function you do often need to annotate because Rust isn&amp;rsquo;t able to infer the kind of collection you want.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; の最初の行で &lt;code&gt;env::args&lt;/code&gt; を呼び出し、すぐに &lt;code&gt;collect&lt;/code&gt; を使用して、イテレーターを、イテレーターによって生成されたすべての値を含むベクトルに変換します。 &lt;code&gt;collect&lt;/code&gt; 関数を使用して多くの種類のコレクションを作成できるため、 &lt;code&gt;args&lt;/code&gt; の型に明示的に注釈を付けて、文字列のベクトルが必要であることを指定します。 Rustで型に注釈を付ける必要はめったにありませんが、Rustは必要なコレクションの種類を推測できないため、 &lt;code&gt;collect&lt;/code&gt; はしばしば注釈を付ける必要がある1つの関数です。</target>
        </trans-unit>
        <trans-unit id="9eddcffce559b2f4fd96faa276545d34f1b2fe9a" translate="yes" xml:space="preserve">
          <source>On the other hand, one trait which would not be appropriate to implement is &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">一方、実装に&lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;ない特性の1つはDefaultです。</target>
        </trans-unit>
        <trans-unit id="09d6ad3b118e12286d44db37bda32a77e5392fde" translate="yes" xml:space="preserve">
          <source>On the other hand, when bringing in structs, enums, and other items with &lt;code&gt;use&lt;/code&gt;, it&amp;rsquo;s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library&amp;rsquo;s &lt;code&gt;HashMap&lt;/code&gt; struct into the scope of a binary crate.</source>
          <target state="translated">一方、structやenumなどのアイテムを &lt;code&gt;use&lt;/code&gt; で取り込む場合は、フルパスを指定するのが慣用です。リスト7-14は、標準ライブラリの &lt;code&gt;HashMap&lt;/code&gt; 構造体をバイナリクレートのスコープに組み込む慣用的な方法を示しています。</target>
        </trans-unit>
        <trans-unit id="50d2f428f140a723a3dc474c3eb5d43ababe5b45" translate="yes" xml:space="preserve">
          <source>On the other hand, with the method using trait objects, one &lt;code&gt;Screen&lt;/code&gt; instance can hold a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that contains a &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; as well as a &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at how this works, and then we&amp;rsquo;ll talk about the runtime performance implications.</source>
          <target state="translated">一方、トレイトオブジェクトを使用するメソッドでは、1つの &lt;code&gt;Screen&lt;/code&gt; インスタンスが &lt;code&gt;Box&amp;lt;Button&amp;gt;&lt;/code&gt; と &lt;code&gt;Box&amp;lt;TextField&amp;gt;&lt;/code&gt; を含む &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; を保持できます。これがどのように機能するかを見てみましょう。次に、実行時のパフォーマンスへの影響について説明します。</target>
        </trans-unit>
        <trans-unit id="a7c793eb037e8ef3b7da8efa89ac452132495eae" translate="yes" xml:space="preserve">
          <source>On top of that, function pointers can vary based on what ABI they use. This is achieved by adding the &lt;code&gt;extern&lt;/code&gt; keyword to the type name, followed by the ABI in question. For example, &lt;code&gt;fn()&lt;/code&gt; is different from &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt;, which itself is different from &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt;, and so on for the various ABIs that Rust supports. Non-&lt;code&gt;extern&lt;/code&gt; functions have an ABI of &lt;code&gt;&quot;Rust&quot;&lt;/code&gt;, and &lt;code&gt;extern&lt;/code&gt; functions without an explicit ABI have an ABI of &lt;code&gt;&quot;C&quot;&lt;/code&gt;. For more information, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;the nomicon's section on foreign calling conventions&lt;/a&gt;.</source>
          <target state="translated">その上、関数ポインターは、使用するABIによって異なる場合があります。これは、型名に &lt;code&gt;extern&lt;/code&gt; キーワードを追加し、その後に問題のABIを追加することで実現されます。たとえば、RustがサポートするさまざまなABI については、 &lt;code&gt;fn()&lt;/code&gt; は &lt;code&gt;extern &quot;C&quot; fn()&lt;/code&gt; とは異なり、それ自体は &lt;code&gt;extern &quot;stdcall&quot; fn()&lt;/code&gt; とは異なります。非 &lt;code&gt;extern&lt;/code&gt; 関数は、ABIの持っている &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; 、と &lt;code&gt;extern&lt;/code&gt; のABI持って明示的にABIせずに関数を &lt;code&gt;&quot;C&quot;&lt;/code&gt; 。詳細については&lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;、外部呼び出し規約に関するノミコンのセクションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="630c59f788be2f8b6b4b1ca247b245094c3530e8" translate="yes" xml:space="preserve">
          <source>On top of that, remember that most types have additional invariants beyond merely being considered initialized at the type level. For example, a &lt;code&gt;1&lt;/code&gt;-initialized &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is considered initialized because the only requirement the compiler knows about it is that the data pointer must be non-null. Creating such a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not cause &lt;em&gt;immediate&lt;/em&gt; undefined behavior, but will cause undefined behavior with most safe operations (including dropping it).</source>
          <target state="translated">その上、ほとんどの型には、型レベルで初期化されたと見なされるだけでなく、追加の不変式があることに注意してください。たとえば、 &lt;code&gt;1&lt;/code&gt; で初期化された&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;は初期化されたと見なされます。コンパイラがそれを知っている唯一の要件は、データポインターがnull以外でなければならないということです。このような &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 作成しても、&lt;em&gt;すぐに&lt;/em&gt;未定義の動作が発生することはありませんが、最も安全な操作（ドロップを含む）で未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="dde4e913efe3a7bb20d91e29731b497ad0b7ade2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;Config::new&lt;/code&gt; takes ownership of the iterator and stops using indexing operations that borrow, we can move the &lt;code&gt;String&lt;/code&gt; values from the iterator into &lt;code&gt;Config&lt;/code&gt; rather than calling &lt;code&gt;clone&lt;/code&gt; and making a new allocation.</source>
          <target state="translated">いったん &lt;code&gt;Config::new&lt;/code&gt; イテレータの所有権を取得し、インデックス運用にその借りを使用して停止し、我々は移動することができます &lt;code&gt;String&lt;/code&gt; の中にイテレータからの値を &lt;code&gt;Config&lt;/code&gt; むしろ呼び出しよりも、 &lt;code&gt;clone&lt;/code&gt; 、新たな割り当てを行います。</target>
        </trans-unit>
        <trans-unit id="8b0de6bbc4d6a271545919a41560436f915e4647" translate="yes" xml:space="preserve">
          <source>Once a future has completed (returned &lt;code&gt;Ready&lt;/code&gt; from &lt;code&gt;poll&lt;/code&gt;), calling its &lt;code&gt;poll&lt;/code&gt; method again may panic, block forever, or cause other kinds of problems; the &lt;code&gt;Future&lt;/code&gt; trait places no requirements on the effects of such a call. However, as the &lt;code&gt;poll&lt;/code&gt; method is not marked &lt;code&gt;unsafe&lt;/code&gt;, Rust's usual rules apply: calls must never cause undefined behavior (memory corruption, incorrect use of &lt;code&gt;unsafe&lt;/code&gt; functions, or the like), regardless of the future's state.</source>
          <target state="translated">futureが完了すると（ &lt;code&gt;poll&lt;/code&gt; から &lt;code&gt;Ready&lt;/code&gt; が返されます）、その &lt;code&gt;poll&lt;/code&gt; メソッドを再度呼び出すと、パニックが発生したり、永久にブロックされたり、その他の種類の問題が発生したりすることがあります。 &lt;code&gt;Future&lt;/code&gt; 特徴は、このようなコールの効果には何の要件を課すません。ただし、 &lt;code&gt;poll&lt;/code&gt; メソッドが &lt;code&gt;unsafe&lt;/code&gt; とマークされていないため、Rustの通常の規則が適用されます。呼び出しは、将来の状態に関係なく、未定義の動作（メモリ破損、 &lt;code&gt;unsafe&lt;/code&gt; でない関数の誤った使用など）を引き起こしてはなりません。</target>
        </trans-unit>
        <trans-unit id="472f512f503c00a7a3badf54bca4e8a984d78d81" translate="yes" xml:space="preserve">
          <source>Once a future has finished, clients should not &lt;code&gt;poll&lt;/code&gt; it again.</source>
          <target state="translated">futureが終了したら、クライアントはそれを再度 &lt;code&gt;poll&lt;/code&gt; しないでください。</target>
        </trans-unit>
        <trans-unit id="52d66dce2b0cbeb3ef0b4a40c595411581c4bf47" translate="yes" xml:space="preserve">
          <source>Once a valid size is received, our &lt;code&gt;ThreadPool&lt;/code&gt; creates a new vector that can hold &lt;code&gt;size&lt;/code&gt; items. We haven&amp;rsquo;t used the &lt;code&gt;with_capacity&lt;/code&gt; function in this book yet, which performs the same task as &lt;code&gt;Vec::new&lt;/code&gt; but with an important difference: it preallocates space in the vector. Because we know we need to store &lt;code&gt;size&lt;/code&gt; elements in the vector, doing this allocation up front is slightly more efficient than using &lt;code&gt;Vec::new&lt;/code&gt;, which resizes itself as elements are inserted.</source>
          <target state="translated">有効なサイズが受信されると、 &lt;code&gt;ThreadPool&lt;/code&gt; は &lt;code&gt;size&lt;/code&gt; 項目を保持できる新しいベクターを作成します。この本では、 &lt;code&gt;with_capacity&lt;/code&gt; 関数をまだ使用していません。Vec &lt;code&gt;Vec::new&lt;/code&gt; と同じタスクを実行しますが、重要な違いがあります。これは、ベクター内のスペースを事前に割り当てます。 &lt;code&gt;size&lt;/code&gt; 要素をベクターに格納する必要があることがわかっているため、この割り当てを事前に行う方が、要素が挿入されるとサイズが変更される &lt;code&gt;Vec::new&lt;/code&gt; を使用するよりもわずかに効率的です。</target>
        </trans-unit>
        <trans-unit id="b9c2a150a70fbfb0f86650e1f5cd73ca0f595c49" translate="yes" xml:space="preserve">
          <source>Once again we're using &lt;code&gt;!&lt;/code&gt;'s ability to coerce into any other type, in this case &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;. Since this method takes a &lt;code&gt;&amp;amp;!&lt;/code&gt; as an argument we know that it can never be called (because there is no value of type &lt;code&gt;!&lt;/code&gt; for it to be called with). Writing &lt;code&gt;*self&lt;/code&gt; essentially tells the compiler &quot;We know that this code can never be run, so just treat the entire function body as having type &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;&quot;. This pattern can be used a lot when implementing traits for &lt;code&gt;!&lt;/code&gt;. Generally, any trait which only has methods which take a &lt;code&gt;self&lt;/code&gt; parameter should have such an impl.</source>
          <target state="translated">もう一度使用しています &lt;code&gt;!&lt;/code&gt; 他のタイプ、この場合は&lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;に強制変換する機能。このメソッドは &lt;code&gt;&amp;amp;!&lt;/code&gt; 引数として呼び出すことはできません（それを呼び出すためのタイプ &lt;code&gt;!&lt;/code&gt; の値がないため）。 &lt;code&gt;*self&lt;/code&gt; を書くことは本質的にコンパイラーに「このコードは決して実行できないことを知っているので、関数本体全体をタイプ&lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;を持つものとして扱います」と伝えます。このパターンは、 &lt;code&gt;!&lt;/code&gt; の特性を実装するときに多く使用できます。。一般に、 &lt;code&gt;self&lt;/code&gt; パラメータを取るメソッドのみを持つすべての特性には、そのような実装が必要です。</target>
        </trans-unit>
        <trans-unit id="3c60f2098dcfc1948a1cd5eb57c13cccf48d2d00" translate="yes" xml:space="preserve">
          <source>Once again, we compile and get... different errors! The compiler is teaching us a lot.</source>
          <target state="translated">もう一度、コンパイルしてみると...違うエラーが出てきました。コンパイラは私たちに多くのことを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="30ba447807ee16c40637ce8c42ca10892e8780ac" translate="yes" xml:space="preserve">
          <source>Once half of a channel has been deallocated, most operations can no longer continue to make progress, so &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; will be returned. Many applications will continue to &lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt; the results returned from this module, instigating a propagation of failure among threads if one unexpectedly dies.</source>
          <target state="translated">チャネルの半分が割り当て解除されると、ほとんどの操作は進行を続けることができなくなるため、&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;が返されます。多くのアプリケーションは、このモジュールから返された結果を&lt;a href=&quot;../../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt;し続け、予期せずに1つが停止した場合に、スレッド間で障害の伝播を引き起こします。</target>
        </trans-unit>
        <trans-unit id="0fa4b20ac7b7c2a8a0f92535a2333b6aa807706f" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we used iterators with &lt;code&gt;for&lt;/code&gt; loops to execute some code on each item, although we glossed over what the call to &lt;code&gt;iter&lt;/code&gt; did until now.</source>
          <target state="translated">イテレータを作成したら、さまざまな方法で使用できます。第3章のリスト3-5では、イテレータを &lt;code&gt;for&lt;/code&gt; ループで使用して各項目でいくつかのコードを実行しましたが、これまでの &lt;code&gt;iter&lt;/code&gt; の呼び出しについては説明していません。</target>
        </trans-unit>
        <trans-unit id="58851a1903858c976f2730a714ae3f3f46765304" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve implemented the &lt;code&gt;Iterator&lt;/code&gt; trait, we have an iterator! Listing 13-22 shows a test demonstrating that we can use the iterator functionality of our &lt;code&gt;Counter&lt;/code&gt; struct by calling the &lt;code&gt;next&lt;/code&gt; method on it directly, just as we did with the iterator created from a vector in Listing 13-15.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; トレイトを実装すると、イテレーターができます。リスト13-22は、リスト13-15でベクターから作成されたイテレータで行ったのと同じように、 &lt;code&gt;next&lt;/code&gt; メソッドを直接呼び出すことで &lt;code&gt;Counter&lt;/code&gt; 構造体のイテレータ機能を使用できることを示すテストを示しています。</target>
        </trans-unit>
        <trans-unit id="84bcbd885f09e288fb3013478b1c1b345aab434e" translate="yes" xml:space="preserve">
          <source>Once you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the &lt;code&gt;[-]&lt;/code&gt; button near the top of the page to collapse it into a more skimmable view.</source>
          <target state="translated">標準ライブラリの内容に慣れると、散文の煩雑さが気になり始めるかもしれません。開発のこの段階で、ページの上部近くにある &lt;code&gt;[-]&lt;/code&gt; ボタンを押して、ページを折りたたんでよりスキミング可能なビューにすることができます。</target>
        </trans-unit>
        <trans-unit id="f9e4ff73fcbf2b9b71b1855afa48c76c6aa49139" translate="yes" xml:space="preserve">
          <source>Once you have the kind of slice you need (with or without a nul terminator), you can call the slice's own &lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; method to get a read-only raw pointer to pass to extern functions. See the documentation for that function for a discussion on ensuring the lifetime of the raw pointer.</source>
          <target state="translated">必要な種類のスライス（nulターミネータの有無にかかわらず）を取得したら、スライスの独自の&lt;a href=&quot;../primitive.slice#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt;メソッドを呼び出して、読み取り専用の生のポインタを取得し、extern関数に渡すことができます。生のポインタの有効期間を確保する方法については、その関数のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ef776c26c7f6b2f89aaf4c349afba29be9ab2040" translate="yes" xml:space="preserve">
          <source>Once::all</source>
          <target state="translated">Once::all</target>
        </trans-unit>
        <trans-unit id="fa85c00dce196844734611fc55302ba498cdda9b" translate="yes" xml:space="preserve">
          <source>Once::any</source>
          <target state="translated">Once::any</target>
        </trans-unit>
        <trans-unit id="826f1ec43224196e7c0e18a9f4c8ba3d03de27f1" translate="yes" xml:space="preserve">
          <source>Once::borrow</source>
          <target state="translated">Once::borrow</target>
        </trans-unit>
        <trans-unit id="e53e91b8fe24cb0570a1a97b3316a02ec5d3ee03" translate="yes" xml:space="preserve">
          <source>Once::borrow_mut</source>
          <target state="translated">Once::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c2f8e8374534fd9f5e2ff592398a6ffc6014fd99" translate="yes" xml:space="preserve">
          <source>Once::by_ref</source>
          <target state="translated">Once::by_ref</target>
        </trans-unit>
        <trans-unit id="28a72e0c985bccd2edce22b1340d3ed027a4ac1f" translate="yes" xml:space="preserve">
          <source>Once::call_once</source>
          <target state="translated">Once::call_once</target>
        </trans-unit>
        <trans-unit id="e0cfc1e91951cfca51a0190fd8a21d0b035190a9" translate="yes" xml:space="preserve">
          <source>Once::call_once_force</source>
          <target state="translated">Once::call_once_force</target>
        </trans-unit>
        <trans-unit id="1376857cb86f72af6eff74ad397cf00fcde6210e" translate="yes" xml:space="preserve">
          <source>Once::chain</source>
          <target state="translated">Once::chain</target>
        </trans-unit>
        <trans-unit id="190ff92b2c593bf6e13bca7abde87e505a3ec2bb" translate="yes" xml:space="preserve">
          <source>Once::clone</source>
          <target state="translated">Once::clone</target>
        </trans-unit>
        <trans-unit id="212f098b1763e1e51ae7f7bc19ffa302ddfe30a1" translate="yes" xml:space="preserve">
          <source>Once::clone_from</source>
          <target state="translated">Once::clone_from</target>
        </trans-unit>
        <trans-unit id="311f7aa02f0a54433f61dae481c3b3e4040d2495" translate="yes" xml:space="preserve">
          <source>Once::clone_into</source>
          <target state="translated">Once::clone_into</target>
        </trans-unit>
        <trans-unit id="19afa196b08d6f8f3b6f43f40d2d7cd3c50fbc8f" translate="yes" xml:space="preserve">
          <source>Once::cloned</source>
          <target state="translated">Once::cloned</target>
        </trans-unit>
        <trans-unit id="6b4930ea79c81962eae48dcaf70c7227f1aa12a7" translate="yes" xml:space="preserve">
          <source>Once::cmp</source>
          <target state="translated">Once::cmp</target>
        </trans-unit>
        <trans-unit id="5d169980cad74ac2c6880808ed94fb787b98960a" translate="yes" xml:space="preserve">
          <source>Once::collect</source>
          <target state="translated">Once::collect</target>
        </trans-unit>
        <trans-unit id="313d94ea32a51b1b516cb8b52850728efe9ae8b5" translate="yes" xml:space="preserve">
          <source>Once::copied</source>
          <target state="translated">Once::copied</target>
        </trans-unit>
        <trans-unit id="f98560cce6e4eadc3911ce81d61f52d107ea5142" translate="yes" xml:space="preserve">
          <source>Once::count</source>
          <target state="translated">Once::count</target>
        </trans-unit>
        <trans-unit id="2ef6bd0928aad3dcaf46fb7f0bdafb3492745ec4" translate="yes" xml:space="preserve">
          <source>Once::cycle</source>
          <target state="translated">Once::cycle</target>
        </trans-unit>
        <trans-unit id="8ad5b4150f82970fff0038e17ac64a51521d1924" translate="yes" xml:space="preserve">
          <source>Once::enumerate</source>
          <target state="translated">Once::enumerate</target>
        </trans-unit>
        <trans-unit id="23c903ad536fa2bd73035fce46787048ed4f628a" translate="yes" xml:space="preserve">
          <source>Once::eq</source>
          <target state="translated">Once::eq</target>
        </trans-unit>
        <trans-unit id="82879e4fcf39171c09b466e2bf43bc8f45af6822" translate="yes" xml:space="preserve">
          <source>Once::filter</source>
          <target state="translated">Once::filter</target>
        </trans-unit>
        <trans-unit id="095605951ca140555bd59e4149308c63f272478d" translate="yes" xml:space="preserve">
          <source>Once::filter_map</source>
          <target state="translated">Once::filter_map</target>
        </trans-unit>
        <trans-unit id="7ca070326207c327aa1bb557f657f2fac61b1c8a" translate="yes" xml:space="preserve">
          <source>Once::find</source>
          <target state="translated">Once::find</target>
        </trans-unit>
        <trans-unit id="f8cbae0491d42da2ee0b9caaa6d41cbeef0233e4" translate="yes" xml:space="preserve">
          <source>Once::find_map</source>
          <target state="translated">Once::find_map</target>
        </trans-unit>
        <trans-unit id="8f0358e16d2477b8dc5e572ca1dae6005b455b17" translate="yes" xml:space="preserve">
          <source>Once::flat_map</source>
          <target state="translated">Once::flat_map</target>
        </trans-unit>
        <trans-unit id="8580b5a613c1d1f4df99cede210bdc2e9fe3a843" translate="yes" xml:space="preserve">
          <source>Once::flatten</source>
          <target state="translated">Once::flatten</target>
        </trans-unit>
        <trans-unit id="c9a403b6a5f9f7ce825a2ce8e6b8fc78c53b4261" translate="yes" xml:space="preserve">
          <source>Once::fmt</source>
          <target state="translated">Once::fmt</target>
        </trans-unit>
        <trans-unit id="a4dbe0ef075896956284d0f6da5e3cf48dd08238" translate="yes" xml:space="preserve">
          <source>Once::fold</source>
          <target state="translated">Once::fold</target>
        </trans-unit>
        <trans-unit id="9129023999880ed84891680b4f8fd96dda590894" translate="yes" xml:space="preserve">
          <source>Once::for_each</source>
          <target state="translated">Once::for_each</target>
        </trans-unit>
        <trans-unit id="d64f18e6780e0faf671ed9d539a0b268b8174066" translate="yes" xml:space="preserve">
          <source>Once::from</source>
          <target state="translated">Once::from</target>
        </trans-unit>
        <trans-unit id="bbf7ace21ce049891d14dd08bdb7b81831f05411" translate="yes" xml:space="preserve">
          <source>Once::fuse</source>
          <target state="translated">Once::fuse</target>
        </trans-unit>
        <trans-unit id="6d843124e3a2669cb3c40cac626394b00fbd78a9" translate="yes" xml:space="preserve">
          <source>Once::ge</source>
          <target state="translated">Once::ge</target>
        </trans-unit>
        <trans-unit id="a9af56769b34f56c5ffcf89a8ea47ff768c6858a" translate="yes" xml:space="preserve">
          <source>Once::gt</source>
          <target state="translated">Once::gt</target>
        </trans-unit>
        <trans-unit id="52b97e5420ac6c5141f11b243b00d6a1d91a82aa" translate="yes" xml:space="preserve">
          <source>Once::inspect</source>
          <target state="translated">Once::inspect</target>
        </trans-unit>
        <trans-unit id="24c9670c06579750ad91802403773c861f00f73c" translate="yes" xml:space="preserve">
          <source>Once::into</source>
          <target state="translated">Once::into</target>
        </trans-unit>
        <trans-unit id="efb0afcea9cf69ad9f300407891f7cf24889abde" translate="yes" xml:space="preserve">
          <source>Once::into_iter</source>
          <target state="translated">Once::into_iter</target>
        </trans-unit>
        <trans-unit id="0608fd7f8eac14cce16ca80dbfd5613b14204122" translate="yes" xml:space="preserve">
          <source>Once::is_completed</source>
          <target state="translated">Once::is_completed</target>
        </trans-unit>
        <trans-unit id="7251c3dcf49fe3c4c5830d926dcb3f340b9a4518" translate="yes" xml:space="preserve">
          <source>Once::is_empty</source>
          <target state="translated">Once::is_empty</target>
        </trans-unit>
        <trans-unit id="4b0fbfe12c4a015929a04dd53407a0499a03410c" translate="yes" xml:space="preserve">
          <source>Once::is_sorted</source>
          <target state="translated">Once::is_sorted</target>
        </trans-unit>
        <trans-unit id="6f25e0f3331d93f4e5eb47652d49ab83abddd5c6" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by</source>
          <target state="translated">Once::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="cb7a1da6af62c62d1c48e6f892b45246ff8fb722" translate="yes" xml:space="preserve">
          <source>Once::is_sorted_by_key</source>
          <target state="translated">Once::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="12b8716333449d7ef6ccc84a866d8c71f4d4596a" translate="yes" xml:space="preserve">
          <source>Once::last</source>
          <target state="translated">Once::last</target>
        </trans-unit>
        <trans-unit id="14b21ec5ab3251444e0715d08a995824bf98046f" translate="yes" xml:space="preserve">
          <source>Once::le</source>
          <target state="translated">Once::le</target>
        </trans-unit>
        <trans-unit id="c7ec127a76b81f92cbddfa60f7e443869f07dfc3" translate="yes" xml:space="preserve">
          <source>Once::len</source>
          <target state="translated">Once::len</target>
        </trans-unit>
        <trans-unit id="5200802a32d08edabd28e77c8bfacda66faabb5f" translate="yes" xml:space="preserve">
          <source>Once::lt</source>
          <target state="translated">Once::lt</target>
        </trans-unit>
        <trans-unit id="f2976b7d4debc6f0c6faff19e72feb23c6da98c9" translate="yes" xml:space="preserve">
          <source>Once::map</source>
          <target state="translated">Once::map</target>
        </trans-unit>
        <trans-unit id="37c43ed9043bf5a1d86c776c7a83980f8e44b550" translate="yes" xml:space="preserve">
          <source>Once::max</source>
          <target state="translated">Once::max</target>
        </trans-unit>
        <trans-unit id="42f687a90cb8ae799fc923fe98bf332780e16e1a" translate="yes" xml:space="preserve">
          <source>Once::max_by</source>
          <target state="translated">Once::max_by</target>
        </trans-unit>
        <trans-unit id="f790fae0c1ab8520d2b3bb6dee8c10e0df61fb21" translate="yes" xml:space="preserve">
          <source>Once::max_by_key</source>
          <target state="translated">Once::max_by_key</target>
        </trans-unit>
        <trans-unit id="be86a53ca110f0c0f2e5f786db25770b11e8fb89" translate="yes" xml:space="preserve">
          <source>Once::min</source>
          <target state="translated">Once::min</target>
        </trans-unit>
        <trans-unit id="5b4c2bfd34d4ce8913a24cdbba40c903c58ba228" translate="yes" xml:space="preserve">
          <source>Once::min_by</source>
          <target state="translated">Once::min_by</target>
        </trans-unit>
        <trans-unit id="0ff4bd1f1edb9d1e53ee61824c45a6b65f4eafd0" translate="yes" xml:space="preserve">
          <source>Once::min_by_key</source>
          <target state="translated">Once::min_by_key</target>
        </trans-unit>
        <trans-unit id="6236fe088142c957857770ab09a2b6fc2f27b69e" translate="yes" xml:space="preserve">
          <source>Once::ne</source>
          <target state="translated">Once::ne</target>
        </trans-unit>
        <trans-unit id="7d6911dda1f2483e209159a8e136b2c52051e6bb" translate="yes" xml:space="preserve">
          <source>Once::new</source>
          <target state="translated">Once::new</target>
        </trans-unit>
        <trans-unit id="578bd116c5e7fde5716979b05be2a783abe2fcec" translate="yes" xml:space="preserve">
          <source>Once::next</source>
          <target state="translated">Once::next</target>
        </trans-unit>
        <trans-unit id="8af821c9e317f67614d97739eed7d7394a46629b" translate="yes" xml:space="preserve">
          <source>Once::next_back</source>
          <target state="translated">Once::next_back</target>
        </trans-unit>
        <trans-unit id="430bb3482a938ef6cd7fe977041d4fa3bbc1fc55" translate="yes" xml:space="preserve">
          <source>Once::nth</source>
          <target state="translated">Once::nth</target>
        </trans-unit>
        <trans-unit id="c55b0c5a25d6a4c7729b67045964bd182f6c743b" translate="yes" xml:space="preserve">
          <source>Once::nth_back</source>
          <target state="translated">Once::nth_back</target>
        </trans-unit>
        <trans-unit id="22c36618829e3a03fdefff9bbca40dbd8e473846" translate="yes" xml:space="preserve">
          <source>Once::partial_cmp</source>
          <target state="translated">Once::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b7269ba05ed7753f4b47e7a0b54fad46c7fdfa25" translate="yes" xml:space="preserve">
          <source>Once::partition</source>
          <target state="translated">Once::partition</target>
        </trans-unit>
        <trans-unit id="a2a93318d906b75ba7d478b7d2053f09b5d47c8e" translate="yes" xml:space="preserve">
          <source>Once::peekable</source>
          <target state="translated">Once::peekable</target>
        </trans-unit>
        <trans-unit id="443ba5a518af1ceeeb00165b521452d07ea04e5b" translate="yes" xml:space="preserve">
          <source>Once::position</source>
          <target state="translated">Once::position</target>
        </trans-unit>
        <trans-unit id="aefb04c2392cc211f451d367f733cc6c65c3e11b" translate="yes" xml:space="preserve">
          <source>Once::product</source>
          <target state="translated">Once::product</target>
        </trans-unit>
        <trans-unit id="0bc9c08f73c34cac78d945ebc22d8397bbb66131" translate="yes" xml:space="preserve">
          <source>Once::rev</source>
          <target state="translated">Once::rev</target>
        </trans-unit>
        <trans-unit id="3c7856aff7c1c10689eb91760b905ac36a86fd8f" translate="yes" xml:space="preserve">
          <source>Once::rfind</source>
          <target state="translated">Once::rfind</target>
        </trans-unit>
        <trans-unit id="bb98b537fa90b815cfad245be9b6f8a9980c10ad" translate="yes" xml:space="preserve">
          <source>Once::rfold</source>
          <target state="translated">Once::rfold</target>
        </trans-unit>
        <trans-unit id="068dbc2b0446d02924974dc89dc2e5c0506be3c0" translate="yes" xml:space="preserve">
          <source>Once::rposition</source>
          <target state="translated">Once::rposition</target>
        </trans-unit>
        <trans-unit id="2f7d42081a9a3b1a18973e17303b804987f7c991" translate="yes" xml:space="preserve">
          <source>Once::scan</source>
          <target state="translated">Once::scan</target>
        </trans-unit>
        <trans-unit id="689e357b41f0be20a1862814b9c83d77ef8f1e70" translate="yes" xml:space="preserve">
          <source>Once::size_hint</source>
          <target state="translated">Once::size_hint</target>
        </trans-unit>
        <trans-unit id="cbf339d38d49468cb345d7cfb9cb77b78f365fd1" translate="yes" xml:space="preserve">
          <source>Once::skip</source>
          <target state="translated">Once::skip</target>
        </trans-unit>
        <trans-unit id="86fd91a24a1bbc66ca2ece695858498a65db16dd" translate="yes" xml:space="preserve">
          <source>Once::skip_while</source>
          <target state="translated">Once::skip_while</target>
        </trans-unit>
        <trans-unit id="6fe0f81f7153271dc977040947a6cad61882f9d1" translate="yes" xml:space="preserve">
          <source>Once::step_by</source>
          <target state="translated">Once::step_by</target>
        </trans-unit>
        <trans-unit id="033b2578f1615ee184814d95335d5fd74302c231" translate="yes" xml:space="preserve">
          <source>Once::sum</source>
          <target state="translated">Once::sum</target>
        </trans-unit>
        <trans-unit id="442e2927616d29972c328197ab646af0a109e0ac" translate="yes" xml:space="preserve">
          <source>Once::take</source>
          <target state="translated">Once::take</target>
        </trans-unit>
        <trans-unit id="e0055054cf1a45bf179b412f905b6b7b804fe427" translate="yes" xml:space="preserve">
          <source>Once::take_while</source>
          <target state="translated">Once::take_while</target>
        </trans-unit>
        <trans-unit id="1ff7fdb84e0ce09813e50c320654790d32c718fe" translate="yes" xml:space="preserve">
          <source>Once::to_owned</source>
          <target state="translated">Once::to_owned</target>
        </trans-unit>
        <trans-unit id="b045ee709dc7ad89b9c21500aecbcde1537d7e58" translate="yes" xml:space="preserve">
          <source>Once::try_fold</source>
          <target state="translated">Once::try_fold</target>
        </trans-unit>
        <trans-unit id="ca7011c5d5b35881f4391164193c191f7c91a8ed" translate="yes" xml:space="preserve">
          <source>Once::try_for_each</source>
          <target state="translated">Once::try_for_each</target>
        </trans-unit>
        <trans-unit id="145392f846fa35a3754a9cdb737cf3389c9b3bb1" translate="yes" xml:space="preserve">
          <source>Once::try_from</source>
          <target state="translated">Once::try_from</target>
        </trans-unit>
        <trans-unit id="36d585158ca953d0dbbe69c61419f1e9cfd5cbd0" translate="yes" xml:space="preserve">
          <source>Once::try_into</source>
          <target state="translated">Once::try_into</target>
        </trans-unit>
        <trans-unit id="bb47966988d0ea30157cfc9b32edfc0454ef3340" translate="yes" xml:space="preserve">
          <source>Once::try_rfold</source>
          <target state="translated">Once::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e7005b30f23dbe8e521fbb090487b02e260839e" translate="yes" xml:space="preserve">
          <source>Once::type_id</source>
          <target state="translated">Once::type_id</target>
        </trans-unit>
        <trans-unit id="89b4b7dbbcd40342a9b06361de2f912cf9887391" translate="yes" xml:space="preserve">
          <source>Once::unzip</source>
          <target state="translated">Once::unzip</target>
        </trans-unit>
        <trans-unit id="9c587dbc5b4ada9eb96816888453bd9099854f2c" translate="yes" xml:space="preserve">
          <source>Once::zip</source>
          <target state="translated">Once::zip</target>
        </trans-unit>
        <trans-unit id="2db71cb543a4836972aba340022bf66c34ca9483" translate="yes" xml:space="preserve">
          <source>OnceState</source>
          <target state="translated">OnceState</target>
        </trans-unit>
        <trans-unit id="864b2494c0a17291fe44802d2dfa7280c6515a58" translate="yes" xml:space="preserve">
          <source>OnceState::borrow</source>
          <target state="translated">OnceState::borrow</target>
        </trans-unit>
        <trans-unit id="3ba03425574355acef161a03b37753e3dc3fce0d" translate="yes" xml:space="preserve">
          <source>OnceState::borrow_mut</source>
          <target state="translated">OnceState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="137f612918b3ff9f01b5b2eed8a892cbbde080f1" translate="yes" xml:space="preserve">
          <source>OnceState::fmt</source>
          <target state="translated">OnceState::fmt</target>
        </trans-unit>
        <trans-unit id="cc9d74ec28c33e153d2d0894a6de5f14c5c9aabd" translate="yes" xml:space="preserve">
          <source>OnceState::from</source>
          <target state="translated">OnceState::from</target>
        </trans-unit>
        <trans-unit id="d968db4b631f42cce77d0ea2bff8656be4e57c06" translate="yes" xml:space="preserve">
          <source>OnceState::into</source>
          <target state="translated">OnceState::into</target>
        </trans-unit>
        <trans-unit id="5279da3ce88f5a2ebd344f9b9ae566f2cb009268" translate="yes" xml:space="preserve">
          <source>OnceState::poisoned</source>
          <target state="translated">OnceState::poisoned</target>
        </trans-unit>
        <trans-unit id="8447bc72e127b3443efef418a2e8188e3cc3f620" translate="yes" xml:space="preserve">
          <source>OnceState::try_from</source>
          <target state="translated">OnceState::try_from</target>
        </trans-unit>
        <trans-unit id="2a35fc55239b76803a74ad10688fe793f6102501" translate="yes" xml:space="preserve">
          <source>OnceState::try_into</source>
          <target state="translated">OnceState::try_into</target>
        </trans-unit>
        <trans-unit id="fcd8d541e6822fd809940974bebc8a81f8b16c8d" translate="yes" xml:space="preserve">
          <source>OnceState::type_id</source>
          <target state="translated">OnceState::type_id</target>
        </trans-unit>
        <trans-unit id="bac414ebd5a08ef0bd8f0f09a9b6b081da1540b4" translate="yes" xml:space="preserve">
          <source>OnceWith</source>
          <target state="translated">OnceWith</target>
        </trans-unit>
        <trans-unit id="9421b02fba334e65b31591c89d7fcfa34aea5e57" translate="yes" xml:space="preserve">
          <source>OnceWith::all</source>
          <target state="translated">OnceWith::all</target>
        </trans-unit>
        <trans-unit id="ec045f959571abb529fe845ffb143c5aa440d98a" translate="yes" xml:space="preserve">
          <source>OnceWith::any</source>
          <target state="translated">OnceWith::any</target>
        </trans-unit>
        <trans-unit id="1ef37dd0c57f299c431f6fc7296ed50225f08e1a" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow</source>
          <target state="translated">OnceWith::borrow</target>
        </trans-unit>
        <trans-unit id="527f129227b962c7154dfbbc8fa56239753273a3" translate="yes" xml:space="preserve">
          <source>OnceWith::borrow_mut</source>
          <target state="translated">OnceWith::borrow_mut</target>
        </trans-unit>
        <trans-unit id="220386db15c3ac797f2d78a1fa6328e0e524bbaa" translate="yes" xml:space="preserve">
          <source>OnceWith::by_ref</source>
          <target state="translated">OnceWith::by_ref</target>
        </trans-unit>
        <trans-unit id="8cca4e55ae50dd0aee68afe79ea244d5bca99ced" translate="yes" xml:space="preserve">
          <source>OnceWith::chain</source>
          <target state="translated">OnceWith::chain</target>
        </trans-unit>
        <trans-unit id="69a3e8d814785ab85c33556c6a099c9cc6ea940e" translate="yes" xml:space="preserve">
          <source>OnceWith::clone</source>
          <target state="translated">OnceWith::clone</target>
        </trans-unit>
        <trans-unit id="18ada5e17d413555745065a07348ed90106c203d" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_from</source>
          <target state="translated">OnceWith::clone_from</target>
        </trans-unit>
        <trans-unit id="840d6af9e9dfbf237e7af2ccf27dbd5ad69cee46" translate="yes" xml:space="preserve">
          <source>OnceWith::clone_into</source>
          <target state="translated">OnceWith::clone_into</target>
        </trans-unit>
        <trans-unit id="28fb35fd1901c33eee7b84b451b7753c7c867260" translate="yes" xml:space="preserve">
          <source>OnceWith::cloned</source>
          <target state="translated">OnceWith::cloned</target>
        </trans-unit>
        <trans-unit id="30d119dee0d9c070c3e61005d6831099ce8bd793" translate="yes" xml:space="preserve">
          <source>OnceWith::cmp</source>
          <target state="translated">OnceWith::cmp</target>
        </trans-unit>
        <trans-unit id="abe9447efe3162bb1b99fa4be3a78e85a49dc04b" translate="yes" xml:space="preserve">
          <source>OnceWith::collect</source>
          <target state="translated">OnceWith::collect</target>
        </trans-unit>
        <trans-unit id="4d6da14365d0d73a28c1b23f782a042915618b92" translate="yes" xml:space="preserve">
          <source>OnceWith::copied</source>
          <target state="translated">OnceWith::copied</target>
        </trans-unit>
        <trans-unit id="7016f9903cc220eec1b3d930f0d6d91062934899" translate="yes" xml:space="preserve">
          <source>OnceWith::count</source>
          <target state="translated">OnceWith::count</target>
        </trans-unit>
        <trans-unit id="addfc373b9df5fc305b9e5e6eb635cd2466d07d4" translate="yes" xml:space="preserve">
          <source>OnceWith::cycle</source>
          <target state="translated">OnceWith::cycle</target>
        </trans-unit>
        <trans-unit id="095f0dc0c2b642b81131fb698197ca6766b54a2e" translate="yes" xml:space="preserve">
          <source>OnceWith::enumerate</source>
          <target state="translated">OnceWith::enumerate</target>
        </trans-unit>
        <trans-unit id="7e9ec613a8f6c55d8eb6ea553ee7ebd7e6244ce6" translate="yes" xml:space="preserve">
          <source>OnceWith::eq</source>
          <target state="translated">OnceWith::eq</target>
        </trans-unit>
        <trans-unit id="f3f3ad0faefd45bbd859ece3bf3eef9075759214" translate="yes" xml:space="preserve">
          <source>OnceWith::filter</source>
          <target state="translated">OnceWith::filter</target>
        </trans-unit>
        <trans-unit id="ea81115d4b00890df3a160e9b9a84ff71ded3a01" translate="yes" xml:space="preserve">
          <source>OnceWith::filter_map</source>
          <target state="translated">OnceWith::filter_map</target>
        </trans-unit>
        <trans-unit id="04462b9dd7bbda24ad2bd90e2b7883781de4acd6" translate="yes" xml:space="preserve">
          <source>OnceWith::find</source>
          <target state="translated">OnceWith::find</target>
        </trans-unit>
        <trans-unit id="aca2dee92401221e00169ab44175f018d2db65f4" translate="yes" xml:space="preserve">
          <source>OnceWith::find_map</source>
          <target state="translated">OnceWith::find_map</target>
        </trans-unit>
        <trans-unit id="10d39de4f24d2dcddb78ea6874f21fecb0e42b39" translate="yes" xml:space="preserve">
          <source>OnceWith::flat_map</source>
          <target state="translated">OnceWith::flat_map</target>
        </trans-unit>
        <trans-unit id="6ff780249f2a51d00d5d95dcfd4610dadafd2bd8" translate="yes" xml:space="preserve">
          <source>OnceWith::flatten</source>
          <target state="translated">OnceWith::flatten</target>
        </trans-unit>
        <trans-unit id="e7394a8ea887cd043223fc687a97cc1f193256c1" translate="yes" xml:space="preserve">
          <source>OnceWith::fmt</source>
          <target state="translated">OnceWith::fmt</target>
        </trans-unit>
        <trans-unit id="5e004a4ea95a589f773f9befbef25abe72f46ba2" translate="yes" xml:space="preserve">
          <source>OnceWith::fold</source>
          <target state="translated">OnceWith::fold</target>
        </trans-unit>
        <trans-unit id="0826514ea858174b22832240424d387a6a62a698" translate="yes" xml:space="preserve">
          <source>OnceWith::for_each</source>
          <target state="translated">OnceWith::for_each</target>
        </trans-unit>
        <trans-unit id="6f44e41130791319e6c6d5e080615570ac91fa72" translate="yes" xml:space="preserve">
          <source>OnceWith::from</source>
          <target state="translated">OnceWith::from</target>
        </trans-unit>
        <trans-unit id="d991094123caac201e372f78da1221c72316dec1" translate="yes" xml:space="preserve">
          <source>OnceWith::fuse</source>
          <target state="translated">OnceWith::fuse</target>
        </trans-unit>
        <trans-unit id="491865c492a9358b9d74d7461f65fbb3c2ad3116" translate="yes" xml:space="preserve">
          <source>OnceWith::ge</source>
          <target state="translated">OnceWith::ge</target>
        </trans-unit>
        <trans-unit id="cb6cb84ba3cef039e288bea61f9e271654ca16b3" translate="yes" xml:space="preserve">
          <source>OnceWith::gt</source>
          <target state="translated">OnceWith::gt</target>
        </trans-unit>
        <trans-unit id="f9bca0dbc5eb1308057e3acda537f87ae5584bf0" translate="yes" xml:space="preserve">
          <source>OnceWith::inspect</source>
          <target state="translated">OnceWith::inspect</target>
        </trans-unit>
        <trans-unit id="130c0779f2fab716215af75fb82426f43a016224" translate="yes" xml:space="preserve">
          <source>OnceWith::into</source>
          <target state="translated">OnceWith::into</target>
        </trans-unit>
        <trans-unit id="e53104deb8174e788d926bdbaa53ed5840ec7390" translate="yes" xml:space="preserve">
          <source>OnceWith::into_iter</source>
          <target state="translated">OnceWith::into_iter</target>
        </trans-unit>
        <trans-unit id="57fb266c4456dcf8194282f31a9c9693a675f52f" translate="yes" xml:space="preserve">
          <source>OnceWith::is_empty</source>
          <target state="translated">OnceWith::is_empty</target>
        </trans-unit>
        <trans-unit id="35067e17a5dc55a4bb918b85dcd10ca948035cb7" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted</source>
          <target state="translated">OnceWith::is_sorted</target>
        </trans-unit>
        <trans-unit id="fa54dbd797d14264ee865bf4783d41bbaaceb9bb" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by</source>
          <target state="translated">OnceWith::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0805f33825aaffa765bd319b5f5123f28e25c541" translate="yes" xml:space="preserve">
          <source>OnceWith::is_sorted_by_key</source>
          <target state="translated">OnceWith::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="b8642e0e6fa2a743b75cee962cacad7d55075240" translate="yes" xml:space="preserve">
          <source>OnceWith::last</source>
          <target state="translated">OnceWith::last</target>
        </trans-unit>
        <trans-unit id="93fa8fd9eba96e349d5cb407b64fe72f152eb5a8" translate="yes" xml:space="preserve">
          <source>OnceWith::le</source>
          <target state="translated">OnceWith::le</target>
        </trans-unit>
        <trans-unit id="7222c5552e670e1ab40e927a15a3bb3893a18137" translate="yes" xml:space="preserve">
          <source>OnceWith::len</source>
          <target state="translated">OnceWith::len</target>
        </trans-unit>
        <trans-unit id="115bc72442e41419d2748702b3dc2105c1045ca1" translate="yes" xml:space="preserve">
          <source>OnceWith::lt</source>
          <target state="translated">OnceWith::lt</target>
        </trans-unit>
        <trans-unit id="4a5a3ea857244c9e36891ebf8831e5ae98613302" translate="yes" xml:space="preserve">
          <source>OnceWith::map</source>
          <target state="translated">OnceWith::map</target>
        </trans-unit>
        <trans-unit id="e13117c44b319bc7f0f9709faa2a5544da1bccc4" translate="yes" xml:space="preserve">
          <source>OnceWith::max</source>
          <target state="translated">OnceWith::max</target>
        </trans-unit>
        <trans-unit id="5fe974dd4baeb92c36de177f1091466a40a950e9" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by</source>
          <target state="translated">OnceWith::max_by</target>
        </trans-unit>
        <trans-unit id="4bced0b61c3c1cb8410f882718a68a33aeae5a9b" translate="yes" xml:space="preserve">
          <source>OnceWith::max_by_key</source>
          <target state="translated">OnceWith::max_by_key</target>
        </trans-unit>
        <trans-unit id="06568f09e719a331a84ceae60f4b66de6e9d0ea4" translate="yes" xml:space="preserve">
          <source>OnceWith::min</source>
          <target state="translated">OnceWith::min</target>
        </trans-unit>
        <trans-unit id="286481980c2d0b526534de52416aa1cce0683996" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by</source>
          <target state="translated">OnceWith::min_by</target>
        </trans-unit>
        <trans-unit id="5dd37a258caeec2b0eb6451dca8a726b836a9a92" translate="yes" xml:space="preserve">
          <source>OnceWith::min_by_key</source>
          <target state="translated">OnceWith::min_by_key</target>
        </trans-unit>
        <trans-unit id="69f93b3a318af71379ddca4ec93fe8d140ce5f0f" translate="yes" xml:space="preserve">
          <source>OnceWith::ne</source>
          <target state="translated">OnceWith::ne</target>
        </trans-unit>
        <trans-unit id="ac26f725cccaf1526e5014347f9adea936f74ce7" translate="yes" xml:space="preserve">
          <source>OnceWith::next</source>
          <target state="translated">OnceWith::next</target>
        </trans-unit>
        <trans-unit id="e4330c855cf5f92fc7584c51cdee41319443487c" translate="yes" xml:space="preserve">
          <source>OnceWith::next_back</source>
          <target state="translated">OnceWith::next_back</target>
        </trans-unit>
        <trans-unit id="1527b9229bda86674b9d9102f7590dba88349ecd" translate="yes" xml:space="preserve">
          <source>OnceWith::nth</source>
          <target state="translated">OnceWith::nth</target>
        </trans-unit>
        <trans-unit id="52e0f2df5caf846213c666b22fff6456cda8a68f" translate="yes" xml:space="preserve">
          <source>OnceWith::nth_back</source>
          <target state="translated">OnceWith::nth_back</target>
        </trans-unit>
        <trans-unit id="2d124bbf09c7f2b80ff84f088c67f3f07ae5780b" translate="yes" xml:space="preserve">
          <source>OnceWith::partial_cmp</source>
          <target state="translated">OnceWith::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cabc7165c7c9b316158511856e73e51b4305e89b" translate="yes" xml:space="preserve">
          <source>OnceWith::partition</source>
          <target state="translated">OnceWith::partition</target>
        </trans-unit>
        <trans-unit id="1cda021009cce16eced253abaf1a3a1b11566d18" translate="yes" xml:space="preserve">
          <source>OnceWith::peekable</source>
          <target state="translated">OnceWith::peekable</target>
        </trans-unit>
        <trans-unit id="03590b6367dd3bb1ba4d65b39afee2b09ca08df1" translate="yes" xml:space="preserve">
          <source>OnceWith::position</source>
          <target state="translated">OnceWith::position</target>
        </trans-unit>
        <trans-unit id="e1735abbbee6972dc130e89d570fd8fa919407fe" translate="yes" xml:space="preserve">
          <source>OnceWith::product</source>
          <target state="translated">OnceWith::product</target>
        </trans-unit>
        <trans-unit id="ec925c93a26e2eadc7d07e055f695e74c83d4c23" translate="yes" xml:space="preserve">
          <source>OnceWith::rev</source>
          <target state="translated">OnceWith::rev</target>
        </trans-unit>
        <trans-unit id="6243776ef017e4a1cf3d502a3968703e2ab8d6ed" translate="yes" xml:space="preserve">
          <source>OnceWith::rfind</source>
          <target state="translated">OnceWith::rfind</target>
        </trans-unit>
        <trans-unit id="aea12fd7d31659bccdee8c41ecdb4fb0f15444db" translate="yes" xml:space="preserve">
          <source>OnceWith::rfold</source>
          <target state="translated">OnceWith::rfold</target>
        </trans-unit>
        <trans-unit id="0c9e294cb61289d08c63ceca07aff5dfaea0261e" translate="yes" xml:space="preserve">
          <source>OnceWith::rposition</source>
          <target state="translated">OnceWith::rposition</target>
        </trans-unit>
        <trans-unit id="cef9b43e5eedf9af103faef7b1bbe4d12db9ab2f" translate="yes" xml:space="preserve">
          <source>OnceWith::scan</source>
          <target state="translated">OnceWith::scan</target>
        </trans-unit>
        <trans-unit id="cc6e5c82263a6bf9a575956ff17a327f6e8e1a12" translate="yes" xml:space="preserve">
          <source>OnceWith::size_hint</source>
          <target state="translated">OnceWith::size_hint</target>
        </trans-unit>
        <trans-unit id="eb30275a1bfcdf9e0075819a60e55de8140da973" translate="yes" xml:space="preserve">
          <source>OnceWith::skip</source>
          <target state="translated">OnceWith::skip</target>
        </trans-unit>
        <trans-unit id="d51df4ad9879230eee4b7d1f410130e26dd6a97e" translate="yes" xml:space="preserve">
          <source>OnceWith::skip_while</source>
          <target state="translated">OnceWith::skip_while</target>
        </trans-unit>
        <trans-unit id="13b1461f738d3541f7f825bf588919136b55d36d" translate="yes" xml:space="preserve">
          <source>OnceWith::step_by</source>
          <target state="translated">OnceWith::step_by</target>
        </trans-unit>
        <trans-unit id="74e43ad0cf8bc22a5af2d491f032ca5523c1d7b0" translate="yes" xml:space="preserve">
          <source>OnceWith::sum</source>
          <target state="translated">OnceWith::sum</target>
        </trans-unit>
        <trans-unit id="89cc6b13712f2c2ac536c3feb4e1809f1a6b5cc2" translate="yes" xml:space="preserve">
          <source>OnceWith::take</source>
          <target state="translated">OnceWith::take</target>
        </trans-unit>
        <trans-unit id="8c2cd8a3d3dfa6e2cb6f5f270f11cddff7173ce1" translate="yes" xml:space="preserve">
          <source>OnceWith::take_while</source>
          <target state="translated">OnceWith::take_while</target>
        </trans-unit>
        <trans-unit id="5a630013ba78b1577b011778f861dca34fdb6510" translate="yes" xml:space="preserve">
          <source>OnceWith::to_owned</source>
          <target state="translated">OnceWith::to_owned</target>
        </trans-unit>
        <trans-unit id="030ec595a21a12e03c641afa5fc2a0fbf3cfd96d" translate="yes" xml:space="preserve">
          <source>OnceWith::try_fold</source>
          <target state="translated">OnceWith::try_fold</target>
        </trans-unit>
        <trans-unit id="716d560ebaa2fa12887a04435f9271204fee9212" translate="yes" xml:space="preserve">
          <source>OnceWith::try_for_each</source>
          <target state="translated">OnceWith::try_for_each</target>
        </trans-unit>
        <trans-unit id="585e7e8b9f7e6990f4b13d54ca37d88a0bf70ca8" translate="yes" xml:space="preserve">
          <source>OnceWith::try_from</source>
          <target state="translated">OnceWith::try_from</target>
        </trans-unit>
        <trans-unit id="7cb93d634335cbd032ccfe91d14126a928250279" translate="yes" xml:space="preserve">
          <source>OnceWith::try_into</source>
          <target state="translated">OnceWith::try_into</target>
        </trans-unit>
        <trans-unit id="640ef41bdeff4cb6f8ee26085f02e8464a124452" translate="yes" xml:space="preserve">
          <source>OnceWith::try_rfold</source>
          <target state="translated">OnceWith::try_rfold</target>
        </trans-unit>
        <trans-unit id="100a64512cd2fe1b9fbd4ceea4850862b8f813b7" translate="yes" xml:space="preserve">
          <source>OnceWith::type_id</source>
          <target state="translated">OnceWith::type_id</target>
        </trans-unit>
        <trans-unit id="64fd105a0a6aa5f709a9477cafb3d6c01fd6cfb0" translate="yes" xml:space="preserve">
          <source>OnceWith::unzip</source>
          <target state="translated">OnceWith::unzip</target>
        </trans-unit>
        <trans-unit id="433df116ad00f74cb6d78ea83682ace23f21cb19" translate="yes" xml:space="preserve">
          <source>OnceWith::zip</source>
          <target state="translated">OnceWith::zip</target>
        </trans-unit>
        <trans-unit id="c04e60357eae6b0d2f646024db69bbf3bdb3f30b" translate="yes" xml:space="preserve">
          <source>One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of &lt;code&gt;grep&lt;/code&gt;, called &lt;code&gt;ripgrep&lt;/code&gt;. By comparison, our version of &lt;code&gt;grep&lt;/code&gt; will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as &lt;code&gt;ripgrep&lt;/code&gt;.</source>
          <target state="translated">Rustコミュニティメンバーの1つであるAndrew Gallantは、 &lt;code&gt;ripgrep&lt;/code&gt; と呼ばれる、フル機能の非常に高速なバージョンの &lt;code&gt;grep&lt;/code&gt; をすでに作成しています。比較すると、私たちのバージョンの &lt;code&gt;grep&lt;/code&gt; はかなり単純ですが、この章では、 &lt;code&gt;ripgrep&lt;/code&gt; などの実際のプロジェクトを理解するために必要な背景知識をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="6d8cb1de18a6c59ff63b7aa03082a18e5d9546ee" translate="yes" xml:space="preserve">
          <source>One benefit of implementing &lt;code&gt;IntoIterator&lt;/code&gt; is that your type will &lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;work with Rust's &lt;code&gt;for&lt;/code&gt; loop syntax&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;IntoIterator&lt;/code&gt; を実装する利点の1つは、型が&lt;a href=&quot;index#for-loops-and-intoiterator&quot;&gt;Rustの &lt;code&gt;for&lt;/code&gt; ループ構文で機能すること&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1d5bdf955d9dc47b0601586e8217dda6094c541f" translate="yes" xml:space="preserve">
          <source>One character can become multiple:</source>
          <target state="translated">一人のキャラが複数になることもあります。</target>
        </trans-unit>
        <trans-unit id="fa91f526636a9109f1e67616db8e82d52af8d580" translate="yes" xml:space="preserve">
          <source>One detail we didn&amp;rsquo;t discuss in the &lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;&amp;ldquo;References and Borrowing&amp;rdquo;&lt;/a&gt; section in Chapter 4 is that every reference in Rust has a &lt;em&gt;lifetime&lt;/em&gt;, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.</source>
          <target state="translated">第4章の&lt;a href=&quot;ch04-02-references-and-borrowing#references-and-borrowing&quot;&gt;「参照と借用」&lt;/a&gt;セクションで説明しなかった詳細の1つは、Rustのすべての参照に&lt;em&gt;存続期間&lt;/em&gt;があることです。これは、その参照が有効なスコープです。ほとんどの場合、ライフタイムは暗黙的で推論され、ほとんどの場合、タイプが推論されます。複数の型が可能な場合は、型に注釈を付ける必要があります。同様に、参照のライフタイムがいくつかの異なる方法で関連付けられる可能性がある場合は、ライフタイムに注釈を付ける必要があります。Rustでは、実行時に使用される実際の参照が確実に有効になるように、ジェネリックライフタイムパラメーターを使用して関係に注釈を付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="d218cebb1b26aab7ac78425185eee65d682c0943" translate="yes" xml:space="preserve">
          <source>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. If we add another state between &lt;code&gt;PendingReview&lt;/code&gt; and &lt;code&gt;Published&lt;/code&gt;, such as &lt;code&gt;Scheduled&lt;/code&gt;, we would have to change the code in &lt;code&gt;PendingReview&lt;/code&gt; to transition to &lt;code&gt;Scheduled&lt;/code&gt; instead. It would be less work if &lt;code&gt;PendingReview&lt;/code&gt; didn&amp;rsquo;t need to change with the addition of a new state, but that would mean switching to another design pattern.</source>
          <target state="translated">状態パターンの1つの欠点は、状態が状態間の遷移を実装するため、一部の状態が互いに結合されることです。 &lt;code&gt;PendingReview&lt;/code&gt; と &lt;code&gt;Published&lt;/code&gt; の間に別の状態（ &lt;code&gt;Scheduled&lt;/code&gt; など）を追加する場合は、代わりに &lt;code&gt;PendingReview&lt;/code&gt; のコードを変更して、 &lt;code&gt;Scheduled&lt;/code&gt; に移行する必要があります。 &lt;code&gt;PendingReview&lt;/code&gt; が新しい状態の追加で変更する必要がなければ、作業は少なくなりますが、それは別のデザインパターンに切り替えることを意味します。</target>
        </trans-unit>
        <trans-unit id="79dab74a608a5fe55775f425d883e5609ea6484a" translate="yes" xml:space="preserve">
          <source>One example of a trait with an associated type is the &lt;code&gt;Iterator&lt;/code&gt; trait that the standard library provides. The associated type is named &lt;code&gt;Item&lt;/code&gt; and stands in for the type of the values the type implementing the &lt;code&gt;Iterator&lt;/code&gt; trait is iterating over. In &lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;&amp;ldquo;The &lt;code&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method&amp;rdquo;&lt;/a&gt; section of Chapter 13, we mentioned that the definition of the &lt;code&gt;Iterator&lt;/code&gt; trait is as shown in Listing 19-12.</source>
          <target state="translated">関連するタイプを持つ特性の1つの例は、標準ライブラリが提供する &lt;code&gt;Iterator&lt;/code&gt; 特性です。関連付けられた型は &lt;code&gt;Item&lt;/code&gt; という名前で、 &lt;code&gt;Iterator&lt;/code&gt; トレイトを実装する型が反復している値の型を表します。では&lt;a href=&quot;ch13-02-iterators#the-iterator-trait-and-the-next-method&quot;&gt;、「 &lt;code&gt;Iterator&lt;/code&gt; 形質と &lt;code&gt;next&lt;/code&gt; 方法」&lt;/a&gt;第13章のセクション、私たちは、の定義と述べた &lt;code&gt;Iterator&lt;/code&gt; 、リスト19-12で示されているようである特性。</target>
        </trans-unit>
        <trans-unit id="6e24d429d27b48134811a91f7546e1e6d93fd489" translate="yes" xml:space="preserve">
          <source>One final expression that has the type &lt;code&gt;!&lt;/code&gt; is a &lt;code&gt;loop&lt;/code&gt;:</source>
          <target state="translated">タイプを持つ1つの最後の式 &lt;code&gt;!&lt;/code&gt; ある &lt;code&gt;loop&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="08b7d5a5c0be732c550b04476aeb4d64ed0d9f34" translate="yes" xml:space="preserve">
          <source>One fix is to use &lt;code&gt;Option&lt;/code&gt;, like so:</source>
          <target state="translated">1つの修正は、次のように &lt;code&gt;Option&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="0404f28b47072e36d14ad36dc7e51fdfb00d1799" translate="yes" xml:space="preserve">
          <source>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</source>
          <target state="translated">一つの解決策は、再帰の制限を増やすことかもしれません。派生参照の無限の再帰を作成することが可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="604777bf4c9ef568f65e74a5ef4770d9197bf0e4" translate="yes" xml:space="preserve">
          <source>One greater than the minimum possible normal power of 2 exponent.</source>
          <target state="translated">2指数の最小可能な通常の乗よりも大きい1つ。</target>
        </trans-unit>
        <trans-unit id="d6888a831481b2df0737ae6067a1763cc0ae4b8b" translate="yes" xml:space="preserve">
          <source>One important part of this code is that the &lt;code&gt;Messenger&lt;/code&gt; trait has one method called &lt;code&gt;send&lt;/code&gt; that takes an immutable reference to &lt;code&gt;self&lt;/code&gt; and the text of the message. This is the interface our mock object needs to have. The other important part is that we want to test the behavior of the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt;. We can change what we pass in for the &lt;code&gt;value&lt;/code&gt; parameter, but &lt;code&gt;set_value&lt;/code&gt; doesn&amp;rsquo;t return anything for us to make assertions on. We want to be able to say that if we create a &lt;code&gt;LimitTracker&lt;/code&gt; with something that implements the &lt;code&gt;Messenger&lt;/code&gt; trait and a particular value for &lt;code&gt;max&lt;/code&gt;, when we pass different numbers for &lt;code&gt;value&lt;/code&gt;, the messenger is told to send the appropriate messages.</source>
          <target state="translated">このコードの重要な部分の1つは、 &lt;code&gt;Messenger&lt;/code&gt; トレイトに、 &lt;code&gt;self&lt;/code&gt; とメッセージのテキストへの不変の参照を取得する &lt;code&gt;send&lt;/code&gt; というメソッドが1つあることです。これは、モックオブジェクトに必要なインターフェイスです。他の重要な部分は、私たちが行動のテストすることです &lt;code&gt;set_value&lt;/code&gt; の方法 &lt;code&gt;LimitTracker&lt;/code&gt; を。 &lt;code&gt;value&lt;/code&gt; パラメータに渡すものを変更できますが、 &lt;code&gt;set_value&lt;/code&gt; はアサーションを行うために何も返しません。 &lt;code&gt;Messenger&lt;/code&gt; トレイトと &lt;code&gt;max&lt;/code&gt; の特定の値を実装するもので &lt;code&gt;LimitTracker&lt;/code&gt; を作成すると、、 &lt;code&gt;value&lt;/code&gt; に異なる数値を渡すと、メッセンジャーは適切なメッセージを送信するように指示されます。</target>
        </trans-unit>
        <trans-unit id="ded7cc38097138108681f22bf5306daeb4f49884" translate="yes" xml:space="preserve">
          <source>One increasingly popular approach to ensuring safe concurrency is &lt;em&gt;message passing&lt;/em&gt;, where threads or actors communicate by sending each other messages containing data. Here&amp;rsquo;s the idea in a slogan from &lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;the Go language documentation&lt;/a&gt;: &amp;ldquo;Do not communicate by sharing memory; instead, share memory by communicating.&amp;rdquo;</source>
          <target state="translated">安全な同時実行性を確保するためのますます一般的なアプローチの1つは、&lt;em&gt;メッセージパッシングです&lt;/em&gt;。この方法では、スレッドまたはアクターが、データを含む他のメッセージを互いに送信することによって通信します。これは&lt;a href=&quot;http://golang.org/doc/effective_go.html&quot;&gt;、Go言語のドキュメント&lt;/a&gt;にあるスローガンのアイデアです。「メモリを共有して通信しないでください。代わりに、通信してメモリを共有してください。」</target>
        </trans-unit>
        <trans-unit id="d6b559b40224203447024d2ae45e68a9e1945eed" translate="yes" xml:space="preserve">
          <source>One last example:</source>
          <target state="translated">最後の一例。</target>
        </trans-unit>
        <trans-unit id="1ad534544463088b932bc112e0ba96d50acc9887" translate="yes" xml:space="preserve">
          <source>One lifetime annotation by itself doesn&amp;rsquo;t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. For example, let&amp;rsquo;s say we have a function with the parameter &lt;code&gt;first&lt;/code&gt; that is a reference to an &lt;code&gt;i32&lt;/code&gt; with lifetime &lt;code&gt;'a&lt;/code&gt;. The function also has another parameter named &lt;code&gt;second&lt;/code&gt; that is another reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;. The lifetime annotations indicate that the references &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; must both live as long as that generic lifetime.</source>
          <target state="translated">アノテーションは、複数の参照の一般的なライフタイムパラメータが互いにどのように関連するかをRustに伝えることを目的としているため、1つのライフタイムアノテーションだけではあまり意味がありません。たとえば、ライフタイム &lt;code&gt;'a&lt;/code&gt; の &lt;code&gt;i32&lt;/code&gt; への参照である &lt;code&gt;first&lt;/code&gt; のパラメーターを持つ関数があるとします。この関数には、ライフタイム &lt;code&gt;'a&lt;/code&gt; を持つ &lt;code&gt;i32&lt;/code&gt; への別の参照である、 &lt;code&gt;second&lt;/code&gt; という別のパラメーターもあります。ライフタイムアノテーションは、 &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;second&lt;/code&gt; の参照の両方が、そのジェネリックライフタイムと同じ長さでなければならないことを示しています。</target>
        </trans-unit>
        <trans-unit id="eb999aea4a6804c2aba22f0ab64c0d473a5cc357" translate="yes" xml:space="preserve">
          <source>One major tool Rust has for accomplishing message-sending concurrency is the &lt;em&gt;channel&lt;/em&gt;, a programming concept that Rust&amp;rsquo;s standard library provides an implementation of. You can imagine a channel in programming as being like a channel of water, such as a stream or a river. If you put something like a rubber duck or boat into a stream, it will travel downstream to the end of the waterway.</source>
          <target state="translated">Rustがメッセージ送信の同時実行を実現するための主要なツールの1つである&lt;em&gt;チャネル&lt;/em&gt;は、Rustの標準ライブラリが実装するプログラミング概念です。プログラミングの水路は、小川や川などの水路のようなものと想像できます。ゴム製のアヒルやボートのようなものを小川に入れると、水路の終わりまで下流に移動します。</target>
        </trans-unit>
        <trans-unit id="a100de9eac9101d503c874b2c73fc8e99b7771dc" translate="yes" xml:space="preserve">
          <source>One maybe obvious note when using append-mode: make sure that all data that belongs together is written to the file in one operation. This can be done by concatenating strings before passing them to &lt;a href=&quot;struct.file#method.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;, or using a buffered writer (with a buffer of adequate size), and calling &lt;a href=&quot;struct.file#method.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; when the message is complete.</source>
          <target state="translated">append-modeを使用する際の明白な注意の1つ：一緒に属するすべてのデータが1回の操作でファイルに書き込まれることを確認してください。これは、文字列を&lt;a href=&quot;struct.file#method.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;に渡す前に連結するか、（適切なサイズのバッファーを備えた）バッファー付きライターを使用して、メッセージが完了したときに&lt;a href=&quot;struct.file#method.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt;を呼び出すことで実行できます。</target>
        </trans-unit>
        <trans-unit id="2650888f948816ac8a9838e1462a292b91d57e17" translate="yes" xml:space="preserve">
          <source>One of the keys to &lt;code&gt;collect()&lt;/code&gt;'s power is that many things you might not think of as 'collections' actually are. For example, a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; is a collection of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. And a collection of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; can be thought of as single &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.</source>
          <target state="translated">&lt;code&gt;collect()&lt;/code&gt; の威力の鍵の1つは、実際には「コレクション」とは思わないことも多いということです。たとえば、&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;のコレクションです。そして&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt; は、単一の&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &amp;lt;Collection &amp;lt;T&amp;gt;、E&amp;gt;と考えることができます。詳細については、以下の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="c25ed3c3dc3acc46e3e6ecc55a7e68acca10b918" translate="yes" xml:space="preserve">
          <source>One of the uses of a &lt;code&gt;loop&lt;/code&gt; is to retry an operation you know might fail, such as checking whether a thread has completed its job. However, you might need to pass the result of that operation to the rest of your code. To do this, you can add the value you want returned after the &lt;code&gt;break&lt;/code&gt; expression you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; の使用法の1つは、スレッドがジョブを完了したかどうかを確認するなど、失敗する可能性のある操作を再試行することです。ただし、その操作の結果を残りのコードに渡す必要がある場合があります。これを行うには、ループを停止するために使用する &lt;code&gt;break&lt;/code&gt; 式の後に、戻りたい値を追加できます。この値はループから返されるので、次に示すように使用できます。</target>
        </trans-unit>
        <trans-unit id="f31603daf9af84bcc62de6d02f7c02e0a197c236" translate="yes" xml:space="preserve">
          <source>One requirement for &lt;code&gt;match&lt;/code&gt; expressions is that they need to be &lt;em&gt;exhaustive&lt;/em&gt; in the sense that all possibilities for the value in the &lt;code&gt;match&lt;/code&gt; expression must be accounted for. One way to ensure you&amp;rsquo;ve covered every possibility is to have a catchall pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.</source>
          <target state="translated">以下のための一つの要件 &lt;code&gt;match&lt;/code&gt; 式は、彼らがする必要があるということです&lt;em&gt;網羅&lt;/em&gt;内の値についてあらゆる可能性という意味で &lt;code&gt;match&lt;/code&gt; 式が考慮されなければなりません。すべての可能性を確実にカバーする1つの方法は、最後のアームのキャッチオールパターンを使用することです。たとえば、任意の値に一致する変数名が失敗することはなく、残りのすべてのケースをカバーします。</target>
        </trans-unit>
        <trans-unit id="2015b7ca5d5d193e7b2cd1b845883b1560077b31" translate="yes" xml:space="preserve">
          <source>One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate. For example, we can implement standard library traits like &lt;code&gt;Display&lt;/code&gt; on a custom type like &lt;code&gt;Tweet&lt;/code&gt; as part of our &lt;code&gt;aggregator&lt;/code&gt; crate functionality, because the type &lt;code&gt;Tweet&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate. We can also implement &lt;code&gt;Summary&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in our &lt;code&gt;aggregator&lt;/code&gt; crate, because the trait &lt;code&gt;Summary&lt;/code&gt; is local to our &lt;code&gt;aggregator&lt;/code&gt; crate.</source>
          <target state="translated">トレイトの実装で注意すべき1つの制限は、トレイトまたはタイプのいずれかがクレートに対してローカルである場合にのみ、タイプにトレイトを実装できることです。例えば、我々のような標準ライブラリの特性を実装することができます &lt;code&gt;Display&lt;/code&gt; のようなカスタム型の &lt;code&gt;Tweet&lt;/code&gt; 私たちの一環として、 &lt;code&gt;aggregator&lt;/code&gt; タイプので、クレート機能 &lt;code&gt;Tweet&lt;/code&gt; 私たちにローカルな &lt;code&gt;aggregator&lt;/code&gt; クレート。特性 &lt;code&gt;Summary&lt;/code&gt; は &lt;code&gt;aggregator&lt;/code&gt; クレートに対してローカルであるため、 &lt;code&gt;aggregator&lt;/code&gt; クレートで &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; に &lt;code&gt;Summary&lt;/code&gt; を実装することもできます。</target>
        </trans-unit>
        <trans-unit id="3ca14e0e855a4d320ac718d1dbab1d5658779f12" translate="yes" xml:space="preserve">
          <source>One should always prefer implementing &lt;code&gt;From&lt;/code&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;code&gt;From&lt;/code&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library.</source>
          <target state="translated">一つは、常に実装好むはずです &lt;code&gt;From&lt;/code&gt; 以上&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;実装するため &lt;code&gt;From&lt;/code&gt; 自動的にするの実装に1を提供&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;標準ライブラリのブランケット実装のおかげ。</target>
        </trans-unit>
        <trans-unit id="b9063035453c1b2c42529a52a82eaf086598016e" translate="yes" xml:space="preserve">
          <source>One should only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. Otherwise one should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; over &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; because implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; automatically provides one with a implementation of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; thanks to the blanket implementation in the standard library. &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; cannot do these type of conversions because of Rust's orphaning rules.</source>
          <target state="translated">現在のクレート外の型への変換が必要な場合にのみ、&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; を&lt;/a&gt;実装する必要があります。そうでなければ1は常に実装好むはずです&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;以上&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;実装するため&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;自動的に実装して1を提供&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;標準ライブラリのブランケット実装のおかげ。Rustの孤立ルールのため、&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;はこれらのタイプの変換を行うことができません。</target>
        </trans-unit>
        <trans-unit id="1a1308a26b40990e2a9ab226282be34a9c0f3915" translate="yes" xml:space="preserve">
          <source>One special lifetime we need to discuss is &lt;code&gt;'static&lt;/code&gt;, which means that this reference &lt;em&gt;can&lt;/em&gt; live for the entire duration of the program. All string literals have the &lt;code&gt;'static&lt;/code&gt; lifetime, which we can annotate as follows:</source>
          <target state="translated">私たちが議論する必要がある特別な寿命の1つは &lt;code&gt;'static&lt;/code&gt; 。これは、この参照&lt;em&gt;が&lt;/em&gt;プログラムの全期間にわたって存続&lt;em&gt;できること&lt;/em&gt;を意味します。すべての文字列リテラルには &lt;code&gt;'static&lt;/code&gt; 存続期間」があり、次のように注釈を付けることができます。</target>
        </trans-unit>
        <trans-unit id="b3c0e81ae8d50e16a5ef5685ec5ba7252876cd13" translate="yes" xml:space="preserve">
          <source>One way to do this would be to parse the guess as an &lt;code&gt;i32&lt;/code&gt; instead of only a &lt;code&gt;u32&lt;/code&gt; to allow potentially negative numbers, and then add a check for the number being in range, like so:</source>
          <target state="translated">これを行う1つの方法は、 &lt;code&gt;u32&lt;/code&gt; だけではなく &lt;code&gt;i32&lt;/code&gt; として推測を解析して、負の可能性のある数値を許可し、次のように範囲内の数値のチェックを追加することです。</target>
        </trans-unit>
        <trans-unit id="040e8b6c5e16e2eb7dbd8ea369897b2ed67939bb" translate="yes" xml:space="preserve">
          <source>One way to fix this is by wrapping &lt;code&gt;ListNode&lt;/code&gt; in a &lt;code&gt;Box&lt;/code&gt;, like so:</source>
          <target state="translated">これを修正する1つの方法は、次のように &lt;code&gt;ListNode&lt;/code&gt; を &lt;code&gt;Box&lt;/code&gt; でラップすることです。</target>
        </trans-unit>
        <trans-unit id="e58c5baae639d4247baa5d3c55a2e51c5fc2fcbf" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;AssertUnwindSafe&lt;/code&gt; is to assert that the entire closure itself is unwind safe, bypassing all checks for all variables:</source>
          <target state="translated">&lt;code&gt;AssertUnwindSafe&lt;/code&gt; を使用する1つの方法は、クロージャー全体がアンワインドセーフであることを表明し、すべての変数のすべてのチェックをバイパスすることです。</target>
        </trans-unit>
        <trans-unit id="1d8228fcb1896e7f726b443ff97084ceedc8b0d1" translate="yes" xml:space="preserve">
          <source>One way to work around this is to introduce a phantom type parameter into &lt;code&gt;FooMaker&lt;/code&gt;, like so:</source>
          <target state="translated">これを回避する1つの方法は、ファントム型パラメーターを &lt;code&gt;FooMaker&lt;/code&gt; に導入することです。</target>
        </trans-unit>
        <trans-unit id="5d2a1cfc42a9afc1fe710bb8389ace0259e088eb" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience worse performance.</source>
          <target state="translated">ハッシュの確率的性質により、&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;のみがコストを予想しています。&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; の&lt;/a&gt;パフォーマンスが低下する可能性は非常に低いですが、理論的には可能です。</target>
        </trans-unit>
        <trans-unit id="c64700ee184977494a32292609d647c2790da91d" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;extern crate&lt;/code&gt; imports at the crate root level are allowed to import macros.</source>
          <target state="translated">マクロをインポートできるのは、クレートルートレベルの &lt;code&gt;extern crate&lt;/code&gt; インポートのみです。</target>
        </trans-unit>
        <trans-unit id="0f1a591311049947010f4fb443dacb5d1227b8a1" translate="yes" xml:space="preserve">
          <source>Only Inserting a Value If the Key Has No Value</source>
          <target state="translated">キーに値がない場合にのみ値を挿入する</target>
        </trans-unit>
        <trans-unit id="a86a2e98e34b9080a837979f0cd7c8a23bdc05cc" translate="yes" xml:space="preserve">
          <source>Only a higher-ranked bound can be used here as the lifetime of the reference is shorter than a lifetime parameter on the function:</source>
          <target state="translated">ここでは、参照の寿命が関数の寿命パラメータよりも短いため、より高いランクの境界のみを使用することができます。</target>
        </trans-unit>
        <trans-unit id="1d9857467e96b586319b486e37d19a227573b8ef" translate="yes" xml:space="preserve">
          <source>Only considers whole path components to match.</source>
          <target state="translated">一致するパス全体のコンポーネントのみを考慮します。</target>
        </trans-unit>
        <trans-unit id="79d045850f7f84e6ac5788c792fcb946090d94ed" translate="yes" xml:space="preserve">
          <source>Only field-less enums can be cast to numerical primitives, so this attribute will not apply to structs.</source>
          <target state="translated">数値プリミティブにキャストできるのはフィールドレスの列挙型のみなので、この属性は構造体には適用されません。</target>
        </trans-unit>
        <trans-unit id="905a2eaaaa2de81962debc1768f8a3e80eac42bb" translate="yes" xml:space="preserve">
          <source>Only functions and methods can be called using &lt;code&gt;()&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; を使用して呼び出すことができるのは関数とメソッドのみです。例：</target>
        </trans-unit>
        <trans-unit id="75a9ac98deeca6b24da630baa2c701b9504057f7" translate="yes" xml:space="preserve">
          <source>Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; if a conversion to a type outside the current crate is required. &lt;code&gt;From&lt;/code&gt; cannot do these type of conversions because of Rust's orphaning rules. See &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">現在のクレート外の型への変換が必要な場合にのみ、&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; を&lt;/a&gt;実装します。Rustの孤立ルールのため、 &lt;code&gt;From&lt;/code&gt; はこれらのタイプの変換を行うことができません。詳細については、&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="32f9fc3a3cbf2058b25d70080083b8cc212e6656" translate="yes" xml:space="preserve">
          <source>Only one argument can be passed per use. So instead of:</source>
          <target state="translated">1回の使用につき、1つの引数しか渡すことができません。そのため、代わりに</target>
        </trans-unit>
        <trans-unit id="457e98acf3983b9b27751cc789092296edcc762f" translate="yes" xml:space="preserve">
          <source>Only one thread will have &lt;code&gt;true&lt;/code&gt; returned from their result, all other threads will have &lt;code&gt;false&lt;/code&gt; returned.</source>
          <target state="translated">1つのスレッドだけが結果から &lt;code&gt;true&lt;/code&gt; を返し、他のすべてのスレッドは &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e3609d3dffa4fe7169c12045193a601a2a125a6f" translate="yes" xml:space="preserve">
          <source>Only primitive types can be cast into each other. Examples:</source>
          <target state="translated">プリミティブ型だけがお互いにキャストできます。例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="ab9f48b23a6a48f0ef7b5f4e6bfbc32e252bb8f0" translate="yes" xml:space="preserve">
          <source>Only published blog posts return content to print, so unapproved posts can&amp;rsquo;t accidentally be published.</source>
          <target state="translated">公開されたブログ投稿のみが印刷するコンテンツを返すため、承認されていない投稿が誤って公開されることはありません。</target>
        </trans-unit>
        <trans-unit id="073ebf55d3884fb61165383e76a504c9d12cc4b5" translate="yes" xml:space="preserve">
          <source>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; is not allowed.</source>
          <target state="translated">構造体と列挙型だけが送信、同期、およびその他のオプトアウトトレイトを実装でき、構造体または列挙型は現在のクレートに対してローカルでなければなりません。したがって、たとえば、 &lt;code&gt;unsafe impl Send for Rc&amp;lt;Foo&amp;gt;&lt;/code&gt; は許可されません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
