<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">この関数は、バッファーを完全に満たす前に「ファイルの終わり」に遭遇すると、種類&lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;エラーを返します。この場合、 &lt;code&gt;buf&lt;/code&gt; の内容は指定されていません。</target>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">この関数は、バッファーを完全に満たす前に「ファイルの終わり」に遭遇すると、種類&lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;エラーを返します。この場合、 &lt;code&gt;buf&lt;/code&gt; の内容は指定されていません。</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">この関数で&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;の種類のエラーが発生した場合、エラーは無視され、操作が続行されます。</target>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">この関数で&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;の種類のエラーが発生した場合、エラーは無視され、操作が続行されます。</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">この関数が何らかの形で I/O やその他のエラーに遭遇した場合、エラー・バリアントが返されます。エラーが返された場合は、バイトが読み込まれなかったことを保証しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">この関数が &lt;code&gt;Ok(0)&lt;/code&gt; を返す場合、ストリームはEOFに達しています。</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">この関数がエラーを返した場合、何バイト読んだかは不定ですが、バッファを完全に埋めるのに必要なバイト数以上は決して読み込まれません。</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">これがバッファリングされたチャネルの場合、この時点でバッファはいっぱいです。これがバッファリングされたチャネルでない場合、データを取得するために利用可能な&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;がありません。</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">これがオプションでない場合は、typeパラメータを別の特性オブジェクトで置き換えることを検討してください（たとえば、 &lt;code&gt;T: OtherTrait&lt;/code&gt; 場合、 &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; で使用します）。このメソッドにフィードするタイプの数が限られている場合は、さまざまなタイプのメソッドを手動でリストすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">初めての方は、標準ライブラリのドキュメントは何気なく目を通すように書かれています。おもしろいものをクリックすると、たいていはおもしろいところにたどり着けるはずです。しかし、見逃したくない重要な部分もありますので、標準ライブラリとそのドキュメントのツアーを読んでみてください。</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">このメソッドが &lt;code&gt;Err&lt;/code&gt; を返す場合、メモリブロックの所有権はこのアロケータに転送されておらず、メモリブロックの内容は変更されていません。</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">このメソッドが &lt;code&gt;Ok(addr)&lt;/code&gt; を返す場合、返される &lt;code&gt;addr&lt;/code&gt; は、 &lt;code&gt;layout&lt;/code&gt; インスタンスを保持するのに適したストレージのブロックを指すnull以外のアドレスになります。</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">このメソッドが NULL を返した場合、メモリ・ブロックの所有権はこのアロケータに移されておらず、メモリ・ブロックの内容は変更されていません。</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">これが複数の候補となる可能性がある場合はエラーであり、メソッド呼び出しを行うには、レシーバーを適切なレシーバータイプに&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;変換&lt;/a&gt;する必要があります。</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">これが &lt;code&gt;Err&lt;/code&gt; を返した場合、メモリブロックは元の（より大きな） &lt;code&gt;layout&lt;/code&gt; を引き続き表していると見なされます。他の場所での再利用のために切り分けられたブロックはなく、メモリブロックの所有権は転送されておらず、メモリブロックの内容は変更されていません。</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">これが &lt;code&gt;Ok&lt;/code&gt; を返す場合、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックの所有権はこのアロケータに転送されています。メモリは解放されている場合とされていない場合があり、使用不可と見なされます（もちろん、このメソッドの戻り値を介して呼び出し元に再度転送された場合を除きます）。</target>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">これが &lt;code&gt;Ok&lt;/code&gt; を返す場合、アロケータは、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックが &lt;code&gt;new_size&lt;/code&gt; に適合することをアサートしているため、そのサイズのレイアウトのデータを運ぶために使用でき、layoutと同じ配置になり &lt;code&gt;layout&lt;/code&gt; 。（アロケーターは、メモリブロックを拡張して後続のブロックや仮想メモリトリックを含めるなど、これを達成するための労力を費やすことができます。）</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">これが &lt;code&gt;Ok&lt;/code&gt; を返す場合、アロケータは、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックが &lt;code&gt;new_size&lt;/code&gt; に適合することを表明しているため、そのより小さなレイアウトのデータを運ぶためにのみ使用できます。（アロケーターはこれを利用して、ブロックの一部を切り取って他の場所で再利用できます。）小さいレイアウト内のブロックの切り捨てられた内容は変更されず、ブロックの所有権は転送されていません。</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">これがnull以外のポインタを返す場合、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックの所有権はこのアロケータに転送されています。メモリは割り当て解除されている場合とされていない場合があり、使用不可と見なされます（もちろん、このメソッドの戻り値を介して呼び出し元に再度転送された場合を除く）。</target>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この構文を使用する場合、印刷する文字数は、フォーマットされる実際のオブジェクトの前にあり、文字数のタイプは&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; で&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">マッチした2つの要素が直接隣接している場合、その間には空のスライスが存在します。</target>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">スタックデータだけでなく、 &lt;code&gt;String&lt;/code&gt; のヒープデータを深くコピー&lt;em&gt;し&lt;/em&gt;たい場合は、 &lt;code&gt;clone&lt;/code&gt; と呼ばれる一般的なメソッドを使用できます。メソッド構文については第5章で説明しますが、メソッドは多くのプログラミング言語で共通の機能であるため、おそらく以前に見たことがあるでしょう。</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">このコードを今すぐコンパイルすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">エラーを読み続けると、次の役立つメモが見つかります。</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">型の定義を制御する場合、 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; を使用して自分で &lt;code&gt;Clone&lt;/code&gt; を実装できます。</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">ここで型注釈を追加しない場合、Rustは次のエラーを表示します。これは、使用する型を知るために、コンパイラーがさらに情報を必要とすることを意味します。</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 関数を &lt;code&gt;Copy&lt;/code&gt; トレイトを実装する型に制限したくない場合は、 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Copy&lt;/code&gt; ではなく &lt;code&gt;Clone&lt;/code&gt; トレイトにバインドされていることを指定できます。次に、 &lt;code&gt;largest&lt;/code&gt; 関数に所有権を持たせたい場合は、スライスの各値を複製できます。 &lt;code&gt;clone&lt;/code&gt; 関数を使用するということは、 &lt;code&gt;String&lt;/code&gt; のようなヒープデータを所有する型の場合、より多くのヒープ割り当てを行う可能性があることを意味します。大量のデータを処理している場合、ヒープ割り当てが遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">ライフタイムアノテーションを忘れてこの関数をコンパイルしようとすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">mutexでロックを取得したら、 &lt;code&gt;recv&lt;/code&gt; を呼び出してチャネルから &lt;code&gt;Job&lt;/code&gt; を受信します。最後の &lt;code&gt;unwrap&lt;/code&gt; は、ここでもエラーを通過します。これは、チャネルの送信側を保持するスレッドがシャットダウンした場合に発生する可能性があります。これは、受信側がシャットダウンした場合に &lt;code&gt;send&lt;/code&gt; メソッドが &lt;code&gt;Err&lt;/code&gt; を返すのと同様です。</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">プログラムの最初に &lt;code&gt;use std::io&lt;/code&gt; 行をリストしていなかった場合は、この関数呼び出しを &lt;code&gt;std::io::stdin&lt;/code&gt; として記述できます。 &lt;code&gt;stdin&lt;/code&gt; 関数は、のインスタンスを返す&lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt;お使いの端末の標準入力へのハンドルを表しタイプです。</target>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">より複雑なキーがある場合、 &lt;code&gt;insert&lt;/code&gt; を呼び出してもキーの値は更新されません。例えば：</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">文字列スライスがある場合は、直接渡すことができます。我々が持っている場合は &lt;code&gt;String&lt;/code&gt; 、我々は全体のスライス渡すことができます &lt;code&gt;String&lt;/code&gt; 。代わりに参照の文字列スライス取るように関数を定義する &lt;code&gt;String&lt;/code&gt; 任意の機能を失うことなく、当社のAPIがより一般的で有用なものにします：</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">キーと値をハッシュマップに挿入してから、同じキーを異なる値で挿入すると、そのキーに関連付けられている値が置き換えられます。リスト8-24のコードは &lt;code&gt;insert&lt;/code&gt; を 2回実行していますが、Blueチームのキーの値を両方とも挿入しているため、ハッシュマップにはキーと値のペアが1つしか含まれていません。</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">ハッシュマップに値への参照を挿入しても、値はハッシュマップに移動されません。参照が指す値は、少なくともハッシュマップが有効である限り有効である必要があります。これらの問題については、第10章の&lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;「有効期間による参照の検証」&lt;/a&gt;セクションで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">Devanagariスクリプトで書かれたヒンディー語の「नमस्ते」を見ると、次のような &lt;code&gt;u8&lt;/code&gt; 値のベクトルとして格納されています。</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">複数の文字列を連結する必要がある場合、 &lt;code&gt;+&lt;/code&gt; 演算子の動作は扱いにくくなります。</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">先ほど見たように、引数を渡さずにテストを実行すると、すべてのテストが並行して実行されます。</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">&lt;em&gt;hello.txt&lt;/em&gt;ファイルなしでこのコードを実行すると、 &lt;code&gt;panic!&lt;/code&gt; からのエラーメッセージが表示されます。 &lt;code&gt;unwrap&lt;/code&gt; メソッドが行う呼び出し：</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">このコードを実行すると、このようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">&lt;code&gt;takes_ownership&lt;/code&gt; の呼び出し後に &lt;code&gt;s&lt;/code&gt; を使用しようとすると、Rustはコンパイル時エラーをスローします。これらの静的チェックはミスから私たちを守ります。 &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;x&lt;/code&gt; を使用するコードを &lt;code&gt;main&lt;/code&gt; に追加して、それらをどこで使用できるか、また所有権のルールによってどこで使用できないかを確認してください。</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">&lt;code&gt;assert_eq!(5, y);&lt;/code&gt; を書こうとした場合 代わりに、次のコンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">スコープの終了後に &lt;code&gt;leaf&lt;/code&gt; の親にアクセスしようとすると、再び &lt;code&gt;None&lt;/code&gt; が返されます。プログラムの終了時に、 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; で &lt;code&gt;leaf&lt;/code&gt; 可変のため、1の強力な数と0の弱い数を持っている &lt;code&gt;leaf&lt;/code&gt; 、今への参照のみである &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; もう一度。</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">リスト15-15に示すように、リスト15-14の &lt;code&gt;main&lt;/code&gt; 関数を変更して &lt;code&gt;Drop&lt;/code&gt; トレイトの &lt;code&gt;drop&lt;/code&gt; メソッドを手動で呼び出そうとすると、コンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">リスト15-3のコードをコンパイルしようとすると、リスト15-4で示されるようなエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">リスト10-21で示されるように &lt;code&gt;longest&lt;/code&gt; 関数を実装しようとすると、コンパイルされません。</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">これらのルールに違反しようとすると、参照の場合のようにコンパイラエラーが発生するのではなく、 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 実装が実行時にパニックになります。リスト15-23はリスト15-22 の &lt;code&gt;send&lt;/code&gt; の実装の修正を示しています。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; が実行時にこれを実行できないようにするために、同じスコープに対してアクティブな2つの可変借入を意図的に作成しようとしています。</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;Some&lt;/code&gt; ではなく &lt;code&gt;None&lt;/code&gt; を使用する場合は、コンパイラーが &lt;code&gt;None&lt;/code&gt; の値だけを見て &lt;code&gt;Some&lt;/code&gt; バリアントが保持する型を推測できないため、Rustにどのタイプの &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; があるかを通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">ベクトルの各要素に順番にアクセスする場合は、インデックスを使用して一度に1つずつアクセスするのではなく、すべての要素を反復処理できます。リスト8-8は、 &lt;code&gt;for&lt;/code&gt; ループを使用して &lt;code&gt;i32&lt;/code&gt; 値のベクトルの各要素への不変の参照を取得し、それらを出力する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">私たちが持参したい場合は&lt;em&gt;、すべての&lt;/em&gt;スコープにパスで定義されている公共のアイテムを、私たちはそのパスを指定することができますが続く &lt;code&gt;*&lt;/code&gt; 、グロブ演算子：</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">テストに合格するための出力値も確認したい場合は、 &lt;code&gt;--nocapture&lt;/code&gt; フラグを使用して出力キャプチャ動作を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">この関数で &lt;code&gt;item1&lt;/code&gt; と &lt;code&gt;item2&lt;/code&gt; に異なるタイプを許可したい場合、（両方のタイプが &lt;code&gt;Summary&lt;/code&gt; を実装している限り） &lt;code&gt;impl Trait&lt;/code&gt; を使用するのが適切です。両方のパラメーターに同じ型を強制したい場合は、次のように、特性の境界を使用してのみ表現できます。</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">タプルの1つ以上の値を無視する場合は、&lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;「パターンの値を無視する」&lt;/a&gt;セクションで説明するように、 &lt;code&gt;_&lt;/code&gt; または &lt;code&gt;..&lt;/code&gt; を使用できます。問題がパターン内の変数が多すぎることである場合、解決策は、変数を削除して型を一致させ、変数の数がタプル内の要素の数と等しくなるようにすることです。</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">このコードの実行が許可されている場合、生成されたスレッドはまったく実行されずにすぐにバックグラウンドに置かれる可能性があります。生成されたスレッドは内部で &lt;code&gt;v&lt;/code&gt; への参照を持っていますが、メインスレッドは、第15章で説明した &lt;code&gt;drop&lt;/code&gt; 関数を使用してすぐに &lt;code&gt;v&lt;/code&gt; を削除します。その後、生成されたスレッドが実行を開始すると、 &lt;code&gt;v&lt;/code&gt; は無効になるため、その参照はまた無効です。大野！</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; を呼び出すと、 &lt;code&gt;coin&lt;/code&gt; は &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; ます。その値を各マッチアームと比較すると、 &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; 到達するまで、どのマッチアームも一致しません。その時点で、 &lt;code&gt;state&lt;/code&gt; のバインディングは値 &lt;code&gt;UsState::Alaska&lt;/code&gt; ます。その後、そのバインディングを &lt;code&gt;println!&lt;/code&gt; で使用できます！式、つまり &lt;code&gt;Quarter&lt;/code&gt; の &lt;code&gt;Coin&lt;/code&gt; enumバリアントから内部状態値を取得します。</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">状態パターンを使用しない代替実装を作成する場合、代わりに &lt;code&gt;Post&lt;/code&gt; のメソッドで、または投稿の状態をチェックしてそれらの場所の動作を変更する &lt;code&gt;main&lt;/code&gt; コードで、 &lt;code&gt;match&lt;/code&gt; 式を使用する場合があります。つまり、投稿が公開済みであることのすべての影響を理解するには、いくつかの場所を調べる必要があります。これにより、追加した状態が増えるだけです。これらの &lt;code&gt;match&lt;/code&gt; 式のそれぞれに別のアームが必要になります。</target>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">同じパッケージまたは同じモジュールで定義された複数のアイテムを使用している場合、各アイテムを1行にリストすると、ファイル内で多くの垂直方向のスペースを占める可能性があります。たとえば、ゲスティングゲームのリスト2-4にある次の2つの &lt;code&gt;use&lt;/code&gt; ステートメントは、アイテムを &lt;code&gt;std&lt;/code&gt; からスコープに持ってきます。</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">あなたは場合に&lt;em&gt;行う&lt;/em&gt;ルーストに、コンパイラはあなたに（によって制御デフォルトでは、警告与えることを書き込み &lt;code&gt;unused_must_use&lt;/code&gt; の糸くずを）。</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">すでにお探しのものの名前がわかっている場合は、ページ上部の検索バーを利用するのが一番手っ取り早いです。</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">独自のスマートポインター型を定義していて、&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST強制システム&lt;/a&gt;を使用してサイズ付き型からサイズなし型への変換を有効にする&lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt;代わりにCoerceUnsizedを使用してください。</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">タイプを考えるのが得意であれば、 &lt;code&gt;map()&lt;/code&gt; を次のように考えることができます。あるタイプ &lt;code&gt;A&lt;/code&gt; のエレメントを提供するイテレーターがあり、他のタイプ &lt;code&gt;B&lt;/code&gt; のイテレーターが必要な場合は、 &lt;code&gt;map()&lt;/code&gt; を使用できます。、 &lt;code&gt;A&lt;/code&gt; を受け取り、 &lt;code&gt;B&lt;/code&gt; を返すクロージャーを渡します。</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">バイトスライスが有効なUTF-8であることが確実で、変換のオーバーヘッドを発生させたくない場合は、この関数の安全ではないバージョン&lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;があります。これは同じ動作をしますが、チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">バイトスライスが有効なUTF-8であることを確認し、有効性チェックのオーバーヘッドを発生させたくない場合は、この関数の安全でないバージョン&lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;があります。これは同じ動作をしますが、チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">バイトスライスが有効なUTF-8であることを確認し、有効性チェックのオーバーヘッドを発生させたくない場合は、この関数の安全でないバージョン&lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;があります。これは同じ動作をしますが、チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">ポインターがnullになり得ないことが確実で、 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ではなく &lt;code&gt;&amp;amp;T&lt;/code&gt; を返す何らかの &lt;code&gt;as_ref_unchecked&lt;/code&gt; を探している場合は、ポインターを直接逆参照できることを確認してください。</target>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">短縮フィールドパターンを使用しているが、構造体フィールドを別の名前で参照したい場合は、明示的に名前を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">既存のファイルフォーマットを処理するプログラムを書いている場合は、この関数を使用する前に、そのフォーマットの空白の定義を確認してください。</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">パーミッションエラーなどでファイルを含むディレクトリにアクセスできない場合、 &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 戦略を使用できない場合は、型がメソッドを持たない &lt;code&gt;Eq&lt;/code&gt; を実装することを指定します。</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">ライフタイム &lt;code&gt;'a&lt;/code&gt; （ &lt;code&gt;&amp;amp;T&lt;/code&gt; または &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 参照）を使用して、安全なコードからアクセスできる安全な参照を作成した場合（たとえば、それを返したため）、その参照と矛盾する方法でデータにアクセスしてはなりません。 &lt;code&gt;'a&lt;/code&gt; の残りの部分。あなたが取る場合にたとえば、これは手段 &lt;code&gt;*mut T&lt;/code&gt; から &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; し、それをキャスト &lt;code&gt;&amp;amp;T&lt;/code&gt; 、その後のデータ &lt;code&gt;T&lt;/code&gt; は不変のままでなければならない（モジュロ任意の &lt;code&gt;UnsafeCell&lt;/code&gt; のデータは、内で見つかった &lt;code&gt;T&lt;/code&gt; もちろん、）その参照の寿命まで期限切れ。同様に、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 安全なコードにリリースされた参照の場合、その参照が期限切れになるまで &lt;code&gt;UnsafeCell&lt;/code&gt; 内のデータにアクセスしてはなりません。</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">変数を作成し、それをどこでも使用しない場合、バグである可能性があるため、Rustは通常警告を発行します。ただし、プロトタイプを作成しているときやプロジェクトを開始するときなど、まだ使用しない変数を作成すると便利な場合があります。この状況では、アンダースコアで変数名を開始することにより、未使用の変数について警告しないようにRustに指示できます。リスト18-20では、2つの未使用の変数を作成していますが、このコードを実行すると、そのうちの1つについてのみ警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">この「少なくとも」動作が必要ない場合は、&lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt;メソッドを参照してください。</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; を呼び出さないと、プログラムはコンパイルされますが、警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">テストを並行して実行したくない場合、または使用するスレッドの数をより細かく制御したい場合は、 &lt;code&gt;--test-threads&lt;/code&gt; フラグと使用するスレッドの数をテストに送信できます。バイナリ。次の例を見てください。</target>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">シグナル性を気にしない(可能性が高い)のであれば、移植性の心配はありません。</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">Rust の基本を知らない場合は、Rust Book を参照してください:https://doc.rust-lang.org/book/。</target>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">名前を修飾しない場合、コードは代わりに「GET」および「POST」という名前の新しい変数をバインドします。この動作はおそらく望んでいるものではないので、それが発生すると &lt;code&gt;rustc&lt;/code&gt; が警告します。</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">このエラーが発生した場合は、入力タイプのすべての可能な値が一致するようにパターンを変更する必要があります。列挙型などのバリアントの数が少ない型の場合は、すべてのケースを明示的にカバーする必要があります。または、アンダースコア &lt;code&gt;_&lt;/code&gt; ワイルドカードパターンを他のすべてのパターンの後に追加して、「その他」に一致させることができます。例：</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">このエラーが発生した場合、あなたはおそらく使用する必要が &lt;code&gt;match&lt;/code&gt; または &lt;code&gt;if let&lt;/code&gt; 故障の可能性に対処します。例：</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">CまたはC ++のバックグラウンドがある場合、これは &lt;code&gt;gcc&lt;/code&gt; または &lt;code&gt;clang&lt;/code&gt; に似ていることに気付くでしょう。正常にコンパイルされた後、Rustはバイナリ実行可能ファイルを出力します。</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;のリストがある場合、 &lt;code&gt;collect()&lt;/code&gt; を使用して、それらのいずれかが失敗したかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; への参照がある場合、Rustでは通常、 &lt;code&gt;SomeStruct&lt;/code&gt; のすべてのフィールドが不変です。コンパイラーは、 &lt;code&gt;&amp;amp;T&lt;/code&gt; が別名でエイリアスまたは変更されておらず、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; が一意であるという知識に基づいて最適化を行います。 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; は、この制限を回避する唯一のコア言語機能です。 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; や &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; など、内部の &lt;code&gt;UnsafeCell&lt;/code&gt; を許可する他のすべての型は、UnsafeCellを使用して内部データをラップします。</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">プログラムに、 &lt;code&gt;match&lt;/code&gt; を使用して表現するには冗長すぎるロジックがある状況がある &lt;code&gt;if let&lt;/code&gt; は、letがRustツールボックスにも含まれていることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">UTF-8バイトのベクターがある場合は、&lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;メソッドを使用してそのベクターから &lt;code&gt;String&lt;/code&gt; を作成できます。</target>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">有効なUTF-8バイトのベクトルがある場合、それから&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;を作成できます。あなたも逆を行うことができます。</target>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">コンテナの所有権がある場合は、代わりに&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">値の所有権がある場合は、代わりに&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;を実装するものがある場合は、&lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; 型&lt;/a&gt;を使用してそれを &lt;code&gt;BufRead&lt;/code&gt; に変換できます。</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">変更を加えずにすぐに &lt;code&gt;cargo build&lt;/code&gt; 再度実行すると、 &lt;code&gt;Finished&lt;/code&gt; 行以外の出力は得られません。Cargoは、依存関係が既にダウンロードおよびコンパイルされていることを認識しており、&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルでそれらについて何も変更していません。Cargoは、コードについて何も変更していないことも認識しているため、再コンパイルもしません。何もすることなく、単に終了します。</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; ではなく&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;が必要な場合は、&lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt;検討してください。</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">あなたが必要な場合 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; スライス&lt;em&gt;で&lt;/em&gt; NULターミネータは、使用することができます&lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;代わりに。</target>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; ではなく &lt;code&gt;String&lt;/code&gt; が必要な場合は、&lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt;検討してください。</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 値の破棄よりも&lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OccupiedEntry&lt;/code&gt; への参照が必要な場合は、into_mutを参照してください。</target>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 値の破棄よりも&lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;な &lt;code&gt;OccupiedEntry&lt;/code&gt; への参照が必要な場合は、into_mutを参照してください。</target>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">値のハッシュ方法をさらに制御する必要がある場合は、もちろん自分で &lt;code&gt;Hash&lt;/code&gt; トレイトを実装できます。</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">値のハッシュ方法をさらに制御する必要がある場合は、&lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;トレイトを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OccupiedEntry&lt;/code&gt; への複数の参照が必要な場合は、&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">この機能が必要な場合は、必ず毎晩リリースされるコンパイラを使うようにしてください(ただし、将来的にこの機能が削除されたり変更されたりする可能性があるので注意してください)。</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">これが必要な場合は、何か間違ったことをしている可能性が高いです。Rust は、異なる構造体のレイアウトについてはあまり保証していないことを覚えておいてください (同じ宣言を持つ 2 つの構造体であっても、異なるレイアウトを持つ可能性があります)。もし transmute を完全に回避する方法があるならば、それを試してみてください。</target>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">&lt;em&gt;多くの&lt;/em&gt;ストリームの長さを取得する必要があり、後でシーク位置を気にしない場合は、単純に &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; を呼び出し、その戻り値（それを使用する）によってシーク操作の数を減らすことができます。はストリームの長さでもあります）。</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">個々のUnicodeスカラー値に対して操作を実行する必要がある場合、そのための最善の方法は、 &lt;code&gt;chars&lt;/code&gt; メソッドを使用することです。「नमस्ते」で &lt;code&gt;chars&lt;/code&gt; を呼び出すと、 &lt;code&gt;char&lt;/code&gt; 型の6つの値が分離されて返されます。結果を繰り返し処理して、各要素にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">名前空間だけをインポートしたい場合は、直接インポートしてください。</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">&lt;em&gt;src / main.rs&lt;/em&gt;ファイルを開いて、ささいな変更を加えてから、保存して再度ビルドすると、2行の出力しか表示されません。</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">ご希望であれば、スクリプトをダウンロードして、実行する前に検査してみてください。</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">ワークスペース内のクレートを&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;に公開する場合、ワークスペース内の各クレートを個別に公開する必要があります。 &lt;code&gt;cargo publish&lt;/code&gt; コマンドはありません &lt;code&gt;--all&lt;/code&gt; フラグまたは &lt;code&gt;-p&lt;/code&gt; あなたは、各クレートのディレクトリと実行に変更しなければならないので、フラグを &lt;code&gt;cargo publish&lt;/code&gt; 箱を公開するために、ワークスペース内の各クレートに。</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">本当にグローバルな変更可能な状態が必要な場合は、 &lt;code&gt;static mut&lt;/code&gt; またはグローバルな &lt;code&gt;UnsafeCell&lt;/code&gt; を使用してみてください。</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">このコードを実行してメインスレッドからの出力のみが表示される場合、またはオーバーラップが表示されない場合は、範囲内の数値を増やして、オペレーティングシステムがスレッドを切り替える機会を増やしてください。</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">バージョン番号が表示されている場合は、それを持っています！ &lt;code&gt;command not found&lt;/code&gt; などのエラーが発生した場合は、インストール方法のドキュメントを参照して、Cargoを個別にインストールする方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">この情報が表示されれば、Rustは正常にインストールされています。この情報が表示されず、Windowsを使用している場合は、Rustが &lt;code&gt;%PATH%&lt;/code&gt; システム変数にあることを確認してください。それでも問題がなく、Rustがまだ機能しない場合は、サポートを受けることができる場所がいくつかあります。最も簡単なのは、&lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;公式のRust Discordの&lt;/a&gt; #beginnersチャンネルです。そこでは、あなたを助けることができる他のRustaceans（私たち自身と呼ぶばかげたニックネーム）とチャットすることができます。その他の優れたリソースには&lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;、ユーザーフォーラム&lt;/a&gt;や&lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;スタックオーバーフローがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Hello、world！で行ったように、Cargoを使用しないプロジェクトを開始した場合。プロジェクトでは、Cargoを使用するプロジェクトに変換できます。プロジェクトコードを&lt;em&gt;src&lt;/em&gt;ディレクトリに移動し、適切な&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">このコードをコンパイルしようとすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; データを含む構造体または列挙型に &lt;code&gt;Copy&lt;/code&gt; を実装しようとすると、エラー&lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">最後の &lt;code&gt;println!&lt;/code&gt; コメントを外した場合！そして、プログラムを実行し、錆がでこのサイクルを印刷しようとするポインティング &lt;code&gt;b&lt;/code&gt; を指し、それがスタックをオーバーフローするまで、などと。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 属性によって提供される動作とは異なる動作が必要な場合は、各特性の&lt;a href=&quot;../std/index&quot;&gt;標準ライブラリのドキュメント&lt;/a&gt;を参照して、それらを手動で実装する方法の詳細を確認してください。</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">他のユーザーがモジュールからバリアントを直接インポートできるようにするには、 &lt;code&gt;pub use&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">このフィールドにアクセスするには、2つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">値を適切に破棄したい場合は、そのデストラクタを実行して、&lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">クロージャーが環境で使用する値の所有権を取得するように強制したい場合は、パラメーターリストの前に &lt;code&gt;move&lt;/code&gt; キーワードを使用できます。この手法は、クロージャーを新しいスレッドに渡してデータを移動し、新しいスレッドが所有するようにする場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">コマンドライン引数を取得したい場合は、 &lt;code&gt;std::env::args&lt;/code&gt; 。指定した終了コードで終了するには、 &lt;code&gt;std::process::exit&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">最初の &lt;code&gt;String&lt;/code&gt; を使い続ける場合は、それを複製して、代わりにその複製に追加できます。</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">メモリをリークしたい場合は、&lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; と照合する場合は、代わりにガードを使用することを検討してください：</target>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">メモリへの生のポインタを取得したい場合は、&lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">最大値を1ステップで取得したい場合は</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">最小値を1ステップで取得したい場合は</target>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">特定のオプションを上書きしても他のデフォルトを保持したい場合。</target>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">SPDXに表示されないライセンスを使用する場合は、そのライセンスのテキストをファイルに配置し、そのファイルをプロジェクトに含めてから、 &lt;code&gt;license-file&lt;/code&gt; を使用してそのファイルの名前を指定する必要があります &lt;code&gt;license&lt;/code&gt; キーを使用する。</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">メソッドを使用する場合は、メソッドの後に &lt;code&gt;()&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; バージョン &lt;code&gt;0.4.0&lt;/code&gt; または &lt;code&gt;0.4.x&lt;/code&gt; シリーズのいずれかのバージョンを使用したい場合は、代わりに&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルを次のように更新する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">この属性を実装内のすべてのメソッドに適用する場合は、各メソッドに手動で注釈を付けます。実装全体に &lt;code&gt;#[inline]&lt;/code&gt; 属性で注釈を付けることはできません。</target>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">Rustの所有権について詳しく知りたい場合は、この本の章から始めてください。</target>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">エクスポートされたすべてのマクロをインポートする場合は、引数なしで &lt;code&gt;macro_use&lt;/code&gt; を記述します。</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">Ruby、Python、JavaScriptなどの動的言語に精通している場合は、プログラムを個別のステップとしてコンパイルおよび実行することに慣れていない可能性があります。Rustは&lt;em&gt;事前にコンパイルされた&lt;/em&gt;言語です。つまり、プログラムをコンパイルして実行可能ファイルを他の人に渡すことができ、Rustがインストールされていなくても実行できます。誰かに&lt;em&gt;.rb&lt;/em&gt;、&lt;em&gt;.py&lt;/em&gt;、または&lt;em&gt;.js&lt;/em&gt;ファイルを与える場合、それらは（それぞれ）Ruby、Python、またはJavaScript実装をインストールする必要があります。しかし、これらの言語では、プログラムをコンパイルして実行するために必要なコマンドは1つだけです。すべては言語設計のトレードオフです。</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">課題がある場合は、リスト20-15のコードを見る前に、これらの変更を自分で実装してみてください。</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">LinuxまたはmacOSを使用している場合は、ターミナルを開いて次のコマンドを入力します。</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">PowerShellを使用している場合は、環境変数を設定し、1つではなく2つのコマンドでプログラムを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">Rustのベータ版または安定版リリースを使用している場合は、機能フラグを使用できません。これは、新しい機能を永遠に安定であると宣言する前に、実際に使用できるようにするための鍵です。最先端をオプトインしたい人はそうすることができ、堅実な体験をしたい人は安定版にこだわり、コードが壊れないことを知っています。停滞のない安定性。</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">あるファイルの内容を別のファイルにコピーする必要があり、&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; を&lt;/a&gt;使用している場合は、&lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt;関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">あるファイルの内容を別のファイルにコピーする必要があり、ファイルシステムパスを操作している場合は、&lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt;関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">他の言語で&lt;em&gt;浅いコピー&lt;/em&gt;と&lt;em&gt;深いコピー&lt;/em&gt;という用語を聞いた場合、データをコピーせずにポインター、長さ、および容量をコピーするという概念は、おそらく浅いコピーを作成するように聞こえます。しかし、Rustは最初の変数も無効にするため、シャローコピーと呼ばれるのではなく、&lt;em&gt;moveと&lt;/em&gt;呼ばれます。この例では、 &lt;code&gt;s1&lt;/code&gt; が &lt;code&gt;s2&lt;/code&gt; に&lt;em&gt;移動&lt;/em&gt;されたと言えます。したがって、実際に何が起こるかを図4-4に示します。</target>
        </trans-unit>
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">コレクションを作成している場合、そのために&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;を実装すると、コレクションを &lt;code&gt;for&lt;/code&gt; ループで使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">あなたは副作用のいくつかの並べ替えをやっている場合は、好む&lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;に &lt;code&gt;map()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">これと &lt;code&gt;SUCCESS&lt;/code&gt; のみを &lt;code&gt;main&lt;/code&gt; から返す場合は、代わりにそれぞれ &lt;code&gt;Err(_)&lt;/code&gt; と &lt;code&gt;Ok(())&lt;/code&gt; を返すことを &lt;code&gt;eprintln!&lt;/code&gt; てください。これらは同じコードを返します（ただし、eprintln！エラーも返されます）。</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">あなたは必ずリントチェックを無効にしたい場合は、あなたが変更することができます &lt;code&gt;forbid&lt;/code&gt; する &lt;code&gt;deny&lt;/code&gt; （または使用 &lt;code&gt;-D&lt;/code&gt; の代わりに、 &lt;code&gt;-F&lt;/code&gt; 場合 &lt;code&gt;forbid&lt;/code&gt; 設定はコマンドラインオプションとして与えられた）内側のリントチェック属性を許可します：</target>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">夜間版のrustcを使っているのであれば、対応する機能を追加するだけで使えるようになります。</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">安定版やベータ版の rustc を使っている場合、不安定な機能は使えません。そのためには、夜間版の rustc に切り替えてください (rustup を使って)。</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; を&lt;/a&gt;作成している場合は、 &lt;code&gt;for&lt;/code&gt; ループで使用できます。</target>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">ある種のコレクションを持っていて、そのコレクションの要素に対して操作を行う必要がある場合、すぐに'イテレータ'に遭遇するでしょう。イテレータは慣用的な Rust コードで頻繁に使用されているので、それらに慣れることは価値があります。</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">構造体が実際に &lt;code&gt;T&lt;/code&gt; 型のデータを&lt;em&gt;所有&lt;/em&gt;していない場合は、 &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; （理想的には）または &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; （存続期間が適用されない場合）などの参照型を使用することをお勧めします。所有権を示すものではありません。</target>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">タイプが &lt;code&gt;Ord&lt;/code&gt; の場合、 &lt;code&gt;cmp()&lt;/code&gt; を使用して &lt;code&gt;partial_cmp()&lt;/code&gt; を実装できます。</target>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">タイプが固定を使用している場合（上記の2つの例など）、 &lt;code&gt;Drop&lt;/code&gt; を実装するときは注意が必要です。 &lt;code&gt;drop&lt;/code&gt; 機能は取り &lt;code&gt;&amp;amp;mut self&lt;/code&gt; が、これはと呼ばれる&lt;em&gt;あなたのタイプが以前に固定された場合でも&lt;/em&gt;！コンパイラーが自動的に &lt;code&gt;get_unchecked_mut&lt;/code&gt; を呼び出したかのようです。</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">代わりに、クロージャーが &lt;code&gt;self.vec&lt;/code&gt; を直接使用する場合、変更可能な参照によって &lt;code&gt;self&lt;/code&gt; をキャプチャしようとします。しかし、 &lt;code&gt;self.set&lt;/code&gt; は繰り返しのために既に借用されているため、コードはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 残りのフィールドを無視します。残りのフィールドは任意の値を持つことができ、どの変数にもバインドされていません。</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">ネストされた &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; を持つ値の一部を無視する</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt; で値の残りの部分を無視する</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">特別に要求されない限り、一部のテストを無視する</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">パターン内の値を無視する</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt; で値全体を無視する</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt; で始まる名前を使用して未使用の変数を無視する</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">ファミリールームのテレビとして &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を想像してください。一人がテレビを見るために入るとき、彼らはそれをつけます。他の人が部屋に入ってテレビを見ることもできます。最後の人が部屋を出るとき、テレビはもう使われていないので、テレビの電源を切ります。誰かがまだテレビを見ているときに誰かがテレビの電源を切ると、残りのテレビ視聴者から大騒ぎになるでしょう！</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">不変のrawエントリの用途は非常に限られています。代わりに &lt;code&gt;raw_entry_mut&lt;/code&gt; が必要な場合があります。</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">不変スライスイテレータ</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">不変に所有価値から借りています。</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">不変に所有価値から借用します。&lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">不変に所有価値から借用します。&lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">不変に所有価値から借用します。&lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">不変に所有価値から借用します。&lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">不変に所有価値から借用します。&lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">包含された値を確実に借用し、値が現在変異的に借用されている場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">包含された値をそのまま拝借します。</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">impl ブロックは、ライフタイムパラメータを個別に宣言します。独自のライフタイムパラメータを持つ型を実装している場合は、impl ブロックにライフタイムパラメータを追加する必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">インプル形質</target>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">安全ではない形質を実装する</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">型に何らかの機能を実装します。</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">&lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt;トレイトを実装して、可変から可変への変換を簡単に行う</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">安価な参照から参照への変換のために&lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt;トレイトを実装する</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">値から値への変換を行うための&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;トレイトを実装する</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">現在のクレート外の型への値から値への変換を行うための&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;トレイトを実装する</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">タイプに &lt;code&gt;Copy&lt;/code&gt; トレイトを実装します。</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">論理的にimmutableなメソッドの実装内容</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">論理的にimmutableなメソッドの実装詳細。</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">実施上の注意事項</target>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">実装では、パニックや異常終了ではなく、メモリ不足時に &lt;code&gt;Err&lt;/code&gt; を返すことが推奨されますが、これは厳密な要件ではありません。（具体的には、メモリ不足が原因で中止される、基になるネイティブアロケーションライブラリの上にこのトレイトを実装することは&lt;em&gt;合法&lt;/em&gt;です。）</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">実装では、メモリを使い果たしたときにアボートするのではなくnullを返すことをお勧めしますが、これは厳密な要件ではありません。（具体的には、メモリ不足が原因で中止される、基になるネイティブアロケーションライブラリの上にこのトレイトを実装することは&lt;em&gt;合法&lt;/em&gt;です。）</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">実装では、パニックや異常終了ではなく、メモリ不足のときにnullを返すことをお勧めしますが、これは厳密な要件ではありません。（具体的には、メモリ不足が原因で中止される、基になるネイティブアロケーションライブラリの上にこのトレイトを実装することは&lt;em&gt;合法&lt;/em&gt;です。）</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">実装では、 &lt;code&gt;impl&lt;/code&gt; キーワードの前に外部&lt;a href=&quot;../attributes&quot;&gt;属性を&lt;/a&gt;、関連する項目を含む括弧内に内部&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;を含めることができます。内部属性は、関連するアイテムの前に置く必要があります。ここで意味を持つ属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 、 &lt;code&gt;PartialOrd&lt;/code&gt; 、および &lt;code&gt;Ord&lt;/code&gt; の実装は互いに同意する&lt;em&gt;必要があり&lt;/em&gt;ます。いくつかの特性を導出し、手動で他の特性を実装することにより、誤ってそれらを不一致にするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 、 &lt;code&gt;PartialOrd&lt;/code&gt; 、および &lt;code&gt;Ord&lt;/code&gt; の実装は互いに同意する&lt;em&gt;必要があり&lt;/em&gt;ます。つまり、 &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; 場合にのみ &lt;code&gt;a == b&lt;/code&gt; および &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; すべてのため &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; 。いくつかの特性を導出し、手動で他の特性を実装することにより、誤ってそれらを不一致にするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">オペレーターの特性の実装は、通常の意味と&lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;オペレーターの優先順位を&lt;/a&gt;念頭に置いて、それぞれのコンテキストで当然のことです。たとえば、&lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; を&lt;/a&gt;実装する場合、演算は乗算に類似している必要があります（関連性などの期待されるプロパティを共有します）。</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">特定の長さまでの固定長配列に対する &lt;code&gt;Eq&lt;/code&gt; のようなものの実装。最終的には、あらゆる長さに一般化できるはずです。</target>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">外国型への実装</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">&lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; と &lt;code&gt;Sync&lt;/code&gt; 手動で実装することは安全ではありません</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">ジェネリックで &lt;code&gt;Add&lt;/code&gt; を実装する</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">タイプに &lt;code&gt;Binary&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">スマートポインターに &lt;code&gt;Deref&lt;/code&gt; を実装すると、背後のデータに簡単にアクセスできるようになります。そのため、 &lt;code&gt;Deref&lt;/code&gt; を実装しています。一方、に関する規則 &lt;code&gt;Deref&lt;/code&gt; と&lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; は、&lt;/a&gt;スマートポインタに対応するために特別に設計されました。このため、混乱を避けるために&lt;strong&gt;、スマートポインターに対してのみ&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; を実装する必要があります&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">スマートポインターに &lt;code&gt;DerefMut&lt;/code&gt; を実装すると、背後のデータを簡単に変更できるようになるため、 &lt;code&gt;DerefMut&lt;/code&gt; を実装します。一方、に関する規則&lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;DerefMut&lt;/code&gt; は、スマートポインタに対応するために特別に設計されました。このため、混乱を避けるために&lt;strong&gt;、スマートポインターに対してのみ&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; を実装する必要があります&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">タイプに &lt;code&gt;Display&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Drop&lt;/code&gt; 実装</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Extend&lt;/code&gt; の実装：</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">あなたのタイプに &lt;code&gt;FromIterator&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 実装</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">外部型への変換のための &lt;code&gt;Into&lt;/code&gt; の実装</target>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">タイプに &lt;code&gt;IntoIterator&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">タイプに &lt;code&gt;LowerExp&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">型に &lt;code&gt;LowerHex&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">タイプに &lt;code&gt;Octal&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">タイプに &lt;code&gt;Pointer&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">ジェネリックで &lt;code&gt;Sub&lt;/code&gt; を実装する</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TryInto&lt;/code&gt; の実装</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">タイプに &lt;code&gt;UpperExp&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">型に &lt;code&gt;UpperHex&lt;/code&gt; を実装する：</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;split_at_mut&lt;/code&gt; の実装：</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">イテレータの実装</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">トランスフォーメーションとしてのトランジションをさまざまなタイプに実装する</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">型への形質の実装</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">型に特性を実装することは、通常のメソッドを実装することに似ています。違いは、 &lt;code&gt;impl&lt;/code&gt; の後に、実装する特性名を入力し、 &lt;code&gt;for&lt;/code&gt; キーワードを使用して、特性を実装する型の名前を指定することです。 &lt;code&gt;impl&lt;/code&gt; ブロック内に、特性定義で定義されたメソッドシグネチャを配置します。各シグネチャの後にセミコロンを追加する代わりに、中かっこを使用して、特定の型に対して特性のメソッドに必要な特定の動作をメソッド本体に入力します。</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;安全でない特性の&lt;/a&gt;実装。</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">オブジェクト指向設計パターンの実装</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">安全でない特性の実装</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; に &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; トレイトを実装する</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">&lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; メソッドの実装</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">&lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; 関数の実装</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">実装 &lt;code&gt;Deref&lt;/code&gt; トレイトは、あなたがの振る舞いをカスタマイズすることを可能にする&lt;em&gt;間接参照演算子を&lt;/em&gt;、 &lt;code&gt;*&lt;/code&gt; （乗算またはグロブ演算子ではなく）。スマートポインターを通常の参照のように扱うことができるように &lt;code&gt;Deref&lt;/code&gt; を実装することで、参照を操作するコードを記述し、そのコードをスマートポインターでも使用できます。</target>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">Traitの実装</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">これらの特徴を実装することで、特定の演算子に負荷をかけることができます。</target>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この特性を実装すると、型を固定する制限が解除され、&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;などの関数で型を移動できるようになります。</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; トレイトの実装者は「リーダー」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">&lt;code&gt;Write&lt;/code&gt; トレイトの実装者は、「ライター」と呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;を実装します。</target>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">辞書的にベクトルの比較を実装しています。</target>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">語彙的にベクトルの比較を実装しています.</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">文字列に対する比較演算を実装します。</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">文字列の順序付けを実装します。</target>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">ベクトルの順序付けを辞書的に実装します.</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; または &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; 部分文字列スライスを実装します。</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; または &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; 部分文字列スライスを実装します。</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; または &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; 部分文字列スライスを実装します。</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; または &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; 部分文字列スライスを実装します。</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; または &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; 部分文字列スライスを実装します。</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; または &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; 部分文字列スライスを実装します。</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">2つの文字列を連結する &lt;code&gt;+&lt;/code&gt; 演算子を実装します。</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; に追加する &lt;code&gt;+=&lt;/code&gt; 演算子を実装します。</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">暗黙のボロー</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">関数と方法を用いた暗黙のデレフ強制</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">暗黙の借用は、以下の式で取ることができます。</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">暗黙のうちに可能にする</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">他のクレートやモジュールからアイテムをインポートしたり、名前を変更したりすることができます。</target>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">インポート（ &lt;code&gt;use&lt;/code&gt; ステートメント）は、変数宣言や式ステートメントなどの非アイテムステートメントの後には許可されません。</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">スレッドプールでサーバーのスループットを向上させます。</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">I/Oプロジェクトの改善</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">スレッドプールによるスループットの向上</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">エラーメッセージの改善</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">&lt;code&gt;ThreadPool::new&lt;/code&gt; 、使用 &lt;code&gt;for&lt;/code&gt; 生成するために、ループカウンタを &lt;code&gt;id&lt;/code&gt; 、新たに作成する &lt;code&gt;Worker&lt;/code&gt; それと &lt;code&gt;id&lt;/code&gt; 、およびベクター中の労働者を保存します。</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">&lt;code&gt;ThreadPool::new&lt;/code&gt; 、私たちは新しいチャネルを作成し、プールホールドに送信側を持っています。これは正常にコンパイルされますが、警告は残ります。</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">&lt;code&gt;ThreadPool::new&lt;/code&gt; 、私たちは、チャネルの受信側に置く &lt;code&gt;Arc&lt;/code&gt; と &lt;code&gt;Mutex&lt;/code&gt; 。新しいワーカーごとに、 &lt;code&gt;Arc&lt;/code&gt; を複製して参照カウントを増やし、ワーカーが受信側の所有権を共有できるようにします。</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">では &lt;code&gt;main&lt;/code&gt; 、我々は呼んで &lt;code&gt;Dog::baby_name&lt;/code&gt; 上に定義され、関連する関数を呼び出す機能、 &lt;code&gt;Dog&lt;/code&gt; を直接。このコードは以下を出力します：</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">では &lt;code&gt;main&lt;/code&gt; 、我々は2つのインスタンスを作成 &lt;code&gt;CustomSmartPointer&lt;/code&gt; をしてから印刷し &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; 。 &lt;code&gt;main&lt;/code&gt; の最後で、 &lt;code&gt;CustomSmartPointer&lt;/code&gt; のインスタンスがスコープ外になり、Rustが &lt;code&gt;drop&lt;/code&gt; メソッドに配置したコードを呼び出して、最終的なメッセージを出力します。 &lt;code&gt;drop&lt;/code&gt; メソッドを明示的に呼び出す必要がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">では &lt;code&gt;main&lt;/code&gt; 、我々は新しいステートメントを追加しました： &lt;code&gt;fs::read_to_string&lt;/code&gt; かかる &lt;code&gt;filename&lt;/code&gt; 、そのファイルをオープンし、返し &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; ファイルの内容を。</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 、我々が定義した &lt;code&gt;Point&lt;/code&gt; 有する &lt;code&gt;i32&lt;/code&gt; のため &lt;code&gt;x&lt;/code&gt; （値 &lt;code&gt;5&lt;/code&gt; ）と &lt;code&gt;f64&lt;/code&gt; のために &lt;code&gt;y&lt;/code&gt; （値 &lt;code&gt;10.4&lt;/code&gt; ）。 &lt;code&gt;p2&lt;/code&gt; 変数である &lt;code&gt;Point&lt;/code&gt; の文字列スライス有する構造体 &lt;code&gt;x&lt;/code&gt; （値が &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ）及び &lt;code&gt;char&lt;/code&gt; 用の &lt;code&gt;y&lt;/code&gt; （値と &lt;code&gt;c&lt;/code&gt; ）。引数 &lt;code&gt;p2&lt;/code&gt; を指定して &lt;code&gt;p1&lt;/code&gt; で &lt;code&gt;mixup&lt;/code&gt; を呼び出すと、 &lt;code&gt;x&lt;/code&gt; に &lt;code&gt;i32&lt;/code&gt; を持つ &lt;code&gt;p3&lt;/code&gt; が得られます。、なぜなら &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;p1&lt;/code&gt; から来たからです。 &lt;code&gt;p3&lt;/code&gt; 変数があります &lt;code&gt;char&lt;/code&gt; のために &lt;code&gt;y&lt;/code&gt; とするので、 &lt;code&gt;y&lt;/code&gt; はから来た &lt;code&gt;p2&lt;/code&gt; 。 &lt;code&gt;println!&lt;/code&gt; マクロ呼び出しは &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">で &lt;code&gt;match&lt;/code&gt; 式を、あなたが使用して複数のパターンを一致させることができます &lt;code&gt;|&lt;/code&gt; 構文、&lt;em&gt;または&lt;/em&gt;を意味します。たとえば、次のコードは &lt;code&gt;x&lt;/code&gt; の値をマッチアームと照合します。最初のアームは&lt;em&gt;or&lt;/em&gt;オプションを持っています。つまり、 &lt;code&gt;x&lt;/code&gt; の値がそのアームの値のいずれかに一致する場合、そのアームのコードが実行されます。</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">CおよびC ++では、メソッドの呼び出しに2つの異なる演算子が使用されます &lt;code&gt;.&lt;/code&gt; オブジェクトのメソッドを直接呼び出している場合 &lt;code&gt;-&amp;gt;&lt;/code&gt; オブジェクトへのポインターのメソッドを呼び出していて、最初にポインターを逆参照する必要がある場合 つまり、 &lt;code&gt;object&lt;/code&gt; がポインタの場合、 &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; は &lt;code&gt;(*object).something()&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">第1章では、 &lt;code&gt;cargo new&lt;/code&gt; がエディションに関する&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルに少しメタデータを追加することを確認し&lt;em&gt;ました&lt;/em&gt;。この付録では、その意味について説明します。</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">第10章の&lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;「型に特性を実装する」&lt;/a&gt;セクションでは、特性または型のいずれかがクレートに対してローカルである限り、型に特性を実装することが許可されることを示す孤立ルールについて説明しました。タプル構造体に新しいタイプを作成することを含む&lt;em&gt;newtype pattern&lt;/em&gt;を使用して、この制限を回避することが可能です。 （タプル構造体については、第5章の&lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;「名前付きフィールドなしの&lt;/a&gt;タプル構造体を使用して異なる型を作成する」セクションで説明しました。）タプル構造体は1つのフィールドを持ち、特性を実装する型の薄いラッパーになります。その後、ラッパータイプはクレートに対してローカルであり、ラッパーに特性を実装できます。&lt;em&gt;新しいタイプ&lt;/em&gt;Haskellプログラミング言語に由来する用語です。このパターンを使用してもランタイムパフォーマンスが低下することはなく、ラッパータイプはコンパイル時に省略されます。</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">第10章では、構造体に参照を格納できるようにこれらのエラーを修正する方法について説明しますが、ここでは、 &lt;code&gt;&amp;amp;str&lt;/code&gt; などの参照ではなく、 &lt;code&gt;String&lt;/code&gt; などの所有型を使用してこれらのエラーを修正します。</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">第12章では、バイナリクレートとライブラリクレートを含むパッケージを作成しました。プロジェクトが発展するにつれて、ライブラリクレートが大きくなり続け、パッケージをさらに複数のライブラリクレートに分割したい場合があります。この状況で、Cargoは&lt;em&gt;ワークスペース&lt;/em&gt;と呼ばれる機能を提供します。これは、タンデムで開発された複数の関連パッケージの管理に役立ちます。</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">第13章では、クロージャーのパラメーターリストの前に &lt;code&gt;move&lt;/code&gt; キーワードを使用して、クロージャーが環境で使用する値の所有権を取得するように強制できることを説明しました。この手法は、あるスレッドから別のスレッドに値の所有権を転送するために新しいスレッドを作成するときに特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">第15章では、スマートポインター &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を使用して値に複数の所有者を指定し、参照カウント値を作成しました。ここでも同じようにして、何が起こるか見てみましょう。リスト16-14 の &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; を &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; でラップし、所有権をスレッドに移動する前に &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を複製します。エラーが表示されたので、 &lt;code&gt;for&lt;/code&gt; ループの使用に戻り、クロージャーを使用して &lt;code&gt;move&lt;/code&gt; キーワードを保持します。</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">第16章では、並行プログラミングのさまざまなモデルについて説明し、Rustを使用して複数のスレッドで大胆にプログラミングする方法について説明します。第17章では、Rustのイディオムと、使い慣れたオブジェクト指向プログラミングの原則との比較について説明します。</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">第16章では、この使用例に最適な&lt;em&gt;チャネル（&lt;/em&gt; 2つのスレッド間で通信する簡単な方法）について学びました。チャネルを使用してジョブのキューとして機能し、 &lt;code&gt;execute&lt;/code&gt; は &lt;code&gt;ThreadPool&lt;/code&gt; から &lt;code&gt;Worker&lt;/code&gt; インスタンスにジョブを送信し、Workerインスタンスはそのジョブをスレッドに送信します。ここに計画があります：</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">第2章では、 &lt;code&gt;rand&lt;/code&gt; という外部パッケージを使用して乱数を取得する推測ゲームプロジェクトをプログラミングしました。プロジェクトで &lt;code&gt;rand&lt;/code&gt; を使用するために、次の行を&lt;em&gt;Cargo.tomlに&lt;/em&gt;追加し&lt;em&gt;ました&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">第20章では、低レベルのマルチスレッドWebサーバーを実装するプロジェクトを完了します。</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">第3章では、Rustコードで &lt;code&gt;for&lt;/code&gt; ループが最も一般的なループ構造であること &lt;code&gt;for&lt;/code&gt; 説明しましたが、forテイクのパターンについてはまだ説明していません。 &lt;code&gt;for&lt;/code&gt; ループ、パターンを直接キーワードを以下の値である &lt;code&gt;for&lt;/code&gt; そうでは、 &lt;code&gt;for x in y&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; はパターンです。</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">第4章の&lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;「ダングリング参照」&lt;/a&gt;セクションで、コンパイラーが参照が常に有効であることを保証することを説明しました。 Unsafe Rustには、参照に類似した&lt;em&gt;rawポインター&lt;/em&gt;と呼ばれる2つの新しい型があります。参照と同様に、生のポインタは不変または可変であり、それぞれ &lt;code&gt;*const T&lt;/code&gt; および &lt;code&gt;*mut T&lt;/code&gt; として記述されます。アスタリスクは間接参照演算子ではありません。タイプ名の一部です。生のポインターのコンテキストでは、&lt;em&gt;不変&lt;/em&gt;とは、ポインターが逆参照された後、ポインターを直接割り当てることができないことを意味します。</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">第5章のリスト5-15では、 &lt;code&gt;Rectangle&lt;/code&gt; 構造体と &lt;code&gt;can_hold&lt;/code&gt; メソッドを使用しました。これらは、ここでリスト11-5で繰り返されています。このコードを&lt;em&gt;src / lib.rs&lt;/em&gt;ファイルに入れて、 &lt;code&gt;assert!&lt;/code&gt; を使用してコードのテストを記述しましょう！大きい。</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">第6章では、主に1つのケースにのみ一致する &lt;code&gt;match&lt;/code&gt; 相当するものを記述するための短い方法として、 &lt;code&gt;if let&lt;/code&gt; 式の使用方法を説明しました。オプションで、 &lt;code&gt;if let&lt;/code&gt; のパターンが一致しない &lt;code&gt;if let&lt;/code&gt; に実行する、対応する &lt;code&gt;else&lt;/code&gt; を含むコードをif letに含めることができます。</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">第7章では、 &lt;code&gt;mod&lt;/code&gt; キーワードを使用してコードをモジュールに編成する方法、 &lt;code&gt;pub&lt;/code&gt; キーワードを使用して項目を公開する方法、および &lt;code&gt;use&lt;/code&gt; キーワードを使用して項目をスコープに入れる方法について説明しました。ただし、クレートを開発しているときに理にかなっている構造は、ユーザーにとってあまり便利ではない場合があります。構造体を複数のレベルを含む階層に編成することもできますが、階層の深いところで定義した型を使用したい人は、その型が存在することを見つけるのに苦労するかもしれません。また、 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; と入力しなければならないことにも悩まされる可能性があります。 &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; &lt;code&gt;use&lt;/code&gt; ではなく。</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">第7章では、Rustのモジュールシステムと、コードとそのパブリックアプリケーションプログラミングインターフェース（API）を整理するためのプライバシールールについて学びます。第8章では、ベクター、文字列、ハッシュマップなど、標準ライブラリが提供するいくつかの一般的なコレクションデータ構造について説明します。第9章では、Rustのエラー処理の哲学とテクニックについて説明します。</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">第8章で、ベクターの1つの制限は、1つのタイプの要素のみを格納できることであると述べました。リスト8-10で回避策を作成し、整数、浮動小数点数、およびテキストを保持するバリアントを持つ &lt;code&gt;SpreadsheetCell&lt;/code&gt; 列挙型を定義しました。これは、各セルにさまざまなタイプのデータを格納し、セルの行を表すベクトルを保持できることを意味しました。これは、コードのコンパイル時にわかっている、互換性のある項目が型の固定セットである場合、完全に優れたソリューションです。</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">列挙定義では</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">関数定義では</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">リスト10-3で、我々は、名前の関数に最大数を見つけコード抽出 &lt;code&gt;largest&lt;/code&gt; 。1つの特定のリストでのみ最大数を見つけることができるリスト10-1のコードとは異なり、このプログラムは2つの異なるリストで最大数を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">リスト11-7では、パラメーターに &lt;code&gt;2&lt;/code&gt; を加算して結果を返す &lt;code&gt;add_two&lt;/code&gt; という名前の関数を記述しています。次に、 &lt;code&gt;assert_eq!&lt;/code&gt; を使用してこの関数をテストします。大きい。</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">リスト12-6で、我々はスライス取ったコードを追加 &lt;code&gt;String&lt;/code&gt; 値をとのインスタンス作成した &lt;code&gt;Config&lt;/code&gt; スライスにインデックスを付けると値をクローニング、可能にすることにより、構造体を &lt;code&gt;Config&lt;/code&gt; 構造体は、それらの値を所有することを。リスト13-24では、リスト12-23と同じように &lt;code&gt;Config::new&lt;/code&gt; 関数の実装を再現しています。</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">リスト12-8では、インデックス1と2にアクセスする前にスライスが十分に長いことを確認するチェックを &lt;code&gt;new&lt;/code&gt; 関数に追加します。スライスが十分に長くない場合、プログラムはパニックになり、より適切なエラーメッセージを表示します。 &lt;code&gt;index out of bounds&lt;/code&gt; メッセージのインデックス。</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">リスト13-18では、ベクターに &lt;code&gt;map&lt;/code&gt; するための呼び出しから返されたイテレーターを反復した結果を収集しています。このベクターには、1ずつ増加した元のベクターの各アイテムが含まれます。</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">リスト13-19では、 &lt;code&gt;Shoe&lt;/code&gt; 構造体インスタンスのコレクションを反復するために、環境から &lt;code&gt;shoe_size&lt;/code&gt; 変数をキャプチャするクロージャーで &lt;code&gt;filter&lt;/code&gt; を使用しています。指定サイズの靴のみ返却します。</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">リスト15-19では、リスト &lt;code&gt;c&lt;/code&gt; の周りに内部スコープを持つように &lt;code&gt;main&lt;/code&gt; を変更します。次に、 &lt;code&gt;c&lt;/code&gt; がスコープ外になったときに参照カウントがどのように変化するかを確認できます。</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">リスト15-26では、リスト15-25の定義を使用する &lt;code&gt;main&lt;/code&gt; 関数を追加しています。このコードは、リスト作成と、リスト &lt;code&gt;b&lt;/code&gt; のリストにそのポイント。次に、 &lt;code&gt;a&lt;/code&gt; のリストを変更して &lt;code&gt;b&lt;/code&gt; を指すようにし、参照サイクルを作成します。 &lt;code&gt;println!&lt;/code&gt; があります！参照カウントがこのプロセスのさまざまな時点で何であるかを示す途中のステートメント。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">リスト16-8では、メインスレッドのチャネルの受信側から値を取得します。これは、川の端にある水からゴム製のアヒルを回収したり、チャットメッセージを受け取ったりするようなものです。</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">リスト18-11では、マッチガードを使用してパターンシャドウイング問題を解決できると述べました。 &lt;code&gt;match&lt;/code&gt; 外の変数を使用する代わりに、 &lt;code&gt;match&lt;/code&gt; 式のパターン内に新しい変数が作成されたことを思い出してください。その新しい変数は、外部変数の値に対してテストできないことを意味しました。リスト18-27は、マッチガードを使用してこの問題を修正する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">リスト7-11では、私たちは持って &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; の範囲にモジュールを &lt;code&gt;eat_at_restaurant&lt;/code&gt; 機能我々は唯一の指定する必要がありますので &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; コールする &lt;code&gt;add_to_waitlist&lt;/code&gt; の中で機能を &lt;code&gt;eat_at_restaurant&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">リスト7-11では、同じ結果を得るために &lt;code&gt;add_to_waitlist&lt;/code&gt; 関数に至るまでの &lt;code&gt;use&lt;/code&gt; パスを指定するのではなく、 &lt;code&gt;eat_at_restaurant&lt;/code&gt; &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; を指定してから、 &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; でhosting :: add_to_waitlistを呼び出した理由に疑問を感じたかもしれません。リスト7-13のように。</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">メソッドの定義では</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">Rust 1.3では、&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156で&lt;/a&gt;説明されているように、デフォルトのオブジェクトライフタイム境界が変更されることが予想されています。コンパイラはこの変更によりコードでコンパイルエラーが発生する可能性があると考えているため、警告が表示されます。可能性は低いですが、これは誤警報である可能性があります。</target>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">Rustでは、関数がパニックに陥ったり、通過的にパニックに陥った関数を呼び出した場合、関数は早期に &quot;戻る &quot;ことができます。このような制御フローは常に予測されているわけではなく、2つの重要なコンポーネントの組み合わせによって微妙なバグを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">Rustでは、&lt;em&gt;リリースプロファイル&lt;/em&gt;は、プログラマがコードをコンパイルするためのさまざまなオプションをより詳細に制御できるようにする、さまざまな構成を持つ事前定義されたカスタマイズ可能なプロファイルです。各プロファイルは、他のプロファイルから独立して構成されます。</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">Rustでは、コメントは2つのスラッシュで始まり、行末まで続く必要があります。1行を超えるコメントの場合、次のように各行に &lt;code&gt;//&lt;/code&gt; を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">Rustでは、グローバル変数は&lt;em&gt;静的&lt;/em&gt;変数と呼ばれます。リスト19-9は宣言の例と値として文字列スライスを持つ静的変数の使用を示しています。</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">Rustでは、統合テストは完全にライブラリの外部にあります。他のコードと同じようにライブラリを使用します。つまり、ライブラリのパブリックAPIの一部である関数のみを呼び出すことができます。それらの目的は、ライブラリの多くの部分が正しく連携するかどうかをテストすることです。単体で正しく機能するコードのユニットは、統合時に問題が発生する可能性があるため、統合されたコードのテストカバレッジも重要です。統合テストを作成するには、最初に&lt;em&gt;テスト&lt;/em&gt;ディレクトリが必要です。</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">Rustでは、さまざまなユースケースに合わせて型のさまざまな表現を提供するのが一般的です。たとえば、値の格納場所と管理は、&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;などのポインター型を介して、特定の用途に応じて適切に選択できます。任意のタイプで使用できるこれらの汎用ラッパーの他に、一部のタイプはオプションのファセットを提供し、潜在的にコストのかかる機能を提供します。そのような型の例は、文字列を拡張する機能を基本的な&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; に&lt;/a&gt;追加する&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;です。これには、単純で不変の文字列には不要な追加情報を保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Rustでは、読み取りアクセスを提供したいだけの場合、ベクトルではなく引数としてスライスを渡す方が一般的です。&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;についても同様です。</target>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">Rustでは、イテレータは&lt;em&gt;レイジーです&lt;/em&gt;。つまり、イテレータを使用するメソッドを呼び出して使い切るまで、イテレータは効果がありません。たとえば、コードリスト13-13のコードは、 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 定義されている &lt;code&gt;iter&lt;/code&gt; メソッドを呼び出すことにより、ベクトル &lt;code&gt;v1&lt;/code&gt; の項目に対してイテレーターを作成します。このコード自体は、何の役にも立ちません。</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Rustでは、いくつかの単純な型が「暗黙的にコピー可能」であり、それらを割り当てるか、引数として渡すと、レシーバーはコピーを取得し、元の値をそのまま残します。これらの型は、コピーに割り当てを必要とせず、ファイナライザを持たない（つまり、所有ボックスが含まれていないか、&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; を&lt;/a&gt;実装していない）ため、コンパイラはそれらを安価で安全にコピーできると見なします。他のタイプの場合は、&lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;トレイトを実装し、&lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことにより、明示的にコピーを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">Rustでは、いくつかの型はコンパイル時に既知のサイズを持っていません。たとえば、 &lt;code&gt;[u32]&lt;/code&gt; のようなスライスタイプでは、要素の数はコンパイル時に分からないため、全体のサイズを計算できません。その結果、そのようなタイプは、参照（例： &lt;code&gt;&amp;amp;T&lt;/code&gt; または &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）または他のポインタータイプ（例： &lt;code&gt;Box&lt;/code&gt; または &lt;code&gt;Rc&lt;/code&gt; ）を介してのみ操作できます。代わりに参照にキャストしてみてください：</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">Rustでは、文字列は常に有効なUTF-8であり、ゼロを含む可能性があります。</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">Rustでは、コンパイラーは、値が変更されないと述べたときに、実際には変更されないことを保証します。つまり、コードを読み書きしているときに、値が変更される方法と場所を追跡する必要はありません。したがって、コードは推論しやすくなります。</target>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">Rustでは、配列に入る値はカンマ区切りのリストとして角括弧の中に書かれます。</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">所有権と借用の概念を使用するRustでは、参照とスマートポインターのもう1つの違いは、参照はデータを借用するだけのポインターであることです。対照的に、多くの場合、スマートポインターはそれらが指すデータを&lt;em&gt;所有&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">Rustでは、コンパイル時にサイズがわかっている場合にのみ値を移動することができます。</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">構造定義では</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">トルコ語では、ラテン語の「i」に相当する形は2つではなく5つです。</target>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">では &lt;code&gt;fn&lt;/code&gt; タイプ、寿命が唯一の戻り値の型ではなく、引数の型に表示されます。</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">特定のプログラムでは、標準ライブラリには、たとえば &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; および &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; によって使用される1つの「グローバル」メモリアロケータがあります。</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">マッチ式では、数値と文字のみが範囲に対してマッチできます。これは、コンパイル時にコンパイラが範囲が空でないことをチェックし、任意の比較関数を評価できないためです。2 つのエンドポイント間の順序可能な型の値をキャプチャしたい場合は、ガードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">パターンでは、 &lt;code&gt;Copy&lt;/code&gt; トレイトを実装しないすべての値を同じ方法でバインドする必要があります。ここでの目的は、by-moveとby-refが同時にバインドされるのを避けることです。</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">パターンでは:包括的な範囲のパターン</target>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;プロトコルと同様に、 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; が &lt;code&gt;next_back()&lt;/code&gt; から &lt;code&gt;None&lt;/code&gt; を返すと、それを再度呼び出すと、 &lt;code&gt;Some&lt;/code&gt; が再び返される場合と返されない場合があります。 &lt;code&gt;next()&lt;/code&gt; と &lt;code&gt;next_back()&lt;/code&gt; は、この目的で交換可能です。</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">ある意味で、プログラミング言語のチャネルは単一の所有権に似ています。値をチャネルに転送すると、その値を使用する必要がなくなるためです。共有メモリの同時実行性は、複数の所有権に似ています。複数のスレッドが同時に同じメモリ位置にアクセスできます。スマートポインターが複数の所有権を可能にした第15章で見たように、複数の所有者は、これらの異なる所有者が管理する必要があるため、複雑さを追加できます。 Rustの型システムと所有権ルールは、この管理を正しく行うのに大きく役立ちます。例として、共有メモリの最も一般的な同時実行プリミティブの1つであるミューテックスを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">不変のコンテキストで（単項） &lt;code&gt;*&lt;/code&gt; 演算子を使用した明示的な逆参照操作に使用されることに加えて、 &lt;code&gt;Deref&lt;/code&gt; は多くの状況でコンパイラーによって暗黙的に使用されます。このメカニズムは&lt;a href=&quot;#more-on-deref-coercion&quot;&gt;「 &lt;code&gt;Deref&lt;/code&gt; 強制」&lt;/a&gt;と呼ばれます。変更可能なコンテキストでは、&lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;が使用されます。</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">&lt;code&gt;DerefMut&lt;/code&gt; は、可変コンテキストで（単項） &lt;code&gt;*&lt;/code&gt; 演算子を使用した明示的な逆参照操作に使用されるだけでなく、多くの状況でコンパイラーによって暗黙的に使用されます。このメカニズムは&lt;a href=&quot;#more-on-deref-coercion&quot;&gt;「&lt;/a&gt; &lt;code&gt;Deref&lt;/code&gt; 強制」と呼ばれます。不変のコンテキストでは、&lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;が使用されます。</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">コードが期待する正しい値を返すことを確認することに加えて、コードが期待どおりにエラー条件を処理することを確認することも重要です。たとえば、第9章のリスト9-10で作成した &lt;code&gt;Guess&lt;/code&gt; タイプを考えてみます。 &lt;code&gt;Guess&lt;/code&gt; を使用するその他のコードは、 &lt;code&gt;Guess&lt;/code&gt; インスタンスに1から100までの値のみが含まれるという保証に依存します。その範囲のパニック外の値で &lt;code&gt;Guess&lt;/code&gt; インスタンスを作成しようとすることを確認するテストを作成できます。</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">パターンマッチングによる分解に加えて、ピリオド（ &lt;code&gt;.&lt;/code&gt; ）に続けてアクセスする値のインデックスを使用することで、タプル要素に直接アクセスできます。例えば：</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">メモリのブロック嵌合に加えて &lt;code&gt;layout&lt;/code&gt; のアラインメント &lt;code&gt;layout&lt;/code&gt; 、メモリのブロックを割り当てるために使用されるアラインメントと一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">グループ化機能に加えて、実装の詳細をカプセル化すると、より高いレベルでコードを再利用できます。操作を実装すると、他のコードは、実装の動作を知らなくても、コードのパブリックインターフェイスを介してそのコードを呼び出すことができます。コードの記述方法は、他のコードで使用できるようにパブリックにする部分と、変更する権利を予約するプライベート実装の詳細にする部分を定義します。これは、頭の中で保持する必要がある詳細の量を制限するもう1つの方法です。</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">関数は、 &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; の形式で固定型を提示するだけでなく、型パラメーターのリストを、それらが含まれる特性境界とともに宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">パブリックおよびプライベートに加えて、Rustを使用すると、ユーザーは特定のスコープ内でアイテムを表示可能として宣言できます。 &lt;code&gt;pub&lt;/code&gt; 制限のルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#implementors&quot;&gt;以下&lt;/a&gt;にリストされているインプリメンターに加えて、以下のタイプも &lt;code&gt;Clone&lt;/code&gt; を実装しています。</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#implementors&quot;&gt;以下に示す実装者に&lt;/a&gt;加えて、次のタイプも &lt;code&gt;Copy&lt;/code&gt; を実装しています。</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">&lt;code&gt;#[cfg]&lt;/code&gt; 属性に加えて、このマクロは、構成フラグのブール式評価を可能にするために提供されています。これにより、コードの重複が少なくなります。</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt;によって返される解析済みの&lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt;情報に加えて、 &lt;code&gt;PrefixComponent&lt;/code&gt; にはas_os_strによって返される未解析および未解析の&lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;スライスも保持され&lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">シグネチャに基づいて変化することに加えて、関数ポインタには、安全と安全でないという2つの種類があります。単純な &lt;code&gt;fn()&lt;/code&gt; 関数ポインターは安全な関数のみを指すことができますが、 &lt;code&gt;unsafe fn()&lt;/code&gt; 関数ポインターは安全な関数または安全でない関数を指すことができます。</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">さらに、 &lt;code&gt;unsafe&lt;/code&gt; は、ブロック内のコードが必ずしも危険であることや、メモリの安全性の問題が確実に発生することを意味しません。プログラマーとして、 &lt;code&gt;unsafe&lt;/code&gt; ブロック内のコードが有効な方法でメモリにアクセスすることを確認します。</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">さらに、&lt;em&gt;任意の&lt;/em&gt;署名、ABI、または安全性の関数ポインターは&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;であり、すべての&lt;em&gt;安全な&lt;/em&gt;関数ポインターは&lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; を&lt;/a&gt;実装します。これらの特性はコンパイラーに特別に知られているため、これは機能します。</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">さらに、これによって暗示される設計上の選択があります。Rustはデータの「深い」コピーを自動的に作成することはありません。したがって、&lt;em&gt;自動&lt;/em&gt;コピーは実行時のパフォーマンスの点で安価であると見なすことができます。</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">さらに、不変の型が内部の値を変更するためのAPIを公開する&lt;em&gt;内部の可変性&lt;/em&gt;パターンについても説明します。&lt;em&gt;参照サイクル&lt;/em&gt;についても説明します。それらはどのようにしてメモリをリークすることができ、どのようにそれらを防ぐことができますか。</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">他のすべての場合（いずれかの場合では &lt;code&gt;setting_value&lt;/code&gt; または &lt;code&gt;new_setting_value&lt;/code&gt; はありません &lt;code&gt;None&lt;/code&gt; で表現） &lt;code&gt;_&lt;/code&gt; 第二のアーム内のパターンは、我々はできるようにしたい &lt;code&gt;new_setting_value&lt;/code&gt; になる &lt;code&gt;setting_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">それ以外の場合、属性は無視されます。</target>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">押し付けがましい二重リンクリストでは、コレクションは実際には要素自体のためにメモリを割り当てません。割り当てはクライアントによって制御され、要素はコレクションよりも短いスタックフレーム上で生活することができます。</target>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">より大きなプログラムでは、ネストされたパスを使用して同じパッケージまたはモジュールから多くの項目をスコープに入れると、必要な個別の &lt;code&gt;use&lt;/code&gt; ステートメントの数を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">これらの例の両方で、「&amp;szlig;」はエンコードに2バイトかかります。</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">これらの例の両方で、「𝕊」は2つの &lt;code&gt;u16&lt;/code&gt; をエンコードに使用します。</target>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">マッチャーとトランスクリ&lt;a href=&quot;macros-by-example#metavariables&quot;&gt;バーの&lt;/a&gt;両方で、 &lt;code&gt;$&lt;/code&gt; トークンはマクロエンジンから特別な動作を呼び出すために使用されます（以下でメタ変数と&lt;a href=&quot;macros-by-example#repetitions&quot;&gt;繰り返し&lt;/a&gt;で説明します）。このような呼び出しの一部ではないトークンは、1つの例外を除いて、照合され、文字どおりに転記されます。例外は、マッチャーの外側の区切り文字が任意の区切り文字のペアと一致することです。したがって、たとえば、マッチャー &lt;code&gt;(())&lt;/code&gt; は &lt;code&gt;{()}&lt;/code&gt; とは一致しますが、 &lt;code&gt;{{}}&lt;/code&gt; とは一致しません。文字 &lt;code&gt;$&lt;/code&gt; は、文字通り一致または転記できません。</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">マッチャーとトランスクリバーの両方で、繰り返しは、繰り返されるトークンを &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; 内に配置することで示され、その後に任意でセパレータートークンを挟んで繰り返し演算子が続きます。区切りトークンには、区切り文字または繰り返し演算子の1つ以外のトークンを使用できますが &lt;code&gt;;&lt;/code&gt; そして &lt;code&gt;,&lt;/code&gt; 最も一般的です。たとえば、 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; は、コンマで区切られた任意の数の識別子を表します。ネストされた繰り返しが許可されています。</target>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; バリアントの場合は、内部エラーを取得します。 &lt;code&gt;try!&lt;/code&gt; 次に、 &lt;code&gt;From&lt;/code&gt; を使用して変換を実行します。これにより、特殊なエラーとより一般的なエラーを自動的に変換できます。結果のエラーはすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">アイテムが &lt;code&gt;impl&lt;/code&gt; 内の関数である場合、プライベートヘルパー関数を定義する方が簡単な場合があります。</target>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">ネストされたモジュールが多い場合、 &lt;code&gt;pub use&lt;/code&gt; して最上位で型を再エクスポートすると、クレートを使用するユーザーのエクスペリエンスに大きな違いが生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">特定のケースでは、Rustにはこの変換を行うための十分な情報がありません。これは&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;強制と呼ばれます。次の例では、文字列スライス&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt;がトレイト &lt;code&gt;TraitExample&lt;/code&gt; を実装し、関数 &lt;code&gt;example_func&lt;/code&gt; はそのトレイトを実装するものをすべて受け取ります。この場合、Rustは2つの暗黙の変換を行う必要がありますが、Rustにはそれを行う手段がありません。そのため、次の例はコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">特定のケースでは、サブバインディングがメモリの安全性を侵害する可能性があります。将来のバージョンのRustの借用チェッカの更新により、この制限がなくなるかもしれませんが、今のところはサブバインディングなしでパターンを書き換えなければなりません。</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">比較すると、&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;はロックを取得するリーダーとライターを区別しないため、ロックが使用可能になるのを待機しているスレッドをブロックします。アン &lt;code&gt;RwLock&lt;/code&gt; ライターがロックを保持していないよう読者の任意の数は限りロックを取得することができます。</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">結論から言うと、取得したいインデックスが本当に存在するかどうかを必ず確認してから実行してください。</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">対照的に、列挙型をパブリックにすると、そのバリアントはすべてパブリックになります。リスト7-10に示すように、 &lt;code&gt;enum&lt;/code&gt; キーワードの前に必要なのは &lt;code&gt;pub&lt;/code&gt; だけです。</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">対照的に、Rustのステートメントは、&lt;em&gt;ほとんど&lt;/em&gt;が式の評価を含み、明示的に順序付けするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">対照的に、リスト19-7 で &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 使用すると、スライスを使用するとクラッシュする可能性があります。このコードは任意のメモリ位置を取り、10,000アイテムのスライスを作成します。</target>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">本質的に、 &lt;code&gt;*const c_void&lt;/code&gt; はCの &lt;code&gt;const void*&lt;/code&gt; と同等で、 &lt;code&gt;*mut c_void&lt;/code&gt; はCの &lt;code&gt;void*&lt;/code&gt; と同等です。これはこれは、言っ&lt;em&gt;ていない&lt;/em&gt; Cさんと同じ &lt;code&gt;void&lt;/code&gt; 錆のある戻り値の型、 &lt;code&gt;()&lt;/code&gt; タイプ。</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">関数シグネチャでは、各パラメーターの型を宣言する&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。これは、Rustの設計における意図的な決定です。関数定義で型注釈を要求するということは、コンパイラーがコードの他の場所でそれらを使用して、意味を理解する必要がほとんどないことを意味します。</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">一般に、 &lt;code&gt;--crate-type=bin&lt;/code&gt; または &lt;code&gt;--crate-type=lib&lt;/code&gt; は、すべてのコンパイルのニーズに十分であり、他のオプションは、クレートの出力形式をより細かく制御する必要がある場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">一般に、C ++の実装はオーバーヘッドのゼロの原則に従います。つまり、使用しないものにはお金はかかりません。さらに、あなたが使用するものは、コードを手渡すことができませんでした。</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">一般に、型の推定を介して実行できるキャストはasを使用し &lt;code&gt;as&lt;/code&gt; 実行することもできるため、 &lt;code&gt;let x: u32 = 123&lt;/code&gt; と書く代わりに、 &lt;code&gt;let x = 123 as u32&lt;/code&gt; 書くことができます（注： &lt;code&gt;let x: u32 = 123&lt;/code&gt; はその状況で最善である）。同じことは他の方向にも当てはまりませんが、明示的に &lt;code&gt;as&lt;/code&gt; を使用すると、生のポインターの型の変更やクロージャーの生のポインターへの変換など、暗黙的に許可されないいくつかの強制が許可されます。</target>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">一般に、この関数はパニックになる可能性があるため、その使用はお勧めしません。代わりに、パターンマッチングを使用して、&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;ケースを明示的に処理することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">一般的に、完全修飾構文は以下のように定義されています。</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">一般に、 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 値を使用するには、各バリアントを処理するコードが必要です。 &lt;code&gt;Some(T)&lt;/code&gt; 値がある場合にのみ実行されるいくつかのコードが必要であり、このコードは内部 &lt;code&gt;T&lt;/code&gt; を使用できます。 &lt;code&gt;None&lt;/code&gt; 値があり、そのコードに利用可能な &lt;code&gt;T&lt;/code&gt; 値がない場合、他のコードを実行する必要があります。 &lt;code&gt;match&lt;/code&gt; 式が列挙と共に使用した場合だけでこれを行う制御フロー構築物である：それが有する列挙型のどの変異体に応じて異なるコードを実行し、そのコードが一致する値内のデータを使用することができます。</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">一般的に、型のサイズはコンパイル間で安定していませんが、プリミティブのような特定の型は安定しています。</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">一般に、この本は、前から後ろへと順番に読んでいることを前提としています。後の章は前の章の概念に基づいて構築されており、前の章ではトピックの詳細を掘り下げない場合があります。通常、このトピックは後の章で再度取り上げます。</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">一般に、反駁可能なパターンと反駁できないパターンの違いを心配する必要はありません。ただし、反論可能性の概念に精通している必要があるので、エラーメッセージに表示されたときに対応できます。このような場合、コードの意図する動作に応じて、パターンまたはパターンを使用している構成体を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">ここでは、 &lt;code&gt;jon_snow&lt;/code&gt; は既に &lt;code&gt;nights_watch&lt;/code&gt; 参照によって借用されているため、同時に &lt;code&gt;starks&lt;/code&gt; クロージャーによって借用することはできません。この問題を修正するには、借用が終了した後でクロージャを作成できます。</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">ここでは、 &lt;code&gt;x&lt;/code&gt; は変更可能ではないため、 &lt;code&gt;y&lt;/code&gt; で可変的に借りようとすると失敗します。このエラーを修正するには、 &lt;code&gt;x&lt;/code&gt; を変更可能にする必要があります。</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">ここでは、 &lt;code&gt;y&lt;/code&gt; は内部スコープの最後にドロップされますが、 &lt;code&gt;println&lt;/code&gt; まで &lt;code&gt;x&lt;/code&gt; によって借用されます。前の例を修正するには、スコープを削除して、printlnの後まで &lt;code&gt;y&lt;/code&gt; が削除されないようにします。</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">Edsger W. Dijkstraは、1972年のエッセイ「The Humble Programmer」で、「プログラムのテストはバグの存在を示す非常に効果的な方法ですが、バグがないことを示すには不十分です」と述べています。だからといって、できる限りテストするべきではないという意味ではありません。</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">2009年のプレゼンテーション「Null References：The Billion Dollar Mistake」で、nullの発明者であるTony Hoareは次のように述べています。</target>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">不変のコンテキストでは、非ポインター型の &lt;code&gt;*x&lt;/code&gt; は &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">そのスレッドでは、 &lt;code&gt;Worker&lt;/code&gt; はチャネルの受信側をループし、受信したすべてのジョブのクロージャーを実行します。</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">標準ライブラリによって提供されるイテレータを持たない言語では、インデックス0で変数を開始し、その変数を使用してベクトルにインデックスを付けて値を取得し、ループで変数値をインクリメントすることで、同じ機能を作成する可能性があります。ベクター内のアイテムの総数に達するまで。</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">ポインターを使用する言語では、誰かに渡された可能性のあるメモリ内の場所を参照する&lt;em&gt;ダングリングポインター&lt;/em&gt;を誤って作成し、そのメモリへのポインターを保持しながらメモリを解放することは簡単です。対照的に、Rustでは、コンパイラーは参照がぶら下がる参照にならないことを保証します。データへの参照がある場合、コンパイラーは、データへの参照が行われる前にデータがスコープ外にならないことを保証します。</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">他の多くのプログラミング言語では、文字列内の個々の文字をインデックスで参照してアクセスすることは、有効で一般的な操作です。ただし、Rustのインデックス構文を使用して &lt;code&gt;String&lt;/code&gt; 一部にアクセスしようとすると、エラーが発生します。リスト8-19の無効なコードを考えてください。</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">多くのプログラミング言語では、スタックやヒープについて頻繁に考える必要はありません。しかし、Rustのようなシステムプログラミング言語では、値がスタックにあるかヒープにあるかによって、言語の動作や特定の決定を行う必要がある理由が大きく影響します。所有権の一部については、この章の後半でスタックとヒープに関連して説明するため、ここでは準備のための簡単な説明を示します。</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; ブロック内のメソッドシグネチャでは、参照は構造体のフィールドの参照の存続期間に関連付けられている場合もあれば、独立している場合もあります。さらに、ライフタイム省略ルールは、多くの場合、メソッドシグネチャでライフタイムアノテーションが不要になるようにします。リスト10-25で定義した &lt;code&gt;ImportantExcerpt&lt;/code&gt; という名前の構造体を使ったいくつかの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">メソッドのシグネチャには、もう一つのルールがあります。</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">より現実的なコードでは、Rustは値を挿入すると格納する値の型を推測できることが多いため、この型注釈を行う必要はほとんどありません。初期値を持つ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; を作成するのがより一般的で、Rustが &lt;code&gt;vec!&lt;/code&gt; 提供します！便宜上マクロ。マクロは、指定した値を保持する新しいベクトルを作成します。 8-2のリストに新しい作成 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; の値を保持 &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; 、および &lt;code&gt;3&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">特定の関数パラメーターが不要になった場合は、ほとんどの場合、シグニチャーを変更して、未使用のパラメーターが含まれないようにします。たとえば、特定の型シグネチャが必要であるが、実装の関数本体にパラメータの1つが必要ないときに特性を実装する場合など、関数パラメータを無視すると特に便利な場合があります。コンパイラは、名前を代わりに使用した場合のように、未使用の関数パラメーターについて警告しません。</target>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">ほとんどの場合、参照は元の値と同じように使用できます。フィールドアクセス、メソッド呼び出し、およびインデックス付けは同じように動作します(もちろん、変異性のルールを除いて)。さらに、比較演算子は参照元の実装に透過的に依存するため、参照を所有する値と同じように比較することができます。</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">現在のほとんどのオペレーティングシステムでは、実行されたプログラムのコードは&lt;em&gt;プロセス&lt;/em&gt;で実行され、オペレーティングシステムは複数のプロセスを一度に管理します。プログラム内で、同時に実行する独立した部分を持つこともできます。これらの独立した部分を実行する機能は&lt;em&gt;スレッド&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">ほとんどの場合、コンパイルされないコードの正しいバージョンが表示されます。</target>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">可変コンテキストでは、非ポインター型の &lt;code&gt;*x&lt;/code&gt; は &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">コンパイルの1つのセッションで、コンパイラはコマンドラインフラグまたは &lt;code&gt;crate_type&lt;/code&gt; 属性を使用して複数のアーティファクトを生成できます。1つ以上のコマンドラインフラグが指定されている場合、コマンドラインで指定されたアーティファクトのみを構築するために、すべての &lt;code&gt;crate_type&lt;/code&gt; 属性が無視されます。</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">ある意味では、このプログラムの方が優れています。タプルを使用すると、構造を少し追加でき、引数を1つだけ渡しています。しかし、別の言い方をすると、このバージョンはあまり明確ではありません。タプルは要素に名前を付けないため、タプルの部分にインデックスを付ける必要があるため、計算がさらに複雑になります。</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">型がこの特性を実装するためには、すべてのメソッドの実装を提供するだけでなく、型 &lt;code&gt;E&lt;/code&gt; を指定する必要があります。次に、標準ライブラリタイプ &lt;code&gt;Vec&lt;/code&gt; の &lt;code&gt;Container&lt;/code&gt; 実装を示します。</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">ファイルを作成するには、&lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt;アクセスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">Rust のグローバルな型推論の欠如と整合性を取るために、アイテムシグネチャでは、型と const のプレースホルダはデザイン上禁止されています。</target>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ジェネリック関数が指定された型 &lt;code&gt;T&lt;/code&gt; に変換できるすべての引数を取ることを表現するために、&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; の特性境界を使用できます。例：関数 &lt;code&gt;is_hello&lt;/code&gt; は、 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 変換できるすべての引数を取ります。</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">このエラーを修正するには、使用している型がその形質を実装していることを確認してください。例</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">このエラーを修正するには、 &lt;code&gt;pub&lt;/code&gt; キーワードを使用してアイテムを公開する必要があります。例：</target>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">一般的なパターンをより人間工学的にするために、&lt;a href=&quot;types/function-item&quot;&gt;関数アイテム&lt;/a&gt;、&lt;a href=&quot;types/function-pointer&quot;&gt;関数ポインター&lt;/a&gt;、&lt;a href=&quot;types/closure&quot;&gt;クロージャー特性&lt;/a&gt;シグニチャーで存続期間引数を&lt;em&gt;省略&lt;/em&gt;できます。次のルールは、省略されたライフタイムのライフタイムパラメータを推測するために使用されます。推定できないライフタイムパラメータを除外するとエラーになります。プレースホルダーの有効期間 &lt;code&gt;'_&lt;/code&gt; を使用して、同じ方法で有効期間を推定することもできます。パスのライフタイムについては、 &lt;code&gt;'_&lt;/code&gt; の使用が推奨されます。特性オブジェクトのライフタイムは、&lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;以下で&lt;/a&gt;説明するさまざまなルールに従います。</target>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">使いやすく、ユーザーが必要とするものだけを公開する、よく整理されたAPIをユーザーに提供するために、Rustのモジュールを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">つまり、すべての&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; は&lt;/a&gt;、自分自身を返すだけで&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; を&lt;/a&gt;実装します。これは2つのことを意味します。</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">言い換えると、各&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;park&lt;/code&gt; および &lt;code&gt;unpark&lt;/code&gt; を使用してロックおよびロック解除できるスピンロックのように機能します。</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">言い換えれば、もしゼロサイズのポインタがアロケータから流出することができるならば、そのアロケータは同様に、そのポインタがそのデアロケートおよび再アロケートメソッドに戻ってくることを受け入れなければなりません。</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">つまり、2つのキーが等しい場合、それらのハッシュも等しくなければなりません。&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; は&lt;/a&gt;どちらもこの動作に依存しています。</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">言い換えれば、2つのキーが等しい場合、そのハッシュは等しくなければなりません。</target>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">言い換えれば、2つのイテレータを連鎖的に結びつけます。🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">つまり、&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;レイヤーを自動的に削除します。マッピングがすでに&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を返していて、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;をスキップしたい場合は、 &lt;code&gt;filter_map&lt;/code&gt; の方がずっと便利です。</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">言い換えれば、2つのイテレータを1つのイテレータにまとめます。</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">つまり、 &lt;code&gt;f(c)&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; を返すように、すべての文字 &lt;code&gt;c&lt;/code&gt; を削除します。この方法は適切に機能し、各文字を元の順序で1回だけ訪問し、保持された文字の順序を保持します。</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; を返すようなすべての要素 &lt;code&gt;e&lt;/code&gt; を削除します。</target>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">つまり、 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; を返すようなすべての要素 &lt;code&gt;e&lt;/code&gt; を削除します。このメソッドは適切に動作し、各要素を元の順序で1回だけ訪問し、保持された要素の順序を保持します。</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">つまり、 &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; がfalseを返すようなすべての要素 &lt;code&gt;e&lt;/code&gt; を削除します。このメソッドは適切に動作し、各要素を元の順序で1回だけ訪問し、保持された要素の順序を保持します。</target>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; を返すように &lt;code&gt;(k, v)&lt;/code&gt; すべてのペア（k、v）を削除します。</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">言い換えると、結果は、 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; ように、整数 &lt;code&gt;n&lt;/code&gt; に丸められた &lt;code&gt;self / rhs&lt;/code&gt; rhsです。 &lt;code&gt;self &amp;gt; 0&lt;/code&gt; 場合、これはゼロに向かって丸めることと同じです（Rustのデフォルト）。 &lt;code&gt;self &amp;lt; 0&lt;/code&gt; 場合、これは+/-無限大への丸めと同じです。</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">つまり、ここでは時間的に重要なポイントが2つあります。</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">つまり、 &lt;code&gt;contents&lt;/code&gt; 引数で &lt;code&gt;search&lt;/code&gt; 関数に渡されたデータが存在する限り、 &lt;code&gt;search&lt;/code&gt; 関数によって返されたデータは存続することをRustに伝えます。これは重要！スライスが参照&lt;em&gt;する&lt;/em&gt;データは、参照が有効になるために有効である必要があります。コンパイラが、 &lt;code&gt;contents&lt;/code&gt; ではなく &lt;code&gt;query&lt;/code&gt; 文字列スライスを作成していると想定すると、安全性チェックが正しく行われません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">言い換えれば、あなたは考えることができます &lt;code&gt;if let&lt;/code&gt; のためのシンタックスシュガーとして &lt;code&gt;match&lt;/code&gt; 値が一つのパターンにマッチし、その後、他のすべての値を無視したときにコードを実行します。</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">言い換えれば、あなたは変換する必要があります &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; する &lt;code&gt;T&lt;/code&gt; あなたが実行する前に &lt;code&gt;T&lt;/code&gt; のそれとの動作を制御します。一般的に、これはnullに関する最も一般的な問題の1つをキャッチするのに役立ちます。実際にはnullでないものを想定します。</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">言い換えると、t&amp;isin;FOLLOW（M）は、トークンシーケンス&amp;alpha;、&amp;beta;、&amp;gamma;、&amp;delta;が存在する（空である可能性がある）場合に限り、ここで：</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">ただし、誤った例では、1つの具象型を参照しています。 &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; が &lt;code&gt;Clone&lt;/code&gt; を実装していることが確実にわかっているので、それを &lt;code&gt;where&lt;/code&gt; 句で指定する理由はありません。</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">特に、 &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Hash&lt;/code&gt; は、借りた値と所有した値で同等である必要があります &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; は、 &lt;code&gt;x == y&lt;/code&gt; と同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">具体的には、一方が所定のアロケータを介して割り当てられたメモリブロックがある場合 &lt;code&gt;a&lt;/code&gt; およびレイアウト &lt;code&gt;k&lt;/code&gt; &lt;code&gt;a.usable_size(k)&lt;/code&gt; を返す &lt;code&gt;(l, u)&lt;/code&gt; 、次に一つにそのブロックを通過することができる &lt;code&gt;a.dealloc()&lt;/code&gt; サイズのレイアウトとを範囲[l、u]。</target>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">特に、レジスタ制約の閉じ括弧を忘れてしまった場合に発生する可能性があります(問題番号#51430を参照)。</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">特に、生のエントリの初期化に使用されたハッシュは、最終的にエントリに格納されるキーのハッシュと一致していなければなりません。これは、HashMap の実装では、リサイズ時にハッシュを再計算する必要があるかもしれないからです。</target>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">特に、ほとんどの場合、戻り値 &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; を満たします。ただし、浮動小数点の丸めエラーにより、 &lt;code&gt;self&lt;/code&gt; が &lt;code&gt;rhs.abs()&lt;/code&gt; よりもはるかに小さく、 &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; 場合、数学的な定義に違反して &lt;code&gt;r == rhs.abs()&lt;/code&gt; になる可能性があります。この結果は関数のコドメインの要素ではありませんが、実数の中で最も近い浮動小数点数であるため、プロパティ &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; 近似的に満たします。</target>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">特に、このイテレータを構成する内部パーツで、この呼び出し &lt;code&gt;try_fold()&lt;/code&gt; を使用するようにしてください。複数の呼び出しが必要な場合、 &lt;code&gt;?&lt;/code&gt; 演算子は、アキュムレータ値をチェーンするのに便利ですが、それらの初期のリターンの前に維持する必要がある不変条件に注意してください。これは &lt;code&gt;&amp;amp;mut self&lt;/code&gt; メソッドなので、ここでエラーが発生した後、反復を再開できるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">まれに、 &lt;code&gt;Result&lt;/code&gt; を返すのではなく、パニックを起こすコードを書く方が適切です。例、プロトタイプコード、およびテストでパニックを起こすことが適切である理由を調べてみましょう。次に、コンパイラーは失敗が不可能であると判断できない状況について説明しますが、人間はそうすることができます。この章の最後には、ライブラリコードでパニックを起こすかどうかを決定する方法に関するいくつかの一般的なガイドラインがあります。</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">つまり、 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; （ &lt;code&gt;T&lt;/code&gt; は任意の型）は異なる型であるため、コンパイラーは &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 値を明確に有効な値であるかのように使用させません。たとえば、次のコードは &lt;code&gt;i8&lt;/code&gt; を &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; に追加しようとしているため、コンパイルされません。</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">シングルスレッドシナリオでは、これにより、シグナルハンドラーまたは特定の種類の低レベルコードを記述するときに問題が発生する可能性があります。&lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;コンパイラフェンス&lt;/a&gt;を使用して、この順序変更を防止します。</target>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">一部の言語では、プログラマーはスマートポインターのインスタンスの使用を終了するたびに、メモリまたはリソースを解放するコードを呼び出す必要があります。それらを忘れると、システムが過負荷になり、クラッシュする可能性があります。Rustでは、値がスコープ外になると必ず特定のコードを実行するように指定でき、コンパイラーはこのコードを自動的に挿入します。その結果、特定の型のインスタンスが終了したプログラム内のどこにでもクリーンアップコードを配置することに注意する必要はありません。リソースがリークすることはありません！</target>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">状況によっては、タイプの組み合わせがあいまいになる場合があります。あいまいさを避けるために、タイプを括弧で囲んでください。たとえば、&lt;a href=&quot;types/pointer#shared-references-&quot;&gt;参照型&lt;/a&gt;内の&lt;a href=&quot;trait-bounds&quot;&gt;型の境界の&lt;/a&gt; &lt;code&gt;+&lt;/code&gt; 演算子は、境界が適用される場所が不明確であるため、括弧を使用する必要があります。この一義化を必要とする文法規則は、&lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;ではなく&lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt;規則を使用します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="78a25e5b990fcd1740e4efa791bdb025c393c864" translate="yes" xml:space="preserve">
          <source>In some situations, some strings that should create a valid float instead return an error. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;issue #31407&lt;/a&gt; for details.</source>
          <target state="translated">状況によっては、有効な浮動小数点数を作成する必要がある一部の文字列がエラーを返すことがあります。詳細については、&lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;問題＃31407&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e28b9cfae095cd08e8afd62032026a0b23bc39f7" translate="yes" xml:space="preserve">
          <source>In statements like &lt;code&gt;let x = 5;&lt;/code&gt; with a variable name in the &lt;code&gt;PATTERN&lt;/code&gt; slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the &lt;code&gt;let x = 5;&lt;/code&gt; example, &lt;code&gt;x&lt;/code&gt; is a pattern that means &amp;ldquo;bind what matches here to the variable &lt;code&gt;x&lt;/code&gt;.&amp;rdquo; Because the name &lt;code&gt;x&lt;/code&gt; is the whole pattern, this pattern effectively means &amp;ldquo;bind everything to the variable &lt;code&gt;x&lt;/code&gt;, whatever the value is.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;let x = 5;&lt;/code&gt; ようなステートメントでは、変数名と &lt;code&gt;PATTERN&lt;/code&gt; スロット、変数名は、単にパターンの特に単純な形です。Rustは式をパターンと比較し、見つかった名前を割り当てます。したがって、 &lt;code&gt;let x = 5;&lt;/code&gt; たとえば、 &lt;code&gt;x&lt;/code&gt; は「ここで一致するものを変数 &lt;code&gt;x&lt;/code&gt; にバインドする」ことを意味するパターンです。名前 &lt;code&gt;x&lt;/code&gt; はパターン全体であるため、このパターンは「値が何であれ、すべてを変数 &lt;code&gt;x&lt;/code&gt; にバインドする」ことを意味します。</target>
        </trans-unit>
        <trans-unit id="ab76c75fb8be2531be195781f70554fa526d2349" translate="yes" xml:space="preserve">
          <source>In such a case, the compiler cannot predict the return type of &lt;code&gt;foo()&lt;/code&gt; in a situation like the following:</source>
          <target state="translated">このような場合、次のような状況では、コンパイラーは &lt;code&gt;foo()&lt;/code&gt; の戻り型を予測できません。</target>
        </trans-unit>
        <trans-unit id="a84c028b3015af78e467c76bddbf22405a6992e9" translate="yes" xml:space="preserve">
          <source>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</source>
          <target state="translated">まとめると、リスト10-2からリスト10-3にコードを変更するために行ったステップは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b66a6766ec59e5aa720a0c750a221736c0a524da" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic memory orderings&lt;/a&gt;, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after &lt;code&gt;join&lt;/code&gt; returns.</source>
          <target state="translated">&lt;a href=&quot;../sync/atomic/index&quot;&gt;アトミックメモリの順序付けの&lt;/a&gt;観点から、関連するスレッドの完了は、この関数が戻るのと同期します。つまり、そのスレッドによって実行されるすべての操作は、 &lt;code&gt;join&lt;/code&gt; が戻った後に発生するすべての操作の前に順序付けされます。</target>
        </trans-unit>
        <trans-unit id="4fb4dfd79140995a00d7f2f4a091910c0bb3584f" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, &lt;a href=&quot;types/trait-object&quot;&gt;&lt;code&gt;dyn&lt;/code&gt;&lt;/a&gt; is a keyword when used in a type position followed by a path that does not start with &lt;code&gt;::&lt;/code&gt;.</source>
          <target state="translated">2015版では、&lt;a href=&quot;types/trait-object&quot;&gt; &lt;code&gt;dyn&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;::&lt;/code&gt; で始まらないパスが後に続く型の位置で使用される場合のキーワードです。</target>
        </trans-unit>
        <trans-unit id="e5c533200fa356e0f6f01942ecd077fd12144d48" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, the pattern for a trait function or method parameter is optional:</source>
          <target state="translated">2015年版では、形質関数やメソッドパラメータのパターンは任意です。</target>
        </trans-unit>
        <trans-unit id="ead217a846b182b1c7c3895bb636fcdc53cf3da8" translate="yes" xml:space="preserve">
          <source>In the 2018 edition, if an in-scope item has the same name as an external crate, then &lt;code&gt;use&lt;/code&gt; of that crate name requires a leading &lt;code&gt;::&lt;/code&gt; to unambiguously select the crate name. This is to retain compatibility with potential future changes.</source>
          <target state="translated">2018年版では、範囲内のアイテムが外部クレートと同じ名前である &lt;code&gt;use&lt;/code&gt; 、そのクレート名を使用するには、先頭に &lt;code&gt;::&lt;/code&gt; が必要で、クレート名を明確に選択できます。これは、潜在的な将来の変更との互換性を維持するためです。</target>
        </trans-unit>
        <trans-unit id="ac8c3e671a7bc9e2a3ca26713c444ad82025ac40" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">では&lt;a href=&quot;index&quot;&gt;モジュールレベルのドキュメント&lt;/a&gt;は、我々は実装&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;Counter&lt;/code&gt; 。 &lt;code&gt;ExactSizeIterator&lt;/code&gt; も実装しましょう：</target>
        </trans-unit>
        <trans-unit id="542be6c89aa5ea78dd9931c09f1fa338c6d41b0e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;User&lt;/code&gt; struct definition in Listing 5-1, we used the owned &lt;code&gt;String&lt;/code&gt; type rather than the &lt;code&gt;&amp;amp;str&lt;/code&gt; string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</source>
          <target state="translated">リスト5-1 の &lt;code&gt;User&lt;/code&gt; 構造体の定義では、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 文字列スライスタイプではなく、所有されている &lt;code&gt;String&lt;/code&gt; タイプを使用しました。この構造体のインスタンスがすべてのデータを所有し、構造体全体が有効である限りそのデータが有効であるため、これは意図的な選択です。</target>
        </trans-unit>
        <trans-unit id="86f5e9e4af3e5d42db41973d9449d9469f700ef8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ve made the &lt;code&gt;stream&lt;/code&gt; parameter mutable. The reason is that the &lt;code&gt;TcpStream&lt;/code&gt; instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. It therefore needs to be &lt;code&gt;mut&lt;/code&gt; because its internal state might change; usually, we think of &amp;ldquo;reading&amp;rdquo; as not needing mutation, but in this case we need the &lt;code&gt;mut&lt;/code&gt; keyword.</source>
          <target state="translated">で &lt;code&gt;handle_connection&lt;/code&gt; の機能、我々は作った &lt;code&gt;stream&lt;/code&gt; 変更可能なパラメータ。その理由は、 &lt;code&gt;TcpStream&lt;/code&gt; インスタンスが内部で返すデータを追跡しているためです。要求したよりも多くのデータを読み取り、次にデータを要求したときにそのデータを保存する可能性があります。したがって、内部状態が変化する可能性があるため、 &lt;code&gt;mut&lt;/code&gt; する必要があります。通常、「読み取り」は変更を必要としないと考えますが、この場合は &lt;code&gt;mut&lt;/code&gt; キーワードが必要です。</target>
        </trans-unit>
        <trans-unit id="41e5d381e8adcfa53c11fefa07fcde5916d77703" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.3.14&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.3.14&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.3.14&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.3.14.&amp;rdquo;</source>
          <target state="translated">で&lt;em&gt;Cargo.tomlの&lt;/em&gt;ファイル、ヘッダの後に続くすべてが別のセクションが始まるまで続くセクションの一部です。 &lt;code&gt;[dependencies]&lt;/code&gt; セクションでは、外部の箱プロジェクトが依存している貨物を伝えるところであるあなたが必要とする木枠のバージョン。この場合、意味バージョン指定子 &lt;code&gt;0.3.14&lt;/code&gt; で &lt;code&gt;rand&lt;/code&gt; クレートを指定します。 Cargo は、バージョン番号を記述するための標準である&lt;a href=&quot;http://semver.org&quot;&gt;セマンティックバージョニング&lt;/a&gt;（&lt;em&gt;SemVer&lt;/em&gt;と呼ばれることもあり&lt;em&gt;ます&lt;/em&gt;）を理解しています。数値 &lt;code&gt;0.3.14&lt;/code&gt; は、実際には &lt;code&gt;^0.3.14&lt;/code&gt; 省略形です。これは、「バージョン0.3.14と互換性のあるパブリックAPIを持つすべてのバージョン」を意味します。</target>
        </trans-unit>
        <trans-unit id="b7177f5dba94e8e93990faf2d2454fb646d49847" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s add an &lt;code&gt;add_one&lt;/code&gt; function:</source>
          <target state="translated">では&lt;em&gt;アドオン1 / SRC / lib.rsの&lt;/em&gt;ファイル、のは、追加してみましょう &lt;code&gt;add_one&lt;/code&gt; の機能を：</target>
        </trans-unit>
        <trans-unit id="3da0b39e8b4dc5e8ab87b83cc0f936c2b1215ca7" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;T&lt;/code&gt; is unknowable by the compiler. To fix this you must bind &lt;code&gt;T&lt;/code&gt; to a concrete type such as &lt;code&gt;String&lt;/code&gt; so that a generator can then be constructed:</source>
          <target state="translated">上記の例では、コンパイラーは &lt;code&gt;T&lt;/code&gt; を認識できません。これを修正するには、ジェネレータを作成できるように、 &lt;code&gt;T&lt;/code&gt; を &lt;code&gt;String&lt;/code&gt; などの具象型にバインドする必要があります。</target>
        </trans-unit>
        <trans-unit id="dac108bef6e0aa0c5a3c87c1e1dd002eec20cb12" translate="yes" xml:space="preserve">
          <source>In the absolute path, we start with &lt;code&gt;crate&lt;/code&gt;, the root of our crate&amp;rsquo;s module tree. Then the &lt;code&gt;front_of_house&lt;/code&gt; module is defined in the crate root. The &lt;code&gt;front_of_house&lt;/code&gt; module isn&amp;rsquo;t public, but because the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is defined in the same module as &lt;code&gt;front_of_house&lt;/code&gt; (that is, &lt;code&gt;eat_at_restaurant&lt;/code&gt; and &lt;code&gt;front_of_house&lt;/code&gt; are siblings), we can refer to &lt;code&gt;front_of_house&lt;/code&gt; from &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Next is the &lt;code&gt;hosting&lt;/code&gt; module marked with &lt;code&gt;pub&lt;/code&gt;. We can access the parent module of &lt;code&gt;hosting&lt;/code&gt;, so we can access &lt;code&gt;hosting&lt;/code&gt;. Finally, the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is marked with &lt;code&gt;pub&lt;/code&gt; and we can access its parent module, so this function call works!</source>
          <target state="translated">絶対パスでは、クレートのモジュールツリーのルートである &lt;code&gt;crate&lt;/code&gt; から始めます。次に、 &lt;code&gt;front_of_house&lt;/code&gt; モジュールがクレートルートで定義されます。 &lt;code&gt;front_of_house&lt;/code&gt; のモジュールは、パブリックではなく、ため &lt;code&gt;eat_at_restaurant&lt;/code&gt; 関数は同じモジュールで定義され &lt;code&gt;front_of_house&lt;/code&gt; （であること &lt;code&gt;eat_at_restaurant&lt;/code&gt; と &lt;code&gt;front_of_house&lt;/code&gt; 兄弟である）、我々が参照でき &lt;code&gt;front_of_house&lt;/code&gt; から &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。次は &lt;code&gt;pub&lt;/code&gt; でマークされた &lt;code&gt;hosting&lt;/code&gt; モジュールです。我々は親モジュールにアクセスすることができます &lt;code&gt;hosting&lt;/code&gt; 我々がアクセスできるように、 &lt;code&gt;hosting&lt;/code&gt; 。最後に、 &lt;code&gt;add_to_waitlist&lt;/code&gt; 関数は &lt;code&gt;pub&lt;/code&gt; でマークされており、その親モジュールにアクセスできるため、この関数呼び出しは機能します。</target>
        </trans-unit>
        <trans-unit id="e8a74d26ff6bb6812e6769b94696470ac83d32c8" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;largest&lt;/code&gt; we wanted to compare two values of type &lt;code&gt;T&lt;/code&gt; using the greater than (&lt;code&gt;&amp;gt;&lt;/code&gt;) operator. Because that operator is defined as a default method on the standard library trait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, we need to specify &lt;code&gt;PartialOrd&lt;/code&gt; in the trait bounds for &lt;code&gt;T&lt;/code&gt; so the &lt;code&gt;largest&lt;/code&gt; function can work on slices of any type that we can compare. We don&amp;rsquo;t need to bring &lt;code&gt;PartialOrd&lt;/code&gt; into scope because it&amp;rsquo;s in the prelude. Change the signature of &lt;code&gt;largest&lt;/code&gt; to look like this:</source>
          <target state="translated">体で &lt;code&gt;largest&lt;/code&gt; 、我々は、型の二つの値を比較したかった &lt;code&gt;T&lt;/code&gt; （より大きい使用 &lt;code&gt;&amp;gt;&lt;/code&gt; ）演算子を。その演算子は標準ライブラリtrait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; デフォルトメソッドとして定義されているため、 &lt;code&gt;largest&lt;/code&gt; 関数が比較可能な任意の型のスライスで機能できるように、 &lt;code&gt;T&lt;/code&gt; の特性境界で &lt;code&gt;PartialOrd&lt;/code&gt; を指定する必要があります。 &lt;code&gt;PartialOrd&lt;/code&gt; はプレリュードに含まれているため、スコープに含める必要はありません。 &lt;code&gt;largest&lt;/code&gt; の署名を次のように変更します。</target>
        </trans-unit>
        <trans-unit id="9eeb876353faccbcba2ce19feeb7d0dafe4faead" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we call &lt;code&gt;into_iter&lt;/code&gt; to create an iterator that takes ownership of the vector. Then we call &lt;code&gt;filter&lt;/code&gt; to adapt that iterator into a new iterator that only contains elements for which the closure returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">ボディで &lt;code&gt;shoes_in_my_size&lt;/code&gt; 、我々は呼んで &lt;code&gt;into_iter&lt;/code&gt; ベクトルの所有権を取得イテレータを作成します。次に、 &lt;code&gt;filter&lt;/code&gt; を呼び出して、そのイテレーターを、クロージャーが &lt;code&gt;true&lt;/code&gt; を返す要素のみを含む新しいイテレーターに適合させます。</target>
        </trans-unit>
        <trans-unit id="ccc28c109f469220d7a0f86ba3d92af7a489d690" translate="yes" xml:space="preserve">
          <source>In the body of a generic function, methods from &lt;code&gt;Trait&lt;/code&gt; can be called on &lt;code&gt;Ty&lt;/code&gt; values. Likewise associated constants on the &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">ジェネリック関数の本体では、 &lt;code&gt;Ty&lt;/code&gt; 値に対して &lt;code&gt;Trait&lt;/code&gt; のメソッドを呼び出すことができます。同様に、 &lt;code&gt;Trait&lt;/code&gt; に関連付けられた定数を使用できます。</target>
        </trans-unit>
        <trans-unit id="ed9b56a6d3a5e9ebb3e76d9359071c31eee0aecc" translate="yes" xml:space="preserve">
          <source>In the case a &lt;code&gt;loop&lt;/code&gt; has an associated &lt;code&gt;break&lt;/code&gt;, it is not considered diverging, and the &lt;code&gt;loop&lt;/code&gt; must have a type compatible with each &lt;code&gt;break&lt;/code&gt; expression. &lt;code&gt;break&lt;/code&gt; without an expression is considered identical to &lt;code&gt;break&lt;/code&gt; with expression &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">場合に &lt;code&gt;loop&lt;/code&gt; 関連付けられてい &lt;code&gt;break&lt;/code&gt; 、それが発散考慮されていない、そして &lt;code&gt;loop&lt;/code&gt; 各々と互換性のある型有していなければならない &lt;code&gt;break&lt;/code&gt; 発現。 &lt;code&gt;break&lt;/code&gt; 表現せずには同一とみなされる &lt;code&gt;break&lt;/code&gt; 式で &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57fe262eb9d9754ab04dac149861a78ef7f9cbdf" translate="yes" xml:space="preserve">
          <source>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&amp;rsquo;s immutability. Unfortunately, we can&amp;rsquo;t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.</source>
          <target state="translated">文字列リテラルの場合、コンパイル時に内容がわかるため、テキストは最終的な実行可能ファイルに直接ハードコードされます。これが、文字列リテラルが高速で効率的な理由です。ただし、これらのプロパティは、文字列リテラルの不変性に由来します。残念ながら、コンパイル時にサイズが不明で、プログラムの実行中にサイズが変化する可能性があるテキストの各部分について、メモリの塊をバイナリに入れることはできません。</target>
        </trans-unit>
        <trans-unit id="174ee51902d80b0fa89335cd9be3f224ff39dd4c" translate="yes" xml:space="preserve">
          <source>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</source>
          <target state="translated">暗黙的にラッピングされたオーバーフローの場合には、実装は、2 の補数オーバーフローの規則を用いて、十分に定義された結果を提供する必要があります(それでも誤りであると考えられる場合もあります)。</target>
        </trans-unit>
        <trans-unit id="ad072c8ebb70bdab55dbb950bf9d58e7b04bb9e3" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;File::open&lt;/code&gt; succeeds, the value in the variable &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Ok&lt;/code&gt; that contains a file handle. In the case where it fails, the value in &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Err&lt;/code&gt; that contains more information about the kind of error that happened.</source>
          <target state="translated">場合は &lt;code&gt;File::open&lt;/code&gt; 成功し、変数の値 &lt;code&gt;f&lt;/code&gt; はのインスタンスになります &lt;code&gt;Ok&lt;/code&gt; ファイルハンドルが含まれています。失敗した場合、 &lt;code&gt;f&lt;/code&gt; の値は、発生したエラーの種類に関する詳細を含む &lt;code&gt;Err&lt;/code&gt; のインスタンスになります。</target>
        </trans-unit>
        <trans-unit id="98ff22c3c9a8db90c4e7212603caadebf4d948d5" translate="yes" xml:space="preserve">
          <source>In the code above, the function is returning data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, but the &lt;code&gt;'a&lt;/code&gt; annotation indicates that it is returning data only from &lt;code&gt;x&lt;/code&gt;. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&amp;amp;'a i32&lt;/code&gt;, like so:</source>
          <target state="translated">上記のコードでは、関数は &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; から借用したデータを返していますが、 &lt;code&gt;'a&lt;/code&gt; アノテーションは &lt;code&gt;x&lt;/code&gt; からのみデータを返していることを示しています。エラーを修正するには、署名と本文を一致させる必要があります。通常、これは関数シグネチャを更新することによって行われます。したがって、この場合、次のように &lt;code&gt;y&lt;/code&gt; のタイプを &lt;code&gt;&amp;amp;'a i32&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="47d276ce9763d36114b6391e5e3702972a6d1fd2" translate="yes" xml:space="preserve">
          <source>In the context of Listing 9-7, the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;File::open&lt;/code&gt; call will return the value inside an &lt;code&gt;Ok&lt;/code&gt; to the variable &lt;code&gt;f&lt;/code&gt;. If an error occurs, the &lt;code&gt;?&lt;/code&gt; operator will return early out of the whole function and give any &lt;code&gt;Err&lt;/code&gt; value to the calling code. The same thing applies to the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call.</source>
          <target state="translated">リスト9-7のコンテキストでは、 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;File::open&lt;/code&gt; 呼び出しの最後で、 &lt;code&gt;Ok&lt;/code&gt; 内の値を変数 &lt;code&gt;f&lt;/code&gt; に返します。エラーが発生した場合、 &lt;code&gt;?&lt;/code&gt; 演算子は関数全体から早期に戻り、呼び出しコードに任意の &lt;code&gt;Err&lt;/code&gt; 値を与えます。同じことは &lt;code&gt;?&lt;/code&gt; &lt;code&gt;read_to_string&lt;/code&gt; 呼び出しの最後。</target>
        </trans-unit>
        <trans-unit id="c49979de4803e07d7682a6dac88ad65cf9bdcef3" translate="yes" xml:space="preserve">
          <source>In the end, this means that you may need to pair &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; with some sort of &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::sync&lt;/code&gt;&lt;/a&gt; type, usually &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">結局、これは、 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; をある種の&lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::sync&lt;/code&gt; &lt;/a&gt;タイプ（通常は&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;とペアにする必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="5a1b716ed41677dd2be556cd6b10193bd9fd8fb5" translate="yes" xml:space="preserve">
          <source>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</source>
          <target state="translated">上記の誤ったコード例では、間違った名前が提供されていたので、正しい名前に変更するとエラーが修正されます。例</target>
        </trans-unit>
        <trans-unit id="a13ba9220a713242d839758de54b6d6a213f5d7c" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;closure&lt;/code&gt; is an &lt;code&gt;FnOnce&lt;/code&gt; closure whereas the &lt;code&gt;bar&lt;/code&gt; function expected an &lt;code&gt;Fn&lt;/code&gt; closure. In this case, it's simple to fix the issue, you just have to implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; traits on &lt;code&gt;struct X&lt;/code&gt; and it'll be ok:</source>
          <target state="translated">上記の例では、 &lt;code&gt;closure&lt;/code&gt; は &lt;code&gt;FnOnce&lt;/code&gt; クロージャーですが、 &lt;code&gt;bar&lt;/code&gt; 関数は &lt;code&gt;Fn&lt;/code&gt; クロージャーを想定しています。この場合、問題を修正するのは簡単です。 &lt;code&gt;struct X&lt;/code&gt; &lt;code&gt;Copy&lt;/code&gt; と &lt;code&gt;Clone&lt;/code&gt; トレイトを実装するだけで問題ありません。</target>
        </trans-unit>
        <trans-unit id="c4e63cece27f012d6cb0c3b410a4800e38cdde84" translate="yes" xml:space="preserve">
          <source>In the example below, we implement a &lt;code&gt;Point&lt;/code&gt; type. Because it only stores two integers, we opt-out of ownership semantics with &lt;code&gt;Copy&lt;/code&gt;. Then we can &lt;code&gt;let p2 = p1&lt;/code&gt; without &lt;code&gt;p1&lt;/code&gt; being moved.</source>
          <target state="translated">以下の例では、 &lt;code&gt;Point&lt;/code&gt; タイプを実装しています。2つの整数しか格納しないため、 &lt;code&gt;Copy&lt;/code&gt; を使用して所有権のセマンティクスをオプトアウトします。次に、 &lt;code&gt;p1&lt;/code&gt; を移動せずに &lt;code&gt;let p2 = p1&lt;/code&gt; とすることができます。</target>
        </trans-unit>
        <trans-unit id="dce7e71b1b63c6637f941a4911789744e653ecbd" translate="yes" xml:space="preserve">
          <source>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">最初のケースでは、出力ライフタイムは一意の入力ライフタイムと同じであると推定されます。 2番目のケースでは、代わりに、寿命は &lt;code&gt;&amp;amp;self&lt;/code&gt; または &lt;code&gt;&amp;amp;mut self&lt;/code&gt; の寿命と同じであると推定されます。</target>
        </trans-unit>
        <trans-unit id="874b3aefadd7a8d78fd78ecf2f3f7b20564e4f86" translate="yes" xml:space="preserve">
          <source>In the first example, the lowercased string is represented &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (the last character is an acute accent &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining character&lt;/a&gt;). Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt;. In the second example, the lowercased string is represented &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (the last character is a single Unicode character representing an 'e' with an acute accent). Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt;.</source>
          <target state="translated">最初の例では、小文字の文字列は &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; （最後の文字は、アキュートアクセント&lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;結合文字です&lt;/a&gt;）。文字列内の他の文字とは異なり、結合文字は大文字のバリアントにマップされないため、 &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt; ます。 2番目の例では、小文字の文字列は &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; （最後の文字は、鋭いアクセントを持つ「e」を表す単一のUnicode文字です）。最後の文字はASCIIの範囲外で定義されているため、大文字のバリアントにマップされず、 &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="7e492b1a4744d12effe76c9a0dc29e53bf345ccf" translate="yes" xml:space="preserve">
          <source>In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the &lt;code&gt;&amp;amp;&lt;/code&gt; operator can't be applied to the value's fields. For example, the following is not valid:</source>
          <target state="translated">最初の一致式では、値がコピー（または移動）されます。2番目の一致では、同じメモリロケーションへの参照が変数値にバインドされます。この構文が必要なのは、サブパターンの分解では &lt;code&gt;&amp;amp;&lt;/code&gt; 演算子を値のフィールドに適用できないためです。たとえば、以下は無効です。</target>
        </trans-unit>
        <trans-unit id="963b4be1c96ed23abf1f14a5ca37f0831c8c64ef" translate="yes" xml:space="preserve">
          <source>In the following example, we make the &lt;code&gt;call_from_c&lt;/code&gt; function accessible from C code, after it&amp;rsquo;s compiled to a shared library and linked from C:</source>
          <target state="translated">次の例では、 &lt;code&gt;call_from_c&lt;/code&gt; 関数を共有ライブラリにコンパイルしてCからリンクした後、Cコードからアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="acbd16055f21eb6fdaf455bf26541bd9198ef8ac" translate="yes" xml:space="preserve">
          <source>In the implementation of &lt;code&gt;outline_print&lt;/code&gt;, we want to use the &lt;code&gt;Display&lt;/code&gt; trait&amp;rsquo;s functionality. Therefore, we need to specify that the &lt;code&gt;OutlinePrint&lt;/code&gt; trait will work only for types that also implement &lt;code&gt;Display&lt;/code&gt; and provide the functionality that &lt;code&gt;OutlinePrint&lt;/code&gt; needs. We can do that in the trait definition by specifying &lt;code&gt;OutlinePrint: Display&lt;/code&gt;. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the &lt;code&gt;OutlinePrint&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;outline_print&lt;/code&gt; の実装では、 &lt;code&gt;Display&lt;/code&gt; トレイトの機能を使用したいと思います。したがって、 &lt;code&gt;OutlinePrint&lt;/code&gt; トレイトが &lt;code&gt;Display&lt;/code&gt; も実装し、 &lt;code&gt;OutlinePrint&lt;/code&gt; に必要な機能を提供するタイプに対してのみ機能することを指定する必要があります。トレイト定義でこれを行うには、 &lt;code&gt;OutlinePrint: Display&lt;/code&gt; 指定します。この手法は、特性にバインドされた特性を追加することに似ています。リスト19-22は &lt;code&gt;OutlinePrint&lt;/code&gt; トレイトの実装を示しています。</target>
        </trans-unit>
        <trans-unit id="81a422714f2fa87b38ce332890d1f64c8678f1a7" translate="yes" xml:space="preserve">
          <source>In the last arm, where we&amp;rsquo;ve specified a variable without a range, we do have the value available to use in the arm&amp;rsquo;s code in a variable named &lt;code&gt;id&lt;/code&gt;. The reason is that we&amp;rsquo;ve used the struct field shorthand syntax. But we haven&amp;rsquo;t applied any test to the value in the &lt;code&gt;id&lt;/code&gt; field in this arm, as we did with the first two arms: any value would match this pattern.</source>
          <target state="translated">範囲のない変数を指定した最後のアームでは、アームのコードで &lt;code&gt;id&lt;/code&gt; という名前の変数に使用できる値があります。その理由は、構造体フィールドの省略構文を使用したからです。ただし、最初の2つのアームで行ったように、このアームの &lt;code&gt;id&lt;/code&gt; フィールドの値にはテストを適用していません。値はすべてこのパターンに一致します。</target>
        </trans-unit>
        <trans-unit id="8a42fbeac9d5cd28add8db6a4c34d47e67684d80" translate="yes" xml:space="preserve">
          <source>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call &lt;code&gt;join&lt;/code&gt; on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</source>
          <target state="translated">メインスレッドでは、すべての結合ハンドルを収集します。次に、リスト16-2で行ったよう &lt;code&gt;join&lt;/code&gt; 、各ハンドルでjoinを呼び出して、すべてのスレッドが確実に終了するようにします。その時点で、メインスレッドはロックを取得し、このプログラムの結果を出力します。</target>
        </trans-unit>
        <trans-unit id="04da7f268aa71a2c6ae0063d0f79d0cc060f8123" translate="yes" xml:space="preserve">
          <source>In the main thread, we&amp;rsquo;re not calling the &lt;code&gt;recv&lt;/code&gt; function explicitly anymore: instead, we&amp;rsquo;re treating &lt;code&gt;rx&lt;/code&gt; as an iterator. For each value received, we&amp;rsquo;re printing it. When the channel is closed, iteration will end.</source>
          <target state="translated">メインスレッドでは、 &lt;code&gt;recv&lt;/code&gt; 関数を明示的に呼び出さなくなりました。代わりに、 &lt;code&gt;rx&lt;/code&gt; をイテレータとして扱います。受け取った値ごとに、それを出力します。チャネルが閉じられると、反復が終了します。</target>
        </trans-unit>
        <trans-unit id="6a6bd022f18026c156e26cea87623c8cec496bfa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn&amp;rsquo;t be cleaned up unless it doesn&amp;rsquo;t have any edges pointing to it.</source>
          <target state="translated">ほとんどの場合、所有権は明らかです。特定の値を所有する変数が正確にわかります。ただし、1つの値に複数の所有者がいる場合があります。たとえば、グラフのデータ構造では、複数のエッジが同じノードを指している場合があり、そのノードは概念的に、そのノードを指すすべてのエッジによって所有されています。ノードを指すエッジがない場合を除き、ノードをクリーンアップしないでください。</target>
        </trans-unit>
        <trans-unit id="b4fe9ca25f444c9952c260922e7715e70a50aab9" translate="yes" xml:space="preserve">
          <source>In the match expression for this code, we add a variable called &lt;code&gt;state&lt;/code&gt; to the pattern that matches values of the variant &lt;code&gt;Coin::Quarter&lt;/code&gt;. When a &lt;code&gt;Coin::Quarter&lt;/code&gt; matches, the &lt;code&gt;state&lt;/code&gt; variable will bind to the value of that quarter&amp;rsquo;s state. Then we can use &lt;code&gt;state&lt;/code&gt; in the code for that arm, like so:</source>
          <target state="translated">このコードの一致式では、バリアント &lt;code&gt;Coin::Quarter&lt;/code&gt; 値に一致するパターンに &lt;code&gt;state&lt;/code&gt; という変数を追加します。ときに &lt;code&gt;Coin::Quarter&lt;/code&gt; 試合、 &lt;code&gt;state&lt;/code&gt; 変数は、その四半期の状態の値にバインドします。次に、次のように、そのアームのコードで &lt;code&gt;state&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="37676c5799bfd02feed7afe648d55c20c391e411" translate="yes" xml:space="preserve">
          <source>In the matcher, &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;&lt;code&gt;:&lt;/code&gt;&lt;em&gt;fragment-specifier&lt;/em&gt; matches a Rust syntax fragment of the kind specified and binds it to the metavariable &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;. Valid fragment specifiers are:</source>
          <target state="translated">マッチャーでは、 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name &lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;fragment-specifier&lt;/em&gt;は、指定された種類のRust構文フラグメントに一致し、メタ変数 &lt;code&gt;$&lt;/code&gt; &lt;em&gt;nameに&lt;/em&gt;バインドします。有効なフラグメント指定子は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="963b3e8473b4ab06c6410ca4e20e74e946590848" translate="yes" xml:space="preserve">
          <source>In the next chapter, we&amp;rsquo;ll look at some collection data structures in the standard library that you can use in your neatly organized code.</source>
          <target state="translated">次の章では、整理されたコードで使用できる標準ライブラリのコレクションデータ構造をいくつか見ていきます。</target>
        </trans-unit>
        <trans-unit id="62f755e3daa908e0af290719bd4bb3bcad378eef" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 12 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">リスト9-2の出力では、バックトレースの12行目が、問題の原因となっているプロジェクトの行を示しています&lt;em&gt;。src / main.rsの&lt;/em&gt; 4行&lt;em&gt;目&lt;/em&gt;です。プログラムにパニックを起こさせたくない場合は、最初に記述したファイルを示す行が指す場所から調査を開始する必要があります。リスト9-1で、バックトレースの使用方法を示すためにパニックになるコードを意図的に記述した場合、パニックを修正する方法は、3つのアイテムのみを含むベクターからインデックス99の要素を要求しないことです。コードが将来パニックするとき、パニックを引き起こす値と、コードが何をすべきかをコードが実行しているアクションを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff1955a5e30929ce37102fab2f4935897b292825" translate="yes" xml:space="preserve">
          <source>In the previous section, we looked at how the &lt;code&gt;IpAddr&lt;/code&gt; enum let us use Rust&amp;rsquo;s type system to encode more information than just the data into our program. This section explores a case study of &lt;code&gt;Option&lt;/code&gt;, which is another enum defined by the standard library. The &lt;code&gt;Option&lt;/code&gt; type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing. Expressing this concept in terms of the type system means the compiler can check whether you&amp;rsquo;ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</source>
          <target state="translated">前のセクションでは、 &lt;code&gt;IpAddr&lt;/code&gt; 列挙型を使用して、Rustの型システムを使用して、データだけでなくプログラムに多くの情報をエンコードする方法を説明しました。このセクションでは、標準ライブラリで定義されている別の列挙型である &lt;code&gt;Option&lt;/code&gt; のケーススタディについて説明します。 &lt;code&gt;Option&lt;/code&gt; には値がものになる可能性が非常に一般的なシナリオをエンコードするか、それは何もできなかったので、種類は多くの場所で使用されています。この概念を型システムの観点から表現すると、コンパイラーは、処理する必要があるすべてのケースを処理したかどうかをコンパイラーが確認できることを意味します。この機能により、他のプログラミング言語で非常に一般的なバグを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="7166e371e82ca092dfca006916f5e7d27ed3dcc0" translate="yes" xml:space="preserve">
          <source>In the previous section, we wanted to get the inner &lt;code&gt;T&lt;/code&gt; value out of the &lt;code&gt;Some&lt;/code&gt; case when using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;; we can also handle &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;match&lt;/code&gt; as we did with the &lt;code&gt;Coin&lt;/code&gt; enum! Instead of comparing coins, we&amp;rsquo;ll compare the variants of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, but the way that the &lt;code&gt;match&lt;/code&gt; expression works remains the same.</source>
          <target state="translated">前のセクションでは、 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; を使用するときに &lt;code&gt;Some&lt;/code&gt; ケースから内部 &lt;code&gt;T&lt;/code&gt; 値を取得する必要がありました。 &lt;code&gt;Coin&lt;/code&gt; enumで行ったように、 &lt;code&gt;match&lt;/code&gt; を使用して &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; を処理することもできます。コインを比較する代わりに、 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; バリアントを比較しますが、 &lt;code&gt;match&lt;/code&gt; 式が機能する方法は同じです。</target>
        </trans-unit>
        <trans-unit id="021531d5da5d15cfe5b7187998d391941c64c620" translate="yes" xml:space="preserve">
          <source>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from &lt;code&gt;front_of_house&lt;/code&gt;. The &lt;code&gt;front_of_house&lt;/code&gt; module is defined within the same module as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, so the relative path starting from the module in which &lt;code&gt;eat_at_restaurant&lt;/code&gt; is defined works. Then, because &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;add_to_waitlist&lt;/code&gt; are marked with &lt;code&gt;pub&lt;/code&gt;, the rest of the path works, and this function call is valid!</source>
          <target state="translated">相対パスでは、ロジックは最初のステップを除いて絶対パスと同じ &lt;code&gt;front_of_house&lt;/code&gt; 。クレートのルートから開始するのではなく、パスはfront_of_houseから開始します。 &lt;code&gt;front_of_house&lt;/code&gt; のモジュールは、同じモジュール内で定義され &lt;code&gt;eat_at_restaurant&lt;/code&gt; 相対パスたモジュールから出発して、 &lt;code&gt;eat_at_restaurant&lt;/code&gt; が作品に定義されています。次に、 &lt;code&gt;hosting&lt;/code&gt; と &lt;code&gt;add_to_waitlist&lt;/code&gt; は &lt;code&gt;pub&lt;/code&gt; でマークされているため、残りのパスは機能し、この関数呼び出しは有効です。</target>
        </trans-unit>
        <trans-unit id="34eddaeb0b0b8fe0265b13cd54b792a68e5d0a8d" translate="yes" xml:space="preserve">
          <source>In the restaurant industry, some parts of a restaurant are referred to as &lt;em&gt;front of house&lt;/em&gt; and others as &lt;em&gt;back of house&lt;/em&gt;. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.</source>
          <target state="translated">レストラン業界では、レストランの一部が「&lt;em&gt;家の前」&lt;/em&gt;と呼ばれ、他の部分が&lt;em&gt;「家の後ろ」&lt;/em&gt;と呼ばれます。家の前は顧客がいる場所です。これは、ホストが顧客を席に置き、サーバーが注文と支払いを行い、バーテンダーが飲み物を作る場所です。家の裏側では、シェフと料理人がキッチンで働き、食器洗い機で片付けを行い、マネージャーは管理作業を行います。</target>
        </trans-unit>
        <trans-unit id="d2fbd57442ab7172a121e226a86228020af2eb14" translate="yes" xml:space="preserve">
          <source>In the second &lt;code&gt;use&lt;/code&gt; statement, we chose the new name &lt;code&gt;IoResult&lt;/code&gt; for the &lt;code&gt;std::io::Result&lt;/code&gt; type, which won&amp;rsquo;t conflict with the &lt;code&gt;Result&lt;/code&gt; from &lt;code&gt;std::fmt&lt;/code&gt; that we&amp;rsquo;ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!</source>
          <target state="translated">2番目の &lt;code&gt;use&lt;/code&gt; ステートメントでは、 &lt;code&gt;std::io::Result&lt;/code&gt; タイプの新しい名前 &lt;code&gt;IoResult&lt;/code&gt; を選択しました。これは、スコープに含めた &lt;code&gt;std::fmt&lt;/code&gt; からの &lt;code&gt;Result&lt;/code&gt; と競合しません。リスト7-15とリスト7-16は慣用的であると考えられているので、選択はあなた次第です！</target>
        </trans-unit>
        <trans-unit id="adc1d9d12c1d2bddf332118061c6c7cd3ce7bb85" translate="yes" xml:space="preserve">
          <source>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&amp;rsquo;t have a variable that contains the actual value of the &lt;code&gt;id&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; field&amp;rsquo;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&amp;rsquo;t know which it is. The pattern code isn&amp;rsquo;t able to use the value from the &lt;code&gt;id&lt;/code&gt; field, because we haven&amp;rsquo;t saved the &lt;code&gt;id&lt;/code&gt; value in a variable.</source>
          <target state="translated">パターンで範囲のみが指定されている2番目のアームでは、アームに関連付けられたコードには、 &lt;code&gt;id&lt;/code&gt; フィールドの実際の値を含む変数がありません。 &lt;code&gt;id&lt;/code&gt; フィールドの値が10、11、または12だったかもしれないが、そのパターンで行くのコードは、それがあるかを知りません。変数に &lt;code&gt;id&lt;/code&gt; 値を保存していないため、パターンコードは &lt;code&gt;id&lt;/code&gt; フィールドの値を使用できません。</target>
        </trans-unit>
        <trans-unit id="555ee2d5bf80e581edd3155ac1632a3804b80f34" translate="yes" xml:space="preserve">
          <source>In the second case, it mentions that a private item &quot;can be accessed&quot; by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</source>
          <target state="translated">2つ目のケースでは、現在のモジュールとその子孫がプライベートアイテムに「アクセスできる」と書いてありますが、アイテムにアクセスする正確な意味は、アイテムが何であるかによって異なります。例えば、モジュールにアクセスするということは、モジュールの中を見ること(より多くのアイテムをインポートすること)を意味します。一方、関数へのアクセスは、関数が呼び出されることを意味します。さらに、パス式やインポート文は、インポート/式が有効なのは、現在の可視性スコープ内に目的地がある場合のみであるという意味で、アイテムへのアクセスとみなされます。</target>
        </trans-unit>
        <trans-unit id="cde08af4b5bbaaf0718281f4cc2fdcf3ef098583" translate="yes" xml:space="preserve">
          <source>In the signature for &lt;code&gt;area&lt;/code&gt;, we use &lt;code&gt;&amp;amp;self&lt;/code&gt; instead of &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; because Rust knows the type of &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Rectangle&lt;/code&gt; due to this method&amp;rsquo;s being inside the &lt;code&gt;impl Rectangle&lt;/code&gt; context. Note that we still need to use the &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt;, just as we did in &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt;. Methods can take ownership of &lt;code&gt;self&lt;/code&gt;, borrow &lt;code&gt;self&lt;/code&gt; immutably as we&amp;rsquo;ve done here, or borrow &lt;code&gt;self&lt;/code&gt; mutably, just as they can any other parameter.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; の署名では、 &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; 代わりに &lt;code&gt;&amp;amp;self&lt;/code&gt; を使用します：＆Rectangleは、Rustがこのメソッドが &lt;code&gt;impl Rectangle&lt;/code&gt; コンテキスト内にあるため、 &lt;code&gt;self&lt;/code&gt; の型が &lt;code&gt;Rectangle&lt;/code&gt; であることを認識しているためです。 &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; と同じように、 &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt; を使用する必要があることに注意してください。メソッドは、 &lt;code&gt;self&lt;/code&gt; の所有権を取得したり、ここで行ったように &lt;code&gt;self&lt;/code&gt; を不変に借用したり、他のパラメーターと同じように &lt;code&gt;self&lt;/code&gt; を可変的に借用したりできます。</target>
        </trans-unit>
        <trans-unit id="b01eb539066ab2d6a68111a77de7d3391be1abdf" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;code&gt;Unpin&lt;/code&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">標準ライブラリでは、ポインタ型には一般に構造的な固定がないため、固定投影は提供されません。これが &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; がすべての &lt;code&gt;T&lt;/code&gt; に対して保持される理由です。移動ので、ポインタ型のためにこれを行うことは理にかなって &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 実際に動かない &lt;code&gt;T&lt;/code&gt; を： &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 別名自由に移動することができ &lt;code&gt;Unpin&lt;/code&gt; しても）、 &lt;code&gt;T&lt;/code&gt; はありません。実際、同じ理由により、 &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; と &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; も常にそれら自体の &lt;code&gt;Unpin&lt;/code&gt; 。それらの内容（ &lt;code&gt;T&lt;/code&gt; ）は固定されますが、固定されたデータを移動せずにポインター自体を移動できます。両方のための &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; および &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 、コンテンツが固定されているかどうかは、ポインターが固定されているかどうかに完全に依存し&lt;em&gt;ません&lt;/em&gt;。つまり、固定は構造的ではあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="69a1bd27469eb2f59075cae2a36951b2f4c30b0e" translate="yes" xml:space="preserve">
          <source>In the test, we&amp;rsquo;re testing what happens when the &lt;code&gt;LimitTracker&lt;/code&gt; is told to set &lt;code&gt;value&lt;/code&gt; to something that is more than 75 percent of the &lt;code&gt;max&lt;/code&gt; value. First, we create a new &lt;code&gt;MockMessenger&lt;/code&gt;, which will start with an empty list of messages. Then we create a new &lt;code&gt;LimitTracker&lt;/code&gt; and give it a reference to the new &lt;code&gt;MockMessenger&lt;/code&gt; and a &lt;code&gt;max&lt;/code&gt; value of 100. We call the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt; with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the &lt;code&gt;MockMessenger&lt;/code&gt; is keeping track of should now have one message in it.</source>
          <target state="translated">このテストでは、 &lt;code&gt;LimitTracker&lt;/code&gt; に &lt;code&gt;value&lt;/code&gt; を &lt;code&gt;max&lt;/code&gt; 値の75％を超える値に設定するように指示されたときに何が起こるかをテストしています。まず、新しい &lt;code&gt;MockMessenger&lt;/code&gt; を作成します。これは、メッセージの空のリストから始まります。その後、我々は新しい作成 &lt;code&gt;LimitTracker&lt;/code&gt; をし、それを新しい参照与える &lt;code&gt;MockMessenger&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; 我々は呼ん100の値 &lt;code&gt;set_value&lt;/code&gt; の方法 &lt;code&gt;LimitTracker&lt;/code&gt; その後、我々が主張100の75％以上である80の値とを、 &lt;code&gt;MockMessenger&lt;/code&gt; が追跡しているメッセージのリストには、1つのメッセージが含まれているはずです。</target>
        </trans-unit>
        <trans-unit id="474cfc53c29ed4a7f5438f6a16ce96a820777966" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">トランスクライバーでは、フラグメントの種類がマッチャーで指定されているため、メタ変数は単に &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt;で参照されます。メタ変数は、それらに一致する構文要素に置き換えられます。キーワードmetavariable &lt;code&gt;$crate&lt;/code&gt; crateを使用して、現在のクレートを参照できます。以下の&lt;a href=&quot;macros-by-example#hygiene&quot;&gt;衛生を&lt;/a&gt;参照してください。メタ変数は、複数回転写することも、まったく転写しないこともできます。</target>
        </trans-unit>
        <trans-unit id="fc28b1beae2c194779de6e426a53754bfb37f82e" translate="yes" xml:space="preserve">
          <source>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don&amp;rsquo;t have: they can capture their environment and access variables from the scope in which they&amp;rsquo;re defined.</source>
          <target state="translated">ワークアウトジェネレーターの例では、インラインの匿名関数としてのみクロージャーを使用しました。ただし、クロージャには関数にはない追加機能があります。つまり、クロージャは環境をキャプチャして、それらが定義されているスコープから変数にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="402986500120f551bc8e41d90bdabaccacec9185" translate="yes" xml:space="preserve">
          <source>In the worst case, the algorithm allocates temporary storage in a &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; the length of the slice.</source>
          <target state="translated">最悪の場合、アルゴリズムは一時ストレージを &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; スライスの長さに割り当てます。</target>
        </trans-unit>
        <trans-unit id="9bc14d5532165c49508408bd484b7e97e6ac2646" translate="yes" xml:space="preserve">
          <source>In this appendix, we provide a reference of all the traits in the standard library that you can use with &lt;code&gt;derive&lt;/code&gt;. Each section covers:</source>
          <target state="translated">この付録では、deriveで使用できる標準ライブラリのすべての特性のリファレンスを提供し &lt;code&gt;derive&lt;/code&gt; 。各セクションは以下をカバーします</target>
        </trans-unit>
        <trans-unit id="0046a6cf07943993e17ce12f3c78298391a2264f" translate="yes" xml:space="preserve">
          <source>In this appendix, we talk about some useful development tools that the Rust project provides. We&amp;rsquo;ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</source>
          <target state="translated">この付録では、Rustプロジェクトが提供するいくつかの便利な開発ツールについて説明します。自動フォーマット、警告修正を適用する簡単な方法、リンター、およびIDEとの統合について見ていきます。</target>
        </trans-unit>
        <trans-unit id="ac9b1080783742689a97db16c3344339516e90c0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo&lt;/code&gt; is undefined, so it inherently isn't anything, and definitely not a struct.</source>
          <target state="translated">この場合、 &lt;code&gt;Foo&lt;/code&gt; は未定義であるため、本質的に何もありません。構造体でもありません。</target>
        </trans-unit>
        <trans-unit id="afe608724d7fcb6b165ca3da57f4af8c6e2f8834" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Question&lt;/code&gt; would need to implement the &lt;code&gt;std::ops::Not&lt;/code&gt; trait in order to be able to use &lt;code&gt;!&lt;/code&gt; on it. Let's implement it:</source>
          <target state="translated">この場合、 &lt;code&gt;Question&lt;/code&gt; は、使用できるように &lt;code&gt;std::ops::Not&lt;/code&gt; トレイトを実装する必要があります &lt;code&gt;!&lt;/code&gt; その上に。それを実装しましょう：</target>
        </trans-unit>
        <trans-unit id="f3b4ba6190447ccb2a7d84efd7c0391f36cf1b3c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;foo&lt;/code&gt; is defined, but is not a struct, so Rust can't use it as one.</source>
          <target state="translated">この場合、 &lt;code&gt;foo&lt;/code&gt; は定義されていますが、構造体ではないため、Rustはそれを1つとして使用できません。</target>
        </trans-unit>
        <trans-unit id="e3897adfb1b49645b05c0b83e391e1fc19ac894e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;len&lt;/code&gt; will be 4, which means the vector storing the string &amp;ldquo;Hola&amp;rdquo; is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</source>
          <target state="translated">この場合、 &lt;code&gt;len&lt;/code&gt; は4になります。これは、文字列「Hola」を格納するベクトルが4バイト長であることを意味します。これらの各文字は、UTF-8でエンコードされると1バイトを使用します。しかし、次の行はどうですか？ （この文字列はアラビア数字3ではなく、大文字のキリル文字Zeで始まることに注意してください。）</target>
        </trans-unit>
        <trans-unit id="8561b972a9830d06a3e257ff13fef28acb8d1808" translate="yes" xml:space="preserve">
          <source>In this case, borrowing &lt;code&gt;x&lt;/code&gt; mutably is not possible, because &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;mut&lt;/code&gt;. But at the same time, borrowing &lt;code&gt;x&lt;/code&gt; immutably would make the assignment illegal, because a &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; reference may not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows &lt;code&gt;x&lt;/code&gt; immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of &lt;code&gt;y&lt;/code&gt; will produce an error because it would violate the uniqueness of the closure's borrow of &lt;code&gt;x&lt;/code&gt;; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.</source>
          <target state="translated">この場合、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;mut&lt;/code&gt; ではないため、 &lt;code&gt;x&lt;/code&gt; を可変に借用することはできません。ただし、同時に &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; 参照は一意ではない可能性があるため、 &lt;code&gt;x&lt;/code&gt; を不変に借用すると割り当てが不正になります。そのため、値を変更するために安全に使用することはできません。したがって、固有の不変の借用が使用されます。これは &lt;code&gt;x&lt;/code&gt; を不変に借用しますが、可変の借用と同様に、一意でなければなりません。上記の例では、 &lt;code&gt;y&lt;/code&gt; の宣言のコメントを外すとエラーが発生します。これは、クロージャーによる &lt;code&gt;x&lt;/code&gt; の借用の一意性に違反するためです。 zの宣言は有効です。なぜなら、クロージャーの存続期間はブロックの終わりに期限切れになり、借用を解放するからです。</target>
        </trans-unit>
        <trans-unit id="bf5da830ba52c31b3f48f71542b74085fca253da" translate="yes" xml:space="preserve">
          <source>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren&amp;rsquo;t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</source>
          <target state="translated">この場合、参照サイクルを作成した直後にプログラムが終了します。このサイクルの結果はそれほど悲惨ではありません。ただし、より複雑なプログラムがサイクルで大量のメモリを割り当て、長時間保持すると、プログラムは必要以上のメモリを使用し、システムに負荷をかけ、使用可能なメモリが不足する可能性があります。</target>
        </trans-unit>
        <trans-unit id="94ade146c6864efc0d837c6a05c5b82eb67849f1" translate="yes" xml:space="preserve">
          <source>In this case, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">この場合、コンパイラは、の種類どのような推測することはできません &lt;code&gt;x&lt;/code&gt; は次のようになります。 &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; の両方に適した候補です。使用するタイプを指定するには、 &lt;code&gt;x&lt;/code&gt; でタイプアノテーションを使用できます。</target>
        </trans-unit>
        <trans-unit id="f275640cc613a55c1aac0d980097965aad345a42" translate="yes" xml:space="preserve">
          <source>In this case, the line indicated is part of our code, and if we go to that line, we see the &lt;code&gt;panic!&lt;/code&gt; macro call. In other cases, the &lt;code&gt;panic!&lt;/code&gt; call might be in code that our code calls, and the filename and line number reported by the error message will be someone else&amp;rsquo;s code where the &lt;code&gt;panic!&lt;/code&gt; macro is called, not the line of our code that eventually led to the &lt;code&gt;panic!&lt;/code&gt; call. We can use the backtrace of the functions the &lt;code&gt;panic!&lt;/code&gt; call came from to figure out the part of our code that is causing the problem. We&amp;rsquo;ll discuss what a backtrace is in more detail next.</source>
          <target state="translated">この場合、示された行はコードの一部であり、その行に移動すると &lt;code&gt;panic!&lt;/code&gt; マクロ呼び出し。他の場合では、 &lt;code&gt;panic!&lt;/code&gt; callは、コードが呼び出すコード内にある場合があり、エラーメッセージによって報告されるファイル名と行番号は、 &lt;code&gt;panic!&lt;/code&gt; が発生した他の誰かのコードになります。マクロが呼び出され、最終的に &lt;code&gt;panic!&lt;/code&gt; コード行ではありません！コール。 &lt;code&gt;panic!&lt;/code&gt; の関数のバックトレースを使用できます！問題の原因となっているコードの部分を特定するための呼び出しが来ました。次に、バックトレースについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="8dfdeb564b13d0de24ae4a70c8a6c9f64176934b" translate="yes" xml:space="preserve">
          <source>In this chapter and throughout the book, we&amp;rsquo;ll show some commands used in the terminal. Lines that you should enter in a terminal all start with &lt;code&gt;$&lt;/code&gt;. You don&amp;rsquo;t need to type in the &lt;code&gt;$&lt;/code&gt; character; it indicates the start of each command. Lines that don&amp;rsquo;t start with &lt;code&gt;$&lt;/code&gt; typically show the output of the previous command. Additionally, PowerShell-specific examples will use &lt;code&gt;&amp;gt;&lt;/code&gt; rather than &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">この章と本全体を通して、ターミナルで使用されるいくつかのコマンドを示します。端末に入力する必要がある行はすべて &lt;code&gt;$&lt;/code&gt; で始まります。 &lt;code&gt;$&lt;/code&gt; 文字を入力する必要はありません。各コマンドの開始を示します。 &lt;code&gt;$&lt;/code&gt; で始まらない行は通常、前のコマンドの出力を示します。さらに、PowerShell固有の例では、 &lt;code&gt;$&lt;/code&gt; ではなく &lt;code&gt;&amp;gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="511940d9b79e52eebc6c566f728bbaeb0dd1dd34" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible values. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">この章では、我々は見てみましょう&lt;em&gt;列挙&lt;/em&gt;とも呼ばれる、&lt;em&gt;列挙型&lt;/em&gt;。列挙型を使用すると、可能な値を列挙してタイプを定義できます。まず、列挙型を定義して使用し、列挙型がデータとともに意味をエンコードする方法を示します。次に、値が何かまたは何もない場合があることを表す &lt;code&gt;Option&lt;/code&gt; と呼ばれる特に有用な列挙型について説明します。次に、 &lt;code&gt;match&lt;/code&gt; 式でのパターンマッチングにより、列挙型のさまざまな値に対してさまざまなコードを簡単に実行できる方法を見ていきます。最後に、 &lt;code&gt;if let&lt;/code&gt; 構文が、コード内の列挙型を処理するために利用できるもう1つの便利で簡潔なイディオムである方法について説明します。</target>
        </trans-unit>
        <trans-unit id="54bfe40f65e4baf089b3fdf58b27393a8784f4c8" translate="yes" xml:space="preserve">
          <source>In this chapter, we won&amp;rsquo;t debate the issue of what functional programming is or isn&amp;rsquo;t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</source>
          <target state="translated">この章では、関数型プログラミングの問題については議論しませんが、関数型と呼ばれることが多い多くの言語の機能に類似したRustのいくつかの機能について説明します。</target>
        </trans-unit>
        <trans-unit id="1a7486659e0b2248f370c5b62acbfa92d0246aa8" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!</source>
          <target state="translated">この章では、これらの機能をすべてカバーし、それらがどのように相互作用するかを説明し、それらを使用してスコープを管理する方法を説明します。最終的には、モジュールシステムをしっかりと理解し、プロのようなスコープで作業できるようになるはずです。</target>
        </trans-unit>
        <trans-unit id="323ae7b14fd96e68551f003142bf4b84170544d5" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover:</source>
          <target state="translated">この章では、以下について説明します。</target>
        </trans-unit>
        <trans-unit id="a4639a7fb71c7cc2724cbe31da70376d99c56baa" translate="yes" xml:space="preserve">
          <source>In this code, the first and last value are matched with &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;. The &lt;code&gt;..&lt;/code&gt; will match and ignore everything in the middle.</source>
          <target state="translated">このコードでは、最初と最後の値が &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;last&lt;/code&gt; と一致します。 &lt;code&gt;..&lt;/code&gt; .一致と真ん中のすべてを無視します。</target>
        </trans-unit>
        <trans-unit id="145a83e849a55e3baebf66ad497473ddcd7f5f55" translate="yes" xml:space="preserve">
          <source>In this code, the same thing happens as in the &lt;code&gt;match&lt;/code&gt; in Listing 19-26: Rust sees that &lt;code&gt;val&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;panic!&lt;/code&gt; has the type &lt;code&gt;!&lt;/code&gt;, so the result of the overall &lt;code&gt;match&lt;/code&gt; expression is &lt;code&gt;T&lt;/code&gt;. This code works because &lt;code&gt;panic!&lt;/code&gt; doesn&amp;rsquo;t produce a value; it ends the program. In the &lt;code&gt;None&lt;/code&gt; case, we won&amp;rsquo;t be returning a value from &lt;code&gt;unwrap&lt;/code&gt;, so this code is valid.</source>
          <target state="translated">このコードでは、リスト19-26 の &lt;code&gt;match&lt;/code&gt; と同じことが起こります。Rustは、 &lt;code&gt;val&lt;/code&gt; の型が &lt;code&gt;T&lt;/code&gt; であり、 &lt;code&gt;panic!&lt;/code&gt; タイプがあり &lt;code&gt;!&lt;/code&gt; なので、全体的な &lt;code&gt;match&lt;/code&gt; 式の結果は &lt;code&gt;T&lt;/code&gt; です。このコードは &lt;code&gt;panic!&lt;/code&gt; から機能します！値を生成しません。プログラムを終了します。では &lt;code&gt;None&lt;/code&gt; の場合、我々はから値を返すことはありません &lt;code&gt;unwrap&lt;/code&gt; ので、このコードは有効です。</target>
        </trans-unit>
        <trans-unit id="4f5f63902ac52a2fdb77ae9b0aaf168362307239" translate="yes" xml:space="preserve">
          <source>In this context, by &lt;em&gt;runtime&lt;/em&gt; we mean code that is included by the language in every binary. This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code. For that reason, colloquially when people say a language has &amp;ldquo;no runtime,&amp;rdquo; they often mean &amp;ldquo;small runtime.&amp;rdquo; Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts. Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</source>
          <target state="translated">この文脈では、&lt;em&gt;ランタイム&lt;/em&gt;とは、言語によってすべてのバイナリに含まれるコードを意味します。このコードは、言語に応じて大きくなる場合と小さくなる場合がありますが、すべての非アセンブリ言語には、ある程度のランタイムコードが含まれます。そのため、口語的に、ある言語に「ランタイムがない」と言われる場合、それらはしばしば「小さなランタイム」を意味します。ランタイムが小さいほど機能は少なくなりますが、バイナリが小さくなるという利点があり、より多くのコンテキストで言語を他の言語と組み合わせるのが容易になります。より多くの機能と引き換えにランタイムサイズを大きくしても多くの言語は問題ありませんが、Rustはランタイムをほとんど必要とせず、パフォーマンスを維持するためにCを呼び出すことができることについて妥協することはできません。</target>
        </trans-unit>
        <trans-unit id="8e0ee0316ee57e8497270b5ce77464ecb56adca2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Cat&lt;/code&gt; is a &lt;em&gt;struct-like enum variant&lt;/em&gt;, whereas &lt;code&gt;Dog&lt;/code&gt; is simply called an enum variant. Each enum instance has a &lt;em&gt;discriminant&lt;/em&gt; which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt;&lt;code&gt;mem::discriminant&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">この例では、 &lt;code&gt;Cat&lt;/code&gt; は&lt;em&gt;構造体のような列挙型バリアントです&lt;/em&gt;が、 &lt;code&gt;Dog&lt;/code&gt; は単に列挙型バリアントと呼ばれます。各列挙型インスタンスには、それに関連する整数である&lt;em&gt;判別式&lt;/em&gt;があり、どのバリアントを保持するかを決定するために使用されます。この判別式への不透明な参照は、&lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt; &lt;code&gt;mem::discriminant&lt;/code&gt; &lt;/a&gt;関数で取得できます。</target>
        </trans-unit>
        <trans-unit id="7bb9799e70052b9e454a954f47a55d73983d300f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Foo&lt;/code&gt; defines an associated type &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;Bar&lt;/code&gt; inherits that type from &lt;code&gt;Foo&lt;/code&gt;, and defines another associated type of the same name. As a result, when we attempt to use &lt;code&gt;Self::A&lt;/code&gt;, it's ambiguous whether we mean the &lt;code&gt;A&lt;/code&gt; defined by &lt;code&gt;Foo&lt;/code&gt; or the one defined by &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;Foo&lt;/code&gt; は関連するタイプ &lt;code&gt;A&lt;/code&gt; を定義しています。 &lt;code&gt;Bar&lt;/code&gt; はそのタイプを &lt;code&gt;Foo&lt;/code&gt; から継承し、同じ名前の別の関連タイプを定義します。その結果、 &lt;code&gt;Self::A&lt;/code&gt; を使用しようとすると、 &lt;code&gt;Foo&lt;/code&gt; によって定義された &lt;code&gt;A&lt;/code&gt; を意味するのか、 &lt;code&gt;Bar&lt;/code&gt; によって定義されたAを意味するのかが曖昧になります。</target>
        </trans-unit>
        <trans-unit id="ea4ed47b5eac4878ae970fa360382b182707dcb9" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;string1&lt;/code&gt; is valid until the end of the outer scope, &lt;code&gt;string2&lt;/code&gt; is valid until the end of the inner scope, and &lt;code&gt;result&lt;/code&gt; references something that is valid until the end of the inner scope. Run this code, and you&amp;rsquo;ll see that the borrow checker approves of this code; it will compile and print &lt;code&gt;The longest string is long string is long&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;string1&lt;/code&gt; は外部スコープの終わりまで有効であり、 &lt;code&gt;string2&lt;/code&gt; は内部スコープの終わりまで有効であり、 &lt;code&gt;result&lt;/code&gt; は内部スコープの終わりまで有効なものを参照します。このコードを実行すると、借用チェッカーがこのコードを承認することがわかります。コンパイルして出力します &lt;code&gt;The longest string is long string is long&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9a21a4f7cf44738665bcf722c117e87d97dd2b44" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;value&lt;/code&gt; is mutably borrowed by &lt;code&gt;borrow&lt;/code&gt; and cannot be used to calculate &lt;code&gt;sum&lt;/code&gt;. This is not possible because this would violate Rust's mutability rules.</source>
          <target state="translated">この例では、 &lt;code&gt;value&lt;/code&gt; mutablyによって借用され &lt;code&gt;borrow&lt;/code&gt; と計算するために使用することができない &lt;code&gt;sum&lt;/code&gt; 。これは、Rustの可変性ルールに違反するため、不可能です。</target>
        </trans-unit>
        <trans-unit id="ee5fd415a36736dbb42604438d3e115f3ef63293" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;x&lt;/code&gt; matches the pattern &lt;code&gt;(0, _)&lt;/code&gt;, the second field is set to &lt;code&gt;y&lt;/code&gt;. If it matches &lt;code&gt;(_, 0)&lt;/code&gt;, the first field is set to &lt;code&gt;y&lt;/code&gt;; so in all cases &lt;code&gt;y&lt;/code&gt; is set to some value.</source>
          <target state="translated">この例では、 &lt;code&gt;x&lt;/code&gt; がパターン &lt;code&gt;(0, _)&lt;/code&gt; に一致する場合、2番目のフィールドは &lt;code&gt;y&lt;/code&gt; に設定されます。 &lt;code&gt;(_, 0)&lt;/code&gt; に一致する場合、最初のフィールドは &lt;code&gt;y&lt;/code&gt; に設定されます。したがって、すべての場合において、 &lt;code&gt;y&lt;/code&gt; はある値に設定されます。</target>
        </trans-unit>
        <trans-unit id="7fe9cc71a505a06c66b5d9f57153a2d3327a9165" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;'SnowWhite&lt;/code&gt; lifetime is supposed to outlive the &lt;code&gt;'kiss&lt;/code&gt; lifetime but the declaration of the &lt;code&gt;Prince&lt;/code&gt; struct doesn't enforce it. To fix this issue, you need to specify it:</source>
          <target state="translated">この例では、 &lt;code&gt;'SnowWhite&lt;/code&gt; ライフタイムは &lt;code&gt;'kiss&lt;/code&gt; ライフタイムよりも長くなるはずですが、 &lt;code&gt;Prince&lt;/code&gt; 構造体の宣言はそれを強制しません。この問題を修正するには、次のように指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c61f98e2cee2baaabf8be1956ffb960bd279fb24" translate="yes" xml:space="preserve">
          <source>In this example, the module &lt;code&gt;quux&lt;/code&gt; re-exports two public names defined in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">この例では、モジュール &lt;code&gt;quux&lt;/code&gt; は &lt;code&gt;foo&lt;/code&gt; で定義された2つのパブリック名を再エクスポートします。</target>
        </trans-unit>
        <trans-unit id="4350bf464e116b6d57c761b20a820cb5925c37d3" translate="yes" xml:space="preserve">
          <source>In this example, the spawned thread is &quot;detached&quot; from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.</source>
          <target state="translated">この例では、スポーンされたスレッドは現在のスレッドから「切り離された」状態になっています。これは、この親がメインスレッドでない限り、そのスレッドは親 (それをスポーンしたスレッド)よりも長生きする可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="adb1f627c4f5f533a368664ad1bfd6b52635fef6" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Foo&lt;/code&gt; and the trait method &lt;code&gt;do_something_else&lt;/code&gt; both define a type parameter &lt;code&gt;T&lt;/code&gt;. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</source>
          <target state="translated">この例では、特性 &lt;code&gt;Foo&lt;/code&gt; と特性メソッド &lt;code&gt;do_something_else&lt;/code&gt; の両方が型パラメーター &lt;code&gt;T&lt;/code&gt; を定義しています。これは許可されていません。メソッドが型パラメーターを定義する場合は、別の名前を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5106de7dace445aa59aa82effd4989b6c9358ae0" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Printable&lt;/code&gt; occurs as a trait object in both the type signature of &lt;code&gt;print&lt;/code&gt;, and the cast expression in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">この例では、特性 &lt;code&gt;Printable&lt;/code&gt; は、 &lt;code&gt;print&lt;/code&gt; の型シグネチャと &lt;code&gt;main&lt;/code&gt; のキャスト式の両方で特性オブジェクトとして発生します。</target>
        </trans-unit>
        <trans-unit id="2c7b2451157bfe66dfc5ae3bcc7df818cb052f87" translate="yes" xml:space="preserve">
          <source>In this example, the value &lt;code&gt;p&lt;/code&gt; matches the second arm by virtue of &lt;code&gt;x&lt;/code&gt; containing a 0, so this code will print &lt;code&gt;On the y axis at 7&lt;/code&gt;.</source>
          <target state="translated">この例では、値 &lt;code&gt;p&lt;/code&gt; は、0を含む &lt;code&gt;x&lt;/code&gt; によって2番目のアームと一致するため、このコードは &lt;code&gt;On the y axis at 7&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="76e376bb135f5c25de32c031f91a381023081f30" translate="yes" xml:space="preserve">
          <source>In this example, the variable named &lt;code&gt;first&lt;/code&gt; will get the value &lt;code&gt;1&lt;/code&gt;, because that is the value at index &lt;code&gt;[0]&lt;/code&gt; in the array. The variable named &lt;code&gt;second&lt;/code&gt; will get the value &lt;code&gt;2&lt;/code&gt; from index &lt;code&gt;[1]&lt;/code&gt; in the array.</source>
          <target state="translated">この例では、 &lt;code&gt;first&lt;/code&gt; という名前の変数は値 &lt;code&gt;1&lt;/code&gt; を取得します。これは、配列のインデックス &lt;code&gt;[0]&lt;/code&gt; の値だからです。 &lt;code&gt;second&lt;/code&gt; という名前の変数は、配列のインデックス &lt;code&gt;[1]&lt;/code&gt; から値 &lt;code&gt;2&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="db1c89f552fe6cd5046ff6bd0d230e80deb004f6" translate="yes" xml:space="preserve">
          <source>In this example, we are asserting that the destructor for &lt;code&gt;Foo&lt;/code&gt; will not access any data of type &lt;code&gt;X&lt;/code&gt;, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this &lt;code&gt;impl&lt;/code&gt; as unsafe.</source>
          <target state="translated">この例では、 &lt;code&gt;Foo&lt;/code&gt; のデストラクタがタイプ &lt;code&gt;X&lt;/code&gt; のデータにアクセスせず、プログラムの全体的な安全性のためにこのアサーションがtrueである必要があることをアサートしています。コンパイラーは現在、このアサーションの検証を試みていません。したがって、この &lt;code&gt;impl&lt;/code&gt; は安全でないタグを付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="5b639017ef60ffaf0981282e4da6c27fcdd578e1" translate="yes" xml:space="preserve">
          <source>In this example, we define a function &lt;code&gt;ten_times&lt;/code&gt; that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.</source>
          <target state="translated">この例では、高次の関数引数をとる関数 &lt;code&gt;ten_times&lt;/code&gt; を定義し、クロージャ式を引数として呼び出し、その後に環境から値を移動するクロージャ式を続けます。</target>
        </trans-unit>
        <trans-unit id="0bbce52117883bf5718cfbbb01cfe64f9309a2ae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the parameter &lt;code&gt;x&lt;/code&gt; and the return type, but not for the parameter &lt;code&gt;y&lt;/code&gt;, because the lifetime of &lt;code&gt;y&lt;/code&gt; does not have any relationship with the lifetime of &lt;code&gt;x&lt;/code&gt; or the return value.</source>
          <target state="translated">この例では、パラメーター &lt;code&gt;x&lt;/code&gt; と戻り値の型に有効期間パラメーター &lt;code&gt;'a&lt;/code&gt; を指定していますが、パラメーター &lt;code&gt;y&lt;/code&gt; には指定していません。これは、 &lt;code&gt;y&lt;/code&gt; の有効期間が &lt;code&gt;x&lt;/code&gt; の有効期間または戻り値と関係がないためです。</target>
        </trans-unit>
        <trans-unit id="2185efdb59ae63a632adf24d45f191ffee2411df" translate="yes" xml:space="preserve">
          <source>In this example, when we assign the integer value 5 to &lt;code&gt;x&lt;/code&gt;, we let the compiler know that the generic type &lt;code&gt;T&lt;/code&gt; will be an integer for this instance of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. Then when we specify 4.0 for &lt;code&gt;y&lt;/code&gt;, which we&amp;rsquo;ve defined to have the same type as &lt;code&gt;x&lt;/code&gt;, we&amp;rsquo;ll get a type mismatch error like this:</source>
          <target state="translated">この例では、整数値5を &lt;code&gt;x&lt;/code&gt; に割り当てると、ジェネリック型 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; このインスタンスの整数になることをコンパイラーに知らせます。次に、 &lt;code&gt;x&lt;/code&gt; と同じ型を持つように定義した &lt;code&gt;y&lt;/code&gt; に4.0を指定すると、次のような型の不一致エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="af5f4c7efbea71694085e036fb3fca287f7c1342" translate="yes" xml:space="preserve">
          <source>In this example, you can see that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; enables mutation inside an immutable struct. In other words, it enables &quot;interior mutability&quot;.</source>
          <target state="translated">この例では、 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; が不変の構造体内の突然変異を有効にしていることがわかります。つまり、「内部の可変性」を可能にします。</target>
        </trans-unit>
        <trans-unit id="28ad91d98b4c69b8725ca2927cbfaca53b3c5e8d" translate="yes" xml:space="preserve">
          <source>In this implementation, the &lt;code&gt;to_string&lt;/code&gt; method panics if the &lt;code&gt;Display&lt;/code&gt; implementation returns an error. This indicates an incorrect &lt;code&gt;Display&lt;/code&gt; implementation since &lt;code&gt;fmt::Write for String&lt;/code&gt; never returns an error itself.</source>
          <target state="translated">この実装では、 &lt;code&gt;Display&lt;/code&gt; 実装がエラーを返すと、 &lt;code&gt;to_string&lt;/code&gt; メソッドがパニックになります。 &lt;code&gt;fmt::Write for String&lt;/code&gt; エラー自体を返すことはないため、これは &lt;code&gt;Display&lt;/code&gt; の実装が正しくないことを示しています。</target>
        </trans-unit>
        <trans-unit id="7cf45f5e676953372bb64ede268b0f879c84bec0" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;not enough arguments&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">このリストでは、これまでカバーしていないメソッド &lt;code&gt;unwrap_or_else&lt;/code&gt; を使用しました。これは、標準ライブラリによって &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 定義されています。使用 &lt;code&gt;unwrap_or_else&lt;/code&gt; は、私たちはいくつかのカスタム、非定義することができます &lt;code&gt;panic!&lt;/code&gt; エラー処理。場合は &lt;code&gt;Result&lt;/code&gt; ある &lt;code&gt;Ok&lt;/code&gt; 値、このメソッドの動作は次のようにある &lt;code&gt;unwrap&lt;/code&gt; ：それは内側の値を返します &lt;code&gt;Ok&lt;/code&gt; ラッピングされています。ただし、値が &lt;code&gt;Err&lt;/code&gt; 値である場合、このメソッドは、私たちが定義して &lt;code&gt;unwrap_or_else&lt;/code&gt; に引数として渡す無名関数である、&lt;em&gt;クロージャ&lt;/em&gt;内のコードを呼び出します。クロージャーについては、&lt;a href=&quot;ch13-00-functional-features&quot;&gt;第13章&lt;/a&gt;。ここでは、 &lt;code&gt;unwrap_or_else&lt;/code&gt; が &lt;code&gt;Err&lt;/code&gt; の内部値（この場合は、リスト12-9で追加した &lt;code&gt;not enough arguments&lt;/code&gt; ではない静的文字列）を、間にある引数 &lt;code&gt;err&lt;/code&gt; のクロージャに渡すことを知っているだけで十分です。垂直パイプ。クロージャー内のコードは、実行時に &lt;code&gt;err&lt;/code&gt; 値を使用できます。</target>
        </trans-unit>
        <trans-unit id="bd1efd0f88f5695bb09cde72e8a0904d7ad1c207" translate="yes" xml:space="preserve">
          <source>In this more complex example, we use &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;.debug_set()&lt;/code&gt; to build a list of match arms:</source>
          <target state="translated">このより複雑な例では、&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;を使用します！および &lt;code&gt;.debug_set()&lt;/code&gt; を使用して、マッチアームのリストを作成します。</target>
        </trans-unit>
        <trans-unit id="b03c6712fd2fec1eec14a91751691024a72c4d16" translate="yes" xml:space="preserve">
          <source>In this next example, &lt;code&gt;init_after_if&lt;/code&gt; is initialized after the &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt; expression&lt;/a&gt; while &lt;code&gt;uninit_after_if&lt;/code&gt; is not because it is not initialized in the &lt;code&gt;else&lt;/code&gt; case.</source>
          <target state="translated">この次の例では、 &lt;code&gt;init_after_if&lt;/code&gt; 後に初期化される&lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; の式&lt;/a&gt;ながら &lt;code&gt;uninit_after_if&lt;/code&gt; はそれがで初期化されていないためではない &lt;code&gt;else&lt;/code&gt; 場合。</target>
        </trans-unit>
        <trans-unit id="8c69b4c18cf4fe1c7e28ef21ab7b9243778f0c95" translate="yes" xml:space="preserve">
          <source>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</source>
          <target state="translated">このプロセスにおいて、コンパイラはリスト10-5でジェネリック関数を作成するために使用したステップとは逆のことを行います:コンパイラはジェネリックコードが呼び出されるすべての場所を見て、ジェネリックコードが呼び出される具体的な型のためのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="9b2eecf1196adab0e0b7bc0dd52bfa9ea4118939" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll add the searching logic to the &lt;code&gt;minigrep&lt;/code&gt; program by using the Test-driven development (TDD) process. This software development technique follows these steps:</source>
          <target state="translated">このセクションでは、テスト駆動開発（TDD）プロセスを使用して、検索ロジックを &lt;code&gt;minigrep&lt;/code&gt; プログラムに追加します。このソフトウェア開発手法は次の手順に従います。</target>
        </trans-unit>
        <trans-unit id="35594ca80fb0c4ca7018f39776903a474d1cfb0f" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll talk about modules and other parts of the module system, namely &lt;em&gt;paths&lt;/em&gt; that allow you to name items; the &lt;code&gt;use&lt;/code&gt; keyword that brings a path into scope; and the &lt;code&gt;pub&lt;/code&gt; keyword to make items public. We&amp;rsquo;ll also discuss the &lt;code&gt;as&lt;/code&gt; keyword, external packages, and the glob operator. For now, let&amp;rsquo;s focus on modules!</source>
          <target state="translated">このセクションでは、モジュールおよびモジュールシステムの他の部分、つまりアイテムに名前を付けることができる&lt;em&gt;パス&lt;/em&gt;について説明します。 &lt;code&gt;use&lt;/code&gt; 範囲にパスをもたらしキーワード。そして、 &lt;code&gt;pub&lt;/code&gt; キーワードは、アイテムを公開することにします。また、 &lt;code&gt;as&lt;/code&gt; キーワード、外部パッケージ、およびglob演算子についても説明します。とりあえず、モジュールに焦点を当てましょう！</target>
        </trans-unit>
        <trans-unit id="b9ddbf2b08f89e10bfeee4884b118c18fb0ff1c3" translate="yes" xml:space="preserve">
          <source>In this situation, even the &lt;code&gt;ref&lt;/code&gt; keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</source>
          <target state="translated">この場合、借りたコンテンツは移動できないため、 &lt;code&gt;ref&lt;/code&gt; キーワードでも解決できません。この問題は一般的には解決できません。値を複製できる場合は、それほど具体的な解決策はありません。</target>
        </trans-unit>
        <trans-unit id="66f6d7f6d5b6dce217f5225ca67e0e2ff88fca0a" translate="yes" xml:space="preserve">
          <source>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for &lt;em&gt;all&lt;/em&gt; possible types, so &lt;code&gt;transmute()&lt;/code&gt; simply only accepts types without any unsubstituted type parameters.</source>
          <target state="translated">この特定のケースでは、変換が無害である可能性が高くなります（ただし、Rustはこれを保証しません）。ただし、配置と列挙型の最適化が問題になると、サイズが異なる型パラメーターの置換と一致する場合と一致しない場合があります。これを&lt;em&gt;すべての&lt;/em&gt;可能な型についてチェックすることは不可能であるため、 &lt;code&gt;transmute()&lt;/code&gt; は、置換されていない型パラメーターのない型のみを受け入れます。</target>
        </trans-unit>
        <trans-unit id="fe9b2052803d3d7b3dd78aa5085c8137d21478b8" translate="yes" xml:space="preserve">
          <source>In this suggestion, &amp;ldquo;indirection&amp;rdquo; means that instead of storing a value directly, we&amp;rsquo;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</source>
          <target state="translated">この提案では、「間接参照」とは、値を直接格納する代わりに、データ構造を変更して、値へのポインターを格納することにより、値を間接的に格納することを意味します。</target>
        </trans-unit>
        <trans-unit id="ace1483441c50f77553551974f43198070533a0e" translate="yes" xml:space="preserve">
          <source>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</source>
          <target state="translated">このように、式の構造が実行の構造を規定します。ブロックは単なる別の種類の式なので、ブロック、ステートメント、式、および再びブロックは、任意の深さまでお互いの内部に再帰的にネストすることができます。</target>
        </trans-unit>
        <trans-unit id="2f60575dd030bfd74d0c69219e41591057c41df3" translate="yes" xml:space="preserve">
          <source>In trait declarations as &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt;: &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; is equivalent to &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/traits#supertraits&quot;&gt;スーパー&lt;/a&gt;トレイトとしてのトレイト宣言： &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; は、 &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="a4f93075a116db72d1570a79e9e24585b192c4ef" translate="yes" xml:space="preserve">
          <source>In trait declarations as bounds on &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;associated types&lt;/a&gt;: &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; is equivalent to &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/associated-items#associated-types&quot;&gt;関連する型の&lt;/a&gt;境界としての特性宣言： &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; は &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt; と同じです。Self:: B：Copy {type B; }。</target>
        </trans-unit>
        <trans-unit id="31d52c1f8837d60baebd5fe1bd8acd4770d12408" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses.</source>
          <target state="translated">タイプでは、 &lt;code&gt;+&lt;/code&gt; タイプの演算子の優先順位が低いため、括弧を使用する必要があることがよくあります。</target>
        </trans-unit>
        <trans-unit id="cd1daf40491a926084464e0388144e6ba829d637" translate="yes" xml:space="preserve">
          <source>In various places in the book, we&amp;rsquo;ve discussed the &lt;code&gt;derive&lt;/code&gt; attribute, which you can apply to a struct or enum definition. The &lt;code&gt;derive&lt;/code&gt; attribute generates code that will implement a trait with its own default implementation on the type you&amp;rsquo;ve annotated with the &lt;code&gt;derive&lt;/code&gt; syntax.</source>
          <target state="translated">本のさまざまな場所で、構造体または列挙型の定義に適用できる &lt;code&gt;derive&lt;/code&gt; 属性について説明しました。 &lt;code&gt;derive&lt;/code&gt; 属性は、あなたと注釈を付けてきたタイプで、独自のデフォルトの実装でトレイトを実装するコードを生成 &lt;code&gt;derive&lt;/code&gt; 構文を。</target>
        </trans-unit>
        <trans-unit id="42e257e75b3e4fa6d9e9989f973afa801a9a03f0" translate="yes" xml:space="preserve">
          <source>Includes a file as a reference to a byte array.</source>
          <target state="translated">バイト配列への参照としてファイルを含む。</target>
        </trans-unit>
        <trans-unit id="9c140715e3185328a980b4bc60a18b0febc51520" translate="yes" xml:space="preserve">
          <source>Includes a utf8-encoded file as a string.</source>
          <target state="translated">utf8エンコードされたファイルを文字列として含みます。</target>
        </trans-unit>
        <trans-unit id="0c11e0c644b5890be96bab7620a548663254f1f7" translate="yes" xml:space="preserve">
          <source>Includes all extension traits, and some important type definitions.</source>
          <target state="translated">すべての拡張形質と、いくつかの重要な型定義を含む。</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="805a014cffe854e2c811b260ab089d2eda0bbeb7" translate="yes" xml:space="preserve">
          <source>Incoming::all</source>
          <target state="translated">Incoming::all</target>
        </trans-unit>
        <trans-unit id="83bd443d175b9e89de0c8b8872961ea2816dcfb6" translate="yes" xml:space="preserve">
          <source>Incoming::any</source>
          <target state="translated">Incoming::any</target>
        </trans-unit>
        <trans-unit id="f9822b9a823019e577bdfe3ac98493f3aa60473c" translate="yes" xml:space="preserve">
          <source>Incoming::borrow</source>
          <target state="translated">Incoming::borrow</target>
        </trans-unit>
        <trans-unit id="db57c16634c0af16618401e02b9b1b14cfb90675" translate="yes" xml:space="preserve">
          <source>Incoming::borrow_mut</source>
          <target state="translated">Incoming::borrow_mut</target>
        </trans-unit>
        <trans-unit id="909a090d9b0ea3ec427658ae73388b50d4bfbc1f" translate="yes" xml:space="preserve">
          <source>Incoming::by_ref</source>
          <target state="translated">Incoming::by_ref</target>
        </trans-unit>
        <trans-unit id="6d7e9108e413d8a837bb790d96b999eaae29b3f2" translate="yes" xml:space="preserve">
          <source>Incoming::chain</source>
          <target state="translated">Incoming::chain</target>
        </trans-unit>
        <trans-unit id="30254dbd6651bc8d2ce9a6489cb59513c462d366" translate="yes" xml:space="preserve">
          <source>Incoming::cloned</source>
          <target state="translated">Incoming::cloned</target>
        </trans-unit>
        <trans-unit id="8a2bf20be5038460f2e5f09718d4cb6a21fb4c03" translate="yes" xml:space="preserve">
          <source>Incoming::cmp</source>
          <target state="translated">Incoming::cmp</target>
        </trans-unit>
        <trans-unit id="5ed0bcc65453a7978586b3e2016dacfbc14352fe" translate="yes" xml:space="preserve">
          <source>Incoming::collect</source>
          <target state="translated">Incoming::collect</target>
        </trans-unit>
        <trans-unit id="e70d0d30256802ac0658826bed8a56d75ffa6c45" translate="yes" xml:space="preserve">
          <source>Incoming::copied</source>
          <target state="translated">Incoming::copied</target>
        </trans-unit>
        <trans-unit id="a1ce4c03ba198d6862609c9bca7b4fdfd0e790c1" translate="yes" xml:space="preserve">
          <source>Incoming::count</source>
          <target state="translated">Incoming::count</target>
        </trans-unit>
        <trans-unit id="445c24f8aeffb804abbe66eac8d728adfa6384c3" translate="yes" xml:space="preserve">
          <source>Incoming::cycle</source>
          <target state="translated">Incoming::cycle</target>
        </trans-unit>
        <trans-unit id="c7373d860bdcd6bd00f58afd7287948921f2cf3d" translate="yes" xml:space="preserve">
          <source>Incoming::enumerate</source>
          <target state="translated">Incoming::enumerate</target>
        </trans-unit>
        <trans-unit id="422e90f2e0427cea81726aa22dde243c959e3442" translate="yes" xml:space="preserve">
          <source>Incoming::eq</source>
          <target state="translated">Incoming::eq</target>
        </trans-unit>
        <trans-unit id="d82ad0962be1b645dba4415057b56c8c71d2db6c" translate="yes" xml:space="preserve">
          <source>Incoming::filter</source>
          <target state="translated">Incoming::filter</target>
        </trans-unit>
        <trans-unit id="f2d060b73d6c431a592011fdcaf80f72c4327ea7" translate="yes" xml:space="preserve">
          <source>Incoming::filter_map</source>
          <target state="translated">Incoming::filter_map</target>
        </trans-unit>
        <trans-unit id="ec24aef48051e0d66dfbf513fbece0b535e8173a" translate="yes" xml:space="preserve">
          <source>Incoming::find</source>
          <target state="translated">Incoming::find</target>
        </trans-unit>
        <trans-unit id="9f1745b317ce967f0969bdd91f79615c9788ba14" translate="yes" xml:space="preserve">
          <source>Incoming::find_map</source>
          <target state="translated">Incoming::find_map</target>
        </trans-unit>
        <trans-unit id="57ed09c2ac8fbae367da14cf88b9a1cf3a0b0f16" translate="yes" xml:space="preserve">
          <source>Incoming::flat_map</source>
          <target state="translated">Incoming::flat_map</target>
        </trans-unit>
        <trans-unit id="aa8cfa9877df81bdf6f3e26ae8c327e4f18e7ca7" translate="yes" xml:space="preserve">
          <source>Incoming::flatten</source>
          <target state="translated">Incoming::flatten</target>
        </trans-unit>
        <trans-unit id="f534c99639d2a7b60622d67e3da268c1b2dbd8a2" translate="yes" xml:space="preserve">
          <source>Incoming::fmt</source>
          <target state="translated">Incoming::fmt</target>
        </trans-unit>
        <trans-unit id="7bf954d9f452b8f0bff229d58d17ebe667b8bdaa" translate="yes" xml:space="preserve">
          <source>Incoming::fold</source>
          <target state="translated">Incoming::fold</target>
        </trans-unit>
        <trans-unit id="f45d04534657562b3b8e1ac8b93f0995c4f52ffc" translate="yes" xml:space="preserve">
          <source>Incoming::for_each</source>
          <target state="translated">Incoming::for_each</target>
        </trans-unit>
        <trans-unit id="146d704978de3d221c4a8b538e653f767ff7d0cc" translate="yes" xml:space="preserve">
          <source>Incoming::from</source>
          <target state="translated">Incoming::from</target>
        </trans-unit>
        <trans-unit id="8d00e730beb7664120c689b2165fe55c7e43696b" translate="yes" xml:space="preserve">
          <source>Incoming::fuse</source>
          <target state="translated">Incoming::fuse</target>
        </trans-unit>
        <trans-unit id="d6f3fa46377ae997728223371f8e2928bbcd46ee" translate="yes" xml:space="preserve">
          <source>Incoming::ge</source>
          <target state="translated">Incoming::ge</target>
        </trans-unit>
        <trans-unit id="ed38c0b5ef84ea5163b2da693e4b72183ddee0ec" translate="yes" xml:space="preserve">
          <source>Incoming::gt</source>
          <target state="translated">Incoming::gt</target>
        </trans-unit>
        <trans-unit id="b1345261a277f185321d6adb9b350bcb58cd599e" translate="yes" xml:space="preserve">
          <source>Incoming::inspect</source>
          <target state="translated">Incoming::inspect</target>
        </trans-unit>
        <trans-unit id="59abb681c116c064869e4b015c6b1cd16fb45598" translate="yes" xml:space="preserve">
          <source>Incoming::into</source>
          <target state="translated">Incoming::into</target>
        </trans-unit>
        <trans-unit id="95a20422d3926772d9c359f121355edbd8f745f9" translate="yes" xml:space="preserve">
          <source>Incoming::into_iter</source>
          <target state="translated">Incoming::into_iter</target>
        </trans-unit>
        <trans-unit id="77b7ce153ce8067d29a7d019ff3fcc043c2fdd8e" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted</source>
          <target state="translated">Incoming::is_sorted</target>
        </trans-unit>
        <trans-unit id="4dfdf545d2798411e8ee50244269b54395d86c9a" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by</source>
          <target state="translated">Incoming::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d90a5dfb897aff5c068a0a4a12a54de5b9bdf1da" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by_key</source>
          <target state="translated">Incoming::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f1c770fca353b885ee610fe1f519139cdebcc0ee" translate="yes" xml:space="preserve">
          <source>Incoming::last</source>
          <target state="translated">Incoming::last</target>
        </trans-unit>
        <trans-unit id="f5c79843bca5e97321f55d85100e1ac93d537dd7" translate="yes" xml:space="preserve">
          <source>Incoming::le</source>
          <target state="translated">Incoming::le</target>
        </trans-unit>
        <trans-unit id="41753aa4086d7645034ac6f543870deca487abbb" translate="yes" xml:space="preserve">
          <source>Incoming::lt</source>
          <target state="translated">Incoming::lt</target>
        </trans-unit>
        <trans-unit id="42262cd6a3c45e0c4ccd2f403ab3dde4f31c999d" translate="yes" xml:space="preserve">
          <source>Incoming::map</source>
          <target state="translated">Incoming::map</target>
        </trans-unit>
        <trans-unit id="b14fbc258acb1391be68964dacf06c868d0223ee" translate="yes" xml:space="preserve">
          <source>Incoming::max</source>
          <target state="translated">Incoming::max</target>
        </trans-unit>
        <trans-unit id="e598cfd5a561805bab3a055536a7ce8d4cbc0d87" translate="yes" xml:space="preserve">
          <source>Incoming::max_by</source>
          <target state="translated">Incoming::max_by</target>
        </trans-unit>
        <trans-unit id="02e8830cd577c40509d7ca817740c861b52c07c0" translate="yes" xml:space="preserve">
          <source>Incoming::max_by_key</source>
          <target state="translated">Incoming::max_by_key</target>
        </trans-unit>
        <trans-unit id="e522553048356a9c7e3aafb53205e73c814823fd" translate="yes" xml:space="preserve">
          <source>Incoming::min</source>
          <target state="translated">Incoming::min</target>
        </trans-unit>
        <trans-unit id="8b1b84ed0cee495bc315c75dc85c4916ce7f680f" translate="yes" xml:space="preserve">
          <source>Incoming::min_by</source>
          <target state="translated">Incoming::min_by</target>
        </trans-unit>
        <trans-unit id="94a6455843a6def08f4247ddbcf5a373aff6a12c" translate="yes" xml:space="preserve">
          <source>Incoming::min_by_key</source>
          <target state="translated">Incoming::min_by_key</target>
        </trans-unit>
        <trans-unit id="af6f0e0d448b8971f8088a94ecfe2c2c28074b20" translate="yes" xml:space="preserve">
          <source>Incoming::ne</source>
          <target state="translated">Incoming::ne</target>
        </trans-unit>
        <trans-unit id="ad9f2df7e05588db669a49fe0bfa35787281e257" translate="yes" xml:space="preserve">
          <source>Incoming::next</source>
          <target state="translated">Incoming::next</target>
        </trans-unit>
        <trans-unit id="15fdadbdf731ff5f14bd01d14581b0031b5aa856" translate="yes" xml:space="preserve">
          <source>Incoming::nth</source>
          <target state="translated">Incoming::nth</target>
        </trans-unit>
        <trans-unit id="f584fdb6a022a6b9c2041ae0049adb844c00af0a" translate="yes" xml:space="preserve">
          <source>Incoming::partial_cmp</source>
          <target state="translated">Incoming::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d6e7347d2f13179a0246ad8c2f8f8c42d5ea1e8b" translate="yes" xml:space="preserve">
          <source>Incoming::partition</source>
          <target state="translated">Incoming::partition</target>
        </trans-unit>
        <trans-unit id="d15dc3a739c395fba4cdef1bb3db41863ef399f5" translate="yes" xml:space="preserve">
          <source>Incoming::peekable</source>
          <target state="translated">Incoming::peekable</target>
        </trans-unit>
        <trans-unit id="cab06ddc3af8abd52b92e45544310b0faa110219" translate="yes" xml:space="preserve">
          <source>Incoming::position</source>
          <target state="translated">Incoming::position</target>
        </trans-unit>
        <trans-unit id="bb23c8eb76a6d68dfc63c6d32849abe960c1b856" translate="yes" xml:space="preserve">
          <source>Incoming::product</source>
          <target state="translated">Incoming::product</target>
        </trans-unit>
        <trans-unit id="b3d90889f7b30454426b3ed4e11228f5d9d8ee9f" translate="yes" xml:space="preserve">
          <source>Incoming::rev</source>
          <target state="translated">Incoming::rev</target>
        </trans-unit>
        <trans-unit id="d662587d11104ca4324befe21e5aaa1cf3ed3fa3" translate="yes" xml:space="preserve">
          <source>Incoming::rposition</source>
          <target state="translated">Incoming::rposition</target>
        </trans-unit>
        <trans-unit id="6b42372525b119239ec4bd20dc7bf69a1a105a08" translate="yes" xml:space="preserve">
          <source>Incoming::scan</source>
          <target state="translated">Incoming::scan</target>
        </trans-unit>
        <trans-unit id="c1399e28a107bc4249663ed0d2b97e798127c9c6" translate="yes" xml:space="preserve">
          <source>Incoming::size_hint</source>
          <target state="translated">Incoming::size_hint</target>
        </trans-unit>
        <trans-unit id="85ee70ca43a998ef206f4a945f59006b6f40ddfa" translate="yes" xml:space="preserve">
          <source>Incoming::skip</source>
          <target state="translated">Incoming::skip</target>
        </trans-unit>
        <trans-unit id="fdd32c3e0206952202e83705e9d627eb48f607e6" translate="yes" xml:space="preserve">
          <source>Incoming::skip_while</source>
          <target state="translated">Incoming::skip_while</target>
        </trans-unit>
        <trans-unit id="5a589e1b9602c4ff48aa22e65968275507ea9485" translate="yes" xml:space="preserve">
          <source>Incoming::step_by</source>
          <target state="translated">Incoming::step_by</target>
        </trans-unit>
        <trans-unit id="d9ed48df44b20a36de8b0990f9b0c9b964475772" translate="yes" xml:space="preserve">
          <source>Incoming::sum</source>
          <target state="translated">Incoming::sum</target>
        </trans-unit>
        <trans-unit id="bcf6381c826c50e1aaea7423243d1529dca214b8" translate="yes" xml:space="preserve">
          <source>Incoming::take</source>
          <target state="translated">Incoming::take</target>
        </trans-unit>
        <trans-unit id="981c1e08f556e3870dd2af3a144f3176473200b7" translate="yes" xml:space="preserve">
          <source>Incoming::take_while</source>
          <target state="translated">Incoming::take_while</target>
        </trans-unit>
        <trans-unit id="2f0356552ebde5f1c3f3f3ad37fa03b3d1bf90bd" translate="yes" xml:space="preserve">
          <source>Incoming::try_fold</source>
          <target state="translated">Incoming::try_fold</target>
        </trans-unit>
        <trans-unit id="5c1f1df01cacdbf861258e63eb2cb8581f88d043" translate="yes" xml:space="preserve">
          <source>Incoming::try_for_each</source>
          <target state="translated">Incoming::try_for_each</target>
        </trans-unit>
        <trans-unit id="9a58299e31b9803379553db37123ab15774b671d" translate="yes" xml:space="preserve">
          <source>Incoming::try_from</source>
          <target state="translated">Incoming::try_from</target>
        </trans-unit>
        <trans-unit id="fff541a38a97a609e5012c516e4164326cfb79eb" translate="yes" xml:space="preserve">
          <source>Incoming::try_into</source>
          <target state="translated">Incoming::try_into</target>
        </trans-unit>
        <trans-unit id="946f55dc3e1af640cd291f2aaa8528234e768102" translate="yes" xml:space="preserve">
          <source>Incoming::type_id</source>
          <target state="translated">Incoming::type_id</target>
        </trans-unit>
        <trans-unit id="bf46b8f3bb432660f79899dee66baf3e9f087f95" translate="yes" xml:space="preserve">
          <source>Incoming::unzip</source>
          <target state="translated">Incoming::unzip</target>
        </trans-unit>
        <trans-unit id="96a8cde7e0e4c52965055072fd39e0d341071072" translate="yes" xml:space="preserve">
          <source>Incoming::zip</source>
          <target state="translated">Incoming::zip</target>
        </trans-unit>
        <trans-unit id="bcbf83cd2f0ed89c4d2689129dde9ed148866efc" translate="yes" xml:space="preserve">
          <source>Incorrect bytes:</source>
          <target state="translated">誤ったバイトです。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="52cb15ca8d9c1e4b950b26ef1f32246271f50339" translate="yes" xml:space="preserve">
          <source>Index expressions on arrays and slices</source>
          <target state="translated">配列とスライスのインデックス式</target>
        </trans-unit>
        <trans-unit id="361d6f89c121ce39bb2ed14f7085cd248645d21b" translate="yes" xml:space="preserve">
          <source>Index expressions, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; or &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; with a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">インデックス式、&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;配列のインデックス&lt;/a&gt;や&lt;a href=&quot;types/slice&quot;&gt;スライス&lt;/a&gt;と &lt;code&gt;usize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="528b0ff12e28b750b5aeda40648664d5f6804c7c" translate="yes" xml:space="preserve">
          <source>Index::index</source>
          <target state="translated">Index::index</target>
        </trans-unit>
        <trans-unit id="21d657443793a7fc6c319cfc186e761fac77191e" translate="yes" xml:space="preserve">
          <source>IndexMut</source>
          <target state="translated">IndexMut</target>
        </trans-unit>
        <trans-unit id="24f9ef47b9bb8985e28653af23b1accbf6cd2d9b" translate="yes" xml:space="preserve">
          <source>IndexMut::index_mut</source>
          <target state="translated">IndexMut::index_mut</target>
        </trans-unit>
        <trans-unit id="bda8e2dcef8324d4ce1ba450c4e2e0cae96a9a4a" translate="yes" xml:space="preserve">
          <source>Indexes must be within bounds of the original slice;</source>
          <target state="translated">インデックスは元のスライスの範囲内でなければなりません。</target>
        </trans-unit>
        <trans-unit id="fa74cb6623de227628f45b4ae93159daddea90b3" translate="yes" xml:space="preserve">
          <source>Indexes must lie on UTF-8 sequence boundaries.</source>
          <target state="translated">インデックスは UTF-8 シーケンスの境界にある必要があります。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="8e33bba2a2fe8c945dee904cfed37743c8dd2807" translate="yes" xml:space="preserve">
          <source>Indexing into Strings</source>
          <target state="translated">文字列へのインデックス化</target>
        </trans-unit>
        <trans-unit id="bc1a7f445eecf9a21ddaa6928da85497c3f808d7" translate="yes" xml:space="preserve">
          <source>Indexing into a string is often a bad idea because it&amp;rsquo;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using &lt;code&gt;[]&lt;/code&gt; with a single number, you can use &lt;code&gt;[]&lt;/code&gt; with a range to create a string slice containing particular bytes:</source>
          <target state="translated">文字列へのインデックス付けは、バイト値、文字、書記素クラスタ、文字列スライスなど、文字列インデックス付け操作の戻り値の型が明確でないため、多くの場合悪い考えです。したがって、文字列スライスを作成するために本当にインデックスを使用する必要がある場合、Rustはより具体的になるように求めます。インデックスをより具体的に指定し、文字列スライスが必要であることを示すには、単一の数値で &lt;code&gt;[]&lt;/code&gt; を使用してインデックスを作成するのではなく、 &lt;code&gt;[]&lt;/code&gt; を範囲で使用して、特定のバイトを含む文字列スライスを作成できます。</target>
        </trans-unit>
        <trans-unit id="6b92d7c5b5fd6e80ddd2c2e71ae6f53dabf14469" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">インデックス作成は一定時間の操作を目的としていますが、UTF-8エンコーディングではこれを行うことができません。さらに、バイト、コードポイント、書記素クラスターなど、インデックスがどのような種類の情報を返すかは明確ではありません。&lt;a href=&quot;#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt;方法は、それぞれ、最初の二つの上にイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="0aba4d1ffc3e50a35d8e6bb2627a9921d36e96c9" translate="yes" xml:space="preserve">
          <source>Indexing outside of the bounds of an object with &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; with the exception of one byte past the end of the object.</source>
          <target state="translated">オブジェクトの終わりを過ぎた1バイトを除いて、&lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;してオブジェクトの境界外でインデックスを作成します。</target>
        </trans-unit>
        <trans-unit id="27caa1fa7c65a4437e649a4888fe129281a79568" translate="yes" xml:space="preserve">
          <source>Indicates if a buffer should be initialized.</source>
          <target state="translated">バッファを初期化するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="c4c4786e638c55c48e8eb353954207ab6043189e" translate="yes" xml:space="preserve">
          <source>Indicates that directories should be created recursively, creating all parent directories. Parents that do not exist are created with the same security and permissions settings.</source>
          <target state="translated">ディレクトリを再帰的に作成し、すべての親ディレクトリを作成する必要があることを示します。存在しない親は、同じセキュリティとパーミッション設定で作成されます。</target>
        </trans-unit>
        <trans-unit id="4856479107baf14ea55cfdf8d4985b8807716a64" translate="yes" xml:space="preserve">
          <source>Indicates the manner in which a thread exited.</source>
          <target state="translated">スレッドの終了方法を示します。</target>
        </trans-unit>
        <trans-unit id="075cfaf01d924967ba4b76beb1cc86c1b8ffbe22" translate="yes" xml:space="preserve">
          <source>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</source>
          <target state="translated">このソケットのマルチキャストパケットの有効時間を指定します。デフォルト値は1で、明示的に要求されない限りマルチキャストパケットはローカルネットワークを離れないことを意味します。</target>
        </trans-unit>
        <trans-unit id="888a497d6d0feb54c4bc51c8bbfa14e4db0f048b" translate="yes" xml:space="preserve">
          <source>Indicates unfinished code.</source>
          <target state="translated">未完成のコードを示します。</target>
        </trans-unit>
        <trans-unit id="4862445239fb7cd37f48e6ace7775dcd354d2d14" translate="yes" xml:space="preserve">
          <source>Indicates unreachable code.</source>
          <target state="translated">到達不可能なコードを示します。</target>
        </trans-unit>
        <trans-unit id="cd5cea6e94489fba68a0399bcc4d11feffb0cbe4" translate="yes" xml:space="preserve">
          <source>Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.</source>
          <target state="translated">値が利用可能かどうか、または現在のタスクが代わりにウェイクアップを受け取るようにスケジュールされているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="a5d9b716629f981c5e75c2880c16718258347eb9" translate="yes" xml:space="preserve">
          <source>Indication that contents should be center-aligned.</source>
          <target state="translated">コンテンツを中央揃えにする必要があることを示しています。</target>
        </trans-unit>
        <trans-unit id="582259f836deeb40225aa78333ee7027acddbdbe" translate="yes" xml:space="preserve">
          <source>Indication that contents should be left-aligned.</source>
          <target state="translated">コンテンツを左揃えにする必要があることを示しています。</target>
        </trans-unit>
        <trans-unit id="30524864694504eb9866802047ab21c114fa2091" translate="yes" xml:space="preserve">
          <source>Indication that contents should be right-aligned.</source>
          <target state="translated">コンテンツを右寄せにすることを示します。</target>
        </trans-unit>
        <trans-unit id="f2cd68a3153c21de89ed40993772ed6007b02a6f" translate="yes" xml:space="preserve">
          <source>Indices are zero-based for arrays and slices. Array access is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a &lt;em&gt;panicked state&lt;/em&gt; if it fails.</source>
          <target state="translated">配列とスライスのインデックスはゼロベースです。配列アクセスは&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;定数式な&lt;/a&gt;ので、定数インデックス値を使用してコンパイル時に境界を確認できます。それ以外の場合は、実行時にチェックが実行され、失敗するとスレッドが&lt;em&gt;パニック状態に&lt;/em&gt;なります。</target>
        </trans-unit>
        <trans-unit id="e7d8ee4a5140f0e6e32c94f9ff32453c7e40a4a3" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">2つの &lt;code&gt;Arc&lt;/code&gt; の不等式。</target>
        </trans-unit>
        <trans-unit id="8aa90054db987f32eec9e62690e9b9862d6f642a" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">2つの &lt;code&gt;Rc&lt;/code&gt; の不等式。</target>
        </trans-unit>
        <trans-unit id="32565cc43897d204c904c25aeddc29a5a2fe5f4d" translate="yes" xml:space="preserve">
          <source>Infallible</source>
          <target state="translated">Infallible</target>
        </trans-unit>
        <trans-unit id="327440953e8036a6b78b97c190dedc5d1ddc1d6f" translate="yes" xml:space="preserve">
          <source>Infallible errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379d563f62e4c026be425a08a60de86e8b28b34e" translate="yes" xml:space="preserve">
          <source>Infallible::borrow</source>
          <target state="translated">Infallible::borrow</target>
        </trans-unit>
        <trans-unit id="ffd9adf91cadc5963cf564501d6440dfcb9953d6" translate="yes" xml:space="preserve">
          <source>Infallible::borrow_mut</source>
          <target state="translated">Infallible::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d5161b5d2a0dd973c7749267f912225db6f86b3c" translate="yes" xml:space="preserve">
          <source>Infallible::clamp</source>
          <target state="translated">Infallible::clamp</target>
        </trans-unit>
        <trans-unit id="f9dfe17efa7693fd64ca4bce650f4693dec46e6a" translate="yes" xml:space="preserve">
          <source>Infallible::clone</source>
          <target state="translated">Infallible::clone</target>
        </trans-unit>
        <trans-unit id="7c7c7505a3bdd3e6bbbfabe3c0aa36eea42c2f97" translate="yes" xml:space="preserve">
          <source>Infallible::clone_from</source>
          <target state="translated">Infallible::clone_from</target>
        </trans-unit>
        <trans-unit id="6af6b86ef345c274a60c49262dbedb50a8323471" translate="yes" xml:space="preserve">
          <source>Infallible::clone_into</source>
          <target state="translated">Infallible::clone_into</target>
        </trans-unit>
        <trans-unit id="3f4e892d27a40b0bfaf9fee7ba4a2719e5f0e03b" translate="yes" xml:space="preserve">
          <source>Infallible::cmp</source>
          <target state="translated">Infallible::cmp</target>
        </trans-unit>
        <trans-unit id="465ca79819acd2f64e9c25bd2a18d141db20f7e4" translate="yes" xml:space="preserve">
          <source>Infallible::eq</source>
          <target state="translated">Infallible::eq</target>
        </trans-unit>
        <trans-unit id="7b0120f9faa0f0e51d2f41f2228ccb58415bb901" translate="yes" xml:space="preserve">
          <source>Infallible::fmt</source>
          <target state="translated">Infallible::fmt</target>
        </trans-unit>
        <trans-unit id="7699715e87167505521e297f0cc5acf9571073ba" translate="yes" xml:space="preserve">
          <source>Infallible::from</source>
          <target state="translated">Infallible::from</target>
        </trans-unit>
        <trans-unit id="9ed64ca1536a61aeb71e791f8b0cd35996768800" translate="yes" xml:space="preserve">
          <source>Infallible::ge</source>
          <target state="translated">Infallible::ge</target>
        </trans-unit>
        <trans-unit id="6bc6944b5c980e7843d508d02dcd2bfaf58a503d" translate="yes" xml:space="preserve">
          <source>Infallible::gt</source>
          <target state="translated">Infallible::gt</target>
        </trans-unit>
        <trans-unit id="be25a1605cddc636f6f076ea8d21d97812f2aa85" translate="yes" xml:space="preserve">
          <source>Infallible::into</source>
          <target state="translated">Infallible::into</target>
        </trans-unit>
        <trans-unit id="acae0cd14002a94fe132d6ca88f1fdd5ca563403" translate="yes" xml:space="preserve">
          <source>Infallible::le</source>
          <target state="translated">Infallible::le</target>
        </trans-unit>
        <trans-unit id="2b7d09de5fbcd932797ca9cc160818ef628164b0" translate="yes" xml:space="preserve">
          <source>Infallible::lt</source>
          <target state="translated">Infallible::lt</target>
        </trans-unit>
        <trans-unit id="d981e531de4db6af3fa624928233a62cc48506b0" translate="yes" xml:space="preserve">
          <source>Infallible::max</source>
          <target state="translated">Infallible::max</target>
        </trans-unit>
        <trans-unit id="4e77b6f968c067dfd00c877ce693a33816232a84" translate="yes" xml:space="preserve">
          <source>Infallible::min</source>
          <target state="translated">Infallible::min</target>
        </trans-unit>
        <trans-unit id="1b9bdf4c04b01562bf66a579b3902b4d24df2814" translate="yes" xml:space="preserve">
          <source>Infallible::ne</source>
          <target state="translated">Infallible::ne</target>
        </trans-unit>
        <trans-unit id="593cf3934010f07d135bbd81984d0e7b07060f05" translate="yes" xml:space="preserve">
          <source>Infallible::partial_cmp</source>
          <target state="translated">Infallible::partial_cmp</target>
        </trans-unit>
        <trans-unit id="171d7fff4d94e2b47d18a78e5a1c94a683078c15" translate="yes" xml:space="preserve">
          <source>Infallible::to_owned</source>
          <target state="translated">Infallible::to_owned</target>
        </trans-unit>
        <trans-unit id="256be91884f5591734d76be10903ead44c9f209f" translate="yes" xml:space="preserve">
          <source>Infallible::to_string</source>
          <target state="translated">Infallible::to_string</target>
        </trans-unit>
        <trans-unit id="c3635403870a783a099eedcae587acfb8a52bc1f" translate="yes" xml:space="preserve">
          <source>Infallible::try_from</source>
          <target state="translated">Infallible::try_from</target>
        </trans-unit>
        <trans-unit id="3c8ee4706115d8499f3abf4d51e35db72e1ffd2e" translate="yes" xml:space="preserve">
          <source>Infallible::try_into</source>
          <target state="translated">Infallible::try_into</target>
        </trans-unit>
        <trans-unit id="9701bd213ca2d8e7962b353284539a737fba44f7" translate="yes" xml:space="preserve">
          <source>Infallible::type_id</source>
          <target state="translated">Infallible::type_id</target>
        </trans-unit>
        <trans-unit id="c548ca9534f0b8a6c18d5933d5460cae1f620bec" translate="yes" xml:space="preserve">
          <source>Inferred type</source>
          <target state="translated">推定型</target>
        </trans-unit>
        <trans-unit id="5b827f3090a9999d7251035ec3accdcd8d4fbe7d" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; のような無限イテレーター&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;、それらを有限にするために、takeのようなアダプターでよく使用されます。</target>
        </trans-unit>
        <trans-unit id="e414b3978173634ff311532d9eb1dc73109f5119" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; のような無限反復子&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;、それらを有限にするために、takeのようなアダプターでよく使用されます。</target>
        </trans-unit>
        <trans-unit id="a2550f47e7bda60f30b73b2126315e72f6a1181f" translate="yes" xml:space="preserve">
          <source>Infinite loops</source>
          <target state="translated">無限ループ</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="2caa9882f0053ecda17ba6be06a5251c1ec2645f" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;).</source>
          <target state="translated">無限大（&amp;infin;）。</target>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="d42473cc429103c815ee41c99ce227e6800bc064" translate="yes" xml:space="preserve">
          <source>Informally:</source>
          <target state="translated">Informally:</target>
        </trans-unit>
        <trans-unit id="50473fcaee3f0826f522b7d9bde1dee298665a6b" translate="yes" xml:space="preserve">
          <source>Informs the compiler that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">コードのこの点に到達できないことをコンパイラに通知し、さらなる最適化を可能にします。</target>
        </trans-unit>
        <trans-unit id="da26edc8a2a6b051f930b8dc35ea3b2d2eb04a3f" translate="yes" xml:space="preserve">
          <source>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</source>
          <target state="translated">条件が常に真であることをオプティマイザに通知します。条件が偽の場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="b07b5b517980bf88c19321ee29f23f8a21e0b4de" translate="yes" xml:space="preserve">
          <source>Inherent Implementations</source>
          <target state="translated">固有の実装</target>
        </trans-unit>
        <trans-unit id="bf73ea65fd18a78a9021507f0c11c78ed2ec5124" translate="yes" xml:space="preserve">
          <source>Inherent associated types were part of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; but are not yet implemented. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;the tracking issue&lt;/a&gt; for the status of this implementation.</source>
          <target state="translated">固有の関連タイプは&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195の&lt;/a&gt;一部でしたが、まだ実装されていません。この実装のステータスについて&lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;は、追跡の問題&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f47cc0e78be269b94ff1fbb506eefabb2d14cd1d" translate="yes" xml:space="preserve">
          <source>Inherent implementation</source>
          <target state="translated">固有の実装</target>
        </trans-unit>
        <trans-unit id="89d8c2e2efc6fafd98f5603953f0cb702613d6d3" translate="yes" xml:space="preserve">
          <source>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the &lt;code&gt;unsafe&lt;/code&gt; keyword from the inherent implementation will resolve this error.</source>
          <target state="translated">固有の実装（特性を実装しないが、型に関連付けられたメソッドを提供する実装）は、安全でない特性を実装していないため、常に安全です。 &lt;code&gt;unsafe&lt;/code&gt; キーワードを固有の実装から削除すると、このエラーが解決します。</target>
        </trans-unit>
        <trans-unit id="02407dbce9ca24cc02710598fc24ae8f49c07a7e" translate="yes" xml:space="preserve">
          <source>Inherent implementations associate the contained items to the implementing type. Inherent implementations can contain &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;associated functions&lt;/a&gt; (including methods) and &lt;a href=&quot;associated-items#associated-constants&quot;&gt;associated constants&lt;/a&gt;. They cannot contain associated type aliases.</source>
          <target state="translated">固有の実装は、含まれている項目を実装タイプに関連付けます。固有の実装には、&lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;関連する関数&lt;/a&gt;（メソッドを含む）および&lt;a href=&quot;associated-items#associated-constants&quot;&gt;関連する定数&lt;/a&gt;を含めることができます。関連する型エイリアスを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="4ccb704ced0ac70357d35287cb1c67388f967d06" translate="yes" xml:space="preserve">
          <source>Inherent method</source>
          <target state="translated">固有メソッド</target>
        </trans-unit>
        <trans-unit id="c7a774bf3dce2aac99ad48347458653bbd55d325" translate="yes" xml:space="preserve">
          <source>Inherit stdin/stdout/stderr for &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt;, but create pipes for &lt;code&gt;output&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; または &lt;code&gt;status&lt;/code&gt; の stdin / stdout / stderrを継承しますが、 &lt;code&gt;output&lt;/code&gt; 用のパイプを作成します</target>
        </trans-unit>
        <trans-unit id="9f4e94fb7b802199fb91e731b50847b79d9607c1" translate="yes" xml:space="preserve">
          <source>Inherit the current process's environment</source>
          <target state="translated">現在のプロセスの環境を継承する</target>
        </trans-unit>
        <trans-unit id="44c348c84d3785ac5adb30ee3d2d10f68e971317" translate="yes" xml:space="preserve">
          <source>Inherit the current process's working directory</source>
          <target state="translated">現在のプロセスの作業ディレクトリを継承する</target>
        </trans-unit>
        <trans-unit id="6325b69277e854d2ebda5c6558b946870708063a" translate="yes" xml:space="preserve">
          <source>Inheritance as a Type System and as Code Sharing</source>
          <target state="translated">型システムとしての継承とコード共有としての継承</target>
        </trans-unit>
        <trans-unit id="c561edc4e8c488ada0373bbdca70237bf7b2c36a" translate="yes" xml:space="preserve">
          <source>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it&amp;rsquo;s often at risk of sharing more code than necessary. Subclasses shouldn&amp;rsquo;t always share all characteristics of their parent class but will do so with inheritance. This can make a program&amp;rsquo;s design less flexible. It also introduces the possibility of calling methods on subclasses that don&amp;rsquo;t make sense or that cause errors because the methods don&amp;rsquo;t apply to the subclass. In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program&amp;rsquo;s design.</source>
          <target state="translated">継承は、多くの場合、必要以上のコードを共有するリスクがあるため、多くのプログラミング言語でのプログラミング設計ソリューションとしての人気が低下しています。サブクラスは常に親クラスのすべての特性を共有する必要はありませんが、継承によって共有します。これにより、プログラムの設計の柔軟性が低下する場合があります。また、意味のないサブクラスでメソッドを呼び出す可能性や、メソッドがサブクラスに適用されないためにエラーが発生する可能性も紹介します。さらに、一部の言語では、サブクラスが1つのクラスからのみ継承できるため、プログラムの設計の柔軟性がさらに制限されます。</target>
        </trans-unit>
        <trans-unit id="2e8b04bb573d36dddf2182bf5af08f053f087e52" translate="yes" xml:space="preserve">
          <source>Initial values</source>
          <target state="translated">初期値</target>
        </trans-unit>
        <trans-unit id="c904b3e1f2d0c5d733b728b7a681f23a1ee75fda" translate="yes" xml:space="preserve">
          <source>Initialization and Destruction</source>
          <target state="translated">初期化と破壊</target>
        </trans-unit>
        <trans-unit id="13d802cdbafe0031cbe0ff944c50f80b718c2135" translate="yes" xml:space="preserve">
          <source>Initialization invariant</source>
          <target state="translated">初期化不変</target>
        </trans-unit>
        <trans-unit id="e4de29eb027f99abd844645c1796c2a7a7d72482" translate="yes" xml:space="preserve">
          <source>Initialization is dynamically performed on the first call to &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; within a thread, and values that implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; get destructed when a thread exits. Some caveats apply, which are explained below.</source>
          <target state="translated">初期化が動的に最初の呼び出しで実行される&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;、スレッド内、および実装の値&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;時にスレッドが終了を破壊ます。以下に説明するいくつかの警告が適用されます。</target>
        </trans-unit>
        <trans-unit id="db21316277d9b77e6330bd9b3d2303f36118171f" translate="yes" xml:space="preserve">
          <source>Initialization value for static &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">静的&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;値の初期化値。</target>
        </trans-unit>
        <trans-unit id="777041461872120636aa50d7bf36c832a7f4df98" translate="yes" xml:space="preserve">
          <source>Initialize a result to &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; before a loop:</source>
          <target state="translated">ループの前に結果を&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;に初期化します。</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cb5407ce66e9cc74c7b9cdad45d317b358a42346" translate="yes" xml:space="preserve">
          <source>Initializer::borrow</source>
          <target state="translated">Initializer::borrow</target>
        </trans-unit>
        <trans-unit id="9329992da7e67d3d87b950443458d66c568d4935" translate="yes" xml:space="preserve">
          <source>Initializer::borrow_mut</source>
          <target state="translated">Initializer::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8b338b461eda8eab3ac52c21c7ba950b55ddab77" translate="yes" xml:space="preserve">
          <source>Initializer::fmt</source>
          <target state="translated">Initializer::fmt</target>
        </trans-unit>
        <trans-unit id="370ad1ce33d717e00bfed251c3d4bf09120c4049" translate="yes" xml:space="preserve">
          <source>Initializer::from</source>
          <target state="translated">Initializer::from</target>
        </trans-unit>
        <trans-unit id="26ef6fd69d6de0da79344847b51c3c8c83e2b8cc" translate="yes" xml:space="preserve">
          <source>Initializer::initialize</source>
          <target state="translated">Initializer::initialize</target>
        </trans-unit>
        <trans-unit id="bdae64fb5268754bb9cc8ae6c8db2ab2a08fdbc3" translate="yes" xml:space="preserve">
          <source>Initializer::into</source>
          <target state="translated">Initializer::into</target>
        </trans-unit>
        <trans-unit id="a79949e93a459b7f8ca5406e877e55f5660e5c75" translate="yes" xml:space="preserve">
          <source>Initializer::nop</source>
          <target state="translated">Initializer::nop</target>
        </trans-unit>
        <trans-unit id="dcb257db32b009bda392da62101575610abd1f91" translate="yes" xml:space="preserve">
          <source>Initializer::should_initialize</source>
          <target state="translated">Initializer::should_initialize</target>
        </trans-unit>
        <trans-unit id="bcab8cf375f63f790f0ce8e05777079bda310ea7" translate="yes" xml:space="preserve">
          <source>Initializer::try_from</source>
          <target state="translated">Initializer::try_from</target>
        </trans-unit>
        <trans-unit id="1ce33c3dc308ea20a9c3e23385d3fd4e6cdbc2f0" translate="yes" xml:space="preserve">
          <source>Initializer::try_into</source>
          <target state="translated">Initializer::try_into</target>
        </trans-unit>
        <trans-unit id="7015bd93154feb364c2957b0fc2cdb3fe5bb0863" translate="yes" xml:space="preserve">
          <source>Initializer::type_id</source>
          <target state="translated">Initializer::type_id</target>
        </trans-unit>
        <trans-unit id="38d15bea38cc632ed42db7368869a2581cd9ac0d" translate="yes" xml:space="preserve">
          <source>Initializer::zeroing</source>
          <target state="translated">Initializer::zeroing</target>
        </trans-unit>
        <trans-unit id="b02eff8ddabee28d5ce99312e8bd3930e76e09a5" translate="yes" xml:space="preserve">
          <source>Initializes a buffer if necessary.</source>
          <target state="translated">必要に応じてバッファを初期化します。</target>
        </trans-unit>
        <trans-unit id="c1014a628ca9687c4db754c43f3628d84e3050c5" translate="yes" xml:space="preserve">
          <source>Initializing a struct field-by-field</source>
          <target state="translated">フィールドごとに構造体を初期化する</target>
        </trans-unit>
        <trans-unit id="6d9d88d804a2b918f6a240e649b5e1a2aa5a1b6e" translate="yes" xml:space="preserve">
          <source>Initializing an array element-by-element</source>
          <target state="translated">配列を要素ごとに初期化する</target>
        </trans-unit>
        <trans-unit id="e30e79f506a4a7b48aa6bd2ea1d1c98586736d96" translate="yes" xml:space="preserve">
          <source>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety &lt;em&gt;and&lt;/em&gt; concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you&amp;rsquo;re working on it rather than potentially after it has been shipped to production. We&amp;rsquo;ve nicknamed this aspect of Rust &lt;em&gt;fearless&lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt;. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</source>
          <target state="translated">当初、Rustチームは、メモリの安全性の確保と同時実行の問題の防止は、異なる方法で解決する2つの個別の課題であると考えていました。時間の経過とともに、チームは所有権とタイプシステムがメモリの安全性&lt;em&gt;と&lt;/em&gt;メモリの管理に役立つ強力なツールセットであることを発見しました&lt;em&gt;&lt;/em&gt;並行性の問題！所有権と型チェックを活用することにより、多くの同時実行エラーは、ランタイムエラーではなく、Rustのコンパイル時エラーです。したがって、ランタイム同時実行バグが発生する正確な状況を再現するために多くの時間を費やすのではなく、不正なコードはコンパイルを拒否し、問題を説明するエラーを表示します。その結果、コードを運用環境に出荷した後ではなく、作業中にコードを修正できます。私たちは、Rustのこの側面に&lt;em&gt;恐れ&lt;/em&gt;を知ら&lt;em&gt;ない&lt;/em&gt;&lt;em&gt;並行処理&lt;/em&gt;というニックネームを付けました。恐れのない並行性により、微妙なバグがなく、新しいバグを導入することなく簡単にリファクタリングできるコードを作成できます。</target>
        </trans-unit>
        <trans-unit id="b7a13c17feda3ff04e933d53202cd41c94dace05" translate="yes" xml:space="preserve">
          <source>Inner attribute</source>
          <target state="translated">内部属性</target>
        </trans-unit>
        <trans-unit id="565c802152b12c7dd9aea0fe59ebaacf3d1a82a3" translate="yes" xml:space="preserve">
          <source>Inner block doc comment</source>
          <target state="translated">インナーブロックのdocコメント</target>
        </trans-unit>
        <trans-unit id="10264f133a74f365cfab7999c77a7091803d2786" translate="yes" xml:space="preserve">
          <source>Inner items do not inherit type or const parameters from the functions they are embedded in.</source>
          <target state="translated">インナーアイテムは、それらが埋め込まれた関数から型やconstパラメータを継承しません。</target>
        </trans-unit>
        <trans-unit id="6909dc9a044dcde9a4fe7603daf0a9a52557aba3" translate="yes" xml:space="preserve">
          <source>Inner line doc comment</source>
          <target state="translated">内線のdocコメント</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">入力形式</target>
        </trans-unit>
        <trans-unit id="daf107c7f6d6d3a06676862d762621e314a3de24" translate="yes" xml:space="preserve">
          <source>Insert and complex keys</source>
          <target state="translated">挿入キーと複合キー</target>
        </trans-unit>
        <trans-unit id="3d9eeb934e6164d2c24b6394e6758d068509ccb2" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;code&gt;O(log n)&lt;/code&gt; time complexity. Checking the largest element is &lt;code&gt;O(1)&lt;/code&gt;. Converting a vector to a binary heap can be done in-place, and has &lt;code&gt;O(n)&lt;/code&gt; complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;code&gt;O(n log n)&lt;/code&gt; in-place heapsort.</source>
          <target state="translated">最大の要素の挿入とポップには、 &lt;code&gt;O(log n)&lt;/code&gt; 時間の複雑さがあります。最大の要素のチェックは &lt;code&gt;O(1)&lt;/code&gt; です。ベクトルのバイナリヒープへの変換はインプレースで実行でき、 &lt;code&gt;O(n)&lt;/code&gt; 複雑です。バイナリヒープは、インプレースで並べ替えられたベクトルに変換することもできるので、 &lt;code&gt;O(n log n)&lt;/code&gt; インプレースヒープソートに使用できます。</target>
        </trans-unit>
        <trans-unit id="e0b51cb1a3f7392b32f519dbb88d97e332d11c69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合は &lt;code&gt;v&lt;/code&gt; をオプションに挿入し、含まれている値への可変参照を返します。</target>
        </trans-unit>
        <trans-unit id="633ef776ac14fc1a5ba3722ac27ba6e3e9e74927" translate="yes" xml:space="preserve">
          <source>Inserts a character into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">この &lt;code&gt;String&lt;/code&gt; のバイト位置に文字を挿入します。</target>
        </trans-unit>
        <trans-unit id="0a96531a2ad16ab4c68e8dd30a04fcb8b88d0c9e" translate="yes" xml:space="preserve">
          <source>Inserts a key-value pair into the map.</source>
          <target state="translated">キーと値のペアをマップに挿入します。</target>
        </trans-unit>
        <trans-unit id="6f07650e645ae306862b323d418b09fad3b7f7a0" translate="yes" xml:space="preserve">
          <source>Inserts a string slice into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">文字列スライスをこの &lt;code&gt;String&lt;/code&gt; のバイト位置に挿入します。</target>
        </trans-unit>
        <trans-unit id="7d8655d30bbaeaee48aa3f55378c0fe2a4d62e4c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">&lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;f&lt;/code&gt; から計算された値をオプションに挿入し、含まれている値への変更可能な参照を返します。</target>
        </trans-unit>
        <trans-unit id="bd878e1d7609b46228a7e1a93fb6e8fa8ab178e1" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the set if the given &lt;code&gt;value&lt;/code&gt; is not present, then returns a reference to the value in the set.</source>
          <target state="translated">指定された &lt;code&gt;value&lt;/code&gt; が存在しない場合、 &lt;code&gt;f&lt;/code&gt; から計算された値をセットに挿入し、セット内の値への参照を返します。</target>
        </trans-unit>
        <trans-unit id="033e5469d3495f120ca34f88432068fa89f314f7" translate="yes" xml:space="preserve">
          <source>Inserts an element at &lt;code&gt;index&lt;/code&gt; within the &lt;code&gt;VecDeque&lt;/code&gt;, shifting all elements with indices greater than or equal to &lt;code&gt;index&lt;/code&gt; towards the back.</source>
          <target state="translated">インサートの要素 &lt;code&gt;index&lt;/code&gt; 内 &lt;code&gt;VecDeque&lt;/code&gt; 、より大きいまたは等しいインデックスを有するすべての要素をシフト &lt;code&gt;index&lt;/code&gt; 背面に向かっ。</target>
        </trans-unit>
        <trans-unit id="12d5beb4f208ab2afd01a906d06c0928be9bf9f4" translate="yes" xml:space="preserve">
          <source>Inserts an element at position &lt;code&gt;index&lt;/code&gt; within the vector, shifting all elements after it to the right.</source>
          <target state="translated">ベクトル内の位置 &lt;code&gt;index&lt;/code&gt; に要素を挿入し、その後のすべての要素を右にシフトします。</target>
        </trans-unit>
        <trans-unit id="32004441f1f355a905cf795d20839963739fd9b1" translate="yes" xml:space="preserve">
          <source>Inserts or updates an environment variable mapping.</source>
          <target state="translated">環境変数のマッピングを挿入または更新します。</target>
        </trans-unit>
        <trans-unit id="ec935fc4eff4c401230b5e9494768220ac04ae85" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="translated">指定された &lt;code&gt;value&lt;/code&gt; が存在しない場合はセットに挿入し、セット内の値への参照を返します。</target>
        </trans-unit>
        <trans-unit id="10a95bea4ce01379ab8d7b752bb3fe35f6abf8b1" translate="yes" xml:space="preserve">
          <source>Inserts the given element just after the element most recently returned by &lt;code&gt;.next()&lt;/code&gt;. The inserted element does not appear in the iteration.</source>
          <target state="translated">&lt;code&gt;.next()&lt;/code&gt; によって最後に返された要素の直後に、指定された要素を挿入します。挿入された要素は反復に表示されません。</target>
        </trans-unit>
        <trans-unit id="af470e35471ccbf3c83cd6c715dc2e1540c10617" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;for&lt;/code&gt; loop, we search for the byte that represents the space by using the byte literal syntax. If we find a space, we return the position. Otherwise, we return the length of the string by using &lt;code&gt;s.len()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループ内では、バイトリテラル構文を使用して、スペースを表すバイトを検索します。スペースが見つかったら、位置を返します。それ以外の場合は、 &lt;code&gt;s.len()&lt;/code&gt; を使用して文字列の長さを返します。</target>
        </trans-unit>
        <trans-unit id="49f499d15e7cb0aca0c18bf8de68e4d96c591f23" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;main&lt;/code&gt; function is the following code:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数内には次のコードがあります。</target>
        </trans-unit>
        <trans-unit id="743099d758832aebc06d09f96504a2db95574113" translate="yes" xml:space="preserve">
          <source>Inside the function signature and body, the name of the type parameter can be used as a type name. &lt;a href=&quot;traits&quot;&gt;Trait&lt;/a&gt; bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the &lt;code&gt;where&lt;/code&gt; syntax:</source>
          <target state="translated">関数のシグネチャと本体の内部では、型パラメーターの名前を型名として使用できます。型パラメーターに&lt;a href=&quot;traits&quot;&gt;特性&lt;/a&gt;境界を指定して、その特性を持つメソッドをその型の値で呼び出すことができます。これは、 &lt;code&gt;where&lt;/code&gt; 構文を使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="82ab79e7a84c19ee615f55de9576c57f6039cbaf" translate="yes" xml:space="preserve">
          <source>Inspect::all</source>
          <target state="translated">Inspect::all</target>
        </trans-unit>
        <trans-unit id="af62c7ee7c236c7e17a30a78c2b4fcf9f79c0b4b" translate="yes" xml:space="preserve">
          <source>Inspect::any</source>
          <target state="translated">Inspect::any</target>
        </trans-unit>
        <trans-unit id="b077905231123238f4a7bb9fcc60ce75f6089a93" translate="yes" xml:space="preserve">
          <source>Inspect::borrow</source>
          <target state="translated">Inspect::borrow</target>
        </trans-unit>
        <trans-unit id="dac186ed9d0b7d57d599f5ce890d1950aca83d7e" translate="yes" xml:space="preserve">
          <source>Inspect::borrow_mut</source>
          <target state="translated">Inspect::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eff030734cfa782924c1060ba45ae2c9617ddff7" translate="yes" xml:space="preserve">
          <source>Inspect::by_ref</source>
          <target state="translated">Inspect::by_ref</target>
        </trans-unit>
        <trans-unit id="c6e04f66ee740f870c7db51ddce5c394c1f5b366" translate="yes" xml:space="preserve">
          <source>Inspect::chain</source>
          <target state="translated">Inspect::chain</target>
        </trans-unit>
        <trans-unit id="af5a3161569b3cc4b1af16e096368ee36af988fd" translate="yes" xml:space="preserve">
          <source>Inspect::clone</source>
          <target state="translated">Inspect::clone</target>
        </trans-unit>
        <trans-unit id="4b8f1150495fa883babb18b3738d6b381ca35719" translate="yes" xml:space="preserve">
          <source>Inspect::clone_from</source>
          <target state="translated">Inspect::clone_from</target>
        </trans-unit>
        <trans-unit id="f20fee187ea64cd2682fd76ef634f46c65ea7337" translate="yes" xml:space="preserve">
          <source>Inspect::clone_into</source>
          <target state="translated">Inspect::clone_into</target>
        </trans-unit>
        <trans-unit id="91d60f6fbbeb3649b6191055cd46e14268f30490" translate="yes" xml:space="preserve">
          <source>Inspect::cloned</source>
          <target state="translated">Inspect::cloned</target>
        </trans-unit>
        <trans-unit id="85a2573bc9e0fcf94624c4b800d4b5742004e819" translate="yes" xml:space="preserve">
          <source>Inspect::cmp</source>
          <target state="translated">Inspect::cmp</target>
        </trans-unit>
        <trans-unit id="bb80987b9610829409c7cf311bd83c99cafb9358" translate="yes" xml:space="preserve">
          <source>Inspect::collect</source>
          <target state="translated">Inspect::collect</target>
        </trans-unit>
        <trans-unit id="6c4755e22c04a1a561bd40c8f7ed7cc9e14afdd5" translate="yes" xml:space="preserve">
          <source>Inspect::copied</source>
          <target state="translated">Inspect::copied</target>
        </trans-unit>
        <trans-unit id="d91465c1eb8c20ff2aaf256018f191b4b51027db" translate="yes" xml:space="preserve">
          <source>Inspect::count</source>
          <target state="translated">Inspect::count</target>
        </trans-unit>
        <trans-unit id="f6a3530affc366af3c3031653f04c92d94544c6f" translate="yes" xml:space="preserve">
          <source>Inspect::cycle</source>
          <target state="translated">Inspect::cycle</target>
        </trans-unit>
        <trans-unit id="2ef8727649c440036fbfd895887f256337974360" translate="yes" xml:space="preserve">
          <source>Inspect::enumerate</source>
          <target state="translated">Inspect::enumerate</target>
        </trans-unit>
        <trans-unit id="90d29ac40ce8f2f13585d9242b559870d571b0d2" translate="yes" xml:space="preserve">
          <source>Inspect::eq</source>
          <target state="translated">Inspect::eq</target>
        </trans-unit>
        <trans-unit id="3c8af74b0f8d034e93cc2689eb1582aea35cd194" translate="yes" xml:space="preserve">
          <source>Inspect::filter</source>
          <target state="translated">Inspect::filter</target>
        </trans-unit>
        <trans-unit id="0c1d967d962d5542a61729409b6700ebf061e41a" translate="yes" xml:space="preserve">
          <source>Inspect::filter_map</source>
          <target state="translated">Inspect::filter_map</target>
        </trans-unit>
        <trans-unit id="ef11d99b08eee4456cbbcf30c8d5eaf30c8a59bd" translate="yes" xml:space="preserve">
          <source>Inspect::find</source>
          <target state="translated">Inspect::find</target>
        </trans-unit>
        <trans-unit id="de75c9aaf20b405a1c60fd94f4dbe93e04bb79b9" translate="yes" xml:space="preserve">
          <source>Inspect::find_map</source>
          <target state="translated">Inspect::find_map</target>
        </trans-unit>
        <trans-unit id="4bdd706bdfb04e01d1c9af213d5586e2748a2444" translate="yes" xml:space="preserve">
          <source>Inspect::flat_map</source>
          <target state="translated">Inspect::flat_map</target>
        </trans-unit>
        <trans-unit id="adc62575b9ec6c48f327e8e73d67dd12a37fd54f" translate="yes" xml:space="preserve">
          <source>Inspect::flatten</source>
          <target state="translated">Inspect::flatten</target>
        </trans-unit>
        <trans-unit id="bf64f53f8ddafacb88390ac8654fa5e287a73a7c" translate="yes" xml:space="preserve">
          <source>Inspect::fmt</source>
          <target state="translated">Inspect::fmt</target>
        </trans-unit>
        <trans-unit id="e1203b82ecf5e7d86eeb57728448c3072c4d31ca" translate="yes" xml:space="preserve">
          <source>Inspect::fold</source>
          <target state="translated">Inspect::fold</target>
        </trans-unit>
        <trans-unit id="e36f213246f9d2f573670ffad6151bd06e3fa586" translate="yes" xml:space="preserve">
          <source>Inspect::for_each</source>
          <target state="translated">Inspect::for_each</target>
        </trans-unit>
        <trans-unit id="e7c3f5132be9e5287630addcdee29ef7865ef06d" translate="yes" xml:space="preserve">
          <source>Inspect::from</source>
          <target state="translated">Inspect::from</target>
        </trans-unit>
        <trans-unit id="fe4bfacc82f6be56fbd2cbdacbd9f9c98dbeb4d0" translate="yes" xml:space="preserve">
          <source>Inspect::fuse</source>
          <target state="translated">Inspect::fuse</target>
        </trans-unit>
        <trans-unit id="18e6f5734f2efd739f3505c74a0c0d087a45dc44" translate="yes" xml:space="preserve">
          <source>Inspect::ge</source>
          <target state="translated">Inspect::ge</target>
        </trans-unit>
        <trans-unit id="51b9499c2f6bcf728ec327afb3eadb4e80054ef7" translate="yes" xml:space="preserve">
          <source>Inspect::gt</source>
          <target state="translated">Inspect::gt</target>
        </trans-unit>
        <trans-unit id="df78def6e9a15f9326fc866aa7162363317dfe3c" translate="yes" xml:space="preserve">
          <source>Inspect::inspect</source>
          <target state="translated">Inspect::inspect</target>
        </trans-unit>
        <trans-unit id="cde84bc6a1ac6acfa3ca27e39148f1683f7a639a" translate="yes" xml:space="preserve">
          <source>Inspect::into</source>
          <target state="translated">Inspect::into</target>
        </trans-unit>
        <trans-unit id="0c85f8b299a3868a074eadb647478881cca1f5f2" translate="yes" xml:space="preserve">
          <source>Inspect::into_iter</source>
          <target state="translated">Inspect::into_iter</target>
        </trans-unit>
        <trans-unit id="93bdbca2f9e35d0382950f48be8119f4c4cd8c39" translate="yes" xml:space="preserve">
          <source>Inspect::is_empty</source>
          <target state="translated">Inspect::is_empty</target>
        </trans-unit>
        <trans-unit id="6cb061e34832197156e0eae9b796318c52eae21c" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted</source>
          <target state="translated">Inspect::is_sorted</target>
        </trans-unit>
        <trans-unit id="0b700978aa9715e5aeabd053030f7e06e5dfdbe8" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by</source>
          <target state="translated">Inspect::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="01522e5b03123c9816813cfbecb670d36dcf9bae" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by_key</source>
          <target state="translated">Inspect::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="97c7968340cdbfc55e6279e63210f8319602c3b1" translate="yes" xml:space="preserve">
          <source>Inspect::last</source>
          <target state="translated">Inspect::last</target>
        </trans-unit>
        <trans-unit id="1641c5ab204a86bd76b52647b967fa3844ee555e" translate="yes" xml:space="preserve">
          <source>Inspect::le</source>
          <target state="translated">Inspect::le</target>
        </trans-unit>
        <trans-unit id="8fedbf984d9131a9c32910d0dd8cd507c9ae41f1" translate="yes" xml:space="preserve">
          <source>Inspect::len</source>
          <target state="translated">Inspect::len</target>
        </trans-unit>
        <trans-unit id="2aae13f70bf251eedf4d622e3c8e8d7ebe509466" translate="yes" xml:space="preserve">
          <source>Inspect::lt</source>
          <target state="translated">Inspect::lt</target>
        </trans-unit>
        <trans-unit id="3c10daeba2bb0af4fb652f56b13c4f712081ee60" translate="yes" xml:space="preserve">
          <source>Inspect::map</source>
          <target state="translated">Inspect::map</target>
        </trans-unit>
        <trans-unit id="d7ab985e5175dcb4007a24ad2073cd92e1ee725b" translate="yes" xml:space="preserve">
          <source>Inspect::max</source>
          <target state="translated">Inspect::max</target>
        </trans-unit>
        <trans-unit id="5548cb84f4f36e68e97b0766437c90e71bec388e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by</source>
          <target state="translated">Inspect::max_by</target>
        </trans-unit>
        <trans-unit id="dce539004497e98e80382919f2b44ac4f343a42e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by_key</source>
          <target state="translated">Inspect::max_by_key</target>
        </trans-unit>
        <trans-unit id="588f749d074427554e4d2614e02fff13ad9cd053" translate="yes" xml:space="preserve">
          <source>Inspect::min</source>
          <target state="translated">Inspect::min</target>
        </trans-unit>
        <trans-unit id="60fe678c3fd98d803d7a0a967cf63b451cdaf79c" translate="yes" xml:space="preserve">
          <source>Inspect::min_by</source>
          <target state="translated">Inspect::min_by</target>
        </trans-unit>
        <trans-unit id="2487d43ef493a331b1b717bc22f40361c1ef635a" translate="yes" xml:space="preserve">
          <source>Inspect::min_by_key</source>
          <target state="translated">Inspect::min_by_key</target>
        </trans-unit>
        <trans-unit id="ffc55c77a0a3cf78936319f186df9927df3e0ccd" translate="yes" xml:space="preserve">
          <source>Inspect::ne</source>
          <target state="translated">Inspect::ne</target>
        </trans-unit>
        <trans-unit id="a43fcb5b031c0ce3926f10977d7f6a10a43f6208" translate="yes" xml:space="preserve">
          <source>Inspect::next</source>
          <target state="translated">Inspect::next</target>
        </trans-unit>
        <trans-unit id="6febe3467ee6ea45f701752f64651a80fe8404ab" translate="yes" xml:space="preserve">
          <source>Inspect::next_back</source>
          <target state="translated">Inspect::next_back</target>
        </trans-unit>
        <trans-unit id="0f9d290f3781cb4ac95ed05a1829eb899359b7f9" translate="yes" xml:space="preserve">
          <source>Inspect::nth</source>
          <target state="translated">Inspect::nth</target>
        </trans-unit>
        <trans-unit id="633dbdd78d8cdd2854d53a34adbb447ab4e90331" translate="yes" xml:space="preserve">
          <source>Inspect::nth_back</source>
          <target state="translated">Inspect::nth_back</target>
        </trans-unit>
        <trans-unit id="fc4ec8ac3236397826a770a15ac100842f901223" translate="yes" xml:space="preserve">
          <source>Inspect::partial_cmp</source>
          <target state="translated">Inspect::partial_cmp</target>
        </trans-unit>
        <trans-unit id="40853e163585e56c8285d38aa5808ca70dc06c35" translate="yes" xml:space="preserve">
          <source>Inspect::partition</source>
          <target state="translated">Inspect::partition</target>
        </trans-unit>
        <trans-unit id="9434c28e5a571fffcf6e901ec452b5ae6a98ab38" translate="yes" xml:space="preserve">
          <source>Inspect::peekable</source>
          <target state="translated">Inspect::peekable</target>
        </trans-unit>
        <trans-unit id="43968189a660c3e4fac603b379bde0cd86ad697c" translate="yes" xml:space="preserve">
          <source>Inspect::position</source>
          <target state="translated">Inspect::position</target>
        </trans-unit>
        <trans-unit id="89b4972ffab1f05ea2fbde1d69c01d599123b156" translate="yes" xml:space="preserve">
          <source>Inspect::product</source>
          <target state="translated">Inspect::product</target>
        </trans-unit>
        <trans-unit id="0443653aa8a5d69a1b0d33c9f17e2c9254f5f5d7" translate="yes" xml:space="preserve">
          <source>Inspect::rev</source>
          <target state="translated">Inspect::rev</target>
        </trans-unit>
        <trans-unit id="7cb21ca083cda72535e929cef63f871b4f3cf651" translate="yes" xml:space="preserve">
          <source>Inspect::rfind</source>
          <target state="translated">Inspect::rfind</target>
        </trans-unit>
        <trans-unit id="f79e10ec84996051e8312ada6ac965fccb6846de" translate="yes" xml:space="preserve">
          <source>Inspect::rfold</source>
          <target state="translated">Inspect::rfold</target>
        </trans-unit>
        <trans-unit id="f78976291c9758ab5955ca36b2caedb636e425a2" translate="yes" xml:space="preserve">
          <source>Inspect::rposition</source>
          <target state="translated">Inspect::rposition</target>
        </trans-unit>
        <trans-unit id="2392835414c1e0b5afa2ace3b96de2ef5ff9083c" translate="yes" xml:space="preserve">
          <source>Inspect::scan</source>
          <target state="translated">Inspect::scan</target>
        </trans-unit>
        <trans-unit id="3e468495e996e3f520360765bb1983040761bf4d" translate="yes" xml:space="preserve">
          <source>Inspect::size_hint</source>
          <target state="translated">Inspect::size_hint</target>
        </trans-unit>
        <trans-unit id="65d5d88728cb3772dee70aa6ae26fe906858cdfa" translate="yes" xml:space="preserve">
          <source>Inspect::skip</source>
          <target state="translated">Inspect::skip</target>
        </trans-unit>
        <trans-unit id="e4df02a7fa585f7bf67e2c2e7620ec2b27bf223a" translate="yes" xml:space="preserve">
          <source>Inspect::skip_while</source>
          <target state="translated">Inspect::skip_while</target>
        </trans-unit>
        <trans-unit id="81611aac4ee662fdf8e1bb6309a5396db2852250" translate="yes" xml:space="preserve">
          <source>Inspect::step_by</source>
          <target state="translated">Inspect::step_by</target>
        </trans-unit>
        <trans-unit id="333ad3419c346fac8b8d3c0fd4cc6a07785ed3a9" translate="yes" xml:space="preserve">
          <source>Inspect::sum</source>
          <target state="translated">Inspect::sum</target>
        </trans-unit>
        <trans-unit id="07c4846ffa005c2b497a796ecdc14a564003a4a8" translate="yes" xml:space="preserve">
          <source>Inspect::take</source>
          <target state="translated">Inspect::take</target>
        </trans-unit>
        <trans-unit id="4f28a1534dff8b2e2c944f0bfaafe96286e1baaa" translate="yes" xml:space="preserve">
          <source>Inspect::take_while</source>
          <target state="translated">Inspect::take_while</target>
        </trans-unit>
        <trans-unit id="2a423ad3eae2fec9385b69311ba93e53244f0ad5" translate="yes" xml:space="preserve">
          <source>Inspect::to_owned</source>
          <target state="translated">Inspect::to_owned</target>
        </trans-unit>
        <trans-unit id="a6362c52c757937e435b1eeef2d9ab055596b389" translate="yes" xml:space="preserve">
          <source>Inspect::try_fold</source>
          <target state="translated">Inspect::try_fold</target>
        </trans-unit>
        <trans-unit id="b44f87043be8c6e37fe81b5e52b558de6e2af9af" translate="yes" xml:space="preserve">
          <source>Inspect::try_for_each</source>
          <target state="translated">Inspect::try_for_each</target>
        </trans-unit>
        <trans-unit id="2933e22002dc23a223d51ac3b5541e6507691dd0" translate="yes" xml:space="preserve">
          <source>Inspect::try_from</source>
          <target state="translated">Inspect::try_from</target>
        </trans-unit>
        <trans-unit id="b21cad5abb074d64e5dc5deb026a557335ea6176" translate="yes" xml:space="preserve">
          <source>Inspect::try_into</source>
          <target state="translated">Inspect::try_into</target>
        </trans-unit>
        <trans-unit id="1fd81bf07a71bc1209ac8f8b1e33f27ed1378a45" translate="yes" xml:space="preserve">
          <source>Inspect::try_rfold</source>
          <target state="translated">Inspect::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e9b8b3f317cc849ace42df081dd27ff57c0541e" translate="yes" xml:space="preserve">
          <source>Inspect::type_id</source>
          <target state="translated">Inspect::type_id</target>
        </trans-unit>
        <trans-unit id="41140164c66c290cc48804ad982a4e7115e22da9" translate="yes" xml:space="preserve">
          <source>Inspect::unzip</source>
          <target state="translated">Inspect::unzip</target>
        </trans-unit>
        <trans-unit id="fe0d4b72621d75d8a76f592b0efd07f85c74dca9" translate="yes" xml:space="preserve">
          <source>Inspect::zip</source>
          <target state="translated">Inspect::zip</target>
        </trans-unit>
        <trans-unit id="8a955d8f62cddda7e4b47eb2772b795f5ac4e929" translate="yes" xml:space="preserve">
          <source>Inspecting a foreign C string:</source>
          <target state="translated">外部のC文字列を検査します。</target>
        </trans-unit>
        <trans-unit id="24c028aad5e4f71eb7323a7fdf907c77523124b6" translate="yes" xml:space="preserve">
          <source>Inspection and manipulation of the process's environment.</source>
          <target state="translated">プロセスの環境の検査・操作。</target>
        </trans-unit>
        <trans-unit id="2cc2859dfe537be8955a457d12a963c9483cf55a" translate="yes" xml:space="preserve">
          <source>Inspects an environment variable at compile time.</source>
          <target state="translated">コンパイル時に環境変数を検査します。</target>
        </trans-unit>
        <trans-unit id="da805945f5409d032b925fa086323fea9942dc3f" translate="yes" xml:space="preserve">
          <source>Install binaries from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;からバイナリをインストールする</target>
        </trans-unit>
        <trans-unit id="27807feadc6086bb00cc2f2fc11c34f918ce0b35" translate="yes" xml:space="preserve">
          <source>Install the latest stable version of Rust using &lt;code&gt;rustup&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rustup&lt;/code&gt; を使用して最新の安定したバージョンのRustをインストールする</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="8bc95ab544ffc801a72a650102cb1b4b0031b02c" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; on Linux or macOS</source>
          <target state="translated">LinuxまたはmacOSへの &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; のインストール</target>
        </trans-unit>
        <trans-unit id="d41546865affb2f20149c73fe77f1fc24d402ca2" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; on Windows</source>
          <target state="translated">Windowsへの &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; のインストール</target>
        </trans-unit>
        <trans-unit id="e19f38815d4acff6e4f527222a8aef2789228129" translate="yes" xml:space="preserve">
          <source>Installing Binaries from Crates.io with &lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt; Crates.ioからバイナリをインストールする</target>
        </trans-unit>
        <trans-unit id="b810516d3307cdf27a35ee79c057d48b6aa21230" translate="yes" xml:space="preserve">
          <source>Installing Rust on Linux, macOS, and Windows</source>
          <target state="translated">Linux、macOS、WindowsへのRustのインストール</target>
        </trans-unit>
        <trans-unit id="2c30b9b10b587e1e4e3853ef85ec4740848abbd7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Fn&lt;/code&gt; can be called repeatedly without mutating state.</source>
          <target state="translated">&lt;code&gt;Fn&lt;/code&gt; のインスタンスは、状態を変更せずに繰り返し呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="1322a032825805d3a73d3fe7e3a12985cf1de692" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnMut&lt;/code&gt; can be called repeatedly and may mutate state.</source>
          <target state="translated">&lt;code&gt;FnMut&lt;/code&gt; のインスタンスは繰り返し呼び出すことができ、状態が変化する場合があります。</target>
        </trans-unit>
        <trans-unit id="b9bc8df98d67671ea9af2ebbd9472094277d62c7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnOnce&lt;/code&gt; can be called, but might not be callable multiple times. Because of this, if the only thing known about a type is that it implements &lt;code&gt;FnOnce&lt;/code&gt;, it can only be called once.</source>
          <target state="translated">&lt;code&gt;FnOnce&lt;/code&gt; のインスタンスは呼び出すことができますが、複数回呼び出すことができない場合があります。このため、型についてわかっていることが &lt;code&gt;FnOnce&lt;/code&gt; を実装していることだけである場合、一度しか呼び出せません。</target>
        </trans-unit>
        <trans-unit id="5b9d31413b772c5dc3e318115ee395c8ad114636" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Hasher&lt;/code&gt; usually represent state that is changed while hashing data.</source>
          <target state="translated">&lt;code&gt;Hasher&lt;/code&gt; のインスタンスは通常、データのハッシュ中に変更される状態を表します。</target>
        </trans-unit>
        <trans-unit id="21ec3e515a993282791572f7098d9de91b54a575" translate="yes" xml:space="preserve">
          <source>Instances of this &lt;code&gt;struct&lt;/code&gt; can be obtained by matching against the &lt;a href=&quot;enum.component#variant.Prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt; variant&lt;/a&gt; on &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この &lt;code&gt;struct&lt;/code&gt; インスタンスは、&lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; の&lt;/a&gt;&lt;a href=&quot;enum.component#variant.Prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; バリアントと&lt;/a&gt;照合することで取得できます。</target>
        </trans-unit>
        <trans-unit id="e5dd7083ff5f07cec7b9b34c02884013f777ac05" translate="yes" xml:space="preserve">
          <source>Instant</source>
          <target state="translated">Instant</target>
        </trans-unit>
        <trans-unit id="b5ac78fce22209b999309e8a7436e97b10622104" translate="yes" xml:space="preserve">
          <source>Instant::add</source>
          <target state="translated">Instant::add</target>
        </trans-unit>
        <trans-unit id="e5c83578445bb46f2191fb87fb2e970bfde98993" translate="yes" xml:space="preserve">
          <source>Instant::add_assign</source>
          <target state="translated">Instant::add_assign</target>
        </trans-unit>
        <trans-unit id="0c8c3b63eb155a52c73bfac3155d0197dd1a085d" translate="yes" xml:space="preserve">
          <source>Instant::borrow</source>
          <target state="translated">Instant::borrow</target>
        </trans-unit>
        <trans-unit id="f0f79568d43ec6cff172ef06950242a1e38ab9d4" translate="yes" xml:space="preserve">
          <source>Instant::borrow_mut</source>
          <target state="translated">Instant::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2e29432f378f62b734e945a4acd41b7defd436d4" translate="yes" xml:space="preserve">
          <source>Instant::checked_add</source>
          <target state="translated">Instant::checked_add</target>
        </trans-unit>
        <trans-unit id="eb4f8d11d037399c427f9a46cdb4e74b0b9fb310" translate="yes" xml:space="preserve">
          <source>Instant::checked_duration_since</source>
          <target state="translated">Instant::checked_duration_since</target>
        </trans-unit>
        <trans-unit id="f623e63718dd7f5e08fc4822d3ea1e552e483468" translate="yes" xml:space="preserve">
          <source>Instant::checked_sub</source>
          <target state="translated">Instant::checked_sub</target>
        </trans-unit>
        <trans-unit id="f7961f96937c07d9b42758cbb78758eeb1202726" translate="yes" xml:space="preserve">
          <source>Instant::clamp</source>
          <target state="translated">Instant::clamp</target>
        </trans-unit>
        <trans-unit id="a221c46ded2b61b64dcb1f60bfcb2b2993a3a5c9" translate="yes" xml:space="preserve">
          <source>Instant::clone</source>
          <target state="translated">Instant::clone</target>
        </trans-unit>
        <trans-unit id="0e4e4ec37ffa30c7418b3d4c01f925199339bd78" translate="yes" xml:space="preserve">
          <source>Instant::clone_from</source>
          <target state="translated">Instant::clone_from</target>
        </trans-unit>
        <trans-unit id="8b5bc24c2667bb02ad8d0c988c0c260c44857a92" translate="yes" xml:space="preserve">
          <source>Instant::clone_into</source>
          <target state="translated">Instant::clone_into</target>
        </trans-unit>
        <trans-unit id="e2495f5ad07793d7e77643dd4f486d02627866e1" translate="yes" xml:space="preserve">
          <source>Instant::cmp</source>
          <target state="translated">Instant::cmp</target>
        </trans-unit>
        <trans-unit id="5bb91176ea9d1de93e298e46888f1699788ffa0c" translate="yes" xml:space="preserve">
          <source>Instant::duration_since</source>
          <target state="translated">Instant::duration_since</target>
        </trans-unit>
        <trans-unit id="afcae638aa376f5908f1f30bd28087f8ac6046bd" translate="yes" xml:space="preserve">
          <source>Instant::elapsed</source>
          <target state="translated">Instant::elapsed</target>
        </trans-unit>
        <trans-unit id="243a247fce13eeb9a4a84c1d5fb1dac67574f6d1" translate="yes" xml:space="preserve">
          <source>Instant::eq</source>
          <target state="translated">Instant::eq</target>
        </trans-unit>
        <trans-unit id="c0e9c53ccf6d3d28525b5acc190c32004eb85ec8" translate="yes" xml:space="preserve">
          <source>Instant::fmt</source>
          <target state="translated">Instant::fmt</target>
        </trans-unit>
        <trans-unit id="91e13bb77c7e58f374e2d3daa91a9fc513ccb0bb" translate="yes" xml:space="preserve">
          <source>Instant::from</source>
          <target state="translated">Instant::from</target>
        </trans-unit>
        <trans-unit id="666400c2a2e214fcba1e53bc6d351d576dedbf88" translate="yes" xml:space="preserve">
          <source>Instant::ge</source>
          <target state="translated">Instant::ge</target>
        </trans-unit>
        <trans-unit id="e1545f7a496f8f598ffee1a4b219bdc08ac325eb" translate="yes" xml:space="preserve">
          <source>Instant::gt</source>
          <target state="translated">Instant::gt</target>
        </trans-unit>
        <trans-unit id="41c216d5664a8a7e6d226c8c88076fb379772e86" translate="yes" xml:space="preserve">
          <source>Instant::hash</source>
          <target state="translated">Instant::hash</target>
        </trans-unit>
        <trans-unit id="754e2486a3657aa16f85c8a3399792e46fc3859e" translate="yes" xml:space="preserve">
          <source>Instant::hash_slice</source>
          <target state="translated">Instant::hash_slice</target>
        </trans-unit>
        <trans-unit id="77b8dcf93181fdfb9c2ccd019961362f091bc10d" translate="yes" xml:space="preserve">
          <source>Instant::into</source>
          <target state="translated">Instant::into</target>
        </trans-unit>
        <trans-unit id="27c580d98c20ea09e90f23c4e7129dd284f1e540" translate="yes" xml:space="preserve">
          <source>Instant::le</source>
          <target state="translated">Instant::le</target>
        </trans-unit>
        <trans-unit id="077dca8f66a9fddef8fd3afcd25ba70cba946a7c" translate="yes" xml:space="preserve">
          <source>Instant::lt</source>
          <target state="translated">Instant::lt</target>
        </trans-unit>
        <trans-unit id="5f279b9b945d564222473676176af94a42a66352" translate="yes" xml:space="preserve">
          <source>Instant::max</source>
          <target state="translated">Instant::max</target>
        </trans-unit>
        <trans-unit id="1fef472f05cd2b320ab2c2019b4644689c5cb2f0" translate="yes" xml:space="preserve">
          <source>Instant::min</source>
          <target state="translated">Instant::min</target>
        </trans-unit>
        <trans-unit id="2607167b08c7b923c8543daeccd1a89c638f791c" translate="yes" xml:space="preserve">
          <source>Instant::ne</source>
          <target state="translated">Instant::ne</target>
        </trans-unit>
        <trans-unit id="2e89ed9eeb6e6fedfd76e029598f95d52ac89e9c" translate="yes" xml:space="preserve">
          <source>Instant::now</source>
          <target state="translated">Instant::now</target>
        </trans-unit>
        <trans-unit id="ef217fe283814eb7e0d5fb84203270e40f97b8d2" translate="yes" xml:space="preserve">
          <source>Instant::partial_cmp</source>
          <target state="translated">Instant::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bf1b8520fb2822b3f5cb83bccfd646a516fffcbf" translate="yes" xml:space="preserve">
          <source>Instant::saturating_duration_since</source>
          <target state="translated">Instant::saturating_duration_since</target>
        </trans-unit>
        <trans-unit id="9ed1ccf1a589fe42420c89b940730dc8b7982f7d" translate="yes" xml:space="preserve">
          <source>Instant::sub</source>
          <target state="translated">Instant::sub</target>
        </trans-unit>
        <trans-unit id="57ade0b6d4dcc1517fdb9cf85b73a61857e80559" translate="yes" xml:space="preserve">
          <source>Instant::sub_assign</source>
          <target state="translated">Instant::sub_assign</target>
        </trans-unit>
        <trans-unit id="bdec0c97db20d86ebdd661571569d5a69a65be45" translate="yes" xml:space="preserve">
          <source>Instant::to_owned</source>
          <target state="translated">Instant::to_owned</target>
        </trans-unit>
        <trans-unit id="0901e5a9482040c503269599b849e7e300181ba0" translate="yes" xml:space="preserve">
          <source>Instant::try_from</source>
          <target state="translated">Instant::try_from</target>
        </trans-unit>
        <trans-unit id="5df3e1f653d0b4e8c037a1c9641f59e6a8cbc24c" translate="yes" xml:space="preserve">
          <source>Instant::try_into</source>
          <target state="translated">Instant::try_into</target>
        </trans-unit>
        <trans-unit id="69f76dc23d56db8a52e6e54a74ec2db10116eb78" translate="yes" xml:space="preserve">
          <source>Instant::type_id</source>
          <target state="translated">Instant::type_id</target>
        </trans-unit>
        <trans-unit id="001172aad080d8306d5d4d1b5dc437b8d68f3a48" translate="yes" xml:space="preserve">
          <source>Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; would be an example from above. When data follows along with a variant, such as with rust's built-in &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; type, the data is added as the type describes, for example &lt;code&gt;Option::Some(123)&lt;/code&gt;. The same follows with struct-like variants, with things looking like &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt;. Empty Enums are similar to () in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.</source>
          <target state="translated">enumバリアントのインスタンス化では、enumの名前を名前空間として明示的に使用し、その後にそのバリアントの1つを続けます。 &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; は、上記の例です。 rustの組み込み&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;タイプなど、バリアントに沿ってデータが続く場合、データはタイプが説明するとおりに追加されます &lt;code&gt;Option::Some(123)&lt;/code&gt; 例：Option :: Some（123））。同じことは、構造体のようなバリアントでも続き、 &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt; ます。空のEnumは、インスタンス化できないという点で（）に似ており、主に型システムを面白い方法で混乱させるために使用されます。</target>
        </trans-unit>
        <trans-unit id="89d417c0066da918ab986006990b8c13e4a1c9d4" translate="yes" xml:space="preserve">
          <source>Instantiation</source>
          <target state="translated">Instantiation</target>
        </trans-unit>
        <trans-unit id="b9d10d744d3b830949e2bf595c80e084be4f440a" translate="yes" xml:space="preserve">
          <source>Instantiations of struct or variant fields</source>
          <target state="translated">構造体またはバリアントフィールドのインスタンス</target>
        </trans-unit>
        <trans-unit id="f7b4faec33775d5b4afedfc919179e22bbcfd3c9" translate="yes" xml:space="preserve">
          <source>Instants are always guaranteed to be no less than any previously measured instant when created, and are often useful for tasks such as measuring benchmarks or timing how long an operation takes.</source>
          <target state="translated">インスタントは、作成時には常に以前に測定されたどのインスタントにも劣らないことが保証されており、ベンチマークを測定したり、操作にかかる時間を計ったりするのに便利なことが多いです。</target>
        </trans-unit>
        <trans-unit id="283f4073d67eb71b9aee283558af89f84e2066b3" translate="yes" xml:space="preserve">
          <source>Instants are opaque types that can only be compared to one another. There is no method to get &quot;the number of seconds&quot; from an instant. Instead, it only allows measuring the duration between two instants (or comparing two instants).</source>
          <target state="translated">インスタントは、互いに比較することしかできない不透明なタイプです。インスタントから「秒数」を取得する方法はありません。代わりに、2つのインスタンス間の持続時間を測定することができるだけです(または、2つのインスタンスを比較することができます)。</target>
        </trans-unit>
        <trans-unit id="61804bc8442fc7d7bb4e71e306aef5c0aea1b60a" translate="yes" xml:space="preserve">
          <source>Instead it is used to prevent moves through the type system, by controlling the behavior of pointers &lt;code&gt;P&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper, which &quot;pin&quot; the type in place by not allowing it to be moved out of them. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin module&lt;/code&gt;&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="translated">代わりに、&lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;ラッパーでラップされたポインター &lt;code&gt;P&lt;/code&gt; の動作を制御することにより、型システム内での移動を防止するために使用されます。&lt;a href=&quot;../pin/index&quot;&gt; &lt;code&gt;pin module&lt;/code&gt; &lt;/a&gt;詳細については、ピンモジュールのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="3589fb3ebd4ad6821bd6d9b7e8dfdf86bb935287" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ok&lt;/code&gt;, the line &lt;code&gt;test tests::another&lt;/code&gt; shows &lt;code&gt;FAILED&lt;/code&gt;. Two new sections appear between the individual results and the summary: the first section displays the detailed reason for each test failure. In this case, &lt;code&gt;another&lt;/code&gt; failed because it &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt;, which happened on line 10 in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to more easily debug it; we&amp;rsquo;ll talk more about ways to run tests in the &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; の代わりに、行 &lt;code&gt;test tests::another&lt;/code&gt; は &lt;code&gt;FAILED&lt;/code&gt; を示します。個々の結果と要約の間に2つの新しいセクションが表示されます。最初のセクションには、各テストの失敗の詳細な理由が表示されます。この場合、&lt;em&gt;src / lib.rs&lt;/em&gt;ファイルの10行目で発生 &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt; でパニックが発生したため、 &lt;code&gt;another&lt;/code&gt; 失敗しました。次のセクションには、失敗したすべてのテストの名前だけがリストされています。これは、多数のテストと詳細な失敗したテスト出力がたくさんある場合に役立ちます。失敗したテストの名前を使用して、そのテストのみを実行し、より簡単にデバッグできます。テストの実行方法については、&lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;「テストの実行方法の制御」&lt;/a&gt;セクションで詳しく説明します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a520d0103dd9e1e65d5d07eb5562a910a387f00" translate="yes" xml:space="preserve">
          <source>Instead of a concrete type for the &lt;code&gt;item&lt;/code&gt; parameter, we specify the &lt;code&gt;impl&lt;/code&gt; keyword and the trait name. This parameter accepts any type that implements the specified trait. In the body of &lt;code&gt;notify&lt;/code&gt;, we can call any methods on &lt;code&gt;item&lt;/code&gt; that come from the &lt;code&gt;Summary&lt;/code&gt; trait, such as &lt;code&gt;summarize&lt;/code&gt;. We can call &lt;code&gt;notify&lt;/code&gt; and pass in any instance of &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt;. Code that calls the function with any other type, such as a &lt;code&gt;String&lt;/code&gt; or an &lt;code&gt;i32&lt;/code&gt;, won&amp;rsquo;t compile because those types don&amp;rsquo;t implement &lt;code&gt;Summary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;item&lt;/code&gt; パラメータの具体的なタイプの代わりに、 &lt;code&gt;impl&lt;/code&gt; キーワードと特性名を指定します。このパラメーターは、指定された特性を実装するすべてのタイプを受け入れます。ボディに &lt;code&gt;notify&lt;/code&gt; 、我々は上の任意のメソッドを呼び出すことができます &lt;code&gt;item&lt;/code&gt; から来る &lt;code&gt;Summary&lt;/code&gt; などの特性、 &lt;code&gt;summarize&lt;/code&gt; 。 &lt;code&gt;NewsArticle&lt;/code&gt; または &lt;code&gt;Tweet&lt;/code&gt; のどのインスタンスでも、 &lt;code&gt;notify&lt;/code&gt; を呼び出して渡すことができます。 &lt;code&gt;String&lt;/code&gt; や &lt;code&gt;i32&lt;/code&gt; などの他のタイプの関数を呼び出すコードは、これらのタイプが &lt;code&gt;Summary&lt;/code&gt; を実装していないため、コンパイルされません。</target>
        </trans-unit>
        <trans-unit id="c586c2da19eaf29595cd7783a0bdd1aaa4af1f4c" translate="yes" xml:space="preserve">
          <source>Instead of adding the &lt;code&gt;assert!&lt;/code&gt; macro as we&amp;rsquo;ve done here, we could make &lt;code&gt;new&lt;/code&gt; return a &lt;code&gt;Result&lt;/code&gt; like we did with &lt;code&gt;Config::new&lt;/code&gt; in the I/O project in Listing 12-9. But we&amp;rsquo;ve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error. If you&amp;rsquo;re feeling ambitious, try to write a version of &lt;code&gt;new&lt;/code&gt; with the following signature to compare both versions:</source>
          <target state="translated">&lt;code&gt;assert!&lt;/code&gt; を追加する代わりに！ここで行ったように、マクロを使用して、リスト12-9のI / Oプロジェクトの &lt;code&gt;Config::new&lt;/code&gt; で行ったように、 &lt;code&gt;new&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 返すことができます。ただし、この場合、スレッドなしでスレッドプールを作成しようとすると、回復不可能なエラーになるはずです。意欲的な場合は、次のシグネチャを使用して &lt;code&gt;new&lt;/code&gt; のバージョンを作成し、両方のバージョンを比較してください。</target>
        </trans-unit>
        <trans-unit id="9745bfc2f2927dceb9288ed29cf395b852078f44" translate="yes" xml:space="preserve">
          <source>Instead of always calling the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function before the &lt;code&gt;if&lt;/code&gt; blocks, we can define a closure and store the &lt;em&gt;closure&lt;/em&gt; in a variable rather than storing the result of the function call, as shown in Listing 13-5. We can actually move the whole body of &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; within the closure we&amp;rsquo;re introducing here.</source>
          <target state="translated">代わりに、常に呼び出しの &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; の前に機能を &lt;code&gt;if&lt;/code&gt; ブロック、我々はクロージャを定義することができますし、保存&lt;em&gt;閉鎖を&lt;/em&gt;リスト13-5に示すように、変数ではなく、関数呼び出しの結果を格納します。ここで紹介するクロージャー内で &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 本体全体を実際に移動できます。</target>
        </trans-unit>
        <trans-unit id="ae67e98f84394870dad9c2dee4383fa199b41a3d" translate="yes" xml:space="preserve">
          <source>Instead of comparing the iterator's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">イテレータの要素を直接比較するのではなく、この関数は、 &lt;code&gt;f&lt;/code&gt; によって決定されるように、要素のキーを比較します。それ以外は、&lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt;と同等です。詳細については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="3f4a03c266892c8db13bbe1ed2f70b65c01aa093" translate="yes" xml:space="preserve">
          <source>Instead of comparing the slice's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">この関数は、スライスの要素を直接比較するのではなく、 &lt;code&gt;f&lt;/code&gt; によって決定されるように、要素のキーを比較します。それ以外は、&lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt;と同等です。詳細については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="cf669630673f131e83096baf2080a7fff2853dbb" translate="yes" xml:space="preserve">
          <source>Instead of saving the closure in a variable directly, we save a new instance of &lt;code&gt;Cacher&lt;/code&gt; that holds the closure. Then, in each place we want the result, we call the &lt;code&gt;value&lt;/code&gt; method on the &lt;code&gt;Cacher&lt;/code&gt; instance. We can call the &lt;code&gt;value&lt;/code&gt; method as many times as we want, or not call it at all, and the expensive calculation will be run a maximum of once.</source>
          <target state="translated">クロージャーを変数に直接保存する代わりに、クロージャーを保持する &lt;code&gt;Cacher&lt;/code&gt; の新しいインスタンスを保存します。次に、結果が必要な各場所で、 &lt;code&gt;Cacher&lt;/code&gt; インスタンスの &lt;code&gt;value&lt;/code&gt; メソッドを呼び出します。私たちは、呼び出すことができる &lt;code&gt;value&lt;/code&gt; 私たちが望むように何回のような方法を、またはすべてでそれを呼び出さない、と高価な計算は、かつての最大の実行されます。</target>
        </trans-unit>
        <trans-unit id="007ce9d48190918926ae8e5decfb3ba7fb1ee115" translate="yes" xml:space="preserve">
          <source>Instead of saving the result of the build in the same directory as our code, Cargo stores it in the &lt;em&gt;target/debug&lt;/em&gt; directory.</source>
          <target state="translated">ビルドの結果をコードと同じディレクトリに保存する代わりに、Cargoはそれを&lt;em&gt;target / debug&lt;/em&gt;ディレクトリに保存します。</target>
        </trans-unit>
        <trans-unit id="12c9e09de719f2e7a3f500e0f9b7335d3a4a658d" translate="yes" xml:space="preserve">
          <source>Instead of stopping at &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will instead start again, from the beginning. After iterating again, it will start at the beginning again. And again. And again. Forever.</source>
          <target state="translated">イテレータは&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;で停止する代わりに、最初から再開します。再度繰り返した後、再び最初から開始します。そしてまた。そしてまた。永遠に。</target>
        </trans-unit>
        <trans-unit id="57207c003495c85f3158cd50928c0d6b80c8565c" translate="yes" xml:space="preserve">
          <source>Instead of storing a vector of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances in the thread pool, we&amp;rsquo;ll store instances of the &lt;code&gt;Worker&lt;/code&gt; struct. Each &lt;code&gt;Worker&lt;/code&gt; will store a single &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instance. Then we&amp;rsquo;ll implement a method on &lt;code&gt;Worker&lt;/code&gt; that will take a closure of code to run and send it to the already running thread for execution. We&amp;rsquo;ll also give each worker an &lt;code&gt;id&lt;/code&gt; so we can distinguish between the different workers in the pool when logging or debugging.</source>
          <target state="translated">&lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; インスタンスのベクトルをスレッドプールに格納する代わりに、 &lt;code&gt;Worker&lt;/code&gt; 構造体のインスタンスを格納します。各 &lt;code&gt;Worker&lt;/code&gt; は単一の &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; インスタンスを格納します。次に、 &lt;code&gt;Worker&lt;/code&gt; メソッドを実装して、コードのクロージャーを実行し、すでに実行中のスレッドに送信して実行します。また、ロギングまたはデバッグ時にプール内の異なるワーカーを区別できるように、各ワーカーに &lt;code&gt;id&lt;/code&gt; を割り当てます。</target>
        </trans-unit>
        <trans-unit id="e496da216bd15fab37b8868b5d0249983379dbc2" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">&lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; を使用する代わりに、この関数は指定された &lt;code&gt;compare&lt;/code&gt; 関数を使用して2つの要素の順序を決定します。それ以外は、&lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt;と同等です。詳細については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c10b23d92f193b5b7c4a31db6e9dd35bde4c84df" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">&lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; を使用する代わりに、この関数は指定された &lt;code&gt;compare&lt;/code&gt; 関数を使用して2つの要素の順序を決定します。それ以外は、&lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt;と同等です。詳細については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="78836dae939176c5518d6cb16a8bc88f88e60ed0" translate="yes" xml:space="preserve">
          <source>Instead, the &lt;code&gt;get&lt;/code&gt; method is generic over the type of the underlying key data, called &lt;code&gt;Q&lt;/code&gt; in the method signature above. It states that &lt;code&gt;K&lt;/code&gt; borrows as a &lt;code&gt;Q&lt;/code&gt; by requiring that &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt;. By additionally requiring &lt;code&gt;Q: Hash + Eq&lt;/code&gt;, it signals the requirement that &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; have implementations of the &lt;code&gt;Hash&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; traits that produce identical results.</source>
          <target state="translated">代わりに、 &lt;code&gt;get&lt;/code&gt; メソッドは、上記のメソッドシグネチャで &lt;code&gt;Q&lt;/code&gt; と呼ばれる、基になるキーデータのタイプに対してジェネリックです。それは、 &lt;code&gt;K&lt;/code&gt; が &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt; 要求することにより、Qとして借用すると述べています。さらに &lt;code&gt;Q: Hash + Eq&lt;/code&gt; 要求することで、 &lt;code&gt;K&lt;/code&gt; と &lt;code&gt;Q&lt;/code&gt; が同じ結果を生成する &lt;code&gt;Hash&lt;/code&gt; と &lt;code&gt;Eq&lt;/code&gt; トレイトの実装を持っているという要件を示します。</target>
        </trans-unit>
        <trans-unit id="878f7237ad30bf50b95fb9667897fe778bbcf6bb" translate="yes" xml:space="preserve">
          <source>Instead, we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it&amp;rsquo;s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-10 shows one way to define a &lt;code&gt;Guess&lt;/code&gt; type that will only create an instance of &lt;code&gt;Guess&lt;/code&gt; if the &lt;code&gt;new&lt;/code&gt; function receives a value between 1 and 100.</source>
          <target state="translated">代わりに、すべての場所で検証を繰り返すのではなく、新しい型を作成し、検証を関数に入れて型のインスタンスを作成できます。そうすることで、関数がシグネチャで新しい型を使用し、受け取った値を自信を持って使用しても安全です。リスト9-10は、 &lt;code&gt;new&lt;/code&gt; 関数が1〜100の値を受け取った場合にのみ &lt;code&gt;Guess&lt;/code&gt; のインスタンスを作成する &lt;code&gt;Guess&lt;/code&gt; 型を定義する1つの方法を示しています。</target>
        </trans-unit>
        <trans-unit id="4262f2636f484912c23478cb754110e371d9c5c5" translate="yes" xml:space="preserve">
          <source>Instead, we can use nested paths to bring the same items into scope in one line. We do this by specifying the common part of the path, followed by two colons, and then curly brackets around a list of the parts of the paths that differ, as shown in Listing 7-18.</source>
          <target state="translated">代わりに、同じアイテムを1行でスコープに入れるために入れ子になったパスを使うことができます。リスト7-18で示されるように、パスの共通部分を指定し、2つのコロンが続き、異なるパスの部分のリストを中括弧で囲むことでこれを実現します。</target>
        </trans-unit>
        <trans-unit id="5890f5912d1fb9403515b5a5574c224c2a726c72" translate="yes" xml:space="preserve">
          <source>Instead, we could write this in a shorter way using &lt;code&gt;if let&lt;/code&gt;. The following code behaves the same as the &lt;code&gt;match&lt;/code&gt; in Listing 6-6:</source>
          <target state="translated">代わりに、 &lt;code&gt;if let&lt;/code&gt; を使用してこれをより短い方法で書くことができます。次のコードは、コードリスト6-6の &lt;code&gt;match&lt;/code&gt; と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="f97c87a1b2b6afb4bd47b58a7850a17ba4dcea9b" translate="yes" xml:space="preserve">
          <source>Instead, we get the following error that talks about lifetimes:</source>
          <target state="translated">その代わりに、寿命について語る次のようなエラーが出てきます。</target>
        </trans-unit>
        <trans-unit id="e71162b50e657665aeaa9b501b8264cb1685df94" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll change our definition of &lt;code&gt;List&lt;/code&gt; to use &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in place of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, as shown in Listing 15-18. Each &lt;code&gt;Cons&lt;/code&gt; variant will now hold a value and an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; pointing to a &lt;code&gt;List&lt;/code&gt;. When we create &lt;code&gt;b&lt;/code&gt;, instead of taking ownership of &lt;code&gt;a&lt;/code&gt;, we&amp;rsquo;ll clone the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that &lt;code&gt;a&lt;/code&gt; is holding, thereby increasing the number of references from one to two and letting &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; share ownership of the data in that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll also clone &lt;code&gt;a&lt;/code&gt; when creating &lt;code&gt;c&lt;/code&gt;, increasing the number of references from two to three. Every time we call &lt;code&gt;Rc::clone&lt;/code&gt;, the reference count to the data within the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; will increase, and the data won&amp;rsquo;t be cleaned up unless there are zero references to it.</source>
          <target state="translated">代わりに、リスト15-18に示すように、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 代わりに &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を使用するように &lt;code&gt;List&lt;/code&gt; の定義を変更します。各 &lt;code&gt;Cons&lt;/code&gt; バリアントは、値と &lt;code&gt;List&lt;/code&gt; を指す &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 保持します。私たちが作成した場合 &lt;code&gt;b&lt;/code&gt; 代わりに所有権取る、我々はクローンます &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; することを、保持することにより1から2に参照の数を増やすとさせて頂いておりかつ &lt;code&gt;b&lt;/code&gt; 中でデータの共有所有権をすることを &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 。 &lt;code&gt;c&lt;/code&gt; の作成時にaも複製 &lt;code&gt;a&lt;/code&gt; ます &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 、参照の数を2から3に増やします。 &lt;code&gt;Rc::clone&lt;/code&gt; を呼び出すたびに、 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 内のデータへの参照カウントが増加し、データへの参照がゼロでない限り、データはクリーンアップされません。</target>
        </trans-unit>
        <trans-unit id="2890fe24db6f7388a46470ac6834b80784db6337" translate="yes" xml:space="preserve">
          <source>Instructions can execute in a different order from the one we define, due to various reasons:</source>
          <target state="translated">命令は、様々な理由により、私たちが定義したものとは異なる順序で実行されることがあります。</target>
        </trans-unit>
        <trans-unit id="b74294f827b0d4541ba12662271114a470d6d7a4" translate="yes" xml:space="preserve">
          <source>IntErrorKind</source>
          <target state="translated">IntErrorKind</target>
        </trans-unit>
        <trans-unit id="80fb7220d8146322b259aee21dfef8944e427bb7" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow</source>
          <target state="translated">IntErrorKind::borrow</target>
        </trans-unit>
        <trans-unit id="bb7aa40e4b4db6e736d2b09e30f31443f1c9b44c" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow_mut</source>
          <target state="translated">IntErrorKind::borrow_mut</target>
        </trans-unit>
        <trans-unit id="86f2a2b8f3ab0b9d3e18ee8e7279ac3646f5e5b6" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone</source>
          <target state="translated">IntErrorKind::clone</target>
        </trans-unit>
        <trans-unit id="dd987594d4a6731556fb4db2a25b883f8e6e834a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_from</source>
          <target state="translated">IntErrorKind::clone_from</target>
        </trans-unit>
        <trans-unit id="8f1809c6588a2cc665ccd543289e14a938828a70" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_into</source>
          <target state="translated">IntErrorKind::clone_into</target>
        </trans-unit>
        <trans-unit id="a5e2ed2cdfa8d2140437ae0a8783a450793b17a2" translate="yes" xml:space="preserve">
          <source>IntErrorKind::eq</source>
          <target state="translated">IntErrorKind::eq</target>
        </trans-unit>
        <trans-unit id="92fce40d27d225b47d39433e8ff156d8c2c93e18" translate="yes" xml:space="preserve">
          <source>IntErrorKind::fmt</source>
          <target state="translated">IntErrorKind::fmt</target>
        </trans-unit>
        <trans-unit id="cd16b5df7c131824209cf18f2e5abfbebb79b75a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::from</source>
          <target state="translated">IntErrorKind::from</target>
        </trans-unit>
        <trans-unit id="e6625420510ba7fab278784b2593fb38c7566390" translate="yes" xml:space="preserve">
          <source>IntErrorKind::into</source>
          <target state="translated">IntErrorKind::into</target>
        </trans-unit>
        <trans-unit id="9d0115c16bd4f87138d516953bbe461d1bf9ec02" translate="yes" xml:space="preserve">
          <source>IntErrorKind::ne</source>
          <target state="translated">IntErrorKind::ne</target>
        </trans-unit>
        <trans-unit id="14958c3a69f5e70cdde8bcf9555c598ab9bb336b" translate="yes" xml:space="preserve">
          <source>IntErrorKind::to_owned</source>
          <target state="translated">IntErrorKind::to_owned</target>
        </trans-unit>
        <trans-unit id="6415d36e18efe91e53b209d52b6293cb58ff6bfa" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_from</source>
          <target state="translated">IntErrorKind::try_from</target>
        </trans-unit>
        <trans-unit id="03f332b4c41b3659819ff1f646ef37a2e67d10fd" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_into</source>
          <target state="translated">IntErrorKind::try_into</target>
        </trans-unit>
        <trans-unit id="b726776952bee36d5bafae04149385980bc0b309" translate="yes" xml:space="preserve">
          <source>IntErrorKind::type_id</source>
          <target state="translated">IntErrorKind::type_id</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="65424b5083b7bb599ce3d3b760be23e671c074b2" translate="yes" xml:space="preserve">
          <source>Integer Overflow</source>
          <target state="translated">整数オーバーフロー</target>
        </trans-unit>
        <trans-unit id="dee2f95e5c81fdaa601cb7ca5b7396c9d7532488" translate="yes" xml:space="preserve">
          <source>Integer Types</source>
          <target state="translated">整数型</target>
        </trans-unit>
        <trans-unit id="6977c92d9e82d5b8f471a2623681e1d1d400b4fb" translate="yes" xml:space="preserve">
          <source>Integer and floating point literals are stringified in order to be concatenated.</source>
          <target state="translated">整数リテラルと浮動小数点リテラルは連結するために文字列化されます。</target>
        </trans-unit>
        <trans-unit id="eea9a8e4af8d6805a657b383a298ba05a67ec8a4" translate="yes" xml:space="preserve">
          <source>Integer is too large to store in target integer type.</source>
          <target state="translated">整数が大きすぎて、ターゲットの整数型に格納できません。</target>
        </trans-unit>
        <trans-unit id="25419a68a3cc357926618f13c044ff7b1347aa8b" translate="yes" xml:space="preserve">
          <source>Integer is too small to store in target integer type.</source>
          <target state="translated">整数が小さすぎて、ターゲットの整数型に格納できません。</target>
        </trans-unit>
        <trans-unit id="13c9f1f069c2155e025409b7880e9bda6c11b765" translate="yes" xml:space="preserve">
          <source>Integer literals</source>
          <target state="translated">整数リテラル</target>
        </trans-unit>
        <trans-unit id="f64049bb9bdfd33c50813111908ece46c327c630" translate="yes" xml:space="preserve">
          <source>Integer operators will panic when they overflow when compiled in debug mode. The &lt;code&gt;-C debug-assertions&lt;/code&gt; and &lt;code&gt;-C overflow-checks&lt;/code&gt; compiler flags can be used to control this more directly. The following things are considered to be overflow:</source>
          <target state="translated">整数演算子は、デバッグモードでコンパイルしたときにオーバーフローするとパニックになります。 &lt;code&gt;-C debug-assertions&lt;/code&gt; 及び &lt;code&gt;-C overflow-checks&lt;/code&gt; コンパイラフラグは、より直接的にこれを制御するために使用することができます。以下はオーバーフローと見なされます。</target>
        </trans-unit>
        <trans-unit id="16d3c89b38e84e433e4fbd3b3a5bad55571258af" translate="yes" xml:space="preserve">
          <source>Integer or Float type</source>
          <target state="translated">整数またはフロート型</target>
        </trans-unit>
        <trans-unit id="3a26a4e37ae1b89c4b86a6d96e9ccef63b9ca764" translate="yes" xml:space="preserve">
          <source>Integer overflow</source>
          <target state="translated">整数オーバーフロー</target>
        </trans-unit>
        <trans-unit id="60c11385ec83a73512788efd527bda9740331202" translate="yes" xml:space="preserve">
          <source>Integer suffixes</source>
          <target state="translated">整数接尾辞</target>
        </trans-unit>
        <trans-unit id="f59b20cbbdd5ddf3c9bd85fd552a52f66ae334d9" translate="yes" xml:space="preserve">
          <source>Integer type</source>
          <target state="translated">整数型</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数型</target>
        </trans-unit>
        <trans-unit id="19f28971f5db0ac7dee3fee9af716d1da8917af3" translate="yes" xml:space="preserve">
          <source>Integer types (u8, i8, u16, i16, usize, isize, etc.).</source>
          <target state="translated">整数型(u8、i8、u16、i16、usize、isizeなど)。</target>
        </trans-unit>
        <trans-unit id="a83667e8fbc7d07069b4ce287d78c06adec56630" translate="yes" xml:space="preserve">
          <source>Integers and other types implementing &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; are unaffected by &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">整数や、&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;を実装するその他の型は、 &lt;code&gt;drop&lt;/code&gt; の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="036a5d47efaf84af91b96bca27d0e3394108b032" translate="yes" xml:space="preserve">
          <source>Integration Tests</source>
          <target state="translated">統合テスト</target>
        </trans-unit>
        <trans-unit id="d9b3c69227b8b09ee6557a63d6eadc1309909958" translate="yes" xml:space="preserve">
          <source>Integration Tests for Binary Crates</source>
          <target state="translated">バイナリクレートの統合テスト</target>
        </trans-unit>
        <trans-unit id="22d0f1d4f5d8a4b65c3ed4d1e121eaf3dc6e87d2" translate="yes" xml:space="preserve">
          <source>Intended for use for errors not exposed to the user, where allocating onto the heap (for normal construction via Error::new) is too costly.</source>
          <target state="translated">(Error::new を介した通常の構築では)ヒープへの割り当てがコスト高になるような、ユーザに公開されないエラーのために使用することを意図しています。</target>
        </trans-unit>
        <trans-unit id="8b67f9d330a2d3ef64e53c30ab32b2a3ac9f06b6" translate="yes" xml:space="preserve">
          <source>Intense! In effect, this error message means that Rust doesn&amp;rsquo;t understand how to add an &lt;code&gt;i8&lt;/code&gt; and an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;, because they&amp;rsquo;re different types. When we have a value of a type like &lt;code&gt;i8&lt;/code&gt; in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; (or whatever type of value we&amp;rsquo;re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</source>
          <target state="translated">激しい！実際、このエラーメッセージは、Rustが &lt;code&gt;i8&lt;/code&gt; と &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; を追加する方法を理解していないことを意味します。これらは異なるタイプだからです。Rustの &lt;code&gt;i8&lt;/code&gt; のような型の値がある場合、コンパイラーは常に有効な値を持つことを保証します。その値を使用する前にnullをチェックする必要なく、自信を持って続行できます。唯一の我々は持っている時に &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; （あるいは我々が作業している値のどんなタイプ）私たちは、おそらく価値を持っていない心配する必要があり、コンパイラは必ず私たちは値を使用する前に、そのケースを扱うようになります行います。</target>
        </trans-unit>
        <trans-unit id="ffafe2f71610dfdf28d74f6f54bc9015fbb24203" translate="yes" xml:space="preserve">
          <source>Interestingly, the Rust language has &lt;em&gt;very&lt;/em&gt; few concurrency features. Almost every concurrency feature we&amp;rsquo;ve talked about so far in this chapter has been part of the standard library, not the language. Your options for handling concurrency are not limited to the language or the standard library; you can write your own concurrency features or use those written by others.</source>
          <target state="translated">興味深いことに、Rust言語には同時実行機能がほとんどあり&lt;em&gt;ませ&lt;/em&gt;ん。この章でこれまで説明してきたほぼすべての同時実行機能は、言語ではなく標準ライブラリの一部でした。並行処理のオプションは、言語や標準ライブラリに限定されません。独自の同時実行機能を作成するか、他のユーザーが作成した機能を使用できます。</target>
        </trans-unit>
        <trans-unit id="21bdfe87f76bf3a6413dde02708bb83e04770512" translate="yes" xml:space="preserve">
          <source>Interior Mutability</source>
          <target state="translated">内部変異性</target>
        </trans-unit>
        <trans-unit id="88bf37967a115d0f3e4ede63c58d62ebf4f74d5a" translate="yes" xml:space="preserve">
          <source>Interior Mutability: A Mutable Borrow to an Immutable Value</source>
          <target state="translated">内的変異性。不変の価値への借り入れ</target>
        </trans-unit>
        <trans-unit id="bb56d65f2c6cb59165a8429fad875c4b21a44fc9" translate="yes" xml:space="preserve">
          <source>Interior mutability is required.</source>
          <target state="translated">内部変異性が必要です。</target>
        </trans-unit>
        <trans-unit id="ca7ba6473fcf9f5318db96e54bb8153323ab66d4" translate="yes" xml:space="preserve">
          <source>Internal Representation</source>
          <target state="translated">内部表現</target>
        </trans-unit>
        <trans-unit id="f8e983bc961f2f79520b6f7bb3705df394320c6d" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::max&lt;/code&gt;.</source>
          <target state="translated">内部的に &lt;code&gt;Ord::max&lt;/code&gt; エイリアスを使用します。</target>
        </trans-unit>
        <trans-unit id="944d65bab4f9ee9f9e2c120271148593d01f1819" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::min&lt;/code&gt;.</source>
          <target state="translated">内部的に &lt;code&gt;Ord::min&lt;/code&gt; エイリアスを使用します。</target>
        </trans-unit>
        <trans-unit id="068003ac53324bf3f0b64c29929ac10bbe1c05ab" translate="yes" xml:space="preserve">
          <source>Internet socket addresses consist of an &lt;a href=&quot;enum.ipaddr&quot;&gt;IP address&lt;/a&gt;, a 16-bit port number, as well as possibly some version-dependent additional information. See &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;'s respective documentation for more details.</source>
          <target state="translated">インターネットソケットアドレスは、&lt;a href=&quot;enum.ipaddr&quot;&gt;IPアドレス&lt;/a&gt;、16ビットのポート番号、および場合によってはバージョンに依存する追加情報で構成されます。詳細については、&lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt;のそれぞれのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ff358fd17c71b9310a296d32bf0fad9d3ef93b34" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;src&lt;/code&gt; as having type &lt;code&gt;&amp;amp;U&lt;/code&gt;, and then reads &lt;code&gt;src&lt;/code&gt; without moving the contained value.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; をタイプ &lt;code&gt;&amp;amp;U&lt;/code&gt; として解釈し、含まれている値を移動せずに &lt;code&gt;src&lt;/code&gt; を読み取ります。</target>
        </trans-unit>
        <trans-unit id="6a36b9396eb19f7860ffbd9cb812832709b1a0ee" translate="yes" xml:space="preserve">
          <source>Interrupted operations can typically be retried.</source>
          <target state="translated">中断された操作は、通常、再試行することができます。</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="d937d21f811516b74380ee512b99e31251a84531" translate="yes" xml:space="preserve">
          <source>Into</source>
          <target state="translated">Into</target>
        </trans-unit>
        <trans-unit id="5bfe78f7766048c0532cc66994c73d1126acb835" translate="yes" xml:space="preserve">
          <source>Into::into</source>
          <target state="translated">Into::into</target>
        </trans-unit>
        <trans-unit id="77f5dd8de42c3fb03062223e3c47c92129133f82" translate="yes" xml:space="preserve">
          <source>IntoInnerError</source>
          <target state="translated">IntoInnerError</target>
        </trans-unit>
        <trans-unit id="3f3157b39d55c6291f5fe8213b30cc7d15253d48" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow</source>
          <target state="translated">IntoInnerError::borrow</target>
        </trans-unit>
        <trans-unit id="8dfa8d9b4ac06c1a6626ce8031f10e6de0dc0387" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow_mut</source>
          <target state="translated">IntoInnerError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7c332dec4b157cd5d25efcbb73292737fbcafa2a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::cause</source>
          <target state="translated">IntoInnerError::cause</target>
        </trans-unit>
        <trans-unit id="824ab9811aae7de9a48a47b240a825897e788412" translate="yes" xml:space="preserve">
          <source>IntoInnerError::description</source>
          <target state="translated">IntoInnerError::description</target>
        </trans-unit>
        <trans-unit id="83d6a8f5f81bfae0852073773b72a21c220d1541" translate="yes" xml:space="preserve">
          <source>IntoInnerError::error</source>
          <target state="translated">IntoInnerError::error</target>
        </trans-unit>
        <trans-unit id="b1804b3db5a18e0f8ea6f6cff9edd76e45db12ed" translate="yes" xml:space="preserve">
          <source>IntoInnerError::fmt</source>
          <target state="translated">IntoInnerError::fmt</target>
        </trans-unit>
        <trans-unit id="74ec382ed3daa2186fca394930d62ea36a8c17d2" translate="yes" xml:space="preserve">
          <source>IntoInnerError::from</source>
          <target state="translated">IntoInnerError::from</target>
        </trans-unit>
        <trans-unit id="f77ca8c3b2a09378cb7ab11a7034bfe301502366" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into</source>
          <target state="translated">IntoInnerError::into</target>
        </trans-unit>
        <trans-unit id="b64935fe113c6776466d9f925b72b58f10a95d0a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into_inner</source>
          <target state="translated">IntoInnerError::into_inner</target>
        </trans-unit>
        <trans-unit id="b98cd1e7eff5f2d406e34cac12fb4fec6a0205d4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::source</source>
          <target state="translated">IntoInnerError::source</target>
        </trans-unit>
        <trans-unit id="b27666ff3803b78aee0d747dc0d776b1f36b641a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::to_string</source>
          <target state="translated">IntoInnerError::to_string</target>
        </trans-unit>
        <trans-unit id="0b54c908cc8363881d303f189af2d3a384fbe644" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_from</source>
          <target state="translated">IntoInnerError::try_from</target>
        </trans-unit>
        <trans-unit id="496358b49c2805d5e6526e43d48129b6eb94e5f4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_into</source>
          <target state="translated">IntoInnerError::try_into</target>
        </trans-unit>
        <trans-unit id="b48124715dd42f1aa190750b7aa9535327b5b2db" translate="yes" xml:space="preserve">
          <source>IntoInnerError::type_id</source>
          <target state="translated">IntoInnerError::type_id</target>
        </trans-unit>
        <trans-unit id="d5bc3a63a8bde6cc5fb0c0c11c8f6e6a2d150f75" translate="yes" xml:space="preserve">
          <source>IntoIter</source>
          <target state="translated">IntoIter</target>
        </trans-unit>
        <trans-unit id="169272921e3355905d2215419cf69783d5e1115d" translate="yes" xml:space="preserve">
          <source>IntoIter::all</source>
          <target state="translated">IntoIter::all</target>
        </trans-unit>
        <trans-unit id="a15574f60107e9d0464eff7cacee4bccf74dd72e" translate="yes" xml:space="preserve">
          <source>IntoIter::any</source>
          <target state="translated">IntoIter::any</target>
        </trans-unit>
        <trans-unit id="51c36bf4138559f11f65b74500f686e06c1f07c6" translate="yes" xml:space="preserve">
          <source>IntoIter::as_mut_slice</source>
          <target state="translated">IntoIter::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="375d884ce90ecd76e63b6eebc5d52f38165f98ea" translate="yes" xml:space="preserve">
          <source>IntoIter::as_slice</source>
          <target state="translated">IntoIter::as_slice</target>
        </trans-unit>
        <trans-unit id="945728e84b93878ccde99bc6b6c902e3add25ce9" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow</source>
          <target state="translated">IntoIter::borrow</target>
        </trans-unit>
        <trans-unit id="4db752fa4ec7a9c0d095aaf0baac141df030f531" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow_mut</source>
          <target state="translated">IntoIter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="aaf973384105c3d31f532c4ad4e6dc925ca8038e" translate="yes" xml:space="preserve">
          <source>IntoIter::by_ref</source>
          <target state="translated">IntoIter::by_ref</target>
        </trans-unit>
        <trans-unit id="bcd8f637007c65386e7e2794c338143218170c6f" translate="yes" xml:space="preserve">
          <source>IntoIter::chain</source>
          <target state="translated">IntoIter::chain</target>
        </trans-unit>
        <trans-unit id="4b7971718173fafccbf11a50c2db440035e10f18" translate="yes" xml:space="preserve">
          <source>IntoIter::clone</source>
          <target state="translated">IntoIter::clone</target>
        </trans-unit>
        <trans-unit id="cdb70f02920a7096b80eae8222a39e9acc9946ce" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_from</source>
          <target state="translated">IntoIter::clone_from</target>
        </trans-unit>
        <trans-unit id="a82a0721b8481c0815dcd502e84574a2073e6632" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_into</source>
          <target state="translated">IntoIter::clone_into</target>
        </trans-unit>
        <trans-unit id="50371856061d6c57455d0ce1dfd33e8f9cb33e2b" translate="yes" xml:space="preserve">
          <source>IntoIter::cloned</source>
          <target state="translated">IntoIter::cloned</target>
        </trans-unit>
        <trans-unit id="e8ad516621215eb3804081635021e01bb0d15b51" translate="yes" xml:space="preserve">
          <source>IntoIter::cmp</source>
          <target state="translated">IntoIter::cmp</target>
        </trans-unit>
        <trans-unit id="8fbe1060e2b348d75cd8e260134f4152fb629580" translate="yes" xml:space="preserve">
          <source>IntoIter::collect</source>
          <target state="translated">IntoIter::collect</target>
        </trans-unit>
        <trans-unit id="49b1597675bf50c85b1e156757a3fba15d6379b2" translate="yes" xml:space="preserve">
          <source>IntoIter::copied</source>
          <target state="translated">IntoIter::copied</target>
        </trans-unit>
        <trans-unit id="1b07d7fdfbcbc77dd6f739fc3349c3f2c936082e" translate="yes" xml:space="preserve">
          <source>IntoIter::count</source>
          <target state="translated">IntoIter::count</target>
        </trans-unit>
        <trans-unit id="abc24391b60331e5b16547b639bace5c08a577cf" translate="yes" xml:space="preserve">
          <source>IntoIter::cycle</source>
          <target state="translated">IntoIter::cycle</target>
        </trans-unit>
        <trans-unit id="076c1a1b603e193e4eb4e0757f8c8cf292b8dfb5" translate="yes" xml:space="preserve">
          <source>IntoIter::drop</source>
          <target state="translated">IntoIter::drop</target>
        </trans-unit>
        <trans-unit id="c4d617218636a45df4ca846f67499ffba56d0009" translate="yes" xml:space="preserve">
          <source>IntoIter::enumerate</source>
          <target state="translated">IntoIter::enumerate</target>
        </trans-unit>
        <trans-unit id="203a6dcfb8a13fd0add782bc832058504307c28c" translate="yes" xml:space="preserve">
          <source>IntoIter::eq</source>
          <target state="translated">IntoIter::eq</target>
        </trans-unit>
        <trans-unit id="c908d336a9125db6fbd5e895b62999e14ef83fab" translate="yes" xml:space="preserve">
          <source>IntoIter::filter</source>
          <target state="translated">IntoIter::filter</target>
        </trans-unit>
        <trans-unit id="dffdf83b64aeaec0f8093868f1a7bbb32780e9ca" translate="yes" xml:space="preserve">
          <source>IntoIter::filter_map</source>
          <target state="translated">IntoIter::filter_map</target>
        </trans-unit>
        <trans-unit id="ab410a5d7b7cbc92b7134e524269b1fa848fc30b" translate="yes" xml:space="preserve">
          <source>IntoIter::find</source>
          <target state="translated">IntoIter::find</target>
        </trans-unit>
        <trans-unit id="27ee1265a09c796da003def69a36560ceff2b181" translate="yes" xml:space="preserve">
          <source>IntoIter::find_map</source>
          <target state="translated">IntoIter::find_map</target>
        </trans-unit>
        <trans-unit id="eddd95067e023ebec6158e4fd0749c395bbce3b5" translate="yes" xml:space="preserve">
          <source>IntoIter::flat_map</source>
          <target state="translated">IntoIter::flat_map</target>
        </trans-unit>
        <trans-unit id="24f22711986263a8d0e02c113bb93328c331ce4c" translate="yes" xml:space="preserve">
          <source>IntoIter::flatten</source>
          <target state="translated">IntoIter::flatten</target>
        </trans-unit>
        <trans-unit id="e538b5a92b4ad8916bfeef8710693a5e5266e987" translate="yes" xml:space="preserve">
          <source>IntoIter::fmt</source>
          <target state="translated">IntoIter::fmt</target>
        </trans-unit>
        <trans-unit id="d818332c13e9dac3c39cfd50a50265cfaea983ac" translate="yes" xml:space="preserve">
          <source>IntoIter::fold</source>
          <target state="translated">IntoIter::fold</target>
        </trans-unit>
        <trans-unit id="ebce24dad77f86422316868125c1ce1b1376c47d" translate="yes" xml:space="preserve">
          <source>IntoIter::for_each</source>
          <target state="translated">IntoIter::for_each</target>
        </trans-unit>
        <trans-unit id="63d5fee827e27caa7f9e5b809ff35ace75693193" translate="yes" xml:space="preserve">
          <source>IntoIter::from</source>
          <target state="translated">IntoIter::from</target>
        </trans-unit>
        <trans-unit id="d10213dec7222893569b1e32a4313a41a6aaecb0" translate="yes" xml:space="preserve">
          <source>IntoIter::fuse</source>
          <target state="translated">IntoIter::fuse</target>
        </trans-unit>
        <trans-unit id="2c8a9a1c31b0f9b10030a7c20db1f8dae0614589" translate="yes" xml:space="preserve">
          <source>IntoIter::ge</source>
          <target state="translated">IntoIter::ge</target>
        </trans-unit>
        <trans-unit id="104a30acd770869920244c22e6c1a727cdee6dae" translate="yes" xml:space="preserve">
          <source>IntoIter::gt</source>
          <target state="translated">IntoIter::gt</target>
        </trans-unit>
        <trans-unit id="ab8d2e8c457b63ffae7769711a00e1a87b2a56eb" translate="yes" xml:space="preserve">
          <source>IntoIter::inspect</source>
          <target state="translated">IntoIter::inspect</target>
        </trans-unit>
        <trans-unit id="c0c222348756fc6dca4ff42b109916a4d5aa1041" translate="yes" xml:space="preserve">
          <source>IntoIter::into</source>
          <target state="translated">IntoIter::into</target>
        </trans-unit>
        <trans-unit id="00014741248dda82e6a92af65524e8bc527d5270" translate="yes" xml:space="preserve">
          <source>IntoIter::into_iter</source>
          <target state="translated">IntoIter::into_iter</target>
        </trans-unit>
        <trans-unit id="5136432030a36a1b23033a0d753895604b4149ac" translate="yes" xml:space="preserve">
          <source>IntoIter::is_empty</source>
          <target state="translated">IntoIter::is_empty</target>
        </trans-unit>
        <trans-unit id="cf791dcb18f1b7d93faf9bdd64add013d8076499" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted</source>
          <target state="translated">IntoIter::is_sorted</target>
        </trans-unit>
        <trans-unit id="5c6daaffe95fe047d7827bfe50f3fd317d40c563" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by</source>
          <target state="translated">IntoIter::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="9f7c1ed14fd6d8b0ea5624c99850ff1ba4ac8f4c" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by_key</source>
          <target state="translated">IntoIter::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="e39349aed40aa6fcfd458252b9c0e111206b7d16" translate="yes" xml:space="preserve">
          <source>IntoIter::last</source>
          <target state="translated">IntoIter::last</target>
        </trans-unit>
        <trans-unit id="965a66efe77546764045f5f96e42028dbb177b19" translate="yes" xml:space="preserve">
          <source>IntoIter::le</source>
          <target state="translated">IntoIter::le</target>
        </trans-unit>
        <trans-unit id="22be990e0e582b87c69cd8c67de2cfd9920d77cd" translate="yes" xml:space="preserve">
          <source>IntoIter::len</source>
          <target state="translated">IntoIter::len</target>
        </trans-unit>
        <trans-unit id="8440a9053eaee6916d3cec75da248b9b8410507f" translate="yes" xml:space="preserve">
          <source>IntoIter::lt</source>
          <target state="translated">IntoIter::lt</target>
        </trans-unit>
        <trans-unit id="e3e2d404675aba8735567f55b57c588d0c0c351a" translate="yes" xml:space="preserve">
          <source>IntoIter::map</source>
          <target state="translated">IntoIter::map</target>
        </trans-unit>
        <trans-unit id="181026e325e14528b026dfe68716b7b26ecd2d2d" translate="yes" xml:space="preserve">
          <source>IntoIter::max</source>
          <target state="translated">IntoIter::max</target>
        </trans-unit>
        <trans-unit id="dd9a47d87f8a0e2db21c65ae146ddcfdf6e0f952" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by</source>
          <target state="translated">IntoIter::max_by</target>
        </trans-unit>
        <trans-unit id="32723c1a1514dde11ed20c922fc56eff6425fcc8" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by_key</source>
          <target state="translated">IntoIter::max_by_key</target>
        </trans-unit>
        <trans-unit id="c528958b5dc23955203383c2f66331a5a91f6f86" translate="yes" xml:space="preserve">
          <source>IntoIter::min</source>
          <target state="translated">IntoIter::min</target>
        </trans-unit>
        <trans-unit id="390fd21e220a5da046b34c827add37c65b895f97" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by</source>
          <target state="translated">IntoIter::min_by</target>
        </trans-unit>
        <trans-unit id="05a738d3c9912a808e8d6c464d2a7c6d5e602efc" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by_key</source>
          <target state="translated">IntoIter::min_by_key</target>
        </trans-unit>
        <trans-unit id="6cc5e0ff9437accb5f5b72fc20bbf3b3985983ae" translate="yes" xml:space="preserve">
          <source>IntoIter::ne</source>
          <target state="translated">IntoIter::ne</target>
        </trans-unit>
        <trans-unit id="95d68245f80704a894c91867b96e64891330dc8f" translate="yes" xml:space="preserve">
          <source>IntoIter::next</source>
          <target state="translated">IntoIter::next</target>
        </trans-unit>
        <trans-unit id="c4df8bce742e0396e8452ed5481fe551b8b2badd" translate="yes" xml:space="preserve">
          <source>IntoIter::next_back</source>
          <target state="translated">IntoIter::next_back</target>
        </trans-unit>
        <trans-unit id="489c39625b1b427238a77aa99c56a91ae04c9c31" translate="yes" xml:space="preserve">
          <source>IntoIter::nth</source>
          <target state="translated">IntoIter::nth</target>
        </trans-unit>
        <trans-unit id="54146217e0f00a76ac06385e197cdac1011f680c" translate="yes" xml:space="preserve">
          <source>IntoIter::nth_back</source>
          <target state="translated">IntoIter::nth_back</target>
        </trans-unit>
        <trans-unit id="2a293f8986446751513826e2a6e67042070d4889" translate="yes" xml:space="preserve">
          <source>IntoIter::partial_cmp</source>
          <target state="translated">IntoIter::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7432ba6416e1cdf63a74ea8f79c2559a3d61d6f5" translate="yes" xml:space="preserve">
          <source>IntoIter::partition</source>
          <target state="translated">IntoIter::partition</target>
        </trans-unit>
        <trans-unit id="a2c1d18ee38c61b94c1e15afa12302f3d7a18c8a" translate="yes" xml:space="preserve">
          <source>IntoIter::peekable</source>
          <target state="translated">IntoIter::peekable</target>
        </trans-unit>
        <trans-unit id="7240e01f5d7115ce4d05e7b2faa4a077b8d81625" translate="yes" xml:space="preserve">
          <source>IntoIter::position</source>
          <target state="translated">IntoIter::position</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
