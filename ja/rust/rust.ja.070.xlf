<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="translated">ベクトルは（&lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../ops/trait.indexmut&quot;&gt; &lt;code&gt;IndexMut&lt;/code&gt; &lt;/a&gt;トレイトを介して）インデックス作成もサポートします。</target>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="translated">ベクトルには、 &lt;code&gt;O(1)&lt;/code&gt; インデックス、償却済み &lt;code&gt;O(1)&lt;/code&gt; プッシュ（最後まで）、および &lt;code&gt;O(1)&lt;/code&gt; ポップ（最後から）があります。</target>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="translated">ベクトル、文字列、ハッシュマップは、データを保存、アクセス、修正する必要がある場合に、プログラムで必要な機能を大量に提供します。ここでは、あなたが今から解けるようにしておくべき練習問題をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">逐語的UNCプレフィックスは、 &lt;code&gt;\?\UNC\&lt;/code&gt; 直後にサーバーのホスト名と共有名が続きます。</target>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="translated">逐語的ディスク接頭辞。たとえば、 &lt;code&gt;\?\C:\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="translated">逐語的ディスクプレフィックスは、 &lt;code&gt;\?\&lt;/code&gt; の直後にドライブ文字と &lt;code&gt;:\&lt;/code&gt; が続きます。</target>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">Windowsの&lt;em&gt;&lt;strong&gt;U&lt;/strong&gt; niform &lt;strong&gt;N&lt;/strong&gt; aming &lt;strong&gt;C&lt;/strong&gt; onvention&lt;/em&gt;を使用した逐語的な接頭辞（例： &lt;code&gt;\?\UNC\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">逐語的な接頭辞。たとえば、 &lt;code&gt;\?\cat_pics&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">逐語的接頭辞は、 &lt;code&gt;\?\&lt;/code&gt; の直後に特定のコンポーネントが続くもので構成されます。</target>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="translated">フィールド名のスペルミスやフィールドが存在していないことを確認してください。例:フィールド名のスペルを間違えていないか、フィールドが存在するかを確認します。</target>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="translated">不変の参照を介して、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 使用すると、プログラムの複数の部分でデータを読み取り専用で共有できます。場合 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; あなたも複数の可変の参照を持つことができ、あなたは借入ルールのいずれかに違反する可能性がある、第4章で説明：同じ場所に複数の可変借りは、データ競合や矛盾を引き起こす可能性があります。しかし、データを変更できることは非常に便利です。次のセクションでは、この不変性の制限を操作するために &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; と組み合わせて使用​​できる内部の &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; パターンとRefCell &amp;lt;T&amp;gt;型について説明します。</target>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="translated">基になるデータを元のデータのサブスライスとして表示します。</target>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="translated">これらに違反すると、アロケータの内部データ構造が破損するなどの問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">これらに違反すると、アロケータの内部データ構造が破損するなどの問題が発生する可能性があります。たとえば、Cの &lt;code&gt;char&lt;/code&gt; 配列へのポインタと &lt;code&gt;size_t&lt;/code&gt; から &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; を構築するの&lt;strong&gt;は&lt;/strong&gt;安全ではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="translated">可視性とプライバシー</target>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">違いを表す値、つまり、 &lt;code&gt;self&lt;/code&gt; ではあるが &lt;code&gt;other&lt;/code&gt; ではない値を昇順で訪問します。</target>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">違いを表す値を訪問します。つまり、 &lt;code&gt;self&lt;/code&gt; が &lt;code&gt;other&lt;/code&gt; はない値を訪問します。</target>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">交差を表す値、つまり、 &lt;code&gt;self&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; 両方の値を昇順で訪問します。</target>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">交差を表す値、つまり &lt;code&gt;self&lt;/code&gt; と &lt;code&gt;other&lt;/code&gt; 両方にある値にアクセスします。</target>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="translated">対称差を表す値、つまり、 &lt;code&gt;self&lt;/code&gt; または &lt;code&gt;other&lt;/code&gt; 両方ではなく、昇順である値にアクセスします。</target>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="translated">対称的な差を表す値、つまり、 &lt;code&gt;self&lt;/code&gt; または &lt;code&gt;other&lt;/code&gt; が両方にはない値にアクセスします。</target>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="translated">ユニオンを表す値、つまり &lt;code&gt;self&lt;/code&gt; または &lt;code&gt;other&lt;/code&gt; のすべての値を、重複なしに昇順で訪問します。</target>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="translated">ユニオンを表す値、つまり &lt;code&gt;self&lt;/code&gt; または &lt;code&gt;other&lt;/code&gt; のすべての値を複製せずに訪問します。</target>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; および &lt;code&gt;weak_count&lt;/code&gt; への変更の視覚化</target>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="translated">揮発性操作はI/Oメモリ上で動作することを目的としており、他の揮発性操作にまたがってコンパイラによって排除されたり、順序が変更されたりしないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="translated">&lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; ハンドルを使用してすべてのスレッドが完了するのを待機しています</target>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="translated">完全なタイムアウトの期限切れを待っています。</target>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="translated">関連するスレッドが終了するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="translated">子プロセスが完全に終了するのを待ち、終了した状態を返します。この関数は、少なくとも一度は呼び出された後も同じ戻り値を持ち続けます。</target>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="translated">通知のためにこの条件変数で待機し、指定された時間後にタイミングアウトします。</target>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="translated">通知のためにこの条件変数で待機し、指定された時間後にタイミングアウトします。猛烈にウェイクしても、この関数は戻りません。</target>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">これに関連したタスクを覚ます &lt;code&gt;Waker&lt;/code&gt; 消費せずに &lt;code&gt;Waker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;Waker&lt;/code&gt; 関連付けられているタスクをウェイクアップします。</target>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="translated">このコンドバーのすべてのブロックされたスレッドをウェイクアップします。</target>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="translated">このコンドバーの1つのブロックされたスレッドを覚醒させる。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">警告： &lt;code&gt;hash_builder&lt;/code&gt; は通常ランダムに生成され、HashMapsが多くの衝突と非常に低いパフォーマンスを引き起こす攻撃に耐えられるように設計されています。この関数を使用して手動で設定すると、DoS攻撃ベクトルが公開される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">警告： &lt;code&gt;hasher&lt;/code&gt; は通常ランダムに生成され、 &lt;code&gt;HashSet&lt;/code&gt; が多くの衝突と非常に低いパフォーマンスを引き起こす攻撃に耐えられるように設計されています。この関数を使用して手動で設定すると、DoS攻撃ベクトルが公開される可能性があります。</target>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="translated">警告：任意に設定された構成オプションが、コンパイラー設定の構成オプションと同じ値を持つ可能性があります。たとえば、Windowsターゲットにコンパイルするときに &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; を実行し、 &lt;code&gt;unix&lt;/code&gt; と &lt;code&gt;windows&lt;/code&gt; の両方の構成オプションを同時に設定することができます。これを実際に行うのは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">警告：の間に決定的な違いがあります &lt;code&gt;enum&lt;/code&gt; 、C言語や錆のCのようなこの表現を持つ列挙型では。C の &lt;code&gt;enum&lt;/code&gt; は、主に &lt;code&gt;typedef&lt;/code&gt; といくつかの名前付き定数です。つまり、 &lt;code&gt;enum&lt;/code&gt; 型のオブジェクトは任意の整数値を保持できます。たとえば、これは &lt;code&gt;C&lt;/code&gt; のビットフラグによく使用されます。対照的に、RustのCのような列挙は、合法的な判別値しか保持できず、他のすべては未定義の動作です。したがって、CモデルにFFIにC-ような列挙を使用して &lt;code&gt;enum&lt;/code&gt; 、多くの場合、間違っています。</target>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">警告：この本は不完全です。すべてを文書化するにはしばらく時間がかかります。この本に記載されていない内容については、&lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHubの問題&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="translated">警告です。これは警告の例です。</target>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="translated">警告： &lt;code&gt;no_std&lt;/code&gt; を使用しても、標準ライブラリがリンクされるのを防ぐことはできません。externcrate &lt;code&gt;extern crate std;&lt;/code&gt; を置くことは依然として有効です。クレートと依存関係にリンクすることもできます。</target>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="translated">言語の不健全な挙動を示す警告や、言語機能の相互作用を混乱させる可能性のある警告は、特別な警告ボックスに表示されます。</target>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="translated">終端は成功したのか?信号の終端は成功とはみなされず、成功はゼロの終了ステータスとして定義されます。</target>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="translated">変数とデータの相互作用の方法:クローン</target>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="translated">変数とデータの相互作用の方法:移動</target>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="translated">&lt;code&gt;use minigrep::Config&lt;/code&gt; 行を追加して、ライブラリクレートの &lt;code&gt;Config&lt;/code&gt; タイプをバイナリクレートのスコープに移動し、 &lt;code&gt;run&lt;/code&gt; 関数の前にクレート名を付けます。これですべての機能が接続され、機能するはずです。でプログラムを実行し &lt;code&gt;cargo run&lt;/code&gt; し、すべてが正常に動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="translated">空の文字列スライスを返す &lt;code&gt;content&lt;/code&gt; メソッドのデフォルト実装を追加します。つまり、 &lt;code&gt;Draft&lt;/code&gt; および &lt;code&gt;PendingReview&lt;/code&gt; 構造体に &lt;code&gt;content&lt;/code&gt; を実装する必要はありません。 &lt;code&gt;Published&lt;/code&gt; 構造体は上書きされます &lt;code&gt;content&lt;/code&gt; の方法をとで値を返す &lt;code&gt;post.content&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="translated">私たちは、追加 &lt;code&gt;approve&lt;/code&gt; にメソッドを &lt;code&gt;State&lt;/code&gt; 特性と新しい構造体を追加することが実装 &lt;code&gt;State&lt;/code&gt; 、 &lt;code&gt;Published&lt;/code&gt; 状態。</target>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Fn&lt;/code&gt; トレイトバインドにタイプを追加して、パラメーターのタイプと、クロージャーがこのトレイトバインドと一致する必要がある戻り値を表します。この場合、私たちの閉鎖は、型のパラメータがある &lt;code&gt;u32&lt;/code&gt; して返す &lt;code&gt;u32&lt;/code&gt; 我々が指定バインド形質があるので、 &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="translated">クエリ文字列を含む行を保存する方法も必要です。そのために、 &lt;code&gt;for&lt;/code&gt; ループの前に変更可能なベクターを作成し、 &lt;code&gt;push&lt;/code&gt; メソッドを呼び出してベクターに &lt;code&gt;line&lt;/code&gt; を格納できます。 &lt;code&gt;for&lt;/code&gt; ループの後、リスト12-19で示されるように、ベクターを返します。</target>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="translated">テストがコンパイルされないため、このテストを実行して失敗するのを見ることができません。 &lt;code&gt;search&lt;/code&gt; 機能はまだ存在しません！したがって、リスト12-16に示すように、常に空のベクトルを返す &lt;code&gt;search&lt;/code&gt; 関数の定義を追加して、テストをコンパイルして実行するのに十分なコードを追加します。空のベクトルは、 &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt; という行を含むベクトルと一致しないため、テストはコンパイルして失敗します。</target>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="translated">私たちは、変数を使用することができません &lt;code&gt;field_name&lt;/code&gt; と &lt;code&gt;field_value&lt;/code&gt; 、彼らはへの呼び出しでハッシュマップに移動してきた後に &lt;code&gt;insert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="translated">我々は、使用を許可されていません &lt;code&gt;v1_iter&lt;/code&gt; を呼び出した後 &lt;code&gt;sum&lt;/code&gt; ので、 &lt;code&gt;sum&lt;/code&gt; 、我々はそれに呼び出すイテレータの所有権を取得します。</target>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="translated">enum の各バリアントに直接データをアタッチするので、余分な構造体は必要ありません。</target>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;guess&lt;/code&gt; を式 &lt;code&gt;guess.trim().parse()&lt;/code&gt; バインドします。式の &lt;code&gt;guess&lt;/code&gt; は、入力が含まれる &lt;code&gt;String&lt;/code&gt; であった元の &lt;code&gt;guess&lt;/code&gt; を指します。 &lt;code&gt;String&lt;/code&gt; インスタンスの &lt;code&gt;trim&lt;/code&gt; メソッドは、最初と最後の空白を削除します。が、 &lt;code&gt;u32&lt;/code&gt; 唯一の数字を含めることができ、ユーザー必見プレスは満足させるために入力し &lt;code&gt;read_line&lt;/code&gt; 。ユーザーがEnterキーを押すと、改行文字が文字列に追加されます。たとえば、ユーザーが5と入力してEnterキーを押すと、 &lt;code&gt;guess&lt;/code&gt; は次のようになります： &lt;code&gt;5\n&lt;/code&gt; 。 &lt;code&gt;\n&lt;/code&gt; Enterキーを押した結果である「改行」を表します。 &lt;code&gt;trim&lt;/code&gt; 法の排除 &lt;code&gt;\n&lt;/code&gt; だけで、その結果、 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="translated">私たちは、持参 &lt;code&gt;std::io::prelude&lt;/code&gt; 、私たちは、ストリームから書き込み読み聞かせて特定の特徴へのアクセスを得るために、スコープに。 &lt;code&gt;main&lt;/code&gt; 関数の &lt;code&gt;for&lt;/code&gt; ループで、接続を作成したことを示すメッセージを出力する代わりに、新しい &lt;code&gt;handle_connection&lt;/code&gt; 関数を呼び出して &lt;code&gt;stream&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="translated">参照を関数のパラメータとして&lt;em&gt;借りること&lt;/em&gt;を呼び出します。実生活と同様に、人が何かを所有している場合、あなたはそれらを借りることができます。終わったら、返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="translated">値の所有権ではなく、 &lt;code&gt;Option&lt;/code&gt; 内の値への参照が必要なため、 &lt;code&gt;Option&lt;/code&gt; &lt;code&gt;as_ref&lt;/code&gt; メソッドを呼び出します。ので &lt;code&gt;state&lt;/code&gt; ある &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; 私たちが呼ぶとき、 &lt;code&gt;as_ref&lt;/code&gt; 、 &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; 返されます。 &lt;code&gt;as_ref&lt;/code&gt; を呼び出さなかった場合、関数パラメーターの借用された &lt;code&gt;&amp;amp;self&lt;/code&gt; から &lt;code&gt;state&lt;/code&gt; 移動できないため、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="translated">別のトレイトを実装する任意のタイプのトレイトを条件付きで実装することもできます。特性の境界を満たす任意のタイプの特性の実装は、&lt;em&gt;ブランケット実装&lt;/em&gt;と呼ばれ、Rust標準ライブラリで広く使用されています。たとえば、標準ライブラリは、 &lt;code&gt;Display&lt;/code&gt; トレイトを実装するすべての型に &lt;code&gt;ToString&lt;/code&gt; トレイトを実装します。標準ライブラリの &lt;code&gt;impl&lt;/code&gt; ブロックは、次のコードに似ています。</target>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="translated">パスの先頭に &lt;code&gt;super&lt;/code&gt; を使用することにより、親モジュールで始まる相対パスを構築することもできます。これは、 &lt;code&gt;..&lt;/code&gt; 構文でファイルシステムパスを開始するようなものです。なぜこれを行いたいのですか？</target>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 構文を使用して、1つ以上のフィールドでジェネリック型パラメーターを使用する構造体を定義することもできます。リスト10-6は、任意の型の &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; 座標値を保持するために &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 構造体を定義する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="translated">また、すべてのフィールドに対して変数を作成するのではなく、構造体パターンの一部としてリテラル値を使用してデストラクトすることもできます。そうすることで、いくつかのフィールドを特定の値でテストしながら、他のフィールドを破壊するために変数を作成することができます。</target>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="translated">すべての要素に変更を加えるために、可変ベクトルの各要素への可変参照を反復することもできます。リスト8-9 の &lt;code&gt;for&lt;/code&gt; ループは各要素に &lt;code&gt;50&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="translated">&lt;code&gt;-p&lt;/code&gt; フラグを使用して、テストするクレートの名前を指定することにより、ワークスペース内の特定のクレートのトップレベルディレクトリからテストを実行することもできます。</target>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">複数の特性境界を指定することもできます。我々が望んでいたと言う &lt;code&gt;notify&lt;/code&gt; に書式設定、表示に使用する &lt;code&gt;item&lt;/code&gt; だけでなく、 &lt;code&gt;summarize&lt;/code&gt; 方法：我々は、で指定 &lt;code&gt;notify&lt;/code&gt; することを定義 &lt;code&gt;item&lt;/code&gt; 両方実装しなければならない &lt;code&gt;Display&lt;/code&gt; と &lt;code&gt;Summary&lt;/code&gt; 。 &lt;code&gt;+&lt;/code&gt; 構文を使用してこれを行うことができます：</target>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="translated">また、I / Oプロジェクトの &lt;code&gt;search&lt;/code&gt; 機能でイテレーターを利用することもできます。これは、リスト12-19と同じようにリスト13-28で再現されています。</target>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="translated">別のパターン内で &lt;code&gt;_&lt;/code&gt; を使用して、値の一部のみを無視することもできます。たとえば、値の一部のみをテストしたいが、実行する対応するコードの他の部分は使用しない場合などです。リスト18-18は設定の値を管理する責任があるコードを示しています。ビジネス要件は、ユーザーが設定の既存のカスタマイズを上書きすることを許可してはいけないことですが、設定を解除し、現在設定されていない場合は値を与えることができます。</target>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; を使用して、他の言語がRust関数を呼び出すことができるインターフェイスを作成することもできます。代わりに &lt;code&gt;extern&lt;/code&gt; ブロック、我々は追加 &lt;code&gt;extern&lt;/code&gt; キーワードをし、直前に使用するABIを指定 &lt;code&gt;fn&lt;/code&gt; キーワード。 &lt;code&gt;#[no_mangle]&lt;/code&gt; アノテーションを追加して、Rustコンパイラにこの関数の名前をマングルしないように指示する必要もあります。&lt;em&gt;マングリング&lt;/em&gt;コンパイラが関数に付けた名前を、コンパイルプロセスの他の部分が使用するためのより多くの情報を含む別の名前に変更するときですが、人間には判読できません。すべてのプログラミング言語コンパイラーは、名前をわずかに異なる方法でマングルします。そのため、Rust関数を他の言語で名前付けできるようにするには、Rustコンパイラーの名前のマングリングを無効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; を使用して、構造体と列挙型をパブリックとして指定することもできますが、追加の詳細がいくつかあります。構造体定義の前に &lt;code&gt;pub&lt;/code&gt; を使用する場合、構造体をパブリックにしますが、構造体のフィールドは引き続きプライベートになります。ケースバイケースで、各フィールドを公開するかどうかを指定できます。リスト7-9では、我々は公共定義した &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 公共持つ構造体 &lt;code&gt;toast&lt;/code&gt; フィールドが、プライベート &lt;code&gt;seasonal_fruit&lt;/code&gt; をフィールド。これは、顧客が食事と一緒に提供するパンの種類を選択できるレストランのケースをモデル化していますが、シェフは季節や在庫状況に基づいて、食事に付随する果物を決定します。利用できる果物はすぐに変わるので、顧客は果物を選択したり、どの果物を手に入れるかを見たりすることさえできません。</target>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="translated">13章で説明したように、クロージャは関数に似ているので、関数のパラメータリストと同じようにクロージャのパラメータリストでパターンを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="translated">パターンを使用して、構造体、列挙型、タプル、参照を分解し、これらの値のさまざまな部分を使用することもできます。それぞれの値について見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="translated">次に示すように、戻り位置で &lt;code&gt;impl Trait&lt;/code&gt; 構文を使用して、特性を実装するあるタイプの値を返すこともできます。</target>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="translated">我々はまた、機能を使用することができます &lt;code&gt;String::from&lt;/code&gt; 作成するために、 &lt;code&gt;String&lt;/code&gt; 列リテラルからを。コードリスト8-13のコードは、 &lt;code&gt;to_string&lt;/code&gt; を使用するコードリスト8-12のコードと同等です。</target>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="translated">特定の値を無視するために1つのパターン内の複数の場所でアンダースコアを使うこともできます。リスト18-19は5つの項目のタプルの2番目と4番目の値を無視する例を示しています。</target>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo build&lt;/code&gt; または &lt;code&gt;cargo check&lt;/code&gt; を使用してプロジェクトを構築できます。</target>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="translated">カーゴランを使用すると、1つのステップでプロジェクトを構築して実行でき &lt;code&gt;cargo run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="translated">定義した関数は、その名前に続けて括弧を入力することで呼び出すことができます。 &lt;code&gt;another_function&lt;/code&gt; はプログラムで定義されているため、 &lt;code&gt;main&lt;/code&gt; 関数内から呼び出すことができます。ソースコードの &lt;code&gt;main&lt;/code&gt; 関数の&lt;em&gt;後&lt;/em&gt;に &lt;code&gt;another_function&lt;/code&gt; を定義したことに注意してください。以前に定義することもできました。Rustは、関数がどこで定義されているかを気にしません。関数がどこで定義されているかだけです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="translated">&lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; のように、文字列スライスを引数として &lt;code&gt;hello&lt;/code&gt; 関数を呼び出すことができます。例えば。リスト15-12に示すように、 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 強制により、タイプMyBox &amp;lt;String&amp;gt;の値への参照を使用して &lt;code&gt;hello&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="translated">イテレータで &lt;code&gt;next&lt;/code&gt; メソッドを直接呼び出すことができます。リスト13-15 は、ベクターから作成されたイテレーターで繰り返される呼び出しから &lt;code&gt;next&lt;/code&gt; へ返される値を示しています。</target>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="translated">私たちは、の定義変更できる &lt;code&gt;List&lt;/code&gt; 15-2との使用リストに列挙型を &lt;code&gt;List&lt;/code&gt; コンパイルしますリスト15-5のコードにリスト15-3では：</target>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; をあらゆる種類のポインタと組み合わせることができます。たとえば、 &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; または &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt; です。実際、これは以前に見たことがありますが、動的にサイズが異なるタイプである特性です。すべての特性は、特性の名前を使用して参照できる動的なサイズの型です。第17章の&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;「さまざまな型の値を許可する特性オブジェクトの使用」&lt;/a&gt;セクションで、特性オブジェクトとして特性を使用するには、 &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; や &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; （ &lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; も機能します）。</target>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;IpAddrKind&lt;/code&gt; ように、IpAddrKindの2つのバリアントのそれぞれのインスタンスを作成できます。</target>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">我々は、指定して括弧内の範囲を使用してスライスを作成することができる &lt;code&gt;[starting_index..ending_index]&lt;/code&gt; ここで、 &lt;code&gt;starting_index&lt;/code&gt; はスライスの最初の位置であり、 &lt;code&gt;ending_index&lt;/code&gt; がスライスの最後の位置よりも一つです。対応する内部、スライスデータ構造を格納開始位置とスライスの長さ、 &lt;code&gt;ending_index&lt;/code&gt; マイナス &lt;code&gt;starting_index&lt;/code&gt; を。だから &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; の場合=＆s [6..11];、 &lt;code&gt;world&lt;/code&gt; は、長さが5 &lt;code&gt;s&lt;/code&gt; 7番目のバイトへのポインタを含むスライスになります。</target>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="translated">&lt;code&gt;IpAddrKind&lt;/code&gt; 列挙を定義し、IPアドレスの可能な種類（ &lt;code&gt;V4&lt;/code&gt; および &lt;code&gt;V6&lt;/code&gt; )をリストすることで、この概念をコードで表現できます。これらは列挙&lt;em&gt;型のバリアント&lt;/em&gt;として知られてい&lt;em&gt;ます&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="translated">リスト4-6のコードのエラーを修正するには、ほんの少し手を加えるだけです。</target>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="translated">&lt;code&gt;thread::spawn&lt;/code&gt; 戻り値を変数に保存することで、生成されたスレッドが実行されない、または完全に実行されないという問題を修正できます。 &lt;code&gt;thread::spawn&lt;/code&gt; の戻りの型は &lt;code&gt;JoinHandle&lt;/code&gt; です。A &lt;code&gt;JoinHandle&lt;/code&gt; は、私たちが呼ぶとき、所有している値である &lt;code&gt;join&lt;/code&gt; それに方法を、最後までそのスレッドを待ちます。リスト16-2は、リスト16-1で作成したスレッドの &lt;code&gt;JoinHandle&lt;/code&gt; を使用し、 &lt;code&gt;join&lt;/code&gt; を呼び出して、生成されたスレッドが &lt;code&gt;main&lt;/code&gt; 終了前に終了することを確認する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="translated">リスト8-23で示されるように、 &lt;code&gt;get&lt;/code&gt; メソッドにキーを提供することでハッシュマップから値を取得できます。</target>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="translated">私たちは成長することができます &lt;code&gt;String&lt;/code&gt; 使用して &lt;code&gt;push_str&lt;/code&gt; のリスト8-15に示すように、文字列のスライスを追加する方法を。</target>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="translated">（第5章で行ったように）構造体と列挙型にメソッドを実装し、その定義でジェネリック型を使用することもできます。リスト10-9は、リスト10-6で定義した &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 構造体に &lt;code&gt;x&lt;/code&gt; という名前のメソッドが実装されていることを示しています。</target>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; で &lt;code&gt;else&lt;/code&gt; を含めることができます。となったコードのブロック &lt;code&gt;else&lt;/code&gt; となるだろうコードのブロックと同じである &lt;code&gt;_&lt;/code&gt; 中の場合 &lt;code&gt;match&lt;/code&gt; と等価である表現 &lt;code&gt;if let&lt;/code&gt; と &lt;code&gt;else&lt;/code&gt; 。思い出して &lt;code&gt;Coin&lt;/code&gt; 表6-4に列挙定義 &lt;code&gt;Quarter&lt;/code&gt; 変異体はまた、保持 &lt;code&gt;UsState&lt;/code&gt; の値。表示されるすべての非クォーターコインを数えたいと同時に、クォーターの状態もアナウンスしたい場合は、次のような &lt;code&gt;match&lt;/code&gt; 式でそれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="translated">代わりに、成功した場合の &lt;code&gt;Config&lt;/code&gt; インスタンスを含み、エラーの場合の問題を説明する &lt;code&gt;Result&lt;/code&gt; 値を返すことができます。 &lt;code&gt;Config::new&lt;/code&gt; が &lt;code&gt;main&lt;/code&gt; と通信しているとき、 &lt;code&gt;Result&lt;/code&gt; タイプを使用して問題があったことを通知できます。次に、 &lt;code&gt;main&lt;/code&gt; を変更して、 &lt;code&gt;thread 'main'&lt;/code&gt; および &lt;code&gt;panic!&lt;/code&gt; 呼び出しである &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; に関する周囲のテキストなしで、 &lt;code&gt;Err&lt;/code&gt; バリアントをユーザーにとってより実用的なエラーに変換できます。原因。</target>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">ベクトルの場合と同様に、 &lt;code&gt;for&lt;/code&gt; ループを使用して、ハッシュマップの各キー/値ペアを反復できます。</target>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="translated">さらに複雑な方法で、デストラクチャリング・パターンを混合、マッチング、およびネストすることができます。次の例は、構造体とタプルをタプルの中に入れ子にして、すべてのプリミティブ値を破壊する複雑な破壊構造を示しています。</target>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="translated">これで &lt;code&gt;use rand;&lt;/code&gt; 追加できます。&lt;em&gt;アドオン1 / SRC / lib.rsの&lt;/em&gt;ファイル、および実行することにより、全体のワークスペースを構築する &lt;code&gt;cargo build&lt;/code&gt; に&lt;em&gt;追加&lt;/em&gt;で持ってきてコンパイルするディレクトリ &lt;code&gt;rand&lt;/code&gt; クレートを：</target>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="translated">任意のテスト関数の名前を &lt;code&gt;cargo test&lt;/code&gt; に渡して、そのテストのみを実行できます。</target>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="translated">これが何をしているのか、おそらく推測できます。「値 &lt;code&gt;5&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; にバインドします。次に、 &lt;code&gt;x&lt;/code&gt; の値のコピーを作成し、それを &lt;code&gt;y&lt;/code&gt; にバインドします。」これで2つの変数 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; があり、どちらも &lt;code&gt;5&lt;/code&gt; です。整数は既知の固定サイズの単純な値であり、これら2つの &lt;code&gt;5&lt;/code&gt; つの値はスタックにプッシュされるため、これは実際に起こっていることです。</target>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="translated">各列挙型バリアントにデータを直接入力することにより、構造体内の列挙型ではなく列挙型のみを使用して、同じ概念をより簡潔に表すことができます。 &lt;code&gt;IpAddr&lt;/code&gt; 列挙型のこの新しい定義は、 &lt;code&gt;V4&lt;/code&gt; と &lt;code&gt;V6&lt;/code&gt; の両方のバリアントに関連付けられた &lt;code&gt;String&lt;/code&gt; 値があることを示しています。</target>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="translated">リスト15-6のコードを書き換えて、参照の代わりに &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; を使用できます。逆参照演算子は、コードリスト15-7に示すように機能します。</target>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="translated">私たちが見ることができるという &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; に1の初期の参照カウントを持っています。その後、 &lt;code&gt;clone&lt;/code&gt; を呼び出すたびに、カウントが1 ずつ増加します &lt;code&gt;c&lt;/code&gt; がスコープから外れると、カウントが1 ずつ減少します &lt;code&gt;Rc::clone&lt;/code&gt; を呼び出す必要があるように、参照カウントを減らす関数を呼び出す必要はありません。参照カウントを増やすための複製： &lt;code&gt;Drop&lt;/code&gt; トレイトの実装は、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 値が範囲外になると、参照カウントを自動的に減らします。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="translated">テスト出力で実際に得られた値を見ることができるので、何が起こると思っていたかではなく、何が起こったのかをデバッグするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="translated">テスト名の一部を指定することができ、その値に一致する名前のテストが実行されます。たとえば、2つのテストの名前に &lt;code&gt;add&lt;/code&gt; が含まれているため、 &lt;code&gt;cargo test add&lt;/code&gt; を実行することでこれら2つを実行できます。</target>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="translated">私たちはまだこれよりうまくいくことができます！これらはすべて文字列なので、 &lt;code&gt;From::from&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="translated">&lt;code&gt;cargo test&lt;/code&gt; 引数としてテスト関数の名前を指定することで、特定の統合テスト関数を実行できます。特定の統合テストファイルですべてのテストを実行するには、 &lt;code&gt;cargo test&lt;/code&gt; の &lt;code&gt;--test&lt;/code&gt; 引数の後にファイル名を続けます。</target>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="translated">&lt;code&gt;parse_config&lt;/code&gt; 関数をさらに改善するために、別の小さなステップを実行できます。現在、タプルを返していますが、すぐにそのタプルを再び個々の部分に分割します。これは、おそらく正しい抽象化がまだできていないことを示しています。</target>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="translated">&lt;code&gt;LineWriter&lt;/code&gt; を使用して一度に1行ずつ書き込むことができるため、ファイルへの実際の書き込み回数を大幅に削減できます。</target>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">パスの任意のレベルでネストされたパスを使用できます。これは、サブパスを共有する2つの &lt;code&gt;use&lt;/code&gt; ステートメントを組み合わせるときに役立ちます。たとえば、リスト7-19は2つの &lt;code&gt;use&lt;/code&gt; ステートメントを示しています。1つは &lt;code&gt;std::io&lt;/code&gt; をスコープ内に持ち、もう1つは &lt;code&gt;std::io::Write&lt;/code&gt; をスコープ内に持ちます。</target>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="translated">ジェネリックスを使用して、関数のシグネチャや構造体などのアイテムの定義を作成できます。これは、さまざまな具象データ型で使用できます。最初に、ジェネリックスを使用して関数、構造体、列挙型、メソッドを定義する方法を見てみましょう。次に、ジェネリックスがコードのパフォーマンスにどのように影響するかについて説明します。</target>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="translated">私たちは、私たちが通過したときに、例えば、そのアサートテストを書くことができる &lt;code&gt;3&lt;/code&gt; に &lt;code&gt;add_two&lt;/code&gt; の機能、返される値は &lt;code&gt;5&lt;/code&gt; 。コードに変更を加えるたびにこれらのテストを実行して、既存の正しい動作が変更されていないことを確認できます。</target>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="translated">イテレーターアダプターメソッドを使用して、このコードをより簡潔に記述できます。そうすることで、変更可能な中間 &lt;code&gt;results&lt;/code&gt; ベクトルを避けることができます。関数型プログラミングスタイルでは、コードをより明確にするために、可変状態の量を最小限に抑えることを好みます。変更可能な状態を削除すると、 &lt;code&gt;results&lt;/code&gt; ベクトルへの同時アクセスを管理する必要がないため、将来の拡張で検索が並行して行われる可能性があります。リスト13-29はこの変更を示しています：</target>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="translated">値がスコープ外になった場合の &lt;code&gt;drop&lt;/code&gt; の自動挿入を無効にすることはできず、 &lt;code&gt;drop&lt;/code&gt; メソッドを明示的に呼び出すこともできません。したがって、値を強制的に早期にクリーンアップする必要がある場合は、 &lt;code&gt;std::mem::drop&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="translated">関数についても同じことはできません。次の例を試すと、コードはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">安全なRustだけを使用してこの関数を実装することはできません。試行はリスト19-5のようになり、コンパイルされません。簡単にするために、 &lt;code&gt;split_at_mut&lt;/code&gt; をメソッドではなく関数として実装し、ジェネリック型 &lt;code&gt;T&lt;/code&gt; ではなく &lt;code&gt;i32&lt;/code&gt; 値のスライスにのみ実装します。</target>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; メソッドは &lt;code&gt;self&lt;/code&gt; への不変の参照を &lt;code&gt;MockMessenger&lt;/code&gt; ため、MockMessengerを変更してメッセージを追跡することはできません。また、使用するエラーテキストからの提案を取ることができない &lt;code&gt;&amp;amp;mut self&lt;/code&gt; その後の署名ので、代わりの &lt;code&gt;send&lt;/code&gt; で署名一致しません &lt;code&gt;Messenger&lt;/code&gt; の特性の定義を（試してみて、何を得るのエラーメッセージが表示して自由に感じます）。</target>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="translated">この方法で複数のテストの名前を指定することはできません。 &lt;code&gt;cargo test&lt;/code&gt; 指定された最初の値のみが使用されます。しかし、複数のテストを実行する方法があります。</target>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;amp;Foo&lt;/code&gt; のオブジェクトは作成できません。この場合、 &lt;code&gt;Self&lt;/code&gt; は &lt;code&gt;Sized&lt;/code&gt; ないためです。</target>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">負の数のスレッドは意味をなさないことがわかっているため、 &lt;code&gt;size&lt;/code&gt; パラメータのタイプとして &lt;code&gt;usize&lt;/code&gt; を選択しました。また、この4をスレッドのコレクションの要素数として使用することもわかっています。これは、第3章の&lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;「整数型」&lt;/a&gt;セクションで説明したように、 &lt;code&gt;usize&lt;/code&gt; 型の目的です。</target>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; を &lt;code&gt;leaf&lt;/code&gt; 複製し、それを &lt;code&gt;branch&lt;/code&gt; に保存します。つまり、 &lt;code&gt;leaf&lt;/code&gt; の &lt;code&gt;Node&lt;/code&gt; に2つの所有者、つまり &lt;code&gt;leaf&lt;/code&gt; と &lt;code&gt;branch&lt;/code&gt; ます。私たちは、から入手することができ &lt;code&gt;branch&lt;/code&gt; に &lt;code&gt;leaf&lt;/code&gt; を通じて &lt;code&gt;branch.children&lt;/code&gt; 、しかしから取得する方法はありません &lt;code&gt;leaf&lt;/code&gt; に &lt;code&gt;branch&lt;/code&gt; 。その理由は、 &lt;code&gt;leaf&lt;/code&gt; は &lt;code&gt;branch&lt;/code&gt; への参照がなく、それらが関連していることを知らないためです。 &lt;code&gt;branch&lt;/code&gt; が親であることを &lt;code&gt;leaf&lt;/code&gt; に知らせたい。次にそれを行います。</target>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="translated">&lt;code&gt;vec!&lt;/code&gt; も使用できます。2つの整数のベクトルまたは5つの文字列スライスのベクトルを作成するマクロ。前もって値の数やタイプがわからないため、関数を使用して同じことを行うことはできません。</target>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="translated">代わりに参照を保持するように &lt;code&gt;Cons&lt;/code&gt; の定義を変更することもできますが、その場合は寿命パラメーターを指定する必要があります。ライフタイムパラメータを指定することで、リスト内のすべての要素が少なくともリスト全体と同じ長さで存続するように指定します。借用チェッカーでは &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; コンパイルできません。一時的なので、例えば、 &lt;code&gt;Nil&lt;/code&gt; 値が前に削除されるだろう、それへの参照を取ることができます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="translated">私たちはここでより多くのことをすることができます! このプロジェクトを継続的に強化していきたいとお考えの方には、以下のようなアイデアをご紹介します。</target>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt; &lt;code&gt;a.clone()&lt;/code&gt; ではなくa.clone（）を呼び出すこともできましたが、Rustの規則はこの場合 &lt;code&gt;Rc::clone&lt;/code&gt; を使用することです。実装 &lt;code&gt;Rc::clone&lt;/code&gt; 、ほとんどの種類の実装などのデータすべてのディープコピーを作成していない &lt;code&gt;clone&lt;/code&gt; ありません。 &lt;code&gt;Rc::clone&lt;/code&gt; の呼び出しは参照カウントをインクリメントするだけで、それほど時間はかかりません。データのディープコピーには時間がかかる場合があります。参照カウントに &lt;code&gt;Rc::clone&lt;/code&gt; を使用することにより、ディープコピーの種類のクローンと、参照カウントを増やすクローンの種類を視覚的に区別できます。コードでパフォーマンスの問題を探す場合は、ディープコピーのクローンを検討するだけでよく、呼び出しを無視できます。 &lt;code&gt;Rc::clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; データはさまざまな方法で管理できますが、最も非効率的ではありますが、最も簡単な方法は、値に対して &lt;code&gt;clone&lt;/code&gt; メソッドを呼び出すことです。これにより、 &lt;code&gt;Config&lt;/code&gt; インスタンスが所有するデータの完全なコピーが作成されます。これには、文字列データへの参照を格納するよりも多くの時間とメモリが必要です。ただし、データのクローンを作成すると、参照の有効期間を管理する必要がないため、コードが非常に簡単になります。この状況では、簡単にするために少しパフォーマンスをあきらめることは、価値のあるトレードオフです。</target>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="translated">さまざまな方法でトレーニングプログラムを再構築できます。まず、リスト13-4に示すように、 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 関数への重複した呼び出しを変数に抽出してみましょう。</target>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">たとえば、ジェネリック型の &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; インスタンスではなく、 &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; インスタンスのみにメソッドを実装できます。リスト10-10では、具象型 &lt;code&gt;f32&lt;/code&gt; を使用しています。つまり、 &lt;code&gt;impl&lt;/code&gt; の後に型を宣言していません。</target>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="translated">この章では多くのことを取り上げました！ジェネリック型パラメーター、トレイトとトレイト境界、およびジェネリックライフタイムパラメーターについて理解したので、さまざまな状況で機能する繰り返しなしでコードを書く準備ができました。ジェネリック型パラメーターを使用すると、さまざまな型にコードを適用できます。特性と特性の境界により、型がジェネリックであっても、コードに必要な動作が確実に得られます。この柔軟なコードにぶら下がっている参照がないようにするために、ライフタイムアノテーションを使用する方法を学びました。また、この分析はすべてコンパイル時に行われるため、実行時のパフォーマンスには影響しません。</target>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="translated">リスト16-12で行ったように、 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 内に &lt;code&gt;i32&lt;/code&gt; を保持する &lt;code&gt;counter&lt;/code&gt; 変数を作成します。次に、一連の数値を反復して10個のスレッドを作成します。 &lt;code&gt;thread::spawn&lt;/code&gt; を使用して、すべてのスレッドに同じクロージャーを与えます。1つはカウンターをスレッドに移動し、 &lt;code&gt;lock&lt;/code&gt; メソッドを呼び出して &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ロックを取得し、ミューテックスの値に1を追加します。スレッドがそのクロージャーの実行を終了すると、 &lt;code&gt;num&lt;/code&gt; はスコープ外になり、ロックを解放して、別のスレッドがロックを獲得できるようにします。</target>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="translated">プロジェクトディレクトリの最上位、&lt;em&gt;srcの&lt;/em&gt;隣に&lt;em&gt;テスト&lt;/em&gt;ディレクトリを作成し&lt;em&gt;ます&lt;/em&gt;。 Cargoは、このディレクトリで統合テストファイルを探すことを知っています。その後、このディレクトリに必要なだけテストファイルを作成できます。Cargoは各ファイルを個別のクレートとしてコンパイルします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="translated">&lt;code&gt;mpsc::channel&lt;/code&gt; 関数を使用して新しいチャネルを作成します。 &lt;code&gt;mpsc&lt;/code&gt; は、&lt;em&gt;複数のプロデューサー、単一のコンシューマーを&lt;/em&gt;表します。要するに、Rustの標準ライブラリがチャネルを実装する方法は、チャネルが値を生成する複数の&lt;em&gt;送信&lt;/em&gt;端を持つことができるが、それらの値を消費する1つの&lt;em&gt;受信&lt;/em&gt;端のみを持つことができることを意味します。複数の小川が1つの大きな川に流れ込むことを想像してください。いずれかの小川に流れ落ちたものはすべて、最後に1つの川になります。ここでは単一のプロデューサーから始めますが、この例が機能するようになったら複数のプロデューサーを追加します。</target>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="translated">かっこ内に値のコンマ区切りリストを記述してタプルを作成します。タプルの各位置にはタイプがあり、タプルの異なる値のタイプは同じである必要はありません。この例では、オプションの型注釈を追加しています。</target>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; インスタンスである値を作成し、後で直接アクセスできるように、 &lt;code&gt;value&lt;/code&gt; という名前の変数に格納します。その後、我々は、作成する &lt;code&gt;List&lt;/code&gt; 中での &lt;code&gt;Cons&lt;/code&gt; を保持バリアント &lt;code&gt;value&lt;/code&gt; 。私たちは、クローンに必要な &lt;code&gt;value&lt;/code&gt; の両方ので、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;value&lt;/code&gt; 、内側の所有権が持っている &lt;code&gt;5&lt;/code&gt; むしろから所有権を転送するよりも、値を &lt;code&gt;value&lt;/code&gt; にか持つからボロー &lt;code&gt;value&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="translated">私たちは、変数を作成 &lt;code&gt;one_borrow&lt;/code&gt; ため &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; から返されたスマートポインタ &lt;code&gt;borrow_mut&lt;/code&gt; 。次に、変数 &lt;code&gt;two_borrow&lt;/code&gt; に同じ方法で別の可変借入を作成します。これにより、同じスコープ内で2つの変更可能な参照が作成されますが、これは許可されていません。ライブラリのテストを実行すると、リスト15-23のコードはエラーなしでコンパイルされますが、テストは失敗します。</target>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="translated">&lt;code&gt;guess&lt;/code&gt; という名前の変数を作成します。しかし、待ってください、プログラムには &lt;code&gt;guess&lt;/code&gt; という名前の変数がすでにありませんか？それはありませんが、錆は、私たちがすることができます&lt;em&gt;影&lt;/em&gt;の前の値 &lt;code&gt;guess&lt;/code&gt; 新しいものに。この機能は、値をあるタイプから別のタイプに変換する場合によく使用されます。シャドウイングを使用すると、 &lt;code&gt;guess_str&lt;/code&gt; や &lt;code&gt;guess&lt;/code&gt; などの2つの一意の変数を作成せずに、 &lt;code&gt;guess&lt;/code&gt; 変数名を再利用できます。 （第3章では、シャドウイングについて詳しく説明しています。）</target>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">変数 &lt;code&gt;a&lt;/code&gt; の &lt;code&gt;List&lt;/code&gt; 値を保持する &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; インスタンスを作成します。初期リストは &lt;code&gt;5, Nil&lt;/code&gt; です。私たちは、その後、作成 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 別の保持のインスタンスを &lt;code&gt;List&lt;/code&gt; 変数に値を &lt;code&gt;b&lt;/code&gt; でリストに値10と点を含んでいます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; キーワードで開始してモジュールを定義し、モジュールの名前（この場合は、 &lt;code&gt;front_of_house&lt;/code&gt; ）を指定して、モジュールの本体を中括弧で囲みます。モジュール内には、他のモジュールを含めることができます。この場合は、 &lt;code&gt;hosting&lt;/code&gt; と &lt;code&gt;serving&lt;/code&gt; モジュールです。モジュールは、構造体、列挙型、定数、特性、またはリスト7-1のように関数など、他の項目の定義も保持できます。</target>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="translated">&lt;code&gt;MyBox&lt;/code&gt; という名前の構造体を定義し、ジェネリックパラメーター &lt;code&gt;T&lt;/code&gt; を宣言します。これは、型に任意の型の値を保持させるためです。 &lt;code&gt;MyBox&lt;/code&gt; のタイプは、タイプの一つの要素を持つタプル構造体である &lt;code&gt;T&lt;/code&gt; 。 &lt;code&gt;MyBox::new&lt;/code&gt; 機能は、タイプの一つのパラメータ取り &lt;code&gt;T&lt;/code&gt; をして返す &lt;code&gt;MyBox&lt;/code&gt; の中で渡された値を保持しているインスタンスを。</target>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="translated">変数 &lt;code&gt;b&lt;/code&gt; を、ヒープに割り当てられている値 &lt;code&gt;5&lt;/code&gt; を指す &lt;code&gt;Box&lt;/code&gt; の値を持つように定義します。このプログラムは &lt;code&gt;b = 5&lt;/code&gt; ます。この場合、このデータがスタックにある場合と同様に、ボックス内のデータにアクセスできます。所有されている値と同様に、ボックスがスコープ外になると、 &lt;code&gt;b&lt;/code&gt; が &lt;code&gt;main&lt;/code&gt; の最後に行うように、割り当てが解除されます。割り当て解除は、ボックス（スタックに格納されている）とボックスが指すデータ（ヒープに格納されている）に対して行われます。</target>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="translated">やりました！私たちは0から10まで数えましたが、それほど印象的ではないかもしれませんが、 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; とスレッドセーフティについて多くのことを教えてくれました。このプログラムの構造を使用して、カウンタをインクリメントするだけではなく、より複雑な操作を実行することもできます。この戦略を使用すると、計算を独立した部分に分割し、それらの部分をスレッド間で分割してから、 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; を使用して、各スレッドにその部分で最終結果を更新させることができます。</target>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; ケースは処理しなかったため、このコードはバグの原因になります。幸いなことに、それはRustがキャッチする方法を知っているバグです。このコードをコンパイルしようとすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="translated">カプセル化を制御する方法については、第7章で説明しました &lt;code&gt;pub&lt;/code&gt; キーワードを使用して、コード内のどのモジュール、型、関数、およびメソッドをパブリックにするかを決定できます。デフォルトでは、他はすべてプライベートです。たとえば、 &lt;code&gt;i32&lt;/code&gt; 値のベクトルを含むフィールドを持つstruct &lt;code&gt;AveragedCollection&lt;/code&gt; を定義できます。構造体は、ベクトルの値の平均を含むフィールドを持つこともできます。つまり、平均は、だれかがそれを必要とするときはいつでもオンデマンドで計算する必要はありません。つまり、 &lt;code&gt;AveragedCollection&lt;/code&gt; は計算された平均をキャッシュします。リスト17-1は &lt;code&gt;AveragedCollection&lt;/code&gt; 構造体の定義を持っています：</target>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="translated">これを行うには、テスト関数に別の属性 &lt;code&gt;should_panic&lt;/code&gt; を追加します。この属性は、関数内のコードでパニックが発生した場合にテストに合格します。関数内のコードがパニックにならない場合、テストは失敗します。</target>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="translated">この場合、あまり役立つメッセージは表示されませんが、テスト関数を見ると、 &lt;code&gt;#[should_panic]&lt;/code&gt; で注釈が付けられていることがわかります。失敗したということは、テスト関数のコードがパニックを引き起こさなかったことを意味します。</target>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="translated">私たちは、内のコード注釈を付ける必要はありません&lt;em&gt;テスト/ integration_test.rs&lt;/em&gt;と &lt;code&gt;#[cfg(test)]&lt;/code&gt; 。Cargoは、 &lt;code&gt;tests&lt;/code&gt; ディレクトリを特別に扱い、 &lt;code&gt;cargo test&lt;/code&gt; を実行するときにのみ、このディレクトリ内のファイルをコンパイルします。 &lt;code&gt;cargo test&lt;/code&gt; 今すぐ実行します。</target>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="translated">この任意の場所にメモリを所有しているわけではなく、このコードが作成するスライスに有効な &lt;code&gt;i32&lt;/code&gt; 値が含まれている保証はありません。 &lt;code&gt;slice&lt;/code&gt; を有効なスライスであるかのように使用しようとすると、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="translated">&lt;code&gt;Trait&lt;/code&gt; のすべてのメソッドのすべての実装のテーブルを作成するだけでなく、 &lt;code&gt;foo()&lt;/code&gt; に供給される異なる型ごとにそのようなテーブルを作成する必要があります。この場合、これは（ &lt;code&gt;Trait&lt;/code&gt; を実装する10の型）*（ &lt;code&gt;foo()&lt;/code&gt; に供給される3の型）= 30の実装になります！</target>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="translated">結局は違う出力になってしまいます。</target>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="translated">&lt;code&gt;deref&lt;/code&gt; メソッドの本体に &lt;code&gt;&amp;amp;self.0&lt;/code&gt; を入力するため、 &lt;code&gt;deref&lt;/code&gt; は &lt;code&gt;*&lt;/code&gt; 演算子でアクセスする値への参照を返します。 &lt;code&gt;main&lt;/code&gt; 通話ことリスト15-9で機能 &lt;code&gt;*&lt;/code&gt; 上の &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 値は、今コンパイルし、アサーションが合格！</target>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="translated">最初に、第10章の&lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;「特性：共有動作の定義」&lt;/a&gt;セクションで特性を取り上げましたが、ライフタイムと同様に、より高度な詳細については説明しませんでした。Rustの詳細を理解したところで、要点を説明します。</target>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="translated">細かいミスや不正確な言い回しなどを随所に修正しました。それらを報告してくださった読者の皆様、ありがとうございました</target>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="translated">&lt;code&gt;ast.ident&lt;/code&gt; を使用して、注釈付きタイプの名前（識別子）を含む &lt;code&gt;Ident&lt;/code&gt; 構造体インスタンスを取得します。私たちが実行したときという表の構造体19-32ショー &lt;code&gt;impl_hello_macro&lt;/code&gt; リスト19-30のコードの機能を、 &lt;code&gt;ident&lt;/code&gt; を我々が得るが持つ &lt;code&gt;ident&lt;/code&gt; の値を持つフィールド &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; 。したがって、リスト19-33の &lt;code&gt;name&lt;/code&gt; 変数には、 &lt;code&gt;Ident&lt;/code&gt; 構造体インスタンスが含まれます。このインスタンスは、印刷されると、文字列 &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; （リスト19-30の構造体の名前）になります。</target>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="translated">&lt;code&gt;Display&lt;/code&gt; は必須だが実装されていないというエラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="translated">エラーが出ます。</target>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="translated">リスト4-7で行ったのと同じ方法で、スペースの最初の出現を探すことで単語の終わりのインデックスを取得します。スペースを見つけるとき、文字列の開始インデックスとスペースのインデックスを開始インデックスと終了インデックスとして使い、文字列のスライスを返します。</target>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="translated">私たちは与える &lt;code&gt;Post&lt;/code&gt; という名前のパブリックメソッド &lt;code&gt;request_review&lt;/code&gt; への変更可能な参照取る &lt;code&gt;self&lt;/code&gt; 。次に、 &lt;code&gt;Post&lt;/code&gt; の現在の状態で内部 &lt;code&gt;request_review&lt;/code&gt; メソッドを呼び出します。この2番目の &lt;code&gt;request_review&lt;/code&gt; メソッドは現在の状態を消費し、新しい状態を返します。</target>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="translated">私たちには、特徴とその機能があります。この時点で、私たちのクレートユーザーは、以下のように、目的の機能を実現するために特徴を実装することができます。</target>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="translated">タプル構造体とタプル構造体列挙型バリアントの実装の詳細を利用する別の有用なパターンがあります。これらの型は、関数呼び出しのように見える初期化構文として &lt;code&gt;()&lt;/code&gt; を使用します。初期化子は実際には、引数から構築されたインスタンスを返す関数として実装されています。これらの初期化関数を、クロージャーの特性を実装する関数ポインターとして使用できます。つまり、次のように、初期化関数を、クロージャーを受け取るメソッドの引数として指定できます。</target>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="translated">ゲームのほとんどは現在動作していますが、ユーザーが推測できるのは1つだけです。ループを追加して変更しましょう！</target>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">2つの構造体 &lt;code&gt;Millimeters&lt;/code&gt; と &lt;code&gt;Meters&lt;/code&gt; があり、異なる単位で値を保持しています。ミリメートル単位の値をメートル単位の値に &lt;code&gt;Add&lt;/code&gt; し、Addの実装に変換を正しく行わせる必要があります。リスト19-15で示されているように、 &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; を &lt;code&gt;RHS&lt;/code&gt; として実装できます。</target>
        </trans-unit>
        <trans-unit id="0334dcbe551a168678883cc6ef5072f1b77f711d" translate="yes" xml:space="preserve">
          <source>We hinted that this example wouldn&amp;rsquo;t compile. Now let&amp;rsquo;s find out why!</source>
          <target state="translated">この例ではコンパイルできないことをほのめかしました。それでは、その理由を調べてみましょう！</target>
        </trans-unit>
        <trans-unit id="1c19907344e59dccc89eee30d7cddf54b21dbd0f" translate="yes" xml:space="preserve">
          <source>We implemented the &lt;code&gt;Iterator&lt;/code&gt; trait by defining the &lt;code&gt;next&lt;/code&gt; method, so we can now use any &lt;code&gt;Iterator&lt;/code&gt; trait method&amp;rsquo;s default implementations as defined in the standard library, because they all use the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s functionality.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; メソッドを定義して &lt;code&gt;Iterator&lt;/code&gt; トレイトを実装しました。すべてが &lt;code&gt;next&lt;/code&gt; メソッドの機能を使用するため、標準ライブラリで定義されている任意の &lt;code&gt;Iterator&lt;/code&gt; トレイトメソッドのデフォルト実装を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="0d4561449955c45ad5ebb7f1cf5ff9bb22096f4e" translate="yes" xml:space="preserve">
          <source>We just built a project with &lt;code&gt;cargo build&lt;/code&gt; and ran it with &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt;, but we can also use &lt;code&gt;cargo run&lt;/code&gt; to compile the code and then run the resulting executable all in one command:</source>
          <target state="translated">&lt;code&gt;cargo build&lt;/code&gt; プロジェクトをビルドして &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt; で &lt;code&gt;cargo run&lt;/code&gt; しただけですが、貨物実行を使用してコードをコンパイルし、結果の実行可能ファイルをすべて1つのコマンドで実行することもできます。</target>
        </trans-unit>
        <trans-unit id="87ae298deaf2e1fd72117ae5b5eb4b47977e9b52" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;offset&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">&lt;code&gt;mid&lt;/code&gt; インデックスがスライス内にあるという主張を維持します。次に、安全でないコードを取得し &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; 関数は、生のポインターと長さを受け取り、スライスを作成します。私たちは、から始まり、スライス作成するには、この機能を使用する &lt;code&gt;ptr&lt;/code&gt; とある &lt;code&gt;mid&lt;/code&gt; 長い項目を。その後、我々は呼んで &lt;code&gt;offset&lt;/code&gt; の方法 &lt;code&gt;ptr&lt;/code&gt; して &lt;code&gt;mid&lt;/code&gt; から開始することを生のポインタを取得するために、引数として &lt;code&gt;mid&lt;/code&gt; 、私たちはそのポインタを使用してスライスし、後のアイテムの残り数作成 &lt;code&gt;mid&lt;/code&gt; の長さなどを。</target>
        </trans-unit>
        <trans-unit id="240382aa15b940fb356b9ed46bfb7832514ebd3d" translate="yes" xml:space="preserve">
          <source>We know we want to define a method, so it will be within the &lt;code&gt;impl Rectangle&lt;/code&gt; block. The method name will be &lt;code&gt;can_hold&lt;/code&gt;, and it will take an immutable borrow of another &lt;code&gt;Rectangle&lt;/code&gt; as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; passes in &lt;code&gt;&amp;amp;rect2&lt;/code&gt;, which is an immutable borrow to &lt;code&gt;rect2&lt;/code&gt;, an instance of &lt;code&gt;Rectangle&lt;/code&gt;. This makes sense because we only need to read &lt;code&gt;rect2&lt;/code&gt; (rather than write, which would mean we&amp;rsquo;d need a mutable borrow), and we want &lt;code&gt;main&lt;/code&gt; to retain ownership of &lt;code&gt;rect2&lt;/code&gt; so we can use it again after calling the &lt;code&gt;can_hold&lt;/code&gt; method. The return value of &lt;code&gt;can_hold&lt;/code&gt; will be a Boolean, and the implementation will check whether the width and height of &lt;code&gt;self&lt;/code&gt; are both greater than the width and height of the other &lt;code&gt;Rectangle&lt;/code&gt;, respectively. Let&amp;rsquo;s add the new &lt;code&gt;can_hold&lt;/code&gt; method to the &lt;code&gt;impl&lt;/code&gt; block from Listing 5-13, shown in Listing 5-15.</source>
          <target state="translated">メソッドを定義したいので、それは &lt;code&gt;impl Rectangle&lt;/code&gt; ブロック内にあります。メソッド名は &lt;code&gt;can_hold&lt;/code&gt; になり、パラメーターとして別の &lt;code&gt;Rectangle&lt;/code&gt; の不変の借用が行われます。メソッドを呼び出すコードを見ると、パラメーターのタイプが何であるかが &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; ます。rect1.can_hold（＆rect2）は &lt;code&gt;&amp;amp;rect2&lt;/code&gt; に渡されます。これは、 &lt;code&gt;Rectangle&lt;/code&gt; のインスタンスである &lt;code&gt;rect2&lt;/code&gt; への不変の借用です。 &lt;code&gt;rect2&lt;/code&gt; を読み取るだけでよいので（書き込みではなく、変更可能な借用が必要になることを意味します）、 &lt;code&gt;main&lt;/code&gt; に &lt;code&gt;rect2&lt;/code&gt; の所有権を保持させたいため、これは理にかなっていますそのため、 &lt;code&gt;can_hold&lt;/code&gt; メソッドを呼び出した後で再び使用できます。 &lt;code&gt;can_hold&lt;/code&gt; の戻り値はブール値になり、実装は &lt;code&gt;self&lt;/code&gt; 幅と高さの両方が、それぞれ他の &lt;code&gt;Rectangle&lt;/code&gt; の幅と高さより大きいかどうかを確認します。リスト5-15に示すように、リスト5-13の &lt;code&gt;impl&lt;/code&gt; ブロックに新しい &lt;code&gt;can_hold&lt;/code&gt; メソッドを追加しましょう。</target>
        </trans-unit>
        <trans-unit id="09720690261d856f42ba9e119c7bca4126dc617c" translate="yes" xml:space="preserve">
          <source>We leave the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; fields private so there is no way for external code to add or remove items to the &lt;code&gt;list&lt;/code&gt; field directly; otherwise, the &lt;code&gt;average&lt;/code&gt; field might become out of sync when the &lt;code&gt;list&lt;/code&gt; changes. The &lt;code&gt;average&lt;/code&gt; method returns the value in the &lt;code&gt;average&lt;/code&gt; field, allowing external code to read the &lt;code&gt;average&lt;/code&gt; but not modify it.</source>
          <target state="translated">私たちは、去る &lt;code&gt;list&lt;/code&gt; と &lt;code&gt;average&lt;/code&gt; 外部コードがに項目を追加または削除する方法がないので、プライベートなフィールドを &lt;code&gt;list&lt;/code&gt; に直接フィールドは、そうしないと、 &lt;code&gt;list&lt;/code&gt; が変更されたときに &lt;code&gt;average&lt;/code&gt; フィールドが同期しなくなる可能性があります。 &lt;code&gt;average&lt;/code&gt; 方法は、の値を返す &lt;code&gt;average&lt;/code&gt; 外部コードを読み取ることができるように、フィールド &lt;code&gt;average&lt;/code&gt; ではなく、それを修正します。</target>
        </trans-unit>
        <trans-unit id="28901e7633295a79506b9862e703f0c9ec5149e8" translate="yes" xml:space="preserve">
          <source>We left a comment in the &lt;code&gt;for&lt;/code&gt; loop in Listing 20-14 regarding the creation of threads. Here, we&amp;rsquo;ll look at how we actually create threads. The standard library provides &lt;code&gt;thread::spawn&lt;/code&gt; as a way to create threads, and &lt;code&gt;thread::spawn&lt;/code&gt; expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them &lt;em&gt;wait&lt;/em&gt; for code that we&amp;rsquo;ll send later. The standard library&amp;rsquo;s implementation of threads doesn&amp;rsquo;t include any way to do that; we have to implement it manually.</source>
          <target state="translated">スレッドの作成に関して、リスト20-14の &lt;code&gt;for&lt;/code&gt; ループにコメントを残しました。ここでは、実際にスレッドを作成する方法を見ていきます。標準ライブラリは、 &lt;code&gt;thread::spawn&lt;/code&gt; を作成する方法としてthread :: spawnを提供し、 &lt;code&gt;thread::spawn&lt;/code&gt; は、スレッドが作成されるとすぐにスレッドが実行する必要があるコードを取得することを期待しています。ただし、ここでは、スレッドを作成して、後で送信するコードを&lt;em&gt;待つ&lt;/em&gt;ようにします。標準ライブラリのスレッドの実装には、それを行う方法は含まれていません。手動で実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="e917b5faacb8108bac1660ec1b4c362d8a292e12" translate="yes" xml:space="preserve">
          <source>We list the &lt;code&gt;x&lt;/code&gt; value and then just include the &lt;code&gt;..&lt;/code&gt; pattern. This is quicker than having to list &lt;code&gt;y: _&lt;/code&gt; and &lt;code&gt;z: _&lt;/code&gt;, particularly when we&amp;rsquo;re working with structs that have lots of fields in situations where only one or two fields are relevant.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 値をリストしてから、 &lt;code&gt;..&lt;/code&gt; パターンだけを含めます。これは、特に関連するフィールドが1つまたは2つしかない状況で、フィールドが多数ある構造体で作業している場合に、 &lt;code&gt;y: _&lt;/code&gt; および &lt;code&gt;z: _&lt;/code&gt; をリストする必要があるよりも高速です。</target>
        </trans-unit>
        <trans-unit id="1649278ad2d9cbd95d5bb9721993ae2f4d897594" translate="yes" xml:space="preserve">
          <source>We make two threads and change the variable names used with the second thread to &lt;code&gt;handle2&lt;/code&gt; and &lt;code&gt;num2&lt;/code&gt;. When we run the code this time, compiling gives us the following:</source>
          <target state="translated">2つのスレッドを作成し、2番目のスレッドで使用される変数名を &lt;code&gt;handle2&lt;/code&gt; および &lt;code&gt;num2&lt;/code&gt; に変更します。今回コードを実行すると、コンパイルによって次のようになります。</target>
        </trans-unit>
        <trans-unit id="488b1d1d555af27ea61cdda89514b2dfd138dd29" translate="yes" xml:space="preserve">
          <source>We may want to write bytes to a &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; in our production code, but use an in-memory buffer in our tests. We can do this with &lt;code&gt;Cursor&lt;/code&gt;:</source>
          <target state="translated">プロダクションコードでは&lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;にバイトを書き込むことができますが、テストではメモリ内バッファを使用します。 &lt;code&gt;Cursor&lt;/code&gt; でこれを行うことができます：</target>
        </trans-unit>
        <trans-unit id="42f5297aad6a8bcbbe769864f90a8b8abdf120a8" translate="yes" xml:space="preserve">
          <source>We modify &lt;code&gt;a&lt;/code&gt; so it points to &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;Nil&lt;/code&gt;, creating a cycle. We do that by using the &lt;code&gt;tail&lt;/code&gt; method to get a reference to the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;, which we put in the variable &lt;code&gt;link&lt;/code&gt;. Then we use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; to change the value inside from an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;Nil&lt;/code&gt; value to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Nil&lt;/code&gt; 代わりに &lt;code&gt;b&lt;/code&gt; を指すようにaを変更 &lt;code&gt;a&lt;/code&gt; 、サイクルを作成します。私たちは、使用していることを行う &lt;code&gt;tail&lt;/code&gt; への参照を取得する方法を &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; で、我々は変数に入れて、 &lt;code&gt;link&lt;/code&gt; 。その後、我々は使用 &lt;code&gt;borrow_mut&lt;/code&gt; の上の方法 &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; から値の内部を変更する &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 保持 &lt;code&gt;Nil&lt;/code&gt; に値を &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; に &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5a434a5fbccadae9667d94aa729d1d78f20bd90" translate="yes" xml:space="preserve">
          <source>We must call the &lt;code&gt;dangerous&lt;/code&gt; function within a separate &lt;code&gt;unsafe&lt;/code&gt; block. If we try to call &lt;code&gt;dangerous&lt;/code&gt; without the &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;ll get an error:</source>
          <target state="translated">別の &lt;code&gt;unsafe&lt;/code&gt; ブロック内で &lt;code&gt;dangerous&lt;/code&gt; 関数を呼び出す必要があります。 &lt;code&gt;unsafe&lt;/code&gt; ブロックなしで &lt;code&gt;dangerous&lt;/code&gt; を呼び出そうとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="4fb4c5141c4cfa6ea474c70142cc893715e15a85" translate="yes" xml:space="preserve">
          <source>We need a mock object that, instead of sending an email or text message when we call &lt;code&gt;send&lt;/code&gt;, will only keep track of the messages it&amp;rsquo;s told to send. We can create a new instance of the mock object, create a &lt;code&gt;LimitTracker&lt;/code&gt; that uses the mock object, call the &lt;code&gt;set_value&lt;/code&gt; method on &lt;code&gt;LimitTracker&lt;/code&gt;, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&amp;rsquo;t allow it:</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; を呼び出すときに電子メールまたはテキストメッセージを送信するのではなく、送信するように指示されたメッセージのみを追跡するモックオブジェクトが必要です。モックオブジェクトの新しいインスタンスを作成し、モックオブジェクトを使用する &lt;code&gt;LimitTracker&lt;/code&gt; を作成し、LimitTrackerで &lt;code&gt;set_value&lt;/code&gt; メソッドを呼び出して、モックオブジェクトに &lt;code&gt;LimitTracker&lt;/code&gt; たメッセージがあることを確認できます。リスト15-21はそれを行うためにモックオブジェクトを実装する試みを示していますが、ボローチェッカーはそれを許可していません：</target>
        </trans-unit>
        <trans-unit id="7bb260a7277d45c34609007ac1f57ba6424e3b7d" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the operating system when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; を使い終わったら、このメモリをオペレーティングシステムに返す方法が必要です。</target>
        </trans-unit>
        <trans-unit id="20e2cb940baac98dfff4c0ce471d1304226840b2" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;code&gt;use&lt;/code&gt; statement to bring &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into scope because it&amp;rsquo;s not in the prelude. In &lt;code&gt;main&lt;/code&gt;, we create the list holding 5 and 10 and store it in a new &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;. Then when we create &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we call the &lt;code&gt;Rc::clone&lt;/code&gt; function and pass a reference to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as an argument.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; はプレリュードに含まれていないため、スコープに含めるには、 &lt;code&gt;use&lt;/code&gt; ステートメントを追加する必要があります。では &lt;code&gt;main&lt;/code&gt; 、我々は5と10を保持するリストを作成し、新しいに保管 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; に。私たちが作成するときに &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; 、我々は呼んで &lt;code&gt;Rc::clone&lt;/code&gt; 機能をとへの参照渡し &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; に引数として。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20a230dc482759cbcb024d662f9a4b5ff8cb7a21" translate="yes" xml:space="preserve">
          <source>We need to add to the code in Listing 9-3 to take different actions depending on the value &lt;code&gt;File::open&lt;/code&gt; returns. Listing 9-4 shows one way to handle the &lt;code&gt;Result&lt;/code&gt; using a basic tool, the &lt;code&gt;match&lt;/code&gt; expression that we discussed in Chapter 6.</source>
          <target state="translated">リスト9-3のコードに追加して、 &lt;code&gt;File::open&lt;/code&gt; が返す値に応じて異なるアクションを実行する必要があります。リスト9-4は、基本的なツールを使用して &lt;code&gt;Result&lt;/code&gt; を処理する1つの方法を示しています。これは、第6章で説明した &lt;code&gt;match&lt;/code&gt; 式です。</target>
        </trans-unit>
        <trans-unit id="9771dc4bdc41f5521988ffa4bcbf0d3c0f959de9" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-24.</source>
          <target state="translated">リスト20-24で示されるように、タイプ &lt;code&gt;Job&lt;/code&gt; ではなく &lt;code&gt;Message&lt;/code&gt; タイプの値を使用するようにチャンネルを調整する必要があります。</target>
        </trans-unit>
        <trans-unit id="9fe42f06f6df7ac68de2d948fcbea1a3d7286a3b" translate="yes" xml:space="preserve">
          <source>We need to declare the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate as a procedural macro crate. We&amp;rsquo;ll also need functionality from the &lt;code&gt;syn&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; crates, as you&amp;rsquo;ll see in a moment, so we need to add them as dependencies. Add the following to the &lt;em&gt;Cargo.toml&lt;/em&gt; file for &lt;code&gt;hello_macro_derive&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hello_macro_derive&lt;/code&gt; クレートを手続き型マクロクレートとして宣言する必要があります。また、 &lt;code&gt;syn&lt;/code&gt; わかるように、synおよび &lt;code&gt;quote&lt;/code&gt; のクレートの機能も必要になるため、依存関係として追加する必要があります。以下を追加&lt;em&gt;Cargo.tomlの&lt;/em&gt;ためのファイル &lt;code&gt;hello_macro_derive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d463764f5c2df75db583b72e63eacc4531621bf0" translate="yes" xml:space="preserve">
          <source>We need to set &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; temporarily rather than setting it directly with code like &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; to get ownership of the &lt;code&gt;state&lt;/code&gt; value. This ensures &lt;code&gt;Post&lt;/code&gt; can&amp;rsquo;t use the old &lt;code&gt;state&lt;/code&gt; value after we&amp;rsquo;ve transformed it into a new state.</source>
          <target state="translated">&lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; ようなコードで直接設定するのではなく、一時的に &lt;code&gt;state&lt;/code&gt; を &lt;code&gt;None&lt;/code&gt; に設定する必要があります。 &lt;code&gt;state&lt;/code&gt; 値の所有権を取得します。これにより、新しい状態に変換した後、 &lt;code&gt;Post&lt;/code&gt; が古い &lt;code&gt;state&lt;/code&gt; 値を使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="7bc24d658a32bb0bbfec91b13ffff10ee769ddc2" translate="yes" xml:space="preserve">
          <source>We needed &lt;code&gt;clone&lt;/code&gt; here because we have a slice with &lt;code&gt;String&lt;/code&gt; elements in the parameter &lt;code&gt;args&lt;/code&gt;, but the &lt;code&gt;new&lt;/code&gt; function doesn&amp;rsquo;t own &lt;code&gt;args&lt;/code&gt;. To return ownership of a &lt;code&gt;Config&lt;/code&gt; instance, we had to clone the values from the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; fields of &lt;code&gt;Config&lt;/code&gt; so the &lt;code&gt;Config&lt;/code&gt; instance can own its values.</source>
          <target state="translated">パラメータ &lt;code&gt;args&lt;/code&gt; に &lt;code&gt;String&lt;/code&gt; 要素を持つスライスがあるため、ここで &lt;code&gt;clone&lt;/code&gt; 必要でしたが、 &lt;code&gt;new&lt;/code&gt; 関数は &lt;code&gt;args&lt;/code&gt; を所有していません。リターン所有権に &lt;code&gt;Config&lt;/code&gt; インスタンス、我々はから値のクローンを作成しなければならなかった &lt;code&gt;query&lt;/code&gt; と &lt;code&gt;filename&lt;/code&gt; のフィールド &lt;code&gt;Config&lt;/code&gt; よう &lt;code&gt;Config&lt;/code&gt; インスタンスは、その値を所有することができます。</target>
        </trans-unit>
        <trans-unit id="a43e27dbd35abeb15b38b9262e2f49308a9d38c7" translate="yes" xml:space="preserve">
          <source>We now have a straightforward API that&amp;rsquo;s much harder to mess up, because the compiler will ensure the references into the &lt;code&gt;String&lt;/code&gt; remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn&amp;rsquo;t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of &lt;code&gt;first_word&lt;/code&gt; will throw a compile-time error:</source>
          <target state="translated">コンパイラーは &lt;code&gt;String&lt;/code&gt; への参照が有効なままであることを保証するため、ごちゃごちゃするのがはるかに難しい単純なAPIができました。リスト4-8のプログラムのバグを思い出してください。最初の単語の終わりまでインデックスを取得しましたが、文字列をクリアしたため、インデックスが無効でした。そのコードは論理的には正しくありませんが、すぐにエラーが発生することはありませんでした。空の文字列で最初の単語のインデックスを使用し続けた場合、問題は後で発生します。スライスによってこのバグは不可能になり、コードに問題が発生するのが早くなりました。 &lt;code&gt;first_word&lt;/code&gt; のスライスバージョンを使用すると、コンパイル時エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="c7a58a3bc34ccbe75e8ddbc8d069a47ead8d2749" translate="yes" xml:space="preserve">
          <source>We now have a way to find out the index of the end of the first word in the string, but there&amp;rsquo;s a problem. We&amp;rsquo;re returning a &lt;code&gt;usize&lt;/code&gt; on its own, but it&amp;rsquo;s only a meaningful number in the context of the &lt;code&gt;&amp;amp;String&lt;/code&gt;. In other words, because it&amp;rsquo;s a separate value from the &lt;code&gt;String&lt;/code&gt;, there&amp;rsquo;s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the &lt;code&gt;first_word&lt;/code&gt; function from Listing 4-7.</source>
          <target state="translated">これで、文字列の最初の単語の終わりのインデックスを見つける方法ができましたが、問題があります。私たちはそれ自体で &lt;code&gt;usize&lt;/code&gt; を返しますが、これは &lt;code&gt;&amp;amp;String&lt;/code&gt; のコンテキストでは意味のある数字にすぎません。つまり、これは &lt;code&gt;String&lt;/code&gt; とは別の値であるため、将来も有効である保証はありません。リスト4-7の &lt;code&gt;first_word&lt;/code&gt; 関数を使用するリスト4-8のプログラムを考えます。</target>
        </trans-unit>
        <trans-unit id="7c5216021536b3c08541f1af93af0172517e8ef7" translate="yes" xml:space="preserve">
          <source>We now need our &lt;code&gt;Job&lt;/code&gt; type alias to be a &lt;code&gt;Box&lt;/code&gt; of anything that implements our new trait &lt;code&gt;FnBox&lt;/code&gt;. This will allow us to use &lt;code&gt;call_box&lt;/code&gt; in &lt;code&gt;Worker&lt;/code&gt; when we get a &lt;code&gt;Job&lt;/code&gt; value instead of invoking the closure directly. Implementing the &lt;code&gt;FnBox&lt;/code&gt; trait for any &lt;code&gt;FnOnce()&lt;/code&gt; closure means we don&amp;rsquo;t have to change anything about the actual values we&amp;rsquo;re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</source>
          <target state="translated">&lt;code&gt;Job&lt;/code&gt; タイプのエイリアスは、新しいトレイト &lt;code&gt;FnBox&lt;/code&gt; を実装するあらゆるものの &lt;code&gt;Box&lt;/code&gt; である必要があります。これにより、クロージャーを直接呼び出すのではなく、 &lt;code&gt;Job&lt;/code&gt; 値を取得するときに &lt;code&gt;Worker&lt;/code&gt; で &lt;code&gt;call_box&lt;/code&gt; を使用できるようになります。 &lt;code&gt;FnOnce()&lt;/code&gt; クロージャーに &lt;code&gt;FnBox&lt;/code&gt; トレイトを実装するということは、チャネルに送信する実際の値について何も変更する必要がないことを意味します。これで、Rustは、私たちがやりたいことは問題ないことを認識できます。</target>
        </trans-unit>
        <trans-unit id="8583c35b022bb0426f8e6796265e5ae06507a412" translate="yes" xml:space="preserve">
          <source>We pass the value in the &lt;code&gt;case_sensitive&lt;/code&gt; variable to the &lt;code&gt;Config&lt;/code&gt; instance so the &lt;code&gt;run&lt;/code&gt; function can read that value and decide whether to call &lt;code&gt;search&lt;/code&gt; or &lt;code&gt;search_case_insensitive&lt;/code&gt;, as we implemented in Listing 12-22.</source>
          <target state="translated">リスト12-22で実装したように、 &lt;code&gt;case_sensitive&lt;/code&gt; 変数の値を &lt;code&gt;Config&lt;/code&gt; インスタンスに渡し、 &lt;code&gt;run&lt;/code&gt; 関数がその値を読み取り、 &lt;code&gt;search&lt;/code&gt; と &lt;code&gt;search_case_insensitive&lt;/code&gt; のどちらを呼び出すかを決定できるようにします。</target>
        </trans-unit>
        <trans-unit id="278796f5b8837b7d0f28d68d910bc02fc27c0a6a" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;#[should_panic]&lt;/code&gt; attribute after the &lt;code&gt;#[test]&lt;/code&gt; attribute and before the test function it applies to. Let&amp;rsquo;s look at the result when this test passes:</source>
          <target state="translated">我々は置く &lt;code&gt;#[should_panic]&lt;/code&gt; 後に属性を &lt;code&gt;#[test]&lt;/code&gt; 属性と、それが適用されるテスト関数の前に。このテストに合格したときの結果を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="2bba2aa85955f56b33ac81b32d1e3abad3ce51a8" translate="yes" xml:space="preserve">
          <source>We ran a benchmark by loading the entire contents of &lt;em&gt;The Adventures of Sherlock Holmes&lt;/em&gt; by Sir Arthur Conan Doyle into a &lt;code&gt;String&lt;/code&gt; and looking for the word &lt;em&gt;the&lt;/em&gt; in the contents. Here are the results of the benchmark on the version of &lt;code&gt;search&lt;/code&gt; using the &lt;code&gt;for&lt;/code&gt; loop and the version using iterators:</source>
          <target state="translated">私たちは、アーサー・コナン・ドイル卿の&lt;em&gt;「シャーロック・ホームズの冒険」の&lt;/em&gt;コンテンツ全体を &lt;code&gt;String&lt;/code&gt; ロードし、コンテンツ内の単語&lt;em&gt;「&lt;/em&gt; the」を探して、ベンチマークを実行しました。 &lt;code&gt;for&lt;/code&gt; ループを使用した &lt;code&gt;search&lt;/code&gt; のバージョンとイテレータを使用したバージョンのベンチマークの結果は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d90131aacb69308c853c9e012b87bab3eb99486f" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">この定義を次のように読みます。関数 &lt;code&gt;largest&lt;/code&gt; は、いくつかの型 &lt;code&gt;T&lt;/code&gt; に対してジェネリックです。この関数には &lt;code&gt;list&lt;/code&gt; という名前のパラメーターが1つあります。これは、タイプ &lt;code&gt;T&lt;/code&gt; の値のスライスです。 &lt;code&gt;largest&lt;/code&gt; 機能は、同じ型の値を返します &lt;code&gt;T&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="147f34652912dc5e1cde73ec0858d227ac63c740" translate="yes" xml:space="preserve">
          <source>We receive the following error:</source>
          <target state="translated">以下のようなエラーが出ます。</target>
        </trans-unit>
        <trans-unit id="7e8e5c0341d305aaf380fa95376adf0a328c5bce" translate="yes" xml:space="preserve">
          <source>We set the associated &lt;code&gt;Item&lt;/code&gt; type for our iterator to &lt;code&gt;u32&lt;/code&gt;, meaning the iterator will return &lt;code&gt;u32&lt;/code&gt; values. Again, don&amp;rsquo;t worry about associated types yet, we&amp;rsquo;ll cover them in Chapter 19.</source>
          <target state="translated">私たちは、関連する設定 &lt;code&gt;Item&lt;/code&gt; に対する当社のイテレータの型 &lt;code&gt;u32&lt;/code&gt; イテレータが返されますつまり、 &lt;code&gt;u32&lt;/code&gt; 値を。繰り返しになりますが、関連する型についてはまだ心配しないでください。第19章で説明します。</target>
        </trans-unit>
        <trans-unit id="758bab9e4ef6994d52233f0c2648d86ae9d96c9c" translate="yes" xml:space="preserve">
          <source>We set the number of test threads to &lt;code&gt;1&lt;/code&gt;, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won&amp;rsquo;t interfere with each other if they share state.</source>
          <target state="translated">テストスレッドの数を &lt;code&gt;1&lt;/code&gt; に設定し、並列処理を使用しないようにプログラムに指示します。1つのスレッドを使用してテストを実行すると、並行して実行するよりも時間がかかりますが、テストが状態を共有している場合、テストは互いに干渉しません。</target>
        </trans-unit>
        <trans-unit id="2570e3bb2400d24bff6a3167e41e4cf75ad5c3a8" translate="yes" xml:space="preserve">
          <source>We should get lines that contain &amp;ldquo;to&amp;rdquo; that might have uppercase letters:</source>
          <target state="translated">大文字の「to」を含む行を取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="8d210a202bdd118dd9e0c3872fbd6277ea746c27" translate="yes" xml:space="preserve">
          <source>We still enable the creation of new posts in the draft state using &lt;code&gt;Post::new&lt;/code&gt; and the ability to add text to the post&amp;rsquo;s content. But instead of having a &lt;code&gt;content&lt;/code&gt; method on a draft post that returns an empty string, we&amp;rsquo;ll make it so draft posts don&amp;rsquo;t have the &lt;code&gt;content&lt;/code&gt; method at all. That way, if we try to get a draft post&amp;rsquo;s content, we&amp;rsquo;ll get a compiler error telling us the method doesn&amp;rsquo;t exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&amp;rsquo;t even compile. Listing 17-19 shows the definition of a &lt;code&gt;Post&lt;/code&gt; struct and a &lt;code&gt;DraftPost&lt;/code&gt; struct, as well as methods on each:</source>
          <target state="translated">&lt;code&gt;Post::new&lt;/code&gt; を使用してドラフト状態で新しい投稿を作成したり、投稿のコンテンツにテキストを追加したりできます。ただし、空の文字列を返すドラフト投稿に &lt;code&gt;content&lt;/code&gt; メソッドを用意する代わりに、ドラフト投稿に &lt;code&gt;content&lt;/code&gt; メソッドがないようにします。そうすることで、ドラフト投稿のコンテンツを取得しようとすると、メソッドが存在しないことを示すコンパイラエラーが発生します。その結果、コードがコンパイルされないため、本番環境でドラフト投稿コンテンツを誤って表示することは不可能です。リスト17-19は &lt;code&gt;Post&lt;/code&gt; 構造体と &lt;code&gt;DraftPost&lt;/code&gt; 構造体の定義、およびそれぞれのメソッドを示しています：</target>
        </trans-unit>
        <trans-unit id="95a2d58046436515ce7947004a7ac4ae33fbaf9a" translate="yes" xml:space="preserve">
          <source>We still have a &lt;code&gt;Post::new&lt;/code&gt; function, but instead of returning an instance of &lt;code&gt;Post&lt;/code&gt;, it returns an instance of &lt;code&gt;DraftPost&lt;/code&gt;. Because &lt;code&gt;content&lt;/code&gt; is private and there aren&amp;rsquo;t any functions that return &lt;code&gt;Post&lt;/code&gt;, it&amp;rsquo;s not possible to create an instance of &lt;code&gt;Post&lt;/code&gt; right now.</source>
          <target state="translated">我々はまだ持っている &lt;code&gt;Post::new&lt;/code&gt; 機能を、代わりのインスタンスを返すの &lt;code&gt;Post&lt;/code&gt; 、それがのインスタンスを返し &lt;code&gt;DraftPost&lt;/code&gt; を。ので &lt;code&gt;content&lt;/code&gt; プライベートで返す任意の関数がない &lt;code&gt;Post&lt;/code&gt; 、それはのインスタンスを作成することはできません &lt;code&gt;Post&lt;/code&gt; 今。</target>
        </trans-unit>
        <trans-unit id="6a14d4ebb9ad3b731ec935502e9ce7735b1d1739" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and doesn&amp;rsquo;t return a value. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">我々はまだ使用して &lt;code&gt;()&lt;/code&gt; をした後 &lt;code&gt;FnOnce&lt;/code&gt; このため &lt;code&gt;FnOnce&lt;/code&gt; はパラメータを取らず、値を返さない閉鎖を表します。関数定義と同様に、戻り値の型はシグネチャから省略できますが、パラメーターがない場合でも、括弧が必要です。</target>
        </trans-unit>
        <trans-unit id="5137b030849ac96f77436fd6551753ef7e79d43f" translate="yes" xml:space="preserve">
          <source>We talked about strings in Chapter 4, but we&amp;rsquo;ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&amp;rsquo;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you&amp;rsquo;re coming from other programming languages.</source>
          <target state="translated">文字列については第4章で説明しましたが、ここではそれらについてさらに詳しく見ていきます。新しいRustaceansは一般に3つの理由の組み合わせで文字列に行き詰まります。Rustが起こり得るエラーを公開する傾向、文字列は多くのプログラマーが信用するよりも複雑なデータ構造であり、UTF-8です。これらの要素は、他のプログラミング言語を使用している場合は難しいと思われる方法で組み合わされます。</target>
        </trans-unit>
        <trans-unit id="aaadc6667df848db61b7c0773e7ae3fb21446c1d" translate="yes" xml:space="preserve">
          <source>We temporarily print the values of these variables to prove that the code is working as we intend. Let&amp;rsquo;s run this program again with the arguments &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;sample.txt&lt;/code&gt;:</source>
          <target state="translated">これらの変数の値を一時的に出力して、コードが意図したとおりに機能していることを証明します。引数 &lt;code&gt;test&lt;/code&gt; および &lt;code&gt;sample.txt&lt;/code&gt; を使用して、このプログラムを再度実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="e19d7657ac4c2d18fdac154ffac8e272b1fa158c" translate="yes" xml:space="preserve">
          <source>We then call the &lt;code&gt;unwrap&lt;/code&gt; method, which we know will never panic, because we know the methods on &lt;code&gt;Post&lt;/code&gt; ensure that &lt;code&gt;state&lt;/code&gt; will always contain a &lt;code&gt;Some&lt;/code&gt; value when those methods are done. This is one of the cases we talked about in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Cases In Which You Have More Information Than the Compiler&amp;rdquo;&lt;/a&gt; section of Chapter 9 when we know that a &lt;code&gt;None&lt;/code&gt; value is never possible, even though the compiler isn&amp;rsquo;t able to understand that.</source>
          <target state="translated">次に、 &lt;code&gt;unwrap&lt;/code&gt; メソッドを呼び出します。これは決してパニックになることはないためです。なぜなら、 &lt;code&gt;Post&lt;/code&gt; のメソッドは、これらのメソッドが実行されたときに、 &lt;code&gt;state&lt;/code&gt; が常に &lt;code&gt;Some&lt;/code&gt; 値を含むことを保証しているからです。これは、第9章の&lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;「コンパイラーよりも多くの情報があるケース」&lt;/a&gt;セクションで説明したケースの1つで、コンパイラーはそれを理解できなくても、 &lt;code&gt;None&lt;/code&gt; 値は不可能であることを知っています。</target>
        </trans-unit>
        <trans-unit id="90e0dc4d89651b511b21e761c7cecacf78deadb6" translate="yes" xml:space="preserve">
          <source>We then start the macro definition with &lt;code&gt;macro_rules!&lt;/code&gt; and the name of the macro we&amp;rsquo;re defining &lt;em&gt;without&lt;/em&gt; the exclamation mark. The name, in this case &lt;code&gt;vec&lt;/code&gt;, is followed by curly brackets denoting the body of the macro definition.</source>
          <target state="translated">次に、 &lt;code&gt;macro_rules!&lt;/code&gt; マクロ定義を開始します。感嘆符&lt;em&gt;なしで&lt;/em&gt;定義しているマクロの名前。名前（この場合は &lt;code&gt;vec&lt;/code&gt; ）の後には、マクロ定義の本体を示す中括弧が続きます。</target>
        </trans-unit>
        <trans-unit id="3e635cdf83139712ccc1cd2aa803bc947c37a339" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;ThreadPool::new&lt;/code&gt; to create a new thread pool with a configurable number of threads, in this case four. Then, in the &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;pool.execute&lt;/code&gt; has a similar interface as &lt;code&gt;thread::spawn&lt;/code&gt; in that it takes a closure the pool should run for each stream. We need to implement &lt;code&gt;pool.execute&lt;/code&gt; so it takes the closure and gives it to a thread in the pool to run. This code won&amp;rsquo;t yet compile, but we&amp;rsquo;ll try so the compiler can guide us in how to fix it.</source>
          <target state="translated">&lt;code&gt;ThreadPool::new&lt;/code&gt; を使用して、構成可能なスレッド数（この場合は4）で新しいスレッドプールを作成します。次に、 &lt;code&gt;for&lt;/code&gt; ループで、 &lt;code&gt;pool.execute&lt;/code&gt; は &lt;code&gt;thread::spawn&lt;/code&gt; と同様のインターフェイスを持ち、プールごとにストリームを実行するためのクロージャーを取得します。 &lt;code&gt;pool.execute&lt;/code&gt; を実装して、クロージャーを取得し、プール内のスレッドに渡して実行する必要があります。このコードはまだコンパイルできませんが、コンパイラーが修正方法をガイドできるように、試行します。</target>
        </trans-unit>
        <trans-unit id="00a8575d12353b261846fe413a9059471bbbb3a1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;expect&lt;/code&gt; in the same way as &lt;code&gt;unwrap&lt;/code&gt;: to return the file handle or call the &lt;code&gt;panic!&lt;/code&gt; macro. The error message used by &lt;code&gt;expect&lt;/code&gt; in its call to &lt;code&gt;panic!&lt;/code&gt; will be the parameter that we pass to &lt;code&gt;expect&lt;/code&gt;, rather than the default &lt;code&gt;panic!&lt;/code&gt; message that &lt;code&gt;unwrap&lt;/code&gt; uses. Here&amp;rsquo;s what it looks like:</source>
          <target state="translated">&lt;code&gt;unwrap&lt;/code&gt; と同じように &lt;code&gt;expect&lt;/code&gt; を使用します。ファイルハンドルを返すか、 &lt;code&gt;panic!&lt;/code&gt; 呼び出します。大きい。 &lt;code&gt;expect&lt;/code&gt; が &lt;code&gt;panic!&lt;/code&gt; 呼び出しで使用するエラーメッセージ！デフォルトの &lt;code&gt;panic!&lt;/code&gt; ではなく、 &lt;code&gt;expect&lt;/code&gt; に渡すパラメーターになります！ &lt;code&gt;unwrap&lt;/code&gt; が使用するメッセージ。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c78d1a392741412017cb0bee15d7b3bfa39b4f96" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;if let&lt;/code&gt; rather than &lt;code&gt;unwrap_or_else&lt;/code&gt; to check whether &lt;code&gt;run&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt; value and call &lt;code&gt;process::exit(1)&lt;/code&gt; if it does. The &lt;code&gt;run&lt;/code&gt; function doesn&amp;rsquo;t return a value that we want to &lt;code&gt;unwrap&lt;/code&gt; in the same way that &lt;code&gt;Config::new&lt;/code&gt; returns the &lt;code&gt;Config&lt;/code&gt; instance. Because &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; in the success case, we only care about detecting an error, so we don&amp;rsquo;t need &lt;code&gt;unwrap_or_else&lt;/code&gt; to return the unwrapped value because it would only be &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unwrap_or_else&lt;/code&gt; ではなく &lt;code&gt;if let&lt;/code&gt; を使用して、 &lt;code&gt;run&lt;/code&gt; が &lt;code&gt;Err&lt;/code&gt; 値を返すかどうかを確認し、返された場合は &lt;code&gt;process::exit(1)&lt;/code&gt; を呼び出します。 &lt;code&gt;run&lt;/code&gt; 機能は、私たちがしたいことを値を返さない &lt;code&gt;unwrap&lt;/code&gt; と同じように、 &lt;code&gt;Config::new&lt;/code&gt; 戻り &lt;code&gt;Config&lt;/code&gt; インスタンス。そのため &lt;code&gt;run&lt;/code&gt; リターン &lt;code&gt;()&lt;/code&gt; 、我々は必要ありませんので、成功の場合には、我々は唯一、エラーを検出気に &lt;code&gt;unwrap_or_else&lt;/code&gt; それだけになるので開封された値を返すように &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ae4452a21a2f1db6f66b2ae014602087da7436" translate="yes" xml:space="preserve">
          <source>We use structs to add meaning by labeling the data. We can transform the tuple we&amp;rsquo;re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</source>
          <target state="translated">構造体を使用して、データにラベルを付けることで意味を追加します。リスト5-10に示すように、使用しているタプルを、全体の名前とパーツの名前を持つデータ型に変換できます。</target>
        </trans-unit>
        <trans-unit id="588a26e819f938a8daa06969800194e2035e44dd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type when we want to allocate some data on the heap for multiple parts of our program to read and we can&amp;rsquo;t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data&amp;rsquo;s owner, and the normal ownership rules enforced at compile time would take effect.</source>
          <target state="translated">プログラムの複数の部分を読み取るためにヒープにデータを割り当てたい場合、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 型を使用します。コンパイル時にどの部分が最後にデータを使用し終えるかを判断できません。最後に終了する部分がわかっている場合は、その部分をデータの所有者にするだけで、コンパイル時に適用される通常の所有権ルールが有効になります。</target>
        </trans-unit>
        <trans-unit id="52b921b4cc68cbe5aa2d7fc1be85a8c378a377ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first call to &lt;code&gt;enumerate&lt;/code&gt; produces the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="translated">&lt;code&gt;enumerate&lt;/code&gt; メソッドを使用して、イテレータを調整して値を生成し、イテレータ内のその値のインデックスをタプルに配置します。 &lt;code&gt;enumerate&lt;/code&gt; の最初の呼び出しは、タプル &lt;code&gt;(0, 'a')&lt;/code&gt; ます。この値がパターン &lt;code&gt;(index, value)&lt;/code&gt; に一致すると、 &lt;code&gt;index&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; になり、 &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;'a'&lt;/code&gt; になり、出力の最初の行を出力します。</target>
        </trans-unit>
        <trans-unit id="4b7fed23abc00c81e6f42de18b1f4486c96308f2" translate="yes" xml:space="preserve">
          <source>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</source>
          <target state="translated">ここでは、すべてのトークン(単純なNTを含む)の集合を表すためにANYTOKENという略語を使用します。例えば、任意のトークンがマッチャMの後に合法である場合、FOLLOW(M)=ANYTOKENとなります。</target>
        </trans-unit>
        <trans-unit id="e8b8d2725e3d51d9cd1d2d122943d1410209c3b4" translate="yes" xml:space="preserve">
          <source>We used the &lt;code&gt;# Examples&lt;/code&gt; Markdown heading in Listing 14-1 to create a section in the HTML with the title &amp;ldquo;Examples.&amp;rdquo; Here are some other sections that crate authors commonly use in their documentation:</source>
          <target state="translated">私たちは、使用 &lt;code&gt;# Examples&lt;/code&gt; タイトルにHTML内のセクションを作成するには、リスト14-1で値下げ見出しを「例。」以下は、クレート作成者がドキュメントで一般的に使用する他のセクションです。</target>
        </trans-unit>
        <trans-unit id="0ef9cc2887d688cae816e0aff37ad262f04c5243" translate="yes" xml:space="preserve">
          <source>We want &lt;code&gt;Cacher&lt;/code&gt; to manage the struct fields&amp;rsquo; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</source>
          <target state="translated">私たちは望ん &lt;code&gt;Cacher&lt;/code&gt; 、むしろこれらのフィールドはプライベートなので、呼び出し元のコードが潜在的に、直接これらのフィールドの値を変更させるよりも、構造体のフィールドの値を管理します。</target>
        </trans-unit>
        <trans-unit id="343cff43eccaf2ff33fadb37476034c08a669197" translate="yes" xml:space="preserve">
          <source>We want a &lt;code&gt;Node&lt;/code&gt; to own its children, and we want to share that ownership with variables so we can access each &lt;code&gt;Node&lt;/code&gt; in the tree directly. To do this, we define the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; items to be values of type &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt;. We also want to modify which nodes are children of another node, so we have a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;children&lt;/code&gt; around the &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">我々はしたい &lt;code&gt;Node&lt;/code&gt; その子を所有するために、そして私たちは、各アクセスできるように、変数を使用してその所有権を共有したい &lt;code&gt;Node&lt;/code&gt; 直接ツリーに。これを行うには、 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; アイテムを &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 型の値として定義します。また、どのノードが別のノードの子であるかを変更したいので、 &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; 周りの &lt;code&gt;children&lt;/code&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="d0d37e81b31729b213fcdf893a4673b004b8c84e" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 6, &lt;code&gt;next&lt;/code&gt; will return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;, but if &lt;code&gt;count&lt;/code&gt; is 6 or higher, our iterator will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">イテレータで現在の状態に1を追加する必要があるため、最初に1を返すように &lt;code&gt;count&lt;/code&gt; を0に初期化しました。 &lt;code&gt;count&lt;/code&gt; の値が6未満の場合、 &lt;code&gt;next&lt;/code&gt; は &lt;code&gt;Some&lt;/code&gt; でラップされた現在の値を返しますが、 &lt;code&gt;count&lt;/code&gt; が6以上の場合、イテレータは &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="159b06d9b1bc3efbb438075384303e9f9ce5bdb3" translate="yes" xml:space="preserve">
          <source>We want our procedural macro to generate an implementation of our &lt;code&gt;HelloMacro&lt;/code&gt; trait for the type the user annotated, which we can get by using &lt;code&gt;#name&lt;/code&gt;. The trait implementation has one function, &lt;code&gt;hello_macro&lt;/code&gt;, whose body contains the functionality we want to provide: printing &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; and then the name of the annotated type.</source>
          <target state="translated">私たちは、手続きマクロが私たちの実装を生成したい &lt;code&gt;HelloMacro&lt;/code&gt; の我々が使用して取得することができ、ユーザは注釈付きタイプ、のための特性 &lt;code&gt;#name&lt;/code&gt; 。トレイトの実装には1つの関数 &lt;code&gt;hello_macro&lt;/code&gt; があり、その本体には提供する機能が含まれています。印刷 &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; 、注釈付きタイプの名前です。</target>
        </trans-unit>
        <trans-unit id="dcf36cf58e85676915b970d805c54013d2ad222e" translate="yes" xml:space="preserve">
          <source>We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&amp;rsquo;t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a &lt;code&gt;ThreadPool&lt;/code&gt; struct we want to use instead of &lt;code&gt;thread::spawn&lt;/code&gt;.</source>
          <target state="translated">スレッドプールを同様の使い慣れた方法で機能させたいので、スレッドからスレッドプールに切り替えるときに、APIを使用するコードに大きな変更を加える必要はありません。リスト20-12は、 &lt;code&gt;thread::spawn&lt;/code&gt; 代わりに使用したい &lt;code&gt;ThreadPool&lt;/code&gt; 構造体の架空のインターフェースを示しています。</target>
        </trans-unit>
        <trans-unit id="fff17d8c2985947122e61a61d15c1a4da390070a" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;Worker&lt;/code&gt; structs that we just created to fetch code to run from a queue held in the &lt;code&gt;ThreadPool&lt;/code&gt; and send that code to its thread to run.</source>
          <target state="translated">先ほど作成した &lt;code&gt;Worker&lt;/code&gt; 構造体で、 &lt;code&gt;ThreadPool&lt;/code&gt; に保持されているキューから実行するコードをフェッチし、そのコードをそのスレッドに送信して実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="131c3dfcc453a4966e031008be09ae09bde292da" translate="yes" xml:space="preserve">
          <source>We want to add a new &lt;code&gt;search_case_insensitive&lt;/code&gt; function that we&amp;rsquo;ll call when the environment variable is on. We&amp;rsquo;ll continue to follow the TDD process, so the first step is again to write a failing test. We&amp;rsquo;ll add a new test for the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function and rename our old test from &lt;code&gt;one_result&lt;/code&gt; to &lt;code&gt;case_sensitive&lt;/code&gt; to clarify the differences between the two tests, as shown in Listing 12-20.</source>
          <target state="translated">環境変数がオンのときに呼び出す新しい &lt;code&gt;search_case_insensitive&lt;/code&gt; 関数を追加します。引き続きTDDプロセスに従いますので、最初のステップは失敗したテストを作成することです。リスト12-20に示すように、新しい &lt;code&gt;search_case_insensitive&lt;/code&gt; 関数の新しいテストを追加し、古いテストの名前を &lt;code&gt;one_result&lt;/code&gt; から &lt;code&gt;case_sensitive&lt;/code&gt; に変更して、2つのテストの違いを明確にします。</target>
        </trans-unit>
        <trans-unit id="b16d6b885dbd18ae9ca5b7b63f85be38981add63" translate="yes" xml:space="preserve">
          <source>We want to allow the user to create a new draft blog post with &lt;code&gt;Post::new&lt;/code&gt;. Then we want to allow text to be added to the blog post while it&amp;rsquo;s in the draft state. If we try to get the post&amp;rsquo;s content immediately, before approval, nothing should happen because the post is still a draft. We&amp;rsquo;ve added &lt;code&gt;assert_eq!&lt;/code&gt; in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the &lt;code&gt;content&lt;/code&gt; method, but we&amp;rsquo;re not going to write tests for this example.</source>
          <target state="translated">ユーザーが &lt;code&gt;Post::new&lt;/code&gt; を使用して新しいドラフトのブログ投稿を作成できるようにします。次に、下書き状態のブログ投稿にテキストを追加できるようにします。承認の前に投稿のコンテンツをすぐに取得しようとした場合、投稿はまだ下書きであるため、何も起こりません。 &lt;code&gt;assert_eq!&lt;/code&gt; を追加しました！デモ用のコードで。これに対する優れた単体テストは、下書きのブログ投稿が &lt;code&gt;content&lt;/code&gt; メソッドから空の文字列を返すことをアサートすることですが、この例ではテストを記述しません。</target>
        </trans-unit>
        <trans-unit id="7fed3691de8586ef2849a59c359e563892a4dc4c" translate="yes" xml:space="preserve">
          <source>We want to define code in one place in our program, but only &lt;em&gt;execute&lt;/em&gt; that code where we actually need the result. This is a use case for closures!</source>
          <target state="translated">プログラムの1つの場所でコードを定義したいのですが、実際に結果が必要な場所でのみそのコードを&lt;em&gt;実行&lt;/em&gt;します。これはクロージャの使用例です！</target>
        </trans-unit>
        <trans-unit id="d18a25187ad631c5a4e827947adecf2aa147cc32" translate="yes" xml:space="preserve">
          <source>We want to do something with the &lt;code&gt;Some(3)&lt;/code&gt; match but do nothing with any other &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; value or the &lt;code&gt;None&lt;/code&gt; value. To satisfy the &lt;code&gt;match&lt;/code&gt; expression, we have to add &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; after processing just one variant, which is a lot of boilerplate code to add.</source>
          <target state="translated">&lt;code&gt;Some(3)&lt;/code&gt; 一致で何かをしたいが、他の &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; 値または &lt;code&gt;None&lt;/code&gt; 値では何もしません。 &lt;code&gt;match&lt;/code&gt; 式を満たすには、1つのバリアントのみを処理した後に &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; を追加する必要があります。これは、追加する定型コードの多くです。</target>
        </trans-unit>
        <trans-unit id="dc02dbe447e584d5bc7325caffcd6113884e46a0" translate="yes" xml:space="preserve">
          <source>We want to express the constraint that Foo should not outlive &lt;code&gt;'a&lt;/code&gt;, because the data pointed to by &lt;code&gt;T&lt;/code&gt; is only valid for that lifetime. The problem is that there are no actual uses of &lt;code&gt;'a&lt;/code&gt;. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が指すデータはその有効期間のみ有効であるため、Fooが &lt;code&gt;'a&lt;/code&gt; 超えてはならないという制約を表現したいと思います。問題は、 &lt;code&gt;'a&lt;/code&gt; の実際の使用法がないことです。構造体にPhantomDataタイプを追加し、これを使用して、構造体に借りた参照 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 含まれているかのように動作するようコンパイラーに指示することで、これを回避することができます。</target>
        </trans-unit>
        <trans-unit id="20c0f35ebffd6903da931ba226fd712a56dd80d9" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;todo!&lt;/code&gt;:</source>
          <target state="translated">いずれかのタイプに &lt;code&gt;Foo&lt;/code&gt; を実装する必要がありますが、最初に &lt;code&gt;bar()&lt;/code&gt; のみを処理する必要もあります。コードをコンパイルするには、 &lt;code&gt;baz()&lt;/code&gt; を実装する必要があるため、 &lt;code&gt;todo!&lt;/code&gt; を使用できます。：</target>
        </trans-unit>
        <trans-unit id="56425053366a107f9b4c0d5cead1a47581ce32c6" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;unimplemented!&lt;/code&gt;:</source>
          <target state="translated">いずれかのタイプに &lt;code&gt;Foo&lt;/code&gt; を実装する必要がありますが、最初に &lt;code&gt;bar()&lt;/code&gt; のみを処理する必要もあります。コードをコンパイルするには、 &lt;code&gt;baz()&lt;/code&gt; を実装する必要があるため、 &lt;code&gt;unimplemented!&lt;/code&gt; を使用できます！：</target>
        </trans-unit>
        <trans-unit id="2603349a6514abb34f4d8e302a6f486604d53289" translate="yes" xml:space="preserve">
          <source>We want to make a media aggregator library that can display summaries of data that might be stored in a &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt; instance. To do this, we need a summary from each type, and we need to request that summary by calling a &lt;code&gt;summarize&lt;/code&gt; method on an instance. Listing 10-12 shows the definition of a &lt;code&gt;Summary&lt;/code&gt; trait that expresses this behavior.</source>
          <target state="translated">&lt;code&gt;NewsArticle&lt;/code&gt; または &lt;code&gt;Tweet&lt;/code&gt; インスタンスに格納される可能性のあるデータの要約を表示できるメディアアグリゲーターライブラリを作成したいと考えています。これを行うために、我々は、各タイプの概要を必要とし、我々は呼び出すことにより、その要約を要求する必要が &lt;code&gt;summarize&lt;/code&gt; インスタンスのメソッドを。リスト10-12はこの振る舞いを表現する &lt;code&gt;Summary&lt;/code&gt; トレイトの定義を示しています。</target>
        </trans-unit>
        <trans-unit id="ad91bce07f001635901cf680ab9baa3e439ca352" translate="yes" xml:space="preserve">
          <source>We welcome contributions of all kinds.</source>
          <target state="translated">あらゆる種類の投稿を歓迎します。</target>
        </trans-unit>
        <trans-unit id="23a6529743bec69716fd57e6fc32983956eb0107" translate="yes" xml:space="preserve">
          <source>We will tend to use the variable &quot;M&quot; to stand for a matcher, variables &quot;t&quot; and &quot;u&quot; for arbitrary individual tokens, and the variables &quot;tt&quot; and &quot;uu&quot; for arbitrary token trees. (The use of &quot;tt&quot; does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</source>
          <target state="translated">我々は、変数 &quot;M &quot;をマッチャー、変数 &quot;t &quot;と &quot;u &quot;を任意の個々のトークン、変数 &quot;tt &quot;と &quot;uu &quot;を任意のトークンツリーに用いる傾向がある(&quot;tt &quot;の使用は、フラグメント指定子としての役割を追加することで、潜在的な曖昧さを提示しているが、どちらの解釈が意味されるかは文脈から明らかであろう)。</target>
        </trans-unit>
        <trans-unit id="83ee5c69c56907ebdffff8aeb268f380fd8205ee" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can&amp;rsquo;t know and define all the types other programmers might want to create. But we do know that &lt;code&gt;gui&lt;/code&gt; needs to keep track of many values of different types, and it needs to call a &lt;code&gt;draw&lt;/code&gt; method on each of these differently typed values. It doesn&amp;rsquo;t need to know exactly what will happen when we call the &lt;code&gt;draw&lt;/code&gt; method, just that the value will have that method available for us to call.</source>
          <target state="translated">この例では、本格的なGUIライブラリは実装しませんが、ピースがどのように組み合わされるかを示します。ライブラリを作成する時点では、他のプログラマーが作成する可能性のあるすべてのタイプを把握して定義することはできません。しかし、 &lt;code&gt;gui&lt;/code&gt; はさまざまなタイプの多くの値を追跡する必要があり、これらのさまざまなタイプの値ごとに &lt;code&gt;draw&lt;/code&gt; メソッドを呼び出す必要があることは知っています。 &lt;code&gt;draw&lt;/code&gt; メソッドを呼び出したときに何が起こるかを正確に知る必要はありません。値が、そのメソッドを呼び出すために利用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="d21a898dd719bc6dce095fa6d8b7f4dd1c97ae10" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t see any output to the terminal, and &lt;em&gt;output.txt&lt;/em&gt; will contain our results:</source>
          <target state="translated">端末への出力は表示されず、&lt;em&gt;output.txt&lt;/em&gt;に結果が含まれます。</target>
        </trans-unit>
        <trans-unit id="1bcf0abfb9f5d1eb6eceeb8401331a69bbdacdc8" translate="yes" xml:space="preserve">
          <source>We would get this error:</source>
          <target state="translated">このようなエラーが出てしまいます。</target>
        </trans-unit>
        <trans-unit id="5622bdba3c15431adc562635e894da31c4a2b58c" translate="yes" xml:space="preserve">
          <source>We wrap the list &lt;code&gt;a&lt;/code&gt; in an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; so when we create lists &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, they can both refer to &lt;code&gt;a&lt;/code&gt;, which is what we did in Listing 15-18.</source>
          <target state="translated">私たちは、リストラップ &lt;code&gt;a&lt;/code&gt; における &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 、我々はリストの作成時にその &lt;code&gt;b&lt;/code&gt; および &lt;code&gt;c&lt;/code&gt; 、彼らはを参照することができ、両方の私たちは、リスト15-18で何をしたかです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8c8515d512bf806d32faac4f020e79d1b4ea0b5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also briefly introduce closures, iterators, and trait objects, which Chapters &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; and &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; will cover in detail.</source>
          <target state="translated">また、簡単に章閉鎖、イテレータ、および形質オブジェクト、紹介&lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt;と&lt;a href=&quot;ch17-00-oop&quot;&gt;17が&lt;/a&gt;詳細にカバーしますが。</target>
        </trans-unit>
        <trans-unit id="bd0d703fb6da707b1fe1894466f6416db96a6796" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll change the start of the &lt;code&gt;main&lt;/code&gt; function that we had in Listing 12-24 to the code in Listing 13-25. This won&amp;rsquo;t compile until we update &lt;code&gt;Config::new&lt;/code&gt; as well.</source>
          <target state="translated">リスト12-24にある &lt;code&gt;main&lt;/code&gt; 関数の開始をリスト13-25のコードに変更します。これは、 &lt;code&gt;Config::new&lt;/code&gt; も更新するまでコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="d3116613c32b066db53048929e2f72dcbc32c305" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll check for errors and handle them using a technique similar to one we used with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-10, but with a slight difference:</source>
          <target state="translated">エラーをチェックし、リスト12-10の &lt;code&gt;Config::new&lt;/code&gt; で使用したものと同様の手法を使用してエラーを処理しますが、若干の違いがあります。</target>
        </trans-unit>
        <trans-unit id="d62b197067e3536d1071880b59f256af5edc6238" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll come back to &lt;code&gt;panic!&lt;/code&gt; and when we should and should not use &lt;code&gt;panic!&lt;/code&gt; to handle error conditions in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section later in this chapter. Next, we&amp;rsquo;ll look at how to recover from an error using &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">私たちは &lt;code&gt;panic!&lt;/code&gt; 戻ります！そして、 &lt;code&gt;panic!&lt;/code&gt; 使用するべきか、しないべきか！でエラー条件を処理する&lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;「を &lt;code&gt;panic!&lt;/code&gt; または &lt;code&gt;panic!&lt;/code&gt; ないでください！」&lt;/a&gt;この章のセクション以降。次に、 &lt;code&gt;Result&lt;/code&gt; を使用してエラーから回復する方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="7c361948b72916d443c2a8639e53ba761429344f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue to get warnings because we aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; および &lt;code&gt;execute&lt;/code&gt; のパラメーターを使用して何も実行していないため、引き続き警告が表示されます。これらの関数の本体を、希望する動作で実装してみましょう。まず、 &lt;code&gt;new&lt;/code&gt; について考えてみましょう。以前は、負の数のスレッドを含むプールは意味がないため、 &lt;code&gt;size&lt;/code&gt; パラメーターに符号なしの型を選択しました。ただし、スレッドがゼロのプールも意味がありませんが、ゼロは完全に有効な &lt;code&gt;usize&lt;/code&gt; です。 &lt;code&gt;ThreadPool&lt;/code&gt; インスタンスを返す前に &lt;code&gt;size&lt;/code&gt; がゼロより大きいことを確認するコードを追加し、 &lt;code&gt;assert!&lt;/code&gt; を使用してプログラムがゼロを受信するとパニックが発生します。リスト20-13で示されるように、マクロ。</target>
        </trans-unit>
        <trans-unit id="51ae0f2c48f47ac8366f3fdf37d10c87f351ab8e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a new &lt;code&gt;Job&lt;/code&gt; struct that will hold the closures we want to send down the channel.</source>
          <target state="translated">チャネルに送信するクロージャーを保持する新しい &lt;code&gt;Job&lt;/code&gt; 構造体を作成します。</target>
        </trans-unit>
        <trans-unit id="4bb83dcab86b4aa0381b060ab157833722eb2537" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create list &lt;code&gt;a&lt;/code&gt; that contains 5 and then 10. Then we&amp;rsquo;ll make two more lists: &lt;code&gt;b&lt;/code&gt; that starts with 3 and &lt;code&gt;c&lt;/code&gt; that starts with 4. Both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; lists will then continue on to the first &lt;code&gt;a&lt;/code&gt; list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</source>
          <target state="translated">私たちは、リスト作成します &lt;code&gt;a&lt;/code&gt; 5が含まれ、その後、10その後、我々は2つのリストを作ります： &lt;code&gt;b&lt;/code&gt; 3として開始すること &lt;code&gt;c&lt;/code&gt; 4両で始まること &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; リストは、最初に進みます5を含むリスト言い換えれば、両方のリストは、5と10を含む最初のリストを共有します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa20d8056fa921c697f37302e71e0fe1ecb7bea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll define the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; to take a closure as a parameter. Recall from the &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;Storing Closures Using Generic Parameters and the &lt;code&gt;Fn&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 13 that we can take closures as parameters with three different traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;. We need to decide which kind of closure to use here. We know we&amp;rsquo;ll end up doing something similar to the standard library &lt;code&gt;thread::spawn&lt;/code&gt; implementation, so we can look at what bounds the signature of &lt;code&gt;thread::spawn&lt;/code&gt; has on its parameter. The documentation shows us the following:</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; の &lt;code&gt;execute&lt;/code&gt; メソッドを定義して、クロージャーをパラメーターとして受け取ります。リコール&lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;「一般的なパラメータと使用の保存クロージャ&lt;/a&gt; &lt;code&gt;Fn&lt;/code&gt; 形質」：私たちは、3つの異なる特性を持つパラメータとしてクロージャを取ることができることを第13章でセクション &lt;code&gt;Fn&lt;/code&gt; 、 &lt;code&gt;FnMut&lt;/code&gt; 、および &lt;code&gt;FnOnce&lt;/code&gt; を。ここで使用するクロージャの種類を決定する必要があります。最終的に標準ライブラリの &lt;code&gt;thread::spawn&lt;/code&gt; 実装と同様の処理を行うことになるので、 &lt;code&gt;thread::spawn&lt;/code&gt; シグネチャがパラメーターにどのような境界を持っているかを確認できます。ドキュメントには次のことが示されています。</target>
        </trans-unit>
        <trans-unit id="a2fdbbe18f87451459f008e457c7a300c4999cac" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate the first situation in the &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;Enabling Recursive Types with Boxes&amp;rdquo;&lt;/a&gt; section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a &lt;em&gt;trait object&lt;/em&gt;, and Chapter 17 devotes an entire section, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types,&amp;rdquo;&lt;/a&gt; just to that topic. So what you learn here you&amp;rsquo;ll apply again in Chapter 17!</source>
          <target state="translated">最初の状況については、&lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;「ボックスを使用した再帰型の有効化」&lt;/a&gt;セクションで説明します。 2番目のケースでは、データがスタック上でコピーされるため、大量のデータの所有権を転送するには長い時間がかかる可能性があります。この状況でのパフォーマンスを向上させるために、ヒープ上の大量のデータをボックスに格納できます。次に、少量のポインターデータのみがスタック上でコピーされますが、参照するデータはヒープ上の1か所にとどまります。 3番目のケースは&lt;em&gt;traitオブジェクト&lt;/em&gt;と呼ばれ、第17章では&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;、&lt;/a&gt;そのトピックについてのみ「さまざまなタイプの値を許可する特性オブジェクトの使用」のセクション全体を取り上げています。ここで学んだことは、第17章で再度適用します。</target>
        </trans-unit>
        <trans-unit id="deceb660af9d289cbab49d701f06e3ffa29f7fd4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.</source>
          <target state="translated">ベクター、文字列、ハッシュマップを作成および更新する方法と、それぞれの特徴を説明します。</target>
        </trans-unit>
        <trans-unit id="8ac89a220719114fba008017ccc516ce2a635466" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss iterators in more detail in Chapter 13. For now, know that &lt;code&gt;iter&lt;/code&gt; is a method that returns each element in a collection and that &lt;code&gt;enumerate&lt;/code&gt; wraps the result of &lt;code&gt;iter&lt;/code&gt; and returns each element as part of a tuple instead. The first element of the tuple returned from &lt;code&gt;enumerate&lt;/code&gt; is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.</source>
          <target state="translated">イテレータについては第13章で詳しく説明します。 &lt;code&gt;iter&lt;/code&gt; 、iterはコレクション内の各要素を返すメソッドであり、 &lt;code&gt;enumerate&lt;/code&gt; は &lt;code&gt;iter&lt;/code&gt; の結果をラップして、代わりに各要素をタプルの一部として返すことを理解してください。 &lt;code&gt;enumerate&lt;/code&gt; から返されるタプルの最初の要素はインデックスで、2番目の要素は要素への参照です。これは、自分でインデックスを計算するよりも少し便利です。</target>
        </trans-unit>
        <trans-unit id="624f79a35ccc7ff9109a384a1f2001d1a19900e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore some aspects of how tests work by experimenting with the template test generated for us without actually testing any code. Then we&amp;rsquo;ll write some real-world tests that call some code that we&amp;rsquo;ve written and assert that its behavior is correct.</source>
          <target state="translated">実際にコードをテストせずに、生成されたテンプレートテストを試して、テストがどのように機能するかをいくつか見ていきます。次に、作成したコードを呼び出す実際のテストをいくつか記述し、その動作が正しいことをアサートします。</target>
        </trans-unit>
        <trans-unit id="2bdd67fc360b4185f7483b213b4f01b862aebe2c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll extract the functionality for parsing arguments into a function that &lt;code&gt;main&lt;/code&gt; will call to prepare for moving the command line parsing logic to &lt;em&gt;src/lib.rs&lt;/em&gt;. Listing 12-5 shows the new start of &lt;code&gt;main&lt;/code&gt; that calls a new function &lt;code&gt;parse_config&lt;/code&gt;, which we&amp;rsquo;ll define in &lt;em&gt;src/main.rs&lt;/em&gt; for the moment.</source>
          <target state="translated">コマンドライン解析ロジックを&lt;em&gt;src / lib.rsに&lt;/em&gt;移動する準備をするために &lt;code&gt;main&lt;/code&gt; が呼び出す関数に引数を解析する機能を抽出します。リスト12-5は、今のところ&lt;em&gt;src / main.rs&lt;/em&gt;で定義する新しい関数 &lt;code&gt;parse_config&lt;/code&gt; を呼び出す &lt;code&gt;main&lt;/code&gt; の新しい開始を示しています。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e88c3b3a979bcfce4b1760b46e6bdec4b2d5837b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first define what we mean by the term &lt;em&gt;string&lt;/em&gt;. Rust has only one string type in the core language, which is the string slice &lt;code&gt;str&lt;/code&gt; that is usually seen in its borrowed form &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Chapter 4, we talked about &lt;em&gt;string slices&lt;/em&gt;, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program&amp;rsquo;s binary and are therefore string slices.</source>
          <target state="translated">まず、&lt;em&gt;文字列&lt;/em&gt;という用語の意味を定義し&lt;em&gt;ます&lt;/em&gt;。Rustは、コア言語で文字列型を1つだけ持っています。これは、通常、借用形式 &lt;code&gt;&amp;amp;str&lt;/code&gt; で見られる文字列スライス &lt;code&gt;str&lt;/code&gt; です。第4章では、&lt;em&gt;文字列スライス&lt;/em&gt;について説明しました。これは、他の場所に格納されている一部のUTF-8エンコードされた文字列データへの参照です。たとえば、文字列リテラルはプログラムのバイナリに格納されるため、文字列スライスです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0a42ef337f81f469e74c07a4e57681998929bd2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll get this error because &lt;code&gt;String&lt;/code&gt; doesn&amp;rsquo;t implement the &lt;code&gt;Draw&lt;/code&gt; trait:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; は &lt;code&gt;Draw&lt;/code&gt; トレイトを実装していないため、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d5a20f154a16497d1d3eb9e39d468647563e6985" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; by the standard library. As always, check the standard library documentation for more information.</source>
          <target state="translated">このセクションでは、ハッシュマップの基本的なAPIについて説明しますが、標準ライブラリによって &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 定義された関数には、さらに多くの便利な機能が隠されています。いつものように、詳細については標準ライブラリのドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="eac18c8869068094c6cd67d1df8b09a6dcd85f58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll have more examples of &lt;code&gt;move&lt;/code&gt; closures in Chapter 16 when we talk about concurrency. For now, here&amp;rsquo;s the code from Listing 13-12 with the &lt;code&gt;move&lt;/code&gt; keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</source>
          <target state="translated">同時実行性について説明するときに、第16章で &lt;code&gt;move&lt;/code&gt; クロージャーの例をさらに紹介します。とりあえず、ここではリスト13-12のコードに &lt;code&gt;move&lt;/code&gt; キーワードをクロージャ定義に追加し、整数の代わりにベクトルを使用しています。整数は移動ではなくコピーできるためです。このコードはまだコンパイルされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="45660693e231ee73bb1364738b13ef0ef0f19408" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a blog post workflow in an incremental way. The blog&amp;rsquo;s final functionality will look like this:</source>
          <target state="translated">ブログ投稿ワークフローを段階的に実装します。ブログの最終的な機能は次のようになります。</target>
        </trans-unit>
        <trans-unit id="13ede53dc0201795dcdc26b0b93f397bb66c964d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a classic beginner programming problem: a guessing game. Here&amp;rsquo;s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</source>
          <target state="translated">私たちは古典的な初心者プログラミング問題、推測ゲームを実装します。動作方法は次のとおりです。プログラムは1から100までのランダムな整数を生成します。次に、推測を入力するようプレーヤーに要求します。推測が入力された後、プログラムは推測が低すぎるか高すぎるかを示します。推測が正しい場合、ゲームはお祝いメッセージを出力して終了します。</target>
        </trans-unit>
        <trans-unit id="048db9a1a62206761ce5925145fa53461a07bbf2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement this behavior by introducing a new data structure between the &lt;code&gt;ThreadPool&lt;/code&gt; and the threads that will manage this new behavior. We&amp;rsquo;ll call this data structure &lt;code&gt;Worker&lt;/code&gt;, which is a common term in pooling implementations. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&amp;rsquo;re responsible for taking those orders and filling them.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; とこの新しい動作を管理するスレッドの間に新しいデータ構造を導入することにより、この動作を実装します。このデータ構造を &lt;code&gt;Worker&lt;/code&gt; と呼びます。これは、実装のプーリングにおける一般的な用語です。レストランのキッチンで働いている人々について考えてみてください。労働者は注文が顧客から届くまで待ってから、注文を受けてそれを埋める責任があります。</target>
        </trans-unit>
        <trans-unit id="3d83967911dd3c9768c9078b0f1f0230b11c5179" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</source>
          <target state="translated">&lt;code&gt;minigrep&lt;/code&gt; を改善するために、機能を追加します。ユーザーが環境変数を使用してオンにできる、大文字と小文字を区別しない検索のオプションです。この機能をコマンドラインオプションにして、適用するたびにユーザーに入力を要求することもできますが、代わりに環境変数を使用します。そうすることで、ユーザーは環境変数を一度設定して、そのターミナルセッションですべての検索で大文字と小文字を区別しないようにできます。</target>
        </trans-unit>
        <trans-unit id="d68f5d386409006cd90ddd8d3bb0c58cf3c62419" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll leave the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; as is, returning an empty string slice. We can now have a &lt;code&gt;Post&lt;/code&gt; in the &lt;code&gt;PendingReview&lt;/code&gt; state as well as in the &lt;code&gt;Draft&lt;/code&gt; state, but we want the same behavior in the &lt;code&gt;PendingReview&lt;/code&gt; state. Listing 17-11 now works up to line 10!</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; メソッドは &lt;code&gt;Post&lt;/code&gt; のままにしておき、空の文字列スライスを返します。私たちは、今持っていることができます &lt;code&gt;Post&lt;/code&gt; に &lt;code&gt;PendingReview&lt;/code&gt; の状態などで &lt;code&gt;Draft&lt;/code&gt; 状態が、我々は中に同じ動作たい &lt;code&gt;PendingReview&lt;/code&gt; の状態を。リスト17-11は10行目まで機能します。</target>
        </trans-unit>
        <trans-unit id="d54b9a4076624177fb35b9a3dd76036387ec23ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&amp;rsquo;s resources and grinding the processing of requests to a halt.</source>
          <target state="translated">サービス拒否（DoS）攻撃から保護するために、プール内のスレッドの数を少ない数に制限します。プログラムが要求ごとに新しいスレッドを作成するようにした場合、サーバーに1000万の要求を行う誰かが、サーバーのすべてのリソースを使い果たし、要求の処理を停止して停止する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c71f00103a62f0c5845aebe33e418eb38eb04404" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to &lt;em&gt;/sleep&lt;/em&gt; with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</source>
          <target state="translated">処理が遅いリクエストが、現在のサーバー実装に対して行われた他のリクエストにどのように影響するかを見ていきます。リスト20-10 は、サーバーが応答する前に5秒間スリープするシミュレートされた遅い応答で&lt;em&gt;/ sleep&lt;/em&gt;へのリクエストを処理する実装です。</target>
        </trans-unit>
        <trans-unit id="63d0e1907454ce3a168d379fb233f059e45940b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll receive an error because the &lt;code&gt;s&lt;/code&gt; value will still be moved into &lt;code&gt;_s&lt;/code&gt;, which prevents us from using &lt;code&gt;s&lt;/code&gt; again. However, using the underscore by itself doesn&amp;rsquo;t ever bind to the value. Listing 18-22 will compile without any errors because &lt;code&gt;s&lt;/code&gt; doesn&amp;rsquo;t get moved into &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; の値が &lt;code&gt;_s&lt;/code&gt; に移動され、再び &lt;code&gt;s&lt;/code&gt; を使用できないため、エラーが発生します。ただし、アンダースコアを単独で使用しても、値にバインドされることはありません。リスト18-22は &lt;code&gt;s&lt;/code&gt; が &lt;code&gt;_&lt;/code&gt; に移動しないため、エラーなしでコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="61f9110a68d84478cf97fc80e4e62fe2b389965b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll round out this chapter by talking about the &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits and how we can use them with custom types.</source>
          <target state="translated">私たちは話してことで、この章を締めくくります &lt;code&gt;Send&lt;/code&gt; と &lt;code&gt;Sync&lt;/code&gt; 特性とどのように我々はカスタムタイプでそれらを使用することができます。</target>
        </trans-unit>
        <trans-unit id="b07b0f8b9fff1c6b7489d1f03bbaf11c53f92f25" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&amp;rsquo;ll encode the states into different types. Consequently, Rust&amp;rsquo;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</source>
          <target state="translated">状態パターンを再考して、さまざまなトレードオフのセットを取得する方法を示します。状態と遷移を完全にカプセル化して外部コードがそれらを認識しないようにするのではなく、状態をさまざまなタイプにエンコードします。その結果、Rustの型チェックシステムは、コンパイラエラーを発行して、公開された投稿のみが許可されているドラフト投稿を使用する試みを防ぎます。</target>
        </trans-unit>
        <trans-unit id="627b700f2567a428c4b498681919e2e69479fc97" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll simulate calling this hypothetical algorithm with the function &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; shown in Listing 13-1, which will print &lt;code&gt;calculating slowly...&lt;/code&gt;, wait for two seconds, and then return whatever number we passed in.</source>
          <target state="translated">リスト13-1に示す関数 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 使用してこの仮想アルゴリズムの呼び出しをシミュレートします。これにより、 &lt;code&gt;calculating slowly...&lt;/code&gt; 、2秒待ってから、渡された数値を返します。</target>
        </trans-unit>
        <trans-unit id="5973b041f6a9740c7e6d85ca07367dbed50852e0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by getting a single-threaded web server working. Before we begin, let&amp;rsquo;s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</source>
          <target state="translated">まず、シングルスレッドのWebサーバーを機能させることから始めます。始める前に、Webサーバーの構築に関連するプロトコルの概要を見てみましょう。これらのプロトコルの詳細はこの本の範囲を超えていますが、簡単な概要で必要な情報を提供します。</target>
        </trans-unit>
        <trans-unit id="060170101757c33938356030dc05849b3282e228" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about each of these in turn, but first, let&amp;rsquo;s look at why we even need macros when we already have functions.</source>
          <target state="translated">これらのそれぞれについて順番に説明しますが、最初に、すでに関数があるのになぜマクロが必要なのかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="00042b704a4af242dc3eb83d8f9f0adbd9c9c6f2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We&amp;rsquo;ll add this functionality in a function called &lt;code&gt;search&lt;/code&gt;.</source>
          <target state="translated">ファイルのコンテンツでクエリ文字列を実際に検索する機能の実装をテストし、クエリに一致する行のリストを生成します。この機能を &lt;code&gt;search&lt;/code&gt; という関数に追加します。</target>
        </trans-unit>
        <trans-unit id="a6a5b07486e18e4aafc4b7efa3b6df52895ecfa1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">ここでは例として &lt;code&gt;String&lt;/code&gt; を使用し、所有権に関連する &lt;code&gt;String&lt;/code&gt; の部分に集中します。これらの側面は、標準ライブラリによって提供され、作成する他の複雑なデータ型にも適用されます。 &lt;code&gt;String&lt;/code&gt; については、第8章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="6fdb67ce55cd6e4b067c62180346b3dbc3180259" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, &lt;code&gt;main&lt;/code&gt;. The standard library provides the &lt;code&gt;eprintln!&lt;/code&gt; macro that prints to the standard error stream, so let&amp;rsquo;s change the two places we were calling &lt;code&gt;println!&lt;/code&gt; to print errors to use &lt;code&gt;eprintln!&lt;/code&gt; instead.</source>
          <target state="translated">リスト12-24のコードを使用して、エラーメッセージの出力方法を変更します。この章の前半で行ったリファクタリングのため、エラーメッセージを出力するすべてのコードは1つの関数 &lt;code&gt;main&lt;/code&gt; に含まれています。標準ライブラリは &lt;code&gt;eprintln!&lt;/code&gt; 提供します！標準エラーストリームに出力するマクロなので、 &lt;code&gt;println!&lt;/code&gt; と呼んでいた2つの場所を変更しましょう。エラーを印刷して &lt;code&gt;eprintln!&lt;/code&gt; を使用します！代わりに。</target>
        </trans-unit>
        <trans-unit id="7be7c248999b3ea861a86839bb6847251beded8a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re allowed to change the value that &lt;code&gt;x&lt;/code&gt; binds to from &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; when &lt;code&gt;mut&lt;/code&gt; is used. In some cases, you&amp;rsquo;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; が使用されている場合、 &lt;code&gt;x&lt;/code&gt; がバインドする値を &lt;code&gt;5&lt;/code&gt; から &lt;code&gt;6&lt;/code&gt; に変更できます。場合によっては、変数を変更可能にする必要があります。これにより、コードが不変変数のみの場合よりもコードの記述が便利になります。</target>
        </trans-unit>
        <trans-unit id="85a800cd9f89b371e568b4c783baa80e895e6025" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re creating an &lt;code&gt;IpAddr&lt;/code&gt; instance by parsing a hardcoded string. We can see that &lt;code&gt;127.0.0.1&lt;/code&gt; is a valid IP address, so it&amp;rsquo;s acceptable to use &lt;code&gt;unwrap&lt;/code&gt; here. However, having a hardcoded, valid string doesn&amp;rsquo;t change the return type of the &lt;code&gt;parse&lt;/code&gt; method: we still get a &lt;code&gt;Result&lt;/code&gt; value, and the compiler will still make us handle the &lt;code&gt;Result&lt;/code&gt; as if the &lt;code&gt;Err&lt;/code&gt; variant is a possibility because the compiler isn&amp;rsquo;t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore &lt;em&gt;did&lt;/em&gt; have a possibility of failure, we&amp;rsquo;d definitely want to handle the &lt;code&gt;Result&lt;/code&gt; in a more robust way instead.</source>
          <target state="translated">ハードコードされた文字列を解析して、 &lt;code&gt;IpAddr&lt;/code&gt; インスタンスを作成しています。 &lt;code&gt;127.0.0.1&lt;/code&gt; が有効なIPアドレスであることを確認できるため、ここで &lt;code&gt;unwrap&lt;/code&gt; を使用しても問題ありません。ただし、ハードコードされた有効な文字列を使用しても、 &lt;code&gt;parse&lt;/code&gt; メソッドの戻り値の型は変更されません。 &lt;code&gt;Result&lt;/code&gt; 値は引き続き取得され、コンパイラーは &lt;code&gt;Result&lt;/code&gt; が &lt;code&gt;Err&lt;/code&gt; バリアントの可能性があるかのように処理します。この文字列が常に有効なIPアドレスであることを確認するのに十分賢い。 IPアドレスの文字列ではなくプログラムにハードコードされているよりも、ユーザーから来たので、場合&lt;em&gt;でし&lt;/em&gt;故障の可能性を持って、我々は間違いなく処理したいと思います &lt;code&gt;Result&lt;/code&gt; の代わりに、より堅牢な方法で。</target>
        </trans-unit>
        <trans-unit id="7a98461520cf94e325231f61b61fe6b7361a4963" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re getting into more complex programs in which operations can fail, so, it&amp;rsquo;s a perfect time to discuss error handling. We&amp;rsquo;ll do that next!</source>
          <target state="translated">操作が失敗する可能性のある、より複雑なプログラムに入っているので、エラー処理について説明する絶好の機会です。次にやります！</target>
        </trans-unit>
        <trans-unit id="1bec095d3bfed69e34b314dbfade082c4c12b16b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re not quite done with this line of code. Although what we&amp;rsquo;ve discussed so far is a single line of text, it&amp;rsquo;s only the first part of the single logical line of code. The second part is this method:</source>
          <target state="translated">このコード行はまだ完全ではありません。これまで説明してきたのは1行のテキストですが、これは1行の論理的なコードの最初の部分にすぎません。2番目の部分はこのメソッドです。</target>
        </trans-unit>
        <trans-unit id="e8fdc745ba3517693a4cefb98c523891480464ad" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re now iterating over the workers twice: once to send one &lt;code&gt;Terminate&lt;/code&gt; message for each worker and once to call &lt;code&gt;join&lt;/code&gt; on each worker&amp;rsquo;s thread. If we tried to send a message and &lt;code&gt;join&lt;/code&gt; immediately in the same loop, we couldn&amp;rsquo;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</source>
          <target state="translated">現在、ワーカーを2回繰り返しています。1回は各ワーカーに1つの &lt;code&gt;Terminate&lt;/code&gt; メッセージを送信するためのもので、1回は各ワーカーのスレッドで &lt;code&gt;join&lt;/code&gt; を呼び出すためのものです。メッセージを送信してすぐに同じループに &lt;code&gt;join&lt;/code&gt; しようとした場合、現在のイテレーションのワーカーがチャネルからメッセージを取得するワーカーであることを保証できません。</target>
        </trans-unit>
        <trans-unit id="3043bedf342450c930adba158d22a65820a93654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the &lt;code&gt;baby_name&lt;/code&gt; method from the &lt;code&gt;Animal&lt;/code&gt; trait as implemented on &lt;code&gt;Dog&lt;/code&gt; by saying that we want to treat the &lt;code&gt;Dog&lt;/code&gt; type as an &lt;code&gt;Animal&lt;/code&gt; for this function call. This code will now print what we want:</source>
          <target state="translated">山かっこ内の型注釈をRustに提供しています。これは、この関数呼び出しでは &lt;code&gt;Dog&lt;/code&gt; タイプを &lt;code&gt;Animal&lt;/code&gt; として扱いたいということで、 &lt;code&gt;Dog&lt;/code&gt; に実装されている &lt;code&gt;Animal&lt;/code&gt; トレイトから &lt;code&gt;baby_name&lt;/code&gt; メソッドを呼び出すことを示しています。このコードは、必要なものを出力します。</target>
        </trans-unit>
        <trans-unit id="4ddf3a6c4a7ff9bc3976c2dddb0193cf3c8094f5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re receiving only warnings now, which means it compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="translated">現在、警告のみが表示されています。つまり、コンパイルされます。ただし、 &lt;code&gt;cargo run&lt;/code&gt; を実行してブラウザでリクエストを行うと、この章の冒頭で見たエラーがブラウザに表示されることに注意してください。私たちのライブラリは、 &lt;code&gt;execute&lt;/code&gt; 渡されたクロージャを実際に呼び出していません！</target>
        </trans-unit>
        <trans-unit id="39e24358659ae04dcbe82e2100b6975e897d6a38" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable &lt;code&gt;query&lt;/code&gt; and the argument value at index 2 to the variable &lt;code&gt;filename&lt;/code&gt; within the &lt;code&gt;main&lt;/code&gt; function, we pass the whole vector to the &lt;code&gt;parse_config&lt;/code&gt; function. The &lt;code&gt;parse_config&lt;/code&gt; function then holds the logic that determines which argument goes in which variable and passes the values back to &lt;code&gt;main&lt;/code&gt;. We still create the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables in &lt;code&gt;main&lt;/code&gt;, but &lt;code&gt;main&lt;/code&gt; no longer has the responsibility of determining how the command line arguments and variables correspond.</source>
          <target state="translated">コマンドライン引数をベクトルに収集していますが、インデックス1の引数値を変数 &lt;code&gt;query&lt;/code&gt; に割り当て、インデックス2の引数値を &lt;code&gt;main&lt;/code&gt; 関数内の変数 &lt;code&gt;filename&lt;/code&gt; に割り当てる代わりに、ベクトル全体を &lt;code&gt;parse_config&lt;/code&gt; 関数。次に、 &lt;code&gt;parse_config&lt;/code&gt; 関数は、どの引数がどの変数に入り、値を &lt;code&gt;main&lt;/code&gt; に戻すかを決定するロジックを保持します。 &lt;code&gt;query&lt;/code&gt; 変数と &lt;code&gt;filename&lt;/code&gt; 変数はまだ &lt;code&gt;main&lt;/code&gt; で作成していますが、 &lt;code&gt;main&lt;/code&gt; コマンドラインの引数と変数がどのように対応するかを決定する責任がなくなりました。</target>
        </trans-unit>
        <trans-unit id="6a2a09503d50f0f83deb42b9b3c8d235d3d20cd7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still using a &lt;code&gt;for&lt;/code&gt; loop to return each line from &lt;code&gt;search&lt;/code&gt; and print it.</source>
          <target state="translated">まだ &lt;code&gt;for&lt;/code&gt; ループを使用して、 &lt;code&gt;search&lt;/code&gt; から各行を返し、出力しています。</target>
        </trans-unit>
        <trans-unit id="c5dc7c10dc508f133971e52b437dcfabc8c9d8d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using another variation of the &lt;code&gt;List&lt;/code&gt; definition from Listing 15-5. The second element in the &lt;code&gt;Cons&lt;/code&gt; variant is now &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt;, meaning that instead of having the ability to modify the &lt;code&gt;i32&lt;/code&gt; value as we did in Listing 15-24, we want to modify which &lt;code&gt;List&lt;/code&gt; value a &lt;code&gt;Cons&lt;/code&gt; variant is pointing to. We&amp;rsquo;re also adding a &lt;code&gt;tail&lt;/code&gt; method to make it convenient for us to access the second item if we have a &lt;code&gt;Cons&lt;/code&gt; variant.</source>
          <target state="translated">リスト15-5の &lt;code&gt;List&lt;/code&gt; 定義の別のバリエーションを使用しています。 &lt;code&gt;Cons&lt;/code&gt; バリアントの2番目の要素は &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; になりました。つまり、リスト15-24で行ったように &lt;code&gt;i32&lt;/code&gt; 値を変更する代わりに、 &lt;code&gt;Cons&lt;/code&gt; バリアントが指している &lt;code&gt;List&lt;/code&gt; 値を変更します。に。また、 &lt;code&gt;Cons&lt;/code&gt; バリアントがある場合に2番目の項目にアクセスしやすくするために、 &lt;code&gt;tail&lt;/code&gt; メソッドを追加しています。</target>
        </trans-unit>
        <trans-unit id="e0c173af0bd25448bf48e4ff0f52351084a37793" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using the &lt;code&gt;is_err&lt;/code&gt; method on the &lt;code&gt;Result&lt;/code&gt; to check whether it&amp;rsquo;s an error and therefore unset, which means it &lt;em&gt;should&lt;/em&gt; do a case-sensitive search. If the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable is set to anything, &lt;code&gt;is_err&lt;/code&gt; will return false and the program will perform a case-insensitive search. We don&amp;rsquo;t care about the &lt;em&gt;value&lt;/em&gt; of the environment variable, just whether it&amp;rsquo;s set or unset, so we&amp;rsquo;re checking &lt;code&gt;is_err&lt;/code&gt; rather than using &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, or any of the other methods we&amp;rsquo;ve seen on &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; で &lt;code&gt;is_err&lt;/code&gt; メソッドを使用して、それがエラーであり、したがって設定されていないかどうかを確認しています。つまり、大文字と小文字を区別した検索を実行する&lt;em&gt;必要&lt;/em&gt;があります。場合 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; の環境変数が何に設定されている、 &lt;code&gt;is_err&lt;/code&gt; は falseを返し、プログラムは大文字と小文字を区別しない検索を実行します。私たちは気にしない&lt;em&gt;値&lt;/em&gt;、我々がチェックしているので、ちょうどそれのセットまたは設定解除するかどうか、環境変数の &lt;code&gt;is_err&lt;/code&gt; ではなく、使用して &lt;code&gt;unwrap&lt;/code&gt; 、 &lt;code&gt;expect&lt;/code&gt; 、あるいは我々が上で見てきた他の方法のいずれかの &lt;code&gt;Result&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d56b97467af5db84c05cb413a5fabde32de08385" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve actually already used statements and expressions. &lt;em&gt;Statements&lt;/em&gt; are instructions that perform some action and do not return a value. &lt;em&gt;Expressions&lt;/em&gt; evaluate to a resulting value. Let&amp;rsquo;s look at some examples.</source>
          <target state="translated">実際には、すでにステートメントと式を使用しています。&lt;em&gt;ステートメント&lt;/em&gt;は、何らかのアクションを実行し、値を返さない命令です。&lt;em&gt;式&lt;/em&gt;は、結果の値に評価されます。いくつかの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c22b2164f8306680aed3e27380f526ec1c6ded84" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each test in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">ユニットテストでは不要だったコードの先頭に &lt;code&gt;use adder&lt;/code&gt; を追加しました。その理由は、 &lt;code&gt;tests&lt;/code&gt; ディレクトリ内の各テストが個別のクレートであるため、ライブラリを各テストクレートのスコープに含める必要があるためです。</target>
        </trans-unit>
        <trans-unit id="584b8b954ee114612008442a8b00d97910ff6eab" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a line at the top to bring the standard library&amp;rsquo;s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.</source>
          <target state="translated">標準ライブラリのファイルシステムモジュールをスコープに含めるための行を上部に追加しました。ファイルの内容を文字列に読み込むためのコードは見慣れたものに見えるはずです。リスト12-4のI / Oプロジェクトのファイルの内容を読み取るときに、これを第12章で使用しました。</target>
        </trans-unit>
        <trans-unit id="4c87cb387453e91590c14806fac036a23f89422e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new &lt;code&gt;use&lt;/code&gt; line to bring &lt;code&gt;process&lt;/code&gt; from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the &lt;code&gt;err&lt;/code&gt; value and then call &lt;code&gt;process::exit&lt;/code&gt;. The &lt;code&gt;process::exit&lt;/code&gt; function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the &lt;code&gt;panic!&lt;/code&gt;-based handling we used in Listing 12-8, but we no longer get all the extra output. Let&amp;rsquo;s try it:</source>
          <target state="translated">標準のライブラリからスコープに &lt;code&gt;process&lt;/code&gt; を取り込むための新しい &lt;code&gt;use&lt;/code&gt; 行を追加しました。エラーの場合に実行されるクロージャーのコードは2行だけです &lt;code&gt;err&lt;/code&gt; 値を出力してから、 &lt;code&gt;process::exit&lt;/code&gt; 呼び出します。 &lt;code&gt;process::exit&lt;/code&gt; 機能は、プログラムを直ちに停止し、終了ステータスコードとして渡された番号を返します。これは &lt;code&gt;panic!&lt;/code&gt; 似ています！リスト12-8で使用したベースの処理ですが、余分な出力をすべて取得することはありません。試してみよう：</target>
        </trans-unit>
        <trans-unit id="7cffa1b480aa410c1dc47385712cedb9b3949a57" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a struct named &lt;code&gt;Config&lt;/code&gt; defined to have fields named &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;. The signature of &lt;code&gt;parse_config&lt;/code&gt; now indicates that it returns a &lt;code&gt;Config&lt;/code&gt; value. In the body of &lt;code&gt;parse_config&lt;/code&gt;, where we used to return string slices that reference &lt;code&gt;String&lt;/code&gt; values in &lt;code&gt;args&lt;/code&gt;, we now define &lt;code&gt;Config&lt;/code&gt; to contain owned &lt;code&gt;String&lt;/code&gt; values. The &lt;code&gt;args&lt;/code&gt; variable in &lt;code&gt;main&lt;/code&gt; is the owner of the argument values and is only letting the &lt;code&gt;parse_config&lt;/code&gt; function borrow them, which means we&amp;rsquo;d violate Rust&amp;rsquo;s borrowing rules if &lt;code&gt;Config&lt;/code&gt; tried to take ownership of the values in &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; という名前のフィールドと &lt;code&gt;filename&lt;/code&gt; を持つように定義された &lt;code&gt;Config&lt;/code&gt; という名前の構造体を追加しました。 &lt;code&gt;parse_config&lt;/code&gt; のシグネチャは、 &lt;code&gt;Config&lt;/code&gt; 値を返すことを示しています。 &lt;code&gt;args&lt;/code&gt; の &lt;code&gt;String&lt;/code&gt; 値を参照する文字列スライスを返すために使用していた &lt;code&gt;parse_config&lt;/code&gt; の本文で、所有する &lt;code&gt;String&lt;/code&gt; 値を含むように &lt;code&gt;Config&lt;/code&gt; を定義します。 &lt;code&gt;args&lt;/code&gt; 中の変数 &lt;code&gt;main&lt;/code&gt; 引数値の所有者であるとだけさせて頂いており &lt;code&gt;parse_config&lt;/code&gt; の場合、我々は錆の借入ルールに違反すると思いますどの手段、機能ボローにそれらを &lt;code&gt;Config&lt;/code&gt; &lt;code&gt;args&lt;/code&gt; の値の所有権を取得しようとしました。</target>
        </trans-unit>
        <trans-unit id="1885fbfa7b60233a91c017c818f49ba0e7b6f717" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added some documentation for our &lt;code&gt;ThreadPool&lt;/code&gt; with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running &lt;code&gt;cargo doc --open&lt;/code&gt; and clicking the &lt;code&gt;ThreadPool&lt;/code&gt; struct to see what the generated docs for &lt;code&gt;new&lt;/code&gt; look like!</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; コメント付きのThreadPoolのドキュメントをいくつか追加しました。第14章で説明したように、関数がパニックになる可能性がある状況を呼び出すセクションを追加することにより、適切なドキュメンテーションプラクティスに従っていることに注意してください &lt;code&gt;cargo doc --open&lt;/code&gt; を実行し、 &lt;code&gt;ThreadPool&lt;/code&gt; 構造体をクリックして、 &lt;code&gt;new&lt;/code&gt; 外観の生成されたドキュメントを確認してくださいお気に入り！</target>
        </trans-unit>
        <trans-unit id="033bfc676c905568043c961c9b266296859d8c02" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added the &lt;code&gt;request_review&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait; all types that implement the trait will now need to implement the &lt;code&gt;request_review&lt;/code&gt; method. Note that rather than having &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter of the method, we have &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. This syntax means the method is only valid when called on a &lt;code&gt;Box&lt;/code&gt; holding the type. This syntax takes ownership of &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, invalidating the old state so the state value of the &lt;code&gt;Post&lt;/code&gt; can transform into a new state.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; メソッドを &lt;code&gt;State&lt;/code&gt; トレイトに追加しました。トレイトを実装するすべてのタイプは、 &lt;code&gt;request_review&lt;/code&gt; メソッドを実装する必要があります。メソッドの最初のパラメーターとして &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;self&lt;/code&gt; 、または &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ではなく、 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; があることに注意してください。この構文は、メソッドが型を保持する &lt;code&gt;Box&lt;/code&gt; 呼び出された場合にのみ有効であることを意味します。この構文は &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; 所有権を取得し、古い状態を無効にして、 &lt;code&gt;Post&lt;/code&gt; の状態値を新しい状態に変換できるようにします。</target>
        </trans-unit>
        <trans-unit id="c2d6bca1ece5398cc0aaa45cdd8c28d538813cdf" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already encountered a few smart pointers in this book, such as &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in Chapter 8, although we didn&amp;rsquo;t call them smart pointers at the time. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with &lt;code&gt;String&lt;/code&gt; ensuring its data will always be valid UTF-8).</source>
          <target state="translated">この本では、第8章の &lt;code&gt;String&lt;/code&gt; や &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; など、すでにいくつかのスマートポインターに出会いましたが、現時点ではそれらをスマートポインターと呼んでいません。これらの型はどちらもメモリを所有していて、それを操作できるため、スマートポインタとしてカウントされます。また、メタデータ（容量など）と追加の機能または保証（ &lt;code&gt;String&lt;/code&gt; を使用するなど、データが常に有効なUTF-8であることを保証するなど）もあります。</target>
        </trans-unit>
        <trans-unit id="5f665940216ffe5d50883d2554e20cbd268101e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren&amp;rsquo;t suitable for every situation in which we may want to use text. One reason is that they&amp;rsquo;re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, &lt;code&gt;String&lt;/code&gt;. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a &lt;code&gt;String&lt;/code&gt; from a string literal using the &lt;code&gt;from&lt;/code&gt; function, like so:</source>
          <target state="translated">文字列値がプログラムにハードコードされている文字列リテラルはすでに見ました。文字列リテラルは便利ですが、テキストを使用したいすべての状況には適していません。 1つの理由は、それらが不変であることです。もう1つは、コードを作成するときにすべての文字列値がわかるわけではないことです。たとえば、ユーザー入力を取得して保存する場合はどうでしょうか。これらの状況では、Rustには2番目の文字列型 &lt;code&gt;String&lt;/code&gt; があります。このタイプはヒープに割り当てられているため、コンパイル時に不明なテキストを格納できます。あなたは、作成することができます &lt;code&gt;String&lt;/code&gt; 使用して、文字列リテラルから &lt;code&gt;from&lt;/code&gt; そうのように、機能：</target>
        </trans-unit>
        <trans-unit id="afec387c328832d115c9aaceeb2e235c2cecfd8f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve brought &lt;code&gt;std::thread&lt;/code&gt; into scope in the library crate, because we&amp;rsquo;re using &lt;code&gt;thread::JoinHandle&lt;/code&gt; as the type of the items in the vector in &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">我々は持ってきた &lt;code&gt;std::thread&lt;/code&gt; 私たちが使用しているので、ライブラリクレートにスコープに &lt;code&gt;thread::JoinHandle&lt;/code&gt; 中のベクター内のアイテムの種類として &lt;code&gt;ThreadPool&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="d06c508a695440c6e3d61967e906e12cd55df3a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve changed the name of the field on &lt;code&gt;ThreadPool&lt;/code&gt; from &lt;code&gt;threads&lt;/code&gt; to &lt;code&gt;workers&lt;/code&gt; because it&amp;rsquo;s now holding &lt;code&gt;Worker&lt;/code&gt; instances instead of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances. We use the counter in the &lt;code&gt;for&lt;/code&gt; loop as an argument to &lt;code&gt;Worker::new&lt;/code&gt;, and we store each new &lt;code&gt;Worker&lt;/code&gt; in the vector named &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">私たちは、上のフィールドの名前を変更した &lt;code&gt;ThreadPool&lt;/code&gt; から &lt;code&gt;threads&lt;/code&gt; への &lt;code&gt;workers&lt;/code&gt; 、それが今持っているため &lt;code&gt;Worker&lt;/code&gt; の代わりに、インスタンス &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; のインスタンスを。私たちは、カウンタを使用する &lt;code&gt;for&lt;/code&gt; の引数としてループ &lt;code&gt;Worker::new&lt;/code&gt; 、そして私たちは、それぞれの新しい保存 &lt;code&gt;Worker&lt;/code&gt; ベクトルという名前で &lt;code&gt;workers&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6773f3d57e1c56123d2fb2caa6f401e95f3ea12" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve chosen &lt;code&gt;&amp;amp;self&lt;/code&gt; here for the same reason we used &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; in the function version: we don&amp;rsquo;t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we&amp;rsquo;ve called the method on as part of what the method does, we&amp;rsquo;d use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter. Having a method that takes ownership of the instance by using just &lt;code&gt;self&lt;/code&gt; as the first parameter is rare; this technique is usually used when the method transforms &lt;code&gt;self&lt;/code&gt; into something else and you want to prevent the caller from using the original instance after the transformation.</source>
          <target state="translated">ここでは、関数バージョンで &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; を使用したのと同じ理由で &lt;code&gt;&amp;amp;self&lt;/code&gt; を選択しました。所有権を取得するのではなく、構造体のデータを読み取るのではなく、読み取るだけです。メソッドの機能の一部としてメソッドを呼び出したインスタンスを変更する場合は、最初のパラメーターとして &lt;code&gt;&amp;amp;mut self&lt;/code&gt; を使用します。最初のパラメーターとして &lt;code&gt;self&lt;/code&gt; だけを使用してインスタンスの所有権を取得するメソッドを持つことはまれです。この手法は通常、メソッドが &lt;code&gt;self&lt;/code&gt; を別のものに変換し、変換後に呼び出し元が元のインスタンスを使用しないようにする場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="c1db49e2d4e1cde132781769873263a6ad0787ce" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve created raw pointers by using &lt;code&gt;as&lt;/code&gt; to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&amp;rsquo;t make that assumption about just any raw pointer.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; を使用して未変更のポインターと変更可能な参照を対応する未加工ポインター型にキャストすることにより、未加工ポインターを作成しました。有効であることが保証されている参照から直接作成したため、これらの特定の未加工ポインターが有効であることはわかっていますが、未加工ポインターだけについてその仮定を行うことはできません。</target>
        </trans-unit>
        <trans-unit id="bffcb1376e08b8bdf566e588ca56d6643d86c91b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</source>
          <target state="translated">任意のタイプの任意の数の引数を取り、指定された要素を含むベクトルを作成するコードを生成できるマクロを定義しました。</target>
        </trans-unit>
        <trans-unit id="51c190acab3ae3b5901bd943815d252d578b8d41" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they&amp;rsquo;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</source>
          <target state="translated">この章では、ほとんどの高度な機能が必要になることはほとんどありませんでした。関連する型は途中のどこかにあります。それらは、本の残りの部分で説明されている機能よりもまれに使用されますが、この章で説明されている他の多くの機能よりも一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="06deefd5074e90766703296697ebf8ccb43b0e5d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve destructured enums earlier in this book, for example, when we destructured &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; in Listing 6-5 in Chapter 6. One detail we haven&amp;rsquo;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the &lt;code&gt;Message&lt;/code&gt; enum from Listing 6-2 and write a &lt;code&gt;match&lt;/code&gt; with patterns that will destructure each inner value.</source>
          <target state="translated">たとえば、第6章のリスト6-5で &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; を分解したときなど、この本の前半で列挙型を分解しました。明示的に言及しなかった詳細の1つは、列挙型を分解するパターンは、 enum内に格納されるデータが定義されます。例として、リスト18-15では、リスト6-2の &lt;code&gt;Message&lt;/code&gt; 列挙を使用して、各内部値を分解するパターンとの &lt;code&gt;match&lt;/code&gt; を記述しています。</target>
        </trans-unit>
        <trans-unit id="eb6277ca606742a1b968d8228027cda7b90d3f30" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, it will not compile.</source>
          <target state="translated">コードを公開しました！このコードは完全に有効ですが、エラーを受信せずに反駁できないパターンを使用することはできません。我々が与えた場合 &lt;code&gt;if let&lt;/code&gt; 、常にのような、マッチするパターン &lt;code&gt;x&lt;/code&gt; 、リスト18-10で示されるように、それがコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="9288497ed026aec5cddf626c274f65076b889591" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve hardcoded the variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; as 10 and the variable &lt;code&gt;simulated_random_number&lt;/code&gt; as 7 for simplicity&amp;rsquo;s sake; in an actual program, we&amp;rsquo;d get the intensity number from the app frontend, and we&amp;rsquo;d use the &lt;code&gt;rand&lt;/code&gt; crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The &lt;code&gt;main&lt;/code&gt; function calls a &lt;code&gt;generate_workout&lt;/code&gt; function with the simulated input values.</source>
          <target state="translated">簡単にするために、 &lt;code&gt;simulated_user_specified_value&lt;/code&gt; 変数を10、 &lt;code&gt;simulated_random_number&lt;/code&gt; 変数を7にハードコーディングしました。実際のプログラムでは、アプリのフロントエンドから強度値を取得し、第2章の推測ゲームの例で行ったように、ランダムクレートを使用して &lt;code&gt;rand&lt;/code&gt; を生成します。 &lt;code&gt;main&lt;/code&gt; 関数は、 &lt;code&gt;generate_workout&lt;/code&gt; 関数を呼び出しますシミュレートされた入力値を使用します。</target>
        </trans-unit>
        <trans-unit id="5e36cd45124891f0ced7a53981629ff72590f283" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve introduced three new crates: &lt;code&gt;proc_macro&lt;/code&gt;, &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate comes with Rust, so we didn&amp;rsquo;t need to add that to the dependencies in &lt;em&gt;Cargo.toml&lt;/em&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate is the compiler&amp;rsquo;s API that allows us to read and manipulate Rust code from our code.</source>
          <target state="translated">&lt;code&gt;proc_macro&lt;/code&gt; 、&lt;a href=&quot;https://crates.io/crates/syn&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://crates.io/crates/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; の&lt;/a&gt; 3つの新しいクレートを導入しました。 &lt;code&gt;proc_macro&lt;/code&gt; 我々が依存関係にそれを追加する必要はありませんでしたので、クレートは、錆が付属しています&lt;em&gt;Cargo.toml&lt;/em&gt;。 &lt;code&gt;proc_macro&lt;/code&gt; クレートは、私たちは私たちのコードから錆コードを読み、操作することができますコンパイラのAPIです。</target>
        </trans-unit>
        <trans-unit id="0ad45439c6472977b496b46c9e8ec344b7d03941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made liberal use of the &lt;code&gt;pub&lt;/code&gt; keyword: on &lt;code&gt;Config&lt;/code&gt;, on its fields and its &lt;code&gt;new&lt;/code&gt; method, and on the &lt;code&gt;run&lt;/code&gt; function. We now have a library crate that has a public API that we can test!</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードを自由に使用しました： &lt;code&gt;Config&lt;/code&gt; 、そのフィールドとその &lt;code&gt;new&lt;/code&gt; メソッド、および &lt;code&gt;run&lt;/code&gt; 関数です。これで、テストできるパブリックAPIを持つライブラリクレートができました。</target>
        </trans-unit>
        <trans-unit id="93d9e35440edfc2a27a289759d47f3243926cd99" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made some small and straightforward changes: we pass the receiving end of the channel into &lt;code&gt;Worker::new&lt;/code&gt;, and then we use it inside the closure.</source>
          <target state="translated">小さな簡単な変更をいくつか加えました。チャネルの受信側を &lt;code&gt;Worker::new&lt;/code&gt; に渡し、クロージャー内で使用します。</target>
        </trans-unit>
        <trans-unit id="56995a6860da00dba94b79267ee87621a35cfd58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made three significant changes here. First, we changed the return type of the &lt;code&gt;run&lt;/code&gt; function to &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt;. This function previously returned the unit type, &lt;code&gt;()&lt;/code&gt;, and we keep that as the value returned in the &lt;code&gt;Ok&lt;/code&gt; case.</source>
          <target state="translated">ここで3つの重要な変更を行いました。まず、 &lt;code&gt;run&lt;/code&gt; 関数の戻り値の型を &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt; 。この関数は以前にユニットタイプ &lt;code&gt;()&lt;/code&gt; を返しましたが、それを &lt;code&gt;Ok&lt;/code&gt; 場合に返される値として保持します。</target>
        </trans-unit>
        <trans-unit id="7aef292d2641df4649db03b9163b74c003c21be2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made two changes in the body of the &lt;code&gt;new&lt;/code&gt; function: instead of calling &lt;code&gt;panic!&lt;/code&gt; when the user doesn&amp;rsquo;t pass enough arguments, we now return an &lt;code&gt;Err&lt;/code&gt; value, and we&amp;rsquo;ve wrapped the &lt;code&gt;Config&lt;/code&gt; return value in an &lt;code&gt;Ok&lt;/code&gt;. These changes make the function conform to its new type signature.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 関数の本体に2つの変更を加えました &lt;code&gt;panic!&lt;/code&gt; を呼び出す代わりに！ユーザーが十分な引数を渡さない場合は、 &lt;code&gt;Err&lt;/code&gt; 値を返し、 &lt;code&gt;Config&lt;/code&gt; の戻り値を &lt;code&gt;Ok&lt;/code&gt; でラップしました。これらの変更により、関数は新しい型シグネチャに準拠します。</target>
        </trans-unit>
        <trans-unit id="be1fafd103cb85a28b4ca20cff35d635b76880a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve mentioned that in Rust, we refrain from calling structs and enums &amp;ldquo;objects&amp;rdquo; to distinguish them from other languages&amp;rsquo; objects. In a struct or enum, the data in the struct fields and the behavior in &lt;code&gt;impl&lt;/code&gt; blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects &lt;em&gt;are&lt;/em&gt; more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can&amp;rsquo;t add data to a trait object. Trait objects aren&amp;rsquo;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</source>
          <target state="translated">Rustでは、構造体や列挙型の「オブジェクト」を呼び出して他の言語のオブジェクトと区別することを控えています。構造体または列挙型では、構造体フィールドのデータと &lt;code&gt;impl&lt;/code&gt; ブロックの動作は分離されますが、他の言語では、1つの概念に結合されたデータと動作は、多くの場合オブジェクトとラベル付けされます。ただし、特性オブジェクト&lt;em&gt;は&lt;/em&gt;、データと動作を組み合わせるという意味で、他の言語のオブジェクトに似ています。ただし、特性オブジェクトは、特性オブジェクトにデータを追加できないという点で従来のオブジェクトとは異なります。トレイトオブジェクトは他の言語のオブジェクトほど一般的には有用ではありません。その特定の目的は、一般的な動作全体で抽象化できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="d6a7a8ffdb70b17f8f4c294d0eea3a1bf35ddd50" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve moved the creation of the new &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; to the beginning of the function; that part hasn&amp;rsquo;t changed. Instead of creating a variable &lt;code&gt;f&lt;/code&gt;, we&amp;rsquo;ve chained the call to &lt;code&gt;read_to_string&lt;/code&gt; directly onto the result of &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt;. We still have a &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call, and we still return an &lt;code&gt;Ok&lt;/code&gt; value containing the username in &lt;code&gt;s&lt;/code&gt; when both &lt;code&gt;File::open&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.</source>
          <target state="translated">私たちは、新しいの創造移動した &lt;code&gt;String&lt;/code&gt; 中 &lt;code&gt;s&lt;/code&gt; 関数の先頭にします。その部分は変わっていません。変数 &lt;code&gt;f&lt;/code&gt; を作成する代わりに、 &lt;code&gt;read_to_string&lt;/code&gt; の呼び出しを &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt; の結果に直接チェーンしましたか？。まだあり &lt;code&gt;?&lt;/code&gt; &lt;code&gt;read_to_string&lt;/code&gt; 呼び出しの最後で、エラーを返すのではなく、 &lt;code&gt;File::open&lt;/code&gt; と &lt;code&gt;read_to_string&lt;/code&gt; の両方が成功した場合でも、 &lt;code&gt;s&lt;/code&gt; にユーザー名を含む &lt;code&gt;Ok&lt;/code&gt; 値を返します。機能もリスト9-6とリスト9-7と同じです。これは、人間工学に基づいた別の方法で記述したものです。</target>
        </trans-unit>
        <trans-unit id="c8159737415ba1d5840c5d1dcfa32d246b649654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve named our test &lt;code&gt;larger_can_hold_smaller&lt;/code&gt;, and we&amp;rsquo;ve created the two &lt;code&gt;Rectangle&lt;/code&gt; instances that we need. Then we called the &lt;code&gt;assert!&lt;/code&gt; macro and passed it the result of calling &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt;. This expression is supposed to return &lt;code&gt;true&lt;/code&gt;, so our test should pass. Let&amp;rsquo;s find out!</source>
          <target state="translated">テストに &lt;code&gt;larger_can_hold_smaller&lt;/code&gt; という名前を付け、必要な2つの &lt;code&gt;Rectangle&lt;/code&gt; インスタンスを作成しました。次に、 &lt;code&gt;assert!&lt;/code&gt; を呼び出しました！マクロを渡して、 &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt; を呼び出した結果を渡しました。この式は &lt;code&gt;true&lt;/code&gt; を返すことになっているため、テストに合格するはずです。確認してみましょう！</target>
        </trans-unit>
        <trans-unit id="eb03fca51e0258eda1b9da34ca6053fc2fa793f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We&amp;rsquo;ve shown how the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type helps you use the type system to prevent errors. When enum values have data inside them, you can use &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to extract and use those values, depending on how many cases you need to handle.</source>
          <target state="translated">これで、列挙型を使用して、列挙値のセットの1つになるカスタムタイプを作成する方法について説明しました。標準ライブラリの &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 型がタイプシステムを使用してエラーを防止する方法を示しました。列挙型の値は、それらの内部でデータを持っている場合は、使用することができます &lt;code&gt;match&lt;/code&gt; か、 &lt;code&gt;if let&lt;/code&gt; 抽出し、それらの値を使用し、あなたが処理する必要がどのように多くのケースに応じました。</target>
        </trans-unit>
        <trans-unit id="2ddb2aa6e11b76709deea3ac27493aedd396c368" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&amp;rsquo;s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won&amp;rsquo;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&amp;rsquo;t have.</source>
          <target state="translated">Rustはオブジェクト指向の設計パターンを実装することができますが、状態システムを型システムにエンコードするなど、他のパターンもRustで使用できることを確認しました。これらのパターンにはさまざまなトレードオフがあります。オブジェクト指向のパターンに精通しているかもしれませんが、Rustの機能を利用するために問題を再考すると、コンパイル時にいくつかのバグを防ぐなどの利点が得られます。オブジェクト指向言語にはない所有権などの特定の機能があるため、Rustでオブジェクト指向パターンが常に最良のソリューションになるとは限りません。</target>
        </trans-unit>
        <trans-unit id="4a3393f5cdb05fd0ee1656e458d53bb37965c9bd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;the standard library has a definition we can use!&lt;/a&gt; Let&amp;rsquo;s look at how the standard library defines &lt;code&gt;IpAddr&lt;/code&gt;: it has the exact enum and variants that we&amp;rsquo;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</source>
          <target state="translated">バージョン4とバージョン6のIPアドレスを格納するデータ構造を定義するいくつかの異なる方法を示しました。しかし、結局のところ、IPアドレスを格納し、それらがどの種類であるかをエンコードすることは非常に一般的で&lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;ある&lt;/a&gt;ため、標準ライブラリには使用可能な定義があります。標準ライブラリが &lt;code&gt;IpAddr&lt;/code&gt; を定義する方法を見てみましょう。これには、定義して使用した正確な列挙型とバリアントがありますが、アドレスデータは、バリアントごとに異なる方法で定義された2つの異なる構造体の形でバリアント内に埋め込まれます。</target>
        </trans-unit>
        <trans-unit id="29dedc9579ea7a2e3397effb70664bac84882984" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on &lt;code&gt;Post&lt;/code&gt; know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the &lt;code&gt;State&lt;/code&gt; trait on the &lt;code&gt;Published&lt;/code&gt; struct.</source>
          <target state="translated">Rustがオブジェクト指向の状態パターンを実装して、投稿が各状態で持つべきさまざまな種類の動作をカプセル化できることを示しました。 &lt;code&gt;Post&lt;/code&gt; のメソッドは、さまざまな動作について何も知りません。コードを整理する方法では、公開された投稿のさまざまな動作を知るために1か所だけを調べる必要があります。それは、 &lt;code&gt;Published&lt;/code&gt; 構造体への &lt;code&gt;State&lt;/code&gt; トレイトの実装です。</target>
        </trans-unit>
        <trans-unit id="ebc522f12982267dfc02e6dcc67a8d4e642dabf5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that you can create an iterator by calling &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;into_iter&lt;/code&gt;, or &lt;code&gt;iter_mut&lt;/code&gt; on a vector. You can create iterators from the other collection types in the standard library, such as hash map. You can also create iterators that do anything you want by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait on your own types. As previously mentioned, the only method you&amp;rsquo;re required to provide a definition for is the &lt;code&gt;next&lt;/code&gt; method. Once you&amp;rsquo;ve done that, you can use all other methods that have default implementations provided by the &lt;code&gt;Iterator&lt;/code&gt; trait!</source>
          <target state="translated">ベクトルに対して &lt;code&gt;iter&lt;/code&gt; 、 &lt;code&gt;into_iter&lt;/code&gt; 、または &lt;code&gt;iter_mut&lt;/code&gt; を呼び出すことでイテレータを作成できることを示しました。ハッシュマップなど、標準ライブラリの他のコレクション型からイテレータを作成できます。独自の型に &lt;code&gt;Iterator&lt;/code&gt; トレイトを実装することで、必要なことをすべて行うイテレータを作成することもできます。前述のように、定義を提供するために必要な唯一の方法は &lt;code&gt;next&lt;/code&gt; 方法です。それが終わったら、 &lt;code&gt;Iterator&lt;/code&gt; トレイトによって提供されるデフォルトの実装を持つ他のすべてのメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="b66581e28df90aa77932dec55a52d6260ebfbe34" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you&amp;rsquo;ve already defined rather than defining a new closure. Doing this with function pointers will allow you to use functions as arguments to other functions. Functions coerce to the type &lt;code&gt;fn&lt;/code&gt; (with a lowercase f), not to be confused with the &lt;code&gt;Fn&lt;/code&gt; closure trait. The &lt;code&gt;fn&lt;/code&gt; type is called a &lt;em&gt;function pointer&lt;/em&gt;. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</source>
          <target state="translated">クロージャを関数に渡す方法について話しました。通常の関数を関数に渡すこともできます！この手法は、新しいクロージャを定義するのではなく、すでに定義した関数を渡したい場合に役立ちます。これを関数ポインタで行うと、関数を他の関数の引数として使用できます。関数は、 &lt;code&gt;fn&lt;/code&gt; 型（小文字のf）に強制変換され &lt;code&gt;Fn&lt;/code&gt; クロージャトレイトと混同しないでください。 &lt;code&gt;fn&lt;/code&gt; タイプが呼び出される&lt;em&gt;関数ポインタ&lt;/em&gt;。リスト19-27で示されるように、パラメーターが関数ポインターであることを指定するための構文はクロージャーの構文に似ています。</target>
        </trans-unit>
        <trans-unit id="44c2c6bad4c34dbea054ba65f353232e3b4bb941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; so it places the instance of &lt;code&gt;Config&lt;/code&gt; returned by &lt;code&gt;parse_config&lt;/code&gt; into a variable named &lt;code&gt;config&lt;/code&gt;, and we updated the code that previously used the separate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables so it now uses the fields on the &lt;code&gt;Config&lt;/code&gt; struct instead.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; を更新して、 &lt;code&gt;parse_config&lt;/code&gt; によって返された &lt;code&gt;Config&lt;/code&gt; のインスタンスを &lt;code&gt;config&lt;/code&gt; という名前の変数に配置し、以前は個別の &lt;code&gt;query&lt;/code&gt; 変数と &lt;code&gt;filename&lt;/code&gt; 変数を使用していたコードを更新して、代わりに &lt;code&gt;Config&lt;/code&gt; 構造体のフィールドを使用するようにしました。</target>
        </trans-unit>
        <trans-unit id="d23dd8237d80151639faf67cba12c8d62a94d599" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; where we were calling &lt;code&gt;parse_config&lt;/code&gt; to instead call &lt;code&gt;Config::new&lt;/code&gt;. We&amp;rsquo;ve changed the name of &lt;code&gt;parse_config&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; and moved it within an &lt;code&gt;impl&lt;/code&gt; block, which associates the &lt;code&gt;new&lt;/code&gt; function with &lt;code&gt;Config&lt;/code&gt;. Try compiling this code again to make sure it works.</source>
          <target state="translated">私たちは、更新した &lt;code&gt;main&lt;/code&gt; 私たちが呼んでいたところ &lt;code&gt;parse_config&lt;/code&gt; を代わりに呼び出すように &lt;code&gt;Config::new&lt;/code&gt; 。私たちは、の名前変更した &lt;code&gt;parse_config&lt;/code&gt; をに &lt;code&gt;new&lt;/code&gt; して以内にそれを移動 &lt;code&gt;impl&lt;/code&gt; 関連付けブロック、 &lt;code&gt;new&lt;/code&gt; と機能 &lt;code&gt;Config&lt;/code&gt; ]を。このコードを再度コンパイルして、機能することを確認してください。</target>
        </trans-unit>
        <trans-unit id="682f1e494883240e497eaf886adabbd3de94d2f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used &lt;code&gt;recv&lt;/code&gt; in this example for simplicity; we don&amp;rsquo;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</source>
          <target state="translated">この例では、簡単にするために &lt;code&gt;recv&lt;/code&gt; を使用しています。メインスレッドがメッセージを待機する以外に行う作業はないため、メインスレッドをブロックするのが適切です。</target>
        </trans-unit>
        <trans-unit id="09261808e853fe8c1b1cf1c98bcaef67bcdbf69f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used macros like &lt;code&gt;println!&lt;/code&gt; throughout this book, but we haven&amp;rsquo;t fully explored what a macro is and how it works. The term &lt;em&gt;macro&lt;/em&gt; refers to a family of features in Rust: &lt;em&gt;declarative&lt;/em&gt; macros with &lt;code&gt;macro_rules!&lt;/code&gt; and three kinds of &lt;em&gt;procedural&lt;/em&gt; macros:</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; ようなマクロを使用しました！この本全体を通して、マクロとは何か、どのように機能するかについては完全には調べていません。&lt;em&gt;マクロ&lt;/em&gt;という用語は、Rustの &lt;code&gt;macro_rules!&lt;/code&gt; の機能を指します：macro_rulesを使用した&lt;em&gt;宣言型&lt;/em&gt;マクロ！および3種類の&lt;em&gt;手続き&lt;/em&gt;マクロ：</target>
        </trans-unit>
        <trans-unit id="e2712446812526a53471c1e0383e7a3108a1b4ae" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used packages from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distributes the source code of your packages, so it primarily hosts code that is open source.</source>
          <target state="translated">私たちはプロジェクトの依存関係として&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;からのパッケージを使用しましたが、独自のパッケージを公開することで他の人とコードを共有することもできます。&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;のクレートレジストリはパッケージのソースコードを配布するため、主にオープンソースのコードをホストします。</target>
        </trans-unit>
        <trans-unit id="ec147c9a441b7f735a89cab0dad06f6138cccde7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used the underscore (&lt;code&gt;_&lt;/code&gt;) as a wildcard pattern that will match any value but not bind to the value. Although the underscore &lt;code&gt;_&lt;/code&gt; pattern is especially useful as the last arm in a &lt;code&gt;match&lt;/code&gt; expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</source>
          <target state="translated">アンダースコア（ &lt;code&gt;_&lt;/code&gt; ）は、任意の値に一致するが値にはバインドしないワイルドカードパターンとして使用しました。アンダースコア &lt;code&gt;_&lt;/code&gt; パターンは、 &lt;code&gt;match&lt;/code&gt; 式の最後のアームとして特に役立ちますが、リスト18-17に示すように、関数パラメーターを含む任意のパターンで使用できます。</target>
        </trans-unit>
        <trans-unit id="44adc69b5d64c0f01b24575df11e052ec21c4722" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve walked through an example of a Rust program already in Chapter 2. Now that we&amp;rsquo;re past basic syntax, we won&amp;rsquo;t include all the &lt;code&gt;fn main() {&lt;/code&gt; code in examples, so if you&amp;rsquo;re following along, you&amp;rsquo;ll have to put the following examples inside a &lt;code&gt;main&lt;/code&gt; function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</source>
          <target state="translated">Rustプログラムの例については、すでに第2章で説明しました。基本的な構文を &lt;code&gt;fn main() {&lt;/code&gt; ので、例にすべてのfn main（）{コードを含めることはしません。次の例を &lt;code&gt;main&lt;/code&gt; 関数内に手動で配置する必要があります。その結果、例はもう少し簡潔になり、定型コードではなく実際の詳細に集中できるようになります。</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="2592fb559c34ba109b261e1e971e0271f723f218" translate="yes" xml:space="preserve">
          <source>Weak keywords</source>
          <target state="translated">弱いキーワード</target>
        </trans-unit>
        <trans-unit id="b141897801ad64a5c292f85e9b0acea35468d86f" translate="yes" xml:space="preserve">
          <source>Weak::as_raw</source>
          <target state="translated">Weak::as_raw</target>
        </trans-unit>
        <trans-unit id="d422a6274254bfe89623f64408426ee6a4b95d2f" translate="yes" xml:space="preserve">
          <source>Weak::borrow</source>
          <target state="translated">Weak::borrow</target>
        </trans-unit>
        <trans-unit id="e090aeaf0035d47a06522ac573102af7ef03019b" translate="yes" xml:space="preserve">
          <source>Weak::borrow_mut</source>
          <target state="translated">Weak::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31f2cf80409016cb1a54e11bd8e10df114bcff9c" translate="yes" xml:space="preserve">
          <source>Weak::clone</source>
          <target state="translated">Weak::clone</target>
        </trans-unit>
        <trans-unit id="1022360ae57147f43f753c89ffa5b787aa1673ef" translate="yes" xml:space="preserve">
          <source>Weak::clone_from</source>
          <target state="translated">Weak::clone_from</target>
        </trans-unit>
        <trans-unit id="7ffb62a38307a645dc9e4fc1d7f948ab860db2a7" translate="yes" xml:space="preserve">
          <source>Weak::clone_into</source>
          <target state="translated">Weak::clone_into</target>
        </trans-unit>
        <trans-unit id="c865a401afc186e43b4eab7ca361d7638e0b536e" translate="yes" xml:space="preserve">
          <source>Weak::default</source>
          <target state="translated">Weak::default</target>
        </trans-unit>
        <trans-unit id="e57f10f57657469def31fa2d885237f40eb69154" translate="yes" xml:space="preserve">
          <source>Weak::drop</source>
          <target state="translated">Weak::drop</target>
        </trans-unit>
        <trans-unit id="ef51946ab6d84ee6b5287e68325989e298d500bc" translate="yes" xml:space="preserve">
          <source>Weak::fmt</source>
          <target state="translated">Weak::fmt</target>
        </trans-unit>
        <trans-unit id="04990cfad4762bebd1df30cc473af5882f2479cb" translate="yes" xml:space="preserve">
          <source>Weak::from</source>
          <target state="translated">Weak::from</target>
        </trans-unit>
        <trans-unit id="df4c7443eba251c8b78b6539d8ece4de970f301b" translate="yes" xml:space="preserve">
          <source>Weak::from_raw</source>
          <target state="translated">Weak::from_raw</target>
        </trans-unit>
        <trans-unit id="a6076aa76799b24c93bec01d241d277a0659dedb" translate="yes" xml:space="preserve">
          <source>Weak::into</source>
          <target state="translated">Weak::into</target>
        </trans-unit>
        <trans-unit id="0d8046306424b99b930a8b4a94195613e63c8154" translate="yes" xml:space="preserve">
          <source>Weak::into_raw</source>
          <target state="translated">Weak::into_raw</target>
        </trans-unit>
        <trans-unit id="a47f17db375bc704f4e384a38de508a900dfe192" translate="yes" xml:space="preserve">
          <source>Weak::new</source>
          <target state="translated">Weak::new</target>
        </trans-unit>
        <trans-unit id="9bc78ec91050d31c7752a036bdbd22e4063b718e" translate="yes" xml:space="preserve">
          <source>Weak::ptr_eq</source>
          <target state="translated">Weak::ptr_eq</target>
        </trans-unit>
        <trans-unit id="772fd61fe1d60fd5b1beff3bc669c9f17593cd0f" translate="yes" xml:space="preserve">
          <source>Weak::strong_count</source>
          <target state="translated">Weak::strong_count</target>
        </trans-unit>
        <trans-unit id="78b91a1fa2b3787768d39e8c6e94b83a6d3b3355" translate="yes" xml:space="preserve">
          <source>Weak::to_owned</source>
          <target state="translated">Weak::to_owned</target>
        </trans-unit>
        <trans-unit id="a0b4587c121fa0987a33f7acf83c36d1aa760be3" translate="yes" xml:space="preserve">
          <source>Weak::try_from</source>
          <target state="translated">Weak::try_from</target>
        </trans-unit>
        <trans-unit id="dffb26aa2fde976b45f16c5f1b3ec4c3c2236a57" translate="yes" xml:space="preserve">
          <source>Weak::try_into</source>
          <target state="translated">Weak::try_into</target>
        </trans-unit>
        <trans-unit id="66cbdb0ce3c9d445fe02eebbca20dc6699c1e0b8" translate="yes" xml:space="preserve">
          <source>Weak::type_id</source>
          <target state="translated">Weak::type_id</target>
        </trans-unit>
        <trans-unit id="ffffecfd343836cf2781f4e9ad8fe4ab904bdda7" translate="yes" xml:space="preserve">
          <source>Weak::upgrade</source>
          <target state="translated">Weak::upgrade</target>
        </trans-unit>
        <trans-unit id="5eadf7e5be67bb31aac15c710ff80ec7238e0320" translate="yes" xml:space="preserve">
          <source>Weak::weak_count</source>
          <target state="translated">Weak::weak_count</target>
        </trans-unit>
        <trans-unit id="cbd86db606d844ea581cc87e07ebe1432bbeb3e7" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">&lt;em&gt;Rustプログラミング言語の&lt;/em&gt;本へようこそ！このバージョンのテキストは、Rust 2018 Editionイディオムを使用するすべてのプロジェクトの&lt;em&gt;Cargo.toml&lt;/em&gt;で &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; を&lt;em&gt;指定&lt;/em&gt;したRust 1.31.0以降を使用していることを前提としています。Rustをインストールまたは更新するに&lt;a href=&quot;book/ch01-01-installation&quot;&gt;は、第1章&lt;/a&gt;の「インストール」セクションを参照して&lt;a href=&quot;book/appendix-05-editions&quot;&gt;ください&lt;/a&gt;。Rustのエディションについては、新しい付録Eを参照してください。</target>
        </trans-unit>
        <trans-unit id="b8d0b89eafe83e20d5f86108981d205157dbff45" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">&lt;em&gt;Rustプログラミング言語の&lt;/em&gt;本へようこそ！このバージョンのテキストは、Rust 2018 Editionイディオムを使用するすべてのプロジェクトの&lt;em&gt;Cargo.toml&lt;/em&gt;で &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; を&lt;em&gt;指定&lt;/em&gt;したRust 1.31.0以降を使用していることを前提としています。Rustをインストールまたは更新するに&lt;a href=&quot;ch01-01-installation&quot;&gt;は、第1章&lt;/a&gt;の「インストール」セクションを参照して&lt;a href=&quot;appendix-05-editions&quot;&gt;ください&lt;/a&gt;。Rustのエディションについては、新しい付録Eを参照してください。</target>
        </trans-unit>
        <trans-unit id="71aabd16eb59292324e9dfd1470f8e3b8318b16b" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt;, an introductory book about Rust. The Rust programming language helps you write faster, more reliable software. High-level ergonomics and low-level control are often at odds in programming language design; Rust challenges that conflict. Through balancing powerful technical capacity and a great developer experience, Rust gives you the option to control low-level details (such as memory usage) without all the hassle traditionally associated with such control.</source>
          <target state="translated">&lt;em&gt;Rust&lt;/em&gt;の入門書である&lt;em&gt;Rustプログラミング言語&lt;/em&gt;へようこそ。 Rustプログラミング言語を使用すると、より高速で信頼性の高いソフトウェアを作成できます。高レベルの人間工学と低レベルの制御は、プログラミング言語の設計においてしばしば対立します。錆はその対立に挑戦します。 Rustは、強力な技術的能力と優れた開発者エクスペリエンスのバランスをとることで、低レベルの詳細（メモリ使用量など）を制御するオプションを提供します。</target>
        </trans-unit>
        <trans-unit id="def3e0cabaddabefe272409c1a7371052fe52e2f" translate="yes" xml:space="preserve">
          <source>Well done! You&amp;rsquo;ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You&amp;rsquo;re now ready to implement your own Rust projects and help with other peoples&amp;rsquo; projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</source>
          <target state="translated">よくやった！これで本の最後に到達しました。Rustのツアーにご参加いただきありがとうございます。これで、独自のRustプロジェクトを実装し、他の人々のプロジェクトを支援する準備が整いました。Rustの旅で遭遇するあらゆる課題を手助けしてくれる他のRustaceansの歓迎するコミュニティがあることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="9cecc65aff2a51e558a3cf424c55a11b8c31dce1" translate="yes" xml:space="preserve">
          <source>What &lt;em&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">どのような&lt;em&gt;リファレンス&lt;/em&gt;ではありません</target>
        </trans-unit>
        <trans-unit id="f518d8ec17050e8115e7f2ec450de2471cd3f305" translate="yes" xml:space="preserve">
          <source>What Is Ownership?</source>
          <target state="translated">所有権とは?</target>
        </trans-unit>
        <trans-unit id="70d9b24e457447486228a37f69315f0aa6c48b62" translate="yes" xml:space="preserve">
          <source>What Is a String?</source>
          <target state="translated">文字列とは何ですか?</target>
        </trans-unit>
        <trans-unit id="2368fe52347b12513e40ec057f72fd1310d84880" translate="yes" xml:space="preserve">
          <source>What do I do?</source>
          <target state="translated">私は何をすればいいの?</target>
        </trans-unit>
        <trans-unit id="aa2332f8c7d8caf559cd55bda6779e69b9228def" translate="yes" xml:space="preserve">
          <source>What happened? Adding the &lt;code&gt;pub&lt;/code&gt; keyword in front of &lt;code&gt;mod hosting&lt;/code&gt; makes the module public. With this change, if we can access &lt;code&gt;front_of_house&lt;/code&gt;, we can access &lt;code&gt;hosting&lt;/code&gt;. But the &lt;em&gt;contents&lt;/em&gt; of &lt;code&gt;hosting&lt;/code&gt; are still private; making the module public doesn&amp;rsquo;t make its contents public. The &lt;code&gt;pub&lt;/code&gt; keyword on a module only lets code in its ancestor modules refer to it.</source>
          <target state="translated">どうした？ &lt;code&gt;mod hosting&lt;/code&gt; 前に &lt;code&gt;pub&lt;/code&gt; キーワードを追加すると、モジュールがパブリックになります。この変更により、 &lt;code&gt;front_of_house&lt;/code&gt; にアクセスできる場合、 &lt;code&gt;hosting&lt;/code&gt; にアクセスできます。しかし、&lt;em&gt;コンテンツ&lt;/em&gt;の &lt;code&gt;hosting&lt;/code&gt; まだ非公開です。モジュールを公開しても、そのコンテンツは公開されません。モジュールの &lt;code&gt;pub&lt;/code&gt; キーワードは、その祖先モジュールのコードにのみ参照させます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8765b8c06cc83702c9dbf2bca66a40041316a4f" translate="yes" xml:space="preserve">
          <source>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</source>
          <target state="translated">配列の終端を過ぎた配列の要素にアクセスしようとするとどうなるでしょうか?この例を以下のコードに変更したとします。</target>
        </trans-unit>
        <trans-unit id="0903cd7655009ddeab2540796c6a002b16cf56ff" translate="yes" xml:space="preserve">
          <source>What implementing the trait signifies about the type</source>
          <target state="translated">形質を実装することが型について何を意味するか</target>
        </trans-unit>
        <trans-unit id="a77059cf1db619a698ed5c928ae175c07abb8490" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;UnwindSafe&lt;/code&gt; とは何ですか？</target>
        </trans-unit>
        <trans-unit id="39c550be471783e69447a16171fe28c441cfa1b6" translate="yes" xml:space="preserve">
          <source>What is in the standard library documentation?</source>
          <target state="translated">標準ライブラリのドキュメントには何がありますか?</target>
        </trans-unit>
        <trans-unit id="6be8c40317b2fde07b27b69f6275feba9067a940" translate="yes" xml:space="preserve">
          <source>What is unwind safety?</source>
          <target state="translated">巻き戻し安全とは?</target>
        </trans-unit>
        <trans-unit id="546be1954cedfdfe8c9b6d5ed68a1aba4520048c" translate="yes" xml:space="preserve">
          <source>What operators and methods deriving this trait will enable</source>
          <target state="translated">どのような演算子や方法でこの特徴を導出することができるのか</target>
        </trans-unit>
        <trans-unit id="8cbcae63b4448efc20dd52bc49133e3cdc73cd42" translate="yes" xml:space="preserve">
          <source>What should the value of &lt;code&gt;answer&lt;/code&gt; be? Should it be &lt;code&gt;З&lt;/code&gt;, the first letter? When encoded in UTF-8, the first byte of &lt;code&gt;З&lt;/code&gt; is &lt;code&gt;208&lt;/code&gt; and the second is &lt;code&gt;151&lt;/code&gt;, so &lt;code&gt;answer&lt;/code&gt; should in fact be &lt;code&gt;208&lt;/code&gt;, but &lt;code&gt;208&lt;/code&gt; is not a valid character on its own. Returning &lt;code&gt;208&lt;/code&gt; is likely not what a user would want if they asked for the first letter of this string; however, that&amp;rsquo;s the only data that Rust has at byte index 0. Users generally don&amp;rsquo;t want the byte value returned, even if the string contains only Latin letters: if &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; were valid code that returned the byte value, it would return &lt;code&gt;104&lt;/code&gt;, not &lt;code&gt;h&lt;/code&gt;. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&amp;rsquo;t compile this code at all and prevents misunderstandings early in the development process.</source>
          <target state="translated">&lt;code&gt;answer&lt;/code&gt; の価値は何であるべきですか？それがあるべき &lt;code&gt;З&lt;/code&gt; 、最初の文字？ UTF-8でエンコードされている場合、 &lt;code&gt;З&lt;/code&gt; の最初のバイトは &lt;code&gt;208&lt;/code&gt; で、2番目のバイトは &lt;code&gt;151&lt;/code&gt; であるため、 &lt;code&gt;answer&lt;/code&gt; は実際には &lt;code&gt;208&lt;/code&gt; になるはずですが、 &lt;code&gt;208&lt;/code&gt; 自体は有効な文字ではありません。ユーザーがこの文字列の最初の文字を要求した場合、 &lt;code&gt;208&lt;/code&gt; を返すことはおそらくユーザーが望むことではありません。ただし、これはRustがバイトインデックス0で保持する唯一のデータです。文字列にラテン文字のみが含まれている場合でも、ユーザーは通常、バイト値が返されることを望んでいません。 &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; がバイト値を返す有効なコードである場合、 &lt;code&gt;104&lt;/code&gt; を返します、ない &lt;code&gt;h&lt;/code&gt; 。予期しない値が返されてすぐに発見されない可能性があるバグが発生するのを防ぐために、Rustはこのコードをまったくコンパイルせず、開発プロセスの早い段階で誤解を防ぎます。</target>
        </trans-unit>
        <trans-unit id="104867f147475715b8460879a1886ec236299ab6" translate="yes" xml:space="preserve">
          <source>What the implementation of the trait provided by &lt;code&gt;derive&lt;/code&gt; does</source>
          <target state="translated">deriveによって提供さ &lt;code&gt;derive&lt;/code&gt; 特性の実装が行うこと</target>
        </trans-unit>
        <trans-unit id="813bb1fc77d8fbc02f8d5943beea4d865f45c1f2" translate="yes" xml:space="preserve">
          <source>What this means is that any type of argument which implements the &lt;a href=&quot;trait.binary&quot;&gt;&lt;code&gt;fmt::Binary&lt;/code&gt;&lt;/a&gt; trait can then be formatted with &lt;code&gt;{:b}&lt;/code&gt;. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{:6}&lt;/code&gt;), then the format trait used is the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">つまり、&lt;a href=&quot;trait.binary&quot;&gt; &lt;code&gt;fmt::Binary&lt;/code&gt; &lt;/a&gt;トレイトを実装するすべてのタイプの引数は、 &lt;code&gt;{:b}&lt;/code&gt; でフォーマットできます。標準ライブラリによって、いくつかのプリミティブ型のこれらの特性に対する実装も提供されています。フォーマットが指定されていない場合（ &lt;code&gt;{}&lt;/code&gt; または &lt;code&gt;{:6}&lt;/code&gt; など）、使用されるフォーマット特性は&lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;特性です。</target>
        </trans-unit>
        <trans-unit id="0093e0ba1575f01e625f11752607bd61339f460b" translate="yes" xml:space="preserve">
          <source>What to do when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition does not hold.</source>
          <target state="translated">とき何をすべき&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;条件が成立しません。</target>
        </trans-unit>
        <trans-unit id="534b9c0fb827379bcd2c8827a70c556de12f2bc1" translate="yes" xml:space="preserve">
          <source>What we can&amp;rsquo;t see in this example is that when &lt;code&gt;b&lt;/code&gt; and then &lt;code&gt;a&lt;/code&gt; go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, the count is then 0, and the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; is cleaned up completely at that point. Using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</source>
          <target state="translated">私たちは、この例では見ることができないことが行われているときに &lt;code&gt;b&lt;/code&gt; 、その後の終わりに範囲を出て行く &lt;code&gt;main&lt;/code&gt; は、カウントを0であり、 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; その時点で完全にクリーンアップされます。 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 使用すると、単一の値に複数の所有者を含めることができ、カウントにより、いずれかの所有者がまだ存在している限り、値が有効であることが保証されます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b08c6969a173d0d359ebf16040e97b732df68a33" translate="yes" xml:space="preserve">
          <source>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?</source>
          <target state="translated">メモリを共有することでコミュニケーションをとることは、どのような形になるのだろうか。また、メッセージパス愛好家はなぜそれを使わず、逆のことをするのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e11dfea032c9cc516196eaa3fe3bafda5d5ff2fa" translate="yes" xml:space="preserve">
          <source>What would happen if we used &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt;? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</source>
          <target state="translated">&lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt; を使用するとどうなりますか？答え：Rustは、無効なインデックスがベクターでアクセスされた場合と同じように、実行時にパニックを起こします。</target>
        </trans-unit>
        <trans-unit id="3a08543da46101db0a5f909c75d05185352f5e54" translate="yes" xml:space="preserve">
          <source>What would happen to the code in Listing 16-4 where the main thread called &lt;code&gt;drop&lt;/code&gt; if we use a &lt;code&gt;move&lt;/code&gt; closure? Would &lt;code&gt;move&lt;/code&gt; fix that case? Unfortunately, no; we would get a different error because what Listing 16-4 is trying to do isn&amp;rsquo;t allowed for a different reason. If we added &lt;code&gt;move&lt;/code&gt; to the closure, we would move &lt;code&gt;v&lt;/code&gt; into the closure&amp;rsquo;s environment, and we could no longer call &lt;code&gt;drop&lt;/code&gt; on it in the main thread. We would get this compiler error instead:</source>
          <target state="translated">リスト16-4のコードで &lt;code&gt;move&lt;/code&gt; クロージャーを使用すると、メインスレッドで &lt;code&gt;drop&lt;/code&gt; が呼び出されます。思い &lt;code&gt;move&lt;/code&gt; する場合、その修正を？残念だけど違う; リスト16-4が試みていることは別の理由で許可されていないため、別のエラーが発生します。 &lt;code&gt;move&lt;/code&gt; をクロージャーに追加した場合、 &lt;code&gt;v&lt;/code&gt; をクロージャーの環境に移動し、メインスレッドで &lt;code&gt;drop&lt;/code&gt; を呼び出すことができなくなります。代わりにこのコンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="7e42bfeecb6b1e951f9890e0818a295e8fe9a892" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; と &lt;code&gt;Clone&lt;/code&gt; 違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="44cd724105e5ed735f83c23d67c2ff48add6811d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary &lt;code&gt;-&lt;/code&gt; on the smallest value of any signed integer type.</source>
          <target state="translated">場合 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、または &lt;code&gt;-&lt;/code&gt; 以下で保存することができる最小値より最大値よりも値の大きいを作成する、または。これには、単項 &lt;code&gt;-&lt;/code&gt; 符号付き整数型の最小値が含まれます。</target>
        </trans-unit>
        <trans-unit id="aec1ff4fb0f51938e677ce85402d7e6e56fa4124" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait2&lt;/code&gt; is a subtrait of &lt;code&gt;Trait1&lt;/code&gt; (for example, when &lt;code&gt;Trait2&lt;/code&gt; has a definition like &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt;), it is not allowed to implement &lt;code&gt;Trait1&lt;/code&gt; for &lt;code&gt;Trait2&lt;/code&gt;. This is because &lt;code&gt;Trait2&lt;/code&gt; already implements &lt;code&gt;Trait1&lt;/code&gt; by definition, so it is not useful to do this.</source>
          <target state="translated">場合 &lt;code&gt;Trait2&lt;/code&gt; でのsubtraitある &lt;code&gt;Trait1&lt;/code&gt; は、（例えば、場合 &lt;code&gt;Trait2&lt;/code&gt; のような定義を有する &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt; ）、それを実現するために許可されていない &lt;code&gt;Trait1&lt;/code&gt; のため &lt;code&gt;Trait2&lt;/code&gt; 。これは、ある &lt;code&gt;Trait2&lt;/code&gt; がすでに実装 &lt;code&gt;Trait1&lt;/code&gt; を定義することによって、これを行うには有用ではありません。</target>
        </trans-unit>
        <trans-unit id="394708bf787cdb05a4155072af4201796f69da61" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait&lt;/code&gt; is treated as a type, the type does not implement the special &lt;code&gt;Sized&lt;/code&gt; trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</source>
          <target state="translated">&lt;code&gt;Trait&lt;/code&gt; が型として扱われる場合、型はコンパイル時に既知のサイズを持たず、ポインターの背後でのみアクセスできるため、その型は特別な &lt;code&gt;Sized&lt;/code&gt; 特性を実装しません。したがって、次のような特性がある場合：</target>
        </trans-unit>
        <trans-unit id="88bc0dd59ab0b7fc42f69193dff99dc50f4478aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated, for example:</source>
          <target state="translated">ときに &lt;code&gt;break&lt;/code&gt; 検出され、関連するループ本体の実行はすぐに、たとえば、終了しました。</target>
        </trans-unit>
        <trans-unit id="595c9458cad4cb9057d8e7fc040fb8866cc8cc3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop &lt;em&gt;head&lt;/em&gt;. In the case of a &lt;code&gt;while&lt;/code&gt; loop, the head is the conditional expression controlling the loop. In the case of a &lt;code&gt;for&lt;/code&gt; loop, the head is the call-expression controlling the loop.</source>
          <target state="translated">場合は &lt;code&gt;continue&lt;/code&gt; 検出され、関連するループ本体の現在の反復が直ちにループに制御を戻す、終了される&lt;em&gt;ヘッド&lt;/em&gt;。以下の場合には &lt;code&gt;while&lt;/code&gt; ループ、ヘッドは、ループを制御する条件式です。以下の場合 &lt;code&gt;for&lt;/code&gt; ループ、ヘッドは、ループを制御するコール式です。</target>
        </trans-unit>
        <trans-unit id="e1a4cd7cb82bb7dfe91312bff7fa4ef245f8f684" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outer&lt;/code&gt; goes out of scope, the &lt;code&gt;drop&lt;/code&gt; method will be called first for &lt;code&gt;Outer&lt;/code&gt;, then for &lt;code&gt;Inner&lt;/code&gt;. Therefore, &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping Outer!&lt;/code&gt; and then &lt;code&gt;Dropping Inner!&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;outer&lt;/code&gt; スコープ外になる、 &lt;code&gt;drop&lt;/code&gt; 方法は、のために最初に呼び出される &lt;code&gt;Outer&lt;/code&gt; 、その後のために、 &lt;code&gt;Inner&lt;/code&gt; 。したがって、 &lt;code&gt;main&lt;/code&gt; プリントは &lt;code&gt;Dropping Outer!&lt;/code&gt; そして、 &lt;code&gt;Dropping Inner!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a6386c03d530a251bd741f83dfe28d17156802f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s&lt;/code&gt; comes &lt;em&gt;into scope&lt;/em&gt;, it is valid.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; が&lt;em&gt;スコープ&lt;/em&gt;に入るとき、それは有効です。</target>
        </trans-unit>
        <trans-unit id="187902d840e750b40be0f468eec4f29e171a13da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;security_qos_flags&lt;/code&gt; が設定されていない場合、悪意のあるプログラムは、ユーザーが指定したパスを開くことを許可すると、それをだまして名前付きパイプを開くことにより、特権Rustプロセスの上位の特権を取得できます。したがって、任意のパスを開くときに、間違いなく &lt;code&gt;security_qos_flags&lt;/code&gt; も設定する必要があります。ただし、ビットは他のフラグ、特に &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; と競合する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ae5e8e8826bd49e5ed65af5663b42f4dcb6bef45" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;can't&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">私のタイプはいつ &lt;code&gt;Copy&lt;/code&gt; &lt;em&gt;できないの&lt;/em&gt;ですか？</target>
        </trans-unit>
        <trans-unit id="1afd27d775db688aa55a7acd7657368f0252621c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;should&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">私のタイプはいつ &lt;code&gt;Copy&lt;/code&gt; する&lt;em&gt;必要&lt;/em&gt;がありますか？</target>
        </trans-unit>
        <trans-unit id="eeffd83a46d46ad1d4f4a9906f6344d685f07825" translate="yes" xml:space="preserve">
          <source>When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances and identifies two kinds of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;: one is &lt;code&gt;i32&lt;/code&gt; and the other is &lt;code&gt;f64&lt;/code&gt;. As such, it expands the generic definition of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into &lt;code&gt;Option_i32&lt;/code&gt; and &lt;code&gt;Option_f64&lt;/code&gt;, thereby replacing the generic definition with the specific ones.</source>
          <target state="translated">Rustがこのコードをコンパイルすると、単形化が実行されます。そのプロセス中に、コンパイラーは &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; インスタンスで使用されている値を読み取り、2種類の &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; を識別します。1つは &lt;code&gt;i32&lt;/code&gt; で、もう1つは &lt;code&gt;f64&lt;/code&gt; です。そのため、それは &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; の一般的な定義を &lt;code&gt;Option_i32&lt;/code&gt; と &lt;code&gt;Option_f64&lt;/code&gt; に拡張し、それによって一般的な定義を特定のものに置き換えます。</target>
        </trans-unit>
        <trans-unit id="2db72e30aa272b55473c5bb5758326ffc2e81ae7" translate="yes" xml:space="preserve">
          <source>When Should You Use Which Collection?</source>
          <target state="translated">どのコレクションを使うべきか?</target>
        </trans-unit>
        <trans-unit id="25db746b33ac06b90cb2c2043d4cbfe8648aece7" translate="yes" xml:space="preserve">
          <source>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don&amp;rsquo;t want to pay in more common cases where we want to execute code that doesn&amp;rsquo;t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</source>
          <target state="translated">クロージャーは、その環境から値をキャプチャーするときに、メモリーを使用してクロージャー本体で使用する値を格納します。このメモリの使用はオーバーヘッドであり、その環境をキャプチャしないコードを実行するより一般的なケースでは支払いたくありません。関数が環境をキャプチャすることは決して許可されないため、関数を定義して使用しても、このオーバーヘッドが発生することはありません。</target>
        </trans-unit>
        <trans-unit id="497ca50f155974a1532fc87c50b119765598e81c" translate="yes" xml:space="preserve">
          <source>When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched. Consider using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt; in such cases.</source>
          <target state="translated">関数が適切なアラインメントを必要とする場合、アクセスがサイズ0であっても、つまりメモリが実際に操作されていなくても、そうします。このような場合は、&lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling&lt;/code&gt; &lt;/a&gt;使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="8dfc9c0b52337fbeec4162f45c275f5e1ab922f4" translate="yes" xml:space="preserve">
          <source>When a function returns &lt;code&gt;Pending&lt;/code&gt;, the function &lt;em&gt;must&lt;/em&gt; also ensure that the current task is scheduled to be awoken when progress can be made.</source>
          <target state="translated">関数が戻るときに &lt;code&gt;Pending&lt;/code&gt; 、機能は&lt;em&gt;しなければならない&lt;/em&gt;にも進展ができたときに、現在のタスクが起こされる予定であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="df3a37e739621c9131e28f62bb1b9067e261aa43" translate="yes" xml:space="preserve">
          <source>When a future is not ready yet, &lt;code&gt;poll&lt;/code&gt; returns &lt;code&gt;Poll::Pending&lt;/code&gt; and stores a clone of the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; copied from the current &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; is then woken once the future can make progress. For example, a future waiting for a socket to become readable would call &lt;code&gt;.clone()&lt;/code&gt; on the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; and store it. When a signal arrives elsewhere indicating that the socket is readable, &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt;&lt;code&gt;Waker::wake&lt;/code&gt;&lt;/a&gt; is called and the socket future's task is awoken. Once a task has been woken up, it should attempt to &lt;code&gt;poll&lt;/code&gt; the future again, which may or may not produce a final value.</source>
          <target state="translated">futureがまだ準備ができていない場合、 &lt;code&gt;poll&lt;/code&gt; は &lt;code&gt;Poll::Pending&lt;/code&gt; を返し、現在の&lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;からコピーされた&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; の&lt;/a&gt;クローンを保存します。この&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;は、未来が進むことができるようになったら起こされます。たとえば、ソケットが読み取り可能になるのを待っている将来は、&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; で&lt;/a&gt; &lt;code&gt;.clone()&lt;/code&gt; を呼び出して保存します。ソケットが読み取り可能であることを示す信号が他の場所に到着すると、&lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt; &lt;code&gt;Waker::wake&lt;/code&gt; &lt;/a&gt;が呼び出され、ソケットfutureのタスクが起こされます。タスクが起こされると、それは再び未来を &lt;code&gt;poll&lt;/code&gt; しようとするべきであり、それは最終的な値を生成するかもしれないししないかもしれない。</target>
        </trans-unit>
        <trans-unit id="0a389975a3b1e10203b84d73debfb669c64513a0" translate="yes" xml:space="preserve">
          <source>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the &lt;code&gt;foo&lt;/code&gt; function here:</source>
          <target state="translated">ジェネリック関数が参照されると、その型は参照のコンテキストに基づいてインスタンス化されます。たとえば、ここで &lt;code&gt;foo&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="6dd55c7ab400acdd91bba18da1fe8d01823a4e07" translate="yes" xml:space="preserve">
          <source>When a macro is exported, the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute can have the &lt;code&gt;local_inner_macros&lt;/code&gt; keyword added to automatically prefix all contained macro invocations with &lt;code&gt;$crate::&lt;/code&gt;. This is intended primarily as a tool to migrate code written before &lt;code&gt;$crate&lt;/code&gt; was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.</source>
          <target state="translated">マクロがエクスポートされると、 &lt;code&gt;#[macro_export]&lt;/code&gt; 属性に &lt;code&gt;local_inner_macros&lt;/code&gt; キーワードを追加して、含まれるすべてのマクロ呼び出しに &lt;code&gt;$crate::&lt;/code&gt; crate ::を自動的にプレフィックスすることができます。これは主に、Rust 2018のパスベースのマクロのインポートで動作するように &lt;code&gt;$crate&lt;/code&gt; が言語に追加される前に書かれたコードを移行するツールとして意図されています。新しいコードでは、その使用は推奨されていません。</target>
        </trans-unit>
        <trans-unit id="5cf6c55b5740990d2d97e584acaf0732444aabf9" translate="yes" xml:space="preserve">
          <source>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.</source>
          <target state="translated">マクロが修飾されていない識別子(マルチパートパスの一部ではない)によって呼び出された場合、最初にテキスト スコーピングで検索されます。これで結果が得られない場合は、パスベースのスコーピングで検索されます。マクロの名前がパスで修飾されている場合は、パスベースのスコーピングでのみ検索されます。</target>
        </trans-unit>
        <trans-unit id="da106a1de68be7bf6a4528e441dfbcc8cf456544" translate="yes" xml:space="preserve">
          <source>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a &lt;code&gt;)&lt;/code&gt;, even though that would allow it to parse the invocation unambiguously:</source>
          <target state="translated">マクロが呼び出されると、マクロエクスパンダはマクロ呼び出しを名前で検索し、各マクロルールを順番に試行します。最初に成功したマッチを書き起こします。これによりエラーが発生した場合、今後の照合は試行されません。一致する場合、先読みは実行されません。コンパイラがマクロ呼び出しを一度に1つのトークンを解析する方法を明確に決定できない場合、エラーになります。次の例では、コンパイラは呼び出しを明確に解析できるようにする場合でも、識別子を越えて次のトークンが &lt;code&gt;)&lt;/code&gt; かどうかを確認しません。</target>
        </trans-unit>
        <trans-unit id="db73e8cf8b50208d0fa9d6efe2409269d6d07431" translate="yes" xml:space="preserve">
          <source>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held &lt;em&gt;in&lt;/em&gt; that memory location. If the type of that value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, then the value will be copied. In the remaining situations if that type is &lt;a href=&quot;special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;, then it may be possible to move the value. Only the following place expressions may be moved out of:</source>
          <target state="translated">プレース式が値式のコンテキストで評価されるか、パターンの値にバインドされている場合&lt;em&gt;、&lt;/em&gt;そのメモリ位置に保持さ&lt;em&gt;れ&lt;/em&gt;ている値を示します。その値のタイプが&lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; を&lt;/a&gt;実装している場合、値がコピーされます。残りの状況では、そのタイプが&lt;a href=&quot;special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; の&lt;/a&gt;場合、値を移動できる可能性があります。次の場所の式のみを移動できます：</target>
        </trans-unit>
        <trans-unit id="f1166409c8dae55a33ce311312672ddb4f4b9f7d" translate="yes" xml:space="preserve">
          <source>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an &lt;code&gt;unsafe&lt;/code&gt; block. The compiler will consider uses of such code safe, in the surrounding context.</source>
          <target state="translated">プログラマーは、潜在的に危険な操作のシーケンスが実際に安全であるという十分な確信を持っている場合、そのシーケンス（全体として取られた）を &lt;code&gt;unsafe&lt;/code&gt; ブロック内にカプセル化できます。コンパイラーは、このようなコードの使用を周囲の状況で安全であると見なします。</target>
        </trans-unit>
        <trans-unit id="37dbbb1590700cff7b3552010c53f0420bf77ff3" translate="yes" xml:space="preserve">
          <source>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</source>
          <target state="translated">スタックフレームが終了すると、そのローカル割り当てはすべて解放され、ボックスへの参照は削除されます。</target>
        </trans-unit>
        <trans-unit id="9c30511e183a1aabc7ef13d867dc58fb961ffdbb" translate="yes" xml:space="preserve">
          <source>When a temporary value expression is being created that is assigned into a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt;, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt; would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a &lt;code&gt;let&lt;/code&gt; binding, and therefore deserve a longer temporary lifetime.</source>
          <target state="translated">ただし、&lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 宣言に&lt;/a&gt;割り当てられた一時的な値式が作成されている場合、代わりに囲まれた&lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 宣言&lt;/a&gt;を使用するとエラーが保証されるため（一時ファイルへのポインタが変数に格納されますが、一時変数は変数が使用される前に解放されます）。コンパイラーは、単純な構文規則を使用して、 &lt;code&gt;let&lt;/code&gt; バインディングに割り当てられる値を決定するため、一時的な寿命が長くなります。</target>
        </trans-unit>
        <trans-unit id="3039f11f165afd56d3c433b69cd1393d96919902" translate="yes" xml:space="preserve">
          <source>When a tool is not in use, the tool's attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</source>
          <target state="translated">ツールが使用されていないときは、ツールの属性は警告なしで受け入れられます。ツールが使用されている場合、そのツールはその属性の処理と解釈に責任を持つ。</target>
        </trans-unit>
        <trans-unit id="4c9879ea05cdb93dca8c0304f717ae122b1e8ba0" translate="yes" xml:space="preserve">
          <source>When a user calls &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt;, the map will search for the key and then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.</source>
          <target state="translated">ユーザーが &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt; を呼び出すと、マップはキーを検索してから、 &lt;code&gt;Entry&lt;/code&gt; enumのバリアントを生成します。</target>
        </trans-unit>
        <trans-unit id="fdd0bd3294966057d48234d31e6f7d296a99309a" translate="yes" xml:space="preserve">
          <source>When a value goes out of scope, it will have its &lt;code&gt;drop&lt;/code&gt; method called if its type implements &lt;code&gt;Drop&lt;/code&gt;. Then, any fields the value contains will also be dropped recursively.</source>
          <target state="translated">値がスコープから外れると、その型が &lt;code&gt;Drop&lt;/code&gt; を実装している場合、その &lt;code&gt;drop&lt;/code&gt; メソッドが呼び出されます。次に、値に含まれるフィールドも再帰的に削除されます。</target>
        </trans-unit>
        <trans-unit id="0821834765580ea9c5440213203fcb1c1cbcdd57" translate="yes" xml:space="preserve">
          <source>When a variable is immutable, once a value is bound to a name, you can&amp;rsquo;t change that value. To illustrate this, let&amp;rsquo;s generate a new project called &lt;em&gt;variables&lt;/em&gt; in your &lt;em&gt;projects&lt;/em&gt; directory by using &lt;code&gt;cargo new variables&lt;/code&gt;.</source>
          <target state="translated">変数が不変である場合、値が名前にバインドされると、その値を変更することはできません。これを説明するために、 &lt;code&gt;cargo new variables&lt;/code&gt; を使用して、&lt;em&gt;プロジェクト&lt;/em&gt;ディレクトリに&lt;em&gt;variables&lt;/em&gt;という新しいプロジェクトを生成してみましょう。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd9a182b7a78038005ce22938a8bdbd281d7f445" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in Rust goes out of scope or a &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt; is no longer needed its &lt;em&gt;destructor&lt;/em&gt; is run. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, unless it's an uninitialized variable. If a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">ときに&lt;a href=&quot;glossary#initialized&quot;&gt;初期化された&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;変数&lt;/a&gt;ルストがスコープ外になるか、&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;一時的に&lt;/a&gt;不要になったその&lt;em&gt;デストラクタが&lt;/em&gt;実行されます。&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;割り当て&lt;/a&gt;は、初期化されていない変数でない限り、左側のオペランドのデストラクタも実行します。&lt;a href=&quot;types/struct&quot;&gt;構造体&lt;/a&gt;変数が部分的に初期化されている場合、初期化されたフィールドのみが削除されます。</target>
        </trans-unit>
        <trans-unit id="e8c277e0058026b8160091c9cd27bc3ead387a36" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStderr&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStderr&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">&lt;code&gt;ChildStderr&lt;/code&gt; のインスタンスが&lt;a href=&quot;../ops/trait.drop&quot;&gt;削除される&lt;/a&gt;と、 &lt;code&gt;ChildStderr&lt;/code&gt; の基になるファイルハンドルが閉じられます。</target>
        </trans-unit>
        <trans-unit id="958df1c2da20bb17df895f86bdedaa3ff7514d03" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdin&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdin&lt;/code&gt;'s underlying file handle will be closed. If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.</source>
          <target state="translated">&lt;code&gt;ChildStdin&lt;/code&gt; のインスタンスが&lt;a href=&quot;../ops/trait.drop&quot;&gt;削除される&lt;/a&gt;と、 &lt;code&gt;ChildStdin&lt;/code&gt; の基になるファイルハンドルが閉じられます。子プロセスが削除される前に入力でブロックされていた場合、削除後にブロックが解除されます。</target>
        </trans-unit>
        <trans-unit id="7f3df133c5feae9ef4d3689b7485515d7c0d45c0" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdout&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdout&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">&lt;code&gt;ChildStdout&lt;/code&gt; のインスタンスが&lt;a href=&quot;../ops/trait.drop&quot;&gt;削除される&lt;/a&gt;と、 &lt;code&gt;ChildStdout&lt;/code&gt; の基になるファイルハンドルが閉じられます。</target>
        </trans-unit>
        <trans-unit id="19c24a2b0ecc148719938d64be9c4f9999639c3f" translate="yes" xml:space="preserve">
          <source>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</source>
          <target state="translated">関数内でライフタイムをアノテーションする場合、アノテーションは関数本体ではなく、関数のシグネチャに行われます。Rust は、関数内のコードを何の助けも借りずに解析することができます。しかし、関数がその関数外のコードを参照している場合、Rustがパラメータや戻り値の寿命を独自に把握することはほとんど不可能になります。関数が呼び出されるたびに寿命が異なる場合があります。そのため、手動で寿命をアノテーションする必要があります。</target>
        </trans-unit>
        <trans-unit id="5eb36c8197085fe87eab8cbaf9a553875da1cc3a" translate="yes" xml:space="preserve">
          <source>When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of methods can be used to hint to the collection how much room it should make for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of these methods will be specific to the collection of interest.</source>
          <target state="translated">要素の大規模な流入を予測する場合、メソッドの &lt;code&gt;reserve&lt;/code&gt; ファミリーを使用して、次のアイテムのためにどのくらいのスペースを確保する必要があるかをコレクションに示唆できます。 &lt;code&gt;with_capacity&lt;/code&gt; と同様に、これらのメソッドの正確な動作は、対象のコレクションに固有です。</target>
        </trans-unit>
        <trans-unit id="5869f8bc191d572958f5cd39be698922927ab6f9" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">該当する場合は、安定したソートよりも高速で、補助メモリを割り当てないため、不安定なソートが推奨されます。&lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d79690f38c03573c4c869dcdef6200c1505551cc" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by&quot;&gt;&lt;code&gt;sort_unstable_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">該当する場合は、安定したソートよりも高速で、補助メモリを割り当てないため、不安定なソートが推奨されます。&lt;a href=&quot;#method.sort_unstable_by&quot;&gt; &lt;code&gt;sort_unstable_by&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e1e5b5f3c7b4b4a47f33b2043eea612fc9e4a52c" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt;&lt;code&gt;sort_unstable_by_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">該当する場合は、安定したソートよりも高速で、補助メモリを割り当てないため、不安定なソートが推奨されます。&lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt; &lt;code&gt;sort_unstable_by_key&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="19a16b324a673b29db2da7d4da32ddcedab4170b" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type, it propagates &lt;code&gt;None&lt;/code&gt;s. If the value is &lt;code&gt;None&lt;/code&gt;, then it will return &lt;code&gt;None&lt;/code&gt;. If applied to &lt;code&gt;Some(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; タイプの値に適用されると、 &lt;code&gt;None&lt;/code&gt; を伝播します。値がされていない場合は &lt;code&gt;None&lt;/code&gt; 、それは返されません &lt;code&gt;None&lt;/code&gt; 。 &lt;code&gt;Some(x)&lt;/code&gt; に適用すると、値をアンラップして &lt;code&gt;x&lt;/code&gt; に評価します。</target>
        </trans-unit>
        <trans-unit id="6010016322f07bd48e6ab713e2801cda33b2dfbc" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, it propagates errors. If the value is &lt;code&gt;Err(e)&lt;/code&gt;, then it will return &lt;code&gt;Err(From::from(e))&lt;/code&gt; from the enclosing function or closure. If applied to &lt;code&gt;Ok(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; タイプの値に適用すると、エラーが発生します。値が &lt;code&gt;Err(e)&lt;/code&gt; の場合、囲んでいる関数またはクロージャー &lt;code&gt;Err(From::from(e))&lt;/code&gt; を返します。 &lt;code&gt;Ok(x)&lt;/code&gt; に適用すると、値をアンラップして &lt;code&gt;x&lt;/code&gt; に評価します。</target>
        </trans-unit>
        <trans-unit id="6bc7928c8c171d59b0f5be17006fd056745b554a" translate="yes" xml:space="preserve">
          <source>When applied within a crate, downstream users of the crate will need to use the &lt;code&gt;_&lt;/code&gt; pattern when matching enums and use the &lt;code&gt;..&lt;/code&gt; pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</source>
          <target state="translated">クレート内で適用される場合、クレートのダウンストリームユーザーは、列挙型に一致する場合は &lt;code&gt;_&lt;/code&gt; パターンを使用し、構造体に一致する場合は &lt;code&gt;..&lt;/code&gt; パターンを使用する必要があります。下流のクレートは、非網羅的な列挙型バリアントと照合できません。</target>
        </trans-unit>
        <trans-unit id="7b7ce408de1692c1cce1be5c86062fc2d1aa15ec" translate="yes" xml:space="preserve">
          <source>When are these warnings going to turn into errors?</source>
          <target state="translated">この警告はいつになったらエラーになるんだ?</target>
        </trans-unit>
        <trans-unit id="b0d2ee129e76133ba53a5ea99826864278fbc53d" translate="yes" xml:space="preserve">
          <source>When associated with a &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop, via one of the forms &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;, where &lt;code&gt;EXPR&lt;/code&gt; is an expression whose result is returned from the &lt;code&gt;loop&lt;/code&gt;. For example:</source>
          <target state="translated">関連付けられたときに &lt;code&gt;loop&lt;/code&gt; 形のいずれかを介して、ブレークの発現は、そのループから値を返すために使用されてもよい &lt;code&gt;break EXPR&lt;/code&gt; 又は &lt;code&gt;break 'label EXPR&lt;/code&gt; 、 &lt;code&gt;EXPR&lt;/code&gt; が結果から返された式である &lt;code&gt;loop&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="c47843d04159de5ef9116ac80f96bd39967f9187" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;product()&lt;/code&gt; and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">&lt;code&gt;product()&lt;/code&gt; を呼び出し、プリミティブ整数型が返されている場合、計算がオーバーフローしてデバッグアサーションが有効になっていると、メソッドはパニックになります。</target>
        </trans-unit>
        <trans-unit id="e4216881c81bce1d1b8084df44f2b67955efbb5a" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">&lt;code&gt;sum()&lt;/code&gt; を呼び出し、プリミティブ整数型が返されているときに、計算がオーバーフローし、デバッグアサーションが有効になっている場合、このメソッドはパニックになります。</target>
        </trans-unit>
        <trans-unit id="ad8c85712072b3d065a1d9c78cdc29d373ce9764" translate="yes" xml:space="preserve">
          <source>When calling methods with the same name, you&amp;rsquo;ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we&amp;rsquo;ve defined two traits, &lt;code&gt;Pilot&lt;/code&gt; and &lt;code&gt;Wizard&lt;/code&gt;, that both have a method called &lt;code&gt;fly&lt;/code&gt;. We then implement both traits on a type &lt;code&gt;Human&lt;/code&gt; that already has a method named &lt;code&gt;fly&lt;/code&gt; implemented on it. Each &lt;code&gt;fly&lt;/code&gt; method does something different.</source>
          <target state="translated">同じ名前のメソッドを呼び出す場合、どのメソッドを使用するかをRustに通知する必要があります。リスト19-16のコードで、 &lt;code&gt;Pilot&lt;/code&gt; と &lt;code&gt;Wizard&lt;/code&gt; の 2つのトレイトを定義しました。どちらにも &lt;code&gt;fly&lt;/code&gt; というメソッドがあります。次に、 &lt;code&gt;fly&lt;/code&gt; というメソッドがすでに実装されているタイプ &lt;code&gt;Human&lt;/code&gt; に両方の特性を実装します。それぞれの &lt;code&gt;fly&lt;/code&gt; メソッドは別のことを行います。</target>
        </trans-unit>
        <trans-unit id="58559539ea94cb174e20c16d3a491d3f60daa52c" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">このメソッドを呼び出すときは、ポインターがNULLでない場合、ポインターが正しく整列され、逆参照可能（ &lt;code&gt;T&lt;/code&gt; のサイズ全体に対して）であり、初期化された &lt;code&gt;T&lt;/code&gt; のインスタンスを指すようにする必要があります。これは、このメソッドの結果が未使用の場合でも適用されます。 （初期化される部分はまだ完全には決定されていませんが、それが唯一の安全なアプローチになるまでは、それらが実際に初期化されることを確認することです。）</target>
        </trans-unit>
        <trans-unit id="154fd499f0df8e4395e27a0bd336a9bcab4964e5" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">このメソッドを呼び出すときは、ポインターがNULLでない場合、ポインターが正しく整列され、逆参照可能（ &lt;code&gt;T&lt;/code&gt; のサイズ全体に対して）であり、初期化された &lt;code&gt;T&lt;/code&gt; のインスタンスを指すようにする必要があります。これは、このメソッドの結果が未使用の場合でも適用されます。（初期化される部分はまだ完全には決定されていませんが、それが決定されるまでは、安全なアプローチは、それらが実際に初期化されていることを確認することです。）</target>
        </trans-unit>
        <trans-unit id="b55e6ba28b9895615b66213ef2f73826e6f58739" translate="yes" xml:space="preserve">
          <source>When can my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">タイプはいつ &lt;code&gt;Copy&lt;/code&gt; できますか？</target>
        </trans-unit>
        <trans-unit id="cee1d8053db523d0e331e35fb72c4806ed64bb77" translate="yes" xml:space="preserve">
          <source>When casting, keep in mind that only primitive types can be cast into each other. Example:</source>
          <target state="translated">キャストする際には、プリミティブ型だけがお互いにキャストできることを覚えておいてください。例</target>
        </trans-unit>
        <trans-unit id="d4a2dc7caf12d861d68e9e941b267ef0330f899f" translate="yes" xml:space="preserve">
          <source>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their addition data compared.</source>
          <target state="translated">ポインターを比較する場合、それらはポインターが指すものではなく、アドレスによって比較されます。&lt;a href=&quot;../dynamically-sized-types&quot;&gt;動的にサイズ設定された型&lt;/a&gt;へのポインターを比較するとき、それらはまた、それらの加算データが比較されます。</target>
        </trans-unit>
        <trans-unit id="c1a443c0cb167970fd613da945b3f247baaf5ed2" translate="yes" xml:space="preserve">
          <source>When comparison is impossible:</source>
          <target state="translated">比較が不可能な場合。</target>
        </trans-unit>
        <trans-unit id="042e1556a905fd63df9a9011e6b9eaa088ecbd8b" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">ロードと組み合わせた場合、ロードされた値が&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;（またはより強い）順序のストアオペレーションによって書き込まれた場合、後続のすべてのオペレーションはそのストアの後に順序付けされます。特に、以降のすべてのロードでは、ストアの前に書き込まれたデータが表示されます。</target>
        </trans-unit>
        <trans-unit id="a96f1d52823f389b197a0d9cfba10684464e92e3" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">ストアと組み合わせると、以前のすべての操作が、&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;（またはより強い）順序付けでこの値がロードされる前に順序付けされます。特に、以前のすべての書き込みは、この値の&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;（またはより強力な）ロードを実行するすべてのスレッドに表示されます。</target>
        </trans-unit>
        <trans-unit id="91d1a77fcc1e6a3499230bbe1efaa4ab2267c420" translate="yes" xml:space="preserve">
          <source>When creating immutable and mutable references, we use the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; syntax, respectively. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we use the &lt;code&gt;borrow&lt;/code&gt; and &lt;code&gt;borrow_mut&lt;/code&gt; methods, which are part of the safe API that belongs to &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;borrow&lt;/code&gt; method returns the smart pointer type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;borrow_mut&lt;/code&gt; returns the smart pointer type &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt;. Both types implement &lt;code&gt;Deref&lt;/code&gt;, so we can treat them like regular references.</source>
          <target state="translated">不変および可変の参照を作成するときは、それぞれ &lt;code&gt;&amp;amp;&lt;/code&gt; および &lt;code&gt;&amp;amp;mut&lt;/code&gt; 構文を使用します。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 、我々は使用 &lt;code&gt;borrow&lt;/code&gt; と &lt;code&gt;borrow_mut&lt;/code&gt; に属している安全なAPIの一部である方法、 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 。 &lt;code&gt;borrow&lt;/code&gt; 方法は、スマートポインタ型返し &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 、そして &lt;code&gt;borrow_mut&lt;/code&gt; 戻るスマートポインタ型 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 。どちらのタイプも &lt;code&gt;Deref&lt;/code&gt; を実装しているため、通常の参照のように扱うことができます。</target>
        </trans-unit>
        <trans-unit id="d153302e6c43d39140a619c03bdcafd574d25849" translate="yes" xml:space="preserve">
          <source>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. Using procedural macros looks like the code in Listing 19-29, where &lt;code&gt;some_attribute&lt;/code&gt; is a placeholder for using a specific macro.</source>
          <target state="translated">手続き型マクロを作成する場合、定義は特別なクレートタイプの独自のクレートに存在する必要があります。これは複雑な技術上の理由により、将来的には排除したいと考えています。手続き型マクロの使用はリスト19-29のコードのように見えます。ここで、 &lt;code&gt;some_attribute&lt;/code&gt; は特定のマクロを使用するためのプレースホルダーです。</target>
        </trans-unit>
        <trans-unit id="ba2b321ad5c05c7fd09164d2ee9abbba93ac268f" translate="yes" xml:space="preserve">
          <source>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</source>
          <target state="translated">ジェネリックを使用する関数を定義する際には、通常はパラメータと戻り値のデータ型を指定するような関数のシグネチャにジェネリックを配置します。このようにすることで、コードがより柔軟になり、コードの重複を防ぎながら、関数の呼び出し元により多くの機能を提供することができます。</target>
        </trans-unit>
        <trans-unit id="649a6e7ed2c9379226547d6e7e75e552d9d288ba" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">再帰的な構造体または列挙型を定義する場合、定義内から定義される型の使用は、ポインタ（ &lt;code&gt;Box&lt;/code&gt; や &lt;code&gt;&amp;amp;&lt;/code&gt; など）の後ろで発生する必要があります。これは、構造体と列挙型には明確に定義されたサイズが必要であり、ポインタがない場合、型のサイズは無制限である必要があるためです。</target>
        </trans-unit>
        <trans-unit id="2c7f1bc79b8fb9a6a685b72bb3e271975e8e2732" translate="yes" xml:space="preserve">
          <source>When derived on structs, &lt;code&gt;PartialOrd&lt;/code&gt; compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; は、構造体で派生した場合、構造体定義にフィールドが出現する順序で各フィールドの値を比較することにより、2つのインスタンスを比較します。enumから派生した場合、enum定義の早い段階で宣言されたenumのバリアントは、後でリストされているバリアントよりも少ないと見なされます。</target>
        </trans-unit>
        <trans-unit id="f282c8c6369ef0fd139eb8e2fef3f5aed8dab06e" translate="yes" xml:space="preserve">
          <source>When enabled, this socket is allowed to send packets to a broadcast address.</source>
          <target state="translated">有効にすると、このソケットはブロードキャストアドレスにパケットを送信することができます。</target>
        </trans-unit>
        <trans-unit id="761e5afed23cf69a708babbaebf38541084e7e71" translate="yes" xml:space="preserve">
          <source>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final expression is executed, if given.</source>
          <target state="translated">ブロック式を評価する場合、項目宣言文を除いた各文は順次実行されます。そして、与えられた場合には最終的な式が実行されます。</target>
        </trans-unit>
        <trans-unit id="ee1fcd0e31ceced99f1f3ec881706ad2610edecf" translate="yes" xml:space="preserve">
          <source>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The &lt;code&gt;ident&lt;/code&gt;, &lt;code&gt;lifetime&lt;/code&gt;, and &lt;code&gt;tt&lt;/code&gt; fragment types are an exception, and &lt;em&gt;can&lt;/em&gt; be matched by literal tokens. The following illustrates this restriction:</source>
          <target state="translated">たとえば、一致したフラグメントを別のマクロに転送する場合、2番目のマクロのマッチャーには、フラグメントタイプの不透明なASTが表示されます。2番目のマクロは、リテラルトークンを使用してマッチャー内のフラグメントを照合することはできず、同じタイプのフラグメント指定子のみを使用できます。 &lt;code&gt;ident&lt;/code&gt; 、 &lt;code&gt;lifetime&lt;/code&gt; 、および &lt;code&gt;tt&lt;/code&gt; 断片の種類は例外であり、そして&lt;em&gt;でき&lt;/em&gt;リテラルトークンにマッチします。この制限を次に示します。</target>
        </trans-unit>
        <trans-unit id="7c0607e7e68ca3e721e6db0ea6bb7b2aa2a0922c" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;code&gt;poll&lt;/code&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;code&gt;poll&lt;/code&gt; implementation).</source>
          <target state="translated">&lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;コンビネータを実装する場合、 &lt;code&gt;poll&lt;/code&gt; を呼び出すためにそれらへの固定された参照を取得する必要があるため、ネストされたfutureの構造的な固定が必要になります。ただし、ピン留めする必要のない他のデータがコンビネータに含まれている場合は、それらのフィールドを構造化せずに、 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; （独自の &lt;code&gt;poll&lt;/code&gt; 実装など）がある場合でも、可変参照で自由にアクセスできます。）。</target>
        </trans-unit>
        <trans-unit id="83728ab8db088c5c5e2bb91d0aa5ec68f4bff8ed" translate="yes" xml:space="preserve">
          <source>When implementing a format trait for your own type, you will have to implement a method of the signature:</source>
          <target state="translated">自身の型にフォーマットの形質を実装する場合は、署名のメソッドを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="3b12d14018112fa67f152d3bcca4ff8a3cd2e160" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">&lt;code&gt;ExactSizeIterator&lt;/code&gt; を実装する場合は、&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;も実装する必要があります。その場合、&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt;の実装はイテレータの正確なサイズを返す&lt;em&gt;必要&lt;/em&gt;があります。</target>
        </trans-unit>
        <trans-unit id="fc5662685206bca89b1530dcc1f9af41c4eb9eca" translate="yes" xml:space="preserve">
          <source>When implementing both &lt;code&gt;Hash&lt;/code&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;, it is important that the following property holds:</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; と&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; の&lt;/a&gt;両方を実装する場合、次のプロパティが保持されていることが重要です。</target>
        </trans-unit>
        <trans-unit id="d4e13d31485717c35b3ad17ef91b724897ba5adb" translate="yes" xml:space="preserve">
          <source>When implementing this trait for &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; we need to pick a type for &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. And since converting a string into a string will never result in an error, the appropriate type is &lt;code&gt;!&lt;/code&gt;. (Currently the type actually used is an enum with no variants, though this is only because &lt;code&gt;!&lt;/code&gt; was added to Rust at a later date and it may change in the future.) With an &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type of &lt;code&gt;!&lt;/code&gt;, if we have to call &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;String::from_str&lt;/code&gt;&lt;/a&gt; for some reason the result will be a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt;&lt;/a&gt; which we can unpack like this:</source>
          <target state="translated">&lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;にこの特性を実装する場合、&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; の&lt;/a&gt;タイプを選択する必要があります。また、文字列を文字列に変換してもエラーにはなりませんので、適切なタイプは &lt;code&gt;!&lt;/code&gt; 。（現在実際に使用されているタイプはバリアントのない列挙型ですが、これは &lt;code&gt;!&lt;/code&gt; が後でRustに追加されたためであり、将来的に変更される可能性があります。）&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;タイプ &lt;code&gt;!&lt;/code&gt; 、何らかの理由で&lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;String::from_str&lt;/code&gt; &lt;/a&gt;を呼び出す必要がある場合、結果は&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt; &lt;/a&gt;ように展開できます。</target>
        </trans-unit>
        <trans-unit id="7aa4b7fd6580c50f7056a94460fc482fde8db6bd" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;code&gt;Slice&lt;/code&gt; you simply provide the value &lt;code&gt;PhantomData&lt;/code&gt; for the field &lt;code&gt;phantom&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Slice&lt;/code&gt; を初期化するときは、フィールド &lt;code&gt;phantom&lt;/code&gt; に値 &lt;code&gt;PhantomData&lt;/code&gt; を指定するだけです。</target>
        </trans-unit>
        <trans-unit id="891072d4b25628183370abc4a215b4cbe1b78b5f" translate="yes" xml:space="preserve">
          <source>When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write &lt;code&gt;fieldname&lt;/code&gt; as a shorthand for &lt;code&gt;fieldname: fieldname&lt;/code&gt;. This allows a compact syntax with less duplication. For example:</source>
          <target state="translated">名前の（しかし、番号なし）フィールドを持つデータ構造体（構造体、列挙型、労働組合）を初期化する場合は、書き込みを許可されている &lt;code&gt;fieldname&lt;/code&gt; の省略形として &lt;code&gt;fieldname: fieldname&lt;/code&gt; 。これにより、重複の少ないコンパクトな構文が可能になります。例えば：</target>
        </trans-unit>
        <trans-unit id="8ecea1e59f3ed90e0cce7be9457c55eec0b2f8dd" translate="yes" xml:space="preserve">
          <source>When invoking closures or other implementations of the function traits &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; using call notation, the number of parameters passed to the function must match its definition.</source>
          <target state="translated">呼び出し表記を使用してクロージャーまたは関数トレイト &lt;code&gt;Fn&lt;/code&gt; 、 &lt;code&gt;FnMut&lt;/code&gt; 、または &lt;code&gt;FnOnce&lt;/code&gt; の他の実装を呼び出す場合、関数に渡されるパラメーターの数はその定義と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="ccc9f327284b4385f76159eac1f35c501745b8a3" translate="yes" xml:space="preserve">
          <source>When looking for the implementation for the trait, the compiler finds both the &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; where T is all types and the &lt;code&gt;impl MyTrait for Foo&lt;/code&gt;. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</source>
          <target state="translated">トレイトの実装を探すとき、コンパイラーは &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; のimpl &amp;lt;T&amp;gt; MyTrait（ Tはすべての型）と &lt;code&gt;impl MyTrait for Foo&lt;/code&gt; ます。特性は複数回実装できないため、これはエラーです。だから、あなたが書くとき：</target>
        </trans-unit>
        <trans-unit id="696c7265bd3688072f55c2cbcd990beecd847885" translate="yes" xml:space="preserve">
          <source>When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</source>
          <target state="translated">メソッドの呼び出しを検索する際に、メソッドを呼び出すために受信機が自動的に派生したり、借用されたりすることがあります。これは、呼び出す可能性のあるメソッドが多数存在する可能性があるため、他の関数の場合よりも複雑なルックアップ処理が必要となります。以下のような手順で行います。</target>
        </trans-unit>
        <trans-unit id="9b2a422583a7efee3ed72f17d4f2851e1858e60e" translate="yes" xml:space="preserve">
          <source>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</source>
          <target state="translated">範囲に対してマッチングするとき、コンパイラは範囲が空でないことを確認します。範囲パターンには両方のエンドポイントが含まれるため、これは範囲の開始点が範囲の終了点以下であることを要求するのと同じです。</target>
        </trans-unit>
        <trans-unit id="b9653a3e395619856456d73e03e247c655234f5c" translate="yes" xml:space="preserve">
          <source>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</source>
          <target state="translated">排他的な範囲とマッチングするとき、コンパイラはその範囲が空でないことを確認します。排他的な範囲パターンには開始点は含まれますが、終了点は含まれないため、これは範囲の開始点が範囲の終了点よりも小さいことを要求するのと同じです。</target>
        </trans-unit>
        <trans-unit id="8087590aa98711c0675fa786398706bd350ddbdc" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</source>
          <target state="translated">変数にマッチする際には、マッチガードの中で変異させることはできません。</target>
        </trans-unit>
        <trans-unit id="c917207922c15bc47219fc846ecafbebb3833877" translate="yes" xml:space="preserve">
          <source>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when &lt;code&gt;Cargo.toml&lt;/code&gt; doesn't specify a crate name, Cargo will transparently replace &lt;code&gt;-&lt;/code&gt; with &lt;code&gt;_&lt;/code&gt; (Refer to &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; for more details).</source>
          <target state="translated">Rustクレートに名前を付ける場合、ハイフンは使用できません。ただし、Cargoパッケージはそれらを使用する場合があります。そのような場合、 &lt;code&gt;Cargo.toml&lt;/code&gt; がクレート名を指定しないと、Cargoは &lt;code&gt;-&lt;/code&gt; を &lt;code&gt;_&lt;/code&gt; に透過的に置き換え&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;ます&lt;/a&gt;（詳細については、RFC 940を参照してください）。</target>
        </trans-unit>
        <trans-unit id="4b84b0246e3a22cc957323594b187a4ee8d486c1" translate="yes" xml:space="preserve">
          <source>When only a single thread is involved, the results are as expected: the line &lt;code&gt;7 4 4&lt;/code&gt; gets printed.</source>
          <target state="translated">1つのスレッドのみが関係している場合、結果は期待どおりです。74 &lt;code&gt;7 4 4&lt;/code&gt; 行が出力されます。</target>
        </trans-unit>
        <trans-unit id="631b2d61cf855b93c1989c5cb6e1c8291602cdf2" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">コンソールで操作する場合、このストリームのWindows実装はUTF-8以外のバイト列をサポートしていません。有効な UTF-8 でないバイトを読み取ろうとすると、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="dbaed3bc410762aacbeb0a4e72c167df5ec7b452" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">コンソールで操作する場合、このストリームのWindows実装はUTF-8以外のバイト列をサポートしていません。有効な UTF-8 でないバイトを書こうとすると、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="6a8905858177aefd0e233b7b17c0d7132a07f2ef" translate="yes" xml:space="preserve">
          <source>When parsing the path, there is a small amount of normalization:</source>
          <target state="translated">パスを解析する際に、正規化が少しあります。</target>
        </trans-unit>
        <trans-unit id="3822f9e7b18bc62d671d8d3984cc7775a10aa571" translate="yes" xml:space="preserve">
          <source>When re-exporting a private item, it can be thought of as allowing the &quot;privacy chain&quot; being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</source>
          <target state="translated">プライベートなアイテムを再輸出する場合、通常のように名前空間階層を通過するのではなく、再輸出によって &quot;プライバシーチェーン &quot;が短絡されることを許容していると考えることができます。</target>
        </trans-unit>
        <trans-unit id="9af3e2801218bbefe9fcf6ba2cdb6292e76c830f" translate="yes" xml:space="preserve">
          <source>When referred to, a &lt;em&gt;function&lt;/em&gt; yields a first-class &lt;em&gt;value&lt;/em&gt; of the corresponding zero-sized &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;function item type&lt;/em&gt;&lt;/a&gt;, which when called evaluates to a direct call to the function.</source>
          <target state="translated">&lt;em&gt;関数&lt;/em&gt;が参照されると、対応するゼロサイズの&lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;関数項目typeの&lt;/em&gt;&lt;/a&gt;ファーストクラスの&lt;em&gt;値&lt;/em&gt;が生成されます。これは、呼び出されると、関数への直接呼び出しとして評価されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1683091416dacec74442beb6b8e2ae04cddfafa2" translate="yes" xml:space="preserve">
          <source>When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its &lt;em&gt;function item type&lt;/em&gt;. That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</source>
          <target state="translated">関数アイテム、またはタプルのような構造体または列挙型バリアントのコンストラクターが参照されると、その&lt;em&gt;関数アイテムタイプの&lt;/em&gt;サイズがゼロの値が生成されます。その型は関数を明示的に識別します-名前、型引数、およびアーリーバインドライフタイム引数（ただし、レイトバインドライフタイム引数はありません。これらは関数が呼び出されたときにのみ割り当てられます）-したがって、値に含める必要はありません実際の関数ポインター。関数が呼び出されたときに間接指定は必要ありません。</target>
        </trans-unit>
        <trans-unit id="242796f19057c3b62462e9cba8dd8c2590aadff7" translate="yes" xml:space="preserve">
          <source>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</source>
          <target state="translated">繰り返しが含まれている場合は、分離器を考慮に入れて、可能な限りの数の拡張にルールが適用されます。これは意味します。</target>
        </trans-unit>
        <trans-unit id="c3d84541bce134cd9e4b390eb66c9f391f2b9c11" translate="yes" xml:space="preserve">
          <source>When requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via &lt;code&gt;{:x}&lt;/code&gt; (like &lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;). The current mapping of types to traits is:</source>
          <target state="translated">引数が特定のタイプでフォーマットされることを要求するとき、実際には、引数が特定の特性に帰することを要求しています。これにより、複数の実際のタイプを &lt;code&gt;{:x}&lt;/code&gt; を介してフォーマットできます（&lt;a href=&quot;../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; など&lt;/a&gt;）。タイプとトレイトの現在のマッピングは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="172f2234ac85fe1a3605f2a91c946d179cec1a7e" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0).</source>
          <target state="translated">戻り値がオーバーフローすると（つまり、 &lt;code&gt;uN&lt;/code&gt; 型の &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; ）、デバッグモードでパニックになり、リリースモードで戻り値が0にラップされます（メソッドが0を返すことができる唯一の状況）。 。</target>
        </trans-unit>
        <trans-unit id="edd8cc343e5de387a9b54e7b83ae697de445cc0a" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), overflows to &lt;code&gt;2^N = 0&lt;/code&gt;.</source>
          <target state="translated">戻り値がオーバーフローする場合（つまり、 &lt;code&gt;uN&lt;/code&gt; 型の &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; ）、オーバーフローして &lt;code&gt;2^N = 0&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="ba5cb533c56f4e80ee649a64f4f48b9916ee9878" translate="yes" xml:space="preserve">
          <source>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does &lt;em&gt;not&lt;/em&gt; refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the &lt;code&gt;longest&lt;/code&gt; function that won&amp;rsquo;t compile:</source>
          <target state="translated">関数から参照を返す場合、戻り値の型の有効期間パラメーターは、いずれかのパラメーターの有効期間パラメーターと一致する必要があります。返された参照がパラメーターの1つを参照してい&lt;em&gt;ない&lt;/em&gt;場合は、この関数内で作成された値を参照する必要があります。これは、値が関数の最後でスコープ外になるため、ぶら下がり参照になります。コンパイルされない &lt;code&gt;longest&lt;/code&gt; 関数のこの試みられた実装を検討してください：</target>
        </trans-unit>
        <trans-unit id="9ba5a0cad76ddab0bb154107936aabf9c3bbc80c" translate="yes" xml:space="preserve">
          <source>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</source>
          <target state="translated">リスト16-10のコードを実行するとき、それぞれの行の間に1秒の一時停止がある次のような出力が表示されるはずです。</target>
        </trans-unit>
        <trans-unit id="6b236fc247e64f3c8aa065d156b22dcb57f154a9" translate="yes" xml:space="preserve">
          <source>When searching for a value in the map, however, having to provide a reference to a &lt;code&gt;K&lt;/code&gt; as the key to search for would require to always create such an owned value. For string keys, this would mean a &lt;code&gt;String&lt;/code&gt; value needs to be created just for the search for cases where only a &lt;code&gt;str&lt;/code&gt; is available.</source>
          <target state="translated">ただし、マップで値を検索する場合、検索するキーとして &lt;code&gt;K&lt;/code&gt; への参照を提供する必要があるため、常にそのような所有値を作成する必要があります。文字列キーの場合、これは、 &lt;code&gt;str&lt;/code&gt; しか使用できない場合の検索のためだけに &lt;code&gt;String&lt;/code&gt; 値を作成する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="b091e7c5109a4bd476e6a41500e0c7dae79d2e20" translate="yes" xml:space="preserve">
          <source>When should &lt;code&gt;UnwindSafe&lt;/code&gt; be used?</source>
          <target state="translated">&lt;code&gt;UnwindSafe&lt;/code&gt; はいつ使用する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="e948e1fccd691ef6c810406fc6cc8816126b310a" translate="yes" xml:space="preserve">
          <source>When starting from a slice rather than an array, fallible conversion APIs can be used:</source>
          <target state="translated">配列ではなくスライスから開始する場合、フォールシブル変換APIを使用することができます。</target>
        </trans-unit>
        <trans-unit id="9972ed917e94de2af5e7cf0dfc874ef3575cd482" translate="yes" xml:space="preserve">
          <source>When such a string in &lt;code&gt;monospace&lt;/code&gt; font occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;monospace&lt;/code&gt; フォントのこのような文字列が文法内で発生する場合、それはそのような文字列テーブル生成の単一のメンバーへの暗黙的な参照です。詳細については、&lt;a href=&quot;tokens&quot;&gt;トークン&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="954b4d58192a34fc7c83e90ef17c03453e2596e2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&lt;/code&gt; on the same stream can cause data loss.</source>
          <target state="translated">とき &lt;code&gt;BufReader&lt;/code&gt; がドロップされ、そのバッファの内容は破棄されます。同じストリーム上に &lt;code&gt;BufReader&lt;/code&gt; の複数のインスタンスを作成すると、データが失われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f6535869e34b4050ebcca71930a99c22bd0cf5ef" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufWriter&lt;/code&gt; is dropped, the contents of its buffer will be written out. However, any errors that happen in the process of flushing the buffer when the writer is dropped will be ignored. Code that wishes to handle such errors must manually call &lt;a href=&quot;#method.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before the writer is dropped.</source>
          <target state="translated">とき &lt;code&gt;BufWriter&lt;/code&gt; がドロップされ、そのバッファの内容が書き出されます。ただし、ライターがドロップされたときにバッファーをフラッシュするプロセスで発生したエラーは無視されます。このようなエラーを処理するコードは、ライターが削除される前に手動で&lt;a href=&quot;#method.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="04aee49349dde3129af240e6a8534c1c64ddefad" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Deref&lt;/code&gt; trait is defined for the types involved, Rust will analyze the types and use &lt;code&gt;Deref::deref&lt;/code&gt; as many times as necessary to get a reference to match the parameter&amp;rsquo;s type. The number of times that &lt;code&gt;Deref::deref&lt;/code&gt; needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</source>
          <target state="translated">関連する型に &lt;code&gt;Deref&lt;/code&gt; トレイトが定義されている場合、Rustは型を分析し、パラメーターの型と一致する参照を取得するために必要な回数だけ &lt;code&gt;Deref::deref&lt;/code&gt; を使用します。 &lt;code&gt;Deref::deref&lt;/code&gt; を挿入する必要がある回数はコンパイル時に解決されるため、deref強制を利用しても実行時のペナルティはありません。</target>
        </trans-unit>
        <trans-unit id="31fb02d0ce651e092ef0bf35613e23e7b377e4aa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;get&lt;/code&gt; method is passed an index that is outside the vector, it returns &lt;code&gt;None&lt;/code&gt; without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that&amp;rsquo;s too large and the program gets a &lt;code&gt;None&lt;/code&gt; value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!</source>
          <target state="translated">とき &lt;code&gt;get&lt;/code&gt; メソッドは、ベクトルの外にあるインデックスが渡され、それは返さない &lt;code&gt;None&lt;/code&gt; を慌てずに。通常の状況でベクターの範囲を超える要素へのアクセスが時々発生する場合は、このメソッドを使用します。コードには、第6章で説明したように、 &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; または &lt;code&gt;None&lt;/code&gt; のいずれかを処理するロジックが含まれます。たとえば、インデックスは、数値を入力する人からのものである可能性があります。大きすぎる数値を誤って入力してプログラムが &lt;code&gt;None&lt;/code&gt; の値を取得した場合、現在のベクトルにあるアイテムの数をユーザーに通知し、有効な値を入力する機会をもう一度与えることができます。それはタイプミスが原因でプログラムをクラッシュさせるよりもユーザーフレンドリーです。</target>
        </trans-unit>
        <trans-unit id="f59c09946d769635e38aad7d10ee44a827a7f14d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn&amp;rsquo;t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our &lt;code&gt;match&lt;/code&gt; has four arms.</source>
          <target state="translated">場合 &lt;code&gt;match&lt;/code&gt; 発現実行ためには、各アームのパターンに対して得られた値とを比較します。パターンが値と一致する場合、そのパターンに関連付けられたコードが実行されます。そのパターンが値と一致しない場合、コイン選別機と同様に、実行は次のアームに続きます。必要な数の武器を用意できます。リスト6-3では、 &lt;code&gt;match&lt;/code&gt; に4つの武器があります。</target>
        </trans-unit>
        <trans-unit id="35dd3cadb8620e015a10c1b7eff5115846f46fce" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression is done, its scope ends, and so does the scope of the inner &lt;code&gt;y&lt;/code&gt;. The last &lt;code&gt;println!&lt;/code&gt; produces &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;match&lt;/code&gt; 表現は、その範囲の両端を行われ、そのため内側の範囲行い &lt;code&gt;y&lt;/code&gt; は。最後の &lt;code&gt;println!&lt;/code&gt; &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt; 生成：x = Some（5）、y = 10。</target>
        </trans-unit>
        <trans-unit id="68d6c3c2b2d97df1f5ec2a0c2cfb150473278b62" translate="yes" xml:space="preserve">
          <source>When the associated function is declared on a trait, the function can also be called with a &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; that is a path to the trait appended by the name of the trait. When this happens, it is substituted for &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt;.</source>
          <target state="translated">関連する関数がトレイトで宣言されている場合、トレイト&lt;a href=&quot;../paths&quot;&gt;へのパス&lt;/a&gt;であるパスをトレイトの名前に追加して、関数を呼び出すこともできます。これが発生すると、 &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt; 代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="bd35bbcd5c352ce9d75d44366396e7a4adb6ff6a" translate="yes" xml:space="preserve">
          <source>When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the &lt;code&gt;value&lt;/code&gt; method. This method checks whether we already have a resulting value in &lt;code&gt;self.value&lt;/code&gt; in a &lt;code&gt;Some&lt;/code&gt;; if we do, it returns the value within the &lt;code&gt;Some&lt;/code&gt; without executing the closure again.</source>
          <target state="translated">呼び出し元のコードでクロージャを評価した結果が必要な場合は、クロージャを直接呼び出すのではなく、 &lt;code&gt;value&lt;/code&gt; メソッドを呼び出します。このメソッドは、 &lt;code&gt;Some&lt;/code&gt; の &lt;code&gt;self.value&lt;/code&gt; に結果の値が既にあるかどうかを確認します。その場合、クロージャーを再度実行することなく、 &lt;code&gt;Some&lt;/code&gt; 内の値を返します。</target>
        </trans-unit>
        <trans-unit id="b1a7e675e1dcb1e2ab13e918ca4b37b70a8d5bf1" translate="yes" xml:space="preserve">
          <source>When the command line parsing logic starts getting complicated, extract it from &lt;em&gt;main.rs&lt;/em&gt; and move it to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="translated">コマンドライン解析ロジックが複雑になり始めたら、それを&lt;em&gt;main.rs&lt;/em&gt;から抽出して&lt;em&gt;lib.rs&lt;/em&gt;に移動し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f005b1e8a05e081cd9cbf74c1d92789005c2778" translate="yes" xml:space="preserve">
          <source>When the configuration predicate is true, this attribute expands out to the attributes listed after the predicate. For example, the following module will either be found at &lt;code&gt;linux.rs&lt;/code&gt; or &lt;code&gt;windows.rs&lt;/code&gt; based on the target.</source>
          <target state="translated">構成述部がtrueの場合、この属性は、述部の後にリストされている属性に展開されます。たとえば、次のモジュールは、ターゲットに基づいて &lt;code&gt;linux.rs&lt;/code&gt; または &lt;code&gt;windows.rs&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="b2cac43891907079676afac07f98ef2691d9a0f5" translate="yes" xml:space="preserve">
          <source>When the draft is done, a review of the post is requested.</source>
          <target state="translated">下書きが終わったら、ポストの見直しを依頼します。</target>
        </trans-unit>
        <trans-unit id="81c2e18caa886f869f8ca82f7d008cc861e8f29d" translate="yes" xml:space="preserve">
          <source>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</source>
          <target state="translated">空の文字列を区切り文字として使用すると、文字列の先頭と末尾とともに、文字列内のすべての文字を区切ります。</target>
        </trans-unit>
        <trans-unit id="993a1dfbbbb04483419f87e35c0750d6b041320f" translate="yes" xml:space="preserve">
          <source>When the inner scope ends, &lt;code&gt;branch&lt;/code&gt; goes out of scope and the strong count of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; decreases to 0, so its &lt;code&gt;Node&lt;/code&gt; is dropped. The weak count of 1 from &lt;code&gt;leaf.parent&lt;/code&gt; has no bearing on whether or not &lt;code&gt;Node&lt;/code&gt; is dropped, so we don&amp;rsquo;t get any memory leaks!</source>
          <target state="translated">内部スコープが終了すると、 &lt;code&gt;branch&lt;/code&gt; はスコープから外れ、 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 強いカウントが0に減少するため、その &lt;code&gt;Node&lt;/code&gt; は削除されます。 &lt;code&gt;leaf.parent&lt;/code&gt; からの弱いカウント1 は、 &lt;code&gt;Node&lt;/code&gt; がドロップされるかどうかには関係がないため、メモリリークは発生しません。</target>
        </trans-unit>
        <trans-unit id="b42ec8800c3cc9133daaff5ef361d3ea73ec622b" translate="yes" xml:space="preserve">
          <source>When the logic to be performed on the value is more complex, we may simply use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the logic afterwards.</source>
          <target state="translated">値に対して実行されるロジックがより複雑な場合は、 &lt;code&gt;entry&lt;/code&gt; APIを使用して、値が確実に初期化され、後でロジックが実行されるようにします。</target>
        </trans-unit>
        <trans-unit id="43d2b59799e2c6b4bb4b98d12d6f70c1cf49277f" translate="yes" xml:space="preserve">
          <source>When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).</source>
          <target state="translated">Rust プログラムのメインスレッドが終了すると、他のスレッドが実行中であってもプログラム全体がシャットダウンします。しかし、このモジュールは、子スレッドの終了を自動的に待つための便利な機能を提供します (つまり、join)。</target>
        </trans-unit>
        <trans-unit id="c0dc6f3a5195559f8d12308da2db6f2414d40676" translate="yes" xml:space="preserve">
          <source>When the owner goes out of scope, the value will be dropped.</source>
          <target state="translated">オーナーが範囲外になると、価値が下がってしまいます。</target>
        </trans-unit>
        <trans-unit id="59190310a1258679f5eb021233a840994f9a99c1" translate="yes" xml:space="preserve">
          <source>When the pattern doesn't match:</source>
          <target state="translated">パターンが合わない場合</target>
        </trans-unit>
        <trans-unit id="ecb20a6a7a7f25d225823e98ccb5c961dba326d7" translate="yes" xml:space="preserve">
          <source>When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. Otherwise, the next pattern, including other matches with the &lt;code&gt;|&lt;/code&gt; operator in the same arm, is tested.</source>
          <target state="translated">パターンが正常に一致すると、パターンガード式が実行されます。式の評価がtrueの場合、パターンは正常に照合されます。それ以外の場合、 &lt;code&gt;|&lt;/code&gt; との他の一致を含む次のパターン 同じアームのオペレーターがテストされます。</target>
        </trans-unit>
        <trans-unit id="b7f41ee353730e0c1a0a6d3264ef3197cc06c52f" translate="yes" xml:space="preserve">
          <source>When the post is approved, it gets published.</source>
          <target state="translated">投稿が承認されると掲載されます。</target>
        </trans-unit>
        <trans-unit id="f7ce9475a843aa2869fe7fade2558fcd95ae51c8" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work.</source>
          <target state="translated">プログラムに有効な参照がある場合、借用チェッカーは所有権と借用ルール（第4章で説明）を適用して、この参照とベクターの内容への他の参照が有効なままであることを確認します。同じスコープ内で変更可能な参照と不変の参照を含めることはできないというルールを思い出してください。このルールはリスト8-7に適用され、ベクターの最初の要素への不変の参照を保持し、最後に要素を追加しようとしますが、機能しません。</target>
        </trans-unit>
        <trans-unit id="f773a5aea5eb96eca971d71eeb66cfae58b30a5a" translate="yes" xml:space="preserve">
          <source>When the programmer has enabled &lt;code&gt;debug_assert!&lt;/code&gt; assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that &lt;code&gt;panic&lt;/code&gt; on overflow. Other kinds of builds may result in &lt;code&gt;panics&lt;/code&gt; or silently wrapped values on overflow, at the implementation's discretion.</source>
          <target state="translated">プログラマが &lt;code&gt;debug_assert!&lt;/code&gt; を有効にしたとき！アサーション（たとえば、最適化されていないビルドを有効にすることにより）、実装は、オーバーフローで &lt;code&gt;panic&lt;/code&gt; する動的チェックを挿入する必要があります。他の種類のビルドでは、実装の裁量により、 &lt;code&gt;panics&lt;/code&gt; が発生したり、オーバーフロー時に値が暗黙的にラップされたりする場合があります。</target>
        </trans-unit>
        <trans-unit id="ce3f6166f132f399bf38664a6cccbedbde5ef26e" translate="yes" xml:space="preserve">
          <source>When the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</source>
          <target state="translated">精査式が&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式である&lt;/a&gt;場合、一致は一時的な場所を割り当てません。ただし、値によるバインディングは、メモリの場所からコピーまたは移動する場合があります。これらの一致の存続期間は、一致の内部に制限されるのではなく、場所式の存続期間を継承するため、可能であれば、場所式で一致することが推奨されます。</target>
        </trans-unit>
        <trans-unit id="2c72e3065d1cd65994fce834d0430d9416ecec2e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.</source>
          <target state="translated">スライス len がチャンクサイズで均等に分割されていない場合は、反復の最後のスライスが残りとなります。</target>
        </trans-unit>
        <trans-unit id="fff85a9a955873b521d1857eca1f1e9a549be54e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">スライスlenがチャンクサイズで均等に分割されていない場合、最後の &lt;code&gt;chunk_size-1&lt;/code&gt; までの要素は省略されますが、イテレータから&lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt;関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="380f0182bf0446b4645382de4340b8f27ea208b9" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">スライスlenがチャンクサイズで均等に分割されていない場合、最後の&lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt; &lt;code&gt;into_remainder&lt;/code&gt; &lt;/a&gt; &lt;code&gt;chunk_size-1&lt;/code&gt; 要素は省略されますが、イテレータのinto_remainder関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="0cb68be86a1a45d1f6b54a16fdad69c0443b3e68" translate="yes" xml:space="preserve">
          <source>When the trailing semicolon is omitted, the result must be type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">末尾のセミコロンを省略した場合、結果はタイプ &lt;code&gt;()&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9c349a820ac0a64039fea25d4cbecfdfad33b558" translate="yes" xml:space="preserve">
          <source>When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let&amp;rsquo;s tackle that next!</source>
          <target state="translated">ベクターが削除されると、その内容もすべて削除されます。つまり、ベクターが保持する整数はクリーンアップされます。これは簡単なポイントのように思えるかもしれませんが、ベクターの要素への参照を導入し始めると、もう少し複雑になる可能性があります。次に取り組みましょう！</target>
        </trans-unit>
        <trans-unit id="045b65f5d67968ff8801369e1d99fcba44a4e94a" translate="yes" xml:space="preserve">
          <source>When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations may not appear where intended.</source>
          <target state="translated">このクロージャが実行されると、stdio ファイル記述子や作業ディレクトリのような側面が正常に変更されるため、これらの場所への出力が意図した場所に表示されないことがあります。</target>
        </trans-unit>
        <trans-unit id="9f6792fc653fbacaf2b989ced239eb6fa2deec46" translate="yes" xml:space="preserve">
          <source>When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).</source>
          <target state="translated">この関数が戻ってきたとき、何らかの初期化が実行されて完了したことが保証されます(指定されたクロージャではないかもしれません)。また、実行されたクロージャによって実行されたメモリ書き込みが、この時点で他のスレッドによって確実に観測されることも保証されています(クロージャとリターン後に実行されるコードの間には happens-before の関係があります)。</target>
        </trans-unit>
        <trans-unit id="6272391ae8d142b8a69f4da76b9108341afacf1f" translate="yes" xml:space="preserve">
          <source>When this method has been called, &lt;code&gt;self&lt;/code&gt; has not yet been deallocated. That only happens after the method is over. If this wasn't the case, &lt;code&gt;self&lt;/code&gt; would be a dangling reference.</source>
          <target state="translated">このメソッドが呼び出されたとき、 &lt;code&gt;self&lt;/code&gt; はまだ割り当て解除されていません。これは、メソッドが終了した後にのみ発生します。そうでない場合、 &lt;code&gt;self&lt;/code&gt; はぶら下がり参照になります。</target>
        </trans-unit>
        <trans-unit id="9b04566ec85e491e3fa2ae5cb87abb0c8372d784" translate="yes" xml:space="preserve">
          <source>When this program executes, it checks each &lt;code&gt;if&lt;/code&gt; expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don&amp;rsquo;t see the output &lt;code&gt;number is divisible by 2&lt;/code&gt;, nor do we see the &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; text from the &lt;code&gt;else&lt;/code&gt; block. That&amp;rsquo;s because Rust only executes the block for the first true condition, and once it finds one, it doesn&amp;rsquo;t even check the rest.</source>
          <target state="translated">このプログラムが実行されると、各 &lt;code&gt;if&lt;/code&gt; 式が順番にチェックされ、条件が真である最初の本体が実行されます。6が2で割り切れても、出力 &lt;code&gt;number is divisible by 2&lt;/code&gt; で割り切れないこと &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; 、 &lt;code&gt;else&lt;/code&gt; ブロックの4、3 、または2のテキストで割り切れないことはありません。これは、Rustが最初の真の条件に対してのみブロックを実行し、1つが見つかると、残りのチェックも行わないためです。</target>
        </trans-unit>
        <trans-unit id="f943a1cfdbb4b42ef0aab62b7f7aa8f670763652" translate="yes" xml:space="preserve">
          <source>When to Use Unsafe Code</source>
          <target state="translated">安全でないコードを使用する場合</target>
        </trans-unit>
        <trans-unit id="e49f07ac591b9df3217836c08c55df9a224df807" translate="yes" xml:space="preserve">
          <source>When to choose interior mutability</source>
          <target state="translated">内部変異性を選択するタイミング</target>
        </trans-unit>
        <trans-unit id="34bd2ffda436616fa2dd5a24ddce1b15ffc8ed97" translate="yes" xml:space="preserve">
          <source>When trying to make some type implement a trait &lt;code&gt;Foo&lt;/code&gt;, you must, at minimum, provide implementations for all of &lt;code&gt;Foo&lt;/code&gt;'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</source>
          <target state="translated">一部のタイプに特性 &lt;code&gt;Foo&lt;/code&gt; を実装させる場合、少なくとも、 &lt;code&gt;Foo&lt;/code&gt; に必要なすべてのメソッド（デフォルト実装を持たないメソッドを意味する）の実装と、関連するタイプや定数。例：</target>
        </trans-unit>
        <trans-unit id="727739e9ec606ff0128888672a6babe668ea6ab8" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeTo&lt;/code&gt; produces a slice of all array elements before the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">使用する場合&lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;、スライスインデックス&lt;/a&gt;、 &lt;code&gt;RangeTo&lt;/code&gt; はインデックスにより示される前に、すべての配列要素のスライスを生成する &lt;code&gt;end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e81866ba280f233e50444316cfe195129a341859" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeToInclusive&lt;/code&gt; produces a slice of all array elements up to and including the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">使用する場合&lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;、スライスインデックス&lt;/a&gt;、 &lt;code&gt;RangeToInclusive&lt;/code&gt; はで示されるインデックスを含むの最大すべての配列要素のスライスを生成する &lt;code&gt;end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b45521f0b2908c3126bcf39f34e601db7fa5296" translate="yes" xml:space="preserve">
          <source>When used as an item or a statement, the &lt;em&gt;MacroInvocationSemi&lt;/em&gt; form is used where a semicolon is required at the end when not using curly braces. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Visibility qualifiers&lt;/a&gt; are never allowed before a macro invocation or &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt;&lt;/a&gt; definition.</source>
          <target state="translated">アイテムまたはステートメントとして使用する場合、中括弧を使用しない場合は末尾にセミコロンが必要な場所に&lt;em&gt;MacroInvocationSemi&lt;/em&gt;フォームが使用されます。&lt;a href=&quot;visibility-and-privacy&quot;&gt;可視性修飾子&lt;/a&gt;は、マクロ呼び出しまたは&lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;macro_rules&lt;/code&gt; &lt;/a&gt;定義の前に決して許可されません。</target>
        </trans-unit>
        <trans-unit id="142d83eb0488a8e5aa5cd0f7af5b426b99a98c2b" translate="yes" xml:space="preserve">
          <source>When used on a &lt;a href=&quot;../items/traits&quot;&gt;trait declaration&lt;/a&gt;, a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; to a function that returns an &lt;a href=&quot;../types/impl-trait&quot;&gt;impl trait&lt;/a&gt; of that trait violates the &lt;code&gt;unused_must_use&lt;/code&gt; lint.</source>
          <target state="translated">&lt;a href=&quot;../items/traits&quot;&gt;特性宣言&lt;/a&gt;で使用すると、その特性の &lt;code&gt;unused_must_use&lt;/code&gt; &lt;a href=&quot;../types/impl-trait&quot;&gt;特性&lt;/a&gt;を返す関数への&lt;a href=&quot;../statements#expression-statements&quot;&gt;式ステートメントの&lt;/a&gt;&lt;a href=&quot;../expressions/call-expr&quot;&gt;呼び出し式&lt;/a&gt;は、unused_must_use lintに違反します。</target>
        </trans-unit>
        <trans-unit id="a852fccfd2a27297b4365a331af8dc1c15ac5f5a" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</source>
          <target state="translated">形質宣言の関数で使用された場合、呼び出し式が形質の実装からの関数である場合にも、この動作が適用されます。</target>
        </trans-unit>
        <trans-unit id="88cab39f222cd92692e6d511980bef189805ee7b" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait implementation, the attribute does nothing.</source>
          <target state="translated">形質実装の関数で使用された場合、この属性は何もしません。</target>
        </trans-unit>
        <trans-unit id="a38aec53cd57e4a640fb72d4c596595beee7f334" translate="yes" xml:space="preserve">
          <source>When used on a function, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; is a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; to that function, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">機能に使用された場合ならば、&lt;a href=&quot;../expressions&quot;&gt;表現&lt;/a&gt;の&lt;a href=&quot;../statements#expression-statements&quot;&gt;式文が&lt;/a&gt;ある&lt;a href=&quot;../expressions/call-expr&quot;&gt;呼び出し式&lt;/a&gt;その関数への、そして &lt;code&gt;unused_must_use&lt;/code&gt; lintは破られます。</target>
        </trans-unit>
        <trans-unit id="e4d571aee68c6431041b80e34711ac5e77b8cfc0" translate="yes" xml:space="preserve">
          <source>When used on user-defined composite types, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; has that type, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">ユーザー定義の複合型で使用&lt;a href=&quot;../expressions&quot;&gt;する&lt;/a&gt;と、&lt;a href=&quot;../statements#expression-statements&quot;&gt;式ステートメント&lt;/a&gt;の式にその型がある場合、 &lt;code&gt;unused_must_use&lt;/code&gt; lintに違反します。</target>
        </trans-unit>
        <trans-unit id="370602de292c5acf9300ec1049f6d7b0d030d468" translate="yes" xml:space="preserve">
          <source>When used with the alternate format specifier &lt;code&gt;#?&lt;/code&gt;, the output is pretty-printed.</source>
          <target state="translated">代替フォーマット指定子 &lt;code&gt;#?&lt;/code&gt; と一緒に使用した場合 、出力はきれいに出力されます。</target>
        </trans-unit>
        <trans-unit id="e3c7fb67d8df75a586e35884637385ed0d8f23ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; it may be the case that some of the closed over variables are not unwind safe. For example if &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.</source>
          <target state="translated">&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt;を使用する場合、クローズされた変数の一部がアンワインドセーフではない場合があります。たとえば、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; がキャプチャされた場合、コンパイラーはアンワインドセーフではないことを示す警告を生成します。ただし、巻き&lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt;安全性が特に考慮されている場合、catch_unwindの特定の使用法が原因でこれが実際に問題になることはありません。このラッパー構造体は、変数が本当にアンワインドセーフであるという迅速かつ軽量な注釈に役立ちます。</target>
        </trans-unit>
        <trans-unit id="b4aaf8ff7f846237ace4f0a059c82e12475ebd13" translate="yes" xml:space="preserve">
          <source>When using a future, you generally won't call &lt;code&gt;poll&lt;/code&gt; directly, but instead &lt;code&gt;.await&lt;/code&gt; the value.</source>
          <target state="translated">futureを使用する場合、通常は &lt;code&gt;poll&lt;/code&gt; を直接呼び出すのではなく、値を &lt;code&gt;.await&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="206af53865bdd4c9d82650ccc0b648e77c1d1339" translate="yes" xml:space="preserve">
          <source>When using a lifetime like &lt;code&gt;'a&lt;/code&gt; in a type, it must be declared before being used.</source>
          <target state="translated">型で &lt;code&gt;'a&lt;/code&gt; のようなライフタイムを使用する場合は、使用する前に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="783900079b0706a4642035130b0d4e5b4c18d3f8" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if promoted to &lt;code&gt;'static&lt;/code&gt;. Promotion of a value expression to a &lt;code&gt;'static&lt;/code&gt; slot occurs when the expression could be written in a constant, borrowed, and dereferencing that borrow where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain &lt;a href=&quot;interior-mutability&quot;&gt;interior mutability&lt;/a&gt; or &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; (these properties are determined based on the value where possible, e.g. &lt;code&gt;&amp;amp;None&lt;/code&gt; always has the type &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt;, as it contains nothing disallowed). Otherwise, the lifetime of temporary values is typically</source>
          <target state="translated">ほとんどの場所式コンテキストで値式を使用すると、一時的な名前のないメモリの場所が作成され、その値に初期化されます。式は、 &lt;code&gt;'static&lt;/code&gt; 昇格された場合を除き、代わりにその場所に評価されます。値式の &lt;code&gt;'static&lt;/code&gt; スロット」への昇格は、式が定数で書き込まれ、借用され、実行時の動作を変更せずに、式が最初に書き込まれた場所で借用を逆参照できる場合に発生します。つまり、昇格された式はコンパイル時に評価でき、結果の値には&lt;a href=&quot;interior-mutability&quot;&gt;内部の可変性&lt;/a&gt;や&lt;a href=&quot;destructors&quot;&gt;デストラクタ&lt;/a&gt;が含まれません（これらのプロパティは可能な限り値に基づいて決定されます。たとえば、 &lt;code&gt;&amp;amp;None&lt;/code&gt; は常に型を持っています） &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt; （許可されていないものが含まれているため）。それ以外の場合、一時的な値の有効期間は通常</target>
        </trans-unit>
        <trans-unit id="8e391fe57ab900573f61faa4d08b9fd057fe4752" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">反復に包含範囲を使用する場合、反復の終了後、&lt;a href=&quot;#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;end()&lt;/code&gt; の値は指定されません。包含的な範囲が空かどうかを判断するには、 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; を比較する代わりに&lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt;メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="b41ad7fcc2b6f72dd75060937158a4566bb3d48c" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">反復に包含範囲を使用する場合、反復の終了後、 &lt;code&gt;start()&lt;/code&gt; および&lt;a href=&quot;#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; の値&lt;/a&gt;は指定されません。包含的な範囲が空かどうかを判断するには、 &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; を比較する代わりに&lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt;メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="d88230c170cac7c9979daeb85327371e8fc8933d" translate="yes" xml:space="preserve">
          <source>When using generators (or async) all type variables must be bound so a generator can be constructed.</source>
          <target state="translated">ジェネレータ(または非同期)を使用する場合は、ジェネレータを構築できるように、すべての型変数をバインドしなければなりません。</target>
        </trans-unit>
        <trans-unit id="eb4afcd059cb498d340016957478dc07a5b0b9cd" translate="yes" xml:space="preserve">
          <source>When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to &lt;code&gt;inspect()&lt;/code&gt;.</source>
          <target state="translated">イテレータを使用する場合、複数のイテレータをチェーンすることがよくあります。このようなコードに取り組んでいるときに、パイプラインのさまざまな部分で何が起こっているかを確認したい場合があります。これを行うには、 &lt;code&gt;inspect()&lt;/code&gt; への呼び出しを挿入します。</target>
        </trans-unit>
        <trans-unit id="c5b59408fe1f6f4de1643cf5f48d4f5771ac3565" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</source>
          <target state="translated">タプル構造体で &lt;code&gt;#[simd]&lt;/code&gt; 属性を使用する場合、タプル構造体のコンポーネントはすべて具体的で非ジェネリック型である必要があります。そうすることで、コンパイラーはSIMDを使用する方法を推論できます。このエラーは、タイプがジェネリックの場合に発生します。</target>
        </trans-unit>
        <trans-unit id="39b563bb5da92b14b1bd3b2de6d3ed8ec3f0fd65" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</source>
          <target state="translated">タプル構造体で &lt;code&gt;#[simd]&lt;/code&gt; 属性を使用する場合、SIMD操作を適用できるように、タプル内の要素はマシンタイプである必要があります。</target>
        </trans-unit>
        <trans-unit id="f68c56eaa365c1195d011c5971774cffabbee19c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</source>
          <target state="translated">使用する場合は &lt;code&gt;#[simd]&lt;/code&gt; 自動的にタプル構造体にSIMD演算を使用する属性を、構造体の型は、すべて同じ型でなければなりません、またはコンパイラは、このエラーがトリガされます。</target>
        </trans-unit>
        <trans-unit id="875f23e80d105f6373be722e024a688059c93026" translate="yes" xml:space="preserve">
          <source>When we assign &lt;code&gt;s1&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;, the &lt;code&gt;String&lt;/code&gt; data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; を &lt;code&gt;s2&lt;/code&gt; に割り当てると、 &lt;code&gt;String&lt;/code&gt; データがコピーされます。つまり、スタック上にあるポインター、長さ、および容量がコピーされます。ポインターが参照するヒープ上のデータはコピーしません。つまり、メモリ内のデータ表現は図4-2のようになります。</target>
        </trans-unit>
        <trans-unit id="20dccc7faf7358ddd1e5e9048cb569181ba72e52" translate="yes" xml:space="preserve">
          <source>When we bring a name into scope with the &lt;code&gt;use&lt;/code&gt; keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code&amp;rsquo;s scope, we can combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;. This technique is called &lt;em&gt;re-exporting&lt;/em&gt; because we&amp;rsquo;re bringing an item into scope but also making that item available for others to bring into their scope.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; キーワードを使用して名前をスコープに入れると、新しいスコープで使用できる名前は非公開になります。コードを呼び出すコードがその名前をそのコードのスコープで定義されているかのように参照できるようにするには、 &lt;code&gt;pub&lt;/code&gt; とを組み合わせ &lt;code&gt;use&lt;/code&gt; 。この手法は、アイテムをスコープに含めるだけでなく、他のユーザーがそのアイテムをスコープに含めることができるように&lt;em&gt;する&lt;/em&gt;ため、&lt;em&gt;再エクスポート&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="42f15b600972fbcabaccb1f899d3d65cff52600b" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;fly&lt;/code&gt; on an instance of &lt;code&gt;Human&lt;/code&gt;, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</source>
          <target state="translated">リスト19-17に示すように、 &lt;code&gt;Human&lt;/code&gt; のインスタンスで &lt;code&gt;fly&lt;/code&gt; を呼び出すと、コンパイラーはデフォルトで、型に直接実装されているメソッドを呼び出すようになります。</target>
        </trans-unit>
        <trans-unit id="350ebfd5b3bd82b33fcb60d5557f6b4f388aac65" translate="yes" xml:space="preserve">
          <source>When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the &lt;code&gt;$x&lt;/code&gt; pattern matches three times with the three expressions &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">このマクロを &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; 呼び出すと、、 &lt;code&gt;$x&lt;/code&gt; パターンは3つの式で三回に一致する &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2&lt;/code&gt; 、および &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b6bd2715022e06e450780014c7b5af3817cebde" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get the following error message:</source>
          <target state="translated">このコードをコンパイルすると、以下のようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="d7383a66b159cf7464f68ba405d35045b37c0b59" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get this error:</source>
          <target state="translated">このコードをコンパイルすると、このようなエラーが出ます。</target>
        </trans-unit>
        <trans-unit id="5e8ce4b2651c1cb04164eadfa1df10bcf9bfb1ce" translate="yes" xml:space="preserve">
          <source>When we compile this example, we get this error:</source>
          <target state="translated">この例をコンパイルすると、このようなエラーが出ます。</target>
        </trans-unit>
        <trans-unit id="54132a8652e951367540a246425bd7e243e44e7e" translate="yes" xml:space="preserve">
          <source>When we create a new &lt;code&gt;Post&lt;/code&gt;, we set its &lt;code&gt;state&lt;/code&gt; field to a &lt;code&gt;Some&lt;/code&gt; value that holds a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; points to a new instance of the &lt;code&gt;Draft&lt;/code&gt; struct. This ensures whenever we create a new instance of &lt;code&gt;Post&lt;/code&gt;, it will start out as a draft. Because the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; is private, there is no way to create a &lt;code&gt;Post&lt;/code&gt; in any other state! In the &lt;code&gt;Post::new&lt;/code&gt; function, we set the &lt;code&gt;content&lt;/code&gt; field to a new, empty &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">新しい &lt;code&gt;Post&lt;/code&gt; を作成するとき、その &lt;code&gt;state&lt;/code&gt; フィールドを &lt;code&gt;Box&lt;/code&gt; を保持する &lt;code&gt;Some&lt;/code&gt; 値に設定します。この &lt;code&gt;Box&lt;/code&gt; は、 &lt;code&gt;Draft&lt;/code&gt; 構造体の新しいインスタンスを指します。これにより、 &lt;code&gt;Post&lt;/code&gt; の新しいインスタンスを作成するときはいつでも、ドラフトとして開始されます。 &lt;code&gt;Post&lt;/code&gt; の &lt;code&gt;state&lt;/code&gt; フィールドはプライベートなので、他の状態で &lt;code&gt;Post&lt;/code&gt; を作成する方法はありません。では &lt;code&gt;Post::new&lt;/code&gt; 機能、我々はセット &lt;code&gt;content&lt;/code&gt; 新しい空にフィールドを &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bdaf316b9ae5f73e74db4dd3cf073c814edc28e" translate="yes" xml:space="preserve">
          <source>When we create the &lt;code&gt;branch&lt;/code&gt; node, it will also have a new &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference in the &lt;code&gt;parent&lt;/code&gt; field, because &lt;code&gt;branch&lt;/code&gt; doesn&amp;rsquo;t have a parent node. We still have &lt;code&gt;leaf&lt;/code&gt; as one of the children of &lt;code&gt;branch&lt;/code&gt;. Once we have the &lt;code&gt;Node&lt;/code&gt; instance in &lt;code&gt;branch&lt;/code&gt;, we can modify &lt;code&gt;leaf&lt;/code&gt; to give it a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to its parent. We use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; in the &lt;code&gt;parent&lt;/code&gt; field of &lt;code&gt;leaf&lt;/code&gt;, and then we use the &lt;code&gt;Rc::downgrade&lt;/code&gt; function to create a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to &lt;code&gt;branch&lt;/code&gt; from the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</source>
          <target state="translated">私たちが作成した場合 &lt;code&gt;branch&lt;/code&gt; ノードを、それはまた、新しい必要があります &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; で参照 &lt;code&gt;parent&lt;/code&gt; ので、フィールドを &lt;code&gt;branch&lt;/code&gt; 親ノードを持ちません。私たちはまだ &lt;code&gt;branch&lt;/code&gt; の子の一人として &lt;code&gt;leaf&lt;/code&gt; を持っています。 &lt;code&gt;branch&lt;/code&gt; に &lt;code&gt;Node&lt;/code&gt; インスタンスを作成したら、 &lt;code&gt;leaf&lt;/code&gt; を変更して、親への &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 参照を与えることができます。私たちは、使用 &lt;code&gt;borrow_mut&lt;/code&gt; の上の方法を &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; に &lt;code&gt;parent&lt;/code&gt; の分野 &lt;code&gt;leaf&lt;/code&gt; 、その後、我々は使用 &lt;code&gt;Rc::downgrade&lt;/code&gt; 作成する機能を &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; を参照する &lt;code&gt;branch&lt;/code&gt; から &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; で &lt;code&gt;branch.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d475e631798bcfdbe8b5d49b3651bb13f536b5" translate="yes" xml:space="preserve">
          <source>When we entered &lt;code&gt;*y&lt;/code&gt; in Listing 15-9, behind the scenes Rust actually ran this code:</source>
          <target state="translated">リスト15-9で &lt;code&gt;*y&lt;/code&gt; と入力すると、Rustは実際にはこのコードを実行しました。</target>
        </trans-unit>
        <trans-unit id="022643a7b2e9e273dbb19c62148637669a0b154f" translate="yes" xml:space="preserve">
          <source>When we entered the command, Cargo created a &lt;em&gt;Cargo.toml&lt;/em&gt; file, giving us a package. Looking at the contents of &lt;em&gt;Cargo.toml&lt;/em&gt;, there&amp;rsquo;s no mention of &lt;em&gt;src/main.rs&lt;/em&gt; because Cargo follows a convention that &lt;em&gt;src/main.rs&lt;/em&gt; is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains &lt;em&gt;src/lib.rs&lt;/em&gt;, the package contains a library crate with the same name as the package, and &lt;em&gt;src/lib.rs&lt;/em&gt; is its crate root. Cargo passes the crate root files to &lt;code&gt;rustc&lt;/code&gt; to build the library or binary.</source>
          <target state="translated">コマンドを入力すると、Cargoは&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルを作成し、パッケージを提供します。&lt;em&gt;Cargo.toml&lt;/em&gt;の内容を見ると、&lt;em&gt;src / main.rs&lt;/em&gt;はパッケージと同じ名前のバイナリクレートのクレートルートであるという規則に従っているため、&lt;em&gt;src / main.rs&lt;/em&gt;についての言及はありません。同様に、Cargoは、パッケージディレクトリに&lt;em&gt;src / lib.rs&lt;/em&gt;が含まれている場合、パッケージにパッケージと同じ名前のライブラリクレートが含まれており、&lt;em&gt;src / lib.rs&lt;/em&gt;がそのクレートルートであることを&lt;em&gt;認識してい&lt;/em&gt;ます。 Cargoはクレートルートファイルを &lt;code&gt;rustc&lt;/code&gt; に渡して、ライブラリまたはバイナリをビルドします。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="457abff93dbe5ac6fded48fa1428f69ee83409b3" translate="yes" xml:space="preserve">
          <source>When we have a &lt;code&gt;Some&lt;/code&gt; value, we know that a value is present and the value is held within the &lt;code&gt;Some&lt;/code&gt;. When we have a &lt;code&gt;None&lt;/code&gt; value, in some sense, it means the same thing as null: we don&amp;rsquo;t have a valid value. So why is having &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; any better than having null?</source>
          <target state="translated">&lt;code&gt;Some&lt;/code&gt; 値がある場合、値が存在し、その値が &lt;code&gt;Some&lt;/code&gt; 内に保持されていることがわかります。 &lt;code&gt;None&lt;/code&gt; 値がある場合、ある意味で、それはnullと同じことを意味します。有効な値がありません。では、なぜ &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; するのがnullを使用するよりも優れているのでしょうか。</target>
        </trans-unit>
        <trans-unit id="f020ca74b67fee23ca0497cca95821474c7cc12b" translate="yes" xml:space="preserve">
          <source>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they&amp;rsquo;re related to the struct fields or the method parameters and return values.</source>
          <target state="translated">ライフタイムのある構造体にメソッドを実装する場合、リスト10-11に示されているジェネリック型パラメーターと同じ構文を使用します。ライフタイムパラメータを宣言して使用する場所は、それらが構造体フィールドに関連しているか、メソッドパラメータと戻り値に関連しているかによって異なります。</target>
        </trans-unit>
        <trans-unit id="a57e5870f2a33156805f7bdbcc9a94b3975d0971" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;RHS&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;RHS&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">&lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; を実装したとき、2つの &lt;code&gt;Point&lt;/code&gt; インスタンスを追加したかったので、 &lt;code&gt;RHS&lt;/code&gt; のデフォルトを使用しました。デフォルトを使用するのではなく、 &lt;code&gt;RHS&lt;/code&gt; タイプをカスタマイズする &lt;code&gt;Add&lt;/code&gt; トレイトの実装例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="59b1449687c25748d2619d5b3c608f432cee9ffd" translate="yes" xml:space="preserve">
          <source>When we look at &lt;em&gt;src/main.rs&lt;/em&gt; again, we&amp;rsquo;ll see that &lt;code&gt;cargo fix&lt;/code&gt; has changed the code:</source>
          <target state="translated">私たちが見たとき&lt;em&gt;のsrc / main.rs&lt;/em&gt;再び、我々はそれを参照してくださいよ &lt;code&gt;cargo fix&lt;/code&gt; 、コードを変更しました：</target>
        </trans-unit>
        <trans-unit id="7a54ab2951cd6fff0884c0511bb61b6ab512dff0" translate="yes" xml:space="preserve">
          <source>When we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module helps you start writing your tests so you don&amp;rsquo;t have to look up the exact structure and syntax of test functions every time you start a new project. You can add as many additional test functions and as many test modules as you want!</source>
          <target state="translated">Cargoで新しいライブラリプロジェクトを作成すると、テスト関数を含むテストモジュールが自動的に生成されます。このモジュールは、新しいプロジェクトを開始するたびにテスト関数の正確な構造と構文を調べる必要がないように、テストの作成を開始するのに役立ちます。追加のテスト機能とテストモジュールをいくつでも追加できます。</target>
        </trans-unit>
        <trans-unit id="c17714721f7f441933c167091091578db54d0995" translate="yes" xml:space="preserve">
          <source>When we pass concrete references to &lt;code&gt;longest&lt;/code&gt;, the concrete lifetime that is substituted for &lt;code&gt;'a&lt;/code&gt; is the part of the scope of &lt;code&gt;x&lt;/code&gt; that overlaps with the scope of &lt;code&gt;y&lt;/code&gt;. In other words, the generic lifetime &lt;code&gt;'a&lt;/code&gt; will get the concrete lifetime that is equal to the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Because we&amp;rsquo;ve annotated the returned reference with the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;, the returned reference will also be valid for the length of the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;longest&lt;/code&gt; への具体的な参照を渡す場合、 &lt;code&gt;'a&lt;/code&gt; に置き換えられる具体的な寿命は、 &lt;code&gt;y&lt;/code&gt; のスコープと重複する &lt;code&gt;x&lt;/code&gt; のスコープの一部です。言い換えると、一般的なライフタイム &lt;code&gt;'a&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のライフタイムのうち小さい方に等しい具体的なライフタイムを取得します。返された参照には同じ有効期間パラメーター &lt;code&gt;'a&lt;/code&gt; で注釈を付けているため、返された参照は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の有効期間の短い方の長さについても有効です。</target>
        </trans-unit>
        <trans-unit id="a267d1c9dce3d09c3ccaaec536f47b38cd5559e0" translate="yes" xml:space="preserve">
          <source>When we print &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we can see that they all have the modified value of 15 rather than 5:</source>
          <target state="translated">我々は印刷すると、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; 、我々は、彼らがすべての15ではなく5の修正値を持っていることを確認できます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e6d697346a86084beb1a95157687a62dfdd661aa" translate="yes" xml:space="preserve">
          <source>When we print the parent of &lt;code&gt;leaf&lt;/code&gt; again, this time we&amp;rsquo;ll get a &lt;code&gt;Some&lt;/code&gt; variant holding &lt;code&gt;branch&lt;/code&gt;: now &lt;code&gt;leaf&lt;/code&gt; can access its parent! When we print &lt;code&gt;leaf&lt;/code&gt;, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; references are printed as &lt;code&gt;(Weak)&lt;/code&gt;:</source>
          <target state="translated">私たちは親の印刷時に &lt;code&gt;leaf&lt;/code&gt; 再び、今回は買ってあげる &lt;code&gt;Some&lt;/code&gt; 変種保持 &lt;code&gt;branch&lt;/code&gt; ：今、 &lt;code&gt;leaf&lt;/code&gt; その親にアクセスすることができます！ &lt;code&gt;leaf&lt;/code&gt; を出力するとき、リスト15-26のようにスタックオーバーフローで最終的に終了するサイクルも回避します。 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; 参考文献は、以下のように印刷されている &lt;code&gt;(Weak)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d6ae0ddb23c20f16f914c98f6cadf070ae827274" translate="yes" xml:space="preserve">
          <source>When we run &lt;code&gt;cargo doc --open&lt;/code&gt;, these comments will display on the front page of the documentation for &lt;code&gt;my_crate&lt;/code&gt; above the list of public items in the crate, as shown in Figure 14-2:</source>
          <target state="translated">図14-2に示すように、 &lt;code&gt;cargo doc --open&lt;/code&gt; を実行すると、これらのコメントは、クレート内のパブリックアイテムのリストの上にある &lt;code&gt;my_crate&lt;/code&gt; のドキュメントのフロントページに表示されます。</target>
        </trans-unit>
        <trans-unit id="e0a9b14cc5672cde13757ff7b922b97b778df10c" translate="yes" xml:space="preserve">
          <source>When we run the code in Listing 16-8, we&amp;rsquo;ll see the value printed from the main thread:</source>
          <target state="translated">リスト16-8のコードを実行すると、メインスレッドから出力された値が表示されます：</target>
        </trans-unit>
        <trans-unit id="b9d752c4fc202642188fd8ee33a406138a554856" translate="yes" xml:space="preserve">
          <source>When we run the program now, we get this:</source>
          <target state="translated">今プログラムを実行するとこんな感じです。</target>
        </trans-unit>
        <trans-unit id="8c0106d7279651b49f13e37d40b4d1b5d7049633" translate="yes" xml:space="preserve">
          <source>When we run the test in Listing 11-8, it will fail:</source>
          <target state="translated">リスト11-8のテストを実行すると失敗します。</target>
        </trans-unit>
        <trans-unit id="44d32483b028a29165bad05ab4f3b2f5da955011" translate="yes" xml:space="preserve">
          <source>When we run the tests again, we&amp;rsquo;ll see a new section in the test output for the &lt;em&gt;common.rs&lt;/em&gt; file, even though this file doesn&amp;rsquo;t contain any test functions nor did we call the &lt;code&gt;setup&lt;/code&gt; function from anywhere:</source>
          <target state="translated">テストを再度実行すると、&lt;em&gt;common.rs&lt;/em&gt;ファイルのテスト出力に新しいセクションが表示されます。ただし、このファイルにはテスト関数が含まれておらず、どこからでも &lt;code&gt;setup&lt;/code&gt; 関数を呼び出していません。</target>
        </trans-unit>
        <trans-unit id="cb3ddc159979bee1d75a46f9ea2d0183358cc97b" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--nocapture&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">リスト11-10のテストを &lt;code&gt;--nocapture&lt;/code&gt; フラグを指定して再度実行すると、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="538d8419c932e242d1adf6db2334731a0ed2c1d0" translate="yes" xml:space="preserve">
          <source>When we run these tests with &lt;code&gt;cargo test&lt;/code&gt;, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">これらのテストを &lt;code&gt;cargo test&lt;/code&gt; で実行すると、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="44da441e6c2b41d33ecf09cf035dd429fd808ba5" translate="yes" xml:space="preserve">
          <source>When we run this code with the &lt;code&gt;main&lt;/code&gt; function in Listing 5-14, we&amp;rsquo;ll get our desired output. Methods can take multiple parameters that we add to the signature after the &lt;code&gt;self&lt;/code&gt; parameter, and those parameters work just like parameters in functions.</source>
          <target state="translated">リスト5-14の &lt;code&gt;main&lt;/code&gt; 関数でこのコードを実行すると、目的の出力が得られます。メソッドは、 &lt;code&gt;self&lt;/code&gt; パラメータの後にシグネチャに追加する複数のパラメータを取ることができ、それらのパラメータは関数のパラメータと同じように機能します。</target>
        </trans-unit>
        <trans-unit id="53901aa87c2188aaba7aa42fd2554bc7576ce3ee" translate="yes" xml:space="preserve">
          <source>When we run this code, keeping the last &lt;code&gt;println!&lt;/code&gt; commented out for the moment, we&amp;rsquo;ll get this output:</source>
          <target state="translated">このコードを実行すると、最後の &lt;code&gt;println!&lt;/code&gt; 保持されます。現時点ではコメント化されており、次の出力が得られます。</target>
        </trans-unit>
        <trans-unit id="5a3726ae54b6ccfb63fe87a5f6a303a012e956de" translate="yes" xml:space="preserve">
          <source>When we run this code, the first &lt;code&gt;[]&lt;/code&gt; method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there&amp;rsquo;s an attempt to access an element past the end of the vector.</source>
          <target state="translated">このコードを実行すると、最初の &lt;code&gt;[]&lt;/code&gt; メソッドは存在しない要素を参照するため、プログラムがパニックになります。この方法は、ベクターの終わりを超えて要素にアクセスしようとした場合にプログラムをクラッシュさせたい場合に最適です。</target>
        </trans-unit>
        <trans-unit id="d8d2da45983d7df0624bea6b1c973bb74ce76aac" translate="yes" xml:space="preserve">
          <source>When we run this code, we get an error with this core message:</source>
          <target state="translated">このコードを実行すると、このコアメッセージでエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="da6003750d05384524bf31be1adada0eff839f64" translate="yes" xml:space="preserve">
          <source>When we run this code, we&amp;rsquo;ll see the same output as in Listing 3-4. More importantly, we&amp;rsquo;ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</source>
          <target state="translated">このコードを実行すると、リスト3-4と同じ出力が表示されます。さらに重要なことに、コードの安全性が向上し、配列の最後を超えたり、十分に行かなかったり、一部のアイテムが欠落したりすることによって発生するバグの可能性がなくなりました。</target>
        </trans-unit>
        <trans-unit id="0377ef8d6715ac2dafa89aafe2017357ba5bea77" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see &lt;code&gt;again!&lt;/code&gt; printed over and over continuously until we stop the program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is stuck in a continual loop. Give it a try:</source>
          <target state="translated">このプログラムを実行すると、 &lt;code&gt;again!&lt;/code&gt; 表示されます。プログラムを手動で停止するまで、何度も繰り返し印刷しました。ほとんどの端末は、継続的なループでスタックしているプログラムを中断するためのキーボードショートカットctrl-cをサポートしています。試してみる：</target>
        </trans-unit>
        <trans-unit id="17d349051e8f46b1c202c3a4fbf98139c89d6d7a" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">このプログラムを実行すると、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="2f39695d914a0c9b88c38a4702c072cc550001b0" translate="yes" xml:space="preserve">
          <source>When we try to check this code, we get this error:</source>
          <target state="translated">このコードを確認しようとすると、このようなエラーが出ます。</target>
        </trans-unit>
        <trans-unit id="b3d78770e0df06fb7d4eaea2e697443df3c1aa40" translate="yes" xml:space="preserve">
          <source>When we try to compile the code in Listing 19-5, we&amp;rsquo;ll get an error.</source>
          <target state="translated">リスト19-5のコードをコンパイルしようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="48d690d7f7c7a29675b105185a25b0eb605ff7f0" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get an error. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; arms have value types that are incompatible, and Rust indicates exactly where to find the problem in the program:</source>
          <target state="translated">このコードをコンパイルしようとすると、エラーが発生します。 &lt;code&gt;if&lt;/code&gt; や &lt;code&gt;else&lt;/code&gt; の腕は互換性のない値の型を持っている、そしてラストは、プログラムに問題を発見する場所を正確に示しています。</target>
        </trans-unit>
        <trans-unit id="20d9e738eb0bfb3c94a0df139314a2d502044dfc" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">このコードをコンパイルしようとすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="382fab0dfc540b6d59e6b19a27e6a865624379ec" translate="yes" xml:space="preserve">
          <source>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic &lt;code&gt;largest&lt;/code&gt; function, place type name declarations inside angle brackets, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, between the name of the function and the parameter list, like this:</source>
          <target state="translated">関数の本体でパラメーターを使用する場合、コンパイラーがその名前の意味を理解できるように、シグニチャーでパラメーター名を宣言する必要があります。同様に、関数のシグネチャで型パラメーター名を使用する場合は、使用する前に型パラメーター名を宣言する必要があります。ジェネリック &lt;code&gt;largest&lt;/code&gt; 関数を定義するには、次のように、関数名とパラメーターリストの間に山かっこ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; で型名宣言を配置します。</target>
        </trans-unit>
        <trans-unit id="8036c669dac454067b908559831bbcc6af369344" translate="yes" xml:space="preserve">
          <source>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; when declaring the generic type.</source>
          <target state="translated">ジェネリック型パラメーターを使用する場合、ジェネリック型のデフォルトの具象型を指定できます。これにより、デフォルトのタイプが機能する場合に、トレイトの実装者が具象タイプを指定する必要がなくなります。ジェネリック型を宣言する場合、ジェネリック型のデフォルトの型を指定する構文は &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d2fd3063d82737c85a4bd4560675bf8f567d4cb1" translate="yes" xml:space="preserve">
          <source>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn&amp;rsquo;t know all the types that might be used with the code that is using trait objects, so it doesn&amp;rsquo;t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn&amp;rsquo;t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method&amp;rsquo;s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&amp;rsquo;s a trade-off to consider.</source>
          <target state="translated">特性オブジェクトを使用する場合、Rustは動的ディスパッチを使用する必要があります。コンパイラーは、特性オブジェクトを使用しているコードで使用される可能性のあるすべてのタイプを知っているわけではないため、どのタイプにどのメソッドを呼び出すかがわかりません。代わりに、実行時にRustは特性オブジェクト内のポインターを使用して、呼び出すメソッドを認識します。このルックアップが発生すると、静的ディスパッチでは発生しないランタイムコストが発生します。また、動的ディスパッチにより、コンパイラーがメソッドのコードをインライン化することを選択できなくなり、最適化が一部妨げられます。ただし、リスト17-5で記述し、リスト17-9でサポートすることができたコードには追加の柔軟性があり、考慮すべきトレードオフです。</target>
        </trans-unit>
        <trans-unit id="5fae46f3aefc24b09d40cb2c031a63a93c19cc1f" translate="yes" xml:space="preserve">
          <source>When we wrote the library, we didn&amp;rsquo;t know that someone might add the &lt;code&gt;SelectBox&lt;/code&gt; type, but our &lt;code&gt;Screen&lt;/code&gt; implementation was able to operate on the new type and draw it because &lt;code&gt;SelectBox&lt;/code&gt; implements the &lt;code&gt;Draw&lt;/code&gt; trait, which means it implements the &lt;code&gt;draw&lt;/code&gt; method.</source>
          <target state="translated">私たちは、ライブラリを書いたとき、私たちはその誰かが追加される場合があります知りませんでした &lt;code&gt;SelectBox&lt;/code&gt; 種類を、私たちの &lt;code&gt;Screen&lt;/code&gt; 実装は、新しいタイプで動作しているため、それを描くことができた &lt;code&gt;SelectBox&lt;/code&gt; 実装 &lt;code&gt;Draw&lt;/code&gt; 、それが実装された手段、形質を &lt;code&gt;draw&lt;/code&gt; する方法を。</target>
        </trans-unit>
        <trans-unit id="1835312d71cbb49146dabf1e8972dadabbddcca1" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re defining this function, we don&amp;rsquo;t know the concrete values that will be passed into this function, so we don&amp;rsquo;t know whether the &lt;code&gt;if&lt;/code&gt; case or the &lt;code&gt;else&lt;/code&gt; case will execute. We also don&amp;rsquo;t know the concrete lifetimes of the references that will be passed in, so we can&amp;rsquo;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. The borrow checker can&amp;rsquo;t determine this either, because it doesn&amp;rsquo;t know how the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; relate to the lifetime of the return value. To fix this error, we&amp;rsquo;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</source>
          <target state="translated">私たちは、この関数を定義しているとき、我々はかどうかわからないので、私たちは、この関数に渡される具体的な値が分からない &lt;code&gt;if&lt;/code&gt; ケースや &lt;code&gt;else&lt;/code&gt; ケースが実行されます。渡される参照の具体的な存続期間もわからないため、リスト10-18および10-19で行ったようにスコープを見て、返される参照が常に有効かどうかを判断することはできません。 。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の存続期間が戻り値の存続期間とどのように関連しているかがわからないため、借用チェッカーもこれを判断できません。このエラーを修正するために、参照間の関係を定義する一般的な有効期間パラメーターを追加して、借用チェッカーが分析を実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="54afd1d4de630fedf720b910edfe13f2d8fe3dc8" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">ピン留めされた構造体を使用する場合、 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; だけを受け取るメソッドでその構造体のフィールドにどのようにアクセスできるかという問題が発生します。通常のアプローチは、 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; をフィールドへの参照に変換するヘルパーメソッド（いわゆる&lt;em&gt;プロジェクション&lt;/em&gt;）を記述することですが、その参照にはどのような型が必要ですか？それは &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ？ &lt;code&gt;enum&lt;/code&gt; のフィールド、および&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;などのコンテナー/ラッパータイプを検討する場合にも、同じ質問が発生します。。（この質問は、可変参照と共有参照の両方に適用されます。ここでは、説明のために、可変参照のより一般的なケースを使用します。）</target>
        </trans-unit>
        <trans-unit id="0c51f9b3e20caf1c1713245e1eb2bd51a6ddf835" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.</source>
          <target state="translated">ファイルの終端を越えて書き込む場合は、ファイルを適切に拡張し、中間バイトを値0で初期化する。</target>
        </trans-unit>
        <trans-unit id="debf85ed8f2982fd1ef982135cd5a37e3b932f44" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.</source>
          <target state="translated">ファイルの終端を越えて書き込む場合は、ファイルを適切に拡張し、中間バイトは初期化されないままにしておきます。</target>
        </trans-unit>
        <trans-unit id="4354c2cf3db4bc019d136bbb52f5ec5d3d5bdd0b" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;型を返す多くの関数を呼び出すコードを記述する場合、エラー処理は面倒な場合があります。疑問符演算子、&lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;、伝播スタックのボイラープレートの一部を呼び出しスタックまで隠します。</target>
        </trans-unit>
        <trans-unit id="66253992d5df0f86fdc814938e97de3a70b258a2" translate="yes" xml:space="preserve">
          <source>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named &lt;code&gt;mod test&lt;/code&gt;. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</source>
          <target state="translated">モジュールの単体テストを作成する場合、テスト対象のモジュールの名前付き &lt;code&gt;mod test&lt;/code&gt; という直接の子を持つことはよくある慣習です。このモジュールは、2番目のケースを通じて親モジュールの任意の項目にアクセスできます。つまり、内部実装の詳細も子モジュールからシームレスにテストできます。</target>
        </trans-unit>
        <trans-unit id="6849dad47894c159da1bb308e92d26a3e924214c" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. As it turns out, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">あなた自身の特性を書くとき、 &lt;code&gt;!&lt;/code&gt; 持っていなければならない &lt;code&gt;impl&lt;/code&gt; 明らかがあるたびに &lt;code&gt;impl&lt;/code&gt; しない &lt;code&gt;panic!&lt;/code&gt; 。結局のところ、ほとんどの特徴は持つことができる &lt;code&gt;impl&lt;/code&gt; のために &lt;code&gt;!&lt;/code&gt; 。&lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;を例にとります：</target>
        </trans-unit>
        <trans-unit id="376eed46fc5732c188b64191ceb100503469e764" translate="yes" xml:space="preserve">
          <source>When you &lt;em&gt;do&lt;/em&gt; want to update a crate, Cargo provides another command, &lt;code&gt;update&lt;/code&gt;, which will ignore the &lt;em&gt;Cargo.lock&lt;/em&gt; file and figure out all the latest versions that fit your specifications in &lt;em&gt;Cargo.toml&lt;/em&gt;. If that works, Cargo will write those versions to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">あなたはとき&lt;em&gt;か&lt;/em&gt;クレートを更新したい、貨物は別のコマンド、提供 &lt;code&gt;update&lt;/code&gt; は無視されます、&lt;em&gt;Cargo.lockの&lt;/em&gt;中で、あなたの仕様に合わせて、すべての最新バージョンからファイルやフィギュアを&lt;em&gt;Cargo.tomlを&lt;/em&gt;。それが機能する場合、Cargoはそれらのバージョンを&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="1ba68f5d231df3408014c574fc5fb4dc7c5f7587" translate="yes" xml:space="preserve">
          <source>When you call a method with the &lt;code&gt;.foo()&lt;/code&gt; syntax, it&amp;rsquo;s often wise to introduce a newline and other whitespace to help break up long lines. We could have written this code as:</source>
          <target state="translated">&lt;code&gt;.foo()&lt;/code&gt; 構文を使用してメソッドを呼び出す場合、長い行を分割するのに役立つように、改行やその他の空白を導入することが賢明な場合があります。このコードは次のように書くこともできます。</target>
        </trans-unit>
        <trans-unit id="05246324bae5d78696c081ca3bb969c9b5f76aa9" translate="yes" xml:space="preserve">
          <source>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement &lt;code&gt;FnOnce&lt;/code&gt; because they can all be called at least once. Closures that don&amp;rsquo;t move the captured variables also implement &lt;code&gt;FnMut&lt;/code&gt;, and closures that don&amp;rsquo;t need mutable access to the captured variables also implement &lt;code&gt;Fn&lt;/code&gt;. In Listing 13-12, the &lt;code&gt;equal_to_x&lt;/code&gt; closure borrows &lt;code&gt;x&lt;/code&gt; immutably (so &lt;code&gt;equal_to_x&lt;/code&gt; has the &lt;code&gt;Fn&lt;/code&gt; trait) because the body of the closure only needs to read the value in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">クロージャーを作成すると、Rustは、クロージャーが環境からの値をどのように使用するかに基づいて、使用する特性を推測します。すべてのクロージャーは、少なくとも1回は &lt;code&gt;FnOnce&lt;/code&gt; ことができるため、FnOnceを実装します。キャプチャーされた変数を移動しないクロージャーも &lt;code&gt;FnMut&lt;/code&gt; を実装し、キャプチャーされた変数への可変アクセスを必要としないクロージャーも &lt;code&gt;Fn&lt;/code&gt; を実装します。リスト13-12では、 &lt;code&gt;equal_to_x&lt;/code&gt; クロージャは不変に &lt;code&gt;x&lt;/code&gt; を借用し &lt;code&gt;Fn&lt;/code&gt; （したがって、 &lt;code&gt;equal_to_x&lt;/code&gt; にはFnトレイトがあります）。クロージャの本体は &lt;code&gt;x&lt;/code&gt; の値を読み取るだけでよいためです。</target>
        </trans-unit>
        <trans-unit id="4b225d4c2d0c02a52b23cd1b31dafb9bb8378985" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data and you want to transfer ownership but ensure the data won&amp;rsquo;t be copied when you do so</source>
          <target state="translated">大量のデータがあり、所有権を譲渡したいが、その際にデータがコピーされないようにする場合</target>
        </trans-unit>
        <trans-unit id="1616d0bcec37e1d1974f0cec040ed2afa3965cea" translate="yes" xml:space="preserve">
          <source>When you have a type whose size can&amp;rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size</source>
          <target state="translated">コンパイル時にサイズがわからないタイプがあり、正確なサイズが必要なコンテキストでそのタイプの値を使用したい場合</target>
        </trans-unit>
        <trans-unit id="faaa349bf2d53d10371fecd29ecbff47ff56b1b0" translate="yes" xml:space="preserve">
          <source>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</source>
          <target state="translated">複数の構造体や列挙型の定義があり、それらが保持する値の型が異なるだけの状況をコードで認識した場合、代わりに汎用型を使用することで重複を避けることができます。</target>
        </trans-unit>
        <trans-unit id="679e3b066cfac92df42c0662cfeca1f3e83d745f" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;cargo check&lt;/code&gt; again, you&amp;rsquo;ll get a few more warnings, but it should succeed.</source>
          <target state="translated">&lt;code&gt;cargo check&lt;/code&gt; 再度実行すると、警告がいくつか表示されますが、成功するはずです。</target>
        </trans-unit>
        <trans-unit id="6448bbefd235d50e1c725bdf06e891f730d7d66b" translate="yes" xml:space="preserve">
          <source>When you run it, you won&amp;rsquo;t get the path of the original executable, you&amp;rsquo;ll get the path of the hard link:</source>
          <target state="translated">これを実行すると、元の実行可能ファイルのパスは取得されず、ハードリンクのパスが取得されます。</target>
        </trans-unit>
        <trans-unit id="30a9b27f023546ce78e3fa8bcc73ea93a891ddb0" translate="yes" xml:space="preserve">
          <source>When you run multiple tests, by default they run in parallel using threads. This means the tests will finish running faster so you can get feedback quicker on whether or not your code is working. Because the tests are running at the same time, make sure your tests don&amp;rsquo;t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</source>
          <target state="translated">複数のテストを実行する場合、デフォルトではスレッドを使用して並行して実行されます。これは、テストの実行がより速く終了することを意味し、コードが機能しているかどうかに関するフィードバックを迅速に得ることができます。テストは同時に実行されているため、テストが相互に依存していないこと、または現在の作業ディレクトリや環境変数などの共有環境を含む共有状態に依存していないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="bdd64a76c4764e34bb256afe510d04a4140ab743" translate="yes" xml:space="preserve">
          <source>When you run the code, your output should look something like this:</source>
          <target state="translated">コードを実行すると、出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="56a080f28d7b938e415697722d1eaa5194296964" translate="yes" xml:space="preserve">
          <source>When you run the program, you&amp;rsquo;ll see something like this:</source>
          <target state="translated">プログラムを実行すると、次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="9d0f951f7def4bb9ddc934064d83b22842550653" translate="yes" xml:space="preserve">
          <source>When you run this code, it will compile but will display a warning:</source>
          <target state="translated">このコードを実行するとコンパイルされますが、警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="cd11ee578beeab8bff18cf7df74988e81ef63b8d" translate="yes" xml:space="preserve">
          <source>When you run this program, the error you&amp;rsquo;ll get looks like this:</source>
          <target state="translated">このプログラムを実行すると、次のようなエラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="88bf968fcfba3ccae7b190e45758bbe17d47d594" translate="yes" xml:space="preserve">
          <source>When you see a call to &lt;code&gt;clone&lt;/code&gt;, you know that some arbitrary code is being executed and that code may be expensive. It&amp;rsquo;s a visual indicator that something different is going on.</source>
          <target state="translated">&lt;code&gt;clone&lt;/code&gt; の呼び出しを見ると、任意のコードが実行されており、そのコードには負荷がかかる可能性があることがわかります。これは、何か別のことが起こっていることを視覚的に示すものです。</target>
        </trans-unit>
        <trans-unit id="dba00a225c49d7aad6a4c3e2fefc5b6ad717617e" translate="yes" xml:space="preserve">
          <source>When you understand ownership, you&amp;rsquo;ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you&amp;rsquo;ll learn ownership by working through some examples that focus on a very common data structure: strings.</source>
          <target state="translated">所有権を理解すると、Rustをユニークにする機能を理解するための強固な基盤ができます。この章では、非常に一般的なデータ構造である文字列に焦点を当てたいくつかの例を通して、所有権を学びます。</target>
        </trans-unit>
        <trans-unit id="fb9b6ed06b18947df730bd329065f971ebc43888" translate="yes" xml:space="preserve">
          <source>When you want a function to have multiple parameters, separate the parameter declarations with commas, like this:</source>
          <target state="translated">関数に複数のパラメータを持たせたい場合は、次のようにパラメータ宣言をカンマで区切ってください。</target>
        </trans-unit>
        <trans-unit id="7140942a9e83dd3630a3c0916a44b851e25bd0ab" translate="yes" xml:space="preserve">
          <source>When you want to own a value and you care only that it&amp;rsquo;s a type that implements a particular trait rather than being of a specific type</source>
          <target state="translated">値を所有したいが、それが特定の型ではなく特定の特性を実装する型であることだけを気にする場合</target>
        </trans-unit>
        <trans-unit id="a38101ccd42a1c4f79b06b155e4e46b8f79f9a7b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error. If you want to wrap explicitly, you can use the standard library type &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt;&lt;code&gt;Wrapping&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--release&lt;/code&gt; フラグを使用してリリースモードでコンパイルする場合、Rustにはパニックを引き起こす整数オーバーフローのチェック&lt;em&gt;は&lt;/em&gt;含まれませ&lt;em&gt;ん&lt;/em&gt;。代わりに、オーバーフローが発生した場合、Rustは&lt;em&gt;2の補数のラッピングを&lt;/em&gt;実行します。つまり、タイプが保持できる最大値より大きい値は、タイプが保持できる最小値まで「ラップアラウンド」します。 &lt;code&gt;u8&lt;/code&gt; の場合、256は0になり、257は1になります。プログラムはパニックに陥ることはありませんが、変数の値はおそらく期待していたものとは異なります。整数オーバーフローのラップ動作に依存すると、エラーと見なされます。明示的にラップする場合は、標準ライブラリタイプの&lt;a href=&quot;../std/num/struct.wrapping&quot;&gt; &lt;code&gt;Wrapping&lt;/code&gt; を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="cf6294d1d4938dc2164807d070a9e5a24c528b0b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</source>
          <target state="translated">ミューテックスが保護するデータを使い終わったら、他のスレッドがロックを取得できるように、データをロック解除する必要があります。</target>
        </trans-unit>
        <trans-unit id="87ed8d0c79155dbc381301582c028a0bc87a94b1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to move on, we&amp;rsquo;ll talk about a concept in Rust that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; commonly exist in other programming languages: ownership.</source>
          <target state="translated">次に進む準備ができたら、他のプログラミング言語に&lt;em&gt;は&lt;/em&gt;一般的に存在&lt;em&gt;しない&lt;/em&gt; Rustの概念である所有権について説明します。</target>
        </trans-unit>
        <trans-unit id="338c49418a81c4fe8cdbaa3398a7f70c772eed82" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a function whose implementation calls something that might fail, instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as &lt;em&gt;propagating&lt;/em&gt; the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</source>
          <target state="translated">実装が失敗する可能性のあるものを呼び出す関数を作成している場合、この関数内のエラーを処理する代わりに、呼び出し元のコードにエラーを返し、何をすべきかを決定できます。これはエラーの&lt;em&gt;伝播&lt;/em&gt;と呼ばれ、呼び出しコードにより多くの制御を提供します。コードのコンテキストで利用できるものよりも、エラーの処理方法を指示するより多くの情報またはロジックが存在する場合があります。</target>
        </trans-unit>
        <trans-unit id="52116b6d188a2650ef7d8367c1d460637ef198b9" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a program, if you don&amp;rsquo;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&amp;rsquo;t work. Instead, you can use a trait object, which we&amp;rsquo;ll cover in Chapter 17.</source>
          <target state="translated">プログラムを作成しているときに、実行時にプログラムがベクターに格納する型の完全なセットがわからない場合、列挙型手法は機能しません。代わりに、第17章で説明する特性オブジェクトを使用できます。</target>
        </trans-unit>
        <trans-unit id="a6c702a723f263e7d6b8ef006b195ad04de8148a" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear. In examples, it&amp;rsquo;s understood that a call to a method like &lt;code&gt;unwrap&lt;/code&gt; that could panic is meant as a placeholder for the way you&amp;rsquo;d want your application to handle errors, which can differ based on what the rest of your code is doing.</source>
          <target state="translated">いくつかの概念を説明するために例を書いているとき、例にも堅牢なエラー処理コードがあると、例が不明確になる可能性があります。例では、パニックが発生する可能性がある &lt;code&gt;unwrap&lt;/code&gt; などのメソッドの呼び出しは、アプリケーションでエラーを処理する方法のプレースホルダーとして意図されていることが理解されています。</target>
        </trans-unit>
        <trans-unit id="c42c6bb649d897cae512ccb086d5d0b9efa0b2d4" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;ve made changes to your crate and are ready to release a new version, you change the &lt;code&gt;version&lt;/code&gt; value specified in your &lt;em&gt;Cargo.toml&lt;/em&gt; file and republish. Use the &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning rules&lt;/a&gt; to decide what an appropriate next version number is based on the kinds of changes you&amp;rsquo;ve made. Then run &lt;code&gt;cargo publish&lt;/code&gt; to upload the new version.</source>
          <target state="translated">クレートに変更を加え、新しいバージョンをリリースする準備ができたら、&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルで指定された &lt;code&gt;version&lt;/code&gt; 値を変更して再公開します。&lt;a href=&quot;http://semver.org/&quot;&gt;セマンティックバージョニングルール&lt;/a&gt;を使用して、行った変更の種類に基づいて適切な次のバージョン番号を決定します。次に、 &lt;code&gt;cargo publish&lt;/code&gt; を実行して新しいバージョンをアップロードします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="839440b70c5a7ad1d7e470fedb75657493aedb6e" translate="yes" xml:space="preserve">
          <source>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function&amp;rsquo;s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</source>
          <target state="translated">コードが関数を呼び出すと、関数に渡された値（ヒープ上のデータへのポインターを含む可能性があります）と関数のローカル変数がスタックにプッシュされます。関数が終了すると、それらの値はスタックからポップされます。</target>
        </trans-unit>
        <trans-unit id="7fc4ed82b7b946f127718773ea3ac4f397f59537" translate="yes" xml:space="preserve">
          <source>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&amp;rsquo;t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call &lt;code&gt;panic!&lt;/code&gt; if you attempt an out-of-bounds memory access: trying to access memory that doesn&amp;rsquo;t belong to the current data structure is a common security problem. Functions often have &lt;em&gt;contracts&lt;/em&gt;: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&amp;rsquo;s not a kind of error you want the calling code to have to explicitly handle. In fact, there&amp;rsquo;s no reasonable way for calling code to recover; the calling &lt;em&gt;programmers&lt;/em&gt; need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</source>
          <target state="translated">コードが値に対して操作を実行するとき、コードは値が有効であることを最初に確認し、値が有効でない場合はパニックを起こす必要があります。これは主に安全上の理由によるものです。無効なデータを操作しようとすると、コードが脆弱性にさらされる可能性があります。これが標準ライブラリが &lt;code&gt;panic!&lt;/code&gt; を呼ぶ主な理由です！範囲外のメモリアクセスを試みる場合：現在のデータ構造に属していないメモリにアクセスしようとすることは、一般的なセキュリティ問題です。機能には&lt;em&gt;契約&lt;/em&gt;があることが多い&lt;em&gt;&lt;/em&gt;：それらの動作は、入力が特定の要件を満たしている場合にのみ保証されます。コントラクトに違反したときにパニックすることは理にかなっています。コントラクト違反は常に呼び出し側のバグを示し、呼び出し側のコードで明示的に処理する必要のある種類のエラーではないためです。実際、コードを呼び出して回復する合理的な方法はありません。呼び出し元の&lt;em&gt;プログラマ&lt;/em&gt;はコードを修正する必要があります。関数のコントラクト、特に違反によってパニックが発生する場合は、関数のAPIドキュメントで説明する必要があります。</target>
        </trans-unit>
        <trans-unit id="89c680949e7cd958d9cc4977874667c68a138ea6" translate="yes" xml:space="preserve">
          <source>When your project is finally ready for release, you can use &lt;code&gt;cargo build --release&lt;/code&gt; to compile it with optimizations. This command will create an executable in &lt;em&gt;target/release&lt;/em&gt; instead of &lt;em&gt;target/debug&lt;/em&gt;. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you&amp;rsquo;ll give to a user that won&amp;rsquo;t be rebuilt repeatedly and that will run as fast as possible. If you&amp;rsquo;re benchmarking your code&amp;rsquo;s running time, be sure to run &lt;code&gt;cargo build --release&lt;/code&gt; and benchmark with the executable in &lt;em&gt;target/release&lt;/em&gt;.</source>
          <target state="translated">プロジェクトが最終的にリリースの準備ができたら、 &lt;code&gt;cargo build --release&lt;/code&gt; を使用して最適化してコンパイルできます。このコマンドは、&lt;em&gt;target / debug&lt;/em&gt;ではなく&lt;em&gt;target / release&lt;/em&gt;に実行可能ファイルを作成します。最適化によりRustコードの実行が高速になりますが、最適化を有効にすると、プログラムのコンパイルにかかる時間が長くなります。これが2つの異なるプロファイルがある理由です。1つは開発用で、迅速かつ頻繁に再構築する場合と、もう1つは、繰り返し再構築されず、できるだけ速く実行される最終プログラムを構築するためのものです。可能。コードの実行時間をベンチマークする場合は、&lt;em&gt;target / releaseの&lt;/em&gt;実行可能ファイルを使用して、 &lt;code&gt;cargo build --release&lt;/code&gt; とベンチマークを実行してください。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3d1e3a329799ed0876a4d1ad716f19e4a9cec94" translate="yes" xml:space="preserve">
          <source>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the &lt;code&gt;let&lt;/code&gt;. This is illustrated in the example above by showing that &lt;code&gt;tmp&lt;/code&gt; would be freed as we exit the block.</source>
          <target state="translated">一時ファイルが作成されると、固定されたルールに従って一時ファイルが自動的に削除（解放）されます。通常、一時ファイルは囲んでいるステートメントの最後にドロップ &lt;code&gt;let&lt;/code&gt; ます。この場合、letの後にドロップされます。上記の例では、ブロックを終了すると &lt;code&gt;tmp&lt;/code&gt; が解放されることを示しています。</target>
        </trans-unit>
        <trans-unit id="eed4432a187ec3056ddd9bd907b999948f00874c" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferrable to use &lt;a href=&quot;#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">可能な限り、代わりに&lt;a href=&quot;#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。これにより、 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 内容が重複することを防ぎます。</target>
        </trans-unit>
        <trans-unit id="a4de23a7f6719a7ba57b078ca4ff7e8250001b36" translate="yes" xml:space="preserve">
          <source>Where clauses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0b082cc3c369bcfe0d32cc803440f9644c559a" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s the &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operator?</source>
          <target state="translated">&lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; 演算子はどこにありますか？</target>
        </trans-unit>
        <trans-unit id="d4ea105a6df2620f7975d097e826dec6963287a4" translate="yes" xml:space="preserve">
          <source>Whether or not to evaluate the sub-expressions when evaluating the expression</source>
          <target state="translated">式を評価する際に副式を評価するかどうか</target>
        </trans-unit>
        <trans-unit id="7441400ac9aa4ede2210143836e6a213067deff4" translate="yes" xml:space="preserve">
          <source>Whew! Now you have some Rust features in your toolbox that you won&amp;rsquo;t use often, but you&amp;rsquo;ll know they&amp;rsquo;re available in very particular circumstances. We&amp;rsquo;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&amp;rsquo; code, you&amp;rsquo;ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</source>
          <target state="translated">ふew！ツールボックスにRustの機能がいくつかありますが、これはあまり使用しませんが、非常に特殊な状況で使用できることがわかります。エラーメッセージの提案や他の人のコードで遭遇したときに、これらの概念と構文を認識できるように、いくつかの複雑なトピックを紹介しました。この章を参考にして、ソリューションを紹介してください。</target>
        </trans-unit>
        <trans-unit id="ecbdd73494930b04d58d59a497ec54128fcf95a8" translate="yes" xml:space="preserve">
          <source>Whew! That was a lot of work, but we&amp;rsquo;ve set ourselves up for success in the future. Now it&amp;rsquo;s much easier to handle errors, and we&amp;rsquo;ve made the code more modular. Almost all of our work will be done in &lt;em&gt;src/lib.rs&lt;/em&gt; from here on out.</source>
          <target state="translated">ふew！それは大変な作業でしたが、私たちは将来の成功に向けて準備を整えました。エラーの処理がはるかに簡単になり、コードがよりモジュール化されました。私たちの作業のほとんどすべては、今後&lt;em&gt;src / lib.rs&lt;/em&gt;で行われます。</target>
        </trans-unit>
        <trans-unit id="357b219e220334335cb6c179ad0fbd5be62e5879" translate="yes" xml:space="preserve">
          <source>Whew! We &lt;em&gt;also&lt;/em&gt; cannot have a mutable reference while we have an immutable one. Users of an immutable reference don&amp;rsquo;t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&amp;rsquo;s reading of the data.</source>
          <target state="translated">ふew！我々は&lt;em&gt;また&lt;/em&gt;、我々は不変のものを持っていながら、可変の参照を持つことはできません。不変参照のユーザーは、値がその下から突然変化することを期待していません。ただし、データを読み取っているだけの人は、他の人のデータの読み取りに影響を与えることができないため、複数の不変参照は問題ありません。</target>
        </trans-unit>
        <trans-unit id="c4abab176ad04758c7995b5bf1a8ebbc48d27dab" translate="yes" xml:space="preserve">
          <source>Which configuration options are set is determined statically during the compilation of the crate. Certain options are &lt;em&gt;compiler-set&lt;/em&gt; based on data about the compilation. Other options are &lt;em&gt;arbitrarily-set&lt;/em&gt;, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.</source>
          <target state="translated">設定される構成オプションは、クレートのコンパイル中に静的に決定されます。特定のオプションは、コンパイルに関するデータに基づいて&lt;em&gt;コンパイラーセット&lt;/em&gt;です。その他のオプションは&lt;em&gt;任意に設定され&lt;/em&gt;、コードの外部でコンパイラに渡される入力に基づいて設定されます。コンパイルされているクレートのソースコード内から構成オプションを設定することはできません。</target>
        </trans-unit>
        <trans-unit id="8e64a82a5b16af1f23a177677675bfbfea39f34c" translate="yes" xml:space="preserve">
          <source>Which kind of iterator are we turning this into?</source>
          <target state="translated">これをどのようなイテレータにするのか?</target>
        </trans-unit>
        <trans-unit id="0807125208cee959762c24f1a5a66bea0dc3bb1c" translate="yes" xml:space="preserve">
          <source>Which method works best depends on what kind of situation you're in.</source>
          <target state="translated">どの方法が最も効果的かは、あなたがどのような状況にいるかによります。</target>
        </trans-unit>
        <trans-unit id="381bdae639e5c41f0066a4ced8cdfc3fa580e603" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; is very useful for removing errors, &lt;code&gt;!&lt;/code&gt; can also be used to remove successes as well. If we think of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; as &quot;if this function returns, it has not errored,&quot; we get a very intuitive idea of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; as well: if the function returns, it &lt;em&gt;has&lt;/em&gt; errored.</source>
          <target state="translated">一方で&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt;、エラーを除去するのに非常に便利です &lt;code&gt;!&lt;/code&gt; 成功を削除するためにも使用できます。我々が考える場合には&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt;「この関数が戻るが、それはエラーが発生したしていない場合は、」我々は非常に直感的なアイデアを取るにつれて&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt;、同様：関数が戻るならば、それは&lt;em&gt;している&lt;/em&gt;エラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="040144073c8f0dfdb2720a3a96450c0f97978b7d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;MaybeUninit&lt;/code&gt; is &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (indicating it guarantees the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;), this does &lt;em&gt;not&lt;/em&gt; change any of the previous caveats. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; may still have different sizes, and types containing a field of type &lt;code&gt;T&lt;/code&gt; may be laid out (and sized) differently than if that field were &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;MaybeUninit&lt;/code&gt; is a union type, and &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions is unstable (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;the tracking issue&lt;/a&gt;). Over time, the exact guarantees of &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions may evolve, and &lt;code&gt;MaybeUninit&lt;/code&gt; may or may not remain &lt;code&gt;#[repr(transparent)]&lt;/code&gt;. That said, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; guarantee that it has the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;; it's just that the way &lt;code&gt;MaybeUninit&lt;/code&gt; implements that guarantee may evolve.</source>
          <target state="translated">ながら &lt;code&gt;MaybeUninit&lt;/code&gt; がある &lt;code&gt;#[repr(transparent)]&lt;/code&gt; （指示が同じサイズ、整列、およびABIを保証 &lt;code&gt;T&lt;/code&gt; ）、このことはない&lt;em&gt;ではない&lt;/em&gt;以前の警告のいずれかを変更します。 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; サイズは異なる場合があり、タイプ &lt;code&gt;T&lt;/code&gt; のフィールドを含むタイプは、そのフィールドが &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 場合とは異なる方法でレイアウト（およびサイズ）される場合があります。 &lt;code&gt;MaybeUninit&lt;/code&gt; は共用体タイプであり、共用体の &lt;code&gt;#[repr(transparent)]&lt;/code&gt; は不安定です（&lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;追跡の問題を&lt;/a&gt;参照）。時間の経過とともに、ユニオンに対する &lt;code&gt;#[repr(transparent)]&lt;/code&gt; の正確な保証が進化する可能性があります。 &lt;code&gt;MaybeUninit&lt;/code&gt; は &lt;code&gt;#[repr(transparent)]&lt;/code&gt; のままである場合とそうでない場合があります。つまり、 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; と同じサイズ、配置、およびABIであることを&lt;em&gt;常に&lt;/em&gt;保証します。それは、 &lt;code&gt;MaybeUninit&lt;/code&gt; が実装する方法が保証を進化させるということです。</target>
        </trans-unit>
        <trans-unit id="b5f05e101ccc42742a41d22d19ff794b2f1ec6bc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TypeId&lt;/code&gt; implements &lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;, it is worth noting that the hashes and ordering will vary between Rust releases. Beware of relying on them inside of your code!</source>
          <target state="translated">一方で &lt;code&gt;TypeId&lt;/code&gt; を実装 &lt;code&gt;Hash&lt;/code&gt; 、 &lt;code&gt;PartialOrd&lt;/code&gt; 、及び &lt;code&gt;Ord&lt;/code&gt; 、それはハッシュと順序が錆のリリースの間で変化するであろうことは注目に値します。コード内でそれらに依存することに注意してください！</target>
        </trans-unit>
        <trans-unit id="ef43e2f499fb4e7ebf44c6c96560fe3863b368a0" translate="yes" xml:space="preserve">
          <source>While Rust strings may contain nul bytes in the middle, C strings can't, as that byte would effectively truncate the string.</source>
          <target state="translated">Rustの文字列は途中にヌルバイトを含むことができますが、Cの文字列はヌルバイトを含むことができません。</target>
        </trans-unit>
        <trans-unit id="9b96c7bdcb6a7fde4fa090bcc724c51dcf154ff7" translate="yes" xml:space="preserve">
          <source>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be &quot;bridging&quot; some Windows APIs together, just passing &lt;code&gt;WCHAR&lt;/code&gt; strings among those APIs without ever really looking into the strings.</source>
          <target state="translated">このような文字列を無損失で有効なUTF-16文字列（またはUTF-8）に変換できるとは限りませんが、そのような文字列を無損失でWindows APIとの間でやり取りできることが望ましい場合がよくあります。たとえば、一部のRustコードは、一部のWindows APIを「ブリッジング」して、 &lt;code&gt;WCHAR&lt;/code&gt; 文字列を調べることなく、これらのAPI間でWCHAR文字列を渡すだけの場合があります。</target>
        </trans-unit>
        <trans-unit id="94ebb9d6a417c21d0e98155c75c39327ba03733c" translate="yes" xml:space="preserve">
          <source>While it might seem strange to have a function that just returns back the input, there are some interesting uses.</source>
          <target state="translated">入力を返すだけの関数があるのは奇妙に思えるかもしれませんが、面白い使い方があります。</target>
        </trans-unit>
        <trans-unit id="9f2427b468d47a7420d460c3c9434666519bb67a" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">反復中に、環境内のいずれかのキーまたは値が有効なUnicodeでない場合、返される反復子はパニックになります。これが望ましくない場合は、&lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;env::vars_os&lt;/code&gt; &lt;/a&gt;関数の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="88abee318504f329611b88069221a80488cf9999" translate="yes" xml:space="preserve">
          <source>While performing error handling it is often useful to implement &lt;code&gt;From&lt;/code&gt; for your own error type. By converting underlying error types to our own custom error type that encapsulates the underlying error type, we can return a single error type without losing information on the underlying cause. The '?' operator automatically converts the underlying error type to our custom error type by calling &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; which is automatically provided when implementing &lt;code&gt;From&lt;/code&gt;. The compiler then infers which implementation of &lt;code&gt;Into&lt;/code&gt; should be used.</source>
          <target state="translated">エラー処理の実行中に、独自のエラータイプに &lt;code&gt;From&lt;/code&gt; を実装すると便利な場合があります。根本的なエラータイプをカプセル化する独自のカスタムエラータイプに変換することにより、根本的な原因に関する情報を失うことなく、単一のエラータイプを返すことができます。 「？」演算子は、 &lt;code&gt;From&lt;/code&gt; の実装時に自動的に提供さ &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; を呼び出すことにより、基になるエラータイプをカスタムエラータイプに自動的に変換します。次に、コンパイラーは &lt;code&gt;Into&lt;/code&gt; のどの実装を使用するかを推測します。</target>
        </trans-unit>
        <trans-unit id="21a3472b42943360038c378154c72aeef876d83b" translate="yes" xml:space="preserve">
          <source>While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are &lt;a href=&quot;#primitives&quot;&gt;documented in the section on primitives&lt;/a&gt;.</source>
          <target state="translated">プリミティブはコンパイラーによって実装されますが、標準ライブラリーは、プリミティブ型に直接メソッドを実装します（これは、&lt;a href=&quot;#primitives&quot;&gt;プリミティブに関するセクションで説明されて&lt;/a&gt;いる唯一のライブラリーです）。</target>
        </trans-unit>
        <trans-unit id="d2a8167e66f949c278500fe8a0d882045622dfbf" translate="yes" xml:space="preserve">
          <source>While the following example is sound, there is a memory leak since the inner vectors were not freed prior to the &lt;code&gt;set_len&lt;/code&gt; call:</source>
          <target state="translated">次の例は適切ですが、 &lt;code&gt;set_len&lt;/code&gt; 呼び出しの前に内部ベクトルが解放されなかったため、メモリリークが発生しています。</target>
        </trans-unit>
        <trans-unit id="1ce58c9d13deabade9d0031e57b5c561b8bbc9a7" translate="yes" xml:space="preserve">
          <source>While these:</source>
          <target state="translated">これらがある間は</target>
        </trans-unit>
        <trans-unit id="5d891980461c7894b78072e4c40fd8f0ee9d4fc4" translate="yes" xml:space="preserve">
          <source>While this means the &lt;code&gt;String&lt;/code&gt; will have a length of zero, it does not touch its capacity.</source>
          <target state="translated">これは、 &lt;code&gt;String&lt;/code&gt; の長さがゼロになることを意味しますが、その容量には影響しません。</target>
        </trans-unit>
        <trans-unit id="1461d256887a81f77bef33d763313b5547fde61d" translate="yes" xml:space="preserve">
          <source>While this method and its mutable counterpart are useful for null-safety, it is important to note that this is still an unsafe operation because the returned value could be pointing to invalid memory.</source>
          <target state="translated">このメソッドとその変異可能な対応はヌルセーフに役立ちますが、返される値が無効なメモリを指している可能性があるため、これはまだ安全でない操作であることに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="ee1ba6c8d8e736d86285c52e19961693ec306982" translate="yes" xml:space="preserve">
          <source>While this trait is unstable, the methods are stable. &lt;code&gt;SliceConcatExt&lt;/code&gt; is included in the &lt;a href=&quot;../prelude/index&quot;&gt;standard library prelude&lt;/a&gt;, so you can use &lt;a href=&quot;#tymethod.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; as if they existed on &lt;code&gt;[T]&lt;/code&gt; itself.</source>
          <target state="translated">この特性は不安定ですが、メソッドは安定しています。 &lt;code&gt;SliceConcatExt&lt;/code&gt; は&lt;a href=&quot;../prelude/index&quot;&gt;標準ライブラリpreludeに&lt;/a&gt;含まれているため、&lt;a href=&quot;#tymethod.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#tymethod.concat&quot;&gt; &lt;code&gt;concat()&lt;/code&gt; &lt;/a&gt;を、 &lt;code&gt;[T]&lt;/code&gt; 自体に存在するかのように使用できます。</target>
        </trans-unit>
        <trans-unit id="a7f3f0c0f2ca43b389646c40f7923cc632b8f8da" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the prelude's import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常のRustスタイルはタイプを直接インポートするものですが、&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; の&lt;/a&gt;エイリアスはそうではない場合が多いため、タイプを簡単に区別できます。&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;は通常&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt;であると想定されているため、このエイリアスのユーザーは通常、プレリュードの&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt;のインポートをシャドウする代わりに &lt;code&gt;io::Result&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="8ba71bc00b481e82beeb9921c07aacd0590f6bd1" translate="yes" xml:space="preserve">
          <source>While you are looking at that &lt;code&gt;[-]&lt;/code&gt; button also notice the &lt;code&gt;[src]&lt;/code&gt; button. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.</source>
          <target state="translated">&lt;code&gt;[-]&lt;/code&gt; ボタンを見ている間、 &lt;code&gt;[src]&lt;/code&gt; ボタンにも注目してください。RustのAPIドキュメントはソースコードに付属しており、読むことをお勧めします。標準ライブラリのソースは一般的に高品質であり、カーテンの後ろをのぞくことがよくわかります。</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="ff785990fe44822be8ffd4354e290cef0c34c873" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode property, namely:</source>
          <target state="translated">空白は、 &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicodeプロパティを持つ文字のみを含む空でない文字列です。</target>
        </trans-unit>
        <trans-unit id="9831741f3701cd2501051eea04df81e500fcac28" translate="yes" xml:space="preserve">
          <source>Who Rust Is For</source>
          <target state="translated">錆は誰のためにあるのか</target>
        </trans-unit>
        <trans-unit id="73012c2e29394e650b32f0b4934e8028ea0802a0" translate="yes" xml:space="preserve">
          <source>Who This Book Is For</source>
          <target state="translated">この本は誰のためにあるのか</target>
        </trans-unit>
        <trans-unit id="43d9a912852b85357d25bd06b5c4e243076f38d3" translate="yes" xml:space="preserve">
          <source>Who implements &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">誰が &lt;code&gt;UnwindSafe&lt;/code&gt; を実装していますか？</target>
        </trans-unit>
        <trans-unit id="e36799f202c4d0ce55f224011110c6d687f10837" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;filter_map&lt;/code&gt; and not just &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;? The key is in this part:</source>
          <target state="translated">なぜ&lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;だけでなく、 &lt;code&gt;filter_map&lt;/code&gt; なのですか？キーはこの部分にあります：</target>
        </trans-unit>
        <trans-unit id="f5b054d5badd7795d72a342651abfb7fc1f4dad9" translate="yes" xml:space="preserve">
          <source>Why do I get this message with code that doesn't involve borrowing?</source>
          <target state="translated">借用を伴わないコードでこのメッセージが表示されるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="996dd8b0e5f1405cbf0cea853468ae25180b7c3c" translate="yes" xml:space="preserve">
          <source>Why would you not want an executable? Often, &lt;code&gt;cargo check&lt;/code&gt; is much faster than &lt;code&gt;cargo build&lt;/code&gt;, because it skips the step of producing an executable. If you&amp;rsquo;re continually checking your work while writing the code, using &lt;code&gt;cargo check&lt;/code&gt; will speed up the process! As such, many Rustaceans run &lt;code&gt;cargo check&lt;/code&gt; periodically as they write their program to make sure it compiles. Then they run &lt;code&gt;cargo build&lt;/code&gt; when they&amp;rsquo;re ready to use the executable.</source>
          <target state="translated">なぜ実行可能ファイルが必要ないのですか？多くの場合、実行可能ファイルを生成するステップをスキップするため、 &lt;code&gt;cargo check&lt;/code&gt; は &lt;code&gt;cargo build&lt;/code&gt; よりもはるかに高速です。コードの記述中に作業を継続的にチェックしている場合は、 &lt;code&gt;cargo check&lt;/code&gt; を使用するとプロセスがスピードアップします！そのため、多くのRustaceans は、プログラムがコンパイルされることを確認するためにプログラムを書くときに、定期的に &lt;code&gt;cargo check&lt;/code&gt; 実行します。次に、実行可能ファイルを使用する準備ができたら、 &lt;code&gt;cargo build&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="a81276e6dfb0c035da01e2595ee9fa04fdc86e1e" translate="yes" xml:space="preserve">
          <source>Wildcard pattern</source>
          <target state="translated">ワイルドカードパターン</target>
        </trans-unit>
        <trans-unit id="f4138f22664d37f96c263052adeb723fdfd7248c" translate="yes" xml:space="preserve">
          <source>Wildcards</source>
          <target state="translated">Wildcards</target>
        </trans-unit>
        <trans-unit id="0843bf815a9dab90b0636f270db8d304e5915a96" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">常に同じ &lt;code&gt;&amp;amp;str&lt;/code&gt; を返します</target>
        </trans-unit>
        <trans-unit id="74ce1cb06587f571c24b39c88c3261da8e964077" translate="yes" xml:space="preserve">
          <source>Will handle the pattern &lt;code&gt;&quot;&quot;&lt;/code&gt; as returning empty matches at each character boundary.</source>
          <target state="translated">各文字境界で空の一致を返すようにパターン &lt;code&gt;&quot;&quot;&lt;/code&gt; を処理します。</target>
        </trans-unit>
        <trans-unit id="57cfca1876affe8c210a04c4805938a5cb452282" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="translated">この文字列スライスを目的のタイプに解析できない場合は、&lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; を&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="acf1c1efc2e097b96e98657a8262127bc226f8f4" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C:&lt;/code&gt; や &lt;code&gt;\server\share&lt;/code&gt; などのWindowsパスプレフィックス。</target>
        </trans-unit>
        <trans-unit id="22f64162f505580122671f38419aea6835f8c68d" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="translated">Windowsは、ドライブボリューム（ &lt;code&gt;C:&lt;/code&gt; など）、ネットワーク共有フォルダー（ &lt;code&gt;\server\share&lt;/code&gt; ）への参照など、さまざまなパスプレフィックススタイルを使用します。さらに、一部のパス接頭辞は「逐語的」（つまり、接頭辞が &lt;code&gt;\?\&lt;/code&gt; ）です。この場合、 &lt;code&gt;/&lt;/code&gt; は区切り文字として扱われ&lt;em&gt;ず&lt;/em&gt;、基本的に正規化は行われません。</target>
        </trans-unit>
        <trans-unit id="7b773809bbe5f3adf18d472bfb1e18eaa3a7d486" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions for the primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::fs&lt;/code&gt; モジュールのプリミティブのWindows固有の拡張機能。</target>
        </trans-unit>
        <trans-unit id="965b862fd7707ea01407f5bde9d76c4b33887700" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; に対する&lt;/a&gt; Windows固有の拡張機能。</target>
        </trans-unit>
        <trans-unit id="315ae7857105e3f47dabe009d9742ce6b255f1de" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; に対する&lt;/a&gt; Windows固有の拡張機能。</target>
        </trans-unit>
        <trans-unit id="e64c5541c43eacfdb85ccf07942595f788d2cb90" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;に対するWindows固有の拡張子。</target>
        </trans-unit>
        <trans-unit id="00024f75ddf677c52ec0b6d2810b742570a31c11" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt;に対するWindows固有の拡張機能。</target>
        </trans-unit>
        <trans-unit id="13ae56a0a615ce91192a5ee5e6f95bfb7ba258a6" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt;に対するWindows固有の拡張機能。</target>
        </trans-unit>
        <trans-unit id="45de75b6c03804d7df1abb9816158b688e268757" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt; &lt;code&gt;fs::OpenOptions&lt;/code&gt; &lt;/a&gt;に対するWindows固有の拡張機能。</target>
        </trans-unit>
        <trans-unit id="94d3d733eec0453c12d54d6f46b9364d74ffa234" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">処理するWindows固有の拡張機能&lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt; &lt;code&gt;process::ExitStatus&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd50699b2495e189ba2c74247886850721ca3204" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="translated">&lt;a href=&quot;../../../process/struct.command&quot;&gt; &lt;code&gt;process::Command&lt;/code&gt; &lt;/a&gt;ビルダーに対するWindows固有の拡張。</target>
        </trans-unit>
        <trans-unit id="72c2a1cf40aca0e7999edbbce4beb69846664076" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;std::ffi&lt;/code&gt; モジュールのプリミティブに対するWindows固有の拡張。</target>
        </trans-unit>
        <trans-unit id="6a36d28de36794d012a45ca83704dfdf241f6fac" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives</source>
          <target state="translated">Windows 固有のプリミティブ</target>
        </trans-unit>
        <trans-unit id="6faf80579510e395a13fd315a37c59f2f038321b" translate="yes" xml:space="preserve">
          <source>Windows::all</source>
          <target state="translated">Windows::all</target>
        </trans-unit>
        <trans-unit id="6716af8ef731d4cbf5689fbdfb93409bf05643fa" translate="yes" xml:space="preserve">
          <source>Windows::any</source>
          <target state="translated">Windows::any</target>
        </trans-unit>
        <trans-unit id="700457e5baeb9db95e547cef9c74633bc4d41f0d" translate="yes" xml:space="preserve">
          <source>Windows::borrow</source>
          <target state="translated">Windows::borrow</target>
        </trans-unit>
        <trans-unit id="17164b9bb020d976e93adc4baa902877434e8dcf" translate="yes" xml:space="preserve">
          <source>Windows::borrow_mut</source>
          <target state="translated">Windows::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31908ffdddda768740e732a89602628774aabf19" translate="yes" xml:space="preserve">
          <source>Windows::by_ref</source>
          <target state="translated">Windows::by_ref</target>
        </trans-unit>
        <trans-unit id="f3d0e279ef4b7617f62329eac02e5ee30b537a4a" translate="yes" xml:space="preserve">
          <source>Windows::chain</source>
          <target state="translated">Windows::chain</target>
        </trans-unit>
        <trans-unit id="dc2580c31dfca64d3e4362d3193516de3088323f" translate="yes" xml:space="preserve">
          <source>Windows::clone</source>
          <target state="translated">Windows::clone</target>
        </trans-unit>
        <trans-unit id="a98bb41ccc08f765218084e917668531933467aa" translate="yes" xml:space="preserve">
          <source>Windows::clone_from</source>
          <target state="translated">Windows::clone_from</target>
        </trans-unit>
        <trans-unit id="561b1708f321b704fa9eba574176baec35025d94" translate="yes" xml:space="preserve">
          <source>Windows::clone_into</source>
          <target state="translated">Windows::clone_into</target>
        </trans-unit>
        <trans-unit id="9c9f0c0979265913d55cdfc2ebb0045f5a724bb0" translate="yes" xml:space="preserve">
          <source>Windows::cloned</source>
          <target state="translated">Windows::cloned</target>
        </trans-unit>
        <trans-unit id="a5b46f7f7dbd448b7a57c4223d0c87d1f200d2c6" translate="yes" xml:space="preserve">
          <source>Windows::cmp</source>
          <target state="translated">Windows::cmp</target>
        </trans-unit>
        <trans-unit id="fbb6b9c622af98d5a66bbf1cfbc26795253b7489" translate="yes" xml:space="preserve">
          <source>Windows::collect</source>
          <target state="translated">Windows::collect</target>
        </trans-unit>
        <trans-unit id="b4ad49bdadeff7d300af28e5eb3fa8051a92ccee" translate="yes" xml:space="preserve">
          <source>Windows::copied</source>
          <target state="translated">Windows::copied</target>
        </trans-unit>
        <trans-unit id="bd6d8af2e6984890043a2ffcecf64303ee4d2b67" translate="yes" xml:space="preserve">
          <source>Windows::count</source>
          <target state="translated">Windows::count</target>
        </trans-unit>
        <trans-unit id="a46aabac6f5fb33e90e0fa67da1b1c957391a4ba" translate="yes" xml:space="preserve">
          <source>Windows::cycle</source>
          <target state="translated">Windows::cycle</target>
        </trans-unit>
        <trans-unit id="54d929ec5d55c2868b2694194d22d67c995476cd" translate="yes" xml:space="preserve">
          <source>Windows::enumerate</source>
          <target state="translated">Windows::enumerate</target>
        </trans-unit>
        <trans-unit id="974003d8cd6730c68f798fb5852a1b8f66b8fc07" translate="yes" xml:space="preserve">
          <source>Windows::eq</source>
          <target state="translated">Windows::eq</target>
        </trans-unit>
        <trans-unit id="fcdcd8564c22f0d208d5887dca20b15981ed7eda" translate="yes" xml:space="preserve">
          <source>Windows::filter</source>
          <target state="translated">Windows::filter</target>
        </trans-unit>
        <trans-unit id="072316ad208e9676ec686940b97aee272075037a" translate="yes" xml:space="preserve">
          <source>Windows::filter_map</source>
          <target state="translated">Windows::filter_map</target>
        </trans-unit>
        <trans-unit id="c74c15ca962f2f3a44811fa2285bb43e26958f3d" translate="yes" xml:space="preserve">
          <source>Windows::find</source>
          <target state="translated">Windows::find</target>
        </trans-unit>
        <trans-unit id="786d8bedc7c35f14926b40554c0038bfc1b31ca1" translate="yes" xml:space="preserve">
          <source>Windows::find_map</source>
          <target state="translated">Windows::find_map</target>
        </trans-unit>
        <trans-unit id="643130ad01d792200f3136ea8c6e080f0365707e" translate="yes" xml:space="preserve">
          <source>Windows::flat_map</source>
          <target state="translated">Windows::flat_map</target>
        </trans-unit>
        <trans-unit id="f4d8fa17f7d4e22990b8c1303515ad7b41c0e51e" translate="yes" xml:space="preserve">
          <source>Windows::flatten</source>
          <target state="translated">Windows::flatten</target>
        </trans-unit>
        <trans-unit id="d2eb04619a69bf18cec3a67a06b479df0576a42c" translate="yes" xml:space="preserve">
          <source>Windows::fmt</source>
          <target state="translated">Windows::fmt</target>
        </trans-unit>
        <trans-unit id="d8a195c51acf16c6aadba984188c415f5441b6c3" translate="yes" xml:space="preserve">
          <source>Windows::fold</source>
          <target state="translated">Windows::fold</target>
        </trans-unit>
        <trans-unit id="01cdc502497ab9b03d2f83fa2d0871f8abb0994a" translate="yes" xml:space="preserve">
          <source>Windows::for_each</source>
          <target state="translated">Windows::for_each</target>
        </trans-unit>
        <trans-unit id="6108a137a74f4bd608fc702807fd0e17b7abd278" translate="yes" xml:space="preserve">
          <source>Windows::from</source>
          <target state="translated">Windows::from</target>
        </trans-unit>
        <trans-unit id="8f30f87a1c9a02e1fb27ac6fe719069f8e122330" translate="yes" xml:space="preserve">
          <source>Windows::fuse</source>
          <target state="translated">Windows::fuse</target>
        </trans-unit>
        <trans-unit id="67db02e23e968fbc8c51336185b95b9b96aec0fb" translate="yes" xml:space="preserve">
          <source>Windows::ge</source>
          <target state="translated">Windows::ge</target>
        </trans-unit>
        <trans-unit id="1b08a3c2211d2e64ecaa8d094412c20af26d6951" translate="yes" xml:space="preserve">
          <source>Windows::gt</source>
          <target state="translated">Windows::gt</target>
        </trans-unit>
        <trans-unit id="6a49da6e96f3901cd2e3f2a458b5df67e32fc1ac" translate="yes" xml:space="preserve">
          <source>Windows::inspect</source>
          <target state="translated">Windows::inspect</target>
        </trans-unit>
        <trans-unit id="dc89660cc21103f886ff9b7d6b842aa6ebb6eea2" translate="yes" xml:space="preserve">
          <source>Windows::into</source>
          <target state="translated">Windows::into</target>
        </trans-unit>
        <trans-unit id="7dc827a9516a85386bc0443ac7acf8dbdc207267" translate="yes" xml:space="preserve">
          <source>Windows::into_iter</source>
          <target state="translated">Windows::into_iter</target>
        </trans-unit>
        <trans-unit id="3bf9a277de1f84adeaec35fb62966d1d7c35ff91" translate="yes" xml:space="preserve">
          <source>Windows::is_empty</source>
          <target state="translated">Windows::is_empty</target>
        </trans-unit>
        <trans-unit id="0f4e75134f8d11b4a570702cb97bdd5515869f82" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted</source>
          <target state="translated">Windows::is_sorted</target>
        </trans-unit>
        <trans-unit id="e74da52cc5b534ed59329d25635be3609f0336ec" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by</source>
          <target state="translated">Windows::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="396da8bc74081a0a8716a03e2ec0b64081b2263f" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by_key</source>
          <target state="translated">Windows::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="8bbf67cd900972eb007b6f354b425cc5682d90e0" translate="yes" xml:space="preserve">
          <source>Windows::last</source>
          <target state="translated">Windows::last</target>
        </trans-unit>
        <trans-unit id="edfebb32722bfb5c8d9922b27c21e2ad57bf0c3b" translate="yes" xml:space="preserve">
          <source>Windows::le</source>
          <target state="translated">Windows::le</target>
        </trans-unit>
        <trans-unit id="5b0f7e7a7b44222bd3e3f54b200e29b7293b2aa2" translate="yes" xml:space="preserve">
          <source>Windows::len</source>
          <target state="translated">Windows::len</target>
        </trans-unit>
        <trans-unit id="f84b680a03923cb8668b70cb3d48a10366b725cb" translate="yes" xml:space="preserve">
          <source>Windows::lt</source>
          <target state="translated">Windows::lt</target>
        </trans-unit>
        <trans-unit id="211653c7638da6256828c029f6bdbbd39290d614" translate="yes" xml:space="preserve">
          <source>Windows::map</source>
          <target state="translated">Windows::map</target>
        </trans-unit>
        <trans-unit id="da3645101a0d749919ba6caacb64cbf6bb5ab932" translate="yes" xml:space="preserve">
          <source>Windows::max</source>
          <target state="translated">Windows::max</target>
        </trans-unit>
        <trans-unit id="6faf7c5f10fa19e5856c7c741e0f6e00ec43ac89" translate="yes" xml:space="preserve">
          <source>Windows::max_by</source>
          <target state="translated">Windows::max_by</target>
        </trans-unit>
        <trans-unit id="a97eb7a3a210c7918ea8d0750c43c0be36a4f490" translate="yes" xml:space="preserve">
          <source>Windows::max_by_key</source>
          <target state="translated">Windows::max_by_key</target>
        </trans-unit>
        <trans-unit id="85afd294e1c8b3ac152c12583d70b807752d21c5" translate="yes" xml:space="preserve">
          <source>Windows::min</source>
          <target state="translated">Windows::min</target>
        </trans-unit>
        <trans-unit id="9851ad95c0803c7379f60e880e611d24b73dd771" translate="yes" xml:space="preserve">
          <source>Windows::min_by</source>
          <target state="translated">Windows::min_by</target>
        </trans-unit>
        <trans-unit id="d2ffacc1b47b99ed28eab58435af4f27856f1432" translate="yes" xml:space="preserve">
          <source>Windows::min_by_key</source>
          <target state="translated">Windows::min_by_key</target>
        </trans-unit>
        <trans-unit id="bd27f7b2dd977463e705864279f5215a8693dcf1" translate="yes" xml:space="preserve">
          <source>Windows::ne</source>
          <target state="translated">Windows::ne</target>
        </trans-unit>
        <trans-unit id="07ea4a2a4bc2affb3d5f44891b5f320bb57788cf" translate="yes" xml:space="preserve">
          <source>Windows::next</source>
          <target state="translated">Windows::next</target>
        </trans-unit>
        <trans-unit id="5df573867c1237a7c0cadeeaaef6362ce41599cb" translate="yes" xml:space="preserve">
          <source>Windows::next_back</source>
          <target state="translated">Windows::next_back</target>
        </trans-unit>
        <trans-unit id="884d14d5f8a19f0db064d5b33b9b17b75a3d8a57" translate="yes" xml:space="preserve">
          <source>Windows::nth</source>
          <target state="translated">Windows::nth</target>
        </trans-unit>
        <trans-unit id="d9ece61aa05f950e8c21d253603cec8c4927666f" translate="yes" xml:space="preserve">
          <source>Windows::nth_back</source>
          <target state="translated">Windows::nth_back</target>
        </trans-unit>
        <trans-unit id="e2337e7096b09ea74ce36d188b9ca860a5770051" translate="yes" xml:space="preserve">
          <source>Windows::partial_cmp</source>
          <target state="translated">Windows::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b234418f227a17c704174f2bef5739ac92992b03" translate="yes" xml:space="preserve">
          <source>Windows::partition</source>
          <target state="translated">Windows::partition</target>
        </trans-unit>
        <trans-unit id="9be20298e80cbaffa477f416ccc86f737f3f8d78" translate="yes" xml:space="preserve">
          <source>Windows::peekable</source>
          <target state="translated">Windows::peekable</target>
        </trans-unit>
        <trans-unit id="45529696a341be706214708f3fbab21c7d0b23fd" translate="yes" xml:space="preserve">
          <source>Windows::position</source>
          <target state="translated">Windows::position</target>
        </trans-unit>
        <trans-unit id="59fc20664973429ad195ba2d8aed0ddf546bb2a2" translate="yes" xml:space="preserve">
          <source>Windows::product</source>
          <target state="translated">Windows::product</target>
        </trans-unit>
        <trans-unit id="50734bb415bc20fe6568bfd1dd1f63f6b93fe949" translate="yes" xml:space="preserve">
          <source>Windows::rev</source>
          <target state="translated">Windows::rev</target>
        </trans-unit>
        <trans-unit id="530fe46767d842dcb4f66462626de45b73ad15f2" translate="yes" xml:space="preserve">
          <source>Windows::rfind</source>
          <target state="translated">Windows::rfind</target>
        </trans-unit>
        <trans-unit id="a36a85b42116649c6a0ad782c4af43ce9da0a6d2" translate="yes" xml:space="preserve">
          <source>Windows::rfold</source>
          <target state="translated">Windows::rfold</target>
        </trans-unit>
        <trans-unit id="6b46a39965804836e499e246c032f1e49efe2b08" translate="yes" xml:space="preserve">
          <source>Windows::rposition</source>
          <target state="translated">Windows::rposition</target>
        </trans-unit>
        <trans-unit id="3085a5deaa7e492e694960ff9a8bb11a44fea77b" translate="yes" xml:space="preserve">
          <source>Windows::scan</source>
          <target state="translated">Windows::scan</target>
        </trans-unit>
        <trans-unit id="600168ee422d0b4058643289d6f5f44a0cc41069" translate="yes" xml:space="preserve">
          <source>Windows::size_hint</source>
          <target state="translated">Windows::size_hint</target>
        </trans-unit>
        <trans-unit id="60a31deba53a9144f8f111c1a535404922718781" translate="yes" xml:space="preserve">
          <source>Windows::skip</source>
          <target state="translated">Windows::skip</target>
        </trans-unit>
        <trans-unit id="f0c88d1e74fd2619b821ca5f9314adc478f85906" translate="yes" xml:space="preserve">
          <source>Windows::skip_while</source>
          <target state="translated">Windows::skip_while</target>
        </trans-unit>
        <trans-unit id="43319d488bcd123c09eddf08cef6849d9980eba7" translate="yes" xml:space="preserve">
          <source>Windows::step_by</source>
          <target state="translated">Windows::step_by</target>
        </trans-unit>
        <trans-unit id="9672bcfc100f3ac44dec88d4d85716df442fe940" translate="yes" xml:space="preserve">
          <source>Windows::sum</source>
          <target state="translated">Windows::sum</target>
        </trans-unit>
        <trans-unit id="7df17ff1135505a96dab1d9f8ef57748282788e2" translate="yes" xml:space="preserve">
          <source>Windows::take</source>
          <target state="translated">Windows::take</target>
        </trans-unit>
        <trans-unit id="1e57647d418ad6082e9d4ee5291c1745f789d2e8" translate="yes" xml:space="preserve">
          <source>Windows::take_while</source>
          <target state="translated">Windows::take_while</target>
        </trans-unit>
        <trans-unit id="8f55f6ef559f032eb73be76c2b09a5737e416d5c" translate="yes" xml:space="preserve">
          <source>Windows::to_owned</source>
          <target state="translated">Windows::to_owned</target>
        </trans-unit>
        <trans-unit id="81cbe418ab3685420d683bda86fea704938b8a31" translate="yes" xml:space="preserve">
          <source>Windows::try_fold</source>
          <target state="translated">Windows::try_fold</target>
        </trans-unit>
        <trans-unit id="b4c27872e29ca09f92a33f4478a1eff0aea539bb" translate="yes" xml:space="preserve">
          <source>Windows::try_for_each</source>
          <target state="translated">Windows::try_for_each</target>
        </trans-unit>
        <trans-unit id="171fea351be781be4e02e711fd24294e453b5b91" translate="yes" xml:space="preserve">
          <source>Windows::try_from</source>
          <target state="translated">Windows::try_from</target>
        </trans-unit>
        <trans-unit id="9220c38d1fb3ec5be1fd9df5b83c243f1caa3ba1" translate="yes" xml:space="preserve">
          <source>Windows::try_into</source>
          <target state="translated">Windows::try_into</target>
        </trans-unit>
        <trans-unit id="92ba387998e4a086247665261fda5122f9f9029e" translate="yes" xml:space="preserve">
          <source>Windows::try_rfold</source>
          <target state="translated">Windows::try_rfold</target>
        </trans-unit>
        <trans-unit id="ff8171358582a1c7e6fe713b6c5031c85fcf7da9" translate="yes" xml:space="preserve">
          <source>Windows::type_id</source>
          <target state="translated">Windows::type_id</target>
        </trans-unit>
        <trans-unit id="ef934a80a8453f69945f5830a3ed61e3b0c17061" translate="yes" xml:space="preserve">
          <source>Windows::unzip</source>
          <target state="translated">Windows::unzip</target>
        </trans-unit>
        <trans-unit id="fc3d2052b8855f4dd5b69c5898112a4724165849" translate="yes" xml:space="preserve">
          <source>Windows::zip</source>
          <target state="translated">Windows::zip</target>
        </trans-unit>
        <trans-unit id="38dc69622ed00aee21cdcf0fd074e253d0cf7005" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">&lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;そして&lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;、これらのマクロは、ソース内の場所に関する開発者向けのデバッグ情報を提供します。</target>
        </trans-unit>
        <trans-unit id="0ec53663cefb4388138a07773bc9d9c40923307a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">&lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;そして&lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;、これらのマクロは、ソース内の場所に関する開発者向けのデバッグ情報を提供します。</target>
        </trans-unit>
        <trans-unit id="815b1bf6287da2f53b57957c1e78d170fa30a354" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">&lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;そして&lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;、これらのマクロは、ソース内の場所に関する開発者向けのデバッグ情報を提供します。</target>
        </trans-unit>
        <trans-unit id="04eb7504cabe503a97d0c1acdec5be3b9053e741" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Infallible&lt;/code&gt; being an enum, this code is valid. However when &lt;code&gt;Infallible&lt;/code&gt; becomes an alias for the never type, the two &lt;code&gt;impl&lt;/code&gt;s will start to overlap and therefore will be disallowed by the language&amp;rsquo;s trait coherence rules.</source>
          <target state="translated">&lt;code&gt;Infallible&lt;/code&gt; 列挙され、このコードは有効です。ただし、 &lt;code&gt;Infallible&lt;/code&gt; がneverタイプのエイリアスになると、2つの &lt;code&gt;impl&lt;/code&gt; は重複し始め、言語の特性一貫性規則によって許可されなくなります。</target>
        </trans-unit>
        <trans-unit id="0eafffeebea0c3842266dddbb6f397a2037dca13" translate="yes" xml:space="preserve">
          <source>With CMD on Windows, you would enter the following:</source>
          <target state="translated">WindowsのCMDでは、以下のように入力します。</target>
        </trans-unit>
        <trans-unit id="c67b427f4a43407481fdbe0434a6fd74d6c08115" translate="yes" xml:space="preserve">
          <source>With Rust&amp;rsquo;s &lt;code&gt;..&lt;/code&gt; range syntax, if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:</source>
          <target state="translated">Rustの &lt;code&gt;..&lt;/code&gt; range構文を使用して、最初のインデックス（ゼロ）から開始する場合は、2つのピリオドの前の値を削除できます。つまり、これらは同じです。</target>
        </trans-unit>
        <trans-unit id="e6848246eb0a467aba8b63d5b96e2ddd94bde183" translate="yes" xml:space="preserve">
          <source>With a basic understanding of threads and the thread API, let&amp;rsquo;s look at what we can &lt;em&gt;do&lt;/em&gt; with threads.</source>
          <target state="translated">スレッドとスレッドAPIの基本を理解&lt;em&gt;したら&lt;/em&gt;、スレッドで何ができるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="b24837e9bbb4a3f319a132114baf06eda4b2e88c" translate="yes" xml:space="preserve">
          <source>With a method call:</source>
          <target state="translated">メソッド呼び出しで</target>
        </trans-unit>
        <trans-unit id="5ec0502a02d896b78bc96b2798e0767135b5c8c9" translate="yes" xml:space="preserve">
          <source>With a pathname:</source>
          <target state="translated">パス名で。</target>
        </trans-unit>
        <trans-unit id="f37d3365310acb52cb4a4d469a50deacc72ef16e" translate="yes" xml:space="preserve">
          <source>With a unique name, the version, the author details that &lt;code&gt;cargo new&lt;/code&gt; added when you created the crate, your description, and a license added, the &lt;em&gt;Cargo.toml&lt;/em&gt; file for a project that is ready to publish might look like this:</source>
          <target state="translated">一意の名前、バージョン、作成者がクレートを作成したときに追加された &lt;code&gt;cargo new&lt;/code&gt; 詳細、説明、および追加されたライセンスを使用すると、公開の準備ができているプロジェクトの&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="33d3ef8879647cae82afb7b344de4fdc8e49a8b3" translate="yes" xml:space="preserve">
          <source>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you&amp;rsquo;ll see in the next section, &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;Calling an Unsafe Function or Method.&amp;rdquo;&lt;/a&gt; Another case is when building up safe abstractions that the borrow checker doesn&amp;rsquo;t understand. We&amp;rsquo;ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</source>
          <target state="translated">これらのすべての危険を踏まえて、なぜ生のポインタを使用するのですか？次のセクション&lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;「安全でない関数またはメソッドの呼び出し」で&lt;/a&gt;説明するように、1つの主な使用例はCコードとのインターフェースです。もう1つのケースは、借用チェッカーが理解できない安全な抽象化を構築する場合です。安全でない関数を紹介し、安全でないコードを使用する安全な抽象化の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a402171e60da25e2d20aa541a5e736d082a2894a" translate="yes" xml:space="preserve">
          <source>With all the changes we&amp;rsquo;ve made, our code compiles without any warnings. But the bad news is this code doesn&amp;rsquo;t function the way we want it to yet. The key is the logic in the closures run by the threads of the &lt;code&gt;Worker&lt;/code&gt; instances: at the moment, we call &lt;code&gt;join&lt;/code&gt;, but that won&amp;rsquo;t shut down the threads because they &lt;code&gt;loop&lt;/code&gt; forever looking for jobs. If we try to drop our &lt;code&gt;ThreadPool&lt;/code&gt; with our current implementation of &lt;code&gt;drop&lt;/code&gt;, the main thread will block forever waiting for the first thread to finish.</source>
          <target state="translated">私たちが行ったすべての変更により、コードは警告なしでコンパイルされます。しかし、悪い点は、このコードがまだ希望どおりに機能しないことです。重要なのは、 &lt;code&gt;Worker&lt;/code&gt; インスタンスのスレッドによって実行されるクロージャーのロジックです。現時点では、 &lt;code&gt;join&lt;/code&gt; を呼び出しますが、ジョブを探して &lt;code&gt;loop&lt;/code&gt; 続けるため、スレッドはシャットダウンされません。現在の &lt;code&gt;drop&lt;/code&gt; の実装で &lt;code&gt;ThreadPool&lt;/code&gt; をドロップしようとすると、メインスレッドは最初のスレッドが完了するのを待って永久にブロックします。</target>
        </trans-unit>
        <trans-unit id="3e478a9c9aaa53e1f24932c1bf11ee27b2b756f9" translate="yes" xml:space="preserve">
          <source>With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the &lt;code&gt;rlib&lt;/code&gt; format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</source>
          <target state="translated">これらすべての種類の出力で、クレートAがクレートBに依存している場合、コンパイラはシステム全体でさまざまな異なる形式のBを見つけることができます。ただし、コンパイラが &lt;code&gt;rlib&lt;/code&gt; する唯一の形式は、rlib形式と動的ライブラリ形式です。依存ライブラリのこれらの2つのオプションを使用すると、コンパイラは、いつかこれらの2つの形式から選択する必要があります。これを念頭に置いて、使用する依存関係の形式を決定するとき、コンパイラーは次の規則に従います。</target>
        </trans-unit>
        <trans-unit id="1b779befcd3540151b782d4543ae930ae53755ec" translate="yes" xml:space="preserve">
          <source>With all this information in mind, let&amp;rsquo;s rewrite &lt;code&gt;first_word&lt;/code&gt; to return a slice. The type that signifies &amp;ldquo;string slice&amp;rdquo; is written as &lt;code&gt;&amp;amp;str&lt;/code&gt;:</source>
          <target state="translated">このすべての情報を念頭に置いて、スライスを返すように &lt;code&gt;first_word&lt;/code&gt; を書き換えましょう。「文字列スライス」を表すタイプは、 &lt;code&gt;&amp;amp;str&lt;/code&gt; として記述されます。</target>
        </trans-unit>
        <trans-unit id="34e91fb00c7adb5b470a7e84f143a4420eb3479d" translate="yes" xml:space="preserve">
          <source>With associated types, we don&amp;rsquo;t need to annotate types because we can&amp;rsquo;t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of &lt;code&gt;Item&lt;/code&gt; will be once, because there can only be one &lt;code&gt;impl Iterator for Counter&lt;/code&gt;. We don&amp;rsquo;t have to specify that we want an iterator of &lt;code&gt;u32&lt;/code&gt; values everywhere that we call &lt;code&gt;next&lt;/code&gt; on &lt;code&gt;Counter&lt;/code&gt;.</source>
          <target state="translated">関連付けられた型では、型に特性を複数回実装できないため、型に注釈を付ける必要はありません。関連付けられたタイプを使用する定義を含むリスト19-12では、 &lt;code&gt;impl Iterator for Counter&lt;/code&gt; 1つしか存在できないため、 &lt;code&gt;Item&lt;/code&gt; のタイプを1回だけ選択できます。私たちは、イテレータのように指定する必要はありません &lt;code&gt;u32&lt;/code&gt; 我々は呼び出すことをどこでも値を &lt;code&gt;next&lt;/code&gt; に &lt;code&gt;Counter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a53dfae04bc081765c66dac442860f331c44aeb" translate="yes" xml:space="preserve">
          <source>With mutable data that is globally accessible, it&amp;rsquo;s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it&amp;rsquo;s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</source>
          <target state="translated">グローバルにアクセス可能な変更可能なデータでは、データ競合がないことを確認するのは困難です。そのため、Rustは変更可能な静的変数を安全ではないと見なしています。可能な場合は、第16章で説明した同時実行技術とスレッドセーフスマートポインターを使用して、コンパイラーが異なるスレッドからアクセスされたデータが安全に行われたことを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ef733904e440fafdfd6f6cff1f3753a02bb10342" translate="yes" xml:space="preserve">
          <source>With our new knowledge about iterators, we can change the &lt;code&gt;new&lt;/code&gt; function to take ownership of an iterator as its argument instead of borrowing a slice. We&amp;rsquo;ll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the &lt;code&gt;Config::new&lt;/code&gt; function is doing because the iterator will access the values.</source>
          <target state="translated">イテレータに関する新しい知識があれば、スライスを借用する代わりに、イテレータの所有権を引数として取るように &lt;code&gt;new&lt;/code&gt; 関数を変更できます。スライスの長さと特定の場所へのインデックスをチェックするコードの代わりに、イテレーター機能を使用します。これにより、イテレーターが値にアクセスするため、 &lt;code&gt;Config::new&lt;/code&gt; 関数の動作が明確になります。</target>
        </trans-unit>
        <trans-unit id="813d416dedfb40190d58c273de8f8eb75ea3340b" translate="yes" xml:space="preserve">
          <source>With real world traits these numbers can grow drastically.</source>
          <target state="translated">現実世界の特性を利用すれば、これらの数字は飛躍的に伸びる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b72f5cb005021c9be16f1dc058fb74107683aac5" translate="yes" xml:space="preserve">
          <source>With references and &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, the borrowing rules&amp;rsquo; invariants are enforced at compile time. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, these invariants are enforced &lt;em&gt;at runtime&lt;/em&gt;. With references, if you break these rules, you&amp;rsquo;ll get a compiler error. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, if you break these rules, your program will panic and exit.</source>
          <target state="translated">参照と &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; と、借用ルールの不変条件がコンパイル時に適用されます。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 、これらの不変条件が適用され&lt;em&gt;、実行時に&lt;/em&gt;。参照を使用すると、これらのルールに違反すると、コンパイラエラーが発生します。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; あなたはこれらの規則を破るならば、あなたのプログラムはパニックして終了します。</target>
        </trans-unit>
        <trans-unit id="9baf0229e3e9e6c893294479bb6fe3668b3a0c0e" translate="yes" xml:space="preserve">
          <source>With simple projects, Cargo doesn&amp;rsquo;t provide a lot of value over just using &lt;code&gt;rustc&lt;/code&gt;, but it will prove its worth as your programs become more intricate. With complex projects composed of multiple crates, it&amp;rsquo;s much easier to let Cargo coordinate the build.</source>
          <target state="translated">単純なプロジェクトの場合、Cargoは &lt;code&gt;rustc&lt;/code&gt; を使用するだけではあまり価値がありませんが、プログラムが複雑になるにつれて価値があることがわかります。複数の箱で構成された複雑なプロジェクトでは、Cargoにビルドを調整させる方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="498cc75c7709fdab78e1cc82cb0379d4fbbfc2cc" translate="yes" xml:space="preserve">
          <source>With stdin:</source>
          <target state="translated">stdinで。</target>
        </trans-unit>
        <trans-unit id="06224dc60392a0fce212359437fb5cee57ac9f42" translate="yes" xml:space="preserve">
          <source>With stdout:</source>
          <target state="translated">標準出力で。</target>
        </trans-unit>
        <trans-unit id="93ea5ac4258ad8d0735b4be8347a757702850e37" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;String&lt;/code&gt; type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; タイプ、テキストの変更可能な、成長可能部分をサポートするために、我々は、ヒープ上のメモリの量を割り当て、コンパイル時に未知の、内容を保持する必要があります。これの意味は：</target>
        </trans-unit>
        <trans-unit id="e41ed52cf940fa02215dfc776f98dffa8f13fd94" translate="yes" xml:space="preserve">
          <source>With the above specification in hand, we can present arguments for why particular matchers are legal and others are not.</source>
          <target state="translated">上記の仕様を手に取ると、なぜ特定のマッチアが合法で、他のマッチアが合法ではないのかという議論を提示することができます。</target>
        </trans-unit>
        <trans-unit id="9c5fab965ba18f74e15ee6e594f51c165aae934a" translate="yes" xml:space="preserve">
          <source>With the closure defined, we can change the code in the &lt;code&gt;if&lt;/code&gt; blocks to call the closure to execute the code and get the resulting value. We call a closure like we do a function: we specify the variable name that holds the closure definition and follow it with parentheses containing the argument values we want to use, as shown in Listing 13-6.</source>
          <target state="translated">クロージャを定義し &lt;code&gt;if&lt;/code&gt; 、ifブロックのコードを変更してクロージャを呼び出し、コードを実行して結果の値を取得できます。リスト13-6に示すように、関数と同じようにクロージャを呼び出します。クロージャ定義を保持する変数名を指定し、その後に使用する引数値を含む括弧を続けます。</target>
        </trans-unit>
        <trans-unit id="01c46a1d067cb86c80a793fada3c4bf6ccb8375e" translate="yes" xml:space="preserve">
          <source>With the implementation of this trick, our thread pool is in a working state! Give it a &lt;code&gt;cargo run&lt;/code&gt; and make some requests:</source>
          <target state="translated">このトリックを実装すると、スレッドプールは動作状態になります。それを与える &lt;code&gt;cargo run&lt;/code&gt; 、いくつかの要求を行います。</target>
        </trans-unit>
        <trans-unit id="24a7fa0675f3c1ff0574c22a8d3081db443c0de4" translate="yes" xml:space="preserve">
          <source>With the notion of an item being either public or private, Rust allows item accesses in two cases:</source>
          <target state="translated">アイテムは公開か非公開かという概念で、Rustでは2つのケースでアイテムにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="bc6738ca71c4d0da46b8887fed6bda41f9aa0556" translate="yes" xml:space="preserve">
          <source>With the remaining program logic separated into the &lt;code&gt;run&lt;/code&gt; function, we can improve the error handling, as we did with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-9. Instead of allowing the program to panic by calling &lt;code&gt;expect&lt;/code&gt;, the &lt;code&gt;run&lt;/code&gt; function will return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; when something goes wrong. This will let us further consolidate into &lt;code&gt;main&lt;/code&gt; the logic around handling errors in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">リスト12-9の &lt;code&gt;Config::new&lt;/code&gt; で行ったように、残りのプログラムロジックを &lt;code&gt;run&lt;/code&gt; 関数に分離すると、エラー処理を改善できます。 &lt;code&gt;expect&lt;/code&gt; を呼び出すことによってプログラムがパニックになるのを許可する代わりに、何かがうまくいかない場合、 &lt;code&gt;run&lt;/code&gt; 関数は &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; を返します。これにより、ユーザーフレンドリーな方法でエラーを処理するためのロジックを &lt;code&gt;main&lt;/code&gt; さらに統合できます。リスト12-12は、 &lt;code&gt;run&lt;/code&gt; のシグネチャと本体に加える必要がある変更を示しています。</target>
        </trans-unit>
        <trans-unit id="34d45efbbc694df1116b7475884bd1d2fd47f1c6" translate="yes" xml:space="preserve">
          <source>With the state pattern, the &lt;code&gt;Post&lt;/code&gt; methods and the places we use &lt;code&gt;Post&lt;/code&gt; don&amp;rsquo;t need &lt;code&gt;match&lt;/code&gt; expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</source>
          <target state="translated">状態パターンと、 &lt;code&gt;Post&lt;/code&gt; 方法と我々が使用する場所 &lt;code&gt;Post&lt;/code&gt; 必要ありません &lt;code&gt;match&lt;/code&gt; 表現を、そして新しい状態を追加するために、我々は唯一の新しい構造体を追加し、その1つの構造体の形質メソッドを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="83ff23e8afd931a2cd544c6885efa1601bab61bb" translate="yes" xml:space="preserve">
          <source>With the text in place, edit &lt;em&gt;src/main.rs&lt;/em&gt; and add code to read the file, as shown in Listing 12-4.</source>
          <target state="translated">リスト12-4に示すように、テキストを配置し&lt;em&gt;たら&lt;/em&gt;、&lt;em&gt;src / main.rs&lt;/em&gt;を編集し、ファイルを読み取るコードを追加します。</target>
        </trans-unit>
        <trans-unit id="e0b0d0d55bb8949af2866594443ea68c01592e9d" translate="yes" xml:space="preserve">
          <source>With the two trait bounds specified, the body of &lt;code&gt;notify&lt;/code&gt; can call &lt;code&gt;summarize&lt;/code&gt; and use &lt;code&gt;{}&lt;/code&gt; to format &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">2つの形質境界が指定して、本体 &lt;code&gt;notify&lt;/code&gt; 呼び出すことができる &lt;code&gt;summarize&lt;/code&gt; および使用 &lt;code&gt;{}&lt;/code&gt; 形式の &lt;code&gt;item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7deae3df9bc9dd91ed2ed3e73a23c867198988dd" translate="yes" xml:space="preserve">
          <source>With these changes, let&amp;rsquo;s run our code and make a request. We&amp;rsquo;re no longer printing any data to the terminal, so we won&amp;rsquo;t see any output other than the output from Cargo. When you load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser, you should get a blank page instead of an error. You&amp;rsquo;ve just hand-coded an HTTP request and response!</source>
          <target state="translated">これらの変更を加えて、コードを実行してリクエストを作成しましょう。ターミナルにデータを出力しなくなったため、Cargoからの出力以外の出力は表示されません。&lt;em&gt;127.0.0.1:7878&lt;/em&gt;をWebブラウザーにロードすると、エラーではなく空白のページが表示されます。HTTPリクエストとレスポンスを手動でコーディングしました！</target>
        </trans-unit>
        <trans-unit id="2b8a9662a9a062dbd858ec248c6bcfe6e17a1e8d" translate="yes" xml:space="preserve">
          <source>With these changes, run your server again. Requesting &lt;em&gt;127.0.0.1:7878&lt;/em&gt; should return the contents of &lt;em&gt;hello.html&lt;/em&gt;, and any other request, like &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;, should return the error HTML from &lt;em&gt;404.html&lt;/em&gt;.</source>
          <target state="translated">これらの変更で、サーバーを再度実行します。要求&lt;em&gt;127.0.0.1:7878は、&lt;/em&gt;内容を返す必要があり&lt;em&gt;hello.html&lt;/em&gt;、およびその他の要求を、同じよう&lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;、からのエラーHTMLを返す必要があります&lt;em&gt;404.html&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a7ea5830e4d89ce20b87325d5feaac7885edd633" translate="yes" xml:space="preserve">
          <source>With these changes, the code compiles! We&amp;rsquo;re getting there!</source>
          <target state="translated">これらの変更により、コードがコンパイルされます！着きました！</target>
        </trans-unit>
        <trans-unit id="53fa98175f3edbe33adc271e61ac4777981eaf67" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-21. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-25.</source>
          <target state="translated">これらの変更により、コードはコンパイルされ、リスト20-21の後と同じように機能し続けます。ただし、 &lt;code&gt;Terminate&lt;/code&gt; の種類のメッセージを作成していないため、警告が表示されます。リスト20-25のように &lt;code&gt;Drop&lt;/code&gt; 実装を変更して、この警告を修正しましょう。</target>
        </trans-unit>
        <trans-unit id="86aa3b5dba5f873b63c48b4c86a229ed1fbfd4e1" translate="yes" xml:space="preserve">
          <source>With these extra few lines of code in &lt;code&gt;new&lt;/code&gt;, let&amp;rsquo;s run the program without any arguments again to see what the error looks like now:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; のこれらの余分な数行のコードで、引数なしでプログラムを再度実行して、エラーが今どのように見えるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="96fe782e8597a2f8b432d3a608914c807144f829" translate="yes" xml:space="preserve">
          <source>With this added &lt;code&gt;content&lt;/code&gt; method, everything in Listing 17-11 up to line 7 works as intended.</source>
          <target state="translated">この追加された &lt;code&gt;content&lt;/code&gt; メソッドを使用すると、リスト17-11の7行目までのすべてが意図したとおりに機能します。</target>
        </trans-unit>
        <trans-unit id="6a69a998d97d76e52647bdd19719b61356e441e9" translate="yes" xml:space="preserve">
          <source>With this approach, x and y share ownership of the data via the &lt;code&gt;Rc&lt;/code&gt; (reference count type). &lt;code&gt;RefCell&lt;/code&gt; essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</source>
          <target state="translated">このアプローチでは、xとyは &lt;code&gt;Rc&lt;/code&gt; （参照カウントタイプ）を介してデータの所有権を共有します。 &lt;code&gt;RefCell&lt;/code&gt; は基本的にランタイム借用チェックを実行します。多くても1つのライターまたは複数のリーダーがいつでもデータにアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="e0294acc426b53e8eefb85526ce41c8bfef32085" translate="yes" xml:space="preserve">
          <source>With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let&amp;rsquo;s look at how iterators can improve our implementation of the &lt;code&gt;Config::new&lt;/code&gt; function and the &lt;code&gt;search&lt;/code&gt; function.</source>
          <target state="translated">イテレータに関するこの新しい知識があれば、イテレータを使用してコード内の場所をより明確かつ簡潔にすることにより、第12章のI / Oプロジェクトを改善できます。イテレータが &lt;code&gt;Config::new&lt;/code&gt; 関数と &lt;code&gt;search&lt;/code&gt; 関数の実装をどのように改善できるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e2fb8bb90dda22d23945c9584750688009a769c8" translate="yes" xml:space="preserve">
          <source>With this:</source>
          <target state="translated">これで</target>
        </trans-unit>
        <trans-unit id="f92b2fe5b7dcaebe110b80babf1c63cd9fdd43ef" translate="yes" xml:space="preserve">
          <source>With type annotations added, the syntax of closures looks more similar to the syntax of functions. The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior. We&amp;rsquo;ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</source>
          <target state="translated">型注釈が追加されているため、クロージャーの構文は関数の構文により似ています。以下は、パラメーターに1を追加する関数の定義と、同じ動作を持つクロージャーの構文の垂直比較です。関連パーツを並べるスペースを追加しました。これは、パイプの使用とオプションの構文の量を除いて、クロージャー構文が関数構文にどのように似ているかを示しています。</target>
        </trans-unit>
        <trans-unit id="e12bdc1ee24b9c9117113f7fd06a681041f0f8ca" translate="yes" xml:space="preserve">
          <source>With values that have many parts, we can use the &lt;code&gt;..&lt;/code&gt; syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value. The &lt;code&gt;..&lt;/code&gt; pattern ignores any parts of a value that we haven&amp;rsquo;t explicitly matched in the rest of the pattern. In Listing 18-23, we have a &lt;code&gt;Point&lt;/code&gt; struct that holds a coordinate in three-dimensional space. In the &lt;code&gt;match&lt;/code&gt; expression, we want to operate only on the &lt;code&gt;x&lt;/code&gt; coordinate and ignore the values in the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; fields.</source>
          <target state="translated">多くの部分がある値の場合、 &lt;code&gt;..&lt;/code&gt; 構文を使用して少数の部分のみを使用し、残りを無視することができるため、無視される値ごとにアンダースコアをリストする必要がありません。 &lt;code&gt;..&lt;/code&gt; パターンは、我々が明示的にパターンの残りの部分で一致していないことを値の任意の部分を無視します。リスト18-23では、3次元空間で座標を保持する &lt;code&gt;Point&lt;/code&gt; 構造体があります。 &lt;code&gt;match&lt;/code&gt; 式、我々は、上で動作する &lt;code&gt;x&lt;/code&gt; 座標の値を無視 &lt;code&gt;y&lt;/code&gt; 及び &lt;code&gt;z&lt;/code&gt; フィールドを。</target>
        </trans-unit>
        <trans-unit id="84bf9a3332dbb1aae191337d7acb72ccf285dc36" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, we list the names and signatures of external functions from another language we want to call. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; part defines which &lt;em&gt;application binary interface (ABI)&lt;/em&gt; the external function uses: the ABI defines how to call the function at the assembly level. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI is the most common and follows the C programming language&amp;rsquo;s ABI.</source>
          <target state="translated">&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; ブロック内に、呼び出したい別の言語の外部関数の名前とシグネチャをリストします。 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 定義一部&lt;em&gt;のアプリケーションバイナリインタフェース（ABI）&lt;/em&gt;外部関数用途は：ABIは、アセンブリレベルでの機能を呼び出す方法を定義します。 &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABIは最も一般的であり、Cプログラミング言語のABIに従います。</target>
        </trans-unit>
        <trans-unit id="a3840b923c5773a4355bfcefff4121f0878713eb" translate="yes" xml:space="preserve">
          <source>Within the body of an item that has type parameter declarations, the names of its type parameters are types:</source>
          <target state="translated">タイプ・パラメータ宣言を持つ項目のボディ内では、そのタイプ・パラメータの名前がタイプになります。</target>
        </trans-unit>
        <trans-unit id="c6cad0f75b24acc004189d1ad1ae2454225184aa" translate="yes" xml:space="preserve">
          <source>Within this documentation's grammar, &quot;simple&quot; tokens are given in &lt;a href=&quot;notation#string-table-productions&quot;&gt;string table production&lt;/a&gt; form, and appear in &lt;code&gt;monospace&lt;/code&gt; font.</source>
          <target state="translated">このドキュメントの文法では、「単純な」トークンは&lt;a href=&quot;notation#string-table-productions&quot;&gt;文字列テーブル生成&lt;/a&gt;形式で提供され、 &lt;code&gt;monospace&lt;/code&gt; フォントで表示されます。</target>
        </trans-unit>
        <trans-unit id="e7f884881293efc9c1f179ad8b3973e698991d41" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;compiler_fence&lt;/code&gt;, the &lt;code&gt;assert_eq!&lt;/code&gt; in following code is &lt;em&gt;not&lt;/em&gt; guaranteed to succeed, despite everything happening in a single thread. To see why, remember that the compiler is free to swap the stores to &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; and &lt;code&gt;IS_READ&lt;/code&gt; since they are both &lt;code&gt;Ordering::Relaxed&lt;/code&gt;. If it does, and the signal handler is invoked right after &lt;code&gt;IS_READY&lt;/code&gt; is updated, then the signal handler will see &lt;code&gt;IS_READY=1&lt;/code&gt;, but &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt;. Using a &lt;code&gt;compiler_fence&lt;/code&gt; remedies this situation.</source>
          <target state="translated">&lt;code&gt;compiler_fence&lt;/code&gt; がない場合、 &lt;code&gt;assert_eq!&lt;/code&gt; 次のコードでは、すべてが単一のスレッドで発生しているにもかかわらず、成功する保証はあり&lt;em&gt;ませ&lt;/em&gt;ん。理由を確認するには、ストアが両方とも &lt;code&gt;Ordering::Relaxed&lt;/code&gt; あるため、コンパイラーがストアを &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; および &lt;code&gt;IS_READ&lt;/code&gt; に自由に交換できることを思い出してください。その場合、 &lt;code&gt;IS_READY&lt;/code&gt; が更新された直後にシグナルハンドラーが呼び出されると、シグナルハンドラーには &lt;code&gt;IS_READY=1&lt;/code&gt; が表示されますが、 &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt; が表示されます。 &lt;code&gt;compiler_fence&lt;/code&gt; を使用すると、この状況が改善されます。</target>
        </trans-unit>
        <trans-unit id="4d2efdc6add8e970dc1865be96d1f867d6e1b60c" translate="yes" xml:space="preserve">
          <source>Without a pathname:</source>
          <target state="translated">パスネームなしで</target>
        </trans-unit>
        <trans-unit id="90c928ad5c0a871061baee534c7a9a3eec8a4645" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;Deref&lt;/code&gt; trait, the compiler can only dereference &lt;code&gt;&amp;amp;&lt;/code&gt; references. The &lt;code&gt;deref&lt;/code&gt; method gives the compiler the ability to take a value of any type that implements &lt;code&gt;Deref&lt;/code&gt; and call the &lt;code&gt;deref&lt;/code&gt; method to get a &lt;code&gt;&amp;amp;&lt;/code&gt; reference that it knows how to dereference.</source>
          <target state="translated">なしで &lt;code&gt;Deref&lt;/code&gt; 特性、コンパイラは、間接参照することができます &lt;code&gt;&amp;amp;&lt;/code&gt; 参照を。 &lt;code&gt;deref&lt;/code&gt; 方法は、コンパイラに実装がいることを任意の型の値が取る能力与え &lt;code&gt;Deref&lt;/code&gt; 呼び出すと &lt;code&gt;deref&lt;/code&gt; 取得する方法を &lt;code&gt;&amp;amp;&lt;/code&gt; それが逆参照する方法を知っているかどうかの参照を。</target>
        </trans-unit>
        <trans-unit id="87160e17882870214c0775aca97bd35e735c34ab" translate="yes" xml:space="preserve">
          <source>Working with Environment Variables</source>
          <target state="translated">環境変数を使った作業</target>
        </trans-unit>
        <trans-unit id="90e474d6c66232279cbf06723c1f38f471687b09" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</source>
          <target state="translated">Rustで生のポインタを使用して作業することは珍しく、通常はいくつかのパターンに限定されます。</target>
        </trans-unit>
        <trans-unit id="727515b132b28daa88eb87eebc62a62072364288" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here are some important parts to focus on: the first inline error says &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The reason for this is in the next important part to focus on, the error message. The distilled error message says &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="translated">うわー、そのエラーメッセージは非常に冗長です！ここで注目すべきいくつかの重要な部分があります。最初のインラインエラーは、 &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt; 。この理由は、次の重要な部分であるエラーメッセージにあります。 &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt; エラーメッセージは、特性にバインドされた「送信」が満たされていないことを示しています。 &lt;code&gt;Send&lt;/code&gt; については次のセクションで説明します。これは、スレッドで使用する型が同時状況での使用を意図したものであることを保証する特性の1つです。</target>
        </trans-unit>
        <trans-unit id="130acb06cdbaff87c403e521823abb94f422c9e0" translate="yes" xml:space="preserve">
          <source>Wrap a value to be manually dropped.</source>
          <target state="translated">手動でドロップする値をラップします。</target>
        </trans-unit>
        <trans-unit id="744e431b88ea1a0035f05b8fb26571f5315f1927" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">OK値をラップして、複合結果を作成します。たとえば、 &lt;code&gt;Result::Ok(x)&lt;/code&gt; と &lt;code&gt;Result::from_ok(x)&lt;/code&gt; は同等です。</target>
        </trans-unit>
        <trans-unit id="a120e7e89eaa3b758fd2407bf284e593ba7d4ab0" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">OK値をラップして、複合結果を作成します。たとえば、 &lt;code&gt;Result::Ok(x)&lt;/code&gt; と &lt;code&gt;Result::from_ok(x)&lt;/code&gt; は同等です。&lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd8c3f0758b57991ee8d44e4f6a9dc360915c844" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">エラー値をラップして、複合結果を作成します。たとえば、 &lt;code&gt;Result::Err(x)&lt;/code&gt; と &lt;code&gt;Result::from_error(x)&lt;/code&gt; は同等です。</target>
        </trans-unit>
        <trans-unit id="b038d6e7a645f366cbf4e437083304bafb6bb808" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">エラー値をラップして、複合結果を作成します。たとえば、 &lt;code&gt;Result::Err(x)&lt;/code&gt; と &lt;code&gt;Result::from_error(x)&lt;/code&gt; は同等です。&lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef840afcddbb0c72a9932bf338567231c320f6c4" translate="yes" xml:space="preserve">
          <source>Wrapping</source>
          <target state="translated">Wrapping</target>
        </trans-unit>
        <trans-unit id="743cdade02c9bf9e30517f2de055980f9f8a86fb" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) absolute value. Computes &lt;code&gt;self.abs()&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">（モジュラー）絶対値のラッピング。型の境界でラップアラウンドして &lt;code&gt;self.abs()&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="f4efecec7c636af1ead7e0409272bc8b700c5382" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ラッピング（モジュラー）追加。型の境界でラップアラウンドして &lt;code&gt;self + rhs&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="8112829180296558677473f537db1e33a076f93c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ラップ（モジュラー）除算。型の境界でラップアラウンドして &lt;code&gt;self / rhs&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="3f6391833e153cf10bdb32314ca04ce9ce43dbdd" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">ラップ（モジュラー）除算。 &lt;code&gt;self / rhs&lt;/code&gt; 計算します。符号なしの型でラップされた除算は、通常の除算です。ラッピングが発生する可能性はありません。この関数が存在するため、すべての操作がラッピング操作で考慮されます。</target>
        </trans-unit>
        <trans-unit id="d6bb89dd7e6026b10f235fa3863c6339f2fb774c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) exponentiation. Computes &lt;code&gt;self.pow(exp)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ラッピング（モジュラー）べき乗。型の境界で折り返して、 &lt;code&gt;self.pow(exp)&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="e6b77bd3d8c54b47f23891885173c42858312a14" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ラッピング（モジュラー）乗算。型の境界でラップアラウンドして &lt;code&gt;self * rhs&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="2ad719d382b4d16912e1a91a3a59d2c050db5a30" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) negation. Computes &lt;code&gt;-self&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ラップ（モジュラー）否定。タイプの境界でラップ &lt;code&gt;-self&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="88feadfab016809fcd2984cfd9226aba00462cae" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ラッピング（モジュラー）残り。型の境界でラップして &lt;code&gt;self % rhs&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="bab7a7fcc721ce6448649830e7166d7008062fd3" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;. Wrapped remainder calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">ラッピング（モジュラー）残り。 &lt;code&gt;self % rhs&lt;/code&gt; 計算します。符号なしの型のラップされた剰余計算は、通常の剰余計算です。ラッピングが発生する可能性はありません。この関数が存在するため、すべての操作がラッピング操作で考慮されます。</target>
        </trans-unit>
        <trans-unit id="0547792119ca778e4ded115060f8e8198122f4ee" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ラップ（モジュラー）減算。型の境界でラップして &lt;code&gt;self - rhs&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="9c70c48db93cbf30305f6f367392a85a748eb0d9" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ユークリッド分割をラップします。型の境界でラップアラウンドして &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="0c397d89ed28af23471d1300df82f2628a5cc9eb" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt;.</source>
          <target state="translated">ユークリッド分割をラップします。 &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; を計算します。符号なしの型のラップされた除算は、通常の除算です。ラッピングが発生する可能性はありません。この関数が存在するため、すべての操作がラッピング操作で考慮されます。正の整数の場合、一般的な除算の定義はすべて等しいため、これは &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt; とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="f1a6d61ea92522854260430b74b8667bece5c095" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean modulo. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;. Wrapped modulo calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt;.</source>
          <target state="translated">ユークリッドモジュロのラッピング。 &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; を計算します。符号なしの型のラップされたモジュロ計算は、通常の剰余計算です。ラッピングが発生する可能性はありません。この関数が存在するため、すべての操作がラッピング操作で考慮されます。正の整数の場合、一般的な除算の定義はすべて等しいため、これは &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt; とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="72c3f54557cafd34a10c40361aa84b7aedc96050" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean remainder. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">ユークリッド剰余のラッピング。型の境界でラップアラウンドして &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="c113027998f084fc650feeb5a7a7db8e8206e9c9" translate="yes" xml:space="preserve">
          <source>Wrapping arithmetic can be achieved either through methods like &lt;code&gt;wrapping_add&lt;/code&gt;, or through the &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</source>
          <target state="translated">ラップ算術は、 &lt;code&gt;wrapping_add&lt;/code&gt; などのメソッド、または &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; タイプを使用して実現できます。これは、基礎となる値に対するすべての標準算術演算がラップセマンティクスを持つことを目的としています。</target>
        </trans-unit>
        <trans-unit id="67accd5f5a259bdba5036a1931f5ae6a264b08ff" translate="yes" xml:space="preserve">
          <source>Wrapping the entire closure amounts to a blanket assertion that all captured variables are unwind safe. This has the downside that if new captures are added in the future, they will also be considered unwind safe. Therefore, you may prefer to just wrap individual captures, as shown below. This is more annotation, but it ensures that if a new capture is added which is not unwind safe, you will get a compilation error at that time, which will allow you to consider whether that new capture in fact represent a bug or not.</source>
          <target state="translated">クロージャ全体をラッピングすることは、すべてのキャプチャされた変数が巻き戻しセーフであるというブランケットの主張になります。これは、将来的に新しいキャプチャが追加された場合、それらも巻き戻しセーフとみなされるという欠点があります。そのため、以下に示すように、個々のキャプチャをラップするだけの方が良いかもしれません。これはより多くのアノテーションですが、巻き戻しセーフではない新しいキャプチャが追加された場合、その時点でコンパイルエラーが発生することを保証します。</target>
        </trans-unit>
        <trans-unit id="3012f027dfde83895278c2a37775ef7453b5a48e" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN % -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). In this case, this method returns 0.</source>
          <target state="translated">ラップは、符号付き型の &lt;code&gt;MIN % -1&lt;/code&gt; でのみ発生します（ &lt;code&gt;MIN&lt;/code&gt; は型の負の最小値です）。この場合、このメソッドは0を返します。</target>
        </trans-unit>
        <trans-unit id="5d2a82c1ae568c2138fb6d4aab53c9ab79d15385" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). This is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In this case, this method returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">ラップは、符号付き型の &lt;code&gt;MIN / -1&lt;/code&gt; でのみ発生します（ &lt;code&gt;MIN&lt;/code&gt; は型の負の最小値です）。これは、タイプで表すには大きすぎる正の値 &lt;code&gt;-MIN&lt;/code&gt; と同等です。この場合、このメソッドは &lt;code&gt;MIN&lt;/code&gt; 自体を返します。</target>
        </trans-unit>
        <trans-unit id="44bf3ad335738a5732c68d1f5196155da8fafc7b" translate="yes" xml:space="preserve">
          <source>Wrapping::abs</source>
          <target state="translated">Wrapping::abs</target>
        </trans-unit>
        <trans-unit id="fc3cfb30e84b8ebe6925ae0fbbf5f0d863e96948" translate="yes" xml:space="preserve">
          <source>Wrapping::add</source>
          <target state="translated">Wrapping::add</target>
        </trans-unit>
        <trans-unit id="e4708fa03c855319c8e70d77b4d353eb63d863a1" translate="yes" xml:space="preserve">
          <source>Wrapping::add_assign</source>
          <target state="translated">Wrapping::add_assign</target>
        </trans-unit>
        <trans-unit id="6227b7b51ca5d41b66a8bd3e6ec7e706422dcd02" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand</source>
          <target state="translated">Wrapping::bitand</target>
        </trans-unit>
        <trans-unit id="50986c3cc68dd80bb41b112f5357a4b5cb0ac2fc" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand_assign</source>
          <target state="translated">Wrapping::bitand_assign</target>
        </trans-unit>
        <trans-unit id="b7da20cfd17d521397a2d0c4d7318400486ff1e3" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor</source>
          <target state="translated">Wrapping::bitor</target>
        </trans-unit>
        <trans-unit id="b1f50a490018b194e6eb7c8804a9e9492ca0ae9b" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor_assign</source>
          <target state="translated">Wrapping::bitor_assign</target>
        </trans-unit>
        <trans-unit id="fd32619eaf11a02453eca2921b2682dcb9909981" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor</source>
          <target state="translated">Wrapping::bitxor</target>
        </trans-unit>
        <trans-unit id="4ee45c7807828640fae4c2e2cbbd932b27eab127" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor_assign</source>
          <target state="translated">Wrapping::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="453a622aaaf4b4b2bd85589c0f8774be95ac4938" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow</source>
          <target state="translated">Wrapping::borrow</target>
        </trans-unit>
        <trans-unit id="7842f835a5fa6d18893907fa71602942c78be04d" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow_mut</source>
          <target state="translated">Wrapping::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4251a19204a74bbc8ead142e79f328751693afa6" translate="yes" xml:space="preserve">
          <source>Wrapping::clamp</source>
          <target state="translated">Wrapping::clamp</target>
        </trans-unit>
        <trans-unit id="cf1afade198e332fd9d6aa7668a3bb32f2401d0b" translate="yes" xml:space="preserve">
          <source>Wrapping::clone</source>
          <target state="translated">Wrapping::clone</target>
        </trans-unit>
        <trans-unit id="54ff9aff38c7f4f514610503b3e487387eb07e58" translate="yes" xml:space="preserve">
          <source>Wrapping::clone_from</source>
          <target state="translated">Wrapping::clone_from</target>
        </trans-unit>
        <trans-unit id="f68c352e73999ff6e48da1e988a3a084b81becdc" translate="yes" xml:space="preserve">
          <source>Wrapping::clone_into</source>
          <target state="translated">Wrapping::clone_into</target>
        </trans-unit>
        <trans-unit id="32813d8440ead76b1def56d4e5d7fd137f1714b5" translate="yes" xml:space="preserve">
          <source>Wrapping::cmp</source>
          <target state="translated">Wrapping::cmp</target>
        </trans-unit>
        <trans-unit id="4fecc3db0f0b1e9deb5da5a1f039d7c88813a6bc" translate="yes" xml:space="preserve">
          <source>Wrapping::count_ones</source>
          <target state="translated">Wrapping::count_ones</target>
        </trans-unit>
        <trans-unit id="0707d6a5c3931efbf437f387bfdbb1a8025b4865" translate="yes" xml:space="preserve">
          <source>Wrapping::count_zeros</source>
          <target state="translated">Wrapping::count_zeros</target>
        </trans-unit>
        <trans-unit id="a236a50222c3eb097eb11ec3a8bd688ac72247f5" translate="yes" xml:space="preserve">
          <source>Wrapping::default</source>
          <target state="translated">Wrapping::default</target>
        </trans-unit>
        <trans-unit id="7606cc1196464916bcf7fa22b931dbc498ed2d35" translate="yes" xml:space="preserve">
          <source>Wrapping::div</source>
          <target state="translated">Wrapping::div</target>
        </trans-unit>
        <trans-unit id="b2ae04a0a7ac3514cff2c427720f641e1e13a105" translate="yes" xml:space="preserve">
          <source>Wrapping::div_assign</source>
          <target state="translated">Wrapping::div_assign</target>
        </trans-unit>
        <trans-unit id="818aac7baf3ade93847ccd4565c9412270bfd765" translate="yes" xml:space="preserve">
          <source>Wrapping::eq</source>
          <target state="translated">Wrapping::eq</target>
        </trans-unit>
        <trans-unit id="edf1a00ab01443e1c22b37d5320b28146f8fae8f" translate="yes" xml:space="preserve">
          <source>Wrapping::fmt</source>
          <target state="translated">Wrapping::fmt</target>
        </trans-unit>
        <trans-unit id="da29af44683c629d1953591b5af876af1284f165" translate="yes" xml:space="preserve">
          <source>Wrapping::from</source>
          <target state="translated">Wrapping::from</target>
        </trans-unit>
        <trans-unit id="bb4414a5497b8f006614444c61fdfbf7e351c1e1" translate="yes" xml:space="preserve">
          <source>Wrapping::from_be</source>
          <target state="translated">Wrapping::from_be</target>
        </trans-unit>
        <trans-unit id="8327aab74dc84b766db6b768bb5f0b4fbae51d60" translate="yes" xml:space="preserve">
          <source>Wrapping::from_le</source>
          <target state="translated">Wrapping::from_le</target>
        </trans-unit>
        <trans-unit id="2e5b33409882b1e267e6cfbfc31a1f3c8c97affd" translate="yes" xml:space="preserve">
          <source>Wrapping::ge</source>
          <target state="translated">Wrapping::ge</target>
        </trans-unit>
        <trans-unit id="763baba99ef1af7752d4c399fd9e4f56ca95cae4" translate="yes" xml:space="preserve">
          <source>Wrapping::gt</source>
          <target state="translated">Wrapping::gt</target>
        </trans-unit>
        <trans-unit id="7f52b5e60bdf5a8b75a6f1bee019e4223125b7ea" translate="yes" xml:space="preserve">
          <source>Wrapping::hash</source>
          <target state="translated">Wrapping::hash</target>
        </trans-unit>
        <trans-unit id="439b5d8bd3660d315ca5a58573799ca1f8b650bd" translate="yes" xml:space="preserve">
          <source>Wrapping::hash_slice</source>
          <target state="translated">Wrapping::hash_slice</target>
        </trans-unit>
        <trans-unit id="e6b9c5af34e5d2c6b6aa7479d3ac5762be077d3b" translate="yes" xml:space="preserve">
          <source>Wrapping::into</source>
          <target state="translated">Wrapping::into</target>
        </trans-unit>
        <trans-unit id="8f7f5f2dd4156c437b4278d979eb99568352829c" translate="yes" xml:space="preserve">
          <source>Wrapping::is_negative</source>
          <target state="translated">Wrapping::is_negative</target>
        </trans-unit>
        <trans-unit id="981b618861d8b57a9acf7fd2996a6466724aea1b" translate="yes" xml:space="preserve">
          <source>Wrapping::is_positive</source>
          <target state="translated">Wrapping::is_positive</target>
        </trans-unit>
        <trans-unit id="3e0d9c814180240ed5988fdbca65c34038e05ba2" translate="yes" xml:space="preserve">
          <source>Wrapping::is_power_of_two</source>
          <target state="translated">Wrapping::is_power_of_two</target>
        </trans-unit>
        <trans-unit id="7eee9ab399dbfec97ad14d12d84dd02ef4c06ce3" translate="yes" xml:space="preserve">
          <source>Wrapping::le</source>
          <target state="translated">Wrapping::le</target>
        </trans-unit>
        <trans-unit id="e5ed947e23bd18f2e1dec6dc53205a1c2b9565b1" translate="yes" xml:space="preserve">
          <source>Wrapping::leading_zeros</source>
          <target state="translated">Wrapping::leading_zeros</target>
        </trans-unit>
        <trans-unit id="863ef48643c8bc709efcb07670e6f74b1ce8d7db" translate="yes" xml:space="preserve">
          <source>Wrapping::lt</source>
          <target state="translated">Wrapping::lt</target>
        </trans-unit>
        <trans-unit id="f8c4ed77b17c6dd866e77c6844acb16e3570ccb0" translate="yes" xml:space="preserve">
          <source>Wrapping::max</source>
          <target state="translated">Wrapping::max</target>
        </trans-unit>
        <trans-unit id="b8977c5e6f634623ea3525b2d454af899f6eb091" translate="yes" xml:space="preserve">
          <source>Wrapping::max_value</source>
          <target state="translated">Wrapping::max_value</target>
        </trans-unit>
        <trans-unit id="0450be54fef79761132d1aef7686c837c2fb7d59" translate="yes" xml:space="preserve">
          <source>Wrapping::min</source>
          <target state="translated">Wrapping::min</target>
        </trans-unit>
        <trans-unit id="8e1254c79d384f9bb2963a56f9a7834418921b24" translate="yes" xml:space="preserve">
          <source>Wrapping::min_value</source>
          <target state="translated">Wrapping::min_value</target>
        </trans-unit>
        <trans-unit id="3dbf2ab4711da3ee943c8515466f305c3d067dd6" translate="yes" xml:space="preserve">
          <source>Wrapping::mul</source>
          <target state="translated">Wrapping::mul</target>
        </trans-unit>
        <trans-unit id="193429091dcbc7d316a04f0dc154b88272a65f08" translate="yes" xml:space="preserve">
          <source>Wrapping::mul_assign</source>
          <target state="translated">Wrapping::mul_assign</target>
        </trans-unit>
        <trans-unit id="0210502668266ded14b09843d193035a2b624a28" translate="yes" xml:space="preserve">
          <source>Wrapping::ne</source>
          <target state="translated">Wrapping::ne</target>
        </trans-unit>
        <trans-unit id="d08218c355fb4c595823228061d8f6285a384c7e" translate="yes" xml:space="preserve">
          <source>Wrapping::neg</source>
          <target state="translated">Wrapping::neg</target>
        </trans-unit>
        <trans-unit id="b68d44f8dc9b7bccaa5f89c2580778d3f5c481ca" translate="yes" xml:space="preserve">
          <source>Wrapping::next_power_of_two</source>
          <target state="translated">Wrapping::next_power_of_two</target>
        </trans-unit>
        <trans-unit id="dc08d2689104cf14575e073facb8aec83dc9a31a" translate="yes" xml:space="preserve">
          <source>Wrapping::not</source>
          <target state="translated">Wrapping::not</target>
        </trans-unit>
        <trans-unit id="e5d2695179201fbe97915617ae577e6a74b5df38" translate="yes" xml:space="preserve">
          <source>Wrapping::partial_cmp</source>
          <target state="translated">Wrapping::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fdaf45498033a636d7d91789f724fabd68edb8d" translate="yes" xml:space="preserve">
          <source>Wrapping::pow</source>
          <target state="translated">Wrapping::pow</target>
        </trans-unit>
        <trans-unit id="df24d6f31eef97d8356983a2855db9da91e53388" translate="yes" xml:space="preserve">
          <source>Wrapping::product</source>
          <target state="translated">Wrapping::product</target>
        </trans-unit>
        <trans-unit id="a8d7bbb8b06894e60316bfa8896f3a9ac47a6d64" translate="yes" xml:space="preserve">
          <source>Wrapping::rem</source>
          <target state="translated">Wrapping::rem</target>
        </trans-unit>
        <trans-unit id="da3a26e48c553a9ebd7ad42e38d4c13f4cbb4bde" translate="yes" xml:space="preserve">
          <source>Wrapping::rem_assign</source>
          <target state="translated">Wrapping::rem_assign</target>
        </trans-unit>
        <trans-unit id="307c0e40471bf0ca34f880f97766b03909622b22" translate="yes" xml:space="preserve">
          <source>Wrapping::reverse_bits</source>
          <target state="translated">Wrapping::reverse_bits</target>
        </trans-unit>
        <trans-unit id="133f98b61cd2fc743ea3ab9ab7d24b004d38769b" translate="yes" xml:space="preserve">
          <source>Wrapping::rotate_left</source>
          <target state="translated">Wrapping::rotate_left</target>
        </trans-unit>
        <trans-unit id="3ce34aaff81a8cb1b00504a6d7ba0307a0954a44" translate="yes" xml:space="preserve">
          <source>Wrapping::rotate_right</source>
          <target state="translated">Wrapping::rotate_right</target>
        </trans-unit>
        <trans-unit id="6fea873396e78fa80dc5b81a4b24f5731984d1b4" translate="yes" xml:space="preserve">
          <source>Wrapping::shl</source>
          <target state="translated">Wrapping::shl</target>
        </trans-unit>
        <trans-unit id="9edfd053f58c6dc953850af5f23fe9791136e673" translate="yes" xml:space="preserve">
          <source>Wrapping::shl_assign</source>
          <target state="translated">Wrapping::shl_assign</target>
        </trans-unit>
        <trans-unit id="727c36c7aba1df8a46aafc2245377be316466083" translate="yes" xml:space="preserve">
          <source>Wrapping::shr</source>
          <target state="translated">Wrapping::shr</target>
        </trans-unit>
        <trans-unit id="a459ea5ad750d76affd0bb2928733c2196d44926" translate="yes" xml:space="preserve">
          <source>Wrapping::shr_assign</source>
          <target state="translated">Wrapping::shr_assign</target>
        </trans-unit>
        <trans-unit id="f5b4f5594c248eaa052551544a5613e890f44805" translate="yes" xml:space="preserve">
          <source>Wrapping::signum</source>
          <target state="translated">Wrapping::signum</target>
        </trans-unit>
        <trans-unit id="5421f7a3c097f4803cab58bff1cb7ebfbe6a61cd" translate="yes" xml:space="preserve">
          <source>Wrapping::sub</source>
          <target state="translated">Wrapping::sub</target>
        </trans-unit>
        <trans-unit id="fe50fe98bf767916368abf1c925e7ac3e037c08c" translate="yes" xml:space="preserve">
          <source>Wrapping::sub_assign</source>
          <target state="translated">Wrapping::sub_assign</target>
        </trans-unit>
        <trans-unit id="f72d77e1d30187c514a849ed36c97ad216978037" translate="yes" xml:space="preserve">
          <source>Wrapping::sum</source>
          <target state="translated">Wrapping::sum</target>
        </trans-unit>
        <trans-unit id="3886fc89ccb5cf7ab1ce69c7013954aa90ca533e" translate="yes" xml:space="preserve">
          <source>Wrapping::swap_bytes</source>
          <target state="translated">Wrapping::swap_bytes</target>
        </trans-unit>
        <trans-unit id="bd4ae9e508fe128f587726b34b639594de73a5f6" translate="yes" xml:space="preserve">
          <source>Wrapping::to_be</source>
          <target state="translated">Wrapping::to_be</target>
        </trans-unit>
        <trans-unit id="7885b2e75fcb436776b4e307af4f9e623074994c" translate="yes" xml:space="preserve">
          <source>Wrapping::to_le</source>
          <target state="translated">Wrapping::to_le</target>
        </trans-unit>
        <trans-unit id="28db626412c7da571e95eec9a8ad5fa799e67614" translate="yes" xml:space="preserve">
          <source>Wrapping::to_owned</source>
          <target state="translated">Wrapping::to_owned</target>
        </trans-unit>
        <trans-unit id="73aa20bad1867d0ff4c2d24f0721a5a8eef6a4d8" translate="yes" xml:space="preserve">
          <source>Wrapping::to_string</source>
          <target state="translated">Wrapping::to_string</target>
        </trans-unit>
        <trans-unit id="04d5020a03ae412567480d9d468c0ac47bbeb27e" translate="yes" xml:space="preserve">
          <source>Wrapping::trailing_zeros</source>
          <target state="translated">Wrapping::trailing_zeros</target>
        </trans-unit>
        <trans-unit id="346c87924a2dddfb76d03753bd7557d01a46d89f" translate="yes" xml:space="preserve">
          <source>Wrapping::try_from</source>
          <target state="translated">Wrapping::try_from</target>
        </trans-unit>
        <trans-unit id="d6a7a2b803d2c4bf9add1e2055e52b0b8af45d11" translate="yes" xml:space="preserve">
          <source>Wrapping::try_into</source>
          <target state="translated">Wrapping::try_into</target>
        </trans-unit>
        <trans-unit id="527e0a06e98efe05731d34b8495de7a9c0796355" translate="yes" xml:space="preserve">
          <source>Wrapping::type_id</source>
          <target state="translated">Wrapping::type_id</target>
        </trans-unit>
        <trans-unit id="d8fe6dbee08984aea95f13fc56e0174b6cc4af39" translate="yes" xml:space="preserve">
          <source>Wraps a borrowed reference to a value in a &lt;code&gt;RefCell&lt;/code&gt; box. A wrapper type for an immutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">借りた参照を &lt;code&gt;RefCell&lt;/code&gt; ボックスの値にラップします。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; から不変に借用された値のラッパータイプ。</target>
        </trans-unit>
        <trans-unit id="14edef43e7df9f66193cba2f15582361d72b01a1" translate="yes" xml:space="preserve">
          <source>Wraps a raw C string with a safe C string wrapper.</source>
          <target state="translated">生のC文字列を安全なC文字列ラッパーでラップします。</target>
        </trans-unit>
        <trans-unit id="cc416cf90ebff133d69706f1e45c9ea10f251fd4" translate="yes" xml:space="preserve">
          <source>Wraps a writer and buffers its output.</source>
          <target state="translated">ライターをラップし、その出力をバッファリングします。</target>
        </trans-unit>
        <trans-unit id="8835b45a5ce8372fc5b7a9379d43ba01d8c84d89" translate="yes" xml:space="preserve">
          <source>Wraps a writer and buffers output to it, flushing whenever a newline (&lt;code&gt;0x0a&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;) is detected.</source>
          <target state="translated">ライターをラップして出力をバッファーに入れ、改行（ &lt;code&gt;0x0a&lt;/code&gt; 、 &lt;code&gt;'\n'&lt;/code&gt; ）が検出されるたびにフラッシュします。</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="422b221e3621326874b9013f07f6893cefb36793" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written.</source>
          <target state="translated">このライタにバッファを書き込んで、書き込まれたバイト数を返します。</target>
        </trans-unit>
        <trans-unit id="ae542cbc15e88f2bf807f8d29fc312d51c4f9344" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このライターにバッファーを書き込み、書き込まれたバイト数を返します。&lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e588991feee7d28024ae797d8cc74c94c42f1fc" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このライターにバッファーを書き込み、書き込まれたバイト数を返します。&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad7b7826de9694bab5fc487da2a9381a00705795" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このライターにバッファーを書き込み、書き込まれたバイト数を返します。&lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42d55a3c5a475b3858d14de608fc86cc1e27fad6" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このライターにバッファーを書き込み、書き込まれたバイト数を返します。&lt;a href=&quot;trait.write#tymethod.write&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f289e0fc842fa4a0a0c757a23aec01849b63cc" translate="yes" xml:space="preserve">
          <source>Write a slice as the entire contents of a file.</source>
          <target state="translated">スライスをファイルの内容全体として書き込みます。</target>
        </trans-unit>
        <trans-unit id="fd14b03d8c7f6b0eec5d8071e36c0b064da74395" translate="yes" xml:space="preserve">
          <source>Write a test that fails and run it to make sure it fails for the reason you expect.</source>
          <target state="translated">失敗するテストを書いて、それを実行して、期待する理由で失敗するようにしましょう。</target>
        </trans-unit>
        <trans-unit id="78bcd0015d2edce502b72162bafb8ff8f006ae23" translate="yes" xml:space="preserve">
          <source>Write and run a Hello, world! program using &lt;code&gt;rustc&lt;/code&gt; directly</source>
          <target state="translated">Hello、world！を作成して実行します。 &lt;code&gt;rustc&lt;/code&gt; を直接使用するプログラム</target>
        </trans-unit>
        <trans-unit id="ffab6af2de782f874c56ecf608ce2d84de7c2b88" translate="yes" xml:space="preserve">
          <source>Write formatted data into a buffer, with a newline appended.</source>
          <target state="translated">フォーマットされたデータを、改行を付加してバッファに書き込みます。</target>
        </trans-unit>
        <trans-unit id="fcbfbac0d9c49bc3cad2d435296a9ffe56032aaa" translate="yes" xml:space="preserve">
          <source>Write is implemented for &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; by copying into the slice, overwriting its data.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; の書き込みは、スライスにコピーしてデータを上書きすることで実装されます。</target>
        </trans-unit>
        <trans-unit id="565edb809a298ba756dfab19911a1af435d39eef" translate="yes" xml:space="preserve">
          <source>Write is implemented for &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; by appending to the vector. The vector will grow as needed.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 書き込みは、ベクターに追加することで実装されます。ベクターは必要に応じて成長します。</target>
        </trans-unit>
        <trans-unit id="ba9c763eec2480149fd9cd47639418928770f449" translate="yes" xml:space="preserve">
          <source>Write or modify just enough code to make the new test pass.</source>
          <target state="translated">新しいテストを合格させるために十分なコードを書いたり、修正したりしてください。</target>
        </trans-unit>
        <trans-unit id="25725f1f38f240f2a77af039a57e73d792f138b4" translate="yes" xml:space="preserve">
          <source>Write::by_ref</source>
          <target state="translated">Write::by_ref</target>
        </trans-unit>
        <trans-unit id="b18d29c2778fcf294a1af5583a58fde2428d05bc" translate="yes" xml:space="preserve">
          <source>Write::flush</source>
          <target state="translated">Write::flush</target>
        </trans-unit>
        <trans-unit id="2ad8047081c1571209c8de21b5d8ef496c875bcb" translate="yes" xml:space="preserve">
          <source>Write::write</source>
          <target state="translated">Write::write</target>
        </trans-unit>
        <trans-unit id="7f21bb462deedb47e98867332781d5a55ac1f33c" translate="yes" xml:space="preserve">
          <source>Write::write_all</source>
          <target state="translated">Write::write_all</target>
        </trans-unit>
        <trans-unit id="59885a3e77b05a624ab69e3e736291d1ac54574b" translate="yes" xml:space="preserve">
          <source>Write::write_char</source>
          <target state="translated">Write::write_char</target>
        </trans-unit>
        <trans-unit id="869124fb10adcbc1f8e39c2d520b04d4a2bb69e1" translate="yes" xml:space="preserve">
          <source>Write::write_fmt</source>
          <target state="translated">Write::write_fmt</target>
        </trans-unit>
        <trans-unit id="3bed1d79d195792e3683c2bc152331ab7dd62609" translate="yes" xml:space="preserve">
          <source>Write::write_str</source>
          <target state="translated">Write::write_str</target>
        </trans-unit>
        <trans-unit id="141b04d7eaaf0c8ba6b520a1addb5de1176dd5e6" translate="yes" xml:space="preserve">
          <source>Write::write_vectored</source>
          <target state="translated">Write::write_vectored</target>
        </trans-unit>
        <trans-unit id="791cf1c7de23e0f236576b53f40de7030db55060" translate="yes" xml:space="preserve">
          <source>Writers are defined by two required methods, &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ライターは、2つの必須メソッドである&lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;によって定義されます。</target>
        </trans-unit>
        <trans-unit id="63d019e37d31448a1c36b68f61dbbcb935ed4575" translate="yes" xml:space="preserve">
          <source>Writers are intended to be composable with one another. Many implementors throughout &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; take and provide types which implement the &lt;code&gt;Write&lt;/code&gt; trait.</source>
          <target state="translated">作家は互いに作曲できるように意図されています。&lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::io&lt;/code&gt; &lt;/a&gt;全体の多くの実装者は、 &lt;code&gt;Write&lt;/code&gt; 特性を実装する型を取得して提供します。</target>
        </trans-unit>
        <trans-unit id="a718c79c131f76156d3a6b0d5a5556c990d2570b" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded.</source>
          <target state="translated">このライターに&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;を書き込み、書き込みが成功したかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="9272508b2e41aaf20afc1194eb5b0b6d2dfdc6c9" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[書き込み &lt;code&gt;char&lt;/code&gt; ]書き込みが成功したかどうかを返し、このライターに。&lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="344bd2db5bc9ba178016d1881285c5afaddc4598" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[書き込み &lt;code&gt;char&lt;/code&gt; ]書き込みが成功したかどうかを返し、このライターに。&lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d63a032a19b4234e192d3e267b268acd649fd1b" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[書き込み &lt;code&gt;char&lt;/code&gt; ]書き込みが成功したかどうかを返し、このライターに。&lt;a href=&quot;trait.write#method.write_char&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95220c41379acdd46bdc780a7a0f1e80e449feff" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered.</source>
          <target state="translated">フォーマットされた文字列をこのライタに書き込み、エラーが発生した場合はそれを返します。</target>
        </trans-unit>
        <trans-unit id="ecd98e7e5a4ec62ace4f960c01001be172e4925a" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;../../../io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">フォーマットされた文字列をこのライターに書き込み、発生したエラーを返します。&lt;a href=&quot;../../../io/trait.write#method.write_fmt&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5543389626d86c8e31553df92af2bde941d2a65" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">フォーマットされた文字列をこのライターに書き込み、発生したエラーを返します。&lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de5e6f1aafa20fef122dbeed5a71a42b9aa2cae7" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">フォーマットされた文字列をこのライターに書き込み、発生したエラーを返します。&lt;a href=&quot;io/trait.write#method.write_fmt&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c76861292606f0bb18321f85e96258836dd2770e" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">フォーマットされた文字列をこのライターに書き込み、発生したエラーを返します。&lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ba303c199b9fe4bf1985b876faca69be2aaf9cf" translate="yes" xml:space="preserve">
          <source>Writes a number of bytes starting from a given offset.</source>
          <target state="translated">指定したオフセットから始まるバイト数を書き込みます。</target>
        </trans-unit>
        <trans-unit id="934343889f7324a6e5af2ff1400d9536dbb167e4" translate="yes" xml:space="preserve">
          <source>Writes a number of bytes starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#tymethod.write_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">指定されたオフセットから始まるバイト数を書き込みます。&lt;a href=&quot;../os/unix/fs/trait.fileext#tymethod.write_at&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45af1e55309b26785973c6185f7a9e763b1c820c" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i128&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;i128&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="6bdae3ffbfb54cc26470f2ec7abd8a54cb058931" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i16&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;i16&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="1e459398c36e231b3d36e4260518d1366491f1f6" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i32&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;i32&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="e6d8da557fcf2c2f0d524d8144d83e2c8862ca13" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i64&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;i64&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="53db12ba27efb40f7499916f3539839440705b87" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i8&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;i8&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="330e06c59d6bdbee17d36d76f63e12553c4d97da" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;isize&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;isize&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="45e49a31d6e7c2d2a651050c305491ca7804f21e" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u128&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;u128&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="aa85ed84476923b1cc5d6b7dfba41874a5d706a0" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u16&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;u16&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="d68ef120a557f4627660db1da5fdfbcac01eb533" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u32&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;u32&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="a14997eaf51c4e7602b5505b9d66837490a2a9fe" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u64&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;u64&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="40743e36f9b775608cfba8e00eb78b804913d33f" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u8&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;u8&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="d83f8161e61d59972914ffd1989afe5538474dbc" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;usize&lt;/code&gt; into this hasher.</source>
          <target state="translated">このハッシャーに単一の &lt;code&gt;usize&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="75c98aad5800d7465070b778412dd48f81ecbabf" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded.</source>
          <target state="translated">バイトのスライスをこのライタに書き込み、書き込みが成功したかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="589037d6e27cf4636e5142d1239dc9ad31b05dda" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バイトのスライスをこのライターに書き込み、書き込みが成功したかどうかを返します。&lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fddaf179154fa846c54d2edd52d74504db1eece" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バイトのスライスをこのライターに書き込み、書き込みが成功したかどうかを返します。&lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8235073da555c5bd3bf719f2ab4a2cc258a3445a" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バイトのスライスをこのライターに書き込み、書き込みが成功したかどうかを返します。&lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00e50e6072cf8d9643cbbf27cb278e15b00644e8" translate="yes" xml:space="preserve">
          <source>Writes formatted data into a buffer.</source>
          <target state="translated">フォーマットされたデータをバッファに書き込みます。</target>
        </trans-unit>
        <trans-unit id="b133e539f22c56a49e3bc9bfe584753136fdfcd5" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;Hasher&lt;/code&gt; にデータを書き込みます。</target>
        </trans-unit>
        <trans-unit id="d56d2da40c1790d440e6f30eedb76e01abcaec37" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;../../hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">この &lt;code&gt;Hasher&lt;/code&gt; にデータを書き込みます。&lt;a href=&quot;../../hash/trait.hasher#tymethod.write&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="664b4eecc8d27414cb11c8ab606f3786a94fd297" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;../hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">この &lt;code&gt;Hasher&lt;/code&gt; にデータを書き込みます。&lt;a href=&quot;../hash/trait.hasher#tymethod.write&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
