<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="2c1cd79ab101e360e9a13e652ea38bf6edc2d76e" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt; to enforce the rule that a cage at a zoo can contain only one kind of animal:</source>
          <target state="translated">&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;除外制約&lt;/a&gt;を使用して、動物園のケージには1種類の動物しか入れることができないという規則を適用します。</target>
        </trans-unit>
        <trans-unit id="ed495ec2e832a44d27151818dc3a53eb05f6485b" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="translated">データページのチェックサムを使用して、通常はサイレントであるI / Oシステムによる破損を検出します。チェックサムを有効にすると、パフォーマンスが著しく低下する可能性があります。設定すると、すべてのデータベースのすべてのオブジェクトのチェックサムが計算されます。すべてのチェックサムエラーは&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt;ビューで報告されます。</target>
        </trans-unit>
        <trans-unit id="ce023d8439552305d2edc6e2bf4149ad204ec26c" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">条件付きコマンドを使用して（ &lt;code&gt;IF EXISTS&lt;/code&gt; 句を追加するなど）、データベースオブジェクトを削除します。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="d755e67717cdd34225a86cde8e3134de7095e52a" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">条件付きコマンドを使用して（つまり、 &lt;code&gt;IF EXISTS&lt;/code&gt; 句を追加して）、データベースやその他のオブジェクトを削除します。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="723b15fd565cd7b73cc4c9f69508e6bb65d787d0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">データベースオブジェクトをクリーン &lt;code&gt;IF EXISTS&lt;/code&gt; する場合は、条件付きコマンドを使用します（つまり、IF EXISTS句を追加します）。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="f8dc23b011f6f1a62e695d4c31ea4636fb489dcc" translate="yes" xml:space="preserve">
          <source>Use efficient file cloning (also known as &amp;ldquo;reflinks&amp;rdquo; on some systems) instead of copying files to the new cluster. This can result in near-instantaneous copying of the data files, giving the speed advantages of &lt;code&gt;-k&lt;/code&gt;/&lt;code&gt;--link&lt;/code&gt; while leaving the old cluster untouched.</source>
          <target state="translated">新しいクラスターにファイルをコピーする代わりに、効率的なファイルのクローン作成（一部のシステムでは「reflinks」とも呼ばれます）を使用します。これにより、データファイルがほぼ瞬時にコピーされ、古いクラスターに影響を与えずに &lt;code&gt;-k&lt;/code&gt; / &lt;code&gt;--link&lt;/code&gt; の速度の利点が得られます。</target>
        </trans-unit>
        <trans-unit id="717457386c7410d1c0caadadb8bcf5cee9b94ef2" translate="yes" xml:space="preserve">
          <source>Use genetic query optimization to plan queries with at least this many &lt;code&gt;FROM&lt;/code&gt; items involved. (Note that a &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; construct counts as only one &lt;code&gt;FROM&lt;/code&gt; item.) The default is 12. For simpler queries it is usually best to use the regular, exhaustive-search planner, but for queries with many tables the exhaustive search takes too long, often longer than the penalty of executing a suboptimal plan. Thus, a threshold on the size of the query is a convenient way to manage use of GEQO.</source>
          <target state="translated">遺伝的クエリ最適化を使用して、少なくともこの数の &lt;code&gt;FROM&lt;/code&gt; アイテムが含まれるクエリを計画します。（ &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; 構文は1つの &lt;code&gt;FROM&lt;/code&gt; アイテムとしてのみカウントされることに注意してください。）デフォルトは12です。単純なクエリの場合、通常は完全な検索プランナーを使用するのが最適ですが、多くのテーブルを含むクエリの場合、完全な検索に時間がかかりすぎます、次善の計画を実行するペナルティよりも長いことが多い。したがって、クエリのサイズのしきい値は、GEQOの使用を管理する便利な方法です。</target>
        </trans-unit>
        <trans-unit id="a0976de4de13332a56e83de88d1173b0054dd784" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;INHERITS&lt;/code&gt; creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; を使用すると、新しい子テーブルとその親テーブルの間に永続的な関係が作成されます。親へのスキーマの変更は通常、子にも反映されます。デフォルトでは、子テーブルのデータは親のスキャンに含まれます。</target>
        </trans-unit>
        <trans-unit id="9e4eb26aa371684361e3e419e078890b371282ac" translate="yes" xml:space="preserve">
          <source>Use of most of these functions requires PostgreSQL to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">これらの関数のほとんどを使用するには、PostgreSQLが &lt;code&gt;configure --with-libxml&lt;/code&gt; で構築されている必要があります。</target>
        </trans-unit>
        <trans-unit id="c68e27d415e6287dfc4c6988546eee3d268cda34" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g. &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">記号参照の使用は、 &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; を列の定義にアタッチすることにより、特定のカタログ列で有効になります。ここで、 &lt;code&gt;lookuprule&lt;/code&gt; は、参照されるカタログの名前（pg_procなど） &lt;code&gt;pg_proc&lt;/code&gt; 。 &lt;code&gt;BKI_LOOKUP&lt;/code&gt; は、型の列に取り付けることができる &lt;code&gt;Oid&lt;/code&gt; 、 &lt;code&gt;regproc&lt;/code&gt; 、 &lt;code&gt;oidvector&lt;/code&gt; 、または &lt;code&gt;Oid[]&lt;/code&gt; 。後者の2つのケースでは、配列の各要素に対してルックアップを実行することを意味します。</target>
        </trans-unit>
        <trans-unit id="7de245d3c3aa0bf5e90f594f4cb93e3038943a92" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;RETURNING&lt;/code&gt; clause requires &lt;code&gt;SELECT&lt;/code&gt; privilege on all columns mentioned in &lt;code&gt;RETURNING&lt;/code&gt;. If you use the &lt;code&gt;query&lt;/code&gt; clause to insert rows from a query, you of course need to have &lt;code&gt;SELECT&lt;/code&gt; privilege on any table or column used in the query.</source>
          <target state="translated">使用 &lt;code&gt;RETURNING&lt;/code&gt; 句が必要です &lt;code&gt;SELECT&lt;/code&gt; で言及したすべての列の特権 &lt;code&gt;RETURNING&lt;/code&gt; を。 &lt;code&gt;query&lt;/code&gt; 句を使用してクエリから行を挿入する場合、クエリで使用されるすべてのテーブルまたは列に対する &lt;code&gt;SELECT&lt;/code&gt; 権限が必要です。</target>
        </trans-unit>
        <trans-unit id="2aa84cc2dc2791298c5a401376b7bb182eec75e7" translate="yes" xml:space="preserve">
          <source>Use real data for experimentation. Using test data for setting up indexes will tell you what indexes you need for the test data, but that is all.</source>
          <target state="translated">実データを実験に使う インデックスの設定にテストデータを使えば、テストデータに必要なインデックスがわかりますが、それだけです。</target>
        </trans-unit>
        <trans-unit id="740a1a424b9afbaad4fd5f97eac328593356e696" translate="yes" xml:space="preserve">
          <source>Use semicolon followed by two newlines, rather than just newline, as the command entry terminator.</source>
          <target state="translated">コマンド入力の終端には、改行だけではなく、セミコロンと改行2行を使用してください。</target>
        </trans-unit>
        <trans-unit id="493672dde3eb1e21802c93c463663707684dc28f" translate="yes" xml:space="preserve">
          <source>Use separate session key. Public-key encryption always uses a separate session key; this option is for symmetric-key encryption, which by default uses the S2K key directly.</source>
          <target state="translated">別々のセッション鍵を使用します。公開鍵暗号化は常に別のセッション鍵を使用します。このオプションは対称鍵暗号化のためのもので、デフォルトではS2K鍵を直接使用します。</target>
        </trans-unit>
        <trans-unit id="93c526253accc03345c125a338a69425d93d7a5c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; statement to drop views.</source>
          <target state="translated">&lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt;ステートメントを使用してビューを削除します。</target>
        </trans-unit>
        <trans-unit id="0d8fcf6d0e2c0c387fa9db23f6382b953340061f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションを使用します。詳細については、&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="49e85f329c30105292985206289324c8f90af224" translate="yes" xml:space="preserve">
          <source>Use the alternative column-list syntax to do the same update:</source>
          <target state="translated">代替カラムリスト構文を使用して、同じ更新を行います。</target>
        </trans-unit>
        <trans-unit id="9ae2307b8f401e6a987e3d05544bf2939cd859f9" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_COLLATE&lt;/code&gt; locale category.</source>
          <target state="translated">&lt;code&gt;LC_COLLATE&lt;/code&gt; ロケールカテゴリには、指定されたオペレーティングシステムロケールを使用します。</target>
        </trans-unit>
        <trans-unit id="55a394e7b9e61f2a206b4b6967eab6c67d2c7b7c" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale category.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; ロケールカテゴリには、指定されたオペレーティングシステムロケールを使用します。</target>
        </trans-unit>
        <trans-unit id="b2aa6b91b4c4ba84fa390b2a6da37aa75a60894a" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.87&lt;/a&gt; for more details).</source>
          <target state="translated">データベースのダンプを作成するときに、指定した同期スナップショットを使用します（詳細については、&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;表9.87&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="ee78ab2ce0e01deb66fa480713a33b2c2b35d2ab" translate="yes" xml:space="preserve">
          <source>Use the specified value of &lt;code&gt;extra_float_digits&lt;/code&gt; when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">使用可能な最大の精度ではなく、浮動小数点データをダンプするときに、 &lt;code&gt;extra_float_digits&lt;/code&gt; の指定された値を使用します。バックアップ目的で作成されたルーチンダンプでは、このオプションを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="af4516f566a55d94c31709c01f556432e3bd7291" translate="yes" xml:space="preserve">
          <source>Use the specified value of extra_float_digits when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">浮動小数点データをダンプする際には、利用可能な最大精度ではなく、指定された extra_float_digits の値を使用します。バックアップを目的とした定期的なダンプでは、このオプションを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="6f31da9aa85cb07454372ac17645a52a84247324" translate="yes" xml:space="preserve">
          <source>Use this sequence in an &lt;code&gt;INSERT&lt;/code&gt; command:</source>
          <target state="translated">このシーケンスを &lt;code&gt;INSERT&lt;/code&gt; コマンドで使用します。</target>
        </trans-unit>
        <trans-unit id="29370364d5a3aa7edfb47c0679c084d535a999d7" translate="yes" xml:space="preserve">
          <source>Used to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on any column appearing within &lt;code&gt;index_predicate&lt;/code&gt; is required.</source>
          <target state="translated">部分的に一意のインデックスを推測できるようにするために使用されます。述語を満たすインデックス（実際には部分インデックスである必要はありません）を推測できます。 &lt;code&gt;CREATE INDEX&lt;/code&gt; 形式に従います。 &lt;code&gt;index_predicate&lt;/code&gt; 内に表示される列に対する &lt;code&gt;SELECT&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="1bfbb286795d184b793a60a1094e6c47b8ed4218" translate="yes" xml:space="preserve">
          <source>Useful values for production work probably range from a small number of hours to a few days. Small values (such as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1min&lt;/code&gt;) are only allowed because they may sometimes be useful for testing. While a setting as high as &lt;code&gt;60d&lt;/code&gt; is allowed, please note that in many workloads extreme bloat or transaction ID wraparound may occur in much shorter time frames.</source>
          <target state="translated">生産作業に役立つ値は、おそらく数時間から数日までの範囲です。小さな値（ &lt;code&gt;0&lt;/code&gt; や &lt;code&gt;1min&lt;/code&gt; など）は、テストに役立つ場合があるため、許可されています。 &lt;code&gt;60d&lt;/code&gt; までの設定が許可されていますが、多くのワークロードでは、極端な膨張またはトランザクションIDの折り返しがはるかに短い時間枠で発生する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0aa9c997122e493dfcfb31ff0542b184a558e6ef" translate="yes" xml:space="preserve">
          <source>User Name Maps</source>
          <target state="translated">ユーザー名マップ</target>
        </trans-unit>
        <trans-unit id="657c8b98d31db02ca6e2f49846863d392059fe65" translate="yes" xml:space="preserve">
          <source>User bypasses every row level security policy, see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt; for more information.</source>
          <target state="translated">ユーザーはすべての行レベルのセキュリティポリシーをバイパスします。詳細については、&lt;a href=&quot;ddl-rowsecurity&quot;&gt;セクション5.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="17a367250b51dc731bdf8cbd166e2c6618238172" translate="yes" xml:space="preserve">
          <source>User can create databases</source>
          <target state="translated">ユーザーはデータベースを作成することができます。</target>
        </trans-unit>
        <trans-unit id="0cd638046cbfe5c1f3e3cd84a3d83b310d114f21" translate="yes" xml:space="preserve">
          <source>User can initiate streaming replication and put the system in and out of backup mode.</source>
          <target state="translated">ユーザーはストリーミングレプリケーションを開始し、システムをバックアップモードに入れたり外したりすることができます。</target>
        </trans-unit>
        <trans-unit id="62ff3be7aa18f82b61ae56cce7156698ab778283" translate="yes" xml:space="preserve">
          <source>User is a superuser</source>
          <target state="translated">ユーザーはスーパーユーザー</target>
        </trans-unit>
        <trans-unit id="0381065a82fe9d6c10d8cd3e9089f5c14f9312b8" translate="yes" xml:space="preserve">
          <source>User mapping specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列などのユーザーマッピング固有のオプション</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">ユーザー名</target>
        </trans-unit>
        <trans-unit id="0966c5e99e856745941e09bf863b1894eaa04766" translate="yes" xml:space="preserve">
          <source>User name for the user to run the service as. For domain users, use the format &lt;code&gt;DOMAIN\username&lt;/code&gt;.</source>
          <target state="translated">サービスを実行するユーザーのユーザー名。ドメインユーザーの場合は、 &lt;code&gt;DOMAIN\username&lt;/code&gt; という形式を使用します。</target>
        </trans-unit>
        <trans-unit id="ae03b2f53e94d67697836cc9ddba3d24303f1bd3" translate="yes" xml:space="preserve">
          <source>User name maps are defined in the ident map file, which by default is named &lt;code&gt;pg_ident.conf&lt;/code&gt; and is stored in the cluster's data directory. (It is possible to place the map file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; configuration parameter.) The ident map file contains lines of the general form:</source>
          <target state="translated">ユーザー名マップは、デフォルトでは &lt;code&gt;pg_ident.conf&lt;/code&gt; という名前のidentマップファイルで定義され、クラスターのデータディレクトリに保存されます。（ただし、マップファイルを別の場所に配置することは可能です&lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;。ident_file&lt;/a&gt;構成パラメーターを参照してください。）identマップファイルには、一般的な形式の行が含まれています。</target>
        </trans-unit>
        <trans-unit id="26c83bd5ba1faee58ca4dfcad77ca8603bcdb897" translate="yes" xml:space="preserve">
          <source>User name of the mapping. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. &lt;code&gt;PUBLIC&lt;/code&gt; is used to match all present and future user names in the system.</source>
          <target state="translated">マッピングのユーザー名。 &lt;code&gt;CURRENT_USER&lt;/code&gt; および &lt;code&gt;USER&lt;/code&gt; は、現在のユーザーの名前と一致します。 &lt;code&gt;PUBLIC&lt;/code&gt; は、システム内の現在および将来のすべてのユーザー名を照合するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5f782be03fcdc443b383e428fe084103c7519032" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to create).</source>
          <target state="translated">接続するユーザー名(作成するユーザー名ではありません)。</target>
        </trans-unit>
        <trans-unit id="58a48e5ec3f1ddd8734180ce7a8bcf7ce3e61813" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to drop).</source>
          <target state="translated">接続するユーザー名(ドロップするユーザー名ではありません)。</target>
        </trans-unit>
        <trans-unit id="6c7c5d855fc83ff64eb10669f8523b7d11212f01" translate="yes" xml:space="preserve">
          <source>User name to connect as.</source>
          <target state="translated">接続するユーザー名。</target>
        </trans-unit>
        <trans-unit id="104f2eb40da0056ec5533c282848e3fce154c0c2" translate="yes" xml:space="preserve">
          <source>User name to connect as. Defaults to current operating system user name.</source>
          <target state="translated">接続するユーザー名。デフォルトは、現在のオペレーティングシステムのユーザー名です。</target>
        </trans-unit>
        <trans-unit id="d47cce93b040f97f45693a064d2ec0fe0d47cbfa" translate="yes" xml:space="preserve">
          <source>User-defined constraint triggers (created with &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt;) also give rise to an entry in this table.</source>
          <target state="translated">ユーザー定義の制約トリガー（ &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt; で作成されたもの）も、このテーブルのエントリを生成します。</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">ユーザー定義タイプ</target>
        </trans-unit>
        <trans-unit id="08a19bf7678e0c925ef7e00adabbc0a5965212bf" translate="yes" xml:space="preserve">
          <source>Users (roles) that are to be added to or removed from the group. The users must already exist; &lt;code&gt;ALTER GROUP&lt;/code&gt; does not create or drop users.</source>
          <target state="translated">グループに追加またはグループから削除されるユーザー（ロール）。ユーザーはすでに存在している必要があります。 &lt;code&gt;ALTER GROUP&lt;/code&gt; はユーザーを作成または削除しません。</target>
        </trans-unit>
        <trans-unit id="c368e154de403e348ebf85b5c480f63c95e940b6" translate="yes" xml:space="preserve">
          <source>Users accustomed to working with other SQL database management systems might be disappointed by the performance of the &lt;code&gt;count&lt;/code&gt; aggregate when it is applied to the entire table. A query like:</source>
          <target state="translated">他のSQLデータベース管理システムでの作業に慣れているユーザーは、 &lt;code&gt;count&lt;/code&gt; 集計がテーブル全体に適用されるときのパフォーマンスに失望する可能性があります。次のようなクエリ：</target>
        </trans-unit>
        <trans-unit id="ec14cfda8b568c538e7a2b35ec4764216fe766a6" translate="yes" xml:space="preserve">
          <source>Users can define their own range types. The most common reason to do this is to use ranges over subtypes not provided among the built-in range types. For example, to define a new range type of subtype &lt;code&gt;float8&lt;/code&gt;:</source>
          <target state="translated">ユーザーは独自の範囲タイプを定義できます。これを行う最も一般的な理由は、組み込みの範囲型の中で提供されていないサブタイプの範囲を使用することです。たとえば、サブタイプ &lt;code&gt;float8&lt;/code&gt; の新しい範囲タイプを定義するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="4944fa9df06f02dea3273ddeb97bb2eab5830741" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of user names means that there cannot be different users named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">クラスタのユーザーは、必ずしもクラスタ内のすべてのデータベースにアクセスする特権を持っているとは限りません。ユーザー名の共有は、同じクラスター内の2つのデータベースに &lt;code&gt;joe&lt;/code&gt; という名前の異なるユーザーが存在することはできないことを意味します。ただし、 &lt;code&gt;joe&lt;/code&gt; 一部のデータベースにのみアクセスできるようにシステムを構成できます。</target>
        </trans-unit>
        <trans-unit id="655defefcbd5cf77a94fb403c6b891d5f809540a" translate="yes" xml:space="preserve">
          <source>Users should be clear that tables that are regularly and heavily updated on the primary server will quickly cause cancellation of longer running queries on the standby. In such cases the setting of a finite value for &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; can be considered similar to setting &lt;code&gt;statement_timeout&lt;/code&gt;.</source>
          <target state="translated">プライマリサーバーで定期的かつ頻繁に更新されるテーブルは、スタンバイで長時間実行されているクエリをすぐにキャンセルすることをユーザーは明確にすべきです。このような場合、 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; または &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; の有限値の設定は、 &lt;code&gt;statement_timeout&lt;/code&gt; の設定と同様に考えることができます。</target>
        </trans-unit>
        <trans-unit id="dc34515c6a1d7984b3e11718da650ce1ef5ed348" translate="yes" xml:space="preserve">
          <source>Users sometimes try to declare operators applying just to a domain type. This is possible but is not nearly as useful as it might seem, because the operator resolution rules are designed to select operators applying to the domain's base type. As an example consider</source>
          <target state="translated">ユーザーは時々、ドメインの型だけに適用される演算子を宣言しようとすることがあります。これは可能ですが、見かけほど有用ではありません。なぜなら、演算子解決ルールはドメインのベースタイプに適用される演算子を選択するように設計されているからです。例として以下を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1772f82727e2e70cce145a14908f76eba9dee789" translate="yes" xml:space="preserve">
          <source>Users sometimes wonder why host names are handled in this seemingly complicated way, with two name resolutions including a reverse lookup of the client's IP address. This complicates use of the feature in case the client's reverse DNS entry is not set up or yields some undesirable host name. It is done primarily for efficiency: this way, a connection attempt requires at most two resolver lookups, one reverse and one forward. If there is a resolver problem with some address, it becomes only that client's problem. A hypothetical alternative implementation that only did forward lookups would have to resolve every host name mentioned in &lt;code&gt;pg_hba.conf&lt;/code&gt; during every connection attempt. That could be quite slow if many names are listed. And if there is a resolver problem with one of the host names, it becomes everyone's problem.</source>
          <target state="translated">ユーザーは、クライアントのIPアドレスの逆引きを含む2つの名前解決で、ホスト名がこの一見複雑に見える方法で処理される理由を不思議に思うことがあります。これにより、クライアントの逆引きDNSエントリが設定されていない場合、または望ましくないホスト名が生成された場合に、機能の使用が複雑になります。これは主に効率化のために行われます。この方法では、接続の試行には最大で2つのリゾルバルックアップが必要です。一部のアドレスにリゾルバーの問題がある場合、それはそのクライアントの問題のみになります。前方参照のみを行った架空の代替実装では、 &lt;code&gt;pg_hba.conf&lt;/code&gt; に記載されているすべてのホスト名を解決する必要がありますすべての接続試行中。多くの名前がリストされている場合、それはかなり遅くなる可能性があります。また、ホスト名の1つにリゾルバーの問題がある場合、それは全員の問題になります。</target>
        </trans-unit>
        <trans-unit id="4adcca052990f33f0c6c8200c5c596110e4cd88f" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">ユーザーは、 &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; を発行することで、セッションが読み取り専用かどうかを確認できます。さらに、一連の関数（&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85&lt;/a&gt;）により、ユーザーはスタンバイサーバーに関する情報にアクセスできます。これらにより、データベースの現在の状態を認識するプログラムを作成できます。これらを使用して、回復の進行状況を監視したり、データベースを特定の状態に復元する複雑なプログラムを作成したりできます。</target>
        </trans-unit>
        <trans-unit id="28e2bf0df748000aab563d6b102d035c272f7dd2" translate="yes" xml:space="preserve">
          <source>Users will stop waiting if a fast shutdown is requested. However, as when using asynchronous replication, the server will not fully shutdown until all outstanding WAL records are transferred to the currently connected standby servers.</source>
          <target state="translated">高速シャットダウンが要求された場合、ユーザーは待機を停止します。しかし、非同期レプリケーションを使用している場合と同様に、現在接続されているスタンバイサーバーにすべての未処理のWALレコードが転送されるまで、サーバーは完全にシャットダウンしません。</target>
        </trans-unit>
        <trans-unit id="00379b69f39e7e2d3d7c05f05b12ede542302d0d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; on an object additionally requires &lt;code&gt;relabelfrom&lt;/code&gt; permission for the object in conjunction with its old security label and &lt;code&gt;relabelto&lt;/code&gt; permission for the object in conjunction with its new security label. (In cases where multiple label providers are installed and the user tries to set a security label, but it is not managed by SELinux, only &lt;code&gt;setattr&lt;/code&gt; should be checked here. This is currently not done due to implementation restrictions.)</source>
          <target state="translated">オブジェクトで&lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt;を使用するには、古いセキュリティラベルと併せてオブジェクトの &lt;code&gt;relabelto&lt;/code&gt; 権限と、新しいセキュリティラベルと組み合わせてオブジェクトの &lt;code&gt;relabelfrom&lt;/code&gt; 権限がさらに必要です。（複数のラベルプロバイダーがインストールされており、ユーザーがセキュリティラベルを設定しようとしたが、SELinuxで管理されていない場合は、 &lt;code&gt;setattr&lt;/code&gt; のみをここで確認する必要があります。現在、実装の制限により、これは行われていません。）</target>
        </trans-unit>
        <trans-unit id="7ba7d6f6db215ecebd0a0dd010a3ef4d72762c57" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; on this view, specifically updating the &lt;code&gt;setting&lt;/code&gt; column, is the equivalent of issuing &lt;code&gt;SET&lt;/code&gt; commands. For example, the equivalent of</source>
          <target state="translated">このビューで&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;を使用すること、特に &lt;code&gt;setting&lt;/code&gt; 列を更新することは、 &lt;code&gt;SET&lt;/code&gt; コマンドを発行することと同じです。たとえば、</target>
        </trans-unit>
        <trans-unit id="9f4a279994eeee7b66ef6f4b6c4072e3efe337a2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ALL&lt;/code&gt; for a policy means that it will apply to all commands, regardless of the type of command. If an &lt;code&gt;ALL&lt;/code&gt; policy exists and more specific policies exist, then both the &lt;code&gt;ALL&lt;/code&gt; policy and the more specific policy (or policies) will be applied. Additionally, &lt;code&gt;ALL&lt;/code&gt; policies will be applied to both the selection side of a query and the modification side, using the &lt;code&gt;USING&lt;/code&gt; expression for both cases if only a &lt;code&gt;USING&lt;/code&gt; expression has been defined.</source>
          <target state="translated">ポリシーに &lt;code&gt;ALL&lt;/code&gt; を使用すると、コマンドのタイプに関係なく、すべてのコマンドに適用されます。場合 &lt;code&gt;ALL&lt;/code&gt; 次に、ポリシーが存在し、より具体的なポリシーが存在し、両方の &lt;code&gt;ALL&lt;/code&gt; のポリシーと、より具体的なポリシー（又はポリシー）が適用されます。また、 &lt;code&gt;ALL&lt;/code&gt; ポリシーが使用して、クエリの選択側と変更側の両方に適用されます &lt;code&gt;USING&lt;/code&gt; 場合にのみ、両方のケースのための式を &lt;code&gt;USING&lt;/code&gt; 式が定義されています。</target>
        </trans-unit>
        <trans-unit id="b1caa6904d1b2e3c70cf23410fccedf2e858e4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;DELETE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;DELETE&lt;/code&gt; commands. Only rows that pass this policy will be seen by a &lt;code&gt;DELETE&lt;/code&gt; command. There can be rows that are visible through a &lt;code&gt;SELECT&lt;/code&gt; that are not available for deletion, if they do not pass the &lt;code&gt;USING&lt;/code&gt; expression for the &lt;code&gt;DELETE&lt;/code&gt; policy.</source>
          <target state="translated">ポリシーに &lt;code&gt;DELETE&lt;/code&gt; を使用すると、 &lt;code&gt;DELETE&lt;/code&gt; コマンドに適用されます。このポリシーに合格した行のみが &lt;code&gt;DELETE&lt;/code&gt; コマンドで表示されます。 &lt;code&gt;DELETE&lt;/code&gt; ポリシーの &lt;code&gt;USING&lt;/code&gt; 式を渡さない場合、削除できない &lt;code&gt;SELECT&lt;/code&gt; を介して表示できる行が存在する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8ba736c87dfcbb2c8e16a4a5fbcf41dc4d34ae6e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;INSERT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;INSERT&lt;/code&gt; commands. Rows being inserted that do not pass this policy will result in a policy violation error, and the entire &lt;code&gt;INSERT&lt;/code&gt; command will be aborted. An &lt;code&gt;INSERT&lt;/code&gt; policy cannot have a &lt;code&gt;USING&lt;/code&gt; expression, as it only applies in cases where records are being added to the relation.</source>
          <target state="translated">ポリシーに &lt;code&gt;INSERT&lt;/code&gt; を使用すると、 &lt;code&gt;INSERT&lt;/code&gt; コマンドに適用されます。このポリシーを通過しない行が挿入されると、ポリシー違反エラーが発生し、 &lt;code&gt;INSERT&lt;/code&gt; コマンド全体が中止されます。 &lt;code&gt;INSERT&lt;/code&gt; のポリシーが持つことはできません &lt;code&gt;USING&lt;/code&gt; 、それはレコードだけが関係に追加されている場合に適用されるように、式を。</target>
        </trans-unit>
        <trans-unit id="4584b8b01123eb82dc7847c4d9677c40b0e5bba4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ONLY&lt;/code&gt; to add or drop a constraint on only the partitioned table is supported as long as there are no partitions. Once partitions exist, using &lt;code&gt;ONLY&lt;/code&gt; will result in an error as adding or dropping constraints on only the partitioned table, when partitions exist, is not supported. Instead, constraints on the partitions themselves can be added and (if they are not present in the parent table) dropped.</source>
          <target state="translated">パーティションがない限り、 &lt;code&gt;ONLY&lt;/code&gt; を使用してパーティション分割されたテーブルのみに制約を追加または削除できます。パーティションが存在する場合、 &lt;code&gt;ONLY&lt;/code&gt; を使用するとエラーが発生します。パーティションが存在する場合、パーティションテーブルのみに対する制約の追加または削除はサポートされないためです。代わりに、パーティション自体に対する制約を追加し、（それらが親テーブルに存在しない場合は）削除できます。</target>
        </trans-unit>
        <trans-unit id="9191967f0b2195c21483c93a60dfe19fe3e18ef8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;. If the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; is defined in the client's environment, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">&lt;code&gt;PGCLIENTENCODING&lt;/code&gt; の使用。環境変数 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; がクライアントの環境で定義されている場合、サーバーへの接続が確立されると、そのクライアントエンコーディングが自動的に選択されます。（これは、上記の他の方法のいずれかを使用して後でオーバーライドできます。）</target>
        </trans-unit>
        <trans-unit id="de75f251dab5b0ad3801e8b63609c603b9f339f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SELECT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;SELECT&lt;/code&gt; queries and whenever &lt;code&gt;SELECT&lt;/code&gt; permissions are required on the relation the policy is defined for. The result is that only those records from the relation that pass the &lt;code&gt;SELECT&lt;/code&gt; policy will be returned during a &lt;code&gt;SELECT&lt;/code&gt; query, and that queries that require &lt;code&gt;SELECT&lt;/code&gt; permissions, such as &lt;code&gt;UPDATE&lt;/code&gt;, will also only see those records that are allowed by the &lt;code&gt;SELECT&lt;/code&gt; policy. A &lt;code&gt;SELECT&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being retrieved from the relation.</source>
          <target state="translated">ポリシーに &lt;code&gt;SELECT&lt;/code&gt; を使用すると、 &lt;code&gt;SELECT&lt;/code&gt; クエリに適用され、ポリシーが定義されている関係で &lt;code&gt;SELECT&lt;/code&gt; 権限が必要な場合は常に適用されます。その結果、 &lt;code&gt;SELECT&lt;/code&gt; ポリシーを通過するリレーションからのレコードのみが &lt;code&gt;SELECT&lt;/code&gt; クエリ中に返され、 &lt;code&gt;UPDATE&lt;/code&gt; などの &lt;code&gt;SELECT&lt;/code&gt; 権限を必要とするクエリでも、 &lt;code&gt;SELECT&lt;/code&gt; ポリシーによって許可されているレコードのみが表示されます。 &lt;code&gt;SELECT&lt;/code&gt; ポリシーが持つことができません &lt;code&gt;WITH CHECK&lt;/code&gt; それはレコードのみが関係から取得されている場合に適用されるように、式を。</target>
        </trans-unit>
        <trans-unit id="8ea11f118aea185625aef767542a580e19f76285" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SET client_encoding TO&lt;/code&gt;. Setting the client encoding can be done with this SQL command:</source>
          <target state="translated">&lt;code&gt;SET client_encoding TO&lt;/code&gt; を使用します。クライアントエンコーディングの設定は、次のSQLコマンドで実行できます。</target>
        </trans-unit>
        <trans-unit id="c3e9a2e659e09abe2efa2c5be22d40b62c3aee16" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Type=notify&lt;/code&gt; requires that the server binary was built with &lt;code&gt;configure --with-systemd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type=notify&lt;/code&gt; を使用するには、サーバーバイナリが &lt;code&gt;configure --with-systemd&lt;/code&gt; でビルドされている必要があります。</target>
        </trans-unit>
        <trans-unit id="5f17447546dfac5a3cba43658b86d3ae11e9f49a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;UPDATE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands, as well as auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clauses of &lt;code&gt;INSERT&lt;/code&gt; commands. Since &lt;code&gt;UPDATE&lt;/code&gt; involves pulling an existing record and replacing it with a new modified record, &lt;code&gt;UPDATE&lt;/code&gt; policies accept both a &lt;code&gt;USING&lt;/code&gt; expression and a &lt;code&gt;WITH CHECK&lt;/code&gt; expression. The &lt;code&gt;USING&lt;/code&gt; expression determines which records the &lt;code&gt;UPDATE&lt;/code&gt; command will see to operate against, while the &lt;code&gt;WITH CHECK&lt;/code&gt; expression defines which modified rows are allowed to be stored back into the relation.</source>
          <target state="translated">ポリシーに &lt;code&gt;UPDATE&lt;/code&gt; を使用すると、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 、および &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; コマンドに加えて、 &lt;code&gt;INSERT&lt;/code&gt; コマンドの補助的な &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句にも適用されます。以来 &lt;code&gt;UPDATE&lt;/code&gt; は既存のレコードを引っ張って、新しい変更されたレコードでそれを置き換える必要、 &lt;code&gt;UPDATE&lt;/code&gt; のポリシーは、両方受け入れ &lt;code&gt;USING&lt;/code&gt; 表現と &lt;code&gt;WITH CHECK&lt;/code&gt; 式を。 &lt;code&gt;USING&lt;/code&gt; 記録表現判定する &lt;code&gt;UPDATE&lt;/code&gt; のコマンドは、反対に動作するために表示されますしばらく &lt;code&gt;WITH CHECK&lt;/code&gt; 式は、変更された行をリレーションに保存できるように定義します。</target>
        </trans-unit>
        <trans-unit id="4872b905960b3b0bb609a1d1f16d8a8085172d7f" translate="yes" xml:space="preserve">
          <source>Using WAL results in a significantly reduced number of disk writes, because only the log file needs to be flushed to disk to guarantee that a transaction is committed, rather than every data file changed by the transaction. The log file is written sequentially, and so the cost of syncing the log is much less than the cost of flushing the data pages. This is especially true for servers handling many small transactions touching different parts of the data store. Furthermore, when the server is processing many small concurrent transactions, one &lt;code&gt;fsync&lt;/code&gt; of the log file may suffice to commit many transactions.</source>
          <target state="translated">トランザクションによって変更されるすべてのデータファイルではなく、トランザクションがコミットされることを保証するためにログファイルのみをディスクにフラッシュする必要があるため、WALを使用すると、ディスク書き込みの数が大幅に削減されます。ログファイルは順次書き込まれるため、ログを同期するコストは、データページをフラッシュするコストよりもはるかに低くなります。これは、データストアのさまざまな部分にアクセスする多くの小さなトランザクションを処理するサーバーに特に当てはまります。さらに、サーバーが多数の小さな同時トランザクションを処理している場合、ログファイルの1つの &lt;code&gt;fsync&lt;/code&gt; で多くのトランザクションをコミットするのに十分な場合があります。</target>
        </trans-unit>
        <trans-unit id="2e62e4e51350449dc0eec4f1e12ec4aa76a1f3f9" translate="yes" xml:space="preserve">
          <source>Using a separate script file is advisable any time you want to use more than a single command in the archiving process. This allows all complexity to be managed within the script, which can be written in a popular scripting language such as bash or perl.</source>
          <target state="translated">アーカイブ処理で 1 つ以上のコマンドを使用したい場合は、別のスクリプトファイルを使用することをお勧めします。これにより、すべての複雑さをスクリプト内で管理することができ、bash や perl のような一般的なスクリプト言語で書くことができます。</target>
        </trans-unit>
        <trans-unit id="b28cc95da9f9c8ec1f9441e5caff1c654ea239b4" translate="yes" xml:space="preserve">
          <source>Using a simple integer &lt;code&gt;offset&lt;/code&gt; is preferred when defining an abbreviation whose offset from UTC has never changed, as such abbreviations are much cheaper to process than those that require consulting a time zone definition.</source>
          <target state="translated">UTCからのオフセットが変更されていない略語を定義する場合は、単純な整数 &lt;code&gt;offset&lt;/code&gt; を使用することをお勧めします。そのような略語は、タイムゾーン定義を調べる必要がある略語よりもはるかに安価に処理できるためです。</target>
        </trans-unit>
        <trans-unit id="d159535298801ecd67e86d11daf24d3f29bae4e5" translate="yes" xml:space="preserve">
          <source>Using a table:</source>
          <target state="translated">テーブルを使って</target>
        </trans-unit>
        <trans-unit id="97a7d609ae1fc837ff854c4a8fe8b3cbd1349e8b" translate="yes" xml:space="preserve">
          <source>Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial.</source>
          <target state="translated">pgAdminのような既存のグラフィカルなフロントエンドツールやODBCやJDBCをサポートするオフィススイートを使用して、データベースを作成したり操作したりします。これらの可能性については、このチュートリアルでは説明しません。</target>
        </trans-unit>
        <trans-unit id="9b0ce3043e87fd971bf85082c10b3ea412051c05" translate="yes" xml:space="preserve">
          <source>Using filter expressions at different nesting levels is also allowed. The following example first filters all segments by location, and then returns high heart rate values for these segments, if available:</source>
          <target state="translated">異なる入れ子レベルでフィルタ式を使用することもできます。次の例では、最初にすべてのセグメントを場所別にフィルタリングし、利用可能な場合はこれらのセグメントの心拍数の高い値を返します。</target>
        </trans-unit>
        <trans-unit id="3f87542d489a5d09a003c3d32c1fdd090240fb1a" translate="yes" xml:space="preserve">
          <source>Using huge pages reduces overhead when using large contiguous chunks of memory, as PostgreSQL does, particularly when using large values of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;. To use this feature in PostgreSQL you need a kernel with &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; and &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt;. You will also have to adjust the kernel setting &lt;code&gt;vm.nr_hugepages&lt;/code&gt;. To estimate the number of huge pages needed, start PostgreSQL without huge pages enabled and check the postmaster's anonymous shared memory segment size, as well as the system's huge page size, using the &lt;code&gt;/proc&lt;/code&gt; file system. This might look like:</source>
          <target state="translated">大きなページを使用すると、PostgreSQLのように、連続したメモリの大きなチャンクを使用する場合、特に&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffersの&lt;/a&gt;値が大きい場合にオーバーヘッドが減少します。PostgreSQLでこの機能を使用するには、 &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; および &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt; を指定したカーネルが必要です。また、カーネル設定 &lt;code&gt;vm.nr_hugepages&lt;/code&gt; を調整する必要があります。必要な巨大ページの数を推定するには、巨大ページを有効にせずにPostgreSQLを起動し、 &lt;code&gt;/proc&lt;/code&gt; ファイルシステムを使用して、postmasterの匿名共有メモリセグメントサイズとシステムの巨大ページサイズを確認します。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c0f4579fb33ddb8969cb60774c58272e5c781549" translate="yes" xml:space="preserve">
          <source>Using just common sense, it appears more convenient to store such data as intervals, rather than pairs of numbers. In practice, it even turns out more efficient in most applications.</source>
          <target state="translated">常識的に考えれば、このようなデータは数値のペアではなく、間隔として保存した方が便利なように見えます。実際には、ほとんどのアプリケーションでは、その方が効率的であることがわかります。</target>
        </trans-unit>
        <trans-unit id="a8fc95773ce3956bab8c2e8bf2027d9e849d1b1f" translate="yes" xml:space="preserve">
          <source>Using psql on a recently vacuumed or analyzed database, you can issue queries to see the disk usage of any table:</source>
          <target state="translated">最近バキュームされた、または分析されたデータベース上でpsqlを使用して、任意のテーブルのディスク使用量を確認するためにクエリを発行することができます。</target>
        </trans-unit>
        <trans-unit id="65181e02239e5820a5b7c0dec699536af98e9eef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command recurse to objects owned by other users.</source>
          <target state="translated">&lt;code&gt;CASCADE&lt;/code&gt; オプションを使用すると、コマンドが他のユーザーが所有するオブジェクトに再帰する場合があります。</target>
        </trans-unit>
        <trans-unit id="a3919689ac7e30c1a7b51bdbeb0b298903ed7b06" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command remove objects in other schemas besides the one(s) named.</source>
          <target state="translated">&lt;code&gt;CASCADE&lt;/code&gt; オプションを使用すると、指定したスキーマ以外のスキーマにあるオブジェクトがコマンドによって削除される場合があります。</target>
        </trans-unit>
        <trans-unit id="9d956f8965b7e70f75d823768214bbad6a425210" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;\encoding&lt;/code&gt; command in psql. &lt;code&gt;\encoding&lt;/code&gt; allows you to change client encoding on the fly. For example, to change the encoding to &lt;code&gt;SJIS&lt;/code&gt;, type:</source>
          <target state="translated">psqlで &lt;code&gt;\encoding&lt;/code&gt; コマンドを使用する。 &lt;code&gt;\encoding&lt;/code&gt; 使用すると、オンザフライでクライアントのエンコーディングを変更できます。たとえば、エンコーディングを &lt;code&gt;SJIS&lt;/code&gt; に変更するには、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="ce95ab1950e8fbb1a63e8b189b58b6a856d611e2" translate="yes" xml:space="preserve">
          <source>Using the configuration variable &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;. If the &lt;code&gt;client_encoding&lt;/code&gt; variable is set, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">構成変数&lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;を使用します。場合 &lt;code&gt;client_encoding&lt;/code&gt; 変数が設定されているサーバーへの接続が行われたときに、そのクライアントの符号化方式が自動的に選択されます。（これは、上記の他の方法のいずれかを使用して後でオーバーライドできます。）</target>
        </trans-unit>
        <trans-unit id="7b44d852d97da519564a9d99f8e49c858203cdb6" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;&lt;code&gt;UNION&lt;/code&gt; Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;&lt;code&gt;INTERSECT&lt;/code&gt; Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;&lt;code&gt;EXCEPT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">演算子 &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;INTERSECT&lt;/code&gt; 、および &lt;code&gt;EXCEPT&lt;/code&gt; を使用すると、複数の &lt;code&gt;SELECT&lt;/code&gt; ステートメントの出力を組み合わせて単一の結果セットを形成できます。 &lt;code&gt;UNION&lt;/code&gt; のオペレータは、結果セットの一方または両方にあるすべての行を返します。 &lt;code&gt;INTERSECT&lt;/code&gt; のオペレータは、両方の結果セットに厳密にあるすべての行を返します。 &lt;code&gt;EXCEPT&lt;/code&gt; 演算子は、最初の結果セットではなく、第二にある行を返します。 3つすべてのケースで、 &lt;code&gt;ALL&lt;/code&gt; を指定しない限り、重複する行は削除されます。ノイズワード &lt;code&gt;DISTINCT&lt;/code&gt; を追加して、重複する行の削除を明示的に指定できます。お知らせ &lt;code&gt;DISTINCT&lt;/code&gt; &lt;code&gt;SELECT&lt;/code&gt; 自体のデフォルトは &lt;code&gt;ALL&lt;/code&gt; ですが、ここではデフォルトの動作です。 （下記の&lt;a href=&quot;sql-select#SQL-UNION&quot;&gt; &lt;code&gt;UNION&lt;/code&gt; &lt;/a&gt;節、&lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt; &lt;code&gt;INTERSECT&lt;/code&gt; &lt;/a&gt;節、および&lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt; &lt;code&gt;EXCEPT&lt;/code&gt; &lt;/a&gt;節を参照してください。）</target>
        </trans-unit>
        <trans-unit id="345d4ccffce95dcf05491c18eea8197735fd71fd" translate="yes" xml:space="preserve">
          <source>Using this command, it is possible to either add privileges or restrict one's privileges. If the session user role has the &lt;code&gt;INHERIT&lt;/code&gt; attribute, then it automatically has all the privileges of every role that it could &lt;code&gt;SET ROLE&lt;/code&gt; to; in this case &lt;code&gt;SET ROLE&lt;/code&gt; effectively drops all the privileges assigned directly to the session user and to the other roles it is a member of, leaving only the privileges available to the named role. On the other hand, if the session user role has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, &lt;code&gt;SET ROLE&lt;/code&gt; drops the privileges assigned directly to the session user and instead acquires the privileges available to the named role.</source>
          <target state="translated">このコマンドを使用すると、特権を追加したり、特権を制限したりすることができます。セッションユーザーロールに &lt;code&gt;INHERIT&lt;/code&gt; 属性がある場合は、 &lt;code&gt;SET ROLE&lt;/code&gt; に設定できるすべてのロールのすべての権限が自動的に付与されます。この場合、 &lt;code&gt;SET ROLE&lt;/code&gt; は、セッションユーザーとそれがメンバーである他のロールに直接割り当てられたすべての特権を効果的に削除し、指定されたロールが使用できる特権のみを残します。一方、セッションユーザーロールに &lt;code&gt;NOINHERIT&lt;/code&gt; 属性がある場合、 &lt;code&gt;SET ROLE&lt;/code&gt; はセッションユーザーに直接割り当てられた特権を削除し、代わりに指定されたロールで使用可能な特権を取得します。</target>
        </trans-unit>
        <trans-unit id="bf3833196f5808681a4549e6dae3e11c17ff7d14" translate="yes" xml:space="preserve">
          <source>Using this option is subtly different from writing &lt;code&gt;psql &amp;lt; filename&lt;/code&gt;. In general, both will do what you expect, but using &lt;code&gt;-f&lt;/code&gt; enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand.</source>
          <target state="translated">このオプションの使用は、 &lt;code&gt;psql &amp;lt; filename&lt;/code&gt; 書くこととは微妙に異なります。一般に、どちらも期待どおりの動作をしますが、 &lt;code&gt;-f&lt;/code&gt; を使用すると、行番号付きのエラーメッセージなどのいくつかの優れた機能が有効になります。このオプションを使用すると、起動時のオーバーヘッドが減少する可能性もあります。一方、シェルの入力リダイレクトを使用するバリアントは、（理論的には）すべてを手動で入力した場合とまったく同じ出力が得られることが保証されています。</target>
        </trans-unit>
        <trans-unit id="bb94658d71fedbd45e9091422be0f40e3960ad97" translate="yes" xml:space="preserve">
          <source>Usually, a row reflecting an incorrect entry will have values for only the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; fields.</source>
          <target state="translated">通常、正しくないエントリを反映する行には、 &lt;code&gt;line_number&lt;/code&gt; フィールドと &lt;code&gt;error&lt;/code&gt; フィールドの値しかありません。</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="615ff5ce2e5448f0eae82299f9e03df2b83f7a7d" translate="yes" xml:space="preserve">
          <source>VACUUM &amp;mdash; garbage-collect and optionally analyze a database</source>
          <target state="translated">VACUUM &amp;mdash;ガベージコレクション、およびオプションでデータベースの分析</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="7e2bb4ebd8bb3d86c6acc1d3b34b4607a8278459" translate="yes" xml:space="preserve">
          <source>VALUES &amp;mdash; compute a set of rows</source>
          <target state="translated">VALUES &amp;mdash;行のセットを計算します</target>
        </trans-unit>
        <trans-unit id="df605145d9028810fbbd6bb82ba2cbbdf49fe2f6" translate="yes" xml:space="preserve">
          <source>VALUES Lists</source>
          <target state="translated">VALUESリスト</target>
        </trans-unit>
        <trans-unit id="49310dbe4a27690da5f29db4c406ef0b0e02e27a" translate="yes" xml:space="preserve">
          <source>Vacuum all databases.</source>
          <target state="translated">すべてのデータベースにバキュームをかける。</target>
        </trans-unit>
        <trans-unit id="d78bc05489ae0681fdd181a90fe2d3af72c88331" translate="yes" xml:space="preserve">
          <source>Vacuum all four standard tables before running the test. With neither &lt;code&gt;-n&lt;/code&gt; nor &lt;code&gt;-v&lt;/code&gt;, pgbench will vacuum the &lt;code&gt;pgbench_tellers&lt;/code&gt; and &lt;code&gt;pgbench_branches&lt;/code&gt; tables, and will truncate &lt;code&gt;pgbench_history&lt;/code&gt;.</source>
          <target state="translated">テストを実行する前に、4つの標準テーブルをすべて掃除してください。 &lt;code&gt;-n&lt;/code&gt; も &lt;code&gt;-v&lt;/code&gt; も使用しない場合、pgbenchは &lt;code&gt;pgbench_tellers&lt;/code&gt; および &lt;code&gt;pgbench_branches&lt;/code&gt; テーブルをバキュームし、pgbench_historyを切り捨て &lt;code&gt;pgbench_history&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="558c7ef6cec7040888bc23237bf5bc10ac6c115d" translate="yes" xml:space="preserve">
          <source>Vacuum also allows removal of old files from the &lt;code&gt;pg_xact&lt;/code&gt; subdirectory, which is why the default is a relatively low 200 million transactions. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="translated">Vacuumを使用すると、 &lt;code&gt;pg_xact&lt;/code&gt; サブディレクトリから古いファイルを削除することもできます。これが、デフォルトで2億トランザクションが比較的低い理由です。このパラメーターはサーバーの起動時にのみ設定できますが、テーブルストレージパラメーターを変更することにより、個々のテーブルの設定を減らすことができます。詳細は&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;項24.1.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f4af123f2e65a46f53e9a9ee64ca03a1079be929" translate="yes" xml:space="preserve">
          <source>Vacuum maintains a &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; for each table to keep track of which pages contain only tuples that are known to be visible to all active transactions (and all future transactions, until the page is again modified). This has two purposes. First, vacuum itself can skip such pages on the next run, since there is nothing to clean up.</source>
          <target state="translated">Vacuum は各テーブルの&lt;a href=&quot;storage-vm&quot;&gt;可視性マップ&lt;/a&gt;を維持して、すべてのアクティブなトランザクション（およびページが再度変更されるまで、将来のすべてのトランザクション）から見えることがわかっているタプルのみを含むページを追跡します。これには2つの目的があります。まず、掃除するものが何もないので、vacuum自体は次の実行でそのようなページをスキップできます。</target>
        </trans-unit>
        <trans-unit id="8fb0ba1bca8b404cfdbdb7679f9f4d296fc6f1fa" translate="yes" xml:space="preserve">
          <source>Vacuuming multixacts also allows removal of old files from the &lt;code&gt;pg_multixact/members&lt;/code&gt; and &lt;code&gt;pg_multixact/offsets&lt;/code&gt; subdirectories, which is why the default is a relatively low 400 million multixacts. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="translated">multixactをバキュームすると、 &lt;code&gt;pg_multixact/members&lt;/code&gt; および &lt;code&gt;pg_multixact/offsets&lt;/code&gt; サブディレクトリから古いファイルを削除することもできます。これが、デフォルトで4億のmultixactが比較的低い理由です。このパラメーターはサーバーの起動時にのみ設定できますが、テーブルストレージパラメーターを変更することにより、個々のテーブルの設定を減らすことができます。詳細は&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;項24.1.5.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac19d033655fd012b97b53639462b257da978e6a" translate="yes" xml:space="preserve">
          <source>Valid Types</source>
          <target state="translated">有効なタイプ</target>
        </trans-unit>
        <trans-unit id="c7e5f1bbc3dc93b5ff6072a3bc81757a3ed075d7" translate="yes" xml:space="preserve">
          <source>Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional &lt;code&gt;AD&lt;/code&gt; or &lt;code&gt;BC&lt;/code&gt;. (Alternatively, &lt;code&gt;AD&lt;/code&gt;/&lt;code&gt;BC&lt;/code&gt; can appear before the time zone, but this is not the preferred ordering.) Thus:</source>
          <target state="translated">タイムスタンプタイプの有効な入力は、日付と時刻の連結、その後に続くオプションのタイムゾーン、それに続くオプションの &lt;code&gt;AD&lt;/code&gt; または &lt;code&gt;BC&lt;/code&gt; で構成されます。 （または、 &lt;code&gt;AD&lt;/code&gt; / &lt;code&gt;BC&lt;/code&gt; はタイムゾーンの前に表示できますが、これは優先順序ではありません。）したがって、</target>
        </trans-unit>
        <trans-unit id="c3fd0054c277594413eaed1c75df986510128d67" translate="yes" xml:space="preserve">
          <source>Valid input for these types consists of a time of day followed by an optional time zone. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;Table 8.11&lt;/a&gt; and &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;Table 8.12&lt;/a&gt;.) If a time zone is specified in the input for &lt;code&gt;time without time zone&lt;/code&gt;, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as &lt;code&gt;America/New_York&lt;/code&gt;. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the &lt;code&gt;time with time zone&lt;/code&gt; value.</source>
          <target state="translated">これらのタイプの有効な入力は、時刻とそれに続くオプションのタイムゾーンで構成されます。 （&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;表8.11&lt;/a&gt;および&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;表8.12を&lt;/a&gt;参照してください。）時間帯 &lt;code&gt;time without time zone&lt;/code&gt; 入力に時間帯が指定されている場合、それは警告なしに無視されます。日付を指定することもできますが、 &lt;code&gt;America/New_York&lt;/code&gt; などの夏時間規則を含むタイムゾーン名を使用する場合を除いて、日付は無視されます。この場合、標準または夏時間が適用されるかどうかを判断するために日付を指定する必要があります。適切なタイムゾーンオフセットは &lt;code&gt;time with time zone&lt;/code&gt; 値を持つ時間に記録されます。</target>
        </trans-unit>
        <trans-unit id="844edfde8ce5da216439f5cc862b141254fb9d4a" translate="yes" xml:space="preserve">
          <source>Valid memory units are &lt;code&gt;B&lt;/code&gt; (bytes), &lt;code&gt;kB&lt;/code&gt; (kilobytes), &lt;code&gt;MB&lt;/code&gt; (megabytes), &lt;code&gt;GB&lt;/code&gt; (gigabytes), and &lt;code&gt;TB&lt;/code&gt; (terabytes). The multiplier for memory units is 1024, not 1000.</source>
          <target state="translated">有効なメモリ単位は、 &lt;code&gt;B&lt;/code&gt; （バイト）、 &lt;code&gt;kB&lt;/code&gt; （キロバイト）、 &lt;code&gt;MB&lt;/code&gt; （メガバイト）、 &lt;code&gt;GB&lt;/code&gt; （ギガバイト）、および &lt;code&gt;TB&lt;/code&gt; （テラバイト）です。メモリユニットの乗数は1000ではなく1024です。</target>
        </trans-unit>
        <trans-unit id="239bf25206857881980ea876d3982e5ae2994831" translate="yes" xml:space="preserve">
          <source>Valid starting points for standby queries are generated at each checkpoint on the master. If the standby is shut down while the master is in a shutdown state, it might not be possible to re-enter Hot Standby until the primary is started up, so that it generates further starting points in the WAL logs. This situation isn't a problem in the most common situations where it might happen. Generally, if the primary is shut down and not available anymore, that's likely due to a serious failure that requires the standby being converted to operate as the new primary anyway. And in situations where the primary is being intentionally taken down, coordinating to make sure the standby becomes the new primary smoothly is also standard procedure.</source>
          <target state="translated">スタンバイクエリの有効な開始点は、マスタの各チェックポイントで生成されます。マスターがシャットダウン状態にある間にスタンバイがシャットダウンされた場合、プライマリが起動するまでホットスタンバイを再入力することができない可能性があるため、WALログにさらに開始点が生成されます。このような状況が発生する可能性のある最も一般的な状況では問題ではありません。一般的に、プライマリがシャットダウンされて使用できなくなった場合、それは深刻な障害が発生したために、いずれにせよ新しいプライマリとして動作するようにスタンバイを変換する必要があることが原因である可能性が高いです。また、意図的にプライマリを停止させている状況では、待機状態がスムーズに新しいプライマリになるように調整することも標準的な手順です。</target>
        </trans-unit>
        <trans-unit id="36d562c59f538b4cf6287a1bc49b7023b220600a" translate="yes" xml:space="preserve">
          <source>Valid time units are &lt;code&gt;us&lt;/code&gt; (microseconds), &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), &lt;code&gt;min&lt;/code&gt; (minutes), &lt;code&gt;h&lt;/code&gt; (hours), and &lt;code&gt;d&lt;/code&gt; (days).</source>
          <target state="translated">有効な時間単位は、 &lt;code&gt;us&lt;/code&gt; （マイクロ秒）、 &lt;code&gt;ms&lt;/code&gt; （ミリ秒）、 &lt;code&gt;s&lt;/code&gt; （秒）、 &lt;code&gt;min&lt;/code&gt; （分）、 &lt;code&gt;h&lt;/code&gt; （時間）、および &lt;code&gt;d&lt;/code&gt; （日）です。</target>
        </trans-unit>
        <trans-unit id="dfda311a4ab9af803299c88d82467b20a4636196" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;field&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 有効な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4e71de8159ccd805dfaf84c4abe0cc37c7fd0bef" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">有効な変数名には、文字、数字、およびアンダースコアを含めることができます。詳細については、以下の&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;変数&lt;/a&gt;のセクションを参照してください。変数名では大文字と小文字が区別されます。</target>
        </trans-unit>
        <trans-unit id="6495bdc388499bc5f8ab2cec7e4d413da357e199" translate="yes" xml:space="preserve">
          <source>Validate the catalog entries for the specified operator class, so far as the access method can reasonably do that. For example, this might include testing that all required support functions are provided. The &lt;code&gt;amvalidate&lt;/code&gt; function must return false if the opclass is invalid. Problems should be reported with &lt;code&gt;ereport&lt;/code&gt; messages.</source>
          <target state="translated">指定された演算子クラスのカタログエントリを検証します。ただし、アクセスメソッドがそれを合理的に実行できる場合に限ります。たとえば、必要なサポート機能がすべて提供されているかどうかのテストが含まれる場合があります。 &lt;code&gt;amvalidate&lt;/code&gt; OPCLASSが無効である場合、関数はfalseを返す必要があります。問題は &lt;code&gt;ereport&lt;/code&gt; メッセージで報告する必要があります。</target>
        </trans-unit>
        <trans-unit id="89711f6e0ac15ee4534c22e657dbb299816df29f" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag)</source>
          <target state="translated">無効な数値を検証します(無効フラグをクリアします)。</target>
        </trans-unit>
        <trans-unit id="a914a2300c495dde9a239ee72a952fef70648b1b" translate="yes" xml:space="preserve">
          <source>Value Example</source>
          <target state="translated">値の例</target>
        </trans-unit>
        <trans-unit id="892634b1322b72a29145754cdb909390816e79df" translate="yes" xml:space="preserve">
          <source>Value Expressions</source>
          <target state="translated">値の表現</target>
        </trans-unit>
        <trans-unit id="b69a17e345014c4860d42b3ea12bfd1d74a98205" translate="yes" xml:space="preserve">
          <source>Value Expressions: Aggregate Expressions</source>
          <target state="translated">値の式。集約式</target>
        </trans-unit>
        <trans-unit id="62258d667ea100846bebdafcf33e6ba0d80bc0cf" translate="yes" xml:space="preserve">
          <source>Value Expressions: Array Constructors</source>
          <target state="translated">値の式。配列コンストラクタ</target>
        </trans-unit>
        <trans-unit id="538d0773b42800a1dced9ebd66981d039270223a" translate="yes" xml:space="preserve">
          <source>Value Expressions: Collation Expressions</source>
          <target state="translated">値の式。照合式</target>
        </trans-unit>
        <trans-unit id="09b3d5a6d9bce4eae0f96433329fd2780b515b1d" translate="yes" xml:space="preserve">
          <source>Value Expressions: Column References</source>
          <target state="translated">値の式。カラム参照</target>
        </trans-unit>
        <trans-unit id="0f5899e3893a9e71da04384ff81d2b0668b66cce" translate="yes" xml:space="preserve">
          <source>Value Expressions: Expression Evaluation Rules</source>
          <target state="translated">値の式。式の評価規則</target>
        </trans-unit>
        <trans-unit id="7a33243a5a764268dbc19c7b5d5ffb815f2b2494" translate="yes" xml:space="preserve">
          <source>Value Expressions: Field Selection</source>
          <target state="translated">値の式。フィールドの選択</target>
        </trans-unit>
        <trans-unit id="fc2734409ea30f439f8007a816c89fd5d4964498" translate="yes" xml:space="preserve">
          <source>Value Expressions: Function Calls</source>
          <target state="translated">値の式。関数呼び出し</target>
        </trans-unit>
        <trans-unit id="06ab5a8d541c803b5a6f5f5baa72444250b7d0c9" translate="yes" xml:space="preserve">
          <source>Value Expressions: Operator Invocations</source>
          <target state="translated">値の式。演算子の呼び出し</target>
        </trans-unit>
        <trans-unit id="e5f7f7098e87803a977afb22b3e716623af90f8e" translate="yes" xml:space="preserve">
          <source>Value Expressions: Positional Parameters</source>
          <target state="translated">値の式。位置パラメータ</target>
        </trans-unit>
        <trans-unit id="c58f459ac2b52cf9d74d05fef53f0cf74dcac929" translate="yes" xml:space="preserve">
          <source>Value Expressions: Row Constructors</source>
          <target state="translated">値の式。行のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="2c538998fa55638c7ded3a8a283b8e9feb0bd885" translate="yes" xml:space="preserve">
          <source>Value Expressions: Scalar Subqueries</source>
          <target state="translated">値の式。スカラー副問い合わせ</target>
        </trans-unit>
        <trans-unit id="1da69c14dd40700afb2c0a8abd86f7b740450e6f" translate="yes" xml:space="preserve">
          <source>Value Expressions: Subscripts</source>
          <target state="translated">値の式。添え字</target>
        </trans-unit>
        <trans-unit id="cccb4f69d3a8cb038ef6a413bb2c663923cd9fc0" translate="yes" xml:space="preserve">
          <source>Value Expressions: Type Casts</source>
          <target state="translated">値の式.タイプキャスト</target>
        </trans-unit>
        <trans-unit id="3715da19fdcfeeba7fe50bb93e020a8b25f6a530" translate="yes" xml:space="preserve">
          <source>Value Expressions: Window Function Calls</source>
          <target state="translated">値の式。ウィンドウ関数呼び出し</target>
        </trans-unit>
        <trans-unit id="bf4f8a0decbb4b4fd4371821f1c74ba9a1594ce9" translate="yes" xml:space="preserve">
          <source>Value Storage</source>
          <target state="translated">価値の貯蔵</target>
        </trans-unit>
        <trans-unit id="2977eb7ab7cb1230619c6002ed4cbbc6cc756fa6" translate="yes" xml:space="preserve">
          <source>Value expressions are used in a variety of contexts, such as in the target list of the &lt;code&gt;SELECT&lt;/code&gt; command, as new column values in &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or in search conditions in a number of commands. The result of a value expression is sometimes called a &lt;em&gt;scalar&lt;/em&gt;, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called &lt;em&gt;scalar expressions&lt;/em&gt; (or even simply &lt;em&gt;expressions&lt;/em&gt;). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations.</source>
          <target state="translated">値式は、 &lt;code&gt;SELECT&lt;/code&gt; コマンドのターゲットリスト、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; の新しい列値として、またはいくつかのコマンドの検索条件など、さまざまなコンテキストで使用されます。値式の結果は、テーブル式（テーブル）の結果と区別するために、&lt;em&gt;スカラー&lt;/em&gt;と呼ばれることがあります。したがって、&lt;em&gt;値式はスカラー式&lt;/em&gt;（または単に&lt;em&gt;式&lt;/em&gt;）とも呼ばれます。式の構文では、算術演算、論理演算、セット演算、およびその他の演算を使用して、プリミティブパーツから値を計算できます。</target>
        </trans-unit>
        <trans-unit id="114f96aeed1ddb1f81a693ccadc122b00691f706" translate="yes" xml:space="preserve">
          <source>Value that &lt;code&gt;RESET&lt;/code&gt; would reset the parameter to in the current session</source>
          <target state="translated">値 &lt;code&gt;RESET&lt;/code&gt; は、現在のセッションでのパラメータをリセットします</target>
        </trans-unit>
        <trans-unit id="28c18b9457473dab8964985ffc208f4a1973292c" translate="yes" xml:space="preserve">
          <source>Value to be assigned to the parameter</source>
          <target state="translated">パラメータに割り当てる値</target>
        </trans-unit>
        <trans-unit id="f84541e98210f793e8890e82c64afbe27a9c9a73" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;false&lt;/code&gt; literal</source>
          <target state="translated">JSON &lt;code&gt;false&lt;/code&gt; リテラルとの比較を実行するために使用される値</target>
        </trans-unit>
        <trans-unit id="f129faa853bacb07b12134ac4fd986301a263b11" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;null&lt;/code&gt; value</source>
          <target state="translated">JSON &lt;code&gt;null&lt;/code&gt; 値との比較を実行するために使用される値</target>
        </trans-unit>
        <trans-unit id="8a792873148b2fe92c538941fe93212a85f960e9" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;true&lt;/code&gt; literal</source>
          <target state="translated">JSON &lt;code&gt;true&lt;/code&gt; リテラルとの比較を実行するために使用される値</target>
        </trans-unit>
        <trans-unit id="e8086792911df062e24caa3131a5135743c9b16c" translate="yes" xml:space="preserve">
          <source>Value/Predicate</source>
          <target state="translated">Value/Predicate</target>
        </trans-unit>
        <trans-unit id="1f1cb2e6759dab2334119644e8cf129ac32ce11d" translate="yes" xml:space="preserve">
          <source>Values are stored internally as 64-bit floating point numbers. This means that numbers with more than about 16 significant digits will be truncated.</source>
          <target state="translated">値は内部的に64ビット浮動小数点数として格納されます。これは、約 16 桁以上の有効数字は切り捨てられることを意味します。</target>
        </trans-unit>
        <trans-unit id="6d7efb522647e3ca74917dae6abd528277b3ab9e" translate="yes" xml:space="preserve">
          <source>Values needed to run one PostgreSQL instance</source>
          <target state="translated">1つのPostgreSQLインスタンスを実行するために必要な値</target>
        </trans-unit>
        <trans-unit id="8d380e11f26f75eaba033d74818adbe55ddca1de" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; data types can be cast to &lt;code&gt;money&lt;/code&gt;. Conversion from the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; data types can be done by casting to &lt;code&gt;numeric&lt;/code&gt; first, for example:</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、および &lt;code&gt;bigint&lt;/code&gt; データ型の値は &lt;code&gt;money&lt;/code&gt; にキャストできます。 &lt;code&gt;real&lt;/code&gt; データ型と &lt;code&gt;double precision&lt;/code&gt; データ型からの変換は、最初に &lt;code&gt;numeric&lt;/code&gt; キャストすることで実行できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="6a94b34531e2a116d1ab90afc1f71919f7dc0067" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; can be obtained only from the &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list&lt;/code&gt; の値は、 &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; 列からのみ取得できます。</target>
        </trans-unit>
        <trans-unit id="3b87bdbb02446940728e896c08b8825bde2b21b0" translate="yes" xml:space="preserve">
          <source>Values of this domain are allowed to be null. This is the default.</source>
          <target state="translated">このドメインの値はヌルにすることができます。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="d29119abb7de6b63218065ed67e351db8dc51728" translate="yes" xml:space="preserve">
          <source>Values of this domain are prevented from being null (but see notes below).</source>
          <target state="translated">このドメインの値はNULLになることはありません(ただし、以下の注意事項を参照してください)。</target>
        </trans-unit>
        <trans-unit id="0d30cecbfdbc76e7857e49ac92bd25f13ef34d9b" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;character&lt;/code&gt; are physically padded with spaces to the specified width &lt;code&gt;n&lt;/code&gt;, and are stored and displayed that way. However, trailing spaces are treated as semantically insignificant and disregarded when comparing two values of type &lt;code&gt;character&lt;/code&gt;. In collations where whitespace is significant, this behavior can produce unexpected results; for example &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; returns true, even though &lt;code&gt;C&lt;/code&gt; locale would consider a space to be greater than a newline. Trailing spaces are removed when converting a &lt;code&gt;character&lt;/code&gt; value to one of the other string types. Note that trailing spaces &lt;em&gt;are&lt;/em&gt; semantically significant in &lt;code&gt;character varying&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; values, and when using pattern matching, that is &lt;code&gt;LIKE&lt;/code&gt; and regular expressions.</source>
          <target state="translated">&lt;code&gt;character&lt;/code&gt; 型の値は、指定された幅 &lt;code&gt;n&lt;/code&gt; までスペースで物理的に埋め込まれ、そのように格納および表示されます。ただし、 &lt;code&gt;character&lt;/code&gt; 型の2つの値を比較する場合、末尾のスペースは意味的に重要ではないと見なされ、無視されます。空白が重要な照合では、この動作により予期しない結果が生じる可能性があります。たとえば、 &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; はtrueを返しますが、 &lt;code&gt;C&lt;/code&gt; ロケールではスペースが改行よりも大きいと見なされます。 &lt;code&gt;character&lt;/code&gt; 値を他の文字列タイプの1つに変換すると、末尾のスペースが削除されます。末尾のスペース&lt;em&gt;は&lt;/em&gt;意味的に重要であることに注意してください &lt;code&gt;character varying&lt;/code&gt; と &lt;code&gt;text&lt;/code&gt; 値、およびパターンマッチングを使用する場合、 &lt;code&gt;LIKE&lt;/code&gt; と正規表現です。</target>
        </trans-unit>
        <trans-unit id="0d0e8ddc497a1b9c951f5949c5d9e1b70b9a22cd" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;path&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">タイプ &lt;code&gt;path&lt;/code&gt; 値は、次の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="d80b51f9c7fc6e7a8b7e3fe299274555e9a2ae02" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;polygon&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">タイプ &lt;code&gt;polygon&lt;/code&gt; の値は、以下の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="e5a16467bfe399e24f49eb7fdb667ccec5d8723e" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER DATABASE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt; are applied only when starting a fresh database session. They override values obtained from the configuration files or server command line, and constitute defaults for the rest of the session. Note that some settings cannot be changed after server start, and so cannot be set with these commands (or the ones listed below).</source>
          <target state="translated">&lt;code&gt;ALTER DATABASE&lt;/code&gt; および &lt;code&gt;ALTER ROLE&lt;/code&gt; で設定された値は、新しいデータベースセッションを開始するときにのみ適用されます。これらは、構成ファイルまたはサーバーのコマンドラインから取得した値を上書きし、残りのセッションのデフォルトを構成します。一部の設定はサーバーの起動後に変更できないため、これらのコマンド（または以下のコマンド）では設定できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="818a4a9f523da08f985a8d7bb8387b916781ef1a" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will be effective after the next server configuration reload, or after the next server restart in the case of parameters that can only be changed at server start. A server configuration reload can be commanded by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, running &lt;code&gt;pg_ctl reload&lt;/code&gt;, or sending a SIGHUP signal to the main server process.</source>
          <target state="translated">&lt;code&gt;ALTER SYSTEM&lt;/code&gt; で設定された値は、次のサーバー構成の再ロード後、またはサーバーの起動時にのみ変更できるパラメーターの場合は次のサーバーの再起動後に有効になります。サーバー構成の再読み込みは、SQL関数 &lt;code&gt;pg_reload_conf()&lt;/code&gt; を呼び出すか、 &lt;code&gt;pg_ctl reload&lt;/code&gt; を実行するか、メインサーバープロセスにSIGHUPシグナルを送信することで実行できます。</target>
        </trans-unit>
        <trans-unit id="8e2a94acd55e77d304a8881179a17d08010c723b" translate="yes" xml:space="preserve">
          <source>Values to be inserted into a table are converted to the destination column's data type according to the following steps.</source>
          <target state="translated">テーブルに挿入される値は、以下の手順に従って、挿入先のカラムのデータ型に変換されます。</target>
        </trans-unit>
        <trans-unit id="543a387448ddbbf661178992c3adaa7b069168fb" translate="yes" xml:space="preserve">
          <source>Values: 0 - Without salt. Dangerous! 1 - With salt but with fixed iteration count. 3 - Variable iteration count. Default: 3 Applies to: pgp_sym_encrypt</source>
          <target state="translated">値。0-塩抜き。危ない! 1-塩を使用しますが、反復回数が固定されています。3-反復回数が可変です。デフォルト:3 適用対象:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e85fa17c91ce0d6924e2ed0119f352ea3f8fb549" translate="yes" xml:space="preserve">
          <source>Values: 0 - no compression 1 - ZIP compression 2 - ZLIB compression (= ZIP plus meta-data and block CRCs) Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">値を指定します。0-圧縮なし 1-ZIP圧縮 2-ZLIB圧縮(=ZIPにメタデータとブロックCRCを加えたもの)デフォルト:0 適用対象:pgp_sym_encrypt、pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="52218ba89357173a5dfb8618986a1e8fdfb757a3" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt</source>
          <target state="translated">値を指定します。0,1 デフォルト:0 適用対象:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="922303e052dbc79ebb5e801b79cffb9186efe35c" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">値を指定します。0,1 デフォルト:0 適用対象:pgp_sym_encrypt,pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="bbe411494b7a8541ba3eda983d9fa94b6f7dde40" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</source>
          <target state="translated">値を指定します。0,1 デフォルト:0 適用対象:pgp_sym_encrypt,pgp_pub_encrypt,pgp_sym_decrypt,pgp_pub_decrypt</target>
        </trans-unit>
        <trans-unit id="87f52252bc49eca143f466418a46bf231d397765" translate="yes" xml:space="preserve">
          <source>Values: 0, 1-9 Default: 6 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">値を指定します。0,1-9 デフォルト:6 適用対象:pgp_sym_encrypt,pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="631bb9d3f376659e6d97cddb0d8676370c2c08b3" translate="yes" xml:space="preserve">
          <source>Values: bf, aes, aes128, aes192, aes256 Default: use cipher-algo Applies to: pgp_sym_encrypt</source>
          <target state="translated">値:bf,aes,aes128,aes192,aes256 デフォルト:use cipher-algo 適用対象:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e9d1d35bfb5be3f756eb7a018b33d9e394f847ba" translate="yes" xml:space="preserve">
          <source>Values: bf, aes128, aes192, aes256 (OpenSSL-only: &lt;code&gt;3des&lt;/code&gt;, &lt;code&gt;cast5&lt;/code&gt;) Default: aes128 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">値：bf、aes128、aes192、aes256（OpenSSLのみ： &lt;code&gt;3des&lt;/code&gt; 、 &lt;code&gt;cast5&lt;/code&gt; ）デフォルト：aes128適用対象：pgp_sym_encrypt、pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="777af837f1de8927748898b65d1060bc773bad7b" translate="yes" xml:space="preserve">
          <source>Values: md5, sha1 Default: sha1 Applies to: pgp_sym_encrypt</source>
          <target state="translated">値:md5,sha1 デフォルト:sha1 適用対象:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a0b72534c52ce05719721c1bfff6524b4aef3cf8" translate="yes" xml:space="preserve">
          <source>Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as &lt;code&gt;':foo'&lt;/code&gt; doesn't work to produce a quoted literal from a variable's value (and it would be unsafe if it did work, since it wouldn't correctly handle quotes embedded in the value).</source>
          <target state="translated">変数の補間は、引用符で囲まれたSQLリテラルと識別子内では実行されません。したがって、 &lt;code&gt;':foo'&lt;/code&gt; などの構造は、変数の値から引用されたリテラルを生成するように機能しません（そして、値に埋め込まれた引用符を正しく処理しないため、機能した場合は安全ではありません）。</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f20578601408732c8ea02e8d928be3d22ba16637" translate="yes" xml:space="preserve">
          <source>Variables that control psql's behavior generally cannot be unset or set to invalid values. An &lt;code&gt;\unset&lt;/code&gt; command is allowed but is interpreted as setting the variable to its default value. A &lt;code&gt;\set&lt;/code&gt; command without a second argument is interpreted as setting the variable to &lt;code&gt;on&lt;/code&gt;, for control variables that accept that value, and is rejected for others. Also, control variables that accept the values &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; will also accept other common spellings of Boolean values, such as &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">psqlの動作を制御する変数は、通常、設定を解除したり、無効な値に設定したりすることはできません。 &lt;code&gt;\unset&lt;/code&gt; コマンドが許可されますが、デフォルト値に変数を設定すると解釈されます。 &lt;code&gt;\set&lt;/code&gt; 第二引数なしのコマンドは、変数を設定すると解釈される &lt;code&gt;on&lt;/code&gt; 、その値を受け入れる制御変数のために、そして他人のために拒否されます。また、値 &lt;code&gt;on&lt;/code&gt; および &lt;code&gt;off&lt;/code&gt; を受け入れる制御変数は、 &lt;code&gt;true&lt;/code&gt; や &lt;code&gt;false&lt;/code&gt; など、ブール値の他の一般的なスペルも受け入れます。</target>
        </trans-unit>
        <trans-unit id="71d1d14c3d8bef73e900f87a2c49118ec1795b0b" translate="yes" xml:space="preserve">
          <source>Various other settings related to &amp;ldquo;semaphore undo&amp;rdquo;, such as &lt;code&gt;SEMMNU&lt;/code&gt; and &lt;code&gt;SEMUME&lt;/code&gt;, do not affect PostgreSQL.</source>
          <target state="translated">&lt;code&gt;SEMMNU&lt;/code&gt; や &lt;code&gt;SEMUME&lt;/code&gt; など、「セマフォの取り消し」に関連するその他のさまざまな設定は、PostgreSQLには影響しません。</target>
        </trans-unit>
        <trans-unit id="bd6240cba4fe3aa73d43764309d30fb6d3d037a4" translate="yes" xml:space="preserve">
          <source>Various parameters have been mentioned above in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt; and &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;Section 26.5.3&lt;/a&gt;.</source>
          <target state="translated">さまざまなパラメータについては、&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;セクション26.5.2&lt;/a&gt;および&lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;セクション26.5.3で説明してい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d5b3325956fac55ce90bb38fba311678783c4a5a" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">検証は、インデックススキャン自体で使用されるものと同じ手順を使用して実行されます。これは、ユーザー定義の演算子クラスコードである場合があります。たとえば、Bツリーインデックスの検証は、1つ以上のBツリーサポート関数1ルーチンで行われた比較に依存しています。参照&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;セクション37.16.3を&lt;/a&gt;演算子クラスのサポート機能の詳細については。</target>
        </trans-unit>
        <trans-unit id="875530bb85a9bc9a572c1b81ee549fe16ccb6d4b" translate="yes" xml:space="preserve">
          <source>Version and Platform Compatibility</source>
          <target state="translated">バージョンとプラットフォームの互換性</target>
        </trans-unit>
        <trans-unit id="1d9929f1f28bbd8834745a088bfee2450b12d5d8" translate="yes" xml:space="preserve">
          <source>Version name</source>
          <target state="translated">バージョン名</target>
        </trans-unit>
        <trans-unit id="2597e3332e662024a1086db859f74acc32e53a21" translate="yes" xml:space="preserve">
          <source>Version name for the extension</source>
          <target state="translated">拡張機能のバージョン名</target>
        </trans-unit>
        <trans-unit id="29156f5ef29fca0492cf46682a435025e1953ccd" translate="yes" xml:space="preserve">
          <source>Version number</source>
          <target state="translated">バージョン番号</target>
        </trans-unit>
        <trans-unit id="637ea0ea7f40808c77700c1c4f68ba0087e0490c" translate="yes" xml:space="preserve">
          <source>Version of SSL in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">使用している SSL のバージョン、またはこの接続で SSL が使用されていない場合は NULL</target>
        </trans-unit>
        <trans-unit id="20a77b4ce23e6a598792ebba9c5fa53b934c43a3" translate="yes" xml:space="preserve">
          <source>Version of the server (optional)</source>
          <target state="translated">サーバーのバージョン(オプション</target>
        </trans-unit>
        <trans-unit id="2002aefc5b11f637b7466ee1a13c20a9e6171391" translate="yes" xml:space="preserve">
          <source>Vertical tab (ASCII 11)</source>
          <target state="translated">縦タブ(ASCII 11</target>
        </trans-unit>
        <trans-unit id="9fe85f9993f6a26e677373400348d89af1072a3c" translate="yes" xml:space="preserve">
          <source>Very long-lived write transactions</source>
          <target state="translated">非常に長持ちする書き込みトランザクション</target>
        </trans-unit>
        <trans-unit id="30f98f07baa783307d6eeb3e956be798331b0ca1" translate="yes" xml:space="preserve">
          <source>Victor Wagner &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Cryptocom LTD</source>
          <target state="translated">ビクターワグナー &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; 、Cryptocom LTD</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="bf0400b0f3aafc0bb49249e45dc8694f8cdb7fdb" translate="yes" xml:space="preserve">
          <source>View Name</source>
          <target state="translated">名前を見る</target>
        </trans-unit>
        <trans-unit id="33ef89bbb476e8982fc98b280a43e4c9b99ae10c" translate="yes" xml:space="preserve">
          <source>View all the locks currently outstanding, all the locks on relations in a particular database, all the locks on a particular relation, or all the locks held by a particular PostgreSQL session.</source>
          <target state="translated">現在未解決のすべてのロック、特定のデータベース内のリレーションに対するすべてのロック、特定のリレーションに対するすべてのロック、または特定のPostgreSQLセッションが保持するすべてのロックを表示します。</target>
        </trans-unit>
        <trans-unit id="cbe38ed5293f170b37453ef21637367ceda0f0b8" translate="yes" xml:space="preserve">
          <source>View definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">ビュー定義（再構築された &lt;code&gt;SELECT&lt;/code&gt; クエリ）</target>
        </trans-unit>
        <trans-unit id="94f66a08ed3a699a66860df21a573d573a238197" translate="yes" xml:space="preserve">
          <source>Viewing Locks</source>
          <target state="translated">ビューイングロック</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c43c0cfc302cb10077693176e5e074e56b5aa3e7" translate="yes" xml:space="preserve">
          <source>Views can be used in almost any place a real table can be used. Building views upon other views is not uncommon.</source>
          <target state="translated">ビューは、ほとんどの場所で実際のテーブルを使用することができます。他のビューの上にビューを構築することは珍しくありません。</target>
        </trans-unit>
        <trans-unit id="8e39d0decda3838416b25ba5106b0efbe06c4023" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction targeted by the lock, or null if the target is not a virtual transaction ID</source>
          <target state="translated">ロックの対象となるトランザクションの仮想 ID、または対象が仮想トランザクション ID でない場合は NULL。</target>
        </trans-unit>
        <trans-unit id="811a0b30888086bd25c748477319220487f25d50" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction that is holding or awaiting this lock</source>
          <target state="translated">このロックを保持または待機しているトランザクションの仮想 ID</target>
        </trans-unit>
        <trans-unit id="4e4ba211a7e69b2432d26b396c51c526655c765b" translate="yes" xml:space="preserve">
          <source>Virtual transaction ID (backendID/localXID)</source>
          <target state="translated">仮想トランザクションID (backendID/localXID)</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="588c142955d93338aefe3c6dd59baf541f7f60c7" translate="yes" xml:space="preserve">
          <source>WAL</source>
          <target state="translated">WAL</target>
        </trans-unit>
        <trans-unit id="1d1c95a48c1cec72e7cde457f1faf1b2311bbdfd" translate="yes" xml:space="preserve">
          <source>WAL Configuration</source>
          <target state="translated">WALの設定</target>
        </trans-unit>
        <trans-unit id="dc7b27e2b628547b61cdbe01ad5b4d44572d2c25" translate="yes" xml:space="preserve">
          <source>WAL Internals</source>
          <target state="translated">WALインターナル</target>
        </trans-unit>
        <trans-unit id="cd824454d5f714596ff079dcd401902ac18dd100" translate="yes" xml:space="preserve">
          <source>WAL also makes it possible to support on-line backup and point-in-time recovery, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. By archiving the WAL data we can support reverting to any time instant covered by the available WAL data: we simply install a prior physical backup of the database, and replay the WAL log just as far as the desired time. What's more, the physical backup doesn't have to be an instantaneous snapshot of the database state &amp;mdash; if it is made over some period of time, then replaying the WAL log for that period will fix any internal inconsistencies.</source>
          <target state="translated">&lt;a href=&quot;continuous-archiving&quot;&gt;セクション25.3で&lt;/a&gt;説明されているように、WALはオンラインバックアップとポイントインタイムリカバリをサポートすることも可能にします。WALデータをアーカイブすることで、利用可能なWALデータでカバーされる任意の時点への復帰をサポートできます。データベースの以前の物理バックアップをインストールし、希望する時間までWALログを再生します。さらに、物理バックアップはデータベースの状態の瞬間的なスナップショットである必要はありません。一定の期間にわたって作成された場合、その期間のWALログを再生すると、内部の不整合が修正されます。</target>
        </trans-unit>
        <trans-unit id="e4adb460b94535160dc5514c2f3243fad9448dc8" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g. &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">&lt;code&gt;pg_start_backup&lt;/code&gt; 、 &lt;code&gt;pg_switch_wal&lt;/code&gt; などのWALファイル制御コマンドはリカバリ中に機能しません。</target>
        </trans-unit>
        <trans-unit id="9b2801865ae804dc7013c1520108c058b7f6c30a" translate="yes" xml:space="preserve">
          <source>WAL is automatically enabled; no action is required from the administrator except ensuring that the disk-space requirements for the WAL logs are met, and that any necessary tuning is done (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;).</source>
          <target state="translated">WALは自動的に有効になります。 WALログのディスク容量要件が満たされていること、および必要な調整が行われていることを確認する以外は、管理者によるアクションは必要ありません（&lt;a href=&quot;wal-configuration&quot;&gt;セクション29.4を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c356b4888573bfd6af6c126f717a43c96a7d21b4" translate="yes" xml:space="preserve">
          <source>WAL location at which to start reading. The default is to start reading the first valid log record found in the earliest file found.</source>
          <target state="translated">読み込みを開始する WAL の位置。デフォルトでは、最初に見つかったファイルで最初に見つかった有効なログレコードの読み込みを開始します。</target>
        </trans-unit>
        <trans-unit id="4873b80cfe4fe4ff618ed5cd62f9b47043675a98" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000000&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">WALログは、データディレクトリの下のディレクトリ &lt;code&gt;pg_wal&lt;/code&gt; に、一連のセグメントファイルとして通常16 MBのサイズで保存されます（ただし、サイズは &lt;code&gt;--wal-segsize&lt;/code&gt; initdbオプションを変更することで変更できます）。各セグメントは通常8 KBのページに分割されます（このサイズは &lt;code&gt;--with-wal-blocksize&lt;/code&gt; 設定オプションで変更できます）。ログレコードヘッダーは &lt;code&gt;access/xlogrecord.h&lt;/code&gt; に記述されています。レコードの内容は、記録されているイベントのタイプによって異なります。セグメントファイルには、 &lt;code&gt;000000010000000000000000&lt;/code&gt; から始まる名前として、増え続ける番号が付けられます。数値は折り返されませんが、使用可能な数値の在庫を使い果たすには非常に長い時間がかかります。</target>
        </trans-unit>
        <trans-unit id="5fa55cdd1f960e02b270cbf81d5d051cfdadab50" translate="yes" xml:space="preserve">
          <source>WAL record construction can be canceled between any of the above steps by calling &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt;. This will discard all changes to the page image copies.</source>
          <target state="translated">&lt;code&gt;GenericXLogAbort(state)&lt;/code&gt; を呼び出すことにより、上記のステップの間にWALレコードの構築をキャンセルできます。これにより、ページのイメージコピーに対するすべての変更が破棄されます。</target>
        </trans-unit>
        <trans-unit id="ec0756aa72f12460643a103d61be69d319455e3e" translate="yes" xml:space="preserve">
          <source>WAL records are appended to the WAL logs as each new record is written. The insert position is described by a Log Sequence Number (LSN) that is a byte offset into the logs, increasing monotonically with each new record. LSN values are returned as the datatype &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;. Values can be compared to calculate the volume of WAL data that separates them, so they are used to measure the progress of replication and recovery.</source>
          <target state="translated">WALレコードは、新しいレコードが書き込まれるたびにWALログに追加されます。挿入位置は、ログへのバイトオフセットであるログシーケンス番号（LSN）で記述され、新しいレコードごとに単調に増加します。LSN値は、データ型&lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt;として返されます。値を比較して、それらを分離するWALデータの量を計算できるため、レプリケーションとリカバリの進行状況を測定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="85207d0ebcdb97d98e8f6e4d0d99438888bd2967" translate="yes" xml:space="preserve">
          <source>WAL segments that cannot be found in the archive will be sought in &lt;code&gt;pg_wal/&lt;/code&gt;; this allows use of recent un-archived segments. However, segments that are available from the archive will be used in preference to files in &lt;code&gt;pg_wal/&lt;/code&gt;.</source>
          <target state="translated">アーカイブで見つからないWALセグメントは &lt;code&gt;pg_wal/&lt;/code&gt; で検索されます。これにより、最近のアーカイブされていないセグメントを使用できます。ただし、アーカイブから利用可能なセグメントは、 &lt;code&gt;pg_wal/&lt;/code&gt; 内のファイルよりも優先して使用されます。</target>
        </trans-unit>
        <trans-unit id="670936924f36e223ed7101a5577c1a95fc54d46f" translate="yes" xml:space="preserve">
          <source>WIDE Project</source>
          <target state="translated">WIDEプロジェクト</target>
        </trans-unit>
        <trans-unit id="0c238a027f49a7325c81b6fcad74df656598a8d1" translate="yes" xml:space="preserve">
          <source>WITH Queries</source>
          <target state="translated">WITH クエリ</target>
        </trans-unit>
        <trans-unit id="62c72223105cadaf945f1907d7cca51ac5e11a9a" translate="yes" xml:space="preserve">
          <source>WITH Queries: Data-Modifying Statements in WITH</source>
          <target state="translated">WITH クエリ。WITH でのデータ変更文</target>
        </trans-unit>
        <trans-unit id="81a33ebe9b068dc28117b34d20aebb31ffcc15d4" translate="yes" xml:space="preserve">
          <source>WITH Queries: SELECT in WITH</source>
          <target state="translated">WITH クエリを使用します。でSELECT</target>
        </trans-unit>
        <trans-unit id="b3c1b6ed1901fdc76c7650d703ade5c43c418ba9" translate="yes" xml:space="preserve">
          <source>Wait Event Name</source>
          <target state="translated">待機イベント名</target>
        </trans-unit>
        <trans-unit id="cfecc9a9e7dbc0650b752c6d733646645d5d3acd" translate="yes" xml:space="preserve">
          <source>Wait Event Type</source>
          <target state="translated">待機イベントタイプ</target>
        </trans-unit>
        <trans-unit id="7d1dd06a2c6e4048cfa872860c567be1efcd7c2b" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">バックエンドが現在待機している場合は待機イベント名、それ以外の場合はNULL。詳細は&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;表27.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e0d176395064480d6a06595b0b0b2f5082eb7376" translate="yes" xml:space="preserve">
          <source>Wait event type name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">バックエンドが現在待機している場合は待機イベントタイプ名、それ以外の場合はNULL。詳細は&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;表27.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d814f74425edb745c0f36dde73fdb494bc74e548" translate="yes" xml:space="preserve">
          <source>Wait for the operation to complete. This is supported for the modes &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;restart&lt;/code&gt;, &lt;code&gt;promote&lt;/code&gt;, and &lt;code&gt;register&lt;/code&gt;, and is the default for those modes.</source>
          <target state="translated">操作が完了するまで待ちます。これは、モード &lt;code&gt;start&lt;/code&gt; 、 &lt;code&gt;stop&lt;/code&gt; 、 &lt;code&gt;restart&lt;/code&gt; 、 &lt;code&gt;promote&lt;/code&gt; 、および &lt;code&gt;register&lt;/code&gt; でサポートされており、これらのモードのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="dd618adedec17e6469d06a5651fc5072c2cb8b33" translate="yes" xml:space="preserve">
          <source>Waiting a new WAL segment created by copying an existing one to reach stable storage.</source>
          <target state="translated">既存のものをコピーして作成した新しいWALセグメントが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="7b263c588c8a9b03696257b8f7a21247383c1982" translate="yes" xml:space="preserve">
          <source>Waiting during base backup when throttling activity.</source>
          <target state="translated">アクティビティをスロットリングしているときにベースバックアップ中に待機しています。</target>
        </trans-unit>
        <trans-unit id="d62ddea7d6b1ce8c2e8479d95982f02c6ba59204" translate="yes" xml:space="preserve">
          <source>Waiting for I/O a subtransaction buffer.</source>
          <target state="translated">サブトランザクションバッファのI/O待ち。</target>
        </trans-unit>
        <trans-unit id="10b267052de8e5af8879f9629c8e82adc667c91f" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a clog (transaction status) buffer.</source>
          <target state="translated">クロッグ(トランザクションステータス)バッファでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="8bbc9325a896b8fd7a70abd45c23e5faa43a813b" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a data page.</source>
          <target state="translated">データページでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="8a704e423e485baf39382a4b61985268bdbe9816" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset buffer.</source>
          <target state="translated">マルチクセクト・オフセット・バッファでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="567d45c24a3c7adfee8a01424ebb678b04e38b31" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact_member buffer.</source>
          <target state="translated">multixact_memberバッファのI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="f5580fedd445b2fc16dfac5701d5e862d784f551" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a replication slot.</source>
          <target state="translated">レプリケーションスロットでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="8eda0ee8cd8803033853db58b70b41cefa970a11" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an async (notify) buffer.</source>
          <target state="translated">非同期(通知)バッファでI/O待ちをしています。</target>
        </trans-unit>
        <trans-unit id="abba94e34c19d07b07ce80f08b906e7d03736163" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an oldserxid buffer.</source>
          <target state="translated">oldserxidバッファでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="89be09a6258d69b36b9e65eae64f0556be147bdd" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on commit timestamp buffer.</source>
          <target state="translated">コミットタイムスタンプバッファでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="da4c5fd8e7b43af2a409040c541ebf56ba090a42" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage during a checkpoint or database shutdown.</source>
          <target state="translated">チェックポイントまたはデータベースのシャットダウン中に SLRU データが安定したストレージに到達するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="a795b2d3551897df90d4dc06b1de18f13711e4ef" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage following a page write.</source>
          <target state="translated">ページ書き込み後、SLRU データが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="3f43eca07331b8b4d48d83deb11f1187e3222c57" translate="yes" xml:space="preserve">
          <source>Waiting for SSL while attempting connection.</source>
          <target state="translated">接続を試みている間、SSLを待っています。</target>
        </trans-unit>
        <trans-unit id="cea499b505dfbcd4c53729e4e78e2f60a5e0dfa9" translate="yes" xml:space="preserve">
          <source>Waiting for TBM shared iterator lock.</source>
          <target state="translated">TBM共有イテレータのロックを待っています。</target>
        </trans-unit>
        <trans-unit id="28f5fe1f96a90cf6f89027f31d1f8fff440aadd4" translate="yes" xml:space="preserve">
          <source>Waiting for WAL buffers to be written to disk.</source>
          <target state="translated">WAL バッファがディスクに書き込まれるのを待っています。</target>
        </trans-unit>
        <trans-unit id="e5f443781f65a70ffb9eadd8d00b62bec73ed570" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from a stream at recovery.</source>
          <target state="translated">回復時のストリームからのWAL待ち。</target>
        </trans-unit>
        <trans-unit id="ce0b3cbfc2a21133aecfeb0025076a64608b1920" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from any kind of source (local, archive or stream) at recovery.</source>
          <target state="translated">リカバリー時に任意の種類のソース(ローカル、アーカイブ、ストリーム)からのWALを待っています。</target>
        </trans-unit>
        <trans-unit id="c3d04b47f170d0a017b5a8840ab7fd732b861077" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to be flushed in WAL sender process.</source>
          <target state="translated">WAL送信者プロセスでWALがフラッシュされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="35934124d45c41b66cac20041da4f7acc6c09234" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach stable storage during bootstrapping.</source>
          <target state="translated">ブートストラップ中にWALが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="2347bde945d2a1ac488cc00b97f03eb25edf886c" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach stable storage.</source>
          <target state="translated">WALファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="b64554949a794fe8845162525251d4f832f615ae" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to complete.</source>
          <target state="translated">チェックポイントの完了を待っています。</target>
        </trans-unit>
        <trans-unit id="fbe85ec49696086b315ad919340a19fe4137e208" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to start.</source>
          <target state="translated">チェックポイントの開始を待っています。</target>
        </trans-unit>
        <trans-unit id="a86020a20952ecd2adfecfb302ee0a5d59b93de9" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach stable storage.</source>
          <target state="translated">新しく作成されたタイムラインの履歴ファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="6fe40708f510b2425a56df962113c332035d1ebb" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach stable storage.</source>
          <target state="translated">新たに初期化されたWALファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="a99635b6aefa182932d6d8ac35e0fadee6f58362" translate="yes" xml:space="preserve">
          <source>Waiting for a read during a file copy operation.</source>
          <target state="translated">ファイルコピー操作中の読み込み待ち。</target>
        </trans-unit>
        <trans-unit id="1b1c7ee0bc940e8ff954a9dc21e088de25e160e7" translate="yes" xml:space="preserve">
          <source>Waiting for a read during recheck of the data directory lock file.</source>
          <target state="translated">データ・ディレクトリ・ロック・ファイルの再チェック中に読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="9ae33919f01ffd845bcfe367fc1ce42274883982" translate="yes" xml:space="preserve">
          <source>Waiting for a read during reorder buffer management.</source>
          <target state="translated">リオーダバッファ管理中に読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="21b0b22bdd6995f4c8facc815a7958bc78a4df11" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a WAL file.</source>
          <target state="translated">WALファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="7c0a57a09d41e3dd4b6c43069589a550983cdfbc" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a buffered file.</source>
          <target state="translated">バッファリングされたファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="9d7f43727962110ab0f659fc3569b92c09e1e4c3" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a relation data file.</source>
          <target state="translated">リレーションデータファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="b5434d2dc36bc6e479cf33762dac4cdbbad013ab" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a replication slot control file.</source>
          <target state="translated">レプリケーションスロット制御ファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="0d8e0677108348e6cb25c6439df96979d79370b4" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during walsender timeline command.</source>
          <target state="translated">walsender timeline コマンドの実行中にタイムライン履歴ファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="bb87f9075b737550478460fe92ea81d5a8e44f1b" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the control file.</source>
          <target state="translated">制御ファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="b13a29b976f4d9243fad247169f0d2821ffe4aa3" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a logical mapping during reorder buffer management.</source>
          <target state="translated">リオーダバッファ管理中に論理マッピングの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="94303f5f840422428a360dcb8cf874ed8d7188d8" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a serialized historical catalog snapshot.</source>
          <target state="translated">シリアライズされたヒストリカル・カタログ・スナップショットの読み取りを待っています。</target>
        </trans-unit>
        <trans-unit id="2ab04c92d0fda0e18fe65ce97ed4f4a6278c8bda" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a timeline history file.</source>
          <target state="translated">タイムラインの履歴ファイルの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="c0e334fe7275467445ed31f445bb0d89fc42ea11" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a two phase state file.</source>
          <target state="translated">二相状態のファイルの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="24f5541db52af4f2f83a5aff926cb570ad37ea9a" translate="yes" xml:space="preserve">
          <source>Waiting for a read of an SLRU page.</source>
          <target state="translated">SLRUのページの読み込み待ち。</target>
        </trans-unit>
        <trans-unit id="ab3bd50798c846431f5c99cd295ac155af5c3628" translate="yes" xml:space="preserve">
          <source>Waiting for a read of the relation map file.</source>
          <target state="translated">リレーションマップファイルの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="653fed415a1560b6108907354641e1d02603af7f" translate="yes" xml:space="preserve">
          <source>Waiting for a read when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">既存のWALセグメントをコピーして新規にWALセグメントを作成する際に、読み込みを待っている。</target>
        </trans-unit>
        <trans-unit id="8b50fdc4779713a2250434752ac096729a9b9e3d" translate="yes" xml:space="preserve">
          <source>Waiting for a read while adding a line to the data directory lock file.</source>
          <target state="translated">データ・ディレクトリ・ロック・ファイルに行を追加している間、読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="764d5f916fab0f4117b0be0cbd2e731f54a839fb" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be extended.</source>
          <target state="translated">関係データファイルの拡張を待っています。</target>
        </trans-unit>
        <trans-unit id="2d4550cc931e0694f7888372505856f6d3c09005" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be truncated.</source>
          <target state="translated">関係データファイルが切り捨てられるのを待っています。</target>
        </trans-unit>
        <trans-unit id="196784ad8df1886187ea3f9758445468708682d5" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach stable storage.</source>
          <target state="translated">関係データファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="2c6dd21f72774436bf4201a14e0bef224865f318" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive to be dropped.</source>
          <target state="translated">レプリケーションオリジンが非アクティブになってドロップされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="51efea4b8a37a030875e22581e67a71b2c0b921b" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage while restoring it to memory.</source>
          <target state="translated">レプリケーションスロット制御ファイルをメモリに復元しながら、安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="3360d7e3a23f4e402f25182926d976cf44db39f3" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage.</source>
          <target state="translated">レプリケーションスロット制御ファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="199501dcba57d5c5271ac74b95e191bf236cb733" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive to be dropped.</source>
          <target state="translated">レプリケーションスロットが非アクティブになってドロップされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="863f50afd3c1563b85fb65b1a42b5b1ae705dfb7" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach stable storage.</source>
          <target state="translated">シリアライズされたヒストリカルカタログスナップショットが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="b66c979e7938ef913ce663fc865d33095c21de87" translate="yes" xml:space="preserve">
          <source>Waiting for a snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">&lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; トランザクションのスナップショットを待機しています。</target>
        </trans-unit>
        <trans-unit id="e483dd61b2e17583a1594dcda6e591f3ac3e513f" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach stable storage.</source>
          <target state="translated">ストリーミングレプリケーションで受信したタイムラインの履歴ファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="2853dc0fde120da340c58317ae296218c97a1c94" translate="yes" xml:space="preserve">
          <source>Waiting for a transaction to finish.</source>
          <target state="translated">取引が終わるのを待っています。</target>
        </trans-unit>
        <trans-unit id="157ed476e7697e7a1cadb6976248a98472434e0a" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach stable storage.</source>
          <target state="translated">二相状態のファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="85a6ffd0d68eb37b547774e0919378d07b939300" translate="yes" xml:space="preserve">
          <source>Waiting for a write during a file copy operation.</source>
          <target state="translated">ファイルコピー操作中の書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="32492adb76e65f3fe0a6e72f8951521baef55fec" translate="yes" xml:space="preserve">
          <source>Waiting for a write during reorder buffer management.</source>
          <target state="translated">リオーダバッファ管理中の書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="ba450cd205c3dd8e5640b537d57ff27410f1253d" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a WAL page during bootstrapping.</source>
          <target state="translated">ブートストラップ中にWALページの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="8705f070fa23d795eb616cd9e31b50566ca67cc3" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a newly created timeline history file.</source>
          <target state="translated">新規作成したタイムライン履歴ファイルの書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="8d1760404310ebeadc931ff2c4124968d47b107a" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a serialized historical catalog snapshot.</source>
          <target state="translated">シリアライズされたヒストリカル・カタログ・スナップショットの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="b37297f957be6d38118691421e743bea3d403b7c" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a timeline history file received via streaming replication.</source>
          <target state="translated">ストリーミングレプリケーションで受信したタイムラインの履歴ファイルの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="be49d8c0c1b4685519fdd85850348ecd44be9749" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a two phase state file.</source>
          <target state="translated">二相状態のファイルの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="53aeb8cdb283bc1d47f777ad7b24ec161b846ee7" translate="yes" xml:space="preserve">
          <source>Waiting for a write of an SLRU page.</source>
          <target state="translated">SLRUのページの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="1465353979b7faf0b115892be0b212bb41254cd5" translate="yes" xml:space="preserve">
          <source>Waiting for a write of logical rewrite mappings.</source>
          <target state="translated">論理的な書き換えマッピングの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="262bd0eebb54ede821d500429e0af687cc713958" translate="yes" xml:space="preserve">
          <source>Waiting for a write of mapping data during a logical rewrite.</source>
          <target state="translated">論理書き換え中のマッピングデータの書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="3b9bd51d9cae106255dd99b45134793e8fe5ca42" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a WAL file.</source>
          <target state="translated">WALファイルへの書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="251086a074c439cbe743d7c3bb152d463c21bb7b" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a buffered file.</source>
          <target state="translated">バッファリングされたファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="8b47e588513cf133674bba56df9090d2883dd101" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a relation data file.</source>
          <target state="translated">リレーションデータファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="299b50c23e70d2d279fbb4a9694963e890bfee88" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a replication slot control file.</source>
          <target state="translated">レプリケーションスロット制御ファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="f26411046b5f9c53b1644f439224f22b40020be7" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the control file.</source>
          <target state="translated">制御ファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="f75228f5ef22ab61abd11733484809e768dbf43c" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the relation map file.</source>
          <target state="translated">リレーションマップファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="d4dc5be0a61a88b12bee2628ecf09d1b773c4c35" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the control file.</source>
          <target state="translated">制御ファイルを更新するための書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="610d140534d98776f4ceaac82401a792839d1b45" translate="yes" xml:space="preserve">
          <source>Waiting for a write when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">既存のWALセグメントをコピーして新規にWALセグメントを作成する際に書き込み待ちになる。</target>
        </trans-unit>
        <trans-unit id="e8e6f804ba2f5656426f9c3ccd5ba5ebd95a87d4" translate="yes" xml:space="preserve">
          <source>Waiting for a write while adding a line to the data directory lock file.</source>
          <target state="translated">データディレクトリのロックファイルに行を追加している間、書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="0696197c3d3d4067137d8fe428f74da050d0c268" translate="yes" xml:space="preserve">
          <source>Waiting for a write while creating the data directory lock file.</source>
          <target state="translated">データディレクトリロックファイルの作成中に書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="2fa5fc8fd5be1292b1cb40d3c83b93e702c367e3" translate="yes" xml:space="preserve">
          <source>Waiting for a write while initializing a new WAL file.</source>
          <target state="translated">新規WALファイルの初期化中に書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="734b565bcfa5ca2fc97c773bf856a02689576213" translate="yes" xml:space="preserve">
          <source>Waiting for action on logical replication worker to finish.</source>
          <target state="translated">論理レプリケーションワーカーのアクションの終了を待っています。</target>
        </trans-unit>
        <trans-unit id="a1613179ffe75070217dd36a5f12906b74afc2ab" translate="yes" xml:space="preserve">
          <source>Waiting for activity from child process when executing &lt;code&gt;Gather&lt;/code&gt; node.</source>
          <target state="translated">&lt;code&gt;Gather&lt;/code&gt; ノードの実行時に子プロセスからのアクティビティを待機しています。</target>
        </trans-unit>
        <trans-unit id="6126b8aaccca6a7a91b7220ca50f325ae2373721" translate="yes" xml:space="preserve">
          <source>Waiting for an asynchronous prefetch from a relation data file.</source>
          <target state="translated">リレーションデータファイルからの非同期プリフェッチを待っています。</target>
        </trans-unit>
        <trans-unit id="7ceade57b19a1c5eb1845d4c821b850186cc2839" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">選出されたパラレルハッシュ参加者がハッシュテーブルを割り当てるのを待っています。</target>
        </trans-unit>
        <trans-unit id="7ae35732e2bfced9301c45c422a5bb06a774ed38" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate more batches.</source>
          <target state="translated">選出されたパラレルハッシュ参加者がより多くのバッチを割り当てるのを待っています。</target>
        </trans-unit>
        <trans-unit id="fb366154c77101be0d76ea7c08df266aa7b65be9" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">選出されたパラレルハッシュ参加者が初期ハッシュテーブルを割り当てるのを待っています。</target>
        </trans-unit>
        <trans-unit id="7cf1c258cd35461c3f1727fa0a9eacebdd04769c" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">選出されたパラレルハッシュ参加者が将来のバッチ成長を決定するのを待っています。</target>
        </trans-unit>
        <trans-unit id="07635fd669dda3c946a486e6f1b23b449441353e" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</source>
          <target state="translated">選出されたパラレルハッシュ参加者がより多くのバケットの割り当てを終了するのを待っています。</target>
        </trans-unit>
        <trans-unit id="4e246fb175c5f149773d0331209040875fd42182" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to stable storage.</source>
          <target state="translated">安定したストレージへの関係データファイルの即時同期を待っています。</target>
        </trans-unit>
        <trans-unit id="95d64a2fc217b281e035d77c750609359d54019d" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the control file to reach stable storage.</source>
          <target state="translated">コントロールファイルの更新が安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="fcf18468a43ecee10b4dea21dad9d1ae0888b697" translate="yes" xml:space="preserve">
          <source>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</source>
          <target state="translated">WAL送信者プロセスでWAL受信者からの返信を処理する際に、何らかのアクティビティを待機している。</target>
        </trans-unit>
        <trans-unit id="27bad1ed6561f03baa1813e29bc1d6a9f97d039b" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to shut down.</source>
          <target state="translated">バックグラウンドワーカーがシャットダウンするのを待っています。</target>
        </trans-unit>
        <trans-unit id="17b78b2404a9c8efe7417660102cb11bcbc99fa4" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to start up.</source>
          <target state="translated">バックグラウンドワーカーの起動を待っています。</target>
        </trans-unit>
        <trans-unit id="121ce51ab6e249cf929aa9e0635dd5196c724d55" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach stable storage.</source>
          <target state="translated">リレーションデータファイルの変更が安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="7aedff25c55dbcd34ea828efe5df0cac10c04231" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from remote server during synchronous replication.</source>
          <target state="translated">同期レプリケーション中にリモートサーバーからの確認を待っています。</target>
        </trans-unit>
        <trans-unit id="e096887a303519506fcd67516869ace11ad3e59e" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while adding a line to the data directory lock file.</source>
          <target state="translated">データディレクトリのロックファイルに行を追加しながら、データが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="fe0ab1a16e2329bfa52c27e76aa50ab788d415cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while assigning WAL sync method.</source>
          <target state="translated">WAL同期方式を割り当てている間、データが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="0a67fcfeb93618a5687879b86795e36261b23961" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while creating the data directory lock file.</source>
          <target state="translated">データディレクトリのロックファイルを作成している間、データが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="1f817023f7f1aeed83afe73b277506f04bbf5f51" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to clear transaction id at transaction end.</source>
          <target state="translated">トランザクション終了時にグループリーダーがトランザクションIDをクリアするのを待っています。</target>
        </trans-unit>
        <trans-unit id="9ad12c44c511affe8e5b28dfe797e5442cb69ba2" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to update transaction status at transaction end.</source>
          <target state="translated">トランザクション終了時にグループリーダーがトランザクションのステータスを更新するのを待っています。</target>
        </trans-unit>
        <trans-unit id="6303bec3edc9303d1de1e17ffbef9d10deeb2ec7" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to change state.</source>
          <target state="translated">論理レプリケーションリモートサーバーの状態変更を待っています。</target>
        </trans-unit>
        <trans-unit id="a171ef7b847c02147b5330baa42032a3b728b099" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">論理レプリケーションリモートサーバが初期テーブル同期のためのデータを送信するのを待っています。</target>
        </trans-unit>
        <trans-unit id="a1252663514ce3e310a8ccaa53abc308558932c1" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage during a checkpoint.</source>
          <target state="translated">チェックポイント中に論理的な書き換えマッピングが安定したストレージに到達するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="754897ce0cd2e99fe42e75806589d9d45f48b612" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage.</source>
          <target state="translated">論理的な書き換えマッピングが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="ddcc4581e90866cae66b033e94adc36e9d35b43d" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach stable storage during a logical rewrite.</source>
          <target state="translated">論理的な書き換え中に、マッピングデータが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="b8552e94ff493c563b97bc367629ad56d62866bf" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish hashing the inner relation.</source>
          <target state="translated">他のパラレルハッシュ参加者が内部関係のハッシュを終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="e11479178e59844fd7fe15f1ce4eb490d0773d60" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</source>
          <target state="translated">他のParallel Hash参加者が新しいバケツにタプルを挿入し終わるのを待っています。</target>
        </trans-unit>
        <trans-unit id="7c11b60c1a40d4f8d29e90353a8affe9075ec7f0" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish loading a hash table.</source>
          <target state="translated">他のパラレルハッシュ参加者がハッシュテーブルの読み込みを終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="5413b25ebacbf60f6298ddfd13544237708b4afd" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</source>
          <target state="translated">他のParallel Hash参加者が外部関係のパーティショニングを終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="6ddf8230dce1afc618c7942a19d13a4e06fbab65" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finishing repartitioning.</source>
          <target state="translated">他のParallel Hash参加者が再分割を終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="7ddcd3a1c9792343c59de081cc3c348d37cc1494" translate="yes" xml:space="preserve">
          <source>Waiting for other process to be attached in shared message queue.</source>
          <target state="translated">共有メッセージキューで他のプロセスがアタッチされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="ea1e4d605c6dfe012718f5d6b6342a2c1167a5ba" translate="yes" xml:space="preserve">
          <source>Waiting for parallel &lt;code&gt;CREATE INDEX&lt;/code&gt; workers to finish heap scan.</source>
          <target state="translated">並列 &lt;code&gt;CREATE INDEX&lt;/code&gt; ワーカーがヒープスキャンを完了するのを待機しています。</target>
        </trans-unit>
        <trans-unit id="2c0e5b890525a78c621a8bd9247fc1bb58a1d9d0" translate="yes" xml:space="preserve">
          <source>Waiting for parallel bitmap scan to become initialized.</source>
          <target state="translated">パラレルビットマップスキャンが初期化されるのを待っています。</target>
        </trans-unit>
        <trans-unit id="54d8ebcdd8df7afcbc1ca990a46b504e44b8711d" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation lock.</source>
          <target state="translated">並列クエリ動的共有メモリ割り当てロックを待っています。</target>
        </trans-unit>
        <trans-unit id="6b2ad8cbb3533dbd2f7a9b18414fee3c1da25764" translate="yes" xml:space="preserve">
          <source>Waiting for parallel workers to finish computing.</source>
          <target state="translated">並列ワーカーがコンピューティングを終了するのを待っています。</target>
        </trans-unit>
        <trans-unit id="d884014cf602749f289dbc7c7fc61acad84fa09d" translate="yes" xml:space="preserve">
          <source>Waiting for standby promotion.</source>
          <target state="translated">待機促進を待っています。</target>
        </trans-unit>
        <trans-unit id="8cb227e761e8b1bc97dcd2f57c98b273168fa6eb" translate="yes" xml:space="preserve">
          <source>Waiting for startup process to send initial data for streaming replication.</source>
          <target state="translated">ストリーミングレプリケーションのための初期データを送信するための起動プロセスを待っています。</target>
        </trans-unit>
        <trans-unit id="4de10813baf47bfe4c27cf4c7969243299b919ed" translate="yes" xml:space="preserve">
          <source>Waiting for the control file to reach stable storage.</source>
          <target state="translated">コントロールファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="681bd23f805b6da445bd3d82fc4a46addc600e13" translate="yes" xml:space="preserve">
          <source>Waiting for the page number needed to continue a parallel B-tree scan to become available.</source>
          <target state="translated">並列B-treeスキャンを継続するために必要なページ番号が利用可能になるのを待っています。</target>
        </trans-unit>
        <trans-unit id="c939d0ba9c27dac2f7d8824016725fedd49ef586" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach stable storage.</source>
          <target state="translated">関係マップファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="c7be20b27094dae3303ee1fadc67011cd3751be8" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to establish connection to remote server.</source>
          <target state="translated">リモートサーバへの接続を確立するためにWAL受信機で待機しています。</target>
        </trans-unit>
        <trans-unit id="8b6df6362589c923614f910bed59cf34ff945324" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to receive data from remote server.</source>
          <target state="translated">WAL受信機でリモートサーバからのデータ受信を待っています。</target>
        </trans-unit>
        <trans-unit id="bb83e82efa5858b6db8ad5949e98eced2a90463a" translate="yes" xml:space="preserve">
          <source>Waiting in an extension.</source>
          <target state="translated">延長で待機中。</target>
        </trans-unit>
        <trans-unit id="feb270e93605e72d07d6bcedd0737f5a39e22df0" translate="yes" xml:space="preserve">
          <source>Waiting in background writer process, hibernating.</source>
          <target state="translated">背景のライタープロセスで待機中、冬眠中。</target>
        </trans-unit>
        <trans-unit id="88eefbfbae399c6feea1548c69357a5e9736f5ab" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL receiver process.</source>
          <target state="translated">WAL受信処理のメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="375265f881add8dd9c33130678344167b52a9588" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL sender process.</source>
          <target state="translated">WAL送信者プロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="f5e173311caac73154fc23d76aed32502c099d08" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL writer process.</source>
          <target state="translated">WALのライター処理のメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="7acb76585737d883d007ddb658d4cfd89597eb50" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of autovacuum launcher process.</source>
          <target state="translated">自動バキュームランチャープロセスのメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="7e6e41b3df7e89238ff4283ef4198a69ebe76109" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process background worker.</source>
          <target state="translated">背景ライタープロセス背景ワーカーのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="d193be75953171ebbce3b3db2cde50e60c132491" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of checkpointer process.</source>
          <target state="translated">checkpointerプロセスのメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="db02418c7eb01a5eb05765091cb30a31f71aa88d" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical apply process.</source>
          <target state="translated">論理適用処理のメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="82a745dd84bf90f7ae367a6c7dc035147ac68293" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical launcher process.</source>
          <target state="translated">論理ランチャープロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="1e0772397293bff630517da7bd7ffb1ab81b17f5" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of syslogger process.</source>
          <target state="translated">sysloggerプロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="54f59b1a36db7407d20232e85176d4c1a23692f4" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the archiver process.</source>
          <target state="translated">アーカイバープロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="212f0884ddfbc91689a2a97c09aafbcd3f389116" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the statistics collector process.</source>
          <target state="translated">統計情報コレクタプロセスのメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="3b4ceca9ff1b34dd3a21d5a1be2bf8a9aa711a70" translate="yes" xml:space="preserve">
          <source>Waiting in process that called &lt;code&gt;pg_sleep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; を呼び出したプロセスで待機しています。</target>
        </trans-unit>
        <trans-unit id="0184a02009f44f4d2a88cbd98d9dfe8231fceb5e" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of finished serializable transactions.</source>
          <target state="translated">終了したシリアライズ可能なトランザクションのリストへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="453521c4c18069faa9fd0afad3d83ca7731d1096" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a non-relation database object.</source>
          <target state="translated">非リレーショナル・データベース・オブジェクトのロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="e1e200aae0e4f2353a2c19cd08c7d6ee7ce7f912" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a relation.</source>
          <target state="translated">関係のロックを取得するために待っています。</target>
        </trans-unit>
        <trans-unit id="caf9078aaa0a5a46ce631268ce4c46ea2cb0e198" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a tuple.</source>
          <target state="translated">タプルのロックを取得するのを待っています。</target>
        </trans-unit>
        <trans-unit id="20d61e9ac29e8e57ca0786825f9ae212af87d782" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on page of a relation.</source>
          <target state="translated">関係のページでロックを取得するのを待っています。</target>
        </trans-unit>
        <trans-unit id="60529117b6f828f517a439e0152cfca12a03780e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a pin on a buffer.</source>
          <target state="translated">バッファ上でピンの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="9dff15d412549524e8b05e08b4e658a978321307" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a speculative insertion lock.</source>
          <target state="translated">投機的な挿入ロックの獲得を待っています。</target>
        </trans-unit>
        <trans-unit id="6f1d92a10ff6e0f42c232bac9cd39b9515b5e1f1" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a user lock.</source>
          <target state="translated">ユーザーロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="feee645b171eddc5255ea3172e0b6eaae2f3531e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual xid lock.</source>
          <target state="translated">仮想 xid ロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="0cff112c15e1e7f938ee8722e01003e541c3a9b9" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an advisory user lock.</source>
          <target state="translated">勧告ユーザロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="f4b782a596b50a85963931c1ce8ff87a36ab9e82" translate="yes" xml:space="preserve">
          <source>Waiting to add a message in shared invalidation queue.</source>
          <target state="translated">共有無効化キューにメッセージを追加するのを待っています。</target>
        </trans-unit>
        <trans-unit id="a30c5b64b9088c9bea1b788c2d9cad490d0feadc" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine locks for backends, or waiting to join or exit a locking group (used by parallel query).</source>
          <target state="translated">バックエンドのロックの追加や検査を待ったり、ロックグループへの参加や終了を待ったりします(並列クエリで使用されます)。</target>
        </trans-unit>
        <trans-unit id="4234f3768471935481a7a5ac70e216c3b3196d0a" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine predicate lock information.</source>
          <target state="translated">述語ロック情報の追加や検査を待っています。</target>
        </trans-unit>
        <trans-unit id="922ece807fb5d0e3eca745374502101b8e2f9883" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign a transaction id.</source>
          <target state="translated">トランザクションIDの割り当てまたは割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="4df1187e247ec9e3885764b731ccac5a81693366" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign an OID.</source>
          <target state="translated">OIDの割り当てまたは割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="36e78f99b93b8582ddda9533616d35bad0cb3435" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or exchange a chunk of memory or update counters during Parallel Hash plan execution.</source>
          <target state="translated">パラレルハッシュ計画の実行中に、メモリのチャンクの割り当てや交換、カウンタの更新を待っています。</target>
        </trans-unit>
        <trans-unit id="aea0084a8686cdd126b6dc0b70e3bb510372f940" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or free a replication slot.</source>
          <target state="translated">レプリケーションスロットの割り当てまたは解放を待っています。</target>
        </trans-unit>
        <trans-unit id="392b0fcbf6923b50ad00d9bcdf711922567f010a" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL at recovery because it is delayed.</source>
          <target state="translated">遅れているので回復時のWAL適用待ち。</target>
        </trans-unit>
        <trans-unit id="417e2e4d470ba2ea215e899c1f2f47a808b6cd1d" translate="yes" xml:space="preserve">
          <source>Waiting to associate a data block with a buffer in the buffer pool.</source>
          <target state="translated">バッファプール内のバッファとデータブロックの関連付けを待っています。</target>
        </trans-unit>
        <trans-unit id="0b5eba1b1476e67df8c9026fe8a8423164cbbbaf" translate="yes" xml:space="preserve">
          <source>Waiting to choose the next subplan during Parallel Append plan execution.</source>
          <target state="translated">Parallel Appendプラン実行中に次のサブプランを選択するのを待っています。</target>
        </trans-unit>
        <trans-unit id="11402cb956b4c4ad7b4f3ee48f5957e1d0e2837b" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop the tablespace.</source>
          <target state="translated">テーブルスペースの作成または削除を待っています。</target>
        </trans-unit>
        <trans-unit id="ef13562f4466bb31b5bf871e5d3f767784c48032" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that the table it has selected for a vacuum still needs vacuuming.</source>
          <target state="translated">それが真空のために選択したテーブルがまだ真空を必要としていることを確認するために待っています。</target>
        </trans-unit>
        <trans-unit id="7d2e90490a1d7b7d270317787f40bff2e1d72ee9" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;txid_status&lt;/code&gt; or update the oldest transaction id available to it.</source>
          <target state="translated">&lt;code&gt;txid_status&lt;/code&gt; の実行、または使用可能な最も古いトランザクションIDの更新を待機しています。</target>
        </trans-unit>
        <trans-unit id="905b59818613073e2e260c6b0fb7d68bf3c39843" translate="yes" xml:space="preserve">
          <source>Waiting to extend a relation.</source>
          <target state="translated">関係の延長を待っています。</target>
        </trans-unit>
        <trans-unit id="f8b7f54188ceea3dc5def955dc47ae1f28373839" translate="yes" xml:space="preserve">
          <source>Waiting to find or allocate space in shared memory.</source>
          <target state="translated">共有メモリ内のスペースの検索や割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="fb53c073cc374cfb75fd8b826e6b4d7eb6cc9003" translate="yes" xml:space="preserve">
          <source>Waiting to get a snapshot or clearing a transaction id at transaction end.</source>
          <target state="translated">トランザクション終了時にスナップショットの取得を待っているか、トランザクションIDをクリアしています。</target>
        </trans-unit>
        <trans-unit id="e384d346b49ba85024e06c032fcf3ccf1737b636" translate="yes" xml:space="preserve">
          <source>Waiting to get the start location of a scan on a table for synchronized scans.</source>
          <target state="translated">同期スキャンのテーブル上でスキャンの開始位置を取得するのを待っています。</target>
        </trans-unit>
        <trans-unit id="9a6beee315605623099d06c2371ae56da6b46cc7" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL into a memory buffer.</source>
          <target state="translated">メモリバッファへのWALの挿入を待っています。</target>
        </trans-unit>
        <trans-unit id="fe4ce59b2db271f1abfb91f4099370c7dcadc0ae" translate="yes" xml:space="preserve">
          <source>Waiting to manage fsync requests.</source>
          <target state="translated">fsync リクエストの管理を待っています。</target>
        </trans-unit>
        <trans-unit id="e3141c5d05c342451c8644a34df11be83dd434ad" translate="yes" xml:space="preserve">
          <source>Waiting to manage space allocation in shared memory.</source>
          <target state="translated">共有メモリのスペース割り当ての管理を待っています。</target>
        </trans-unit>
        <trans-unit id="b97c8584b996285f48aeab64ef02658839acbba9" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a list of locks held by serializable transactions.</source>
          <target state="translated">シリアライズ可能なトランザクションが保持するロックのリストに対する操作の実行を待機しています。</target>
        </trans-unit>
        <trans-unit id="d8589a1b8c66d6f8e4debafdd099f1a4b71a5b13" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a serializable transaction in a parallel query.</source>
          <target state="translated">並列クエリでシリアライズ可能なトランザクションに対する操作の実行を待っています。</target>
        </trans-unit>
        <trans-unit id="d2ade432e382335fbb1d6fb86bda4500ee8c2cbb" translate="yes" xml:space="preserve">
          <source>Waiting to perform checkpoint.</source>
          <target state="translated">チェックポイントの実行を待っています。</target>
        </trans-unit>
        <trans-unit id="1908bfbabea7a0ab1bbde739ebc0330fc7517b79" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client.</source>
          <target state="translated">クライアントからのデータ読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="05dd640e8c1d54ebf01054c0befd12ca4f14b63e" translate="yes" xml:space="preserve">
          <source>Waiting to read or record conflicting serializable transactions.</source>
          <target state="translated">競合するシリアライズ可能なトランザクションの読み込みまたは記録を待っています。</target>
        </trans-unit>
        <trans-unit id="0afe38ebe7d995583b3d1a5cd94b6fbc8cf1b845" translate="yes" xml:space="preserve">
          <source>Waiting to read or truncate multixact information.</source>
          <target state="translated">マルチアクト情報の読み込み待ち、または切り捨て待ち。</target>
        </trans-unit>
        <trans-unit id="a018a1a15593b5af23414939d50aec3fcb48c5cb" translate="yes" xml:space="preserve">
          <source>Waiting to read or update background worker state.</source>
          <target state="translated">バックグラウンドワーカーの状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="cea27617060567594092b7422c38330bfc2e5ee2" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory state.</source>
          <target state="translated">動的共有メモリの状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="5b94e34a6c9a38b9de8ddbf38266ea41569caa0e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about synchronous replicas.</source>
          <target state="translated">同期レプリカに関する情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="7be479f3c24eeb847b5e44a9bf4f341c29d1834b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact member mappings.</source>
          <target state="translated">マルチエクストラクト・メンバ・マッピングの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="548a78a89a3c004e9ad475a70fb6f1bb50c1151e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact offset mappings.</source>
          <target state="translated">多軸オフセットマッピングの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="ed18ac469b6f870e80be0efbf5c76a4d5c79b754" translate="yes" xml:space="preserve">
          <source>Waiting to read or update notification messages.</source>
          <target state="translated">通知メッセージの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="76d4dfb568ccc6112df58f601dc5c426ad5d62a8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update old snapshot control information.</source>
          <target state="translated">古いスナップショット制御情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="6ce0cc66a076e07f94b764161b2bddd57ada2509" translate="yes" xml:space="preserve">
          <source>Waiting to read or update replication slot state.</source>
          <target state="translated">レプリケーションスロットの状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="fff67315163276ff44c96c0a78a1830dd666732b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared multixact state.</source>
          <target state="translated">共有マルチアクト状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="b79ef3c6f580409e99c1e495bc8e24c202fbe7ed" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared notification state.</source>
          <target state="translated">共有通知状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="af64ba8ecf87cac9594cd6dc3c61c2e7ddf060d1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update sub-transaction information.</source>
          <target state="translated">サブトランザクション情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="bdb0edf32466a645cdde40c21227abb2a0bb1f30" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the control file or creation of a new WAL file.</source>
          <target state="translated">制御ファイルの読み込みや更新、新規WALファイルの作成を待っています。</target>
        </trans-unit>
        <trans-unit id="221da797b029fb896c5fbaed99fd507a4ef2a941" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the fast-path lock information.</source>
          <target state="translated">ファストパスロック情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="e9baf36ef5d66bb0ea1e99230d14314cf70bc406" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for the transaction timestamp.</source>
          <target state="translated">トランザクションのタイムスタンプに設定された最後の値の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="15f6ffef563dec9ba786a7f233d5003f5ed45d14" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the replication progress.</source>
          <target state="translated">レプリケーションの進行状況の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="defd9a9d465fec9edd19efb8c557ca9acbf7364b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of prepared transactions.</source>
          <target state="translated">準備された取引の状態の読み取りまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="3dc7e6836006d3d5cbb7a9151c1a348063bbcc88" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction commit timestamps.</source>
          <target state="translated">トランザクション・コミットのタイムスタンプの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="22fb7890af933754ae7b2b3d81b6bd6e23c2cc52" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction status.</source>
          <target state="translated">トランザクションステータスの読み取りまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="1691bd5ffa74ce0764d59f613b874fce42907700" translate="yes" xml:space="preserve">
          <source>Waiting to read or update vacuum-related information for a B-tree index.</source>
          <target state="translated">Bツリーインデックスの真空関連情報の閲覧・更新を待っています。</target>
        </trans-unit>
        <trans-unit id="7909f678b84800f1b2a16328d0f20ff93a738a0c" translate="yes" xml:space="preserve">
          <source>Waiting to read or write a data page in memory.</source>
          <target state="translated">メモリ内のデータページの読み書きを待っています。</target>
        </trans-unit>
        <trans-unit id="ba3f3c6d87b25a2add5f41dc054490a6748416d8" translate="yes" xml:space="preserve">
          <source>Waiting to read or write relation cache initialization file.</source>
          <target state="translated">リレーションキャッシュ初期化ファイルの読み込みまたは書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="56e29e2fa37b4e49226f461d31f27cc492afa177" translate="yes" xml:space="preserve">
          <source>Waiting to read while creating the data directory lock file.</source>
          <target state="translated">データディレクトリロックファイルの作成中に読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="22b6a17e9f6b4570d83c86bfc0b1331afbfa69c0" translate="yes" xml:space="preserve">
          <source>Waiting to receive bytes from a shared message queue.</source>
          <target state="translated">共有メッセージキューからのバイトの受信を待っています。</target>
        </trans-unit>
        <trans-unit id="9ce53a35add68653a7082475749be3845de4e91c" translate="yes" xml:space="preserve">
          <source>Waiting to replace a page in WAL buffers.</source>
          <target state="translated">WAL バッファ内のページの入れ替えを待っています。</target>
        </trans-unit>
        <trans-unit id="e3b17dffde0ea5035f1032f34d22df0ea10ab951" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or remove messages from shared invalidation queue.</source>
          <target state="translated">共有された無効化キューからのメッセージの取得または削除を待っています。</target>
        </trans-unit>
        <trans-unit id="4f507f65bfda2fa748e9dfb44f6b949cbab52bf9" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or store information about serializable transactions.</source>
          <target state="translated">シリアライズ可能なトランザクションに関する情報の取得または保存を待機しています。</target>
        </trans-unit>
        <trans-unit id="c9928fb30a8b9bafde30f4c1a7932ab2be3ad802" translate="yes" xml:space="preserve">
          <source>Waiting to send bytes to a shared message queue.</source>
          <target state="translated">共有メッセージキューへのバイト送信を待っています。</target>
        </trans-unit>
        <trans-unit id="352defc191b1b37d8d934ce574b79689999451d7" translate="yes" xml:space="preserve">
          <source>Waiting to setup, drop or use replication origin.</source>
          <target state="translated">セットアップ、ドロップ、またはレプリケーションオリジンの使用を待っています。</target>
        </trans-unit>
        <trans-unit id="99b1822a05f8be538a4edd0d27d811178799d3aa" translate="yes" xml:space="preserve">
          <source>Waiting to update the &lt;code&gt;postgresql.auto.conf&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;postgresql.auto.conf&lt;/code&gt; ファイルの更新を待機しています。</target>
        </trans-unit>
        <trans-unit id="7f7ad4b1674906a82b48581d682f5005d47dd119" translate="yes" xml:space="preserve">
          <source>Waiting to update the relation map file used to store catalog to filenode mapping.</source>
          <target state="translated">カタログからファイルノードへのマッピングを格納するために使用されるリレーションマップファイルの更新を待っています。</target>
        </trans-unit>
        <trans-unit id="8dc204f5803f3077a290dca7bb374395f034529e" translate="yes" xml:space="preserve">
          <source>Waiting to write a protocol message to a shared message queue.</source>
          <target state="translated">共有メッセージキューへのプロトコルメッセージの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="2d0728d153f9f18004a22e4fb271924454b6a556" translate="yes" xml:space="preserve">
          <source>Waiting to write data to the client.</source>
          <target state="translated">クライアントへのデータ書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="65a1974782cb646a2959736cb6599731cefd99f2" translate="yes" xml:space="preserve">
          <source>Waiting to write zero bytes to a dynamic shared memory backing file.</source>
          <target state="translated">動的共有メモリバッキングファイルへのゼロバイトの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="0929df55dd9f72fd6c1d910f07bdae3bd6e941bb" translate="yes" xml:space="preserve">
          <source>Warm and hot standby servers can be kept current by reading a stream of write-ahead log (WAL) records. If the main server fails, the standby contains almost all of the data of the main server, and can be quickly made the new master database server. This can be synchronous or asynchronous and can only be done for the entire database server.</source>
          <target state="translated">ウォームスタンバイおよびホットスタンバイサーバは、WAL(write-ahead log)レコードのストリームを読み込むことで、最新の状態に保つことができます。メインサーバに障害が発生した場合、スタンバイサーバにはメインサーバのほぼすべてのデータが含まれており、迅速に新しいマスターデータベースサーバにすることができます。これは同期または非同期のどちらでも可能で、データベースサーバ全体に対してのみ行うことができます。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="a016c375864acf9c142cbb1359e053c54d4d9438" translate="yes" xml:space="preserve">
          <source>We already saw that &lt;code&gt;ORDER BY&lt;/code&gt; can be omitted if the ordering of rows is not important. It is also possible to omit &lt;code&gt;PARTITION BY&lt;/code&gt;, in which case there is a single partition containing all rows.</source>
          <target state="translated">行の順序が重要でない場合は、 &lt;code&gt;ORDER BY&lt;/code&gt; を省略できることはすでに説明しました。 &lt;code&gt;PARTITION BY&lt;/code&gt; を省略することもできます。その場合、すべての行を含む単一のパーティションがあります。</target>
        </trans-unit>
        <trans-unit id="836ee2eeb6e7ae6444006848acb871065ea3b213" translate="yes" xml:space="preserve">
          <source>We already saw the MCV information for &lt;code&gt;stringu1&lt;/code&gt;, and here is its histogram:</source>
          <target state="translated">&lt;code&gt;stringu1&lt;/code&gt; のMCV情報はすでに確認しました。そのヒストグラムを次に示します。</target>
        </trans-unit>
        <trans-unit id="4916a888ae7040005cd716f2c3e28e1930fe1e1c" translate="yes" xml:space="preserve">
          <source>We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has indeed been permanently recorded and won't be lost even if a crash ensues shortly thereafter. For example, if we are recording a cash withdrawal by Bob, we do not want any chance that the debit to his account will disappear in a crash just after he walks out the bank door. A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.</source>
          <target state="translated">また、一度トランザクションが完了し、データベースシステムによって承認されると、それは本当に永久に記録され、その後すぐにクラッシュが発生しても失われないことを保証したいと思います。例えば、ボブが現金を引き出したことを記録している場合、彼が銀行のドアから出て行った直後のクラッシュで彼の口座への引き落としが消えてしまうようなことは避けたいものです。トランザクションデータベースは、トランザクションが完了したと報告される前に、トランザクションによって行われたすべての更新が永久記憶装置(ディスク上)に記録されることを保証します。</target>
        </trans-unit>
        <trans-unit id="6743dd465747bd2e107f6841f4c88e12a10fdc63" translate="yes" xml:space="preserve">
          <source>We can also access arbitrary rectangular slices of an array, or subarrays. An array slice is denoted by writing &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; for one or more array dimensions. For example, this query retrieves the first item on Bill's schedule for the first two days of the week:</source>
          <target state="translated">また、配列またはサブ配列の任意の長方形スライスにアクセスすることもできます。配列スライスは、1つ以上の配列次元に対して &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; を記述することによって示されます。たとえば、次のクエリは、ビルのスケジュールの最初の2日間の最初のアイテムを取得します。</target>
        </trans-unit>
        <trans-unit id="26d5e00c2932aa021f71e1c7987bbc84382d9b85" translate="yes" xml:space="preserve">
          <source>We can also choose to return &lt;code&gt;NULL&lt;/code&gt;, instead of the lower-cased word, if it is not found in the stop words file. This behavior is selected by setting the dictionary's &lt;code&gt;Accept&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt;. Continuing the example:</source>
          <target state="translated">ストップワードファイルに &lt;code&gt;NULL&lt;/code&gt; が見つからない場合は、小文字の代わりにNULLを返すこともできます。この動作は、ディクショナリの &lt;code&gt;Accept&lt;/code&gt; パラメータを &lt;code&gt;false&lt;/code&gt; に設定することによって選択されます。例を続ける：</target>
        </trans-unit>
        <trans-unit id="dfd312f5fc4d67101d851237062bdba159c0ec59" translate="yes" xml:space="preserve">
          <source>We can also join a table against itself. This is called a &lt;em&gt;self join&lt;/em&gt;. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of each &lt;code&gt;weather&lt;/code&gt; row to the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of all other &lt;code&gt;weather&lt;/code&gt; rows. We can do this with the following query:</source>
          <target state="translated">自分自身に対してテーブルを結合することもできます。これは&lt;em&gt;自己結合&lt;/em&gt;と呼ばれます。例として、他の気象記録の温度範囲にあるすべての気象記録を検索したいとします。比較する必要があり、我々はそう &lt;code&gt;temp_lo&lt;/code&gt; と &lt;code&gt;temp_hi&lt;/code&gt; それぞれの列 &lt;code&gt;weather&lt;/code&gt; に行を &lt;code&gt;temp_lo&lt;/code&gt; と &lt;code&gt;temp_hi&lt;/code&gt; 他のすべての列 &lt;code&gt;weather&lt;/code&gt; 行。これは、次のクエリで実行できます。</target>
        </trans-unit>
        <trans-unit id="4dc6beb3b0e1bef62d183184143ea3d3ef810b4c" translate="yes" xml:space="preserve">
          <source>We can change the rewriting rules just by updating the table:</source>
          <target state="translated">テーブルを更新するだけで書き換えルールを変更することができます。</target>
        </trans-unit>
        <trans-unit id="ee2618785314089b8d336377e9a207db9405d3b4" translate="yes" xml:space="preserve">
          <source>We can create a GIN index (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;) to speed up text searches:</source>
          <target state="translated">GINインデックス（&lt;a href=&quot;textsearch-indexes&quot;&gt;セクション12.9&lt;/a&gt;）を作成して、テキスト検索を高速化できます。</target>
        </trans-unit>
        <trans-unit id="c7821bbb704a2ac952eb9690616bfdd424400d47" translate="yes" xml:space="preserve">
          <source>We can do inheritance:</source>
          <target state="translated">相続はできる。</target>
        </trans-unit>
        <trans-unit id="d91685339d290a8a5e3f0243e992defd515e095f" translate="yes" xml:space="preserve">
          <source>We can then see that an administrator connecting over a network will not see any records, due to the restrictive policy:</source>
          <target state="translated">そして、ネットワーク上に接続している管理者は、制限されたポリシーのために、何の記録も表示されないことがわかります。</target>
        </trans-unit>
        <trans-unit id="9e7ee16addc76bca0dc0a634456700165327da1e" translate="yes" xml:space="preserve">
          <source>We can update an individual subfield of a composite column:</source>
          <target state="translated">複合カラムの個々のサブフィールドを更新することができます。</target>
        </trans-unit>
        <trans-unit id="dbaecdebc4248cd30d99181acc6ee4648ce55281" translate="yes" xml:space="preserve">
          <source>We choose not to index or search some token types that the built-in configuration does handle:</source>
          <target state="translated">組み込みの設定で処理できるいくつかのトークン型をインデックス化したり検索したりしないようにしています。</target>
        </trans-unit>
        <trans-unit id="f68910847b8b293ecced82107bbdb7c9e86be5f0" translate="yes" xml:space="preserve">
          <source>We could also have written:</source>
          <target state="translated">書くこともできました。</target>
        </trans-unit>
        <trans-unit id="1af074a97ee1433a54eef949ce0f504465ee61b0" translate="yes" xml:space="preserve">
          <source>We could simplify this by creating a SQL function that inserts a label at a specified position in a path:</source>
          <target state="translated">パス内の指定した位置にラベルを挿入する SQL 関数を作成することで、これを単純化することができます。</target>
        </trans-unit>
        <trans-unit id="10ed1bedde4f0b0f00a9838d665bf3bd179f0836" translate="yes" xml:space="preserve">
          <source>We define the synonym dictionary like this:</source>
          <target state="translated">類義語辞典をこのように定義しています。</target>
        </trans-unit>
        <trans-unit id="d488cdbcb41070244eeea7399c07a12ab608b66e" translate="yes" xml:space="preserve">
          <source>We do not need a perfectly consistent file system backup as the starting point. Any internal inconsistency in the backup will be corrected by log replay (this is not significantly different from what happens during crash recovery). So we do not need a file system snapshot capability, just tar or a similar archiving tool.</source>
          <target state="translated">出発点として完全に一貫したファイルシステムのバックアップは必要ありません。バックアップの内部的な不整合はログ再生によって修正されます(これはクラッシュリカバリー中に起こることと大きな違いはありません)。そのため、ファイルシステムのスナップショット機能は必要ありません。</target>
        </trans-unit>
        <trans-unit id="7d9a8fa7a3f06527b3bcf2908ca8717c376647ee" translate="yes" xml:space="preserve">
          <source>We have already discussed constants in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The following sections discuss the remaining options.</source>
          <target state="translated">定数については、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;セクション4.1.2&lt;/a&gt;ですでに説明しました。以下のセクションでは、残りのオプションについて説明します。</target>
        </trans-unit>
        <trans-unit id="a1ef9ac43045748116a115e49374f363a8ba372f" translate="yes" xml:space="preserve">
          <source>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data. In this situation we can use partitioning to help us meet all of our different requirements for the measurements table.</source>
          <target state="translated">このテーブルの主な用途は、管理用のオンラインレポートを作成することになるので、ほとんどのクエリは先週、月、四半期のデータだけにアクセスすることがわかっています。保存する必要のある古いデータの量を減らすために、直近の3年分のデータのみを保存することにしました。各月の初めに、古い月のデータを削除します。このような状況では、パーティショニングを使用することで、測定表に対するさまざまな要件をすべて満たすことができます。</target>
        </trans-unit>
        <trans-unit id="8a993aca05617d8df040114000bd6876b7a6bbb8" translate="yes" xml:space="preserve">
          <source>We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:</source>
          <target state="translated">外部キーは、どの商品にも関連しない注文の作成を禁止していることは知っています。しかし、商品を参照する注文が作成された後に商品が削除された場合はどうでしょうか?SQLでは、そのような場合にも対応することができます。直感的には、いくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="afd1ca25954ba7db5e426cd93dec87fb2f18cad3" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">データが何らかの方法で &lt;code&gt;capitals&lt;/code&gt; テーブルにルーティングされることを期待するかもしれませんが、これは起こりません &lt;code&gt;INSERT&lt;/code&gt; 常に指定されたテーブルに正確に挿入します。場合によっては、ルールを使用して挿入をリダイレクトできます（&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章を&lt;/a&gt;参照）。ただし、 &lt;code&gt;cities&lt;/code&gt; テーブルには列の &lt;code&gt;state&lt;/code&gt; が含まれていないため、上記のケースには役立ちません。そのため、ルールを適用する前にコマンドは拒否されます。</target>
        </trans-unit>
        <trans-unit id="668bafcded25fc8a525c39fc8ba11f8e8e98aa03" translate="yes" xml:space="preserve">
          <source>We might want to insert data and have the server automatically locate the child table into which the row should be added. We could do this with a more complex trigger function, for example:</source>
          <target state="translated">データを挿入して、行を追加すべき子テーブルをサーバが自動的に見つけてくれるようにしたいかもしれません。これは、例えば、より複雑なトリガー関数を使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="1aa4d9dcdf43d5b53cef629cb08b1cf507249faa" translate="yes" xml:space="preserve">
          <source>We must redefine the trigger function each month so that it always points to the current child table. The trigger definition does not need to be updated, however.</source>
          <target state="translated">常に現在の子テーブルを指すように、毎月トリガー関数を再定義する必要があります。しかし、トリガ定義は更新する必要はありません。</target>
        </trans-unit>
        <trans-unit id="1597c32eb07ab6cca066ebab3e65392f57896307" translate="yes" xml:space="preserve">
          <source>We recommend that active production databases be vacuumed frequently (at least nightly), in order to remove dead rows. After adding or deleting a large number of rows, it might be a good idea to issue a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; command for the affected table. This will update the system catalogs with the results of all recent changes, and allow the PostgreSQL query planner to make better choices in planning queries.</source>
          <target state="translated">デッド行を削除するために、アクティブな本番データベースを頻繁に（少なくとも毎晩）バキュームすることをお勧めします。多数の行を追加または削除した後、影響を受けるテーブルに対して &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; コマンドを発行することをお勧めします。これにより、すべての最近の変更の結果でシステムカタログが更新され、PostgreSQLクエリプランナーがクエリの計画においてより適切な選択を行えるようになります。</target>
        </trans-unit>
        <trans-unit id="4e67abf5ade818ba6d22ea4bc6d74fa648515393" translate="yes" xml:space="preserve">
          <source>We reject the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command across the board, because any module loaded could easily circumvent security policy enforcement.</source>
          <target state="translated">読み込まれたモジュールはセキュリティポリシーの適用を簡単に回避できるため、&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;コマンドは全面的に拒否されます。</target>
        </trans-unit>
        <trans-unit id="977603731abefa85626583cf9841c1f7f86bb5c7" translate="yes" xml:space="preserve">
          <source>We require the index access method to apply these tests itself, which means that it must reach into the heap to check the commit status of any row that is shown to have a duplicate key according to the index contents. This is without a doubt ugly and non-modular, but it saves redundant work: if we did a separate probe then the index lookup for a conflicting row would be essentially repeated while finding the place to insert the new row's index entry. What's more, there is no obvious way to avoid race conditions unless the conflict check is an integral part of insertion of the new index entry.</source>
          <target state="translated">つまり、インデックスの内容に応じてキーが重複していると示された行のコミット状態をチェックするためにヒープに到達しなければならないということです。これは間違いなく醜くて非モジュール的なものですが、冗長な作業を省くことができます。さらに、競合チェックが新しいインデックスエントリの挿入に不可欠な部分でない限り、競合状態を回避する明白な方法はありません。</target>
        </trans-unit>
        <trans-unit id="61809ffaa1e9bec3b74e00f63e536c6b27a9b1ac" translate="yes" xml:space="preserve">
          <source>We say that in this situation the orders table is the &lt;em&gt;referencing&lt;/em&gt; table and the products table is the &lt;em&gt;referenced&lt;/em&gt; table. Similarly, there are referencing and referenced columns.</source>
          <target state="translated">私たちは、この状況での受注テーブルがあると言う&lt;em&gt;参照元の&lt;/em&gt;テーブルと製品テーブルがある&lt;em&gt;参照先&lt;/em&gt;テーブル。同様に、参照列と参照列があります。</target>
        </trans-unit>
        <trans-unit id="926fa8d618ecd63d98d203881339877369fb9e8a" translate="yes" xml:space="preserve">
          <source>We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:</source>
          <target state="translated">最初の2つの制約は列制約であるのに対し、3番目の制約は任意の1つの列の定義とは別に書かれているため、テーブル制約であると言っています。カラム制約はテーブル制約としても書くことができますが、逆は必ずしも可能ではありません。(PostgreSQLはこの規則を強制していませんが、テーブル定義を他のデータベースシステムで動作させたい場合は、この規則に従うべきです)。上の例は次のように書くこともできます。</target>
        </trans-unit>
        <trans-unit id="61ad12c01cac6b9fd7b6ff658816ff5bf8b904a2" translate="yes" xml:space="preserve">
          <source>We store these documents in a table named &lt;code&gt;api&lt;/code&gt;, in a &lt;code&gt;jsonb&lt;/code&gt; column named &lt;code&gt;jdoc&lt;/code&gt;. If a GIN index is created on this column, queries like the following can make use of the index:</source>
          <target state="translated">これらのドキュメントを &lt;code&gt;api&lt;/code&gt; という名前のテーブルの &lt;code&gt;jsonb&lt;/code&gt; という名前の &lt;code&gt;jdoc&lt;/code&gt; 列に格納します。この列にGINインデックスが作成されている場合、次のようなクエリでインデックスを使用できます。</target>
        </trans-unit>
        <trans-unit id="c00287a4e7374c9957df5b25550d2f8b5bf2d466" translate="yes" xml:space="preserve">
          <source>We use the following terms below: The &lt;em&gt;precision&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The &lt;em&gt;scale&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.</source>
          <target state="translated">以下の用語を使用します。 &lt;code&gt;numeric&lt;/code&gt; の&lt;em&gt;精度&lt;/em&gt;は、整数の有効桁の総数、つまり、小数点の両側の桁数です。 &lt;code&gt;numeric&lt;/code&gt; の&lt;em&gt;スケール&lt;/em&gt;は、小数点の右側の小数部分の小数点の数です。したがって、数値23.5141の精度は6で、スケールは4です。整数は、スケールがゼロであると見なすことができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a22e103a166cab5bebeb6c6bf8216ec0f41d1ce6" translate="yes" xml:space="preserve">
          <source>We use the same &lt;code&gt;measurement&lt;/code&gt; table we used above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">上記と同じ &lt;code&gt;measurement&lt;/code&gt; テーブルを使用します。継承を使用してパーティションを実装するには、次の手順を使用します。</target>
        </trans-unit>
        <trans-unit id="87bb5356e299e65f3820ac3133d7b4e088f6bde2" translate="yes" xml:space="preserve">
          <source>We use the word &lt;em&gt;item&lt;/em&gt; to refer to a composite value that is to be indexed, and the word &lt;em&gt;key&lt;/em&gt; to refer to an element value. GIN always stores and searches for keys, not item values per se.</source>
          <target state="translated">インデックスを付ける複合値を参照するには&lt;em&gt;item&lt;/em&gt;という単語を使用し、要素の値を参照するには&lt;em&gt;key&lt;/em&gt;という単語を使用します。GINは常にアイテムの値そのものではなく、キーを保存して検索します。</target>
        </trans-unit>
        <trans-unit id="aaac10448fb5e7278bf16580755bd9621bfb54f1" translate="yes" xml:space="preserve">
          <source>We want our application to be able to say &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; and have the data be redirected into the appropriate child table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest child, we can use a very simple trigger function:</source>
          <target state="translated">アプリケーションで &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; を使用して、データを適切な子テーブルにリダイレクトできるようにしたいと考えています。マスターテーブルに適切なトリガー関数を付けることで、それを調整できます。最新の子にのみデータが追加される場合は、非常に単純なトリガー関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="cdc05935dfdf1c41e4dbff177f8b502be331c045" translate="yes" xml:space="preserve">
          <source>We will use a PostgreSQL-specific synonym list and store it in &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt;. The file contents look like:</source>
          <target state="translated">PostgreSQL固有の同義語リストを使用して、それを &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt; ます。ファイルの内容は次のようになります。</target>
        </trans-unit>
        <trans-unit id="963adbfe40be253cf091e436ca27447ef3a470bc" translate="yes" xml:space="preserve">
          <source>Wed, Weds</source>
          <target state="translated">水、水</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="fdeddc33f6adb1db2fc6d6142f8a57019f70774f" translate="yes" xml:space="preserve">
          <source>Weights are typically used to reflect document structure, for example by marking title words differently from body words. Text search ranking functions can assign different priorities to the different weight markers.</source>
          <target state="translated">重みは一般的に文書構造を反映させるために使用され、例えば、タイトル語と本文語とを区別してマークすることである。テキスト検索ランキング機能は、異なる重みマーカーに異なる優先順位を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="683c9370be61bfcd03e58355d7c86c6e1369d2d9" translate="yes" xml:space="preserve">
          <source>Western European</source>
          <target state="translated">西欧人</target>
        </trans-unit>
        <trans-unit id="e82bc7cf6e54b2e4257e788dff104c1e42da4e0b" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?</source>
          <target state="translated">JITコンパイルとは?</target>
        </trans-unit>
        <trans-unit id="9d446878c466219c122696ab7b32c54ff789d87e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Inlining</source>
          <target state="translated">JITコンパイルとは?インライン化</target>
        </trans-unit>
        <trans-unit id="ca44cc7300ef1dcac2b672637a01e3b0a0da90f7" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: JIT Accelerated Operations</source>
          <target state="translated">JITコンパイルとは?JIT加速化された運用</target>
        </trans-unit>
        <trans-unit id="760d95b57cc4647ff2722b6cf5ee7f34082cc25e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Optimization</source>
          <target state="translated">JITコンパイルとは?最適化</target>
        </trans-unit>
        <trans-unit id="6026d88e883e805146a8bbfee4583738ccfd77d8" translate="yes" xml:space="preserve">
          <source>What Is the &amp;ldquo;Transaction&amp;rdquo; Actually Performed in pgbench?</source>
          <target state="translated">pgbenchで実際に実行される「トランザクション」とは何ですか？</target>
        </trans-unit>
        <trans-unit id="6c8a97eccbb7e55f60d7659738855ee30c65e97d" translate="yes" xml:space="preserve">
          <source>What has really happened here is that the two unknown literals are resolved to &lt;code&gt;text&lt;/code&gt; by default, allowing the &lt;code&gt;||&lt;/code&gt; operator to be resolved as &lt;code&gt;text&lt;/code&gt; concatenation. Then the &lt;code&gt;text&lt;/code&gt; result of the operator is converted to &lt;code&gt;bpchar&lt;/code&gt; (&amp;ldquo;blank-padded char&amp;rdquo;, the internal name of the &lt;code&gt;character&lt;/code&gt; data type) to match the target column type. (Since the conversion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;bpchar&lt;/code&gt; is binary-coercible, this conversion does not insert any real function call.) Finally, the sizing function &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; is found in the system catalog and applied to the operator's result and the stored column length. This type-specific function performs the required length check and addition of padding spaces.</source>
          <target state="translated">ここで実際に起こったことは、2つの不明なリテラルがデフォルトで &lt;code&gt;text&lt;/code&gt; 解決され、 &lt;code&gt;||&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 連結として解決される演算子。次に、演算子の &lt;code&gt;text&lt;/code&gt; 結果が &lt;code&gt;bpchar&lt;/code&gt; （「空白で埋め込まれたchar」、 &lt;code&gt;character&lt;/code&gt; データ型の内部名）に変換され、ターゲット列の型と一致します。 （ &lt;code&gt;text&lt;/code&gt; から &lt;code&gt;bpchar&lt;/code&gt; への変換はバイナリ強制可能であるため、この変換では実際の関数呼び出しは挿入されません。）最後に、サイジング関数 &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; システムカタログで見つかり、オペレーターの結果と格納されている列の長さに適用されます。このタイプ固有の関数は、必要な長さチェックとパディングスペースの追加を実行します。</target>
        </trans-unit>
        <trans-unit id="dfcede4e6134968fca6be5ab22337a4021df7d2f" translate="yes" xml:space="preserve">
          <source>What is a &amp;ldquo;system user&amp;rdquo; is determined at systemd compile time from the &lt;code&gt;SYS_UID_MAX&lt;/code&gt; setting in &lt;code&gt;/etc/login.defs&lt;/code&gt;.</source>
          <target state="translated">「システムユーザー」とは、systemdのコンパイル時に &lt;code&gt;/etc/login.defs&lt;/code&gt; の &lt;code&gt;SYS_UID_MAX&lt;/code&gt; 設定から決定されます。</target>
        </trans-unit>
        <trans-unit id="c3b062bdc5b358d8bc1d0ea5b87500675ecf488c" translate="yes" xml:space="preserve">
          <source>What is essentially happening here is a join between &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;producers&lt;/code&gt;, with all successfully joined &lt;code&gt;films&lt;/code&gt; rows being marked for deletion. This syntax is not standard. A more standard way to do it is:</source>
          <target state="translated">ここで本質的に起こっていることは、 &lt;code&gt;films&lt;/code&gt; と &lt;code&gt;producers&lt;/code&gt; 間の結合であり、結合に成功したすべての &lt;code&gt;films&lt;/code&gt; 行は削除対象としてマークされています。この構文は標準ではありません。それを行うためのより標準的な方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e6eec3dfd99f17e2a6e53d2f854ed352bd2c2826" translate="yes" xml:space="preserve">
          <source>What locales are available on your system under what names depends on what was provided by the operating system vendor and what was installed. On most Unix systems, the command &lt;code&gt;locale -a&lt;/code&gt; will provide a list of available locales. Windows uses more verbose locale names, such as &lt;code&gt;German_Germany&lt;/code&gt; or &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt;, but the principles are the same.</source>
          <target state="translated">システムで使用できるロケールは、オペレーティングシステムベンダーから提供されたものと、インストールされたものによって異なります。ほとんどのUnixシステムでは、コマンド &lt;code&gt;locale -a&lt;/code&gt; を使用すると、使用可能なロケールのリストが表示されます。 Windowsは、 &lt;code&gt;German_Germany&lt;/code&gt; や &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt; などのより詳細なロケール名を使用しますが、原理は同じです。</target>
        </trans-unit>
        <trans-unit id="40680439c20fb6866bd543023ba55a7dbd37c92b" translate="yes" xml:space="preserve">
          <source>What this does is to record the links created by pg_upgrade's link mode that connect files in the old and new clusters on the primary server. It then finds matching files in the standby's old cluster and creates links for them in the standby's new cluster. Files that were not linked on the primary are copied from the primary to the standby. (They are usually small.) This provides rapid standby upgrades. Unfortunately, rsync needlessly copies files associated with temporary and unlogged tables because these files don't normally exist on standby servers.</source>
          <target state="translated">これは、プライマリサーバ上の新旧クラスタ内のファイルを接続するpg_upgradeのリンクモードによって作成されたリンクを記録することです。そして、スタンバイの古いクラスタ内で一致するファイルを見つけ、スタンバイの新しいクラスタ内にそれらのファイルへのリンクを作成します。プライマリ上でリンクされていなかったファイルは、プライマリからスタンバイにコピーされます。(それらは通常小さなものです。)これにより、スタンバイの迅速なアップグレードが可能になります。残念なことに、一時的なテーブルやログされていないテーブルに関連するファイルは通常スタンバイサーバには存在しないので、rsync は不必要にコピーしてしまいます。</target>
        </trans-unit>
        <trans-unit id="a446c8d9e480b9f0f6cbcd76fef7e2bcda6c700b" translate="yes" xml:space="preserve">
          <source>What's more, when you load data into a table with existing foreign key constraints, each new row requires an entry in the server's list of pending trigger events (since it is the firing of a trigger that checks the row's foreign key constraint). Loading many millions of rows can cause the trigger event queue to overflow available memory, leading to intolerable swapping or even outright failure of the command. Therefore it may be &lt;em&gt;necessary&lt;/em&gt;, not just desirable, to drop and re-apply foreign keys when loading large amounts of data. If temporarily removing the constraint isn't acceptable, the only other recourse may be to split up the load operation into smaller transactions.</source>
          <target state="translated">さらに、既存の外部キー制約があるテーブルにデータをロードする場合、新しい行ごとに、サーバーの保留中のトリガーイベントのリストにエントリが必要です（行の外部キー制約をチェックするトリガーの起動であるため）。何百万もの行をロードすると、トリガーイベントキューが使用可能なメモリをオーバーフローし、許容できないスワッピングまたはコマンドの完全な失敗につながる可能性があります。したがって、大量のデータをロードする場合、外部キーを削除して再適用することが望ましいだけでなく、&lt;em&gt;必要&lt;/em&gt;になる場合があります。一時的な制約の削除が受け入れられない場合、他の唯一の手段は、ロード操作を小さなトランザクションに分割することです。</target>
        </trans-unit>
        <trans-unit id="f0604f8d2119324fb427a16a8668c529701bc1a2" translate="yes" xml:space="preserve">
          <source>Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding &lt;code&gt;CASCADE&lt;/code&gt;:</source>
          <target state="translated">列にあったデータはすべて消えます。列を含むテーブルの制約も削除されます。ただし、列が別のテーブルの外部キー制約によって参照されている場合、PostgreSQLはその制約を暗黙的に削除しません。 &lt;code&gt;CASCADE&lt;/code&gt; を追加することで、列に依存するすべてを削除することを承認できます。</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="a60fe559ad2643627bd47ea3eceb6f63037101eb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt; is set, this parameter also determines the amount of time to wait before a log message is issued about the lock wait. If you are trying to investigate locking delays you might want to set a shorter than normal &lt;code&gt;deadlock_timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt;が設定されている場合、このパラメーターは、ロック待機に関するログメッセージが発行されるまでの待機時間も決定します。ロックの遅延を調査する場合は、通常よりも短い &lt;code&gt;deadlock_timeout&lt;/code&gt; を設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="57e37b6a94a28e9acbd6287be1d60c38f8541fd8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">とき &lt;code&gt;--source-server&lt;/code&gt; オプションが使用されている、pg_rewindもlibpqでサポートされる環境変数を使用しています（参照&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;セクション33.14を&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1854281aa73e4f5b1f721e95b9f05123b0ade134" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-n&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected schema(s) might depend upon. Therefore, there is no guarantee that the results of a specific-schema dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; が指定されている場合、pg_dumpは、選択されたスキーマが依存している可能性のある他のデータベースオブジェクトをダンプしようとしません。したがって、特定のスキーマのダンプの結果が、それ自体で正常なデータベースに正常に復元できるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="5fef81c501efe3e088f4b73c9a697af2561cb6dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that the results of a specific-table dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; が指定されている場合、pg_dumpは、選択されたテーブルが依存する可能性のある他のデータベースオブジェクトをダンプしようとしません。したがって、特定のテーブルのダンプの結果を正常なデータベースに正常に復元できるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="8c86589858bd9989813c8435013ddbc1a41c69f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_restore makes no attempt to restore any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that a specific-table restore into a clean database will succeed.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; が指定されている場合、pg_restoreは、選択されたテーブルが依存する可能性のある他のデータベースオブジェクトの復元を試みません。したがって、クリーンなデータベースへの特定のテーブルの復元が成功する保証はありません。</target>
        </trans-unit>
        <trans-unit id="6dd3feb588f68391e70d37037327ad64b7721fd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALTER&lt;/code&gt; command is executed, &lt;code&gt;setattr&lt;/code&gt; will be checked on the object being modified for each object types, except for subsidiary objects such as the indexes or triggers of a table, where permissions are instead checked on the parent object. In some cases, additional permissions are required:</source>
          <target state="translated">場合 &lt;code&gt;ALTER&lt;/code&gt; のコマンドが実行され、 &lt;code&gt;setattr&lt;/code&gt; 子会社は、そのような権限はなく、親オブジェクトでチェックされるテーブルのインデックスまたはトリガなどのオブジェクトを除いて、各オブジェクトタイプに変更されたオブジェクトにチェックされます。場合によっては、追加の権限が必要です。</target>
        </trans-unit>
        <trans-unit id="95ea06756271ccb08739b45bacb4e5cf14e003e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE INDEX&lt;/code&gt; is invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If the &lt;code&gt;ONLY&lt;/code&gt; option is specified, no recursion is done, and the index is marked invalid. (&lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; marks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future using &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; will automatically have a matching index, regardless of whether &lt;code&gt;ONLY&lt;/code&gt; is specified.</source>
          <target state="translated">場合は &lt;code&gt;CREATE INDEX&lt;/code&gt; パーティションテーブルの上に呼び出され、デフォルトの動作では、彼らはすべての一致するインデックスを持っていることを確認するために、すべてのパーティションに再帰することです。最初に各パーティションがチェックされ、同等のインデックスがすでに存在するかどうかが判断されます。存在する場合、そのインデックスはパーティションインデックスとして作成されるインデックスにアタッチされ、親インデックスになります。一致するインデックスが存在しない場合、新しいインデックスが作成され、自動的にアタッチされます。各パーティションの新しいインデックスの名前は、コマンドでインデックス名が指定されていないかのように決定されます。 &lt;code&gt;ONLY&lt;/code&gt; オプションが指定されている場合、再帰は行われず、インデックスは無効とマークされます。 （ &lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; すべてのパーティションが一致するインデックスを取得すると、インデックスが有効とマークされます。）ただし、 &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; を使用して将来作成されるパーティションは、 &lt;code&gt;ONLY&lt;/code&gt; が指定されているかどうかに関係なく、自動的に一致するインデックスを持ちます。</target>
        </trans-unit>
        <trans-unit id="0c15e2e86d36f47a57239a8f802301f2d222dbb6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; is used to replace an existing function, the ownership and permissions of the function do not change. All other function properties are assigned the values specified or implied in the command. You must own the function to replace it (this includes being a member of the owning role).</source>
          <target state="translated">場合は &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 既存の関数を置き換えるために使用され、機能の所有権とアクセス権は変更されません。他のすべての関数プロパティには、コマンドで指定または暗示されている値が割り当てられます。これを置き換えるには、関数を所有している必要があります（これには、所有ロールのメンバーであることも含まれます）。</target>
        </trans-unit>
        <trans-unit id="db55d63efcb8b5298291fde068a29837b503dfcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; is used to replace an existing procedure, the ownership and permissions of the procedure do not change. All other procedure properties are assigned the values specified or implied in the command. You must own the procedure to replace it (this includes being a member of the owning role).</source>
          <target state="translated">場合は &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 既存のプロシージャを置き換えるために使用され、手続きの所有権とアクセス権は変更されません。他のすべてのプロシージャプロパティには、コマンドで指定または暗示されている値が割り当てられます。プロシージャを置き換えるには、そのプロシージャを所有している必要があります（これには、所有ロールのメンバーであることも含まれます）。</target>
        </trans-unit>
        <trans-unit id="11b7e02139c0fd56fa0d0c0d7e02cacf1863b7dd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; is used on an existing view, only the view's defining SELECT rule is changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).</source>
          <target state="translated">場合は &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 既存のビューで使用されている、唯一のビューの定義SELECTルールが変更されます。所有権、権限、非SELECTルールなど、他のビュープロパティは変更されません。それを置き換えるには、ビューを所有している必要があります（これには、所有ロールのメンバーであることも含まれます）。</target>
        </trans-unit>
        <trans-unit id="b2b68d33a4076adb362da4bb710ac3317fb09cf8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DROP&lt;/code&gt; command is executed, &lt;code&gt;drop&lt;/code&gt; will be checked on the object being removed. Permissions will be also checked for objects dropped indirectly via &lt;code&gt;CASCADE&lt;/code&gt;. Deletion of objects contained within a particular schema (tables, views, sequences and procedures) additionally requires &lt;code&gt;remove_name&lt;/code&gt; on the schema.</source>
          <target state="translated">ときに &lt;code&gt;DROP&lt;/code&gt; のコマンドが実行され、 &lt;code&gt;drop&lt;/code&gt; 削除されたオブジェクトにチェックされます。 &lt;code&gt;CASCADE&lt;/code&gt; を介して間接的に削除されたオブジェクトのアクセス許可もチェックされます。特定のスキーマ（テーブル、ビュー、シーケンス、およびプロシージャ）に含まれているオブジェクトを削除するには、さらにスキーマに &lt;code&gt;remove_name&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="f47c9d6dc4a8942d1dd522d4978fe59346f8ad48" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GROUP BY&lt;/code&gt; is present, or any aggregate functions are present, it is not valid for the &lt;code&gt;SELECT&lt;/code&gt; list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; が存在する場合、または集約関数が存在する場合、集約関数内、またはグループ化されていない列がグループ化された列に機能的に依存している場合を除いて、 &lt;code&gt;SELECT&lt;/code&gt; リスト式がグループ化されていない列を参照することは無効です。グループ化されていない列に対して返される可能性のある1つの値よりも大きい。グループ化された列（またはそのサブセット）が、グループ化されていない列を含むテーブルの主キーである場合、機能的な依存関係が存在します。</target>
        </trans-unit>
        <trans-unit id="a61a8feeb668ae119fbcd691b6fc8464f954d0c9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NOTIFY&lt;/code&gt; is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the &lt;code&gt;NOTIFY&lt;/code&gt; in a statement trigger that is triggered by table updates. In this way, notification happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; を使用して特定のテーブルへの変更の発生を通知する場合、有用なプログラミング手法は、テーブルの更新によってトリガーされるステートメントトリガーに &lt;code&gt;NOTIFY&lt;/code&gt; を配置することです。このようにして、テーブルが変更されたときに通知が自動的に行われ、アプリケーションプログラマが誤ってそれを忘れることはありません。</target>
        </trans-unit>
        <trans-unit id="96d946d891d853517e02080ffe41ee5e79e55c40" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. This is unlike the normal behavior of &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt;. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">場合 &lt;code&gt;RESTART IDENTITY&lt;/code&gt; が指定され、黙示 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; の動作もトランザクション行われます。つまり、周囲のトランザクションがコミットされない場合、ロールバックされます。これは、 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; の通常の動作とは異なります。トランザクションがロールバックされる前に、再起動されたシーケンスで追加のシーケンス操作が行われた場合、シーケンスに対するこれらの操作の影響はロールバックされますが、 &lt;code&gt;currval()&lt;/code&gt; への影響はありません。つまり、トランザクション &lt;code&gt;currval()&lt;/code&gt; の後シーケンス自体がそれと一致しなくなったとしても、失敗したトランザクション内で取得された最後のシーケンス値を反映し続けます。これは、トランザクションが失敗した後の &lt;code&gt;currval()&lt;/code&gt; の通常の動作に似ています。</target>
        </trans-unit>
        <trans-unit id="1dd38b054f6c38892cf4b53376368a92afaa9614" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; changes the mode of a constraint from &lt;code&gt;DEFERRED&lt;/code&gt; to &lt;code&gt;IMMEDIATE&lt;/code&gt;, the new mode takes effect retroactively: any outstanding data modifications that would have been checked at the end of the transaction are instead checked during the execution of the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. If any such constraint is violated, the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; fails (and does not change the constraint mode). Thus, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; can be used to force checking of constraints to occur at a specific point in a transaction.</source>
          <target state="translated">ときに &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; からの制約のモードを変更 &lt;code&gt;DEFERRED&lt;/code&gt; に &lt;code&gt;IMMEDIATE&lt;/code&gt; 、新しいモードが遡及的に有効になります。トランザクションの終了時にチェックされていた未処理のデータ変更が代わりに実行時にチェックされ &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; コマンド。このような制約に違反すると、 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; は失敗します（制約モードは変更されません）。したがって、 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; を使用すると、トランザクションの特定のポイントで制約のチェックを強制的に実行できます。</target>
        </trans-unit>
        <trans-unit id="c0b169cb5b7cb17bff71441e629815508752132d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VALUES&lt;/code&gt; is used in &lt;code&gt;INSERT&lt;/code&gt;, the values are all automatically coerced to the data type of the corresponding destination column. When it's used in other contexts, it might be necessary to specify the correct data type. If the entries are all quoted literal constants, coercing the first is sufficient to determine the assumed type for all:</source>
          <target state="translated">ときに &lt;code&gt;VALUES&lt;/code&gt; で使用される &lt;code&gt;INSERT&lt;/code&gt; 、値はすべて自動的に対応する宛先カラムのデータ型に強制されています。他のコンテキストで使用する場合は、正しいデータ型を指定する必要がある場合があります。エントリがすべて引用符で囲まれたリテラル定数の場合、最初のものを強制するだけで、すべての想定される型を特定できます。</target>
        </trans-unit>
        <trans-unit id="45ae9ff8fa95f77c4ea16390adcefafbd4f890d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;ANALYZE&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">場合 &lt;code&gt;VERBOSE&lt;/code&gt; が指定され、 &lt;code&gt;ANALYZE&lt;/code&gt; 発するは、現在処理されているテーブルを示すためのメッセージを進行します。テーブルに関するさまざまな統計情報も出力されます。</target>
        </trans-unit>
        <trans-unit id="14f1458fcf796362f90bd6b53ff757eaee1e2939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;VACUUM&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">場合 &lt;code&gt;VERBOSE&lt;/code&gt; が指定されている、 &lt;code&gt;VACUUM&lt;/code&gt; の発するは、現在処理されているテーブルを示すためのメッセージを進行します。テーブルに関するさまざまな統計情報も出力されます。</target>
        </trans-unit>
        <trans-unit id="f54823d23e5df73c9472414a7a83e6ba082b1ce2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, or &lt;code&gt;\ev&lt;/code&gt; is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user's editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples:</source>
          <target state="translated">とき &lt;code&gt;\e&lt;/code&gt; 、 &lt;code&gt;\ef&lt;/code&gt; 、または &lt;code&gt;\ev&lt;/code&gt; 行番号の引数とともに使用され、この変数は、コマンドライン引数は、ユーザのエディタに開始行番号を渡すために使用を指定します。 Emacsやviなどのエディターの場合、これはプラス記号です。オプション名と行番号の間にスペースが必要な場合は、変数の値に末尾のスペースを含めます。例：</target>
        </trans-unit>
        <trans-unit id="880bf87755564e46a3f310f5734ab8ac6764465b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;archive_mode&lt;/code&gt; is enabled, completed WAL segments are sent to archive storage by setting &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. In addition to &lt;code&gt;off&lt;/code&gt;, to disable, there are two modes: &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;always&lt;/code&gt;. During normal operation, there is no difference between the two modes, but when set to &lt;code&gt;always&lt;/code&gt; the WAL archiver is enabled also during archive recovery or standby mode. In &lt;code&gt;always&lt;/code&gt; mode, all files restored from the archive or streamed with streaming replication will be archived (again). See &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;Section 26.2.9&lt;/a&gt; for details.</source>
          <target state="translated">とき &lt;code&gt;archive_mode&lt;/code&gt; 有効になっている、完成WALセグメントを設定することにより、アーカイブストレージに送信さ&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;にarchive_commandを&lt;/a&gt;。 &lt;code&gt;off&lt;/code&gt; に加えて、無効にするために、 &lt;code&gt;on&lt;/code&gt; と &lt;code&gt;always&lt;/code&gt; の 2つのモードがあります。通常の操作中、2つのモードの間に違いはありませんが、 &lt;code&gt;always&lt;/code&gt; 設定されている場合、WALアーカイバはアーカイブのリカバリまたはスタンバイモードでも有効になります。で &lt;code&gt;always&lt;/code&gt; モードで、すべてのファイルは、アーカイブから復元または（再）アーカイブされますストリーミングレプリケーションでストリーミング。詳細は&lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;項26.2.9&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="46cdaf5a9c68bb7dda3e95a7d23c6fce30bcf59a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;commit_delay&lt;/code&gt; is set to zero (the default), it is still possible for a form of group commit to occur, but each group will consist only of sessions that reach the point where they need to flush their commit records during the window in which the previous flush operation (if any) is occurring. At higher client counts a &amp;ldquo;gangway effect&amp;rdquo; tends to occur, so that the effects of group commit become significant even when &lt;code&gt;commit_delay&lt;/code&gt; is zero, and thus explicitly setting &lt;code&gt;commit_delay&lt;/code&gt; tends to help less. Setting &lt;code&gt;commit_delay&lt;/code&gt; can only help when (1) there are some concurrently committing transactions, and (2) throughput is limited to some degree by commit rate; but with high rotational latency this setting can be effective in increasing transaction throughput with as few as two clients (that is, a single committing client with one sibling transaction).</source>
          <target state="translated">とき &lt;code&gt;commit_delay&lt;/code&gt; ゼロ（デフォルト）に設定され、グループの形が発生することを約束するために、それはまだ可能ですが、各グループは彼らが窓の間に彼らのコミットレコードをフラッシュする必要がある点に到達するのセッションで構成されます以前のフラッシュ操作（ある場合）が発生しています。クライアント数が多いと「ギャングウェイ効果」が発生する傾向があるため、 &lt;code&gt;commit_delay&lt;/code&gt; がゼロの場合でもグループコミットの効果が大きくなるため、commit_delayを明示的に設定すると &lt;code&gt;commit_delay&lt;/code&gt; が低下する傾向があります。 &lt;code&gt;commit_delay&lt;/code&gt; の設定（1）同時にコミットするトランザクションがいくつかあり、（2）スループットがコミットレートによってある程度制限されている場合にのみ役立ちます。ただし、回転待ち時間が長い場合、この設定は、わずか2つのクライアント（つまり、1つの兄弟トランザクションを持つ単一のコミットクライアント）でトランザクションスループットを向上させるのに効果的です。</target>
        </trans-unit>
        <trans-unit id="639e6544c619e9aa79e7a25d85adc789836438b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;default_tablespace&lt;/code&gt; is set to anything but an empty string, it supplies an implicit &lt;code&gt;TABLESPACE&lt;/code&gt; clause for &lt;code&gt;CREATE TABLE&lt;/code&gt; and &lt;code&gt;CREATE INDEX&lt;/code&gt; commands that do not have an explicit one.</source>
          <target state="translated">とき &lt;code&gt;default_tablespace&lt;/code&gt; 何もなく、空の文字列に設定されている、それは暗黙の供給 &lt;code&gt;TABLESPACE&lt;/code&gt; のための句 &lt;code&gt;CREATE TABLE&lt;/code&gt; と &lt;code&gt;CREATE INDEX&lt;/code&gt; 明示的なものを持っていないコマンドを。</target>
        </trans-unit>
        <trans-unit id="26b9fcc2ea9102afd846d23d5a3d7acf06ea6fcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extractQuery&lt;/code&gt; returns a null key in &lt;code&gt;queryKeys[]&lt;/code&gt;, the corresponding &lt;code&gt;check[]&lt;/code&gt; element is true if the indexed item contains a null key; that is, the semantics of &lt;code&gt;check[]&lt;/code&gt; are like &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt;. The &lt;code&gt;consistent&lt;/code&gt; function can examine the corresponding &lt;code&gt;nullFlags[]&lt;/code&gt; element if it needs to tell the difference between a regular value match and a null match.</source>
          <target state="translated">場合 &lt;code&gt;extractQuery&lt;/code&gt; のがでヌルキー返し &lt;code&gt;queryKeys[]&lt;/code&gt; 、対応する &lt;code&gt;check[]&lt;/code&gt; 要素は、索引項目がヌルキーが含まれている場合も同様です。つまり、 &lt;code&gt;check[]&lt;/code&gt; セマンティクスは &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; のようなものです。 &lt;code&gt;consistent&lt;/code&gt; 機能は、対応する調べることができます &lt;code&gt;nullFlags[]&lt;/code&gt; それは通常の値が一致し、nullマッチの違いを見分ける必要がある場合の要素を。</target>
        </trans-unit>
        <trans-unit id="e521d3acb4576333ab5bee010106dc1a1c2bc018" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">とき &lt;code&gt;geqo_threshold&lt;/code&gt; を超えているで説明したように、考えられて参加シーケンスは、経験則によって決定されている&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章&lt;/a&gt;。それ以外のプロセスは同じです。</target>
        </trans-unit>
        <trans-unit id="d28ef38bf9e5530ece862031c842201d36ddd349" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the directory in which log files will be created. It can be specified as an absolute path, or relative to the cluster data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;log&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターは、ログファイルが作成されるディレクトリを決定します。絶対パスまたはクラスターデータディレクトリへの相対パスとして指定できます。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。デフォルトは &lt;code&gt;log&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b3acb8f6d64e7dee8bb588e16430447375cec4a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum amount of time to use an individual log file, after which a new log file will be created. If this value is specified without units, it is taken as minutes. The default is 24 hours. Set to zero to disable time-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターは、個々のログファイルを使用する最大時間を決定します。その後、新しいログファイルが作成されます。この値を単位なしで指定した場合、分として扱われます。デフォルトは24時間です。新しいログファイルの時間ベースの作成を無効にするには、ゼロに設定します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="6ba6806c5a61bd0e7df256b20d72936b6dfff344" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum size of an individual log file. After this amount of data has been emitted into a log file, a new log file will be created. If this value is specified without units, it is taken as kilobytes. The default is 10 megabytes. Set to zero to disable size-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターは個々のログファイルの最大サイズを決定します。この量のデータがログファイルに出力されると、新しいログファイルが作成されます。この値を単位なしで指定すると、キロバイトとして扱われます。デフォルトは10メガバイトです。サイズに基づく新しいログファイルの作成を無効にするには、ゼロに設定します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="33d04df6ccc65336486b417a686759bd20169c58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターは作成されたログファイルのファイル名を設定します。値は &lt;code&gt;strftime&lt;/code&gt; パターンとして扱われるため、 &lt;code&gt;%&lt;/code&gt; - escapesを使用して時変ファイル名を指定できます。 （タイムゾーンに依存する &lt;code&gt;%&lt;/code&gt; -escapesがある場合、計算はlog_timezoneで指定されたゾーンで行われることに&lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;注意してください&lt;/a&gt;。）サポートされている &lt;code&gt;%&lt;/code&gt; -escapesは、Open Groupの&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt;仕様にリストされているものと同様です。システムの &lt;code&gt;strftime&lt;/code&gt; は直接使用されないため、プラットフォーム固有（非標準）の拡張は機能しないことに注意してください。デフォルトは &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="912a8bc2db1f94954749b8b7569bc346c69e11ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter will cause PostgreSQL to truncate (overwrite), rather than append to, any existing log file of the same name. However, truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation. When off, pre-existing files will be appended to in all cases. For example, using this setting in combination with a &lt;code&gt;log_filename&lt;/code&gt; like &lt;code&gt;postgresql-%H.log&lt;/code&gt; would result in generating twenty-four hourly log files and then cyclically overwriting them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターにより、PostgreSQLは同じ名前の既存のログファイルに追加するのではなく、トランケート（上書き）します。ただし、切り捨ては、サーバーの起動時やサイズベースのローテーションではなく、時間ベースのローテーションにより新しいファイルが開かれているときにのみ発生します。オフの場合、既存のファイルがすべての場合に追加されます。たとえば、この設定を &lt;code&gt;postgresql-%H.log&lt;/code&gt; のような &lt;code&gt;log_filename&lt;/code&gt; と組み合わせて使用​​すると、24時間ごとのログファイルが生成され、それらが周期的に上書きされます。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ac2a30741ea2b8dcb498e785772cf2a514f01258" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;on&lt;/code&gt; (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL command. When &lt;code&gt;off&lt;/code&gt; or unset, SQL commands are not committed until you explicitly issue &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;. The autocommit-off mode works by issuing an implicit &lt;code&gt;BEGIN&lt;/code&gt; for you, just before any command that is not already in a transaction block and is not itself a &lt;code&gt;BEGIN&lt;/code&gt; or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as &lt;code&gt;VACUUM&lt;/code&gt;).</source>
          <target state="translated">とき &lt;code&gt;on&lt;/code&gt; （デフォルト）、各SQLコマンドが自動的に成功した完了時にコミットしています。このモードでコミットを延期するには、 &lt;code&gt;BEGIN&lt;/code&gt; または &lt;code&gt;START TRANSACTION&lt;/code&gt; SQLコマンドを入力する必要があります。ときに &lt;code&gt;off&lt;/code&gt; または設定解除を明示的に発行するまで、SQLコマンドはコミットされません &lt;code&gt;COMMIT&lt;/code&gt; または &lt;code&gt;END&lt;/code&gt; 。自動コミットオフモードは、トランザクションブロック内になく、 &lt;code&gt;BEGIN&lt;/code&gt; または他のトランザクション制御コマンドではなく、トランザクションブロック内で実行できないコマンドの直前に、暗黙の &lt;code&gt;BEGIN&lt;/code&gt; を発行することで機能します。（ &lt;code&gt;VACUUM&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="c85a8f652ce31ff087a3b7cc628918aedc0afe36" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pg_stat_statements&lt;/code&gt; is loaded, it tracks statistics across all databases of the server. To access and manipulate these statistics, the module provides a view, &lt;code&gt;pg_stat_statements&lt;/code&gt;, and the utility functions &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; and &lt;code&gt;pg_stat_statements&lt;/code&gt;. These are not available globally but can be enabled for a specific database with &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;pg_stat_statements&lt;/code&gt; ビューがロードされ、それは、サーバーのすべてのデータベース間での統計情報を追跡します。これらの統計にアクセスして操作するために、モジュールはビュー &lt;code&gt;pg_stat_statements&lt;/code&gt; と、ユーティリティ関数 &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; および &lt;code&gt;pg_stat_statements&lt;/code&gt; を提供します。これらはグローバルには利用できませんが、 &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt; を使用して特定のデータベースに対して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="5c48693eca5bd4dca7f7f71afdfbb3d41be3ea38" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;postgres_fdw&lt;/code&gt; encounters a join between foreign tables on the same foreign server, it sends the entire join to the foreign server, unless for some reason it believes that it will be more efficient to fetch rows from each table individually, or unless the table references involved are subject to different user mappings. While sending the &lt;code&gt;JOIN&lt;/code&gt; clauses, it takes the same precautions as mentioned above for the &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">とき &lt;code&gt;postgres_fdw&lt;/code&gt; 出会いが同じ外部サーバ上で外国のテーブル間の結合、それはいくつかの理由で、個別に各テーブルから行をフェッチするために、より効率的になると考えていない限り、全体が外部サーバへの参加送信、またはテーブルの参照が関与しない限り、異なるユーザーマッピングが適用されます。 &lt;code&gt;JOIN&lt;/code&gt; 句を送信するときは、 &lt;code&gt;WHERE&lt;/code&gt; 句について前述したのと同じ予防策をとります。</target>
        </trans-unit>
        <trans-unit id="8c8497bbbc5c881081d121fdf01a588723979b05" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;program&lt;/code&gt; is specified, &lt;code&gt;command&lt;/code&gt; is executed by psql and the data passed from or to &lt;code&gt;command&lt;/code&gt; is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">ときに &lt;code&gt;program&lt;/code&gt; 指定され、 &lt;code&gt;command&lt;/code&gt; psqlのことで実行され、またはに渡されたデータ &lt;code&gt;command&lt;/code&gt; サーバとクライアント間でルーティングされます。この場合も、実行特権はサーバーではなくローカルユーザーの特権であり、SQLスーパーユーザー特権は必要ありません。</target>
        </trans-unit>
        <trans-unit id="6840df87dd751c0fab0c6f46649358f6b34c5849" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;slot_name&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, there will be no replication slot associated with the subscription. This can be used if the replication slot will be created later manually. Such subscriptions must also have both &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;create_slot&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;slot_name&lt;/code&gt; が &lt;code&gt;NONE&lt;/code&gt; に設定されている場合、サブスクリプションに関連付けられているレプリケーションスロットはありません。これは、後で複製スロットを手動で作成する場合に使用できます。このようなサブスクリプションでは、 &lt;code&gt;enabled&lt;/code&gt; と &lt;code&gt;create_slot&lt;/code&gt; の両方を &lt;code&gt;false&lt;/code&gt; に設定する必要もあります。</target>
        </trans-unit>
        <trans-unit id="d3788a4cfcb030ae27460c4ddd94f0d92885c664" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;temp_tablespaces&lt;/code&gt; is set interactively, specifying a nonexistent tablespace is an error, as is specifying a tablespace for which the user does not have &lt;code&gt;CREATE&lt;/code&gt; privilege. However, when using a previously set value, nonexistent tablespaces are ignored, as are tablespaces for which the user lacks &lt;code&gt;CREATE&lt;/code&gt; privilege. In particular, this rule applies when using a value set in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;temp_tablespaces&lt;/code&gt; がインタラクティブに設定されている場合、存在しないテーブルスペースを指定するとエラーが発生します。ユーザーが &lt;code&gt;CREATE&lt;/code&gt; 権限を持っていないテーブルスペースを指定する場合も同様です。ただし、以前に設定された値を使用する場合、存在しないテーブルスペースは無視され、ユーザーが &lt;code&gt;CREATE&lt;/code&gt; 権限を持たないテーブルスペースも無視されます。特に、このルールは &lt;code&gt;postgresql.conf&lt;/code&gt; で設定された値を使用するときに適用されます。</target>
        </trans-unit>
        <trans-unit id="9c068d98cbad8e288e90e4c1dd972e7c59abbaa3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;tgconstraint&lt;/code&gt; is nonzero, &lt;code&gt;tgconstrrelid&lt;/code&gt;, &lt;code&gt;tgconstrindid&lt;/code&gt;, &lt;code&gt;tgdeferrable&lt;/code&gt;, and &lt;code&gt;tginitdeferred&lt;/code&gt; are largely redundant with the referenced &lt;code&gt;pg_constraint&lt;/code&gt; entry. However, it is possible for a non-deferrable trigger to be associated with a deferrable constraint: foreign key constraints can have some deferrable and some non-deferrable triggers.</source>
          <target state="translated">&lt;code&gt;tgconstraint&lt;/code&gt; がゼロ以外の場合、 &lt;code&gt;tgconstrrelid&lt;/code&gt; 、 &lt;code&gt;tgconstrindid&lt;/code&gt; 、 &lt;code&gt;tgdeferrable&lt;/code&gt; 、および &lt;code&gt;tginitdeferred&lt;/code&gt; は、参照される &lt;code&gt;pg_constraint&lt;/code&gt; エントリで大部分は冗長です。ただし、延期できないトリガーを延期可能な制約に関連付けることは可能です。外部キー制約には、一部の延期可能なトリガーと一部の延期不可能なトリガーを含めることができます。</target>
        </trans-unit>
        <trans-unit id="19d575b88117ece85c7a87c6ea7ead5a6532b19a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trust&lt;/code&gt; authentication is specified, PostgreSQL assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the &lt;code&gt;database&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</source>
          <target state="translated">ときに &lt;code&gt;trust&lt;/code&gt; 認証が指定され、PostgreSQLは、サーバーに接続できる誰もが、彼らが（でもスーパーユーザ名）を指定するどんなデータベースユーザー名でデータベースにアクセスすることを許可されている前提としています。もちろん、 &lt;code&gt;database&lt;/code&gt; と &lt;code&gt;user&lt;/code&gt; 列で行われた制限は引き続き適用されます。この方法は、サーバーへの接続に適切なオペレーティングシステムレベルの保護がある場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="966280f7c40171987c3cbc983291b38e3a71017e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_remote_estimate&lt;/code&gt; is true, &lt;code&gt;postgres_fdw&lt;/code&gt; obtains row count and cost estimates from the remote server and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. When &lt;code&gt;use_remote_estimate&lt;/code&gt; is false, &lt;code&gt;postgres_fdw&lt;/code&gt; performs local row count and cost estimation and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. This local estimation is unlikely to be very accurate unless local copies of the remote table's statistics are available. Running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the foreign table is the way to update the local statistics; this will perform a scan of the remote table and then calculate and store statistics just as though the table were local. Keeping local statistics can be a useful way to reduce per-query planning overhead for a remote table &amp;mdash; but if the remote table is frequently updated, the local statistics will soon be obsolete.</source>
          <target state="translated">とき &lt;code&gt;use_remote_estimate&lt;/code&gt; は真、ある &lt;code&gt;postgres_fdw&lt;/code&gt; リモートサーバから取得した行数と費用の見積もり、その後追加 &lt;code&gt;fdw_startup_cost&lt;/code&gt; と &lt;code&gt;fdw_tuple_cost&lt;/code&gt; をコストの見積もりに。 &lt;code&gt;use_remote_estimate&lt;/code&gt; がfalseの場合、 &lt;code&gt;postgres_fdw&lt;/code&gt; はローカル行カウントとコスト見積もりを &lt;code&gt;fdw_tuple_cost&lt;/code&gt; し、 &lt;code&gt;fdw_startup_cost&lt;/code&gt; とfdw_tuple_costをコスト見積もりに追加します。このローカル推定は、リモートテーブルの統計のローカルコピーが利用可能でない限り、非常に正確である可能性は低いです。&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZEの&lt;/a&gt;実行外部テーブルでは、ローカル統計を更新する方法です。これにより、リモートテーブルのスキャンが実行され、テーブルがローカルであるかのように統計が計算および保存されます。ローカル統計を保持することは、リモートテーブルのクエリごとの計画オーバーヘッドを削減するのに役立つ方法です。ただし、リモートテーブルが頻繁に更新される場合、ローカル統計はすぐに廃止されます。</target>
        </trans-unit>
        <trans-unit id="f04447293cfe5a43fce5bd6f976cc350e753a232" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; some SQL commands are optimized to avoid WAL logging, as described in &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;. If archiving or streaming replication were turned on during execution of one of these statements, WAL would not contain enough information for archive recovery. (Crash recovery is unaffected.) For this reason, &lt;code&gt;wal_level&lt;/code&gt; can only be changed at server start. However, &lt;code&gt;archive_command&lt;/code&gt; can be changed with a configuration file reload. If you wish to temporarily stop archiving, one way to do it is to set &lt;code&gt;archive_command&lt;/code&gt; to the empty string (&lt;code&gt;''&lt;/code&gt;). This will cause WAL files to accumulate in &lt;code&gt;pg_wal/&lt;/code&gt; until a working &lt;code&gt;archive_command&lt;/code&gt; is re-established.</source>
          <target state="translated">&lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;セクション14.4.7で&lt;/a&gt;説明されているように、 &lt;code&gt;wal_level&lt;/code&gt; が &lt;code&gt;minimal&lt;/code&gt; 場合、WALロギングを回避するために一部のSQLコマンドが最適化されます。これらのステートメントのいずれかの実行中にアーカイブまたはストリーミングレプリケーションがオンになっている場合、WALにはアーカイブのリカバリに十分な情報が含まれていません。 （クラッシュリカバリは影響を受けません。）このため、 &lt;code&gt;wal_level&lt;/code&gt; はサーバーの起動時にのみ変更できます。ただし、 &lt;code&gt;archive_command&lt;/code&gt; は、構成ファイルのリロードで変更できます。一時的にアーカイブを停止したい場合、1つの方法は、 &lt;code&gt;archive_command&lt;/code&gt; を空の文字列（ &lt;code&gt;''&lt;/code&gt; ）に設定することです。これにより、WALファイルが動作するまで &lt;code&gt;pg_wal/&lt;/code&gt; に蓄積されます。 &lt;code&gt;archive_command&lt;/code&gt; が再確立されました。</target>
        </trans-unit>
        <trans-unit id="bc54463c4a91042c587b320f65f275bd091c2193" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed, there is generally a greatly increased chance of detecting single-bit errors, since strict binary equality is tested, and the indexed attributes within the heap are tested.</source>
          <target state="translated">場合&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;検証が行われ、そこ厳密なバイナリ等式が試験されているので、一般的にシングルビットエラーを検出大幅に増加チャンスであり、ヒープ内のインデックス付き属性がテストされます。</target>
        </trans-unit>
        <trans-unit id="668fe437dfa47692f950b23dc7849bfb4637dcda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; is greater than one, the returned numbers should be averages expected for any one scan of the index.</source>
          <target state="translated">とき&lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt; 1より大きい場合、返された数字は平均値は、インデックスのいずれかのスキャンのために期待されなければなりません。</target>
        </trans-unit>
        <trans-unit id="36ef5495d24b79877e9b0ce1d70303e79e6501c2" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned for &lt;code&gt;NULL&lt;/code&gt; inputs. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">ときに&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;正の場合、ゼロ行が返され&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;より大きくなる&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;。逆に、&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;が負の場合、&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;が&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;より小さい場合、ゼロ行が返されます。 &lt;code&gt;NULL&lt;/code&gt; 入力の場合、ゼロ行も返されます。&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;がゼロになるのはエラーです。次にいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="4d1d230678ad6398ea1b726af7844a229cc8f13e" translate="yes" xml:space="preserve">
          <source>When Can Parallel Query Be Used?</source>
          <target state="translated">パラレルクエリはどのような場合に利用できますか?</target>
        </trans-unit>
        <trans-unit id="8c5a55e381f3b4b99fc5f9dc03b78c3fc758ed84" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">GSSAPIがKerberosを使用する場合、 &lt;code&gt;servicename/hostname@realm&lt;/code&gt; という形式の標準プリンシパルを使用します。 PostgreSQLサーバーは、サーバーが使用するキータブに含まれるすべてのプリンシパルを受け入れますが、 &lt;code&gt;krbsrvname&lt;/code&gt; 接続パラメーターを使用してクライアントから接続するときは、正しいプリンシパルの詳細を指定するように注意する必要があります。 （も参照&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;セクション33.1.2を&lt;/a&gt;。）インストール時のデフォルトは、デフォルトから変更することができます &lt;code&gt;postgres&lt;/code&gt; の使用してビルド時 &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; 。ほとんどの環境では、このパラメーターを変更する必要はありません。一部のKerberos実装では、サービス名を大文字にする必要があるMicrosoft Active Directory（ &lt;code&gt;POSTGRES&lt;/code&gt; ）など、別のサービス名が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="cb176371849755f8e3fddd6c5c7996731ba8719c" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_archive_delay&lt;/code&gt; applies when WAL data is being read from WAL archive (and is therefore not current). If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;セクション26.5.2で&lt;/a&gt;説明されているように、ホットスタンバイがアクティブな場合、このパラメータは、適用されるWALエントリと競合するスタンバイクエリをキャンセルする前にスタンバイサーバーが待機する時間を決定します。 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; は、WALデータがWALアーカイブから読み取られるときに適用されます（したがって、最新ではありません）。この値が単位なしで指定されている場合、ミリ秒と見なされます。デフォルトは30秒です。値が-1の場合、スタンバイは、競合するクエリが完了するまで永久に待機します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="0ec8116773102304d6d7b1390f1e98f30e3bb2ff" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; applies when WAL data is being received via streaming replication. If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;セクション26.5.2で&lt;/a&gt;説明されているように、ホットスタンバイがアクティブな場合、このパラメータは、適用されるWALエントリと競合するスタンバイクエリをキャンセルする前にスタンバイサーバーが待機する時間を決定します。 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; は、WALデータがストリーミングレプリケーションを介して受信されている場合に適用されます。この値が単位なしで指定されている場合、ミリ秒と見なされます。デフォルトは30秒です。値が-1の場合、スタンバイは、競合するクエリが完了するまで永久に待機します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="0f0d78fac0ffb73c1a9e09c7cc14d11764cc7556" translate="yes" xml:space="preserve">
          <source>When PostgreSQL maps SQL data values to XML (as in &lt;code&gt;xmlelement&lt;/code&gt;), or XML to SQL (as in the output columns of &lt;code&gt;xmltable&lt;/code&gt;), except for a few cases treated specially, PostgreSQL simply assumes that the XML data type's XPath 1.0 string form will be valid as the text-input form of the SQL datatype, and conversely. This rule has the virtue of simplicity while producing, for many data types, results similar to the mappings specified in the standard.</source>
          <target state="translated">PostgreSQLがSQLデータ値をXMLにマップするとき（ &lt;code&gt;xmlelement&lt;/code&gt; のように）、またはXMLをSQLにマップするとき（xmltableの出力列の &lt;code&gt;xmltable&lt;/code&gt; ）、特別に扱われるいくつかのケースを除いて、PostgreSQLは単にXMLデータ型のXPath 1.0文字列形式がSQLデータ型のテキスト入力形式として有効であり、逆の場合も同様です。このルールには、多くのデータ型について、標準で指定されているマッピングと同様の結果を生成する一方で、単純さという利点があります。</target>
        </trans-unit>
        <trans-unit id="4181958cdfd24c8fd1ab7073c5b2ff83fa0a559f" translate="yes" xml:space="preserve">
          <source>When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name that the client sends in the &lt;code&gt;client-first-message&lt;/code&gt;. The user name that was already sent in the startup message is used instead. PostgreSQL supports multiple character encodings, while SCRAM dictates UTF-8 to be used for the user name, so it might be impossible to represent the PostgreSQL user name in UTF-8.</source>
          <target state="translated">PostgreSQLでSCRAM-SHA-256が使用されている場合、サーバーは、 &lt;code&gt;client-first-message&lt;/code&gt; 送信するユーザー名を無視します。代わりに、起動メッセージで既に送信されたユーザー名が使用されます。 PostgreSQLは複数の文字エンコーディングをサポートしていますが、SCRAMはユーザー名にUTF-8を使用するよう指示しているため、PostgreSQLユーザー名をUTF-8で表すことができない場合があります。</target>
        </trans-unit>
        <trans-unit id="4cd20efcfa95fdaaa37532258734ec47bc3eda12" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_list&lt;/code&gt;, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句が存在する場合、基本的には、ターゲットテーブルが &lt;code&gt;from_list&lt;/code&gt; に記述されているテーブルに結合され、結合の各出力行がターゲットテーブルの更新操作を表します。 &lt;code&gt;FROM&lt;/code&gt; を使用する場合は、変更する行ごとに最大1つの出力行が結合で生成されるようにする必要があります。言い換えると、ターゲット行は他のテーブルの複数の行に結合してはなりません。含まれている場合、ターゲット行の更新に使用されるのは1つの結合行だけですが、どちらが使用されるかは簡単には予測できません。</target>
        </trans-unit>
        <trans-unit id="0a80d67f6221f67e848e31748e5e7aded5d6746e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; item contains &lt;code&gt;LATERAL&lt;/code&gt; cross-references, evaluation proceeds as follows: for each row of the &lt;code&gt;FROM&lt;/code&gt; item providing the cross-referenced column(s), or set of rows of multiple &lt;code&gt;FROM&lt;/code&gt; items providing the columns, the &lt;code&gt;LATERAL&lt;/code&gt; item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; アイテムに &lt;code&gt;LATERAL&lt;/code&gt; 相互参照が含まれている場合、評価は次のように行われます。相互参照される列を提供する &lt;code&gt;FROM&lt;/code&gt; アイテムの各行、または列を提供する複数の &lt;code&gt;FROM&lt;/code&gt; アイテムの行のセットに対して、 &lt;code&gt;LATERAL&lt;/code&gt; アイテムはその行または行セットの列の値。結果の行は、通常どおり、計算元の行と結合されます。これは、列ソーステーブルの行または行のセットごとに繰り返されます。</target>
        </trans-unit>
        <trans-unit id="9131be6a2fce2c0e060d15eb98b8c743d3328da0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint is not deferrable, PostgreSQL checks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint as &lt;code&gt;DEFERRABLE&lt;/code&gt; but not deferred (i.e., &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;). Be aware that this can be significantly slower than immediate uniqueness checking.</source>
          <target state="translated">場合 &lt;code&gt;UNIQUE&lt;/code&gt; または &lt;code&gt;PRIMARY KEY&lt;/code&gt; 行が挿入または変更されるたびに、制約が直ちに、一意性のためのPostgreSQLのチェック遅延可能ではありません。 SQL標準では、一意性はステートメントの最後にのみ適用する必要があるとしています。これにより、たとえば、単一のコマンドが複数のキー値を更新するときに違いが生じます。標準に準拠した動作を実現するには、制約を &lt;code&gt;DEFERRABLE&lt;/code&gt; として宣言しますが、据え置きしません（つまり、 &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; ）。これは、即時の一意性チェックよりも大幅に遅くなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d7633f6759da586e80f43626088973d06a48ea56" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;pg_cast&lt;/code&gt; entry has different source and target types and a function that takes more than one argument, it represents converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">場合 &lt;code&gt;pg_cast&lt;/code&gt; のエントリが異なるソースおよびターゲット・タイプと複数の引数を取る機能を有し、それは、ある型から別の型に変換し、単一のステップで長さの強制を適用表します。そのようなエントリが利用できない場合、型修飾子を使用する型への強制には2つのステップが含まれます。1つはデータ型間の変換で、もう1つは修飾子を適用します。</target>
        </trans-unit>
        <trans-unit id="88f0e69da747f3bb16cb53c469a234fbf587434e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;timestamp with time zone&lt;/code&gt; value is output, it is always converted from UTC to the current &lt;code&gt;timezone&lt;/code&gt; zone, and displayed as local time in that zone. To see the time in another time zone, either change &lt;code&gt;timezone&lt;/code&gt; or use the &lt;code&gt;AT TIME ZONE&lt;/code&gt; construct (see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;Section 9.9.3&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;timestamp with time zone&lt;/code&gt; 値付きのタイムスタンプが出力されると、常にUTCから現在の &lt;code&gt;timezone&lt;/code&gt; ゾーンに変換され、そのゾーンの現地時間として表示されます。別のタイムゾーンの時刻を表示するには、 &lt;code&gt;timezone&lt;/code&gt; 変更するか、 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 構文を使用します（&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;セクション9.9.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="27629e4b11182354bc4cc1d2c2660d2bd8a7f20c" translate="yes" xml:space="preserve">
          <source>When a cast has different source and target types and a function that takes more than one argument, it supports converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two cast steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">キャストが異なるソース型とターゲット型を持ち、複数の引数を取る関数を持つ場合、1つの型から別の型への変換と長さの強制適用を1つのステップでサポートしています。そのようなエントリがない場合、型修飾子を使用する型への強制は、データ型間の変換と修飾子の適用のための2つのキャスト・ステップを必要とします。</target>
        </trans-unit>
        <trans-unit id="49788d41c6b6cbdafb9c157dde66cc21e7ad5c8d" translate="yes" xml:space="preserve">
          <source>When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type).</source>
          <target state="translated">キャストが既知の型の値式に適用される場合、それは実行時の型変換を表します。キャストは、適切な型変換操作が定義されている場合にのみ成功します。&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;セクション4.1.2.7に&lt;/a&gt;示すように、これは定数を使用したキャストの使用とは微妙に異なることに注意してください。修飾されていない文字列リテラルに適用されたキャストは、リテラル定数値への型の初期割り当てを表すため、任意の型で成功します（文字列リテラルの内容がデータ型の許容可能な入力構文である場合）。</target>
        </trans-unit>
        <trans-unit id="cf5e183edf65b04ea968b8cbec71c03d82d34814" translate="yes" xml:space="preserve">
          <source>When a character string value is cast to or from type &lt;code&gt;xml&lt;/code&gt; without going through &lt;code&gt;XMLPARSE&lt;/code&gt; or &lt;code&gt;XMLSERIALIZE&lt;/code&gt;, respectively, the choice of &lt;code&gt;DOCUMENT&lt;/code&gt; versus &lt;code&gt;CONTENT&lt;/code&gt; is determined by the &amp;ldquo;XML option&amp;rdquo;  session configuration parameter, which can be set using the standard command:</source>
          <target state="translated">文字列値が &lt;code&gt;XMLPARSE&lt;/code&gt; または &lt;code&gt;XMLSERIALIZE&lt;/code&gt; を経由せずに &lt;code&gt;xml&lt;/code&gt; タイプとの間でそれぞれキャストされる場合、 &lt;code&gt;DOCUMENT&lt;/code&gt; と &lt;code&gt;CONTENT&lt;/code&gt; の選択は、標準コマンドを使用して設定できる「XMLオプション」セッション構成パラメーターによって決定されます。</target>
        </trans-unit>
        <trans-unit id="42fc13aa34e4743bab6d0037fe542f1b13a66649" translate="yes" xml:space="preserve">
          <source>When a column is added with &lt;code&gt;ADD COLUMN&lt;/code&gt; and a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If no &lt;code&gt;DEFAULT&lt;/code&gt; is specified, NULL is used. In neither case is a rewrite of the table required.</source>
          <target state="translated">列が &lt;code&gt;ADD COLUMN&lt;/code&gt; で追加され、不揮発性の &lt;code&gt;DEFAULT&lt;/code&gt; が指定されている場合、デフォルトはステートメントの実行時に評価され、結果はテーブルのメタデータに格納されます。その値は、既存のすべての行の列に使用されます。 &lt;code&gt;DEFAULT&lt;/code&gt; が指定されていない場合、NULLが使用されます。どちらの場合も、テーブルの書き換えは必要ありません。</target>
        </trans-unit>
        <trans-unit id="4617ca746c05eccbac9e1250d759f5bd44319fcd" translate="yes" xml:space="preserve">
          <source>When a conflicting query is short, it's typically desirable to allow it to complete by delaying WAL application for a little bit; but a long delay in WAL application is usually not desirable. So the cancel mechanism has parameters, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;, that define the maximum allowed delay in WAL application. Conflicting queries will be canceled once it has taken longer than the relevant delay setting to apply any newly-received WAL data. There are two parameters so that different delay values can be specified for the case of reading WAL data from an archive (i.e., initial recovery from a base backup or &amp;ldquo;catching up&amp;rdquo; a standby server that has fallen far behind) versus reading WAL data via streaming replication.</source>
          <target state="translated">競合するクエリが短い場合は、通常、WALアプリケーションを少し遅らせることでクエリを完了できるようにすることが望ましいです。しかし、WALアプリケーションの長い遅延は通常望ましくありません。したがって、キャンセルメカニズムには、WALアプリケーションで許可される最大遅延を定義するパラメーター&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delayが&lt;/a&gt;あります。新しく受信したWALデータを適用するために関連する遅延設定よりも長くかかると、競合するクエリはキャンセルされます。 2つのパラメーターがあるため、アーカイブからWALデータを読み取る場合（つまり、ベースバックアップからの最初のリカバリ、または大幅に遅れているスタンバイサーバーの「キャッチアップ」）と、WALデータを読み取る場合に異なる遅延値を指定できます。ストリーミングレプリケーション。</target>
        </trans-unit>
        <trans-unit id="fe9942af75508e96643f23b2bb2b19c3cb29a5d8" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind anonymously (since &lt;code&gt;ldapbinddn&lt;/code&gt; was not specified) to the LDAP server, perform a search for &lt;code&gt;(uid=someuser)&lt;/code&gt; under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</source>
          <target state="translated">データベースユーザー &lt;code&gt;someuser&lt;/code&gt; としてデータベースサーバーへの接続が要求されると、PostgreSQLはLDAPサーバーに（ &lt;code&gt;ldapbinddn&lt;/code&gt; が指定されていないため）匿名でバインドしようとし、指定されたベースDNで &lt;code&gt;(uid=someuser)&lt;/code&gt; を検索します。エントリが見つかった場合は、見つかった情報とクライアントから提供されたパスワードを使用してバインドを試みます。2番目の接続が成功すると、データベースアクセスが許可されます。</target>
        </trans-unit>
        <trans-unit id="48781ec5a4acd4a7481b8c8839149e95712b5009" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind to the LDAP server using the DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; and the password provided by the client. If that connection succeeds, the database access is granted.</source>
          <target state="translated">データベースユーザー &lt;code&gt;someuser&lt;/code&gt; としてデータベースサーバーへの接続が要求されると、PostgreSQLはDN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; およびクライアントから提供されたパスワードを使用してLDAPサーバーにバインドしようとします。その接続が成功すると、データベースアクセスが許可されます。</target>
        </trans-unit>
        <trans-unit id="c225436eedb2c4fcd16a275b1ddffc50962ab028" translate="yes" xml:space="preserve">
          <source>When a constant's value has been ignored for purposes of matching the query to other queries, the constant is replaced by a parameter symbol, such as &lt;code&gt;$1&lt;/code&gt;, in the &lt;code&gt;pg_stat_statements&lt;/code&gt; display. The rest of the query text is that of the first query that had the particular &lt;code&gt;queryid&lt;/code&gt; hash value associated with the &lt;code&gt;pg_stat_statements&lt;/code&gt; entry.</source>
          <target state="translated">クエリを他のクエリと照合する目的で定数の値が無視された場合、 &lt;code&gt;pg_stat_statements&lt;/code&gt; 表示では、定数は &lt;code&gt;$1&lt;/code&gt; などのパラメータシンボルに置き換えられます。クエリテキストの残りの部分は、 &lt;code&gt;pg_stat_statements&lt;/code&gt; エントリに関連付けられた特定のクエリ &lt;code&gt;queryid&lt;/code&gt; ハッシュ値を持つ最初のクエリのテキストです。</target>
        </trans-unit>
        <trans-unit id="ecb409e448668771f827d8fbf0e7974aed415eec" translate="yes" xml:space="preserve">
          <source>When a data-only dump is chosen and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_dump emits commands to disable triggers on user tables before inserting the data, and then commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">データのみのダンプが選択され、オプション &lt;code&gt;--disable-triggers&lt;/code&gt; が使用されている場合、pg_dumpは、データを挿入する前にユーザーテーブルのトリガーを無効にするコマンドを発行し、データが挿入された後にトリガーを再度有効にするコマンドを発行します。復元が途中で停止した場合、システムカタログが誤った状態のままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2bb4292f30931b17f0bc254f84df53dc22a84368" translate="yes" xml:space="preserve">
          <source>When a direct database connection is specified using the &lt;code&gt;-d&lt;/code&gt; option, pg_restore internally executes SQL statements. If you have problems running pg_restore, make sure you are able to select information from the database using, for example, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; オプションを使用して直接データベース接続が指定されている場合、pg_restoreは内部でSQLステートメントを実行します。pg_restoreの実行に問題がある場合は、たとえば&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を使用してデータベースから情報を選択できることを確認してください。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="70b0a551bd1d82e60af1e6e20328604ac27e04a2" translate="yes" xml:space="preserve">
          <source>When a domain has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested in alphabetical order by name. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">ドメインに複数の &lt;code&gt;CHECK&lt;/code&gt; 制約がある場合、それらは名前のアルファベット順にテストされます。（PostgreSQLバージョン9.5より前は、 &lt;code&gt;CHECK&lt;/code&gt; 制約の特定の起動順序を尊重していませんでした。）</target>
        </trans-unit>
        <trans-unit id="82ae6b8670e18414fb24938a0f2cc8a6d1070788" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the output which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句の関数の末尾に &lt;code&gt;WITH ORDINALITY&lt;/code&gt; を付けると、 &lt;code&gt;bigint&lt;/code&gt; 列が出力に追加されます。この列は、1から始まり、関数の出力の行ごとに1ずつ増加します。これは、 &lt;code&gt;unnest()&lt;/code&gt; などのセットを返す関数の場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="cc5d8fb3f4d70c3c0f1dea589130a29e4dae23e6" translate="yes" xml:space="preserve">
          <source>When a heap entry is to be deleted (by &lt;code&gt;VACUUM&lt;/code&gt;), all its index entries must be removed first.</source>
          <target state="translated">ヒープエントリを（ &lt;code&gt;VACUUM&lt;/code&gt; によって）削除する場合、そのすべてのインデックスエントリを最初に削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="00af93fe8454ff02af34b94554824196fc81e8fc" translate="yes" xml:space="preserve">
          <source>When a locking clause appears at the top level of a &lt;code&gt;SELECT&lt;/code&gt; query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a &lt;code&gt;LIMIT&lt;/code&gt; is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by &lt;code&gt;OFFSET&lt;/code&gt; will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.</source>
          <target state="translated">ロック句が &lt;code&gt;SELECT&lt;/code&gt; クエリの最上位にある場合、ロックされる行は、クエリによって返される行とまったく同じです。結合クエリの場合、ロックされる行は、返される結合行に寄与する行です。また、スナップショット後に更新され、クエリ条件を満たさなくなった場合は返されませんが、クエリスナップショットの時点でクエリ条件を満たす行はロックされます。場合 &lt;code&gt;LIMIT&lt;/code&gt; が使用されている十分な行が制限を満たすために戻ってきた（しかし、行がでスキップなお、一度、ロックが停止し &lt;code&gt;OFFSET&lt;/code&gt; ロックされます）。同様に、ロッキング句がカーソルのクエリで使用される場合、カーソルによって実際にフェッチまたはステップオーバーされた行のみがロックされます。</target>
        </trans-unit>
        <trans-unit id="ef95b8a60ebd804a0c28a2e00cab45258a43a0d6" translate="yes" xml:space="preserve">
          <source>When a locking clause appears in a sub-&lt;code&gt;SELECT&lt;/code&gt;, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,</source>
          <target state="translated">ロッキング句がサブ &lt;code&gt;SELECT&lt;/code&gt; にある場合、ロックされる行は、サブクエリによって外部クエリに返される行です。サブクエリの実行を最適化するために外部クエリの条件が使用される可能性があるため、これには、サブクエリの検査だけが示唆するよりも少ない行が含まれる場合があります。例えば、</target>
        </trans-unit>
        <trans-unit id="bfc7a3d97debfcf5d558fe06d1809283c70c4abd" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;GRANT&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options. The &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">オブジェクト試行の場合は非所有者 &lt;code&gt;GRANT&lt;/code&gt; のオブジェクトに対する権限をユーザーがオブジェクト上の一切の権限を持っていない場合、コマンドは完全に失敗します。いくつかの特権が利用可能である限り、コマンドは続行されますが、ユーザーが付与オプションを持っている特権のみが付与されます。 &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; なしグラントオプションが開催されていない場合は特に、コマンドで指定された権限のいずれかのためのグラントオプションが開催されていない場合は、他の形態は、警告を発行しますながらフォームは、警告メッセージを発行します。 （原則として、これらのステートメントはオブジェクトの所有者にも適用されますが、所有者は常にすべての付与オプションを保持しているものとして扱われるため、ケースが発生することはありません。）</target>
        </trans-unit>
        <trans-unit id="89d5be09265c0f260930da66e4dbc18e249c5a52" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;REVOKE&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options. The &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">オブジェクトの非所有者がオブジェクトに対する &lt;code&gt;REVOKE&lt;/code&gt; を取り消そうとすると、ユーザーがオブジェクトに対する権限をまったく持っていない場合、コマンドは完全に失敗します。いくつかの特権が利用可能である限り、コマンドは続行しますが、ユーザーが付与オプションを持っている特権のみを取り消します。 &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; 全くグラントオプションが開催されていない場合は、具体的コマンドで指定された権限のいずれかのためのグラントオプションが開催されていない場合は、他の形態は、警告を発行しますながらフォームは、警告メッセージを発行します。 （原則として、これらのステートメントはオブジェクトの所有者にも適用されますが、所有者は常にすべての付与オプションを保持しているものとして扱われるため、ケースが発生することはありません。）</target>
        </trans-unit>
        <trans-unit id="81fc5d42be5663314dba2e99345c9e9036540107" translate="yes" xml:space="preserve">
          <source>When a password is specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, this parameter determines the algorithm to use to encrypt the password. The default value is &lt;code&gt;md5&lt;/code&gt;, which stores the password as an MD5 hash (&lt;code&gt;on&lt;/code&gt; is also accepted, as alias for &lt;code&gt;md5&lt;/code&gt;). Setting this parameter to &lt;code&gt;scram-sha-256&lt;/code&gt; will encrypt the password with SCRAM-SHA-256.</source>
          <target state="translated">&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;または&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;でパスワードが指定されている場合、このパラメーターは、パスワードの暗号化に使用するアルゴリズムを決定します。デフォルト値は &lt;code&gt;md5&lt;/code&gt; で、MD5ハッシュとしてパスワードを保存します（ &lt;code&gt;md5&lt;/code&gt; のエイリアスとして &lt;code&gt;on&lt;/code&gt; も受け入れられます）。このパラメーターを &lt;code&gt;scram-sha-256&lt;/code&gt; に設定すると、SCRAM-SHA-256でパスワードが暗号化されます。</target>
        </trans-unit>
        <trans-unit id="a045ad36bdf763a5564eafc812cd1f70e538ac02" translate="yes" xml:space="preserve">
          <source>When a query involves multiple window functions, it is possible to write out each one with a separate &lt;code&gt;OVER&lt;/code&gt; clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a &lt;code&gt;WINDOW&lt;/code&gt; clause and then referenced in &lt;code&gt;OVER&lt;/code&gt;. For example:</source>
          <target state="translated">クエリに複数のウィンドウ関数が含まれる場合、それぞれを個別の &lt;code&gt;OVER&lt;/code&gt; 句で書き出すことが可能ですが、これは重複しており、複数の関数で同じウィンドウ処理動作が必要な場合はエラーが発生しやすくなります。代わりに、各ウィンドウ動作を &lt;code&gt;WINDOW&lt;/code&gt; 句で名前を付け、 &lt;code&gt;OVER&lt;/code&gt; で参照できます。例えば：</target>
        </trans-unit>
        <trans-unit id="6b051ff28261e8c6e18971fa6cb50736f0add4f7" translate="yes" xml:space="preserve">
          <source>When a query only involves two or three tables, there aren't many join orders to worry about. But the number of possible join orders grows exponentially as the number of tables expands. Beyond ten or so input tables it's no longer practical to do an exhaustive search of all the possibilities, and even for six or seven tables planning might take an annoyingly long time. When there are too many input tables, the PostgreSQL planner will switch from exhaustive search to a &lt;em&gt;genetic&lt;/em&gt; probabilistic search through a limited number of possibilities. (The switch-over threshold is set by the &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; run-time parameter.) The genetic search takes less time, but it won't necessarily find the best possible plan.</source>
          <target state="translated">クエリに2つまたは3つのテーブルのみが含まれる場合、心配する必要のある結合順序はあまりありません。ただし、テーブルの数が増えると、可能な結合順序の数は指数関数的に増加します。 10個程度の入力テーブルを超えると、すべての可能性を網羅的に検索することは現実的ではなくなり、6個または7個のテーブルでも、計画に厄介な時間がかかる場合があります。入力テーブルが多すぎる場合、PostgreSQLプランナーは、限られた数の可能性を介して、網羅的検索から&lt;em&gt;遺伝的&lt;/em&gt;確率検索に切り替えます。 （切り替えしきい値は、&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;実行時パラメーターによって設定されます。）遺伝子検索にかかる時間は短くなりますが、必ずしも最良の計画が見つかるとは限りません。</target>
        </trans-unit>
        <trans-unit id="52a265f5fc62979fde73128f8ace62054feb152e" translate="yes" xml:space="preserve">
          <source>When a schema-qualified operator name is used in the &lt;code&gt;OPERATOR&lt;/code&gt; syntax, as for example in:</source>
          <target state="translated">以下のように、スキーマ修飾演算子名が &lt;code&gt;OPERATOR&lt;/code&gt; 構文で使用される場合。</target>
        </trans-unit>
        <trans-unit id="07d688620d10b715a262026cbd31ef1489999e7d" translate="yes" xml:space="preserve">
          <source>When a sequential scan and sort is used, a temporary sort file is also created, so that the peak temporary space requirement is as much as double the table size, plus the index sizes. This method is often faster than the index scan method, but if the disk space requirement is intolerable, you can disable this choice by temporarily setting &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">順次スキャンとソートを使用すると、一時ソートファイルも作成されるため、ピーク一時スペース要件は、テーブルサイズとインデックスサイズの2倍になります。多くの場合、この方法はインデックススキャン方式よりも高速ですが、ディスク容量の要件が許容できない場合は、一時的に&lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt;を &lt;code&gt;off&lt;/code&gt; に設定することで、この選択を無効にできます。</target>
        </trans-unit>
        <trans-unit id="f0770f15e6049d266a12140bc7f33a5609b9c35a" translate="yes" xml:space="preserve">
          <source>When a single element is pushed onto either the beginning or end of a one-dimensional array, the result is an array with the same lower bound subscript as the array operand. For example:</source>
          <target state="translated">1つの要素が1次元配列の先頭または末尾のいずれかに押されると、結果は配列オペランドと同じ下界の添え字を持つ配列になります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f80cd58c4f6747cdabdfc227aecb194029c6f93d" translate="yes" xml:space="preserve">
          <source>When a standby first attaches to the primary, it will not yet be properly synchronized. This is described as &lt;code&gt;catchup&lt;/code&gt; mode. Once the lag between standby and primary reaches zero for the first time we move to real-time &lt;code&gt;streaming&lt;/code&gt; state. The catch-up duration may be long immediately after the standby has been created. If the standby is shut down, then the catch-up period will increase according to the length of time the standby has been down. The standby is only able to become a synchronous standby once it has reached &lt;code&gt;streaming&lt;/code&gt; state. This state can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">スタンバイが最初にプライマリに接続するとき、まだ適切に同期されていません。これは &lt;code&gt;catchup&lt;/code&gt; モードと呼ばれます。スタンバイとプライマリの間のラグが初めてゼロに達すると、リアルタイム &lt;code&gt;streaming&lt;/code&gt; 状態に移行します。スタンバイが作成された直後のキャッチアップ期間は長くなる可能性があります。スタンバイがシャットダウンされている場合、キャッチアップ期間は、スタンバイがダウンしていた時間の長さに応じて長くなります。スタンバイは、 &lt;code&gt;streaming&lt;/code&gt; 状態に達した後でのみ同期スタンバイになることができます。この状態は、 &lt;code&gt;pg_stat_replication&lt;/code&gt; ビューを使用して表示できます。</target>
        </trans-unit>
        <trans-unit id="ad5c61ffccbfb5effcfe0a2c8686ec7385263d29" translate="yes" xml:space="preserve">
          <source>When a subscription is dropped and recreated, the synchronization information is lost. This means that the data has to be resynchronized afterwards.</source>
          <target state="translated">サブスクリプションを削除して再作成すると、同期情報が失われます。つまり、後からデータを再同期する必要があります。</target>
        </trans-unit>
        <trans-unit id="b46a9ad23681ef38bc14d25148f1365c37846a4e" translate="yes" xml:space="preserve">
          <source>When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate &lt;code&gt;CHECK&lt;/code&gt; constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.</source>
          <target state="translated">テーブルにデフォルトパーティションがある場合、新しいパーティションを定義すると、デフォルトパーティションのパーティション制約が変更されます。デフォルトのパーティションには、新しいパーティションに移動する必要がある行を含めることはできません。行が存在しないことを確認するためにスキャンされます。このスキャンは、新しいパーティションのスキャンと同様に、適切な &lt;code&gt;CHECK&lt;/code&gt; 制約が存在する場合は回避できます。また、新しいパーティションのスキャンと同様に、デフォルトのパーティションが外部テーブルの場合は常にスキップされます。</target>
        </trans-unit>
        <trans-unit id="152306185769e157a52b3f97557867eb083f11a7" translate="yes" xml:space="preserve">
          <source>When a table has an existing &lt;code&gt;DEFAULT&lt;/code&gt; partition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.</source>
          <target state="translated">テーブルに既存の &lt;code&gt;DEFAULT&lt;/code&gt; パーティションがあり、新しいパーティションが追加されている場合、デフォルトパーティションをスキャンして、新しいパーティションに適切に属する行が含まれていないことを確認する必要があります。デフォルトのパーティションに多数の行が含まれている場合、これは遅くなる可能性があります。デフォルトのパーティションが外部テーブルである場合、または新しいパーティションに配置する必要がある行を含むことができないことを証明する制約がある場合、スキャンはスキップされます。</target>
        </trans-unit>
        <trans-unit id="43b2ea07826933a7c581c975e04300af317cf31d" translate="yes" xml:space="preserve">
          <source>When a table has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested for each row in alphabetical order by name, after checking &lt;code&gt;NOT NULL&lt;/code&gt; constraints. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">テーブルに複数の &lt;code&gt;CHECK&lt;/code&gt; 制約がある場合、 &lt;code&gt;NOT NULL&lt;/code&gt; 制約をチェックした後、名前ごとにアルファベット順に各行についてテストされます。（9.5より前のバージョンのPostgreSQLでは、 &lt;code&gt;CHECK&lt;/code&gt; 制約の特定の起動順序は考慮されていませんでした。）</target>
        </trans-unit>
        <trans-unit id="082c9f9ffee26ce9be34e1d589e0da24d6b1e31a" translate="yes" xml:space="preserve">
          <source>When a table is being clustered, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock is acquired on it. This prevents any other database operations (both reads and writes) from operating on the table until the &lt;code&gt;CLUSTER&lt;/code&gt; is finished.</source>
          <target state="translated">テーブルがクラスター化されている場合、 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックがそのテーブルで取得されます。これにより、 &lt;code&gt;CLUSTER&lt;/code&gt; が完了するまで、他のデータベース操作（読み取りと書き込みの両方）がテーブルで動作するのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="7d4eb9118baea2c47a40ccbe4939e2face5ca64c" translate="yes" xml:space="preserve">
          <source>When a table is clustered, PostgreSQL remembers which index it was clustered by. The form &lt;code&gt;CLUSTER table_name&lt;/code&gt; reclusters the table using the same index as before. You can also use the &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; forms of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to set the index to be used for future cluster operations, or to clear any previous setting.</source>
          <target state="translated">テーブルがクラスター化されると、PostgreSQLはクラスター化されたインデックスを記憶します。 &lt;code&gt;CLUSTER table_name&lt;/code&gt; の形式は、以前と同じインデックスを使用してテーブルを再クラスター化します。また、使用することができます &lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; 形&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;将来のクラスター操作に使用する、または任意の以前の設定をクリアするには、インデックスを設定します。</target>
        </trans-unit>
        <trans-unit id="8eb320e131f3533a19b92cb04f708af68aba5d79" translate="yes" xml:space="preserve">
          <source>When a table is clustered, it is physically reordered based on the index information. Clustering is a one-time operation: when the table is subsequently updated, the changes are not clustered. That is, no attempt is made to store new or updated rows according to their index order. (If one wishes, one can periodically recluster by issuing the command again. Also, setting the table's &lt;code&gt;fillfactor&lt;/code&gt; storage parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are kept on the same page if enough space is available there.)</source>
          <target state="translated">テーブルがクラスター化されると、インデックス情報に基づいて物理的に並べ替えられます。クラスタリングは1回限りの操作です。テーブルが後で更新されても、変更はクラスタリングされません。つまり、インデックスの順序に従って新しい行または更新された行を格納する試みは行われません。 （必要に応じて、コマンドを再発行して定期的に再クラスター化できます。また、テーブルの &lt;code&gt;fillfactor&lt;/code&gt; storageパラメーターを100％未満に設定すると、十分なスペースがある場合に更新された行が同じページに保持されるため、更新時にクラスターの順序を維持するのに役立ちますそこで利用できます。）</target>
        </trans-unit>
        <trans-unit id="49a3d5e22ae2844ff5c06f47ba492689eb79f5ba" translate="yes" xml:space="preserve">
          <source>When a table is created, it contains no data. The first thing to do before a database can be of much use is to insert data. Data is conceptually inserted one row at a time. Of course you can also insert more than one row, but there is no way to insert less than one row. Even if you know only some column values, a complete row must be created.</source>
          <target state="translated">テーブルが作成されたとき、そのテーブルには何のデータも含まれていません。データベースが大きく役立つようになる前に最初にやるべきことは、データを挿入することです。データは概念的には1行ずつ挿入されます。もちろん複数の行を挿入することもできますが、1行未満のデータを挿入する方法はありません。一部の列の値だけを知っていても、完全な行を作成しなければなりません。</target>
        </trans-unit>
        <trans-unit id="85bad0d57dfc672246f13e6ad8d8a435cc923083" translate="yes" xml:space="preserve">
          <source>When a table or index exceeds 1 GB, it is divided into gigabyte-sized &lt;em&gt;segments&lt;/em&gt;. The first segment's file name is the same as the filenode; subsequent segments are named filenode.1, filenode.2, etc. This arrangement avoids problems on platforms that have file size limitations. (Actually, 1 GB is just the default segment size. The segment size can be adjusted using the configuration option &lt;code&gt;--with-segsize&lt;/code&gt; when building PostgreSQL.) In principle, free space map and visibility map forks could require multiple segments as well, though this is unlikely to happen in practice.</source>
          <target state="translated">テーブルまたはインデックスが1 GBを超えると、ギガバイトサイズの&lt;em&gt;セグメントに&lt;/em&gt;分割されます。最初のセグメントのファイル名はfilenodeと同じです。後続のセグメントにはfilenode.1、filenode.2などの名前が付けられます。この配置により、ファイルサイズに制限があるプラットフォームでの問題が回避されます。 （実際には、1 GBがデフォルトのセグメントサイズです。セグメントサイズは、PostgreSQLの &lt;code&gt;--with-segsize&lt;/code&gt; 時に--with-segsize設定オプションを使用して調整できます。）原則として、フリースペースマップと可視性マップのフォークには複数のセグメントも必要になる可能性があります。これは実際には起こりそうにありません。</target>
        </trans-unit>
        <trans-unit id="10a45cc60012ed72f0453155b208d80983750321" translate="yes" xml:space="preserve">
          <source>When a table reference names a table that is the parent of a table inheritance hierarchy, the table reference produces rows of not only that table but all of its descendant tables, unless the key word &lt;code&gt;ONLY&lt;/code&gt; precedes the table name. However, the reference produces only the columns that appear in the named table &amp;mdash; any columns added in subtables are ignored.</source>
          <target state="translated">テーブルの参照名テーブルの継承階層の親である表は、テーブルの参照はそのテーブルが、その子孫のテーブルのすべてではないだけの行を生成するときのキーワードがない限り &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に。ただし、参照は名前付きテーブルに表示される列のみを生成します。サブテーブルに追加された列は無視されます。</target>
        </trans-unit>
        <trans-unit id="238107619ce9861ed394df0ebec618f90c2d4272" translate="yes" xml:space="preserve">
          <source>When a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by the &lt;code&gt;CREATE TABLE&lt;/code&gt; command. But the &lt;code&gt;CREATE TABLE&lt;/code&gt; command can add defaults and constraints to the table and can specify storage parameters.</source>
          <target state="translated">型付き表が作成されると、列のデータ型は基礎となる複合型によって決定され、 &lt;code&gt;CREATE TABLE&lt;/code&gt; コマンドでは指定されません。ただし、 &lt;code&gt;CREATE TABLE&lt;/code&gt; コマンドは、デフォルトと制約をテーブルに追加し、ストレージパラメータを指定できます。</target>
        </trans-unit>
        <trans-unit id="40ca1a4315d7efd053d1772d2a1868caf568479c" translate="yes" xml:space="preserve">
          <source>When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way:</source>
          <target state="translated">値をSQLリテラルや識別子として使用する場合は、引用符で囲むのが最も安全です。SQLリテラルとして変数の値を引用するには、コロンの後に変数名を一重引用符で囲みます。SQL識別子として値を引用するには、コロンの後に二重引用符で変数名を記述します。これらの構文は、変数値に埋め込まれた引用符やその他の特殊文字を正しく処理します。前の例では、このように書くとより安全です。</target>
        </trans-unit>
        <trans-unit id="55eaed5a13493b2841925c6347f0f009f1c69d52" translate="yes" xml:space="preserve">
          <source>When a view is locked, all relations appearing in the view definition query are also locked recursively with the same lock mode.</source>
          <target state="translated">ビューがロックされている場合、ビュー定義クエリに現れるすべてのリレーションも、同じロックモードで再帰的にロックされます。</target>
        </trans-unit>
        <trans-unit id="0731d9c33a2135d592b4234920022cbe73ac4232" translate="yes" xml:space="preserve">
          <source>When acquiring locks automatically for commands that reference tables, PostgreSQL always uses the least restrictive lock mode possible. &lt;code&gt;LOCK TABLE&lt;/code&gt; provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the &lt;code&gt;READ COMMITTED&lt;/code&gt; isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain &lt;code&gt;SHARE&lt;/code&gt; lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because &lt;code&gt;SHARE&lt;/code&gt; lock mode conflicts with the &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; lock acquired by writers, and your &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; statement will wait until any concurrent holders of &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode locks commit or roll back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock.</source>
          <target state="translated">テーブルを参照するコマンドのロックを自動的に取得する場合、PostgreSQLは常に最も制限の少ないロックモードを使用します。 &lt;code&gt;LOCK TABLE&lt;/code&gt; は、より制限的なロックが必要になる場合に備えて提供されます。たとえば、アプリケーションが &lt;code&gt;READ COMMITTED&lt;/code&gt; 分離レベルでトランザクションを実行し、テーブルのデータがトランザクションの期間中安定していることを確認する必要があるとします。これを実現するには、クエリを実行する前にテーブルに対して &lt;code&gt;SHARE&lt;/code&gt; ロックモードを取得します。 &lt;code&gt;SHARE&lt;/code&gt; ロックモードはライターが取得した &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; ロックと競合するため、これにより、同時データ変更が防止され、テーブルの後続の読み取りでコミットされたデータの安定したビューが表示されます。 &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; ステートメントは、 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; モードロックの同時保持者がコミットまたはロールバックするまで待機します。したがって、いったんロックを取得すると、コミットされていない未処理の書き込みはありません。さらに、ロックを解除するまで何も開始できません。</target>
        </trans-unit>
        <trans-unit id="71a870f6af21f8dafd4cc733a991bd99fd9d13ef" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;CST7CDT&lt;/code&gt;, &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; will produce &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt;, while adding &lt;code&gt;interval '24 hours'&lt;/code&gt; to the same initial &lt;code&gt;timestamp with time zone&lt;/code&gt; produces &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt;, as there is a change in daylight saving time at &lt;code&gt;2005-04-03 02:00&lt;/code&gt; in time zone &lt;code&gt;CST7CDT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timestamp with time zone&lt;/code&gt; 値を持つタイムスタンプに &lt;code&gt;interval&lt;/code&gt; 値を追加する（またはタイムスタンプ値から &lt;code&gt;interval&lt;/code&gt; 値を減算する）場合、日コンポーネントは、 &lt;code&gt;timestamp with time zone&lt;/code&gt; の日付を指定された日数だけ進めるか、減らします。夏時間の変更（セッションのタイムゾーンがDSTを認識するタイムゾーンに設定されている場合）全体で、これは、 &lt;code&gt;interval '1 day'&lt;/code&gt; が &lt;code&gt;interval '24 hours'&lt;/code&gt; 必ずしも等しいとは限らないことを意味します。たとえば、セッションのタイムゾーンが &lt;code&gt;CST7CDT&lt;/code&gt; に設定されている場合、 &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt; 生成します06 '、追加中 &lt;code&gt;interval '24 hours'&lt;/code&gt; &lt;code&gt;timestamp with time zone&lt;/code&gt; 同じ初期タイムスタンプの間隔'24時間 'は、 &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt; 生成します。これは、 &lt;code&gt;2005-04-03 02:00&lt;/code&gt; の夏時間に変更があるためです。タイムゾーン &lt;code&gt;CST7CDT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1434d3ccf06b603b0c31a66fe4b553e885790f9" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;Append&lt;/code&gt; node is used in a parallel plan, each process will execute the child plans in the order in which they appear, so that all participating processes cooperate to execute the first child plan until it is complete and then move to the second plan at around the same time. When a &lt;code&gt;Parallel Append&lt;/code&gt; is used instead, the executor will instead spread out the participating processes as evenly as possible across its child plans, so that multiple child plans are executed simultaneously. This avoids contention, and also avoids paying the startup cost of a child plan in those processes that never execute it.</source>
          <target state="translated">&lt;code&gt;Append&lt;/code&gt; ノードが並列プランで使用される場合、各プロセスは、出現順に子プランを実行します。これにより、参加しているすべてのプロセスが協力して、最初の子プランが完了するまで実行され、次に2番目のプランに移動します。ほぼ同時に。とき &lt;code&gt;Parallel Append&lt;/code&gt; 代わりに使用され、エグゼキュータは、代わりに複数の子計画が同時に実行されるように、均等にその子計画全体でできるだけ参加のプロセスを広げます。これにより、競合が回避され、子プランを実行しないプロセスで子プランの開始コストを支払うことも回避されます。</target>
        </trans-unit>
        <trans-unit id="5e4864e701f86b03083b18f6c388ffa7cee629fe" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;INSERT&lt;/code&gt; command has an auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause, if the &lt;code&gt;UPDATE&lt;/code&gt; path is taken, the row to be updated is first checked against the &lt;code&gt;USING&lt;/code&gt; expressions of any &lt;code&gt;UPDATE&lt;/code&gt; policies, and then the new updated row is checked against the &lt;code&gt;WITH CHECK&lt;/code&gt; expressions. Note, however, that unlike a standalone &lt;code&gt;UPDATE&lt;/code&gt; command, if the existing row does not pass the &lt;code&gt;USING&lt;/code&gt; expressions, an error will be thrown (the &lt;code&gt;UPDATE&lt;/code&gt; path will &lt;em&gt;never&lt;/em&gt; be silently avoided).</source>
          <target state="translated">場合 &lt;code&gt;INSERT&lt;/code&gt; コマンドは、補助有し &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句場合、 &lt;code&gt;UPDATE&lt;/code&gt; のパスが取られ、更新すべき行が最初に照合され &lt;code&gt;USING&lt;/code&gt; 任意の式 &lt;code&gt;UPDATE&lt;/code&gt; のポリシー、および新しい更新された行が照合され &lt;code&gt;WITH CHECK&lt;/code&gt; 式。ただし、スタンドアロンの &lt;code&gt;UPDATE&lt;/code&gt; コマンドとは異なり、既存の行が &lt;code&gt;USING&lt;/code&gt; 式を渡さない場合、エラーがスローされます（ &lt;code&gt;UPDATE&lt;/code&gt; パスが暗黙的に回避される&lt;em&gt;こと&lt;/em&gt;はあり&lt;em&gt;ませ&lt;/em&gt;ん）。</target>
        </trans-unit>
        <trans-unit id="f5ddde61a4b6e8647a9abfe81db27fb6ec9b4388" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;N&lt;/code&gt;-dimensional array is pushed onto the beginning or end of an &lt;code&gt;N+1&lt;/code&gt;-dimensional array, the result is analogous to the element-array case above. Each &lt;code&gt;N&lt;/code&gt;-dimensional sub-array is essentially an element of the &lt;code&gt;N+1&lt;/code&gt;-dimensional array's outer dimension. For example:</source>
          <target state="translated">場合 &lt;code&gt;N&lt;/code&gt; 次元アレイはの最初または最後にプッシュされる &lt;code&gt;N+1&lt;/code&gt; 次元アレイ、結果は、上記素子アレイの場合に類似しています。各 &lt;code&gt;N&lt;/code&gt; 次元のサブ配列は、基本的に &lt;code&gt;N+1&lt;/code&gt; 次元の配列の外側の次元の要素です。例えば：</target>
        </trans-unit>
        <trans-unit id="31260cf4fd42afa924c8ee13fbb974bf90d187b0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; command affects an inheritance hierarchy, the output might look like this:</source>
          <target state="translated">とき &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; コマンドが継承階層に影響を与え、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5c47d72e8415ae2214a0b4c8ffca096b8ee4f7c5" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">集計式がサブクエリにある場合（&lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;セクション4.2.11&lt;/a&gt;および&lt;a href=&quot;functions-subquery&quot;&gt;セクション9.22を&lt;/a&gt;参照）、通常、集計はサブクエリの行に対して評価されます。ただし、集計の引数（および &lt;code&gt;filter_clause&lt;/code&gt; 場合はfilter_clause）に外部レベルの変数のみが含まれている場合は例外が発生します。集計は次に最も近い外部レベルに属し、そのクエリの行に対して評価されます。集計式は全体として、それが出現するサブクエリの外部参照となり、そのサブクエリの1つの評価に対して定数として機能します。結果リストまたは &lt;code&gt;HAVING&lt;/code&gt; 句にのみ表示されることに関する制限は、集計が属するクエリレベルに適用されます。</target>
        </trans-unit>
        <trans-unit id="34d2b87c80e1af3054e4c9d4d3c71d80a5607eb6" translate="yes" xml:space="preserve">
          <source>When an aggregate function is used as a window function, it aggregates over the rows within the current row's window frame. An aggregate used with &lt;code&gt;ORDER BY&lt;/code&gt; and the default window frame definition produces a &amp;ldquo;running sum&amp;rdquo; type of behavior, which may or may not be what's wanted. To obtain aggregation over the whole partition, omit &lt;code&gt;ORDER BY&lt;/code&gt; or use &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt;. Other frame specifications can be used to obtain other effects.</source>
          <target state="translated">集計関数をウィンドウ関数として使用すると、現在の行のウィンドウフレーム内の行全体で集計されます。 &lt;code&gt;ORDER BY&lt;/code&gt; とデフォルトのウィンドウフレーム定義で使用される集約は、「実行合計」タイプの動作を生成します。これは、必要な場合とそうでない場合があります。パーティション全体の集計を取得するには、 &lt;code&gt;ORDER BY&lt;/code&gt; を省略するか、 &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt; を使用します。他のフレーム仕様を使用して、他の効果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="64b60eb6cf1570c88f1c1631b3c6e4c5824a2f8b" translate="yes" xml:space="preserve">
          <source>When an alias is applied to the output of a &lt;code&gt;JOIN&lt;/code&gt; clause, the alias hides the original name(s) within the &lt;code&gt;JOIN&lt;/code&gt;. For example:</source>
          <target state="translated">エイリアスが &lt;code&gt;JOIN&lt;/code&gt; 句の出力に適用されると、エイリアスは &lt;code&gt;JOIN&lt;/code&gt; 内の元の名前を隠します。例えば：</target>
        </trans-unit>
        <trans-unit id="0151521ad4c1bed3dd275586a7870760908f04a0" translate="yes" xml:space="preserve">
          <source>When an application receives this error message, it should abort the current transaction and retry the whole transaction from the beginning. The second time through, the transaction will see the previously-committed change as part of its initial view of the database, so there is no logical conflict in using the new version of the row as the starting point for the new transaction's update.</source>
          <target state="translated">アプリケーションがこのエラーメッセージを受け取った場合、アプリケーションは現在のトランザクションを中止して、トランザクション全体を最初から再試行すべきである。2回目の実行では、トランザクションは以前にコミットされた変更をデータベースの最初のビューの一部として見ることになるので、新しいトランザクションの更新の開始点として行の新しいバージョンを使用することに論理的な衝突はありません。</target>
        </trans-unit>
        <trans-unit id="4ee9b3bf4967c5d2fb0d054d753f418145337cf0" translate="yes" xml:space="preserve">
          <source>When an enum type is created, its members are assigned sort-order positions 1..&lt;code&gt;n&lt;/code&gt;. But members added later might be given negative or fractional values of &lt;code&gt;enumsortorder&lt;/code&gt;. The only requirement on these values is that they be correctly ordered and unique within each enum type.</source>
          <target state="translated">列挙型が作成されると、そのメンバーにはソート順の位置1 .. &lt;code&gt;n&lt;/code&gt; が割り当てられます。ただし、後で追加されたメンバーには、 &lt;code&gt;enumsortorder&lt;/code&gt; の負の値または小数値が与えられる場合があります。これらの値の唯一の要件は、それらが正しく列挙され、各列挙型内で一意であることです。</target>
        </trans-unit>
        <trans-unit id="0950043f7233c157a718d379ee2b34585d4ee731" translate="yes" xml:space="preserve">
          <source>When an index is declared unique, multiple table rows with equal indexed values are not allowed. Null values are not considered equal. A multicolumn unique index will only reject cases where all indexed columns are equal in multiple rows.</source>
          <target state="translated">インデックスが一意であると宣言されている場合、等しいインデックス値を持つ複数のテーブル行は許可されません。ヌル値は等しいとはみなされません。複数列の一意インデックスは、複数の行ですべてのインデックス列が等しい場合にのみ拒否されます。</target>
        </trans-unit>
        <trans-unit id="4aa9424b6df0026312433f3f9260dd9161451961" translate="yes" xml:space="preserve">
          <source>When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page.</source>
          <target state="translated">インデックスページの分割が必要な場合、この関数は、ページ上のどのエントリを古いページに残し、どのエントリを新しいページに移動するかを決定します。</target>
        </trans-unit>
        <trans-unit id="d0d21498c252827ceaa7947111042a06bc38a5a5" translate="yes" xml:space="preserve">
          <source>When an index scan is used, a temporary copy of the table is created that contains the table data in the index order. Temporary copies of each index on the table are created as well. Therefore, you need free space on disk at least equal to the sum of the table size and the index sizes.</source>
          <target state="translated">インデックス スキャンを使用すると、インデックス順にテーブル データを含むテーブルの一時コピーが作成されます。テーブル上の各インデックスの一時コピーも同様に作成されます。したがって、少なくともテーブルのサイズとインデックスのサイズの合計に等しいディスク上の空き容量が必要です。</target>
        </trans-unit>
        <trans-unit id="dad624a33f1e64269d27c153de83dc5212addec4" translate="yes" xml:space="preserve">
          <source>When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, &lt;em&gt;privileges&lt;/em&gt; must be granted.</source>
          <target state="translated">オブジェクトが作成されると、所有者が割り当てられます。所有者は通常、作成ステートメントを実行したロールです。ほとんどの種類のオブジェクトでは、初期状態では、所有者（またはスーパーユーザー）だけがオブジェクトを操作できます。他のロールで使用できるようにするには、&lt;em&gt;権限を付与する&lt;/em&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="016db50c093e11f2c3975978fc13dbb74ccca023" translate="yes" xml:space="preserve">
          <source>When an operator or function of the underlying type is applied to a domain value, the domain is automatically down-cast to the underlying type. Thus, for example, the result of &lt;code&gt;mytable.id - 1&lt;/code&gt; is considered to be of type &lt;code&gt;integer&lt;/code&gt; not &lt;code&gt;posint&lt;/code&gt;. We could write &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; to cast the result back to &lt;code&gt;posint&lt;/code&gt;, causing the domain's constraints to be rechecked. In this case, that would result in an error if the expression had been applied to an &lt;code&gt;id&lt;/code&gt; value of 1. Assigning a value of the underlying type to a field or variable of the domain type is allowed without writing an explicit cast, but the domain's constraints will be checked.</source>
          <target state="translated">基になる型の演算子または関数がドメイン値に適用されると、ドメインは基になる型に自動的にダウンキャストされます。したがって、例えば、結果 &lt;code&gt;mytable.id - 1&lt;/code&gt; 型であると考えられている &lt;code&gt;integer&lt;/code&gt; ない &lt;code&gt;posint&lt;/code&gt; 。私たちは書くことができます &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; にキャストする結果バック &lt;code&gt;posint&lt;/code&gt; ドメインの制約を再チェックすることが原因。この場合、式が1の &lt;code&gt;id&lt;/code&gt; 値に適用されているとエラーになります。基になる型の値をドメイン型のフィールドまたは変数に割り当てることは、明示的なキャストを記述せずに許可されますが、ドメインの制約がチェックされます。</target>
        </trans-unit>
        <trans-unit id="9d220c80b589197cba0d859444da322b0880222c" translate="yes" xml:space="preserve">
          <source>When archiving WAL data, we need to capture the contents of each segment file once it is filled, and save that data somewhere before the segment file is recycled for reuse. Depending on the application and the available hardware, there could be many different ways of &amp;ldquo;saving the data somewhere&amp;rdquo;: we could copy the segment files to an NFS-mounted directory on another machine, write them onto a tape drive (ensuring that you have a way of identifying the original name of each file), or batch them together and burn them onto CDs, or something else entirely. To provide the database administrator with flexibility, PostgreSQL tries not to make any assumptions about how the archiving will be done. Instead, PostgreSQL lets the administrator specify a shell command to be executed to copy a completed segment file to wherever it needs to go. The command could be as simple as a &lt;code&gt;cp&lt;/code&gt;, or it could invoke a complex shell script &amp;mdash; it's all up to you.</source>
          <target state="translated">WALデータをアーカイブするときは、各セグメントファイルがいっぱいになったらその内容をキャプチャし、セグメントファイルを再利用する前にそのデータをどこかに保存する必要があります。アプリケーションと使用可能なハードウェアに応じて、「データをどこかに保存する」さまざまな方法があります。セグメントファイルを別のマシンのNFSマウントディレクトリにコピーし、テープドライブに書き込みます（確実に各ファイルの元の名前を識別する方法）、またはそれらを一緒にバッチ処理してCDに書き込むか、完全に別の方法で書き込みます。データベース管理者に柔軟性を提供するために、PostgreSQLはアーカイブがどのように行われるかについて何も想定しないようにしています。代わりに、PostgreSQLでは、管理者が実行するシェルコマンドを指定して、完了したセグメントファイルを必要な場所にコピーできます。コマンドは、 &lt;code&gt;cp&lt;/code&gt; 、またはそれは複雑なシェルスクリプトを呼び出すことができます&amp;mdash;それはすべてあなた次第です。</target>
        </trans-unit>
        <trans-unit id="c3d93c6ecb33c6eb94db27d2fba2d265ff994790" translate="yes" xml:space="preserve">
          <source>When autosummarization is enabled, each time a page range is filled a request is sent to autovacuum for it to execute a targeted summarization for that range, to be fulfilled at the end of the next worker run on the same database. If the request queue is full, the request is not recorded and a message is sent to the server log:</source>
          <target state="translated">autosummarizationが有効になっている場合、ページ範囲が満たされるたびに、その範囲を対象とした要約を実行するためのリクエストがautovacuumに送信され、同じデータベース上で次のワーカーの実行の最後に実行されます。リクエストキューが一杯になると、リクエストは記録されず、サーバログにメッセージが送られます。</target>
        </trans-unit>
        <trans-unit id="f660851bc52c800a20554ffeb6a7df92726f03b4" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-b&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are given, the behavior is to output large objects, when data is being dumped, see the &lt;code&gt;-b&lt;/code&gt; documentation.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; と &lt;code&gt;-B&lt;/code&gt; の両方が指定されている場合、動作はラージオブジェクトを出力することです。データがダンプされている場合は、 &lt;code&gt;-b&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ad45f5349fac03bd7966e305b187db06383f5ed7" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given for the same schema name, the &lt;code&gt;-N&lt;/code&gt; switch wins and the schema is excluded.</source>
          <target state="translated">同じスキーマ名に &lt;code&gt;-n&lt;/code&gt; と &lt;code&gt;-N&lt;/code&gt; の両方が指定されている場合、 &lt;code&gt;-N&lt;/code&gt; スイッチが優先され、スキーマは除外されます。</target>
        </trans-unit>
        <trans-unit id="ede3b8af7caafd954943fe5f04f3a1cc429ba018" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given, the behavior is to dump just the schemas that match at least one &lt;code&gt;-n&lt;/code&gt; switch but no &lt;code&gt;-N&lt;/code&gt; switches. If &lt;code&gt;-N&lt;/code&gt; appears without &lt;code&gt;-n&lt;/code&gt;, then schemas matching &lt;code&gt;-N&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; と &lt;code&gt;-N&lt;/code&gt; の両方が指定されている場合、動作は、少なくとも1つの &lt;code&gt;-n&lt;/code&gt; スイッチに一致し、 &lt;code&gt;-N&lt;/code&gt; スイッチには一致しないスキーマのみをダンプすることです。場合は &lt;code&gt;-N&lt;/code&gt; はせずに表示されます &lt;code&gt;-n&lt;/code&gt; 、その後、一致するスキーマ &lt;code&gt;-N&lt;/code&gt; は、そうでない場合は、通常のダンプが何であるかを対象から除外されています。</target>
        </trans-unit>
        <trans-unit id="031547c5dfb59556734ca49134f210c68e4c5520" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-T&lt;/code&gt; are given, the behavior is to dump just the tables that match at least one &lt;code&gt;-t&lt;/code&gt; switch but no &lt;code&gt;-T&lt;/code&gt; switches. If &lt;code&gt;-T&lt;/code&gt; appears without &lt;code&gt;-t&lt;/code&gt;, then tables matching &lt;code&gt;-T&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; と &lt;code&gt;-T&lt;/code&gt; の両方が指定されている場合、動作は、少なくとも1つの &lt;code&gt;-t&lt;/code&gt; スイッチに一致し、 &lt;code&gt;-T&lt;/code&gt; スイッチに一致しないテーブルのみをダンプすることです。場合は &lt;code&gt;-T&lt;/code&gt; をせずに表示されます &lt;code&gt;-t&lt;/code&gt; 、その後、マッチングテーブル &lt;code&gt;-T&lt;/code&gt; は、そうでない場合は、通常のダンプが何であるかを対象から除外されています。</target>
        </trans-unit>
        <trans-unit id="6e63ae1dfc17974e0be483ba0ff638bbea32a3b3" translate="yes" xml:space="preserve">
          <source>When casting from &lt;code&gt;EAN13&lt;/code&gt; to another type, there is a run-time check that the value is within the domain of the other type, and an error is thrown if not. The other casts are simply relabelings that will always succeed.</source>
          <target state="translated">&lt;code&gt;EAN13&lt;/code&gt; から別のタイプにキャストする場合、値が他のタイプのドメイン内にあることをランタイムチェックし、そうでない場合はエラーがスローされます。他のキャストは、常に成功する単純なラベル付けです。</target>
        </trans-unit>
        <trans-unit id="9b112e4a8b6a5ae3071dcef7339526c0bc3d3e45" translate="yes" xml:space="preserve">
          <source>When changing this value, consider also adjusting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;.</source>
          <target state="translated">この値を変更するときは、&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;、&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;、および&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;も調整することを検討してください。</target>
        </trans-unit>
        <trans-unit id="db437265a89a8152322953823332b5732e1c0d00" translate="yes" xml:space="preserve">
          <source>When choosing OIDs for a patch that is not expected to be committed immediately, best practice is to use a group of more-or-less consecutive OIDs starting with some random choice in the range 8000&amp;mdash;9999. This minimizes the risk of OID collisions with other patches being developed concurrently. To keep the 8000&amp;mdash;9999 range free for development purposes, after a patch has been committed to the master git repository its OIDs should be renumbered into available space below that range. Typically, this will be done near the end of each development cycle, moving all OIDs consumed by patches committed in that cycle at the same time. The script &lt;code&gt;renumber_oids.pl&lt;/code&gt; can be used for this purpose. If an uncommitted patch is found to have OID conflicts with some recently-committed patch, &lt;code&gt;renumber_oids.pl&lt;/code&gt; may also be useful for recovering from that situation.</source>
          <target state="translated">すぐにコミットされるとは予想されないパッチのOIDを選択する場合、ベストプラクティスは、8000〜9999の範囲のランダムな選択で始まる、多かれ少なかれ連続するOIDのグループを使用することです。これにより、同時に開発されている他のパッチとのOID衝突のリスクが最小限に抑えられます。開発目的で8000〜9999の範囲を空けておくには、パッチがマスターgitリポジトリにコミットされた後、そのOIDをその範囲より下の使用可能なスペースに再番号付けする必要があります。通常、これは各開発サイクルの終わり近くに行われ、そのサイクルでコミットされたパッチによって同時に消費されたすべてのOIDが移動されます。スクリプト &lt;code&gt;renumber_oids.pl&lt;/code&gt; はこの目的で使用できます。コミットされていないパッチが、最近コミットされたいくつかのパッチとOIDが競合していることが判明した場合は、 &lt;code&gt;renumber_oids.pl&lt;/code&gt; そのような状況からの回復にも役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="9881b7b2a51c119b916b26c12b2f50a595bc868b" translate="yes" xml:space="preserve">
          <source>When compiled with OpenSSL, there will be more algorithms available. Also public-key encryption functions will be faster as OpenSSL has more optimized BIGNUM functions.</source>
          <target state="translated">OpenSSLでコンパイルすると、より多くのアルゴリズムが利用できるようになります。また、公開鍵暗号化関数は、OpenSSLがより最適化されたBIGNUM関数を持っているため、より高速になります。</target>
        </trans-unit>
        <trans-unit id="5f2a4f35ae5e876b04f4e8702b5ef942899c0855" translate="yes" xml:space="preserve">
          <source>When compiled with zlib, PGP encryption functions are able to compress data before encrypting.</source>
          <target state="translated">zlibでコンパイルした場合、PGP暗号化機能は暗号化する前にデータを圧縮することができます。</target>
        </trans-unit>
        <trans-unit id="4526356cc9d2b5524d1c0613a2cac8e5545975fc" translate="yes" xml:space="preserve">
          <source>When compiling the preprocessed C code files, the compiler needs to be able to find the ECPG header files in the PostgreSQL include directory. Therefore, you might have to use the &lt;code&gt;-I&lt;/code&gt; option when invoking the compiler (e.g., &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt;).</source>
          <target state="translated">前処理されたCコードファイルをコンパイルする場合、コンパイラは、PostgreSQLインクルードディレクトリでECPGヘッダーファイルを見つけることができる必要があります。したがって、コンパイラーを呼び出すときに &lt;code&gt;-I&lt;/code&gt; オプションを使用する必要がある場合があります（例： &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f6cfdda77ce1539f64bc346b96c3160b7466725a" translate="yes" xml:space="preserve">
          <source>When computing the selectivity for a query involving functionally dependent columns, the planner adjusts the per-condition selectivity estimates using the dependency coefficients so as not to produce an underestimate.</source>
          <target state="translated">関数的に依存する列を含む問い合わせの選択性を計算する際,プランナは,過小評価にならないように依存性係数を用いて条件ごとの選択性の推定値を調整します.</target>
        </trans-unit>
        <trans-unit id="29ea042e28fa2362fa9c26ca7e49e9bd0ec5e906" translate="yes" xml:space="preserve">
          <source>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name &lt;code&gt;fred&lt;/code&gt;, principal &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; would be able to connect. To also allow principal &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt;, use a user name map, as described in &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;.</source>
          <target state="translated">データベースに接続するときは、要求されたデータベースユーザー名と一致するプリンシパルのチケットがあることを確認してください。たとえば、データベースユーザー名が &lt;code&gt;fred&lt;/code&gt; の場合、プリンシパル &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; は接続できます。プリンシパル &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt; も許可するには、&lt;a href=&quot;auth-username-maps&quot;&gt;セクション20.2で&lt;/a&gt;説明されているように、ユーザー名マップを使用します。</target>
        </trans-unit>
        <trans-unit id="7fb2d529ca9e4c06995d0fca116b867907b7f0d6" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify in its connection request the name of the database it wants to connect to. It is not possible to access more than one database per connection. However, an application is not restricted in the number of connections it opens to the same or other databases. Databases are physically separated and access control is managed at the connection level. If one PostgreSQL server instance is to house projects or users that should be separate and for the most part unaware of each other, it is therefore recommended to put them into separate databases. If the projects or users are interrelated and should be able to use each other's resources, they should be put in the same database but possibly into separate schemas. Schemas are a purely logical structure and who can access what is managed by the privilege system. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">データベースサーバーに接続するとき、クライアントは接続要求で、接続するデータベースの名前を指定する必要があります。接続ごとに複数のデータベースにアクセスすることはできません。ただし、アプリケーションは、同じデータベースまたは他のデータベースに対して開く接続の数に制限はありません。データベースは物理的に分離され、アクセス制御は接続レベルで管理されます。 1つのPostgreSQLサーバーインスタンスが、独立している必要があり、ほとんどの場合互いに気づかないプロジェクトまたはユーザーを収容する場合、それらを別々のデータベースに配置することをお勧めします。プロジェクトまたはユーザーが相互に関連していて、互いのリソースを使用できる必要がある場合、それらは同じデータベースに配置する必要がありますが、別のスキーマに配置する必要があります。スキーマは純粋に論理的な構造であり、誰が特権システムによって管理されているものにアクセスできます。スキーマの管理の詳細については、&lt;a href=&quot;ddl-schemas&quot;&gt;セクション5.9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12d0d4ecddcc515b05d012f2d76c53d27fb85b80" translate="yes" xml:space="preserve">
          <source>When continuous WAL archiving is used in a standby, there are two different scenarios: the WAL archive can be shared between the primary and the standby, or the standby can have its own WAL archive. When the standby has its own WAL archive, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt;, and the standby will call the archive command for every WAL segment it receives, whether it's by restoring from the archive or by streaming replication. The shared archive can be handled similarly, but the &lt;code&gt;archive_command&lt;/code&gt; must test if the file being archived exists already, and if the existing file has identical contents. This requires more care in the &lt;code&gt;archive_command&lt;/code&gt;, as it must be careful to not overwrite an existing file with different contents, but return success if the exactly same file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive the same file at the same time.</source>
          <target state="translated">スタンバイで継続的なWALアーカイブを使用する場合、2つの異なるシナリオがあります。WALアーカイブをプライマリとスタンバイ間で共有することも、スタンバイが独自のWALアーカイブを持つこともできます。スタンバイに独自のWALアーカイブがある場合は、 &lt;code&gt;archive_mode&lt;/code&gt; を &lt;code&gt;always&lt;/code&gt; に設定します。スタンバイは、アーカイブからの復元またはストリーミングレプリケーションのいずれの場合でも、受信するすべてのWALセグメントに対してアーカイブコマンドを呼び出します。共有アーカイブは同様に処理できますが、 &lt;code&gt;archive_command&lt;/code&gt; は、アーカイブされるファイルがすでに存在するかどうか、および既存のファイルの内容が同じかどうかをテストする必要があります。これには、 &lt;code&gt;archive_command&lt;/code&gt; でさらに注意が必要です。、異なる内容で既存のファイルを上書きしないように注意する必要がありますが、まったく同じファイルが2回アーカイブされた場合は成功を返します。また、2つのサーバーが同じファイルを同時にアーカイブしようとする場合、これらすべてを競合状態から解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="206b825e98c6a586acace075380fd147e6696a55" translate="yes" xml:space="preserve">
          <source>When converting textual JSON input into &lt;code&gt;jsonb&lt;/code&gt;, the primitive types described by RFC 7159 are effectively mapped onto native PostgreSQL types, as shown in &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;Table 8.23&lt;/a&gt;. Therefore, there are some minor additional constraints on what constitutes valid &lt;code&gt;jsonb&lt;/code&gt; data that do not apply to the &lt;code&gt;json&lt;/code&gt; type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, &lt;code&gt;jsonb&lt;/code&gt; will reject numbers that are outside the range of the PostgreSQL &lt;code&gt;numeric&lt;/code&gt; data type, while &lt;code&gt;json&lt;/code&gt; will not. Such implementation-defined restrictions are permitted by RFC 7159. However, in practice such problems are far more likely to occur in other implementations, as it is common to represent JSON's &lt;code&gt;number&lt;/code&gt; primitive type as IEEE 754 double precision floating point (which RFC 7159 explicitly anticipates and allows for). When using JSON as an interchange format with such systems, the danger of losing numeric precision compared to data originally stored by PostgreSQL should be considered.</source>
          <target state="translated">&lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;表8.23に&lt;/a&gt;示すように、テキストJSON入力を &lt;code&gt;jsonb&lt;/code&gt; に変換すると、RFC 7159で説明されているプリミティブ型がネイティブのPostgreSQL型に効果的にマッピングされます。したがって、基礎となるデータ型で表すことができるものの制限に対応して、 &lt;code&gt;json&lt;/code&gt; 型にも抽象のJSONにも適用されない有効な &lt;code&gt;jsonb&lt;/code&gt; データを構成するものには、いくつかの小さな制約があります。特に、 &lt;code&gt;jsonb&lt;/code&gt; はPostgreSQLの &lt;code&gt;numeric&lt;/code&gt; データ型の範囲外の数値を拒否しますが、 &lt;code&gt;json&lt;/code&gt; しない。このような実装定義の制限は、RFC 7159で許可されています。ただし、実際には、JSONの &lt;code&gt;number&lt;/code&gt; プリミティブ型をIEEE 754倍精度浮動小数点（RFC 7159が明示的に予測する）として表すことが一般的であるため、このような問題は他の実装で発生する可能性がはるかに高くなります。そして可能にする）。このようなシステムで交換形式としてJSONを使用する場合、PostgreSQLによって最初に格納されたデータと比較して数値の精度が失われる危険性を考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="e063ec55d6b5085c54d075810d580142922489d3" translate="yes" xml:space="preserve">
          <source>When creating a comment on a constraint, a trigger, a rule or a policy these parameters specify the name of the table or domain on which that object is defined.</source>
          <target state="translated">制約、トリガー、ルール、ポリシーのコメントを作成する場合、これらのパラメータは、そのオブジェクトが定義されているテーブルまたはドメインの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="696e17ed5a7d60938c1cece83fb1d6b1c0903390" translate="yes" xml:space="preserve">
          <source>When creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.</source>
          <target state="translated">ハッシュパーティションを作成する際には、モジュラスと余りを指定しなければなりません。係数は正の整数でなければならず、残りは係数以下の非負の整数でなければなりません。一般的に、ハッシュパーティションのテーブルを最初にセットアップするときは、パーティションの数と同じモジュラスを選択し、すべてのテーブルに同じモジュラスと異なる余白を割り当てるべきです (後述の例を参照してください)。しかし、すべてのパーティションが同じモジュラスを持つ必要はなく、ハッシュ分割されたテーブルのパーティション間で発生するすべてのモジュラスが、次のより大きなモジュラスの係数であることだけです。これにより、すべてのデータを一度に移動させることなく、パーティションの数を段階的に増やすことができます。例えば、8つのパーティションを持つハッシュ分割テーブルを持っていて、それぞれのパーティションはモジュラス8ですが、パーティションの数を16に増やす必要があることがわかったとします。モジュラス8のパーティションの1つを切り離し、キー空間の同じ部分をカバーする2つの新しいモジュラス16のパーティションを作成し(1つは切り離したパーティションの残りの値と同じ余剰を持ち、もう1つはその値に8を足した値と同じ余剰を持つ)、データを再配置することができます。そして、これを、おそらく後で、modulus-8 パーティションが一つも残らなくなるまで繰り返すことができます。各ステップで大量のデータ移動が必要になるかもしれませんが、新しいテーブルを作成して一度にすべてのデータを移動するよりは良いでしょう。</target>
        </trans-unit>
        <trans-unit id="dc592c55de3b2852cc094ece1e21e03a790645cd" translate="yes" xml:space="preserve">
          <source>When creating a list partition, &lt;code&gt;NULL&lt;/code&gt; can be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table. &lt;code&gt;NULL&lt;/code&gt; cannot be specified for range partitions.</source>
          <target state="translated">リストパーティションを作成する場合、 &lt;code&gt;NULL&lt;/code&gt; を指定して、パーティションでパーティションキー列をnullにすることができます。ただし、特定の親テーブルには、このようなリストパーティションを複数作成することはできません。範囲パーティションには &lt;code&gt;NULL&lt;/code&gt; を指定できません。</target>
        </trans-unit>
        <trans-unit id="959c4be92ae7a89cd93733c9fb53bfb204d0cf54" translate="yes" xml:space="preserve">
          <source>When creating a range partition involving more than one column, it can also make sense to use &lt;code&gt;MAXVALUE&lt;/code&gt; as part of the lower bound, and &lt;code&gt;MINVALUE&lt;/code&gt; as part of the upper bound. For example, a partition defined using &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined using &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; allows any rows where the first partition key column starts with &quot;a&quot;.</source>
          <target state="translated">複数の列を含む範囲パーティションを作成する場合、下限の一部として &lt;code&gt;MAXVALUE&lt;/code&gt; を使用し、上限の一部として &lt;code&gt;MINVALUE&lt;/code&gt; を使用することも意味があります。たとえば、 &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; を使用して定義されたパーティションは、最初のパーティションキー列が0より大きく10以下の行を許可します。同様に、 &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; は、最初のパーティションキー列が「a」で始まるすべての行を許可します。</target>
        </trans-unit>
        <trans-unit id="57bc08d42f10eaae11d2af1199ad3605b863277f" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">範囲パーティションを作成する場合、 &lt;code&gt;FROM&lt;/code&gt; で指定された下限は包含的境界ですが、 &lt;code&gt;TO&lt;/code&gt; で指定された上限は排他的境界です。つまり、 &lt;code&gt;FROM&lt;/code&gt; リストで指定された値は、このパーティションに対応するパーティションキー列の有効な値ですが、 &lt;code&gt;TO&lt;/code&gt; リストの値はそうではありません。このステートメントは、行ごとの比較のルール（&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;9.23.5項&lt;/a&gt;）に従って理解する必要があることに注意してください。たとえば、 &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; と、 &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; バインドされたパーティションは、 &lt;code&gt;x=1&lt;/code&gt; で任意の &lt;code&gt;y&amp;gt;=2&lt;/code&gt; 、 &lt;code&gt;x=2&lt;/code&gt; で任意の非null &lt;code&gt;y&lt;/code&gt; を許可します、 &lt;code&gt;x=3&lt;/code&gt; 、 &lt;code&gt;y&amp;lt;4&lt;/code&gt; いずれか。</target>
        </trans-unit>
        <trans-unit id="812122c3d99be13340fb205c1949bf12eabae44b" translate="yes" xml:space="preserve">
          <source>When creating a replication slot (the default behavior), &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">レプリケーションスロットを作成するとき（デフォルトの動作）、 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; はトランザクションブロック内では実行できません。</target>
        </trans-unit>
        <trans-unit id="de7cd6bf9e49c5d84cc8863ddd6e1c17c3e9e579" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">スロットを作成する場合、指定された論理デコード出力プラグインを使用します。&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章を&lt;/a&gt;参照してください。スロットがすでに存在する場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="005a2c498e4cc6e0542ca9414edc2d0ef17812bb" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the remote host is not reachable or in an unclear state. In that case, the subscription can be created using the &lt;code&gt;connect = false&lt;/code&gt; option. The remote host will then not be contacted at all. This is what pg_dump uses. The remote replication slot will then have to be created manually before the subscription can be activated.</source>
          <target state="translated">サブスクリプションを作成するときに、リモートホストに到達できないか、不明な状態です。その場合、サブスクリプションは、 &lt;code&gt;connect = false&lt;/code&gt; オプションを使用して作成できます。その場合、リモートホストにはまったく接続されません。これはpg_dumpが使用するものです。その後、サブスクリプションをアクティブ化する前に、リモート複製スロットを手動で作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="34ca2fb6b711dd16e241f960cfce7ef591df396f" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the replication slot already exists. In that case, the subscription can be created using the &lt;code&gt;create_slot = false&lt;/code&gt; option to associate with the existing slot.</source>
          <target state="translated">サブスクリプションを作成するとき、レプリケーションスロットはすでに存在しています。その場合は、 &lt;code&gt;create_slot = false&lt;/code&gt; オプションを使用してサブスクリプションを作成し、既存のスロットに関連付けることができます。</target>
        </trans-unit>
        <trans-unit id="16abed6745cbdfc58355b822cc58590cd4574664" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the number of partitions on which the index has been completed.</source>
          <target state="translated">パーティショニングされたテーブルにインデックスを作成する場合、この列にはインデックスが完成したパーティショニングの数が設定されます。</target>
        </trans-unit>
        <trans-unit id="0cf84112606c62d754e9e14623f4cabe94d1c440" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the total number of partitions on which the index is to be created.</source>
          <target state="translated">パーティショニングされたテーブルにインデックスを作成する場合、この列にはインデックスを作成するパーティションの総数が設定されます。</target>
        </trans-unit>
        <trans-unit id="0f225feca5ba0ff2fa1c5fa9fb76ca1ce05ad30d" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, a &lt;code&gt;choose&lt;/code&gt; result of &lt;code&gt;spgMatchNode&lt;/code&gt; is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied &lt;code&gt;nodeN&lt;/code&gt; value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since that would make the nodes not all equivalent; the &lt;code&gt;spgSplitTuple&lt;/code&gt; action must be used if the value to be inserted doesn't match the existing nodes.</source>
          <target state="translated">扱う場合 &lt;code&gt;allTheSame&lt;/code&gt; のタプル、 &lt;code&gt;choose&lt;/code&gt; の結果 &lt;code&gt;spgMatchNode&lt;/code&gt; は、新しい値が同等のノードのいずれかに割り当てることができることを意味すると解釈されます。コアコードは、指定された &lt;code&gt;nodeN&lt;/code&gt; 値を無視し、ランダムにノードの1つに降ります（ツリーのバランスを保つため）。 &lt;code&gt;spgAddNode&lt;/code&gt; を返す &lt;code&gt;choose&lt;/code&gt; すると、ノードがすべて等価になるわけではないため、エラーになります。挿入する値が既存のノードと一致しない場合は、 &lt;code&gt;spgSplitTuple&lt;/code&gt; アクションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cc81dfaf2529806492d6926ee92f707f3d6c4c1b" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, the &lt;code&gt;inner_consistent&lt;/code&gt; function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the &lt;code&gt;inner_consistent&lt;/code&gt; function normally assumes about the meaning of the nodes.</source>
          <target state="translated">&lt;code&gt;allTheSame&lt;/code&gt; タプルを処理する場合、 &lt;code&gt;inner_consistent&lt;/code&gt; 関数は、すべてが同等であるため、インデックス検索を続行するためのターゲットとして、すべてのノードを返すか、ノードを返さないかを指定する必要があります。これは、 &lt;code&gt;inner_consistent&lt;/code&gt; 関数がノードの意味について通常想定する量に応じて、特別な場合のコードを必要とする場合と必要としない場合があります。</target>
        </trans-unit>
        <trans-unit id="b32b90019e8bbf81fee22cbcc2778aa7cfddfd6c" translate="yes" xml:space="preserve">
          <source>When dealing with multiple-argument aggregate functions, note that the &lt;code&gt;ORDER BY&lt;/code&gt; clause goes after all the aggregate arguments. For example, write this:</source>
          <target state="translated">複数引数の集約関数を処理する場合、 &lt;code&gt;ORDER BY&lt;/code&gt; 句はすべての集約引数の後にあることに注意してください。たとえば、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="ec8f5c244f8f3ee5e69ba2a3cc1d82f9a3714553" translate="yes" xml:space="preserve">
          <source>When dealing with outer joins, you might see join plan nodes with both &amp;ldquo;Join Filter&amp;rdquo; and plain &amp;ldquo;Filter&amp;rdquo; conditions attached. Join Filter conditions come from the outer join's &lt;code&gt;ON&lt;/code&gt; clause, so a row that fails the Join Filter condition could still get emitted as a null-extended row. But a plain Filter condition is applied after the outer-join rules and so acts to remove rows unconditionally. In an inner join there is no semantic difference between these types of filters.</source>
          <target state="translated">外部結合を処理するとき、「結合フィルター」条件とプレーンな「フィルター」条件の両方が付加された結合計画ノードが表示される場合があります。結合フィルター条件は外部結合の &lt;code&gt;ON&lt;/code&gt; 句から取得されるため、結合フィルター条件に失敗した行は、null拡張行として発行される可能性があります。ただし、単純なFilter条件は外部結合ルールの後に適用されるため、無条件に行を削除するように機能します。内部結合では、これらのタイプのフィルターの間に意味上の違いはありません。</target>
        </trans-unit>
        <trans-unit id="8a4bff252219a510e2ce0b73debb16a2f8ba45f1" translate="yes" xml:space="preserve">
          <source>When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: &lt;code&gt;bb*&lt;/code&gt; matches the three middle characters of &lt;code&gt;abbbc&lt;/code&gt;; &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; matches all ten characters of &lt;code&gt;weeknights&lt;/code&gt;; when &lt;code&gt;(.*).*&lt;/code&gt; is matched against &lt;code&gt;abc&lt;/code&gt; the parenthesized subexpression matches all three characters; and when &lt;code&gt;(a*)*&lt;/code&gt; is matched against &lt;code&gt;bc&lt;/code&gt; both the whole RE and the parenthesized subexpression match an empty string.</source>
          <target state="translated">一致の長さを決定するとき、一致の長さは照合要素ではなく文字で測定されます。空の文字列は、一致しないよりも長いと見なされます。例： &lt;code&gt;bb*&lt;/code&gt; は、 &lt;code&gt;abbbc&lt;/code&gt; の中間の3文字に一致します。 &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; は、 &lt;code&gt;weeknights&lt;/code&gt; 10文字すべてに一致します。とき &lt;code&gt;(.*).*&lt;/code&gt; 照合され &lt;code&gt;abc&lt;/code&gt; 、括弧内の部分式は、3つのすべての文字にマッチします。 &lt;code&gt;(a*)*&lt;/code&gt; が &lt;code&gt;bc&lt;/code&gt; と一致する場合、RE全体と括弧で囲まれた部分式の両方が空の文字列と一致します。</target>
        </trans-unit>
        <trans-unit id="f51f30bba3581f1e69eb69eac04311486d90890a" translate="yes" xml:space="preserve">
          <source>When defining the path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similar to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">パスを定義するときに、SQLの &lt;code&gt;WHERE&lt;/code&gt; 句と同様に機能する1つ以上の&lt;em&gt;フィルター式&lt;/em&gt;を使用することもできます。フィルター式は疑問符で始まり、括弧内に条件を提供します：</target>
        </trans-unit>
        <trans-unit id="359ea83f4fdb1b7fa655731f901be35273bbf743" translate="yes" xml:space="preserve">
          <source>When dropping a subscription that is associated with a replication slot on the remote host (the normal state), &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will connect to the remote host and try to drop the replication slot as part of its operation. This is necessary so that the resources allocated for the subscription on the remote host are released. If this fails, either because the remote host is not reachable or because the remote replication slot cannot be dropped or does not exist or never existed, the &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; command will fail. To proceed in this situation, disassociate the subscription from the replication slot by executing &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt;. After that, &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will no longer attempt any actions on a remote host. Note that if the remote replication slot still exists, it should then be dropped manually; otherwise it will continue to reserve WAL and might eventually cause the disk to fill up. See also &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;Section 30.2.1&lt;/a&gt;.</source>
          <target state="translated">リモートホストのレプリケーションスロットに関連付けられているサブスクリプションを削除すると（通常の状態）、 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; はリモートホストに接続し、その操作の一部としてレプリケーションスロットを削除しようとします。これは、リモートホストのサブスクリプションに割り当てられたリソースを解放するために必要です。これが失敗した場合、リモートホストに到達できないか、リモートレプリケーションスロットを削除できないか、存在しないか存在しなかったため、 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; コマンドは失敗します。この状況で続行するには、 &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt; 実行して、サブスクリプションとレプリケーションスロットの関連付けを解除します。その後、 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; リモートホストでのアクションは試行されなくなります。リモート複製スロットがまだ存在する場合は、手動で削除する必要があることに注意してください。そうしないと、WALが予約され続け、最終的にディスクがいっぱいになる可能性があります。&lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;セクション30.2.1&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="16b8b09fc04797b1f4bd77cb938d65220f3c98d4" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the remote host is not reachable. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription. If the remote database instance no longer exists, no further action is then necessary. If, however, the remote database instance is just unreachable, the replication slot should then be dropped manually; otherwise it would continue to reserve WAL and might eventually cause the disk to fill up. Such cases should be carefully investigated.</source>
          <target state="translated">サブスクリプションを削除すると、リモートホストに到達できなくなります。その場合、サブスクリプションを削除する前に、 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; を使用してスロットとサブスクリプションの関連付けを解除してください。リモートデータベースインスタンスが存在しない場合、それ以上のアクションは必要ありません。ただし、リモートデータベースインスタンスに到達できない場合は、レプリケーションスロットを手動で削除する必要があります。そうしないと、WALが予約され続け、最終的にディスクがいっぱいになる可能性があります。そのような場合は注意深く調査する必要があります。</target>
        </trans-unit>
        <trans-unit id="aef261ef51923658a5c92b355545488277ab638d" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the replication slot should be kept. This could be useful when the subscriber database is being moved to a different host and will be activated from there. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription.</source>
          <target state="translated">サブスクリプションを削除するときは、レプリケーションスロットを保持する必要があります。これは、サブスクライバーデータベースが別のホストに移動され、そこからアクティブ化される場合に役立ちます。その場合、サブスクリプションを削除する前に、 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; を使用してスロットとサブスクリプションの関連付けを解除してください。</target>
        </trans-unit>
        <trans-unit id="7012bb7adb09426a92f880209bcb563fe9379138" translate="yes" xml:space="preserve">
          <source>When dumping data for a table partition, make the &lt;code&gt;COPY&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt; statements target the root of the partitioning hierarchy that contains it, rather than the partition itself. This causes the appropriate partition to be re-determined for each row when the data is loaded. This may be useful when reloading data on a server where rows do not always fall into the same partitions as they did on the original server. That could happen, for example, if the partitioning column is of type text and the two systems have different definitions of the collation used to sort the partitioning column.</source>
          <target state="translated">テーブルパーティションのデータをダンプするときは、 &lt;code&gt;COPY&lt;/code&gt; ステートメントまたは &lt;code&gt;INSERT&lt;/code&gt; ステートメントが、パーティション自体ではなく、それを含むパーティション階層のルートを対象とするようにします。これにより、データが読み込まれるときに、行ごとに適切なパーティションが再決定されます。これは、行が常に元のサーバーと同じパーティションに分類されるとは限らないサーバーでデータを再ロードする場合に役立ちます。たとえば、パーティション化列のタイプがテキストであり、2つのシステムでパーティション化列のソートに使用される照合の定義が異なる場合に、これが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b3c4665e18254fa2583d0b9a6ca4200ef73e4faf" translate="yes" xml:space="preserve">
          <source>When dumping logical replication subscriptions, pg_dump will generate &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; commands that use the &lt;code&gt;connect = false&lt;/code&gt; option, so that restoring the subscription does not make remote connections for creating a replication slot or for initial table copy. That way, the dump can be restored without requiring network access to the remote servers. It is then up to the user to reactivate the subscriptions in a suitable way. If the involved hosts have changed, the connection information might have to be changed. It might also be appropriate to truncate the target tables before initiating a new full table copy.</source>
          <target state="translated">論理レプリケーションサブスクリプションをダンプするとき、pg_dumpは、 &lt;code&gt;connect = false&lt;/code&gt; オプションを使用する &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; コマンドを生成します。そのため、サブスクリプションを復元しても、レプリケーションスロットの作成や初期テーブルコピーのためのリモート接続は行われません。このようにして、リモートサーバーへのネットワークアクセスを必要とせずに、ダンプを復元できます。その後、適切な方法でサブスクリプションを再アクティブ化するのはユーザー次第です。関連するホストが変更された場合、接続情報を変更する必要がある場合があります。新しい全表コピーを開始する前に、ターゲット表を切り捨てることも適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="edeac7aa265daa84ac15a79b57465693d865b8ff" translate="yes" xml:space="preserve">
          <source>When either stderr or csvlog are included, the file &lt;code&gt;current_logfiles&lt;/code&gt; is created to record the location of the log file(s) currently in use by the logging collector and the associated logging destination. This provides a convenient way to find the logs currently in use by the instance. Here is an example of this file's content:</source>
          <target state="translated">stderrまたはcsvlogのいずれかが含まれている場合、ファイル &lt;code&gt;current_logfiles&lt;/code&gt; が作成され、ロギングコレクターと関連するロギング先で現在使用されているログファイルの場所が記録されます。これにより、インスタンスで現在使用されているログを簡単に見つけることができます。このファイルのコンテンツの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="0bf7e84c79ef7d8674ff36f5bd69afa904df5b94" translate="yes" xml:space="preserve">
          <source>When encrypting with a public key:</source>
          <target state="translated">公開鍵で暗号化する場合</target>
        </trans-unit>
        <trans-unit id="d8c4c4accb682e67b5f8b1813c77704fe93cbcb0" translate="yes" xml:space="preserve">
          <source>When encrypting with a symmetric key (i.e., a password):</source>
          <target state="translated">対称鍵(つまりパスワード)で暗号化する場合。</target>
        </trans-unit>
        <trans-unit id="db0cd6f3816a8188a89deee57f710a1baaa98cf3" translate="yes" xml:space="preserve">
          <source>When entering &lt;code&gt;bytea&lt;/code&gt; values in escape format, octets of certain values &lt;em&gt;must&lt;/em&gt; be escaped, while all octet values &lt;em&gt;can&lt;/em&gt; be escaped. In general, to escape an octet, convert it into its three-digit octal value and precede it by a backslash. Backslash itself (octet decimal value 92) can alternatively be represented by double backslashes. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; shows the characters that must be escaped, and gives the alternative escape sequences where applicable.</source>
          <target state="translated">エスケープ形式で &lt;code&gt;bytea&lt;/code&gt; 値を入力する場合、特定の値のオクテットはエスケープする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ますが、すべてのオクテット値&lt;em&gt;は&lt;/em&gt;エスケープ&lt;em&gt;でき&lt;/em&gt;ます。一般に、オクテットをエスケープするには、それを3桁の8進数値に変換し、その前にバックスラッシュを付けます。バックスラッシュ自体（10進数のオクテット値92）は、ダブルバックスラッシュで表すこともできます。&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7&lt;/a&gt;は、エスケープする必要がある文字を示し、該当する場合は代替のエスケープシーケンスを示します。</target>
        </trans-unit>
        <trans-unit id="0b723af7e86ecb6fa9f1f4fcf436b5692ddd09fd" translate="yes" xml:space="preserve">
          <source>When establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.</source>
          <target state="translated">複数レベルのパーティション階層に一意の制約を設定する場合、ターゲット・パーティション・テーブルのパーティション・キー内のすべての列と、その子孫のすべてのパーティション・テーブルの列を制約の定義に含めなければなりません。</target>
        </trans-unit>
        <trans-unit id="5828ba22818bd784c0d1de682badc9fdcf5283f1" translate="yes" xml:space="preserve">
          <source>When estimating the selectivity, the planner applies all the conditions on items in the MCV list, and then sums the frequencies of the matching ones. See &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; in &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; for details.</source>
          <target state="translated">選択性を推定するとき、プランナーはMCVリストの項目にすべての条件を適用し、一致するものの頻度を合計します。詳細 &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; は、 &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; のmcv_clauselist_selectivityを参照してください。</target>
        </trans-unit>
        <trans-unit id="716da7567a674fa423040a77262890c91b3b1491" translate="yes" xml:space="preserve">
          <source>When estimating with functional dependencies, the planner assumes that conditions on the involved columns are compatible and hence redundant. If they are incompatible, the correct estimate would be zero rows, but that possibility is not considered. For example, given a query like</source>
          <target state="translated">関数依存関係を使用して推定する場合、プランナーは、関係する列の条件が互換性があり、したがって冗長であることを前提としている。両者が互換性がない場合、正しい推定値は0行になりますが、その可能性は考慮されません。例えば、以下のようなクエリがあるとします。</target>
        </trans-unit>
        <trans-unit id="064d226f0b61cda9a60ca08881b4d97cee01ca7a" translate="yes" xml:space="preserve">
          <source>When executed on a primary, the function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. The return value is the backup's ending write-ahead log location (which again can be ignored). After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">この機能を1次サーバーで実行すると、先行書き込みログのアーカイブ領域にバックアップ履歴ファイルも作成されます。履歴ファイルには、 &lt;code&gt;pg_start_backup&lt;/code&gt; に付与されたラベル、バックアップの開始および終了先書きログの場所、バックアップの開始および終了時間が含まれます。戻り値は、バックアップの最後の先行書き込みログの場所です（これも無視できます）。終了位置を記録した後、現在の先行ログ挿入ポイントは自動的に次の先行ログファイルに進められるため、終了先行ログファイルをすぐにアーカイブしてバックアップを完了することができます。</target>
        </trans-unit>
        <trans-unit id="b575c812fb039c331ed73bad6b9599e79ed09b9b" translate="yes" xml:space="preserve">
          <source>When executed, the example D script gives output such as:</source>
          <target state="translated">D スクリプトの例を実行すると、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="9b9cbbd3bd8e290879a575143872c711e1071acb" translate="yes" xml:space="preserve">
          <source>When executing a parallel plan, you can use &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; to display per-worker statistics for each plan node. This may be useful in determining whether the work is being evenly distributed between all plan nodes and more generally in understanding the performance characteristics of the plan.</source>
          <target state="translated">並列プランを実行する場合、 &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; を使用して、各プランノードのワーカーごとの統計を表示できます。これは、作業がすべての計画ノード間で均等に分散されているかどうかを判別する場合、およびより一般的には計画のパフォーマンス特性を理解する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f5c9db9afb12cc927dcae6f85bc0fefc8f88ecba" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion so as its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">最近昇格したソースとしてオンラインクラスターを使用してpg_rewindを実行する場合は、昇格後に &lt;code&gt;CHECKPOINT&lt;/code&gt; を実行する必要があります。これにより、制御ファイルに最新のタイムライン情報が反映されるため、pg_rewindでターゲットクラスターが使用できるかどうかを確認できます。指定されたソースクラスタを使用して巻き戻します。</target>
        </trans-unit>
        <trans-unit id="45578e8de56cf79c1bab7717b9b7f3794e4ce080" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source, a role having sufficient permissions to execute the functions used by pg_rewind on the source cluster can be used instead of a superuser. Here is how to create such a role, named &lt;code&gt;rewind_user&lt;/code&gt; here:</source>
          <target state="translated">ソースとしてオンラインクラスターを使用してpg_rewindを実行する場合、スーパーユーザーの代わりに、ソースクラスターでpg_rewindによって使用される関数を実行するための十分な権限を持つロールを使用できます。ここでは、 &lt;code&gt;rewind_user&lt;/code&gt; という名前のこのようなロールを作成する方法を示します。</target>
        </trans-unit>
        <trans-unit id="9d8da664aa55aa1d9ba572665740c9977324d898" translate="yes" xml:space="preserve">
          <source>When false, the command will not try to refresh table information. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; should then be executed separately. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">falseの場合、コマンドはテーブル情報を更新しようとしません。次に、 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; を個別に実行する必要があります。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d12b7ebd6720c102addd509acf7a1b3a9bca1905" translate="yes" xml:space="preserve">
          <source>When host names are specified in &lt;code&gt;pg_hba.conf&lt;/code&gt;, you should make sure that name resolution is reasonably fast. It can be of advantage to set up a local name resolution cache such as &lt;code&gt;nscd&lt;/code&gt;. Also, you may wish to enable the configuration parameter &lt;code&gt;log_hostname&lt;/code&gt; to see the client's host name instead of the IP address in the log.</source>
          <target state="translated">ホスト名が &lt;code&gt;pg_hba.conf&lt;/code&gt; で指定されている場合、名前解決がかなり高速であることを確認する必要があります。 &lt;code&gt;nscd&lt;/code&gt; などのローカルの名前解決キャッシュを設定すると便利です。また、構成パラメーター &lt;code&gt;log_hostname&lt;/code&gt; を有効にして、ログでIPアドレスの代わりにクライアントのホスト名を表示することもできます。</target>
        </trans-unit>
        <trans-unit id="72b7c985f760c5c9e2832f32ef829164b2539557" translate="yes" xml:space="preserve">
          <source>When ident is specified for a local (non-TCP/IP) connection, peer authentication (see &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt;) will be used instead.</source>
          <target state="translated">ローカル（非TCP / IP）接続にidentが指定されている場合、代わりにピア認証（&lt;a href=&quot;auth-peer&quot;&gt;セクション20.9を&lt;/a&gt;参照）が使用されます。</target>
        </trans-unit>
        <trans-unit id="81c1aa17a38d25550246efe2b31fe8f5cb3b0dba" translate="yes" xml:space="preserve">
          <source>When indexes are not used, it can be useful for testing to force their use. There are run-time parameters that can turn off various plan types (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;). For instance, turning off sequential scans (&lt;code&gt;enable_seqscan&lt;/code&gt;) and nested-loop joins (&lt;code&gt;enable_nestloop&lt;/code&gt;), which are the most basic plans, will force the system to use a different plan. If the system still chooses a sequential scan or nested-loop join then there is probably a more fundamental reason why the index is not being used; for example, the query condition does not match the index. (What kind of query can use what kind of index is explained in the previous sections.)</source>
          <target state="translated">インデックスが使用されていない場合は、テストでそれらを強制的に使用するのに役立ちます。さまざまな種類のプランをオフにできるランタイムパラメータがあります（&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;セクション19.7.1を&lt;/a&gt;参照）。たとえば、最も基本的なプランである順次スキャン（ &lt;code&gt;enable_seqscan&lt;/code&gt; ）とネストループ結合（ &lt;code&gt;enable_nestloop&lt;/code&gt; ）をオフにすると、システムは強制的に別のプランを使用します。それでもシステムが順次スキャンまたはネストループ結合を選択する場合、おそらくインデックスが使用されていないより根本的な理由があります。たとえば、クエリ条件がインデックスと一致しません。 （前のセクションで説明した種類のインデックスを使用できるクエリの種類）。</target>
        </trans-unit>
        <trans-unit id="9e50d0004d8680329345366b2774f5ebb4ad654f" translate="yes" xml:space="preserve">
          <source>When inserting a lot of data at the same time, consider using the &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. It is not as flexible as the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command, but is more efficient. Refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt; for more information on improving bulk loading performance.</source>
          <target state="translated">大量のデータを同時に挿入する場合は、&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;コマンドの使用を検討してください。&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;コマンドほど柔軟ではありませんが、より効率的です。バルクロードのパフォーマンスを向上させる方法の詳細については、&lt;a href=&quot;populate&quot;&gt;セクション14.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dfb95bd9b76a1aa6b1bb1f21c135d8d5ba87cb03" translate="yes" xml:space="preserve">
          <source>When issuing queries in a database where some users mistrust other users, observe security precautions from &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt; when writing function calls.</source>
          <target state="translated">一部のユーザーが他のユーザーを信頼していないデータベースでクエリを発行する場合は、関数呼び出しを作成するときに、&lt;a href=&quot;typeconv-func&quot;&gt;セクション10.3の&lt;/a&gt;セキュリティ対策を守ってください。</target>
        </trans-unit>
        <trans-unit id="4ed9176dec0c08e99a6d40ec733c0b7bac5bbcf2" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.17&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">評価順序を強制する必要がある場合は、 &lt;code&gt;CASE&lt;/code&gt; 構文（&lt;a href=&quot;functions-conditional&quot;&gt;セクション9.17を&lt;/a&gt;参照）を使用できます。たとえば、これは &lt;code&gt;WHERE&lt;/code&gt; 句でゼロによる除算を回避しようとする信頼できない方法です。</target>
        </trans-unit>
        <trans-unit id="d43ae9852bbd4e7fca0407119c0359f8ae17da03" translate="yes" xml:space="preserve">
          <source>When loading large amounts of data into an installation that uses WAL archiving or streaming replication, it might be faster to take a new base backup after the load has completed than to process a large amount of incremental WAL data. To prevent incremental WAL logging while loading, disable archiving and streaming replication, by setting &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; to &lt;code&gt;minimal&lt;/code&gt;, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;, and &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; to zero. But note that changing these settings requires a server restart.</source>
          <target state="translated">WALアーカイブまたはストリーミングレプリケーションを使用するインストールに大量のデータをロードする場合、大量の増分WALデータを処理するよりも、ロードの完了後に新しい基本バックアップを作成する方が速い場合があります。ロード中の増分WALロギングを防ぐには、&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt;を &lt;code&gt;minimal&lt;/code&gt; に、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt;を &lt;code&gt;off&lt;/code&gt; に、&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt;をゼロに設定して、アーカイブおよびストリーミングレプリケーションを無効にします。ただし、これらの設定を変更すると、サーバーを再起動する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a320947bd6f8b1714ed336d766e812f876be824d" translate="yes" xml:space="preserve">
          <source>When logging to event log is enabled, this parameter determines the program name used to identify PostgreSQL messages in the log. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">イベントログへのロギングが有効な場合、このパラメーターは、ログ内のPostgreSQLメッセージを識別するために使用されるプログラム名を決定します。デフォルトは &lt;code&gt;PostgreSQL&lt;/code&gt; です。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="688b202e83ca61ee5187e2a33b6d2092af8c2739" translate="yes" xml:space="preserve">
          <source>When logging to syslog and this is on (the default), then each message will be prefixed by an increasing sequence number (such as &lt;code&gt;[2]&lt;/code&gt;). This circumvents the &amp;ldquo;--- last message repeated N times ---&amp;rdquo; suppression that many syslog implementations perform by default. In more modern syslog implementations, repeated message suppression can be configured (for example, &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; in rsyslog), so this might not be necessary. Also, you could turn this off if you actually want to suppress repeated messages.</source>
          <target state="translated">syslogにログを記録し、これがオン（デフォルト）の場合、各メッセージの先頭には、増加するシーケンス番号（ &lt;code&gt;[2]&lt;/code&gt; など）が付けられます。これにより、多くのsyslog実装がデフォルトで実行する「---最後のメッセージがN回繰り返される---」抑制が回避されます。最新のsyslog実装では、メッセージの繰り返し抑制を構成できるため（たとえば、rsyslogの &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; ）、これは必要ない場合があります。また、実際に繰り返されるメッセージを抑制したい場合は、これをオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="ba8a396481d44a42fb2aa24b4ad06150638300e9" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines how messages are delivered to syslog. When on (the default), messages are split by lines, and long lines are split so that they will fit into 1024 bytes, which is a typical size limit for traditional syslog implementations. When off, PostgreSQL server log messages are delivered to the syslog service as is, and it is up to the syslog service to cope with the potentially bulky messages.</source>
          <target state="translated">syslogへのロギングが有効な場合、このパラメータはsyslogへのメッセージの配信方法を決定します。オン(デフォルト)の場合、メッセージは行ごとに分割され、長い行は1024バイトに収まるように分割されます。オフの場合、PostgreSQLサーバのログメッセージはそのままsyslogサービスに配信されます。</target>
        </trans-unit>
        <trans-unit id="80ff0840aef3199452ea4eb2990b10a8d1c55939" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the program name used to identify PostgreSQL messages in syslog logs. The default is &lt;code&gt;postgres&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">syslogへのロギングが有効な場合、このパラメーターは、syslogログでPostgreSQLメッセージを識別するために使用されるプログラム名を決定します。デフォルトは &lt;code&gt;postgres&lt;/code&gt; です。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="985b03993881f4457d8f0c3b34d9b7b01342f4d8" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the syslog &amp;ldquo;facility&amp;rdquo; to be used. You can choose from &lt;code&gt;LOCAL0&lt;/code&gt;, &lt;code&gt;LOCAL1&lt;/code&gt;, &lt;code&gt;LOCAL2&lt;/code&gt;, &lt;code&gt;LOCAL3&lt;/code&gt;, &lt;code&gt;LOCAL4&lt;/code&gt;, &lt;code&gt;LOCAL5&lt;/code&gt;, &lt;code&gt;LOCAL6&lt;/code&gt;, &lt;code&gt;LOCAL7&lt;/code&gt;; the default is &lt;code&gt;LOCAL0&lt;/code&gt;. See also the documentation of your system's syslog daemon. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">syslogへのロギングが有効になっている場合、このパラメーターは、使用されるsyslogの「ファシリティ」を決定します。 &lt;code&gt;LOCAL0&lt;/code&gt; 、 &lt;code&gt;LOCAL1&lt;/code&gt; 、 &lt;code&gt;LOCAL2&lt;/code&gt; 、 &lt;code&gt;LOCAL3&lt;/code&gt; 、 &lt;code&gt;LOCAL4&lt;/code&gt; 、 &lt;code&gt;LOCAL5&lt;/code&gt; 、 &lt;code&gt;LOCAL6&lt;/code&gt; 、 &lt;code&gt;LOCAL7&lt;/code&gt; から選択できます。デフォルトは &lt;code&gt;LOCAL0&lt;/code&gt; です。システムのsyslogデーモンのドキュメントも参照してください。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="b30985843aab3e94f2bd3bce331e8a5523cabcbb" translate="yes" xml:space="preserve">
          <source>When more than one expression is specified, the later values are used to sort rows that are equal according to the earlier values. Each expression can be followed by an optional &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; keyword to set the sort direction to ascending or descending. &lt;code&gt;ASC&lt;/code&gt; order is the default. Ascending order puts smaller values first, where &amp;ldquo;smaller&amp;rdquo; is defined in terms of the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. Similarly, descending order is determined with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">複数の式を指定すると、後の値を使用して、前の値に従って等しい行をソートします。各式の後にオプションの &lt;code&gt;ASC&lt;/code&gt; または &lt;code&gt;DESC&lt;/code&gt; キーワードを続けて、ソート方向を昇順または降順に設定できます。 &lt;code&gt;ASC&lt;/code&gt; オーダーがデフォルトです。昇順では小さい値が最初に配置され、「小さい」は &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子で定義されます。同様に、降順は &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子で決定されます。&lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11912d8e839cffb71f2e5fc45344859e046a9cbc" translate="yes" xml:space="preserve">
          <source>When more than one row is specified, all the rows must have the same number of elements. The data types of the resulting table's columns are determined by combining the explicit or inferred types of the expressions appearing in that column, using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="translated">複数の行を指定する場合、すべての行の要素数は同じでなければなりません。結果のテーブルの列のデータ型は、 &lt;code&gt;UNION&lt;/code&gt; と同じルールを使用して、その列に現れる式の明示的な型または推論された型を組み合わせることによって決定されます（&lt;a href=&quot;typeconv-union-case&quot;&gt;セクション10.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="dcff81a7a0194a63301c74dc5ce189cffc265222" translate="yes" xml:space="preserve">
          <source>When multiple policies apply to a given query, they are combined using either &lt;code&gt;OR&lt;/code&gt; (for permissive policies, which are the default) or using &lt;code&gt;AND&lt;/code&gt; (for restrictive policies). This is similar to the rule that a given role has the privileges of all roles that they are a member of. Permissive vs. restrictive policies are discussed further below.</source>
          <target state="translated">複数のポリシーが特定のクエリに適用される場合、それらは &lt;code&gt;OR&lt;/code&gt; （デフォルトの寛容なポリシーの場合）または &lt;code&gt;AND&lt;/code&gt; （制限的なポリシーの場合）を使用して結合されます。これは、特定のロールがメンバーであるすべてのロールの特権を持つというルールに似ています。許容ポリシーと制限ポリシーについては、以下で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="269b9ef4adee76f3240604e5767201bc6ee01e71" translate="yes" xml:space="preserve">
          <source>When multiple policies of different command types apply to the same command (for example, &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; policies applied to an &lt;code&gt;UPDATE&lt;/code&gt; command), then the user must have both types of permissions (for example, permission to select rows from the relation as well as permission to update them). Thus the expressions for one type of policy are combined with the expressions for the other type of policy using the &lt;code&gt;AND&lt;/code&gt; operator.</source>
          <target state="translated">異なるコマンドタイプの複数のポリシーが同じコマンドに適用される場合（たとえば、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドに適用される &lt;code&gt;SELECT&lt;/code&gt; および &lt;code&gt;UPDATE&lt;/code&gt; ポリシー）、ユーザーは両方のタイプの権限（たとえば、リレーションから行を選択する権限と、それらを更新する権限）。したがって、あるタイプのポリシーの式は、 &lt;code&gt;AND&lt;/code&gt; 演算子を使用して、他のタイプのポリシーの式と組み合わされます。</target>
        </trans-unit>
        <trans-unit id="556057cb09a8742cb36bd19c1657e03ac61a815b" translate="yes" xml:space="preserve">
          <source>When multiple policies of the same command type apply to the same command, then there must be at least one &lt;code&gt;PERMISSIVE&lt;/code&gt; policy granting access to the relation, and all of the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policies must pass. Thus all the &lt;code&gt;PERMISSIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;OR&lt;/code&gt;, all the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;AND&lt;/code&gt;, and the results are combined using &lt;code&gt;AND&lt;/code&gt;. If there are no &lt;code&gt;PERMISSIVE&lt;/code&gt; policies, then access is denied.</source>
          <target state="translated">同じコマンドタイプの複数のポリシーが同じコマンドに適用される場合、関係へのアクセスを許可する少なくとも1つの &lt;code&gt;PERMISSIVE&lt;/code&gt; ポリシーが必要であり、すべての &lt;code&gt;RESTRICTIVE&lt;/code&gt; ポリシーがパスする必要があります。したがって、すべての &lt;code&gt;PERMISSIVE&lt;/code&gt; ポリシー式は &lt;code&gt;OR&lt;/code&gt; を使用して結合され、すべての &lt;code&gt;RESTRICTIVE&lt;/code&gt; ポリシー式は &lt;code&gt;AND&lt;/code&gt; を使用して結合され、結果は &lt;code&gt;AND&lt;/code&gt; を使用して結合されます。 &lt;code&gt;PERMISSIVE&lt;/code&gt; ポリシーがない場合、アクセスは拒否されます。</target>
        </trans-unit>
        <trans-unit id="5d6d15be5ddf45a51b853b506d5d1a1d2068106c" translate="yes" xml:space="preserve">
          <source>When multiple window functions are used, all the window functions having syntactically equivalent &lt;code&gt;PARTITION BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; clauses in their window definitions are guaranteed to be evaluated in a single pass over the data. Therefore they will see the same sort ordering, even if the &lt;code&gt;ORDER BY&lt;/code&gt; does not uniquely determine an ordering. However, no guarantees are made about the evaluation of functions having different &lt;code&gt;PARTITION BY&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; specifications. (In such cases a sort step is typically required between the passes of window function evaluations, and the sort is not guaranteed to preserve ordering of rows that its &lt;code&gt;ORDER BY&lt;/code&gt; sees as equivalent.)</source>
          <target state="translated">複数のウィンドウ関数を使用する場合、構文的に同等の &lt;code&gt;PARTITION BY&lt;/code&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 句とORDER BY句をウィンドウ定義に持つすべてのウィンドウ関数は、データに対する単一パスで評価されることが保証されます。したがって、 &lt;code&gt;ORDER BY&lt;/code&gt; が順序を一意に決定しなくても、同じソート順序が表示されます。ただし、 &lt;code&gt;PARTITION BY&lt;/code&gt; または &lt;code&gt;ORDER BY&lt;/code&gt; の仕様が異なる関数の評価については保証されません。 （このような場合、通常、ウィンドウ関数の評価のパス間で並べ替え手順が必要です。並べ替えは、その &lt;code&gt;ORDER BY&lt;/code&gt; が同等と見なす行の順序を保持することが保証されていません。）</target>
        </trans-unit>
        <trans-unit id="34f31d5224ac605a926f4e92907e12ec5add9474" translate="yes" xml:space="preserve">
          <source>When multiple workers are running, the autovacuum cost delay parameters (see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt;) are &amp;ldquo;balanced&amp;rdquo; among all the running workers, so that the total I/O impact on the system is the same regardless of the number of workers actually running. However, any workers processing tables whose per-table &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; or &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; storage parameters have been set are not considered in the balancing algorithm.</source>
          <target state="translated">複数のワーカーが実行されている場合、自動バキュームコスト遅延パラメーター（&lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;セクション19.4.4を&lt;/a&gt;参照）は実行中のすべてのワーカー間で「バランスがとれ」ているため、システムへのI / Oの影響は、実際に実行されているワーカーの数に関係なく同じです。 。ただし、テーブルごとに &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; または &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; ストレージパラメータが設定されているテーブルを処理するワーカーは、バランシングアルゴリズムでは考慮されません。</target>
        </trans-unit>
        <trans-unit id="84f11ff5e7225ec364ea450b05da5b31bd525923" translate="yes" xml:space="preserve">
          <source>When no final &lt;code&gt;ELSE&lt;/code&gt; clause is provided to a &lt;code&gt;CASE&lt;/code&gt;, the default value is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; に最後の &lt;code&gt;ELSE&lt;/code&gt; 句が指定されていない場合、デフォルト値は &lt;code&gt;NULL&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cb2d002b299026c6a8e3abc29ae594e572a6b112" translate="yes" xml:space="preserve">
          <source>When non-serializable writes are possible, to ensure the current validity of a row and protect it against concurrent updates one must use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or an appropriate &lt;code&gt;LOCK TABLE&lt;/code&gt; statement. (&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; lock just the returned rows against concurrent updates, while &lt;code&gt;LOCK TABLE&lt;/code&gt; locks the whole table.) This should be taken into account when porting applications to PostgreSQL from other environments.</source>
          <target state="translated">シリアライズ不可能な書き込みが可能な場合、行の現在の有効性を保証し、同時更新から保護するには、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 、 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 、または適切な &lt;code&gt;LOCK TABLE&lt;/code&gt; ステートメントを使用する必要があります。 （ &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; と &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; は、同時更新に対して返された行だけをロックしますが、 &lt;code&gt;LOCK TABLE&lt;/code&gt; はテーブル全体をロックします。）これは、アプリケーションを他の環境からPostgreSQLに移植するときに考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="8d5d4ed5a8f5b52f15315d7a651b9128c1d498f8" translate="yes" xml:space="preserve">
          <source>When not all owned objects are to be transferred to the same successor owner, it's best to handle the exceptions manually and then perform the above steps to mop up.</source>
          <target state="translated">所有しているすべてのオブジェクトを同じ後継者に譲渡しない場合は、例外を手動で処理してから上記の手順を実行してモップアップするのがベストです。</target>
        </trans-unit>
        <trans-unit id="ed8afcb65f27d90b88c36a924e96931352e55b61" translate="yes" xml:space="preserve">
          <source>When not using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, the &lt;code&gt;column_definition&lt;/code&gt; list replaces the column alias list that could otherwise be attached to the &lt;code&gt;FROM&lt;/code&gt; item; the names in the column definitions serve as column aliases. When using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, a &lt;code&gt;column_definition&lt;/code&gt; list can be attached to each member function separately; or if there is only one member function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause, a &lt;code&gt;column_definition&lt;/code&gt; list can be written in place of a column alias list following &lt;code&gt;ROWS FROM()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ROWS FROM()&lt;/code&gt; 構文を使用しない場合、 &lt;code&gt;column_definition&lt;/code&gt; リストは、 &lt;code&gt;FROM&lt;/code&gt; アイテムにアタッチできる列のエイリアスリストを置き換えます。列定義の名前は列のエイリアスとして機能します。 &lt;code&gt;ROWS FROM()&lt;/code&gt; 構文を使用する場合、 &lt;code&gt;column_definition&lt;/code&gt; リストを各メンバー関数に個別にアタッチできます。または、メンバー関数が1つだけあり、 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 句がない場合は、 &lt;code&gt;ROWS FROM()&lt;/code&gt; の後に列エイリアスリストの代わりに &lt;code&gt;column_definition&lt;/code&gt; リストを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="89c266fb8eeefdc22c382f51ddfa36d2cdf3fd08" translate="yes" xml:space="preserve">
          <source>When objects are created without specifying a particular target schema, they will be placed in the first valid schema named in &lt;code&gt;search_path&lt;/code&gt;. An error is reported if the search path is empty.</source>
          <target state="translated">特定のターゲットスキーマを指定せずにオブジェクトを作成すると、オブジェクトは &lt;code&gt;search_path&lt;/code&gt; で指定された最初の有効なスキーマに配置されます。検索パスが空の場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="99ff2ff0bf302907b157207503609b9e0138a5a9" translate="yes" xml:space="preserve">
          <source>When on, a warning is issued if a backslash (&lt;code&gt;\&lt;/code&gt;) appears in an ordinary string literal (&lt;code&gt;'...'&lt;/code&gt; syntax) and &lt;code&gt;standard_conforming_strings&lt;/code&gt; is off. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">オンの場合、通常の文字列リテラル（ &lt;code&gt;'...'&lt;/code&gt; 構文）にバックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）があり、 &lt;code&gt;standard_conforming_strings&lt;/code&gt; がオフの場合、警告が発行されます。デフォルトは &lt;code&gt;on&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a39a26ef7d5c306f15cfec242fa1908a71ae3775" translate="yes" xml:space="preserve">
          <source>When on, expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; (or &lt;code&gt;NULL = expr&lt;/code&gt;) are treated as &lt;code&gt;expr IS NULL&lt;/code&gt;, that is, they return true if &lt;code&gt;expr&lt;/code&gt; evaluates to the null value, and false otherwise. The correct SQL-spec-compliant behavior of &lt;code&gt;expr = NULL&lt;/code&gt; is to always return null (unknown). Therefore this parameter defaults to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">オンの場合、 &lt;code&gt;expr = NULL&lt;/code&gt; （または &lt;code&gt;NULL = expr&lt;/code&gt; ）の形式の式は &lt;code&gt;expr IS NULL&lt;/code&gt; として扱われます。つまり、 &lt;code&gt;expr&lt;/code&gt; がnull値に評価される場合はtrueを返し、それ以外の場合はfalse を返します。 &lt;code&gt;expr = NULL&lt;/code&gt; の正しいSQL仕様準拠の動作は、常にnull（不明）を返すことです。したがって、このパラメーターのデフォルトは &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bd83814e734e8771d44c1de9842876866f19a1c6" translate="yes" xml:space="preserve">
          <source>When on, the parser will emit a warning for any construct that might have changed meanings since PostgreSQL 9.4 as a result of changes in operator precedence. This is useful for auditing applications to see if precedence changes have broken anything; but it is not meant to be kept turned on in production, since it will warn about some perfectly valid, standard-compliant SQL code. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">オンにすると、演算子の優先順位の変更の結果としてPostgreSQL 9.4以降に意味が変更された可能性のあるすべての構文に対して、パーサーは警告を発行します。これは、優先順位の変更によって何かが壊れていないかどうかをアプリケーションを監査するのに役立ちます。ただし、完全に有効な標準に準拠したSQLコードについて警告するため、本番環境で有効にしておくことは意図されていません。デフォルトは &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f61f3e69afe30c64a291d60390d7c29326445c47" translate="yes" xml:space="preserve">
          <source>When operators and support functions are added to a family with &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;, they are not part of any specific operator class within the family, but are just &amp;ldquo;loose&amp;rdquo; within the family. This indicates that these operators and functions are compatible with the family's semantics, but are not required for correct functioning of any specific index. (Operators and functions that are so required should be declared as part of an operator class, instead; see &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS&lt;/a&gt;.) PostgreSQL will allow loose members of a family to be dropped from the family at any time, but members of an operator class cannot be dropped without dropping the whole class and any indexes that depend on it. Typically, single-data-type operators and functions are part of operator classes because they are needed to support an index on that specific data type, while cross-data-type operators and functions are made loose members of the family.</source>
          <target state="translated">演算子とサポート関数が &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; を使用してファミリに追加された場合、それらはファミリ内の特定の演算子クラスの一部ではなく、ファミリ内で「ルーズ」になっています。これは、これらの演算子と関数がファミリのセマンティクスと互換性があることを示していますが、特定のインデックスを正しく機能させるためには必要ありません。 （必要な演算子と関数は、代わりに演算子クラスの一部として宣言する必要があります&lt;a href=&quot;sql-createopclass&quot;&gt;。CREATEOPERATOR CLASSを&lt;/a&gt;参照してください。。）PostgreSQLでは、ファミリーの緩いメンバーをファミリーからいつでも削除できますが、演算子クラスのメンバーは、クラス全体とそれに依存するインデックスを削除しないと削除できません。通常、単一のデータ型の演算子と関数は、特定のデータ型のインデックスをサポートする必要があるため、演算子クラスの一部ですが、クロスデータ型の演算子と関数は、ファミリーの緩いメンバーになります。</target>
        </trans-unit>
        <trans-unit id="0f2ad4b5a54137b2f0c70ae82420f67c0b1b6ea3" translate="yes" xml:space="preserve">
          <source>When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table.</source>
          <target state="translated">クエリや更新が単一パーティションの大きな割合でアクセスする場合、インデックスやテーブル全体に散在するランダムアクセスリードを使用する代わりに、そのパーティションのシーケンシャルスキャンを利用することで、パフォーマンスを向上させることができます。</target>
        </trans-unit>
        <trans-unit id="2540d43e50d1abeb1a847d9db340690266815c23" translate="yes" xml:space="preserve">
          <source>When relying on Serializable transactions to prevent anomalies, it is important that any data read from a permanent user table not be considered valid until the transaction which read it has successfully committed. This is true even for read-only transactions, except that data read within a &lt;em&gt;deferrable&lt;/em&gt; read-only transaction is known to be valid as soon as it is read, because such a transaction waits until it can acquire a snapshot guaranteed to be free from such problems before starting to read any data. In all other cases applications must not depend on results read during a transaction that later aborted; instead, they should retry the transaction until it succeeds.</source>
          <target state="translated">異常を防ぐためにシリアライズ可能なトランザクションに依存する場合、永続的なユーザーテーブルから読み取られたデータは、それを読み取ったトランザクションが正常にコミットするまで有効と見なされないことが重要です。これは、読み取り専用トランザクションにも当てはまります。ただし、&lt;em&gt;遅延可能な&lt;/em&gt;読み取り専用トランザクション内で読み取られたデータは、読み取られるとすぐに有効になることがわかっています。データの読み取りを開始する前の問題。他のすべてのケースでは、アプリケーションは、後で中止されたトランザクション中に読み取られた結果に依存してはなりません。代わりに、成功するまでトランザクションを再試行する必要があります。</target>
        </trans-unit>
        <trans-unit id="0f545c1f8d440a6a74e5e5cae7b49a8321ce778e" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE FUNCTION&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">繰り返される &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 呼び出しが同じオブジェクトファイルを参照する場合、ファイルはセッションごとに1回だけロードされます。（おそらく開発中に）ファイルをアンロードして再ロードするには、新しいセッションを開始します。</target>
        </trans-unit>
        <trans-unit id="63cb3d013e86db6ef5ef57500326cdf863814f3a" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">繰り返される &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 呼び出しが同じオブジェクトファイルを参照する場合、ファイルはセッションごとに1回だけロードされます。（おそらく開発中に）ファイルをアンロードして再ロードするには、新しいセッションを開始します。</target>
        </trans-unit>
        <trans-unit id="b358e9fc6a1b297fd0b37a45eac263be99236636" translate="yes" xml:space="preserve">
          <source>When replacing an existing definition, the argument types, result type, and number of direct arguments may not be changed. Also, the new definition must be of the same kind (ordinary aggregate, ordered-set aggregate, or hypothetical-set aggregate) as the old one.</source>
          <target state="translated">既存の定義を置き換える場合、引数の型、結果の型、直接引数の数は変更できません。また、新しい定義は、古い定義と同じ種類のもの(通常の集合体、順序付き集合体、または仮説集合体)でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf16a952f545e26cfee0e603603bfd07e12cf881" translate="yes" xml:space="preserve">
          <source>When replacing an existing function with &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;, there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function's result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced.</source>
          <target state="translated">既存の関数を &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; で置き換える場合、パラメーター名の変更には制限があります。入力パラメーターに既に割り当てられている名前を変更することはできません（以前に名前がなかったパラメーターに名前を追加することはできます）。複数の出力パラメーターがある場合、出力パラメーターの名前を変更することはできません。これにより、関数の結果を説明する匿名の複合型の列名が変更されるためです。これらの制限は、関数の既存の呼び出しが置き換えられたときに機能を停止しないようにするために行われます。</target>
        </trans-unit>
        <trans-unit id="80773f67cc3b08f5dcb6c36638c7da08b5a16582" translate="yes" xml:space="preserve">
          <source>When requesting synchronous replication, each commit of a write transaction will wait until confirmation is received that the commit has been written to the write-ahead log on disk of both the primary and standby server. The only possibility that data can be lost is if both the primary and the standby suffer crashes at the same time. This can provide a much higher level of durability, though only if the sysadmin is cautious about the placement and management of the two servers. Waiting for confirmation increases the user's confidence that the changes will not be lost in the event of server crashes but it also necessarily increases the response time for the requesting transaction. The minimum wait time is the round-trip time between primary to standby.</source>
          <target state="translated">同期レプリケーションを要求する場合、書き込みトランザクションの各コミットは、プライマリサーバとスタンバイサーバの両方のディスク上の書き込み先ログにコミットが書き込まれたことが確認されるまで待機します。データが失われる可能性があるのは、プライマリサーバとスタンバイサーバの両方が同時にクラッシュした場合だけです。これは、システム管理者が2つのサーバの配置と管理に慎重である場合に限りますが、より高いレベルの耐久性を提供することができます。確認を待つことで、サーバがクラッシュしても変更が失われないというユーザの信頼感が高まりますが、要求したトランザクションの応答時間も必然的に長くなります。最小の待ち時間は、プライマリからスタンバイまでの往復時間である。</target>
        </trans-unit>
        <trans-unit id="7cbfd2d18fb6178afa3088b0725b2bc3fcdf04fe" translate="yes" xml:space="preserve">
          <source>When restoring data to a pre-existing table and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_restore emits commands to disable triggers on user tables before inserting the data, then emits commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">既存のテーブルにデータを復元し、オプション &lt;code&gt;--disable-triggers&lt;/code&gt; が使用されている場合、pg_restoreは、データを挿入する前にユーザーテーブルのトリガーを無効にするコマンドを発行し、データが挿入された後にそれらを再度有効にするコマンドを発行します。復元が途中で停止した場合、システムカタログが誤った状態のままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ade7c8c975218ba23dcef154671330d11fa5728d" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">ロールのメンバーシップを取り消す場合、 &lt;code&gt;GRANT OPTION&lt;/code&gt; は代わりに &lt;code&gt;ADMIN OPTION&lt;/code&gt; と呼ばれますが、動作は似ています。この形式のコマンドでは、ノイズワード &lt;code&gt;GROUP&lt;/code&gt; が許可されないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="f68adac31376cf57c26d631be30fdfc9650022d2" translate="yes" xml:space="preserve">
          <source>When revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect.</source>
          <target state="translated">テーブル上の特権を取り消す場合、対応するカラムの特権(もしあれば)は、テーブルの各カラムも同様に自動的に取り消されます。一方、あるロールがテーブル上で特権を付与されている場合、個々の列から同じ特権を取り消すことは何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="300dad807edac8d993f28c0997a914c75b99f4bc" translate="yes" xml:space="preserve">
          <source>When rounding values, the &lt;code&gt;numeric&lt;/code&gt; type rounds ties away from zero, while (on most machines) the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; types round ties to the nearest even number. For example:</source>
          <target state="translated">値を丸める場合、 &lt;code&gt;numeric&lt;/code&gt; 型はゼロから離れて丸められますが、（ほとんどのマシンでは） &lt;code&gt;real&lt;/code&gt; および &lt;code&gt;double precision&lt;/code&gt; 型は、最も近い偶数に丸められます。例えば：</target>
        </trans-unit>
        <trans-unit id="5f76f7c7b77ca49ded558a0639a8d27cc09a3811" translate="yes" xml:space="preserve">
          <source>When row security is enabled on a table (with &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt;), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as &lt;code&gt;TRUNCATE&lt;/code&gt; and &lt;code&gt;REFERENCES&lt;/code&gt;, are not subject to row security.</source>
          <target state="translated">テーブルで行セキュリティが有効になっている場合（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITYを使用&lt;/a&gt;）、行を選択または変更するためのテーブルへの通常のアクセスはすべて、行セキュリティポリシーによって許可される必要があります。（ただし、テーブルの所有者は通常、行のセキュリティポリシーの対象ではありません。）テーブルにポリシーが存在しない場合、default-denyポリシーが使用されます。これは、行が表示されない、または変更できないことを意味します。 &lt;code&gt;TRUNCATE&lt;/code&gt; や &lt;code&gt;REFERENCES&lt;/code&gt; など、テーブル全体に適用される操作は、行セキュリティの対象ではありません。</target>
        </trans-unit>
        <trans-unit id="226f5e12ea7fb1c629a76bb1b3cc1943cd4502fc" translate="yes" xml:space="preserve">
          <source>When running a long test on hardware that can handle a lot of transactions, the log files can become very large. The &lt;code&gt;--sampling-rate&lt;/code&gt; option can be used to log only a random sample of transactions.</source>
          <target state="translated">多くのトランザクションを処理できるハードウェアで長いテストを実行すると、ログファイルが非常に大きくなる可能性があります。 &lt;code&gt;--sampling-rate&lt;/code&gt; オプションは、トランザクションの唯一のランダムなサンプルを記録するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="4051fc47591e058546d74bee2aa79ca3ea360af8" translate="yes" xml:space="preserve">
          <source>When running a standby server, you must set this parameter to the same or higher value than on the master server. Otherwise, queries will not be allowed in the standby server.</source>
          <target state="translated">待機サーバーを実行する場合は、このパラメータをマスターサーバーと同じかそれ以上の値に設定する必要があります。そうしないと、待機サーバでのクエリは許可されません。</target>
        </trans-unit>
        <trans-unit id="0becdbc99cfe7674fb7d475f00ec87ca3a5a28cc" translate="yes" xml:space="preserve">
          <source>When running at the &lt;code&gt;serializable&lt;/code&gt; isolation level, a deferrable read-only SQL transaction may be delayed before it is allowed to proceed. However, once it begins executing it does not incur any of the overhead required to ensure serializability; so serialization code will have no reason to force it to abort because of concurrent updates, making this option suitable for long-running read-only transactions.</source>
          <target state="translated">&lt;code&gt;serializable&lt;/code&gt; 可能な分離レベルで実行している場合、遅延可能な読み取り専用SQLトランザクションは、続行する前に遅延する可能性があります。ただし、いったん実行を開始すると、シリアライザビリティを確保するために必要なオーバーヘッドは発生しません。そのため、シリアライゼーションコードは、同時更新のために強制的に強制終了する理由がないため、このオプションは長時間実行される読み取り専用トランザクションに適しています。</target>
        </trans-unit>
        <trans-unit id="d1a67057ea54f0f16f47cefbf38d78344e7ecca6" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;on&lt;/code&gt;, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to &lt;code&gt;interactive&lt;/code&gt;, such errors are only ignored in interactive sessions, and not when reading script files. When set to &lt;code&gt;off&lt;/code&gt; (the default), a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit &lt;code&gt;SAVEPOINT&lt;/code&gt; for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; に設定すると、トランザクションブロックのステートメントがエラーを生成した場合、エラーは無視され、トランザクションが続行されます。 &lt;code&gt;interactive&lt;/code&gt; に設定すると、そのようなエラーはインタラクティブセッションでのみ無視され、スクリプトファイルの読み取り時には無視されません。設定すると &lt;code&gt;off&lt;/code&gt; （デフォルト）、エラーが発生したトランザクションブロック内の文は、トランザクション全体を中止します。エラーロールバックモードは、トランザクションブロック内の各コマンドの直前に暗黙の &lt;code&gt;SAVEPOINT&lt;/code&gt; を発行し、コマンドが失敗した場合にセーブポイントにロールバックすることで機能します。</target>
        </trans-unit>
        <trans-unit id="43e9cba78fc8dadeb25eba89d19fc5d8c6ee61b8" translate="yes" xml:space="preserve">
          <source>When set to off, which is the default, PostgreSQL will raise a PANIC-level error on failure to flush modified data files to the file system. This causes the database server to crash. This parameter can only be set at server start.</source>
          <target state="translated">デフォルトのoffに設定されている場合、PostgreSQLは変更されたデータファイルをファイルシステムにフラッシュできなかった場合にPANICレベルのエラーを発生させます。これにより、データベースサーバがクラッシュします。このパラメータはサーバ起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="6cbaca794cc78ed3c2b124781f712501c0ff4934" translate="yes" xml:space="preserve">
          <source>When set to on, which is the default, PostgreSQL will automatically reinitialize after a backend crash. Leaving this value set to on is normally the best way to maximize the availability of the database. However, in some circumstances, such as when PostgreSQL is being invoked by clusterware, it may be useful to disable the restart so that the clusterware can gain control and take any actions it deems appropriate.</source>
          <target state="translated">デフォルトのonに設定すると、PostgreSQLはバックエンドがクラッシュした後に自動的に再初期化します。通常、この値をonに設定したままにしておくことが、データベースの可用性を最大化する最良の方法です。しかし、クラスタウェアによってPostgreSQLが起動されているような状況では、クラスタウェアが制御して適切と思われるアクションを取ることができるように、再起動を無効にすることが有用な場合があります。</target>
        </trans-unit>
        <trans-unit id="a7b55871d6d7b3f171d441751dee834b0868dec6" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;debug_pretty_print&lt;/code&gt; indents the messages produced by &lt;code&gt;debug_print_parse&lt;/code&gt;, &lt;code&gt;debug_print_rewritten&lt;/code&gt;, or &lt;code&gt;debug_print_plan&lt;/code&gt;. This results in more readable but much longer output than the &amp;ldquo;compact&amp;rdquo; format used when it is off. It is on by default.</source>
          <target state="translated">設定すると、 &lt;code&gt;debug_pretty_print&lt;/code&gt; は、 &lt;code&gt;debug_print_parse&lt;/code&gt; 、 &lt;code&gt;debug_print_rewritten&lt;/code&gt; 、または &lt;code&gt;debug_print_plan&lt;/code&gt; によって生成されたメッセージをインデントします。これにより、オフの場合に使用される「コンパクト」形式よりも読みやすくなりますが、出力ははるかに長くなります。デフォルトではオンになっています。</target>
        </trans-unit>
        <trans-unit id="9655c6cce4ab0fb89202aa42165255e7c2310c07" translate="yes" xml:space="preserve">
          <source>When setting any of these parameters, a relative path will be interpreted with respect to the directory in which &lt;code&gt;postgres&lt;/code&gt; is started.</source>
          <target state="translated">これらのパラメータのいずれかを設定すると、相対パスは &lt;code&gt;postgres&lt;/code&gt; が起動されたディレクトリを基準に解釈されます。</target>
        </trans-unit>
        <trans-unit id="f5cba5ccebd44827dbe97e5c58205ecd19cd5549" translate="yes" xml:space="preserve">
          <source>When several data types share near-identical sorting semantics, their operator classes can be grouped into an operator family. Doing so is advantageous because it allows the planner to make deductions about cross-type comparisons. Each operator class within the family should contain the single-type operators (and associated support functions) for its input data type, while cross-type comparison operators and support functions are &amp;ldquo;loose&amp;rdquo; in the family. It is recommendable that a complete set of cross-type operators be included in the family, thus ensuring that the planner can represent any comparison conditions that it deduces from transitivity.</source>
          <target state="translated">複数のデータ型がほぼ同一のソートセマンティクスを共有する場合、それらの演算子クラスを演算子ファミリーにグループ化できます。そうすることは、プランナがクロスタイプ比較について推論を行うことを可能にするので有利です。ファミリー内の各演算子クラスには、入力データ型の単一タイプの演算子（および関連するサポート関数）が含まれている必要がありますが、クロスタイプ比較演算子とサポート関数は、ファミリーでは「ルーズ」です。クロスタイプ演算子の完全なセットをファミリに含めることをお勧めします。これにより、プランナが推移性から推定する比較条件を表現できるようになります。</target>
        </trans-unit>
        <trans-unit id="cb221d1e490779006a131832600e7b4ca11a22c2" translate="yes" xml:space="preserve">
          <source>When showing progress (option &lt;code&gt;-P&lt;/code&gt;), use a timestamp (Unix epoch) instead of the number of seconds since the beginning of the run. The unit is in seconds, with millisecond precision after the dot. This helps compare logs generated by various tools.</source>
          <target state="translated">進行状況を表示する場合（オプション &lt;code&gt;-P&lt;/code&gt; ）、実行開始からの秒数ではなく、タイムスタンプ（UNIXエポック）を使用します。単位は秒で、ドットの後にミリ秒の精度があります。これは、さまざまなツールによって生成されたログを比較するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="cc026cecf0c9d705d368f497265f6e7182739df8" translate="yes" xml:space="preserve">
          <source>When sorting &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; data types, IPv4 addresses will always sort before IPv6 addresses, including IPv4 addresses encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::ffff:10.4.3.2.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; または &lt;code&gt;cidr&lt;/code&gt; データ型をソートする場合、IPv4アドレスは、IPv6アドレスの前に常にソートされます。これには、カプセル化またはIPv6アドレスにマップされたIPv4アドレスが含まれます。</target>
        </trans-unit>
        <trans-unit id="00112c1a0dfb2756ee57aac0f953ab1b28e8aa6b" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">指定すると、推論中に一致するために、対応する &lt;code&gt;index_column_name&lt;/code&gt; または &lt;code&gt;index_expression&lt;/code&gt; が特定の照合を使用するように強制します。通常、照合は制約違反が発生するかどうかに影響しないため、これは省略されます。 &lt;code&gt;CREATE INDEX&lt;/code&gt; 形式に従います。</target>
        </trans-unit>
        <trans-unit id="49ab9aed56a17743958b35c4487c001e52ad9448" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use particular operator class in order to be matched during inference. Typically this is omitted, as the &lt;em&gt;equality&lt;/em&gt; semantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">指定すると、推論中に一致するために、対応する &lt;code&gt;index_column_name&lt;/code&gt; または &lt;code&gt;index_expression&lt;/code&gt; が特定の演算子クラスを使用するように強制します。通常、これは省略されます。これは、&lt;em&gt;等価の&lt;/em&gt;セマンティクスが型の演算子クラス全体で同等であることが多いため、または定義された一意のインデックスが等価の適切な定義を持っていることを信頼するのに十分であるためです。 &lt;code&gt;CREATE INDEX&lt;/code&gt; 形式に従います。</target>
        </trans-unit>
        <trans-unit id="f47b14844e6f65e1969fe664f76645a83ada8978" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;program&lt;/code&gt; option, keep in mind that the option string is executed by the shell. If you need to pass any arguments to the command that come from an untrusted source, you must be careful to strip or escape any characters that might have special meaning to the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">&lt;code&gt;program&lt;/code&gt; オプションを指定するときは、オプション文字列がシェルによって実行されることに注意してください。信頼できないソースからの引数をコマンドに渡す必要がある場合は、シェルにとって特別な意味を持つ可能性のある文字を削除またはエスケープするように注意する必要があります。セキュリティ上の理由から、固定のコマンド文字列を使用するか、少なくともユーザー入力を渡さないようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a86f4916e3e42d9bf0f446f6ed8f6c9365f0b9b8" translate="yes" xml:space="preserve">
          <source>When starting a client session via libpq, parameter settings can be specified using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable. Settings established in this way constitute defaults for the life of the session, but do not affect other sessions. For historical reasons, the format of &lt;code&gt;PGOPTIONS&lt;/code&gt; is similar to that used when launching the &lt;code&gt;postgres&lt;/code&gt; command; specifically, the &lt;code&gt;-c&lt;/code&gt; flag must be specified. For example,</source>
          <target state="translated">libpq経由でクライアントセッションを開始する場合、パラメーター設定は &lt;code&gt;PGOPTIONS&lt;/code&gt; 環境変数を使用して指定できます。この方法で確立された設定は、セッションの存続期間のデフォルトになりますが、他のセッションには影響しません。歴史的な理由から、 &lt;code&gt;PGOPTIONS&lt;/code&gt; の形式は &lt;code&gt;postgres&lt;/code&gt; コマンドを起動するときに使用される形式と似ています。具体的には、 &lt;code&gt;-c&lt;/code&gt; フラグを指定する必要があります。例えば、</target>
        </trans-unit>
        <trans-unit id="80810b3a36d5394cd36078211fe98f572205f903" translate="yes" xml:space="preserve">
          <source>When suitable, query results can be shown in a crosstab representation with the &lt;code&gt;\crosstabview&lt;/code&gt; command:</source>
          <target state="translated">必要に応じて、 &lt;code&gt;\crosstabview&lt;/code&gt; コマンドを使用して、クエリ結果をクロス集計表現で表示できます。</target>
        </trans-unit>
        <trans-unit id="a46f34ffb8c110010cfd3fe050b49b5689c1e534" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, it is the user's responsibility to unpack each tar file before starting the PostgreSQL server. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar形式モードを使用する場合、PostgreSQLサーバーを起動する前に各tarファイルを解凍するのはユーザーの責任です。追加のテーブルスペースがある場合は、それらのtarファイルを正しい場所に解凍する必要があります。この場合、これらのテーブルスペースのシンボリックリンクは、 &lt;code&gt;base.tar&lt;/code&gt; ファイルに含まれている &lt;code&gt;tablespace_map&lt;/code&gt; ファイルの内容に従ってサーバーによって作成されます。</target>
        </trans-unit>
        <trans-unit id="34c7d99e4e21933c48e46c135fcf1d89d1aca09e" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">tar形式モードを使用する場合は、先行書き込みログファイルの名前の別のファイルに書き込まれます &lt;code&gt;pg_wal.tar&lt;/code&gt; （サーバは前のバージョン10を超える場合、ファイルが名前になります &lt;code&gt;pg_xlog.tar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="13bf3c4060b6a548c1c5420c5acc0dd3edcdfdfa" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar形式モードを使用すると、先行書き込みログファイルが &lt;code&gt;base.tar&lt;/code&gt; ファイルに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="f11ae7cfc9d8e7c9709340ffb2024d1b68d62efb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; parameter is set to true on a standby server, it will begin accepting connections once the recovery has brought the system to a consistent state. All such connections are strictly read-only; not even temporary tables may be written.</source>
          <target state="translated">とき&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standbyの&lt;/a&gt;パラメータは、スタンバイサーバー上のtrueに設定されている回復が一貫性のある状態にシステムをもたらしていたら、それは接続を受け入れ始めます。このような接続はすべて厳密に読み取り専用です。一時テーブルでさえ書けないかもしれません。</target>
        </trans-unit>
        <trans-unit id="7959e96ecaba15e9d39e3fc41cafc94b8dcfae7f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CONSTRAINT&lt;/code&gt; option is specified, this command creates a &lt;em&gt;constraint trigger&lt;/em&gt;. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;. Constraint triggers must be &lt;code&gt;AFTER ROW&lt;/code&gt; triggers on plain tables (not foreign tables). They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be &lt;em&gt;deferred&lt;/em&gt;. A pending deferred-trigger firing can also be forced to happen immediately by using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</source>
          <target state="translated">とき &lt;code&gt;CONSTRAINT&lt;/code&gt; のオプションを指定すると、このコマンドは、作成&lt;em&gt;制約トリガを&lt;/em&gt;。これは、トリガーの発火のタイミングが&lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;を使用して調整できることを除いて、通常のトリガーと同じです。制約トリガーは、（外部テーブルではなく）プレーンテーブルの &lt;code&gt;AFTER ROW&lt;/code&gt; トリガーである必要があります。それらは、トリガーイベントを引き起こしているステートメントの最後、または含まれているトランザクションの最後のいずれかで起動できます。後者の場合、それらは&lt;em&gt;延期さ&lt;/em&gt;れると言われています。 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; を使用して、保留中の遅延トリガーの発火を強制的にすぐに発生させることもできます。制約トリガーは、それらが実装する制約に違反すると、例外を発生させることが期待されています。</target>
        </trans-unit>
        <trans-unit id="df5c7d4a7ad0b452626a13ac455de82c0906adea" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;SELECT&lt;/code&gt; is one arm of a &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) construct, or when it appears within &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, this rule is not applied since rules given in preceding sections take precedence. The type of an unspecified-type literal can be taken from the other &lt;code&gt;UNION&lt;/code&gt; arm in the first case, or from the destination column in the second case.</source>
          <target state="translated">場合 &lt;code&gt;SELECT&lt;/code&gt; は、の一方のアームである &lt;code&gt;UNION&lt;/code&gt; （または &lt;code&gt;INTERSECT&lt;/code&gt; または &lt;code&gt;EXCEPT&lt;/code&gt; ）構築物、又はそれの中に表示されたときに &lt;code&gt;INSERT ... SELECT&lt;/code&gt; 節の前に与えられたルールが優先するので、このルールが適用されません。 unspecified-typeリテラルのタイプは、最初のケースでは他の &lt;code&gt;UNION&lt;/code&gt; アームから、または2番目のケースでは宛先列から取得できます。</target>
        </trans-unit>
        <trans-unit id="7f2ffb48d56de0e4aaa18bb9efa3e04da4e9e279" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;WHERE&lt;/code&gt; clause is present, a &lt;em&gt;partial index&lt;/em&gt; is created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to use &lt;code&gt;WHERE&lt;/code&gt; with &lt;code&gt;UNIQUE&lt;/code&gt; to enforce uniqueness over a subset of a table. See &lt;a href=&quot;indexes-partial&quot;&gt;Section 11.8&lt;/a&gt; for more discussion.</source>
          <target state="translated">ときに &lt;code&gt;WHERE&lt;/code&gt; 句が存在している、&lt;em&gt;部分インデックスが&lt;/em&gt;作成されます。部分インデックスは、テーブルの一部のみのエントリを含むインデックスです。通常は、残りのテーブルよりもインデックス作成に役立つ部分です。たとえば、請求済みの注文と未請求の注文の両方を含むテーブルがあり、未請求の注文がテーブル全体のごく一部を占めているが、それが頻繁に使用されるセクションである場合、その部分にのみインデックスを作成することでパフォーマンスを向上できます。別の可能なアプリケーションは、 &lt;code&gt;UNIQUE&lt;/code&gt; で &lt;code&gt;WHERE&lt;/code&gt; を使用して、テーブルのサブセットに対して一意性を適用することです。詳細については、&lt;a href=&quot;indexes-partial&quot;&gt;セクション11.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8c185ac9497904ca6d14d82c8dc0a0e1690d4901" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ampredlocks&lt;/code&gt; flag is not set, any scan using that index access method within a serializable transaction will acquire a nonblocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations.</source>
          <target state="translated">&lt;code&gt;ampredlocks&lt;/code&gt; フラグが設定されていない場合、シリアル化可能なトランザクション内でそのインデックスアクセスメソッドを使用したスキャンは、完全なインデックスで非ブロッキング述語ロックを取得します。これにより、同時直列化可能トランザクションによるタプルのそのインデックスへの挿入と読み取り/書き込みの競合が発生します。読み取り/書き込みの競合の特定のパターンが、一連の並行シリアライズ可能なトランザクション間で検出された場合、それらのトランザクションの1つがキャンセルされ、データの整合性が保護されます。フラグが設定されている場合、それは、インデックスアクセスメソッドがよりきめの細かい述語ロックを実装することを示します。これにより、そのようなトランザクションのキャンセルの頻度が減少する傾向があります。</target>
        </trans-unit>
        <trans-unit id="32c110466857121d054324f74c8a38f9bb5212e4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;border&lt;/code&gt; setting is greater than zero, the &lt;code&gt;linestyle&lt;/code&gt; option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them.</source>
          <target state="translated">ときに &lt;code&gt;border&lt;/code&gt; 設定がゼロよりも大きい場合、 &lt;code&gt;linestyle&lt;/code&gt; オプションも境界線が描画されると文字を決定します。プレーンASCII文字はどこでも機能しますが、Unicode文字はそれらを認識するディスプレイ上で見栄えがよくなります。</target>
        </trans-unit>
        <trans-unit id="00d6a0dfb20c2e25ada6bca76d0486b409be8ef1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;off&lt;/code&gt;, the pager program is not used. When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;on&lt;/code&gt;, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The &lt;code&gt;pager&lt;/code&gt; option can also be set to &lt;code&gt;always&lt;/code&gt;, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. &lt;code&gt;\pset pager&lt;/code&gt; without a &lt;code&gt;value&lt;/code&gt; toggles pager use on and off.</source>
          <target state="translated">ときに &lt;code&gt;pager&lt;/code&gt; オプションは &lt;code&gt;off&lt;/code&gt; 、ページャプログラムが使用されていません。ときに &lt;code&gt;pager&lt;/code&gt; オプションがある &lt;code&gt;on&lt;/code&gt; 、ページャは、適切な場合に使用されている、すなわち、出力は端末にあると、画面に収まらないとき。 &lt;code&gt;pager&lt;/code&gt; オプションもに設定することができ &lt;code&gt;always&lt;/code&gt; 関係なく、それが画面に収まるかどうかのすべての端末出力に使用するページャを引き起こします。 &lt;code&gt;value&lt;/code&gt; ない &lt;code&gt;\pset pager&lt;/code&gt; は、ページャーの使用のオンとオフを切り替えます。</target>
        </trans-unit>
        <trans-unit id="81a140433737ca4c23a575624ce695fcc511dede" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_buffercache&lt;/code&gt; view is accessed, internal buffer manager locks are taken for long enough to copy all the buffer state data that the view will display. This ensures that the view produces a consistent set of results, while not blocking normal buffer activity longer than necessary. Nonetheless there could be some impact on database performance if this view is read often.</source>
          <target state="translated">場合 &lt;code&gt;pg_buffercache&lt;/code&gt; のビューにアクセスし、内部バッファ・マネージャ・ロックは、ビューが表示されたすべてのバッファ状態データをコピーするために十分な長さのために採取されます。これにより、ビューは一貫した一連の結果を生成し、必要以上に通常のバッファアクティビティをブロックしなくなります。それでも、このビューが頻繁に読み込まれると、データベースのパフォーマンスに影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="cd60a2856753e705f8fe475e92d422e142a5a733" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_prepared_xacts&lt;/code&gt; view is accessed, the internal transaction manager data structures are momentarily locked, and a copy is made for the view to display. This ensures that the view produces a consistent set of results, while not blocking normal operations longer than necessary. Nonetheless there could be some impact on database performance if this view is frequently accessed.</source>
          <target state="translated">とき &lt;code&gt;pg_prepared_xacts&lt;/code&gt; のビューがアクセスされ、内部トランザクション管理データ構造が一時的にロックされ、コピーがディスプレイに表示のために作られています。これにより、ビューは一貫した結果セットを生成し、必要以上に通常の操作をブロックしなくなります。それでも、このビューに頻繁にアクセスすると、データベースのパフォーマンスに影響が出る可能性があります。</target>
        </trans-unit>
        <trans-unit id="7ee8be71b9dbdb6fe9839b8abd30a5d0ca45b722" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;text&lt;/code&gt; format is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null. &lt;code&gt;COPY FROM&lt;/code&gt; will raise an error if any line of the input file contains more or fewer columns than are expected.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 形式を使用する場合、読み書きされるデータは、テーブル行ごとに1行のテキストファイルです。行の列は区切り文字で区切られます。列の値自体は、各属性のデータ型の出力関数によって生成された文字列、または入力関数で受け入れ可能な文字列です。指定されたnull文字列は、nullの列の代わりに使用されます。入力ファイルのいずれかの行に予想よりも多いまたは少ない列が含まれている場合、 &lt;code&gt;COPY FROM&lt;/code&gt; はエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="1c4c47cbbcff114da7b14a508ba7d65a0b19eac7" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; argument to verification functions is &lt;code&gt;true&lt;/code&gt;, an additional phase of verification is performed against the table associated with the target index relation. This consists of a &amp;ldquo;dummy&amp;rdquo;&lt;code&gt;CREATE INDEX&lt;/code&gt; operation, which checks for the presence of all hypothetical new index tuples against a temporary, in-memory summarizing structure (this is built when needed during the basic first phase of verification). The summarizing structure &amp;ldquo;fingerprints&amp;rdquo; every tuple found within the target index. The high level principle behind &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is that a new index that is equivalent to the existing, target index must only have entries that can be found in the existing structure.</source>
          <target state="translated">場合&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;検証関数の引数が &lt;code&gt;true&lt;/code&gt; 、検証の追加的な位相は、目標指標関係に関連付けられたテーブルに対して実行されます。これは、一時的なメモリ内の要約構造（これは検証の基本的な最初のフェーズで必要なときに構築されます）に対してすべての架空の新しいインデックスタプルの存在をチェックする「ダミー」の &lt;code&gt;CREATE INDEX&lt;/code&gt; 操作で構成されます。要約構造は、ターゲットインデックス内で見つかったすべてのタプルを「フィンガープリント」します。&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;検証の背後にある高レベルの原則は、既存のターゲットインデックスと同等の新しいインデックスは、既存の構造内で見つけることができるエントリのみを持つ必要があるということです。</target>
        </trans-unit>
        <trans-unit id="a4898e6eb712c6c928410a4432225d77730464bb" translate="yes" xml:space="preserve">
          <source>When the backup is in tar mode, and the directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar file will be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">バックアップがtarモードで、ディレクトリが &lt;code&gt;-&lt;/code&gt; （ダッシュ）として指定されている場合、tarファイルは &lt;code&gt;stdout&lt;/code&gt; に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="2bf62b247e8d0c8ddb36cb4a11374b1155c5b650" translate="yes" xml:space="preserve">
          <source>When the client application uses the &amp;ldquo;extended query&amp;rdquo; protocol to issue a &lt;code&gt;FETCH&lt;/code&gt; command, the Bind protocol message specifies whether data is to be retrieved in text or binary format. This choice overrides the way that the cursor is defined. The concept of a binary cursor as such is thus obsolete when using extended query protocol &amp;mdash; any cursor can be treated as either text or binary.</source>
          <target state="translated">クライアントアプリケーションが「拡張クエリ」プロトコルを使用して &lt;code&gt;FETCH&lt;/code&gt; コマンドを発行する場合、Bindプロトコルメッセージは、データをテキスト形式で取得するかバイナリ形式で取得するかを指定します。この選択は、カーソルの定義方法をオーバーライドします。したがって、拡張クエリプロトコルを使用する場合、バイナリカーソル自体の概念は廃止されます。どのカーソルもテキストまたはバイナリとして扱うことができます。</target>
        </trans-unit>
        <trans-unit id="cef2bc6393c8c4a9107edf2302ecf0f071877452" translate="yes" xml:space="preserve">
          <source>When the connection to the server is lost, do not retry in a loop, just exit.</source>
          <target state="translated">サーバへの接続が切れた場合は、ループで再試行せずに終了する。</target>
        </trans-unit>
        <trans-unit id="c8229aa8ad36a0b0c5e6146511e976844f24d945" translate="yes" xml:space="preserve">
          <source>When the database generates SQL, force all identifiers to be quoted, even if they are not (currently) keywords. This will affect the output of &lt;code&gt;EXPLAIN&lt;/code&gt; as well as the results of functions like &lt;code&gt;pg_get_viewdef&lt;/code&gt;. See also the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option of &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; and &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;.</source>
          <target state="translated">データベースがSQLを生成するとき、識別子が（現在）キーワードでなくても、すべての識別子を強制的に引用符で囲みます。これは &lt;code&gt;EXPLAIN&lt;/code&gt; の出力と &lt;code&gt;pg_get_viewdef&lt;/code&gt; のような関数の結果に影響します。&lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt;および&lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;の &lt;code&gt;--quote-all-identifiers&lt;/code&gt; オプションも参照してください。</target>
        </trans-unit>
        <trans-unit id="ea2bc8f44657321dd80c423b48806c42005dbc7a" translate="yes" xml:space="preserve">
          <source>When the database system has to perform an ordering or a character classification, it uses the collation of the input expression. This happens, for example, with &lt;code&gt;ORDER BY&lt;/code&gt; clauses and function or operator calls such as &lt;code&gt;&amp;lt;&lt;/code&gt;. The collation to apply for an &lt;code&gt;ORDER BY&lt;/code&gt; clause is simply the collation of the sort key. The collation to apply for a function or operator call is derived from the arguments, as described below. In addition to comparison operators, collations are taken into account by functions that convert between lower and upper case letters, such as &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt;; by pattern matching operators; and by &lt;code&gt;to_char&lt;/code&gt; and related functions.</source>
          <target state="translated">データベースシステムは、順序付けまたは文字分類を実行する必要がある場合、入力式の照合を使用します。これは、たとえば、 &lt;code&gt;ORDER BY&lt;/code&gt; 句や &lt;code&gt;&amp;lt;&lt;/code&gt; などの関数または演算子の呼び出しで発生します。 &lt;code&gt;ORDER BY&lt;/code&gt; 句に適用する照合順序は、単にソートキーの照合順序です。関数または演算子の呼び出しに適用する照合は、以下で説明するように、引数から取得されます。比較演算子に加えて、 &lt;code&gt;lower&lt;/code&gt; 、 &lt;code&gt;upper&lt;/code&gt; 、および &lt;code&gt;initcap&lt;/code&gt; など、大文字と小文字を変換する関数によって照合順序が考慮されます。パターンマッチング演算子;そして &lt;code&gt;to_char&lt;/code&gt; と関連する関数によって。</target>
        </trans-unit>
        <trans-unit id="cf20c03f9a438d0f6675629396820f040d752814" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">デフォルトが適切でない場合は、環境変数 &lt;code&gt;PGDATABASE&lt;/code&gt; 、 &lt;code&gt;PGHOST&lt;/code&gt; 、 &lt;code&gt;PGPORT&lt;/code&gt; 、および/または &lt;code&gt;PGUSER&lt;/code&gt; を適切な値に設定することで、入力を減らすことができます。 （追加の環境変数については、&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;セクション33.14を&lt;/a&gt;参照してください。）また、パスワードを定期的に入力する必要がないように &lt;code&gt;~/.pgpass&lt;/code&gt; ファイルを用意すると便利です。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;項33.15&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="58644d348761a861122023ab84e086a5de61b1bd" translate="yes" xml:space="preserve">
          <source>When the input value is +/-Infinity, &lt;code&gt;extract&lt;/code&gt; returns +/-Infinity for monotonically-increasing fields (&lt;code&gt;epoch&lt;/code&gt;, &lt;code&gt;julian&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;isoyear&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, and &lt;code&gt;millennium&lt;/code&gt;). For other fields, NULL is returned. PostgreSQL versions before 9.6 returned zero for all cases of infinite input.</source>
          <target state="translated">入力値がある場合には+/-インフィニティ、 &lt;code&gt;extract&lt;/code&gt; 戻り+/-単調増加フィールドのインフィニティ（ &lt;code&gt;epoch&lt;/code&gt; 、 &lt;code&gt;julian&lt;/code&gt; 、 &lt;code&gt;year&lt;/code&gt; 、 &lt;code&gt;isoyear&lt;/code&gt; 、 &lt;code&gt;decade&lt;/code&gt; 、 &lt;code&gt;century&lt;/code&gt; 、そして &lt;code&gt;millennium&lt;/code&gt; ）。その他のフィールドの場合、NULLが返されます。 9.6より前のバージョンのPostgreSQLは、無限入力のすべてのケースでゼロを返しました。</target>
        </trans-unit>
        <trans-unit id="ca7b95a2bfd76e66a3b9a3c283932ae7ceb9d1f3" translate="yes" xml:space="preserve">
          <source>When the input value is of type &lt;code&gt;timestamp with time zone&lt;/code&gt;, the truncation is performed with respect to a particular time zone; for example, truncation to &lt;code&gt;day&lt;/code&gt; produces a value that is midnight in that zone. By default, truncation is done with respect to the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, but the optional &lt;code&gt;time_zone&lt;/code&gt; argument can be provided to specify a different time zone. The time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">入力値が &lt;code&gt;timestamp with time zone&lt;/code&gt; タイプの場合、切り捨ては特定のタイムゾーンに対して実行されます。例えば、への切り捨て &lt;code&gt;day&lt;/code&gt; そのゾーンで深夜の値を生成します。デフォルトでは、現在の&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;設定に基づいて切り捨てが行われますが、オプションの &lt;code&gt;time_zone&lt;/code&gt; 引数を指定して、別のタイムゾーンを指定できます。タイムゾーン名は、&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3項&lt;/a&gt;で説明する方法のいずれかで指定できます。</target>
        </trans-unit>
        <trans-unit id="fb992423a64d9af4e9c24a6d03361c5985029c38" translate="yes" xml:space="preserve">
          <source>When the node at the top of the parallel portion of the plan is &lt;code&gt;Gather Merge&lt;/code&gt; rather than &lt;code&gt;Gather&lt;/code&gt;, it indicates that each process executing the parallel portion of the plan is producing tuples in sorted order, and that the leader is performing an order-preserving merge. In contrast, &lt;code&gt;Gather&lt;/code&gt; reads tuples from the workers in whatever order is convenient, destroying any sort order that may have existed.</source>
          <target state="translated">計画の平行部の上部のノードである場合 &lt;code&gt;Gather Merge&lt;/code&gt; なく &lt;code&gt;Gather&lt;/code&gt; 、それは計画の並列部分を実行する各プロセスは、ソート順でタプルを生成していること、およびリーダー順序保存マージを行っていることを示し。対照的に、 &lt;code&gt;Gather&lt;/code&gt; はワーカーからタプルを都合のよい順序で読み取り、存在していた可能性のある並べ替え順序を破棄します。</target>
        </trans-unit>
        <trans-unit id="3c8d54f7450d49b82cd5a8da77194f4c25e5cdb1" translate="yes" xml:space="preserve">
          <source>When the operating system sends a write request to the storage hardware, there is little it can do to make sure the data has arrived at a truly non-volatile storage area. Rather, it is the administrator's responsibility to make certain that all storage components ensure integrity for both data and file-system metadata. Avoid disk controllers that have non-battery-backed write caches. At the drive level, disable write-back caching if the drive cannot guarantee the data will be written before shutdown. If you use SSDs, be aware that many of these do not honor cache flush commands by default. You can test for reliable I/O subsystem behavior using &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt;&lt;code&gt;diskchecker.pl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">オペレーティングシステムがストレージハードウェアに書き込み要求を送信するとき、データが本当に不揮発性のストレージ領域に到着したことを確認するためにできることはほとんどありません。むしろ、すべてのストレージコンポーネントがデータとファイルシステムメタデータの両方の整合性を保証することを確認するのは、管理者の責任です。バッテリーを使用しない書き込みキャッシュを持つディスクコントローラーは使用しないでください。シャットダウン前にドライブがデータの書き込みを保証できない場合は、ドライブレベルでライトバックキャッシュを無効にします。 SSDを使用する場合、これらの多くはデフォルトでキャッシュフラッシュコマンドを受け入れないことに注意してください。&lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt; &lt;code&gt;diskchecker.pl&lt;/code&gt; &lt;/a&gt;を使用して、信頼性の高いI / Oサブシステムの動作をテストできます。</target>
        </trans-unit>
        <trans-unit id="2d33bb04f73c12f42af37757660638f7bf07dd0c" translate="yes" xml:space="preserve">
          <source>When the optimizer determines that parallel query is the fastest execution strategy for a particular query, it will create a query plan which includes a &lt;em&gt;Gather&lt;/em&gt; or &lt;em&gt;Gather Merge&lt;/em&gt; node. Here is a simple example:</source>
          <target state="translated">オプティマイザーは、並列クエリが特定のクエリの最速の実行戦略であると判断すると、&lt;em&gt;Gather&lt;/em&gt;ノードまたは&lt;em&gt;Gather Merge&lt;/em&gt;ノードを含むクエリプランを作成します。以下に簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="01b643d7a7954ad91561b8c24a008664f59d15dd" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. The parenthesized syntax was added in PostgreSQL 11; the unparenthesized syntax is deprecated.</source>
          <target state="translated">オプションリストが括弧で囲まれている場合、オプションは任意の順序で記述することができます。括弧付き構文はPostgreSQL 11で追加されました。</target>
        </trans-unit>
        <trans-unit id="abee5df8a890efa75529bd092cf02d64e5f74e41" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. Without parentheses, options must be specified in exactly the order shown above. The parenthesized syntax was added in PostgreSQL 9.0; the unparenthesized syntax is deprecated.</source>
          <target state="translated">オプションリストが括弧で囲まれている場合、オプションはどのような順序でも記述できます。括弧がない場合、オプションは上記の順序で正確に指定しなければなりません。括弧付き構文はPostgreSQL 9.0で追加されました。</target>
        </trans-unit>
        <trans-unit id="0e9dc738f4097cde58c9e8bf1cce2f13a3e0faff" translate="yes" xml:space="preserve">
          <source>When the query executor is running a statement using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, individual operations are timed as well as showing a summary. The overhead of your system can be checked by counting rows with the psql program:</source>
          <target state="translated">クエリエグゼキュータが &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; を使用してステートメントを実行している場合、個々の操作は時間を計られるとともに要約を表示します。システムのオーバーヘッドは、psqlプログラムで行を数えることで確認できます。</target>
        </trans-unit>
        <trans-unit id="a4efc71382094156bb1e14ebb8922c4bbfee26e8" translate="yes" xml:space="preserve">
          <source>When the query involves more than two relations, the final result must be built up by a tree of join steps, each with two inputs. The planner examines different possible join sequences to find the cheapest one.</source>
          <target state="translated">クエリに2つ以上の関係が含まれる場合、最終的な結果は、2つの入力を持つ結合ステップのツリーによって構築されなければなりません。プランナーは、さまざまな可能性のある結合シーケンスを調べて、最も安価なものを見つけます。</target>
        </trans-unit>
        <trans-unit id="f91c3e21cf6bd9480dad3eeeece86758f55a90e3" translate="yes" xml:space="preserve">
          <source>When the query involves outer joins, the planner has less freedom than it does for plain (inner) joins. For example, consider:</source>
          <target state="translated">クエリが外側の結合を含む場合、プランナは単純な(内側の)結合よりも自由度が低くなります。例えば、次のように考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="53d57a11c26095ca3bee53a6ad82668d9cd1b948" translate="yes" xml:space="preserve">
          <source>When the replication client of pg_receivewal is configured on the server as a synchronous standby, then using a replication slot will report the flush position to the server, but only when a WAL file is closed. Therefore, that configuration will cause transactions on the primary to wait for a long time and effectively not work satisfactorily. The option &lt;code&gt;--synchronous&lt;/code&gt; (see below) must be specified in addition to make this work correctly.</source>
          <target state="translated">pg_receivewalのレプリケーションクライアントがサーバー上で同期スタンバイとして構成されている場合、レプリケーションスロットを使用すると、フラッシュ位置がサーバーに報告されますが、WALファイルが閉じられている場合のみです。したがって、その構成では、プライマリのトランザクションが長時間待機し、事実上十分に機能しなくなります。これを正しく機能させるには、オプション &lt;code&gt;--synchronous&lt;/code&gt; （下記を参照）を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6e97e877617ee50758f9c1ed0038c82401b37ff4" translate="yes" xml:space="preserve">
          <source>When the server finds an entry in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog for the given language name, it will use the catalog data even if the command includes language parameters. This behavior simplifies loading of old dump files, which are likely to contain out-of-date information about language support functions.</source>
          <target state="translated">サーバーは、 &lt;code&gt;pg_pltemplate&lt;/code&gt; カタログで指定された言語名のエントリを見つけると、コマンドに言語パラメーターが含まれていても、カタログデータを使用します。この動作により、言語サポート関数に関する古い情報が含まれている可能性が高い古いダンプファイルの読み込みが簡略化されます。</target>
        </trans-unit>
        <trans-unit id="5acf91c2009ea693cf720914c5dcc7ec25263a3f" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a walreceiver process in the standby, and a corresponding walsender process in the primary.</source>
          <target state="translated">スタンバイが開始され、 &lt;code&gt;primary_conninfo&lt;/code&gt; が正しく設定されている場合、スタンバイは、アーカイブで使用可能なすべてのWALファイルを再生した後、プライマリに接続します。接続が正常に確立されると、スタンバイにwalreceiverプロセス、プライマリに対応するwalsenderプロセスが表示されます。</target>
        </trans-unit>
        <trans-unit id="eedf68c3267fbf09aabeff8e3149a2fc6e02e4a5" translate="yes" xml:space="preserve">
          <source>When the system is forced to combine multiple page-level predicate locks into a single relation-level predicate lock because the predicate lock table is short of memory, an increase in the rate of serialization failures may occur. You can avoid this by increasing &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;, &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;, and/or &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt;.</source>
          <target state="translated">述語ロックテーブルのメモリが不足しているために、システムが複数のページレベルの述語ロックを1つのリレーションレベルの述語ロックに結合するように強制されると、シリアル化の失敗率が増加する可能性があります。&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;、&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;、または&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_pageを&lt;/a&gt;増やすことで、これを回避できます。</target>
        </trans-unit>
        <trans-unit id="1e5d69b735badff5a43514c3f20c29f9fa27a5a4" translate="yes" xml:space="preserve">
          <source>When the target server is started for the first time after running pg_rewind, it will go into recovery mode and replay all WAL generated in the source server after the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and configuring suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">ターゲットサーバーがpg_rewindの実行後に初めて起動すると、回復モードになり、分岐点の後でソースサーバーで生成されたすべてのWALを再生します。 pg_rewindの実行時にソースサーバーでWALの一部が利用できなくなったため、pg_rewindセッションでWALをコピーできなかった場合は、ターゲットサーバーの起動時に利用可能にする必要があります。これは、作成することによって行うことができます &lt;code&gt;recovery.signal&lt;/code&gt; 対象のデータディレクトリ内のファイルを、適切な設定&lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;を行うrestore_commandを&lt;/a&gt;して &lt;code&gt;postgresql.conf&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="46d8ca3256e28b3a76b80a636c768a65a62af8f1" translate="yes" xml:space="preserve">
          <source>When the token is a number or number field:</source>
          <target state="translated">トークンが数字または数字フィールドの場合。</target>
        </trans-unit>
        <trans-unit id="13de437cb552624377cc1efe8012608874203a3b" translate="yes" xml:space="preserve">
          <source>When there are &lt;code&gt;OUT&lt;/code&gt; or &lt;code&gt;INOUT&lt;/code&gt; parameters, the &lt;code&gt;RETURNS&lt;/code&gt; clause can be omitted. If present, it must agree with the result type implied by the output parameters: &lt;code&gt;RECORD&lt;/code&gt; if there are multiple output parameters, or the same type as the single output parameter.</source>
          <target state="translated">ある場合 &lt;code&gt;OUT&lt;/code&gt; または &lt;code&gt;INOUT&lt;/code&gt; パラメータ、 &lt;code&gt;RETURNS&lt;/code&gt; の句は省略することができます。存在する場合は、出力パラメーターが暗黙的に示す結果タイプと一致する必要があります。複数の出力パラメーターがある場合は &lt;code&gt;RECORD&lt;/code&gt; 、または単一の出力パラメーターと同じタイプです。</target>
        </trans-unit>
        <trans-unit id="086da7e4c8252cf99eea2a26d212bfca20a89638" translate="yes" xml:space="preserve">
          <source>When there are no &lt;code&gt;GIN_MAYBE&lt;/code&gt; values in the &lt;code&gt;check&lt;/code&gt; vector, a &lt;code&gt;GIN_MAYBE&lt;/code&gt; return value is the equivalent of setting the &lt;code&gt;recheck&lt;/code&gt; flag in the Boolean &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; ベクトルに &lt;code&gt;GIN_MAYBE&lt;/code&gt; 値がない場合、 &lt;code&gt;GIN_MAYBE&lt;/code&gt; の戻り値は、ブール型の &lt;code&gt;consistent&lt;/code&gt; 関数で &lt;code&gt;recheck&lt;/code&gt; フラグを設定することと同じです。</target>
        </trans-unit>
        <trans-unit id="6d0ae32f2046467b15848b335dcbaffbcaf195f8" translate="yes" xml:space="preserve">
          <source>When this command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="translated">このコマンドを使用すると、前述のSQLクエリは1つの行を返すことが期待され、その列は列名にちなんで名付けられた変数に格納され、提供されている場合は &lt;code&gt;prefix&lt;/code&gt; 付けられます。</target>
        </trans-unit>
        <trans-unit id="d01a63b618f24f934c421a450096ebe3b2d3fb7a" translate="yes" xml:space="preserve">
          <source>When this feature is enabled, freed space at the end of a relation cannot be released to the operating system, since that could remove information needed to detect the &amp;ldquo;snapshot too old&amp;rdquo; condition. All space allocated to a relation remains associated with that relation for reuse only within that relation unless explicitly freed (for example, with &lt;code&gt;VACUUM FULL&lt;/code&gt;).</source>
          <target state="translated">この機能を有効にすると、「スナップショットが古すぎる」状態を検出するために必要な情報が削除される可能性があるため、関係の最後にある空き領域をオペレーティングシステムに解放できません。リレーションに割り当てられたすべてのスペースは、明示的に解放されない限り（たとえば、 &lt;code&gt;VACUUM FULL&lt;/code&gt; で）、リレーション内でのみ再利用できるように関連付けられたままです。</target>
        </trans-unit>
        <trans-unit id="edeb5910da7722ed71fd344bba96eef32a3f6641" translate="yes" xml:space="preserve">
          <source>When this happens, the range will be summarized normally during the next regular vacuum of the table.</source>
          <target state="translated">そうなると、次のテーブルの定期的なバキュームの間に、その範囲が普通にまとめられてしまいます。</target>
        </trans-unit>
        <trans-unit id="e4570af0f67cc29537d90c659afba5db93e8b7f0" translate="yes" xml:space="preserve">
          <source>When this is enabled, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent.</source>
          <target state="translated">これを有効にすると、バックアップはデータベース全体のサイズを列挙することから始まり、その後、実際の内容に戻って送信されます。これにより、バックアップに若干の時間がかかる場合があり、特に最初のデータが送信されるまでに時間がかかります。</target>
        </trans-unit>
        <trans-unit id="28c1776ab93887297f059584c258d507675ecdfe" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">このオプションを使用すると、PostgreSQLは、テーブルの同時挿入、更新、または削除を防止するロックを取得せずにインデックスを構築します。一方、標準のインデックスビルドは、完了するまでテーブルへの書き込み（読み取りではなく）をロックアウトします。このオプションを使用する場合は、いくつかの注意点があります。「&lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;インデックスの同時作成&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="469c5b3c25ebc28298d0a68f767fa4e6b9232f83" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">このオプションを使用すると、PostgreSQLは、テーブルの同時挿入、更新、または削除を防止するロックを取得せずにインデックスを再構築します。一方、標準のインデックスの再構築では、完了するまでテーブルへの書き込みがロックされます（読み取りはロックされません）。このオプションを使用する場合は、いくつかの注意点があります。「&lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;インデックスの同時再構築&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="8c3757e4ca86742c07911d6404be9ee33ce2c815" translate="yes" xml:space="preserve">
          <source>When this option is used, psql will connect to the database &lt;code&gt;postgres&lt;/code&gt;, unless a different database is named on the command line (option &lt;code&gt;-d&lt;/code&gt; or non-option argument, possibly via a service entry, but not via an environment variable).</source>
          <target state="translated">このオプションを使用すると、コマンドラインで別のデータベースが指定されない限り（オプション &lt;code&gt;-d&lt;/code&gt; または非オプション引数、おそらくサービスエントリを介して、環境変数を介さずに）、psqlはデータベース &lt;code&gt;postgres&lt;/code&gt; に接続します。</target>
        </trans-unit>
        <trans-unit id="2bc222201723d0a9f83d166df5e42c7cf99836b6" translate="yes" xml:space="preserve">
          <source>When this option is used, the database named with &lt;code&gt;-d&lt;/code&gt; is used only to issue the initial &lt;code&gt;DROP DATABASE&lt;/code&gt; and &lt;code&gt;CREATE DATABASE&lt;/code&gt; commands. All data is restored into the database name that appears in the archive.</source>
          <target state="translated">このオプションを使用すると、 &lt;code&gt;-d&lt;/code&gt; で指定されたデータベースは、最初の &lt;code&gt;DROP DATABASE&lt;/code&gt; &lt;code&gt;CREATE DATABASE&lt;/code&gt; コマンドとCREATE DATABASEコマンドを発行するためにのみ使用されます。すべてのデータは、アーカイブに表示されるデータベース名に復元されます。</target>
        </trans-unit>
        <trans-unit id="3390cee1b88ac1d254da2a22a816a53421d2e870" translate="yes" xml:space="preserve">
          <source>When this parameter allows it for a particular table, the planner compares query conditions with the table's &lt;code&gt;CHECK&lt;/code&gt; constraints, and omits scanning tables for which the conditions contradict the constraints. For example:</source>
          <target state="translated">このパラメーターが特定のテーブルに対して許可する場合、プランナーはクエリ条件をテーブルの &lt;code&gt;CHECK&lt;/code&gt; 制約と比較し、条件が制約と矛盾するスキャンテーブルを省略します。例えば：</target>
        </trans-unit>
        <trans-unit id="70be33b4f92d88452bcc535d531cf8223b72afbc" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server compresses a full page image written to WAL when &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is on or during a base backup. A compressed page image will be decompressed during WAL replay. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">このパラメーターが &lt;code&gt;on&lt;/code&gt; の場合、PostgreSQLサーバーは、&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;がonまたはベースバックアップ中に、WALに書き込まれたフルページイメージを圧縮します。圧縮されたページ画像は、WAL再生中に解凍されます。デフォルト値は &lt;code&gt;off&lt;/code&gt; です。スーパーユーザーのみがこの設定を変更できます。</target>
        </trans-unit>
        <trans-unit id="095a2e6ccc43e3049250993f0343788b4a6a861a" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint, even for non-critical modifications of so-called hint bits.</source>
          <target state="translated">このパラメーターが &lt;code&gt;on&lt;/code&gt; の場合、PostgreSQLサーバーは、チェックポイント後のページの最初の変更中に、いわゆるヒントビットの重要でない変更であっても、各ディスクページのコンテンツ全体をWALに書き込みます。</target>
        </trans-unit>
        <trans-unit id="ff47b09b0654ad59cedec7d15e17e9fba55f3e2b" translate="yes" xml:space="preserve">
          <source>When this parameter is on, &lt;code&gt;sepgsql&lt;/code&gt; functions in permissive mode, even if SELinux in general is working in enforcing mode. This parameter is primarily useful for testing purposes.</source>
          <target state="translated">このパラメータがオンの場合、一般にSELinuxが強制モードで動作している場合でも、 &lt;code&gt;sepgsql&lt;/code&gt; はパーミッシブモードで機能します。このパラメーターは、主にテスト目的で役立ちます。</target>
        </trans-unit>
        <trans-unit id="b664e492ac1b6b5bd7bf06b57282c7f341a60102" translate="yes" xml:space="preserve">
          <source>When this parameter is on, per-plan-node timing occurs for all statements executed, whether or not they run long enough to actually get logged. This can have an extremely negative impact on performance. Turning off &lt;code&gt;auto_explain.log_timing&lt;/code&gt; ameliorates the performance cost, at the price of obtaining less information.</source>
          <target state="translated">このパラメーターがオンの場合、実際にログが記録されるのに十分長く実行されているかどうかに関係なく、実行されたすべてのステートメントに対して計画ノードごとのタイミングが発生します。これは、パフォーマンスに非常に悪影響を及ぼす可能性があります。 &lt;code&gt;auto_explain.log_timing&lt;/code&gt; をオフにすると、取得する情報が少なくなりますが、パフォーマンスコストは改善されます。</target>
        </trans-unit>
        <trans-unit id="d4e134d46721d701b088fe76d2d53da371f96514" translate="yes" xml:space="preserve">
          <source>When this parameter is on, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint. This is needed because a page write that is in process during an operating system crash might be only partially completed, leading to an on-disk page that contains a mix of old and new data. The row-level change data normally stored in WAL will not be enough to completely restore such a page during post-crash recovery. Storing the full page image guarantees that the page can be correctly restored, but at the price of increasing the amount of data that must be written to WAL. (Because WAL replay always starts from a checkpoint, it is sufficient to do this during the first change of each page after a checkpoint. Therefore, one way to reduce the cost of full-page writes is to increase the checkpoint interval parameters.)</source>
          <target state="translated">このパラメータがオンの場合、PostgreSQLサーバはチェックポイント後のページの最初の変更時に、各ディスクページの内容全体をWALに書き込みます。これは、オペレーティングシステムのクラッシュ時に処理中のページ書き込みが部分的にしか完了せず、古いデータと新しいデータが混在したディスク上のページが作成される可能性があるために必要となります。通常WALに格納されている行レベルの変更データだけでは、クラッシュ後の復旧時にそのようなページを完全に復元するには十分ではありません。完全なページ イメージを保存することで、ページが正しく復元されることが保証されますが、その代償として、WAL に書き込む必要のあるデータ量が増加します。(WALの再生は常にチェックポイントから始まるので、チェックポイント後の各ページの最初の変更時にこれを行えば十分である。したがって、フルページ書き込みのコストを削減する一つの方法は、チェックポイント間隔パラメータを増加させることである)。</target>
        </trans-unit>
        <trans-unit id="5a1902b314fccc53fa419bb9d1c5d0a54674b4cd" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;on&lt;/code&gt; and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch &lt;code&gt;-E&lt;/code&gt;.) If you set this variable to the value &lt;code&gt;noexec&lt;/code&gt;, the queries are just shown but are not actually sent to the server and executed. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">この変数が &lt;code&gt;on&lt;/code&gt; 設定されており、バックスラッシュコマンドがデータベースにクエリを実行すると、クエリが最初に表示されます。この機能は、PostgreSQLの内部を調査し、独自のプログラムで同様の機能を提供するのに役立ちます。（プログラムの起動時にこの動作を選択するには、スイッチ &lt;code&gt;-E&lt;/code&gt; を使用します。）この変数を値 &lt;code&gt;noexec&lt;/code&gt; に設定すると、クエリは表示されるだけですが、実際にはサーバーに送信されず、実行されません。デフォルト値は &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0a31ece5bfbb183043ca04edf566185c4d24f24d" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="translated">スロットリングがアクティブな場合、ランの最後に報告されるトランザクションの待ち時間は、スケジュールされた開始時間から計算されるので、各トランザクションが前のトランザクションが終了するのを待たなければならなかった時間が含まれます。この待ち時間はスケジュール遅延時間と呼ばれ、その平均値と最大値も別々に報告される。実際のトランザクション開始時間、すなわちデータベースでのトランザクションの実行に費やされた時間に関 するトランザクション・レイテンシは、報告されたレイテンシからスケジュール・ラグ時間を差し引くことで計算できる。</target>
        </trans-unit>
        <trans-unit id="62a5ce62fea33e48d7ca4dcdb6fc1d49b58833f9" translate="yes" xml:space="preserve">
          <source>When throttling is used (&lt;code&gt;--rate=...&lt;/code&gt;), transactions that lag behind schedule by more than &lt;code&gt;limit&lt;/code&gt; ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as &lt;em&gt;skipped&lt;/em&gt;.</source>
          <target state="translated">スロットリングが使用されている場合（ &lt;code&gt;--rate=...&lt;/code&gt; ）、 &lt;code&gt;limit&lt;/code&gt; msを超えてスケ​​ジュールより遅れ、したがってレイテンシ制限を満たす見込みがないトランザクションは、サーバーにまったく送信されません。&lt;em&gt;スキップ&lt;/em&gt;されたものとしてカウントされ、個別に報告されます。</target>
        </trans-unit>
        <trans-unit id="b0431d629c5fa2195a09522dc9eddb52b7d7ef5d" translate="yes" xml:space="preserve">
          <source>When to JIT?</source>
          <target state="translated">JITをするタイミングは?</target>
        </trans-unit>
        <trans-unit id="c212a8c30b6a166bd84fdfc048fb956853e7ba65" translate="yes" xml:space="preserve">
          <source>When two arrays with an equal number of dimensions are concatenated, the result retains the lower bound subscript of the left-hand operand's outer dimension. The result is an array comprising every element of the left-hand operand followed by every element of the right-hand operand. For example:</source>
          <target state="translated">同じ次元数の2つの配列が連結されている場合,結果は左辺のオペランドの外側の次元の下界の添え字を保持します.結果は,左辺のオペランドの各要素の後に右辺のオペランドの各要素が続く配列となります.例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a09c4eb9b4b598594720766db600d02893739065" translate="yes" xml:space="preserve">
          <source>When used as a standalone program all WAL files logically preceding the &lt;code&gt;oldestkeptwalfile&lt;/code&gt; will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. In this mode, if you specify a &lt;code&gt;.partial&lt;/code&gt; or &lt;code&gt;.backup&lt;/code&gt; file name, then only the file prefix will be used as the &lt;code&gt;oldestkeptwalfile&lt;/code&gt;. This treatment of &lt;code&gt;.backup&lt;/code&gt; file name allows you to remove all WAL files archived prior to a specific base backup without error. For example, the following example will remove all files older than WAL file name &lt;code&gt;000000010000003700000010&lt;/code&gt;:</source>
          <target state="translated">スタンドアロンプ​​ログラムとして使用した場合、論理的に &lt;code&gt;oldestkeptwalfile&lt;/code&gt; の前にあるすべてのWALファイルは、 &lt;code&gt;archivelocation&lt;/code&gt; から削除されます。このモードでは、 &lt;code&gt;.partial&lt;/code&gt; または &lt;code&gt;.backup&lt;/code&gt; ファイル名を指定すると、ファイルのプレフィックスのみが &lt;code&gt;oldestkeptwalfile&lt;/code&gt; として使用されます。この &lt;code&gt;.backup&lt;/code&gt; ファイル名の扱いにより、特定のベースバックアップの前にアーカイブされたすべてのWALファイルをエラーなしで削除できます。たとえば、次の例では、WALファイル名 &lt;code&gt;000000010000003700000010&lt;/code&gt; より古いファイルをすべて削除します。</target>
        </trans-unit>
        <trans-unit id="b4f92bbabc1b26d77780494bcd623901f19d77be" translate="yes" xml:space="preserve">
          <source>When used with one of the archive file formats and combined with pg_restore, pg_dump provides a flexible archival and transfer mechanism. pg_dump can be used to backup an entire database, then pg_restore can be used to examine the archive and/or select which parts of the database are to be restored. The most flexible output file formats are the &amp;ldquo;custom&amp;rdquo; format (&lt;code&gt;-Fc&lt;/code&gt;) and the &amp;ldquo;directory&amp;rdquo; format (&lt;code&gt;-Fd&lt;/code&gt;). They allow for selection and reordering of all archived items, support parallel restoration, and are compressed by default. The &amp;ldquo;directory&amp;rdquo; format is the only format that supports parallel dumps.</source>
          <target state="translated">アーカイブファイル形式のいずれかで使用し、pg_restoreと組み合わせると、pg_dumpは柔軟なアーカイブおよび転送メカニズムを提供します。 pg_dumpを使用してデータベース全体をバックアップし、次にpg_restoreを使用してアーカイブを検査したり、データベースのどの部分を復元するかを選択したりできます。最も柔軟な出力ファイル形式は、「カスタム」形式（ &lt;code&gt;-Fc&lt;/code&gt; ）と「ディレクトリ」形式（ &lt;code&gt;-Fd&lt;/code&gt; ）です。それらはすべてのアーカイブ済みアイテムの選択と並べ替えを可能にし、並行復元をサポートし、デフォルトで圧縮されます。 「ディレクトリ」形式は、並列ダンプをサポートする唯一の形式です。</target>
        </trans-unit>
        <trans-unit id="7fe14a6b317961785cf4d152bc27d49064bcda5a" translate="yes" xml:space="preserve">
          <source>When used within &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;, all WAL files logically preceding the value of the &lt;code&gt;%r&lt;/code&gt; argument will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. This minimizes the number of files that need to be retained, while preserving crash-restart capability. Use of this parameter is appropriate if the &lt;code&gt;archivelocation&lt;/code&gt; is a transient staging area for this particular standby server, but &lt;em&gt;not&lt;/em&gt; when the &lt;code&gt;archivelocation&lt;/code&gt; is intended as a long-term WAL archive area, or when multiple standby servers are recovering from the same archive location.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;内で使用すると、論理的に &lt;code&gt;%r&lt;/code&gt; 引数の値の前にあるすべてのWALファイルが &lt;code&gt;archivelocation&lt;/code&gt; から削除されます。これにより、クラッシュの再起動機能を維持しながら、保持する必要のあるファイルの数を最小限に抑えることができます。場合は、このパラメータを使用することは適切で &lt;code&gt;archivelocation&lt;/code&gt; 、この特定のスタンバイ・サーバのための過渡的なステージング領域ですが、&lt;em&gt;ない&lt;/em&gt;とき &lt;code&gt;archivelocation&lt;/code&gt; 長期WALアーカイブ領域として意図され、または複数のスタンバイサーバが同じアーカイブ場所から回復しているとき。</target>
        </trans-unit>
        <trans-unit id="7051b09dcb61945ea4e0d3beb1e52e65c9014732" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;COPY FROM&lt;/code&gt;, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used with &lt;code&gt;COPY TO&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; を使用する場合、この文字列に一致するデータ項目はすべてnull値として格納されるため、 &lt;code&gt;COPY TO&lt;/code&gt; で使用したのと同じ文字列を使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="f8b5d7a27b46e73dc32c1b851c7dfef0ad7fe8a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is a good idea to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows &amp;mdash; you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">使用する場合は &lt;code&gt;LIMIT&lt;/code&gt; を、使用することをお勧めします &lt;code&gt;ORDER BY&lt;/code&gt; 一意な順序に結果の行を制約句。そうしないと、クエリの行の予測できないサブセットが取得されます。10番目から20番目までの行を要求する場合がありますが、10番目から20番目までの順序はどのようなものですか。 &lt;code&gt;ORDER BY&lt;/code&gt; を指定しない限り、どのような順序付けかはわかりません。</target>
        </trans-unit>
        <trans-unit id="481c23a58e8db851baee87afbfd06f8aa525bda9" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is important to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">使用する場合は &lt;code&gt;LIMIT&lt;/code&gt; を、使用することが重要である &lt;code&gt;ORDER BY&lt;/code&gt; 一意な順序に結果の行を制約句。そうしないと、クエリの行の予測できないサブセットが取得されます。あなたは10列目から20列目までを求めているかもしれませんが、10列目から20列目まではどのような順序ですか？ &lt;code&gt;ORDER BY&lt;/code&gt; を指定しない限り、順序は不明です。</target>
        </trans-unit>
        <trans-unit id="f85dc3be9cb7f009d076c5eedd8386addcb8b584" translate="yes" xml:space="preserve">
          <source>When using Kerberos authentication, SSPI works the same way GSSAPI does; see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details.</source>
          <target state="translated">Kerberos認証を使用する場合、SSPIはGSSAPIと同じように機能します。詳細は&lt;a href=&quot;gssapi-auth&quot;&gt;項20.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dc80b0e9ed4294e8911057b0a0a50261a196de62" translate="yes" xml:space="preserve">
          <source>When using POSIX semaphores, the number of semaphores needed is the same as for System V, that is one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;). On the platforms where this option is preferred, there is no specific kernel limit on the number of POSIX semaphores.</source>
          <target state="translated">POSIXセマフォを使用する場合、必要なセマフォの数はSystem Vの場合と同じです。つまり、許可された接続（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;）、許可されたautovacuumワーカープロセス（&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;）および許可されたバックグラウンドプロセス（&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;）ごとに1つのセマフォです。このオプションが推奨されるプラットフォームでは、POSIXセマフォの数に特定のカーネル制限はありません。</target>
        </trans-unit>
        <trans-unit id="0d87a93d2de1be22dab32dcbbc5446297da3c6d5" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="translated">RADIUS認証を使用する場合、構成されたRADIUSサーバーにアクセス要求メッセージが送信されます。この要求のタイプは &lt;code&gt;Authenticate Only&lt;/code&gt; であり、 &lt;code&gt;user name&lt;/code&gt; 、 &lt;code&gt;password&lt;/code&gt; （暗号化）、および &lt;code&gt;NAS Identifier&lt;/code&gt; パラメーターが含まれます。リクエストは、サーバーと共有されるシークレットを使用して暗号化されます。 RADIUSサーバーは、このサーバーに &lt;code&gt;Access Accept&lt;/code&gt; または &lt;code&gt;Access Reject&lt;/code&gt; のいずれかで応答します。 RADIUSアカウンティングはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="df1ce6f4ba5a71b98d3f24da1f9c50898361216d" translate="yes" xml:space="preserve">
          <source>When using System V semaphores, PostgreSQL uses one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;), in sets of 16. Each such set will also contain a 17th semaphore which contains a &amp;ldquo;magic number&amp;rdquo;, to detect collision with semaphore sets used by other applications. The maximum number of semaphores in the system is set by &lt;code&gt;SEMMNS&lt;/code&gt;, which consequently must be at least as high as &lt;code&gt;max_connections&lt;/code&gt; plus &lt;code&gt;autovacuum_max_workers&lt;/code&gt; plus &lt;code&gt;max_wal_senders&lt;/code&gt;, plus &lt;code&gt;max_worker_processes&lt;/code&gt;, plus one extra for each 16 allowed connections plus workers (see the formula in &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;Table 18.1&lt;/a&gt;). The parameter &lt;code&gt;SEMMNI&lt;/code&gt; determines the limit on the number of semaphore sets that can exist on the system at one time. Hence this parameter must be at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt;. Lowering the number of allowed connections is a temporary workaround for failures, which are usually confusingly worded &amp;ldquo;No space left on device&amp;rdquo;, from the function &lt;code&gt;semget&lt;/code&gt;.</source>
          <target state="translated">System Vセマフォを使用する場合、PostgreSQLは、許可された接続（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;）、許可された自動バキュームワーカープロセス（&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;）、および許可されたバックグラウンドプロセス（&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;）ごとに1つのセマフォを16のセットで使用します。このような各セットには、「他のアプリケーションで使用されているセマフォセットとの衝突を検出します。システム内のセマフォの最大数は &lt;code&gt;SEMMNS&lt;/code&gt; によって設定されるため、少なくとも &lt;code&gt;max_connections&lt;/code&gt; + &lt;code&gt;autovacuum_max_workers&lt;/code&gt; + &lt;code&gt;max_wal_senders&lt;/code&gt; + &lt;code&gt;max_worker_processes&lt;/code&gt; と同じ数にする必要があります。、さらに16の許可された接続ごとに1つの追加とワーカー（&lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;表18.1の&lt;/a&gt;式を参照）。 &lt;code&gt;SEMMNI&lt;/code&gt; パラメータは、システムに同時に存在できるセマフォセットの数の制限を決定します。したがって、このパラメーターは少なくとも &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; でなければなりません。許可される接続の数を減らすことは、障害の一時的な回避策です。これは通常、関数 &lt;code&gt;semget&lt;/code&gt; から「デバイスにスペースが残っていません」と紛らわしく言われています。</target>
        </trans-unit>
        <trans-unit id="c8382eef968bcd1841af0a45f03df20722ebed18" translate="yes" xml:space="preserve">
          <source>When using a replication setup with tools which perform direct copies of relation file blocks (for example &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;), enabling or disabling checksums can lead to page corruptions in the shape of incorrect checksums if the operation is not done consistently across all nodes. When enabling or disabling checksums in a replication setup, it is thus recommended to stop all the clusters before switching them all consistently. Destroying all standbys, performing the operation on the primary and finally recreating the standbys from scratch is also safe.</source>
          <target state="translated">リレーションファイルブロックの直接コピーを実行するツール（&lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewindなど&lt;/a&gt;）でレプリケーションセットアップを使用する場合、チェックサムを有効または無効にすると、操作がすべてのノードで一貫して行われていない場合、誤ったチェックサムの形でページが破損する可能性があります。したがって、レプリケーション設定でチェックサムを有効または無効にする場合、すべてのクラスターを一貫して切り替える前に、すべてのクラスターを停止することをお勧めします。すべてのスタンバイを破棄し、プライマリで操作を実行し、最後にスタンバイを最初から再作成しても安全です。</target>
        </trans-unit>
        <trans-unit id="eac93956f94fd1f4ae45bb87df2631e194bcbe28" translate="yes" xml:space="preserve">
          <source>When using a separate column to store the &lt;code&gt;tsvector&lt;/code&gt; representation of your documents, it is necessary to create a trigger to update the &lt;code&gt;tsvector&lt;/code&gt; column when the document content columns change. Two built-in trigger functions are available for this, or you can write your own.</source>
          <target state="translated">別の列を使用してドキュメントの &lt;code&gt;tsvector&lt;/code&gt; 表現を格納する場合、ドキュメントのコンテンツ列が変更されたときに &lt;code&gt;tsvector&lt;/code&gt; 列を更新するトリガーを作成する必要があります。これには2つの組み込みトリガー関数を使用できますが、独自に作成することもできます。</target>
        </trans-unit>
        <trans-unit id="9150f1a85447666f80a11e9912230df80685449c" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;archive_command&lt;/code&gt; script, it's desirable to enable &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;. Any messages written to stderr from the script will then appear in the database server log, allowing complex configurations to be diagnosed easily if they fail.</source>
          <target state="translated">&lt;code&gt;archive_command&lt;/code&gt; スクリプトを使用するときは、&lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;を有効にすることが望ましいです。スクリプトからstderrに書き込まれたメッセージはすべてデータベースサーバーログに表示されるため、複雑な構成が失敗した場合に簡単に診断できます。</target>
        </trans-unit>
        <trans-unit id="953b500ebbfdd4983d6d154f36b232db63c79506" translate="yes" xml:space="preserve">
          <source>When using an external authentication system such as Ident or GSSAPI, the name of the operating system user that initiated the connection might not be the same as the database user (role) that is to be used. In this case, a user name map can be applied to map the operating system user name to a database user. To use user name mapping, specify &lt;code&gt;map&lt;/code&gt;=&lt;code&gt;map-name&lt;/code&gt; in the options field in &lt;code&gt;pg_hba.conf&lt;/code&gt;. This option is supported for all authentication methods that receive external user names. Since different mappings might be needed for different connections, the name of the map to be used is specified in the &lt;code&gt;map-name&lt;/code&gt; parameter in &lt;code&gt;pg_hba.conf&lt;/code&gt; to indicate which map to use for each individual connection.</source>
          <target state="translated">IdentやGSSAPIなどの外部認証システムを使用する場合、接続を開始したオペレーティングシステムユーザーの名前は、使用されるデータベースユーザー（ロール）と同じでない場合があります。この場合、ユーザー名マップを適用して、オペレーティングシステムのユーザー名をデータベースユーザーにマップできます。ユーザー名マッピングを使用するには、 &lt;code&gt;pg_hba.conf&lt;/code&gt; のオプションフィールドで &lt;code&gt;map&lt;/code&gt; = &lt;code&gt;map-name&lt;/code&gt; を指定します。このオプションは、外部ユーザー名を受け取るすべての認証方法でサポートされています。異なる接続には異なるマッピングが必要になる場合があるため、使用する &lt;code&gt;map-name&lt;/code&gt; は、個々の接続ごとに使用するマップを示すために、 &lt;code&gt;pg_hba.conf&lt;/code&gt; のmap-nameパラメーターで指定されます。</target>
        </trans-unit>
        <trans-unit id="492838d017254285805f7e847c1bb4763dffb265" translate="yes" xml:space="preserve">
          <source>When using binary mode to pass query parameters to the server and query results back to the client, no encoding conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that PostgreSQL does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.</source>
          <target state="translated">バイナリモードを使用してクエリパラメータをサーバに渡し、クエリ結果をクライアントに返す場合、エンコーディング変換は行われませんので、状況は異なります。この場合、XMLデータ内の符号化宣言が観測され、それがない場合はUTF-8(XML標準で要求されている)とみなされます(PostgreSQLはUTF-16をサポートしていないことに注意してください)。PostgreSQLはUTF-16をサポートしていないことに注意してください。出力時には、クライアントのエンコーディングを指定するエンコーディング宣言があります。</target>
        </trans-unit>
        <trans-unit id="56607247aff04e4e074b7797ef04095046172c94" translate="yes" xml:space="preserve">
          <source>When using collations provided by the ICU library, the ICU-specific version of the collator is recorded in the system catalog when the collation object is created. When the collation is used, the current version is checked against the recorded version, and a warning is issued when there is a mismatch, for example:</source>
          <target state="translated">ICU ライブラリで提供されている照合順序を使用する場合、照合順序オブジェクトの作成時に、ICU固有の照合順序のバージョンがシステムカタログに記録される。照合を使用する際には、現在のバージョンと記録されているバージョンが照合され、不一致があった場合などに警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="de5896493e8d94d607ede6725d8b75b29f2f0f82" translate="yes" xml:space="preserve">
          <source>When using cost-based vacuuming, appropriate values for &lt;code&gt;vacuum_cost_delay&lt;/code&gt; are usually quite small, perhaps less than 1 millisecond. While &lt;code&gt;vacuum_cost_delay&lt;/code&gt; can be set to fractional-millisecond values, such delays may not be measured accurately on older platforms. On such platforms, increasing &lt;code&gt;VACUUM&lt;/code&gt;'s throttled resource consumption above what you get at 1ms will require changing the other vacuum cost parameters. You should, nonetheless, keep &lt;code&gt;vacuum_cost_delay&lt;/code&gt; as small as your platform will consistently measure; large delays are not helpful.</source>
          <target state="translated">コストベースのバキューム処理を使用する場合、 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; の適切な値は通常非常に小さく、おそらく1ミリ秒未満です。ながら &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 小数ミリ秒の値に設定することができ、このような遅延は、古いプラットフォーム上で正確に測定することはできません。そのようなプラットフォームでは、 &lt;code&gt;VACUUM&lt;/code&gt; の調整されたリソース消費を1msで得られる以上に増やすには、他のバキュームコストパラメーターを変更する必要があります。それでもなお、 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; は、プラットフォームが一貫して測定するのと同じくらい小さく保つ必要があります。大きな遅延は役に立ちません。</target>
        </trans-unit>
        <trans-unit id="75aee5f97d42018467b21311d706aa5a647707a9" translate="yes" xml:space="preserve">
          <source>When using exclusive backup mode, it is absolutely imperative to ensure that &lt;code&gt;pg_stop_backup&lt;/code&gt; completes successfully at the end of the backup. Even if the backup itself fails, for example due to lack of disk space, failure to call &lt;code&gt;pg_stop_backup&lt;/code&gt; will leave the server in backup mode indefinitely, causing future backups to fail and increasing the risk of a restart failure during the time that &lt;code&gt;backup_label&lt;/code&gt; exists.</source>
          <target state="translated">排他バックアップモードを使用する場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; がバックアップの最後に正常に完了するようにすることが絶対に不可欠です。たとえば、ディスク領域の不足が原因でバックアップ自体が失敗した場合でも、 &lt;code&gt;pg_stop_backup&lt;/code&gt; の呼び出しに失敗すると、サーバーが無期限にバックアップモードのままになるため、将来のバックアップが失敗し、 &lt;code&gt;backup_label&lt;/code&gt; が存在する間に再起動が失敗するリスクが高まります。</target>
        </trans-unit>
        <trans-unit id="ec73be80732f41a040847bc00566e73f63c25a96" translate="yes" xml:space="preserve">
          <source>When using link mode, standby servers can be quickly upgraded using rsync. To accomplish this, from a directory on the primary server that is above the old and new database cluster directories, run this on the &lt;em&gt;primary&lt;/em&gt; for each standby server:</source>
          <target state="translated">リンクモードを使用する場合、スタンバイサーバーはrsyncを使用してすばやくアップグレードできます。これを行うには、新旧のデータベースクラスタディレクトリの上にあるプライマリサーバーのディレクトリから、各スタンバイサーバーの&lt;em&gt;プライマリ&lt;/em&gt;でこれを実行します。</target>
        </trans-unit>
        <trans-unit id="7d1e98ef020032cfb9faf29c2d74acac7b1c192c" translate="yes" xml:space="preserve">
          <source>When using multiple &lt;code&gt;INSERT&lt;/code&gt;s, turn off autocommit and just do one commit at the end. (In plain SQL, this means issuing &lt;code&gt;BEGIN&lt;/code&gt; at the start and &lt;code&gt;COMMIT&lt;/code&gt; at the end. Some client libraries might do this behind your back, in which case you need to make sure the library does it when you want it done.) If you allow each insertion to be committed separately, PostgreSQL is doing a lot of work for each row that is added. An additional benefit of doing all insertions in one transaction is that if the insertion of one row were to fail then the insertion of all rows inserted up to that point would be rolled back, so you won't be stuck with partially loaded data.</source>
          <target state="translated">複数の &lt;code&gt;INSERT&lt;/code&gt; を使用する場合は、自動コミットをオフにして、最後に1回だけコミットしてください。 （プレーンSQLでは、これは最初に &lt;code&gt;BEGIN&lt;/code&gt; を発行し、最後に &lt;code&gt;COMMIT&lt;/code&gt; を発行することを意味します。一部のクライアントライブラリは、これを背後で実行する場合があります。その場合、ライブラリが必要なときに実行するようにする必要があります。）各挿入が個別にコミットされると、PostgreSQLは追加された各行に対して多くの作業を実行します。 1つのトランザクションですべての挿入を実行することの追加の利点は、1つの行の挿入が失敗した場合、その時点までに挿入されたすべての行の挿入がロールバックされるため、部分的にロードされたデータで立ち往生しないことです。</target>
        </trans-unit>
        <trans-unit id="8692847b55239c8542d72c31d947ca1f69e8f98c" translate="yes" xml:space="preserve">
          <source>When using pg_receivewal instead of &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; as the main WAL backup method, it is strongly recommended to use replication slots. Otherwise, the server is free to recycle or remove write-ahead log files before they are backed up, because it does not have any information, either from &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; or the replication slots, about how far the WAL stream has been archived. Note, however, that a replication slot will fill up the server's disk space if the receiver does not keep up with fetching the WAL data.</source>
          <target state="translated">メインのWALバックアップ方法として、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_commandの&lt;/a&gt;代わりにpg_receivewal を使用する場合、レプリケーションスロットを使用することを強くお勧めします。それ以外の場合、WALストリームがどこまでアーカイブされたかについての情報は&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;またはレプリケーションスロットから得られないため、バックアップする前に、サーバーは先読みログファイルを自由にリサイクルまたは削除できます。ただし、レシーバーがWALデータのフェッチに追いついていない場合、レプリケーションスロットがサーバーのディスク領域をいっぱいにすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7805e078bb69ca14f943ca44e9ff4b57cc0c775e" translate="yes" xml:space="preserve">
          <source>When using search+bind mode, the search can be performed using a single attribute specified with &lt;code&gt;ldapsearchattribute&lt;/code&gt;, or using a custom search filter specified with &lt;code&gt;ldapsearchfilter&lt;/code&gt;. Specifying &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; is equivalent to specifying &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt;. If neither option is specified the default is &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt;.</source>
          <target state="translated">検索+バインドモードを使用する場合、検索はして指定された単一の属性を用いて行うことができる &lt;code&gt;ldapsearchattribute&lt;/code&gt; を、またはで指定されたカスタム検索フィルタ使用 &lt;code&gt;ldapsearchfilter&lt;/code&gt; を。指定 &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; が指定するのと同じです &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt; 。どちらのオプションも指定されていない場合、デフォルトは &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ccf2c531c08aa10ba699a8b190067e047b3e70bf" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this timeframe. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="translated">静的ログファイル名を使用する場合、最大オープンファイル制限に達したり、ファイルテーブルのオーバーフローが発生したりすると、サーバーはログファイルを再度開くことができない場合があります。この場合、ログのローテーションが成功するまで、ログメッセージは古いログファイルに送信されます。logrotateがログファイルを圧縮して削除するように構成されている場合、サーバーはこの期間に記録されたメッセージを失う可能性があります。この問題を回避するには、ログファイル名を動的に割り当てるようにロギングコレクターを構成し、 &lt;code&gt;prerotate&lt;/code&gt; スクリプトを使用して開いているログファイルを無視します。</target>
        </trans-unit>
        <trans-unit id="ddcdbf5154b4eb280778c5288af6f89414cb4462" translate="yes" xml:space="preserve">
          <source>When using systemd, you can use the following service unit file (e.g., at &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt;):</source>
          <target state="translated">systemdを使用する場合、次のサービスユニットファイルを使用できます（例： &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="aa4f4b5954d77c90199a922670870bbe00993316" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt;モジュールを使用する場合、外部サーバーの名前を&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt;関数の引数として使用して、接続パラメーターを示すことができます。このように使用するには、外部サーバーに対する &lt;code&gt;USAGE&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="bd246a1d45857b9944b119a71ad8342fdd069e69" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. A column definition list can be placed after the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; construct only if there's just a single function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 構文を使用するときに、いずれかの関数で列定義リストが必要な場合は、 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 内の関数呼び出しの後に列定義リストを配置することをお勧めします。列定義リストは、関数が1つだけで &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 句がない場合にのみ、 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 構文の後に配置できます。</target>
        </trans-unit>
        <trans-unit id="98b68f1005505d22ba3f1b802a0a0796977dd397" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;extensions&lt;/code&gt; option, &lt;em&gt;it is the user's responsibility&lt;/em&gt; that the listed extensions exist and behave identically on both the local and remote servers. Otherwise, remote queries may fail or behave unexpectedly.</source>
          <target state="translated">&lt;code&gt;extensions&lt;/code&gt; オプションを使用する場合、リストされた拡張が存在し、ローカルサーバーとリモートサーバーの両方で同じように動作する&lt;em&gt;のはユーザーの責任&lt;/em&gt;です。そうしないと、リモートクエリが失敗するか、予期しない動作をする可能性があります。</target>
        </trans-unit>
        <trans-unit id="e797775100fdafb459cefc34e37395f8e226c9b6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;libc&lt;/code&gt; collation provider, the locale must be applicable to the current database encoding. See &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; for the precise rules.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 照合プロバイダーを使用する場合、ロケールは現在のデータベースエンコーディングに適用できる必要があります。正確な規則については、&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="33347a458dabb91eee87e22ef8743db48a2953ba" translate="yes" xml:space="preserve">
          <source>When using the statistics to monitor collected data, it is important to realize that the information does not update instantaneously. Each individual server process transmits new statistical counts to the collector just before going idle; so a query or transaction still in progress does not affect the displayed totals. Also, the collector itself emits a new report at most once per &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; milliseconds (500 ms unless altered while building the server). So the displayed information lags behind actual activity. However, current-query information collected by &lt;code&gt;track_activities&lt;/code&gt; is always up-to-date.</source>
          <target state="translated">収集されたデータを監視するために統計を使用する場合、情報が瞬時に更新されないことを認識することが重要です。個々のサーバープロセスはそれぞれ、アイドルになる直前に新しい統計カウントをコレクターに送信します。そのため、まだ進行中のクエリまたはトランザクションは、表示される合計に影響しません。また、コレクター自体は、 &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; ミリ秒（サーバーの構築中に変更されない限り500ミリ秒）ごとに最大1回、新しいレポートを発行します。そのため、表示される情報は実際のアクティビティよりも遅れています。ただし、 &lt;code&gt;track_activities&lt;/code&gt; によって収集される現在のクエリ情報は常に最新です。</target>
        </trans-unit>
        <trans-unit id="869040936f3cd63714aedfeb674cbbcb51ecde9f" translate="yes" xml:space="preserve">
          <source>When using this option together with &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, the text of statements that are logged because of &lt;code&gt;log_statement&lt;/code&gt; will not be repeated in the duration log message. If you are not using syslog, it is recommended that you log the PID or session ID using &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; so that you can link the statement message to the later duration message using the process ID or session ID.</source>
          <target state="translated">一緒にこのオプションを使用する場合&lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;、理由のログに記録されている文のテキスト &lt;code&gt;log_statement&lt;/code&gt; は持続ログメッセージの中で繰り返されることはありません。 syslogを使用していない場合は、&lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt;を使用してPIDまたはセッションIDをログに記録し、プロセスIDまたはセッションIDを使用してステートメントメッセージを後の期間メッセージにリンクできるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f56584dae166e0f5d41c03bae8959fb67da882b7" translate="yes" xml:space="preserve">
          <source>When using this technique, it will avoid creating an unnecessary burden for application programmers if the application software goes through a framework which automatically retries transactions which are rolled back with a serialization failure. It may be a good idea to set &lt;code&gt;default_transaction_isolation&lt;/code&gt; to &lt;code&gt;serializable&lt;/code&gt;. It would also be wise to take some action to ensure that no other transaction isolation level is used, either inadvertently or to subvert integrity checks, through checks of the transaction isolation level in triggers.</source>
          <target state="translated">この手法を使用すると、アプリケーションソフトウェアが、シリアライゼーションエラーでロールバックされたトランザクションを自動的に再試行するフレームワークを通過する場合に、アプリケーションプログラマーに不要な負担をかけることを回避できます。 &lt;code&gt;default_transaction_isolation&lt;/code&gt; を &lt;code&gt;serializable&lt;/code&gt; に設定することをお勧めします。また、トリガーのトランザクション分離レベルのチェックを通じて、他のトランザクション分離レベルが誤って使用されたり、整合性チェックを覆したりしないように、何らかのアクションをとることも賢明です。</target>
        </trans-unit>
        <trans-unit id="3e33ed6ffb66e09afb90b2aa31b40f235c917227" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="translated">チェックサムを検証するとき、クラスター内のすべてのファイルがスキャンされます。チェックサムを有効にすると、クラスター内のすべてのファイルが書き換えられます。チェックサムを無効にすると、ファイル &lt;code&gt;pg_control&lt;/code&gt; のみが更新されます。</target>
        </trans-unit>
        <trans-unit id="fda53778d06f68bfde32b3023f6347b2be67790d" translate="yes" xml:space="preserve">
          <source>When waiting, &lt;code&gt;pg_ctl&lt;/code&gt; repeatedly checks the server's PID file, sleeping for a short amount of time between checks. Startup is considered complete when the PID file indicates that the server is ready to accept connections. Shutdown is considered complete when the server removes the PID file. &lt;code&gt;pg_ctl&lt;/code&gt; returns an exit code based on the success of the startup or shutdown.</source>
          <target state="translated">待機中、 &lt;code&gt;pg_ctl&lt;/code&gt; はサーバーのPIDファイルを繰り返しチェックし、チェックとチェックの間の短い時間スリープします。サーバーが接続を受け入れる準備ができていることをPIDファイルが示している場合、起動は完了したと見なされます。サーバーがPIDファイルを削除すると、シャットダウンは完了したと見なされます。 &lt;code&gt;pg_ctl&lt;/code&gt; は、起動またはシャットダウンの成功に基づいて終了コードを返します。</target>
        </trans-unit>
        <trans-unit id="319a6ac32ba7d37c93ad8b3aed41a7b25d9cd283" translate="yes" xml:space="preserve">
          <source>When we speak of inheriting the locale from the execution environment, this means the following on most operating systems: For a given locale category, say the collation, the following environment variables are consulted in this order until one is found to be set: &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; (or the variable corresponding to the respective category), &lt;code&gt;LANG&lt;/code&gt;. If none of these environment variables are set then the locale defaults to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">実行環境からロケールを継承するとは、ほとんどのオペレーティングシステムで次のことを意味します。特定のロケールカテゴリ（照合など）では、設定が見つかるまで、次の環境変数がこの順序で参照されます： &lt;code&gt;LC_ALL&lt;/code&gt; 、 &lt;code&gt;LC_COLLATE&lt;/code&gt; （またはそれぞれのカテゴリに対応する変数）、 &lt;code&gt;LANG&lt;/code&gt; 。これらの環境変数が設定されていない場合、ロケールはデフォルトで &lt;code&gt;C&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="09870d0ba2815a6a474afa8adde88701322779a5" translate="yes" xml:space="preserve">
          <source>When we write</source>
          <target state="translated">書くときは</target>
        </trans-unit>
        <trans-unit id="5f55fad869d686971a61de9989dadab77ae5eb95" translate="yes" xml:space="preserve">
          <source>When working with an inner tuple having unlabeled nodes, it is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since the set of nodes is supposed to be fixed in such cases.</source>
          <target state="translated">ラベルのないノードを持つ内部タプルを操作する場合、ノードのセットはそのような場合に修正されることが想定されているため、 &lt;code&gt;spgAddNode&lt;/code&gt; を返すことを &lt;code&gt;choose&lt;/code&gt; するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="513c84ce8934fc59619703510a7a572aaca0c319" translate="yes" xml:space="preserve">
          <source>When working with multiple tables, it can also be useful to ask for all the columns of a particular table:</source>
          <target state="translated">複数のテーブルを扱う際には、特定のテーブルのすべての列を求めるのも便利です。</target>
        </trans-unit>
        <trans-unit id="3f387116d6a98de65f13445ebf4c25f94df15576" translate="yes" xml:space="preserve">
          <source>When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a left unary operator named &lt;code&gt;@&lt;/code&gt;, you cannot write &lt;code&gt;X*@Y&lt;/code&gt;; you must write &lt;code&gt;X* @Y&lt;/code&gt; to ensure that PostgreSQL reads it as two operator names not one.</source>
          <target state="translated">SQL標準以外の演算子名を使用する場合は、曖昧さを避けるために、隣接する演算子をスペースで区切る必要があります。たとえば、 &lt;code&gt;@&lt;/code&gt; という名前の左単項演算子を定義した場合、 &lt;code&gt;X*@Y&lt;/code&gt; 書くことはできません。 &lt;code&gt;X* @Y&lt;/code&gt; と記述して、PostgreSQLがそれを1つではなく2つの演算子名として読み取るようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="ec3a2849e7e7665d1ef0586b393970fa38e06c50" translate="yes" xml:space="preserve">
          <source>When working with recursive queries it is important to be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. Sometimes, using &lt;code&gt;UNION&lt;/code&gt; instead of &lt;code&gt;UNION ALL&lt;/code&gt; can accomplish this by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are completely duplicate: it may be necessary to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the already-visited values. For example, consider the following query that searches a table &lt;code&gt;graph&lt;/code&gt; using a &lt;code&gt;link&lt;/code&gt; field:</source>
          <target state="translated">再帰クエリを使用する場合、クエリの再帰部分が最終的にタプルを返さないことを確認することが重要です。そうしないと、クエリが無限にループします。時には、使用して &lt;code&gt;UNION&lt;/code&gt; の代わりに &lt;code&gt;UNION ALL&lt;/code&gt; は、前回の出力行を複製する行を破棄することによって、これを達成することができます。ただし、多くの場合、サイクルには完全に重複する出力行は含まれません。同じポイントに以前に到達したかどうかを確認するために、1つまたはいくつかのフィールドのみをチェックする必要がある場合があります。このような状況を処理するための標準的な方法は、すでにアクセスした値の配列を計算することです。たとえば、 &lt;code&gt;link&lt;/code&gt; フィールドを使用してテーブル &lt;code&gt;graph&lt;/code&gt; を検索する次のクエリを考えてみます。</target>
        </trans-unit>
        <trans-unit id="e5718cfeb2fe2d91286009aaf2e77c006f835bbe" translate="yes" xml:space="preserve">
          <source>When writing an interval constant with a &lt;code&gt;fields&lt;/code&gt; specification, or when assigning a string to an interval column that was defined with a &lt;code&gt;fields&lt;/code&gt; specification, the interpretation of unmarked quantities depends on the &lt;code&gt;fields&lt;/code&gt;. For example &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; is read as 1 year, whereas &lt;code&gt;INTERVAL '1'&lt;/code&gt; means 1 second. Also, field values &amp;ldquo;to the right&amp;rdquo; of the least significant field allowed by the &lt;code&gt;fields&lt;/code&gt; specification are silently discarded. For example, writing &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; results in dropping the seconds field, but not the day field.</source>
          <target state="translated">間隔を一定に書き込む際 &lt;code&gt;fields&lt;/code&gt; で定義された間隔の列に文字列を割り当てるとき仕様、または &lt;code&gt;fields&lt;/code&gt; 仕様、マークされていない量の解釈は、に依存する &lt;code&gt;fields&lt;/code&gt; 。たとえば、 &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; は1年として読み取られますが、 &lt;code&gt;INTERVAL '1'&lt;/code&gt; は1秒を意味します。また、 &lt;code&gt;fields&lt;/code&gt; 仕様で許可されている最下位フィールドの「右側」のフィールド値は、通知なく破棄されます。たとえば、 &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; と入力すると、秒フィールドは削除されますが、日フィールドは削除されません。</target>
        </trans-unit>
        <trans-unit id="988ef8be5d9c8af4c97d0fc59910f990922134e4" translate="yes" xml:space="preserve">
          <source>When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.</source>
          <target state="translated">テーブルを作成していて、間違いを犯したことに気づいたり、アプリケーションの要件が変更されたりした場合、そのテーブルを削除して再度作成することができます。しかし、テーブルが既にデータで埋め尽くされている場合や、テーブルが他のデータベースオブジェクト(例えば外部キー制約)から参照されている場合には、これは便利なオプションではありません。そこでPostgreSQLでは、既存のテーブルを変更するためのコマンド群を提供しています。これは、テーブルに含まれるデータを変更することとは概念的に異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="63a09c13346cb20d8d1dd7186def1b2a2f01cbc1" translate="yes" xml:space="preserve">
          <source>When you create complex database structures involving many tables with foreign key constraints, views, triggers, functions, etc. you implicitly create a net of dependencies between the objects. For instance, a table with a foreign key constraint depends on the table it references.</source>
          <target state="translated">外部キー制約、ビュー、トリガ、関数などを持つ多くのテーブルを含む複雑なデータベース構造を作成する場合、オブジェクト間に暗黙のうちに依存関係のネットを作成します。例えば、外部キー制約を持つテーブルは、それが参照するテーブルに依存します。</target>
        </trans-unit>
        <trans-unit id="b9a5344aa581794cb8d710e210bdb65e511f2134" translate="yes" xml:space="preserve">
          <source>When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other.</source>
          <target state="translated">多くの相互に関連した表を作成するときは、表と列に一貫した命名パターンを選択するのが賢明です。例えば、テーブル名には単数形または複数形の名詞を使用することができます。</target>
        </trans-unit>
        <trans-unit id="593e96c33f6f0aab676c4ca184c4ca854f13bc97" translate="yes" xml:space="preserve">
          <source>When you insert invalid numbers in a table using the weak mode, the number will be inserted with the corrected check digit, but it will be displayed with an exclamation mark (&lt;code&gt;!&lt;/code&gt;) at the end, for example &lt;code&gt;0-11-000322-5!&lt;/code&gt;. This invalid marker can be checked with the &lt;code&gt;is_valid&lt;/code&gt; function and cleared with the &lt;code&gt;make_valid&lt;/code&gt; function.</source>
          <target state="translated">ウィークモードを使用してテーブルに無効な数値を挿入すると、数値は修正されたチェックデジットとともに挿入されますが、末尾に感嘆符（ &lt;code&gt;!&lt;/code&gt; ）が表示されます（例： &lt;code&gt;0-11-000322-5!&lt;/code&gt; )。。この無効なマーカーは、 &lt;code&gt;is_valid&lt;/code&gt; 関数で確認し、make_valid関数でクリア &lt;code&gt;make_valid&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="1bf59c49779a368d436367de404fed33cad74dcd" translate="yes" xml:space="preserve">
          <source>When you query JSON data, the path expression may not match the actual JSON data structure. An attempt to access a non-existent member of an object or element of an array results in a structural error. SQL/JSON path expressions have two modes of handling structural errors:</source>
          <target state="translated">JSON データをクエリすると、パス式が実際の JSON データ構造と一致しない場合があります。オブジェクトの存在しないメンバーや配列の要素にアクセスしようとすると、構造エラーが発生します。SQL/JSONパス式には、構造エラーを処理するための2つのモードがあります。</target>
        </trans-unit>
        <trans-unit id="d3780caf73c39bd4ac2d31b375fc0dd6e1923bd0" translate="yes" xml:space="preserve">
          <source>When you write the argument of a sequence function as an unadorned literal string, it becomes a constant of type &lt;code&gt;regclass&lt;/code&gt;. Since this is really just an OID, it will track the originally identified sequence despite later renaming, schema reassignment, etc. This &amp;ldquo;early binding&amp;rdquo; behavior is usually desirable for sequence references in column defaults and views. But sometimes you might want &amp;ldquo;late binding&amp;rdquo; where the sequence reference is resolved at run time. To get late-binding behavior, force the constant to be stored as a &lt;code&gt;text&lt;/code&gt; constant instead of &lt;code&gt;regclass&lt;/code&gt;:</source>
          <target state="translated">シーケンス関数の引数を修飾されていないリテラル文字列として書き込むと、それは &lt;code&gt;regclass&lt;/code&gt; 型の定数になります。これは実際には単なるOIDなので、後で名前を変更したり、スキーマを再割り当てしたりしても、最初に識別されたシーケンスを追跡します。この「早期バインディング」の動作は、通常、列のデフォルトおよびビューでのシーケンス参照に適しています。ただし、実行時にシーケンス参照が解決される「遅延バインディング」が必要になる場合があります。レイトバインディング動作を取得するには、定数を &lt;code&gt;regclass&lt;/code&gt; ではなく &lt;code&gt;text&lt;/code&gt; 定数として強制的に保存します。</target>
        </trans-unit>
        <trans-unit id="2507ec70331a5deab93cd40d826b1bdba44ecbc3" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; view will contain a row for each backend that is currently running either command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; が実行されているときはいつでも、 &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; ビューには、現在いずれかのコマンドを実行している各バックエンドの行が含まれます。以下の表は、報告される情報とその解釈方法について説明しています。</target>
        </trans-unit>
        <trans-unit id="51b73a7d0ff3b39db66ff19d5f58e0f20613bb45" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; view will contain one row for each backend that is currently creating indexes. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; または &lt;code&gt;REINDEX&lt;/code&gt; が実行されているときは常に、 &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; ビューには、現在インデックスを作成しているバックエンドごとに1行が含まれます。以下の表は、報告される情報とその解釈方法について説明しています。</target>
        </trans-unit>
        <trans-unit id="0da2e4c266065ef5b47dc244d1142646be363723" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; が実行されているときは常に、 &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; ビューには、現在バキュームされているバックエンド（autovacuumワーカープロセスを含む）ごとに1行が含まれます。以下の表は、報告される情報とその解釈方法について説明しています。 &lt;code&gt;VACUUM FULL&lt;/code&gt; と &lt;code&gt;CLUSTER&lt;/code&gt; は両方ともテーブルを書き換えますが、通常の &lt;code&gt;VACUUM&lt;/code&gt; はその場で変更するだけなので、 &lt;code&gt;VACUUM FULL&lt;/code&gt; コマンドの進行状況は &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; を介して報告されます。&lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;セクション27.4.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="48d664025546cdeafdfe0701b9fa38130d919c75" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; scans any part of a table, it will replace any multixact ID it encounters which is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;, an aggressive vacuum is forced. As discussed in the previous section, an aggressive vacuum means that only those pages which are known to be all-frozen will be skipped. &lt;code&gt;mxid_age()&lt;/code&gt; can be used on &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; to find its age.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; がテーブルの任意の部分をスキャンするときは常に、&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt;よりも古いmultixact IDを別の値（ゼロ値、単一のトランザクションID、または新しいmultixact ID）に置き換えることができます。テーブルごとに &lt;code&gt;pg_class&lt;/code&gt; 。 &lt;code&gt;relminmxid&lt;/code&gt; は、そのテーブルの任意のタプルにまだ表示されている可能な最も古いmultixact IDを格納します。この値が&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;よりも古い場合、積極的なバキュームが強制されます。前のセクションで説明したように、アグレッシブなバキュームとは、すべて凍結されていることがわかっているページだけがスキップされることを意味します。 &lt;code&gt;mxid_age()&lt;/code&gt; は &lt;code&gt;pg_class&lt;/code&gt; で使用できます。 &lt;code&gt;relminmxid&lt;/code&gt; その年齢を見つける。</target>
        </trans-unit>
        <trans-unit id="5f844cc225201cbe85cbdde3d905d07e347e61a8" translate="yes" xml:space="preserve">
          <source>Whenever PostgreSQL needs to combine rows from multiple sources into a single result set, it uses an &lt;code&gt;Append&lt;/code&gt; or &lt;code&gt;MergeAppend&lt;/code&gt; plan node. This commonly happens when implementing &lt;code&gt;UNION ALL&lt;/code&gt; or when scanning a partitioned table. Such nodes can be used in parallel plans just as they can in any other plan. However, in a parallel plan, the planner may instead use a &lt;code&gt;Parallel Append&lt;/code&gt; node.</source>
          <target state="translated">PostgreSQLは、複数のソースからの行を単一の結果セットに組み合わせる必要がある場合は常に、 &lt;code&gt;Append&lt;/code&gt; または &lt;code&gt;MergeAppend&lt;/code&gt; プランノードを使用します。これは通常、 &lt;code&gt;UNION ALL&lt;/code&gt; を実装するとき、または分割テーブルをスキャンするときに発生します。このようなノードは、他のプランと同様に、並列プランで使用できます。ただし、並列プランでは、プランナは代わりに &lt;code&gt;Parallel Append&lt;/code&gt; ノードを使用できます。</target>
        </trans-unit>
        <trans-unit id="85e82d59ea38cfaea7777dbbbcc2b327247984a8" translate="yes" xml:space="preserve">
          <source>Whenever a command is executed, psql also polls for asynchronous notification events generated by &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;.</source>
          <target state="translated">コマンドが実行されるたびに、psqlは&lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt;および&lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;によって生成された非同期通知イベントもポーリングします。</target>
        </trans-unit>
        <trans-unit id="fe283c15f98e1d6878cfeeadd5bbfd6c5078c552" translate="yes" xml:space="preserve">
          <source>Whenever a user-defined type is created, PostgreSQL automatically creates an associated array type, whose name consists of the element type's name prepended with an underscore, and truncated if necessary to keep it less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long. (If the name so generated collides with an existing type name, the process is repeated until a non-colliding name is found.) This implicitly-created array type is variable length and uses the built-in input and output functions &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. The array type tracks any changes in its element type's owner or schema, and is dropped if the element type is.</source>
          <target state="translated">ユーザー定義型が作成されるたびに、PostgreSQLは関連付けられた配列型を自動的に作成します。その名前は、要素型の名前の前に下線を付けたもので、 &lt;code&gt;NAMEDATALEN&lt;/code&gt; バイト未満に保つために必要に応じて切り捨てられます。 （そのように生成された名前が既存のタイプ名と衝突する場合、衝突しない名前が見つかるまでこのプロセスが繰り返されます。）この暗黙的に作成された配列タイプは可変長であり、組み込みの入出力関数 &lt;code&gt;array_in&lt;/code&gt; および &lt;code&gt;array_out&lt;/code&gt; を使用します。配列型は、その要素型の所有者またはスキーマの変更を追跡し、要素型がそうである場合は削除されます。</target>
        </trans-unit>
        <trans-unit id="c317e2f18ac74c5065186374d831c55658598512" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by a single backend, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;0&lt;/code&gt;, i.e., no forced writeback. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the maximum value scales proportionally to it.)</source>
          <target state="translated">この量を超えるデータが単一のバックエンドによって書き込まれた場合は、OSに強制的にこれらの書き込みを基盤となるストレージに発行させてください。そうすることで、カーネルのページキャッシュ内のダーティデータの量が制限され、チェックポイントの最後に &lt;code&gt;fsync&lt;/code&gt; が発行されたとき、またはOSがバックグラウンドで大きなバッチでデータを書き戻したときに、ストールの可能性が減少します。多くの場合、トランザクションのレイテンシが大幅に削減されますが、特に、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;より大きく、OSのページキャッシュよりも小さいワークロードでは、パフォーマンスが低下する場合もあります。この設定は、一部のプラットフォームでは効果がない場合があります。この値が単位なしで指定された場合、それはブロック、つまり &lt;code&gt;BLCKSZ&lt;/code&gt; と見なされますバイト、通常8kB。有効な範囲は、強制ライトバックを無効にする &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;2MB&lt;/code&gt; の間です。デフォルトは &lt;code&gt;0&lt;/code&gt; です。つまり、強制的な書き戻しはありません。 （ &lt;code&gt;BLCKSZ&lt;/code&gt; が8kBでない場合、最大値はそれに比例してスケーリングされます。）</target>
        </trans-unit>
        <trans-unit id="de89b6016c756123d6b9441e22d55848a32a9ab3" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;512kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">この量を超えるデータがバックグラウンドライターによって書き込まれた場合は常に、OSに強制的にこれらの書き込みを基盤となるストレージに発行させてください。そうすることで、カーネルのページキャッシュ内のダーティデータの量が制限され、チェックポイントの最後に &lt;code&gt;fsync&lt;/code&gt; が発行されたとき、またはOSがバックグラウンドで大きなバッチでデータを書き戻したときに、ストールの可能性が減少します。多くの場合、トランザクションのレイテンシが大幅に削減されますが、特に、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;より大きく、OSのページキャッシュよりも小さいワークロードでは、パフォーマンスが低下する場合もあります。この設定は、一部のプラットフォームでは効果がない場合があります。この値が単位なしで指定された場合、それはブロック、つまり &lt;code&gt;BLCKSZ&lt;/code&gt; と見なされますバイト、通常8kB。有効な範囲は、強制ライトバックを無効にする &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;2MB&lt;/code&gt; の間です。Linuxではデフォルトは &lt;code&gt;512kB&lt;/code&gt; 、それ以外では &lt;code&gt;0&lt;/code&gt; です。 （ &lt;code&gt;BLCKSZ&lt;/code&gt; が8kBでない場合、デフォルト値と最大値はそれに比例してスケーリングされます。）このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="41035af23763d236bc43d7713084261d3a812120" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written while performing a checkpoint, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of the checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;256kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">チェックポイントの実行中に、この量を超えるデータが書き込まれた場合は、OSに強制的にこれらの書き込みを基盤となるストレージに発行させてください。そうすることで、カーネルのページキャッシュ内のダーティデータの量が制限され、チェックポイントの最後に &lt;code&gt;fsync&lt;/code&gt; が発行されたとき、またはOSがバックグラウンドで大きなバッチでデータを書き戻したときに停止する可能性が低くなります。多くの場合、トランザクションのレイテンシが大幅に削減されますが、特に、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;より大きく、OSのページキャッシュよりも小さいワークロードでは、パフォーマンスが低下する場合もあります。この設定は、一部のプラットフォームでは効果がない場合があります。この値が単位なしで指定された場合、それはブロック、つまり &lt;code&gt;BLCKSZ&lt;/code&gt; と見なされますバイト、通常8kB。有効な範囲は、強制ライトバックを無効にする &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;2MB&lt;/code&gt; の間です。Linuxではデフォルトは &lt;code&gt;256kB&lt;/code&gt; 、それ以外では &lt;code&gt;0&lt;/code&gt; です。 （ &lt;code&gt;BLCKSZ&lt;/code&gt; が8kBでない場合、デフォルト値と最大値はそれに比例してスケーリングされます。）このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="cafdfe0e40c272ef5695922c2a975f51df9e1cea" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;pattern&lt;/code&gt; parameter is omitted completely, the &lt;code&gt;\d&lt;/code&gt; commands display all objects that are visible in the current schema search path &amp;mdash; this is equivalent to using &lt;code&gt;*&lt;/code&gt; as the pattern. (An object is said to be &lt;em&gt;visible&lt;/em&gt; if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use &lt;code&gt;*.*&lt;/code&gt; as the pattern.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; パラメータが完全に省略されている場合は常に、 &lt;code&gt;\d&lt;/code&gt; コマンドは現在のスキーマ検索パスに表示されているすべてのオブジェクトを表示します。これは &lt;code&gt;*&lt;/code&gt; をパターンとして使用することと同じです。 （オブジェクトを含むスキーマが検索パスにあり、同じ種類と名前のオブジェクトが検索パスの前にない場合、オブジェクトは&lt;em&gt;可視で&lt;/em&gt;あると言います。これは、明示的なスキーマなしでオブジェクトを名前で参照できるというステートメントと同等です修飾。）可視性に関係なくデータベース内のすべてのオブジェクトを表示するには、 &lt;code&gt;*.*&lt;/code&gt; をパターンとして使用します。</target>
        </trans-unit>
        <trans-unit id="2dffd7d6d50f37b1f139649fc2afe46f33411c06" translate="yes" xml:space="preserve">
          <source>Whenever the command &lt;code&gt;NOTIFY channel&lt;/code&gt; is invoked, either by this session or another one connected to the same database, all the sessions currently listening on that notification channel are notified, and each will in turn notify its connected client application.</source>
          <target state="translated">このセッションまたは同じデータベースに接続されている別のセッションによってコマンド &lt;code&gt;NOTIFY channel&lt;/code&gt; が呼び出されると、その通知チャネルで現在リッスンしているすべてのセッションが通知され、それぞれが接続されているクライアントアプリケーションに通知します。</target>
        </trans-unit>
        <trans-unit id="464c9a84b9274c416e8217076cf62d6ce77919b2" translate="yes" xml:space="preserve">
          <source>Whenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. This only happens at login time; executing &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; or &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; does not cause new configuration values to be set. Settings set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.</source>
          <target state="translated">その後、ロールが新しいセッションを開始するたびに、指定された値がセッションのデフォルトになり、 &lt;code&gt;postgresql.conf&lt;/code&gt; に存在する設定または &lt;code&gt;postgres&lt;/code&gt; コマンドラインから受け取った設定を上書きします。これはログイン時にのみ発生します。&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;または&lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATIONを&lt;/a&gt;実行しても、新しい構成値は設定されません。すべてのデータベースに設定された設定は、ロールにアタッチされたデータベース固有の設定によって上書きされます。特定のデータベースまたは特定のロールの設定は、すべてのロールの設定を上書きします。</target>
        </trans-unit>
        <trans-unit id="1cb07a399aec26555c15e193c16effe1e79f48af" translate="yes" xml:space="preserve">
          <source>Whenever you create a table, a composite type is also automatically created, with the same name as the table, to represent the table's row type. For example, had we said:</source>
          <target state="translated">テーブルを作成すると、テーブルと同じ名前の複合型も自動的に作成され、テーブルの行の型を表します。例えば、私たちが言っていたのは</target>
        </trans-unit>
        <trans-unit id="72417af150626f41547b564cc2af3102889d282f" translate="yes" xml:space="preserve">
          <source>Whenever you have significantly altered the distribution of data within a table, running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; is strongly recommended. This includes bulk loading large amounts of data into the table. Running &lt;code&gt;ANALYZE&lt;/code&gt; (or &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;) ensures that the planner has up-to-date statistics about the table. With no statistics or obsolete statistics, the planner might make poor decisions during query planning, leading to poor performance on any tables with inaccurate or nonexistent statistics. Note that if the autovacuum daemon is enabled, it might run &lt;code&gt;ANALYZE&lt;/code&gt; automatically; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">テーブル内のデータの分布を大幅に変更した場合は、&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZEを&lt;/a&gt;実行することを強くお勧めします。これには、テーブルへの大量のデータの一括読み込みが含まれます。実行 &lt;code&gt;ANALYZE&lt;/code&gt; （または &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; は）プランナがテーブルに関する最新の統計情報を持っていることを保証します。統計がないか古い統計があると、プランナはクエリの計画中に不適切な決定を下し、統計が不正確または存在しないテーブルのパフォーマンスが低下する可能性があります。 autovacuumデーモンが有効になっている場合、 &lt;code&gt;ANALYZE&lt;/code&gt; が自動的に実行される可能性があることに注意してください。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="70267c330cb08a0ff5a2a298e316262a59a144c4" translate="yes" xml:space="preserve">
          <source>Where interoperability with other systems is a concern, for some data types, it may be necessary to use data type formatting functions (such as those in &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) explicitly to produce the standard mappings.</source>
          <target state="translated">他のシステムとの相互運用性が懸念される場合、一部のデータ型では、標準のマッピングを生成するためにデータ型フォーマット関数（&lt;a href=&quot;functions-formatting&quot;&gt;セクション9.8の&lt;/a&gt;関数など）を明示的に使用する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="de87765a2f74958f3598da9f1ae5cd4df124304a" translate="yes" xml:space="preserve">
          <source>Where the command omits database name, user, host, or port, the new connection can reuse values from the previous connection. By default, values from the previous connection are reused except when processing a &lt;code&gt;conninfo&lt;/code&gt; string. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. When the command neither specifies nor reuses a particular parameter, the libpq default is used. Specifying any of &lt;code&gt;dbname&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter. If &lt;code&gt;hostaddr&lt;/code&gt; was specified in the original connection's &lt;code&gt;conninfo&lt;/code&gt;, that address is reused for the new connection (disregarding any other host specification).</source>
          <target state="translated">コマンドがデータベース名、ユーザー、ホスト、またはポートを省略している場合、新しい接続は以前の接続の値を再利用できます。デフォルトでは、 &lt;code&gt;conninfo&lt;/code&gt; 文字列を処理する場合を除いて、以前の接続の値が再利用されます。 &lt;code&gt;-reuse-previous=on&lt;/code&gt; または &lt;code&gt;-reuse-previous=off&lt;/code&gt; の最初の引数を渡すと、そのデフォルトが上書きされます。コマンドが特定のパラメーターを指定も再利用もしない場合、libpqのデフォルトが使用されます。 &lt;code&gt;dbname&lt;/code&gt; 、 &lt;code&gt;username&lt;/code&gt; 、 &lt;code&gt;host&lt;/code&gt; または &lt;code&gt;port&lt;/code&gt; のいずれかを &lt;code&gt;-&lt;/code&gt; として指定することは、そのパラメーターを省略することと同じです。元の接続の &lt;code&gt;conninfo&lt;/code&gt; で &lt;code&gt;hostaddr&lt;/code&gt; が指定されていた場合、そのアドレスは新しい接続に再利用されます（他のホスト指定は無視されます）。</target>
        </trans-unit>
        <trans-unit id="f9b1968453a400f5fd07425f7b52ed24d9c6b52b" translate="yes" xml:space="preserve">
          <source>Where the current standard provides a family of XML data types to hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo; in untyped or XML Schema-typed variants, and a type &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; to hold arbitrary pieces of XML content, PostgreSQL provides the single &lt;code&gt;xml&lt;/code&gt; type, which can hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo;. There is no equivalent of the standard's &amp;ldquo;sequence&amp;rdquo; type.</source>
          <target state="translated">現在の標準は、型なしまたはXMLスキーマ型のバリアントで「ドキュメント」または「コンテンツ」を保持するXMLデータタイプのファミリーと、XMLコンテンツの任意の部分を保持するタイプ &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; を提供しますが、PostgreSQLは単一の &lt;code&gt;xml&lt;/code&gt; タイプを提供します、「ドキュメント」または「コンテンツ」を保持できます。標準の「シーケンス」タイプに相当するものはありません。</target>
        </trans-unit>
        <trans-unit id="9be0ce89e49423198dedc7c03fd710b9a77c7468" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;pgstattuple&lt;/code&gt; always performs a full-table scan and returns an exact count of live and dead tuples (and their sizes) and free space, &lt;code&gt;pgstattuple_approx&lt;/code&gt; tries to avoid the full-table scan and returns exact dead tuple statistics along with an approximation of the number and size of live tuples and free space.</source>
          <target state="translated">一方 &lt;code&gt;pgstattuple&lt;/code&gt; は常にフルテーブルスキャンとリターンの正確なライブや死んだタプルの数（とそのサイズ）と空き領域、実行 &lt;code&gt;pgstattuple_approx&lt;/code&gt; の数の近似値と一緒にフルテーブルスキャンおよびリターン正確な死者のタプル統計を回避しようとしますライブタプルと空き容量のサイズ。</target>
        </trans-unit>
        <trans-unit id="9ec341d8bc6b0b4825eb80f0ff91c4f3ae8eee3b" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;aggfinalfn&lt;/code&gt; modifies the transition state value: &lt;code&gt;r&lt;/code&gt; if it is read-only, &lt;code&gt;s&lt;/code&gt; if the &lt;code&gt;aggtransfn&lt;/code&gt; cannot be applied after the &lt;code&gt;aggfinalfn&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; if it writes on the value</source>
          <target state="translated">か &lt;code&gt;aggfinalfn&lt;/code&gt; 修正遷移状態値： &lt;code&gt;r&lt;/code&gt; それは読み取り専用の場合、 &lt;code&gt;s&lt;/code&gt; の場合 &lt;code&gt;aggtransfn&lt;/code&gt; の後に適用することができない &lt;code&gt;aggfinalfn&lt;/code&gt; 、または &lt;code&gt;w&lt;/code&gt; の場合には値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="b63ddfd6a1548ba35d00a888f441158a5e09419b" translate="yes" xml:space="preserve">
          <source>Whether an RE is greedy or not is determined by the following rules:</source>
          <target state="translated">REが欲張りかどうかは、以下のルールで決まります。</target>
        </trans-unit>
        <trans-unit id="a052d21cc109877e0a34f6fceb8177147b8e054e" translate="yes" xml:space="preserve">
          <source>Whether the sequence cycles</source>
          <target state="translated">シーケンスサイクルの有無</target>
        </trans-unit>
        <trans-unit id="099ca603e257bb42c8d0080a36e8a200732df4c1" translate="yes" xml:space="preserve">
          <source>Whether to convert &lt;code&gt;\n&lt;/code&gt; into &lt;code&gt;\r\n&lt;/code&gt; when encrypting and &lt;code&gt;\r\n&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; when decrypting. RFC 4880 specifies that text data should be stored using &lt;code&gt;\r\n&lt;/code&gt; line-feeds. Use this to get fully RFC-compliant behavior.</source>
          <target state="translated">暗号化時に &lt;code&gt;\n&lt;/code&gt; を &lt;code&gt;\r\n&lt;/code&gt; 、復号化時に &lt;code&gt;\r\n&lt;/code&gt; を &lt;code&gt;\n&lt;/code&gt; に変換するかどうか。RFC 4880では、テキストデータは &lt;code&gt;\r\n&lt;/code&gt; 改行を使用して保存するように規定されています。これを使用して、完全にRFC準拠の動作を取得します。</target>
        </trans-unit>
        <trans-unit id="6a913bec72a9d1cd9190d3ca3274a90d4c381b09" translate="yes" xml:space="preserve">
          <source>Whether to convert textual data from database internal encoding to UTF-8 and back. If your database already is UTF-8, no conversion will be done, but the message will be tagged as UTF-8. Without this option it will not be.</source>
          <target state="translated">データベースの内部エンコーディングからテキストデータをUTF-8に変換して戻すかどうか。データベースが既にUTF-8の場合、変換は行われませんが、メッセージはUTF-8としてタグ付けされます。このオプションがない場合は、変換されません。</target>
        </trans-unit>
        <trans-unit id="5d0908bbd26e431175b3928caa067e2b55410af7" translate="yes" xml:space="preserve">
          <source>Which S2K algorithm to use.</source>
          <target state="translated">どのS2Kアルゴリズムを使うか。</target>
        </trans-unit>
        <trans-unit id="1b435ac17c99f4ed78933b5d05d5b47d3dfdd820" translate="yes" xml:space="preserve">
          <source>Which cipher algorithm to use.</source>
          <target state="translated">どの暗号アルゴリズムを使うか</target>
        </trans-unit>
        <trans-unit id="4215d6c5a786cf08cc1b93732554ac25c2ba7716" translate="yes" xml:space="preserve">
          <source>Which cipher to use for encrypting separate session key.</source>
          <target state="translated">別々のセッション鍵を暗号化するためにどの暗号を使用するか。</target>
        </trans-unit>
        <trans-unit id="8c9643312802b96a36d211d4bd8a2d4fbec5df7d" translate="yes" xml:space="preserve">
          <source>Which compression algorithm to use. Only available if PostgreSQL was built with zlib.</source>
          <target state="translated">どの圧縮アルゴリズムを使用するか。PostgreSQLがzlibで構築されている場合のみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="36178694d36e0d8b9b4d6953d14f4cb84f698946" translate="yes" xml:space="preserve">
          <source>Which digest algorithm to use in S2K calculation.</source>
          <target state="translated">S2Kの計算で使用するダイジェストアルゴリズムはどれか。</target>
        </trans-unit>
        <trans-unit id="5b9d8c9d7eb5636216a755086b48fa5a8cd067ff" translate="yes" xml:space="preserve">
          <source>Which one of these you use is mainly a matter of style. The &lt;code&gt;JOIN&lt;/code&gt; syntax in the &lt;code&gt;FROM&lt;/code&gt; clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the &lt;code&gt;FROM&lt;/code&gt; clause. The &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause of an outer join is &lt;em&gt;not&lt;/em&gt; equivalent to a &lt;code&gt;WHERE&lt;/code&gt; condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result.</source>
          <target state="translated">これらのどれを使用するかは、主にスタイルの問題です。 &lt;code&gt;FROM&lt;/code&gt; 句の &lt;code&gt;JOIN&lt;/code&gt; 構文は、SQL標準に含まれていても、他のSQLデータベース管理システムに移植することはおそらくできません。外部結合の場合、選択肢はありません &lt;code&gt;FROM&lt;/code&gt; 句で行う必要があります。外部結合の &lt;code&gt;ON&lt;/code&gt; 句または &lt;code&gt;USING&lt;/code&gt; 句は、 &lt;code&gt;WHERE&lt;/code&gt; 条件と同等ではあり&lt;em&gt;ません。&lt;/em&gt;これは、（一致しない入力行に対して）行が追加され、最終結果から行が削除されるためです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f207dff92fd241726ec3f780d5ff085d75648337" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="translated">どの特定の演算子が存在し、それらが単項か二項かは、システムまたはユーザーによって定義されている演算子によって異なります。&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章で&lt;/a&gt;は、組み込み演算子について説明します。</target>
        </trans-unit>
        <trans-unit id="8189028b5d12d59cd50147d702e5a513253a68c3" translate="yes" xml:space="preserve">
          <source>Which row(s) to update</source>
          <target state="translated">どの行を更新するか</target>
        </trans-unit>
        <trans-unit id="a8a5e55dc1620d200691892efc7a7c676cbd8264" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CREATE INDEX&lt;/code&gt; with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.</source>
          <target state="translated">一方で &lt;code&gt;CREATE INDEX&lt;/code&gt; し &lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションがサポート平行な特別な制限なしで構築し、最初のテーブルスキャンが実際に並行して行われます。</target>
        </trans-unit>
        <trans-unit id="714b73638a1ef948dee8dfe7820683df70955357" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;UNIQUE&lt;/code&gt; is a natural constraint for scalar values, it is usually unsuitable for range types. Instead, an exclusion constraint is often more appropriate (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt;). Exclusion constraints allow the specification of constraints such as &amp;ldquo;non-overlapping&amp;rdquo; on a range type. For example:</source>
          <target state="translated">一方で &lt;code&gt;UNIQUE&lt;/code&gt; は、スカラー値のための自然な制約である、それはレンジタイプのため、通常は不向きです。代わりに、多くの場合、除外制約がより適切です（&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDEを&lt;/a&gt;参照）。除外制約を使用すると、範囲タイプの「重複しない」などの制約を指定できます。例えば：</target>
        </trans-unit>
        <trans-unit id="4a9577e86cf0dfccc12f0ecf60188a3b6040e454" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;pg_resetwal&lt;/code&gt; will set the WAL starting address beyond the latest existing WAL segment file, some segment size changes can cause previous WAL file names to be reused. It is recommended to use &lt;code&gt;-l&lt;/code&gt; together with this option to manually set the WAL starting address if WAL file name overlap will cause problems with your archiving strategy.</source>
          <target state="translated">一方で &lt;code&gt;pg_resetwal&lt;/code&gt; は最新の既存のWALセグメントファイルを超えたWAL開始アドレスを設定しますが、いくつかのセグメントサイズの変更は、以前のWALファイル名が再利用されることがあります。WALファイル名の重複によりアーカイブ戦略に問題が発生する場合は、このオプションと一緒に &lt;code&gt;-l&lt;/code&gt; を使用してWALの開始アドレスを手動で設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="01708a73847573f321d3d2da0f455cb9f949df75" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;to_date&lt;/code&gt; will reject a mixture of Gregorian and ISO week-numbering date fields, &lt;code&gt;to_char&lt;/code&gt; will not, since output format specifications like &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; can be useful. But avoid writing something like &lt;code&gt;IYYY-MM-DD&lt;/code&gt;; that would yield surprising results near the start of the year. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt; for more information.)</source>
          <target state="translated">一方で &lt;code&gt;to_date&lt;/code&gt; グレゴリオ暦とISO週番号日付フィールドの混合物を拒絶する、 &lt;code&gt;to_char&lt;/code&gt; 関数は、出力形式以降のような仕様ではないでしょう &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; 便利です。ただし、 &lt;code&gt;IYYY-MM-DD&lt;/code&gt; などの記述は避けてください。それは年の初め近くに驚くべき結果をもたらすでしょう。（詳細については、&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;セクション9.9.1&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="e362e9f328b5aa2d887a4c59191ea1b7f9721dc4" translate="yes" xml:space="preserve">
          <source>While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql.</source>
          <target state="translated">Cスタイルのブロックコメントは処理と削除のためにサーバに渡されますが、SQL標準のコメントはpsqlによって削除されます。</target>
        </trans-unit>
        <trans-unit id="5d725442e0975d9459afb2abfae7302730928d6f" translate="yes" xml:space="preserve">
          <source>While PostgreSQL's Serializable transaction isolation level only allows concurrent transactions to commit if it can prove there is a serial order of execution that would produce the same effect, it doesn't always prevent errors from being raised that would not occur in true serial execution. In particular, it is possible to see unique constraint violations caused by conflicts with overlapping Serializable transactions even after explicitly checking that the key isn't present before attempting to insert it. This can be avoided by making sure that &lt;em&gt;all&lt;/em&gt; Serializable transactions that insert potentially conflicting keys explicitly check if they can do so first. For example, imagine an application that asks the user for a new key and then checks that it doesn't exist already by trying to select it first, or generates a new key by selecting the maximum existing key and adding one. If some Serializable transactions insert new keys directly without following this protocol, unique constraints violations might be reported even in cases where they could not occur in a serial execution of the concurrent transactions.</source>
          <target state="translated">PostgreSQLのSerializableトランザクション分離レベルでは、同じ効果を生み出す実行のシリアル順序があることが証明できる場合にのみ、同時トランザクションのコミットが許可されますが、実際のシリアル実行では発生しないエラーの発生を必ずしも防ぐわけではありません。特に、挿入しようとする前にキーが存在しないことを明示的に確認した後でも、シリアル化可能なトランザクションの重複との競合によって引き起こされる一意の制約違反を確認できます。これは、&lt;em&gt;すべての&lt;/em&gt;競合する可能性のあるキーを挿入するシリアライズ可能なトランザクションは、最初に可能かどうかを明示的にチェックします。たとえば、ユーザーに新しいキーを要求し、最初にそのキーを選択して既存のものではないことを確認するアプリケーション、または最大の既存のキーを選択して追加することで新しいキーを生成するアプリケーションを想像してください。一部のSerializableトランザクションがこのプロトコルに従わずに新しいキーを直接挿入する場合、同時トランザクションのシリアル実行で発生しなかった場合でも、一意の制約違反が報告される可能性があります。</target>
        </trans-unit>
        <trans-unit id="594dab457c5441b59c42227020751df6f6f62a48" translate="yes" xml:space="preserve">
          <source>While XQuery/XPath provides all of the types defined in XML Schema and many operators and functions over those types, XPath 1.0 has only node-sets and the three atomic types &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">XQuery / XPathはXMLスキーマで定義されたすべてのタイプとそれらのタイプに対する多くの演算子と関数を提供しますが、XPath 1.0にはノードセットと3つのアトミックタイプ &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;double&lt;/code&gt; 、および &lt;code&gt;string&lt;/code&gt; しかありません。</target>
        </trans-unit>
        <trans-unit id="4a627fd0ca096f765ec57a0f53e97d18839b3a4e" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;LIKE&lt;/code&gt; clause exists in the SQL standard, many of the options that PostgreSQL accepts for it are not in the standard, and some of the standard's options are not implemented by PostgreSQL.</source>
          <target state="translated">一方で &lt;code&gt;LIKE&lt;/code&gt; の句は、SQL標準で存在する、PostgreSQLはそれを受け入れることのオプションの多くは、標準ではなく、標準のオプションのいくつかはPostgreSQLで実装されていません。</target>
        </trans-unit>
        <trans-unit id="bcdd2fd3f430f1ca01d2b3670c0f594bdee786bb" translate="yes" xml:space="preserve">
          <source>While a Repeatable Read transaction has a stable view of the data throughout its execution, there is a subtle issue with using MVCC snapshots for data consistency checks, involving something known as &lt;em&gt;read/write conflicts&lt;/em&gt;. If one transaction writes data and a concurrent transaction attempts to read the same data (whether before or after the write), it cannot see the work of the other transaction. The reader then appears to have executed first regardless of which started first or which committed first. If that is as far as it goes, there is no problem, but if the reader also writes data which is read by a concurrent transaction there is now a transaction which appears to have run before either of the previously mentioned transactions. If the transaction which appears to have executed last actually commits first, it is very easy for a cycle to appear in a graph of the order of execution of the transactions. When such a cycle appears, integrity checks will not work correctly without some help.</source>
          <target state="translated">反復可能読み取りトランザクションは、実行全体を通じてデータの安定したビューを持っていますが、データの整合性チェックにMVCCスナップショットを使用すると、&lt;em&gt;読み取り/書き込みの競合と&lt;/em&gt;呼ばれるものを含む、微妙な問題があります&lt;em&gt;&lt;/em&gt;。 1つのトランザクションがデータを書き込み、並行トランザクションが同じデータを読み取ろうとした場合（書き込みの前でも後でも）、他のトランザクションの動作を確認できません。リーダーは、どちらが最初に開始されたか、どちらが最初にコミットされたかに関係なく、最初に実行されたように見えます。それが可能な限り問題はありませんが、並行トランザクションによって読み取られるデータもリーダーが書き込む場合、前述のトランザクションの前に実行されたように見えるトランザクションがあります。最後に実行されたように見えるトランザクションが実際に最初にコミットする場合、トランザクションの実行順序のグラフにサイクルが現れるのは非常に簡単です。このようなサイクルが発生した場合、整合性チェックは何らかの助けなしでは正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="6a87fa7f9afe44920c1e825c81201c0429df3a1c" translate="yes" xml:space="preserve">
          <source>While a self-signed certificate can be used for testing, a certificate signed by a certificate authority (CA) (usually an enterprise-wide root CA) should be used in production.</source>
          <target state="translated">自己署名証明書はテストに使用することができますが、証明書局(CA)(通常は企業全体のルートCA)が署名した証明書を本番で使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cdc31b216171332e350cb9df34dfb0418ab3630e" translate="yes" xml:space="preserve">
          <source>While designing your archiving setup, consider what will happen if the archive command fails repeatedly because some aspect requires operator intervention or the archive runs out of space. For example, this could occur if you write to tape without an autochanger; when the tape fills, nothing further can be archived until the tape is swapped. You should ensure that any error condition or request to a human operator is reported appropriately so that the situation can be resolved reasonably quickly. The &lt;code&gt;pg_wal/&lt;/code&gt; directory will continue to fill with WAL segment files until the situation is resolved. (If the file system containing &lt;code&gt;pg_wal/&lt;/code&gt; fills up, PostgreSQL will do a PANIC shutdown. No committed transactions will be lost, but the database will remain offline until you free some space.)</source>
          <target state="translated">アーカイブのセットアップを設計するときは、いくつかの側面でオペレーターの介入が必要になるか、アーカイブのスペースが不足するために、archiveコマンドが繰り返し失敗した場合にどうなるかを検討してください。たとえば、オートチェンジャなしでテープに書き込む場合に発生する可能性があります。テープがいっぱいになると、テープが交換されるまで、これ以上アーカイブできません。状況を合理的に迅速に解決できるように、エラー状態またはオペレーターへの要求が適切に報告されるようにする必要があります。 &lt;code&gt;pg_wal/&lt;/code&gt; ディレクトリには、状況が解決されるまで、WALセグメントファイルに記入していきます。 （ &lt;code&gt;pg_wal/&lt;/code&gt; を含むファイルシステムがいっぱいになると、PostgreSQLはPANICシャットダウンを実行します。コミットされたトランザクションは失われませんが、データベースは空き容量ができるまでオフラインのままです。）</target>
        </trans-unit>
        <trans-unit id="ed48d255fcc854a30e92ea66bfc2714ea9b2abf4" translate="yes" xml:space="preserve">
          <source>While forcing data to the disk platters periodically might seem like a simple operation, it is not. Because disk drives are dramatically slower than main memory and CPUs, several layers of caching exist between the computer's main memory and the disk platters. First, there is the operating system's buffer cache, which caches frequently requested disk blocks and combines disk writes. Fortunately, all operating systems give applications a way to force writes from the buffer cache to disk, and PostgreSQL uses those features. (See the &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; parameter to adjust how this is done.)</source>
          <target state="translated">定期的にデータをディスクプラッターに強制することは簡単な操作のように思えるかもしれませんが、そうではありません。ディスクドライブはメインメモリやCPUよりも劇的に遅いため、コンピューターのメインメモリとディスクプラッターの間にいくつかのキャッシュ層が存在します。まず、オペレーティングシステムのバッファキャッシュがあります。これは、頻繁に要求されるディスクブロックをキャッシュし、ディスクの書き込みを組み合わせます。幸い、すべてのオペレーティングシステムがアプリケーションにバッファキャッシュからディスクへの書き込みを強制する方法を提供し、PostgreSQLはそれらの機能を使用します。 （これがどのように行われるかを調整するには、&lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;パラメーターを参照してください。）</target>
        </trans-unit>
        <trans-unit id="ae2f9725af5b866105aef02d826c3c21674b82a5" translate="yes" xml:space="preserve">
          <source>While it is possible to obtain information about which processes block which other processes by joining &lt;code&gt;pg_locks&lt;/code&gt; against itself, this is very difficult to get right in detail. Such a query would have to encode knowledge about which lock modes conflict with which others. Worse, the &lt;code&gt;pg_locks&lt;/code&gt; view does not expose information about which processes are ahead of which others in lock wait queues, nor information about which processes are parallel workers running on behalf of which other client sessions. It is better to use the &lt;code&gt;pg_blocking_pids()&lt;/code&gt; function (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;Table 9.63&lt;/a&gt;) to identify which process(es) a waiting process is blocked behind.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; をそれ自体に結合することにより、どのプロセスが他のどのプロセスをブロックするかについての情報を取得することは可能ですが、これを詳細に理解することは非常に困難です。このようなクエリでは、どのロックモードが他のどのロックモードと競合するかについての知識をエンコードする必要があります。さらに悪いことに、 &lt;code&gt;pg_locks&lt;/code&gt; ビューは、どのプロセスがロック待機キュー内の他のプロセスよりも進んでいるかに関する情報も、どのプロセスが他のクライアントセッションの代わりに実行されている並列ワーカーであるかに関する情報も公開しません。 &lt;code&gt;pg_blocking_pids()&lt;/code&gt; 関数（&lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;表9.63を&lt;/a&gt;参照）を使用して、待機中のプロセスがブロックされているプロセスを特定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="17d114999ab92dc3c41f0deae7314e26f77d91d6" translate="yes" xml:space="preserve">
          <source>While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout.</source>
          <target state="translated">ほとんどの正規表現検索は非常に速く実行できますが、正規表現は処理に任意の量の時間とメモリを必要とすることがあります。敵対的なソースから正規表現検索パターンを受け入れることには注意が必要です。どうしてもそうしなければならない場合は、文のタイムアウトを課すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4544bbaee7531ef45a0e42c59e09a0908293364f" translate="yes" xml:space="preserve">
          <source>While most timezone abbreviations represent fixed offsets from UTC, there are some that have historically varied in value (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt; for more information). In such cases this view presents their current meaning.</source>
          <target state="translated">ほとんどのタイムゾーン省略形はUTCからの固定オフセットを表しますが、値が歴史的に変化しているものもあります（詳細については、&lt;a href=&quot;datetime-config-files&quot;&gt;セクションB.4&lt;/a&gt;を参照）。このような場合、このビューは現在の意味を示します。</target>
        </trans-unit>
        <trans-unit id="64e20acb9a4d1b2d1994838c4133180e7c30312a" translate="yes" xml:space="preserve">
          <source>While not required, it is recommended that you continue to follow this old convention of naming cast implementation functions after the target data type. Many users are used to being able to cast data types using a function-style notation, that is &lt;code&gt;typename&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;). This notation is in fact nothing more nor less than a call of the cast implementation function; it is not specially treated as a cast. If your conversion functions are not named to support this convention then you will have surprised users. Since PostgreSQL allows overloading of the same function name with different argument types, there is no difficulty in having multiple conversion functions from different types that all use the target type's name.</source>
          <target state="translated">必須ではありませんが、キャスト実装関数にターゲットデータ型の後に名前を付けるというこの古い規則に従うことをお勧めします。多くのユーザーは、関数形式の表記、つまり &lt;code&gt;typename&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）を使用してデータ型をキャストできることに慣れています。この表記は、実際にはキャスト実装関数の呼び出しにすぎません。それは特別にキャストとして扱われません。この変換をサポートするように変換関数の名前が付けられていない場合、ユーザーを驚かせることになります。 PostgreSQLでは、引数の型が異なる同じ関数名のオーバーロードが許可されているため、ターゲット型の名前をすべて使用する異なる型からの複数の変換関数を作成しても問題はありません。</target>
        </trans-unit>
        <trans-unit id="9e3fedf4b54ce85919b4142394d398f5b611a696" translate="yes" xml:space="preserve">
          <source>While policies will be applied for explicit queries against tables in the database, they are not applied when the system is performing internal referential integrity checks or validating constraints. This means there are indirect ways to determine that a given value exists. An example of this is attempting to insert a duplicate value into a column that is a primary key or has a unique constraint. If the insert fails then the user can infer that the value already exists. (This example assumes that the user is permitted by policy to insert records which they are not allowed to see.) Another example is where a user is allowed to insert into a table which references another, otherwise hidden table. Existence can be determined by the user inserting values into the referencing table, where success would indicate that the value exists in the referenced table. These issues can be addressed by carefully crafting policies to prevent users from being able to insert, delete, or update records at all which might possibly indicate a value they are not otherwise able to see, or by using generated values (e.g., surrogate keys) instead of keys with external meanings.</source>
          <target state="translated">ポリシーは、データベース内のテーブルに対する明示的な問い合わせには適用されますが、システムが内部参照整合性チェックや制約の検証を行っている場合には適用されません。つまり、与えられた値が存在することを判断する間接的な方法があるということです。この例として、主キーまたは一意の制約を持つ列に重複した値を挿入しようとした場合があります。挿入に失敗した場合、ユーザーはその値がすでに存在していることを推測できます。(この例では、ユーザーがポリシーによって、閲覧を許可されていないレコードの挿入を許可されていることを想定しています)。もう一つの例は、ユーザーが別のテーブルを参照しているテーブルへの挿入を許可されている場合です。存在は、ユーザが参照先のテーブルに値を挿入することで判断することができ、成功すれば、値が参照先のテーブルに存在することを示します。これらの問題は、ユーザが見えない値を示す可能性のあるレコードを挿入、削除、更新できないようにポリシーを慎重に作成したり、外部の意味を持つキーの代わりに生成された値(サロゲートキーなど)を使用したりすることで解決できます。</target>
        </trans-unit>
        <trans-unit id="5fbe4c0896d37fe14f081d1ac25be59617f075b0" translate="yes" xml:space="preserve">
          <source>While recovery is paused no further database changes are applied. If in hot standby, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="translated">リカバリが一時停止されている間は、それ以上のデータベース変更は適用されません。ホットスタンバイの場合、すべての新しいクエリはデータベースの同じ一貫したスナップショットを表示し、回復が再開されるまでは、それ以上のクエリの競合は発生しません。</target>
        </trans-unit>
        <trans-unit id="67bee53c255823e86d8c23b4190b410627254abc" translate="yes" xml:space="preserve">
          <source>While rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">ローカルパーティションから外部テーブルパーティションに行を移動させることはできますが(外部データラッパーがタプルルーティングをサポートしている場合)、外部テーブルパーティションから別のパーティションに行を移動させることはできません。</target>
        </trans-unit>
        <trans-unit id="7158e641e335f398bdfc35c274f36a1760cfa0bc" translate="yes" xml:space="preserve">
          <source>While running pg_dump, one should examine the output for any warnings (printed on standard error), especially in light of the limitations listed below.</source>
          <target state="translated">pg_dumpを実行している間は、特に以下に列挙する制限事項を考慮して、警告(標準エラーで表示される)が出力されていないか調べなければなりません。</target>
        </trans-unit>
        <trans-unit id="891b0584891eb2794e238a1971ed31f1c215e841" translate="yes" xml:space="preserve">
          <source>While that doesn't look all that bad by itself, it's still oversimplified. A far more complicated sub-select would be needed to select the right OID if there are multiple tables named &lt;code&gt;mytable&lt;/code&gt; in different schemas. The &lt;code&gt;regclass&lt;/code&gt; input converter handles the table lookup according to the schema path setting, and so it does the &amp;ldquo;right thing&amp;rdquo; automatically. Similarly, casting a table's OID to &lt;code&gt;regclass&lt;/code&gt; is handy for symbolic display of a numeric OID.</source>
          <target state="translated">それだけではそれほど悪くはありませんが、単純化しすぎです。異なるスキーマに &lt;code&gt;mytable&lt;/code&gt; という名前のテーブルが複数ある場合、正しいOIDを選択するには、はるかに複雑な副選択が必要になります。 &lt;code&gt;regclass&lt;/code&gt; データ入力コンバータハンドルテーブルスキーマパスの設定に応じて、ルックアップ、それが自動的に「正しいこと」を行いますので。同様に、テーブルのOIDを &lt;code&gt;regclass&lt;/code&gt; にキャストすると、数値OIDの記号表示に便利です。</target>
        </trans-unit>
        <trans-unit id="d982cd814f64616912cda4d88166e9a69d28b85b" translate="yes" xml:space="preserve">
          <source>While that particular example might seem silly, related cases that don't obviously involve constants can occur in queries executed within functions, since the values of function arguments and local variables can be inserted into queries as constants for planning purposes. Within PL/pgSQL functions, for example, using an &lt;code&gt;IF&lt;/code&gt;-&lt;code&gt;THEN&lt;/code&gt;-&lt;code&gt;ELSE&lt;/code&gt; statement to protect a risky computation is much safer than just nesting it in a &lt;code&gt;CASE&lt;/code&gt; expression.</source>
          <target state="translated">その特定の例はばかげているように見えるかもしれませんが、関数の引数とローカル変数の値は計画のために定数としてクエリに挿入できるため、関数内で実行されるクエリで定数を含まない関連ケースが発生する可能性があります。たとえば、PL / pgSQL関数内では、 &lt;code&gt;IF&lt;/code&gt; - &lt;code&gt;THEN&lt;/code&gt; - &lt;code&gt;ELSE&lt;/code&gt; ステートメントを使用して危険な計算を保護する方が、 &lt;code&gt;CASE&lt;/code&gt; 式で単にネストするよりもはるかに安全です。</target>
        </trans-unit>
        <trans-unit id="cfcd6cf6959e988635a363ac7fbe48c4622cc9ea" translate="yes" xml:space="preserve">
          <source>While the built-in declarative partitioning is suitable for most common use cases, there are some circumstances where a more flexible approach may be useful. Partitioning can be implemented using table inheritance, which allows for several features not supported by declarative partitioning, such as:</source>
          <target state="translated">組み込みの宣言的パーティショニングはほとんどの一般的なユースケースに適していますが、より柔軟なアプローチが有用な場合もあります。パーティショニングはテーブル継承を使って実装することができます。</target>
        </trans-unit>
        <trans-unit id="f761cf19de1d987297c4bdb87e576a9e8ef5e265" translate="yes" xml:space="preserve">
          <source>While the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations is retained, &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; does not order the generated rows based on this property. If you want the data to be ordered upon generation, you must use an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the backing query.</source>
          <target state="translated">今後の&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;操作のデフォルトのインデックスは保持されますが、 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; はこのプロパティに基づいて生成された行を並べ替えません。生成時にデータを並べ &lt;code&gt;ORDER BY&lt;/code&gt; 場合は、バッキングクエリでORDER BY句を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="89bb80c5dc369e5a7b8dcef839df901e5b397bf5" translate="yes" xml:space="preserve">
          <source>While the details of the new type's internal representation are only known to the I/O functions and other functions you create to work with the type, there are several properties of the internal representation that must be declared to PostgreSQL. Foremost of these is &lt;code&gt;internallength&lt;/code&gt;. Base data types can be fixed-length, in which case &lt;code&gt;internallength&lt;/code&gt; is a positive integer, or variable-length, indicated by setting &lt;code&gt;internallength&lt;/code&gt; to &lt;code&gt;VARIABLE&lt;/code&gt;. (Internally, this is represented by setting &lt;code&gt;typlen&lt;/code&gt; to -1.) The internal representation of all variable-length types must start with a 4-byte integer giving the total length of this value of the type. (Note that the length field is often encoded, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;; it's unwise to access it directly.)</source>
          <target state="translated">新しい型の内部表現の詳細は、その型を操作するために作成するI / O関数とその他の関数だけが知っていますが、PostgreSQLに宣言する必要がある内部表現のプロパティがいくつかあります。これらの最も重要なものは &lt;code&gt;internallength&lt;/code&gt; です。基本データ型は固定長にすることができます。この場合、 &lt;code&gt;internallength&lt;/code&gt; は正の整数、または &lt;code&gt;internallength&lt;/code&gt; を &lt;code&gt;VARIABLE&lt;/code&gt; に設定することによって示される可変長にすることができます。 （内部的には、 &lt;code&gt;typlen&lt;/code&gt; を-1に設定することで表されます。）すべての可変長型の内部表現は、型のこの値の全長を表す4バイトの整数で始まる必要があります。 （で説明されているように、長さフィールドはしばしばエンコードされることに注意してください&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt; ; 直接アクセスするのは賢明ではありません。）</target>
        </trans-unit>
        <trans-unit id="915068b5c9a0a4207ecd95ee0a72471b7e35a59c" translate="yes" xml:space="preserve">
          <source>While the examples for these functions use constants, the typical use would be to reference a table in the &lt;code&gt;FROM&lt;/code&gt; clause and use one of its &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; columns as an argument to the function. Extracted key values can then be referenced in other parts of the query, like &lt;code&gt;WHERE&lt;/code&gt; clauses and target lists. Extracting multiple values in this way can improve performance over extracting them separately with per-key operators.</source>
          <target state="translated">これらの関数の例では定数を使用していますが、一般的な使用法は、 &lt;code&gt;FROM&lt;/code&gt; 句でテーブルを参照し、 &lt;code&gt;json&lt;/code&gt; または &lt;code&gt;jsonb&lt;/code&gt; 列のいずれかを関数の引数として使用することです。抽出されたキー値は、 &lt;code&gt;WHERE&lt;/code&gt; 句やターゲットリストなど、クエリの他の部分で参照できます。この方法で複数の値を抽出すると、キーごとの演算子を使用して個別に抽出するよりもパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="0c09c1945f14d262f5a989a6b1b7f78a8869fb1b" translate="yes" xml:space="preserve">
          <source>While the server is running, it is not possible for a malicious user to take the place of the normal database server. However, when the server is down, it is possible for a local user to spoof the normal server by starting their own server. The spoof server could read passwords and queries sent by clients, but could not return any data because the &lt;code&gt;PGDATA&lt;/code&gt; directory would still be secure because of directory permissions. Spoofing is possible because any user can start a database server; a client cannot identify an invalid server unless it is specially configured.</source>
          <target state="translated">サーバーの実行中は、悪意のあるユーザーが通常のデータベースサーバーの代わりをすることはできません。ただし、サーバーがダウンしている場合、ローカルユーザーが独自のサーバーを起動して通常のサーバーを偽装する可能性があります。スプーフィングサーバーは、クライアントから送信されたパスワードとクエリを読み取ることができましたが、ディレクトリのアクセス許可のために &lt;code&gt;PGDATA&lt;/code&gt; ディレクトリが引き続き保護されるため、データを返すことができませんでした。すべてのユーザーがデータベースサーバーを起動できるため、なりすましが可能です。特別に構成されていない限り、クライアントは無効なサーバーを識別できません。</target>
        </trans-unit>
        <trans-unit id="a8b90c7536148bdec5e290019a51b2379ecb8d63" translate="yes" xml:space="preserve">
          <source>While the server is running, its PID is stored in the file &lt;code&gt;postmaster.pid&lt;/code&gt; in the data directory. This is used to prevent multiple server instances from running in the same data directory and can also be used for shutting down the server.</source>
          <target state="translated">サーバーの実行中、そのPIDはデータディレクトリのファイル &lt;code&gt;postmaster.pid&lt;/code&gt; に保存されます。これは、複数のサーバーインスタンスが同じデータディレクトリで実行されるのを防ぐために使用され、サーバーのシャットダウンにも使用できます。</target>
        </trans-unit>
        <trans-unit id="a03c807444bf3594110c4d388ec7b0a59f62a431" translate="yes" xml:space="preserve">
          <source>While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes or backslashes, since each of those must be doubled. To allow more readable queries in such situations, PostgreSQL provides another way, called &amp;ldquo;dollar quoting&amp;rdquo;, to write string constants. A dollar-quoted string constant consists of a dollar sign (&lt;code&gt;$&lt;/code&gt;), an optional &amp;ldquo;tag&amp;rdquo; of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string &amp;ldquo;Dianne's horse&amp;rdquo; using dollar quoting:</source>
          <target state="translated">文字列定数を指定するための標準的な構文は通常便利ですが、目的の文字列に多数の単一引用符またはバックスラッシュが含まれていると、それぞれを二重にする必要があるため、理解しにくい場合があります。そのような状況でより読みやすいクエリを可能にするために、PostgreSQLは「ドル引用」と呼ばれる、文字列定数を書き込む別の方法を提供しています。ドル引用符で囲まれた文字列定数は、ドル記号（ &lt;code&gt;$&lt;/code&gt; ）、0個以上の文字のオプションの「タグ」、別のドル記号、文字列コンテンツを構成する任意の文字シーケンス、ドル記号、同じタグこのドルの見積もりとドル記号が始まりました。たとえば、ドル引用符を使用して文字列「ダイアンの馬」を指定するには、次の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="97a03d15b6274d3b06d93b14cfe041b66ef2af72" translate="yes" xml:space="preserve">
          <source>While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed.</source>
          <target state="translated">この機能は単月の場合よりも複雑ですが、必要になる前にブランチを追加することができるので、それほど頻繁に更新する必要はありません。</target>
        </trans-unit>
        <trans-unit id="eb917c6d1ba7f34837342b8b023d8fdc99add536" translate="yes" xml:space="preserve">
          <source>While this is the only way to convert character strings into XML values according to the SQL standard, the PostgreSQL-specific syntaxes:</source>
          <target state="translated">SQL標準に従って文字列をXML値に変換する唯一の方法ではありますが、PostgreSQL固有の構文を使用しています。</target>
        </trans-unit>
        <trans-unit id="13b118c29b5eac33252cf8f05a41900068035eae" translate="yes" xml:space="preserve">
          <source>While transition table names for &lt;code&gt;AFTER&lt;/code&gt; triggers are specified using the &lt;code&gt;REFERENCING&lt;/code&gt; clause in the standard way, the row variables used in &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers may not be specified in a &lt;code&gt;REFERENCING&lt;/code&gt; clause. They are available in a manner that is dependent on the language in which the trigger function is written, but is fixed for any one language. Some languages effectively behave as though there is a &lt;code&gt;REFERENCING&lt;/code&gt; clause containing &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AFTER&lt;/code&gt; トリガーの遷移表名は、 &lt;code&gt;REFERENCING&lt;/code&gt; 句を使用して標準的な方法で指定されますが、 &lt;code&gt;FOR EACH ROW&lt;/code&gt; トリガーで使用される行変数は、 &lt;code&gt;REFERENCING&lt;/code&gt; 句で指定されない場合があります。これらは、トリガー関数が記述されている言語に依存する方法で使用できますが、いずれか1つの言語に固定されています。一部の言語は、 &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt; を含む &lt;code&gt;REFERENCING&lt;/code&gt; 句があるかのように効果的に動作します。</target>
        </trans-unit>
        <trans-unit id="0775e3a82644839414e547fda3c53cda5989eee1" translate="yes" xml:space="preserve">
          <source>While turning off &lt;code&gt;fsync&lt;/code&gt; is often a performance benefit, this can result in unrecoverable data corruption in the event of a power failure or system crash. Thus it is only advisable to turn off &lt;code&gt;fsync&lt;/code&gt; if you can easily recreate your entire database from external data.</source>
          <target state="translated">多くの場合、 &lt;code&gt;fsync&lt;/code&gt; をオフにするとパフォーマンスが向上しますが、電源障害やシステムクラッシュが発生した場合に、データが破損して回復不能になる可能性があります。したがって、オフにする唯一の賢明である &lt;code&gt;fsync&lt;/code&gt; 使用すると、簡単に外部のデータからデータベース全体を再作成することができます。</target>
        </trans-unit>
        <trans-unit id="5d9f7345f5e4a9cecb1d3a73e9e82a30d0080279" translate="yes" xml:space="preserve">
          <source>White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (&amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo;) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above).</source>
          <target state="translated">空白（スペース、タブ、改行）はSQLコマンドで自由に使用できます。つまり、上記とは異なる方法でコマンドを入力することも、すべてを1行で入力することもできます。2つのダッシュ（「 &lt;code&gt;--&lt;/code&gt; 」）はコメントを示します。それらに続くものはすべて、行の終わりまで無視されます。SQLは、大文字と小文字を区別するために識別子が二重引用符で囲まれている場合（上記では実行されない）を除いて、キーワードと識別子について大文字と小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="58bd91fff64a844973a8238af97e34efc8a5c324" translate="yes" xml:space="preserve">
          <source>White space is ignored on input, so &lt;code&gt;[(x),(y)]&lt;/code&gt; is the same as &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt;.</source>
          <target state="translated">ホワイトスペースは、入力時には無視されるので、 &lt;code&gt;[(x),(y)]&lt;/code&gt; 同じである &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac41fe428645044123abfe95a020b4d162465d70" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed before and after the range value, but any whitespace between the parentheses or brackets is taken as part of the lower or upper bound value. (Depending on the element type, it might or might not be significant.)</source>
          <target state="translated">範囲値の前後には空白が許されていますが、括弧や括弧の間の空白は、下界値や上界値の一部として扱われます。(要素の種類によっては、重要である場合と重要でない場合があります)。</target>
        </trans-unit>
        <trans-unit id="3cc40c3d855977fc828d35a4c20284c43f252dc0" translate="yes" xml:space="preserve">
          <source>Why would you want to use the weak mode? Well, it could be that you have a huge collection of ISBN numbers, and that there are so many of them that for weird reasons some have the wrong check digit (perhaps the numbers were scanned from a printed list and the OCR got the numbers wrong, perhaps the numbers were manually captured... who knows). Anyway, the point is you might want to clean the mess up, but you still want to be able to have all the numbers in your database and maybe use an external tool to locate the invalid numbers in the database so you can verify the information and validate it more easily; so for example you'd want to select all the invalid numbers in the table.</source>
          <target state="translated">なぜ弱いモードを使いたいのですか?まあ、それはあなたがISBN番号の膨大なコレクションを持っている可能性がありますし、奇妙な理由でいくつかのチェックデジットが間違っている(おそらく番号は印刷されたリストからスキャンされ、OCRは番号を間違っていた、おそらく番号は手動でキャプチャされた...誰が知っている)それらの非常に多くがあります。とにかく、ポイントは、あなたが混乱をクリーンアップしたいかもしれないということですが、あなたはまだあなたのデータベース内のすべての番号を持つことができるようにしたいと思いますし、おそらく外部ツールを使用してデータベース内の無効な番号を見つけるために、情報を検証し、より簡単にそれを検証することができます。</target>
        </trans-unit>
        <trans-unit id="70a7ce99eb76502ad0a6210d94039f0b40c3419d" translate="yes" xml:space="preserve">
          <source>Wildcard array element accessor that returns all array elements.</source>
          <target state="translated">すべての配列要素を返すワイルドカード配列要素アクセサ。</target>
        </trans-unit>
        <trans-unit id="cd2106ae04d09a5386f20710a015aa4219dc3f6c" translate="yes" xml:space="preserve">
          <source>Wildcard member accessor that returns the values of all members located at the top level of the current object.</source>
          <target state="translated">現在のオブジェクトの最上位レベルにあるすべてのメンバの値を返すワイルドカード・メンバ・アクセサ。</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">ウィンドウ機能</target>
        </trans-unit>
        <trans-unit id="01267df331f99498a90196b34760cb7aa229a46d" translate="yes" xml:space="preserve">
          <source>Window function calls are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query.</source>
          <target state="translated">ウィンドウ関数呼び出しは、クエリの &lt;code&gt;SELECT&lt;/code&gt; リストと &lt;code&gt;ORDER BY&lt;/code&gt; 句でのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="c367a920e4a4ea3efbe3a1a798085a3a023e6741" translate="yes" xml:space="preserve">
          <source>Window functions are described in detail in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">ウィンドウ関数は、に詳細に記載されている&lt;a href=&quot;tutorial-window&quot;&gt;セクション3.5&lt;/a&gt;、&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8&lt;/a&gt;、および&lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;セクション7.2.5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f451b621911f3a41da7c18da4aff7cdb55589c1" translate="yes" xml:space="preserve">
          <source>Window functions are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query. They are forbidden elsewhere, such as in &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.</source>
          <target state="translated">ウィンドウ関数は、クエリの &lt;code&gt;SELECT&lt;/code&gt; リストと &lt;code&gt;ORDER BY&lt;/code&gt; 句でのみ許可されます。 &lt;code&gt;GROUP BY&lt;/code&gt; 、 &lt;code&gt;HAVING&lt;/code&gt; 、 &lt;code&gt;WHERE&lt;/code&gt; 句など、他の場所では禁止されています。これは、これらの句の処理後に論理的に実行されるためです。また、ウィンドウ関数は非ウィンドウ集約関数の後に実行されます。つまり、ウィンドウ関数の引数に集約関数呼び出しを含めることは有効ですが、その逆はできません。</target>
        </trans-unit>
        <trans-unit id="79e789d251d694ff69667eed3b6a1eef1b73bc73" translate="yes" xml:space="preserve">
          <source>Window: cume_dist</source>
          <target state="translated">ウィンドウ:cume_dist</target>
        </trans-unit>
        <trans-unit id="1e7f6a60bbd5fd2e82c3412bbb88bea212c4bdb7" translate="yes" xml:space="preserve">
          <source>Window: dense_rank</source>
          <target state="translated">ウィンドウ:dense_rank</target>
        </trans-unit>
        <trans-unit id="08d36b418003a8b9c0e9b2dd2a6f2bff70e5a8ac" translate="yes" xml:space="preserve">
          <source>Window: first_value</source>
          <target state="translated">ウィンドウ:first_value</target>
        </trans-unit>
        <trans-unit id="b5f178a106cd7cba1da80bdc71ec514eea37f26d" translate="yes" xml:space="preserve">
          <source>Window: lag</source>
          <target state="translated">ウィンドウ:ラグ</target>
        </trans-unit>
        <trans-unit id="fabaa17e6490da4ec5451b3b47ee388b70cf91b0" translate="yes" xml:space="preserve">
          <source>Window: last_value</source>
          <target state="translated">ウィンドウ:last_value</target>
        </trans-unit>
        <trans-unit id="994efd60b559fadbd405573c301089b7cf18f884" translate="yes" xml:space="preserve">
          <source>Window: lead</source>
          <target state="translated">窓:鉛</target>
        </trans-unit>
        <trans-unit id="757db4a854089f2de8d98fd39c8889ef5116458d" translate="yes" xml:space="preserve">
          <source>Window: nth_value</source>
          <target state="translated">ウィンドウ:nth_value</target>
        </trans-unit>
        <trans-unit id="e7f90d6e0544bf0f16ab443f5e02ee4cd6fe42bc" translate="yes" xml:space="preserve">
          <source>Window: ntile</source>
          <target state="translated">窓:ntile</target>
        </trans-unit>
        <trans-unit id="bb901cf4a6350aa408d137094086445ef7a0cf50" translate="yes" xml:space="preserve">
          <source>Window: percent_rank</source>
          <target state="translated">ウィンドウ:percent_rank</target>
        </trans-unit>
        <trans-unit id="c0ecbc78e1223c489bcdc839303f81579d301dbd" translate="yes" xml:space="preserve">
          <source>Window: rank</source>
          <target state="translated">窓:ランク</target>
        </trans-unit>
        <trans-unit id="31c13454a2137d228d57d97a95bb16f2559129e2" translate="yes" xml:space="preserve">
          <source>Window: row_number</source>
          <target state="translated">ウィンドウ:行番号</target>
        </trans-unit>
        <trans-unit id="afb3a4bfc7eab0371f71e7828e71cca0cb17b3c3" translate="yes" xml:space="preserve">
          <source>Windows CP1250</source>
          <target state="translated">ウィンドウズCP1250</target>
        </trans-unit>
        <trans-unit id="9a2c00b8e44a047e41a03f1caab3a7b4b6689695" translate="yes" xml:space="preserve">
          <source>Windows CP1251</source>
          <target state="translated">ウィンドウズCP1251</target>
        </trans-unit>
        <trans-unit id="ee9d69428625d1ff5f15b6e3dcde936a0fd1f094" translate="yes" xml:space="preserve">
          <source>Windows CP1252</source>
          <target state="translated">Windows CP1252</target>
        </trans-unit>
        <trans-unit id="cc78a0c32f91f66c55ae633ccbcefebb486eb07a" translate="yes" xml:space="preserve">
          <source>Windows CP1253</source>
          <target state="translated">ウィンドウズCP1253</target>
        </trans-unit>
        <trans-unit id="5f231ed423cb65bf660816b30028087f1a8e8ce5" translate="yes" xml:space="preserve">
          <source>Windows CP1254</source>
          <target state="translated">ウィンドウズCP1254</target>
        </trans-unit>
        <trans-unit id="a23b534f177679e438c10751dd8cd9af7ceda942" translate="yes" xml:space="preserve">
          <source>Windows CP1255</source>
          <target state="translated">ウィンドウズCP1255</target>
        </trans-unit>
        <trans-unit id="6790dc03b7d5b6e6f32fcb36c60e23323fb868ac" translate="yes" xml:space="preserve">
          <source>Windows CP1256</source>
          <target state="translated">ウィンドウズCP1256</target>
        </trans-unit>
        <trans-unit id="2de6d342a6a1f91fe73d1aed1c38e985a216e16e" translate="yes" xml:space="preserve">
          <source>Windows CP1257</source>
          <target state="translated">ウィンドウズCP1257</target>
        </trans-unit>
        <trans-unit id="640bb2a94fe66a43ea03427875c71fa7af756764" translate="yes" xml:space="preserve">
          <source>Windows CP1258</source>
          <target state="translated">ウィンドウズCP1258</target>
        </trans-unit>
        <trans-unit id="e95532249be79aa59a141ea1dc6d988132a7c104" translate="yes" xml:space="preserve">
          <source>Windows CP866</source>
          <target state="translated">ウィンドウズシーピー866</target>
        </trans-unit>
        <trans-unit id="69925dc2d1afa064badeb7131e0815ad04126da3" translate="yes" xml:space="preserve">
          <source>Windows CP874</source>
          <target state="translated">ウィンドウズシーピー874</target>
        </trans-unit>
        <trans-unit id="c6d589f8c6c9e727468855e6a54c0d6dfb5cce47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, pg_restore also restores the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also restored, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--create&lt;/code&gt; 、pg_restoreのもあれば、データベースのコメントを復元し、このデータベースに固有のすべての構成変数の設定、任意の、あること &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; と &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; このデータベースに言及するSET ...コマンド。 &lt;code&gt;--no-acl&lt;/code&gt; が指定されていない限り、データベース自体のアクセス権限も復元されます。</target>
        </trans-unit>
        <trans-unit id="8fdece12f1fb080c2dbfd8709cabeca4afb1d172" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, the output also includes the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also dumped, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--create&lt;/code&gt; 、出力もあれば、データベースのコメントが含まれており、このデータベースに固有のすべての構成変数の設定、任意の、あること &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; と &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; このデータベースに言及するSET ...コマンド。 &lt;code&gt;--no-acl&lt;/code&gt; が指定されていない限り、データベース自体へのアクセス権限もダンプされます。</target>
        </trans-unit>
        <trans-unit id="f453a9fafc8b310f8a3de3fda65ed4c38e9ca283" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1, this forces the planner to join A to B before joining them to other tables, but doesn't constrain its choices otherwise. In this example, the number of possible join orders is reduced by a factor of 5.</source>
          <target state="translated">&lt;code&gt;join_collapse_limit&lt;/code&gt; は、この力はプランナが他のテーブルにそれらを結合する前にBにAを結合するために、= 1、それ以外の選択肢を制限しません。この例では、可能な結合順序の数が5分の1に減少しています。</target>
        </trans-unit>
        <trans-unit id="fe49ef2ae18f846d2f24144892dcb7436b22edbb" translate="yes" xml:space="preserve">
          <source>With ICU, it is not sensible to enumerate all possible locale names. ICU uses a particular naming system for locales, but there are many more ways to name a locale than there are actually distinct locales. &lt;code&gt;initdb&lt;/code&gt; uses the ICU APIs to extract a set of distinct locales to populate the initial set of collations. Collations provided by ICU are created in the SQL environment with names in BCP 47 language tag format, with a &amp;ldquo;private use&amp;rdquo; extension &lt;code&gt;-x-icu&lt;/code&gt; appended, to distinguish them from libc locales.</source>
          <target state="translated">ICUでは、すべての可能なロケール名を列挙することは賢明ではありません。 ICUはロケールに特定のネーミングシステムを使用しますが、実際に異なるロケールよりも、ロケールに名前を付ける方法はたくさんあります。 &lt;code&gt;initdb&lt;/code&gt; は、ICU APIを使用して一連の異なるロケールを抽出し、最初の照合セットを生成します。 ICUによって提供される照合順序は、BCP 47言語タグ形式の名前でSQL環境で作成され、「私用」拡張 &lt;code&gt;-x-icu&lt;/code&gt; が追加されて、libcロケールと区別されます。</target>
        </trans-unit>
        <trans-unit id="cc0ce6e945d75c0e017cd4582a6ce07fb85c72b6" translate="yes" xml:space="preserve">
          <source>With OpenSSL</source>
          <target state="translated">OpenSSLを使って</target>
        </trans-unit>
        <trans-unit id="8fa1343fb87dfb28347c1e7e66e33ba69c59c2ca" translate="yes" xml:space="preserve">
          <source>With SSL support compiled in, the PostgreSQL server can be started with SSL enabled by setting the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The server will listen for both normal and SSL connections on the same TCP port, and will negotiate with any connecting client on whether to use SSL. By default, this is at the client's option; see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about how to set up the server to require use of SSL for some or all connections.</source>
          <target state="translated">SSLサポートが&lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;組み込ま&lt;/a&gt;れ &lt;code&gt;on&lt;/code&gt; 、 &lt;code&gt;postgresql.conf&lt;/code&gt; でパラメーターsslをonに設定することにより、SSLを有効にしてPostgreSQLサーバーを起動できます。サーバーは、同じTCPポートで通常の接続とSSL接続の両方をリッスンし、SSLを使用するかどうかについて接続しているクライアントと交渉します。デフォルトでは、これはクライアントのオプションです。一部またはすべての接続でSSLの使用を要求するようにサーバーを設定する方法については、&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;セクション20.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1d13ab27fd57668592221b667df2e40b0bb1e2e4" translate="yes" xml:space="preserve">
          <source>With a cluster distributed across multiple geographic locations, using different values per location brings more flexibility in the cluster management. A smaller value is useful for faster failure detection with a standby having a low-latency network connection, and a larger value helps in judging better the health of a standby if located on a remote location, with a high-latency network connection.</source>
          <target state="translated">クラスタが複数の地理的な場所に分散している場合、場所ごとに異なる値を使用することで、クラスタ管理の柔軟性が向上します。値を小さくすると、低レイテンシのネットワーク接続を持つ待機機の障害検出を迅速に行うことができ、値を大きくすると、高レイテンシのネットワーク接続を持つ遠隔地に位置する待機機の健全性をより良く判断することができます。</target>
        </trans-unit>
        <trans-unit id="2817eb5fe50b4283e89c69a97c63500ae24da2d7" translate="yes" xml:space="preserve">
          <source>With a parameter, turns displaying of how long each SQL statement takes on or off. Without a parameter, toggles the display between on and off. The display is in milliseconds; intervals longer than 1 second are also shown in minutes:seconds format, with hours and days fields added if needed.</source>
          <target state="translated">パラメータを指定すると、各SQL文の表示時間のオン/オフを切り替えます。パラメータを指定しない場合は、表示をオンとオフの間で切り替えます。表示はミリ秒単位で表示され、1秒以上の間隔は分:秒形式で表示され、必要に応じて時と日のフィールドが追加されます。</target>
        </trans-unit>
        <trans-unit id="862b8683e39578b4e7d997552333b9aad19243ce" translate="yes" xml:space="preserve">
          <source>With constraint exclusion enabled, this &lt;code&gt;SELECT&lt;/code&gt; will not scan &lt;code&gt;child1000&lt;/code&gt; at all, improving performance.</source>
          <target state="translated">制約の除外を有効にすると、この &lt;code&gt;SELECT&lt;/code&gt; は &lt;code&gt;child1000&lt;/code&gt; をまったくスキャンしないため、パフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="281288184f75c730f93254833c37347e0fc29fe4" translate="yes" xml:space="preserve">
          <source>With data warehouse type workloads, it can make sense to use a larger number of partitions than with an OLTP type workload. Generally, in data warehouses, query planning time is less of a concern as the majority of processing time is spent during query execution. With either of these two types of workload, it is important to make the right decisions early, as re-partitioning large quantities of data can be painfully slow. Simulations of the intended workload are often beneficial for optimizing the partitioning strategy. Never assume that more partitions are better than fewer partitions and vice-versa.</source>
          <target state="translated">データウェアハウスタイプのワークロードでは、OLTPタイプのワークロードよりも多くのパーティションを使用することが理にかなっている場合があります。一般的に、データウェアハウスでは、クエリの実行中に処理時間の大部分が費やされるため、クエリの計画時間はあまり気になりません。これら 2 つのタイプのワークロードでは、大量のデータの再パーティション化に時間がかかるため、早期に適切な判断を下すことが重要です。パーティショニング戦略を最適化するためには、意図したワークロードのシミュレーションが有益であることがよくあります。パーティションの数が多い方が少ないよりも良いと決めつけてはいけませんし、逆もまた然りです。</target>
        </trans-unit>
        <trans-unit id="3766650cc974cf1ed93fe99df3e842788c554914" translate="yes" xml:space="preserve">
          <source>With no advance preparation, the system would have to scan the entire &lt;code&gt;test1&lt;/code&gt; table, row by row, to find all matching entries. If there are many rows in &lt;code&gt;test1&lt;/code&gt; and only a few rows (perhaps zero or one) that would be returned by such a query, this is clearly an inefficient method. But if the system has been instructed to maintain an index on the &lt;code&gt;id&lt;/code&gt; column, it can use a more efficient method for locating matching rows. For instance, it might only have to walk a few levels deep into a search tree.</source>
          <target state="translated">事前の準備がなければ、システムは &lt;code&gt;test1&lt;/code&gt; テーブル全体を行ごとにスキャンして、一致するすべてのエントリを見つける必要があります。 &lt;code&gt;test1&lt;/code&gt; に多数の行があり、そのようなクエリによって返される行が少数（おそらく0または1）しかない場合、これは明らかに非効率的な方法です。しかし、システムが &lt;code&gt;id&lt;/code&gt; 列のインデックスを維持するように指示されている場合、一致する行を見つけるためのより効率的な方法を使用できます。たとえば、検索ツリーの深さを数レベルだけ歩く必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d718f6eccff45185b0a45095de6fde081eea1bba" translate="yes" xml:space="preserve">
          <source>With no argument, escapes to a sub-shell; psql resumes when the sub-shell exits. With an argument, executes the shell command &lt;code&gt;command&lt;/code&gt;.</source>
          <target state="translated">引数なしで、サブシェルにエスケープします。サブシェルが終了すると、psqlが再開します。引数を指定して、シェルコマンド &lt;code&gt;command&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="9514950fe011b56b473f75097880ade2b163bceb" translate="yes" xml:space="preserve">
          <source>With statement-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="translated">ステートメントベースのレプリケーションミドルウェアを使用すると、プログラムはすべてのSQLクエリをインターセプトし、それを1つまたはすべてのサーバに送信します。各サーバは独立して動作します。読み書き可能なクエリは、すべてのサーバに送信しなければならないので、すべてのサーバが変更を受け取ることになります。しかし、読み取り専用のクエリは1つのサーバーに送信することができ、読み取り作業負荷をサーバー間で分散させることができます。</target>
        </trans-unit>
        <trans-unit id="4094d09ba0d0f0a9849aa3ea46bb7d77a767e980" translate="yes" xml:space="preserve">
          <source>With synchronous replication options specified at the application level (on the primary) we can offer synchronous replication for the most important changes, without slowing down the bulk of the total workload. Application level options are an important and practical tool for allowing the benefits of synchronous replication for high performance applications.</source>
          <target state="translated">アプリケーションレベル(プライマリ)で同期レプリケーションオプションを指定することで、全体のワークロードの大部分を減速させることなく、最も重要な変更に対しても同期レプリケーションを提供することができます。アプリケーションレベルのオプションは、ハイパフォーマンスアプリケーションで同期レプリケーションのメリットを享受するための重要かつ実用的なツールです。</target>
        </trans-unit>
        <trans-unit id="e625f82083935e0517f3c7cf1a804070d41f41f5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--aggregate-interval&lt;/code&gt; option, a different format is used for the log files:</source>
          <target state="translated">&lt;code&gt;--aggregate-interval&lt;/code&gt; オプション、異なるフォーマットは、ログファイル用に使用されます。</target>
        </trans-unit>
        <trans-unit id="21c13395c6ff50aca429bd803e2b410319037881" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-l&lt;/code&gt; option (but without the &lt;code&gt;--aggregate-interval&lt;/code&gt; option), pgbench writes information about each transaction to a log file. The log file will be named &lt;code&gt;prefix.nnn&lt;/code&gt;, where &lt;code&gt;prefix&lt;/code&gt; defaults to &lt;code&gt;pgbench_log&lt;/code&gt;, and &lt;code&gt;nnn&lt;/code&gt; is the PID of the pgbench process. The prefix can be changed by using the &lt;code&gt;--log-prefix&lt;/code&gt; option. If the &lt;code&gt;-j&lt;/code&gt; option is 2 or higher, so that there are multiple worker threads, each will have its own log file. The first worker will use the same name for its log file as in the standard single worker case. The additional log files for the other workers will be named &lt;code&gt;prefix.nnn.mmm&lt;/code&gt;, where &lt;code&gt;mmm&lt;/code&gt; is a sequential number for each worker starting with 1.</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; オプション（しかしなし &lt;code&gt;--aggregate-interval&lt;/code&gt; オプション）、pgbenchは、ログファイルに各トランザクションに関する情報を書き込みます。ログファイルの名前は &lt;code&gt;prefix.nnn&lt;/code&gt; です。ここで、 &lt;code&gt;prefix&lt;/code&gt; のデフォルトは &lt;code&gt;pgbench_log&lt;/code&gt; で、 &lt;code&gt;nnn&lt;/code&gt; はpgbenchプロセスのPIDです。プレフィックスは &lt;code&gt;--log-prefix&lt;/code&gt; オプションを使用して変更できます。場合は &lt;code&gt;-j&lt;/code&gt; オプションが2以上であるので、複数のワーカースレッドがあることを、それぞれが独自のログファイルを持っています。最初のワーカーは、標準の単一ワーカーの場合と同じ名前をログファイルに使用します。他のワーカーの追加のログファイルには、 &lt;code&gt;prefix.nnn.mmm&lt;/code&gt; という名前が付けられます。 &lt;code&gt;mmm&lt;/code&gt; は、1から始まる各ワーカーの連番です。</target>
        </trans-unit>
        <trans-unit id="dea12aa8ce2a4f9481a6f03ad5ce52c7d1882b2a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-r&lt;/code&gt; option, pgbench collects the elapsed transaction time of each statement executed by every client. It then reports an average of those values, referred to as the latency for each statement, after the benchmark has finished.</source>
          <target state="translated">&lt;code&gt;-r&lt;/code&gt; オプション、pgbenchは、すべてのクライアントで実行される各文の経過、取引時間を収集します。次に、ベンチマークが終了した後、各ステートメントのレイテンシと呼ばれるこれらの値の平均を報告します。</target>
        </trans-unit>
        <trans-unit id="b0d0adcb9fc8fc9dddac0cfadc06d179ba840172" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;, it is only useful to place a &lt;code&gt;simple&lt;/code&gt; dictionary at the end of a list of dictionaries, since it will never pass on any token to a following dictionary. Conversely, &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; is only useful when there is at least one following dictionary.</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; のデフォルト設定では、 &lt;code&gt;simple&lt;/code&gt; ディクショナリは次のディクショナリにトークンを渡さないため、ディクショナリのリストの最後に配置することだけが役立ちます。逆に、 &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; は、少なくとも1つの後続の辞書がある場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="1679a02524be37201556be412a6d701fa1ad4ae3" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="translated">これまでに説明したツールを使用すると、完全に機能するテーブルを作成できます。この章の残りの部分では、テーブルの定義に機能を追加して、データの整合性、セキュリティ、または利便性を確保する方法について説明します。テーブルにデータを入力したい場合は、&lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;第6章に&lt;/a&gt;進んで、この章の残りの部分を後で読むことができます。</target>
        </trans-unit>
        <trans-unit id="37674f638cca87d9f8a3c6dc8d132c3743ff6b7c" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g. &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="translated">このパラメーターを有効にしても、通常のグローバルユーザーを作成できます。クライアントでユーザー名を指定するときは、 &lt;code&gt;@&lt;/code&gt; を追加するだけです（例： &lt;code&gt;joe@&lt;/code&gt; 。 &lt;code&gt;@&lt;/code&gt; は、ユーザー名がサーバーによって検索される前に剥離することになります。</target>
        </trans-unit>
        <trans-unit id="de39e9b44ca28bac2cf5d078925f7311c5e84abb" translate="yes" xml:space="preserve">
          <source>With this preparation, a backup can be taken using a script like the following:</source>
          <target state="translated">この準備があれば、以下のようなスクリプトを使ってバックアップを取ることができます。</target>
        </trans-unit>
        <trans-unit id="d7d93925105d3192c92e0036610fccacd28a3de6" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;, the special table names &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt; can be used to refer to values in the referenced table. &lt;code&gt;NEW&lt;/code&gt; is valid in &lt;code&gt;ON INSERT&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; rules to refer to the new row being inserted or updated. &lt;code&gt;OLD&lt;/code&gt; is valid in &lt;code&gt;ON UPDATE&lt;/code&gt; and &lt;code&gt;ON DELETE&lt;/code&gt; rules to refer to the existing row being updated or deleted.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; および &lt;code&gt;command&lt;/code&gt; 内では、 &lt;code&gt;NEW&lt;/code&gt; および &lt;code&gt;OLD&lt;/code&gt; という特別なテーブル名を使用して、参照されるテーブルの値を参照できます。 &lt;code&gt;NEW&lt;/code&gt; は、挿入または更新される新しい行を参照する &lt;code&gt;ON INSERT&lt;/code&gt; および &lt;code&gt;ON UPDATE&lt;/code&gt; ルールで有効です。 &lt;code&gt;OLD&lt;/code&gt; は &lt;code&gt;ON UPDATE&lt;/code&gt; および &lt;code&gt;ON DELETE&lt;/code&gt; ルールで有効であり、更新または削除される既存の行を参照します。</target>
        </trans-unit>
        <trans-unit id="b7c7983937789ea59f666ccaa3b6dc10f18e4489" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;tsquery&lt;/code&gt;, the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) operator specifies that both its arguments must appear in the document to have a match. Similarly, the &lt;code&gt;|&lt;/code&gt; (OR) operator specifies that at least one of its arguments must appear, while the &lt;code&gt;!&lt;/code&gt; (NOT) operator specifies that its argument must &lt;em&gt;not&lt;/em&gt; appear in order to have a match. For example, the query &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; matches documents that contain &lt;code&gt;fat&lt;/code&gt; but not &lt;code&gt;rat&lt;/code&gt;.</source>
          <target state="translated">内 &lt;code&gt;tsquery&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; （AND）演算子の両方を指定その引数が試合を持っているために、文書に表示されなければならないこと。同様に、 &lt;code&gt;|&lt;/code&gt; （OR）演算子は、引数の少なくとも1つを指定する必要があることを指定しますが、 &lt;code&gt;!&lt;/code&gt; （NOT）演算子は、一致させるためにその引数を指定してはなら&lt;em&gt;ない&lt;/em&gt;ことを指定します。たとえば、クエリ &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; は、 &lt;code&gt;fat&lt;/code&gt; を含むが、 &lt;code&gt;rat&lt;/code&gt; を含まないドキュメントに一致します。</target>
        </trans-unit>
        <trans-unit id="f2368cc4cb5a919d014b1e03cda4cf0d9819b781" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a &lt;code&gt;ch&lt;/code&gt; collating element, then the RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; matches the first five characters of &lt;code&gt;chchcc&lt;/code&gt;.</source>
          <target state="translated">角括弧式内で、 &lt;code&gt;[.&lt;/code&gt; 囲まれた照合要素（文字、単一文字であるかのように照合する複数文字シーケンス、またはいずれかの照合シーケンス名）。 and &lt;code&gt;.]&lt;/code&gt; は、その照合要素の文字シーケンスを表します。シーケンスは、ブラケット式のリストの単一の要素として扱われます。これにより、複数文字の照合要素を含むブラケット式が複数の文字に一致することができます。たとえば、照合シーケンスに &lt;code&gt;ch&lt;/code&gt; 照合要素が含まれている場合、RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; は &lt;code&gt;chchcc&lt;/code&gt; の最初の5文字に一致します。</target>
        </trans-unit>
        <trans-unit id="5e1fe750b2061555e551fa7ddfd0d60d1ac81517" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element enclosed in &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; is an &lt;em&gt;equivalence class&lt;/em&gt;, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt;.) For example, if &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt; are the members of an equivalence class, then &lt;code&gt;[[=o=]]&lt;/code&gt;, &lt;code&gt;[[=^=]]&lt;/code&gt;, and &lt;code&gt;[o^]&lt;/code&gt; are all synonymous. An equivalence class cannot be an endpoint of a range.</source>
          <target state="translated">ブラケット式内では、 &lt;code&gt;[=&lt;/code&gt; と &lt;code&gt;=]&lt;/code&gt; で囲まれた照合要素は&lt;em&gt;等価クラスであり&lt;/em&gt;、それ自体を含む、それに対応するすべての照合要素の文字シーケンスを表します。 （同等の照合要素が他にない場合は、囲まれた区切り文字が &lt;code&gt;[.&lt;/code&gt; および &lt;code&gt;.]&lt;/code&gt; かのように扱われます。）たとえば、 &lt;code&gt;o&lt;/code&gt; と &lt;code&gt;^&lt;/code&gt; が同値クラスのメンバーである場合、 &lt;code&gt;[[=o=]]&lt;/code&gt; 、 &lt;code&gt;[[=^=]]&lt;/code&gt; と &lt;code&gt;[o^]&lt;/code&gt; はすべて同義です。同値クラスを範囲のエンドポイントにすることはできません。</target>
        </trans-unit>
        <trans-unit id="abb82d076f25a7be9aee0f56365d178b74a1a2ff" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, the name of a character class enclosed in &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; stands for the list of all characters belonging to that class. A character class cannot be used as an endpoint of a range. The POSIX standard defines these character class names: &lt;code&gt;alnum&lt;/code&gt; (letters and numeric digits), &lt;code&gt;alpha&lt;/code&gt; (letters), &lt;code&gt;blank&lt;/code&gt; (space and tab), &lt;code&gt;cntrl&lt;/code&gt; (control characters), &lt;code&gt;digit&lt;/code&gt; (numeric digits), &lt;code&gt;graph&lt;/code&gt; (printable characters except space), &lt;code&gt;lower&lt;/code&gt; (lower-case letters), &lt;code&gt;print&lt;/code&gt; (printable characters including space), &lt;code&gt;punct&lt;/code&gt; (punctuation), &lt;code&gt;space&lt;/code&gt; (any white space), &lt;code&gt;upper&lt;/code&gt; (upper-case letters), and &lt;code&gt;xdigit&lt;/code&gt; (hexadecimal digits). The behavior of these standard character classes is generally consistent across platforms for characters in the 7-bit ASCII set. Whether a given non-ASCII character is considered to belong to one of these classes depends on the &lt;em&gt;collation&lt;/em&gt; that is used for the regular-expression function or operator (see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;), or by default on the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting (see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;). The classification of non-ASCII characters can vary across platforms even in similarly-named locales. (But the &lt;code&gt;C&lt;/code&gt; locale never considers any non-ASCII characters to belong to any of these classes.) In addition to these standard character classes, PostgreSQL defines the &lt;code&gt;ascii&lt;/code&gt; character class, which contains exactly the 7-bit ASCII set.</source>
          <target state="translated">ブラケット式内では、 &lt;code&gt;[:&lt;/code&gt; と &lt;code&gt;:]&lt;/code&gt; で囲まれた文字クラスの名前は、そのクラスに属するすべての文字のリストを表します。文字クラスは範囲のエンドポイントとして使用できません。 POSIX標準は、これらの文字クラス名を定義します： &lt;code&gt;alnum&lt;/code&gt; （文字と数字）、 &lt;code&gt;alpha&lt;/code&gt; （文字）、 &lt;code&gt;blank&lt;/code&gt; （スペースとタブ）、 &lt;code&gt;cntrl&lt;/code&gt; （制御文字）、 &lt;code&gt;digit&lt;/code&gt; （数字）、 &lt;code&gt;graph&lt;/code&gt; （スペース以外の印刷可能な文字）、 &lt;code&gt;lower&lt;/code&gt; （小文字）、 &lt;code&gt;print&lt;/code&gt; （スペースを含む印刷可能文字）、 &lt;code&gt;punct&lt;/code&gt; （句読点）、 &lt;code&gt;space&lt;/code&gt; （任意の空白）、 &lt;code&gt;upper&lt;/code&gt; （大文字）、および &lt;code&gt;xdigit&lt;/code&gt; （16進数）。これらの標準文字クラスの動作は、7ビットASCIIセットの文字のプラットフォーム間で一般的に一貫しています。特定の非ASCII文字がこれらのクラスのいずれかに属していると見なされるかどうかは、正規表現関数または演算子に使用される&lt;em&gt;照合&lt;/em&gt;（&lt;a href=&quot;collation&quot;&gt;セクション23.2を&lt;/a&gt;参照）、またはデフォルトでデータベースの &lt;code&gt;LC_CTYPE&lt;/code&gt; ロケール設定（&lt;a href=&quot;locale&quot;&gt;セクション23.1を&lt;/a&gt;参照）に依存します。）。非ASCII文字の分類は、同様の名前のロケールであっても、プラットフォームによって異なる場合があります。 （しかし、 &lt;code&gt;C&lt;/code&gt; ロケールは、非ASCII文字がこれらのクラスのいずれかに属しているとは決して見なしません。）これらの標準文字クラスに加えて、PostgreSQLは、7ビットASCIIセットを正確に含む &lt;code&gt;ascii&lt;/code&gt; 文字クラスを定義します。</target>
        </trans-unit>
        <trans-unit id="d35bef27a0203dd6547cf96a8cb6d957c5595d5c" translate="yes" xml:space="preserve">
          <source>Within a pattern, &lt;code&gt;*&lt;/code&gt; matches any sequence of characters (including no characters) and &lt;code&gt;?&lt;/code&gt; matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, &lt;code&gt;\dt int*&lt;/code&gt; displays tables whose names begin with &lt;code&gt;int&lt;/code&gt;. But within double quotes, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; lose these special meanings and are just matched literally.</source>
          <target state="translated">パターン内では、 &lt;code&gt;*&lt;/code&gt; は任意の文字シーケンス（文字なしを含む）と一致し、 &lt;code&gt;?&lt;/code&gt; 任意の1文字と一致します。（この表記は、Unixシェルのファイル名パターンに相当します。）たとえば、 &lt;code&gt;\dt int*&lt;/code&gt; は、名前が &lt;code&gt;int&lt;/code&gt; で始まるテーブルを表示します。ただし、二重引用符内では、 &lt;code&gt;*&lt;/code&gt; および &lt;code&gt;?&lt;/code&gt; これらの特別な意味を失い、文字通り一致します。</target>
        </trans-unit>
        <trans-unit id="323b9b12ce6cec030c2782c77172b386cffa6487" translate="yes" xml:space="preserve">
          <source>Within an argument, text that is enclosed in backquotes (&lt;code&gt;`&lt;/code&gt;) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. Within the text enclosed in backquotes, no special quoting or other processing occurs, except that appearances of &lt;code&gt;:variable_name&lt;/code&gt; where &lt;code&gt;variable_name&lt;/code&gt; is a psql variable name are replaced by the variable's value. Also, appearances of &lt;code&gt;:'variable_name'&lt;/code&gt; are replaced by the variable's value suitably quoted to become a single shell command argument. (The latter form is almost always preferable, unless you are very sure of what is in the variable.) Because carriage return and line feed characters cannot be safely quoted on all platforms, the &lt;code&gt;:'variable_name'&lt;/code&gt; form prints an error message and does not substitute the variable value when such characters appear in the value.</source>
          <target state="translated">引数内では、バッククォート（ &lt;code&gt;`&lt;/code&gt; ）で囲まれたテキストが、シェルに渡されるコマンドラインとして解釈されます。コマンドの出力（末尾の改行が削除されている）は、バッククォートされたテキストを置き換えます。バッククォートで囲まれたテキスト内では、 &lt;code&gt;:variable_name&lt;/code&gt; （ &lt;code&gt;variable_name&lt;/code&gt; はpsql変数名）の出現が変数の値で置き換えられることを除いて、特別なクォートやその他の処理は行われません。また、 &lt;code&gt;:'variable_name'&lt;/code&gt; の出現単一のシェルコマンド引数になるように適切に引用された変数の値に置き換えられます。 （変数の内容が明確でない限り、ほとんどの場合後者の形式が推奨されます。）すべてのプラットフォームで復帰文字と改行文字を安全に引用できないため、 &lt;code&gt;:'variable_name'&lt;/code&gt; 形式はエラーメッセージを出力しません。そのような文字が値に現れる場合、変数値を置き換えます。</target>
        </trans-unit>
        <trans-unit id="02446a7929ab10f300f87f18642a172ae6a7fbfe" translate="yes" xml:space="preserve">
          <source>Within any particular database, only collations that use that database's encoding are of interest. Other entries in &lt;code&gt;pg_collation&lt;/code&gt; are ignored. Thus, a stripped collation name such as &lt;code&gt;de_DE&lt;/code&gt; can be considered unique within a given database even though it would not be unique globally. Use of the stripped collation names is recommended, since it will make one less thing you need to change if you decide to change to another database encoding. Note however that the &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; collations can be used regardless of the database encoding.</source>
          <target state="translated">特定のデータベース内では、そのデータベースのエンコーディングを使用する照合のみが対象です。 &lt;code&gt;pg_collation&lt;/code&gt; 他のエントリは無視されます。したがって、 &lt;code&gt;de_DE&lt;/code&gt; などの除去された照合名は、グローバルに一意でなくても、特定のデータベース内で一意と見なすことができます。別のデータベースエンコーディングに変更する場合、変更する必要のあることが1つ少なくなるため、ストリップされた照合名の使用をお勧めします。ただし、 &lt;code&gt;default&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、および &lt;code&gt;POSIX&lt;/code&gt; 照合は、データベースのエンコードに関係なく使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4a80b578691f1b5a7af0065fe86a5cb4aa2ce86a" translate="yes" xml:space="preserve">
          <source>Within bracket expressions, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; lose their outer brackets, and &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt; are illegal. (So, for example, &lt;code&gt;[a-c\d]&lt;/code&gt; is equivalent to &lt;code&gt;[a-c[:digit:]]&lt;/code&gt;. Also, &lt;code&gt;[a-c\D]&lt;/code&gt;, which is equivalent to &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt;, is illegal.)</source>
          <target state="translated">ブラケット式内では、 &lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\s&lt;/code&gt; 、および &lt;code&gt;\w&lt;/code&gt; は外側のブラケットを失い、 &lt;code&gt;\D&lt;/code&gt; 、 &lt;code&gt;\S&lt;/code&gt; 、および &lt;code&gt;\W&lt;/code&gt; は無効です。 （たとえば、 &lt;code&gt;[a-c\d]&lt;/code&gt; は &lt;code&gt;[a-c[:digit:]]&lt;/code&gt; ]と同等です。また、 &lt;code&gt;[a-c\D]&lt;/code&gt; は &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt; と同等であり、不正です。）</target>
        </trans-unit>
        <trans-unit id="2542957abf2f09b64545fb48b800de1036c8c62f" translate="yes" xml:space="preserve">
          <source>Within each FSM page is a binary tree, stored in an array with one byte per node. Each leaf node represents a heap page, or a lower level FSM page. In each non-leaf node, the higher of its children's values is stored. The maximum value in the leaf nodes is therefore stored at the root.</source>
          <target state="translated">各 FSM ページ内には、ノードごとに 1 バイトの配列に格納されたバイナリツリーがあります。各リーフノードはヒープページ、または下位レベルのFSMページを表します。各非リーフノードでは、その子ノードの値のうち高い方の値が格納されます。したがって、リーフノードの最大値はルートに格納されます。</target>
        </trans-unit>
        <trans-unit id="eb8d6e1ae92682e55948b9d998dc41d07bd4d9ee" translate="yes" xml:space="preserve">
          <source>Within each catalog row, write comma-separated &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The allowed &lt;code&gt;key&lt;/code&gt;s are the names of the catalog's columns, plus the metadata keys &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt;. (The use of &lt;code&gt;oid&lt;/code&gt; and &lt;code&gt;oid_symbol&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;Section 69.2.2&lt;/a&gt; below, while &lt;code&gt;array_type_oid&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;Section 69.2.4&lt;/a&gt;. &lt;code&gt;descr&lt;/code&gt; supplies a description string for the object, which will be inserted into &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_shdescription&lt;/code&gt; as appropriate.) While the metadata keys are optional, the catalog's defined columns must all be provided, except when the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for the column. (In the example above, the &lt;code&gt;datdba&lt;/code&gt; field has been omitted because &lt;code&gt;pg_database.h&lt;/code&gt; supplies a suitable default value for it.)</source>
          <target state="translated">各カタログ行内に、カンマ区切りの &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; ペアを記述します。許可される &lt;code&gt;key&lt;/code&gt; は、カタログの列の名前と、メタデータキー &lt;code&gt;oid&lt;/code&gt; 、 &lt;code&gt;oid_symbol&lt;/code&gt; 、 &lt;code&gt;array_type_oid&lt;/code&gt; 、および &lt;code&gt;descr&lt;/code&gt; です。 （の使用 &lt;code&gt;oid&lt;/code&gt; と &lt;code&gt;oid_symbol&lt;/code&gt; がに記載されている&lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;セクション69.2.2&lt;/a&gt;ながら、以下 &lt;code&gt;array_type_oid&lt;/code&gt; がに記載されている&lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;セクション69.2.4&lt;/a&gt;。 &lt;code&gt;descr&lt;/code&gt; 中に挿入されるオブジェクトの説明文字列を供給する &lt;code&gt;pg_description&lt;/code&gt; または &lt;code&gt;pg_shdescription&lt;/code&gt; メタデータキーはオプションですが、カタログの &lt;code&gt;.h&lt;/code&gt; ファイルで列のデフォルト値が指定されている場合を除き、カタログで定義されている列をすべて指定する必要があります。（上記の例では、 &lt;code&gt;pg_database.h&lt;/code&gt; が適切なデフォルト値を提供するため、 &lt;code&gt;datdba&lt;/code&gt; フィールドは省略されています。）</target>
        </trans-unit>
        <trans-unit id="3b70f85093aa93c4bd37783889d55ab04e575f61" translate="yes" xml:space="preserve">
          <source>Within each pair of curly braces, the metadata fields &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt; (if present) come first, in that order, then the catalog's own fields appear in their defined order.</source>
          <target state="translated">中括弧の各ペア内では、メタデータフィールド &lt;code&gt;oid&lt;/code&gt; 、 &lt;code&gt;oid_symbol&lt;/code&gt; 、 &lt;code&gt;array_type_oid&lt;/code&gt; 、および &lt;code&gt;descr&lt;/code&gt; （存在する場合）がこの順序で最初に来て、カタログの独自のフィールドが定義された順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="7877c1484b515b178eb13d5365bc7aee43c3498f" translate="yes" xml:space="preserve">
          <source>Within larger commands, &lt;code&gt;VALUES&lt;/code&gt; is syntactically allowed anywhere that &lt;code&gt;SELECT&lt;/code&gt; is. Because it is treated like a &lt;code&gt;SELECT&lt;/code&gt; by the grammar, it is possible to use the &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt; (or equivalently &lt;code&gt;FETCH FIRST&lt;/code&gt;), and &lt;code&gt;OFFSET&lt;/code&gt; clauses with a &lt;code&gt;VALUES&lt;/code&gt; command.</source>
          <target state="translated">より大きなコマンド内では、 &lt;code&gt;VALUES&lt;/code&gt; は構文的に &lt;code&gt;SELECT&lt;/code&gt; のどこにでも許可されます。文法では &lt;code&gt;SELECT&lt;/code&gt; のように扱われるため、 &lt;code&gt;VALUES&lt;/code&gt; コマンドで &lt;code&gt;ORDER BY&lt;/code&gt; 、 &lt;code&gt;LIMIT&lt;/code&gt; （または同等の &lt;code&gt;FETCH FIRST&lt;/code&gt; ）、および &lt;code&gt;OFFSET&lt;/code&gt; 句を使用できます。</target>
        </trans-unit>
        <trans-unit id="85b2c20b975865db54e88c092240735063656bf9" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;ANALYZE&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to analyze. With a list, &lt;code&gt;ANALYZE&lt;/code&gt; processes only those table(s). It is further possible to give a list of column names for a table, in which case only the statistics for those columns are collected.</source>
          <target state="translated">&lt;code&gt;table_and_columns&lt;/code&gt; リストがない場合、 &lt;code&gt;ANALYZE&lt;/code&gt; は、現在のユーザーが分析する権限を持つ現在のデータベース内のすべてのテーブルとマテリアライズドビューを処理します。リストを使用すると、 &lt;code&gt;ANALYZE&lt;/code&gt; はそれらのテーブルのみを処理します。さらに、テーブルの列名のリストを指定することもできます。その場合、それらの列の統計のみが収集されます。</target>
        </trans-unit>
        <trans-unit id="0bd2342b55fa6fe36f0fd7dea1e8abcfbe35286d" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;VACUUM&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to vacuum. With a list, &lt;code&gt;VACUUM&lt;/code&gt; processes only those table(s).</source>
          <target state="translated">&lt;code&gt;table_and_columns&lt;/code&gt; リストがない場合、 &lt;code&gt;VACUUM&lt;/code&gt; は、現在のユーザーがバキュームする権限を持つ現在のデータベース内のすべてのテーブルとマテリアライズドビューを処理します。リストを使用すると、 &lt;code&gt;VACUUM&lt;/code&gt; はそれらのテーブルのみを処理します。</target>
        </trans-unit>
        <trans-unit id="2564642da39c57e6f0da0af32cec7b221b00e6cf" translate="yes" xml:space="preserve">
          <source>Without a qualification, &lt;code&gt;DELETE&lt;/code&gt; will remove &lt;em&gt;all&lt;/em&gt; rows from the given table, leaving it empty. The system will not request confirmation before doing this!</source>
          <target state="translated">修飾がない場合、 &lt;code&gt;DELETE&lt;/code&gt; は指定されたテーブルから&lt;em&gt;すべての&lt;/em&gt;行を削除し、空のままにします。システムはこれを行う前に確認を要求しません！</target>
        </trans-unit>
        <trans-unit id="63fcdcc5d8356bd3ccce31a7a0f56d4a3af85303" translate="yes" xml:space="preserve">
          <source>Without functional-dependency statistics, the planner would assume that the two &lt;code&gt;WHERE&lt;/code&gt; conditions are independent, and would multiply their selectivities together to arrive at a much-too-small row count estimate. With such statistics, the planner recognizes that the &lt;code&gt;WHERE&lt;/code&gt; conditions are redundant and does not underestimate the row count.</source>
          <target state="translated">機能依存の統計がない場合、プランナは2つの &lt;code&gt;WHERE&lt;/code&gt; 条件が独立していると想定し、それらの選択性を掛け合わせて、行数の見積もりが少なすぎます。このような統計により、プランナは &lt;code&gt;WHERE&lt;/code&gt; 条件が冗長であることを認識し、行数を過小評価しません。</target>
        </trans-unit>
        <trans-unit id="dc783547ace7f2e9e22e7b50a67f3d97784d6474" translate="yes" xml:space="preserve">
          <source>Without partition pruning, the above query would scan each of the partitions of the &lt;code&gt;measurement&lt;/code&gt; table. With partition pruning enabled, the planner will examine the definition of each partition and prove that the partition need not be scanned because it could not contain any rows meeting the query's &lt;code&gt;WHERE&lt;/code&gt; clause. When the planner can prove this, it excludes (&lt;em&gt;prunes&lt;/em&gt;) the partition from the query plan.</source>
          <target state="translated">パーティションプルーニングを使用しない場合、上記のクエリは &lt;code&gt;measurement&lt;/code&gt; テーブルの各パーティションをスキャンします。パーティションプルーニングを有効にすると、プランナは各パーティションの定義を調べ、クエリの &lt;code&gt;WHERE&lt;/code&gt; 句を満たす行を含めることができないため、パーティションをスキャンする必要がないことを証明します。プランナーがこれを証明できると、クエリプランからパーティションが除外（&lt;em&gt;プルーニング&lt;/em&gt;）されます。</target>
        </trans-unit>
        <trans-unit id="23034486b72d6e700160ee9f0facdf636985eee4" translate="yes" xml:space="preserve">
          <source>Without quotes, &lt;code&gt;to_tsquery&lt;/code&gt; will generate a syntax error for tokens that are not separated by an AND, OR, or FOLLOWED BY operator.</source>
          <target state="translated">引用符がないと、 &lt;code&gt;to_tsquery&lt;/code&gt; は、AND、OR、またはFOLLOWED BY演算子で区切られていないトークンの構文エラーを生成します。</target>
        </trans-unit>
        <trans-unit id="8d1c012acaa571247fa7393ff98695c754cfacba" translate="yes" xml:space="preserve">
          <source>Without the extra parentheses, this will generate a syntax error.</source>
          <target state="translated">余分な括弧がない場合は、構文エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="3003268a98f289ec381313920f30367739bc175f" translate="yes" xml:space="preserve">
          <source>Without the third rule, it is possible for an index reader to see an index entry just before it is removed by &lt;code&gt;VACUUM&lt;/code&gt;, and then to arrive at the corresponding heap entry after that was removed by &lt;code&gt;VACUUM&lt;/code&gt;. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by &lt;code&gt;heap_fetch()&lt;/code&gt;. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as &lt;code&gt;SnapshotAny&lt;/code&gt;), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be &amp;ldquo;in flight&amp;rdquo; from the index entry to the matching heap entry. Making &lt;code&gt;ambulkdelete&lt;/code&gt; block on such a pin ensures that &lt;code&gt;VACUUM&lt;/code&gt; cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict.</source>
          <target state="translated">インデックスリーダーは、それがすることによって除去される直前にインデックスエントリを参照するための第3のルールなしで、それが可能で &lt;code&gt;VACUUM&lt;/code&gt; 、その後それはによって除去した後、対応するヒープ・エントリに到達する &lt;code&gt;VACUUM&lt;/code&gt; 。空の項目スロットは &lt;code&gt;heap_fetch()&lt;/code&gt; によって無視されるため、リーダーが到達したときにその項目番号がまだ使用されていない場合、これは深刻な問題を引き起こしません。しかし、3番目のバックエンドがアイテムスロットを他の何かのためにすでに再利用している場合はどうなりますか？ MVCC準拠のスナップショットを使用する場合、スロットの新しい占有者はスナップショットテストに合格するには新しすぎることが確実であるため、問題はありません。ただし、MVCCに準拠していないスナップショット（ &lt;code&gt;SnapshotAny&lt;/code&gt; など））、実際にはスキャンキーと一致しない行を受け入れて返すことが可能です。スキャンキーをすべての場合にヒープ行に対して再チェックするように要求することで、このシナリオを防ぐことができますが、それはコストがかかりすぎます。代わりに、インデックスページのピンをプロキシとして使用して、リーダーがインデックスエントリから一致するヒープエントリにまだ「移動中」である可能性があることを示します。そのようなピンで &lt;code&gt;ambulkdelete&lt;/code&gt; ブロックを作成すると、リーダーがそれを完了する前に、 &lt;code&gt;VACUUM&lt;/code&gt; がヒープエントリを削除できないことが保証されます。このソリューションは実行時間のコストがほとんどなく、実際に競合が発生するまれなケースでのみブロッキングオーバーヘッドが追加されます。</target>
        </trans-unit>
        <trans-unit id="fdba0729d7141c4dc983525f28420a370b378b16" translate="yes" xml:space="preserve">
          <source>Without this clause, it is an error to specify an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) for an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;. This clause overrides that restriction.</source>
          <target state="translated">この句がないと、 &lt;code&gt;GENERATED ALWAYS&lt;/code&gt; として定義されているID列に（ &lt;code&gt;DEFAULT&lt;/code&gt; 以外の）明示的な値を指定するとエラーになります。この句はその制限を上書きします。</target>
        </trans-unit>
        <trans-unit id="5de5c631615b4050dbf3abcb11bda852949d1d49" translate="yes" xml:space="preserve">
          <source>Word, all ASCII letters</source>
          <target state="translated">ワード、すべてのASCII文字</target>
        </trans-unit>
        <trans-unit id="cd638519c2bb50f94881c41d59edcf0f4b988187" translate="yes" xml:space="preserve">
          <source>Word, all letters</source>
          <target state="translated">ワード、すべての文字</target>
        </trans-unit>
        <trans-unit id="d929261f89fb5edc0a55361dccd5a42cfafc1e28" translate="yes" xml:space="preserve">
          <source>Word, letters and digits</source>
          <target state="translated">単語、文字、数字</target>
        </trans-unit>
        <trans-unit id="1c821c5f35490070199526bcafeccdc95331fb80" translate="yes" xml:space="preserve">
          <source>Work is still needed to improve the genetic algorithm parameter settings. In file &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt;, routines &lt;code&gt;gimme_pool_size&lt;/code&gt; and &lt;code&gt;gimme_number_generations&lt;/code&gt;, we have to find a compromise for the parameter settings to satisfy two competing demands:</source>
          <target state="translated">遺伝的アルゴリズムのパラメーター設定を改善するための作業がまだ必要です。ファイル &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt; 、ルーチン &lt;code&gt;gimme_pool_size&lt;/code&gt; および &lt;code&gt;gimme_number_generations&lt;/code&gt; で、2つの競合する要求を満たすためにパラメーター設定の妥協点を見つける必要があります。</target>
        </trans-unit>
        <trans-unit id="3ae6871c604e1194dadbdf1baf868fa3278d7cc4" translate="yes" xml:space="preserve">
          <source>Write Ahead Log</source>
          <target state="translated">ライトアヘッドログ</target>
        </trans-unit>
        <trans-unit id="3f9793b6786fb282a995505c49ca5c8dab4849b1" translate="yes" xml:space="preserve">
          <source>Write a message to the server log if checkpoints caused by the filling of WAL segment files happen closer together than this amount of time (which suggests that &lt;code&gt;max_wal_size&lt;/code&gt; ought to be raised). If this value is specified without units, it is taken as seconds. The default is 30 seconds (&lt;code&gt;30s&lt;/code&gt;). Zero disables the warning. No warnings will be generated if &lt;code&gt;checkpoint_timeout&lt;/code&gt; is less than &lt;code&gt;checkpoint_warning&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WALセグメントファイルの書き込みによって発生したチェックポイントがこの時間よりも近く発生した場合は、サーバーログにメッセージを書き込みます（ &lt;code&gt;max_wal_size&lt;/code&gt; を大きくする必要があることを示しています）。この値が単位なしで指定された場合、秒として解釈されます。デフォルトは30秒（ &lt;code&gt;30s&lt;/code&gt; ）です。ゼロは警告を無効にします。どんな警告は生成されません &lt;code&gt;checkpoint_timeout&lt;/code&gt; より少ない &lt;code&gt;checkpoint_warning&lt;/code&gt; 。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="79f29b256742ae32a7ee610c6c80dec55fe4bb44" translate="yes" xml:space="preserve">
          <source>Write all query output into file &lt;code&gt;filename&lt;/code&gt;, in addition to the normal output destination.</source>
          <target state="translated">通常の出力先に加えて、すべてのクエリ出力をファイル &lt;code&gt;filename&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="ced9f94f9040a73c60549d122b831459c11a3fbf" translate="yes" xml:space="preserve">
          <source>Write information about each transaction to a log file. See below for details.</source>
          <target state="translated">各トランザクションの情報をログファイルに書き込みます。詳細は以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="e33b6c1a70b5c50c6203011bb22d6394a5061934" translate="yes" xml:space="preserve">
          <source>Write received and decoded transaction data into this file. Use &lt;code&gt;-&lt;/code&gt; for stdout.</source>
          <target state="translated">受信およびデコードされたトランザクションデータをこのファイルに書き込みます。stdoutには &lt;code&gt;-&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="660438e8219803d5c64d3c38fd0601dbee576ac1" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the current data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the server.</source>
          <target state="translated">現在のデータディレクトリとテーブルスペースと同じレイアウトで、出力をプレーンファイルとして書き込みます。クラスタに追加のテーブルスペースがない場合、データベース全体がターゲットディレクトリに配置されます。クラスタに追加のテーブルスペースがある場合、メインデータディレクトリはターゲットディレクトリに配置されますが、他のすべてのテーブルスペースはサーバ上のものと同じ絶対パスに配置されます。</target>
        </trans-unit>
        <trans-unit id="bbc92c3f4b6de8494f22f127e95dec8313f91169" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and all other tablespaces will be named after the tablespace OID.</source>
          <target state="translated">出力をtarファイルとしてターゲットディレクトリに書き込みます。メインデータディレクトリは &lt;code&gt;base.tar&lt;/code&gt; という名前のファイルに書き込まれ、他のすべてのテーブルスペースはテーブルスペースOIDに基づいて名前が付けられます。</target>
        </trans-unit>
        <trans-unit id="12aba288e98df3f05ebad1cf7143b1a4df822af8" translate="yes" xml:space="preserve">
          <source>Write, or append to, a text file</source>
          <target state="translated">テキストファイルへの書き込み、または追加</target>
        </trans-unit>
        <trans-unit id="73694598d4f6dd9ae50f65c44a8d5357103fbda0" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log</source>
          <target state="translated">ライトアヘッドログ</target>
        </trans-unit>
        <trans-unit id="32219ea741aab08cd4b2cc75491ff92cd882b3c1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Shipping</source>
          <target state="translated">ライトアヘッドログ出荷</target>
        </trans-unit>
        <trans-unit id="674bcf8c81a59458958b21d0660da76f6ba332b5" translate="yes" xml:space="preserve">
          <source>Writes the current query buffer to the file &lt;code&gt;filename&lt;/code&gt; or pipes it to the shell command &lt;code&gt;command&lt;/code&gt;. If the current query buffer is empty, the most recently executed query is written instead.</source>
          <target state="translated">現在のクエリバッファをファイル &lt;code&gt;filename&lt;/code&gt; に書き込むか、それをシェルコマンド &lt;code&gt;command&lt;/code&gt; にパイプします。現在のクエリバッファが空の場合、最後に実行されたクエリが代わりに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="b84228914215a42dbe6fe7e926dad3ab9b4cf367" translate="yes" xml:space="preserve">
          <source>Writes the generated LLVM IR out to the file system, inside &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;. This is only useful for working on the internals of the JIT implementation. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be changed by a superuser.</source>
          <target state="translated">生成されたLLVM IRを&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;内のファイルシステムに書き込みます。これは、JIT実装の内部で作業する場合にのみ役立ちます。デフォルト設定は &lt;code&gt;off&lt;/code&gt; です。このパラメーターはスーパーユーザーのみが変更できます。</target>
        </trans-unit>
        <trans-unit id="d5af6404c7f764d57f9d5c62315cdf9f310e1309" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;*&lt;/code&gt; is not necessary, since this behavior is always the default. However, this syntax is still supported for compatibility with older releases where the default could be changed.</source>
          <target state="translated">この動作は常にデフォルトであるため、 &lt;code&gt;*&lt;/code&gt; を記述する必要はありません。ただし、この構文は、デフォルトを変更できる古いリリースとの互換性のために引き続きサポートされています。</target>
        </trans-unit>
        <trans-unit id="6151e701c60f047c7b832b2686813d1310a12fca" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;ALL&lt;/code&gt; in place of a specific privilege grants all privileges that are relevant for the object type.</source>
          <target state="translated">特定の特権の代わりに &lt;code&gt;ALL&lt;/code&gt; を書き込むと、オブジェクトタイプに関連するすべての特権が付与されます。</target>
        </trans-unit>
        <trans-unit id="f43277b6f1b770dadde2ceed80f27334202f924f" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;SECURITY DEFINER&lt;/code&gt; Functions Safely</source>
          <target state="translated">書き込み &lt;code&gt;SECURITY DEFINER&lt;/code&gt; の安全機能を</target>
        </trans-unit>
        <trans-unit id="ffbf328be37b139670f7ef37c6af175473c5c705" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="translated">使用可能ないくつかの言語バインディングの1つを使用して、カスタムアプリケーションを作成します。これらの可能性については、&lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;パートIVで&lt;/a&gt;さらに説明します。</target>
        </trans-unit>
        <trans-unit id="de5165fc57d1f9a5e5c5994fec1932df3a128a9e" translate="yes" xml:space="preserve">
          <source>Writing the actual numeric value of any OID in C code is considered very bad form; always use a macro, instead. Direct references to &lt;code&gt;pg_proc&lt;/code&gt; OIDs are common enough that there's a special mechanism to create the necessary macros automatically; see &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt;. Similarly &amp;mdash; but, for historical reasons, not done the same way &amp;mdash; there's an automatic method for creating macros for &lt;code&gt;pg_type&lt;/code&gt; OIDs. &lt;code&gt;oid_symbol&lt;/code&gt; entries are therefore not necessary in those two catalogs. Likewise, macros for the &lt;code&gt;pg_class&lt;/code&gt; OIDs of system catalogs and indexes are set up automatically. For all other system catalogs, you have to manually specify any macros you need via &lt;code&gt;oid_symbol&lt;/code&gt; entries.</source>
          <target state="translated">CコードでOIDの実際の数値を書き込むことは、非常に悪い形式と見なされます。代わりに、常にマクロを使用してください。 &lt;code&gt;pg_proc&lt;/code&gt; OID への直接参照は十分に一般的であり、必要なマクロを自動的に作成する特別なメカニズムがあります。 &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt; を参照してください。同様に-しかし、歴史的な理由から、同じ方法では行われません &lt;code&gt;pg_type&lt;/code&gt; OIDのマクロを作成するための自動メソッドがあります。したがって、これら2つのカタログでは、 &lt;code&gt;oid_symbol&lt;/code&gt; エントリは必要ありません。同様に、システムカタログとインデックスの &lt;code&gt;pg_class&lt;/code&gt; OIDのマクロは自動的に設定されます。他のすべてのシステムカタログでは、 &lt;code&gt;oid_symbol&lt;/code&gt; エントリを介して必要なマクロを手動で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="d5409f1461aa5b5298ee6d5c93002f7a27e50654" translate="yes" xml:space="preserve">
          <source>XID</source>
          <target state="translated">XID</target>
        </trans-unit>
        <trans-unit id="70fc167721857c5174dbbe545fe597100e840cd6" translate="yes" xml:space="preserve">
          <source>XID for VACUUM operation moving a row version</source>
          <target state="translated">行のバージョンを移動するVACUUM操作のためのXID</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="6dbc2e3a95bd424284a60fab71bfd99ecc6aa480" translate="yes" xml:space="preserve">
          <source>XML Functions</source>
          <target state="translated">XML 関数</target>
        </trans-unit>
        <trans-unit id="677fbcd727fb96243fff280b768de17534da204d" translate="yes" xml:space="preserve">
          <source>XML Limits and Conformance to SQL/XML</source>
          <target state="translated">XMLの限界とSQL/XMLへの適合性</target>
        </trans-unit>
        <trans-unit id="be1200e7280e074bb09cc29b489d7736fa9c3b13" translate="yes" xml:space="preserve">
          <source>XML Type</source>
          <target state="translated">XMLタイプ</target>
        </trans-unit>
        <trans-unit id="72f6e6e18c4cf2cdf2736a3171665401b5f531b0" translate="yes" xml:space="preserve">
          <source>XML data</source>
          <target state="translated">エックスエムエルデータ</target>
        </trans-unit>
        <trans-unit id="9bc2b7976718250ab1463410139c7c00b0f2e7ce" translate="yes" xml:space="preserve">
          <source>XML declarations, if present, are combined as follows. If all argument values have the same XML version declaration, that version is used in the result, else no version is used. If all argument values have the standalone declaration value &amp;ldquo;yes&amp;rdquo;, then that value is used in the result. If all argument values have a standalone declaration value and at least one is &amp;ldquo;no&amp;rdquo;, then that is used in the result. Else the result will have no standalone declaration. If the result is determined to require a standalone declaration but no version declaration, a version declaration with version 1.0 will be used because XML requires an XML declaration to contain a version declaration. Encoding declarations are ignored and removed in all cases.</source>
          <target state="translated">XML宣言がある場合は、次のように結合されます。すべての引数値に同じXMLバージョン宣言がある場合、そのバージョンが結果で使用されます。それ以外の場合、バージョンは使用されません。すべての引数値にスタンドアロン宣言値「yes」がある場合、その値が結果で使用されます。すべての引数値にスタンドアロンの宣言値があり、少なくとも1つが「いいえ」の場合、その値が結果で使用されます。それ以外の場合、結果にはスタンドアロン宣言はありません。結果がスタンドアロン宣言を必要とするがバージョン宣言を必要としないと判断された場合、XMLはバージョン宣言を含むXML宣言を必要とするため、バージョン1.0のバージョン宣言が使用されます。エンコーディング宣言は無視され、すべての場合に削除されます。</target>
        </trans-unit>
        <trans-unit id="93db77a518a3a65df06b8910ae3df05493323aa8" translate="yes" xml:space="preserve">
          <source>XML entity</source>
          <target state="translated">エックスエムエルじったい</target>
        </trans-unit>
        <trans-unit id="41d948a6e01de6c3d4845c4fb6a9cd77bb4a345f" translate="yes" xml:space="preserve">
          <source>XML format is left as an exercise for the reader.</source>
          <target state="translated">XML形式は読者のための演習として残しています。</target>
        </trans-unit>
        <trans-unit id="c648229e46576f92e57966e5bb6a169947ab07af" translate="yes" xml:space="preserve">
          <source>XML tag</source>
          <target state="translated">エックスエムエルタグ</target>
        </trans-unit>
        <trans-unit id="b7b6740d5d3d1f4067adb9c002cd0cc814ec4855" translate="yes" xml:space="preserve">
          <source>XML: IS DOCUMENT</source>
          <target state="translated">XMLを使用しています。は文書です。</target>
        </trans-unit>
        <trans-unit id="863fe78f50c66a6f7d93b18bf787a5d0aa670b5c" translate="yes" xml:space="preserve">
          <source>XML: IS NOT DOCUMENT</source>
          <target state="translated">XMLを使用しています。は文書ではありません。</target>
        </trans-unit>
        <trans-unit id="708b35917f64aea4aecf43902f9f6861b388f0a3" translate="yes" xml:space="preserve">
          <source>XML: XMLEXISTS</source>
          <target state="translated">XMLを使用しています。XMLEXISTS</target>
        </trans-unit>
        <trans-unit id="7aea648b2b4e07c316d48e040a2dfe07aea119ed" translate="yes" xml:space="preserve">
          <source>XML: xml_is_well_formed</source>
          <target state="translated">XML:xml_is_well_formed</target>
        </trans-unit>
        <trans-unit id="3eca7373df1b8e0c5ed4c506c73dcc360d0c1000" translate="yes" xml:space="preserve">
          <source>XML: xmlagg</source>
          <target state="translated">XML:xmlagg</target>
        </trans-unit>
        <trans-unit id="31986b6f48c236780bb28b6f7a97cd2e7fe2fbbc" translate="yes" xml:space="preserve">
          <source>XML: xmlcomment</source>
          <target state="translated">XML:xmlコメント</target>
        </trans-unit>
        <trans-unit id="3336319324aa48adbaa76e0cbbf9934042dd41f7" translate="yes" xml:space="preserve">
          <source>XML: xmlconcat</source>
          <target state="translated">XML:xmlconcat</target>
        </trans-unit>
        <trans-unit id="c269b1860c6e177984dcd77f1f2f9180f500a7b1" translate="yes" xml:space="preserve">
          <source>XML: xmlelement</source>
          <target state="translated">XML:xmlelement</target>
        </trans-unit>
        <trans-unit id="f6f6cd60dad73c2efa2b22421846170fa537daf4" translate="yes" xml:space="preserve">
          <source>XML: xmlforest</source>
          <target state="translated">XML:xmlforest</target>
        </trans-unit>
        <trans-unit id="b4c3ab3b44e0a9d5e8cf4d618e5fb213a70446ae" translate="yes" xml:space="preserve">
          <source>XML: xmlpi</source>
          <target state="translated">XML:xmlpi</target>
        </trans-unit>
        <trans-unit id="2cb9abaad07f3be72c6b803b64719f6ad9373b8b" translate="yes" xml:space="preserve">
          <source>XML: xmlroot</source>
          <target state="translated">XML:xmlroot</target>
        </trans-unit>
        <trans-unit id="fe1c1afeea56eb4d61a6d5854b178d21b29bd194" translate="yes" xml:space="preserve">
          <source>XML: xmltable</source>
          <target state="translated">XML:xmltable</target>
        </trans-unit>
        <trans-unit id="943bcc21921946abacf747784b147601338c43bb" translate="yes" xml:space="preserve">
          <source>XML: xpath</source>
          <target state="translated">XML:xpath</target>
        </trans-unit>
        <trans-unit id="112eb0200c63c2f0de87632cdeab3a1c8a706831" translate="yes" xml:space="preserve">
          <source>XML: xpath_exists</source>
          <target state="translated">XML:xpath_exists</target>
        </trans-unit>
        <trans-unit id="a417f6430ccc4b644617c160b0d4f1b2c80cd5e2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 blurs the distinction between &lt;em&gt;value comparisons&lt;/em&gt; and &lt;em&gt;general comparisons&lt;/em&gt; as XQuery/XPath define them. Both &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; and &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; are existentially quantified comparisons, true if there is any &lt;code&gt;sale&lt;/code&gt; with the given value for the attribute, but &lt;code&gt;sale/@taxable = false()&lt;/code&gt; is a value comparison to the &lt;em&gt;effective boolean value&lt;/em&gt; of a whole node-set. It is true only if no &lt;code&gt;sale&lt;/code&gt; has a &lt;code&gt;taxable&lt;/code&gt; attribute at all.</source>
          <target state="translated">XPath 1.0は、XQuery / XPathが定義するため、&lt;em&gt;値の比較&lt;/em&gt;と&lt;em&gt;一般的な比較&lt;/em&gt;の違いを曖昧にします。 &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; と &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; はどちらも実存的に定量化された比較です。属性に指定 &lt;code&gt;sale&lt;/code&gt; れた値を持つ販売がある場合はtrueですが、 &lt;code&gt;sale/@taxable = false()&lt;/code&gt; はノードセット全体の&lt;em&gt;有効なブール値&lt;/em&gt;。これは、 &lt;code&gt;taxable&lt;/code&gt; 属性を持つ &lt;code&gt;sale&lt;/code&gt; がまったくない場合にのみ当てはまります。</target>
        </trans-unit>
        <trans-unit id="f37617c0d5dc43deba6ebd523a1e7daa408818b2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 does not specify an order for nodes in a node-set, so code that relies on a particular order of the results will be implementation-dependent. Details can be found in &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;Section D.3.1.2&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0はノードセット内のノードの順序を指定しないので、結果の特定の順序に依存するコードは実装に依存します。詳細は、&lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;D.3.1.2項を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccec9b819d48fea6e95ee65b1f2c2363e5212016" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no conditional operator. An XQuery/XPath expression such as &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; has no XPath 1.0 equivalent.</source>
          <target state="translated">XPath 1.0には条件演算子はありません。 &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; などのXQuery / XPath式には、「帽子なし」には同等のXPath 1.0がありません。</target>
        </trans-unit>
        <trans-unit id="575a5727a0aaf2dc929963572ab31f3a07d3b31b" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no ordering comparison operator for strings. Both &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; and &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; are false, because each is a numeric comparison of two &lt;code&gt;NaN&lt;/code&gt;s. In contrast, &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; do compare the strings as strings.</source>
          <target state="translated">XPath 1.0には、文字列の順序付け比較演算子はありません。 &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; および &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; はどちらもfalseです。これは、それぞれが2つの &lt;code&gt;NaN&lt;/code&gt; の数値比較であるためです。対照的に、 &lt;code&gt;=&lt;/code&gt; と &lt;code&gt;!=&lt;/code&gt; は文字列を文字列として比較します。</target>
        </trans-unit>
        <trans-unit id="8c4149ee47a54aa2c037b2786d8549ef1627ad8e" translate="yes" xml:space="preserve">
          <source>XQuery allows declaration and use of local functions.</source>
          <target state="translated">XQueryでは、ローカル関数の宣言と使用が可能です。</target>
        </trans-unit>
        <trans-unit id="818970bcffceb4be8cc185fddd03719babd24f42" translate="yes" xml:space="preserve">
          <source>XQuery character class elements using &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; or the inverse &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; are not supported.</source>
          <target state="translated">&lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; またはその逆の &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; を使用するXQuery文字クラス要素はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="6f9675f91b1bee552c1436f5af897518b9d66036" translate="yes" xml:space="preserve">
          <source>XQuery character class shorthands &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\i&lt;/code&gt;, and &lt;code&gt;\I&lt;/code&gt; are not supported.</source>
          <target state="translated">XQuery文字クラスの省略形である &lt;code&gt;\c&lt;/code&gt; 、 &lt;code&gt;\C&lt;/code&gt; 、 &lt;code&gt;\i&lt;/code&gt; 、および &lt;code&gt;\I&lt;/code&gt; はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="e05d40877e991191e09256daf83989a5f47e5557" translate="yes" xml:space="preserve">
          <source>XQuery character class subtraction is not supported. An example of this feature is using the following to match only English consonants: &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt;.</source>
          <target state="translated">XQuery文字クラスの減算はサポートされていません。この機能の例として、英語の子音のみを照合するために &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d7ba7fb2ffaaf928a3568f9854442e7071379dc9" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">XQueryには、先読みまたは後読み制約がなく、&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;表9.21で&lt;/a&gt;説明されている制約エスケープもありません。</target>
        </trans-unit>
        <trans-unit id="41577214ab7c5c54db475c958675a49fbb00b4a6" translate="yes" xml:space="preserve">
          <source>XQuery does not support the &lt;code&gt;[:name:]&lt;/code&gt; syntax for character classes within bracket expressions.</source>
          <target state="translated">XQueryは、ブラケット式内の文字クラスの &lt;code&gt;[:name:]&lt;/code&gt; 構文をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="2e0c3c6ff5da1ba3d8311b799d1cf51c7385d7c2" translate="yes" xml:space="preserve">
          <source>XQuery expressions can construct and return new XML nodes, in addition to all possible XPath values. XPath can create and return values of the atomic types (numbers, strings, and so on) but can only return XML nodes that were already present in documents supplied as input to the expression.</source>
          <target state="translated">XQuery 式は、可能なすべての XPath 値に加えて、新しい XML ノードを構築して返すことができます。XPath は、アトミック型 (数値、文字列など)の値を作成して返すことができますが、式の入力として供給されたドキュメントに既に存在していた XML ノードのみを返すことができます。</target>
        </trans-unit>
        <trans-unit id="7d07dea26dd7592af4147bb1ae9d21c709ece2a7" translate="yes" xml:space="preserve">
          <source>XQuery has control constructs for iteration, sorting, and grouping.</source>
          <target state="translated">XQueryには、反復、ソート、およびグループ化のための制御構文があります。</target>
        </trans-unit>
        <trans-unit id="9add350a4eb532be8a2c9c9d393be8bd03cceb66" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;s&lt;/code&gt; (allow dot to match newline) and &lt;code&gt;m&lt;/code&gt; (allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines) flags provide access to the same behaviors as POSIX's &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; flags, but they do &lt;em&gt;not&lt;/em&gt; match the behavior of POSIX's &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; flags. Note in particular that dot-matches-newline is the default behavior in POSIX but not XQuery.</source>
          <target state="translated">XQueryの &lt;code&gt;s&lt;/code&gt; （ドットが改行に一致することを許可する）および &lt;code&gt;m&lt;/code&gt; （ &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; が改行に一致することを許可する）フラグは、POSIXの &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; および &lt;code&gt;w&lt;/code&gt; フラグと同じ動作へのアクセスを提供しますが、POSIXの &lt;code&gt;s&lt;/code&gt; および &lt;code&gt;m&lt;/code&gt; フラグの動作に一致しませ&lt;em&gt;ん&lt;/em&gt;。特に、dot-matches-newlineはPOSIXのデフォルトの動作ですが、XQueryではありません。</target>
        </trans-unit>
        <trans-unit id="0fbdf61430816231b42e0b59499fabbec39b5ae3" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;x&lt;/code&gt; (ignore whitespace in pattern) flag is noticeably different from POSIX's expanded-mode flag. POSIX's &lt;code&gt;x&lt;/code&gt; flag also allows &lt;code&gt;#&lt;/code&gt; to begin a comment in the pattern, and POSIX will not ignore a whitespace character after a backslash.</source>
          <target state="translated">XQueryの &lt;code&gt;x&lt;/code&gt; （パターン内の空白を無視）フラグは、POSIXの拡張モードフラグとは著しく異なります。POSIXの &lt;code&gt;x&lt;/code&gt; フラグを使用すると、 &lt;code&gt;#&lt;/code&gt; でパターン内のコメントを開始することもできます。POSIXは、バックスラッシュの後の空白文字を無視しません。</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="cb29757e458776404c0d0c4f5c75b0740d559b1c" translate="yes" xml:space="preserve">
          <source>Year and day of year: for example &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; also returns &lt;code&gt;2006-10-19&lt;/code&gt;.</source>
          <target state="translated">年と日：たとえば、 &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; も &lt;code&gt;2006-10-19&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="fc5a18c267810c3dc6c5d4fdd0b02c9e146fd0f1" translate="yes" xml:space="preserve">
          <source>Year, week number, and weekday: for example &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; returns the date &lt;code&gt;2006-10-19&lt;/code&gt;. If you omit the weekday it is assumed to be 1 (Monday).</source>
          <target state="translated">年、週番号、および曜日：たとえば、 &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; は、日付 &lt;code&gt;2006-10-19&lt;/code&gt; を返します。平日を省略すると、1（月曜日）と見なされます。</target>
        </trans-unit>
        <trans-unit id="7abdb2567a06fc713cd1d6b57e90f634441b367e" translate="yes" xml:space="preserve">
          <source>Year-Month Interval</source>
          <target state="translated">年月間隔</target>
        </trans-unit>
        <trans-unit id="96f997bcecb36502ed4b296a795f72aff9d6bfe7" translate="yes" xml:space="preserve">
          <source>Years</source>
          <target state="translated">Years</target>
        </trans-unit>
        <trans-unit id="3cfd5c7e576642a9c9f3bbe4db929041cea0177f" translate="yes" xml:space="preserve">
          <source>Years in the 1900s are in the second millennium. The third millennium started January 1, 2001.</source>
          <target state="translated">1900年代の年は第二千年紀。第三千年紀は2001年1月1日に始まりました。</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="6dd15150afde3fb668c9c37b5570c9f350a42483" translate="yes" xml:space="preserve">
          <source>You can (and, for most purposes, probably should) increase the number of rows by using the &lt;code&gt;-s&lt;/code&gt; (scale factor) option. The &lt;code&gt;-F&lt;/code&gt; (fillfactor) option might also be used at this point.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; （スケールファクター）オプションを使用すると、行数を増やすことができます（ほとんどの場合、おそらくそうする必要があります）。 &lt;code&gt;-F&lt;/code&gt; （フィルファクタ）オプションもこの時点で使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="145c00d5953681c62f21c82b058caafeee2a8310" translate="yes" xml:space="preserve">
          <source>You can adapt this module to your needs by changing the source code. For example, you can use &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; to check passwords &amp;mdash; this only requires uncommenting two lines in the &lt;code&gt;Makefile&lt;/code&gt; and rebuilding the module. (We cannot include CrackLib by default for license reasons.) Without CrackLib, the module enforces a few simple rules for password strength, which you can modify or extend as you see fit.</source>
          <target state="translated">ソースコードを変更することで、このモジュールをニーズに適合させることができます。たとえば、&lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt;を使用してパスワードをチェックできます&amp;mdash;これには、 &lt;code&gt;Makefile&lt;/code&gt; の 2行のコメントを外してモジュールを再構築するだけです。（ライセンス上の理由により、デフォルトでCrackLibを含めることはできません。）CrackLibがない場合、モジュールはパスワードの強度に関するいくつかの単純なルールを適用します。必要に応じて変更または拡張できます。</target>
        </trans-unit>
        <trans-unit id="28dae3ce662983a3720ca411f5e625f764893bf1" translate="yes" xml:space="preserve">
          <source>You can add whitespace before a left brace or after a right brace. You can also add whitespace before or after any individual item string. In all of these cases the whitespace will be ignored. However, whitespace within double-quoted elements, or surrounded on both sides by non-whitespace characters of an element, is not ignored.</source>
          <target state="translated">左中括弧の前や右中括弧の後に空白を追加することができます。また、個々の項目文字列の前後に空白を追加することもできます。これらすべての場合、空白は無視されます。し か し 、 二重引用符で囲まれた要素内の空白や、 要素の両側で空白以外のキ ャ ラ ク タ で囲まれた空白は無視 さ れません。</target>
        </trans-unit>
        <trans-unit id="569893ff6c39724a565a145b8a3ad3a0b9606463" translate="yes" xml:space="preserve">
          <source>You can adjust the ordering of a B-tree index by including the options &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; when creating the index; for example:</source>
          <target state="translated">インデックスの作成時にオプション &lt;code&gt;ASC&lt;/code&gt; 、 &lt;code&gt;DESC&lt;/code&gt; 、 &lt;code&gt;NULLS FIRST&lt;/code&gt; 、または &lt;code&gt;NULLS LAST&lt;/code&gt; を含めることにより、Bツリーインデックスの順序を調整できます。例えば：</target>
        </trans-unit>
        <trans-unit id="4b7d9d02889a217be36bf8f71750c721f9d62b3a" translate="yes" xml:space="preserve">
          <source>You can also control the order in which rows are processed by window functions using &lt;code&gt;ORDER BY&lt;/code&gt; within &lt;code&gt;OVER&lt;/code&gt;. (The window &lt;code&gt;ORDER BY&lt;/code&gt; does not even have to match the order in which the rows are output.) Here is an example:</source>
          <target state="translated">&lt;code&gt;OVER&lt;/code&gt; 内で &lt;code&gt;ORDER BY&lt;/code&gt; を使用して、ウィンドウ関数によって行が処理される順序を制御することもできます。（ウィンドウ &lt;code&gt;ORDER BY&lt;/code&gt; は、行が出力される順序と一致する必要さえありません。）次に例を示します。</target>
        </trans-unit>
        <trans-unit id="d8031e0a82c5477e58a31c17656bff548035b193" translate="yes" xml:space="preserve">
          <source>You can also create databases with other names. PostgreSQL allows you to create any number of databases at a given site. Database names must have an alphabetic first character and are limited to 63 bytes in length. A convenient choice is to create a database with the same name as your current user name. Many tools assume that database name as the default, so it can save you some typing. To create that database, simply type:</source>
          <target state="translated">他の名前でデータベースを作成することもできます。PostgreSQLでは、任意のサイトに任意の数のデータベースを作成することができます。データベース名はアルファベットの最初の文字でなければならず、長さは63バイトに制限されています。便利な選択は、現在のユーザ名と同じ名前でデータベースを作成することです。多くのツールはこのデータベース名をデフォルトとしているので、入力の手間が省けます。そのデータベースを作成するには、単に次のように入力します。</target>
        </trans-unit>
        <trans-unit id="2855332ddeec7909c633615734e0f09916910215" translate="yes" xml:space="preserve">
          <source>You can also define constraints on the column at the same time, using the usual syntax:</source>
          <target state="translated">また、通常の構文を使用して、列の制約を同時に定義することもできます。</target>
        </trans-unit>
        <trans-unit id="ee1e40e96d3d99c788ff89c86039beb4c7ae5ad3" translate="yes" xml:space="preserve">
          <source>You can also force the insertion of invalid numbers even when not in the weak mode, by appending the &lt;code&gt;!&lt;/code&gt; character at the end of the number.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; を追加することで、ウィークモードでない場合でも無効な数値を強制的に挿入することもできます。番号の終わりの文字。</target>
        </trans-unit>
        <trans-unit id="e92dd9f79aa93357545022991d035db8fa3c697a" translate="yes" xml:space="preserve">
          <source>You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:</source>
          <target state="translated">制約に別の名前を付けることもできます。これにより、エラーメッセージが明確になり、制約を変更する必要がある場合に制約を参照できるようになります。構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5c0e733bb8f77339cb0554d27f0faf1999d777b7" translate="yes" xml:space="preserve">
          <source>You can also nest filter expressions within each other:</source>
          <target state="translated">また、フィルタ式を互いに入れ子にすることもできます。</target>
        </trans-unit>
        <trans-unit id="540c7cc55f43958519f25aa973c9e5a2c6dcb66b" translate="yes" xml:space="preserve">
          <source>You can also search an array using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, which checks whether the left operand overlaps with the right operand. For instance:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子を使用して配列を検索することもできます。これは、左のオペランドが右のオペランドと重複するかどうかをチェックします。例えば：</target>
        </trans-unit>
        <trans-unit id="7317ad78770ade20f7fc205d1692cc3871b32860" translate="yes" xml:space="preserve">
          <source>You can also search for specific values in an array using the &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt; functions. The former returns the subscript of the first occurrence of a value in an array; the latter returns an array with the subscripts of all occurrences of the value in the array. For example:</source>
          <target state="translated">また、使用して、配列内の特定の値を検索することができ &lt;code&gt;array_position&lt;/code&gt; と &lt;code&gt;array_positions&lt;/code&gt; 機能を。前者は、配列内の最初の値の添え字を返します。後者は、配列内の値のすべての出現の添え字を持つ配列を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="72011efb5669336e4615ad697b69c64d57f8e812" translate="yes" xml:space="preserve">
          <source>You can also shorten the above command to:</source>
          <target state="translated">上記のコマンドを短くすることもできます。</target>
        </trans-unit>
        <trans-unit id="362c18912cf35df18fb18daa4743d6a04f75f78b" translate="yes" xml:space="preserve">
          <source>You can also write &lt;code&gt;all&lt;/code&gt; to match any IP address, &lt;code&gt;samehost&lt;/code&gt; to match any of the server's own IP addresses, or &lt;code&gt;samenet&lt;/code&gt; to match any address in any subnet that the server is directly connected to.</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; を書き込んで任意のIPアドレスと &lt;code&gt;samehost&lt;/code&gt; たり、samehostを書き込んでサーバーの任意のIPアドレスと一致させたり、 &lt;code&gt;samenet&lt;/code&gt; を書き込んでサーバーが直接接続されているサブネット内の任意のアドレスと一致させたりすることもできます。</target>
        </trans-unit>
        <trans-unit id="81719f677a0ec0af21aab7f90315c40b111bfbd1" translate="yes" xml:space="preserve">
          <source>You can also write the table name with a trailing &lt;code&gt;*&lt;/code&gt; to explicitly specify that descendant tables are included:</source>
          <target state="translated">末尾に &lt;code&gt;*&lt;/code&gt; を付けてテーブル名を記述して、子孫テーブルが含まれることを明示的に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="5703517ac040c492127e1fb49e5ced3da0debc99" translate="yes" xml:space="preserve">
          <source>You can ask for all fields of a composite value by writing &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">あなたは書き込むことによって、複合値のすべてのフィールドを求めることができます &lt;code&gt;.*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3fc07d5e0044a9e8829c097c35614fb4ad2ee919" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a foreign key constraint, in the usual way.</source>
          <target state="translated">通常の方法で、外部キー制約に自分の名前を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="78537f8a74bec7b625797355864a6e8b33eb27d6" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a unique constraint, in the usual way:</source>
          <target state="translated">固有の制約には、通常の方法で自分の名前を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="2e4029bdb8227766d867d39118fde7beadbd5eab" translate="yes" xml:space="preserve">
          <source>You can avoid always having to write out a &lt;code&gt;FROM&lt;/code&gt; clause to define the output columns, by setting up a custom crosstab function that has the desired output row type wired into its definition. This is described in the next section. Another possibility is to embed the required &lt;code&gt;FROM&lt;/code&gt; clause in a view definition.</source>
          <target state="translated">必要な出力行タイプを定義に配線したカスタムクロス集計関数を設定することにより、出力列を定義するために常に &lt;code&gt;FROM&lt;/code&gt; 句を書き出す必要を回避できます。これについては、次のセクションで説明します。別の可能性は、必要な &lt;code&gt;FROM&lt;/code&gt; 句をビュー定義に埋め込むことです。</target>
        </trans-unit>
        <trans-unit id="564b000e3befed57b182cb04e1dbb1e1574bf5b5" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas. Default privileges that are specified per-schema are added to whatever the global default privileges are for the particular object type.</source>
          <target state="translated">デフォルトの権限は、自分自身または自分がメンバーであるロールによって作成されるオブジェクトに対してのみ変更することができます。権限は、グローバルに(つまり、現在のデータベースに作成されたすべてのオブジェクトに対して)設定することも、指定されたスキーマに作成されたオブジェクトに対してのみ設定することもできます。スキーマごとに指定されたデフォルト権限は、特定のオブジェクトタイプのグローバルなデフォルト権限に追加されます。</target>
        </trans-unit>
        <trans-unit id="9ce7b82cbd1c40e5d5b3f5f38a6fd3d98a532714" translate="yes" xml:space="preserve">
          <source>You can combine these approaches by setting up logrotate to collect log files produced by PostgreSQL built-in logging collector. In this case, the logging collector defines the names and location of the log files, while logrotate periodically archives these files. When initiating log rotation, logrotate must ensure that the application sends further output to the new file. This is commonly done with a &lt;code&gt;postrotate&lt;/code&gt; script that sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the application, which then reopens the log file. In PostgreSQL, you can run &lt;code&gt;pg_ctl&lt;/code&gt; with the &lt;code&gt;logrotate&lt;/code&gt; option instead. When the server receives this command, the server either switches to a new log file or reopens the existing file, depending on the logging configuration (see &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;).</source>
          <target state="translated">これらのアプローチを組み合わせるには、PostgreSQLの組み込みロギングコレクターによって生成されたログファイルを収集するようにlogrotateを設定します。この場合、ログコレクターはログファイルの名前と場所を定義し、logrotateはこれらのファイルを定期的にアーカイブします。ログローテーションを開始する場合、logrotateは、アプリケーションが新しいファイルにさらに出力を送信するようにする必要があります。これは通常、アプリケーションに &lt;code&gt;SIGHUP&lt;/code&gt; シグナルを送信する &lt;code&gt;postrotate&lt;/code&gt; スクリプトで行われ、その後、ログファイルが再度開かれます。 PostgreSQLでは、代わりに &lt;code&gt;logrotate&lt;/code&gt; オプションを指定して &lt;code&gt;pg_ctl&lt;/code&gt; を実行できます。サーバーがこのコマンドを受信すると、サーバーは、ログの構成に応じて、新しいログファイルに切り替えるか、既存のファイルを再度開きます（「&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;セクション19.8.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5b0f94e4408c19791436a634fd6c150fbb5fd164" translate="yes" xml:space="preserve">
          <source>You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example:</source>
          <target state="translated">空の配列を作成することもできますが、型を持たない配列を持つことは不可能なので、空の配列を明示的に希望の型にキャストしなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="769ef112866ecb5c170f43630a2adb624d294a3a" translate="yes" xml:space="preserve">
          <source>You can convert an epoch value back to a time stamp with &lt;code&gt;to_timestamp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; でエポック値をタイムスタンプに戻すことができます：</target>
        </trans-unit>
        <trans-unit id="6ea1e38b69360026f2565a2133b9cc41f674fbe6" translate="yes" xml:space="preserve">
          <source>You can create a new table by specifying the table name, along with all column names and their types:</source>
          <target state="translated">すべてのカラム名とその種類とともにテーブル名を指定することで、新しいテーブルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="2293b489a80bd69ba669dbf459fa76acfff7a213" translate="yes" xml:space="preserve">
          <source>You can create a replication slot like this:</source>
          <target state="translated">このようにレプリケーションスロットを作成することができます。</target>
        </trans-unit>
        <trans-unit id="e3025b62033e69c38fff841b12fa1dec6f73605a" translate="yes" xml:space="preserve">
          <source>You can create predefined functions to avoid having to write out the result column names and types in each query. See the examples in the previous section. The underlying C function for this form of &lt;code&gt;crosstab&lt;/code&gt; is named &lt;code&gt;crosstab_hash&lt;/code&gt;.</source>
          <target state="translated">事前定義された関数を作成すると、各クエリで結果の列名と型を書き出す必要がなくなります。前のセクションの例を参照してください。この形式の &lt;code&gt;crosstab&lt;/code&gt; の基礎となるC関数の名前は &lt;code&gt;crosstab_hash&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="05fb579365a5f238d0a6df67c0b79ce59d0a29c6" translate="yes" xml:space="preserve">
          <source>You can create the illusion of an updatable view by defining &lt;code&gt;ON INSERT&lt;/code&gt;, &lt;code&gt;ON UPDATE&lt;/code&gt;, and &lt;code&gt;ON DELETE&lt;/code&gt; rules (or any subset of those that's sufficient for your purposes) to replace update actions on the view with appropriate updates on other tables. If you want to support &lt;code&gt;INSERT RETURNING&lt;/code&gt; and so on, then be sure to put a suitable &lt;code&gt;RETURNING&lt;/code&gt; clause into each of these rules.</source>
          <target state="translated">&lt;code&gt;ON INSERT&lt;/code&gt; 、 &lt;code&gt;ON UPDATE&lt;/code&gt; 、および &lt;code&gt;ON DELETE&lt;/code&gt; ルール（または目的に十分なサブセット）を定義して、ビューの更新アクションを他のテーブルの適切な更新に置き換えることで、更新可能なビューの錯覚を作成できます。 &lt;code&gt;INSERT RETURNING&lt;/code&gt; などをサポートする場合は、これらの各ルールに適切な &lt;code&gt;RETURNING&lt;/code&gt; 句を必ず追加してください。</target>
        </trans-unit>
        <trans-unit id="a0fd26f2da3bc0e528eb70dd91043a00be53f7e3" translate="yes" xml:space="preserve">
          <source>You can define a cast as an &lt;em&gt;I/O conversion cast&lt;/em&gt; by using the &lt;code&gt;WITH INOUT&lt;/code&gt; syntax. An I/O conversion cast is performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type. In many common cases, this feature avoids the need to write a separate cast function for conversion. An I/O conversion cast acts the same as a regular function-based cast; only the implementation is different.</source>
          <target state="translated">&lt;code&gt;WITH INOUT&lt;/code&gt; 構文を使用して、&lt;em&gt;キャストをI / O変換&lt;/em&gt;キャストとして定義できます。I / O変換キャストは、ソースデータ型の出力関数を呼び出し、結果の文字列をターゲットデータ型の入力関数に渡すことによって実行されます。多くの場合、この機能により、変換のために別個のキャスト関数を作成する必要がなくなります。I / O変換キャストは、通常の関数ベースのキャストと同じように機能します。実装のみが異なります。</target>
        </trans-unit>
        <trans-unit id="986b5339acb3c76e9d88ad629ad134c8af474edf" translate="yes" xml:space="preserve">
          <source>You can display tables in different ways by using the &lt;code&gt;\pset&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; コマンドを使用すると、さまざまな方法でテーブルを表示できます。</target>
        </trans-unit>
        <trans-unit id="16683852e12279f72c19abb8cc240108de7e38a2" translate="yes" xml:space="preserve">
          <source>You can do the same thing more verbosely with an explicitly named composite type:</source>
          <target state="translated">明示的に名前を付けた複合型を使えば、より冗長に同じことができます。</target>
        </trans-unit>
        <trans-unit id="647bf3e05906b80225fe1b4782288902652983a3" translate="yes" xml:space="preserve">
          <source>You can easily display index sizes, too:</source>
          <target state="translated">インデックスサイズも簡単に表示できます。</target>
        </trans-unit>
        <trans-unit id="a376faf67a062024c4f071a8c440875731b4314a" translate="yes" xml:space="preserve">
          <source>You can enter this into &lt;code&gt;psql&lt;/code&gt; with the line breaks. &lt;code&gt;psql&lt;/code&gt; will recognize that the command is not terminated until the semicolon.</source>
          <target state="translated">これを改行して &lt;code&gt;psql&lt;/code&gt; に入力できます。 &lt;code&gt;psql&lt;/code&gt; は、コマンドがセミコロンになるまで終了しないことを認識します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
