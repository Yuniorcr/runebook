<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="90c5a9e56ec693f6e6129ec5a5d9bccec6f61c69" translate="yes" xml:space="preserve">
          <source>As an example, if an &lt;code&gt;UPDATE&lt;/code&gt; is issued, then the &lt;code&gt;ALL&lt;/code&gt; policy will be applicable both to what the &lt;code&gt;UPDATE&lt;/code&gt; will be able to select as rows to be updated (applying the &lt;code&gt;USING&lt;/code&gt; expression), and to the resulting updated rows, to check if they are permitted to be added to the table (applying the &lt;code&gt;WITH CHECK&lt;/code&gt; expression, if defined, and the &lt;code&gt;USING&lt;/code&gt; expression otherwise). If an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command attempts to add rows to the table that do not pass the &lt;code&gt;ALL&lt;/code&gt; policy's &lt;code&gt;WITH CHECK&lt;/code&gt; expression, the entire command will be aborted.</source>
          <target state="translated">例として、 &lt;code&gt;UPDATE&lt;/code&gt; が発行された場合、 &lt;code&gt;ALL&lt;/code&gt; ポリシーは、 &lt;code&gt;UPDATE&lt;/code&gt; が更新する行として選択できるもの（ &lt;code&gt;USING&lt;/code&gt; 式を適用）と、結果の更新された行の両方に適用され、それらがテーブルへの追加が許可されます（定義されている場合は &lt;code&gt;WITH CHECK&lt;/code&gt; 式を適用し、定義されていない場合は &lt;code&gt;USING&lt;/code&gt; 式を適用します）。場合は &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; 通らないテーブルに行を追加するためのコマンドの試行 &lt;code&gt;ALL&lt;/code&gt; のポリシーの &lt;code&gt;WITH CHECK&lt;/code&gt; 式を、コマンド全体が中止されます。</target>
        </trans-unit>
        <trans-unit id="939804fcee1e20d77d25bd0bcffade6b732e6187" translate="yes" xml:space="preserve">
          <source>As an example, suppose that user &lt;code&gt;miriam&lt;/code&gt; creates table &lt;code&gt;mytable&lt;/code&gt; and does:</source>
          <target state="translated">例として、そのユーザーと仮定 &lt;code&gt;miriam&lt;/code&gt; テーブル作成 &lt;code&gt;mytable&lt;/code&gt; はをして行います。</target>
        </trans-unit>
        <trans-unit id="7dea5d7bb31aa71940b0966bc7e8fd7ee8f021dd" translate="yes" xml:space="preserve">
          <source>As an example, the full definition of the built-in TPC-B-like transaction is:</source>
          <target state="translated">一例として、組み込みのTPC-B的なトランザクションの完全な定義があります。</target>
        </trans-unit>
        <trans-unit id="cfc78f7c719c6f7419eadd4a007ca5004840837d" translate="yes" xml:space="preserve">
          <source>As an example, we can find the highest low-temperature reading anywhere with:</source>
          <target state="translated">例としては、どこにいても最高の低温読みを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">一例として。</target>
        </trans-unit>
        <trans-unit id="b50a75f7dfe3aa7965ef5d4e176cb3485c343ba0" translate="yes" xml:space="preserve">
          <source>As an extension to the SQL standard, PostgreSQL allows there to be just one escape-double-quote separator, in which case the third regular expression is taken as empty; or no separators, in which case the first and third regular expressions are taken as empty.</source>
          <target state="translated">標準SQLへの拡張として、PostgreSQLではエスケープダブルクォートセパレータを1つだけ持つことができます。</target>
        </trans-unit>
        <trans-unit id="fa9c14e462aa9732a24d51e00bd5d77bf7a81cc2" translate="yes" xml:space="preserve">
          <source>As another example, if one often does queries like:</source>
          <target state="translated">別の例として、1つが頻繁に次のようなクエリを実行する場合。</target>
        </trans-unit>
        <trans-unit id="a99c411c58f58d7e7474741b999e04e5e53fd82b" translate="yes" xml:space="preserve">
          <source>As before, however, PostgreSQL does not enforce the size restriction in any case.</source>
          <target state="translated">しかし、これまでと同様に、PostgreSQLはいかなる場合でもサイズ制限を実施しません。</target>
        </trans-unit>
        <trans-unit id="6c4c55629e9060b4cdfbd0fb1ea96b264210b4b6" translate="yes" xml:space="preserve">
          <source>As before, the estimated number of rows is just the product of this with the cardinality of &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">前と同様に、推定される行数は、これとカーディナリティ &lt;code&gt;tenk1&lt;/code&gt; の積にすぎません。</target>
        </trans-unit>
        <trans-unit id="7a87fbf380bd12f56579ba8b09d2dfca1e87a7aa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;, there are various situations in which subexpressions of an expression are evaluated at different times, so that the principle that &amp;ldquo;&lt;code&gt;CASE&lt;/code&gt; evaluates only necessary subexpressions&amp;rdquo; is not ironclad. For example a constant &lt;code&gt;1/0&lt;/code&gt; subexpression will usually result in a division-by-zero failure at planning time, even if it's within a &lt;code&gt;CASE&lt;/code&gt; arm that would never be entered at run time.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;セクション4.2.14&lt;/a&gt;で説明されているように、式の部分式がさまざまなタイミングで評価されるさまざまな状況があるため、「 &lt;code&gt;CASE&lt;/code&gt; は必要な部分式のみを評価する」という原則は根拠のないものです。たとえば、定数の &lt;code&gt;1/0&lt;/code&gt; 部分式は、実行時に入力されない &lt;code&gt;CASE&lt;/code&gt; アーム内にある場合でも、通常、計画時にゼロ除算の失敗を引き起こします。</target>
        </trans-unit>
        <trans-unit id="518e3cc29b2ad22029595abb39bdf434ee471900" translate="yes" xml:space="preserve">
          <source>As described in the previous section, transaction commit is normally &lt;em&gt;synchronous&lt;/em&gt;: the server waits for the transaction's WAL records to be flushed to permanent storage before returning a success indication to the client. The client is therefore guaranteed that a transaction reported to be committed will be preserved, even in the event of a server crash immediately after. However, for short transactions this delay is a major component of the total transaction time. Selecting asynchronous commit mode means that the server returns success as soon as the transaction is logically completed, before the WAL records it generated have actually made their way to disk. This can provide a significant boost in throughput for small transactions.</source>
          <target state="translated">前のセクションで説明したように、トランザクションコミットは通常&lt;em&gt;同期し&lt;/em&gt;ています。サーバーは、トランザクションのWALレコードが永続的なストレージにフラッシュされるのを待ってから、クライアントに成功を返します。したがって、クライアントは、直後にサーバーがクラッシュした場合でも、コミットされたと報告されたトランザクションが保持されることを保証します。ただし、短いトランザクションの場合、この遅延は合計トランザクション時間の主要なコンポーネントです。非同期コミットモードを選択すると、サーバーは、トランザクションが論理的に完了するとすぐに、サーバーが生成したWALレコードが実際にディスクに移動する前に成功を返します。これにより、小規模なトランザクションのスループットが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="64a53cc76e5b39051f25182477eec0422ea4a682" translate="yes" xml:space="preserve">
          <source>As explained above, it is possible to create indexes on partitioned tables and they are applied automatically to the entire hierarchy. This is very convenient, as not only the existing partitions will become indexed, but also any partitions that are created in the future will. One limitation is that it's not possible to use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; qualifier when creating such a partitioned index. To overcome long lock times, it is possible to use &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; the partitioned table; such an index is marked invalid, and the partitions do not get the index applied automatically. The indexes on partitions can be created separately using &lt;code&gt;CONCURRENTLY&lt;/code&gt;, and later &lt;em&gt;attached&lt;/em&gt; to the index on the parent using &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt;. Once indexes for all partitions are attached to the parent index, the parent index is marked valid automatically. Example:</source>
          <target state="translated">上記で説明したように、パーティション化されたテーブルにインデックスを作成することが可能で、それらは階層全体に自動的に適用されます。これは非常に便利です。既存のパーティションだけでなく、将来作成されるパーティションにもインデックスが作成されるからです。 1つの制限は、そのようなパーティション化されたインデックスを作成するときに &lt;code&gt;CONCURRENTLY&lt;/code&gt; 修飾子を使用できないことです。長いロック時間を克服するために、パーティション化されたテーブル &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; を使用することが可能です。このようなインデックスは無効とマークされ、パーティションにはインデックスが自動的に適用されません。パーティションのインデックスは、 &lt;code&gt;CONCURRENTLY&lt;/code&gt; を使用して個別に作成し、後で親のインデックスに&lt;em&gt;アタッチ&lt;/em&gt;できます。 &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt; 。すべてのパーティションのインデックスが親インデックスにアタッチされると、親インデックスは自動的に有効とマークされます。例：</target>
        </trans-unit>
        <trans-unit id="fb2dc582124a2fe2747429c6ba796f17d561c7c2" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;, the default privileges for any object type normally grant all grantable permissions to the object owner, and may grant some privileges to &lt;code&gt;PUBLIC&lt;/code&gt; as well. However, this behavior can be changed by altering the global default privileges with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;ddl-priv&quot;&gt;セクション5.7&lt;/a&gt;で説明したように、任意のオブジェクトタイプのデフォルトの権限は通常、付与可能なすべての権限をオブジェクトの所有者に付与し、一部の権限を &lt;code&gt;PUBLIC&lt;/code&gt; にも付与する場合があります。ただし、この動作は、 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; を使用してグローバルデフォルト権限を変更することで変更できます。</target>
        </trans-unit>
        <trans-unit id="7cfc29a245774c7f93be3cd482cd2720e2efb253" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt;, functional dependencies are very cheap and efficient type of statistics, but their main limitation is their global nature (only tracking dependencies at the column level, not between individual column values).</source>
          <target state="translated">&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;70.2.1項で&lt;/a&gt;説明したように、機能依存性は非常に安価で効率的な統計タイプですが、主な制限はグローバルな性質です（個々の列値間ではなく、列レベルでのみ依存性を追跡します）。</target>
        </trans-unit>
        <trans-unit id="c5ba1476be535d17f697ff078bc8840ec5998688" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, the planner can determine cardinality of &lt;code&gt;t&lt;/code&gt; using the number of pages and rows obtained from &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;planner-stats&quot;&gt;セクション14.2&lt;/a&gt;で説明したように、プランナは &lt;code&gt;pg_class&lt;/code&gt; から取得したページと行の数を使用して &lt;code&gt;t&lt;/code&gt; のカーディナリティを決定できます。</target>
        </trans-unit>
        <trans-unit id="149ce91ff7ffadae424c16cab2b4c0512100eae4" translate="yes" xml:space="preserve">
          <source>As in basic &lt;code&gt;tsquery&lt;/code&gt; input, weight(s) can be attached to each lexeme to restrict it to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes of those weight(s). For example:</source>
          <target state="translated">基本的な &lt;code&gt;tsquery&lt;/code&gt; 入力と同様に、各語彙素に重みを付けて、それらの重みの &lt;code&gt;tsvector&lt;/code&gt; 語彙素のみに一致するように制限できます。例えば：</target>
        </trans-unit>
        <trans-unit id="1c139aca10977b17d5102cc7674b71010f5c568f" translate="yes" xml:space="preserve">
          <source>As is standard in SQL, all functions return NULL, if any of the arguments are NULL. This may create security risks on careless usage.</source>
          <target state="translated">SQLでは標準的に、引数のいずれかがNULLの場合、すべての関数はNULLを返します。これは、不注意な使い方をするとセキュリティ上のリスクを生む可能性があります。</target>
        </trans-unit>
        <trans-unit id="585d0521870959cf15a89091a2347acd4003a598" translate="yes" xml:space="preserve">
          <source>As is typical of client/server applications, the client and the server can be on different hosts. In that case they communicate over a TCP/IP network connection. You should keep this in mind, because the files that can be accessed on a client machine might not be accessible (or might only be accessible using a different file name) on the database server machine.</source>
          <target state="translated">クライアント/サーバアプリケーションの典型的な例として、クライアントとサーバは異なるホスト上に存在することがあります。その場合、TCP/IP ネットワーク接続を介して通信します。クライアントマシン上でアクセスできるファイルは、データベースサーバーマシン上ではアクセスできないかもしれない(あるいは別のファイル名でしかアクセスできないかもしれない)ので、このことを念頭に置いておく必要があります。</target>
        </trans-unit>
        <trans-unit id="29fce103d97e5fc966f97584895b606dc9b97769" translate="yes" xml:space="preserve">
          <source>As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. If this value is specified without units, it is taken as megabytes. The default is 80 MB. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WALのディスク使用量がこの設定を下回っている限り、古いWALファイルは、削除されるのではなく、チェックポイントで将来使用するために常にリサイクルされます。これを使用して、たとえば大規模なバッチジョブを実行する場合など、WAL使用率の急上昇に対処するために十分なWALスペースを確保することができます。この値を単位なしで指定すると、メガバイトとして扱われます。デフォルトは80 MBです。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="935b68a13a63015aa5e693b61464b2a9c3100546" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, each (active) subscription receives changes from a replication slot on the remote (publishing) side. Normally, the remote replication slot is created automatically when the subscription is created using &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; and it is dropped automatically when the subscription is dropped using &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt;. In some situations, however, it can be useful or necessary to manipulate the subscription and the underlying replication slot separately. Here are some scenarios:</source>
          <target state="translated">前述のように、各（アクティブ）サブスクリプションは、リモート（パブリッシング）側のレプリケーションスロットから変更を受け取ります。通常、リモートレプリケーションスロットは、サブスクリプションが &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; を使用して作成されると自動的に作成され、サブスクリプションが &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; を使用して削除されると自動的に削除されます。ただし、状況によっては、サブスクリプションと基になるレプリケーションスロットを個別に操作することが役立つ場合や必要な場合があります。ここにいくつかのシナリオがあります：</target>
        </trans-unit>
        <trans-unit id="6d35d01797be09599719c5fbe0e98e1d8b777874" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;, Serializable transactions are just Repeatable Read transactions which add nonblocking monitoring for dangerous patterns of read/write conflicts. When a pattern is detected which could cause a cycle in the apparent order of execution, one of the transactions involved is rolled back to break the cycle.</source>
          <target state="translated">&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;セクション13.2.3&lt;/a&gt;で述べたように、シリアライズ可能なトランザクションは、読み取り/書き込みの競合の危険なパターンに対する非ブロッキング監視を追加する単なる反復可能な読み取りトランザクションです。見かけ上の実行順序でサイクルを引き起こす可能性のあるパターンが検出されると、関連するトランザクションの1つがロールバックされ、サイクルが中断されます。</target>
        </trans-unit>
        <trans-unit id="d7967f9ae1b2dfb5df2376dc5e14f007c840b5d2" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="translated">前述のように、TOASTポインターデータムには複数のタイプがあります。最も古く最も一般的なタイプは、TOASTポインターデータ自体が含まれている&lt;em&gt;テーブル&lt;/em&gt;とは別の、関連付けられている&lt;em&gt;TOASTテーブルに&lt;/em&gt;格納されている&lt;em&gt;行外&lt;/em&gt;データへのポインターです。これら&lt;em&gt;のディスク上の&lt;/em&gt;ポインターデータは、ディスクに格納するタプルが大きすぎてそのまま格納できない場合に、TOAST管理コード（ &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt; 内）によって作成されます。詳細は&lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;68.2.1項に記載されています&lt;/a&gt;。または、TOASTポインタデータムには、メモリ内の他の場所にある行外データへのポインタを含めることができます。このようなデータは有効期間が短く、ディスク上に表示されることはありませんが、大きなデータ値のコピーや冗長処理を回避するのに非常に役立ちます。詳細については、&lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;68.2.2項を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e83c3b33db2892f30f5c07aab1da708113577a83" translate="yes" xml:space="preserve">
          <source>As noted above, if the server crashes during the backup it may not be possible to restart until the &lt;code&gt;backup_label&lt;/code&gt; file has been manually deleted from the &lt;code&gt;PGDATA&lt;/code&gt; directory. Note that it is very important to never remove the &lt;code&gt;backup_label&lt;/code&gt; file when restoring a backup, because this will result in corruption. Confusion about when it is appropriate to remove this file is a common cause of data corruption when using this method; be very certain that you remove the file only on an existing master and never when building a standby or restoring a backup, even if you are building a standby that will subsequently be promoted to a new master.</source>
          <target state="translated">上記のように、バックアップ中にサーバーがクラッシュした場合、 &lt;code&gt;backup_label&lt;/code&gt; ファイルが &lt;code&gt;PGDATA&lt;/code&gt; ディレクトリから手動で削除されるまで再起動できない可能性があります。バックアップを復元するときは、 &lt;code&gt;backup_label&lt;/code&gt; する可能性があるため、決してbackup_labelファイルを削除しないことが非常に重要です。このファイルをいつ削除するのが適切かについての混乱は、この方法を使用する場合のデータ破損の一般的な原因です。後で新しいマスターに昇格するスタンバイを構築している場合でも、既存のマスターでのみファイルを削除し、スタンバイの構築時やバックアップの復元時には絶対に削除しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="b565015dcc8ef588510a75b03d00c798591daa60" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, &lt;code&gt;amvacuumcleanup&lt;/code&gt; will also be called at completion of an &lt;code&gt;ANALYZE&lt;/code&gt; operation. In this case &lt;code&gt;stats&lt;/code&gt; is always NULL and any return value will be ignored. This case can be distinguished by checking &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt;. It is recommended that the access method do nothing except post-insert cleanup in such a call, and that only in an autovacuum worker process.</source>
          <target state="translated">PostgreSQL 8.4以降、 &lt;code&gt;ANALYZE&lt;/code&gt; 操作の完了時に &lt;code&gt;amvacuumcleanup&lt;/code&gt; も呼び出されます。この場合、 &lt;code&gt;stats&lt;/code&gt; は常にNULLであり、戻り値は無視されます。このケースは、 &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt; をチェックすることで区別できます。このような呼び出しでは、アクセス方法が挿入後のクリーンアップ以外に何も行わず、自動バキュームワーカープロセスでのみ行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="41cf08ef1ae95fce9351d2775b5ca30eb5967a1b" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, this advice is less necessary since delayed indexing is used (see &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details). But for very large updates it may still be best to drop and recreate the index.</source>
          <target state="translated">PostgreSQL 8.4以降では、遅延インデックスが使用されるため、このアドバイスはあまり必要ありません（詳細については&lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;セクション66.4.1&lt;/a&gt;を参照）。ただし、非常に大きな更新の場合は、インデックスを削除して再作成するのが最善の方法です。</target>
        </trans-unit>
        <trans-unit id="fd60ea8bf7dbb2005dc3edad9e036817a4cf429d" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.0, &lt;code&gt;hstore&lt;/code&gt; uses a different internal representation than previous versions. This presents no obstacle for dump/restore upgrades since the text representation (used in the dump) is unchanged.</source>
          <target state="translated">PostgreSQL 9.0以降、 &lt;code&gt;hstore&lt;/code&gt; は以前のバージョンとは異なる内部表現を使用します。これは、ダンプで使用されるテキスト表現が変更されないため、ダンプ/復元アップグレードの障害にはなりません。</target>
        </trans-unit>
        <trans-unit id="280a05cda72f4f22e9db55fedf9a21987eec509c" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be installed with &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt; not &lt;code&gt;CREATE LANGUAGE&lt;/code&gt;. Direct use of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; should now be confined to extension installation scripts. If you have a &amp;ldquo;bare&amp;rdquo; language in your database, perhaps as a result of an upgrade, you can convert it to an extension using &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 9.1では、ほとんどの手続き型言語は「拡張機能」になっているため、 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; ではなくCREATE &lt;a href=&quot;sql-createextension&quot;&gt;EXTENSION&lt;/a&gt;でインストールする必要があります。 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; の直接使用は、拡張機能のインストールスクリプトに限定されるようになりました。データベースに「ベア」言語がある場合、おそらくアップグレードの結果として、 &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt; を使用して拡張に変換できます。</target>
        </trans-unit>
        <trans-unit id="ad6c1afacf960c00b0b43cc22652add17660a754" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be removed with &lt;a href=&quot;sql-dropextension&quot;&gt;DROP EXTENSION&lt;/a&gt; not &lt;code&gt;DROP LANGUAGE&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 9.1以降、ほとんどの手続き型言語は「拡張機能」になっているため、 &lt;code&gt;DROP LANGUAGE&lt;/code&gt; ではなくDROP &lt;a href=&quot;sql-dropextension&quot;&gt;EXTENSION&lt;/a&gt;で削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="9efc7bda1a790af9716120cc8586743f8662e379" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, null key values can be included in the index. Also, placeholder nulls are included in the index for indexed items that are null or contain no keys according to &lt;code&gt;extractValue&lt;/code&gt;. This allows searches that should find empty items to do so.</source>
          <target state="translated">PostgreSQL 9.1では、nullキー値をインデックスに含めることができます。また、プレースホルダーnullは、nullであるか、または &lt;code&gt;extractValue&lt;/code&gt; に従ってキーを含まないインデックス付きアイテムのインデックスに含まれます。これにより、空のアイテムを検索する必要がある検索が可能になります。</target>
        </trans-unit>
        <trans-unit id="41a7562cb3e64fe55b5aa379cb00b42fdb0e1138" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, you can attach a &lt;code&gt;COLLATE&lt;/code&gt; specification to &lt;code&gt;citext&lt;/code&gt; columns or data values. Currently, &lt;code&gt;citext&lt;/code&gt; operators will honor a non-default &lt;code&gt;COLLATE&lt;/code&gt; specification while comparing case-folded strings, but the initial folding to lower case is always done according to the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting (that is, as though &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; were given). This may be changed in a future release so that both steps follow the input &lt;code&gt;COLLATE&lt;/code&gt; specification.</source>
          <target state="translated">PostgreSQL 9.1以降では、 &lt;code&gt;COLLATE&lt;/code&gt; 仕様を &lt;code&gt;citext&lt;/code&gt; 列またはデータ値にアタッチできます。現在、 &lt;code&gt;citext&lt;/code&gt; 演算子は、大文字と小文字を区別した文字列を比較するときに、デフォルト以外の &lt;code&gt;COLLATE&lt;/code&gt; 仕様を受け入れますが、小文字への最初の折りたたみは、常にデータベースの &lt;code&gt;LC_CTYPE&lt;/code&gt; 設定に従って行われます（つまり、 &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; が指定されているかのように）。これは、両方のステップが入力 &lt;code&gt;COLLATE&lt;/code&gt; 仕様に従うように、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="df8c2a751dfbd5be0d7c157dabee58d14e6c8985" translate="yes" xml:space="preserve">
          <source>As previously stated, when a JSON value is input and then printed without any additional processing, &lt;code&gt;json&lt;/code&gt; outputs the same text that was input, while &lt;code&gt;jsonb&lt;/code&gt; does not preserve semantically-insignificant details such as whitespace. For example, note the differences here:</source>
          <target state="translated">前述のように、JSON値が入力され、追加の処理なしで印刷されると、 &lt;code&gt;json&lt;/code&gt; は入力されたものと同じテキストを出力しますが、 &lt;code&gt;jsonb&lt;/code&gt; は空白などの意味的に重要ではない詳細を保持しません。たとえば、ここの違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="1442483656b1d2da488c86cbbe647b9c3925f511" translate="yes" xml:space="preserve">
          <source>As seen in the second example, the element name can be omitted if the content value is a column reference, in which case the column name is used by default. Otherwise, a name must be specified.</source>
          <target state="translated">2番目の例で見られるように、コンテンツ値がカラム参照である場合は、要素名を省略することができ、その場合はデフォルトでカラム名が使用されます。それ以外の場合は、名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fbfde401bab7c53809229a3d8a380b7c73d7b56a" translate="yes" xml:space="preserve">
          <source>As seen in this example, when the query is an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command, the actual work of applying the table changes is done by a top-level Insert, Update, or Delete plan node. The plan nodes underneath this node perform the work of locating the old rows and/or computing the new data. So above, we see the same sort of bitmap table scan we've seen already, and its output is fed to an Update node that stores the updated rows. It's worth noting that although the data-modifying node can take a considerable amount of run time (here, it's consuming the lion's share of the time), the planner does not currently add anything to the cost estimates to account for that work. That's because the work to be done is the same for every correct query plan, so it doesn't affect planning decisions.</source>
          <target state="translated">この例でわかるように、クエリが &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; の場合コマンド、テーブルの変更を適用する実際の作業は、トップレベルの挿入、更新、または削除の計画ノードによって行われます。このノードの下にある計画ノードは、古い行を見つけたり、新しいデータを計算したりする作業を実行します。上記のように、すでに見たのと同じ種類のビットマップテーブルスキャンがあり、その出力は更新された行を格納するUpdateノードに送られます。データ変更ノードはかなりの実行時間を要する可能性がありますが（ここでは、時間の大部分を消費しています）、プランナーは現在、その作業を説明するためにコスト見積もりに何も追加していません。これは、実行する作業がすべての正しいクエリプランで同じであるため、計画の決定に影響を与えないためです。</target>
        </trans-unit>
        <trans-unit id="299b9141677294c0e2aa3b93c3483b8a98e2f995" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;code&gt;union&lt;/code&gt; function's first &lt;code&gt;internal&lt;/code&gt; argument is actually a &lt;code&gt;GistEntryVector&lt;/code&gt; pointer. The second argument is a pointer to an integer variable, which can be ignored. (It used to be required that the &lt;code&gt;union&lt;/code&gt; function store the size of its result value into that variable, but this is no longer necessary.)</source>
          <target state="translated">上記のように、 &lt;code&gt;union&lt;/code&gt; 関数の最初の &lt;code&gt;internal&lt;/code&gt; 引数は、実際には &lt;code&gt;GistEntryVector&lt;/code&gt; ポインターです。2番目の引数は整数変数へのポインターであり、無視できます。（以前は、 &lt;code&gt;union&lt;/code&gt; 関数がその結果値のサイズをその変数に格納する必要がありましたが、これはもう必要ありません。）</target>
        </trans-unit>
        <trans-unit id="e49718fcf44bf904fec83a97285f69086516abb8" translate="yes" xml:space="preserve">
          <source>As shown here, the &lt;code&gt;rank&lt;/code&gt; function produces a numerical rank for each distinct &lt;code&gt;ORDER BY&lt;/code&gt; value in the current row's partition, using the order defined by the &lt;code&gt;ORDER BY&lt;/code&gt; clause. &lt;code&gt;rank&lt;/code&gt; needs no explicit parameter, because its behavior is entirely determined by the &lt;code&gt;OVER&lt;/code&gt; clause.</source>
          <target state="translated">ここに示すように、 &lt;code&gt;rank&lt;/code&gt; 関数は、 &lt;code&gt;ORDER BY&lt;/code&gt; 句で定義された順序を使用して、現在の行のパーティション内の各 &lt;code&gt;ORDER BY&lt;/code&gt; 値の数値ランクを生成します。 &lt;code&gt;rank&lt;/code&gt; の動作は &lt;code&gt;OVER&lt;/code&gt; 句によって完全に決定されるため、rankには明示的なパラメータは必要ありません。</target>
        </trans-unit>
        <trans-unit id="7278da1d6766bb19352b261eabd292dd18fce4c5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.2&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;表37.2&lt;/a&gt;に示すように、btree演算子クラスは、5つの比較演算子 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; を提供する必要があります。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; も演算子クラスの一部である必要があると思われるかもしれませんが、そうではありません。インデックス検索で &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE句を使用することはほとんど役に立ちません。 （いくつかの目的のために、プランナは &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; をbtree演算子クラスに関連付けられているものとして扱いますが、 &lt;code&gt;pg_amop&lt;/code&gt; からではなく &lt;code&gt;=&lt;/code&gt; 演算子の否定子リンクを介してその演算子を見つけます。）</target>
        </trans-unit>
        <trans-unit id="2b7658bd4634c80bfa02d903fd89d9f89cfdf0c3" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.8&lt;/a&gt;, btree defines one required and two optional support functions.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;表37.8&lt;/a&gt;に示すように、btreeは1つの必須サポート関数と2つのオプションサポート関数を定義します。</target>
        </trans-unit>
        <trans-unit id="01827ef18402ec5bd4e9a302a910b59d06b2ca2b" translate="yes" xml:space="preserve">
          <source>As shown in the previous section, the table expression in the &lt;code&gt;SELECT&lt;/code&gt; command constructs an intermediate virtual table by possibly combining tables, views, eliminating rows, grouping, etc. This table is finally passed on to processing by the &lt;em&gt;select list&lt;/em&gt;. The select list determines which &lt;em&gt;columns&lt;/em&gt; of the intermediate table are actually output.</source>
          <target state="translated">前のセクションで示したように、 &lt;code&gt;SELECT&lt;/code&gt; コマンドのテーブル式は、テーブル、ビュー、行の削除、グループ化などを組み合わせて中間仮想テーブルを作成します。このテーブルは、最終的に&lt;em&gt;選択リスト&lt;/em&gt;による処理に渡され&lt;em&gt;ます&lt;/em&gt;。選択リストは、中間テーブルのどの&lt;em&gt;列&lt;/em&gt;が実際に出力されるかを決定し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a1a6ed6a1882593d5ac926bd03fffe04913abef7" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing a composite value you can write double quotes around any individual field value. You &lt;em&gt;must&lt;/em&gt; do so if the field value would otherwise confuse the composite-value parser. In particular, fields containing parentheses, commas, double quotes, or backslashes must be double-quoted. To put a double quote or backslash in a quoted composite field value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted field value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as composite syntax.</source>
          <target state="translated">前に示したように、複合値を書き込むときは、個々のフィールド値を二重引用符で囲むことができます。フィールド値によって複合値パーサーが混乱する場合は、そうする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。特に、括弧、コンマ、二重引用符、またはバックスラッシュを含むフィールドは二重引用符で囲む必要があります。二重引用符またはバックスラッシュを引用符付きの複合フィールド値に含めるには、その前にバックスラッシュを付けます。 （また、二重引用符で囲まれたフィールド値内の二重引用符のペアは、SQLリテラル文字列の単一引用符のルールと同様に、二重引用符文字を表すために使用されます。）または、引用符を避け、バックスラッシュエスケープを使用して保護することもできますそうでなければ複合構文として解釈されるすべてのデータ文字。</target>
        </trans-unit>
        <trans-unit id="bf6c49e3bf726dc38d17652f47395db71e4e4fbd" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing an array value you can use double quotes around any individual array element. You &lt;em&gt;must&lt;/em&gt; do so if the element value would otherwise confuse the array-value parser. For example, elements containing curly braces, commas (or the data type's delimiter character), double quotes, backslashes, or leading or trailing whitespace must be double-quoted. Empty strings and strings matching the word &lt;code&gt;NULL&lt;/code&gt; must be quoted, too. To put a double quote or backslash in a quoted array element value, precede it with a backslash. Alternatively, you can avoid quotes and use backslash-escaping to protect all data characters that would otherwise be taken as array syntax.</source>
          <target state="translated">前に示したように、配列値を書き込むときは、個々の配列要素を二重引用符で囲むことができます。要素値が配列値パーサーを混乱させる場合は、そうする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。たとえば、中括弧、コンマ（またはデータ型の区切り文字）、二重引用符、バックスラッシュ、または先頭または末尾の空白を含む要素は、二重引用符で囲む必要があります。空の文字列および &lt;code&gt;NULL&lt;/code&gt; という単語に一致する文字列も引用符で囲む必要があります。引用符で囲まれた配列要素の値に二重引用符またはバックスラッシュを入れるには、その前にバックスラッシュを付けます。または、引用符を避け、バックスラッシュエスケープを使用して、配列構文として使用されるすべてのデータ文字を保護することもできます。</target>
        </trans-unit>
        <trans-unit id="8a1775eb12b1097993052bc9db7c32cd0419a0ce" translate="yes" xml:space="preserve">
          <source>As shown, an array data type is named by appending square brackets (&lt;code&gt;[]&lt;/code&gt;) to the data type name of the array elements. The above command will create a table named &lt;code&gt;sal_emp&lt;/code&gt; with a column of type &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;name&lt;/code&gt;), a one-dimensional array of type &lt;code&gt;integer&lt;/code&gt; (&lt;code&gt;pay_by_quarter&lt;/code&gt;), which represents the employee's salary by quarter, and a two-dimensional array of &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;schedule&lt;/code&gt;), which represents the employee's weekly schedule.</source>
          <target state="translated">示されているように、配列データ型は、配列要素のデータ型名に角括弧（ &lt;code&gt;[]&lt;/code&gt; ）を追加することによって名前が付けられます。上記コマンドは、指定したテーブルが作成されます &lt;code&gt;sal_emp&lt;/code&gt; 型のカラムを持つ &lt;code&gt;text&lt;/code&gt; （ &lt;code&gt;name&lt;/code&gt; ）、型の一次元アレイ &lt;code&gt;integer&lt;/code&gt; （ &lt;code&gt;pay_by_quarter&lt;/code&gt; 四半期によって従業員の給与を表す）、及び二次元アレイ &lt;code&gt;text&lt;/code&gt; （ &lt;code&gt;schedule&lt;/code&gt; ） 、従業員の週次スケジュールを表します。</target>
        </trans-unit>
        <trans-unit id="e0b46ae37bd20da5e49ea599dd897a3ac9299776" translate="yes" xml:space="preserve">
          <source>As the above example suggests, a &lt;code&gt;tsquery&lt;/code&gt; is not just raw text, any more than a &lt;code&gt;tsvector&lt;/code&gt; is. A &lt;code&gt;tsquery&lt;/code&gt; contains search terms, which must be already-normalized lexemes, and may combine multiple terms using AND, OR, NOT, and FOLLOWED BY operators. (For syntax details see &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;Section 8.11.2&lt;/a&gt;.) There are functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, and &lt;code&gt;phraseto_tsquery&lt;/code&gt; that are helpful in converting user-written text into a proper &lt;code&gt;tsquery&lt;/code&gt;, primarily by normalizing words appearing in the text. Similarly, &lt;code&gt;to_tsvector&lt;/code&gt; is used to parse and normalize a document string. So in practice a text search match would look more like this:</source>
          <target state="translated">上記の例が示唆しているように、 &lt;code&gt;tsquery&lt;/code&gt; は &lt;code&gt;tsvector&lt;/code&gt; 以外の単なる生のテキストではありません。 &lt;code&gt;tsquery&lt;/code&gt; は既に正規化された語彙素でなければならない検索用語を、含まれており、使用して複数の条件を組み合わせることができるAND、OR、NOT、および演算子が続きます。（構文の詳細については、&lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;セクション8.11.2を&lt;/a&gt;参照してください。）ユーザーが作成したテキストを適切な &lt;code&gt;tsquery&lt;/code&gt; に変換するのに役立つ関数 &lt;code&gt;to_tsquery&lt;/code&gt; 、 &lt;code&gt;plainto_tsquery&lt;/code&gt; 、および &lt;code&gt;phraseto_tsquery&lt;/code&gt; があります。同様に、 &lt;code&gt;to_tsvector&lt;/code&gt; ドキュメント文字列を解析して正規化するために使用されます。したがって、実際にはテキスト検索の一致は次のようになります。</target>
        </trans-unit>
        <trans-unit id="6b22935fd06acdc1c0f8d1431b124c6c0f7b088d" translate="yes" xml:space="preserve">
          <source>As the last example demonstrates, the regexp split functions ignore zero-length matches that occur at the start or end of the string or immediately after a previous match. This is contrary to the strict definition of regexp matching that is implemented by &lt;code&gt;regexp_match&lt;/code&gt; and &lt;code&gt;regexp_matches&lt;/code&gt;, but is usually the most convenient behavior in practice. Other software systems such as Perl use similar definitions.</source>
          <target state="translated">最後の例が示すように、regexp分割関数は、文字列の先頭または末尾、または直前の一致の直後に発生する長さゼロの一致を無視します。これは、 &lt;code&gt;regexp_match&lt;/code&gt; および &lt;code&gt;regexp_matches&lt;/code&gt; によって実装されるregexpマッチングの厳密な定義とは逆ですが、通常、実際には最も便利な動作です。 Perlなどの他のソフトウェアシステムも同様の定義を使用します。</target>
        </trans-unit>
        <trans-unit id="0378825838c0e066e87e6d5b0be89bee2dd5620d" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;IN&lt;/code&gt; is null.</source>
          <target state="translated">通常どおり、行のnull値はSQLブール式の通常の規則に従って結合されます。 2つの行は、対応するすべてのメンバーがnullでなく等しい場合、等しいと見なされます。対応するメンバーがnullでなく、等しくない場合、行は等しくありません。そうでない場合、その行比較の結果は不明です（null）。すべての行ごとの結果が等しくないかnullであり、少なくとも1つのnullがある場合、 &lt;code&gt;IN&lt;/code&gt; の結果はnullになります。</target>
        </trans-unit>
        <trans-unit id="0b8508c03666af11ade2c1725a303ade508dcc57" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;NOT IN&lt;/code&gt; is null.</source>
          <target state="translated">通常どおり、行のnull値はSQLブール式の通常の規則に従って結合されます。2つの行は、対応するすべてのメンバーがnullでなく、等しい場合に等しいと見なされます。対応するメンバーがnullでなく、等しくない場合、行は等しくありません。そうでない場合、その行比較の結果は不明です（null）。すべての行ごとの結果が等しくないかnullであり、少なくとも1つのnullがある場合、 &lt;code&gt;NOT IN&lt;/code&gt; の結果はnullになります。</target>
        </trans-unit>
        <trans-unit id="00f8ed65d004834d267f75de424eb5e9aec68c8b" translate="yes" xml:space="preserve">
          <source>As visible here, JIT was used, but inlining and expensive optimization were not. If &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; were also lowered, that would change.</source>
          <target state="translated">ここに示されているように、JITが使用されましたが、インライン化と高価な最適化は使用されませんでした。場合&lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;または&lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_costを&lt;/a&gt;も低下させ、それが変化するであろう。</target>
        </trans-unit>
        <trans-unit id="e991d7170113bfec3a30551fcd7b4c1810192115" translate="yes" xml:space="preserve">
          <source>As we can see, a complex table hierarchy could require a substantial amount of DDL. In the above example we would be creating a new child table each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">ご覧のように、複雑なテーブル階層はかなりの量のDDLを必要とします。上記の例では、毎月新しい子テーブルを作成しているので、必要なDDLを自動的に生成するスクリプトを書くのが賢明かもしれません。</target>
        </trans-unit>
        <trans-unit id="13f137c0044f99ee6629a214a80858091639b3df" translate="yes" xml:space="preserve">
          <source>As we saw in the previous section, the query planner needs to estimate the number of rows retrieved by a query in order to make good choices of query plans. This section provides a quick look at the statistics that the system uses for these estimates.</source>
          <target state="translated">前のセクションで見たように、クエリプランナはクエリプランを適切に選択するために、クエリによって取得された行数を推定する必要があります。このセクションでは、システムがこれらの推定に使用する統計情報について簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="e28715fe2eadf5afacb168abae8c272e3eef5af1" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;EXISTS&lt;/code&gt;, it's unwise to assume that the subquery will be evaluated completely.</source>
          <target state="translated">&lt;code&gt;EXISTS&lt;/code&gt; と同様に、サブクエリが完全に評価されると想定することは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="181bd891b583b10919f382d152707212af1347e4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters; or a different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;.</source>
          <target state="translated">同じように &lt;code&gt;LIKE&lt;/code&gt; 、バックスラッシュは、これらのメタ文字のいずれかの特別な意味を無効にします。または、別のエスケープ文字を &lt;code&gt;ESCAPE&lt;/code&gt; で指定できます。</target>
        </trans-unit>
        <trans-unit id="8c360e616acbe7a6ddce202d4edfd50d452f4ba5" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;SIMILAR TO&lt;/code&gt;, the specified pattern must match the entire data string, or else the function fails and returns null. To indicate the part of the pattern for which the matching data sub-string is of interest, the pattern should contain two occurrences of the escape character followed by a double quote (&lt;code&gt;&quot;&lt;/code&gt;). The text matching the portion of the pattern between these separators is returned when the match is successful.</source>
          <target state="translated">同様に &lt;code&gt;SIMILAR TO&lt;/code&gt; 、指定されたパターンがデータ文字列全体と一致している必要があり、さもなければ関数はnullを失敗し、返します。一致するデータのサブストリングが関係するパターンの部分を示すために、パターンにはエスケープ文字が2回出現し、その後に二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）が続く必要があります。これらの区切り文字の間のパターンの部分に一致するテキストは、マッチが成功したときに返されます。</target>
        </trans-unit>
        <trans-unit id="2f915404c792b4b375081401e8be4799b6fdf5c9" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;pgstattuple&lt;/code&gt;, the results are accumulated page-by-page, and should not be expected to represent an instantaneous snapshot of the whole index.</source>
          <target state="translated">&lt;code&gt;pgstattuple&lt;/code&gt; の場合と同様に、結果はページごとに蓄積され、インデックス全体の瞬間的なスナップショットを表すとは期待できません。</target>
        </trans-unit>
        <trans-unit id="fd70faee0fe9a1b62ee5a071b1f7e464081b1189" translate="yes" xml:space="preserve">
          <source>As with any security settings, it's important to test and ensure that the system is behaving as expected. Using the example above, this demonstrates that the permission system is working properly.</source>
          <target state="translated">他のセキュリティ設定と同様に、システムが期待通りに動作していることをテストして確認することが重要です。上記の例を使用して、これはパーミッションシステムが正しく動作していることを示しています。</target>
        </trans-unit>
        <trans-unit id="5f9153f6ce7772c623a80d637e2a8064efd48ff4" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) It is not advisable to install executables owned by this user because compromised systems could then modify their own binaries.</source>
          <target state="translated">外部からアクセスできるサーバーデーモンと同様に、PostgreSQLは別のユーザーアカウントで実行することをお勧めします。このユーザーアカウントは、サーバーによって管理されるデータのみを所有する必要があり、他のデーモンと共有しないでください。（たとえば、ユーザー &lt;code&gt;nobody&lt;/code&gt; を使用することは悪い考えです。）侵害されたシステムが独自のバイナリを変更する可能性があるため、このユーザーが所有する実行可能ファイルをインストールすることはお勧めできません。</target>
        </trans-unit>
        <trans-unit id="c718a2b52c9e3b6c8aed088c8f0e6614024fc446" translate="yes" xml:space="preserve">
          <source>As with base backups, the easiest way to produce a standalone hot backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. If you include the &lt;code&gt;-X&lt;/code&gt; parameter when calling it, all the write-ahead log required to use the backup will be included in the backup automatically, and no special action is required to restore the backup.</source>
          <target state="translated">ベースバックアップと同様に、スタンドアロンのホットバックアップを作成する最も簡単な方法は、&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;ツールを使用することです。呼び出し時に &lt;code&gt;-X&lt;/code&gt; パラメーターを含めると、バックアップを使用するために必要なすべての先行書き込みログが自動的にバックアップに含まれ、バックアップを復元するための特別なアクションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="478aba2ebcc8faa95902624459b6a85534e22480" translate="yes" xml:space="preserve">
          <source>As with dropping a column, you need to add &lt;code&gt;CASCADE&lt;/code&gt; if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s).</source>
          <target state="translated">列の削除と同様に、何かが依存している制約を削除する場合は、 &lt;code&gt;CASCADE&lt;/code&gt; を追加する必要があります。たとえば、外部キー制約は、参照される列の一意または主キー制約に依存します。</target>
        </trans-unit>
        <trans-unit id="f3f0c2f615e83e516256da21365a0381f69d219d" translate="yes" xml:space="preserve">
          <source>As with other PostgreSQL text search configuration files, the rules file must be stored in UTF-8 encoding. The data is automatically translated into the current database's encoding when loaded. Any lines containing untranslatable characters are silently ignored, so that rules files can contain rules that are not applicable in the current encoding.</source>
          <target state="translated">他のPostgreSQLテキスト検索設定ファイルと同様に、ルールファイルはUTF-8エンコーディングで格納されている必要があります。データはロード時に現在のデータベースのエンコーディングに自動的に翻訳されます。翻訳不可能な文字を含む行は静かに無視されますので、ルールファイルには現在のエンコーディングでは適用できないルールを含めることができます。</target>
        </trans-unit>
        <trans-unit id="10502eec64e33ad71eb02c8495b055a53abfa416" translate="yes" xml:space="preserve">
          <source>As with the plain file-system-backup technique, this method can only support restoration of an entire database cluster, not a subset. Also, it requires a lot of archival storage: the base backup might be bulky, and a busy system will generate many megabytes of WAL traffic that have to be archived. Still, it is the preferred backup technique in many situations where high reliability is needed.</source>
          <target state="translated">通常のファイルシステムバックアップ技術と同様に、この方法はデータベースクラスタ全体の復元のみをサポートし、サブセットはサポートしません。また、多くのアーカイブストレージを必要とします。ベースバックアップはかさばるかもしれませんし、忙しいシステムでは、アーカイブされなければならない多くのメガバイトのWALトラフィックが発生します。それでも、高い信頼性が必要とされる多くの状況では、これが好ましいバックアップ手法です。</target>
        </trans-unit>
        <trans-unit id="41912914d23f57d6b4964446c4839bcd6bf6e2ec" translate="yes" xml:space="preserve">
          <source>As with vacuuming for space recovery, frequent updates of statistics are more useful for heavily-updated tables than for seldom-updated ones. But even for a heavily-updated table, there might be no need for statistics updates if the statistical distribution of the data is not changing much. A simple rule of thumb is to think about how much the minimum and maximum values of the columns in the table change. For example, a &lt;code&gt;timestamp&lt;/code&gt; column that contains the time of row update will have a constantly-increasing maximum value as rows are added and updated; such a column will probably need more frequent statistics updates than, say, a column containing URLs for pages accessed on a website. The URL column might receive changes just as often, but the statistical distribution of its values probably changes relatively slowly.</source>
          <target state="translated">スペース回復のためのバキューム処理と同様に、統計の頻繁な更新は、頻繁に更新されるテーブルよりも、頻繁に更新されるテーブルの方が役立ちます。ただし、頻繁に更新されるテーブルであっても、データの統計的分布があまり変化しない場合は、統計を更新する必要がない場合があります。簡単な経験則は、テーブルの列の最小値と最大値がどれだけ変化するかを考えることです。たとえば、 &lt;code&gt;timestamp&lt;/code&gt; 行の更新時刻を含む列には、行が追加および更新されるにつれて、最大値が常に増加します。このような列は、たとえば、WebサイトでアクセスされたページのURLを含む列よりも頻繁に統計を更新する必要があります。URL列は同じくらい頻繁に変更を受け取る可能性がありますが、その値の統計的分布はおそらく比較的ゆっくりと変化します。</target>
        </trans-unit>
        <trans-unit id="25d8d489832d7110fbb67ed9e2a0a908cb5a5e5d" translate="yes" xml:space="preserve">
          <source>As you can see, in this skeleton we're dealing with a data type where &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt;. It's easy enough to support data types where this is not the case, by implementing the proper union algorithm in this GiST support method.</source>
          <target state="translated">ご覧のとおり、このスケルトンでは、 &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt; であるデータ型を扱っています。このGiSTサポートメソッドに適切なユニオンアルゴリズムを実装することで、そうでない場合でもデータ型をサポートするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="bf9aec8aa0de7661a07d98a75f47c3b69757e7a1" translate="yes" xml:space="preserve">
          <source>As you see, pg_dump writes its result to the standard output. We will see below how this can be useful. While the above command creates a text file, pg_dump can create files in other formats that allow for parallelism and more fine-grained control of object restoration.</source>
          <target state="translated">ご覧のように、pg_dumpはその結果を標準出力に書き込みます。これがどのように有用であるかを後述します。上記のコマンドはテキストファイルを作成しますが、pg_dumpは他の形式でファイルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="21e1923806603d461ddac0e0413cc2a388550aac" translate="yes" xml:space="preserve">
          <source>As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word &lt;code&gt;CHECK&lt;/code&gt; followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense.</source>
          <target state="translated">ご覧のとおり、制約の定義は、デフォルト値の定義と同様に、データ型の後にあります。デフォルト値と制約は任意の順序でリストできます。チェック制約は、キーワード &lt;code&gt;CHECK&lt;/code&gt; とそれに続く括弧内の式で構成されます。チェック制約式は、このように制約された列を含む必要があります。そうでない場合、制約はあまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="d1b9d2baec69327019075ccf63fb47f3a04b6635" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="translated">ご覧のとおり、新しい値の式は行の既存の値を参照できます。 &lt;code&gt;WHERE&lt;/code&gt; 句も省略しました。省略した場合、テーブルのすべての行が更新されます。存在する場合、 &lt;code&gt;WHERE&lt;/code&gt; 条件に一致する行のみが更新されます。 &lt;code&gt;SET&lt;/code&gt; 句の等号は代入であり、 &lt;code&gt;WHERE&lt;/code&gt; 句の等号は比較ですが、これによって曖昧さが生じることはありません。もちろん、 &lt;code&gt;WHERE&lt;/code&gt; 条件は等価テストである必要はありません。他の多くの演算子が利用可能です（&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章を&lt;/a&gt;参照）。ただし、式はブール結果に評価される必要があります。</target>
        </trans-unit>
        <trans-unit id="313a697ffb23a7210631919b2999246578e93b67" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they are designed not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt;. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.) This applies to the following commands:</source>
          <target state="translated">それらがあれば、すべてのWALを書き込みしないように設計されているので別にWALデータを処理するアーカイバまたはWAL送信者のための時間を避けてから、これを実行すると、実際に、より高速な特定のコマンドを行います &lt;code&gt;wal_level&lt;/code&gt; がある &lt;code&gt;minimal&lt;/code&gt; 。（WALを記述するよりも、最後に &lt;code&gt;fsync&lt;/code&gt; を実行する方が、より安全にクラッシュの安全性を保証できます。）これは、次のコマンドに適用されます。</target>
        </trans-unit>
        <trans-unit id="ba62da50a0cd807fd06ac3427894951fdffc554f" translate="yes" xml:space="preserve">
          <source>Aside from preventing cycles, the array value is often useful in its own right as representing the &amp;ldquo;path&amp;rdquo; taken to reach any particular row.</source>
          <target state="translated">サイクルの防止とは別に、配列値は、特定の行に到達するために取られる「パス」を表すために、それ自体でしばしば有用です。</target>
        </trans-unit>
        <trans-unit id="f08bd4c872560fdf37016b1456326d2f1f83a30c" translate="yes" xml:space="preserve">
          <source>Aside from the index's own internal consistency requirements, concurrent updates create issues about consistency between the parent table (the &lt;em&gt;heap&lt;/em&gt;) and the index. Because PostgreSQL separates accesses and updates of the heap from those of the index, there are windows in which the index might be inconsistent with the heap. We handle this problem with the following rules:</source>
          <target state="translated">インデックス自体の内部整合性要件とは別に、同時更新では、親テーブル（&lt;em&gt;ヒープ&lt;/em&gt;）とインデックス間の整合性に関する問題が発生します。PostgreSQLはヒープのアクセスと更新をインデックスのアクセスと更新から分離しているため、インデックスがヒープと一致しない可能性があるウィンドウがあります。この問題は次のルールで処理します。</target>
        </trans-unit>
        <trans-unit id="66acedea6ec5e6c71ffc128f764e1116af5e0326" translate="yes" xml:space="preserve">
          <source>Assign a literal constant default value for the column &lt;code&gt;name&lt;/code&gt;, arrange for the default value of column &lt;code&gt;did&lt;/code&gt; to be generated by selecting the next value of a sequence object, and make the default value of &lt;code&gt;modtime&lt;/code&gt; be the time at which the row is inserted:</source>
          <target state="translated">列リテラル定数のデフォルト値割り当てる &lt;code&gt;name&lt;/code&gt; 、カラムのデフォルト値が手配 &lt;code&gt;did&lt;/code&gt; シーケンス・オブジェクトの次の値を選択することによって生成される、とのデフォルト値作る &lt;code&gt;modtime&lt;/code&gt; 行が挿入された時刻です。</target>
        </trans-unit>
        <trans-unit id="f079970016568a6988faea4629841a26d4520b05" translate="yes" xml:space="preserve">
          <source>Associated sort operator (zero if none)</source>
          <target state="translated">関連ソート演算子(ない場合はゼロ</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="d530f867f7438d52f3d933c2185ee58e5795fb55" translate="yes" xml:space="preserve">
          <source>Assume a table like this:</source>
          <target state="translated">このようなテーブルを想定します。</target>
        </trans-unit>
        <trans-unit id="d62cfe7fee7bb0995d8fe897df02204b5ae94b18" translate="yes" xml:space="preserve">
          <source>Assume we have dumped a database called &lt;code&gt;mydb&lt;/code&gt; into a custom-format dump file:</source>
          <target state="translated">&lt;code&gt;mydb&lt;/code&gt; というデータベースをカスタム形式のダンプファイルにダンプしたとします。</target>
        </trans-unit>
        <trans-unit id="00714db2b04e92390b518c92e4ea170b71450adc" translate="yes" xml:space="preserve">
          <source>Assuming that there is a table called &lt;code&gt;table1&lt;/code&gt;, this command would retrieve all rows and all user-defined columns from &lt;code&gt;table1&lt;/code&gt;. (The method of retrieval depends on the client application. For example, the psql program will display an ASCII-art table on the screen, while client libraries will offer functions to extract individual values from the query result.) The select list specification &lt;code&gt;*&lt;/code&gt; means all columns that the table expression happens to provide. A select list can also select a subset of the available columns or make calculations using the columns. For example, if &lt;code&gt;table1&lt;/code&gt; has columns named &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; (and perhaps others) you can make the following query:</source>
          <target state="translated">&lt;code&gt;table1&lt;/code&gt; と呼ばれるテーブルがあると想定すると、このコマンドはtable1からすべての行とすべてのユーザー定義列を取得し &lt;code&gt;table1&lt;/code&gt; 。（取得方法はクライアントアプリケーションによって異なります。たとえば、psqlプログラムは画面にASCIIアートテーブルを表示しますが、クライアントライブラリはクエリ結果から個々の値を抽出する関数を提供します。）選択リストの指定 &lt;code&gt;*&lt;/code&gt; は、テーブル式がたまたま提供するすべての列。選択リストでは、使用可能な列のサブセットを選択したり、列を使用して計算を行ったりすることもできます。たとえば、 &lt;code&gt;table1&lt;/code&gt; に &lt;code&gt;b&lt;/code&gt; 、b、および &lt;code&gt;c&lt;/code&gt; という名前 &lt;code&gt;a&lt;/code&gt; 列がある場合 （およびおそらく他の）次のクエリを実行できます。</target>
        </trans-unit>
        <trans-unit id="a6a8e2732fbce126a0a797cdd1e90b4272d9f93c" translate="yes" xml:space="preserve">
          <source>Asynchronous Commit</source>
          <target state="translated">非同期コミット</target>
        </trans-unit>
        <trans-unit id="1d15a4a3147c0af21cd5fba27008e02e7487f287" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O depends on an effective &lt;code&gt;posix_fadvise&lt;/code&gt; function, which some operating systems lack. If the function is not present then setting this parameter to anything but zero will result in an error. On some operating systems (e.g., Solaris), the function is present but does not actually do anything.</source>
          <target state="translated">非同期I / Oは、一部のオペレーティングシステムにはない効果的な &lt;code&gt;posix_fadvise&lt;/code&gt; 関数に依存しています。関数が存在しない場合、このパラメーターをゼロ以外に設定すると、エラーが発生します。一部のオペレーティングシステム（Solarisなど）では、関数は存在しますが、実際には何も実行しません。</target>
        </trans-unit>
        <trans-unit id="abb97da8205f09a691f99d2fcdea6f23dc61d65e" translate="yes" xml:space="preserve">
          <source>Asynchronous Multimaster Replication</source>
          <target state="translated">非同期マルチマスターレプリケーション</target>
        </trans-unit>
        <trans-unit id="00b2ec7d525c7895ab7759ef95defc6c17d534cd" translate="yes" xml:space="preserve">
          <source>Asynchronous commit introduces the risk of data loss. There is a short time window between the report of transaction completion to the client and the time that the transaction is truly committed (that is, it is guaranteed not to be lost if the server crashes). Thus asynchronous commit should not be used if the client will take external actions relying on the assumption that the transaction will be remembered. As an example, a bank would certainly not use asynchronous commit for a transaction recording an ATM's dispensing of cash. But in many scenarios, such as event logging, there is no need for a strong guarantee of this kind.</source>
          <target state="translated">非同期コミットはデータ損失のリスクを伴います。クライアントにトランザクションの完了を報告してから、トランザクションが本当にコミットされるまでの間には短い時間があります(つまり、サーバがクラッシュしてもデータが失われないことが保証されています)。したがって、クライアントがトランザクションが記憶されることを前提とした外部のアクションを行う場合には、非同期コミットは使用すべきではありません。例えば、銀行がATMで現金を払い出したことを記録するトランザクションに非同期コミットを使うことはないでしょう。しかし、イベントロギングのような多くのシナリオでは、この種の強力な保証は必要ありません。</target>
        </trans-unit>
        <trans-unit id="d90c24d882782b103f7c8579885000885b06b013" translate="yes" xml:space="preserve">
          <source>Asynchronous commit provides behavior different from setting &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off. &lt;code&gt;fsync&lt;/code&gt; is a server-wide setting that will alter the behavior of all transactions. It disables all logic within PostgreSQL that attempts to synchronize writes to different portions of the database, and therefore a system crash (that is, a hardware or operating system crash, not a failure of PostgreSQL itself) could result in arbitrarily bad corruption of the database state. In many scenarios, asynchronous commit provides most of the performance improvement that could be obtained by turning off &lt;code&gt;fsync&lt;/code&gt;, but without the risk of data corruption.</source>
          <target state="translated">非同期コミットは、&lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = offの設定とは異なる動作を提供します。 &lt;code&gt;fsync&lt;/code&gt; はサーバー全体の設定であり、すべてのトランザクションの動作を変更します。データベースの異なる部分への書き込みを同期しようとするPostgreSQL内のすべてのロジックを無効にするため、システムクラッシュ（つまり、ハードウェアまたはオペレーティングシステムのクラッシュであり、PostgreSQL自体の障害ではない）により、データベースの破損が任意に悪化する可能性があります。状態。多くのシナリオで、非同期コミットは &lt;code&gt;fsync&lt;/code&gt; をオフにすることで得られるパフォーマンスの改善のほとんどを提供しますが、データ破損のリスクはありません。</target>
        </trans-unit>
        <trans-unit id="38108f139265527283b18b5d33c78a6ddd380598" translate="yes" xml:space="preserve">
          <source>At a more basic level, it is not clear that solving query optimization with a GA algorithm designed for TSP is appropriate. In the TSP case, the cost associated with any substring (partial tour) is independent of the rest of the tour, but this is certainly not true for query optimization. Thus it is questionable whether edge recombination crossover is the most effective mutation procedure.</source>
          <target state="translated">より基本的なレベルでは、TSP用に設計されたGAアルゴリズムでクエリ最適化を解くことが適切であることは明らかではありません。TSPの場合、任意の部分文字列(部分巡回)に関連するコストは、残りの部分巡回とは独立していますが、これは確かに問い合わせ最適化には当てはまりません。したがって、エッジ組換えクロスオーバーが最も効果的な突然変異手順であるかどうかは疑問である。</target>
        </trans-unit>
        <trans-unit id="4d29cf5673a23d613acb6f0d1c22f5f4b6b78fcf" translate="yes" xml:space="preserve">
          <source>At all times, PostgreSQL maintains a &lt;em&gt;write ahead log&lt;/em&gt; (WAL) in the &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory of the cluster's data directory. The log records every change made to the database's data files. This log exists primarily for crash-safety purposes: if the system crashes, the database can be restored to consistency by &amp;ldquo;replaying&amp;rdquo; the log entries made since the last checkpoint. However, the existence of the log makes it possible to use a third strategy for backing up databases: we can combine a file-system-level backup with backup of the WAL files. If recovery is needed, we restore the file system backup and then replay from the backed-up WAL files to bring the system to a current state. This approach is more complex to administer than either of the previous approaches, but it has some significant benefits:</source>
          <target state="translated">PostgreSQL は &lt;code&gt;pg_wal/&lt;/code&gt; &lt;em&gt;先読みログ&lt;/em&gt;（WAL）を保持し&lt;em&gt;ています&lt;/em&gt;クラスターのデータディレクトリのサブディレクトリ。ログには、データベースのデータファイルに加えられたすべての変更が記録されます。このログは、主にクラッシュセーフの目的で存在します。システムがクラッシュした場合、最後のチェックポイント以降に作成されたログエントリを「再生」することにより、データベースを一貫性のある状態に復元できます。ただし、ログの存在により、データベースのバックアップに3番目の戦略を使用することが可能になります。ファイルシステムレベルのバックアップとWALファイルのバックアップを組み合わせることができます。リカバリが必要な場合は、ファイルシステムのバックアップを復元し、バックアップされたWALファイルから再生して、システムを現在の状態にします。このアプローチは、以前のいずれのアプローチよりも管理が複雑ですが、いくつかの重要な利点があります。</target>
        </trans-unit>
        <trans-unit id="d0aa9f0f7a8b54305272b705ab4c8ce4332faa1e" translate="yes" xml:space="preserve">
          <source>At compile time, &lt;code&gt;transaction__start&lt;/code&gt; is converted to a macro called &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; (notice the underscores are single here), which is available by including &lt;code&gt;pg_trace.h&lt;/code&gt;. Add the macro call to the appropriate location in the source code. In this case, it looks like the following:</source>
          <target state="translated">コンパイル時に、 &lt;code&gt;transaction__start&lt;/code&gt; は &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; と呼ばれるマクロに変換されます（アンダースコアはここでは1つであることに注意してください）。これは &lt;code&gt;pg_trace.h&lt;/code&gt; をインクルードすることで利用できます。マクロ呼び出しをソースコードの適切な場所に追加します。この場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="1c05bc819458daf00162775e69bb6f11e3009ae1" translate="yes" xml:space="preserve">
          <source>At least as of version 5.1, it should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="translated">少なくともバージョン5.1以降では、 &lt;code&gt;SHMMAX&lt;/code&gt; などのパラメーターに対して特別な構成を行う必要はありません。これは、すべてのメモリを共有メモリとして使用できるように構成されているためです。これは、DB / 2などの他のデータベースで一般的に使用される種類の構成です。</target>
        </trans-unit>
        <trans-unit id="df036c0dc6f1685c583f36a683953e72b19d8691" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;LEFTARG&lt;/code&gt; and &lt;code&gt;RIGHTARG&lt;/code&gt; must be defined. For binary operators, both must be defined. For right unary operators, only &lt;code&gt;LEFTARG&lt;/code&gt; should be defined, while for left unary operators only &lt;code&gt;RIGHTARG&lt;/code&gt; should be defined.</source>
          <target state="translated">&lt;code&gt;LEFTARG&lt;/code&gt; および &lt;code&gt;RIGHTARG&lt;/code&gt; の少なくとも1つを定義する必要があります。 2項演算子の場合、両方を定義する必要があります。右単項演算子の場合は &lt;code&gt;LEFTARG&lt;/code&gt; のみを定義し、左単項演算子の場合は &lt;code&gt;RIGHTARG&lt;/code&gt; のみを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="81523154b2540393f2eb08b2e64447cb44f3b4fa" translate="yes" xml:space="preserve">
          <source>At least one of the following options must be specified to select an action:</source>
          <target state="translated">アクションを選択するには、以下のオプションのうち少なくとも1つを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b72121826b7e4651c5d94f2436d0c7ffe3e3c260" translate="yes" xml:space="preserve">
          <source>At least one of these two things has to be ensured, or the PostgreSQL server will be very unreliable.</source>
          <target state="translated">この2つのうち少なくとも1つは確実にしないと、PostgreSQLサーバは非常に信頼性の低いものになってしまいます。</target>
        </trans-unit>
        <trans-unit id="d8eaf93cff7d6986839d33f973b6b2eb6f3e3612" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt; for details.</source>
          <target state="translated">サブスクリプションごとに少なくとも1行。サブスクリプションワーカーに関する情報を示します。詳細は&lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7d5c8007175669495e5c5ec2b3f06db9f4615159" translate="yes" xml:space="preserve">
          <source>At present, any table used as the target of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; must not have a conditional rule, nor an &lt;code&gt;ALSO&lt;/code&gt; rule, nor an &lt;code&gt;INSTEAD&lt;/code&gt; rule that expands to multiple statements.</source>
          <target state="translated">現在、 &lt;code&gt;WITH&lt;/code&gt; でデータ変更ステートメントのターゲットとして使用されるテーブルには、条件付きルール、 &lt;code&gt;ALSO&lt;/code&gt; ルール、または複数のステートメントに展開される &lt;code&gt;INSTEAD&lt;/code&gt; ルールがあってはなりません。</target>
        </trans-unit>
        <trans-unit id="ff0acb0e759b914c8ac0d92fbd4b06b6c52abe9f" translate="yes" xml:space="preserve">
          <source>At present, it's assumed that the sort order for an ordering operator is the default for the referenced operator family, i.e., &lt;code&gt;ASC NULLS LAST&lt;/code&gt;. This might someday be relaxed by adding additional columns to specify sort options explicitly.</source>
          <target state="translated">現在、順序付け演算子の並べ替え順序は、参照される演算子ファミリのデフォルト、つまり &lt;code&gt;ASC NULLS LAST&lt;/code&gt; であると想定されています。これは、列を追加してソートオプションを明示的に指定することにより、いつか緩和される可能性があります。</target>
        </trans-unit>
        <trans-unit id="0da87b74c1c3af23d284a826d817211a0d50dbca" translate="yes" xml:space="preserve">
          <source>At present, the &lt;code&gt;soundex&lt;/code&gt;, &lt;code&gt;metaphone&lt;/code&gt;, &lt;code&gt;dmetaphone&lt;/code&gt;, and &lt;code&gt;dmetaphone_alt&lt;/code&gt; functions do not work well with multibyte encodings (such as UTF-8).</source>
          <target state="translated">現在、 &lt;code&gt;soundex&lt;/code&gt; 、 &lt;code&gt;metaphone&lt;/code&gt; 、 &lt;code&gt;dmetaphone&lt;/code&gt; 、および &lt;code&gt;dmetaphone_alt&lt;/code&gt; 関数は、マルチバイトエンコーディング（UTF-8など）ではうまく機能しません。</target>
        </trans-unit>
        <trans-unit id="a78a49f80284f34a995726cc4689e41d04fb4798" translate="yes" xml:space="preserve">
          <source>At present, this setting is supported only on Linux and Windows. The setting is ignored on other systems when set to &lt;code&gt;try&lt;/code&gt;.</source>
          <target state="translated">現在、この設定はLinuxとWindowsでのみサポートされています。 &lt;code&gt;try&lt;/code&gt; に設定すると、他のシステムではこの設定は無視されます。</target>
        </trans-unit>
        <trans-unit id="965d1f5ec334a9d95d86fe2f92675d08806b41f2" translate="yes" xml:space="preserve">
          <source>At startup, the standby begins by restoring all WAL available in the archive location, calling &lt;code&gt;restore_command&lt;/code&gt;. Once it reaches the end of WAL available there and &lt;code&gt;restore_command&lt;/code&gt; fails, it tries to restore any WAL available in the &lt;code&gt;pg_wal&lt;/code&gt; directory. If that fails, and streaming replication has been configured, the standby tries to connect to the primary server and start streaming WAL from the last valid record found in archive or &lt;code&gt;pg_wal&lt;/code&gt;. If that fails or streaming replication is not configured, or if the connection is later disconnected, the standby goes back to step 1 and tries to restore the file from the archive again. This loop of retries from the archive, &lt;code&gt;pg_wal&lt;/code&gt;, and via streaming replication goes on until the server is stopped or failover is triggered by a trigger file.</source>
          <target state="translated">起動時に、スタンバイは、アーカイブの場所で利用可能なすべてのWALを復元し、 &lt;code&gt;restore_command&lt;/code&gt; を呼び出します。そこで利用可能なWALの最後に到達し、 &lt;code&gt;restore_command&lt;/code&gt; が失敗すると、 &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリで利用可能なWALを復元しようとします。これが失敗し、ストリーミングレプリケーションが構成されている場合、スタンバイはプライマリサーバーに接続し、アーカイブまたは &lt;code&gt;pg_wal&lt;/code&gt; で見つかった最後の有効なレコードからストリーミングWALを開始しようとします。これが失敗した場合、またはストリーミングレプリケーションが構成されていない場合、または接続が後で切断された場合、スタンバイは手順1に戻り、アーカイブからファイルを再度復元しようとします。アーカイブ &lt;code&gt;pg_wal&lt;/code&gt; からのこの再試行ループ、およびストリーミングレプリケーションは、サーバーが停止するか、トリガーファイルによってフェイルオーバーがトリガーされるまで続きます。</target>
        </trans-unit>
        <trans-unit id="55d8465dd064f760adc6de27f3c71c491c82a460" translate="yes" xml:space="preserve">
          <source>At the &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction isolation level this would cause a serialization failure (with a &lt;code&gt;SQLSTATE&lt;/code&gt; of &lt;code&gt;'40001'&lt;/code&gt;), so there is no possibility of receiving rows out of order under these isolation levels.</source>
          <target state="translated">で &lt;code&gt;REPEATABLE READ&lt;/code&gt; または &lt;code&gt;SERIALIZABLE&lt;/code&gt; トランザクション分離レベルこれは（とシリアライズ障害引き起こす &lt;code&gt;SQLSTATE&lt;/code&gt; の &lt;code&gt;'40001'&lt;/code&gt; ）ので、これらの分離レベルの下順不同行を受けることはありません。</target>
        </trans-unit>
        <trans-unit id="d9934a1c03bcddc43aaddd8a50e8957f0b10bf33" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be written on the server the backup is taken from. Especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used, this can take some time during which pg_basebackup will be appear to be idle.</source>
          <target state="translated">バックアップの開始時に、バックアップを取得するサーバーにチェックポイントを書き込む必要があります。特にオプション &lt;code&gt;--checkpoint=fast&lt;/code&gt; が使用されていない場合、pg_basebackupがアイドル状態のように見えるまでに時間がかかることがあります。</target>
        </trans-unit>
        <trans-unit id="0a42b715d6522241c83704ed30aede2b52fb0a06" translate="yes" xml:space="preserve">
          <source>At the default &amp;ldquo;scale factor&amp;rdquo; of 1, the tables initially contain this many rows:</source>
          <target state="translated">デフォルトの「スケール係数」が1の場合、テーブルには最初、これだけ多くの行が含まれています。</target>
        </trans-unit>
        <trans-unit id="1c903746f8f0e8094ed1c641f98efb9a635313ed" translate="yes" xml:space="preserve">
          <source>At the end of each session, &lt;code&gt;UNLISTEN *&lt;/code&gt; is automatically executed.</source>
          <target state="translated">各セッションの最後に、 &lt;code&gt;UNLISTEN *&lt;/code&gt; が自動的に実行されます。</target>
        </trans-unit>
        <trans-unit id="8cd262012c4caf6374bfb34cbb6a915df644c90b" translate="yes" xml:space="preserve">
          <source>At the end of recovery, &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; held by prepared transactions will require twice the normal number of lock table entries. If you plan on running either a large number of concurrent prepared transactions that normally take &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, or you plan on having one large transaction that takes many &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, you are advised to select a larger value of &lt;code&gt;max_locks_per_transaction&lt;/code&gt;, perhaps as much as twice the value of the parameter on the primary server. You need not consider this at all if your setting of &lt;code&gt;max_prepared_transactions&lt;/code&gt; is 0.</source>
          <target state="translated">リカバリの最後に、準備されたトランザクションによって保持されている &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; には、通常の2倍のロックテーブルエントリが必要になります。あなたが通常取る同時準備されたトランザクションの数が多いのいずれかで実行する予定の場合は &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; を多く取る一つの大きなトランザクションた上で、またはあなたが計画 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; を、あなたは、より大きな値を選択することをお勧めします &lt;code&gt;max_locks_per_transaction&lt;/code&gt; の値の2倍として、おそらく同じくらい、プライマリサーバーのパラメーター。 &lt;code&gt;max_prepared_transactions&lt;/code&gt; の設定が0の場合、これを考慮する必要はありません。</target>
        </trans-unit>
        <trans-unit id="14547baffec9c8ba5963d60806059645bd69fca9" translate="yes" xml:space="preserve">
          <source>At the prompt, the user can type in SQL commands. Ordinarily, input lines are sent to the server when a command-terminating semicolon is reached. An end of line does not terminate a command. Thus commands can be spread over several lines for clarity. If the command was sent and executed without error, the results of the command are displayed on the screen.</source>
          <target state="translated">プロンプトでは、ユーザーはSQLコマンドを入力することができます。通常、入力行は、コマンドで終了するセミコロンに達するとサーバーに送信されます。行末はコマンドを終了させません。そのため、コマンドはわかりやすくするために複数行に分けることができます。コマンドが送信され、エラーなく実行された場合は、コマンドの結果が画面に表示されます。</target>
        </trans-unit>
        <trans-unit id="a73b24b0f045657de48b1ab740f05e1e597825d0" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="translated">同時に、 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; は、2番目の文字列内の単語の範囲を選択します。上記の例では、 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; は、トライグラムのセットが &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; である単一の単語 &lt;code&gt;'words'&lt;/code&gt; の範囲を選択します。 ds &quot;}。</target>
        </trans-unit>
        <trans-unit id="416a07de78793e22bb0ac6ecdc4a78f4b476ae54" translate="yes" xml:space="preserve">
          <source>At the time of creation, all existing heap pages are scanned and a summary index tuple is created for each range, including the possibly-incomplete range at the end. As new pages are filled with data, page ranges that are already summarized will cause the summary information to be updated with data from the new tuples. When a new page is created that does not fall within the last summarized range, that range does not automatically acquire a summary tuple; those tuples remain unsummarized until a summarization run is invoked later, creating initial summaries. This process can be invoked manually using the &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; or &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; functions; automatically when &lt;code&gt;VACUUM&lt;/code&gt; processes the table; or by automatic summarization executed by autovacuum, as insertions occur. (This last trigger is disabled by default and can be enabled with the &lt;code&gt;autosummarize&lt;/code&gt; parameter.) Conversely, a range can be de-summarized using the &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; function, which is useful when the index tuple is no longer a very good representation because the existing values have changed.</source>
          <target state="translated">作成時に、既存のすべてのヒープページがスキャンされ、最後に不完全である可能性のある範囲を含め、各範囲に対してサマリーインデックスタプルが作成されます。新しいページがデータで満たされると、既に要約されているページ範囲により、要約情報が新しいタプルからのデータで更新されます。最後に要約された範囲に含まれない新しいページが作成された場合、その範囲は自動的に要約タプルを取得しません。これらのタプルは、後で要約の実行が呼び出されて初期の要約が作成されるまで、要約されません。このプロセスは、 &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; または &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; 関数を使用して手動で呼び出すことができます。 &lt;code&gt;VACUUM&lt;/code&gt; 時に自動的にテーブルを処理します。または、挿入が発生したときにautovacuumによって実行される自動要約。（この最後のトリガーはデフォルトで無効になっており、 &lt;code&gt;autosummarize&lt;/code&gt; パラメーターを使用して有効にできます。）逆に、範囲は &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; 関数を使用して逆要約できます。これは、インデックスタプルがあまり適切でない場合に役立ちます。既存の値が変更されたため、表現。</target>
        </trans-unit>
        <trans-unit id="570ab49c8c4979d8f2b45f71407d683f61c768c4" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;pg_proc.dat&lt;/code&gt; has all three columns, &lt;code&gt;prokind&lt;/code&gt;, &lt;code&gt;proisagg&lt;/code&gt;, and &lt;code&gt;proiswindow&lt;/code&gt;, though they will appear only in rows where they have non-default values.</source>
          <target state="translated">この時点で、 &lt;code&gt;pg_proc.dat&lt;/code&gt; には &lt;code&gt;prokind&lt;/code&gt; 、 &lt;code&gt;proisagg&lt;/code&gt; 、および &lt;code&gt;proiswindow&lt;/code&gt; の 3つの列がすべてありますが、デフォルト以外の値がある行にのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="394da4678018ab888c36788be82e3560af3396a8" translate="yes" xml:space="preserve">
          <source>At this point, you will have an index on the &lt;code&gt;t&lt;/code&gt; column that you can use for similarity searching. A typical query is</source>
          <target state="translated">この時点で、 &lt;code&gt;t&lt;/code&gt; 列にインデックスがあり、類似性検索に使用できます。典型的なクエリは</target>
        </trans-unit>
        <trans-unit id="2a3a5c5f47d6770989533a4fd46849cfebf7e2e9" translate="yes" xml:space="preserve">
          <source>At this writing, there are several limitations of the continuous archiving technique. These will probably be fixed in future releases:</source>
          <target state="translated">この記事を書いている時点では、継続的なアーカイブ技術にはいくつかの制限があります。これらはおそらく将来のリリースで修正されるでしょう。</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="cfaa3dc03c49871e78cddda27fc42c3f092dc0c4" translate="yes" xml:space="preserve">
          <source>Attach a comment to the table &lt;code&gt;mytable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mytable&lt;/code&gt; テーブルにコメントを添付します。</target>
        </trans-unit>
        <trans-unit id="b30d15695b4486ee3edc48c2da787bd31caa82e5" translate="yes" xml:space="preserve">
          <source>Attaching a partition acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table, in addition to &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; locks on the table to be attached and on the default partition (if any).</source>
          <target state="translated">パーティションをアタッチすると、アタッチされるテーブルとデフォルトパーティション（存在する場合）の &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックに加えて、親テーブルの &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; ロックが取得されます。</target>
        </trans-unit>
        <trans-unit id="d4f51e4421d7c33f901d2846a5f5963016f01207" translate="yes" xml:space="preserve">
          <source>Attempt to allow server crashes to produce core files, on platforms where this is possible, by lifting any soft resource limit placed on core files. This is useful in debugging or diagnosing problems by allowing a stack trace to be obtained from a failed server process.</source>
          <target state="translated">これが可能なプラットフォームでは、コアファイルにかけられたソフトリソースの制限を解除することで、サーバクラッシュがコアファイルを生成できるようにしようとします。これは、失敗したサーバプロセスからスタックトレースを取得できるようにすることで、 問題のデバッグや診断に役立ちます。</target>
        </trans-unit>
        <trans-unit id="22d313995c5aa4824bbbe6a43fa47548d5dd9981" translate="yes" xml:space="preserve">
          <source>Attempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. To do this without failing the entire transaction, use savepoints:</source>
          <target state="translated">新しい在庫アイテムを在庫数と一緒に挿入しようとします。アイテムがすでに存在する場合は、代わりに既存のアイテムの在庫数を更新します。トランザクション全体を失敗させずにこれを行うには、savepointsを使用します。</target>
        </trans-unit>
        <trans-unit id="76eb27398e988091546915b412edd431f3061249" translate="yes" xml:space="preserve">
          <source>Attempting to drop a table that does not exist is an error. Nevertheless, it is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. (If you like, you can use the &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; variant to avoid the error messages, but this is not standard SQL.)</source>
          <target state="translated">存在しないテーブルを削除しようとするとエラーになります。それでも、SQLスクリプトファイルでは、テーブルを作成する前に無条件に各テーブルを削除しようとし、エラーメッセージを無視して、テーブルが存在するかどうかに関係なくスクリプトが機能するようにするのが一般的です。（必要に応じて、 &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; バリアントを使用してエラーメッセージを回避できますが、これは標準SQLではありません。）</target>
        </trans-unit>
        <trans-unit id="a0d00292b426c90d6f3e1dbff7f81bbe2e552240" translate="yes" xml:space="preserve">
          <source>Attempting to enter a date using a mixture of ISO 8601 week-numbering fields and Gregorian date fields is nonsensical, and will cause an error. In the context of an ISO 8601 week-numbering year, the concept of a &amp;ldquo;month&amp;rdquo; or &amp;ldquo;day of month&amp;rdquo; has no meaning. In the context of a Gregorian year, the ISO week has no meaning.</source>
          <target state="translated">ISO 8601の週番号フィールドとグレゴリオ暦の日付フィールドを組み合わせて日付を入力しようとしても無意味で、エラーが発生します。ISO 8601の週番号の年の文脈では、「月」または「月の日」の概念は意味を持ちません。グレゴリオ年の文脈では、ISO週は意味を持ちません。</target>
        </trans-unit>
        <trans-unit id="c85e1c86ef58d9df3e2aa30f481d2a46d06ccc08" translate="yes" xml:space="preserve">
          <source>Attribute to match against the user name in the search when doing search+bind authentication. If no attribute is specified, the &lt;code&gt;uid&lt;/code&gt; attribute will be used.</source>
          <target state="translated">検索+バインド認証を行うときに、検索でユーザー名と照合する属性。属性が指定されていない場合、 &lt;code&gt;uid&lt;/code&gt; 属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="666a0c222579ebcb139d2bf4bc0c9f0b94222439" translate="yes" xml:space="preserve">
          <source>Attribute-level foreign data wrapper options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としての属性レベルの外部データラッパーオプション</target>
        </trans-unit>
        <trans-unit id="81543c9a145dd6869d89d4e634466bddb425f66f" translate="yes" xml:space="preserve">
          <source>Attribute-level options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としての属性レベルのオプション</target>
        </trans-unit>
        <trans-unit id="75629af51d7c7f120dbb5b462013bfa48af33285" translate="yes" xml:space="preserve">
          <source>Aug</source>
          <target state="translated">Aug</target>
        </trans-unit>
        <trans-unit id="69d97c5797dc7d211aaa4e9229db5c8466d4edef" translate="yes" xml:space="preserve">
          <source>August</source>
          <target state="translated">August</target>
        </trans-unit>
        <trans-unit id="9ac07ce6cd52d678fbe1229a683f5eafa07e3b6a" translate="yes" xml:space="preserve">
          <source>Authenticate using SSL client certificates. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details.</source>
          <target state="translated">SSLクライアント証明書を使用して認証します。詳細は&lt;a href=&quot;auth-cert&quot;&gt;項20.12&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b62091287fb724791ca34488a0ab2a9fac4a1e4d" translate="yes" xml:space="preserve">
          <source>Authenticate using a RADIUS server. See &lt;a href=&quot;auth-radius&quot;&gt;Section 20.11&lt;/a&gt; for details.</source>
          <target state="translated">RADIUSサーバーを使用して認証します。詳細は&lt;a href=&quot;auth-radius&quot;&gt;項20.11&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="82054cdf870e919ceb8345be400ef8ccd343353b" translate="yes" xml:space="preserve">
          <source>Authenticate using an LDAP server. See &lt;a href=&quot;auth-ldap&quot;&gt;Section 20.10&lt;/a&gt; for details.</source>
          <target state="translated">LDAPサーバーを使用して認証します。詳細は&lt;a href=&quot;auth-ldap&quot;&gt;項20.10&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="55d3191d61e9daf8a3de6d8c5454a6099b6e7e03" translate="yes" xml:space="preserve">
          <source>Authenticate using the BSD Authentication service provided by the operating system. See &lt;a href=&quot;auth-bsd&quot;&gt;Section 20.14&lt;/a&gt; for details.</source>
          <target state="translated">オペレーティングシステムが提供するBSD認証サービスを使用して認証します。詳細は&lt;a href=&quot;auth-bsd&quot;&gt;項20.14&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="99ad70b6f56fd0c0d9729bfab969bd959ae5fb53" translate="yes" xml:space="preserve">
          <source>Authenticate using the Pluggable Authentication Modules (PAM) service provided by the operating system. See &lt;a href=&quot;auth-pam&quot;&gt;Section 20.13&lt;/a&gt; for details.</source>
          <target state="translated">オペレーティングシステムが提供するPluggable Authentication Modules（PAM）サービスを使用して認証します。詳細は&lt;a href=&quot;auth-pam&quot;&gt;項20.13&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ad4053a30971cdd0eca5d90cab892f9f383ba3e" translate="yes" xml:space="preserve">
          <source>Authentication Methods</source>
          <target state="translated">認証方法</target>
        </trans-unit>
        <trans-unit id="98fb3925f64e0642987c3e7beb38bbfbcaa16576" translate="yes" xml:space="preserve">
          <source>Authentication Problems</source>
          <target state="translated">認証の問題</target>
        </trans-unit>
        <trans-unit id="bcf5b4f7c9dc716b472b6e8b3f05c043e93a5b63" translate="yes" xml:space="preserve">
          <source>Authentication failures and related problems generally manifest themselves through error messages like the following:</source>
          <target state="translated">認証の失敗とそれに関連する問題は、一般的に以下のようなエラーメッセージで表示されます。</target>
        </trans-unit>
        <trans-unit id="4a2641463bda57c970dcaba44cead46536e41155" translate="yes" xml:space="preserve">
          <source>Authentication method</source>
          <target state="translated">認証方法</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="ae017ff45a4a035cd29d47f616f68029f16fd0e1" translate="yes" xml:space="preserve">
          <source>Automatic Vacuuming</source>
          <target state="translated">自動バキューム</target>
        </trans-unit>
        <trans-unit id="7c977c91d67cb7d94506d78b8621aa22f728f9df" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="translated">インデックスの構造的整合性の自動検証は、論理的な不整合が導入されることを合理的に許容する可能性のある、新しいまたは提案されたPostgreSQL機能の一般的なテストで役割を果たします。テーブル構造の検証、および関連する可視性とトランザクションステータス情報は、同様の役割を果たします。明らかなテスト戦略の1つは、標準の回帰テストを実行するときに &lt;code&gt;amcheck&lt;/code&gt; 関数を継続的に呼び出すことです。参照&lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;セクション32.1を&lt;/a&gt;テストの実行の詳細については。</target>
        </trans-unit>
        <trans-unit id="820a99cec2958e050680c6f99db97b790304fa53" translate="yes" xml:space="preserve">
          <source>Automatically drop objects (tables, functions, etc.) that are contained in the schema, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">スキーマに含まれているオブジェクト（テーブル、関数など）を自動的に削除し、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7996658087a343e0aa2b3cf4b1db038fe35de48f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the access method (such as operator classes, operator families, and indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">アクセス方法に依存するオブジェクト（演算子クラス、演算子ファミリ、インデックスなど）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="baccb8c23deca0c76a8a79a9c5f9953c38de8bc4" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the affected objects, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">影響を受けるオブジェクトに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="38e895c6814216f5b3e9484010061f8b91dc249f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the aggregate function (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">集約関数に依存するオブジェクト（それを使用するビューなど）を自動的に削除し、次に、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="abc0b1d37273a9737a10dc3892acfa6c92fe5d93" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the collation, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">照合に依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="745a5a5b00e94aac1eab4bd026b0c3eb4c8c446e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the constraint, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">制約に依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e6ef4a74296e736f065e1732a22c73d138658014" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the domain (such as table columns), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">ドメインに依存するオブジェクト（テーブルの列など）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="660862c86777512d4fcfc8d0ae2ba2705d79fc1b" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">削除された列または制約に依存するオブジェクト（たとえば、列を参照するビュー）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="ce7ac7937862e4e4126fdf7e2c5724e3de1e23e6" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the extension, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">拡張子に依存するオブジェクトを自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6bd522b5b8653034eb0b6145f2ce2e5dacb2cba0" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">外部テーブルに依存しているオブジェクト（ビューなど）を自動的に削除し、それらのオブジェクトに依存しているすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a988e483f220bf7f0532dd68b502a2b7076edf0a" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign-data wrapper (such as foreign tables and servers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">外部データラッパーに依存するオブジェクト（外部テーブルやサーバーなど）、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e27007381181e414122b1ae56cdfd1a6d1dab2ad" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the function (such as operators or triggers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">関数に依存するオブジェクト（演算子やトリガーなど）を自動的に削除し、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1b9c92f0f554dcfb206e40bfd135fab8fe00e7e2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the index, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">インデックスに依存するオブジェクトを自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bcb27d2712f35ddb733c1f98ff51f21d7d424aaa" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the language (such as functions in the language), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">言語に依存するオブジェクト（言語の関数など）を自動的に削除し、次に、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2f6d0323ae070e0fb6a9170cf88c29d107b33c44" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the materialized view (such as other materialized views, or regular views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">マテリアライズドビューに依存するオブジェクト（他のマテリアライズドビューや通常のビューなど）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bf9e6848c526fa45713feaa1a3f98743157a4884" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">演算子に依存するオブジェクト（演算子を使用するビューなど）を自動的に削除し、次に、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="cbbaf53e6f678b4c8cf5eec8a71b6a7c2ee4f9ea" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator class (such as indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">演算子クラスに依存するオブジェクト（インデックスなど）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="eb5de09991d91e56b807fa44deb753015952ad1e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator family, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">演算子族に依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e459a28af6e31c3e35e65f3a6c2487c577b6fa29" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the procedure, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">プロシージャに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14項を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b0c32bf11160fbc2a809f14fb04d0b4471ad9003" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the rule, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">ルールに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="de054c43bd92a23004c72d1888e8a17d538b0b78" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the sequence, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">シーケンスに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bb69e1d5d516109b91608eb01c14e7c1738edbdf" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the server (such as user mappings), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">サーバーに依存するオブジェクト（ユーザーマッピングなど）を自動的に削除し、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="40e6c61745089f774dd3e41d1dc840b568fe3b30" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テーブルなどに依存するオブジェクト（ビューなど）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="53f104557d2e3eaa82997c5ded39fd7f6ba0b2a2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search configuration, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テキスト検索構成に依存するオブジェクトを自動的にドロップし、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c790e11a342e191d26db4cfa94c2202262cf7507" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search dictionary, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テキスト検索ディクショナリに依存するオブジェクトを自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5ce0aa99a0b061d5935384944655cf0dc2b98983" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search parser, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テキスト検索パーサーに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="24a3aa8af1a85db5b902e0817649894b200120f5" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search template, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テキスト検索テンプレートに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="52e34eb24e551596b0414271aef19a7a92f41187" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the transform, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">トランスフォームに依存するオブジェクトを自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5430ece32ada38350ecf74986f0bbc942e6e3cfc" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the trigger, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">トリガーに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="946c18a9096115a846e5ed6451faa1e38fe8c835" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the type (such as table columns, functions, and operators), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">型に依存するオブジェクト（テーブルの列、関数、演算子など）を自動的に削除し、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3d1c86e5f361718e066619a34ceb6e0c61659055" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the view (such as other views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">ビューに依存するオブジェクト（他のビューなど）を自動的にドロップし、それらのオブジェクトに依存するすべてのオブジェクトを自動的にドロップします（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3b54adcbf7578fd1e32a97c6d995480099f4e4ee" translate="yes" xml:space="preserve">
          <source>Automatically generate certain C code from SQL code. Currently, this works for &lt;code&gt;EXEC SQL TYPE&lt;/code&gt;.</source>
          <target state="translated">SQLコードから特定のCコードを自動的に生成します。現在、これは &lt;code&gt;EXEC SQL TYPE&lt;/code&gt; で機能します。</target>
        </trans-unit>
        <trans-unit id="02a28684ac310395befcd622074bd92c8287b214" translate="yes" xml:space="preserve">
          <source>Automatically install any extensions that this extension depends on that are not already installed. Their dependencies are likewise automatically installed, recursively. The &lt;code&gt;SCHEMA&lt;/code&gt; clause, if given, applies to all extensions that get installed this way. Other options of the statement are not applied to automatically-installed extensions; in particular, their default versions are always selected.</source>
          <target state="translated">この拡張機能が依存する拡張機能のうち、まだインストールされていないものを自動的にインストールします。それらの依存関係も同様に、再帰的に自動的にインストールされます。 &lt;code&gt;SCHEMA&lt;/code&gt; の句は、与えられた場合は、getがこのようにインストールされていることをすべての拡張機能に適用されます。ステートメントの他のオプションは、自動インストールされる拡張機能には適用されません。特に、デフォルトのバージョンが常に選択されています。</target>
        </trans-unit>
        <trans-unit id="82114421ee75a29b216b45460b9e22d194a04f14" translate="yes" xml:space="preserve">
          <source>Automatically propagate the operation to typed tables of the type being altered, and their descendants.</source>
          <target state="translated">変更される型の型付きテーブルとその子孫に操作を自動的に伝搬させます。</target>
        </trans-unit>
        <trans-unit id="8cbbea802a2969bf6986433c47646c8510fbfd3b" translate="yes" xml:space="preserve">
          <source>Automatically restart sequences owned by columns of the truncated table(s).</source>
          <target state="translated">切り捨てられたテーブルの列が所有するシーケンスを自動的に再起動します。</target>
        </trans-unit>
        <trans-unit id="5642bfdf85a2050b70397bd1e7d1e3fa447f8560" translate="yes" xml:space="preserve">
          <source>Automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN.</source>
          <target state="translated">受信が指定したLSNに到達すると自動的にレプリケーションを停止し、通常の終了ステータス0で終了します。</target>
        </trans-unit>
        <trans-unit id="39275b6e09e38bef3ed571db2ef1da8d2f155a4e" translate="yes" xml:space="preserve">
          <source>Automatically truncate all tables that have foreign-key references to any of the named tables, or to any tables added to the group due to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="translated">名前付きテーブルのいずれか、または &lt;code&gt;CASCADE&lt;/code&gt; によりグループに追加されたテーブルへの外部キー参照を持つすべてのテーブルを自動的に切り捨てます。</target>
        </trans-unit>
        <trans-unit id="63b02d90144047f7b0ae09ab6bb39285e944deab" translate="yes" xml:space="preserve">
          <source>Autovacuum is not active during recovery. It will start normally at the end of recovery.</source>
          <target state="translated">リカバリー中は自動バキュームは作動しません。リカバリーの終了時には正常に起動します。</target>
        </trans-unit>
        <trans-unit id="d7773c835487baf5b5c0ec83d176517e017c8f8a" translate="yes" xml:space="preserve">
          <source>Autovacuum worker or launcher waiting to update or read the current state of autovacuum workers.</source>
          <target state="translated">自動バキュームワーカーまたはランチャーは、自動バキュームワーカーの現在の状態の更新または読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="4aa1cd4d844c5afaaef04eccf35c0da21524cd29" translate="yes" xml:space="preserve">
          <source>Autovacuum workers generally don't block other commands. If a process attempts to acquire a lock that conflicts with the &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock held by autovacuum, lock acquisition will interrupt the autovacuum. For conflicting lock modes, see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;. However, if the autovacuum is running to prevent transaction ID wraparound (i.e., the autovacuum query name in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view ends with &lt;code&gt;(to prevent wraparound)&lt;/code&gt;), the autovacuum is not automatically interrupted.</source>
          <target state="translated">自動バキュームワーカーは通常、他のコマンドをブロックしません。プロセスがautovacuumによって保持されている &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; ロックと競合するロックを取得しようとすると、ロックの取得によってautovacuumが中断されます。競合するロックモードについては、&lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;表13.2を&lt;/a&gt;参照してください。ただし、autovacuumが実行されてトランザクションIDのラップアラウンドを防止している場合（つまり、 &lt;code&gt;pg_stat_activity&lt;/code&gt; ビューのautovacuumクエリ名が &lt;code&gt;(to prevent wraparound)&lt;/code&gt; ）で終わっている場合）、自動バキュームは自動的に中断されません。</target>
        </trans-unit>
        <trans-unit id="df5a7bec123e69676856b9a816b4c6aef10e3a78" translate="yes" xml:space="preserve">
          <source>Available Client Character Sets</source>
          <target state="translated">利用可能なクライアント文字セット</target>
        </trans-unit>
        <trans-unit id="820b74a0a5297b8b6e88df74e84d5e81e977acf2" translate="yes" xml:space="preserve">
          <source>Available cipher suite details will vary across OpenSSL versions. Use the command &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; to see actual details for the currently installed OpenSSL version. Note that this list is filtered at run time based on the server key type.</source>
          <target state="translated">利用可能な暗号スイートの詳細は、OpenSSLのバージョンによって異なります。 &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; コマンドを使用して、現在インストールされているOpenSSLバージョンの実際の詳細を確認します。このリストは、サーバーのキータイプに基づいて実行時にフィルタリングされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ba149cade6a0a4e50af1ecb3e25946c72c71094e" translate="yes" xml:space="preserve">
          <source>Average density of leaf pages</source>
          <target state="translated">葉っぱページの平均密度</target>
        </trans-unit>
        <trans-unit id="4903dacf2f00d069a2643728e3f02486ff810d77" translate="yes" xml:space="preserve">
          <source>Average width in bytes of column's entries</source>
          <target state="translated">列のエントリの平均幅をバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="3e9553fca4b719e6a36df1dda8f90b143771ffd9" translate="yes" xml:space="preserve">
          <source>B-Tree Indexes</source>
          <target state="translated">B-Treeインデックス</target>
        </trans-unit>
        <trans-unit id="68486e8aa60ef6bf0ca374b07c2662a92ae24f27" translate="yes" xml:space="preserve">
          <source>B-Tree Support Functions</source>
          <target state="translated">B-Treeサポート機能</target>
        </trans-unit>
        <trans-unit id="9504ad9e3e7718bba2e8ff2d49bd5578d047ea98" translate="yes" xml:space="preserve">
          <source>B-tree equivalent functionality for several data types</source>
          <target state="translated">いくつかのデータ型でB-treeと同等の機能</target>
        </trans-unit>
        <trans-unit id="905661856e09f20be385c26d6a37cee5d0959557" translate="yes" xml:space="preserve">
          <source>B-tree index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 上のBツリーインデックス： &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdeef32a168111374c1be4cd04224fef89dc4b4b" translate="yes" xml:space="preserve">
          <source>B-tree index pages that have become completely empty are reclaimed for re-use. However, there is still a possibility of inefficient use of space: if all but a few index keys on a page have been deleted, the page remains allocated. Therefore, a usage pattern in which most, but not all, keys in each range are eventually deleted will see poor use of space. For such usage patterns, periodic reindexing is recommended.</source>
          <target state="translated">完全に空になったB-treeインデックスページは、再利用のために再利用されます。しかし、スペースの非効率的な使用の可能性もあります。あるページのインデックスキーが少数のキーを除いてすべて削除された場合、そのページは割り当てられたままになります。したがって、各範囲のキーのうち、すべてではないがほとんどのキーが最終的に削除されてしまうような利用パターンでは、スペースの使用効率が悪くなります。このような使用パターンでは、定期的なインデックスの再作成が推奨されます。</target>
        </trans-unit>
        <trans-unit id="065de2528617033a42220233cd1c35a251757908" translate="yes" xml:space="preserve">
          <source>B-tree indexes additionally accept this parameter:</source>
          <target state="translated">B-tree インデックスは、このパラメータも受け付けます。</target>
        </trans-unit>
        <trans-unit id="b33f3c038c507d02cde94014e083413eba3062f2" translate="yes" xml:space="preserve">
          <source>B-tree indexes can also be used to retrieve data in sorted order. This is not always faster than a simple scan and sort, but it is often helpful.</source>
          <target state="translated">B-treeインデックスは、ソートされた順序でデータを取得するために使用することもできます。これは、単純なスキャンやソートよりも常に速くなるわけではありませんが、しばしば役立ちます。</target>
        </trans-unit>
        <trans-unit id="c1aa64fe8a588b4b8c3bb44a5ae5f195209958ec" translate="yes" xml:space="preserve">
          <source>B-tree version number</source>
          <target state="translated">B-treeのバージョン番号</target>
        </trans-unit>
        <trans-unit id="ee82358aad15ad2f88908ab7225b36322cd1065a" translate="yes" xml:space="preserve">
          <source>B-tree, GiST and SP-GiST indexes</source>
          <target state="translated">B-tree、GiST、SP-GiSTインデックス</target>
        </trans-unit>
        <trans-unit id="16921be12274c9c7c84517bda5d89a5ff3df5941" translate="yes" xml:space="preserve">
          <source>B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators:</source>
          <target state="translated">B-木は、何らかの順序に並べ替えることができるデータの等値性問い合わせや範囲問い合わせを扱うことができます。特に、PostgreSQLの問い合わせプランナは、これらの演算子の1つを使用した比較にインデックス付きの列が関与している場合、B-treeインデックスを使用することを検討します。</target>
        </trans-unit>
        <trans-unit id="90fe59b25bb93f64682a57a1af270b45d31afdca" translate="yes" xml:space="preserve">
          <source>B.1. Date/Time Input Interpretation</source>
          <target state="translated">B.1.日付/時間入力の解釈</target>
        </trans-unit>
        <trans-unit id="9899d2230f4a93f14e01b57b593ac9983fb8a83d" translate="yes" xml:space="preserve">
          <source>B.2. Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">B.2.無効または曖昧なタイムスタンプの処理</target>
        </trans-unit>
        <trans-unit id="3840db4e415d986c6609f0316669636755ab2262" translate="yes" xml:space="preserve">
          <source>B.3. Date/Time Key Words</source>
          <target state="translated">B.3.日付・時間キーワード</target>
        </trans-unit>
        <trans-unit id="922ab4c02bf090b11d909a4d188dbe702c610716" translate="yes" xml:space="preserve">
          <source>B.4. Date/Time Configuration Files</source>
          <target state="translated">B.4.日付/時刻設定ファイル</target>
        </trans-unit>
        <trans-unit id="58922b284be009208c01702b42070c1a181d5b29" translate="yes" xml:space="preserve">
          <source>B.5. History of Units</source>
          <target state="translated">B.5.単位の歴史</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="e87cf2c2aaae478fefafcf671d30d2bd91ab190c" translate="yes" xml:space="preserve">
          <source>BEGIN &amp;mdash; start a transaction block</source>
          <target state="translated">BEGIN &amp;mdash;トランザクションブロックを開始する</target>
        </trans-unit>
        <trans-unit id="e3b1705472dc241e491b245a0698901129b83705" translate="yes" xml:space="preserve">
          <source>BIGNUM math</source>
          <target state="translated">バイグナム数学</target>
        </trans-unit>
        <trans-unit id="c7854587bf0a26f0dd0236c46e64d140a0d9aa2a" translate="yes" xml:space="preserve">
          <source>BKI</source>
          <target state="translated">BKI</target>
        </trans-unit>
        <trans-unit id="a8e02c60c1fbe70ac08216f4d50adb47cd1b1f47" translate="yes" xml:space="preserve">
          <source>BREs differ from EREs in several respects. In BREs, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;?&lt;/code&gt; are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are &lt;code&gt;\{&lt;/code&gt; and &lt;code&gt;\}&lt;/code&gt;, with &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; by themselves ordinary characters. The parentheses for nested subexpressions are &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt;, with &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; by themselves ordinary characters. &lt;code&gt;^&lt;/code&gt; is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, &lt;code&gt;$&lt;/code&gt; is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and &lt;code&gt;*&lt;/code&gt; is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading &lt;code&gt;^&lt;/code&gt;). Finally, single-digit back references are available, and &lt;code&gt;\&amp;lt;&lt;/code&gt; and &lt;code&gt;\&amp;gt;&lt;/code&gt; are synonyms for &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; respectively; no other escapes are available in BREs.</source>
          <target state="translated">BREはEREといくつかの点で異なります。 BREでは、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;+&lt;/code&gt; 、および &lt;code&gt;?&lt;/code&gt; 通常の文字であり、それらの機能に相当するものはありません。境界の区切り文字は &lt;code&gt;\{&lt;/code&gt; および &lt;code&gt;\}&lt;/code&gt; で、 &lt;code&gt;{&lt;/code&gt; および &lt;code&gt;}&lt;/code&gt; 自体は通常の文字です。ネストされた部分式の括弧は &lt;code&gt;\(&lt;/code&gt; と &lt;code&gt;\)&lt;/code&gt; で、 &lt;code&gt;(&lt;/code&gt; と &lt;code&gt;)&lt;/code&gt; 自体は通常の文字です。 &lt;code&gt;^&lt;/code&gt; は、REの先頭または括弧で囲まれた部分式の先頭を除いて、通常の文字です &lt;code&gt;$&lt;/code&gt; REの終わりまたはかっこで囲まれた部分式の終わりを除いて通常の文字です。 &lt;code&gt;*&lt;/code&gt; がREの始めまたはかっこで囲まれた部分式の始まり（先頭の &lt;code&gt;^&lt;/code&gt; の後にある可能性があります）にある場合、通常の文字です。最後に、1桁の後方参照が利用可能で、 &lt;code&gt;\&amp;lt;&lt;/code&gt; と &lt;code&gt;\&amp;gt;&lt;/code&gt; はそれぞれ &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; と &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; の同義語です。 BREでは他のエスケープは使用できません。</target>
        </trans-unit>
        <trans-unit id="b45363f80402fee41de7af6a2bc3803bd8fcc804" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Built-in Operator Classes</source>
          <target state="translated">BRINインデックス。組込み演算子クラス</target>
        </trans-unit>
        <trans-unit id="610805949da9a921d5d35ddef0174271633dc849" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Extensibility</source>
          <target state="translated">BRINインデックス。拡張性</target>
        </trans-unit>
        <trans-unit id="e9ea37807ed02774eb4219265e764033548569ae" translate="yes" xml:space="preserve">
          <source>BRIN indexes (a shorthand for Block Range INdexes) store summaries about the values stored in consecutive physical block ranges of a table. Like GiST, SP-GiST and GIN, BRIN can support many different indexing strategies, and the particular operators with which a BRIN index can be used vary depending on the indexing strategy. For data types that have a linear sort order, the indexed data corresponds to the minimum and maximum values of the values in the column for each block range. This supports indexed queries using these operators:</source>
          <target state="translated">BRINインデックス(Block Range INdexesの略語)は、テーブルの連続する物理ブロック範囲に格納された値のサマリーを格納します。GiST、SP-GIST、GINと同様に、BRINは多くの異なるインデックス化戦略をサポートすることができ、BRINインデックスが使用できる特定の演算子はインデックス化戦略に応じて異なります。線形ソート順を持つデータ型の場合、インデックス化されたデータは、各ブロック範囲の列内の値の最小値と最大値に対応します。これは、これらの演算子を使用してインデックス化されたクエリをサポートしています。</target>
        </trans-unit>
        <trans-unit id="192104c1f501554301510ea5a728a13a08ab43a4" translate="yes" xml:space="preserve">
          <source>BRIN indexes accept different parameters:</source>
          <target state="translated">BRINインデックスは異なるパラメータを受け入れます。</target>
        </trans-unit>
        <trans-unit id="b838c564f224f8b8543683d11eed0d0437e44e11" translate="yes" xml:space="preserve">
          <source>BRIN indexes can satisfy queries via regular bitmap index scans, and will return all tuples in all pages within each range if the summary info stored by the index is &lt;em&gt;consistent&lt;/em&gt; with the query conditions. The query executor is in charge of rechecking these tuples and discarding those that do not match the query conditions &amp;mdash; in other words, these indexes are lossy. Because a BRIN index is very small, scanning the index adds little overhead compared to a sequential scan, but may avoid scanning large parts of the table that are known not to contain matching tuples.</source>
          <target state="translated">BRINインデックスは、通常のビットマップインデックススキャンを介してクエリを満たすことができ、インデックスによって保存された要約情報がクエリ条件と&lt;em&gt;一致&lt;/em&gt;している場合、各範囲内のすべてのページのすべてのタプルを返します。クエリエグゼキュータは、これらのタプルの再チェックとクエリ条件に一致しないタプルの破棄を担当します。つまり、これらのインデックスは損失を伴います。 BRINインデックスは非常に小さいため、インデックスをスキャンしても、シーケンシャルスキャンに比べてオーバーヘッドはほとんど追加されませんが、一致するタプルが含まれていないことがわかっているテーブルの大部分をスキャンしないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="55b3c9c4efac0d4d71eaa3d4c8cc93a475582a37" translate="yes" xml:space="preserve">
          <source>BRIN stands for Block Range Index. BRIN is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table. A &lt;em&gt;block range&lt;/em&gt; is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index. For example, a table storing a store's sale orders might have a date column on which each order was placed, and most of the time the entries for earlier orders will appear earlier in the table as well; a table storing a ZIP code column might have all codes for a city grouped together naturally.</source>
          <target state="translated">BRINはBlock Range Indexの略です。 BRINは、特定の列がテーブル内の物理的な位置と自然に相関している非常に大きなテーブルを処理するために設計されています。&lt;em&gt;ブロック範囲は、&lt;/em&gt;テーブル内の物理的に隣接しているページのグループです。各ブロック範囲について、いくつかの要約情報がインデックスによって保存されます。たとえば、ストアの販売注文を格納するテーブルには、各注文が行われた日付列があり、ほとんどの場合、以前の注文のエントリもテーブルの前に表示されます。郵便番号列を格納するテーブルには、都市のすべてのコードが自然にグループ化されている場合があります。</target>
        </trans-unit>
        <trans-unit id="c5bca0a807cb4e3535b6c51a06c3bccf47631d7c" translate="yes" xml:space="preserve">
          <source>BSD Authentication</source>
          <target state="translated">BSD 認証</target>
        </trans-unit>
        <trans-unit id="f1a97c299183923139e5920b8bda3da33aa50cdf" translate="yes" xml:space="preserve">
          <source>BSD Authentication in PostgreSQL uses the &lt;code&gt;auth-postgresql&lt;/code&gt; login type and authenticates with the &lt;code&gt;postgresql&lt;/code&gt; login class if that's defined in &lt;code&gt;login.conf&lt;/code&gt;. By default that login class does not exist, and PostgreSQL will use the default login class.</source>
          <target state="translated">PostgreSQLのBSD認証は、 &lt;code&gt;auth-postgresql&lt;/code&gt; ログインタイプを使用し、 &lt;code&gt;login.conf&lt;/code&gt; で定義されている場合、 &lt;code&gt;postgresql&lt;/code&gt; ログインクラスで認証します。デフォルトでは、そのログインクラスは存在せず、PostgreSQLはデフォルトのログインクラスを使用します。</target>
        </trans-unit>
        <trans-unit id="99affebb8bc98ca77c8c04882ebec0dea90a3114" translate="yes" xml:space="preserve">
          <source>Backend Interface</source>
          <target state="translated">バックエンドインタフェース</target>
        </trans-unit>
        <trans-unit id="60f8490b7625580e80d17d5a1df23b1d4de6ebc4" translate="yes" xml:space="preserve">
          <source>Backslash &lt;code&gt;x&lt;/code&gt; followed by one or two hex digits specifies the character with that numeric code</source>
          <target state="translated">バックスラッシュ &lt;code&gt;x&lt;/code&gt; の後に1桁または2桁の16進数が続き、その数値コードの文字を指定します</target>
        </trans-unit>
        <trans-unit id="f71436b4e34992baf3c146d9f7bcd610fe7bd64e" translate="yes" xml:space="preserve">
          <source>Backslash Escape Sequence</source>
          <target state="translated">バックスラッシュエスケープシーケンス</target>
        </trans-unit>
        <trans-unit id="08da95faebff9b822ea5284de54543cc7bd092f0" translate="yes" xml:space="preserve">
          <source>Backslash characters (&lt;code&gt;\&lt;/code&gt;) can be used in the &lt;code&gt;COPY&lt;/code&gt; data to quote data characters that might otherwise be taken as row or column delimiters. In particular, the following characters &lt;em&gt;must&lt;/em&gt; be preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character.</source>
          <target state="translated">バックスラッシュ文字（ &lt;code&gt;\&lt;/code&gt; ）を &lt;code&gt;COPY&lt;/code&gt; データで使用して、行または列の区切り文字として使用される可能性のあるデータ文字を引用できます。特に、列の値の一部として表示される場合、バックスラッシュ自体、改行、復帰、および現在の区切り文字の前にバックスラッシュを付ける&lt;em&gt;必要&lt;/em&gt;があります。</target>
        </trans-unit>
        <trans-unit id="79f7f8eb79d3eb20be7d5f2fdb2c6cb1e00c749f" translate="yes" xml:space="preserve">
          <source>Backslash followed by one to three octal digits specifies the character with that numeric code</source>
          <target state="translated">バックスラッシュの後に1~3桁の8進数が続く場合は、その数値コードを持つ文字を指定します。</target>
        </trans-unit>
        <trans-unit id="7b77925a9192b55418069493a221c26ff154c448" translate="yes" xml:space="preserve">
          <source>Backslash-semicolon is not a meta-command in the same way as the preceding commands; rather, it simply causes a semicolon to be added to the query buffer without any further processing.</source>
          <target state="translated">Backslash-semicolonは、前述のコマンドと同じようにメタコマンドではなく、単にセミコロンをクエリバッファに追加するだけです。</target>
        </trans-unit>
        <trans-unit id="3415ee42fbdf165d3ab63673dafeffa9121924ae" translate="yes" xml:space="preserve">
          <source>Backspace (ASCII 8)</source>
          <target state="translated">バックスペース(ASCII 8</target>
        </trans-unit>
        <trans-unit id="a5932464fe7ee7685cdde1f28a54e89455da1784" translate="yes" xml:space="preserve">
          <source>Backup and Restore</source>
          <target state="translated">バックアップとリストア</target>
        </trans-unit>
        <trans-unit id="86e2f1a9ee8c86cb8243f522b50b65e6423c34d6" translate="yes" xml:space="preserve">
          <source>Backward compatibility syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; システム列を削除するための下位互換性構文。以下のよう &lt;code&gt;oid&lt;/code&gt; システム列はもう追加することはできません、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="3ea614d7d0d66375e7b59ad1603ddbf9c6954a56" translate="yes" xml:space="preserve">
          <source>Backward fetches are also disallowed when the query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;; therefore &lt;code&gt;SCROLL&lt;/code&gt; may not be specified in this case.</source>
          <target state="translated">クエリに &lt;code&gt;FOR UPDATE&lt;/code&gt; または &lt;code&gt;FOR SHARE&lt;/code&gt; が含まれている場合も、後方フェッチは許可されません。したがって、この場合、 &lt;code&gt;SCROLL&lt;/code&gt; は指定できません。</target>
        </trans-unit>
        <trans-unit id="92077d51292270928790f0d07fb2a1301d60ee31" translate="yes" xml:space="preserve">
          <source>Backward-compatible syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; システム列を削除するための下位互換性のある構文。以下のよう &lt;code&gt;oid&lt;/code&gt; システム列はもう追加することはできません、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="044409ea2cd85fda028f96eed9a84a9fcc920931" translate="yes" xml:space="preserve">
          <source>Baltic</source>
          <target state="translated">Baltic</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">ベースタイプ</target>
        </trans-unit>
        <trans-unit id="7d67a1e0565652b8a1f39922bf439ec06adfe28a" translate="yes" xml:space="preserve">
          <source>Basically a thesaurus dictionary replaces all non-preferred terms by one preferred term and, optionally, preserves the original terms for indexing as well. PostgreSQL's current implementation of the thesaurus dictionary is an extension of the synonym dictionary with added &lt;em&gt;phrase&lt;/em&gt; support. A thesaurus dictionary requires a configuration file of the following format:</source>
          <target state="translated">基本的に、シソーラス辞書は、すべての非優先用語を1つの優先用語で置き換え、オプションで、索引付けのために元の用語も保持します。PostgreSQLのシソーラスディクショナリの現在の実装は、同義語ディクショナリの拡張で、&lt;em&gt;フレーズの&lt;/em&gt;サポートが追加されています。シソーラス辞書には、次の形式の構成ファイルが必要です。</target>
        </trans-unit>
        <trans-unit id="e1ddc988e6d784f9a638904386d7cd96020404d0" translate="yes" xml:space="preserve">
          <source>Batching WAL files so that they are transferred every three hours, rather than one at a time</source>
          <target state="translated">WALファイルを一度に1つではなく、3時間ごとに転送するようにバッチ処理する</target>
        </trans-unit>
        <trans-unit id="56ac908a2429c8b6f57e6b53eb261c2b37853b9f" translate="yes" xml:space="preserve">
          <source>Be aware however that such a query will be very inefficient.</source>
          <target state="translated">ただし、このようなクエリは非常に効率が悪いので注意が必要です。</target>
        </trans-unit>
        <trans-unit id="dd8576c5e404ad1333289b223aeb849843ea4d63" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;COPY&lt;/code&gt; ignores rules. If you want to use &lt;code&gt;COPY&lt;/code&gt; to insert data, you'll need to copy into the correct child table rather than directly into the master. &lt;code&gt;COPY&lt;/code&gt; does fire triggers, so you can use it normally if you use the trigger approach.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; はルールを無視することに注意してください。 &lt;code&gt;COPY&lt;/code&gt; を使用してデータを挿入する場合は、マスターに直接コピーするのではなく、正しい子テーブルにコピーする必要があります。 &lt;code&gt;COPY&lt;/code&gt; はトリガーを起動するので、トリガーアプローチを使用すれば通常どおり使用できます。</target>
        </trans-unit>
        <trans-unit id="3ec6516cf2acdacef6ec02909f23a042de655757" translate="yes" xml:space="preserve">
          <source>Be careful that the names and types of the view's columns will be assigned the way you want. For example:</source>
          <target state="translated">ビューのカラムの名前とタイプが希望通りに割り当てられるように注意してください。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2ecd0bd78d58da0c631755bb828f27e267549d1c" translate="yes" xml:space="preserve">
          <source>Be careful to specify the schema in which you installed the existing &lt;code&gt;hstore&lt;/code&gt; objects.</source>
          <target state="translated">既存の &lt;code&gt;hstore&lt;/code&gt; オブジェクトをインストールしたスキーマを指定するように注意してください。</target>
        </trans-unit>
        <trans-unit id="3286148c08a1b92253bcb1e687624659972203da" translate="yes" xml:space="preserve">
          <source>Be careful with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. There is no concept of inheritance for the privileges of a &lt;code&gt;CREATEROLE&lt;/code&gt;-role. That means that even if a role does not have a certain privilege but is allowed to create other roles, it can easily create another role with different privileges than its own (except for creating roles with superuser privileges). For example, if the role &amp;ldquo;user&amp;rdquo; has the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege but not the &lt;code&gt;CREATEDB&lt;/code&gt; privilege, nonetheless it can create a new role with the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. Therefore, regard roles that have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege as almost-superuser-roles.</source>
          <target state="translated">&lt;code&gt;CREATEROLE&lt;/code&gt; 特権に注意してください。 &lt;code&gt;CREATEROLE&lt;/code&gt; -ロールの特権の継承の概念はありません。つまり、特定の権限がなくても他のロールの作成が許可されている場合でも、自分のロールとは異なる権限を持つ別のロールを簡単に作成できます（スーパーユーザー権限を持つロールの作成を除く）。役割「ユーザが」持っている場合たとえば、 &lt;code&gt;CREATEROLE&lt;/code&gt; の特権ではなく、 &lt;code&gt;CREATEDB&lt;/code&gt; の権限を、それにもかかわらず、それが持つ新しい役割を作成することができます &lt;code&gt;CREATEDB&lt;/code&gt; の権限を。したがって、 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、ほぼスーパーユーザーのロールと見なしてください。</target>
        </trans-unit>
        <trans-unit id="e9a084e06d49f90e432ff228c5d493ff5d910d84" translate="yes" xml:space="preserve">
          <source>Be certain that your backup includes all of the files under the database cluster directory (e.g., &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;). If you are using tablespaces that do not reside underneath this directory, be careful to include them as well (and be sure that your backup archives symbolic links as links, otherwise the restore will corrupt your tablespaces).</source>
          <target state="translated">バックアップには、データベースクラスターディレクトリ（たとえば、 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; ）の下のすべてのファイルが含まれていることを確認してください。このディレクトリの下にないテーブルスペースを使用している場合は、それらも含めるように注意してください（バックアップがシンボリックリンクをリンクとしてアーカイブすることを確認してください。そうしないと、復元によってテーブルスペースが破損します）。</target>
        </trans-unit>
        <trans-unit id="8050bf055d69a2c17aebfa6f23142af8cc972e31" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;...&lt;/code&gt; is widely used in data sources, it is allowed as an alternative spelling of &lt;code&gt;..&lt;/code&gt;. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; はデータソースで広く使用されているため、..。の代替スペルとして使用でき &lt;code&gt;..&lt;/code&gt; 。残念ながら、これにより解析のあいまいさが生じます &lt;code&gt;0...23&lt;/code&gt; 上限が &lt;code&gt;23&lt;/code&gt; であるのか、 &lt;code&gt;0.23&lt;/code&gt; であるのかが明確ではありません。これは、 &lt;code&gt;seg&lt;/code&gt; 入力のすべての数値で、小数点の前に少なくとも1桁を必要とすることで解決されます。</target>
        </trans-unit>
        <trans-unit id="786d48aa791887748b32e63ec202e2ae60a5fb6e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;CLUSTER&lt;/code&gt; remembers which indexes are clustered, one can cluster the tables one wants clustered manually the first time, then set up a periodic maintenance script that executes &lt;code&gt;CLUSTER&lt;/code&gt; without any parameters, so that the desired tables are periodically reclustered.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; はクラスター化されたインデックスを記憶しているため、最初に手動でクラスター化したいテーブルをクラスター化し、パラメーターなしで &lt;code&gt;CLUSTER&lt;/code&gt; を実行する定期的なメンテナンススクリプトを設定して、目的のテーブルを定期的に再クラスター化できます。</target>
        </trans-unit>
        <trans-unit id="483573a468db7932cd30d693208c560bce934759" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;float8&lt;/code&gt; has no meaningful &amp;ldquo;step&amp;rdquo;, we do not define a canonicalization function in this example.</source>
          <target state="translated">ので &lt;code&gt;float8&lt;/code&gt; 型は、意味のある「ステップ」を持っていない、我々は、この例では、正規化関数を定義していません。</target>
        </trans-unit>
        <trans-unit id="8c58240b228b0ae5aff4efd20c01cc67a3bd5a52" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; calls are never rolled back, sequence objects cannot be used if &amp;ldquo;gapless&amp;rdquo; assignment of sequence numbers is needed. It is possible to build gapless assignment by using exclusive locking of a table containing a counter; but this solution is much more expensive than sequence objects, especially if many transactions need sequence numbers concurrently.</source>
          <target state="translated">ので &lt;code&gt;nextval&lt;/code&gt; と &lt;code&gt;setval&lt;/code&gt; のコールがロールバックされることはありませんシーケンス番号の「ギャップレス」の割り当てが必要な場合は、シーケンス・オブジェクトを使用することはできません。カウンタを含むテーブルの排他的ロックを使用することにより、ギャップのない割り当てを構築できます。しかし、このソリューションは、特に多くのトランザクションがシーケンス番号を同時に必要とする場合、シーケンスオブジェクトよりもはるかに高価です。</target>
        </trans-unit>
        <trans-unit id="57fa06eff5bff23d9975c881fe012eee591895a8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;smallserial&lt;/code&gt; 、 &lt;code&gt;serial&lt;/code&gt; 、および &lt;code&gt;bigserial&lt;/code&gt; はシーケンスを使用して実装されているため、行が削除されていなくても、列に表示される値のシーケンスに「穴」またはギャップがある場合があります。シーケンスから割り当てられた値は、その値を含む行がテーブル列に正常に挿入されなかった場合でも、「使い果たされ」ます。これは、たとえば、挿入トランザクションがロールバックした場合に発生する可能性があります。詳細は、&lt;a href=&quot;functions-sequence&quot;&gt;9.16&lt;/a&gt;項の &lt;code&gt;nextval()&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="2055271ae8273a98d1c3120c9ad69e5bbb4dabd7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;to_tsvector&lt;/code&gt;(&lt;code&gt;NULL&lt;/code&gt;) will return &lt;code&gt;NULL&lt;/code&gt;, it is recommended to use &lt;code&gt;coalesce&lt;/code&gt; whenever a field might be null. Here is the recommended method for creating a &lt;code&gt;tsvector&lt;/code&gt; from a structured document:</source>
          <target state="translated">ので &lt;code&gt;to_tsvector&lt;/code&gt; （ &lt;code&gt;NULL&lt;/code&gt; が）を返します &lt;code&gt;NULL&lt;/code&gt; を、使用することをお勧めします &lt;code&gt;coalesce&lt;/code&gt; フィールドがヌルであるかもしれない時はいつでも。次に、構造化ドキュメントから &lt;code&gt;tsvector&lt;/code&gt; を作成するための推奨方法を示します。</target>
        </trans-unit>
        <trans-unit id="e67190c3b34212fbd9608f10ce1643e97f3b598d" translate="yes" xml:space="preserve">
          <source>Because JSON containment is nested, an appropriate query can skip explicit selection of sub-objects. As an example, suppose that we have a &lt;code&gt;doc&lt;/code&gt; column containing objects at the top level, with most objects containing &lt;code&gt;tags&lt;/code&gt; fields that contain arrays of sub-objects. This query finds entries in which sub-objects containing both &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; and &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; appear, while ignoring any such keys outside the &lt;code&gt;tags&lt;/code&gt; array:</source>
          <target state="translated">JSON包含はネストされているため、適切なクエリはサブオブジェクトの明示的な選択をスキップできます。例として、最上位のオブジェクトを含む &lt;code&gt;doc&lt;/code&gt; 列があり、サブオブジェクトの配列を含む &lt;code&gt;tags&lt;/code&gt; フィールドを含むほとんどのオブジェクトがあるとします。このクエリは、 &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; と &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; の両方を含むサブオブジェクトが表示されるエントリを検索しますが、 &lt;code&gt;tags&lt;/code&gt; 配列の外部にあるそのようなキーは無視します。</target>
        </trans-unit>
        <trans-unit id="9a6a9b9301894dfb915e7f65b2cfd52739126757" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL does not require constraint names to be unique within a schema (but only per-table), it is possible that there is more than one match for a specified constraint name. In this case &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; will act on all matches. For a non-schema-qualified name, once a match or matches have been found in some schema in the search path, schemas appearing later in the path are not searched.</source>
          <target state="translated">PostgreSQLは制約名がスキーマ内で一意である必要はないが（テーブルごとだけである）、指定された制約名に複数の一致がある可能性があります。この場合、 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; はすべての一致に作用します。スキーマ修飾されていない名前の場合、検索パスの一部のスキーマで1つ以上の一致が見つかると、パスの後ろにあるスキーマは検索されません。</target>
        </trans-unit>
        <trans-unit id="1054531abd84ea6ab456598b0cbf13df62bd8f3f" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities.</source>
          <target state="translated">PostgreSQLはオープンソースで拡張が容易なため、多くの企業がPostgreSQLを採用し、独自のフェイルオーバー、レプリケーション、ロードバランシング機能を備えた商用のクローズドソースソリューションを作成しています。</target>
        </trans-unit>
        <trans-unit id="7c927394e6733d9a2cd5092ccd59b8f1d233eaee" translate="yes" xml:space="preserve">
          <source>Because Read Committed mode starts each command with a new snapshot that includes all transactions committed up to that instant, subsequent commands in the same transaction will see the effects of the committed concurrent transaction in any case. The point at issue above is whether or not a &lt;em&gt;single&lt;/em&gt; command sees an absolutely consistent view of the database.</source>
          <target state="translated">コミット読み取りモードは、その瞬間までにコミットされたすべてのトランザクションを含む新しいスナップショットで各コマンドを開始するため、同じトランザクション内の後続のコマンドは、いずれの場合でも、コミットされた同時トランザクションの影響を確認します。上記の問題点は、&lt;em&gt;単一の&lt;/em&gt;コマンドがデータベースの完全に一貫したビューを見るかどうかです。</target>
        </trans-unit>
        <trans-unit id="cb5cad886e41acd11550eebbf5881fb1ea7474ee" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g. &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="translated">WALはクラッシュ後にデータベースファイルの内容を復元するため、ジャーナルファイルシステムは、データファイルまたはWALファイルの信頼性の高いストレージには必要ありません。実際、ジャーナリングによってファイルシステム&lt;em&gt;データ&lt;/em&gt;がディスクにフラッシュされる場合は特に、ジャーナリングのオーバーヘッドによってパフォーマンスが低下する可能性があります。幸い、ジャーナリング中のデータのフラッシュは、ファイルシステムのマウントオプションで無効にできることがよくあります（例：Linux ext3ファイルシステムの &lt;code&gt;data=writeback&lt;/code&gt; ）。ジャーナルファイルシステムは、クラッシュ後の起動速度を向上させます。</target>
        </trans-unit>
        <trans-unit id="af002f2ced30c87d8ca2cfc786b9d6c148a8b054" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;SECURITY DEFINER&lt;/code&gt; function is executed with the privileges of the user that owns it, care is needed to ensure that the function cannot be misused. For security, &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; should be set to exclude any schemas writable by untrusted users. This prevents malicious users from creating objects (e.g., tables, functions, and operators) that mask objects intended to be used by the function. Particularly important in this regard is the temporary-table schema, which is searched first by default, and is normally writable by anyone. A secure arrangement can be obtained by forcing the temporary schema to be searched last. To do this, write &lt;code&gt;pg_temp&lt;/code&gt; as the last entry in &lt;code&gt;search_path&lt;/code&gt;. This function illustrates safe usage:</source>
          <target state="translated">ので &lt;code&gt;SECURITY DEFINER&lt;/code&gt; の機能は、それを所有するユーザの権限で実行され、注意が機能が悪用されることができないことを保証するために必要とされます。セキュリティを確保するために、信頼できないユーザーが書き込み可能なスキーマを除外するように&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;を設定する必要があります。これにより、悪意のあるユーザーが、関数での使用を目的としたオブジェクトをマスクするオブジェクト（テーブル、関数、演算子など）を作成することを防ぎます。この点で特に重要なのは、デフォルトで最初に検索され、通常誰でも書き込み可能な一時テーブルスキーマです。一時スキーマを最後に検索するように強制することにより、安全な配置を得ることができます。これを行うには、 &lt;code&gt;search_path&lt;/code&gt; の最後のエントリとして &lt;code&gt;pg_temp&lt;/code&gt; を記述します。この関数は、安全な使用法を示しています。</target>
        </trans-unit>
        <trans-unit id="7ccf103cb4c217d06785a0ccdc57267c861dec31" translate="yes" xml:space="preserve">
          <source>Because backslash is not a special character in the &lt;code&gt;CSV&lt;/code&gt; format, &lt;code&gt;\.&lt;/code&gt;, the end-of-data marker, could also appear as a data value. To avoid any misinterpretation, a &lt;code&gt;\.&lt;/code&gt; data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data marker. If you are loading a file created by another application that has a single unquoted column and might have a value of &lt;code&gt;\.&lt;/code&gt;, you might need to quote that value in the input file.</source>
          <target state="translated">バックスラッシュは &lt;code&gt;CSV&lt;/code&gt; 形式の特殊文字ではないため、 &lt;code&gt;\.&lt;/code&gt; データ終了マーカーであるは、データ値としても表示されます。誤解を避けるために、 &lt;code&gt;\.&lt;/code&gt; 行の唯一のエントリとして表示されるデータ値は、出力時に自動的に引用され、入力時に引用された場合、データの終わりマーカーとして解釈されません。引用符で囲まれていない単一の列を持ち、 &lt;code&gt;\.&lt;/code&gt; 値を持つ可能性がある別のアプリケーションによって作成されたファイルをロードする場合。、入力ファイルでその値を引用する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="8837df7b2c1fb8da3ce2a114226b6b81d22d5575" translate="yes" xml:space="preserve">
          <source>Because column &lt;code&gt;y&lt;/code&gt; is not part of the index's search key, it does not have to be of a data type that the index can handle; it's merely stored in the index and is not interpreted by the index machinery. Also, if the index is a unique index, that is</source>
          <target state="translated">列 &lt;code&gt;y&lt;/code&gt; はインデックスの検索キーの一部ではないため、インデックスが処理できるデータ型である必要はありません。それは単にインデックスに格納され、インデックス機構によって解釈されません。また、インデックスが一意のインデックスである場合、つまり</target>
        </trans-unit>
        <trans-unit id="3d96d2addf447433c224777bf906ab67b3fda87a" translate="yes" xml:space="preserve">
          <source>Because custom options may need to be set in processes that have not loaded the relevant extension module, PostgreSQL will accept a setting for any two-part parameter name. Such variables are treated as placeholders and have no function until the module that defines them is loaded. When an extension module is loaded, it will add its variable definitions, convert any placeholder values according to those definitions, and issue warnings for any unrecognized placeholders that begin with its extension name.</source>
          <target state="translated">カスタムオプションは、関連する拡張モジュールをロードしていないプロセスで設定する必要があるかもしれません。このような変数はプレースホルダとして扱われ、それらを定義するモジュールがロードされるまでは何の機能も持ちません。拡張モジュールがロードされると、その変数の定義を追加し、それらの定義に従ってプレースホルダの値を変換し、その拡張名で始まる認識されないプレースホルダに対して警告を発行します。</target>
        </trans-unit>
        <trans-unit id="501d8e61189d0ec14bdd409d7b3e2083ee96580b" translate="yes" xml:space="preserve">
          <source>Because each btree operator class imposes a sort order on its data type, btree operator classes (or, really, operator families) have come to be used as PostgreSQL's general representation and understanding of sorting semantics. Therefore, they've acquired some features that go beyond what would be needed just to support btree indexes, and parts of the system that are quite distant from the btree AM make use of them.</source>
          <target state="translated">各btree演算子クラスはそのデータ型にソート順を課しているため、btree演算子クラス(実際には演算子ファミリ)はPostgreSQLのソートセマンティクスの一般的な表現と理解として使用されるようになりました。そのため、単にbtreeインデックスをサポートするだけで必要とされる機能を超えたいくつかの機能を獲得しており、btree AMからかなり離れたシステムの一部ではそれを利用しています。</target>
        </trans-unit>
        <trans-unit id="1cf84fc42fc11690b4a8d7c72f78d6f59379bbaa" translate="yes" xml:space="preserve">
          <source>Because each worker executes the parallel portion of the plan to completion, it is not possible to simply take an ordinary query plan and run it using multiple workers. Each worker would produce a full copy of the output result set, so the query would not run any faster than normal but would produce incorrect results. Instead, the parallel portion of the plan must be what is known internally to the query optimizer as a &lt;em&gt;partial plan&lt;/em&gt;; that is, it must be constructed so that each process which executes the plan will generate only a subset of the output rows in such a way that each required output row is guaranteed to be generated by exactly one of the cooperating processes. Generally, this means that the scan on the driving table of the query must be a parallel-aware scan.</source>
          <target state="translated">各ワーカーはプランの並列部分を実行して完了するため、通常のクエリプランを単純に取得して、複数のワーカーを使用して実行することはできません。各ワーカーは出力結果セットの完全なコピーを生成するため、クエリは通常よりも速く実行されませんが、誤った結果が生成されます。代わりに、プランの並列部分は、クエリオプティマイザが内部&lt;em&gt;的に部分プラン&lt;/em&gt;として認識しているものでなければなりません。つまり、計画を実行する各プロセスが出力行のサブセットのみを生成し、必要な各出力行が協調プロセスの1つだけで生成されることが保証されるように構成する必要があります。通常、これは、クエリの駆動テーブルでのスキャンが並列対応スキャンでなければならないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f7c3975c53757320af8c077a7aa386b120a149d9" translate="yes" xml:space="preserve">
          <source>Because logical replication is based on a similar architecture as &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;physical streaming replication&lt;/a&gt;, the monitoring on a publication node is similar to monitoring of a physical replication master (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;Section 26.2.5.2&lt;/a&gt;).</source>
          <target state="translated">論理レプリケーションは&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;物理ストリーミングレプリケーション&lt;/a&gt;と同様のアーキテクチャに基づいているため、パブリケーションノードでの監視は物理レプリケーションマスターの監視と同様です（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;セクション26.2.5.2を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a2196adb2d7ec23f760e34a49d8237be649fa41e" translate="yes" xml:space="preserve">
          <source>Because of MVCC, it is always necessary to allow duplicate entries to exist physically in an index: the entries might refer to successive versions of a single logical row. The behavior we actually want to enforce is that no MVCC snapshot could include two rows with equal index keys. This breaks down into the following cases that must be checked when inserting a new row into a unique index:</source>
          <target state="translated">MVCCのため、インデックス内に物理的に重複したエントリが存在することを常に許容する必要があります。実際に強制したい動作は、MVCCスナップショットでは、同じインデックスキーを持つ2つの行を含むことができないということです。これは、一意のインデックスに新しい行を挿入する際にチェックしなければならない以下のケースに分けられます。</target>
        </trans-unit>
        <trans-unit id="92df70087fcf249f647fdf27a084f1becf03071e" translate="yes" xml:space="preserve">
          <source>Because of limited &lt;code&gt;maintenance_work_mem&lt;/code&gt;, &lt;code&gt;ambulkdelete&lt;/code&gt; might need to be called more than once when many tuples are to be deleted. The &lt;code&gt;stats&lt;/code&gt; argument is the result of the previous call for this index (it is NULL for the first call within a &lt;code&gt;VACUUM&lt;/code&gt; operation). This allows the AM to accumulate statistics across the whole operation. Typically, &lt;code&gt;ambulkdelete&lt;/code&gt; will modify and return the same struct if the passed &lt;code&gt;stats&lt;/code&gt; is not null.</source>
          <target state="translated">制限された &lt;code&gt;maintenance_work_mem&lt;/code&gt; のため、多くのタプルを削除する場合、 &lt;code&gt;ambulkdelete&lt;/code&gt; を複数回呼び出す必要がある場合があります。 &lt;code&gt;stats&lt;/code&gt; 引数がこのインデックスの前の呼び出しの結果である（それは内の最初の呼び出しのためにNULLである &lt;code&gt;VACUUM&lt;/code&gt; の動作）。これにより、AMは操作全体の統計を蓄積できます。通常、 &lt;code&gt;ambulkdelete&lt;/code&gt; は、渡された &lt;code&gt;stats&lt;/code&gt; がnullでない場合、同じ構造体を変更して返します。</target>
        </trans-unit>
        <trans-unit id="af06227e43627d5f9e3c80ba9b58e41dee4f1bd3" translate="yes" xml:space="preserve">
          <source>Because of the above rules, it is possible for an updating command to see an inconsistent snapshot: it can see the effects of concurrent updating commands on the same rows it is trying to update, but it does not see effects of those commands on other rows in the database. This behavior makes Read Committed mode unsuitable for commands that involve complex search conditions; however, it is just right for simpler cases. For example, consider updating bank balances with transactions like:</source>
          <target state="translated">上記のルールのため、更新コマンドは、更新しようとしている同じ行に対しては同時更新コマンドの効果を見ることができますが、データベース内の他の行に対してはそれらのコマンドの効果を見ることができません。この動作により、Read Committedモードは複雑な検索条件を含むコマンドには適していません。例えば、以下のようなトランザクションで銀行残高を更新することを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="094a085e303baa417739feb6622a057e4139e4ba" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it's unwise to give a function that takes a single composite-type argument the same name as any of the fields of that composite type. If there is ambiguity, the field-name interpretation will be chosen if field-name syntax is used, while the function will be chosen if function-call syntax is used. However, PostgreSQL versions before 11 always chose the field-name interpretation, unless the syntax of the call required it to be a function call. One way to force the function interpretation in older versions is to schema-qualify the function name, that is, write &lt;code&gt;schema.func(compositevalue)&lt;/code&gt;.</source>
          <target state="translated">この動作のため、単一の複合型引数を取る関数に、その複合型のフィールドのいずれかと同じ名前を付けることは賢明ではありません。あいまいな場合は、フィールド名の構文が使用されている場合はフィールド名の解釈が選択され、関数呼び出しの構文が使用されている場合は関数が選択されます。ただし、呼び出しの構文で関数呼び出しである必要がある場合を除いて、11より前のバージョンのPostgreSQLでは、常にフィールド名の解釈が選択されていました。古いバージョンでは機能の解釈を強制する一つの方法は、スキーマ修飾する関数名、書き込みにある &lt;code&gt;schema.func(compositevalue)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6916a8fbcc68029c3a341e8400e967ac545c917" translate="yes" xml:space="preserve">
          <source>Because of this behavior, putting more than one SQL command in a single &lt;code&gt;-c&lt;/code&gt; string often has unexpected results. It's better to use repeated &lt;code&gt;-c&lt;/code&gt; commands or feed multiple commands to psql's standard input, either using echo as illustrated above, or via a shell here-document, for example:</source>
          <target state="translated">この動作のため、1つの &lt;code&gt;-c&lt;/code&gt; 文字列に複数のSQLコマンドを入れると、予期しない結果になることがよくあります。上記のエコーを使用するか、シェルのヒアドキュメントを介して、 &lt;code&gt;-c&lt;/code&gt; コマンドを繰り返し使用するか、複数のコマンドをpsqlの標準入力にフィードすることをお勧めします。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="1e30503a8aa4dc4dd17e2394f194dfc73877aea7" translate="yes" xml:space="preserve">
          <source>Because of this convention of possibly renumbering OIDs assigned by patches, the OIDs assigned by a patch should not be considered stable until the patch has been included in an official release. We do not change manually-assigned object OIDs once released, however, as that would create assorted compatibility problems.</source>
          <target state="translated">パッチによって割り当てられた OID の番号が変更される可能性があるため、パッチによって割り当てられた OID は、そのパッチが公式リリースに含まれるまでは安定しているとは考えられません。しかし、一度リリースされたオブジェクトの OID を手動で変更することは、様々な互換性の問題を引き起こすことになるので、私たちは変更しません。</target>
        </trans-unit>
        <trans-unit id="167e13b17a2cb4d9e247d60e890e572062fe98da" translate="yes" xml:space="preserve">
          <source>Because of this indeterminacy, referencing other tables only within sub-selects is safer, though often harder to read and slower than using a join.</source>
          <target state="translated">このように不確定性があるため、サブセレクト内でのみ他のテーブルを参照する方が安全ですが、ジョインを使用するよりも読みにくく、時間がかかることがよくあります。</target>
        </trans-unit>
        <trans-unit id="71a8fc6262b2555f78a8d5aeb3468844fc9b3fb8" translate="yes" xml:space="preserve">
          <source>Because optimizer statistics are not transferred by &lt;code&gt;pg_upgrade&lt;/code&gt;, you will be instructed to run a command to regenerate that information at the end of the upgrade. You might need to set connection parameters to match your new cluster.</source>
          <target state="translated">オプティマイザ統計は &lt;code&gt;pg_upgrade&lt;/code&gt; によって転送されないため、アップグレードの最後にその情報を再生成するコマンドを実行するように指示されます。新しいクラスターに一致するように接続パラメーターを設定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="c35cef2d44681e7faa9cdda9938f800f990d4dc8" translate="yes" xml:space="preserve">
          <source>Because pg_dump is used to transfer data to newer versions of PostgreSQL, the output of pg_dump can be expected to load into PostgreSQL server versions newer than pg_dump's version. pg_dump can also dump from PostgreSQL servers older than its own version. (Currently, servers back to version 8.0 are supported.) However, pg_dump cannot dump from PostgreSQL servers newer than its own major version; it will refuse to even try, rather than risk making an invalid dump. Also, it is not guaranteed that pg_dump's output can be loaded into a server of an older major version &amp;mdash; not even if the dump was taken from a server of that version. Loading a dump file into an older server may require manual editing of the dump file to remove syntax not understood by the older server. Use of the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option is recommended in cross-version cases, as it can prevent problems arising from varying reserved-word lists in different PostgreSQL versions.</source>
          <target state="translated">pg_dumpは新しいバージョンのPostgreSQLにデータを転送するために使用されるため、pg_dumpの出力は、pg_dumpのバージョンより新しいPostgreSQLサーバーのバージョンにロードされることが期待できます。 pg_dumpは、自身のバージョンより古いPostgreSQLサーバーからダンプすることもできます。 （現在、バージョン8.0に戻るサーバーがサポートされています。）ただし、pg_dumpは、それ自体のメジャーバージョンより新しいPostgreSQLサーバーからダンプできません。無効なダンプを作成するリスクを負うのではなく、試行を拒否します。また、pg_dumpの出力が古いメジャーバージョンのサーバーに読み込まれることは保証されていません。そのバージョンのサーバーからダンプが取得された場合でも同様です。古いサーバーにダンプファイルをロードするには、古いサーバーで理解されていない構文を削除するために、ダンプファイルを手動で編集する必要がある場合があります。使用 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; このオプションは、異なるバージョンのPostgreSQLで予約語リストを変更することによって発生する問題を防ぐことができるため、クロスバージョンの場合に推奨されます。</target>
        </trans-unit>
        <trans-unit id="74ecae8ce7298adddc06312de549cde5a1f05bfd" translate="yes" xml:space="preserve">
          <source>Because roles can own database objects and can hold privileges to access other objects, dropping a role is often not just a matter of a quick &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. Any objects owned by the role must first be dropped or reassigned to other owners; and any permissions granted to the role must be revoked.</source>
          <target state="translated">ロールはデータベースオブジェクトを所有し、他のオブジェクトにアクセスする権限を保持できるため、ロールの削除は、簡単な&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLEの&lt;/a&gt;問題だけではありません。ロールが所有するオブジェクトは、最初に削除するか、他の所有者に再割り当てする必要があります。また、ロールに付与されているすべての権限を取り消す必要があります。</target>
        </trans-unit>
        <trans-unit id="3c6bd276df7f7795dcf1ec012b5fa318dae1fa92" translate="yes" xml:space="preserve">
          <source>Because sequences are non-transactional, changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="translated">シーケンスは非トランザクションであるため、トランザクションがロールバックしても、 &lt;code&gt;setval&lt;/code&gt; による変更は取り消されません。</target>
        </trans-unit>
        <trans-unit id="045cb510a11b664aff1ae0f9d4a4e6bf852e98a6" translate="yes" xml:space="preserve">
          <source>Because that day was a spring-forward transition date in that time zone, there was no civil time instant 2:30AM; clocks jumped forward from 2AM EST to 3AM EDT. PostgreSQL interprets the given time as if it were standard time (UTC-5), which then renders as 3:30AM EDT (UTC-4).</source>
          <target state="translated">その日はそのタイムゾーンでは春分移行日だったため、午前2時30分には市民時間は存在しませんでした。PostgreSQLは、与えられた時刻を標準時(UTC-5)であるかのように解釈し、3:30AM EDT(UTC-4)として表示します。</target>
        </trans-unit>
        <trans-unit id="a4c15eb3326253a984503903ababbb5a012e0e63" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node runs on the leader process, queries which produce a relatively large number of groups in comparison to the number of input rows will appear less favorable to the query planner. For example, in the worst-case scenario the number of groups seen by the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node could be as many as the number of input rows which were seen by all worker processes in the &lt;code&gt;Partial Aggregate&lt;/code&gt; stage. For such cases, there is clearly going to be no performance benefit to using parallel aggregation. The query planner takes this into account during the planning process and is unlikely to choose parallel aggregate in this scenario.</source>
          <target state="translated">ので &lt;code&gt;Finalize Aggregate&lt;/code&gt; ノードがリーダープロセス上で実行され、入力された行の数と比較してグループの比較的大きな数を生成クエリは、クエリプランナに不利表示されます。たとえば、最悪のシナリオでは、 &lt;code&gt;Finalize Aggregate&lt;/code&gt; ノードで表示されるグループの数は、 &lt;code&gt;Partial Aggregate&lt;/code&gt; ステージのすべてのワーカープロセスで表示される入力行の数と同じになります。このような場合、並列集計を使用してもパフォーマンス上のメリットは明らかにありません。クエリプランナーは、計画プロセス中にこれを考慮し、このシナリオでは並列集計を選択することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="c37bfc8193816ef9726582311c95eb690d59a5d3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;json&lt;/code&gt; type stores an exact copy of the input text, it will preserve semantically-insignificant white space between tokens, as well as the order of keys within JSON objects. Also, if a JSON object within the value contains the same key more than once, all the key/value pairs are kept. (The processing functions consider the last value as the operative one.) By contrast, &lt;code&gt;jsonb&lt;/code&gt; does not preserve white space, does not preserve the order of object keys, and does not keep duplicate object keys. If duplicate keys are specified in the input, only the last value is kept.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; タイプは入力テキストの正確なコピーを格納するため、トークン間の意味的に重要ではない空白と、JSONオブジェクト内のキーの順序が保持されます。また、値内のJSONオブジェクトに同じキーが複数含まれている場合、すべてのキーと値のペアが保持されます。 （処理関数は最後の値を有効な値と見なします。）対照的に、 &lt;code&gt;jsonb&lt;/code&gt; は空白を保持せず、オブジェクトキーの順序を保持せず、重複したオブジェクトキーを保持しません。入力で重複するキーが指定されている場合、最後の値のみが保持されます。</target>
        </trans-unit>
        <trans-unit id="a2b58f4e608829c960ebd5345ab5c69ff0a6f48c" translate="yes" xml:space="preserve">
          <source>Because the cache is shared by all the databases, there will normally be pages from relations not belonging to the current database. This means that there may not be matching join rows in &lt;code&gt;pg_class&lt;/code&gt; for some rows, or that there could even be incorrect joins. If you are trying to join against &lt;code&gt;pg_class&lt;/code&gt;, it's a good idea to restrict the join to rows having &lt;code&gt;reldatabase&lt;/code&gt; equal to the current database's OID or zero.</source>
          <target state="translated">キャッシュはすべてのデータベースで共有されるため、通常、現在のデータベースに属していないリレーションのページが存在します。これは、一部の行の &lt;code&gt;pg_class&lt;/code&gt; に一致する結合行がない可能性があること、または不正な結合でさえある可能性があることを意味します。 &lt;code&gt;pg_class&lt;/code&gt; に対して結合しようとしている場合は、現在のデータベースのOIDまたはゼロに等しい &lt;code&gt;reldatabase&lt;/code&gt; を持つ行に結合を制限することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="db3d427c20974c56be935e79b307fe146f033de0" translate="yes" xml:space="preserve">
          <source>Because the data directory contains all the data stored in the database, it is essential that it be secured from unauthorized access. &lt;code&gt;initdb&lt;/code&gt; therefore revokes access permissions from everyone but the PostgreSQL user, and optionally, group. Group access, when enabled, is read-only. This allows an unprivileged user in the same group as the cluster owner to take a backup of the cluster data or perform other operations that only require read access.</source>
          <target state="translated">データディレクトリにはデータベースに保存されているすべてのデータが含まれるため、不正アクセスから保護することが重要です。したがって、 &lt;code&gt;initdb&lt;/code&gt; は、PostgreSQLユーザー、およびオプションでグループ以外のすべてのユーザーからアクセス許可を取り消します。グループアクセスは、有効になっている場合、読み取り専用です。これにより、クラスター所有者と同じグループ内の非特権ユーザーは、クラスターデータのバックアップを取るか、読み取りアクセスのみを必要とする他の操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="1b1433bfc602856fd35d38e930969e2b25fd0ae1" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator class is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator class.</source>
          <target state="translated">インデックス機構は関数を使用する前に関数のアクセス許可をチェックしないので、関数や演算子を演算子クラスに含めることは、その関数や演算子に公開実行許可を与えることと同じことになります。これは通常、演算子クラスで有用な種類の関数については問題ではありません。</target>
        </trans-unit>
        <trans-unit id="12e05e286bda0df5f833a009aa68ad96a2c3e153" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator family is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator family.</source>
          <target state="translated">インデックス機構は、関数を使用する前に関数のアクセス許可をチェックしないので、関数や演算子を演算子ファミリに含めることは、その関数や演算子に公開実行許可を与えることに等しいです。これは通常、演算子ファミリの中で有用な種類の関数については問題になりません。</target>
        </trans-unit>
        <trans-unit id="05ce34a0d540aca4ce52a5f0344a9da290661688" translate="yes" xml:space="preserve">
          <source>Because the number of possible column combinations is very large, it's impractical to compute multivariate statistics automatically. Instead, &lt;em&gt;extended statistics objects&lt;/em&gt;, more often called just &lt;em&gt;statistics objects&lt;/em&gt;, can be created to instruct the server to obtain statistics across interesting sets of columns.</source>
          <target state="translated">可能な列の組み合わせの数は非常に多いため、多変量統計を自動的に計算することは現実的ではありません。代わりに、より多くの場合、単に&lt;em&gt;統計オブジェクト&lt;/em&gt;と呼ばれる&lt;em&gt;拡張統計オブジェクトを&lt;/em&gt;作成して、&lt;em&gt;対象&lt;/em&gt;の列のセット全体で統計を取得するようにサーバーに指示できます。</target>
        </trans-unit>
        <trans-unit id="4d0acad31e5ac16c376a00a683ae533e823a54c5" translate="yes" xml:space="preserve">
          <source>Because the planner records statistics about the ordering of tables, it is advisable to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the newly clustered table. Otherwise, the planner might make poor choices of query plans.</source>
          <target state="translated">プランナーはテーブルの順序に関する統計を記録するため、新しくクラスター化されたテーブルで&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行することをお勧めします。そうしないと、プランナがクエリプランを適切に選択できない可能性があります。</target>
        </trans-unit>
        <trans-unit id="2d35897de153aa519a54a8b8fb6f5606c68e7ee1" translate="yes" xml:space="preserve">
          <source>Because the two-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; was used in the index above, only a query reference that uses the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; with the same configuration name will use that index. That is, &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; can use the index, but &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; cannot. This ensures that an index will be used only with the same configuration used to create the index entries.</source>
          <target state="translated">上記のインデックスでは2引数バージョンの &lt;code&gt;to_tsvector&lt;/code&gt; が使用されたため、同じ構成名で2引数バージョンの &lt;code&gt;to_tsvector&lt;/code&gt; を使用するクエリ参照のみがそのインデックスを使用します。つまり、 &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; はインデックスを使用できますが、 &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; は使用できません。これにより、インデックスエントリの作成に使用したのと同じ構成でのみインデックスが使用されるようになります。</target>
        </trans-unit>
        <trans-unit id="3db556aa68ed6f557f519e10166a776c7f49e136" translate="yes" xml:space="preserve">
          <source>Because there are no restrictions on use of a data type once it's been created, creating a base type or range type is tantamount to granting public execute permission on the functions mentioned in the type definition. This is usually not an issue for the sorts of functions that are useful in a type definition. But you might want to think twice before designing a type in a way that would require &amp;ldquo;secret&amp;rdquo; information to be used while converting it to or from external form.</source>
          <target state="translated">一度作成されたデータ型の使用に制限はないため、基本型または範囲型を作成することは、型定義で言及されている関数にパブリック実行権限を付与することと同じです。これは通常、型定義で役立つ種類の関数の問題ではありません。しかし、タイプを設計する前に、「秘密」の情報を外部フォームに変換したり、外部フォームから変換したりするために、その情報を使用する必要があるように考える必要があります。</target>
        </trans-unit>
        <trans-unit id="21ceed46db3017cd5cd38ced3fddd77a8ce650db" translate="yes" xml:space="preserve">
          <source>Because these functions return detailed page-level information, access is restricted by default. By default, only the role &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; has &lt;code&gt;EXECUTE&lt;/code&gt; privilege. Superusers of course bypass this restriction. After the extension has been installed, users may issue &lt;code&gt;GRANT&lt;/code&gt; commands to change the privileges on the functions to allow others to execute them. However, it might be preferable to add those users to the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role instead.</source>
          <target state="translated">これらの関数は詳細なページレベルの情報を返すため、デフォルトではアクセスが制限されています。デフォルトでは、ロール &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; のみが &lt;code&gt;EXECUTE&lt;/code&gt; 権限を持っています。スーパーユーザーはもちろんこの制限を回避します。拡張機能がインストールされた後、ユーザーは &lt;code&gt;GRANT&lt;/code&gt; コマンドを発行して、関数の権限を変更し、他のユーザーがそれらを実行できるようにすることができます。ただし、代わりにそれらのユーザーを &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; ロールに追加することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="cab3b5bbab6ef84f87ff0c28b63da48ab8adbf53" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_auth_members&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_auth_members&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ユーザーIDはクラスター全体にわたるため、 &lt;code&gt;pg_auth_members&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_auth_members&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つはありません。</target>
        </trans-unit>
        <trans-unit id="0a9b4bf1d549fcf042c9f5eb8f3493cb9cfe27e7" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_authid&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_authid&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ユーザーIDはクラスター全体にわたるため、 &lt;code&gt;pg_authid&lt;/code&gt; はクラスターのすべてのデータベース間で共有されます &lt;code&gt;pg_authid&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つではありません。</target>
        </trans-unit>
        <trans-unit id="b7824c0664ad3fb70745076ae899f66946c9584d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.1, the arguments of the sequence functions were of type &lt;code&gt;text&lt;/code&gt;, not &lt;code&gt;regclass&lt;/code&gt;, and the above-described conversion from a text string to an OID value would happen at run time during each call. For backward compatibility, this facility still exists, but internally it is now handled as an implicit coercion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;regclass&lt;/code&gt; before the function is invoked.</source>
          <target state="translated">PostgreSQL 8.1より前のバージョンでは、シーケンス関数の引数は &lt;code&gt;regclass&lt;/code&gt; ではなく &lt;code&gt;text&lt;/code&gt; 型であり、上記のテキスト文字列からOID値への変換は、各呼び出しの実行時に実行されていました。下位互換性のために、この機能はまだ存在していますが、関数が呼び出される前に、内部的に &lt;code&gt;text&lt;/code&gt; から &lt;code&gt;regclass&lt;/code&gt; への暗黙の強制として処理されます。</target>
        </trans-unit>
        <trans-unit id="5fe2f878504da2e1db73277f0e33ea8b96b5ad9c" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the &lt;code&gt;.*&lt;/code&gt; syntax was not expanded in row constructors, so that writing &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; created a two-field row whose first field was another row value. The new behavior is usually more useful. If you need the old behavior of nested row values, write the inner row value without &lt;code&gt;.*&lt;/code&gt;, for instance &lt;code&gt;ROW(t, 42)&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 8.2より前は、行コンストラクターで &lt;code&gt;.*&lt;/code&gt; 構文が拡張されていなかったため、 &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; を書き込むと、最初のフィールドが別の行値である2フィールド行が作成されました。通常、新しい動作の方が便利です。ネストされた行の値の古い動作が必要な場合は、 &lt;code&gt;.*&lt;/code&gt; なしで内部行の値を記述します &lt;code&gt;ROW(t, 42)&lt;/code&gt; 例：ROW（t、42））。</target>
        </trans-unit>
        <trans-unit id="e8d01c186f775230385d810745e30ede0c0292d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were respectively called &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;. These names are still available, but are deprecated and will eventually be removed.</source>
          <target state="translated">PostgreSQL 8.2以前は、包含演算子 &lt;code&gt;@&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;@&lt;/code&gt; はそれぞれ &lt;code&gt;~&lt;/code&gt; と &lt;code&gt;@&lt;/code&gt; と呼ばれていました。これらの名前は引き続き使用できますが、廃止され、最終的には削除されます。</target>
        </trans-unit>
        <trans-unit id="c036ccc0fef09aace79d8f72b4bc4956e2e6b969" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.3, these functions would silently accept values of several non-string data types as well, due to the presence of implicit coercions from those data types to &lt;code&gt;text&lt;/code&gt;. Those coercions have been removed because they frequently caused surprising behaviors. However, the string concatenation operator (&lt;code&gt;||&lt;/code&gt;) still accepts non-string input, so long as at least one input is of a string type, as shown in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;. For other cases, insert an explicit coercion to &lt;code&gt;text&lt;/code&gt; if you need to duplicate the previous behavior.</source>
          <target state="translated">PostgreSQL 8.3より前のバージョンでは、これらの関数は文字列以外のいくつかのデータ型の値も暗黙的に受け入れて &lt;code&gt;text&lt;/code&gt; 。これは、これらのデータ型からテキストへの暗黙的な強制型変換が存在するためです。これらの強制は、驚くべき行動を頻繁に引き起こしたため、削除されました。ただし、&lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;表9.9に&lt;/a&gt;示すように、少なくとも1つの入力が文字列型である限り、文字列連結演算子（ &lt;code&gt;||&lt;/code&gt; ）は文字列以外の入力を受け入れます。その他の場合、以前の動作を複製する必要がある場合は、明示的な強制型変換を &lt;code&gt;text&lt;/code&gt; 挿入します。</target>
        </trans-unit>
        <trans-unit id="3b8019c3d24fcdf13fb68d8305a1528d20dff010" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, psql allowed the first argument of a single-letter backslash command to start directly after the command, without intervening whitespace. Now, some whitespace is required.</source>
          <target state="translated">PostgreSQL 8.4以前では、psqlは1文字のバックスラッシュコマンドの第1引数を、空白を介さずにコマンドの直後に開始することができました。現在では、多少の空白が必要になりました。</target>
        </trans-unit>
        <trans-unit id="95fbf31e963d4b484912ba157149b28d1649f2d4" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, the &lt;code&gt;OPERATOR&lt;/code&gt; clause could include a &lt;code&gt;RECHECK&lt;/code&gt; option. This is no longer supported because whether an index operator is &amp;ldquo;lossy&amp;rdquo; is now determined on-the-fly at run time. This allows efficient handling of cases where an operator might or might not be lossy.</source>
          <target state="translated">PostgreSQL 8.4より前のバージョンでは、 &lt;code&gt;OPERATOR&lt;/code&gt; 句に &lt;code&gt;RECHECK&lt;/code&gt; オプションを含めることができました。これはサポートされなくなりました。これは、インデックス演算子が「損失がある」かどうかが実行時にオンザフライで決定されるようになったためです。これにより、オペレーターが損失を伴う場合とそうでない場合を効率的に処理できます。</target>
        </trans-unit>
        <trans-unit id="5824a92b6b2740af57b007a3a86225a310d091b7" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, &lt;code&gt;pg_am&lt;/code&gt; contained many additional columns representing properties of index access methods. That data is now only directly visible at the C code level. However, &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; and related functions have been added to allow SQL queries to inspect index access method properties; see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;Table 9.68&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 9.6より前の &lt;code&gt;pg_am&lt;/code&gt; は、pg_amにはインデックスアクセスメソッドのプロパティを表す多くの列が含まれていました。このデータは、Cコードレベルでのみ直接表示されるようになりました。ただし、 &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; および関連関数が追加され、SQLクエリがインデックスアクセスメソッドのプロパティを検査できるようになりました。&lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;表9.68を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a4765a073d10eb89d73b00161ddb8dddb0be1ef8" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, SQL commands in script files were terminated by newlines, and so they could not be continued across lines. Now a semicolon is &lt;em&gt;required&lt;/em&gt; to separate consecutive SQL commands (though a SQL command does not need one if it is followed by a meta command). If you need to create a script file that works with both old and new versions of pgbench, be sure to write each SQL command on a single line ending with a semicolon.</source>
          <target state="translated">PostgreSQL 9.6より前のバージョンでは、スクリプトファイル内のSQLコマンドは改行で終了していたため、行をまたいで継続することはできませんでした。セミコロンは、連続するSQLコマンドを区切る&lt;em&gt;ために必要です&lt;/em&gt;（SQLコマンドの後にメタコマンドが続く場合は、セミコロンは&lt;em&gt;必要&lt;/em&gt;ありません）。pgbenchの古いバージョンと新しいバージョンの両方で動作するスクリプトファイルを作成する必要がある場合は、セミコロンで終わる1行に各SQLコマンドを記述してください。</target>
        </trans-unit>
        <trans-unit id="25a91312b02bab209e6a6f9a691f6a084f05d75d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, the &lt;code&gt;-c&lt;/code&gt; option implied &lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--no-psqlrc&lt;/code&gt;); this is no longer the case.</source>
          <target state="translated">PostgreSQL 9.6より前の &lt;code&gt;--no-psqlrc&lt;/code&gt; では、 &lt;code&gt;-c&lt;/code&gt; オプションは &lt;code&gt;-X&lt;/code&gt; （--no-psqlrc）を意味していました。これはもう当てはまりません。</target>
        </trans-unit>
        <trans-unit id="e88cb3afc9e7c5edbb82c8ba3662818b28a3aaef" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL had the &lt;code&gt;INCLUDE&lt;/code&gt; feature, people sometimes made covering indexes by writing the payload columns as ordinary index columns, that is writing</source>
          <target state="translated">PostgreSQLに &lt;code&gt;INCLUDE&lt;/code&gt; 機能が導入される前は、ペイロード列を通常のインデックス列として書き込むことでインデックスをカバーすることがありました。</target>
        </trans-unit>
        <trans-unit id="b6ecfe47fb55ef8a0352cf146e2122df69c11049" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.2, the shell-type creation syntax &lt;code&gt;CREATE TYPE name&lt;/code&gt; did not exist. The way to create a new base type was to create its input function first. In this approach, PostgreSQL will first see the name of the new data type as the return type of the input function. The shell type is implicitly created in this situation, and then it can be referenced in the definitions of the remaining I/O functions. This approach still works, but is deprecated and might be disallowed in some future release. Also, to avoid accidentally cluttering the catalogs with shell types as a result of simple typos in function definitions, a shell type will only be made this way when the input function is written in C.</source>
          <target state="translated">PostgreSQLバージョン8.2より前は、シェルタイプ作成構文 &lt;code&gt;CREATE TYPE name&lt;/code&gt; は存在しませんでした。新しい基本型を作成する方法は、最初に入力関数を作成することでした。このアプローチでは、PostgreSQLは最初に新しいデータ型の名前を入力関数の戻り型として認識します。この場合、シェルタイプは暗黙的に作成され、残りのI / O関数の定義で参照できます。このアプローチは引き続き機能しますが、推奨されておらず、将来のリリースで許可されなくなる可能性があります。また、関数定義での単純なタイプミスの結果として、誤ってカタログがシェルタイプで乱雑にならないようにするために、シェルタイプは、入力関数がCで記述されている場合にのみこの方法で作成されます。</target>
        </trans-unit>
        <trans-unit id="133cff6a54d531aaca5754e3dd9245f0764b14c3" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the &lt;code&gt;SET&lt;/code&gt; clause was not available, and so older functions may contain rather complicated logic to save, set, and restore &lt;code&gt;search_path&lt;/code&gt;. The &lt;code&gt;SET&lt;/code&gt; clause is far easier to use for this purpose.</source>
          <target state="translated">PostgreSQLバージョン8.3より前は、 &lt;code&gt;SET&lt;/code&gt; 句は使用できなかったため、古い関数には &lt;code&gt;search_path&lt;/code&gt; を保存、設定、および復元するためのかなり複雑なロジックが含まれている可能性があります。 &lt;code&gt;SET&lt;/code&gt; の句は、この目的のために使用する方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="d40dc4e81bdd5f6ad72cddc10364e0a47323f2d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the name of a generated array type was always exactly the element type's name with one underscore character (&lt;code&gt;_&lt;/code&gt;) prepended. (Type names were therefore restricted in length to one less character than other names.) While this is still usually the case, the array type name may vary from this in case of maximum-length names or collisions with user type names that begin with underscore. Writing code that depends on this convention is therefore deprecated. Instead, use &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typarray&lt;/code&gt; to locate the array type associated with a given type.</source>
          <target state="translated">PostgreSQLバージョン8.3より前のバージョンでは、生成された配列型の名前は常に1つのアンダースコア文字（ &lt;code&gt;_&lt;/code&gt; ）が前に付加された要素型の名前でした。 （したがって、タイプ名は他の名前よりも1文字少ない長さに制限されていました。）これは通常のケースですが、最大長の名前またはアンダースコアで始まるユーザータイプ名との衝突の場合、配列タイプ名はこれとは異なる場合があります。 。したがって、この規則に依存するコードの作成は非推奨です。代わりに、 &lt;code&gt;pg_type&lt;/code&gt; を使用してください。 &lt;code&gt;typarray&lt;/code&gt; は、特定の型に関連付けられている配列型を見つけます。</target>
        </trans-unit>
        <trans-unit id="96a33375376d06d4d560a6a1c1041e7d31e19935" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;. The &lt;code&gt;postgres&lt;/code&gt; program must know where to find the data it is supposed to use. This is done with the &lt;code&gt;-D&lt;/code&gt; option. Thus, the simplest way to start the server is:</source>
          <target state="translated">だれでもデータベースにアクセスできるようにするには、データベースサーバーを起動する必要があります。データベースサーバープログラムは &lt;code&gt;postgres&lt;/code&gt; と呼ばれます。 &lt;code&gt;postgres&lt;/code&gt; プログラムはどこ使用することになっているデータを見つけるために知っている必要があります。これは &lt;code&gt;-D&lt;/code&gt; オプションで行われます。したがって、サーバーを起動する最も簡単な方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="222bfa6cd0afdad9a2e9f50eb2cacfa866429974" translate="yes" xml:space="preserve">
          <source>Before doing so, the function should check the sign of &lt;code&gt;offset&lt;/code&gt;: if it is less than zero, raise error &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013) with error text like &amp;ldquo;invalid preceding or following size in window function&amp;rdquo;. (This is required by the SQL standard, although nonstandard operator families might perhaps choose to ignore this restriction, since there seems to be little semantic necessity for it.) This requirement is delegated to the &lt;code&gt;in_range&lt;/code&gt; function so that the core code needn't understand what &amp;ldquo;less than zero&amp;rdquo; means for a particular data type.</source>
          <target state="translated">そうする前に、関数は &lt;code&gt;offset&lt;/code&gt; の符号をチェックする必要があります。ゼロ未満の場合は、「ウィンドウ関数の無効な先行または後続のサイズ」などのエラーテキストを含むエラー &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; （22013）を発生させます。 （これはSQL標準で必須ですが、非標準の演算子ファミリはこの制限を無視することを選択する可能性があります。意味上の必要性はほとんどないようです。）この要件は &lt;code&gt;in_range&lt;/code&gt; 関数に委任されているため、コアコードは理解する必要がありません。特定のデータ型の「ゼロ未満」の意味。</target>
        </trans-unit>
        <trans-unit id="9433a751fdf2c9c611a9f86077418abf326bf14a" translate="yes" xml:space="preserve">
          <source>Before restoring an SQL dump, all the users who own objects or were granted permissions on objects in the dumped database must already exist. If they do not, the restore will fail to recreate the objects with the original ownership and/or permissions. (Sometimes this is what you want, but usually it is not.)</source>
          <target state="translated">SQL ダンプをリストアする前に、ダンプされたデータベース内のオブジェクトを所有している、またはオブジェクトに権限を付与されているすべてのユーザーがすでに存在している必要があります。存在しない場合、リストアは元の所有権および/または権限を持つオブジェクトの再作成に失敗します(これは望むことではありませんが、通常はそうではありません)。(これが必要な場合もありますが、通常はそうではありません。)</target>
        </trans-unit>
        <trans-unit id="5350218eee7862579014da56e03f9c4a8c7df37f" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="translated">&lt;code&gt;ATTACH PARTITION&lt;/code&gt; コマンドを実行する前に、目的のパーティション制約に一致するように、アタッチするテーブルに &lt;code&gt;CHECK&lt;/code&gt; 制約を作成することをお勧めします。これにより、システムはスキャンをスキップして、暗黙のパーティション制約を検証できます。 &lt;code&gt;CHECK&lt;/code&gt; 制約がない場合、そのパーティションに対する &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックと親テーブルに対する &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; ロックを保持しながら、テーブルがスキャンされてパーティション制約が検証されます。 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; が終了した後、冗長な &lt;code&gt;CHECK&lt;/code&gt; 制約を削除することが望ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="6cd8ecaf3b3090d8469e126e6ec0aadfd531ece9" translate="yes" xml:space="preserve">
          <source>Before we proceed, you should understand the basic PostgreSQL system architecture. Understanding how the parts of PostgreSQL interact will make this chapter somewhat clearer.</source>
          <target state="translated">先に進む前に、PostgreSQLの基本的なシステムアーキテクチャを理解しておく必要があります。PostgreSQLの各部分がどのように相互作用するかを理解することで、この章が多少明確になります。</target>
        </trans-unit>
        <trans-unit id="2bd6b34f5ab63eba4552e311eedb5465ee67a88a" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="translated">何かを行う前に、ディスク上のデータベースストレージ領域を初期化する必要があります。これを&lt;em&gt;データベースクラスタ&lt;/em&gt;と呼び&lt;em&gt;ます&lt;/em&gt;。 （SQL標準では、カタログクラスターという用語を使用しています。）データベースクラスターは、実行中のデータベースサーバーの単一のインスタンスによって管理されるデータベースのコレクションです。初期化後、データベースクラスターには &lt;code&gt;postgres&lt;/code&gt; という名前のデータベースが含まれます。これは、ユーティリティ、ユーザー、およびサードパーティのアプリケーションが使用するデフォルトのデータベースです。データベースサーバー自体は &lt;code&gt;postgres&lt;/code&gt; データベースが存在する必要はありませんが、多くの外部ユーティリティプログラムはそれが存在すると想定しています。初期化中に各クラスター内に作成された別のデータベースは、 &lt;code&gt;template1&lt;/code&gt; と呼ばれます。名前が示すように、これは後で作成されるデータベースのテンプレートとして使用されます。実際の作業には使用しないでください。（クラスター内での新しいデータベースの作成については、&lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;第22章を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="c5021e6ec2c149bc593346cdbced55fdf083dae8" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE EXTENSION&lt;/code&gt; を使用して拡張機能をデータベースにロードする前に、拡張機能のサポートファイルをインストールする必要があります。PostgreSQLで提供される拡張機能のインストールに関する情報は、&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;追加のモジュールにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b42b034c7e4f7289aaf07ce4a58233afbf01dc95" translate="yes" xml:space="preserve">
          <source>Before you can use PostgreSQL you need to install it, of course. It is possible that PostgreSQL is already installed at your site, either because it was included in your operating system distribution or because the system administrator already installed it. If that is the case, you should obtain information from the operating system documentation or your system administrator about how to access PostgreSQL.</source>
          <target state="translated">PostgreSQLを使用する前に、もちろんインストールする必要があります。オペレーティングシステムの配布物に含まれていたか、システム管理者が既にインストールしていたために、PostgreSQLが既にインストールされている可能性があります。その場合、PostgreSQLへのアクセス方法について、オペレーティングシステムのドキュメントやシステム管理者から情報を得る必要があります。</target>
        </trans-unit>
        <trans-unit id="b26dbac1aa32ad5c0e931ef76f5f13b493f4cca5" translate="yes" xml:space="preserve">
          <source>Begin recovery on the standby server from the local WAL archive, using &lt;code&gt;restore_command&lt;/code&gt; that waits as described previously (see &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">前述のように待機する &lt;code&gt;restore_command&lt;/code&gt; を使用して、ローカルWALアーカイブからスタンバイサーバーでリカバリを開始します（&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;セクション25.3.4を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b089abb1b8e490f01578f107a306004e919d4fa6" translate="yes" xml:space="preserve">
          <source>Begin streaming changes from the logical replication slot specified by &lt;code&gt;--slot&lt;/code&gt;, continuing until terminated by a signal. If the server side change stream ends with a server shutdown or disconnect, retry in a loop unless &lt;code&gt;--no-loop&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--slot&lt;/code&gt; で指定された論理複製スロットから変更のストリーミングを開始し、シグナルで終了するまで続行します。サーバー側の変更ストリームがサーバーのシャットダウンまたは切断で終了する場合、 &lt;code&gt;--no-loop&lt;/code&gt; が指定されていない限り、ループで再試行します。</target>
        </trans-unit>
        <trans-unit id="5723f3fda46717e1c7feda49b72b28e567ff2c36" translate="yes" xml:space="preserve">
          <source>Begin the output with a command to create the database itself and reconnect to the created database. (With a script of this form, it doesn't matter which database in the destination installation you connect to before running the script.) If &lt;code&gt;--clean&lt;/code&gt; is also specified, the script drops and recreates the target database before reconnecting to it.</source>
          <target state="translated">データベース自体を作成し、作成したデータベースに再接続するコマンドで出力を開始します。（この形式のスクリプトでは、スクリプトを実行する前に接続先インストールのどのデータベースに接続するかは関係ありません。）-- &lt;code&gt;--clean&lt;/code&gt; も指定されている場合、スクリプトはターゲットデータベースを削除して再作成してから、データベースに再接続します。</target>
        </trans-unit>
        <trans-unit id="039cd3e67eb5290833876444452a3461967b021e" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.1, these index types also support index searches for &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;ILIKE&lt;/code&gt;, for example</source>
          <target state="translated">PostgreSQL 9.1以降、これらのインデックスタイプは &lt;code&gt;LIKE&lt;/code&gt; および &lt;code&gt;ILIKE&lt;/code&gt; のインデックス検索もサポートします。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="50f6ae535e6d21e272577a4aeb90ccdf9bd1fc99" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.3, these index types also support index searches for regular-expression matches (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; operators), for example</source>
          <target state="translated">PostgreSQL 9.3以降、これらのインデックスタイプは、正規表現の一致（ &lt;code&gt;~&lt;/code&gt; および &lt;code&gt;~*&lt;/code&gt; 演算子）のインデックス検索もサポートしています。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="e18ae86eb6dacc56f3e992def21c4e72f662c365" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">&lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 関数と同じように動作しますが、変更は消費されません。つまり、それらは将来の呼び出しで再び返されます。</target>
        </trans-unit>
        <trans-unit id="2cc29d4604bab2d23897cf42e9aa658714f98b76" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt; and that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">変更が &lt;code&gt;bytea&lt;/code&gt; として返され、変更が消費されないことを除いて、 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 関数と同じように動作します。つまり、それらは将来の呼び出しで再び返されます。</target>
        </trans-unit>
        <trans-unit id="0d8b3d76c539629fdd464e88d07fda0a141c2719" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">変更が &lt;code&gt;bytea&lt;/code&gt; として返されることを除いて、 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 関数と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="10e28951f118886fb1db9aad1518cc8230f657d1" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, except that it acquires a shared lock rather than exclusive lock on each retrieved row. A shared lock blocks other transactions from performing &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; or &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; on these rows, but it does not prevent them from performing &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">検索された各行に対して排他ロックではなく共有ロックを取得することを除いて、 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; と同様に動作します。共有ロックは、他のトランザクションがこれらの行に対して &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; または &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; を実行するのをブロックしますが、 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; または &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; の実行を妨げません。</target>
        </trans-unit>
        <trans-unit id="4166e40468956f25d587c502c88de582346f3e60" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR SHARE&lt;/code&gt;, except that the lock is weaker: &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; is blocked, but not &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;. A key-shared lock blocks other transactions from performing &lt;code&gt;DELETE&lt;/code&gt; or any &lt;code&gt;UPDATE&lt;/code&gt; that changes the key values, but not other &lt;code&gt;UPDATE&lt;/code&gt;, and neither does it prevent &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">ロックが弱いことを除いて、 &lt;code&gt;FOR SHARE&lt;/code&gt; と同様に動作します &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; はブロックされますが、 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; はブロックされません。キー共有ロックは、他のトランザクションがキー値を変更する &lt;code&gt;DELETE&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; を実行することをブロックしますが、他の &lt;code&gt;UPDATE&lt;/code&gt; はブロックしません。また、 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; 、 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 、または &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; もブロックしません。</target>
        </trans-unit>
        <trans-unit id="b3975839e55e061601c3038a505012e75c26cc40" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR UPDATE&lt;/code&gt;, except that the lock acquired is weaker: this lock will not block &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; commands that attempt to acquire a lock on the same rows. This lock mode is also acquired by any &lt;code&gt;UPDATE&lt;/code&gt; that does not acquire a &lt;code&gt;FOR UPDATE&lt;/code&gt; lock.</source>
          <target state="translated">取得したロックが弱いことを除いて、 &lt;code&gt;FOR UPDATE&lt;/code&gt; と同様に動作します。このロックは、同じ行でロックを取得しようとする &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; コマンドをブロックしません。このロックモードは、 &lt;code&gt;FOR UPDATE&lt;/code&gt; ロックを取得しない &lt;code&gt;UPDATE&lt;/code&gt; によっても取得されます。</target>
        </trans-unit>
        <trans-unit id="bfbd41304878c2d772d5d897e0245d1caed66504" translate="yes" xml:space="preserve">
          <source>Behavior of B-Tree Operator Classes</source>
          <target state="translated">B-Treeオペレータクラスの挙動</target>
        </trans-unit>
        <trans-unit id="126af5216968b8a395d1e58cbc6d82b4d656f6fb" translate="yes" xml:space="preserve">
          <source>Below is a larger example of how this feature can be used in production environments. The table &lt;code&gt;passwd&lt;/code&gt; emulates a Unix password file:</source>
          <target state="translated">以下は、この機能を運用環境で使用する方法のより大きな例です。テーブル &lt;code&gt;passwd&lt;/code&gt; は、Unixパスワードファイルをエミュレートします。</target>
        </trans-unit>
        <trans-unit id="7fca4fa390ed5f3e5c9eff1ebae50bc1ae5a07f1" translate="yes" xml:space="preserve">
          <source>Below we create a dictionary and bind some token types to an astronomical thesaurus and English stemmer:</source>
          <target state="translated">以下では、辞書を作成し、いくつかのトークンタイプを天文学的シソーラスと英語ステムラーにバインドします。</target>
        </trans-unit>
        <trans-unit id="870f5d9661b7407b932b1598182f5f2d810cf9fe" translate="yes" xml:space="preserve">
          <source>Benchmarking Options</source>
          <target state="translated">ベンチマークオプション</target>
        </trans-unit>
        <trans-unit id="2fb7c98fc75cb4f79b347af89afb1652e417df34" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章に&lt;/a&gt;記載されている構成パラメータの他に、 &lt;code&gt;SET&lt;/code&gt; コマンドを使用してのみ調整できるものや、特別な構文を持つものがあります。</target>
        </trans-unit>
        <trans-unit id="60abe3d5ae299760f0dd57db1ab7b6b69b7cc66b" translate="yes" xml:space="preserve">
          <source>Beware that recent releases of macOS ignore attempts to set &lt;code&gt;SHMMAX&lt;/code&gt; to a value that isn't an exact multiple of 4096.</source>
          <target state="translated">macOSの最近のリリースでは、 &lt;code&gt;SHMMAX&lt;/code&gt; を4096の正確な倍数ではない値に設定しようとする試みを無視していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b80b5f7ca59611a24bc9604afc3876b56110cee0" translate="yes" xml:space="preserve">
          <source>Beware that the &lt;code&gt;ROWS&lt;/code&gt; mode can produce unpredictable results if the &lt;code&gt;ORDER BY&lt;/code&gt; ordering does not order the rows uniquely. The &lt;code&gt;RANGE&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; modes are designed to ensure that rows that are peers in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; の順序付けが行を一意に順序付けしない場合、 &lt;code&gt;ROWS&lt;/code&gt; モードは予期しない結果をもたらす可能性があることに注意してください。 &lt;code&gt;RANGE&lt;/code&gt; と &lt;code&gt;GROUPS&lt;/code&gt; モードは、ピアにある行ことを保証するために設計されている &lt;code&gt;ORDER BY&lt;/code&gt; 所与のピアグループのすべての行がフレームにあるか、またはそれから除外されます順序が同様に扱われます。</target>
        </trans-unit>
        <trans-unit id="774be1cf4f3a522f1a25f2b6316b0d501136298e" translate="yes" xml:space="preserve">
          <source>Beware that this approach can fail if the outer query level contains additional processing, such as a join, because that might cause the subquery's output to be reordered before the aggregate is computed.</source>
          <target state="translated">外部クエリレベルに結合などの追加処理が含まれている場合、このアプローチは失敗する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="4afac498b0186c05ae272a50fdfb777d86f83f5a" translate="yes" xml:space="preserve">
          <source>Big Five</source>
          <target state="translated">ビッグファイブ</target>
        </trans-unit>
        <trans-unit id="05792c2e47b633979450a4d3fdc731bebb67e917" translate="yes" xml:space="preserve">
          <source>Binary Data Types</source>
          <target state="translated">バイナリデータ型</target>
        </trans-unit>
        <trans-unit id="d978fc265919867464402ead8b5aa5056e5fbd19" translate="yes" xml:space="preserve">
          <source>Binary Data Types: bytea</source>
          <target state="translated">バイナリデータ型:bytea</target>
        </trans-unit>
        <trans-unit id="be10328dd5eb2024df80c19f0915f781f57e2ed4" translate="yes" xml:space="preserve">
          <source>Binary Format</source>
          <target state="translated">バイナリフォーマット</target>
        </trans-unit>
        <trans-unit id="eea185b10ff34a7d0730fbc39d8d1573222be81b" translate="yes" xml:space="preserve">
          <source>Binary String Functions and Operators</source>
          <target state="translated">バイナリ文字列関数と演算子</target>
        </trans-unit>
        <trans-unit id="b8dff4368de0e3c40124e448acd2ca6783cd44df" translate="yes" xml:space="preserve">
          <source>Binary String: btrim</source>
          <target state="translated">バイナリ文字列:btrim</target>
        </trans-unit>
        <trans-unit id="dab4683aaea619005a4200cd9a5215872f4f193a" translate="yes" xml:space="preserve">
          <source>Binary String: decode</source>
          <target state="translated">バイナリ文字列:デコード</target>
        </trans-unit>
        <trans-unit id="1bb599e86584900c656608c4be089126932fb4ca" translate="yes" xml:space="preserve">
          <source>Binary String: encode</source>
          <target state="translated">バイナリ文字列:エンコード</target>
        </trans-unit>
        <trans-unit id="ed9e62f8973e5d6bffd91187c9e478de6423b5ec" translate="yes" xml:space="preserve">
          <source>Binary String: get_bit</source>
          <target state="translated">バイナリ文字列:get_bit</target>
        </trans-unit>
        <trans-unit id="a7dc78314758d39820bb026c008feb884ce531ff" translate="yes" xml:space="preserve">
          <source>Binary String: get_byte</source>
          <target state="translated">バイナリ文字列:get_byte</target>
        </trans-unit>
        <trans-unit id="3b3dfd58346ed838c2d28b9b46ab8febf746666b" translate="yes" xml:space="preserve">
          <source>Binary String: length</source>
          <target state="translated">バイナリ文字列:長さ</target>
        </trans-unit>
        <trans-unit id="3d6bb6f2a913f2fe4e19cd19b79eb492e8027877" translate="yes" xml:space="preserve">
          <source>Binary String: md5</source>
          <target state="translated">バイナリ文字列:md5</target>
        </trans-unit>
        <trans-unit id="2b6e00319f3a8699a801221f672b9e6fae165f94" translate="yes" xml:space="preserve">
          <source>Binary String: octet_length</source>
          <target state="translated">バイナリ文字列:オクテット長</target>
        </trans-unit>
        <trans-unit id="549d7f8bb245593c2f0ec51b5eecfcb99bfc4c36" translate="yes" xml:space="preserve">
          <source>Binary String: overlay</source>
          <target state="translated">バイナリ文字列:オーバーレイ</target>
        </trans-unit>
        <trans-unit id="317470b7465e50bb01ea0ed9d647db9aa1569cbc" translate="yes" xml:space="preserve">
          <source>Binary String: position</source>
          <target state="translated">バイナリ文字列:位置</target>
        </trans-unit>
        <trans-unit id="9434d0dc118c447e4ee164199720303685e8f31a" translate="yes" xml:space="preserve">
          <source>Binary String: set_bit</source>
          <target state="translated">バイナリ文字列:set_bit</target>
        </trans-unit>
        <trans-unit id="f39a20b22ec73f10ccf2ff12ede513b3bf197e16" translate="yes" xml:space="preserve">
          <source>Binary String: set_byte</source>
          <target state="translated">バイナリ文字列:set_byte</target>
        </trans-unit>
        <trans-unit id="edd1f7f5db831e55c4404df9e415cec21d97ca8d" translate="yes" xml:space="preserve">
          <source>Binary String: sha224</source>
          <target state="translated">バイナリ文字列:sha224</target>
        </trans-unit>
        <trans-unit id="a4e5fd05bd7c2057fbb588451d73bc8e364bcd00" translate="yes" xml:space="preserve">
          <source>Binary String: sha256</source>
          <target state="translated">バイナリ文字列:sha256</target>
        </trans-unit>
        <trans-unit id="199ba90dac671366fc2d30018bc9cc60da6d8112" translate="yes" xml:space="preserve">
          <source>Binary String: sha384</source>
          <target state="translated">バイナリ文字列:sha384</target>
        </trans-unit>
        <trans-unit id="b17b7742692d6cc8900d5a09fbba1ba2dcf79e2d" translate="yes" xml:space="preserve">
          <source>Binary String: sha512</source>
          <target state="translated">バイナリ文字列:sha512</target>
        </trans-unit>
        <trans-unit id="eb754287eb3b8d22b0752ef54dea23d275538097" translate="yes" xml:space="preserve">
          <source>Binary String: substring</source>
          <target state="translated">バイナリ文字列:部分文字列</target>
        </trans-unit>
        <trans-unit id="0880194133ad39b402dac81c879f4881bf8922df" translate="yes" xml:space="preserve">
          <source>Binary String: trim</source>
          <target state="translated">バイナリ文字列:トリム</target>
        </trans-unit>
        <trans-unit id="4b19a17003e3a215c61a3139f7843b960e175e71" translate="yes" xml:space="preserve">
          <source>Binary String: ||</source>
          <target state="translated">バイナリ文字列。||</target>
        </trans-unit>
        <trans-unit id="c41bc309d8cd529592e339f0c36e8e967a2fed13" translate="yes" xml:space="preserve">
          <source>Binary cursors are a PostgreSQL extension.</source>
          <target state="translated">バイナリカーソルはPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="6b44f09a82f5b765933694a9db3f15e511f15291" translate="yes" xml:space="preserve">
          <source>Binary cursors should be used carefully. Many applications, including psql, are not prepared to handle binary cursors and expect data to come back in the text format.</source>
          <target state="translated">バイナリカーソルは慎重に使用する必要があります。psqlを含む多くのアプリケーションは、バイナリカーソルを扱う準備ができておらず、データがテキスト形式で返ってくることを期待しています。</target>
        </trans-unit>
        <trans-unit id="253c59e522f194890c38a49fa034c56d5597e5ce" translate="yes" xml:space="preserve">
          <source>Bit 16</source>
          <target state="translated">ビット16</target>
        </trans-unit>
        <trans-unit id="b304e502a60fe2721a2acc2ea86477e058a5fc18" translate="yes" xml:space="preserve">
          <source>Bit String Functions and Operators</source>
          <target state="translated">ビット文字列の関数と演算子</target>
        </trans-unit>
        <trans-unit id="e1ec8af5ed0ac3706706e7ca0257fb8472997bd9" translate="yes" xml:space="preserve">
          <source>Bit String Types</source>
          <target state="translated">ビット文字列の種類</target>
        </trans-unit>
        <trans-unit id="26d5338edfde42da5636b07f3a1f7b3b99348954" translate="yes" xml:space="preserve">
          <source>Bit String: #</source>
          <target state="translated">ビット文字列 #</target>
        </trans-unit>
        <trans-unit id="54a89e1d14e86ab43af7735b61c206ac06fd6632" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;amp;</source>
          <target state="translated">ビット文字列：＆</target>
        </trans-unit>
        <trans-unit id="25bf3896db23b3430dc3419d701ee4519f795bf6" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;gt;&amp;gt;</source>
          <target state="translated">ビット文字列：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d52a6739aec041222c397e3ab3508452bbdace4c" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;lt;&amp;lt;</source>
          <target state="translated">ビット文字列：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="4e47fbeeacb2ccb2058a0e13885d27607dc2ff89" translate="yes" xml:space="preserve">
          <source>Bit String: |</source>
          <target state="translated">ビット文字列。|</target>
        </trans-unit>
        <trans-unit id="a9f58217517f242096405bc47fb766301ddb90d4" translate="yes" xml:space="preserve">
          <source>Bit String: ||</source>
          <target state="translated">ビット文字列。||</target>
        </trans-unit>
        <trans-unit id="fb535d3c1297857f6c6638c764b59c16782c04dd" translate="yes" xml:space="preserve">
          <source>Bit String: ~</source>
          <target state="translated">ビット文字列 ~</target>
        </trans-unit>
        <trans-unit id="2efae331bc5aa821406a784a6e78c0b9daf6c7df" translate="yes" xml:space="preserve">
          <source>Bit mask identifying trigger firing conditions</source>
          <target state="translated">トリガ発射条件を識別するビットマスク</target>
        </trans-unit>
        <trans-unit id="35edcdbad2868d30fa30834e2406d3005ac8363c" translate="yes" xml:space="preserve">
          <source>Bit strings are strings of 1's and 0's. They can be used to store or visualize bit masks. There are two SQL bit types: &lt;code&gt;bit(n)&lt;/code&gt; and &lt;code&gt;bit varying(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a positive integer.</source>
          <target state="translated">ビット文字列は、1と0の文字列です。それらは、ビットマスクを格納または視覚化するために使用できます。2つのSQLビット種類があり &lt;code&gt;bit(n)&lt;/code&gt; と &lt;code&gt;bit varying(n)&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; は正の整数であるが。</target>
        </trans-unit>
        <trans-unit id="440588c03e76a6dbf3a0dad3d94ffb56eaf0107d" translate="yes" xml:space="preserve">
          <source>Bit-string constants look like regular string constants with a &lt;code&gt;B&lt;/code&gt; (upper or lower case) immediately before the opening quote (no intervening whitespace), e.g., &lt;code&gt;B'1001'&lt;/code&gt;. The only characters allowed within bit-string constants are &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">ビット文字列定数は、 &lt;code&gt;B'1001'&lt;/code&gt; に、開始引用符の直前に &lt;code&gt;B&lt;/code&gt; （大文字または小文字）が付いた通常の文字列定数のように見えます（間に空白はありません）。ビット文字列定数内で使用できる文字は &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;1&lt;/code&gt; だけです。</target>
        </trans-unit>
        <trans-unit id="ef8b2561e514bdc32792b41e10c969f64c960716" translate="yes" xml:space="preserve">
          <source>Bit-string types</source>
          <target state="translated">ビット文字列型</target>
        </trans-unit>
        <trans-unit id="3119bee988c6c128ef1a7a4d003a2772fc4ae36a" translate="yes" xml:space="preserve">
          <source>BitmapAnd and BitmapOr nodes always report their actual row counts as zero, due to implementation limitations.</source>
          <target state="translated">BitmapAndノードとBitmapOrノードは、実装の制限により、常に実際の行数をゼロとして報告します。</target>
        </trans-unit>
        <trans-unit id="6f50e3e14cce1a8627751575e909b4caa4d3a6a3" translate="yes" xml:space="preserve">
          <source>Bloom is better than btree in handling this type of search:</source>
          <target state="translated">このタイプの検索を扱うには、btreeよりもBloomの方が優れている。</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="92c882ac33d0ee2cd51460d3e115370fb18b7f64" translate="yes" xml:space="preserve">
          <source>Blowfish cipher</source>
          <target state="translated">フグ暗号</target>
        </trans-unit>
        <trans-unit id="38d26af6e5082bc6e784c3815947a0f5acecada7" translate="yes" xml:space="preserve">
          <source>Blowfish crypt</source>
          <target state="translated">ふぐの墓所</target>
        </trans-unit>
        <trans-unit id="17d54f2a65a51558dd8c1f3e789157750ff7d6f8" translate="yes" xml:space="preserve">
          <source>Blowfish-based, variant 2a</source>
          <target state="translated">フグベース、バリアント2a</target>
        </trans-unit>
        <trans-unit id="58299c5eb711f9a461ff1240fa8b1c0679ab5056" translate="yes" xml:space="preserve">
          <source>Boolean AND</source>
          <target state="translated">ブールアンド</target>
        </trans-unit>
        <trans-unit id="c69f2185492e832f7277d3fff7b42d01f558fb61" translate="yes" xml:space="preserve">
          <source>Boolean NOT</source>
          <target state="translated">ブールひてい</target>
        </trans-unit>
        <trans-unit id="2c320907721a13b5dd2b75f194044bf4fb118e32" translate="yes" xml:space="preserve">
          <source>Boolean OR</source>
          <target state="translated">ブールオア</target>
        </trans-unit>
        <trans-unit id="54bd3ce38554ce1715613858323d1049c39c0685" translate="yes" xml:space="preserve">
          <source>Boolean Type</source>
          <target state="translated">ブール型</target>
        </trans-unit>
        <trans-unit id="9656fd514386a9028815794334d9467f9f5a0c5e" translate="yes" xml:space="preserve">
          <source>Boolean Type: boolean</source>
          <target state="translated">ブール型:ブール</target>
        </trans-unit>
        <trans-unit id="d602b755186d61e697c04da0a7d821ff7d4efa39" translate="yes" xml:space="preserve">
          <source>Boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. As for &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;some&lt;/code&gt;, it seems that there is an ambiguity built into the standard syntax:</source>
          <target state="translated">ブール集合体 &lt;code&gt;bool_and&lt;/code&gt; と &lt;code&gt;bool_or&lt;/code&gt; 標準SQLの集合体に対応し &lt;code&gt;every&lt;/code&gt; および &lt;code&gt;any&lt;/code&gt; または &lt;code&gt;some&lt;/code&gt; 。用として &lt;code&gt;any&lt;/code&gt; および &lt;code&gt;some&lt;/code&gt; 、標準の構文には曖昧さがあるようです。</target>
        </trans-unit>
        <trans-unit id="e7e48e64bd944bf0341a3c4f226c0c85bf62984d" translate="yes" xml:space="preserve">
          <source>Boolean constants can be represented in SQL queries by the SQL key words &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;, and &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">ブール定数はSQLクエリでSQLキーワード &lt;code&gt;TRUE&lt;/code&gt; 、 &lt;code&gt;FALSE&lt;/code&gt; 、および &lt;code&gt;NULL&lt;/code&gt; で表すことができます。</target>
        </trans-unit>
        <trans-unit id="52e1ee47a7ff1168010b326824ee21ddfeae28c3" translate="yes" xml:space="preserve">
          <source>Boolean types</source>
          <target state="translated">ブール型</target>
        </trans-unit>
        <trans-unit id="ec240e7050d6f871548eb16c80190949f2f4c3c5" translate="yes" xml:space="preserve">
          <source>Boolean values can also be tested using the predicates</source>
          <target state="translated">ブール値は、述語を使ってテストすることもできます。</target>
        </trans-unit>
        <trans-unit id="61e93ae531636a2f7c54ab2267a73987c4067669" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;NOT NULL&lt;/code&gt; constraints of a partitioned table are always inherited by all its partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints that are marked &lt;code&gt;NO INHERIT&lt;/code&gt; are not allowed to be created on partitioned tables.</source>
          <target state="translated">パーティションテーブルの &lt;code&gt;CHECK&lt;/code&gt; 制約と &lt;code&gt;NOT NULL&lt;/code&gt; 制約の両方は、常にすべてのパーティションに継承されます。 &lt;code&gt;NO INHERIT&lt;/code&gt; とマークされている &lt;code&gt;CHECK&lt;/code&gt; 制約は、パーティション化されたテーブルで作成することはできません。</target>
        </trans-unit>
        <trans-unit id="b889ca8993198c7004a576b1cf90c434b540954c" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; can be any non-null string, with a maximum of 255 characters. The cost parameters specify how much to charge for a character insertion, deletion, or substitution, respectively. You can omit the cost parameters, as in the second version of the function; in that case they all default to 1.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; と &lt;code&gt;target&lt;/code&gt; はどちらも、最大255文字のnull以外の文字列にすることができます。コストパラメータは、文字の挿入、削除、または置換にそれぞれいくら課金するかを指定します。関数の2番目のバージョンのように、コストパラメータを省略できます。その場合、デフォルトはすべて1です。</target>
        </trans-unit>
        <trans-unit id="5ea32d54e6cfd34abb39f16058fc4fd6f2961804" translate="yes" xml:space="preserve">
          <source>Both advisory locks and regular locks are stored in a shared memory pool whose size is defined by the configuration variables &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;. Care must be taken not to exhaust this memory or the server will be unable to grant any locks at all. This imposes an upper limit on the number of advisory locks grantable by the server, typically in the tens to hundreds of thousands depending on how the server is configured.</source>
          <target state="translated">勧告的ロックと通常のロックの両方は、構成変数&lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt;および&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;によってサイズが定義される共有メモリプールに格納されます。このメモリを使い果たしないように注意する必要があります。そうしないと、サーバーはロックをまったく付与できなくなります。これにより、サーバーによって許可されるアドバイザリロックの数に上限が課せられます。通常、サーバーの構成に応じて数万から数十万になります。</target>
        </trans-unit>
        <trans-unit id="64fe65c7e1e3e888472be5adaa2902cc6b0a1a3b" translate="yes" xml:space="preserve">
          <source>Both forms of bit-string constant can be continued across lines in the same way as regular string constants. Dollar quoting cannot be used in a bit-string constant.</source>
          <target state="translated">どちらの形式のビット文字列定数も、通常の文字列定数と同じ方法で行をまたいで続けることができます。ドルのクォートはビット文字列定数では使用できません。</target>
        </trans-unit>
        <trans-unit id="2b41d8e55f4edf059d0388795bf4f266c2e06c3f" translate="yes" xml:space="preserve">
          <source>Both minmax and inclusion operator classes support cross-data-type operators, though with these the dependencies become more complicated. The minmax operator class requires a full set of operators to be defined with both arguments having the same data type. It allows additional data types to be supported by defining extra sets of operators. Inclusion operator class operator strategies are dependent on another operator strategy as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;Table 67.3&lt;/a&gt;, or the same operator strategy as themselves. They require the dependency operator to be defined with the &lt;code&gt;STORAGE&lt;/code&gt; data type as the left-hand-side argument and the other supported data type to be the right-hand-side argument of the supported operator. See &lt;code&gt;float4_minmax_ops&lt;/code&gt; as an example of minmax, and &lt;code&gt;box_inclusion_ops&lt;/code&gt; as an example of inclusion.</source>
          <target state="translated">minmax演算子クラスと包含演算子クラスはどちらもクロスデータ型演算子をサポートしていますが、これらの依存関係はさらに複雑になります。 minmax演算子クラスでは、両方の引数が同じデータ型を持つように定義された演算子の完全なセットが必要です。追加の演算子のセットを定義することにより、追加のデータ型をサポートできます。包含演算子クラスの演算子戦略は、&lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;表67.3&lt;/a&gt;に示す別の演算子戦略、またはそれ自体と同じ演算子戦略に依存しています。依存関係演算子は、 &lt;code&gt;STORAGE&lt;/code&gt; データ型を左側の引数として定義し、サポートされる他のデータ型をサポートされる演算子の右側の引数として定義する必要があります。 &lt;code&gt;float4_minmax_ops&lt;/code&gt; の例としてfloat4_minmax_opsを参照してください。 &lt;code&gt;box_inclusion_ops&lt;/code&gt; 包含の例としてのbox_inclusion_ops。</target>
        </trans-unit>
        <trans-unit id="7b6bb44fe8014c95fc406791cc963af10b33bb29" translate="yes" xml:space="preserve">
          <source>Both the maximum precision and the maximum scale of a &lt;code&gt;numeric&lt;/code&gt; column can be configured. To declare a column of type &lt;code&gt;numeric&lt;/code&gt; use the syntax:</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 列の最大精度と最大スケールの両方を構成できます。 &lt;code&gt;numeric&lt;/code&gt; 型の列を宣言するには、次の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="ea3fb61640ce7586a68af124013d79c4c57b81a1" translate="yes" xml:space="preserve">
          <source>Both the scan position and the mark position (if any) must be maintained consistently in the face of concurrent insertions or deletions in the index. It is OK if a freshly-inserted entry is not returned by a scan that would have found the entry if it had existed when the scan started, or for the scan to return such an entry upon rescanning or backing up even though it had not been returned the first time through. Similarly, a concurrent delete might or might not be reflected in the results of a scan. What is important is that insertions or deletions not cause the scan to miss or multiply return entries that were not themselves being inserted or deleted.</source>
          <target state="translated">スキャン位置とマーク位置(ある場合)は、インデックス内で同時挿入又は削除があっても一貫して維持されなければならない。スキャンが開始されたときにエントリが存在していれば、そのエントリが見つかっていたはずのスキャンで、挿入されたばかりのエントリが返されなかったり、最初に返されなかったにもかかわらず、再スキャンやバックアップの際にそのようなエントリがスキャンによって返されたりしても構いません。同様に、同時削除は、スキャンの結果に反映されるかもしれないし、反映されないかもしれません。重要なのは、挿入や削除によって、スキャンが挿入や削除されていないエントリを見逃したり、複数のエントリを返したりしないようにすることです。</target>
        </trans-unit>
        <trans-unit id="3bce0a8d20dfad3adb1a5af3b099eec9aec7a17c" translate="yes" xml:space="preserve">
          <source>Both the system-wide startup file and the user's personal startup file can be made psql-version-specific by appending a dash and the PostgreSQL major or minor release number to the file name, for example &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; or &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt;. The most specific version-matching file will be read in preference to a non-version-specific file.</source>
          <target state="translated">システム全体のスタートアップファイルとユーザーの個人用スタートアップファイルの両方に、ダッシュとPostgreSQLのメジャーリリース番号またはマイナーリリース番号をファイル名に追加することで、psqlバージョン固有にすることができます（例： &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; または &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt; 。最もバージョンが一致するファイルは、バージョンが固有でないファイルよりも優先して読み取られます。</target>
        </trans-unit>
        <trans-unit id="a9f1bcbf395b360aecae5c7aad8432687c5d0c98" translate="yes" xml:space="preserve">
          <source>Boxes are output using the second syntax.</source>
          <target state="translated">ボックスは、2 番目の構文を使用して出力されます。</target>
        </trans-unit>
        <trans-unit id="3b7172d9675205f8063e821e7bb335558a00ea56" translate="yes" xml:space="preserve">
          <source>Boxes are represented by pairs of points that are opposite corners of the box. Values of type &lt;code&gt;box&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">ボックスは、ボックスの対角にあるポイントのペアで表されます。タイプ &lt;code&gt;box&lt;/code&gt; 値は、次の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="80edaabf28ae789b6d2df8969096454a0d5adc8a" translate="yes" xml:space="preserve">
          <source>Brackets (&lt;code&gt;[]&lt;/code&gt;) are used to select the elements of an array. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more information on arrays.</source>
          <target state="translated">大括弧（ &lt;code&gt;[]&lt;/code&gt; ）は、配列のエレメントを選択するために使用されます。配列の詳細については、&lt;a href=&quot;arrays&quot;&gt;セクション8.15&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a42247eae020c4a6a90987074cedeaeafefcb933" translate="yes" xml:space="preserve">
          <source>Break the input string into tokens and categorize each token as a string, time, time zone, or number.</source>
          <target state="translated">入力文字列をトークンに分割し、各トークンを文字列、時間、タイムゾーン、または数字に分類します。</target>
        </trans-unit>
        <trans-unit id="7f060d64f6791f16fa5efaff60c076733c80c6cc" translate="yes" xml:space="preserve">
          <source>Brian Gladman</source>
          <target state="translated">ブライアン・グラッドマン</target>
        </trans-unit>
        <trans-unit id="ffa9096408246acd9955cddd88051877608e02b2" translate="yes" xml:space="preserve">
          <source>Bucardo</source>
          <target state="translated">Bucardo</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="8d8140d7cfbb395763a377b0065a8f622c660961" translate="yes" xml:space="preserve">
          <source>Build a new index. The index relation has been physically created, but is empty. It must be filled in with whatever fixed data the access method requires, plus entries for all tuples already existing in the table. Ordinarily the &lt;code&gt;ambuild&lt;/code&gt; function will call &lt;code&gt;table_index_build_scan()&lt;/code&gt; to scan the table for existing tuples and compute the keys that need to be inserted into the index. The function must return a palloc'd struct containing statistics about the new index.</source>
          <target state="translated">新しいインデックスを作成します。インデックスリレーションシップは物理的に作成されていますが、空です。アクセス方法に必要な固定データと、テーブルにすでに存在するすべてのタプルのエントリを入力する必要があります。通常、 &lt;code&gt;ambuild&lt;/code&gt; 関数は &lt;code&gt;table_index_build_scan()&lt;/code&gt; を呼び出して既存のタプルのテーブルをスキャンし、インデックスに挿入する必要があるキーを計算します。関数は、新しいインデックスに関する統計を含むpallocされた構造体を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="5ab5f75a4f668c4f5eba6aa186b68fe6555350c4" translate="yes" xml:space="preserve">
          <source>Build an empty index, and write it to the initialization fork (&lt;code&gt;INIT_FORKNUM&lt;/code&gt;) of the given relation. This method is called only for unlogged indexes; the empty index written to the initialization fork will be copied over the main relation fork on each server restart.</source>
          <target state="translated">空のインデックスを作成し、指定されたリレーションの初期化フォーク（ &lt;code&gt;INIT_FORKNUM&lt;/code&gt; ）に書き込みます。このメソッドは、ログに記録されていないインデックスに対してのみ呼び出されます。初期化フォークに書き込まれた空のインデックスは、サーバーを再起動するたびにメインリレーションフォークにコピーされます。</target>
        </trans-unit>
        <trans-unit id="59b2f3dbb6bd6f1f5bde23a4b9bc5f2c1659dd06" translate="yes" xml:space="preserve">
          <source>Build the new PostgreSQL source with &lt;code&gt;configure&lt;/code&gt; flags that are compatible with the old cluster. pg_upgrade will check &lt;code&gt;pg_controldata&lt;/code&gt; to make sure all settings are compatible before starting the upgrade.</source>
          <target state="translated">古いクラスターと互換性のある &lt;code&gt;configure&lt;/code&gt; フラグを使用して、新しいPostgreSQLソースをビルドします。pg_upgradeのが確認されます &lt;code&gt;pg_controldata&lt;/code&gt; を確認すべての設定がアップグレードを開始する前に、互換性があります作成します。</target>
        </trans-unit>
        <trans-unit id="b0efda5eef1ba866b7542374c8ece9a4b87bf621" translate="yes" xml:space="preserve">
          <source>Build time for a GIN index is very sensitive to the &lt;code&gt;maintenance_work_mem&lt;/code&gt; setting; it doesn't pay to skimp on work memory during index creation.</source>
          <target state="translated">GINインデックスのビルド時間は、 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 設定に非常に敏感です。インデックスの作成時に作業メモリを節約することはできません。</target>
        </trans-unit>
        <trans-unit id="33f8808cf736a2f0f4fe91a19f0db395826f76fd" translate="yes" xml:space="preserve">
          <source>Building Indexes Concurrently</source>
          <target state="translated">インデックスの同時構築</target>
        </trans-unit>
        <trans-unit id="39c26d35b65d38341a1a91676925e41df6b2055c" translate="yes" xml:space="preserve">
          <source>Building an index type that supports concurrent updates usually requires extensive and subtle analysis of the required behavior. For the b-tree and hash index types, you can read about the design decisions involved in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; and &lt;code&gt;src/backend/access/hash/README&lt;/code&gt;.</source>
          <target state="translated">同時更新をサポートするインデックスタイプを構築するには、通常、必要な動作の広範囲で微妙な分析が必要です。b-treeおよびハッシュインデックスタイプについては、 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; および &lt;code&gt;src/backend/access/hash/README&lt;/code&gt; に関連する設計上の決定について読むことができます。</target>
        </trans-unit>
        <trans-unit id="47e5cdcd370dad05acde9abb1ab525b1924edb0a" translate="yes" xml:space="preserve">
          <source>Building large GiST indexes by simply inserting all the tuples tends to be slow, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, the insertions need to perform a lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more efficient method to build GiST indexes based on buffering, which can dramatically reduce the number of random I/Os needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as whole does not.</source>
          <target state="translated">単純にすべてのタプルを挿入して大規模なGiSTインデックスを構築すると、インデックスタプルがインデックス全体に散らばっていて、インデックスがキャッシュに収まらないほど大きい場合、挿入では多くのランダムI/Oを実行する必要があるため、時間がかかる傾向があります。バージョン9.2以降、PostgreSQLはバッファリングに基づいてGiSTインデックスを構築するより効率的な方法をサポートしています。なぜなら、一度に新しいタプルを受け取るのは少数のページのみであり、インデックス全体がそうでなくても、それらのページはキャッシュに収まるからです。</target>
        </trans-unit>
        <trans-unit id="802f99132933c7e50ae4b1dc60414e1dd9622319" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair.</source>
          <target state="translated">テキスト配列から JSON オブジェクトを作成します。配列は、偶数のメンバを持つ正確に 1 次元でなければなりません。この場合、それらのメンバは交互にキーと値のペアとして扱われます。</target>
        </trans-unit>
        <trans-unit id="f2aecbff08d9f05062e48cef54ff41a7deab5245" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values.</source>
          <target state="translated">可変引数リストからJSONオブジェクトを構築します。規約では、引数リストはキーと値を交互に並べたもので構成されます。</target>
        </trans-unit>
        <trans-unit id="ad91ede47a5280dfb0e7c89b0ab06f2bb7e0630d" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list.</source>
          <target state="translated">可変引数リストから、異質な型を持つ可能性のあるJSON配列を構築します。</target>
        </trans-unit>
        <trans-unit id="6b5998f67810590d9a53e6c46c1e94143e2a8d11" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary record from a JSON object (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">JSONオブジェクトから任意のレコードを作成します（下記の注を参照）。 &lt;code&gt;record&lt;/code&gt; を返すすべての関数と同様に、呼び出し元は、 &lt;code&gt;AS&lt;/code&gt; 句を使用してレコードの構造を明示的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="08637f34c0762d04a0506b89a280023ac2d9b88b" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary set of records from a JSON array of objects (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">オブジェクトのJSON配列からレコードの任意のセットを作成します（下記の注を参照）。 &lt;code&gt;record&lt;/code&gt; を返すすべての関数と同様に、呼び出し元は、 &lt;code&gt;AS&lt;/code&gt; 句を使用してレコードの構造を明示的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="5cd7d28e330cbb1847ac7f97e57334ab1657662f" translate="yes" xml:space="preserve">
          <source>Built-In Functions</source>
          <target state="translated">内蔵機能</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="9cd4a830278cf917981f2492e289136d8fcb76a0" translate="yes" xml:space="preserve">
          <source>Built-in Operators</source>
          <target state="translated">作り付けのオペレータ</target>
        </trans-unit>
        <trans-unit id="e6f4065b40dff42dc088b0122b579c99bd5cdb2f" translate="yes" xml:space="preserve">
          <source>Bulk loads and deletes can be accomplished by adding or removing partitions, if that requirement is planned into the partitioning design. Doing &lt;code&gt;ALTER TABLE DETACH PARTITION&lt;/code&gt; or dropping an individual partition using &lt;code&gt;DROP TABLE&lt;/code&gt; is far faster than a bulk operation. These commands also entirely avoid the &lt;code&gt;VACUUM&lt;/code&gt; overhead caused by a bulk &lt;code&gt;DELETE&lt;/code&gt;.</source>
          <target state="translated">パーティションの設計で要件が計画されている場合は、パーティションを追加または削除することにより、一括読み込みと削除を実行できます。こう &lt;code&gt;ALTER TABLE DETACH PARTITION&lt;/code&gt; のをまたは使用して、個々のパーティションを削除 &lt;code&gt;DROP TABLE&lt;/code&gt; は、はるかに高速一括操作よりもあります。これらのコマンドは、一括 &lt;code&gt;DELETE&lt;/code&gt; によって引き起こされる &lt;code&gt;VACUUM&lt;/code&gt; オーバーヘッドも完全に回避します。</target>
        </trans-unit>
        <trans-unit id="ba7aa498b8190a3e40ac8cc44de7a317a4821d6c" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;-o&lt;/code&gt; is specified, that replaces any previous options. To restart using port 5433, disabling &lt;code&gt;fsync&lt;/code&gt; upon restart:</source>
          <target state="translated">ただし、 &lt;code&gt;-o&lt;/code&gt; を指定すると、以前のオプションが置き換えられます。無効化、ポート5433を使用して再起動するには &lt;code&gt;fsync&lt;/code&gt; を再起動時：</target>
        </trans-unit>
        <trans-unit id="602beb3b1a1bbe225614fdbf63a5d0bd06c13935" translate="yes" xml:space="preserve">
          <source>But if we tell the planner to honor the &lt;code&gt;JOIN&lt;/code&gt; order, the second and third take less time to plan than the first. This effect is not worth worrying about for only three tables, but it can be a lifesaver with many tables.</source>
          <target state="translated">しかし、プランナーに &lt;code&gt;JOIN&lt;/code&gt; 命令を尊重するように指示すると、2番目と3番目の計画は最初の計画よりも時間がかかりません。この影響は3つのテーブルについてのみ心配する価値はありませんが、多くのテーブルがある場合は命の恩人になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="09b41d05f84a635c62f9f96512a903ce9737d4a8" translate="yes" xml:space="preserve">
          <source>But if you use the &lt;code&gt;-j&lt;/code&gt; command line switch, a single newline does not terminate command entry; instead, the sequence semicolon-newline-newline does. That is, type a semicolon immediately followed by a completely empty line. Backslash-newline is not treated specially in this mode. Again, there is no intelligence about such a sequence appearing within a string literal or comment.</source>
          <target state="translated">ただし、 &lt;code&gt;-j&lt;/code&gt; コマンドラインスイッチを使用した場合、単一の改行でコマンドエントリが終了することはありません。代わりに、セミコロン-改行-改行というシーケンスが行います。つまり、セミコロンの直後に完全に空の行を入力します。このモードでは、バックスラッシュと改行は特別に扱われません。この場合も、文字列リテラルまたはコメント内に出現するそのようなシーケンスに関する情報はありません。</target>
        </trans-unit>
        <trans-unit id="f29dbb61f87fc9cd4617a00bcc7185e6a0e0f4d5" translate="yes" xml:space="preserve">
          <source>But minimal WAL does not contain enough information to reconstruct the data from a base backup and the WAL logs, so &lt;code&gt;replica&lt;/code&gt; or higher must be used to enable WAL archiving (&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt;) and streaming replication.</source>
          <target state="translated">ただし、最小限のWALには、ベースバックアップとWALログからデータを再構築するための十分な情報が含まれていないため、WALアーカイブ（&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt;）およびストリーミングレプリケーションを有効にするには、 &lt;code&gt;replica&lt;/code&gt; 以上を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff32a7d1b246935a4ae3a58c792ebf05564a55cb" translate="yes" xml:space="preserve">
          <source>But there's a problem: the &lt;code&gt;WHERE&lt;/code&gt; clause refers to &lt;code&gt;success&lt;/code&gt; which is not available as a result column of the index. Nonetheless, an index-only scan is possible because the plan does not need to recheck that part of the &lt;code&gt;WHERE&lt;/code&gt; clause at run time: all entries found in the index necessarily have &lt;code&gt;success = true&lt;/code&gt; so this need not be explicitly checked in the plan. PostgreSQL versions 9.6 and later will recognize such cases and allow index-only scans to be generated, but older versions will not.</source>
          <target state="translated">しかし、問題があります &lt;code&gt;WHERE&lt;/code&gt; 句は、インデックスの結果列として使用できない &lt;code&gt;success&lt;/code&gt; を参照しています。それでも、プランは実行時に &lt;code&gt;WHERE&lt;/code&gt; 句のその部分を再チェックする必要がないため、インデックスのみのスキャンが可能です。インデックスで見つかったすべてのエントリは必ず &lt;code&gt;success = true&lt;/code&gt; ので、プランで明示的にチェックする必要はありません。PostgreSQLバージョン9.6以降では、このようなケースが認識され、インデックスのみのスキャンを生成できますが、古いバージョンでは生成できません。</target>
        </trans-unit>
        <trans-unit id="4ca875b680fdb97fc74f9300d7be351d9a268b49" translate="yes" xml:space="preserve">
          <source>But these are not:</source>
          <target state="translated">しかし、これらはそうではありません。</target>
        </trans-unit>
        <trans-unit id="a6f6a57b5a3f46981dddd10346050b6e06f08985" translate="yes" xml:space="preserve">
          <source>But this is an error:</source>
          <target state="translated">しかし、これはエラーです。</target>
        </trans-unit>
        <trans-unit id="accaa3dea52db94367cfe201c42c88caefb30d09" translate="yes" xml:space="preserve">
          <source>But this is safe:</source>
          <target state="translated">でも、これは安全です。</target>
        </trans-unit>
        <trans-unit id="44cc34850e38168bd2b77ca3e32ee99a97567661" translate="yes" xml:space="preserve">
          <source>But this requires visiting both indexes, so it's not necessarily a win compared to using just one index and treating the other condition as a filter. If you vary the ranges involved you'll see the plan change accordingly.</source>
          <target state="translated">しかし、これは両方のインデックスを訪問する必要があるので、片方のインデックスだけを使ってもう片方の条件をフィルタとして扱うのに比べれば、必ずしも勝てるとは限りません。関与する範囲を変えれば、それに応じて計画が変わるのがわかるでしょう。</target>
        </trans-unit>
        <trans-unit id="4e48dc70b851014d5e67f11a0b7f3119e8e08c81" translate="yes" xml:space="preserve">
          <source>But without multivariate statistics, the estimate for the number of groups in a query with two columns in &lt;code&gt;GROUP BY&lt;/code&gt;, as in the following example, is off by an order of magnitude:</source>
          <target state="translated">ただし、多変量統計がない場合、次の例のように、 &lt;code&gt;GROUP BY&lt;/code&gt; に 2つの列があるクエリのグループ数の推定は、桁違いにずれています。</target>
        </trans-unit>
        <trans-unit id="4aef23c855b410735a4672255ed03112924e3fc7" translate="yes" xml:space="preserve">
          <source>But, of course, this calendar is only valid for Great Britain and dominions, not other places. Since it would be difficult and confusing to try to track the actual calendars that were in use in various places at various times, PostgreSQL does not try, but rather follows the Gregorian calendar rules for all dates, even though this method is not historically accurate.</source>
          <target state="translated">しかし、当然ながら、この暦は英国と領国にのみ有効であり、他の場所では有効ではありません。様々な場所で様々な時代に使用されていた実際の暦を追跡しようとするのは困難で混乱を招くので、PostgreSQLは試みず、この方法は歴史的に正確ではないにしても、すべての日付についてグレゴリオ暦の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="50b0ebe5a19d2b28b3ec57041c04e85532ece01c" translate="yes" xml:space="preserve">
          <source>By default (that is, when &lt;a href=&quot;runtime-config-query#GUC-PLAN-CACHE_MODE&quot;&gt;plan_cache_mode&lt;/a&gt; is set to &lt;code&gt;auto&lt;/code&gt;), the server will automatically choose whether to use a generic or custom plan for a prepared statement that has parameters. The current rule for this is that the first five executions are done with custom plans and the average estimated cost of those plans is calculated. Then a generic plan is created and its estimated cost is compared to the average custom-plan cost. Subsequent executions use the generic plan if its cost is not so much higher than the average custom-plan cost as to make repeated replanning seem preferable.</source>
          <target state="translated">デフォルトでは（つまり、&lt;a href=&quot;runtime-config-query#GUC-PLAN-CACHE_MODE&quot;&gt;plan_cache_mode&lt;/a&gt;が &lt;code&gt;auto&lt;/code&gt; に設定されている場合）、サーバーは、パラメーターを持つ準備されたステートメントに汎用プランとカスタムプランのどちらを使用するかを自動的に選択します。現在のルールでは、最初の5つの実行はカスタムプランで実行され、それらのプランの平均推定コストが計算されます。次に、一般的な計画が作成され、その推定コストが平均のカスタム計画コストと比較されます。後続の実行では、そのコストが平均のカスタムプランのコストよりも高くなく、再計画を繰り返すことが望ましいように見える場合に、ジェネリックプランを使用します。</target>
        </trans-unit>
        <trans-unit id="13ce471ea5f04800baa0f0ecc31a88ceee3c919e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;postgres&lt;/code&gt; starts in the foreground and prints log messages to the standard error stream. In practical applications &lt;code&gt;postgres&lt;/code&gt; should be started as a background process, perhaps at boot time.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;postgres&lt;/code&gt; はフォアグラウンドで起動し、ログメッセージを標準エラーストリームに出力します。実際のアプリケーションでは、おそらく起動時に &lt;code&gt;postgres&lt;/code&gt; をバックグラウンドプロセスとして開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="c089fc5daeae114cff2ba4b221ff57c41409f19d" translate="yes" xml:space="preserve">
          <source>By default all foreign tables using &lt;code&gt;postgres_fdw&lt;/code&gt; are assumed to be updatable. This may be overridden using the following option:</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;postgres_fdw&lt;/code&gt; を使用するすべての外部テーブルは更新可能であると見なされます。これは、次のオプションを使用してオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="7f347a9a45b3a87f36b46205b565cc13692102c6" translate="yes" xml:space="preserve">
          <source>By default use is restricted to superusers and members of the &lt;code&gt;pg_read_all_stats&lt;/code&gt; role. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、使用はスーパーユーザーと &lt;code&gt;pg_read_all_stats&lt;/code&gt; ロールのメンバーに制限されています。 &lt;code&gt;GRANT&lt;/code&gt; を使用して他のユーザーにアクセスを許可することができます。</target>
        </trans-unit>
        <trans-unit id="c5eb9a4b1f5db5b0c40d78042f064f1e9a056def" translate="yes" xml:space="preserve">
          <source>By default use is restricted to superusers and members of the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、使用はスーパーユーザーと &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; ロールのメンバーに制限されています。 &lt;code&gt;GRANT&lt;/code&gt; を使用して他のユーザーにアクセスを許可することができます。</target>
        </trans-unit>
        <trans-unit id="6c608d37b651cf68db387435a834eaf1d2af114f" translate="yes" xml:space="preserve">
          <source>By default use is restricted to superusers, members of the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role, and users with &lt;code&gt;SELECT&lt;/code&gt; permissions on the table.</source>
          <target state="translated">デフォルトでは、使用はスーパーユーザー、 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; ロールのメンバー、およびテーブルに対する &lt;code&gt;SELECT&lt;/code&gt; 権限を持つユーザーに制限されています。</target>
        </trans-unit>
        <trans-unit id="35037bbd451cbdc76924f4075f03adbfb4640f34" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;\prompt&lt;/code&gt; uses the terminal for input and output. However, if the &lt;code&gt;-f&lt;/code&gt; command line switch was used, &lt;code&gt;\prompt&lt;/code&gt; uses standard input and standard output.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;\prompt&lt;/code&gt; は入出力に端末を使用します。ただし、 &lt;code&gt;-f&lt;/code&gt; コマンドラインスイッチを使用した場合、 &lt;code&gt;\prompt&lt;/code&gt; は標準入力と標準出力を使用します。</target>
        </trans-unit>
        <trans-unit id="f78e158d60bdcbfa2aa7d2e55e101b4676b65b34" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;initdb&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;initdb&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the data directory corrupt. Generally, this option is useful for testing, but should not be used when creating a production installation.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;initdb&lt;/code&gt; はすべてのファイルが安全にディスクに書き込まれるまで待機します。このオプションを &lt;code&gt;initdb&lt;/code&gt; すると、initdbは待機せずに戻ります。これは高速ですが、その後のオペレーティングシステムのクラッシュにより、データディレクトリが破損する可能性があります。通常、このオプションはテストには役立ちますが、実稼働インストールを作成する場合は使用しないでください。</target>
        </trans-unit>
        <trans-unit id="ce1347bf37780a515db01fc3f42a28d865be94d4" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_basebackup&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_basebackup&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the base backup corrupt. Generally, this option is useful for testing but should not be used when creating a production installation.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_basebackup&lt;/code&gt; はすべてのファイルがディスクに安全に書き込まれるまで待機します。このオプションにより、 &lt;code&gt;pg_basebackup&lt;/code&gt; は待機せずに戻ります。これは高速ですが、その後のオペレーティングシステムのクラッシュにより、ベースバックアップが破損したままになる可能性があります。通常、このオプションはテストには役立ちますが、実稼働インストールを作成するときには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="3a18a12b0f883d660ff6c8520bf255ac929ed7d2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_checksums&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_checksums&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the updated data directory corrupt. Generally, this option is useful for testing but should not be used on a production installation. This option has no effect when using &lt;code&gt;--check&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_checksums&lt;/code&gt; はすべてのファイルが安全にディスクに書き込まれるのを待ちます。このオプションを &lt;code&gt;pg_checksums&lt;/code&gt; すると、pg_checksumsは待機せずに戻ります。これは高速ですが、その後のオペレーティングシステムのクラッシュにより、更新されたデータディレクトリが破損したままになる可能性があります。通常、このオプションはテストには役立ちますが、実稼働環境では使用しないでください。 &lt;code&gt;--check&lt;/code&gt; を使用する場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="4d204457a7c533537a8ef60c679036dd19b2101e" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_dump&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_dump&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the dump corrupt. Generally, this option is useful for testing but should not be used when dumping data from production installation.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_dump&lt;/code&gt; はすべてのファイルが安全にディスクに書き込まれるのを待ちます。このオプションにより、 &lt;code&gt;pg_dump&lt;/code&gt; は待機せずに戻ります。これは高速ですが、その後のオペレーティングシステムのクラッシュにより、ダンプが破損する可能性があります。通常、このオプションはテストには役立ちますが、本番環境のインストールからデータをダンプする場合は使用しないでください。</target>
        </trans-unit>
        <trans-unit id="c0f49fbd975cf48bcd27fb1f035994c8051d90b2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_dumpall&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_dumpall&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the dump corrupt. Generally, this option is useful for testing but should not be used when dumping data from production installation.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_dumpall&lt;/code&gt; はすべてのファイルが安全にディスクに書き込まれるのを待ちます。このオプションにより、 &lt;code&gt;pg_dumpall&lt;/code&gt; は待機せずに戻ります。これは高速ですが、その後のオペレーティングシステムのクラッシュにより、ダンプが破損したままになる可能性があります。通常、このオプションはテストには役立ちますが、本番環境のインストールからデータをダンプする場合は使用しないでください。</target>
        </trans-unit>
        <trans-unit id="67e32dd79cf143919ce3c6f7a4d75d7a165f5ad4" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_rewind&lt;/code&gt; will wait for all files to be written safely to disk. This option causes &lt;code&gt;pg_rewind&lt;/code&gt; to return without waiting, which is faster, but means that a subsequent operating system crash can leave the synchronized data directory corrupt. Generally, this option is useful for testing but should not be used when creating a production installation.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_rewind&lt;/code&gt; はすべてのファイルがディスクに安全に書き込まれるまで待機します。このオプションにより、 &lt;code&gt;pg_rewind&lt;/code&gt; は待機せずに戻ります。これは高速ですが、その後のオペレーティングシステムのクラッシュにより、同期されたデータディレクトリが破損する可能性があります。通常、このオプションはテストには役立ちますが、実稼働インストールを作成するときには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="be51caa2ed6f2929431841a2d94a49fd4f5675c6" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_start_backup&lt;/code&gt; can take a long time to finish. This is because it performs a checkpoint, and the I/O required for the checkpoint will be spread out over a significant period of time, by default half your inter-checkpoint interval (see the configuration parameter &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt;). This is usually what you want, because it minimizes the impact on query processing. If you want to start the backup as soon as possible, change the second parameter to &lt;code&gt;true&lt;/code&gt;, which will issue an immediate checkpoint using as much I/O as available.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_start_backup&lt;/code&gt; の終了には長い時間がかかる場合があります。これは、チェックポイントを実行し、チェックポイントに必要なI / Oが、デフォルトではチェックポイント間間隔の半分のかなりの期間にわたって分散されるためです（構成パラメーター&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_targetを&lt;/a&gt;参照）。クエリ処理への影響を最小限に抑えるため、これは通常必要なことです。できるだけ早くバックアップを開始する場合は、2番目のパラメーターを &lt;code&gt;true&lt;/code&gt; に変更します。これにより、可能な限り多くのI / Oを使用して即時チェックポイントが発行されます。</target>
        </trans-unit>
        <trans-unit id="824ed3b8d5605e6a123037241b401483b28267f6" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pg_start_backup&lt;/code&gt; can take a long time to finish. This is because it performs a checkpoint, and the I/O required for the checkpoint will be spread out over a significant period of time, by default half your inter-checkpoint interval (see the configuration parameter &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt;). This is usually what you want, because it minimizes the impact on query processing. If you want to start the backup as soon as possible, use:</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_start_backup&lt;/code&gt; の終了には長い時間がかかる場合があります。これは、チェックポイントを実行し、チェックポイントに必要なI / Oが、デフォルトではチェックポイント間間隔の半分のかなりの期間にわたって分散されるためです（構成パラメーター&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_targetを&lt;/a&gt;参照）。クエリ処理への影響を最小限に抑えるため、これは通常必要なことです。できるだけ早くバックアップを開始したい場合は、以下を使用します。</target>
        </trans-unit>
        <trans-unit id="727a3042f84c21b7c863ee84e972a1a5591760e4" translate="yes" xml:space="preserve">
          <source>By default, B-tree indexes store their entries in ascending order with nulls last (table TID is treated as a tiebreaker column among otherwise equal entries). This means that a forward scan of an index on column &lt;code&gt;x&lt;/code&gt; produces output satisfying &lt;code&gt;ORDER BY x&lt;/code&gt; (or more verbosely, &lt;code&gt;ORDER BY x ASC NULLS LAST&lt;/code&gt;). The index can also be scanned backward, producing output satisfying &lt;code&gt;ORDER BY x DESC&lt;/code&gt; (or more verbosely, &lt;code&gt;ORDER BY x DESC NULLS FIRST&lt;/code&gt;, since &lt;code&gt;NULLS FIRST&lt;/code&gt; is the default for &lt;code&gt;ORDER BY DESC&lt;/code&gt;).</source>
          <target state="translated">デフォルトでは、Bツリーインデックスはエントリを昇順で格納し、最後にnullを付けます（テーブルTIDは他の点では等しいエントリ間のタイブレーカー列として扱われます）。これは、列 &lt;code&gt;x&lt;/code&gt; のインデックスのフォワードスキャンにより、 &lt;code&gt;ORDER BY x&lt;/code&gt; （またはより詳細には &lt;code&gt;ORDER BY x ASC NULLS LAST&lt;/code&gt; ）を満たす出力が生成されることを意味します。インデックスを逆方向にスキャンして、 &lt;code&gt;ORDER BY x DESC&lt;/code&gt; （または、より詳細には、 &lt;code&gt;ORDER BY x DESC NULLS FIRST&lt;/code&gt; （ &lt;code&gt;NULLS FIRST&lt;/code&gt; が &lt;code&gt;ORDER BY DESC&lt;/code&gt; のデフォルトであるため）を満たす出力）を生成することもできます。</target>
        </trans-unit>
        <trans-unit id="f6d5d67ccaf09eaeb6ef7377a91514709c5059c7" translate="yes" xml:space="preserve">
          <source>By default, PostgreSQL allocates a very small amount of System V shared memory, as well as a much larger amount of anonymous &lt;code&gt;mmap&lt;/code&gt; shared memory. Alternatively, a single large System V shared memory region can be used (see &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt;). In addition a significant number of semaphores, which can be either System V or POSIX style, are created at server startup. Currently, POSIX semaphores are used on Linux and FreeBSD systems while other platforms use System V semaphores.</source>
          <target state="translated">デフォルトでは、PostgreSQLは非常に少量のSystem V共有メモリと、はるかに大量の匿名 &lt;code&gt;mmap&lt;/code&gt; 共有メモリを割り当てます。または、単一の大きなSystem V共有メモリ領域を使用できます（&lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_typeを&lt;/a&gt;参照）。さらに、かなりの数のセマフォ（System VまたはPOSIXスタイルのいずれか）がサーバーの起動時に作成されます。現在、POSIXセマフォはLinuxおよびFreeBSDシステムで使用されていますが、他のプラットフォームではSystem Vセマフォが使用されています。</target>
        </trans-unit>
        <trans-unit id="7d5112c6a6f4a183b23febd8e6d04aee3595be29" translate="yes" xml:space="preserve">
          <source>By default, PostgreSQL assigns the names &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. to the columns of a &lt;code&gt;VALUES&lt;/code&gt; table. The column names are not specified by the SQL standard and different database systems do it differently, so it's usually better to override the default names with a table alias list, like this:</source>
          <target state="translated">デフォルトでは、PostgreSQL は &lt;code&gt;VALUES&lt;/code&gt; テーブルの列に &lt;code&gt;column1&lt;/code&gt; 、 &lt;code&gt;column2&lt;/code&gt; などの名前を割り当てます。列名はSQL標準では指定されておらず、データベースシステムごとに異なる方法で指定されるため、通常は次のように、デフォルトの名前をテーブルエイリアスリストでオーバーライドすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="95bcb0edee685e99045ff9209204f6710283bfbb" translate="yes" xml:space="preserve">
          <source>By default, a GiST index build switches to the buffering method when the index size reaches &lt;a href=&quot;runtime-config-query#GUC-EFFECTIVE-CACHE-SIZE&quot;&gt;effective_cache_size&lt;/a&gt;. It can be manually turned on or off by the &lt;code&gt;buffering&lt;/code&gt; parameter to the CREATE INDEX command. The default behavior is good for most cases, but turning buffering off might speed up the build somewhat if the input data is ordered.</source>
          <target state="translated">デフォルトでは、GiSTインデックスビルドは、インデックスサイズが&lt;a href=&quot;runtime-config-query#GUC-EFFECTIVE-CACHE-SIZE&quot;&gt;effective_cache_sizeに&lt;/a&gt;達するとバッファリング方式に切り替わります。CREATE INDEXコマンドの &lt;code&gt;buffering&lt;/code&gt; パラメータによって手動でオンまたはオフにできます。デフォルトの動作はほとんどの場合に適していますが、入力データが順序付けされている場合、バッファリングをオフにすると、ビルドが多少高速化する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9518ab9b08e7bcd057eb1671276711e3db7a05db" translate="yes" xml:space="preserve">
          <source>By default, a cast can be invoked only by an explicit cast request, that is an explicit &lt;code&gt;CAST(x AS typename)&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;&lt;code&gt;::&lt;/code&gt;&lt;code&gt;typename&lt;/code&gt; construct.</source>
          <target state="translated">デフォルトでは、キャストは明示的なキャスト要求、つまり明示的な &lt;code&gt;CAST(x AS typename)&lt;/code&gt; または &lt;code&gt;x&lt;/code&gt; &lt;code&gt;::&lt;/code&gt; &lt;code&gt;typename&lt;/code&gt; 構成によってのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="78836ce5d2eb0478baace71feb0580df09029d89" translate="yes" xml:space="preserve">
          <source>By default, a side-effect-free &lt;code&gt;WITH&lt;/code&gt; query is folded into the primary query if it is used exactly once in the primary query's &lt;code&gt;FROM&lt;/code&gt; clause. This allows joint optimization of the two query levels in situations where that should be semantically invisible. However, such folding can be prevented by marking the &lt;code&gt;WITH&lt;/code&gt; query as &lt;code&gt;MATERIALIZED&lt;/code&gt;. That might be useful, for example, if the &lt;code&gt;WITH&lt;/code&gt; query is being used as an optimization fence to prevent the planner from choosing a bad plan. PostgreSQL versions before v12 never did such folding, so queries written for older versions might rely on &lt;code&gt;WITH&lt;/code&gt; to act as an optimization fence.</source>
          <target state="translated">デフォルトでは、副作用のない &lt;code&gt;WITH&lt;/code&gt; クエリは、プライマリクエリの &lt;code&gt;FROM&lt;/code&gt; 句で1回だけ使用されると、プライマリクエリに折りたたまれます。これにより、意味的に見えない状況で2つのクエリレベルを同時に最適化できます。ただし、このような折りたたみは、 &lt;code&gt;WITH&lt;/code&gt; クエリを &lt;code&gt;MATERIALIZED&lt;/code&gt; としてマークすることで防ぐことができます。たとえば、 &lt;code&gt;WITH&lt;/code&gt; クエリが最適化フェンスとして使用されており、プランナが不適切なプランを選択できないようにする場合に役立ちます。 v12より前のPostgreSQLバージョンではこのようなフォールディングは行われなかったため、古いバージョン用に作成されたクエリは、最適化フェンスとして機能するために &lt;code&gt;WITH&lt;/code&gt; に依存する場合があります。</target>
        </trans-unit>
        <trans-unit id="f707e3c37120d93e6cd7bf3ab1d3cdf9ae694731" translate="yes" xml:space="preserve">
          <source>By default, a standby server restores WAL records from the sending server as soon as possible. It may be useful to have a time-delayed copy of the data, offering opportunities to correct data loss errors. This parameter allows you to delay recovery by a specified amount of time. For example, if you set this parameter to &lt;code&gt;5min&lt;/code&gt;, the standby will replay each transaction commit only when the system time on the standby is at least five minutes past the commit time reported by the master. If this value is specified without units, it is taken as milliseconds. The default is zero, adding no delay.</source>
          <target state="translated">デフォルトでは、スタンバイサーバーは送信サーバーからWALレコードをできるだけ早く復元します。データの遅延コピーを作成して、データ損失エラーを修正する機会を提供すると便利な場合があります。このパラメーターを使用すると、指定した時間だけ回復を遅らせることができます。たとえば、このパラメーターを &lt;code&gt;5min&lt;/code&gt; に設定すると、スタンバイのシステム時間がマスターから報告されたコミット時間を少なくとも5分超えた場合にのみ、スタンバイは各トランザクションのコミットを再生します。この値が単位なしで指定されている場合、ミリ秒と見なされます。デフォルトはゼロで、遅延はありません。</target>
        </trans-unit>
        <trans-unit id="0062f220bac13d83889b8bdbd40b0e28de2cbf32" translate="yes" xml:space="preserve">
          <source>By default, all tables and views existing in a particular schema on the foreign server are imported. Optionally, the list of tables can be limited to a specified subset, or specific tables can be excluded. The new foreign tables are all created in the target schema, which must already exist.</source>
          <target state="translated">デフォルトでは、外部サーバー上の特定のスキーマに存在するすべてのテーブルとビューがインポートされます。オプションで、テーブルのリストを指定したサブセットに制限したり、特定のテーブルを除外したりすることができます。新しい外部テーブルはすべてターゲットスキーマに作成されますが、すでに存在している必要があります。</target>
        </trans-unit>
        <trans-unit id="6ff32c06ed2b330c24aacf6672aa71190f12a8e0" translate="yes" xml:space="preserve">
          <source>By default, checksums are verified and checksum failures will result in a non-zero exit status. However, the base backup will not be removed in such a case, as if the &lt;code&gt;--no-clean&lt;/code&gt; option had been used. Checksum verifications failures will also be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="translated">デフォルトでは、チェックサムが検証され、チェックサムの失敗はゼロ以外の終了ステータスになります。ただし、そのような場合、 &lt;code&gt;--no-clean&lt;/code&gt; オプションが使用されたかのように、ベースバックアップは削除されません。チェックサム検証の失敗は、&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt;ビューでも報告されます。</target>
        </trans-unit>
        <trans-unit id="a560a90f898f8246e7e4f7444eb268c641b6dc5b" translate="yes" xml:space="preserve">
          <source>By default, command processing continues after an error. When this variable is set to &lt;code&gt;on&lt;/code&gt;, processing will instead stop immediately. In interactive mode, psql will return to the command prompt; otherwise, psql will exit, returning error code 3 to distinguish this case from fatal error conditions, which are reported using error code 1. In either case, any currently running scripts (the top-level script, if any, and any other scripts which it may have in invoked) will be terminated immediately. If the top-level command string contained multiple SQL commands, processing will stop with the current command.</source>
          <target state="translated">デフォルトでは、コマンド処理はエラー後も続行されます。この変数が &lt;code&gt;on&lt;/code&gt; に設定されている場合、処理は代わりにすぐに停止します。対話モードでは、psqlはコマンドプロンプトに戻ります。そうでない場合、psqlは終了し、エラーコード3を返して、このケースを致命的なエラー状態と区別します。致命的なエラー状態は、エラーコード1を使用して報告されます。どちらの場合でも、現在実行中のスクリプト（存在する場合はトップレベルのスクリプト）とその他のスクリプト呼び出された可能性があります）すぐに終了します。トップレベルのコマンド文字列に複数のSQLコマンドが含まれている場合、処理は現在のコマンドで停止します。</target>
        </trans-unit>
        <trans-unit id="c496804ab443f5ab6f5251de611b0ed906df79f8" translate="yes" xml:space="preserve">
          <source>By default, connection log messages only show the IP address of the connecting host. Turning this parameter on causes logging of the host name as well. Note that depending on your host name resolution setup this might impose a non-negligible performance penalty. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">デフォルトでは、接続ログメッセージには接続ホストのIPアドレスのみが表示されます。このパラメーターをオンにすると、ホスト名もログに記録されます。ホスト名解決の設定によっては、無視できないほどのパフォーマンスの低下が生じる可能性があることに注意してください。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="b2cb10f9601bf125d113e5f98b6a6bec8328b483" translate="yes" xml:space="preserve">
          <source>By default, floating point values are output in text form in their shortest precise decimal representation; the decimal value produced is closer to the true stored binary value than to any other value representable in the same binary precision. (However, the output value is currently never &lt;em&gt;exactly&lt;/em&gt; midway between two representable values, in order to avoid a widespread bug where input routines do not properly respect the round-to-even rule.) This value will use at most 17 significant decimal digits for &lt;code&gt;float8&lt;/code&gt; values, and at most 9 digits for &lt;code&gt;float4&lt;/code&gt; values.</source>
          <target state="translated">デフォルトでは、浮動小数点値はテキスト形式で最短の正確な10進表現で出力されます。生成される10進値は、同じバイナリ精度で表現可能な他の値よりも、実際に保存されているバイナリ値に近くなります。 （ただし、入力ルーチンが四捨五入の規則を適切に考慮しないという広範囲にわたるバグを回避するために、現在、出力値は2つの表現可能な値の&lt;em&gt;ちょうど&lt;/em&gt;中間ではありません。）この値は、最大で17桁の有効桁数を使用します。 &lt;code&gt;float8&lt;/code&gt; 値、および &lt;code&gt;float4&lt;/code&gt; 値の最大9桁。</target>
        </trans-unit>
        <trans-unit id="b8ea675b27a48f435ea5af00f412fdb479b874ca" translate="yes" xml:space="preserve">
          <source>By default, only &lt;code&gt;WHERE&lt;/code&gt; clauses using built-in operators and functions will be considered for execution on the remote server. Clauses involving non-built-in functions are checked locally after rows are fetched. If such functions are available on the remote server and can be relied on to produce the same results as they do locally, performance can be improved by sending such &lt;code&gt;WHERE&lt;/code&gt; clauses for remote execution. This behavior can be controlled using the following option:</source>
          <target state="translated">デフォルトでは、組み込みの演算子と関数を使用する &lt;code&gt;WHERE&lt;/code&gt; 句のみが、リモートサーバーでの実行が考慮されます。非組み込み関数を含む句は、行がフェッチされた後にローカルでチェックされます。そのような関数がリモートサーバーで利用可能であり、ローカルと同じ結果を生成するために信頼できる場合は、そのような &lt;code&gt;WHERE&lt;/code&gt; 句をリモート実行に送信することでパフォーマンスを向上できます。この動作は、次のオプションを使用して制御できます。</target>
        </trans-unit>
        <trans-unit id="b44430e6dc22e36766f26461b571e7fad5599537" translate="yes" xml:space="preserve">
          <source>By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。</target>
        </trans-unit>
        <trans-unit id="84eca666e9be0384ce24adaa941223dc1388c0fe" translate="yes" xml:space="preserve">
          <source>By default, pg_dump uses &lt;code&gt;COPY&lt;/code&gt;, and when it is generating a complete schema-and-data dump, it is careful to load data before creating indexes and foreign keys. So in this case several guidelines are handled automatically. What is left for you to do is to:</source>
          <target state="translated">デフォルトでは、pg_dumpは &lt;code&gt;COPY&lt;/code&gt; を使用します。完全なスキーマとデータのダンプを生成するときは、インデックスと外部キーを作成する前にデータをロードするように注意してください。したがって、この場合、いくつかのガイドラインが自動的に処理されます。あなたがするために残されていることは次のことです：</target>
        </trans-unit>
        <trans-unit id="70659cc257c963a48edee3365f7ee706626aef7b" translate="yes" xml:space="preserve">
          <source>By default, probes are not available, so you will need to explicitly tell the configure script to make the probes available in PostgreSQL. To include DTrace support specify &lt;code&gt;--enable-dtrace&lt;/code&gt; to configure. See &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt; for further information.</source>
          <target state="translated">デフォルトではプローブは使用できないため、PostgreSQLでプローブを使用できるようにconfigureスクリプトに明示的に指示する必要があります。DTraceサポートを含めるには、設定する &lt;code&gt;--enable-dtrace&lt;/code&gt; を指定します。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;セクション16.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e34b0da35878a3936d296ebd79b8956e8e7181ad" translate="yes" xml:space="preserve">
          <source>By default, recovery will recover to the end of the WAL log. The following parameters can be used to specify an earlier stopping point. At most one of &lt;code&gt;recovery_target&lt;/code&gt;, &lt;code&gt;recovery_target_lsn&lt;/code&gt;, &lt;code&gt;recovery_target_name&lt;/code&gt;, &lt;code&gt;recovery_target_time&lt;/code&gt;, or &lt;code&gt;recovery_target_xid&lt;/code&gt; can be used; if more than one of these is specified in the configuration file, an error will be raised. These parameters can only be set at server start.</source>
          <target state="translated">デフォルトでは、回復はWALログの最後まで回復​​します。以下のパラメーターを使用して、より早い停止ポイントを指定できます。 &lt;code&gt;recovery_target&lt;/code&gt; 、 &lt;code&gt;recovery_target_lsn&lt;/code&gt; 、 &lt;code&gt;recovery_target_name&lt;/code&gt; 、 &lt;code&gt;recovery_target_time&lt;/code&gt; 、または &lt;code&gt;recovery_target_xid&lt;/code&gt; の最大1つを使用できます。これらが構成ファイルで複数指定されている場合、エラーが発生します。これらのパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="b68a7fa3368775dbbe67be55a6bf41e8f9011897" translate="yes" xml:space="preserve">
          <source>By default, table data is restored even if the creation command for the table failed (e.g., because it already exists). With this option, data for such a table is skipped. This behavior is useful if the target database already contains the desired table contents. For example, auxiliary tables for PostgreSQL extensions such as PostGIS might already be loaded in the target database; specifying this option prevents duplicate or obsolete data from being loaded into them.</source>
          <target state="translated">既定では、テーブルの作成コマンドが失敗した場合(既に存在するためなど)であっても、テーブルのデータはリストアされます。このオプションを指定すると、そのようなテーブルのデータはスキップされます。この動作は、ターゲットデータベースに目的のテーブルの内容が既に含まれている場合に便利です。例えば、PostGISなどのPostgreSQL拡張のための補助テーブルがターゲットデータベースに既にロードされているかもしれません。</target>
        </trans-unit>
        <trans-unit id="938bcc328e251fd065ac790e820d24708cece22b" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;pg_config&lt;/code&gt; view can be read only by superusers.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_config&lt;/code&gt; ビューはスーパーユーザーのみが読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="4ca1e9d32f7ce039fccc5e945dfbea3cfa377ca3" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;pg_file_settings&lt;/code&gt; view can be read only by superusers.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_file_settings&lt;/code&gt; ビューはスーパーユーザーのみが読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="11bc9b5dcf74fe244aef327d6abd1c9f703080a6" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;pg_hba_file_rules&lt;/code&gt; view can be read only by superusers.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_hba_file_rules&lt;/code&gt; ビューはスーパーユーザーのみが読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="a88f67228f7f2606ad9e9b6a422ac102dba107f7" translate="yes" xml:space="preserve">
          <source>By default, the array element type is the common type of the member expressions, determined using the same rules as for &lt;code&gt;UNION&lt;/code&gt; or &lt;code&gt;CASE&lt;/code&gt; constructs (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;). You can override this by explicitly casting the array constructor to the desired type, for example:</source>
          <target state="translated">デフォルトでは、配列要素の型はメンバー式の一般的な型であり、 &lt;code&gt;UNION&lt;/code&gt; または &lt;code&gt;CASE&lt;/code&gt; 構文と同じ規則を使用して決定されます（&lt;a href=&quot;typeconv-union-case&quot;&gt;セクション10.5を&lt;/a&gt;参照）。これをオーバーライドするには、配列コンストラクターを目的の型に明示的にキャストします。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="3591838c95961e914884bf460a76fd06162e5a35" translate="yes" xml:space="preserve">
          <source>By default, the lower bound index value of an array's dimensions is set to one. To represent arrays with other lower bounds, the array subscript ranges can be specified explicitly before writing the array contents. This decoration consists of square brackets (&lt;code&gt;[]&lt;/code&gt;) around each array dimension's lower and upper bounds, with a colon (&lt;code&gt;:&lt;/code&gt;) delimiter character in between. The array dimension decoration is followed by an equal sign (&lt;code&gt;=&lt;/code&gt;). For example:</source>
          <target state="translated">デフォルトでは、配列の次元の下限インデックス値は1に設定されています。他の下限で配列を表すには、配列の内容を書き込む前に、配列の添え字範囲を明示的に指定できます。この装飾は、（角括弧で構成されて &lt;code&gt;[]&lt;/code&gt; （コロンで、各配列の次元の上限と下限の周囲） &lt;code&gt;:&lt;/code&gt; ）との間に区切り文字。配列の次元の装飾の後には等号（ &lt;code&gt;=&lt;/code&gt; ）が続きます。例えば：</target>
        </trans-unit>
        <trans-unit id="bd894373c2bb27879ba8c09c0eb0e05e4db1539e" translate="yes" xml:space="preserve">
          <source>By default, the new database will be created by cloning the standard system database &lt;code&gt;template1&lt;/code&gt;. A different template can be specified by writing &lt;code&gt;TEMPLATE name&lt;/code&gt;. In particular, by writing &lt;code&gt;TEMPLATE template0&lt;/code&gt;, you can create a virgin database containing only the standard objects predefined by your version of PostgreSQL. This is useful if you wish to avoid copying any installation-local objects that might have been added to &lt;code&gt;template1&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、新しいデータベースは標準システムデータベース &lt;code&gt;template1&lt;/code&gt; 複製することによって作成されます。 &lt;code&gt;TEMPLATE name&lt;/code&gt; を書き込むことで、別のテンプレートを指定できます。特に、 &lt;code&gt;TEMPLATE template0&lt;/code&gt; を作成することにより、PostgreSQLのバージョンで事前定義された標準オブジェクトのみを含む新しいデータベースを作成できます。これは、 &lt;code&gt;template1&lt;/code&gt; に追加された可能性があるインストールローカルオブジェクトをコピーしないようにする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f862162ca39718449320291cb0bbfd45cc6c0117" translate="yes" xml:space="preserve">
          <source>By default, the psql script will continue to execute after an SQL error is encountered. You might wish to run psql with the &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; variable set to alter that behavior and have psql exit with an exit status of 3 if an SQL error occurs:</source>
          <target state="translated">デフォルトでは、psqlスクリプトはSQLエラーが発生した後も実行を続けます。 &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; 変数を設定してpsqlを実行し、その動作を変更し、SQLエラーが発生した場合にpsqlを終了ステータス3で終了させることができます。</target>
        </trans-unit>
        <trans-unit id="87f7d852da9b9d6ce1fdafcecffc01cbd65edbd0" translate="yes" xml:space="preserve">
          <source>By default, the value created by a &lt;code&gt;ROW&lt;/code&gt; expression is of an anonymous record type. If necessary, it can be cast to a named composite type &amp;mdash; either the row type of a table, or a composite type created with &lt;code&gt;CREATE TYPE AS&lt;/code&gt;. An explicit cast might be needed to avoid ambiguity. For example:</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;ROW&lt;/code&gt; 式によって作成される値は匿名のレコードタイプです。必要に応じて、名前付き複合タイプ（テーブルの行タイプ、または &lt;code&gt;CREATE TYPE AS&lt;/code&gt; で作成された複合タイプ）にキャストできます。あいまいさを避けるために、明示的なキャストが必要になる場合があります。例えば：</target>
        </trans-unit>
        <trans-unit id="a7a2912fb8fcc0f01a5b34a76950a5650d5bebcf" translate="yes" xml:space="preserve">
          <source>By default, these functions are executable only by superusers and members of the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role, with the exception of &lt;code&gt;pg_truncate_visibility_map(relation regclass)&lt;/code&gt; which can only be executed by superusers.</source>
          <target state="translated">デフォルトでは、これらの関数は、スーパーユーザーと &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; ロールのメンバーだけが実行できます。ただし、スーパーユーザーのみが実行できる &lt;code&gt;pg_truncate_visibility_map(relation regclass)&lt;/code&gt; は例外です。</target>
        </trans-unit>
        <trans-unit id="446669d309fb465403327b1660f824b344b44bfb" translate="yes" xml:space="preserve">
          <source>By default, this variable is set the same as &lt;code&gt;from_collapse_limit&lt;/code&gt;, which is appropriate for most uses. Setting it to 1 prevents any reordering of explicit &lt;code&gt;JOIN&lt;/code&gt;s. Thus, the explicit join order specified in the query will be the actual order in which the relations are joined. Because the query planner does not always choose the optimal join order, advanced users can elect to temporarily set this variable to 1, and then specify the join order they desire explicitly. For more information see &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、この変数は &lt;code&gt;from_collapse_limit&lt;/code&gt; と同じように設定されており、ほとんどの用途に適しています。これを1に設定すると、明示的な &lt;code&gt;JOIN&lt;/code&gt; の並べ替えが防止されます。したがって、クエリで指定された明示的な結合順序は、関係が結合される実際の順序になります。クエリプランナーは常に最適な結合順序を選択するわけではないため、上級ユーザーはこの変数を一時的に1に設定し、必要な結合順序を明示的に指定できます。詳細については、&lt;a href=&quot;explicit-joins&quot;&gt;セクション14.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a5fda89ea07462f31e5d8ea4c4e4b93c88a52d39" translate="yes" xml:space="preserve">
          <source>By default, users cannot access any objects in schemas they do not own. To allow that, the owner of the schema must grant the &lt;code&gt;USAGE&lt;/code&gt; privilege on the schema. To allow users to make use of the objects in the schema, additional privileges might need to be granted, as appropriate for the object.</source>
          <target state="translated">デフォルトでは、ユーザーは自分が所有していないスキーマのオブジェクトにはアクセスできません。これを可能にするには、スキーマの所有者がスキーマに対する &lt;code&gt;USAGE&lt;/code&gt; 特権を付与する必要があります。ユーザーがスキーマ内のオブジェクトを使用できるようにするには、オブジェクトに応じて、追加の特権を付与する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="6afb384acb9e661836b4ed370b6bfc2d551d532e" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;initdb&lt;/code&gt; determines that an error prevented it from completely creating the database cluster, it removes any files it might have created before discovering that it cannot finish the job. This option inhibits tidying-up and is thus useful for debugging.</source>
          <target state="translated">デフォルトでは、エラーによりデータベースクラスターを完全に作成できなかったと &lt;code&gt;initdb&lt;/code&gt; が判断した場合、initdbはジョブを完了できないことを検出する前に、作成した可能性のあるファイルをすべて削除します。このオプションは片付けを抑制し、デバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="9f3c7c286549c13ef09a8657f7d741258feadbff" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;pg_basebackup&lt;/code&gt; aborts with an error, it removes any directories it might have created before discovering that it cannot finish the job (for example, data directory and write-ahead log directory). This option inhibits tidying-up and is thus useful for debugging.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pg_basebackup&lt;/code&gt; はエラーで異常終了すると、ジョブを完了できないことを検出する前に作成した可能性のあるすべてのディレクトリ（データディレクトリや先行書き込みログディレクトリなど）を削除します。このオプションは片付けを抑制し、デバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="5d2d5200ed36b4f1ceba70175eb5ac569f06a690" translate="yes" xml:space="preserve">
          <source>By design, ICU will accept almost any string as a locale name and match it to the closest locale it can provide, using the fallback procedure described in its documentation. Thus, there will be no direct feedback if a collation specification is composed using features that the given ICU installation does not actually support. It is therefore recommended to create application-level test cases to check that the collation definitions satisfy one's requirements.</source>
          <target state="translated">設計上、ICUはほとんどすべての文字列をロケール名として受け入れ、ドキュメントに記述されているフォールバック処理を用いて、提供可能な最も近いロケールにマッチさせます。そのため、ICU のインストールが実際にはサポートしていない機能を使って照合仕様が構成されていても、直接的なフィードバックはありません。したがって、アプリケーションレベルのテストケースを作成して、照合の定義が要件を満たしているかどうかを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a5e9693cd42a9a7f1772aa42a6b36d8781e0c7b0" translate="yes" xml:space="preserve">
          <source>By redefining the statistics object to include n-distinct counts for the two columns, the estimate is much improved:</source>
          <target state="translated">統計オブジェクトを再定義して、2つの列のn個の区別のないカウントを含むようにしたことで、推定値が大幅に改善されました。</target>
        </trans-unit>
        <trans-unit id="ca686ce897e1abc4af0ddbb3c8a9400c719ef37e" translate="yes" xml:space="preserve">
          <source>By using tablespaces, an administrator can control the disk layout of a PostgreSQL installation. This is useful in at least two ways. First, if the partition or volume on which the cluster was initialized runs out of space and cannot be extended, a tablespace can be created on a different partition and used until the system can be reconfigured.</source>
          <target state="translated">tablespacesを使用することで、管理者はPostgreSQLインストールのディスクレイアウトを制御することができます。これは少なくとも2つの方法で有用です。第一に、クラスタが初期化されたパーティションやボリュームのスペースが不足して拡張できない場合、別のパーティションにテーブルスペースを作成して、システムが再構成できるまで使用することができます。</target>
        </trans-unit>
        <trans-unit id="4dc55e9079e768265d2074904a05887307e46957" translate="yes" xml:space="preserve">
          <source>By using the EXPLAIN command and the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; configuration parameter, it's possible to show the difference between a plan for which partitions have been pruned and one for which they have not. A typical unoptimized plan for this type of table setup is:</source>
          <target state="translated">EXPLAINコマンドと&lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt;構成パラメーターを使用することで、パーティションがプルーニングされたプランとプランニングされていないプランの違いを示すことができます。このタイプのテーブル設定の一般的な最適化されていない計画は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0dd73397fb8c38422ccd4664552ba4e84e357bc5" translate="yes" xml:space="preserve">
          <source>Bytes/Char</source>
          <target state="translated">Bytes/Char</target>
        </trans-unit>
        <trans-unit id="09acbb7d1da8aa3daff4c1ec8076713606974c64" translate="yes" xml:space="preserve">
          <source>CA</source>
          <target state="translated">CA</target>
        </trans-unit>
        <trans-unit id="1b3cb484695189b567d88ee9266fe7c295405a5c" translate="yes" xml:space="preserve">
          <source>CALL</source>
          <target state="translated">CALL</target>
        </trans-unit>
        <trans-unit id="419a5f50b7408f1dca60e896cea951f0e9ecd6b4" translate="yes" xml:space="preserve">
          <source>CALL &amp;mdash; invoke a procedure</source>
          <target state="translated">CALL &amp;mdash;プロシージャを呼び出す</target>
        </trans-unit>
        <trans-unit id="7477d3df9a8d34a128e2d80082cf97370f07e887" translate="yes" xml:space="preserve">
          <source>CHECKPOINT</source>
          <target state="translated">CHECKPOINT</target>
        </trans-unit>
        <trans-unit id="13213822c571d7742c3e15242191df8ccdfb4ba2" translate="yes" xml:space="preserve">
          <source>CHECKPOINT &amp;mdash; force a write-ahead log checkpoint</source>
          <target state="translated">CHECKPOINT &amp;mdash;先行書き込みログチェックポイントを強制する</target>
        </trans-unit>
        <trans-unit id="36977700f4822e3e205bf0238bce67dbe3b91b01" translate="yes" xml:space="preserve">
          <source>CIDR</source>
          <target state="translated">CIDR</target>
        </trans-unit>
        <trans-unit id="dbc87420347a2d9903d256035f6466489d185381" translate="yes" xml:space="preserve">
          <source>CLOSE</source>
          <target state="translated">CLOSE</target>
        </trans-unit>
        <trans-unit id="97a54a1a3cc7674867530dac20934b089b136388" translate="yes" xml:space="preserve">
          <source>CLOSE &amp;mdash; close a cursor</source>
          <target state="translated">CLOSE &amp;mdash;カーソルを閉じる</target>
        </trans-unit>
        <trans-unit id="e3b9b52696ca51803a72a1787b8689b560877e3b" translate="yes" xml:space="preserve">
          <source>CLUSTER</source>
          <target state="translated">CLUSTER</target>
        </trans-unit>
        <trans-unit id="6ed38588d12a88b9f02ddf8e838df59030bdc223" translate="yes" xml:space="preserve">
          <source>CLUSTER &amp;mdash; cluster a table according to an index</source>
          <target state="translated">CLUSTER &amp;mdash;インデックスに従ってテーブルをクラスター化する</target>
        </trans-unit>
        <trans-unit id="b1a13fadf51ef7eece7dea40c4b6e6e8042822d2" translate="yes" xml:space="preserve">
          <source>COMMENT</source>
          <target state="translated">COMMENT</target>
        </trans-unit>
        <trans-unit id="24f7342cb20d190bab761b0e4961854f758b7f6b" translate="yes" xml:space="preserve">
          <source>COMMENT &amp;mdash; define or change the comment of an object</source>
          <target state="translated">COMMENT &amp;mdash;オブジェクトのコメントを定義または変更します</target>
        </trans-unit>
        <trans-unit id="17e4d773881595e83eed7274990576cb3c33d081" translate="yes" xml:space="preserve">
          <source>COMMIT</source>
          <target state="translated">COMMIT</target>
        </trans-unit>
        <trans-unit id="483a6ce560e1decead0608ec6f96c5eb80c60b37" translate="yes" xml:space="preserve">
          <source>COMMIT &amp;mdash; commit the current transaction</source>
          <target state="translated">COMMIT &amp;mdash;現在のトランザクションをコミットします</target>
        </trans-unit>
        <trans-unit id="928f39135ea222a061b51eda52616e1d70b6f4ed" translate="yes" xml:space="preserve">
          <source>COMMIT PREPARED</source>
          <target state="translated">コミットプレパレーション</target>
        </trans-unit>
        <trans-unit id="7efac7831084dae760da22dfe2ccdf6a8467284f" translate="yes" xml:space="preserve">
          <source>COMMIT PREPARED &amp;mdash; commit a transaction that was earlier prepared for two-phase commit</source>
          <target state="translated">COMMIT PREPARED &amp;mdash;以前に2フェーズコミット用に準備されたトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="aecf0292da85cb2048d8b648567127d024d4074f" translate="yes" xml:space="preserve">
          <source>COPY</source>
          <target state="translated">COPY</target>
        </trans-unit>
        <trans-unit id="f9753e0a6bebe6b414113aa884e48a8692c57a00" translate="yes" xml:space="preserve">
          <source>COPY &amp;mdash; copy data between a file and a table</source>
          <target state="translated">COPY &amp;mdash;ファイルとテーブルの間でデータをコピーする</target>
        </trans-unit>
        <trans-unit id="ea0b6538392d829d8b749d944b7acd94dee0ddb6" translate="yes" xml:space="preserve">
          <source>CPAN</source>
          <target state="translated">CPAN</target>
        </trans-unit>
        <trans-unit id="d96e1a6da4b22e767e2f00e6ac5822929d6b6431" translate="yes" xml:space="preserve">
          <source>CREATE ACCESS METHOD</source>
          <target state="translated">CREATE ACCESS METHOD</target>
        </trans-unit>
        <trans-unit id="b60ba4afed837bb62b0e217ef3453fec9b20aa8b" translate="yes" xml:space="preserve">
          <source>CREATE ACCESS METHOD &amp;mdash; define a new access method</source>
          <target state="translated">CREATE ACCESS METHOD &amp;mdash;新しいアクセス方法を定義する</target>
        </trans-unit>
        <trans-unit id="dca4577463aa3fe977b4f25b93142362498a7ab4" translate="yes" xml:space="preserve">
          <source>CREATE AGGREGATE</source>
          <target state="translated">CREATE AGGREGATE</target>
        </trans-unit>
        <trans-unit id="1e5d6e908efdad05a1dfb7400a1512114a9ba148" translate="yes" xml:space="preserve">
          <source>CREATE AGGREGATE &amp;mdash; define a new aggregate function</source>
          <target state="translated">CREATE AGGREGATE &amp;mdash;新しい集約関数を定義する</target>
        </trans-unit>
        <trans-unit id="27453be4f19eeb395ed1c1f26aee7e6994d6f565" translate="yes" xml:space="preserve">
          <source>CREATE CAST</source>
          <target state="translated">クリエイトキャスト</target>
        </trans-unit>
        <trans-unit id="5b11bc113a182153b70257c85a8f9b6e3a11ce42" translate="yes" xml:space="preserve">
          <source>CREATE CAST &amp;mdash; define a new cast</source>
          <target state="translated">CREATE CAST &amp;mdash;新しいキャストを定義する</target>
        </trans-unit>
        <trans-unit id="15821e9ce820c98a60236ff18257f17f124c1103" translate="yes" xml:space="preserve">
          <source>CREATE COLLATION</source>
          <target state="translated">コラボレーションを作成する</target>
        </trans-unit>
        <trans-unit id="fbcbd528094c2c09b27455d50f5f56aa490f8fbc" translate="yes" xml:space="preserve">
          <source>CREATE COLLATION &amp;mdash; define a new collation</source>
          <target state="translated">CREATE COLLATION &amp;mdash;新しい照合を定義する</target>
        </trans-unit>
        <trans-unit id="9a590dab7b1573de682ed6118e55cc8e20312a59" translate="yes" xml:space="preserve">
          <source>CREATE CONVERSION</source>
          <target state="translated">クリエイト変換</target>
        </trans-unit>
        <trans-unit id="6193de73c2aaf0a006c421f6069d282ec6fd1764" translate="yes" xml:space="preserve">
          <source>CREATE CONVERSION &amp;mdash; define a new encoding conversion</source>
          <target state="translated">CREATE CONVERSION &amp;mdash;新しいエンコーディング変換を定義します</target>
        </trans-unit>
        <trans-unit id="7d4062ecf576482c660a1aa699cc54b88d165ea7" translate="yes" xml:space="preserve">
          <source>CREATE DATABASE</source>
          <target state="translated">CREATE DATABASE</target>
        </trans-unit>
        <trans-unit id="7c394e959f481a40604ae937a3ac22ef5ebc2056" translate="yes" xml:space="preserve">
          <source>CREATE DATABASE &amp;mdash; create a new database</source>
          <target state="translated">CREATE DATABASE &amp;mdash;新しいデータベースを作成する</target>
        </trans-unit>
        <trans-unit id="b70b81109668b468c0c6dead2038258a2d265479" translate="yes" xml:space="preserve">
          <source>CREATE DOMAIN</source>
          <target state="translated">クリエイトドメイン</target>
        </trans-unit>
        <trans-unit id="e9fdc1a9b6d567085f0f98916df0ab99c45f6576" translate="yes" xml:space="preserve">
          <source>CREATE DOMAIN &amp;mdash; define a new domain</source>
          <target state="translated">CREATE DOMAIN &amp;mdash;新しいドメインを定義する</target>
        </trans-unit>
        <trans-unit id="31a3846387771411310180f6f1fde6520c80f8c4" translate="yes" xml:space="preserve">
          <source>CREATE EVENT TRIGGER</source>
          <target state="translated">イベントトリガーの作成</target>
        </trans-unit>
        <trans-unit id="a5c622c0285b981c4bc8ab15e53228ce8796f173" translate="yes" xml:space="preserve">
          <source>CREATE EVENT TRIGGER &amp;mdash; define a new event trigger</source>
          <target state="translated">CREATE EVENT TRIGGER &amp;mdash;新しいイベントトリガーを定義します</target>
        </trans-unit>
        <trans-unit id="1845fb209e3e906a586ca08a84b971749b1cc321" translate="yes" xml:space="preserve">
          <source>CREATE EXTENSION</source>
          <target state="translated">クリエイトエクステンション</target>
        </trans-unit>
        <trans-unit id="42d4ae949a8ecfb7e4238283d2d692f05b447628" translate="yes" xml:space="preserve">
          <source>CREATE EXTENSION &amp;mdash; install an extension</source>
          <target state="translated">CREATE EXTENSION &amp;mdash;拡張機能をインストールする</target>
        </trans-unit>
        <trans-unit id="06a82006252ed34850ab2a718088e4a5f5d2d70a" translate="yes" xml:space="preserve">
          <source>CREATE FOREIGN DATA WRAPPER</source>
          <target state="translated">CREATE FOREIGN DATA WRAPPER</target>
        </trans-unit>
        <trans-unit id="1cafc5712ed76d0e342beb2264bc63216f1effab" translate="yes" xml:space="preserve">
          <source>CREATE FOREIGN DATA WRAPPER &amp;mdash; define a new foreign-data wrapper</source>
          <target state="translated">CREATE FOREIGN DATA WRAPPER &amp;mdash;新しい外部データラッパーを定義します</target>
        </trans-unit>
        <trans-unit id="28e78e9de49d9e5b91636b1bbba8763694ac0eec" translate="yes" xml:space="preserve">
          <source>CREATE FOREIGN TABLE</source>
          <target state="translated">CREATE FOREIGN TABLE</target>
        </trans-unit>
        <trans-unit id="04bd70a358fbb9b0d71eac8a4feeb2dfbc87e6d1" translate="yes" xml:space="preserve">
          <source>CREATE FOREIGN TABLE &amp;mdash; define a new foreign table</source>
          <target state="translated">CREATE FOREIGN TABLE &amp;mdash;新しい外部テーブルを定義する</target>
        </trans-unit>
        <trans-unit id="dafc718f6d046e932a269810aea29356b8b9499e" translate="yes" xml:space="preserve">
          <source>CREATE FUNCTION</source>
          <target state="translated">CREATE FUNCTION</target>
        </trans-unit>
        <trans-unit id="4cec9507d23fe9a56fcf1a6029fb62430631c6a0" translate="yes" xml:space="preserve">
          <source>CREATE FUNCTION &amp;mdash; define a new function</source>
          <target state="translated">CREATE FUNCTION &amp;mdash;新しい関数を定義する</target>
        </trans-unit>
        <trans-unit id="d6b838babefc8b935a94e798471ee2c10d69cf60" translate="yes" xml:space="preserve">
          <source>CREATE GROUP</source>
          <target state="translated">CREATE グループ</target>
        </trans-unit>
        <trans-unit id="7aeef0722c2ad5240f0a525f90a9c0bd8108eb20" translate="yes" xml:space="preserve">
          <source>CREATE GROUP &amp;mdash; define a new database role</source>
          <target state="translated">CREATE GROUP &amp;mdash;新しいデータベースロールを定義する</target>
        </trans-unit>
        <trans-unit id="4dfe073e739c382b273bdf0f1bdd27e7f10f38af" translate="yes" xml:space="preserve">
          <source>CREATE INDEX</source>
          <target state="translated">CREATE INDEX</target>
        </trans-unit>
        <trans-unit id="8f6534dfd70827bb61669df54dbb8bd9a1341019" translate="yes" xml:space="preserve">
          <source>CREATE INDEX &amp;mdash; define a new index</source>
          <target state="translated">CREATE INDEX &amp;mdash;新しいインデックスを定義する</target>
        </trans-unit>
        <trans-unit id="9f70ff049dfe19df7fbaef8d79090867151dc257" translate="yes" xml:space="preserve">
          <source>CREATE LANGUAGE</source>
          <target state="translated">言語を作成する</target>
        </trans-unit>
        <trans-unit id="6de7b6a9d3316d1d0e3bd6f5d978cf27d9aa1514" translate="yes" xml:space="preserve">
          <source>CREATE LANGUAGE &amp;mdash; define a new procedural language</source>
          <target state="translated">CREATE LANGUAGE &amp;mdash;新しい手続き言語を定義する</target>
        </trans-unit>
        <trans-unit id="f47bf032497240f851b6a2cbfa5a310fe111bba2" translate="yes" xml:space="preserve">
          <source>CREATE MATERIALIZED VIEW</source>
          <target state="translated">マテリアル表示の作成</target>
        </trans-unit>
        <trans-unit id="11a481a382a3edcec5ac2501e187bc999acf5aeb" translate="yes" xml:space="preserve">
          <source>CREATE MATERIALIZED VIEW &amp;mdash; define a new materialized view</source>
          <target state="translated">CREATE MATERIALIZED VIEW &amp;mdash;新しいマテリアライズドビューを定義します</target>
        </trans-unit>
        <trans-unit id="482429da6e1c15fe2937923636acaa889a99b34a" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR</source>
          <target state="translated">オペレータの作成</target>
        </trans-unit>
        <trans-unit id="7f8d16b4a8f98a6caf75fb7d72f5cf65fda233c2" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR &amp;mdash; define a new operator</source>
          <target state="translated">CREATE OPERATOR &amp;mdash;新しい演算子を定義する</target>
        </trans-unit>
        <trans-unit id="d9da3f211232deee62f75b77079130f4e003ceda" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR CLASS</source>
          <target state="translated">オペレータクラスの作成</target>
        </trans-unit>
        <trans-unit id="bc11e10166a90c7c5db110a6df5c36ab3a634b02" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR CLASS &amp;mdash; define a new operator class</source>
          <target state="translated">CREATE OPERATOR CLASS &amp;mdash;新しい演算子クラスを定義します</target>
        </trans-unit>
        <trans-unit id="623a3d0a1cdac48674d70e9c6f27202077348623" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR FAMILY</source>
          <target state="translated">オペレータファミリの作成</target>
        </trans-unit>
        <trans-unit id="c97a21711f350cb8a76ed5433e8dfc9d47fb839f" translate="yes" xml:space="preserve">
          <source>CREATE OPERATOR FAMILY &amp;mdash; define a new operator family</source>
          <target state="translated">オペレーターファミリーの作成&amp;mdash;新しいオペレーターファミリーを定義します。</target>
        </trans-unit>
        <trans-unit id="1668a9f7ebf5df13d023f1cec484f67c44b8448e" translate="yes" xml:space="preserve">
          <source>CREATE POLICY</source>
          <target state="translated">ポリシーを作成する</target>
        </trans-unit>
        <trans-unit id="5020ad195efa40bf7884f98b9705c18b63503211" translate="yes" xml:space="preserve">
          <source>CREATE POLICY &amp;mdash; define a new row level security policy for a table</source>
          <target state="translated">CREATE POLICY &amp;mdash;テーブルの新しい行レベルのセキュリティポリシーを定義します</target>
        </trans-unit>
        <trans-unit id="12fa5fcaba8eae05abcc1e5b1cc620eaf6dc3ada" translate="yes" xml:space="preserve">
          <source>CREATE PROCEDURE</source>
          <target state="translated">CREATE PROCEDURE</target>
        </trans-unit>
        <trans-unit id="ac9f4d77ca7ed5459b8332ab6d39c4a338fc5851" translate="yes" xml:space="preserve">
          <source>CREATE PROCEDURE &amp;mdash; define a new procedure</source>
          <target state="translated">CREATE PROCEDURE &amp;mdash;新しいプロシージャを定義する</target>
        </trans-unit>
        <trans-unit id="3cedff6ea63cd6d8248f94622fbbe09a93e6b39f" translate="yes" xml:space="preserve">
          <source>CREATE PUBLICATION</source>
          <target state="translated">パブリケーションを作成する</target>
        </trans-unit>
        <trans-unit id="af6f62738c3508470b3eddf2b221111ecdcf5c7b" translate="yes" xml:space="preserve">
          <source>CREATE PUBLICATION &amp;mdash; define a new publication</source>
          <target state="translated">CREATE PUBLICATION &amp;mdash;新しいパブリケーションを定義する</target>
        </trans-unit>
        <trans-unit id="acbbb46d34a4aea4eb00f468a5dcf19d65f95778" translate="yes" xml:space="preserve">
          <source>CREATE ROLE</source>
          <target state="translated">クリエイトロール</target>
        </trans-unit>
        <trans-unit id="689c6a5b0f6843ebae96c95b657e92561bccfd8f" translate="yes" xml:space="preserve">
          <source>CREATE ROLE &amp;mdash; define a new database role</source>
          <target state="translated">CREATE ROLE &amp;mdash;新しいデータベースロールを定義する</target>
        </trans-unit>
        <trans-unit id="9c9b524b6918da216fde80d8ca989b435e864567" translate="yes" xml:space="preserve">
          <source>CREATE RULE</source>
          <target state="translated">クリエイトルール</target>
        </trans-unit>
        <trans-unit id="6ff5a674c9a5d9304820c21513094f421a6fd38c" translate="yes" xml:space="preserve">
          <source>CREATE RULE &amp;mdash; define a new rewrite rule</source>
          <target state="translated">CREATE RULE &amp;mdash;新しい書き換えルールを定義する</target>
        </trans-unit>
        <trans-unit id="924d310847d294df10c2589c465fb5c4a6254510" translate="yes" xml:space="preserve">
          <source>CREATE SCHEMA</source>
          <target state="translated">クリエイトスキーマ</target>
        </trans-unit>
        <trans-unit id="b41fda9a07c379eb9a569e4c355aff770cd2d956" translate="yes" xml:space="preserve">
          <source>CREATE SCHEMA &amp;mdash; define a new schema</source>
          <target state="translated">CREATE SCHEMA &amp;mdash;新しいスキーマを定義する</target>
        </trans-unit>
        <trans-unit id="bf7598785b07ca70f266afcf7d0a8eb1cf4d0316" translate="yes" xml:space="preserve">
          <source>CREATE SEQUENCE</source>
          <target state="translated">クリエイトシーケンス</target>
        </trans-unit>
        <trans-unit id="7525f9d62ab7c9d7125bbff19dd959a8725e6be7" translate="yes" xml:space="preserve">
          <source>CREATE SEQUENCE &amp;mdash; define a new sequence generator</source>
          <target state="translated">CREATE SEQUENCE &amp;mdash;新しいシーケンスジェネレーターを定義する</target>
        </trans-unit>
        <trans-unit id="3ebe54a161c2c2fcef53be80c658d2a8423ed56d" translate="yes" xml:space="preserve">
          <source>CREATE SERVER</source>
          <target state="translated">クリエイトサーバー</target>
        </trans-unit>
        <trans-unit id="ca9eb197f9d10a52fe8fffa9f1b5348bdb60514d" translate="yes" xml:space="preserve">
          <source>CREATE SERVER &amp;mdash; define a new foreign server</source>
          <target state="translated">CREATE SERVER &amp;mdash;新しい外部サーバーを定義する</target>
        </trans-unit>
        <trans-unit id="157a801a877cda20c2d0084aac08e4ad59f79225" translate="yes" xml:space="preserve">
          <source>CREATE STATISTICS</source>
          <target state="translated">統計情報の作成</target>
        </trans-unit>
        <trans-unit id="7f09faa3466ed0240bd2e4dd2aac530863325acb" translate="yes" xml:space="preserve">
          <source>CREATE STATISTICS &amp;mdash; define extended statistics</source>
          <target state="translated">CREATE STATISTICS &amp;mdash;拡張統計を定義します</target>
        </trans-unit>
        <trans-unit id="5e0c7a97306134a592b25c59e20dd36d2a769213" translate="yes" xml:space="preserve">
          <source>CREATE SUBSCRIPTION</source>
          <target state="translated">CREATE SUBSCRIPTION</target>
        </trans-unit>
        <trans-unit id="5ec0c25961be41da80c8a91b830ea4b02df4cf13" translate="yes" xml:space="preserve">
          <source>CREATE SUBSCRIPTION &amp;mdash; define a new subscription</source>
          <target state="translated">CREATE SUBSCRIPTION &amp;mdash;新しいサブスクリプションを定義します</target>
        </trans-unit>
        <trans-unit id="979ae29e43d609d39c91f43b7d2c9c6f0170c84c" translate="yes" xml:space="preserve">
          <source>CREATE TABLE</source>
          <target state="translated">クリエイトテーブル</target>
        </trans-unit>
        <trans-unit id="26d5b732dbd25f2e1b3d1fbfc02876be87c76737" translate="yes" xml:space="preserve">
          <source>CREATE TABLE &amp;mdash; define a new table</source>
          <target state="translated">CREATE TABLE &amp;mdash;新しいテーブルを定義する</target>
        </trans-unit>
        <trans-unit id="fdc5603516a1557309c21e74d5f3a300d7053f48" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS</source>
          <target state="translated">CREATE TABLE AS</target>
        </trans-unit>
        <trans-unit id="f17a1b7a9a5cdfbc14bd6e2b3bdb0943d5c8debf" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS &amp;mdash; define a new table from the results of a query</source>
          <target state="translated">CREATE TABLE AS &amp;mdash;クエリの結果から新しいテーブルを定義します</target>
        </trans-unit>
        <trans-unit id="eb3911ee759f233a5280c04fb3873a55053eecf0" translate="yes" xml:space="preserve">
          <source>CREATE TABLESPACE</source>
          <target state="translated">CREATE TABLESPACE</target>
        </trans-unit>
        <trans-unit id="7a2efca1d1fa6b73192144d045ac62adbd5febc0" translate="yes" xml:space="preserve">
          <source>CREATE TABLESPACE &amp;mdash; define a new tablespace</source>
          <target state="translated">CREATE TABLESPACE &amp;mdash;新しいテーブルスペースを定義する</target>
        </trans-unit>
        <trans-unit id="f30459fe4e8391762bf04e818af7ed45fea90e31" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH CONFIGURATION</source>
          <target state="translated">テキスト検索設定を作成する</target>
        </trans-unit>
        <trans-unit id="98a91abc0640991fbe46b809a84f7c096214adb9" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH CONFIGURATION &amp;mdash; define a new text search configuration</source>
          <target state="translated">CREATE TEXT SEARCH CONFIGURATION &amp;mdash;新しいテキスト検索構成を定義します</target>
        </trans-unit>
        <trans-unit id="e0786ad367cbc7c76eebbdff0d52a92c06682a22" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH DICTIONARY</source>
          <target state="translated">テキスト検索辞書の作成</target>
        </trans-unit>
        <trans-unit id="90ccddfdc15f750dfec0d9f6b9bc9a22063d4b78" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH DICTIONARY &amp;mdash; define a new text search dictionary</source>
          <target state="translated">CREATE TEXT SEARCH DICTIONARY &amp;mdash;新しいテキスト検索辞書を定義します</target>
        </trans-unit>
        <trans-unit id="371f770602d7c4471f374bc1d1a8431e689987db" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH PARSER</source>
          <target state="translated">CREATE TEXT SEARCH PARSER</target>
        </trans-unit>
        <trans-unit id="b8c7383b1db46fcf9300b35b5eaa298fe202ebd2" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH PARSER &amp;mdash; define a new text search parser</source>
          <target state="translated">CREATE TEXT SEARCH PARSER &amp;mdash;新しいテキスト検索パーサーを定義します</target>
        </trans-unit>
        <trans-unit id="0e295842db3e33d0a4cc6e5c9a1dd12f6470851f" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH TEMPLATE</source>
          <target state="translated">テキスト検索テンプレートの作成</target>
        </trans-unit>
        <trans-unit id="b458565464da05d909a95f9f30c81a3354a718a7" translate="yes" xml:space="preserve">
          <source>CREATE TEXT SEARCH TEMPLATE &amp;mdash; define a new text search template</source>
          <target state="translated">CREATE TEXT SEARCH TEMPLATE &amp;mdash;新しいテキスト検索テンプレートを定義します</target>
        </trans-unit>
        <trans-unit id="43f626a434ef69424c81fa793ea2be0e2da3655f" translate="yes" xml:space="preserve">
          <source>CREATE TRANSFORM</source>
          <target state="translated">クリエイトトランスフォーム</target>
        </trans-unit>
        <trans-unit id="afd90f78bb312dd95d197ddbfea9bbf217cbed65" translate="yes" xml:space="preserve">
          <source>CREATE TRANSFORM &amp;mdash; define a new transform</source>
          <target state="translated">CREATE TRANSFORM &amp;mdash;新しい変換を定義する</target>
        </trans-unit>
        <trans-unit id="cf6418466d171e86053f358e78bdbbeb775f1f4f" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER</source>
          <target state="translated">CREATE TRIGGER</target>
        </trans-unit>
        <trans-unit id="ad28054db3468768cfafe732739590de2c31517d" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER &amp;mdash; define a new trigger</source>
          <target state="translated">CREATE TRIGGER &amp;mdash;新しいトリガーを定義します</target>
        </trans-unit>
        <trans-unit id="84a0c5bdfbf721756e56c1a21782a7726869fb02" translate="yes" xml:space="preserve">
          <source>CREATE TYPE</source>
          <target state="translated">CREATE TYPE</target>
        </trans-unit>
        <trans-unit id="78ecad2beba697ded50856d8a6efbd2767878e3e" translate="yes" xml:space="preserve">
          <source>CREATE TYPE &amp;mdash; define a new data type</source>
          <target state="translated">CREATE TYPE &amp;mdash;新しいデータ型を定義する</target>
        </trans-unit>
        <trans-unit id="b9b4f23af8e09b7f85cfa3af0d06b6b261d9ae23" translate="yes" xml:space="preserve">
          <source>CREATE USER</source>
          <target state="translated">クリエイトユーザ</target>
        </trans-unit>
        <trans-unit id="aec95ff6b458aa9525e70591e994d88efd245a4f" translate="yes" xml:space="preserve">
          <source>CREATE USER &amp;mdash; define a new database role</source>
          <target state="translated">CREATE USER &amp;mdash;新しいデータベースロールを定義する</target>
        </trans-unit>
        <trans-unit id="9d48020c90ebc18d37338a7bd718bc869e022a84" translate="yes" xml:space="preserve">
          <source>CREATE USER MAPPING</source>
          <target state="translated">CREATE USER MAPPING</target>
        </trans-unit>
        <trans-unit id="ec0fae676273fd4cdaf28c6a951c036c0cba102d" translate="yes" xml:space="preserve">
          <source>CREATE USER MAPPING &amp;mdash; define a new mapping of a user to a foreign server</source>
          <target state="translated">CREATE USER MAPPING &amp;mdash;外部サーバーへのユーザーの新しいマッピングを定義します</target>
        </trans-unit>
        <trans-unit id="c6d65be0664c12895eed3811d312f2344a61a809" translate="yes" xml:space="preserve">
          <source>CREATE VIEW</source>
          <target state="translated">クリエイトビュー</target>
        </trans-unit>
        <trans-unit id="0147b1a98a0ef41a4b049d6e7de36e860f8351d4" translate="yes" xml:space="preserve">
          <source>CREATE VIEW &amp;mdash; define a new view</source>
          <target state="translated">CREATE VIEW &amp;mdash;新しいビューを定義する</target>
        </trans-unit>
        <trans-unit id="fa3416b89da9ef05cb9e9d2480e0fd805ea5f0a9" translate="yes" xml:space="preserve">
          <source>CRL</source>
          <target state="translated">CRL</target>
        </trans-unit>
        <trans-unit id="3281188351b89c8e2db28d6da7af4992d415de90" translate="yes" xml:space="preserve">
          <source>CSV</source>
          <target state="translated">CSV</target>
        </trans-unit>
        <trans-unit id="b3706da5e4cc32b0bedecec46b4ac426e2af6808" translate="yes" xml:space="preserve">
          <source>CSV Format</source>
          <target state="translated">シーエスブイフォーマット</target>
        </trans-unit>
        <trans-unit id="e5cf7ef0f924f6d30fb5a33edb5b128eeaee7a5e" translate="yes" xml:space="preserve">
          <source>CSV format will both recognize and produce CSV files with quoted values containing embedded carriage returns and line feeds. Thus the files are not strictly one line per table row like text-format files.</source>
          <target state="translated">CSVフォーマットは、埋め込みキャリッジリターンと改行を含む引用符で囲まれた値を持つCSVファイルを認識し、生成します。したがって、ファイルはテキスト形式のファイルのようにテーブルの行ごとに厳密に1行ではありません。</target>
        </trans-unit>
        <trans-unit id="76892178b436ea8bdde6e161ad4d4ea9686b38bf" translate="yes" xml:space="preserve">
          <source>CTE</source>
          <target state="translated">CTE</target>
        </trans-unit>
        <trans-unit id="b3940909bbd68a59ba0277b02624768dfaeb6e9b" translate="yes" xml:space="preserve">
          <source>CVE</source>
          <target state="translated">CVE</target>
        </trans-unit>
        <trans-unit id="247813b3c844bd5d06cdcae1ecce2cdd4b970eef" translate="yes" xml:space="preserve">
          <source>Cache size of the sequence</source>
          <target state="translated">シーケンスのキャッシュサイズ</target>
        </trans-unit>
        <trans-unit id="0cb1c895a27cf7a692331abf7527a78ed40aff2a" translate="yes" xml:space="preserve">
          <source>Calculate the difference between two write-ahead log locations</source>
          <target state="translated">2つの書込み先ログの位置の差を計算する</target>
        </trans-unit>
        <trans-unit id="fea0627ce6667c0ebd9b97f7ca4a898c44a74581" translate="yes" xml:space="preserve">
          <source>Calculates a crypt(3)-style hash of &lt;em&gt;&lt;code&gt;password&lt;/code&gt;&lt;/em&gt;. When storing a new password, you need to use &lt;code&gt;gen_salt()&lt;/code&gt; to generate a new &lt;em&gt;&lt;code&gt;salt&lt;/code&gt;&lt;/em&gt; value. To check a password, pass the stored hash value as &lt;em&gt;&lt;code&gt;salt&lt;/code&gt;&lt;/em&gt;, and test whether the result matches the stored value.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;password&lt;/code&gt; &lt;/em&gt; crypt（3）スタイルのハッシュを計算し&lt;em&gt;ます&lt;/em&gt;。新しいパスワードを保存するときは、 &lt;code&gt;gen_salt()&lt;/code&gt; を使用して新しい&lt;em&gt; &lt;code&gt;salt&lt;/code&gt; &lt;/em&gt;値を生成する必要があります。パスワードを確認するには、保存されているハッシュ値を&lt;em&gt; &lt;code&gt;salt&lt;/code&gt; &lt;/em&gt;として渡し、結果が保存されている値と一致するかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="861e89fd9688c36464c88762b222ee32afefc886" translate="yes" xml:space="preserve">
          <source>Calculates hashed MAC for &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt; with key &lt;em&gt;&lt;code&gt;key&lt;/code&gt;&lt;/em&gt;. &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; is the same as in &lt;code&gt;digest()&lt;/code&gt;.</source>
          <target state="translated">キー&lt;em&gt; &lt;code&gt;key&lt;/code&gt; を&lt;/em&gt;持つ&lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt;ハッシュ化されたMACを計算し&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt;は &lt;code&gt;digest()&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="3c31f29ac70693bcc792a1f5312cf3bb90f137b5" translate="yes" xml:space="preserve">
          <source>Calculates the MD5 hash of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;, returning the result in hexadecimal</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;のMD5ハッシュを計算し、結果を16進数で返します</target>
        </trans-unit>
        <trans-unit id="befefdcc641ba3007ad8e4f140dfc06f0376aadb" translate="yes" xml:space="preserve">
          <source>Call a function to log updates of &lt;code&gt;accounts&lt;/code&gt;, but only if something changed:</source>
          <target state="translated">&lt;code&gt;accounts&lt;/code&gt; 更新を記録する関数を呼び出しますが、何かが変更された場合のみです。</target>
        </trans-unit>
        <trans-unit id="2f2b1f5f71d89e54c8503e6cf93a04999cc1b58a" translate="yes" xml:space="preserve">
          <source>Calling Functions</source>
          <target state="translated">呼び出し機能</target>
        </trans-unit>
        <trans-unit id="203462ce9b91673b52d9f4d2d91355f3aa6602db" translate="yes" xml:space="preserve">
          <source>Calling Functions: Mixed Notation</source>
          <target state="translated">関数の呼び出し。混合記法</target>
        </trans-unit>
        <trans-unit id="a536706c9ea5b680977b44c15311fa4951f2711a" translate="yes" xml:space="preserve">
          <source>Calling Functions: Named Notation</source>
          <target state="translated">関数の呼び出し。名前付き記法</target>
        </trans-unit>
        <trans-unit id="fc4a9cc712a759cf51a3323495fcadd9bd96bc79" translate="yes" xml:space="preserve">
          <source>Calling Functions: Positional Notation</source>
          <target state="translated">呼び出し関数。位置記法</target>
        </trans-unit>
        <trans-unit id="da4ac9cae427158f02958852d4d2d5e7ffe27ccf" translate="yes" xml:space="preserve">
          <source>Can give wrong results when the server is running.</source>
          <target state="translated">サーバーが動作しているときに間違った結果が出ることがあります。</target>
        </trans-unit>
        <trans-unit id="a93dec0f38c1b9cc3a9947f4ed876ed816928818" translate="yes" xml:space="preserve">
          <source>Can the column be scanned in order by a &amp;ldquo;distance&amp;rdquo; operator, for example &lt;code&gt;ORDER BY col &amp;lt;-&amp;gt; constant&lt;/code&gt; ?</source>
          <target state="translated">列は、「距離」演算子（ &lt;code&gt;ORDER BY col &amp;lt;-&amp;gt; constant&lt;/code&gt; など）によって順番にスキャンできますか？</target>
        </trans-unit>
        <trans-unit id="6539f7da14fafe21218e45f67919c4c481fed653" translate="yes" xml:space="preserve">
          <source>Can the column value be returned by an index-only scan?</source>
          <target state="translated">インデックスのみのスキャンで列の値を返すことはできますか?</target>
        </trans-unit>
        <trans-unit id="0935874144556d7285be1025b3aa5607d7d0ddc3" translate="yes" xml:space="preserve">
          <source>Can the index be used in a &lt;code&gt;CLUSTER&lt;/code&gt; command?</source>
          <target state="translated">インデックスを &lt;code&gt;CLUSTER&lt;/code&gt; コマンドで使用できますか？</target>
        </trans-unit>
        <trans-unit id="b77f7d0943d5d161914d1daaa3ce278bcefc5f99" translate="yes" xml:space="preserve">
          <source>Can the scan direction be changed in mid-scan (to support &lt;code&gt;FETCH BACKWARD&lt;/code&gt; on a cursor without needing materialization)?</source>
          <target state="translated">スキャン方向は、（サポートするミッドスキャンに変更することができます &lt;code&gt;FETCH BACKWARD&lt;/code&gt; マテリアを必要とせずに、カーソルの上に）？</target>
        </trans-unit>
        <trans-unit id="9f0df21242294739bbb4a2952c632be02a94f355" translate="yes" xml:space="preserve">
          <source>Cancel a backend's current query. This is also allowed if the calling role is a member of the role whose backend is being canceled or the calling role has been granted &lt;code&gt;pg_signal_backend&lt;/code&gt;, however only superusers can cancel superuser backends.</source>
          <target state="translated">バックエンドの現在のクエリをキャンセルします。これは、呼び出し側の役割がバックエンドがキャンセルされる役割のメンバーである場合、または呼び出し側の役割に &lt;code&gt;pg_signal_backend&lt;/code&gt; が付与されている場合にも許可されますが、スーパーユーザーのみがスーパーユーザーのバックエンドをキャンセルできます。</target>
        </trans-unit>
        <trans-unit id="c9da0a3cad76feeeddc910a8b8ceb607b614bd1b" translate="yes" xml:space="preserve">
          <source>Cancel the effects of &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt; の効果をキャンセルします。</target>
        </trans-unit>
        <trans-unit id="3c1b1bf8357eb64e4252455c2cd4e94e21c1f28f" translate="yes" xml:space="preserve">
          <source>Cancel the effects of &lt;code&gt;pg_replication_origin_xact_setup()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin_xact_setup()&lt;/code&gt; の効果をキャンセルします。</target>
        </trans-unit>
        <trans-unit id="23032323429fac1ae297d0bcb8316e73f0646ac9" translate="yes" xml:space="preserve">
          <source>Canceled queries may be retried immediately (after beginning a new transaction, of course). Since query cancellation depends on the nature of the WAL records being replayed, a query that was canceled may well succeed if it is executed again.</source>
          <target state="translated">キャンセルされたクエリは、直ちに(もちろん、新しいトランザクションを開始した後に)再試行することができます。クエリのキャンセルは再生されるWALレコードの性質に依存するので、キャンセルされたクエリが再度実行されれば成功する可能性があります。</target>
        </trans-unit>
        <trans-unit id="693faa0292da8531e1fbe82d7b3027be66637ae6" translate="yes" xml:space="preserve">
          <source>Care must be taken when dealing with multiple character encodings on the client, server, and in the XML data passed through them. When using the text mode to pass queries to the server and query results to the client (which is the normal mode), PostgreSQL converts all character data passed between the client and the server and vice versa to the character encoding of the respective end; see &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;. This includes string representations of XML values, such as in the above examples. This would ordinarily mean that encoding declarations contained in XML data can become invalid as the character data is converted to other encodings while traveling between client and server, because the embedded encoding declaration is not changed. To cope with this behavior, encoding declarations contained in character strings presented for input to the &lt;code&gt;xml&lt;/code&gt; type are &lt;em&gt;ignored&lt;/em&gt;, and content is assumed to be in the current server encoding. Consequently, for correct processing, character strings of XML data must be sent from the client in the current client encoding. It is the responsibility of the client to either convert documents to the current client encoding before sending them to the server, or to adjust the client encoding appropriately. On output, values of type &lt;code&gt;xml&lt;/code&gt; will not have an encoding declaration, and clients should assume all data is in the current client encoding.</source>
          <target state="translated">クライアント、サーバー、およびそれらを介して渡されるXMLデータで複数の文字エンコーディングを処理する場合は注意が必要です。テキストモードを使用してサーバーにクエリを渡し、クエリ結果をクライアントに渡す場合（通常モード）、PostgreSQLはクライアントとサーバー間でやり取りされるすべての文字データを変換し、その逆も、それぞれのエンドの文字エンコードに変換します。&lt;a href=&quot;multibyte&quot;&gt;セクション23.3を&lt;/a&gt;参照。これには、上記の例のように、XML値の文字列表現が含まれます。これは通常、XMLデータに含まれるエンコーディング宣言が無効になる可能性があることを意味します。埋め込まれたエンコーディング宣言が変更されないため、クライアントとサーバーの間を移動するときに文字データが他のエンコーディングに変換されるためです。この動作に対処するため、 &lt;code&gt;xml&lt;/code&gt; 型への入力用に提示された文字列に含まれるエンコーディング宣言は&lt;em&gt;無視されます&lt;/em&gt;、コンテンツは現在のサーバーのエンコーディングであると見なされます。したがって、正しく処理するには、XMLデータの文字列を現在のクライアントエンコーディングでクライアントから送信する必要があります。ドキュメントをサーバーに送信する前に現在のクライアントエンコーディングに変換するか、クライアントエンコーディングを適切に調整するのはクライアントの責任です。出力では、タイプ &lt;code&gt;xml&lt;/code&gt; の値はエンコーディング宣言を持たず、クライアントはすべてのデータが現在のクライアントエンコーディングであると想定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e8b9c886cfee9a0088d73099139600c074f9b050" translate="yes" xml:space="preserve">
          <source>Care should be taken when granting these roles to ensure they are only used where needed and with the understanding that these roles grant access to privileged information.</source>
          <target state="translated">これらの役割を付与する際には、これらの役割が特権情報へのアクセスを許可することを理解した上で、必要な場所でのみ使用されるように注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="a731e5cd6aa8ed98146eab667e56ae88e3c5d7fc" translate="yes" xml:space="preserve">
          <source>Care was taken during the creation of the algorithms and they were meticulously verified against the suggested algorithms in the official ISBN, ISMN, ISSN User Manuals.</source>
          <target state="translated">アルゴリズムの作成には細心の注意が払われ、公式のISBN、ISMN、ISSNのユーザーマニュアルで提案されたアルゴリズムと照合して検証されました。</target>
        </trans-unit>
        <trans-unit id="6c7f8a2bb8fffa23f523c6163b0903e536de65ba" translate="yes" xml:space="preserve">
          <source>Carriage return (ASCII 13)</source>
          <target state="translated">キャリッジリターン(ASCII 13</target>
        </trans-unit>
        <trans-unit id="2650e53427c41e8804613f092fb9a0fb7ace5eee" translate="yes" xml:space="preserve">
          <source>Carry out the command and show actual run times and other statistics. This parameter defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">コマンドを実行して、実際の実行時間とその他の統計を表示します。このパラメーターのデフォルトは &lt;code&gt;FALSE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0bc75ee91fac0dcf8fbe5c9b1aeb7cbdb9f3add3" translate="yes" xml:space="preserve">
          <source>Cascading replication is currently asynchronous. Synchronous replication (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;) settings have no effect on cascading replication at present.</source>
          <target state="translated">カスケード複製は現在非同期です。同期レプリケーション（&lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;セクション26.2.8を&lt;/a&gt;参照）の設定は、現在のところカスケードレプリケーションには影響を与えません。</target>
        </trans-unit>
        <trans-unit id="03ff4ebf1ea10982d29fb1e92aa1f028e700f862" translate="yes" xml:space="preserve">
          <source>Cast implementation functions can have one to three arguments. The first argument type must be identical to or binary-coercible from the cast's source type. The second argument, if present, must be type &lt;code&gt;integer&lt;/code&gt;; it receives the type modifier associated with the destination type, or &lt;code&gt;-1&lt;/code&gt; if there is none. The third argument, if present, must be type &lt;code&gt;boolean&lt;/code&gt;; it receives &lt;code&gt;true&lt;/code&gt; if the cast is an explicit cast, &lt;code&gt;false&lt;/code&gt; otherwise. (Bizarrely, the SQL standard demands different behaviors for explicit and implicit casts in some cases. This argument is supplied for functions that must implement such casts. It is not recommended that you design your own data types so that this matters.)</source>
          <target state="translated">キャスト実装関数には、1つから3つの引数を指定できます。最初の引数の型は、キャストのソース型と同じであるか、キャストのソース型からバイナリ強制可能でなければなりません。 2番目の引数がある場合、それは &lt;code&gt;integer&lt;/code&gt; 型でなければなりません。宛先タイプに関連付けられたタイプ修飾子を受け取ります。存在しない場合は &lt;code&gt;-1&lt;/code&gt; を受け取ります。 3番目の引数が存在する場合、それは &lt;code&gt;boolean&lt;/code&gt; 型でなければなりません。キャストが明示的なキャストである場合は &lt;code&gt;true&lt;/code&gt; を受け取り、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を受け取ります。 （奇妙なことに、SQL標準では、明示的キャストと暗黙的キャストに異なる動作が要求される場合があります。この引数は、そのようなキャストを実装する必要がある関数に提供されます。これが重要になるように独自のデータ型を設計することはお勧めしません。）</target>
        </trans-unit>
        <trans-unit id="8bfaf65bcc3bfd3f69874267680d575eefe7735d" translate="yes" xml:space="preserve">
          <source>Casting an integer to &lt;code&gt;bit(n)&lt;/code&gt; copies the rightmost &lt;code&gt;n&lt;/code&gt; bits. Casting an integer to a bit string width wider than the integer itself will sign-extend on the left.</source>
          <target state="translated">整数を &lt;code&gt;bit(n)&lt;/code&gt; にキャストすると、右端の &lt;code&gt;n&lt;/code&gt; ビットがコピーされます。整数を整数自体よりも広いビット文字列幅にキャストすると、左側が符号拡張されます。</target>
        </trans-unit>
        <trans-unit id="8b12286d851a29dd1eb5cbb3a3c36eb2a6d20ae4" translate="yes" xml:space="preserve">
          <source>Catalog Name</source>
          <target state="translated">カタログ名</target>
        </trans-unit>
        <trans-unit id="e39f1d43412f335d260f6d16604f35d75f9f19c8" translate="yes" xml:space="preserve">
          <source>Catalogs: System Views</source>
          <target state="translated">カタログ:システムビュー</target>
        </trans-unit>
        <trans-unit id="cd0231f25ccdf0d0faf414b312a62b082eeb5b93" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_aggregate</source>
          <target state="translated">カタログ:pg_aggregate</target>
        </trans-unit>
        <trans-unit id="5a2cc7f7d79e3465c6cb75edcddc6849aa0cbe29" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_am</source>
          <target state="translated">カタログ:pg_am</target>
        </trans-unit>
        <trans-unit id="6f5861da97f8e27d0265b79b0e8f0602d04e3c6c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_amop</source>
          <target state="translated">カタログ:pg_amop</target>
        </trans-unit>
        <trans-unit id="540f25e5c7bfa6e5939b7ffa20ee2292a88850ba" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_amproc</source>
          <target state="translated">カタログ:pg_amproc</target>
        </trans-unit>
        <trans-unit id="a5d37bbcf80d99313d0fcf92265cf0378e3ebfda" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_attrdef</source>
          <target state="translated">カタログ:pg_attrdef</target>
        </trans-unit>
        <trans-unit id="809d8237b28a35759881f596677f3687a9caa14e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_attribute</source>
          <target state="translated">カタログ:pg_attribute</target>
        </trans-unit>
        <trans-unit id="d22f444a2f1dced1268fc5a74cc510d5853b50fb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_auth_members</source>
          <target state="translated">カタログ:pg_auth_members</target>
        </trans-unit>
        <trans-unit id="9e2777250a55ada681979e409c1e9f68b5f4a8e0" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_authid</source>
          <target state="translated">カタログ:pg_authid</target>
        </trans-unit>
        <trans-unit id="098b7f0ec7e32aaf4413dc833248e8ba2ba61dbb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_available_extension_versions</source>
          <target state="translated">カタログ:pg_available_extension_versions</target>
        </trans-unit>
        <trans-unit id="21541dc8fd93a658bf7fda69daeb0fc8bc3ac5fb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_available_extensions</source>
          <target state="translated">カタログ:pg_available_extensions</target>
        </trans-unit>
        <trans-unit id="3a492ed5f8fa73610c5f384ee71ac2af2d343280" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_cast</source>
          <target state="translated">カタログ:pg_cast</target>
        </trans-unit>
        <trans-unit id="214b25acc823e53a3866fac8ad4bdb58a5849695" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_class</source>
          <target state="translated">カタログ:pg_class</target>
        </trans-unit>
        <trans-unit id="1f95915ba59d80f58e01f2b5de8cc456bcc65284" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_collation</source>
          <target state="translated">カタログ:pg_collation</target>
        </trans-unit>
        <trans-unit id="45a417e5bb393b7aea80ba15614c9e574b1ec967" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_config</source>
          <target state="translated">カタログ:pg_config</target>
        </trans-unit>
        <trans-unit id="ef3a1d16c7beaa5ff7cde438e280c6004fc99358" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_constraint</source>
          <target state="translated">カタログ:pg_constraint</target>
        </trans-unit>
        <trans-unit id="e1533025c2199a2c17644351fc8d500bab2cd3bb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_conversion</source>
          <target state="translated">カタログ:pg_conversion</target>
        </trans-unit>
        <trans-unit id="6ee477ff028fe4897030c498b3792c6fb4efa684" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_cursors</source>
          <target state="translated">カタログ:pg_cursors</target>
        </trans-unit>
        <trans-unit id="53aaa0259c4a9a04e8eb75ff7858ac223e5bb9ef" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_database</source>
          <target state="translated">カタログ:pg_database</target>
        </trans-unit>
        <trans-unit id="dce93e6bd535d6849381dd52df6a2fe69c966a15" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_db_role_setting</source>
          <target state="translated">カタログ:pg_db_role_setting</target>
        </trans-unit>
        <trans-unit id="393ce7080c621e5669cea8ce22e81a4d14bce3bd" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_default_acl</source>
          <target state="translated">カタログ:pg_default_acl</target>
        </trans-unit>
        <trans-unit id="63be8b4fe3bd96d14c425f3779c77c1bde3c7f70" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_depend</source>
          <target state="translated">カタログ:pg_depend</target>
        </trans-unit>
        <trans-unit id="6c7b51ab42295189697291ccc89d633240d22b4a" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_description</source>
          <target state="translated">カタログ:pg_description</target>
        </trans-unit>
        <trans-unit id="e81e9f736a55c37e62171851380f6909958bd1a4" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_enum</source>
          <target state="translated">カタログ:pg_enum</target>
        </trans-unit>
        <trans-unit id="d16a46d2e57c59ea3c662f29c4e0c310d1fac618" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_event_trigger</source>
          <target state="translated">カタログ:pg_event_trigger</target>
        </trans-unit>
        <trans-unit id="e2f3d74a77699443187baa8f4450089845b9cb76" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_extension</source>
          <target state="translated">カタログ:pg_extension</target>
        </trans-unit>
        <trans-unit id="631f07d60ad79d31d4aece900c3f41f0d9385f5e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_file_settings</source>
          <target state="translated">カタログ:pg_file_settings</target>
        </trans-unit>
        <trans-unit id="10bd0a6fc97d6b9d339d72472d3626185232809c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_foreign_data_wrapper</source>
          <target state="translated">カタログ:pg_foreign_data_wrapper</target>
        </trans-unit>
        <trans-unit id="99a0f269b04cd636dbe4eedcdc1a264689616ce6" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_foreign_server</source>
          <target state="translated">カタログ:pg_foreign_server</target>
        </trans-unit>
        <trans-unit id="e03ca9b9ed8c896e7abecbf15858efd786ccc932" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_foreign_table</source>
          <target state="translated">カタログ:pg_foreign_table</target>
        </trans-unit>
        <trans-unit id="b8a522cb4849f86cc0ebd1d8e4533b981fe760e8" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_group</source>
          <target state="translated">カタログ:pg_group</target>
        </trans-unit>
        <trans-unit id="809afcd307ea7a846272cfe2055518e09a097e34" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_hba_file_rules</source>
          <target state="translated">カタログ:pg_hba_file_rules</target>
        </trans-unit>
        <trans-unit id="3ede65ae6ffe5b427435f5d68e81b9255349537a" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_index</source>
          <target state="translated">カタログ:pg_index</target>
        </trans-unit>
        <trans-unit id="062ebb2a310599c5c55a326d43df0384367543ce" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_indexes</source>
          <target state="translated">カタログ:pg_indexes</target>
        </trans-unit>
        <trans-unit id="896e4e7fa3850b76e1727ff9ae9c7894fdeb4535" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_inherits</source>
          <target state="translated">カタログ:pg_inherits</target>
        </trans-unit>
        <trans-unit id="a99a7230356dc633d7735302eb1f597def0d6246" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_init_privs</source>
          <target state="translated">カタログ:pg_init_privs</target>
        </trans-unit>
        <trans-unit id="2bc5ebd2eb94cb79767b534211814328af877d03" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_language</source>
          <target state="translated">カタログ:pg_language</target>
        </trans-unit>
        <trans-unit id="7475eeb141889567a43afdcbdbc39b5953c158e5" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_largeobject</source>
          <target state="translated">カタログ:pg_largeobject</target>
        </trans-unit>
        <trans-unit id="13d246ab8635647844676127fcad44b7d85bdb7b" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_largeobject_metadata</source>
          <target state="translated">カタログ:pg_largeobject_metadata</target>
        </trans-unit>
        <trans-unit id="47d201ca5d48022eebb7f49698984eedf590519d" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_locks</source>
          <target state="translated">カタログ:pg_locks</target>
        </trans-unit>
        <trans-unit id="44021f8a25348e256fc0757db930fb338b754fb7" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_matviews</source>
          <target state="translated">カタログ:pg_matviews</target>
        </trans-unit>
        <trans-unit id="22707cfbd7b73718bdf695d657834844b0f409b9" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_namespace</source>
          <target state="translated">カタログ:pg_namespace</target>
        </trans-unit>
        <trans-unit id="deb4d3669218dad9cb34ea405ff1eae78e8631dd" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_opclass</source>
          <target state="translated">カタログ:pg_opclass</target>
        </trans-unit>
        <trans-unit id="7d7c2c3b54c2b67c28cb4558ef76babf65acfde2" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_operator</source>
          <target state="translated">カタログ:pg_operator</target>
        </trans-unit>
        <trans-unit id="8a758121c56b38114d101d017db33b71016f1bc2" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_opfamily</source>
          <target state="translated">カタログ:pg_opfamily</target>
        </trans-unit>
        <trans-unit id="9d5ccf8bfb6af0c7726d42696afbdd455a68550d" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_partitioned_table</source>
          <target state="translated">カタログ:pg_partitioned_table</target>
        </trans-unit>
        <trans-unit id="167642e6d760a30fbfd27cf56e9be558f2930209" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_pltemplate</source>
          <target state="translated">カタログ:pg_pltemplate</target>
        </trans-unit>
        <trans-unit id="4dec76c5312c96a5b30ebba9a03ef220af8d85cd" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_policies</source>
          <target state="translated">カタログ:pg_policies</target>
        </trans-unit>
        <trans-unit id="6b912e5e80b5e7c6f7e379f86297d335cb90fb66" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_policy</source>
          <target state="translated">カタログ:pg_policy</target>
        </trans-unit>
        <trans-unit id="37bfb758865bf592e8327a655b253ebe26b3a27c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_prepared_statements</source>
          <target state="translated">カタログ:pg_prepared_statements</target>
        </trans-unit>
        <trans-unit id="e0f65f36699b59cc051c4443b8c7f9448bdb976f" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_prepared_xacts</source>
          <target state="translated">カタログ:pg_prepared_xacts</target>
        </trans-unit>
        <trans-unit id="df03f30fae73bd4555cb205dc3f229899b26e406" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_proc</source>
          <target state="translated">カタログ:pg_proc</target>
        </trans-unit>
        <trans-unit id="08d769cfc75bc7a5291b9cc51d62e27993c176cb" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_publication</source>
          <target state="translated">カタログ:pg_publication</target>
        </trans-unit>
        <trans-unit id="663db137e4eb335b4daa441fea43166f26c3e69d" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_publication_rel</source>
          <target state="translated">カタログ:pg_publication_rel</target>
        </trans-unit>
        <trans-unit id="21b9962277bcef09369bc7e2e1ad2e90cc32d817" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_publication_tables</source>
          <target state="translated">カタログ:pg_publication_tables</target>
        </trans-unit>
        <trans-unit id="2134507ad10f2206eea8739a1872a03fa790735e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_range</source>
          <target state="translated">カタログ:pg_range</target>
        </trans-unit>
        <trans-unit id="13a5aaf5f820d003b94c89c2cb007a9a48d202ef" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_replication_origin</source>
          <target state="translated">カタログ:pg_replication_origin</target>
        </trans-unit>
        <trans-unit id="d7da07d9eaadc1b0c362176aac0724e6f8e5a48c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_replication_origin_status</source>
          <target state="translated">カタログ:pg_replication_origin_status</target>
        </trans-unit>
        <trans-unit id="e8c4e3caea19df2483c4ab01f26aa94ffa837bb1" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_replication_slots</source>
          <target state="translated">カタログ:pg_replication_slots</target>
        </trans-unit>
        <trans-unit id="0821b6a25a55bf7424742dbc12dc0e5ba3d591b6" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_rewrite</source>
          <target state="translated">カタログ:pg_rewrite</target>
        </trans-unit>
        <trans-unit id="6c3b335fca2a54e90ad821652548aa0d9bb5690e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_roles</source>
          <target state="translated">カタログ:pg_roles</target>
        </trans-unit>
        <trans-unit id="0de354bd3294eb64fef4c4abce85b3d2d3beb830" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_rules</source>
          <target state="translated">カタログ:pg_rules</target>
        </trans-unit>
        <trans-unit id="0ebe4b3acf940a10a081afebef169c56d586e493" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_seclabel</source>
          <target state="translated">カタログ:pg_seclabel</target>
        </trans-unit>
        <trans-unit id="9814c0f5828be7c7093a5709f52e474199783220" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_seclabels</source>
          <target state="translated">カタログ:pg_seclabels</target>
        </trans-unit>
        <trans-unit id="daa7b2d6a686574b8a24af09f4e1b47e4eff4aa1" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_sequence</source>
          <target state="translated">カタログ:pg_sequence</target>
        </trans-unit>
        <trans-unit id="ce18fa6a531efc4888fbef423b3467af39c898d4" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_sequences</source>
          <target state="translated">カタログ:pg_sequences</target>
        </trans-unit>
        <trans-unit id="45c1c4bedc4d1a7d8867b8130599c07d2c1d577c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_settings</source>
          <target state="translated">カタログ:pg_settings</target>
        </trans-unit>
        <trans-unit id="3eb114fca9ffe1b0450b4530729652dcc6f0b9e6" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_shadow</source>
          <target state="translated">カタログ:pg_shadow</target>
        </trans-unit>
        <trans-unit id="f2894dea53b78d43d5b3f3281c5f27fc5f3f001b" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_shdepend</source>
          <target state="translated">カタログ:pg_shdepend</target>
        </trans-unit>
        <trans-unit id="90da2a4e4580d6be1fc41ef0a6804e131b5d13bf" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_shdescription</source>
          <target state="translated">カタログ:pg_shdescription</target>
        </trans-unit>
        <trans-unit id="be567ea9a42b5f126c21736241eb2ef91bbd2f79" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_shseclabel</source>
          <target state="translated">カタログ:pg_shseclabel</target>
        </trans-unit>
        <trans-unit id="e90a15834d30c2cd762287e4d2a23a44e610c928" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_statistic</source>
          <target state="translated">カタログ:pg_statistic</target>
        </trans-unit>
        <trans-unit id="fc17f5bd5df84e4c69e2cf93c15b0c0ec6bdf02c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_statistic_ext</source>
          <target state="translated">カタログ:pg_statistic_ext</target>
        </trans-unit>
        <trans-unit id="edacc8fe30e9d6b9a1b1540584abcf7a77d8d1ab" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_statistic_ext_data</source>
          <target state="translated">カタログ:pg_statistic_ext_data</target>
        </trans-unit>
        <trans-unit id="4fe3e6c409cd897cbd40edf5647789819cd97c3f" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_stats</source>
          <target state="translated">カタログ:pg_stats</target>
        </trans-unit>
        <trans-unit id="97198984637b4f8081d351a59e07f627d82013d5" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_stats_ext</source>
          <target state="translated">カタログ:pg_stats_ext</target>
        </trans-unit>
        <trans-unit id="d751befc44bc4db36e1763767ab10200eee30415" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_subscription</source>
          <target state="translated">カタログ:pg_subscription</target>
        </trans-unit>
        <trans-unit id="f690e18690d08756f75b3315f92011ff3ef9c963" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_subscription_rel</source>
          <target state="translated">カタログ:pg_subscription_rel</target>
        </trans-unit>
        <trans-unit id="15150d5768ee1b796c4e6bd2ac3c26eae2b6a8e9" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_tables</source>
          <target state="translated">カタログ:pg_tables</target>
        </trans-unit>
        <trans-unit id="454570cb6d83f09006014194368c60f79eb88220" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_tablespace</source>
          <target state="translated">カタログ:pg_tablespace</target>
        </trans-unit>
        <trans-unit id="b02dd37583faac8a36cec78042caa70a6e32ba24" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_timezone_abbrevs</source>
          <target state="translated">カタログ:pg_timezone_abbrevs</target>
        </trans-unit>
        <trans-unit id="51beadbc15fdfa8bc0949181b01459e3cd7f72dd" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_timezone_names</source>
          <target state="translated">カタログ:pg_timezone_names</target>
        </trans-unit>
        <trans-unit id="c7bfdd455c3f4e8454a7846aa451fdea37a96ef5" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_transform</source>
          <target state="translated">カタログ:pg_transform</target>
        </trans-unit>
        <trans-unit id="202390ad7b0c62ae7dce434843121dfbfde375e8" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_trigger</source>
          <target state="translated">カタログ:pg_trigger</target>
        </trans-unit>
        <trans-unit id="ea8a9b3d765f8be3769406083e40a166da6faf3e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_config</source>
          <target state="translated">カタログ:pg_ts_config</target>
        </trans-unit>
        <trans-unit id="2a1c376cf13aefc2c1504e915090505e5783d753" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_config_map</source>
          <target state="translated">カタログ:pg_ts_config_map</target>
        </trans-unit>
        <trans-unit id="5a3e74be33f49e3b3a1f60a75adce9f08d6c06db" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_dict</source>
          <target state="translated">カタログ:pg_ts_dict</target>
        </trans-unit>
        <trans-unit id="40ce6ddbc53610b063cf04785a5c8be5f7f49c6f" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_parser</source>
          <target state="translated">カタログ:pg_ts_parser</target>
        </trans-unit>
        <trans-unit id="a326494cd8521b1cd4e545e3b34b26162b8e9726" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_ts_template</source>
          <target state="translated">カタログ:pg_ts_template</target>
        </trans-unit>
        <trans-unit id="513906697155f5f42dd3f499de7692b61d383217" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_type</source>
          <target state="translated">カタログ:pg_type</target>
        </trans-unit>
        <trans-unit id="945e0fd46fca84cb2189e5f64036b8473468d6b7" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_user</source>
          <target state="translated">カタログ:pg_user</target>
        </trans-unit>
        <trans-unit id="32120ec9651c7b46e5686537528ac1d2b0e2c12e" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_user_mapping</source>
          <target state="translated">カタログ:pg_user_mapping</target>
        </trans-unit>
        <trans-unit id="09c47b0dd3afb85fbf04db7e76b88c08e663ef5c" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_user_mappings</source>
          <target state="translated">カタログ:pg_user_mappings</target>
        </trans-unit>
        <trans-unit id="61e4c2d909721eba5ae80f09a9313a27e24a17ba" translate="yes" xml:space="preserve">
          <source>Catalogs: pg_views</source>
          <target state="translated">カタログ:pg_views</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="c591c7836d1018a266bff5665cfa4ab9192173b9" translate="yes" xml:space="preserve">
          <source>Cause server processes to reload their configuration files</source>
          <target state="translated">サーバープロセスが設定ファイルをリロードする原因となる</target>
        </trans-unit>
        <trans-unit id="061004f7a3a0616256a6ed3e84699707a6ff3354" translate="yes" xml:space="preserve">
          <source>Causes checkpoints and restartpoints to be logged in the server log. Some statistics are included in the log messages, including the number of buffers written and the time spent writing them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is off.</source>
          <target state="translated">チェックポイントとリスタートポイントをサーバーログに記録させます。書き込まれたバッファの数や書き込みに費やされた時間など、いくつかの統計がログメッセージに含まれます。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。デフォルトはオフです。</target>
        </trans-unit>
        <trans-unit id="e04251bc5f3a68b6174a8e3288ca8639f32a8564" translate="yes" xml:space="preserve">
          <source>Causes each action executed by autovacuum to be logged if it ran for at least the specified amount of time. Setting this to zero logs all autovacuum actions. &lt;code&gt;-1&lt;/code&gt; (the default) disables logging autovacuum actions. If this value is specified without units, it is taken as milliseconds. For example, if you set this to &lt;code&gt;250ms&lt;/code&gt; then all automatic vacuums and analyzes that run 250ms or longer will be logged. In addition, when this parameter is set to any value other than &lt;code&gt;-1&lt;/code&gt;, a message will be logged if an autovacuum action is skipped due to a conflicting lock or a concurrently dropped relation. Enabling this parameter can be helpful in tracking autovacuum activity. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.</source>
          <target state="translated">autovacuumによって実行された各アクションが、少なくとも指定された時間実行された場合にログに記録されます。これをゼロに設定すると、すべての自動バキュームアクションがログに記録されます。 &lt;code&gt;-1&lt;/code&gt; （デフォルト）は、autovacuumアクションのロギングを無効にします。この値が単位なしで指定されている場合、ミリ秒と見なされます。たとえば、これを &lt;code&gt;250ms&lt;/code&gt; 設定すると、250ミリ秒以上実行されるすべての自動バキュームと分析がログに記録されます。さらに、このパラメーターが &lt;code&gt;-1&lt;/code&gt; 以外の値に設定されている場合、競合するロックまたは同時にドロップされた関係が原因で自動バキュームアクションがスキップされると、メッセージがログに記録されます。このパラメーターを有効にすると、自動バキュームのアクティビティを追跡するのに役立ちます。このパラメーターは &lt;code&gt;postgresql.conf&lt;/code&gt; でのみ設定できますファイルまたはサーバーのコマンドライン。ただし、テーブルストレージパラメータを変更することで、個々のテーブルの設定を上書きできます。</target>
        </trans-unit>
        <trans-unit id="1332903808bf92372d34eb563558f4978f18300e" translate="yes" xml:space="preserve">
          <source>Causes each attempted connection to the server to be logged, as well as successful completion of client authentication. Only superusers can change this parameter at session start, and it cannot be changed at all within a session. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">サーバーへの接続の試行がそれぞれログに記録され、クライアント認証が正常に完了します。セッションの開始時にこのパラメーターを変更できるのはスーパーユーザーのみであり、セッション内ではまったく変更できません。デフォルトは &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d6323a01865d7f71338d51ad0db02e3accd4a99f" translate="yes" xml:space="preserve">
          <source>Causes each replication command to be logged in the server log. See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for more information about replication command. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">各レプリケーションコマンドをサーバーログに記録します。レプリケーションコマンドの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;セクション52.4&lt;/a&gt;を参照してください。デフォルト値は &lt;code&gt;off&lt;/code&gt; です。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="e53cbe9c2a49f4096f57a6845a69c106f9e0a362" translate="yes" xml:space="preserve">
          <source>Causes script execution to sleep for the specified duration in microseconds (&lt;code&gt;us&lt;/code&gt;), milliseconds (&lt;code&gt;ms&lt;/code&gt;) or seconds (&lt;code&gt;s&lt;/code&gt;). If the unit is omitted then seconds are the default. &lt;code&gt;number&lt;/code&gt; can be either an integer constant or a &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt; reference to a variable having an integer value.</source>
          <target state="translated">マイクロ秒（ &lt;code&gt;us&lt;/code&gt; ）、ミリ秒（ &lt;code&gt;ms&lt;/code&gt; ）、または秒（ &lt;code&gt;s&lt;/code&gt; ）で指定された期間、スクリプトの実行をスリープさせます。単位が省略されている場合、デフォルトは秒です。 &lt;code&gt;number&lt;/code&gt; は、整数定数または &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; いずれかで、整数値を持つ変数を参照できます。</target>
        </trans-unit>
        <trans-unit id="4981e08aa03f98c21078b6ad0c5efcd341beaa55" translate="yes" xml:space="preserve">
          <source>Causes session terminations to be logged. The log output provides information similar to &lt;code&gt;log_connections&lt;/code&gt;, plus the duration of the session. Only superusers can change this parameter at session start, and it cannot be changed at all within a session. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">セッションの終了を記録します。ログ出力は、 &lt;code&gt;log_connections&lt;/code&gt; と同様の情報に加えて、セッションの期間を提供します。セッションの開始時にこのパラメーターを変更できるのはスーパーユーザーのみであり、セッション内ではまったく変更できません。デフォルトは &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="82f98319f3b2884c120297a0e6b899a808e993b2" translate="yes" xml:space="preserve">
          <source>Causes the cursor to return data in binary rather than in text format.</source>
          <target state="translated">カーソルがテキスト形式ではなくバイナリ形式でデータを返します。</target>
        </trans-unit>
        <trans-unit id="4b3649b306b086669f8c20b1f53cb6aced3b309c" translate="yes" xml:space="preserve">
          <source>Causes the duration of each completed statement to be logged if the statement ran for at least the specified amount of time. If this value is specified without units, it is taken as milliseconds. Setting this to zero prints all statement durations. Minus-one (the default) disables logging statement durations. For example, if you set it to &lt;code&gt;250ms&lt;/code&gt; then all SQL statements that run 250ms or longer will be logged. Enabling this parameter can be helpful in tracking down unoptimized queries in your applications. Only superusers can change this setting.</source>
          <target state="translated">ステートメントが少なくとも指定された時間実行された場合、完了した各ステートメントの期間がログに記録されます。この値が単位なしで指定されている場合、ミリ秒と見なされます。これをゼロに設定すると、すべてのステートメント期間が出力されます。マイナス1（デフォルト）は、ロギングステートメント期間を無効にします。たとえば、 &lt;code&gt;250ms&lt;/code&gt; に設定すると、250ms以上実行されるすべてのSQLステートメントがログに記録されます。このパラメーターを有効にすると、アプリケーションで最適化されていないクエリを追跡するのに役立ちます。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="bfe7cedef9226455a66044ed2753f9a02d24e7ac" translate="yes" xml:space="preserve">
          <source>Causes the duration of every completed statement to be logged. The default is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">完了したすべてのステートメントの期間をログに記録させます。デフォルトは &lt;code&gt;off&lt;/code&gt; です。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="99e5772acf594c054ad0eebaeed915afc1f71c58" translate="yes" xml:space="preserve">
          <source>Causes the named index to become attached to the altered index. The named index must be on a partition of the table containing the index being altered, and have an equivalent definition. An attached index cannot be dropped by itself, and will automatically be dropped if its parent index is dropped.</source>
          <target state="translated">名前付きインデックスを変更されたインデックスにアタッチします。名前付きインデックスは、変更されるインデックスを含むテーブルのパーティション上にあり、同等の定義を持っていなければなりません。アタッチされたインデックスはそれ自身では削除できず、親インデックスが削除された場合は自動的に削除されます。</target>
        </trans-unit>
        <trans-unit id="156e1dbe32702076721ff55ef0bffd691a236c11" translate="yes" xml:space="preserve">
          <source>Causes the system to check for duplicate values in the table when the index is created (if data already exist) and each time data is added. Attempts to insert or update data which would result in duplicate entries will generate an error.</source>
          <target state="translated">インデックスが作成されたとき(データが既に存在する場合)、およびデータが追加されるたびに、システムがテーブル内に重複した値がないかチェックします。重複したエントリになるようなデータを挿入または更新しようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="55a89527100d7affacb785a535913eceec75eda6" translate="yes" xml:space="preserve">
          <source>Caution</source>
          <target state="translated">Caution</target>
        </trans-unit>
        <trans-unit id="a8acba579ef8e3069745d6a9aad2a038c0a8478f" translate="yes" xml:space="preserve">
          <source>Caution must be exercised when specifying an unencrypted password with this command. The password will be transmitted to the server in cleartext, and it might also be logged in the client's command history or the server log. &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; contains a command &lt;code&gt;\password&lt;/code&gt; that can be used to change a role's password without exposing the cleartext password.</source>
          <target state="translated">このコマンドで暗号化されていないパスワードを指定する場合は注意が必要です。パスワードはクリアテキストでサーバーに送信され、クライアントのコマンド履歴またはサーバーログに記録される場合もあります。&lt;a href=&quot;app-psql&quot;&gt;psqlに&lt;/a&gt;は、クリアテキストのパスワードを公開せずにロールのパスワードを変更するために使用できるコマンド &lt;code&gt;\password&lt;/code&gt; が含まれています。</target>
        </trans-unit>
        <trans-unit id="13141094aaaae772e2304157d403fed4d04987dd" translate="yes" xml:space="preserve">
          <source>Caution must be exercised when specifying an unencrypted password with this command. The password will be transmitted to the server in cleartext, and it might also be logged in the client's command history or the server log. The command &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt;, however, transmits the password encrypted. Also, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; contains a command &lt;code&gt;\password&lt;/code&gt; that can be used to safely change the password later.</source>
          <target state="translated">このコマンドで暗号化されていないパスワードを指定する場合は注意が必要です。パスワードはクリアテキストでサーバーに送信され、クライアントのコマンド履歴またはサーバーログに記録される場合もあります。ただし、コマンド&lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt;は暗号化されたパスワードを送信します。また、&lt;a href=&quot;app-psql&quot;&gt;psqlに&lt;/a&gt;は、後でパスワードを安全に変更するために使用できるコマンド &lt;code&gt;\password&lt;/code&gt; が含まれています。</target>
        </trans-unit>
        <trans-unit id="59c4087d8a5f9b4650eb454d2d22ed280de76447" translate="yes" xml:space="preserve">
          <source>Cautious users will want to test their client applications on the new version before switching over fully; therefore, it's often a good idea to set up concurrent installations of old and new versions. When testing a PostgreSQL major upgrade, consider the following categories of possible changes:</source>
          <target state="translated">慎重なユーザは、完全に切り替える前に新しいバージョンでクライアントアプリケーションをテストしたいでしょう。PostgreSQLのメジャーアップグレードをテストする際には、以下のような変更の可能性を考慮してください。</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="8318a7f7457f1a010a3cbc12c805c3073d851311" translate="yes" xml:space="preserve">
          <source>Celtic</source>
          <target state="translated">Celtic</target>
        </trans-unit>
        <trans-unit id="a2391118c8141b7f016207cb0da015ce9b3323e4" translate="yes" xml:space="preserve">
          <source>Center</source>
          <target state="translated">Center</target>
        </trans-unit>
        <trans-unit id="cd23172153f82db844b961331e1dcdc9f04798a5" translate="yes" xml:space="preserve">
          <source>Central European</source>
          <target state="translated">ちゅうおうおうおう</target>
        </trans-unit>
        <trans-unit id="9f43d8cddc33c7a1b859cf192071f47cb602514c" translate="yes" xml:space="preserve">
          <source>Certain modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FM99.99&lt;/code&gt; is the &lt;code&gt;99.99&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-NUMERICMOD-TABLE&quot;&gt;Table 9.28&lt;/a&gt; shows the modifier patterns for numeric formatting.</source>
          <target state="translated">特定の修飾子をテンプレートパターンに適用して、その動作を変更できます。たとえば、 &lt;code&gt;FM99.99&lt;/code&gt; は、 &lt;code&gt;FM&lt;/code&gt; 修飾子を含む &lt;code&gt;99.99&lt;/code&gt; パターンです。&lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-NUMERICMOD-TABLE&quot;&gt;表9.28&lt;/a&gt;は、数値フォーマットの修飾子パターンを示しています。</target>
        </trans-unit>
        <trans-unit id="c951a4db63ebb3cd3179e2b26dd954d081d53c72" translate="yes" xml:space="preserve">
          <source>Certain utility commands, for instance &lt;code&gt;DROP TABLE&lt;/code&gt;, are forced to commit synchronously regardless of the setting of &lt;code&gt;synchronous_commit&lt;/code&gt;. This is to ensure consistency between the server's file system and the logical state of the database. The commands supporting two-phase commit, such as &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, are also always synchronous.</source>
          <target state="translated">一部のユーティリティコマンドは、インスタンスのため &lt;code&gt;DROP TABLE&lt;/code&gt; 、同期の設定に関わらずコミットすることを余儀なくされている &lt;code&gt;synchronous_commit&lt;/code&gt; 。これは、サーバーのファイルシステムとデータベースの論理状態の整合性を確保するためです。 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; などの2フェーズコミットをサポートするコマンドも、常に同期しています。</target>
        </trans-unit>
        <trans-unit id="d8565af86e7dd8fcc32e67bc814d1bb213d6be60" translate="yes" xml:space="preserve">
          <source>Certain variables are special, in that they control psql's behavior or are automatically set to reflect connection state. These variables are documented in &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, below.</source>
          <target state="translated">特定の変数は特別であり、psqlの動作を制御するか、接続状態を反映するように自動的に設定されます。これらの変数は、以下の&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;変数&lt;/a&gt;に記載されています。</target>
        </trans-unit>
        <trans-unit id="4cbd7bb4dc50373cab7f998cf0e909ee69411d53" translate="yes" xml:space="preserve">
          <source>Certificate Authentication</source>
          <target state="translated">証明書認証</target>
        </trans-unit>
        <trans-unit id="d4e234a1ca3005d6b26035fb79c1b9f721db2dfa" translate="yes" xml:space="preserve">
          <source>Certificate Authority</source>
          <target state="translated">認証局</target>
        </trans-unit>
        <trans-unit id="c8a485438966853fda29f434c35133cbf732f0fe" translate="yes" xml:space="preserve">
          <source>Certificate Revocation List</source>
          <target state="translated">証明書失効リスト</target>
        </trans-unit>
        <trans-unit id="17bf1f083821e0e50336e0f90f08e0b36b367e24" translate="yes" xml:space="preserve">
          <source>Change a foreign-data wrapper &lt;code&gt;dbi&lt;/code&gt;, add option &lt;code&gt;foo&lt;/code&gt;, drop &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">外部データラッパー &lt;code&gt;dbi&lt;/code&gt; を変更し、オプション &lt;code&gt;foo&lt;/code&gt; を追加し、 &lt;code&gt;bar&lt;/code&gt; ドロップします。</target>
        </trans-unit>
        <trans-unit id="32a2f5eaac3588dc682626e21196a5c2b59c5a20" translate="yes" xml:space="preserve">
          <source>Change a password expiration date, specifying that the password should expire at midday on 4th May 2015 using the time zone which is one hour ahead of UTC:</source>
          <target state="translated">パスワードの有効期限を変更し、UTCより1時間進んだタイムゾーンを使用して、2015年5月4日の正午にパスワードの有効期限が切れるように指定します。</target>
        </trans-unit>
        <trans-unit id="89136451caa26ba2ef49b9ddac14e69df14f397c" translate="yes" xml:space="preserve">
          <source>Change a role's password:</source>
          <target state="translated">ロールのパスワードを変更します。</target>
        </trans-unit>
        <trans-unit id="76a6da74954b28b8f70437a300c038dec6941d29" translate="yes" xml:space="preserve">
          <source>Change column data types</source>
          <target state="translated">列データ型の変更</target>
        </trans-unit>
        <trans-unit id="c93fcec47f72e06d06fbac297527cbd438f906f0" translate="yes" xml:space="preserve">
          <source>Change default values</source>
          <target state="translated">デフォルト値の変更</target>
        </trans-unit>
        <trans-unit id="5b362073437f207683f5461f1b1b443c7b3b8ab4" translate="yes" xml:space="preserve">
          <source>Change options for the foreign table or one of its columns. &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; specify the action to be performed. &lt;code&gt;ADD&lt;/code&gt; is assumed if no operation is explicitly specified. Duplicate option names are not allowed (although it's OK for a table option and a column option to have the same name). Option names and values are also validated using the foreign data wrapper library.</source>
          <target state="translated">外部テーブルまたはその列のいずれかのオプションを変更します。 &lt;code&gt;ADD&lt;/code&gt; 、 &lt;code&gt;SET&lt;/code&gt; 、および &lt;code&gt;DROP&lt;/code&gt; は、実行するアクションを指定します。操作が明示的に指定されていない場合は、 &lt;code&gt;ADD&lt;/code&gt; が想定されます。オプション名の重複は許可されていません（テーブルオプションと列オプションが同じ名前であっても問題ありません）。オプションの名前と値も、外部データラッパーライブラリを使用して検証されます。</target>
        </trans-unit>
        <trans-unit id="55f114791e1954dfff79bd76576f13f1d557469a" translate="yes" xml:space="preserve">
          <source>Change options for the foreign-data wrapper. &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; specify the action to be performed. &lt;code&gt;ADD&lt;/code&gt; is assumed if no operation is explicitly specified. Option names must be unique; names and values are also validated using the foreign data wrapper's validator function, if any.</source>
          <target state="translated">外部データラッパーのオプションを変更します。 &lt;code&gt;ADD&lt;/code&gt; 、 &lt;code&gt;SET&lt;/code&gt; 、および &lt;code&gt;DROP&lt;/code&gt; は、実行するアクションを指定します。操作が明示的に指定されていない場合は、 &lt;code&gt;ADD&lt;/code&gt; が想定されます。オプション名は一意である必要があります。名前と値も、外部データラッパーのバリデーター関数を使用して検証されます。</target>
        </trans-unit>
        <trans-unit id="b54efbe9196a20405fd2c83c8c58b2bd79277d4a" translate="yes" xml:space="preserve">
          <source>Change options for the server. &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; specify the action to be performed. &lt;code&gt;ADD&lt;/code&gt; is assumed if no operation is explicitly specified. Option names must be unique; names and values are also validated using the server's foreign-data wrapper library.</source>
          <target state="translated">サーバーのオプションを変更します。 &lt;code&gt;ADD&lt;/code&gt; 、 &lt;code&gt;SET&lt;/code&gt; 、および &lt;code&gt;DROP&lt;/code&gt; は、実行するアクションを指定します。操作が明示的に指定されていない場合は、 &lt;code&gt;ADD&lt;/code&gt; が想定されます。オプション名は一意である必要があります。名前と値も、サーバーの外部データラッパーライブラリを使用して検証されます。</target>
        </trans-unit>
        <trans-unit id="6e9f24bb6b0408186a6ae9d3d4bfa8aed5349997" translate="yes" xml:space="preserve">
          <source>Change options for the user mapping. The new options override any previously specified options. &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; specify the action to be performed. &lt;code&gt;ADD&lt;/code&gt; is assumed if no operation is explicitly specified. Option names must be unique; options are also validated by the server's foreign-data wrapper.</source>
          <target state="translated">ユーザーマッピングのオプションを変更します。新しいオプションは、以前に指定されたオプションを上書きします。 &lt;code&gt;ADD&lt;/code&gt; 、 &lt;code&gt;SET&lt;/code&gt; 、および &lt;code&gt;DROP&lt;/code&gt; は、実行するアクションを指定します。操作が明示的に指定されていない場合は、 &lt;code&gt;ADD&lt;/code&gt; が想定されます。オプション名は一意である必要があります。オプションは、サーバーの外部データラッパーによっても検証されます。</target>
        </trans-unit>
        <trans-unit id="4079f921f60434a791719049a23492fea7f07a35" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;kind&lt;/code&gt; column of the table &lt;code&gt;films&lt;/code&gt; in the row on which the cursor &lt;code&gt;c_films&lt;/code&gt; is currently positioned:</source>
          <target state="translated">カーソル &lt;code&gt;c_films&lt;/code&gt; が現在配置されている行のテーブル &lt;code&gt;films&lt;/code&gt; の &lt;code&gt;kind&lt;/code&gt; 列を変更します。</target>
        </trans-unit>
        <trans-unit id="b6047ac63e307a1c73e41cea4c35cbe978e5136b" translate="yes" xml:space="preserve">
          <source>Change the estimated execution cost of the function. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more information.</source>
          <target state="translated">関数の推定実行コストを変更します。詳細については、&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e7be062c0a326c001bfbc1643bf43fd4478ebdb7" translate="yes" xml:space="preserve">
          <source>Change the estimated number of rows returned by a set-returning function. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more information.</source>
          <target state="translated">セットを返す関数によって返される推定行数を変更します。詳細については、&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="752e27cecfa297027f38ddc03ddff0fc4b807417" translate="yes" xml:space="preserve">
          <source>Change the foreign-data wrapper &lt;code&gt;dbi&lt;/code&gt; validator to &lt;code&gt;bob.myvalidator&lt;/code&gt;:</source>
          <target state="translated">外部データラッパーの &lt;code&gt;dbi&lt;/code&gt; バリデーターを &lt;code&gt;bob.myvalidator&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="99dd6ebc845670651ee7fd5030fcefab705a16bd" translate="yes" xml:space="preserve">
          <source>Change the owner of a custom operator &lt;code&gt;a @@ b&lt;/code&gt; for type &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 型のカスタムオペレーター &lt;code&gt;a @@ b&lt;/code&gt; の所有者を変更します。</target>
        </trans-unit>
        <trans-unit id="f67faa872d879796ec2bc11061dcb9aa0dc35620" translate="yes" xml:space="preserve">
          <source>Change the owner of tablespace &lt;code&gt;index_space&lt;/code&gt;:</source>
          <target state="translated">テーブルスペース &lt;code&gt;index_space&lt;/code&gt; の所有者を変更します。</target>
        </trans-unit>
        <trans-unit id="822b72ef81f93836b39722295acc34f4c19b0ad4" translate="yes" xml:space="preserve">
          <source>Change the password for user mapping &lt;code&gt;bob&lt;/code&gt;, server &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">ユーザーマッピング &lt;code&gt;bob&lt;/code&gt; 、サーバー &lt;code&gt;foo&lt;/code&gt; のパスワードを変更します。</target>
        </trans-unit>
        <trans-unit id="c6bbf58e1e213f392cf582da3a65ec34c7ff9158" translate="yes" xml:space="preserve">
          <source>Change the publication subscribed by a subscription to &lt;code&gt;insert_only&lt;/code&gt;:</source>
          <target state="translated">サブスクリプションによってサブスクライブされたパブリケーションを &lt;code&gt;insert_only&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="34045da15d11f6b740295ddc20c0543d3c0083d2" translate="yes" xml:space="preserve">
          <source>Change the publication to publish only deletes and updates:</source>
          <target state="translated">削除と更新のみを掲載するように変更します。</target>
        </trans-unit>
        <trans-unit id="f3a2a1e4d568c17a9cd30237edc9531469c8253f" translate="yes" xml:space="preserve">
          <source>Change the restriction and join selectivity estimator functions of a custom operator &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; for type &lt;code&gt;int[]&lt;/code&gt;:</source>
          <target state="translated">タイプ &lt;code&gt;int[]&lt;/code&gt; カスタム演算子 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; の制限を変更し、選択性推定関数を結合します。</target>
        </trans-unit>
        <trans-unit id="5eaac47535f3006e741788eeae8fad9312a10aad" translate="yes" xml:space="preserve">
          <source>Change the volatility of the function to the specified setting. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for details.</source>
          <target state="translated">関数のボラティリティを指定された設定に変更します。詳細については、&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="60d595e67191c4d753fcf4d6f5f6b1e59875a42f" translate="yes" xml:space="preserve">
          <source>Change the word &lt;code&gt;Drama&lt;/code&gt; to &lt;code&gt;Dramatic&lt;/code&gt; in the column &lt;code&gt;kind&lt;/code&gt; of the table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">テーブルの &lt;code&gt;films&lt;/code&gt; 列の &lt;code&gt;kind&lt;/code&gt; で、「 &lt;code&gt;Drama&lt;/code&gt; という単語を「 &lt;code&gt;Dramatic&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="25251bc112e3a399370d96db7461370f4dac1521" translate="yes" xml:space="preserve">
          <source>Change whether the function is a security definer or not. The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is ignored for SQL conformance. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more information about this capability.</source>
          <target state="translated">関数がセキュリティ定義者であるかどうかを変更します。キーワード &lt;code&gt;EXTERNAL&lt;/code&gt; は、SQL準拠のために無視されます。この&lt;a href=&quot;sql-createfunction&quot;&gt;機能の&lt;/a&gt;詳細については、CREATE FUNCTIONを参照してください。</target>
        </trans-unit>
        <trans-unit id="bb664af015dace04548cd3bd3ebd863d23f845c0" translate="yes" xml:space="preserve">
          <source>Change whether the function is considered leakproof or not. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more information about this capability.</source>
          <target state="translated">関数がリーク防止と見なされるかどうかを変更します。この&lt;a href=&quot;sql-createfunction&quot;&gt;機能の&lt;/a&gt;詳細については、CREATE FUNCTIONを参照してください。</target>
        </trans-unit>
        <trans-unit id="710f9c7b0ca4d696dc493952c70e1f717c7f158b" translate="yes" xml:space="preserve">
          <source>Change whether the function is deemed safe for parallelism. See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for details.</source>
          <target state="translated">関数が並列処理に対して安全であると見なされるかどうかを変更します。詳細については、&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ccc17eca5e67913c7a2e828017ca46a7b7979197" translate="yes" xml:space="preserve">
          <source>Change whether the procedure is a security definer or not. The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is ignored for SQL conformance. See &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt; for more information about this capability.</source>
          <target state="translated">プロシージャがセキュリティ定義者であるかどうかを変更します。キーワード &lt;code&gt;EXTERNAL&lt;/code&gt; は、SQL準拠のために無視されます。この機能の詳細については、&lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="70c22a270b73e2d826094dc62ba61207ee6ca0fc" translate="yes" xml:space="preserve">
          <source>Changes list of subscribed publications. See &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; for more information. By default this command will also act like &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt;.</source>
          <target state="translated">購読している出版物のリストを変更します。詳細については、&lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;を参照してください。デフォルトでは、このコマンドは &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; のようにも機能します。</target>
        </trans-unit>
        <trans-unit id="0777421bfc3abbfb82a4dcb9e3f2333e76343008" translate="yes" xml:space="preserve">
          <source>Changes the check option of the view. The value must be &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;cascaded&lt;/code&gt;.</source>
          <target state="translated">ビューのチェックオプションを変更します。値は &lt;code&gt;local&lt;/code&gt; または &lt;code&gt;cascaded&lt;/code&gt; なければなりません。</target>
        </trans-unit>
        <trans-unit id="777c3c6f950fa43c4d4037401ba7e0940fae4b49" translate="yes" xml:space="preserve">
          <source>Changes the current working directory to &lt;code&gt;directory&lt;/code&gt;. Without argument, changes to the current user's home directory.</source>
          <target state="translated">現在の作業ディレクトリを &lt;code&gt;directory&lt;/code&gt; に変更します。引数がない場合、現在のユーザーのホームディレクトリに変更されます。</target>
        </trans-unit>
        <trans-unit id="ddde67e94aac5719e856f9f56f12bfe3f8078cfb" translate="yes" xml:space="preserve">
          <source>Changes the password of the specified user (by default, the current user). This command prompts for the new password, encrypts it, and sends it to the server as an &lt;code&gt;ALTER ROLE&lt;/code&gt; command. This makes sure that the new password does not appear in cleartext in the command history, the server log, or elsewhere.</source>
          <target state="translated">指定したユーザー（デフォルトでは現在のユーザー）のパスワードを変更します。このコマンドは、新しいパスワードの入力を求め、それを暗号化して、 &lt;code&gt;ALTER ROLE&lt;/code&gt; コマンドとしてサーバーに送信します。これにより、コマンド履歴、サーバーログ、またはその他の場所に新しいパスワードがクリアテキストで表示されなくなります。</target>
        </trans-unit>
        <trans-unit id="d1b27c7f777795b5a8bac186c7dd233e03b18cba" translate="yes" xml:space="preserve">
          <source>Changes the security-barrier property of the view. The value must be Boolean value, such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ビューのセキュリティバリアプロパティを変更します。値は &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; などのブール値である必要があります。</target>
        </trans-unit>
        <trans-unit id="d7ce3845fd5b5d14e3265dc23e6b60ef23ef1b60" translate="yes" xml:space="preserve">
          <source>Changes to these settings can be made in &lt;code&gt;postgresql.conf&lt;/code&gt; without restarting the server. Send a SIGHUP signal to the postmaster to cause it to re-read &lt;code&gt;postgresql.conf&lt;/code&gt; and apply the changes. The postmaster will also forward the SIGHUP signal to its child processes so that they all pick up the new value.</source>
          <target state="translated">これらの設定の変更は、サーバーを再起動せずに &lt;code&gt;postgresql.conf&lt;/code&gt; で行うことができます。SIGHUPシグナルをpostmasterに送信して、 &lt;code&gt;postgresql.conf&lt;/code&gt; を再度読み取り、変更を適用します。postmasterはまた、SIGHUPシグナルをその子プロセスに転送して、それらすべてが新しい値を取得するようにします。</target>
        </trans-unit>
        <trans-unit id="0934f8a643d966fc64ef65df08c958701e8d815a" translate="yes" xml:space="preserve">
          <source>Changes to these settings can be made in &lt;code&gt;postgresql.conf&lt;/code&gt; without restarting the server. They can also be set for a particular session in the connection request packet (for example, via libpq's &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable), but only if the connecting user is a superuser. However, these settings never change in a session after it is started. If you change them in &lt;code&gt;postgresql.conf&lt;/code&gt;, send a SIGHUP signal to the postmaster to cause it to re-read &lt;code&gt;postgresql.conf&lt;/code&gt;. The new values will only affect subsequently-launched sessions.</source>
          <target state="translated">これらの設定の変更は、サーバーを再起動せずに &lt;code&gt;postgresql.conf&lt;/code&gt; で行うことができます。これらは、接続要求パケットの特定のセッションに設定することもできます（たとえば、libpqの &lt;code&gt;PGOPTIONS&lt;/code&gt; 環境変数を介して）。ただし、接続しているユーザーがスーパーユーザーの場合のみ。ただし、これらの設定は、開始後のセッションでは変更されません。あなたがそれらを変更した場合 &lt;code&gt;postgresql.conf&lt;/code&gt; 、再読み込みにそれを引き起こすためにポストマスターにSIGHUPシグナルを送る &lt;code&gt;postgresql.conf&lt;/code&gt; 。新しい値は、その後起動されるセッションにのみ影響します。</target>
        </trans-unit>
        <trans-unit id="a6c05c39b940af67c715028a77dd005d7cf98570" translate="yes" xml:space="preserve">
          <source>Changes to these settings can be made in &lt;code&gt;postgresql.conf&lt;/code&gt; without restarting the server. They can also be set for a particular session in the connection request packet (for example, via libpq's &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable); any user can make such a change for their session. However, these settings never change in a session after it is started. If you change them in &lt;code&gt;postgresql.conf&lt;/code&gt;, send a SIGHUP signal to the postmaster to cause it to re-read &lt;code&gt;postgresql.conf&lt;/code&gt;. The new values will only affect subsequently-launched sessions.</source>
          <target state="translated">これらの設定の変更は、サーバーを再起動せずに &lt;code&gt;postgresql.conf&lt;/code&gt; で行うことができます。これらは、接続要求パケットの特定のセッションに設定することもできます（たとえば、libpqの &lt;code&gt;PGOPTIONS&lt;/code&gt; 環境変数を介して）。どのユーザーも自分のセッションでそのような変更を行うことができます。ただし、これらの設定は、開始後のセッションでは変更されません。あなたがそれらを変更した場合 &lt;code&gt;postgresql.conf&lt;/code&gt; 、再読み込みにそれを引き起こすためにポストマスターにSIGHUPシグナルを送る &lt;code&gt;postgresql.conf&lt;/code&gt; 。新しい値は、その後起動されるセッションにのみ影響します。</target>
        </trans-unit>
        <trans-unit id="51c5f5c3f24afc08ce8ad26a3d8c4257e01709ce" translate="yes" xml:space="preserve">
          <source>Changing Time Sources</source>
          <target state="translated">タイムソースの変更</target>
        </trans-unit>
        <trans-unit id="24c13713f33c06e521f24073f9a29f50dd240e05" translate="yes" xml:space="preserve">
          <source>Changing any part of a system catalog index is not permitted.</source>
          <target state="translated">システムカタログインデックスの一部を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="973bbe6ff83bf124a281e544016f1c5fb5860e0e" translate="yes" xml:space="preserve">
          <source>Changing any part of a system catalog table is not permitted.</source>
          <target state="translated">システムカタログテーブルの一部を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="21462f78ab4f0aaa927058f48a0fc647c028e21a" translate="yes" xml:space="preserve">
          <source>Changing cluster options acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">クラスターオプションを変更すると、 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; ロックが取得されます。</target>
        </trans-unit>
        <trans-unit id="5877579fd9f9e91de9fa7be674c1083ea2046c3e" translate="yes" xml:space="preserve">
          <source>Changing per-attribute options acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">属性ごとのオプションを変更すると、 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; ロックが取得されます。</target>
        </trans-unit>
        <trans-unit id="7584a57d6ab8a0cf30aa0677fe9bdf7463b56891" translate="yes" xml:space="preserve">
          <source>Changing table-level options requires being a superuser or having the privileges of the default role &lt;code&gt;pg_read_server_files&lt;/code&gt; (to use a filename) or the default role &lt;code&gt;pg_execute_server_program&lt;/code&gt; (to use a program), for security reasons: only certain users should be able to control which file is read or which program is run. In principle regular users could be allowed to change the other options, but that's not supported at present.</source>
          <target state="translated">テーブルレベルのオプションを変更するには、セキュリティ上の理由から、スーパーユーザーであるか、デフォルトのロール &lt;code&gt;pg_read_server_files&lt;/code&gt; （ファイル名を使用する）またはデフォルトのロール &lt;code&gt;pg_execute_server_program&lt;/code&gt; （プログラムを使用する）の特権を持っている必要があります。特定のユーザーのみがどのファイルを制御できるようにする必要があります読み込まれるか、どのプログラムが実行されるか。原則として、通常のユーザーは他のオプションを変更できますが、現在のところサポートされていません。</target>
        </trans-unit>
        <trans-unit id="ec87cc74541eda23f7b65c039143416f12ea00c9" translate="yes" xml:space="preserve">
          <source>Changing the data type automatically changes the minimum and maximum values of the sequence if and only if the previous minimum and maximum values were the minimum or maximum value of the old data type (in other words, if the sequence had been created using &lt;code&gt;NO MINVALUE&lt;/code&gt; or &lt;code&gt;NO MAXVALUE&lt;/code&gt;, implicitly or explicitly). Otherwise, the minimum and maximum values are preserved, unless new values are given as part of the same command. If the minimum and maximum values do not fit into the new data type, an error will be generated.</source>
          <target state="translated">データ型を変更すると、以前の最小値と最大値が古いデータ型の最小値または最大値であった場合（つまり、 &lt;code&gt;NO MINVALUE&lt;/code&gt; を使用してシーケンスが作成された場合、または &lt;code&gt;NO MAXVALUE&lt;/code&gt; 、暗黙的または明示的に）。それ以外の場合、新しい値が同じコマンドの一部として指定されない限り、最小値と最大値は保持されます。最小値と最大値が新しいデータ型に適合しない場合、エラーが生成されます。</target>
        </trans-unit>
        <trans-unit id="7dc3983a4c99b0fe0a191c91c764c99b40a05eca" translate="yes" xml:space="preserve">
          <source>Chapter 1. Getting Started</source>
          <target state="translated">第1章 はじめに</target>
        </trans-unit>
        <trans-unit id="e6d40f75e780880b35096c7da5d0b6cf88f51548" translate="yes" xml:space="preserve">
          <source>Chapter 10. Type Conversion</source>
          <target state="translated">第10章 型変換</target>
        </trans-unit>
        <trans-unit id="cfc60ee425037eb0cb18f43ee9772ce702d95eb9" translate="yes" xml:space="preserve">
          <source>Chapter 11. Indexes</source>
          <target state="translated">第11章 インデックス</target>
        </trans-unit>
        <trans-unit id="144f77ced617edb24e991a9d443488ae927d7c88" translate="yes" xml:space="preserve">
          <source>Chapter 12. Full Text Search</source>
          <target state="translated">第12章のこと 全文検索</target>
        </trans-unit>
        <trans-unit id="da45141dfeefeb5e789dc9ca5e0fb10036e0db6b" translate="yes" xml:space="preserve">
          <source>Chapter 13. Concurrency Control</source>
          <target state="translated">第13章 並行性制御</target>
        </trans-unit>
        <trans-unit id="b6ddf02aec05f48576f7b85e82401c2fb11071b2" translate="yes" xml:space="preserve">
          <source>Chapter 14. Performance Tips</source>
          <target state="translated">第14章 パフォーマンスのヒント</target>
        </trans-unit>
        <trans-unit id="a623aebbb35dd440482c53dd04d3cc33587e63de" translate="yes" xml:space="preserve">
          <source>Chapter 15. Parallel Query</source>
          <target state="translated">第15章 並列クエリ</target>
        </trans-unit>
        <trans-unit id="0957a991197939830de983f69bedda91d4f25003" translate="yes" xml:space="preserve">
          <source>Chapter 18. Server Setup and Operation</source>
          <target state="translated">第18章 サーバーの設定と操作 サーバーの設定と操作</target>
        </trans-unit>
        <trans-unit id="81614972621513084f8d86c5e74b927c0877f9d6" translate="yes" xml:space="preserve">
          <source>Chapter 19. Server Configuration</source>
          <target state="translated">第19章 サーバーの構成 サーバーの設定</target>
        </trans-unit>
        <trans-unit id="efd5bae0ce55fc43eb45287a5d1358eeee9c1b2a" translate="yes" xml:space="preserve">
          <source>Chapter 2. The SQL Language</source>
          <target state="translated">第2章 SQL言語</target>
        </trans-unit>
        <trans-unit id="af2a556e9df470b26cc29ab94ee6bdb8e560309e" translate="yes" xml:space="preserve">
          <source>Chapter 20. Client Authentication</source>
          <target state="translated">第20章 クライアント認証 クライアント認証</target>
        </trans-unit>
        <trans-unit id="6bfff62df4428a98260ccc9d271cbb22ddc7803f" translate="yes" xml:space="preserve">
          <source>Chapter 21. Database Roles</source>
          <target state="translated">第21章 データベースの役割 データベースの役割</target>
        </trans-unit>
        <trans-unit id="b792ed08d021d0c561b88be9f49cbde88d6ced6a" translate="yes" xml:space="preserve">
          <source>Chapter 22. Managing Databases</source>
          <target state="translated">第22章 データベースの管理 データベースの管理</target>
        </trans-unit>
        <trans-unit id="8d2edcb13a63c18cd7431348c9c33dd52179cd7a" translate="yes" xml:space="preserve">
          <source>Chapter 23. Localization</source>
          <target state="translated">第23章 ローカライゼーション ローカライゼーション</target>
        </trans-unit>
        <trans-unit id="cc6e2a7196fcdb26bf6fc059b5192cf48cbbeb9a" translate="yes" xml:space="preserve">
          <source>Chapter 24. Routine Database Maintenance Tasks</source>
          <target state="translated">第24章 データベースの定期的なメンテナンスタスク</target>
        </trans-unit>
        <trans-unit id="999abf9a7e4b84d6e10d17d3ec4bee1b92661ec4" translate="yes" xml:space="preserve">
          <source>Chapter 25. Backup and Restore</source>
          <target state="translated">第25章 バックアップとリストア バックアップとリストア</target>
        </trans-unit>
        <trans-unit id="2f78caaef8b16396a00b39c42fd9aa13a58d3184" translate="yes" xml:space="preserve">
          <source>Chapter 26. High Availability, Load Balancing, and Replication</source>
          <target state="translated">第26章 高可用性、ロードバランシング、レプリケーション</target>
        </trans-unit>
        <trans-unit id="8493e0a0f186cf62af71bae82b8349af48aa3fd9" translate="yes" xml:space="preserve">
          <source>Chapter 27. Monitoring Database Activity</source>
          <target state="translated">第27章 データベースのアクティビティを監視する</target>
        </trans-unit>
        <trans-unit id="1d570d3d2b96fe14cfb80e65a5fe7f4b3e799cdd" translate="yes" xml:space="preserve">
          <source>Chapter 28. Monitoring Disk Usage</source>
          <target state="translated">第28章 ディスクの使用状況の監視 ディスク使用量の監視</target>
        </trans-unit>
        <trans-unit id="a7885f0c5b06135be5bc70fc82f008c6016fa830" translate="yes" xml:space="preserve">
          <source>Chapter 29. Reliability and the Write-Ahead Log</source>
          <target state="translated">第29章 信頼性と書き出しログ 信頼性とライトアヘッドログ</target>
        </trans-unit>
        <trans-unit id="97aa927595d881f2ff337f4912ea0e9b82088241" translate="yes" xml:space="preserve">
          <source>Chapter 3. Advanced Features</source>
          <target state="translated">第3章 高度な機能</target>
        </trans-unit>
        <trans-unit id="e8e86ed3680a0da061058da829d1c17ec1464f63" translate="yes" xml:space="preserve">
          <source>Chapter 30. Logical Replication</source>
          <target state="translated">第30章 論理的複製</target>
        </trans-unit>
        <trans-unit id="0140c5595dbd5eded593d083b7cb332d49390c5f" translate="yes" xml:space="preserve">
          <source>Chapter 31. Just-in-Time Compilation (JIT)</source>
          <target state="translated">第31章 ジャストインタイムコンパイル(JIT)ジャストインタイムコンパイル(JIT)</target>
        </trans-unit>
        <trans-unit id="1c7e336e40970e68c4ae71ede9ff09d76f9e2079" translate="yes" xml:space="preserve">
          <source>Chapter 32. Regression Tests</source>
          <target state="translated">第32章 回帰検定</target>
        </trans-unit>
        <trans-unit id="1f8599ba762099abf0b89f7dc39cca2e5a083ac4" translate="yes" xml:space="preserve">
          <source>Chapter 34</source>
          <target state="translated">第34章</target>
        </trans-unit>
        <trans-unit id="a93ab43c432bd443ba365612032323e07c1fc754" translate="yes" xml:space="preserve">
          <source>Chapter 4. SQL Syntax</source>
          <target state="translated">第4章 SQL構文</target>
        </trans-unit>
        <trans-unit id="c2b5a541b35089953bda9d932bfef2ebf3ccf321" translate="yes" xml:space="preserve">
          <source>Chapter 49. Replication Progress Tracking</source>
          <target state="translated">第49章 レプリケーションのプログレス追跡 レプリケーションの進捗状況の追跡</target>
        </trans-unit>
        <trans-unit id="5ea97798ce48ae5bf5d042baf817fc0df4595548" translate="yes" xml:space="preserve">
          <source>Chapter 5. Data Definition</source>
          <target state="translated">第5章 データの定義</target>
        </trans-unit>
        <trans-unit id="a8b14bc1812f9defda6a2509d441df7ef70b7425" translate="yes" xml:space="preserve">
          <source>Chapter 50. Overview of PostgreSQL Internals</source>
          <target state="translated">第50章 PostgreSQL内部の概要</target>
        </trans-unit>
        <trans-unit id="e23b07ca96c19b38aad6046e78d79f3afc6ca003" translate="yes" xml:space="preserve">
          <source>Chapter 51. System Catalogs</source>
          <target state="translated">第51章 システムカタログ システムカタログ</target>
        </trans-unit>
        <trans-unit id="01a1ea702aa47902cf7384a552f9ea849e00d4bc" translate="yes" xml:space="preserve">
          <source>Chapter 52. Frontend/Backend Protocol</source>
          <target state="translated">第52章 フロントエンド/バックエンドプロトコル フロントエンド/バックエンドプロトコル</target>
        </trans-unit>
        <trans-unit id="f102361cd632919e9b21dd5529b48deab47f2d3b" translate="yes" xml:space="preserve">
          <source>Chapter 59. Genetic Query Optimizer</source>
          <target state="translated">第59章 遺伝的クエリオプティマイザ 遺伝的クエリオプティマイザ</target>
        </trans-unit>
        <trans-unit id="84bf92c9f2634767c3f75678e6c3b21abc348a37" translate="yes" xml:space="preserve">
          <source>Chapter 6. Data Manipulation</source>
          <target state="translated">第6章 データの操作 データの操作</target>
        </trans-unit>
        <trans-unit id="00e7845f472e9e21938a52be52669507694bef24" translate="yes" xml:space="preserve">
          <source>Chapter 60. Table Access Method Interface Definition</source>
          <target state="translated">第60章 テーブルアクセス方式インタフェースの定義 テーブルアクセス方式インタフェースの定義</target>
        </trans-unit>
        <trans-unit id="50b349d477a1004af15a262946b1b1bf78f59506" translate="yes" xml:space="preserve">
          <source>Chapter 61. Index Access Method Interface Definition</source>
          <target state="translated">第61章 インデックスアクセス方式インタフェースの定義 インデックスアクセス方式のインタフェース定義</target>
        </trans-unit>
        <trans-unit id="e86751cda024c4b0057b8bc2d8e134bf6720ad4f" translate="yes" xml:space="preserve">
          <source>Chapter 62. Generic WAL Records</source>
          <target state="translated">第62章 一般的なWALレコード</target>
        </trans-unit>
        <trans-unit id="2b20988c4a380ea4a2ab94af4609d4e072cb7eb5" translate="yes" xml:space="preserve">
          <source>Chapter 63. B-Tree Indexes</source>
          <target state="translated">第63章 B-Treeインデックス</target>
        </trans-unit>
        <trans-unit id="5890471db64af7d3bf7b87716d5092b9f512e1cb" translate="yes" xml:space="preserve">
          <source>Chapter 64. GiST Indexes</source>
          <target state="translated">第64章 GiSTインデックス</target>
        </trans-unit>
        <trans-unit id="e56f90bfb3dacab919ac1112ea25a3efcb6c1a00" translate="yes" xml:space="preserve">
          <source>Chapter 65. SP-GiST Indexes</source>
          <target state="translated">第65章 SP-GiSTインデックス</target>
        </trans-unit>
        <trans-unit id="c6f0f26cc9de5e585a31d9d2cf9c68cca6ec7658" translate="yes" xml:space="preserve">
          <source>Chapter 66. GIN Indexes</source>
          <target state="translated">第66章 GINインデックス</target>
        </trans-unit>
        <trans-unit id="8f2e47f95ee2acadfb5ec33dd6ae2cf9fd4a6711" translate="yes" xml:space="preserve">
          <source>Chapter 67. BRIN Indexes</source>
          <target state="translated">第六十七章 BRINインデックス</target>
        </trans-unit>
        <trans-unit id="6afd1fb819de09d125ca4e339c9265abf900ac85" translate="yes" xml:space="preserve">
          <source>Chapter 68. Database Physical Storage</source>
          <target state="translated">第68章 データベースの物理ストレージ データベースの物理ストレージ</target>
        </trans-unit>
        <trans-unit id="2fe6d5ccc8d12bd80e2fa0c2ee3d84273661e269" translate="yes" xml:space="preserve">
          <source>Chapter 69. System Catalog Declarations and Initial Contents</source>
          <target state="translated">第69章 システムカタログの宣言と初期内容 システムカタログの宣言と初期内容</target>
        </trans-unit>
        <trans-unit id="85a83fb1ee953f82a74bb0425f0e03a24516c11e" translate="yes" xml:space="preserve">
          <source>Chapter 7. Queries</source>
          <target state="translated">第7章 クエリー クエリー</target>
        </trans-unit>
        <trans-unit id="80bc7bf38cd739b624ee0a7ea1a1d3f778334dbe" translate="yes" xml:space="preserve">
          <source>Chapter 70. How the Planner Uses Statistics</source>
          <target state="translated">第70章 プランナーが統計を使用する方法</target>
        </trans-unit>
        <trans-unit id="6642f4e46001481876e1721c282938a698fb6952" translate="yes" xml:space="preserve">
          <source>Chapter 8. Data Types</source>
          <target state="translated">第8章 データ型 データ型</target>
        </trans-unit>
        <trans-unit id="a79b450fb04e556467b32b8d86d6e908fabd3a9d" translate="yes" xml:space="preserve">
          <source>Chapter 9. Functions and Operators</source>
          <target state="translated">第9章 関数と演算子</target>
        </trans-unit>
        <trans-unit id="8fb52d46ccc67c5f0a8ba2bd734e96328d987098" translate="yes" xml:space="preserve">
          <source>Character Set Support</source>
          <target state="translated">キャラクターセットサポート</target>
        </trans-unit>
        <trans-unit id="86006dcd13baf1cafe09a54ad445f33fc30c6cf3" translate="yes" xml:space="preserve">
          <source>Character Types</source>
          <target state="translated">文字の種類</target>
        </trans-unit>
        <trans-unit id="4f7075e995d2056ff3899650c4361b65b9866300" translate="yes" xml:space="preserve">
          <source>Character Types: &amp;quot;char&amp;quot;</source>
          <target state="translated">文字タイプ：「char」</target>
        </trans-unit>
        <trans-unit id="a3a45c91003d5cefafa6107f199f7a38d0c3c890" translate="yes" xml:space="preserve">
          <source>Character Types: char</source>
          <target state="translated">文字タイプ:char</target>
        </trans-unit>
        <trans-unit id="0aee8fce8b418732e8a93fd32cc1cc805032fb73" translate="yes" xml:space="preserve">
          <source>Character Types: character</source>
          <target state="translated">キャラクタータイプ:キャラクター</target>
        </trans-unit>
        <trans-unit id="184b3e9992e817890a21c13085e7efc314459161" translate="yes" xml:space="preserve">
          <source>Character Types: character varying</source>
          <target state="translated">キャラクターの種類:キャラクターの変化</target>
        </trans-unit>
        <trans-unit id="d4fd2a583804bcd76bea8c996513a8311f7ac4e9" translate="yes" xml:space="preserve">
          <source>Character Types: name</source>
          <target state="translated">文字タイプ:名前</target>
        </trans-unit>
        <trans-unit id="0486f703899f29349943b2afc946401438fa2fb5" translate="yes" xml:space="preserve">
          <source>Character Types: text</source>
          <target state="translated">文字タイプ:テキスト</target>
        </trans-unit>
        <trans-unit id="d4567dcae64a823d557e1c63712b4fcc9fd32502" translate="yes" xml:space="preserve">
          <source>Character Types: varchar</source>
          <target state="translated">文字タイプ:varchar</target>
        </trans-unit>
        <trans-unit id="bab88ca409704f60d81387fe2d6df281de9d2556" translate="yes" xml:space="preserve">
          <source>Character classification (&lt;code&gt;LC_CTYPE&lt;/code&gt;) to use in the new database. This affects the categorization of characters, e.g. lower, upper and digit. The default is to use the character classification of the template database. See below for additional restrictions.</source>
          <target state="translated">新しいデータベースで使用する文字分類（ &lt;code&gt;LC_CTYPE&lt;/code&gt; ）。これは、文字の分類に影響します（例：下、上、数字）。デフォルトでは、テンプレートデータベースの文字分類が使用されます。追加の制限については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="9f3582c4ef82e94dd06e96939b0da35a20fc80c2" translate="yes" xml:space="preserve">
          <source>Character classification (What is a letter? Its upper-case equivalent?)</source>
          <target state="translated">文字の分類(文字とは何か? 大文字に相当するものは?</target>
        </trans-unit>
        <trans-unit id="aa111127437686e9ef12f3077c9087864a7d1bee" translate="yes" xml:space="preserve">
          <source>Character encoding for this database (&lt;code&gt;pg_encoding_to_char()&lt;/code&gt; can translate this number to the encoding name)</source>
          <target state="translated">このデータベースの文字エンコーディング（ &lt;code&gt;pg_encoding_to_char()&lt;/code&gt; はこの数値をエンコーディング名に変換できます）</target>
        </trans-unit>
        <trans-unit id="5c302c7525b7a3146ad611a4f0f12d64c21504af" translate="yes" xml:space="preserve">
          <source>Character set encoding to use in the new database. Specify a string constant (e.g., &lt;code&gt;'SQL_ASCII'&lt;/code&gt;), or an integer encoding number, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default encoding (namely, the encoding of the template database). The character sets supported by the PostgreSQL server are described in &lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;Section 23.3.1&lt;/a&gt;. See below for additional restrictions.</source>
          <target state="translated">新しいデータベースで使用する文字セットエンコーディング。文字列定数（例： &lt;code&gt;'SQL_ASCII'&lt;/code&gt; ）、整数のエンコーディング番号、またはデフォルトのエンコーディング（つまり、テンプレートデータベースのエンコーディング）を使用する &lt;code&gt;DEFAULT&lt;/code&gt; を指定します。PostgreSQLサーバーでサポートされている文字セットについては、&lt;a href=&quot;multibyte#MULTIBYTE-CHARSET-SUPPORTED&quot;&gt;セクション23.3.1で&lt;/a&gt;説明しています。追加の制限については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="bbfed8165769c95c83883de51ead984f0672c66d" translate="yes" xml:space="preserve">
          <source>Character that separates two values of this type when parsing array input. Note that the delimiter is associated with the array element data type, not the array data type.</source>
          <target state="translated">配列の入力を解析する際に,この型の2つの値を区切る文字.区切り文字は,配列のデータ型ではなく,配列要素のデータ型に関連付けられていることに注意してください.</target>
        </trans-unit>
        <trans-unit id="0d26b57dd1b6ed08d8cfe3afbee948653ba7fb89" translate="yes" xml:space="preserve">
          <source>Character with the given code. For UTF8 the argument is treated as a Unicode code point. For other multibyte encodings the argument must designate an ASCII character. The NULL (0) character is not allowed because text data types cannot store such bytes.</source>
          <target state="translated">与えられたコードを持つ文字。UTF8 の場合、 引数は Unicode コ ー ド 点 と し て扱われます。その他のマルチバ イ ト エン コ ーデ ィ ン グでは、 引数は ASCII キ ャ ラ ク タ を指定す る 必要があ り ます。テキストデータ型ではそのようなバイトを格納できないため、NULL (0)文字は許可されていません。</target>
        </trans-unit>
        <trans-unit id="fdedfe7a4afbdacdcf985eb3b52d523de98f2bcf" translate="yes" xml:space="preserve">
          <source>Character-string data is sorted according to the collation that applies to the column being sorted. That can be overridden at need by including a &lt;code&gt;COLLATE&lt;/code&gt; clause in the &lt;code&gt;expression&lt;/code&gt;, for example &lt;code&gt;ORDER BY mycolumn COLLATE &quot;en_US&quot;&lt;/code&gt;. For more information see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-COLLATE-EXPRS&quot;&gt;Section 4.2.10&lt;/a&gt; and &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.</source>
          <target state="translated">文字列データは、並べ替えられる列に適用される照合順序に従って並べ替えられます。 &lt;code&gt;ORDER BY mycolumn COLLATE &quot;en_US&quot;&lt;/code&gt; のように、 &lt;code&gt;expression&lt;/code&gt; &lt;code&gt;COLLATE&lt;/code&gt; 句を含めることで、必要に応じてオーバーライドできます。詳細については、&lt;a href=&quot;sql-expressions#SQL-SYNTAX-COLLATE-EXPRS&quot;&gt;セクション4.2.10&lt;/a&gt;および&lt;a href=&quot;collation&quot;&gt;セクション23.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3c5ac88bf4f0fe444e0c2465c83a58e27360537f" translate="yes" xml:space="preserve">
          <source>Chebyshev (L-inf metric) distance between a and b.</source>
          <target state="translated">a と b の間のチェビシェフ(L-inf メートル法)距離。</target>
        </trans-unit>
        <trans-unit id="28adc605845f7c3238135a62761fd3dab78dc6b8" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; for details on possible error conditions.</source>
          <target state="translated">考えられるエラー条件の詳細については、&lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="881903249e105e6faf78f5aa20ebda36308bf1af" translate="yes" xml:space="preserve">
          <source>Check constraints on domains are stored here, too.</source>
          <target state="translated">ドメインのチェック制約は、ここにも格納されています。</target>
        </trans-unit>
        <trans-unit id="9b7e37f10bc050bb609ea93daca587898aec0aab" translate="yes" xml:space="preserve">
          <source>Check for a function accepting exactly the input argument types. If one exists (there can be only one exact match in the set of functions considered), use it. Lack of an exact match creates a security hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;, a function found in a schema that permits untrusted users to create objects. In such situations, cast arguments to force an exact match. (Cases involving &lt;code&gt;unknown&lt;/code&gt; will never find a match at this step.)</source>
          <target state="translated">入力引数の型を正確に受け入れる関数を確認してください。存在する場合（考慮される関数のセットで完全に一致するものは1つしか存在しない場合があります）、それを使用します。完全一致の欠如は、信頼されていないユーザーがオブジェクトを作成することを許可するスキーマにある関数を修飾名&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;を介して呼び出すときに、セキュリティ上の危険を引き起こします。このような状況では、引数をキャストして完全一致を強制します。 （ &lt;code&gt;unknown&lt;/code&gt; を含むケースでは、このステップで一致するものを見つけることはできません。）</target>
        </trans-unit>
        <trans-unit id="9ec7dff9841a879a9c69437c7718d0bd7aac1d4d" translate="yes" xml:space="preserve">
          <source>Check for an exact match with the target.</source>
          <target state="translated">ターゲットと完全に一致するかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="e7df70bcd90516e453d9dc6d68524c573ec357e2" translate="yes" xml:space="preserve">
          <source>Check for an operator accepting exactly the input argument types. If one exists (there can be only one exact match in the set of operators considered), use it. Lack of an exact match creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.OP-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;OP-QUALIFIED-SECURITY&quot;&gt;[9]&lt;/sup&gt;&lt;/a&gt; (not typical), any operator found in a schema that permits untrusted users to create objects. In such situations, cast arguments to force an exact match.</source>
          <target state="translated">入力引数の型を正確に受け入れる演算子を確認してください。存在する場合（考慮される演算子のセットで完全に一致するものは1つしか存在しない場合があります）、それを使用します。完全一致の欠如は、信頼できないユーザーがオブジェクトを作成することを許可するスキーマで見つかった演算子を、修飾名&lt;a href=&quot;#ftn.OP-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;OP-QUALIFIED-SECURITY&quot;&gt;[9]&lt;/sup&gt;&lt;/a&gt;（一般的ではありません）を介して呼び出すときにセキュリティの危険を引き起こします。このような状況では、引数をキャストして完全一致を強制します。</target>
        </trans-unit>
        <trans-unit id="f44d969c5b8fd2af5b373e500b5ba3c82215bc10" translate="yes" xml:space="preserve">
          <source>Check that PostgreSQL is actually using the locale that you think it is. The &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings are determined when a database is created, and cannot be changed except by creating a new database. Other locale settings including &lt;code&gt;LC_MESSAGES&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; are initially determined by the environment the server is started in, but can be changed on-the-fly. You can check the active locale settings using the &lt;code&gt;SHOW&lt;/code&gt; command.</source>
          <target state="translated">PostgreSQLが実際に想定しているロケールを使用していることを確認してください。 &lt;code&gt;LC_COLLATE&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; の設定はデータベース作成時に決定され、新しいデータベースを作成することによって除き、変更することはできません。 &lt;code&gt;LC_MESSAGES&lt;/code&gt; や &lt;code&gt;LC_MONETARY&lt;/code&gt; を含むその他のロケール設定は、サーバーが起動される環境によって最初に決定されますが、オンザフライで変更できます。 &lt;code&gt;SHOW&lt;/code&gt; コマンドを使用して、アクティブなロケール設定を確認できます。</target>
        </trans-unit>
        <trans-unit id="7ba406818c8f1055e3ce7bbdb75cfb6882131af8" translate="yes" xml:space="preserve">
          <source>Check this out:</source>
          <target state="translated">これをチェックしてみてください。</target>
        </trans-unit>
        <trans-unit id="d82fa7ebda1d6f869b8585a124a94f6775cc9c50" translate="yes" xml:space="preserve">
          <source>Check to see if there is a sizing cast for the target type. A sizing cast is a cast from that type to itself. If one is found in the &lt;code&gt;pg_cast&lt;/code&gt; catalog, apply it to the expression before storing into the destination column. The implementation function for such a cast always takes an extra parameter of type &lt;code&gt;integer&lt;/code&gt;, which receives the destination column's &lt;code&gt;atttypmod&lt;/code&gt; value (typically its declared length, although the interpretation of &lt;code&gt;atttypmod&lt;/code&gt; varies for different data types), and it may take a third &lt;code&gt;boolean&lt;/code&gt; parameter that says whether the cast is explicit or implicit. The cast function is responsible for applying any length-dependent semantics such as size checking or truncation.</source>
          <target state="translated">ターゲットタイプのサイズ変更キャストがあるかどうかを確認します。サイジングキャストは、そのタイプからそれ自体へのキャストです。 &lt;code&gt;pg_cast&lt;/code&gt; カタログで見つかった場合は、宛先列に格納する前にそれを式に適用します。このようなキャストの実装関数は、常に &lt;code&gt;integer&lt;/code&gt; 型の追加パラメーターを受け取ります。これは、宛先列の &lt;code&gt;atttypmod&lt;/code&gt; 値（通常、宣言された長さですが、 &lt;code&gt;atttypmod&lt;/code&gt; の解釈はデータ型によって異なります）を受け取り、次の3番目の &lt;code&gt;boolean&lt;/code&gt; パラメーターを受け取る場合があります。キャストが明示的か暗黙的かを示します。キャスト関数は、サイズのチェックや切り捨てなど、長さに依存するセマンティクスを適用する役割を果たします。</target>
        </trans-unit>
        <trans-unit id="488bbca005e5d656c373f536704da9574c64804b" translate="yes" xml:space="preserve">
          <source>Check whether the index can support &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;index-only scans&lt;/em&gt;&lt;/a&gt; on the given column, by returning the indexed column values for an index entry in the form of an &lt;code&gt;IndexTuple&lt;/code&gt;. The attribute number is 1-based, i.e. the first column's attno is 1. Returns true if supported, else false. If the access method does not support index-only scans at all, the &lt;code&gt;amcanreturn&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct can be set to NULL.</source>
          <target state="translated">&lt;code&gt;IndexTuple&lt;/code&gt; の形式でインデックスエントリのインデックス付きの列の値を返すことにより、インデックスが特定の列で&lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;インデックスのみのスキャン&lt;/em&gt;&lt;/a&gt;をサポートできるかどうかを確認します。属性番号は1から始まります。つまり、最初の列のattnoは1です。サポートされている場合はtrue、それ以外の場合はfalseを返します。アクセス方法がインデックスのみのスキャンをまったくサポートしていない場合は、 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 構造体の &lt;code&gt;amcanreturn&lt;/code&gt; フィールドをNULLに設定できます。</target>
        </trans-unit>
        <trans-unit id="719e3d162a113b1c19b3b2856b97aaee35467c4d" translate="yes" xml:space="preserve">
          <source>Checking the MCV list, we find that the condition &lt;code&gt;stringu1 &amp;lt; 'IAAAAA'&lt;/code&gt; is satisfied by the first six entries and not the last four, so the selectivity within the MCV part of the population is</source>
          <target state="translated">MCVリストを確認すると、条件 &lt;code&gt;stringu1 &amp;lt; 'IAAAAA'&lt;/code&gt; は、最後の4つのエントリではなく、最初の6つのエントリによって満たされていることがわかります。したがって、母集団のMCV部分内の選択性は</target>
        </trans-unit>
        <trans-unit id="c1cda95fa689cb3d5830910d67b28feaccae1de1" translate="yes" xml:space="preserve">
          <source>Checkpoints are fairly expensive, first because they require writing out all currently dirty buffers, and second because they result in extra subsequent WAL traffic as discussed above. It is therefore wise to set the checkpointing parameters high enough so that checkpoints don't happen too often. As a simple sanity check on your checkpointing parameters, you can set the &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-WARNING&quot;&gt;checkpoint_warning&lt;/a&gt; parameter. If checkpoints happen closer together than &lt;code&gt;checkpoint_warning&lt;/code&gt; seconds, a message will be output to the server log recommending increasing &lt;code&gt;max_wal_size&lt;/code&gt;. Occasional appearance of such a message is not cause for alarm, but if it appears often then the checkpoint control parameters should be increased. Bulk operations such as large &lt;code&gt;COPY&lt;/code&gt; transfers might cause a number of such warnings to appear if you have not set &lt;code&gt;max_wal_size&lt;/code&gt; high enough.</source>
          <target state="translated">チェックポイントはかなり高コストです。1つは現在ダーティバッファーをすべて書き出す必要があるため、2つ目は前述のように追加の後続のWALトラフィックが発生するためです。したがって、チェックポイントが頻繁に発生しないように、チェックポイントパラメータを十分に高く設定することをお勧めします。あなたのチェックポイントのパラメータの簡単な健全性チェックとして、あなたは設定することができ&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-WARNING&quot;&gt;checkpoint_warningの&lt;/a&gt;パラメータを。チェックポイントが &lt;code&gt;checkpoint_warning&lt;/code&gt; 秒よりも接近して発生した場合、 &lt;code&gt;max_wal_size&lt;/code&gt; を増やすことを推奨するメッセージがサーバーログに出力されます。このようなメッセージがときどき現れることはアラームの原因にはなりませんが、頻繁に現れる場合は、チェックポイント制御パラメーターを増やす必要があります。大規模な &lt;code&gt;COPY&lt;/code&gt; などの一括操作 &lt;code&gt;max_wal_size&lt;/code&gt; を十分に高く設定していない場合、転送によってこのような警告がいくつか表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="46973d9be1a1814adf1464037fbdb1be5e8d6b47" translate="yes" xml:space="preserve">
          <source>Checks checksums. This is the default mode if nothing else is specified.</source>
          <target state="translated">チェックサムをチェックします。他に何も指定されていない場合は、これがデフォルトのモードです。</target>
        </trans-unit>
        <trans-unit id="5391fb02e831f35b55c17ace48e9218641ee801d" translate="yes" xml:space="preserve">
          <source>Checks for the presence of the invalid flag</source>
          <target state="translated">無効なフラグが存在するかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="aa8a835e319bd1e6dac67841e62eddb79cc4e5a5" translate="yes" xml:space="preserve">
          <source>Checks whether JSON path returns any item for the specified JSON value.</source>
          <target state="translated">JSONパスが指定されたJSON値の項目を返すかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="15dc18865567bcc98554a72a8036e1b64a8b85d5" translate="yes" xml:space="preserve">
          <source>Chinese</source>
          <target state="translated">Chinese</target>
        </trans-unit>
        <trans-unit id="850f86593a110cf1f0c83911a1210546b313dfdb" translate="yes" xml:space="preserve">
          <source>Choose the first non-unknown input type which is a preferred type in that category, if there is one.</source>
          <target state="translated">そのカテゴリの中で優先されるタイプである最初の不特定多数の入力タイプがある場合は、それを選択します。</target>
        </trans-unit>
        <trans-unit id="a69230bc7ed4cf6a7a2fc18f922e5c50b3e5d64e" translate="yes" xml:space="preserve">
          <source>Chooses a method for inserting a new value into an inner tuple.</source>
          <target state="translated">新しい値を内部タプルに挿入する方法を選択します。</target>
        </trans-unit>
        <trans-unit id="54fd671b5f2d22b32dc8536c4592d6154ff72dae" translate="yes" xml:space="preserve">
          <source>Choosing the target number of partitions that the table should be divided into is also a critical decision to make. Not having enough partitions may mean that indexes remain too large and that data locality remains poor which could result in low cache hit ratios. However, dividing the table into too many partitions can also cause issues. Too many partitions can mean longer query planning times and higher memory consumption during both query planning and execution. When choosing how to partition your table, it's also important to consider what changes may occur in the future. For example, if you choose to have one partition per customer and you currently have a small number of large customers, consider the implications if in several years you instead find yourself with a large number of small customers. In this case, it may be better to choose to partition by &lt;code&gt;HASH&lt;/code&gt; and choose a reasonable number of partitions rather than trying to partition by &lt;code&gt;LIST&lt;/code&gt; and hoping that the number of customers does not increase beyond what it is practical to partition the data by.</source>
          <target state="translated">テーブルを分割する必要があるパーティションのターゲット数を選択することも重要な決定です。十分なパーティションがないと、インデックスが大きくなりすぎてデータの局所性が低くなり、キャッシュヒット率が低下する可能性があります。ただし、テーブルを分割するパーティションが多すぎると、問題が発生する可能性があります。パーティションが多すぎると、クエリの計画と実行の両方で、クエリの計画時間が長くなり、メモリの消費量が増える可能性があります。テーブルを分割する方法を選択するときは、将来どのような変更が発生するかを考慮することも重要です。たとえば、顧客ごとに1つのパーティションを選択し、現在少数の大規模顧客がいる場合、数年後に代わりに多数の小規模顧客がいる場合の影響を考慮してください。この場合、パーティション分割を選択する方が良い場合があります &lt;code&gt;HASH&lt;/code&gt; 、 &lt;code&gt;LIST&lt;/code&gt; でパーティション化しようとするのではなく、妥当な数のパーティションを選択して、顧客の数がデータのパーティション化が実際的である数を超えないことを期待します。</target>
        </trans-unit>
        <trans-unit id="8e7b59e9016961f5946b822566182155391c3900" translate="yes" xml:space="preserve">
          <source>Cipher suites that use ciphers from &lt;code&gt;HIGH&lt;/code&gt; group (e.g., AES, Camellia, 3DES)</source>
          <target state="translated">&lt;code&gt;HIGH&lt;/code&gt; グループの暗号を使用する暗号スイート（AES、Camellia、3DESなど）</target>
        </trans-unit>
        <trans-unit id="a90feb83c70049708c284c2320a5ae7640f39786" translate="yes" xml:space="preserve">
          <source>Cipher suites that use ciphers from &lt;code&gt;MEDIUM&lt;/code&gt; group (e.g., RC4, SEED)</source>
          <target state="translated">&lt;code&gt;MEDIUM&lt;/code&gt; グループの暗号（RC4、SEEDなど）を使用する暗号スイート</target>
        </trans-unit>
        <trans-unit id="1cc7820a08e28aa22dd2e6db74a83b75abc240f5" translate="yes" xml:space="preserve">
          <source>Circle</source>
          <target state="translated">Circle</target>
        </trans-unit>
        <trans-unit id="4c4236345bc9bfb0ad518b6ac3fbc2dd31a75604" translate="yes" xml:space="preserve">
          <source>Circles are output using the first syntax.</source>
          <target state="translated">円は、最初の構文を使用して出力されます。</target>
        </trans-unit>
        <trans-unit id="030bbcf35146cacbbc420191a591376e72bc90d5" translate="yes" xml:space="preserve">
          <source>Circles are represented by a center point and radius. Values of type &lt;code&gt;circle&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">円は中心点と半径で表されます。タイプ &lt;code&gt;circle&lt;/code&gt; の値は、以下の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="eccded7de4a65ea6b5b06c290b5b3a845542227e" translate="yes" xml:space="preserve">
          <source>Classless Inter-Domain Routing</source>
          <target state="translated">クラスレスドメイン間ルーティング</target>
        </trans-unit>
        <trans-unit id="a49fe44e3b0307a1bcb798968f766c04a2364f10" translate="yes" xml:space="preserve">
          <source>Clean (drop) database objects before recreating them. (Unless &lt;code&gt;--if-exists&lt;/code&gt; is used, this might generate some harmless error messages, if any objects were not present in the destination database.)</source>
          <target state="translated">再作成する前に、データベースオブジェクトをクリーン（ドロップ）します。（ &lt;code&gt;--if-exists&lt;/code&gt; を使用しない限り、宛先データベースにオブジェクトが存在しなかった場合、無害なエラーメッセージが生成される可能性があります。）</target>
        </trans-unit>
        <trans-unit id="a57d1cb7f7cf6beddd5cd4dce54e99565a6b71af" translate="yes" xml:space="preserve">
          <source>Clean or analyze &lt;code&gt;table&lt;/code&gt; only. Column names can be specified only in conjunction with the &lt;code&gt;--analyze&lt;/code&gt; or &lt;code&gt;--analyze-only&lt;/code&gt; options. Multiple tables can be vacuumed by writing multiple &lt;code&gt;-t&lt;/code&gt; switches.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; のみをクリーンアップまたは分析します。列名は &lt;code&gt;--analyze&lt;/code&gt; または &lt;code&gt;--analyze-only&lt;/code&gt; オプションと組み合わせた場合にのみ指定できます。複数の &lt;code&gt;-t&lt;/code&gt; スイッチを記述することにより、複数のテーブルをバキュームできます。</target>
        </trans-unit>
        <trans-unit id="735c96393614ad7c5c2b8ceb1620f8e0925da5fa" translate="yes" xml:space="preserve">
          <source>Clean up after a &lt;code&gt;VACUUM&lt;/code&gt; operation (zero or more &lt;code&gt;ambulkdelete&lt;/code&gt; calls). This does not have to do anything beyond returning index statistics, but it might perform bulk cleanup such as reclaiming empty index pages. &lt;code&gt;stats&lt;/code&gt; is whatever the last &lt;code&gt;ambulkdelete&lt;/code&gt; call returned, or NULL if &lt;code&gt;ambulkdelete&lt;/code&gt; was not called because no tuples needed to be deleted. If the result is not NULL it must be a palloc'd struct. The statistics it contains will be used to update &lt;code&gt;pg_class&lt;/code&gt;, and will be reported by &lt;code&gt;VACUUM&lt;/code&gt; if &lt;code&gt;VERBOSE&lt;/code&gt; is given. It is OK to return NULL if the index was not changed at all during the &lt;code&gt;VACUUM&lt;/code&gt; operation, but otherwise correct stats should be returned.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 操作後のクリーンアップ（0回以上の &lt;code&gt;ambulkdelete&lt;/code&gt; 呼び出し）。これは、インデックス統計を返す以外に何もする必要はありませんが、空のインデックスページの再生などの一括クリーンアップを実行する場合があります。 &lt;code&gt;stats&lt;/code&gt; は、最後の &lt;code&gt;ambulkdelete&lt;/code&gt; 呼び出しが返したもの、または削除する必要のあるタプルがないために &lt;code&gt;ambulkdelete&lt;/code&gt; が呼び出されなかった場合はNULLです。結果がNULLでない場合、それはpallocされた構造体でなければなりません。そこに含まれる統計は &lt;code&gt;pg_class&lt;/code&gt; の更新に使用され、 &lt;code&gt;VERBOSE&lt;/code&gt; が指定されている場合は &lt;code&gt;VACUUM&lt;/code&gt; によって報告されます。 &lt;code&gt;VACUUM&lt;/code&gt; 中にインデックスがまったく変更されなかった場合は、NULLを返しても問題ありません。 操作、それ以外の場合は正しい統計を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="7ad74a5024055d7cfa2c59a9048dd8da2e960d57" translate="yes" xml:space="preserve">
          <source>Clear the table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">テーブル &lt;code&gt;films&lt;/code&gt; クリアします。</target>
        </trans-unit>
        <trans-unit id="a9a4c5e05949324bf6b0fb16d4b4f3cadea624c4" translate="yes" xml:space="preserve">
          <source>Client Authentication</source>
          <target state="translated">クライアント認証</target>
        </trans-unit>
        <trans-unit id="357dbce503344612c0fabd6c1533f8bd69142fe2" translate="yes" xml:space="preserve">
          <source>Client Connection Defaults</source>
          <target state="translated">クライアント接続のデフォルト</target>
        </trans-unit>
        <trans-unit id="d1fc8bcb92d3397338fda7ac070162a07bf83d07" translate="yes" xml:space="preserve">
          <source>Client applications that handle server-side errors by parsing the text of the error message will obviously have problems when the server's messages are in a different language. Authors of such applications are advised to make use of the error code scheme instead.</source>
          <target state="translated">エラーメッセージのテキストを解析することでサーバ側のエラーを処理するクライアントアプリケーションは、サーバのメッセージが異なる言語である場合、明らかに問題が発生します。そのようなアプリケーションの作者は、代わりにエラーコードスキームを使うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="7f62d9a1fbbb2ce2cddd029ed2fe28a281be2056" translate="yes" xml:space="preserve">
          <source>Client authentication for replication is controlled by a &lt;code&gt;pg_hba.conf&lt;/code&gt; record specifying &lt;code&gt;replication&lt;/code&gt; in the &lt;code&gt;database&lt;/code&gt; field. For example, if the standby is running on host IP &lt;code&gt;192.168.1.100&lt;/code&gt; and the account name for replication is &lt;code&gt;foo&lt;/code&gt;, the administrator can add the following line to the &lt;code&gt;pg_hba.conf&lt;/code&gt; file on the primary:</source>
          <target state="translated">レプリケーションのクライアント認証は、 &lt;code&gt;database&lt;/code&gt; フィールドで &lt;code&gt;replication&lt;/code&gt; を指定する &lt;code&gt;pg_hba.conf&lt;/code&gt; レコードによって制御されます。たとえば、スタンバイがホストIP &lt;code&gt;192.168.1.100&lt;/code&gt; で実行されていて、レプリケーションのアカウント名が &lt;code&gt;foo&lt;/code&gt; である場合、管理者は次の行をプライマリの &lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルに追加できます。</target>
        </trans-unit>
        <trans-unit id="cc84a669a62f5ca232ebf922e0ad965b3deb7dd8" translate="yes" xml:space="preserve">
          <source>Client authentication is controlled by a configuration file, which traditionally is named &lt;code&gt;pg_hba.conf&lt;/code&gt; and is stored in the database cluster's data directory. (HBA stands for host-based authentication.) A default &lt;code&gt;pg_hba.conf&lt;/code&gt; file is installed when the data directory is initialized by &lt;code&gt;initdb&lt;/code&gt;. It is possible to place the authentication configuration file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-HBA-FILE&quot;&gt;hba_file&lt;/a&gt; configuration parameter.</source>
          <target state="translated">クライアント認証は、従来は &lt;code&gt;pg_hba.conf&lt;/code&gt; という名前でデータベースクラスターのデータディレクトリに保存されている構成ファイルによって制御されます。 （HBAはホストベースの認証を表します。）デフォルトの &lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルは、データディレクトリが &lt;code&gt;initdb&lt;/code&gt; によって初期化されるときにインストールされます。ただし、認証構成ファイルを別の場所に配置することは可能です。&lt;a href=&quot;runtime-config-file-locations#GUC-HBA-FILE&quot;&gt;hba_file&lt;/a&gt;構成パラメーターを参照してください。</target>
        </trans-unit>
        <trans-unit id="629b3a674ff2759a15234a0f27ca1c2b61f9c46a" translate="yes" xml:space="preserve">
          <source>Client principals can be mapped to different PostgreSQL database user names with &lt;code&gt;pg_ident.conf&lt;/code&gt;. For example, &lt;code&gt;pgusername@realm&lt;/code&gt; could be mapped to just &lt;code&gt;pgusername&lt;/code&gt;. Alternatively, you can use the full &lt;code&gt;username@realm&lt;/code&gt; principal as the role name in PostgreSQL without any mapping.</source>
          <target state="translated">クライアントプリンシパルは、 &lt;code&gt;pg_ident.conf&lt;/code&gt; を使用してさまざまなPostgreSQLデータベースユーザー名にマップできます。たとえば、 &lt;code&gt;pgusername@realm&lt;/code&gt; は &lt;code&gt;pgusername&lt;/code&gt; だけにマッピングできます。または、完全な &lt;code&gt;username@realm&lt;/code&gt; プリンシパルを、マッピングなしでPostgreSQLのロール名として使用できます。</target>
        </trans-unit>
        <trans-unit id="c5ce6d7e6024f003e8f14e4f587b6a6491740908" translate="yes" xml:space="preserve">
          <source>Client sends a SASLResponse message, with SCRAM &lt;code&gt;client-final-message&lt;/code&gt; as the content.</source>
          <target state="translated">クライアントは、コンテンツとしてSCRAM &lt;code&gt;client-final-message&lt;/code&gt; を使用してSASLResponseメッセージを送信します。</target>
        </trans-unit>
        <trans-unit id="b8e10276e48f038db512681466dbafb12118bd5c" translate="yes" xml:space="preserve">
          <source>Client-Side Encryption</source>
          <target state="translated">クライアント側の暗号化</target>
        </trans-unit>
        <trans-unit id="d51a6617646b13e732892d1749ba1e127309d447" translate="yes" xml:space="preserve">
          <source>Clock Hardware and Timing Accuracy</source>
          <target state="translated">クロックハードウェアとタイミング精度</target>
        </trans-unit>
        <trans-unit id="21a7e36482abe916e6a3c560955a0114009a4ca6" translate="yes" xml:space="preserve">
          <source>Clock-sweep access count</source>
          <target state="translated">クロックスイープアクセス数</target>
        </trans-unit>
        <trans-unit id="81c141a1154555d95b94141dc24a19f7f8213aed" translate="yes" xml:space="preserve">
          <source>Close all open cursors.</source>
          <target state="translated">開いているカーソルをすべて閉じてください。</target>
        </trans-unit>
        <trans-unit id="3d1b36aa8b5c70b44195178c220fe55db85afcb7" translate="yes" xml:space="preserve">
          <source>Close the cursor &lt;code&gt;liahona&lt;/code&gt;:</source>
          <target state="translated">カーソル &lt;code&gt;liahona&lt;/code&gt; を閉じます。</target>
        </trans-unit>
        <trans-unit id="84ce1963621c46f85aecb48b42fdae72b3b573d0" translate="yes" xml:space="preserve">
          <source>Closed path (similar to polygon)</source>
          <target state="translated">閉じたパス(多角形に似ている</target>
        </trans-unit>
        <trans-unit id="6c6d23ffde231143c689d9a1a9d23c93cbcb98af" translate="yes" xml:space="preserve">
          <source>Closest point to first operand on second operand</source>
          <target state="translated">第2オペランド上の第1オペランドに最も近い点</target>
        </trans-unit>
        <trans-unit id="66b7e0ec8761e07b30c255551fcfb12a214a2e8c" translate="yes" xml:space="preserve">
          <source>Cluster &lt;code&gt;table&lt;/code&gt; only. Multiple tables can be clustered by writing multiple &lt;code&gt;-t&lt;/code&gt; switches.</source>
          <target state="translated">クラスタ &lt;code&gt;table&lt;/code&gt; のみ。複数の &lt;code&gt;-t&lt;/code&gt; スイッチを記述することにより、複数のテーブルをクラスター化できます。</target>
        </trans-unit>
        <trans-unit id="78cfb158c75c4cb2618febccbc1722937af9bc2b" translate="yes" xml:space="preserve">
          <source>Cluster all databases.</source>
          <target state="translated">すべてのデータベースをクラスタ化します。</target>
        </trans-unit>
        <trans-unit id="e0943d95e87e6ca7c31ed73f1e9d681c6d1a8586" translate="yes" xml:space="preserve">
          <source>Cluster all tables in the database that have previously been clustered:</source>
          <target state="translated">以前にクラスタ化されたデータベース内のすべてのテーブルをクラスタ化します。</target>
        </trans-unit>
        <trans-unit id="ef48045cf823187e8b55ae44255dacd11f79eb82" translate="yes" xml:space="preserve">
          <source>Cluster the &lt;code&gt;employees&lt;/code&gt; table using the same index that was used before:</source>
          <target state="translated">以前に使用したのと同じインデックスを使用して &lt;code&gt;employees&lt;/code&gt; テーブルをクラスタ化します。</target>
        </trans-unit>
        <trans-unit id="be1f7ed6b59f3f6d3521c319a991c6f6e4456808" translate="yes" xml:space="preserve">
          <source>Cluster the table &lt;code&gt;employees&lt;/code&gt; on the basis of its index &lt;code&gt;employees_ind&lt;/code&gt;:</source>
          <target state="translated">インデックス &lt;code&gt;employees_ind&lt;/code&gt; に基づいてテーブル &lt;code&gt;employees&lt;/code&gt; をクラスタリングします。</target>
        </trans-unit>
        <trans-unit id="a8fdb3b6f5d839e583d5c2ffab9262c8d2afb036" translate="yes" xml:space="preserve">
          <source>Cluster-wide data can be dumped alone using the pg_dumpall &lt;code&gt;--globals-only&lt;/code&gt; option. This is necessary to fully backup the cluster if running the pg_dump command on individual databases.</source>
          <target state="translated">クラスター全体のデータは、pg_dumpall &lt;code&gt;--globals-only&lt;/code&gt; オプションを使用して単独でダンプできます。これは、個々のデータベースでpg_dumpコマンドを実行する場合にクラスターを完全にバックアップするために必要です。</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="c9488ec230a940ca27958b3358bb15e97a3ff0f7" translate="yes" xml:space="preserve">
          <source>Coerce the given value to text and then quote it as a literal. Embedded single-quotes and backslashes are properly doubled.</source>
          <target state="translated">与えられた値を強制的にテキストにして、リテラルとして引用します。埋め込まれたシングルクォートとバックスラッシュは適切に二重化されます。</target>
        </trans-unit>
        <trans-unit id="12fd65533c35a7aa862d0ffcc3974cdde7cfcd86" translate="yes" xml:space="preserve">
          <source>Coerce the given value to text and then quote it as a literal; or, if the argument is null, return &lt;code&gt;NULL&lt;/code&gt;. Embedded single-quotes and backslashes are properly doubled.</source>
          <target state="translated">与えられた値をテキストに強制し、それをリテラルとして引用します。または、引数がnullの場合は、NULLを返し &lt;code&gt;NULL&lt;/code&gt; 。埋め込まれた一重引用符とバックスラッシュは適切に二重化されます。</target>
        </trans-unit>
        <trans-unit id="6f53e99e8baac8db604ea270dc09be0a2bfe89d5" translate="yes" xml:space="preserve">
          <source>Collation Support</source>
          <target state="translated">照合サポート</target>
        </trans-unit>
        <trans-unit id="cc0fb30413ed48243029d196a0e4276fcbf8bebd" translate="yes" xml:space="preserve">
          <source>Collation name (unique per namespace and encoding)</source>
          <target state="translated">照合名 (名前空間とエンコーディングごとに一意)</target>
        </trans-unit>
        <trans-unit id="c0674c8e614f8ab3ac407aeb60841e6cf3375f17" translate="yes" xml:space="preserve">
          <source>Collation order (&lt;code&gt;LC_COLLATE&lt;/code&gt;) to use in the new database. This affects the sort order applied to strings, e.g. in queries with ORDER BY, as well as the order used in indexes on text columns. The default is to use the collation order of the template database. See below for additional restrictions.</source>
          <target state="translated">新しいデータベースで使用する照合順序（ &lt;code&gt;LC_COLLATE&lt;/code&gt; ）。これは、ORDER BYを使用したクエリなど、文字列に適用される並べ替え順序と、テキスト列のインデックスで使用される順序に影響します。デフォルトでは、テンプレートデータベースの照合順序が使用されます。追加の制限については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="a9d3c380590b334bc9cfdd805604191d71f3646b" translate="yes" xml:space="preserve">
          <source>Collecting accurate timing information is normally done on computers using hardware clocks with various levels of accuracy. With some hardware the operating systems can pass the system clock time almost directly to programs. A system clock can also be derived from a chip that simply provides timing interrupts, periodic ticks at some known time interval. In either case, operating system kernels provide a clock source that hides these details. But the accuracy of that clock source and how quickly it can return results varies based on the underlying hardware.</source>
          <target state="translated">正確なタイミング情報の収集は、通常、様々なレベルの精度を持つハードウェアクロックを使用してコンピュータ上で行われます。いくつかのハードウェアでは、オペレーティングシステムがシステムクロックの時間をプログラムにほぼ直接渡すことができます。また、システムクロックは、単にタイミング割り込み、既知の時間間隔での周期的な刻みを提供するチップから派生することもできます。いずれの場合も、オペレーティングシステムのカーネルは、これらの詳細を隠すクロックソースを提供します。しかし、そのクロックソースの精度や、どれだけ早く結果を返すことができるかは、基盤となるハードウェアによって異なります。</target>
        </trans-unit>
        <trans-unit id="1d793dfbef9f0a0e6127b407a9dbd1cb9cbbcf60" translate="yes" xml:space="preserve">
          <source>Color names can be replaced by their hexadecimal values, e.g., &lt;code&gt;red, green, blue, magenta -&amp;gt; FF0000, 00FF00, 0000FF, FF00FF&lt;/code&gt;</source>
          <target state="translated">色の名前は、16進値で置き換えることができます。たとえば、 &lt;code&gt;red, green, blue, magenta -&amp;gt; FF0000, 00FF00, 0000FF, FF00FF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65ba00e95e60fb8971e699c771908e7c41d91624" translate="yes" xml:space="preserve">
          <source>Column</source>
          <target state="translated">Column</target>
        </trans-unit>
        <trans-unit id="1439028f17fc21ee7e56500963ffcc43d546167f" translate="yes" xml:space="preserve">
          <source>Column &lt;code&gt;STORAGE&lt;/code&gt; settings are also copied from parent tables.</source>
          <target state="translated">列の &lt;code&gt;STORAGE&lt;/code&gt; 設定も親テーブルからコピーされます。</target>
        </trans-unit>
        <trans-unit id="289cfdd6222b45e607a45739197e47437dd847a8" translate="yes" xml:space="preserve">
          <source>Column Check Constraints</source>
          <target state="translated">カラムチェックの制約</target>
        </trans-unit>
        <trans-unit id="f0e08cc3301877a460436bcf15d46df904fa1c8f" translate="yes" xml:space="preserve">
          <source>Column Name</source>
          <target state="translated">カラム名</target>
        </trans-unit>
        <trans-unit id="5082f7083ababbc77bb979626c5aac6366817ae3" translate="yes" xml:space="preserve">
          <source>Column data values of the appropriate kind for the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;, or null if the slot kind does not store any data values. Each array's element values are actually of the specific column's data type, or a related type such as an array's element type, so there is no way to define these columns' type more specifically than &lt;code&gt;anyarray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 番目の「スロット」に適した種類の列データ値。スロットの種類にデータ値が格納されていない場合はnull。各配列の要素値は、実際には特定の列のデータ型、または配列の要素型などの関連する型であるため、これらの列の型を &lt;code&gt;anyarray&lt;/code&gt; より具体的に定義する方法はありません。</target>
        </trans-unit>
        <trans-unit id="3452ec634a556f5804e69085fd6039486777070d" translate="yes" xml:space="preserve">
          <source>Column number targeted by the lock (the &lt;code&gt;classid&lt;/code&gt; and &lt;code&gt;objid&lt;/code&gt; refer to the table itself), or zero if the target is some other general database object, or null if the target is not a general database object</source>
          <target state="translated">ロックの対象となる列番号（ &lt;code&gt;classid&lt;/code&gt; および &lt;code&gt;objid&lt;/code&gt; はテーブル自体を参照）、またはターゲットが他の一般的なデータベースオブジェクトの場合はゼロ、ターゲットが一般的なデータベースオブジェクトでない場合はnull</target>
        </trans-unit>
        <trans-unit id="c02b6a156f26f9570640cefebee04ceb3c4781f0" translate="yes" xml:space="preserve">
          <source>Column numbers, if trigger is column-specific; otherwise an empty array</source>
          <target state="translated">トリガが列固有の場合は列番号、そうでない場合は空の配列</target>
        </trans-unit>
        <trans-unit id="4f5840e9e9eef85bc5eff199eb5320f4319160ea" translate="yes" xml:space="preserve">
          <source>Column-level access privileges, if any have been granted specifically on this column</source>
          <target state="translated">カラムレベルのアクセス権限がある場合、このカラムに特別に付与されている場合</target>
        </trans-unit>
        <trans-unit id="37600cd17920781a24b5b7e102123d5dd57326b1" translate="yes" xml:space="preserve">
          <source>Column-level permissions will also be checked for each referenced column. &lt;code&gt;db_column:select&lt;/code&gt; is checked on not only the columns being read using &lt;code&gt;SELECT&lt;/code&gt;, but those being referenced in other DML statements; &lt;code&gt;db_column:update&lt;/code&gt; or &lt;code&gt;db_column:insert&lt;/code&gt; will also be checked for columns being modified by &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;.</source>
          <target state="translated">参照されている各列について、列レベルの権限もチェックされます。 &lt;code&gt;db_column:select&lt;/code&gt; は、 &lt;code&gt;SELECT&lt;/code&gt; を使用して読み取られている列だけでなく、他のDMLステートメントで参照されている列でもチェックされます。 &lt;code&gt;db_column:update&lt;/code&gt; または &lt;code&gt;db_column:insert&lt;/code&gt; も、 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;INSERT&lt;/code&gt; によって変更される列についてチェックされます。</target>
        </trans-unit>
        <trans-unit id="ee56bbceca154f2098f19f6e8e425a6491c6cee7" translate="yes" xml:space="preserve">
          <source>Columns listed in the &lt;code&gt;INCLUDE&lt;/code&gt; clause don't need appropriate operator classes; the clause can include columns whose data types don't have operator classes defined for a given access method.</source>
          <target state="translated">&lt;code&gt;INCLUDE&lt;/code&gt; 句にリストされている列には、適切な演算子クラスは必要ありません。句には、特定のアクセスメソッドに対して定義された演算子クラスを持たないデータ型の列を含めることができます。</target>
        </trans-unit>
        <trans-unit id="a16a5643d1f00b1978a8c620cd41de3d0bb8524e" translate="yes" xml:space="preserve">
          <source>Columns may be marked &lt;code&gt;NOT NULL&lt;/code&gt;. If the &lt;code&gt;column_expression&lt;/code&gt; for a &lt;code&gt;NOT NULL&lt;/code&gt; column does not match anything and there is no &lt;code&gt;DEFAULT&lt;/code&gt; or the &lt;code&gt;default_expression&lt;/code&gt; also evaluates to null, an error is reported.</source>
          <target state="translated">列は &lt;code&gt;NOT NULL&lt;/code&gt; とマークされる場合があります。 &lt;code&gt;NOT NULL&lt;/code&gt; 列の &lt;code&gt;column_expression&lt;/code&gt; が何にも一致せず、 &lt;code&gt;DEFAULT&lt;/code&gt; がない場合、または &lt;code&gt;default_expression&lt;/code&gt; もnullと評価される場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="8722c83ccb79b0cdcd5f2ed4e7529f7bf85136b9" translate="yes" xml:space="preserve">
          <source>Columns of a table are also matched by name. The order of columns in the subscriber table does not need to match that of the publisher. The data types of the columns do not need to match, as long as the text representation of the data can be converted to the target type. For example, you can replicate from a column of type &lt;code&gt;integer&lt;/code&gt; to a column of type &lt;code&gt;bigint&lt;/code&gt;. The target table can also have additional columns not provided by the published table. Any such columns will be filled with the default value as specified in the definition of the target table.</source>
          <target state="translated">テーブルの列も名前で照合されます。サブスクライバーテーブルの列の順序は、パブリッシャーの列の順序と一致する必要はありません。データのテキスト表現をターゲットタイプに変換できる限り、列のデータタイプは一致する必要はありません。たとえば、型の列から複製することができ &lt;code&gt;integer&lt;/code&gt; 型の列に &lt;code&gt;bigint&lt;/code&gt; 。ターゲットテーブルには、パブリッシュされたテーブルでは提供されない追加の列を含めることもできます。そのような列には、ターゲット表の定義で指定されているデフォルト値が入力されます。</target>
        </trans-unit>
        <trans-unit id="f6722930440001f207cb71c029960e6823ed128c" translate="yes" xml:space="preserve">
          <source>Columns that have been dropped from the table also contribute to the maximum column limit. Moreover, although the dropped column values for newly created tuples are internally marked as null in the tuple's null bitmap, the null bitmap also occupies space.</source>
          <target state="translated">テーブルから削除された列もまた、最大列数の制限に寄与します。さらに、新しく作成されたタプルのドロップされた列の値は、内部的にはタプルのヌルビットマップにヌルとしてマークされますが、ヌルビットマップもスペースを占有します。</target>
        </trans-unit>
        <trans-unit id="7b9695a881e079b5e76a032197eee89f340ed0b0" translate="yes" xml:space="preserve">
          <source>Columns used to form &amp;ldquo;replica identity&amp;rdquo; for rows: &lt;code&gt;d&lt;/code&gt; = default (primary key, if any), &lt;code&gt;n&lt;/code&gt; = nothing, &lt;code&gt;f&lt;/code&gt; = all columns &lt;code&gt;i&lt;/code&gt; = index with &lt;code&gt;indisreplident&lt;/code&gt; set, or default</source>
          <target state="translated">行の「レプリカID」を形成するために使用される列： &lt;code&gt;d&lt;/code&gt; =デフォルト（存在する場合は主キー）、 &lt;code&gt;n&lt;/code&gt; =なし、 &lt;code&gt;f&lt;/code&gt; =すべての列 &lt;code&gt;i&lt;/code&gt; = &lt;code&gt;indisreplident&lt;/code&gt; 設定されたインデックス、またはデフォルト</target>
        </trans-unit>
        <trans-unit id="ecf4938c09b7baa93df6f51766d4b9568ff8b87e" translate="yes" xml:space="preserve">
          <source>Combine function (zero if none)</source>
          <target state="translated">コンバイン機能(なければゼロ</target>
        </trans-unit>
        <trans-unit id="b2934e3c1cc659ddbafc11f39d4747e931c97bf5" translate="yes" xml:space="preserve">
          <source>Combines both of the above options.</source>
          <target state="translated">上記のオプションの両方を組み合わせます。</target>
        </trans-unit>
        <trans-unit id="9b8c6c21748f6385c19086f65218b6f955d17f46" translate="yes" xml:space="preserve">
          <source>Combining Multiple Indexes</source>
          <target state="translated">複数のインデックスを組み合わせる</target>
        </trans-unit>
        <trans-unit id="7ed5f1795200b9a5f27686390337eb73996c75b4" translate="yes" xml:space="preserve">
          <source>Combining Queries</source>
          <target state="translated">クエリの組み合わせ</target>
        </trans-unit>
        <trans-unit id="7d744180e2b1652f30d0b01c3ec0dffd855d81d8" translate="yes" xml:space="preserve">
          <source>Combining Queries: EXCEPT</source>
          <target state="translated">クエリを結合します。EXCEPT</target>
        </trans-unit>
        <trans-unit id="1962bff7a417b581598656f48af3e5258db60ea1" translate="yes" xml:space="preserve">
          <source>Combining Queries: INTERSECT</source>
          <target state="translated">クエリを組み合わせる インターセクト</target>
        </trans-unit>
        <trans-unit id="6cf590965ba1f9879168440f1f27eb1bd0bda058" translate="yes" xml:space="preserve">
          <source>Combining Queries: UNION</source>
          <target state="translated">クエリを結合します。ユニオン</target>
        </trans-unit>
        <trans-unit id="ca19eaee08702deeaef3602966f0b70fca762ada" translate="yes" xml:space="preserve">
          <source>Comma Separated Values</source>
          <target state="translated">カンマ区切りの値</target>
        </trans-unit>
        <trans-unit id="8901895fb1b1d4c4ea2fec368c25176bf73e2f7e" translate="yes" xml:space="preserve">
          <source>Command</source>
          <target state="translated">Command</target>
        </trans-unit>
        <trans-unit id="174a63a1205957f0771a13a913b2ad84bd765510" translate="yes" xml:space="preserve">
          <source>Command executed by the &lt;code&gt;\!&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;\!&lt;/code&gt; によって実行されるコマンド コマンド。</target>
        </trans-unit>
        <trans-unit id="278ac1cdf2ca6ded3a4a528bee443fbc9fd5a344" translate="yes" xml:space="preserve">
          <source>Command identifiers are also 32-bit quantities. This creates a hard limit of 2&lt;sup&gt;32&lt;/sup&gt; (4 billion) SQL commands within a single transaction. In practice this limit is not a problem &amp;mdash; note that the limit is on the number of SQL commands, not the number of rows processed. Also, only commands that actually modify the database contents will consume a command identifier.</source>
          <target state="translated">コマンド識別子も32ビットの数量です。これにより、1つのトランザクション内に2 &lt;sup&gt;32&lt;/sup&gt;（40億）のSQLコマンドのハード制限が作成されます。実際には、この制限は問題ではありません。制限は、処理される行の数ではなく、SQLコマンドの数にあることに注意してください。また、実際にデータベースの内容を変更するコマンドのみがコマンド識別子を使用します。</target>
        </trans-unit>
        <trans-unit id="2c4b8fd91008dbf8bd6354ca2c271fc25998dcdb" translate="yes" xml:space="preserve">
          <source>Command tag: type of session's current command</source>
          <target state="translated">コマンドタグ:セッションの現在のコマンドのタイプ</target>
        </trans-unit>
        <trans-unit id="232187997abcc8c310be15f9e2b1664cf9978b9d" translate="yes" xml:space="preserve">
          <source>Command tags for which this trigger will fire. If NULL, the firing of this trigger is not restricted on the basis of the command tag.</source>
          <target state="translated">このトリガが起動するコマンドタグ。NULLの場合、このトリガの発射はコマンドタグに基づいて制限されません。</target>
        </trans-unit>
        <trans-unit id="b25e5fb9a11f166615d93fcb65262b0c87f57e44" translate="yes" xml:space="preserve">
          <source>Command-Line Editing</source>
          <target state="translated">コマンドライン編集</target>
        </trans-unit>
        <trans-unit id="6158b615b8c54dc251e1ffff571847cadca842cf" translate="yes" xml:space="preserve">
          <source>CommandId</source>
          <target state="translated">CommandId</target>
        </trans-unit>
        <trans-unit id="45e5f3f72e961cb70134ba35f7a27a9620e515f7" translate="yes" xml:space="preserve">
          <source>Commands</source>
          <target state="translated">Commands</target>
        </trans-unit>
        <trans-unit id="95cb369a2c1ae6926c27cd5f5544f941b4636eab" translate="yes" xml:space="preserve">
          <source>Commas (&lt;code&gt;,&lt;/code&gt;) are used in some syntactical constructs to separate the elements of a list.</source>
          <target state="translated">カンマ（ &lt;code&gt;,&lt;/code&gt; ）は、リストの要素を区切るために一部の構文構成で使用されます。</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="a3bfde75e2fe305108416a7acb2609c34a1a5994" translate="yes" xml:space="preserve">
          <source>Comment string from the extension's control file</source>
          <target state="translated">拡張機能のコントロールファイルからのコメント文字列</target>
        </trans-unit>
        <trans-unit id="5b50e65179e9dde82ce934eff47ec7882e869f4f" translate="yes" xml:space="preserve">
          <source>Comments and whitespace are handled in the same way as in &lt;code&gt;pg_hba.conf&lt;/code&gt;. The &lt;code&gt;map-name&lt;/code&gt; is an arbitrary name that will be used to refer to this mapping in &lt;code&gt;pg_hba.conf&lt;/code&gt;. The other two fields specify an operating system user name and a matching database user name. The same &lt;code&gt;map-name&lt;/code&gt; can be used repeatedly to specify multiple user-mappings within a single map.</source>
          <target state="translated">コメントと空白は &lt;code&gt;pg_hba.conf&lt;/code&gt; と同じ方法で処理されます。 &lt;code&gt;map-name&lt;/code&gt; 、このマッピングを参照するために使用される任意の名前である &lt;code&gt;pg_hba.conf&lt;/code&gt; の。他の2つのフィールドは、オペレーティングシステムのユーザー名と一致するデータベースユーザー名を指定します。同じ &lt;code&gt;map-name&lt;/code&gt; を繰り返し使用して、1つのマップ内で複数のユーザーマッピングを指定できます。</target>
        </trans-unit>
        <trans-unit id="44a6fd86d069c0f83a2af7714ff0672a07e9a12b" translate="yes" xml:space="preserve">
          <source>Comments are preceded by &lt;code&gt;#&lt;/code&gt;, and must be on their own lines.</source>
          <target state="translated">コメントの前には &lt;code&gt;#&lt;/code&gt; があり、コメントは独自の行になければなりません。</target>
        </trans-unit>
        <trans-unit id="8ea98a71022b615fabbb92e9b911e7731dde6a5f" translate="yes" xml:space="preserve">
          <source>Comments can be viewed using psql's &lt;code&gt;\d&lt;/code&gt; family of commands. Other user interfaces to retrieve comments can be built atop the same built-in functions that psql uses, namely &lt;code&gt;obj_description&lt;/code&gt;, &lt;code&gt;col_description&lt;/code&gt;, and &lt;code&gt;shobj_description&lt;/code&gt; (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;Table 9.73&lt;/a&gt;).</source>
          <target state="translated">コメントは、psqlの &lt;code&gt;\d&lt;/code&gt; ファミリのコマンドを使用して表示できます。コメントを取得するための他のユーザーインターフェイスは、psqlが使用するのと同じ組み込み関数、つまり &lt;code&gt;obj_description&lt;/code&gt; 、 &lt;code&gt;col_description&lt;/code&gt; 、および &lt;code&gt;shobj_description&lt;/code&gt; の上に構築できます（&lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;表9.73を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5b2ac1534bc179931f5fa20ea8355d274f0ee844" translate="yes" xml:space="preserve">
          <source>Comments for the copied columns, constraints, and indexes will be copied. The default behavior is to exclude comments, resulting in the copied columns and constraints in the new table having no comments.</source>
          <target state="translated">コピーされた列、制約、およびインデックスのコメントがコピーされます。デフォルトの動作はコメントを除外することで、新しいテーブルのコピーされた列と制約にはコメントがありません。</target>
        </trans-unit>
        <trans-unit id="4a778236e17d9f01dae405aa74899721aa2f09ca" translate="yes" xml:space="preserve">
          <source>Commercial Solutions</source>
          <target state="translated">商用ソリューション</target>
        </trans-unit>
        <trans-unit id="b8b8cad039eea4bbd93fe4a7569bc664e95f71b6" translate="yes" xml:space="preserve">
          <source>Commit the transaction identified by the transaction identifier &lt;code&gt;foobar&lt;/code&gt;:</source>
          <target state="translated">トランザクション識別子 &lt;code&gt;foobar&lt;/code&gt; 識別されるトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="f6eaa962650a97f840a2800c301825ed8d72a917" translate="yes" xml:space="preserve">
          <source>Common Options</source>
          <target state="translated">共通オプション</target>
        </trans-unit>
        <trans-unit id="cf6f857064f7e69451a2963d2cda7e8c356ef71d" translate="yes" xml:space="preserve">
          <source>Common Table Expression</source>
          <target state="translated">共通テーブル表現</target>
        </trans-unit>
        <trans-unit id="253e2f931e23b5f531559b7abd6d31539e0a117a" translate="yes" xml:space="preserve">
          <source>Common Vulnerabilities and Exposures</source>
          <target state="translated">一般的な脆弱性とエクスポージャ</target>
        </trans-unit>
        <trans-unit id="64c95e8ab21e68bee3d8dd4d244de519744fccc7" translate="yes" xml:space="preserve">
          <source>Communication method</source>
          <target state="translated">通信方式</target>
        </trans-unit>
        <trans-unit id="2e5e3073095fe271a2d9297b034a848894250b4f" translate="yes" xml:space="preserve">
          <source>Commutator of the &lt;code&gt;&amp;lt;%&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;%&lt;/code&gt; 演算子の交換子。</target>
        </trans-unit>
        <trans-unit id="8b0f8d58d1c77eb764351a0b6f87f69add89f9d1" translate="yes" xml:space="preserve">
          <source>Commutator of the &lt;code&gt;&amp;lt;&amp;lt;%&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;%&lt;/code&gt; 演算子の交換子。</target>
        </trans-unit>
        <trans-unit id="6d875e8a794fe250e3d0d7dbbc5344c5b94699c0" translate="yes" xml:space="preserve">
          <source>Commutator of the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;-&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;-&amp;gt;&lt;/code&gt; 演算子の交換子。</target>
        </trans-unit>
        <trans-unit id="1b3622e2ac284bfb523ad8fc2abbc031eb2a62d8" translate="yes" xml:space="preserve">
          <source>Commutator of the &lt;code&gt;&amp;lt;&amp;lt;-&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;-&amp;gt;&lt;/code&gt; 演算子の交換子。</target>
        </trans-unit>
        <trans-unit id="8f95659e3581f0b29bdb3913745fcf1dd53b5995" translate="yes" xml:space="preserve">
          <source>Commutator of this operator, if any</source>
          <target state="translated">もしあれば、この演算子のコミュテータ</target>
        </trans-unit>
        <trans-unit id="d124776efdf568a154cc960bb025e2ef08d7a89e" translate="yes" xml:space="preserve">
          <source>Compare a partial-match query key to an index key. Returns an integer whose sign indicates the result: less than zero means the index key does not match the query, but the index scan should continue; zero means that the index key does match the query; greater than zero indicates that the index scan should stop because no more matches are possible. The strategy number &lt;code&gt;n&lt;/code&gt; of the operator that generated the partial match query is provided, in case its semantics are needed to determine when to end the scan. Also, &lt;code&gt;extra_data&lt;/code&gt; is the corresponding element of the extra-data array made by &lt;code&gt;extractQuery&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if none. Null keys are never passed to this function.</source>
          <target state="translated">部分一致クエリキーをインデックスキーと比較します。符号が結果を示す整数を返します。ゼロ未満の場合、インデックスキーはクエリに一致しませんが、インデックススキャンは続行されます。ゼロは、インデックスキーがクエリと一致することを意味します。ゼロより大きい場合、これ以上一致する可能性がないため、インデックススキャンを停止する必要があることを示します。部分一致クエリを生成した演算子の戦略番号 &lt;code&gt;n&lt;/code&gt; が提供されます。これは、スキャンを終了するタイミングを決定するためにそのセマンティクスが必要な場合に備えています。また、 &lt;code&gt;extra_data&lt;/code&gt; は製エクストラデータアレイの対応する要素である &lt;code&gt;extractQuery&lt;/code&gt; の、または &lt;code&gt;NULL&lt;/code&gt; なし場合。 nullキーがこの関数に渡されることはありません。</target>
        </trans-unit>
        <trans-unit id="42cdd4afb9c4a9955f909a36e78ad45ab07bdac5" translate="yes" xml:space="preserve">
          <source>Compared to functional dependencies, MCV lists have two major advantages. Firstly, the list stores actual values, making it possible to decide which combinations are compatible.</source>
          <target state="translated">機能依存関係と比較して、MCVリストには大きく2つの利点があります。第一に、リストには実際の値が格納されているため、互換性のある組み合わせを決定することが可能になります。</target>
        </trans-unit>
        <trans-unit id="04f64ce8bc8a69b417a8a154b465629b1da24aa9" translate="yes" xml:space="preserve">
          <source>Compares two keys (not indexed items!) and returns an integer less than zero, zero, or greater than zero, indicating whether the first key is less than, equal to, or greater than the second. Null keys are never passed to this function.</source>
          <target state="translated">2 つのキー (インデックス化された項目ではありません!)を比較し、最初のキーが 2 番目のキーよりも小さいか、等しいか、または大きいかを示す 0 よりも小さいか、0 よりも大きいか、または 0 よりも大きい整数を返します。NULL キーがこの関数に渡されることはありません。</target>
        </trans-unit>
        <trans-unit id="144fad6e22d897b3948d3102d3a4ee6f98b4f0f3" translate="yes" xml:space="preserve">
          <source>Comparing two floating-point values for equality might not always work as expected.</source>
          <target state="translated">2つの浮動小数点値を比較して等しさを求めると、必ずしも期待通りにはいかないことがあります。</target>
        </trans-unit>
        <trans-unit id="82668afbd9ca9905b48bc0534a51ab3d6f379746" translate="yes" xml:space="preserve">
          <source>Comparison of Different Solutions</source>
          <target state="translated">異なるソリューションの比較</target>
        </trans-unit>
        <trans-unit id="688d1dd068f557e23c1811d137fa9d0ee7984602" translate="yes" xml:space="preserve">
          <source>Comparison of crypt-des, crypt-md5 and bcrypt algorithms.</source>
          <target state="translated">crypt-des,crypt-md5,bcryptアルゴリズムの比較。</target>
        </trans-unit>
        <trans-unit id="3973aa07a4403e385cc1e99e69e0be49b6cc3b61" translate="yes" xml:space="preserve">
          <source>Comparison operators are available for all relevant data types. All comparison operators are binary operators that return values of type &lt;code&gt;boolean&lt;/code&gt;; expressions like &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; are not valid (because there is no &lt;code&gt;&amp;lt;&lt;/code&gt; operator to compare a Boolean value with &lt;code&gt;3&lt;/code&gt;).</source>
          <target state="translated">比較演算子は、関連するすべてのデータタイプで使用できます。すべての比較演算子は、 &lt;code&gt;boolean&lt;/code&gt; 型の値を返す2項演算子です。 &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; ような式は無効です（ブール値を &lt;code&gt;3&lt;/code&gt; と比較する &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子がないため）。</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="9021a3ffbf0cdb7258143f75a75a99fb3bbf436c" translate="yes" xml:space="preserve">
          <source>Comparisons involving an added enum value will sometimes be slower than comparisons involving only original members of the enum type. This will usually only occur if &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; is used to set the new value's sort position somewhere other than at the end of the list. However, sometimes it will happen even though the new value is added at the end (this occurs if the OID counter &amp;ldquo;wrapped around&amp;rdquo; since the original creation of the enum type). The slowdown is usually insignificant; but if it matters, optimal performance can be regained by dropping and recreating the enum type, or by dumping and reloading the database.</source>
          <target state="translated">追加された列挙値を含む比較は、列挙型の元のメンバーのみを含む比較よりも遅くなることがあります。これは通常、 &lt;code&gt;BEFORE&lt;/code&gt; または &lt;code&gt;AFTER&lt;/code&gt; を使用して新しい値のソート位置をリストの最後以外の場所に設定した場合にのみ発生します。ただし、最後に新しい値が追加された場合でも発生することがあります（これは、OIDカウンターが列挙型の最初の作成以降に「ラップアラウンド」した場合に発生します）。減速は通常重要ではありません。ただし、問題がある場合は、列挙型を削除して再作成するか、データベースをダンプして再ロードすることで、最適なパフォーマンスを回復できます。</target>
        </trans-unit>
        <trans-unit id="72f70a808fb8dff833a9ba6a1ec891ad79c91ddf" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;gt;</source>
          <target state="translated">比較：&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5fd0bc4fc993999d06759d89da7ccf387529bff" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;gt;=</source>
          <target state="translated">比較：&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="6fe80c71e2e7d878eb87f66fd7e56b66f7e76985" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;lt;</source>
          <target state="translated">比較：&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ceb484cdd06746bf898467c23e5bc8299bec7c13" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;lt;&amp;gt;</source>
          <target state="translated">比較：&amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0e016e19c1413324801b9522ced74a81a4c2e94d" translate="yes" xml:space="preserve">
          <source>Comparisons: &amp;lt;=</source>
          <target state="translated">比較：&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="8dde29d89f59d19ce1b51c0d2e2e2bed0dee7065" translate="yes" xml:space="preserve">
          <source>Comparisons: =</source>
          <target state="translated">比較:=比較</target>
        </trans-unit>
        <trans-unit id="ee5183de6e4bf275c384cea74c0400b55b746d02" translate="yes" xml:space="preserve">
          <source>Comparisons: BETWEEN</source>
          <target state="translated">比較してみました。間</target>
        </trans-unit>
        <trans-unit id="aa67bacfe69a4a17e45b3d66f8f7996bc796594e" translate="yes" xml:space="preserve">
          <source>Comparisons: BETWEEN SYMMETRIC</source>
          <target state="translated">比較します。間シンメトリックス</target>
        </trans-unit>
        <trans-unit id="9b896fc3b06e75ccc1a09e2c9a1969d831a2d16e" translate="yes" xml:space="preserve">
          <source>Comparisons: IS DISTINCT FROM</source>
          <target state="translated">比較してみましょう。から離れています。</target>
        </trans-unit>
        <trans-unit id="1c79549f9e78b7beb0454a7e7d27503fd85db6ca" translate="yes" xml:space="preserve">
          <source>Comparisons: IS FALSE</source>
          <target state="translated">比較すること。は「偽」です。</target>
        </trans-unit>
        <trans-unit id="6062f3bde8f951e2d9b36c1332df7954220f7d2d" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT DISTINCT FROM</source>
          <target state="translated">比較です。からの距離ではありません。</target>
        </trans-unit>
        <trans-unit id="a3a4a8777a6e8acb75d32d5cbcc1ebf8f4ee8e2b" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT FALSE</source>
          <target state="translated">比較すること。は偽りではありません。</target>
        </trans-unit>
        <trans-unit id="1d15c7ea99bc16b6d7b497d14960efd81e844616" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT NULL</source>
          <target state="translated">比較。IS NOT NULL</target>
        </trans-unit>
        <trans-unit id="d52c743eb62fbb4089e38c3bcc8ac850978f5e47" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT TRUE</source>
          <target state="translated">比較してみてください。真ではありません。</target>
        </trans-unit>
        <trans-unit id="d22d0b9103ac49f59b0ca02492f5189321fda490" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NOT UNKNOWN</source>
          <target state="translated">比較してみました。IS NOT UNKNOWN</target>
        </trans-unit>
        <trans-unit id="9e2c3021a351b272eb8a97d468495e36ba1772c6" translate="yes" xml:space="preserve">
          <source>Comparisons: IS NULL</source>
          <target state="translated">比較します。IS NULL</target>
        </trans-unit>
        <trans-unit id="f122aa342eb5b2de82a09c639872b8b9c03bb8a1" translate="yes" xml:space="preserve">
          <source>Comparisons: IS TRUE</source>
          <target state="translated">比較してみましょう。真</target>
        </trans-unit>
        <trans-unit id="8dd19d79d059f22e6e7d35c01a28407439729301" translate="yes" xml:space="preserve">
          <source>Comparisons: IS UNKNOWN</source>
          <target state="translated">比較してみました。IS UNKNOWN</target>
        </trans-unit>
        <trans-unit id="431a3c5547cbf4fd11195bcf71b983e89940803d" translate="yes" xml:space="preserve">
          <source>Comparisons: ISNULL</source>
          <target state="translated">比較してみました。ISNULL</target>
        </trans-unit>
        <trans-unit id="cd0c06292093ac5d89114d79d296c85753ff7359" translate="yes" xml:space="preserve">
          <source>Comparisons: NOT BETWEEN</source>
          <target state="translated">比較する。間ではない</target>
        </trans-unit>
        <trans-unit id="bd2796acf9e88836f98b26163186dc5132a135c1" translate="yes" xml:space="preserve">
          <source>Comparisons: NOT BETWEEN SYMMETRIC</source>
          <target state="translated">比較。シンメトリクス間ではない</target>
        </trans-unit>
        <trans-unit id="406e730102d9cc93be2f47c3ba43a6e7f1a96dc9" translate="yes" xml:space="preserve">
          <source>Comparisons: NOTNULL</source>
          <target state="translated">比較を行います。NOTNULL</target>
        </trans-unit>
        <trans-unit id="f339b211417b72bf5bcc21878fc8760d864e1c8c" translate="yes" xml:space="preserve">
          <source>Comparisons: num_nonnulls</source>
          <target state="translated">比較:num_nonnulls</target>
        </trans-unit>
        <trans-unit id="db31a1ea15667990f06c57c4970da4626506bd51" translate="yes" xml:space="preserve">
          <source>Comparisons: num_nulls</source>
          <target state="translated">比較:num_nulls</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="3fcce917a99aa1e0b998f0b229bc0ee92255056a" translate="yes" xml:space="preserve">
          <source>Complex queries can involve many levels of plan nodes, but the general approach is the same: each node computes and returns its next output row each time it is called. Each node is also responsible for applying any selection or projection expressions that were assigned to it by the planner.</source>
          <target state="translated">複雑なクエリには多くのレベルのプランノードが含まれますが、一般的なアプローチは同じです:各ノードは呼び出されるたびに次の出力行を計算して返します。各ノードは,プランナによって割り当てられた選択式や射影式を適用する責任も負います.</target>
        </trans-unit>
        <trans-unit id="7bf0ab10fb9860e23b1ca89e4313be7fafb258f7" translate="yes" xml:space="preserve">
          <source>Composite Types</source>
          <target state="translated">コンポジットタイプ</target>
        </trans-unit>
        <trans-unit id="537187710d8643593965aef2a7a923121f09907a" translate="yes" xml:space="preserve">
          <source>Composite types</source>
          <target state="translated">複合タイプ</target>
        </trans-unit>
        <trans-unit id="66c4e897db42f9c56916e2de56c4ee7bced3dac9" translate="yes" xml:space="preserve">
          <source>Comprehensive Perl Archive Network</source>
          <target state="translated">包括的なPerlアーカイブネットワーク</target>
        </trans-unit>
        <trans-unit id="27b6dd31d02e8ac5ef9c53dc3256e339965c8ec4" translate="yes" xml:space="preserve">
          <source>Compute the index access cost. A generic estimator might do this:</source>
          <target state="translated">インデックスアクセスコストを計算します。一般的な推定器がこれを行うかもしれません。</target>
        </trans-unit>
        <trans-unit id="e20a1dbf33bf0e4db3b6761dbfa9a781b01604c7" translate="yes" xml:space="preserve">
          <source>Computes a binary hash of the given &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt;. &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; is the algorithm to use. Standard algorithms are &lt;code&gt;md5&lt;/code&gt;, &lt;code&gt;sha1&lt;/code&gt;, &lt;code&gt;sha224&lt;/code&gt;, &lt;code&gt;sha256&lt;/code&gt;, &lt;code&gt;sha384&lt;/code&gt; and &lt;code&gt;sha512&lt;/code&gt;. If &lt;code&gt;pgcrypto&lt;/code&gt; was built with OpenSSL, more algorithms are available, as detailed in &lt;a href=&quot;pgcrypto#PGCRYPTO-WITH-WITHOUT-OPENSSL&quot;&gt;Table F.19&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt;バイナリハッシュを計算し&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt;は使用するアルゴリズムです。標準アルゴリズムは、 &lt;code&gt;md5&lt;/code&gt; 、 &lt;code&gt;sha1&lt;/code&gt; 、 &lt;code&gt;sha224&lt;/code&gt; 、 &lt;code&gt;sha256&lt;/code&gt; 、 &lt;code&gt;sha384&lt;/code&gt; 、 &lt;code&gt;sha512&lt;/code&gt; です。 &lt;code&gt;pgcrypto&lt;/code&gt; がOpenSSLで構築されている場合は、&lt;a href=&quot;pgcrypto#PGCRYPTO-WITH-WITHOUT-OPENSSL&quot;&gt;表F.19&lt;/a&gt;に示すように、より多くのアルゴリズムを使用できます。</target>
        </trans-unit>
        <trans-unit id="b403ea8b697b5a1271920418a675e0c16387e926" translate="yes" xml:space="preserve">
          <source>Computing time</source>
          <target state="translated">計算時間</target>
        </trans-unit>
        <trans-unit id="aadb86cad4563bf048f76bee72cc413d9670abc2" translate="yes" xml:space="preserve">
          <source>Concatenate all but the first argument with separators. The first argument is used as the separator string. NULL arguments are ignored.</source>
          <target state="translated">第1引数以外のすべてをセパレータで連結します。第一引数がセパレータ文字列として使用されます。NULL 引数は無視されます。</target>
        </trans-unit>
        <trans-unit id="10f9586f627cdbf27c6e355d31387bbf162dfdb1" translate="yes" xml:space="preserve">
          <source>Concatenate the text representations of all the arguments. NULL arguments are ignored.</source>
          <target state="translated">すべての引数のテキスト表現を連結します。NULL 引数は無視されます。</target>
        </trans-unit>
        <trans-unit id="7c3d0c23ffb9fdb22ea46ba55d20510d1de197e6" translate="yes" xml:space="preserve">
          <source>Concatenate two &lt;code&gt;jsonb&lt;/code&gt; values into a new &lt;code&gt;jsonb&lt;/code&gt; value</source>
          <target state="translated">2つの &lt;code&gt;jsonb&lt;/code&gt; 値を連結して新しい &lt;code&gt;jsonb&lt;/code&gt; 値にする</target>
        </trans-unit>
        <trans-unit id="0fc858f9117ebe86d3894371f4487964bd12946e" translate="yes" xml:space="preserve">
          <source>Conceptually, every expression of a collatable data type has a collation. (The built-in collatable data types are &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt;. User-defined base types can also be marked collatable, and of course a domain over a collatable data type is collatable.) If the expression is a column reference, the collation of the expression is the defined collation of the column. If the expression is a constant, the collation is the default collation of the data type of the constant. The collation of a more complex expression is derived from the collations of its inputs, as described below.</source>
          <target state="translated">概念的には、照合可能なデータ型のすべての式には照合順序があります。 （組み込みの照合可能なデータ型は &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、および &lt;code&gt;char&lt;/code&gt; です。ユーザー定義の基本型も照合可能としてマークできます。もちろん、照合可能なデータ型のドメインは照合可能です。）式が列参照の場合、式の照合は、列の定義された照合です。式が定数の場合、照合は定数のデータ型のデフォルトの照合です。以下で説明するように、より複雑な式の照合は、その入力の照合から派生します。</target>
        </trans-unit>
        <trans-unit id="7f315b1389481e62a5048c7274c93f74a68c1f7c" translate="yes" xml:space="preserve">
          <source>Conclusion? It is nice to have a special data type that can record the limits of an interval with arbitrarily variable precision. Variable in the sense that each data element records its own precision.</source>
          <target state="translated">結論から言うと?任意に可変精度で区間の限界を記録できる特殊なデータ型があるといいですね。各データ要素がそれぞれの精度を記録するという意味では可変的です。</target>
        </trans-unit>
        <trans-unit id="6297e1cbe3d6a0c06891acd5c8af4d127c0d1132" translate="yes" xml:space="preserve">
          <source>Concurrency Control</source>
          <target state="translated">並行処理制御</target>
        </trans-unit>
        <trans-unit id="bd13301a59c28852e4300d37d71af83b51e78423" translate="yes" xml:space="preserve">
          <source>Concurrent builds for indexes on partitioned tables are currently not supported. However, you may concurrently build the index on each partition individually and then finally create the partitioned index non-concurrently in order to reduce the time where writes to the partitioned table will be locked out. In this case, building the partitioned index is a metadata only operation.</source>
          <target state="translated">パーティショニングされたテーブル上のインデックスの同時ビルドは現在サポートされていません。しかし、パーティショニングされたテーブルへの書き込みがロックアウトされる時間を短縮するために、各パーティション上のインデックスを個別に同時ビルドし、最後に非同時ビルドでパーティショニングされたインデックスを作成することができます。この場合、パーティショニングされたインデックスの構築はメタデータのみの操作となります。</target>
        </trans-unit>
        <trans-unit id="963a572c795297d4b531f2d8dc46d16e80d45499" translate="yes" xml:space="preserve">
          <source>Concurrent builds of expression indexes and partial indexes are supported. Errors occurring in the evaluation of these expressions could cause behavior similar to that described above for unique constraint violations.</source>
          <target state="translated">式インデックスと部分インデックスの同時ビルドがサポートされています。これらの式の評価でエラーが発生すると、一意の制約違反に対して上記で説明したのと同様の動作を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="6e305b80ad043f3938d2064507fd1c4224e23df3" translate="yes" xml:space="preserve">
          <source>Condition Name</source>
          <target state="translated">条件名</target>
        </trans-unit>
        <trans-unit id="8a0d63179619b501ad5800876cf0df368b27a390" translate="yes" xml:space="preserve">
          <source>Conditional Expressions</source>
          <target state="translated">条件式</target>
        </trans-unit>
        <trans-unit id="96981fb7d354d12e3362c85d68207f4e2f0838fc" translate="yes" xml:space="preserve">
          <source>Conditional Expressions: CASE</source>
          <target state="translated">条件式。CASE</target>
        </trans-unit>
        <trans-unit id="31aeb72f2f3391d030478c674c1b1e99a6bfaa65" translate="yes" xml:space="preserve">
          <source>Conditional Expressions: COALESCE</source>
          <target state="translated">条件式。coallesce</target>
        </trans-unit>
        <trans-unit id="80b1183f8c1779a8f9e2e00b4b48c3ac0b91eb03" translate="yes" xml:space="preserve">
          <source>Conditional Expressions: GREATEST and LEAST</source>
          <target state="translated">条件式。GREATESTとLEAST</target>
        </trans-unit>
        <trans-unit id="82e1c19ddb5b72b2d1628f347f8bae9565387565" translate="yes" xml:space="preserve">
          <source>Conditional Expressions: NULLIF</source>
          <target state="translated">条件式。NULLIF</target>
        </trans-unit>
        <trans-unit id="e8bca94262e57c3a1ece8f104ce7fd307805ff70" translate="yes" xml:space="preserve">
          <source>Config: DateStyle</source>
          <target state="translated">コンフィグ。デートスタイル</target>
        </trans-unit>
        <trans-unit id="8511a3d87020c8a69f6436b1827106433ad1d2ee" translate="yes" xml:space="preserve">
          <source>Config: IntervalStyle</source>
          <target state="translated">設定。IntervalStyle</target>
        </trans-unit>
        <trans-unit id="b144c36fb88dac3ce5285c3c981dc9351e3b98fc" translate="yes" xml:space="preserve">
          <source>Config: TimeZone</source>
          <target state="translated">設定します。タイムゾーン</target>
        </trans-unit>
        <trans-unit id="18a399a27b0a37f91c764c69975729a0e6573d13" translate="yes" xml:space="preserve">
          <source>Config: allow_system_table_mods</source>
          <target state="translated">設定:allow_system_table_mods</target>
        </trans-unit>
        <trans-unit id="f0fab5fc27a2fe4c5e7760f7f7c177e385ad2591" translate="yes" xml:space="preserve">
          <source>Config: application_name</source>
          <target state="translated">設定:アプリケーション名</target>
        </trans-unit>
        <trans-unit id="d1f6d8b6e711d4ba59b0b94f84ceac5029dbaf7e" translate="yes" xml:space="preserve">
          <source>Config: archive_cleanup_command</source>
          <target state="translated">設定:archive_cleanup_command</target>
        </trans-unit>
        <trans-unit id="2fab064686922676e797fc47a18c333454a80fa1" translate="yes" xml:space="preserve">
          <source>Config: archive_command</source>
          <target state="translated">設定:archive_command</target>
        </trans-unit>
        <trans-unit id="7245f5a1ef6fc61169efa659a07ddb9c10d24604" translate="yes" xml:space="preserve">
          <source>Config: archive_mode</source>
          <target state="translated">設定:archive_mode</target>
        </trans-unit>
        <trans-unit id="840bc864a38d460630bcd6de13d3535faf7a00bf" translate="yes" xml:space="preserve">
          <source>Config: archive_timeout</source>
          <target state="translated">設定:archive_timeout</target>
        </trans-unit>
        <trans-unit id="ba4297026f3e073c1e0dc3a2afeae0b082ebd020" translate="yes" xml:space="preserve">
          <source>Config: array_nulls</source>
          <target state="translated">設定:array_nulls</target>
        </trans-unit>
        <trans-unit id="7bb011279372ad23a9a2b11a5c3ea59c686e271b" translate="yes" xml:space="preserve">
          <source>Config: authentication_timeout</source>
          <target state="translated">設定:authentication_timeout</target>
        </trans-unit>
        <trans-unit id="5941e7a97778ba946038d81f471acc5a7b8af99e" translate="yes" xml:space="preserve">
          <source>Config: autovacuum</source>
          <target state="translated">設定:自動バキューム</target>
        </trans-unit>
        <trans-unit id="a43f76e1db32589e05b8c05232a61e43de7938c5" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_analyze_scale_factor</source>
          <target state="translated">設定:autovacuum_analyze_scale_factor</target>
        </trans-unit>
        <trans-unit id="242180115535965f07118f06213c1df477e0f174" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_analyze_threshold</source>
          <target state="translated">設定:autovacuum_analyze_threshold</target>
        </trans-unit>
        <trans-unit id="83e95fe01f4fc127940b09173f91885cf297f68d" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_freeze_max_age</source>
          <target state="translated">設定:autovacuum_freeze_max_age</target>
        </trans-unit>
        <trans-unit id="017808f6d070e5e8e7cf3c185a5fd17fde18c054" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_max_workers</source>
          <target state="translated">設定:autovacuum_max_workers</target>
        </trans-unit>
        <trans-unit id="53ade2cde7db11b6c4e3bb8cdf3c9a64c500c156" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_multixact_freeze_max_age</source>
          <target state="translated">設定:autovacuum_multixact_freeze_max_age</target>
        </trans-unit>
        <trans-unit id="55d0a539086ca4d4a71bf19539eb4916a39c362b" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_naptime</source>
          <target state="translated">設定:autovacuum_naptime</target>
        </trans-unit>
        <trans-unit id="f6de913c942c9946837babc768d0f897678d23bc" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_vacuum_cost_delay</source>
          <target state="translated">設定:autovacuum_vacuum_cost_delay</target>
        </trans-unit>
        <trans-unit id="85ac6ab8e00a08929e157f17f1a926fcb57aebb2" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_vacuum_cost_limit</source>
          <target state="translated">設定:autovacuum_vacuum_cost_limit</target>
        </trans-unit>
        <trans-unit id="658166dda413e0040c2f606fded0147b97cd7f9f" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_vacuum_scale_factor</source>
          <target state="translated">設定:autovacuum_vacuum_scale_factor</target>
        </trans-unit>
        <trans-unit id="6d09feb26281c939269c7f66dab6a858024efaeb" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_vacuum_threshold</source>
          <target state="translated">設定:autovacuum_vacuum_threshold</target>
        </trans-unit>
        <trans-unit id="3306f6d52b58797515ffd3bb2de543ee8e3b05f2" translate="yes" xml:space="preserve">
          <source>Config: autovacuum_work_mem</source>
          <target state="translated">設定:autovacuum_work_mem</target>
        </trans-unit>
        <trans-unit id="ce8f98d44391f786dd5f656e40b627a5a19894a4" translate="yes" xml:space="preserve">
          <source>Config: backend_flush_after</source>
          <target state="translated">設定:backend_flush_after</target>
        </trans-unit>
        <trans-unit id="177de7ae0453e0490ad03b84788518a349cd7c38" translate="yes" xml:space="preserve">
          <source>Config: backslash_quote</source>
          <target state="translated">設定:backslash_quote</target>
        </trans-unit>
        <trans-unit id="ed264423122a9b435d56653dfce96b0aaf843d7a" translate="yes" xml:space="preserve">
          <source>Config: bgwriter_delay</source>
          <target state="translated">設定:bgwriter_delay</target>
        </trans-unit>
        <trans-unit id="8248026151b19669fc716236de46e4581858ce37" translate="yes" xml:space="preserve">
          <source>Config: bgwriter_flush_after</source>
          <target state="translated">設定:bgwriter_flush_after</target>
        </trans-unit>
        <trans-unit id="e2ffe551d8a693157336985e8341d6853ff4096a" translate="yes" xml:space="preserve">
          <source>Config: bgwriter_lru_maxpages</source>
          <target state="translated">設定:bgwriter_lru_maxpages</target>
        </trans-unit>
        <trans-unit id="a5fbeda3e9d2eb6fc02dedc336a690d19d598946" translate="yes" xml:space="preserve">
          <source>Config: bgwriter_lru_multiplier</source>
          <target state="translated">設定:bgwriter_lru_multiplier</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
