<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="f76857de86cd4afe434d4b21d9313477ab29ebe7" translate="yes" xml:space="preserve">
          <source>A limitation of this feature is that an &lt;code&gt;ORDER BY&lt;/code&gt; clause applying to the result of a &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, or &lt;code&gt;EXCEPT&lt;/code&gt; clause can only specify an output column name or number, not an expression.</source>
          <target state="translated">この機能の制限は、 &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;INTERSECT&lt;/code&gt; 、または &lt;code&gt;EXCEPT&lt;/code&gt; 句の結果に適用される &lt;code&gt;ORDER BY&lt;/code&gt; 句は、式ではなく出力列の名前または数値のみを指定できることです。</target>
        </trans-unit>
        <trans-unit id="6e332e0f99b25d5ac06d1f211aa0eb2e56e7af5e" translate="yes" xml:space="preserve">
          <source>A list of NULL flags for the most common combinations of values. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">値の最も一般的な組み合わせのNULLフラグのリスト。（ &lt;code&gt;most_common_vals&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="faedcc532ba9e80276afc21b0d135826be8f1422" translate="yes" xml:space="preserve">
          <source>A list of non-null element values most often appearing within values of the column. (Null for scalar types.)</source>
          <target state="translated">カラムの値の中で最も頻繁に現れる非ヌル要素の値のリスト。(スカラ型の場合はNull)。</target>
        </trans-unit>
        <trans-unit id="9222c144bac210ee75eb7f8e023e5b70c063c9b1" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and the update expressions. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement. Note that the target table must not appear in the &lt;code&gt;from_list&lt;/code&gt;, unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_list&lt;/code&gt;).</source>
          <target state="translated">テーブル式のリスト。他のテーブルの列を &lt;code&gt;WHERE&lt;/code&gt; 条件と更新式に表示できます。これは、 &lt;code&gt;SELECT&lt;/code&gt; ステートメントの&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 句&lt;/a&gt;で指定できるテーブルのリストに似ています。自己結合を意図している場合を除いて、ターゲットテーブルは &lt;code&gt;from_list&lt;/code&gt; に表示しないでください（この場合、 &lt;code&gt;from_list&lt;/code&gt; にエイリアスを付けて表示する必要があります）。</target>
        </trans-unit>
        <trans-unit id="a5ec616bf7215f2b568c6fa91ae40cb63c46d2ff" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table in the &lt;code&gt;using_list&lt;/code&gt;, unless you wish to set up a self-join.</source>
          <target state="translated">テーブル式のリスト。他のテーブルの列を &lt;code&gt;WHERE&lt;/code&gt; 条件に表示できます。これは、 &lt;code&gt;SELECT&lt;/code&gt; ステートメントの&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 句&lt;/a&gt;で指定できるテーブルのリストに似ています。たとえば、テーブル名のエイリアスを指定できます。自己結合を設定する場合を除き、 &lt;code&gt;using_list&lt;/code&gt; でターゲットテーブルを繰り返さないでください。</target>
        </trans-unit>
        <trans-unit id="4a9f5b6a7fa98f13d9b0649d9b104ce5e824c915" translate="yes" xml:space="preserve">
          <source>A list of the base frequencies of the most common combinations, i.e., product of per-value frequencies. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最も一般的な組み合わせの基本周波数のリスト、つまり、値ごとの周波数の積。（ &lt;code&gt;most_common_vals&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="c0a9903e8f4ef251af0eff5fa2455e175a7548a4" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common combinations, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最も一般的な組み合わせの頻度のリスト、つまり、それぞれの出現回数を行の総数で割ったもの。（ &lt;code&gt;most_common_vals&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="527238c1ce219277abbb45386e199364181b4e39" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common element values, i.e., the fraction of rows containing at least one instance of the given value. Two or three additional values follow the per-element frequencies; these are the minimum and maximum of the preceding per-element frequencies, and optionally the frequency of null elements. (Null when &lt;code&gt;most_common_elems&lt;/code&gt; is.)</source>
          <target state="translated">最も一般的な要素値の頻度のリスト、つまり、指定された値の少なくとも1つのインスタンスを含む行の割合。2つまたは3つの追加の値が要素ごとの頻度に従います。これらは、前述の要素ごとの頻度の最小値と最大値であり、オプションでnull要素の頻度です。（ &lt;code&gt;most_common_elems&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="6973fe18397e6786beffdd562ca0c447ef38be82" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common values, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最も一般的な値の頻度のリスト、つまり、それぞれの出現回数を行の総数で割ったもの。（ &lt;code&gt;most_common_vals&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="f63bcd58b43a4c5b783b6642ba5709e3ccbcb180" translate="yes" xml:space="preserve">
          <source>A list of the most common combinations of values in the columns. (Null if no combinations seem to be more common than any others.)</source>
          <target state="translated">列内の値の最も一般的な組み合わせのリスト。(他のどの組み合わせよりも一般的な組み合わせがない場合はNULL)。</target>
        </trans-unit>
        <trans-unit id="7e7a21f80a86cbb3d663d9a6c19c5698cb32c935" translate="yes" xml:space="preserve">
          <source>A list of the most common values in the column. (Null if no values seem to be more common than any others.)</source>
          <target state="translated">列の中で最も一般的な値のリスト。(他のどの値よりも一般的な値がない場合はNULL)。</target>
        </trans-unit>
        <trans-unit id="f5ec309be4a2c82919d5db6bbf83466f9afb0124" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g. &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="translated">トリガーが起動する、関連する &lt;code&gt;filter_variable&lt;/code&gt; の値のリスト。以下のために &lt;code&gt;TAG&lt;/code&gt; 、これはコマンドタグのリスト（例えば意味 &lt;code&gt;'DROP FUNCTION'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6e4fe90764276ed140f41c638b69ba17b32d691f" translate="yes" xml:space="preserve">
          <source>A list of values that divide the column's values into groups of approximately equal population. The values in &lt;code&gt;most_common_vals&lt;/code&gt;, if present, are omitted from this histogram calculation. (This column is null if the column data type does not have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator or if the &lt;code&gt;most_common_vals&lt;/code&gt; list accounts for the entire population.)</source>
          <target state="translated">列の値をほぼ等しい母集団のグループに分割する値のリスト。 &lt;code&gt;most_common_vals&lt;/code&gt; の値は、存在する場合、このヒストグラム計算から省略されます。（列のデータ型に &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子がない場合、または &lt;code&gt;most_common_vals&lt;/code&gt; リストが母集団全体を占める場合、この列はnullです。）</target>
        </trans-unit>
        <trans-unit id="a40d49086dbccf43760fcf28e8592fb7682d6120" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (empty on Windows), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="translated">現在のポストマスタープロセスID（PID）、クラスターデータディレクトリパス、ポストマスター開始タイムスタンプ、ポート番号、Unixドメインソケットディレクトリパス（Windowsでは空）、最初の有効なlisten_address（IPアドレスまたは &lt;code&gt;*&lt;/code&gt; 、または空でない場合は空）を記録するロックファイルTCPでリッスン）、および共有メモリセグメントID（このファイルはサーバーのシャットダウン後は存在しません）</target>
        </trans-unit>
        <trans-unit id="66a4816dba1f7f218c3433fca4faabe3c13b10b2" translate="yes" xml:space="preserve">
          <source>A logical replication subscription can be a standby for synchronous replication (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;). The standby name is by default the subscription name. An alternative name can be specified as &lt;code&gt;application_name&lt;/code&gt; in the connection information of the subscription.</source>
          <target state="translated">論理レプリケーションサブスクリプションは、同期レプリケーションのスタンバイになることができます（&lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;セクション26.2.8を&lt;/a&gt;参照）。スタンバイ名は、デフォルトではサブスクリプション名です。サブスクリプションの接続情報で &lt;code&gt;application_name&lt;/code&gt; として代替名を指定できます。</target>
        </trans-unit>
        <trans-unit id="fcc633543c398580321199fbfe8326677176cedc" translate="yes" xml:space="preserve">
          <source>A logical replication worker will be started to replicate data for the new subscription at the commit of the transaction where this command is run.</source>
          <target state="translated">論理レプリケーションワーカーは、このコマンドが実行されるトランザクションのコミット時に、新しいサブスクリプションのデータをレプリケートするために開始されます。</target>
        </trans-unit>
        <trans-unit id="60aa88a1c8ef8747220ad187c41c4e1174fc8b76" translate="yes" xml:space="preserve">
          <source>A master-standby replication setup sends all data modification queries to the master server. The master server asynchronously sends data changes to the standby server. The standby can answer read-only queries while the master server is running. The standby server is ideal for data warehouse queries.</source>
          <target state="translated">マスターとスタンバイのレプリケーション設定では、すべてのデータ変更クエリをマスターサーバーに送信します。マスターサーバーは、非同期的にデータ変更をスタンバイサーバーに送信します。スタンバイサーバーは、マスターサーバーが実行されている間、読み取り専用のクエリに応答することができます。スタンバイサーバーは、データウェアハウスのクエリに最適です。</target>
        </trans-unit>
        <trans-unit id="df6419859ed47f78b720bf1d7b110d267f1953f4" translate="yes" xml:space="preserve">
          <source>A message like:</source>
          <target state="translated">みたいなメッセージ。</target>
        </trans-unit>
        <trans-unit id="f0390b8c07f298b04ffb62c09de627ab67ceed13" translate="yes" xml:space="preserve">
          <source>A modified version of shared hardware functionality is file system replication, where all changes to a file system are mirrored to a file system residing on another computer. The only restriction is that the mirroring must be done in a way that ensures the standby server has a consistent copy of the file system &amp;mdash; specifically, writes to the standby must be done in the same order as those on the master. DRBD is a popular file system replication solution for Linux.</source>
          <target state="translated">共有ハードウェア機能の変更されたバージョンはファイルシステムレプリケーションです。ファイルシステムへのすべての変更は、別のコンピューター上にあるファイルシステムにミラーリングされます。唯一の制限は、スタンバイサーバーがファイルシステムの一貫したコピーを保持できるようにミラーリングを実行する必要があることです。具体的には、スタンバイへの書き込みは、マスター上の書き込みと同じ順序で実行する必要があります。DRBDは、Linux向けの一般的なファイルシステムレプリケーションソリューションです。</target>
        </trans-unit>
        <trans-unit id="eaf74e8b7bd2011db8b23c31e08c4d8c5dc7b496" translate="yes" xml:space="preserve">
          <source>A more complete example, which is directly useful for most European languages, can be found in &lt;code&gt;unaccent.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; when the &lt;code&gt;unaccent&lt;/code&gt; module is installed. This rules file translates characters with accents to the same characters without accents, and it also expands ligatures into the equivalent series of simple characters (for example, &amp;AElig; to AE).</source>
          <target state="translated">ほとんどのヨーロッパ言語の直接役立つ、より完全な例は、で見つけることができ &lt;code&gt;unaccent.rules&lt;/code&gt; にインストールされ、 &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; &lt;code&gt;unaccent&lt;/code&gt; モジュールがインストールされています。このルールファイルは、アクセントのある文字をアクセントのない同じ文字に変換し、合字を同等の一連の単純な文字（&amp;AElig;からAEなど）に拡張します。</target>
        </trans-unit>
        <trans-unit id="e62513d51117a7629a102ebbc4e62bd57c604e14" translate="yes" xml:space="preserve">
          <source>A more complex example is to select the ten most recent documents that contain &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;table&lt;/code&gt; in the &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt;:</source>
          <target state="translated">より複雑な例は、 &lt;code&gt;title&lt;/code&gt; または &lt;code&gt;body&lt;/code&gt; &lt;code&gt;create&lt;/code&gt; および &lt;code&gt;table&lt;/code&gt; を含む最新の10個のドキュメントを選択することです。</target>
        </trans-unit>
        <trans-unit id="a65faa0d2e1360aa9fc34743f49ee685ce803abe" translate="yes" xml:space="preserve">
          <source>A more complex view that does not satisfy all these conditions is read-only by default: the system will not allow an insert, update, or delete on the view. You can get the effect of an updatable view by creating &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers on the view, which must convert attempted inserts, etc. on the view into appropriate actions on other tables. For more information see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;. Another possibility is to create rules (see &lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt;), but in practice triggers are easier to understand and use correctly.</source>
          <target state="translated">これらの条件をすべて満たさないより複雑なビューは、デフォルトでは読み取り専用です。システムは、ビューの挿入、更新、または削除を許可しません。ビューで &lt;code&gt;INSTEAD OF&lt;/code&gt; トリガーを作成することにより、更新可能なビューの効果を得ることができます。これにより、ビューで試行された挿入などを他のテーブルでの適切なアクションに変換する必要があります。詳細については、「&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;」を参照してください。もう1つの可能性は、ルールを作成することです（&lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULEを&lt;/a&gt;参照）が、実際にはトリガーの方が理解しやすく、正しく使用できます。</target>
        </trans-unit>
        <trans-unit id="21c69ec8617bd0a23e27b4a22f876578e2ac2724" translate="yes" xml:space="preserve">
          <source>A multicharacter operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">名前に次の文字の少なくとも1つが含まれていない限り、複数文字の演算子名の末尾を &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; にすることはできません。</target>
        </trans-unit>
        <trans-unit id="763ddc64feb8cdfed8680a02b945f082cacaa6b2" translate="yes" xml:space="preserve">
          <source>A multicolumn B-tree index can be used with query conditions that involve any subset of the index's columns, but the index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned. Constraints on columns to the right of these columns are checked in the index, so they save visits to the table proper, but they do not reduce the portion of the index that has to be scanned. For example, given an index on &lt;code&gt;(a, b, c)&lt;/code&gt; and a query condition &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt;, the index would have to be scanned from the first entry with &lt;code&gt;a&lt;/code&gt; = 5 and &lt;code&gt;b&lt;/code&gt; = 42 up through the last entry with &lt;code&gt;a&lt;/code&gt; = 5. Index entries with &lt;code&gt;c&lt;/code&gt; &amp;gt;= 77 would be skipped, but they'd still have to be scanned through. This index could in principle be used for queries that have constraints on &lt;code&gt;b&lt;/code&gt; and/or &lt;code&gt;c&lt;/code&gt; with no constraint on &lt;code&gt;a&lt;/code&gt; &amp;mdash; but the entire index would have to be scanned, so in most cases the planner would prefer a sequential table scan over using the index.</source>
          <target state="translated">複数列のBツリーインデックスは、インデックスの列のサブセットを含むクエリ条件で使用できますが、先頭（左端）の列に制約がある場合に最も効率的です。正確なルールは、先行列の等価制約と、等価制約のない最初の列の不等制約を使用して、スキャンされるインデックスの部分を制限することです。これらの列の右側の列の制約はインデックスでチェックされるため、テーブルへの訪問を適切に保存できますが、スキャンする必要のあるインデックスの部分は削減されません。例えば、上のインデックス指定された &lt;code&gt;(a, b, c)&lt;/code&gt; と検索条件 &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt; 、インデックスが持つ最初のエントリから走査されなければならない &lt;code&gt;a&lt;/code&gt; = 5と &lt;code&gt;b&lt;/code&gt; との最後のエントリを通じて= 42までと= 5インデックスエントリ &lt;code&gt;c&lt;/code&gt; &amp;gt; = 77はスキップされますが、彼らはまだを通じてスキャンする必要があるだろう。このインデックスは、原理的には上の制約が持っているクエリに使用することができ &lt;code&gt;b&lt;/code&gt; および/または &lt;code&gt;c&lt;/code&gt; 上の制約なしで-しかし、インデックス全体をスキャンする必要がありますので、ほとんどの場合、プランナはインデックスを使用しての上に、順次テーブルスキャンを好むだろう。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc5434281e629991ee555ca6201f316515a8d25" translate="yes" xml:space="preserve">
          <source>A multicolumn BRIN index can be used with query conditions that involve any subset of the index's columns. Like GIN and unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use. The only reason to have multiple BRIN indexes instead of one multicolumn BRIN index on a single table is to have a different &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter.</source>
          <target state="translated">マルチカラムBRINインデックスは、インデックスのカラムのサブセットを含むクエリ条件で使用できます。GINと同様に、BツリーやGiSTとは異なり、クエリ条件が使用するインデックス列に関係なく、インデックス検索の効果は同じです。単一のテーブルに1つのマルチカラムBRINインデックスではなく複数のBRINインデックスを設定する唯一の理由は、異なる &lt;code&gt;pages_per_range&lt;/code&gt; ストレージパラメータを設定することです。</target>
        </trans-unit>
        <trans-unit id="04d3a962116670f39174cfb6d475fa11fdc7b880" translate="yes" xml:space="preserve">
          <source>A multicolumn GIN index can be used with query conditions that involve any subset of the index's columns. Unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use.</source>
          <target state="translated">マルチカラムGINインデックスは、インデックスのカラムの任意のサブセットを含むクエリ条件で使用することができます。B-treeやGiSTとは異なり、クエリ条件がどのインデックス列を使用するかに関わらず、インデックス検索の有効性は同じです。</target>
        </trans-unit>
        <trans-unit id="a40f443a6350a7a3a7b742a42955a0061cf6840b" translate="yes" xml:space="preserve">
          <source>A multicolumn GiST index can be used with query conditions that involve any subset of the index's columns. Conditions on additional columns restrict the entries returned by the index, but the condition on the first column is the most important one for determining how much of the index needs to be scanned. A GiST index will be relatively ineffective if its first column has only a few distinct values, even if there are many distinct values in additional columns.</source>
          <target state="translated">複数列のGiSTインデックスは、インデックスの列の任意のサブセットを含む問い合わせ条件で使用することができます。追加の列に対する条件は、インデックスが返すエントリを制限しますが、最初の列に対する条件は、インデックスのスキャンの必要性を決定する上で最も重要なものです。GiSTインデックスは、追加の列に多くの異なる値があったとしても、最初の列が少数の異なる値しか持っていない場合には、相対的に効果がありません。</target>
        </trans-unit>
        <trans-unit id="61e3a968ac084ffcdbf2ee57ee023225a4c61ed4" translate="yes" xml:space="preserve">
          <source>A multiple-character operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">複数文字の演算子名の最後に &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; を付けることはできません。ただし、名前に次の文字が少なくとも1つ含まれている場合を除きます。</target>
        </trans-unit>
        <trans-unit id="c34267e8f8081ad131049e90185ef07a4a593a2c" translate="yes" xml:space="preserve">
          <source>A name (without schema qualification) must be specified for each &lt;code&gt;WITH&lt;/code&gt; query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; クエリごとに名前（スキーマ修飾なし）を指定する必要があります。オプションで、列名のリストを指定できます。これを省略した場合、列名はサブクエリから推定されます。</target>
        </trans-unit>
        <trans-unit id="6bf463ff31beb31d0372f0b1e73503dfa89eeca4" translate="yes" xml:space="preserve">
          <source>A name to use for a returned column.</source>
          <target state="translated">返されたカラムに使用する名前。</target>
        </trans-unit>
        <trans-unit id="c05611b43715c57dcc82e9a73dc2d7f3d8e3a806" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions. See &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; and its notes for details.</source>
          <target state="translated">名前付き変数。その値は、いくつかのJSON処理関数のパラメーター&lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt;によって設定できます。詳細については、&lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;表9.47&lt;/a&gt;とその注記を参照してください。</target>
        </trans-unit>
        <trans-unit id="a91a5ad7df4feb45e2e64cef1252fbd5ff25b557" translate="yes" xml:space="preserve">
          <source>A new database object basically inherits the security label of the parent object, except when the security policy has special rules known as type-transition rules, in which case a different label may be applied. For schemas, the parent object is the current database; for tables, sequences, views, and functions, it is the containing schema; for columns, it is the containing table.</source>
          <target state="translated">新しいデータベースオブジェクトは基本的に親オブジェクトのセキュリティラベルを継承しますが、セキュリティポリシーにタイプ遷移ルールとして知られる特別なルールがある場合は別のラベルが適用されることがあります。スキーマの場合、親オブジェクトは現在のデータベースであり、テーブル、シーケンス、ビュー、関数の場合、それは含まれるスキーマであり、カラムの場合、それは含まれるテーブルです。</target>
        </trans-unit>
        <trans-unit id="a69d7af9d66bab695fb9262e5704599a7bd6821d" translate="yes" xml:space="preserve">
          <source>A new heap entry is made before making its index entries. (Therefore a concurrent index scan is likely to fail to see the heap entry. This is okay because the index reader would be uninterested in an uncommitted row anyway. But see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt;.)</source>
          <target state="translated">インデックスエントリを作成する前に、新しいヒープエントリが作成されます。（したがって、同時インデックススキャンではヒープエントリの確認に失敗する可能性があります。いずれにしても、インデックスリーダーがコミットされていない行に関心がないため、これは問題ありません。ただし、&lt;a href=&quot;index-unique-checks&quot;&gt;セクション61.5を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="e9bfb94dcc9a12b2e365d8f54e18e6c8a60beb96" translate="yes" xml:space="preserve">
          <source>A new random session key is generated.</source>
          <target state="translated">新しいランダムセッションキーが生成されます。</target>
        </trans-unit>
        <trans-unit id="cd5509bd2e57840414a4b31d4dcfe1a53cd60297" translate="yes" xml:space="preserve">
          <source>A new temporary index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="translated">新しい一時インデックス定義がカタログ &lt;code&gt;pg_index&lt;/code&gt; に追加されます。この定義は、古いインデックスを置き換えるために使用されます。A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; のセッション・レベルでのロックが処理中に任意のスキーマの変更を防止するだけでなく、としてそれらに関連するテーブルを索引が再作成されたインデックスに取り込まれます。</target>
        </trans-unit>
        <trans-unit id="10ddb11c7f41b9fc173a0daee9b22a0046a88a72" translate="yes" xml:space="preserve">
          <source>A non-XML result assigned to an &lt;code&gt;xml&lt;/code&gt; output column produces content, a single text node with the string value of the result. An XML result assigned to a column of any other type may not have more than one node, or an error is raised. If there is exactly one node, the column will be set as if by assigning the node's string value (as defined for the XPath 1.0 &lt;code&gt;string&lt;/code&gt; function) to the PostgreSQL type.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 出力列に割り当てられた非XML結果は、結果の文字列値を持つ単一のテキストノードであるコンテンツを生成します。他のタイプの列に割り当てられたXML結果は、複数のノードを持つことができないか、エラーが発生します。ノードが1つしかない場合、列は、ノードの文字列値（XPath 1.0 &lt;code&gt;string&lt;/code&gt; 関数で定義されている）をPostgreSQLタイプに割り当てるかのように設定されます。</target>
        </trans-unit>
        <trans-unit id="473219c281a2d874786237c92b0fcf8169682ead" translate="yes" xml:space="preserve">
          <source>A non-exclusive low level backup is one that allows other concurrent backups to be running (both those started using the same backup API and those started using &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;).</source>
          <target state="translated">非排他的な低レベルのバックアップは、他の同時バックアップの実行を許可するものです（同じバックアップAPIを使用して開始されたものと&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;を使用して開始されたものの両方）。</target>
        </trans-unit>
        <trans-unit id="401550561965c2499f16ad6fd4b31c047d5f304a" translate="yes" xml:space="preserve">
          <source>A normal relationship between separately-created objects. The dependent object can be dropped without affecting the referenced object. The referenced object can only be dropped by specifying &lt;code&gt;CASCADE&lt;/code&gt;, in which case the dependent object is dropped, too. Example: a table column has a normal dependency on its data type.</source>
          <target state="translated">個別に作成されたオブジェクト間の通常の関係。依存オブジェクトは、参照されるオブジェクトに影響を与えることなく削除できます。参照されるオブジェクトは、 &lt;code&gt;CASCADE&lt;/code&gt; を指定することによってのみドロップできます。この場合、依存オブジェクトもドロップされます。例：テーブルの列は、そのデータ型に通常依存しています。</target>
        </trans-unit>
        <trans-unit id="f4e6fa0c13024f923c36983ca255cb802f2a15dc" translate="yes" xml:space="preserve">
          <source>A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt;, but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way.</source>
          <target state="translated">null以外の制約は、常に列制約として記述されます。非null制約は機能的にはチェック制約 &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt; を作成することと同等ですが、PostgreSQLでは明示的な非null制約を作成する方が効率的です。欠点は、この方法で作成されたnull以外の制約に明示的な名前を付けることができないことです。</target>
        </trans-unit>
        <trans-unit id="29e3f0f63dd403df874ec2bd2e2e99cfcbefc40b" translate="yes" xml:space="preserve">
          <source>A not-null constraint simply specifies that a column must not assume the null value. A syntax example:</source>
          <target state="translated">not-null 制約は、列が NULL 値を想定してはならないことを単純に指定します。構文の例。</target>
        </trans-unit>
        <trans-unit id="38f215d8dff9a872adcc025cd248723a7de60a09" translate="yes" xml:space="preserve">
          <source>A number of probes or trace points are already inserted into the source code. These probes are intended to be used by database developers and administrators. By default the probes are not compiled into PostgreSQL; the user needs to explicitly tell the configure script to make the probes available.</source>
          <target state="translated">多くのプローブやトレースポイントがすでにソースコードに挿入されています。これらのプローブは、データベース開発者や管理者が使用することを意図しています。デフォルトでは、プローブはPostgreSQLにコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="62bf9b2e29dd2eab9640de99e0e28efaa651fde7" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.28&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.29&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="translated">&lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;表27.28に&lt;/a&gt;示すように、ソースコードにはいくつかの標準プローブが用意されています。&lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;表27.29&lt;/a&gt;は、プローブで使用されるタイプを示しています。PostgreSQLの可観測性を強化するために、さらに多くのプローブを追加できます。</target>
        </trans-unit>
        <trans-unit id="83f77be94ef3c8feb2e598e753ef0750ef27c239" translate="yes" xml:space="preserve">
          <source>A number of these variables are treated specially by psql. They represent certain option settings that can be changed at run time by altering the value of the variable, or in some cases represent changeable state of psql. By convention, all specially treated variables' names consist of all upper-case ASCII letters (and possibly digits and underscores). To ensure maximum compatibility in the future, avoid using such variable names for your own purposes.</source>
          <target state="translated">これらの変数の多くはpsqlによって特別に扱われます。これらは、実行時に変数の値を変更することで変更できる特定のオプション設定を表しています。規約では、特別に扱われる変数の名前はすべて大文字のASCII文字(場合によっては数字とアンダースコア)で構成されています。将来的に最大限の互換性を確保するために、そのような変数名の使用は避けてください。</target>
        </trans-unit>
        <trans-unit id="9671dc450d1031cf1ea5da7434a9e12abf1e8725" translate="yes" xml:space="preserve">
          <source>A numeric constant that contains neither a decimal point nor an exponent is initially presumed to be type &lt;code&gt;integer&lt;/code&gt; if its value fits in type &lt;code&gt;integer&lt;/code&gt; (32 bits); otherwise it is presumed to be type &lt;code&gt;bigint&lt;/code&gt; if its value fits in type &lt;code&gt;bigint&lt;/code&gt; (64 bits); otherwise it is taken to be type &lt;code&gt;numeric&lt;/code&gt;. Constants that contain decimal points and/or exponents are always initially presumed to be type &lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="translated">小数点も指数も含まない数値定数は、その値が &lt;code&gt;integer&lt;/code&gt; 型（32ビット）に収まる場合、最初は &lt;code&gt;integer&lt;/code&gt; 型であると見なされます。そうでない場合は、タイプであると推定される &lt;code&gt;bigint&lt;/code&gt; 型で、その値収まる場合 &lt;code&gt;bigint&lt;/code&gt; （64ビット）。それ以外の場合は、 &lt;code&gt;numeric&lt;/code&gt; 型と見なされます。小数点または指数、あるいはその両方を含む定数は、常に最初は &lt;code&gt;numeric&lt;/code&gt; 型であると見なされます。</target>
        </trans-unit>
        <trans-unit id="28053ae7864d70a55d085c051398ee367a8ba696" translate="yes" xml:space="preserve">
          <source>A numeric constant that specifies the length in bytes of the new type's internal representation. The default assumption is that it is variable-length.</source>
          <target state="translated">新しい型の内部表現の長さをバイト単位で指定する数値定数。デフォルトでは可変長であることが前提となっています。</target>
        </trans-unit>
        <trans-unit id="458377c420bfcead4a575e16d3cb5a525edf744e" translate="yes" xml:space="preserve">
          <source>A one-dimensional interval starting at &lt;code&gt;x&lt;/code&gt; and ending at &lt;code&gt;y&lt;/code&gt; or vice versa; the order does not matter</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; で始まり &lt;code&gt;y&lt;/code&gt; で終わる、またはその逆の1次元の間隔。順序は関係ありません</target>
        </trans-unit>
        <trans-unit id="258b20d113a4ac0002010f6811f02c8de89d74bf" translate="yes" xml:space="preserve">
          <source>A one-dimensional point (or, zero-length one-dimensional interval)</source>
          <target state="translated">一次元点(または、ゼロ長一次元区間</target>
        </trans-unit>
        <trans-unit id="bc1071526f0987dbc584cef038787a5b04285bb1" translate="yes" xml:space="preserve">
          <source>A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">&lt;code&gt;get_raw_page&lt;/code&gt; で取得したページ画像を引数として渡す必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="5d8915a6b0933e1f5dc0f9cee0ae40fe953639a8" translate="yes" xml:space="preserve">
          <source>A parent table cannot be dropped while any of its children remain. Neither can columns or check constraints of child tables be dropped or altered if they are inherited from any parent tables. If you wish to remove a table and all of its descendants, one easy way is to drop the parent table with the &lt;code&gt;CASCADE&lt;/code&gt; option (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">親テーブルは、子が残っている間は削除できません。子テーブルの列やチェック制約は、親テーブルから継承されている場合は削除または変更できません。テーブルとそのすべての子孫を削除したい場合、簡単な方法の1つは &lt;code&gt;CASCADE&lt;/code&gt; オプションを使用して親テーブルを削除することです（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b87d25eb2f25d2d484b24b9f4a15020854de03d4" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this foreign table.</source>
          <target state="translated">この外部テーブルとの関連付けまたは関連付けを解除する親テーブル。</target>
        </trans-unit>
        <trans-unit id="9038188b4e1e4e207e5656bab49c0b4bbe2840fb" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this table.</source>
          <target state="translated">このテーブルとの関連付けや関連付けを解除する親テーブル。</target>
        </trans-unit>
        <trans-unit id="bef9303e674e1152b39759a3ac4a051765f051a5" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition.</source>
          <target state="translated">パーティションには、それが属するパーティションテーブルと同じ列名と型が必要です。パーティションテーブルの列名またはタイプを変更すると、すべてのパーティションに自動的に反映されます。 &lt;code&gt;CHECK&lt;/code&gt; 制約はすべてのパーティションに自動的に継承されますが、個々のパーティションで追加の &lt;code&gt;CHECK&lt;/code&gt; 制約を指定できます。親と同じ名前と条件を持つ追加の制約は、親制約とマージされます。デフォルトは、パーティションごとに個別に指定できます。</target>
        </trans-unit>
        <trans-unit id="2265efb683514f071f0b16aed28cd3bcc5853f6a" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached is marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="translated">使用してパーティション &lt;code&gt;FOR VALUES&lt;/code&gt; のために同じ構文を使用します。 &lt;code&gt;partition_bound_spec&lt;/code&gt; を通り&lt;a href=&quot;sql-createtable&quot;&gt;、CREATE TABLE&lt;/a&gt;。パーティションバインド仕様は、ターゲットテーブルのパーティション戦略とパーティションキーに対応している必要があります。アタッチされるテーブルには、ターゲットテーブルと同じ列がすべて含まれている必要があります。さらに、列タイプも一致する必要があります。また、ターゲットテーブルのすべての &lt;code&gt;NOT NULL&lt;/code&gt; および &lt;code&gt;CHECK&lt;/code&gt; 制約が必要です。現在、 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 制約は考慮されていません。親テーブルの &lt;code&gt;UNIQUE&lt;/code&gt; および &lt;code&gt;PRIMARY KEY&lt;/code&gt; 制約がまだ存在しない場合は、それらがパーティションに作成されます。 &lt;code&gt;CHECK&lt;/code&gt; いずれかアタッチされるテーブルの制約が &lt;code&gt;NO INHERIT&lt;/code&gt; とマークされている場合、コマンドは失敗します。そのような制約は、 &lt;code&gt;NO INHERIT&lt;/code&gt; 句なしで再作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="02bfa1f4284b2b7254a60122f0ece5c14ca3baa1" translate="yes" xml:space="preserve">
          <source>A partitioned table is divided into sub-tables (called partitions), which are created using separate &lt;code&gt;CREATE TABLE&lt;/code&gt; commands. The partitioned table is itself empty. A data row inserted into the table is routed to a partition based on the value of columns or expressions in the partition key. If no existing partition matches the values in the new row, an error will be reported.</source>
          <target state="translated">パーティションテーブルはサブテーブル（パーティションと呼ばれます）に分割されます。サブテーブルは、個別の &lt;code&gt;CREATE TABLE&lt;/code&gt; コマンドを使用して作成されます。分割テーブル自体は空です。テーブルに挿入されたデータ行は、パーティションキーの列または式の値に基づいてパーティションにルーティングされます。新しい行の値と一致する既存のパーティションがない場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="47bfb6365d874606167f5297b7825760e1b94998" translate="yes" xml:space="preserve">
          <source>A password is only significant if the client authentication method requires the user to supply a password when connecting to the database. The &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;md5&lt;/code&gt; authentication methods make use of passwords. Database passwords are separate from operating system passwords. Specify a password upon role creation with &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt;.</source>
          <target state="translated">パスワードは、クライアント認証方法でデータベースに接続するときにユーザーがパスワードを入力する必要がある場合にのみ重要です。 &lt;code&gt;password&lt;/code&gt; および &lt;code&gt;md5&lt;/code&gt; 認証方式は、パスワードを使用しています。データベースのパスワードは、オペレーティングシステムのパスワードとは別のものです。 &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt; を使用して、ロールの作成時にパスワードを指定します。</target>
        </trans-unit>
        <trans-unit id="35958631e7f174f767add77cc9815bb09387d918" translate="yes" xml:space="preserve">
          <source>A password that does not follow either of those formats is assumed to be unencrypted.</source>
          <target state="translated">これらの形式のいずれにも従わないパスワードは、暗号化されていないものとみなされます。</target>
        </trans-unit>
        <trans-unit id="ab9b8b43d3aed0e06f19d1971e9a5e5fb76320e8" translate="yes" xml:space="preserve">
          <source>A path expression can be a Boolean predicate, although the SQL/JSON standard allows predicates only in filters. This is necessary for implementation of the &lt;code&gt;@@&lt;/code&gt; operator. For example, the following &lt;code&gt;jsonpath&lt;/code&gt; expression is valid in PostgreSQL:</source>
          <target state="translated">パス式にはブール述語を使用できますが、SQL / JSON標準では述語をフィルターでのみ使用できます。これは、 &lt;code&gt;@@&lt;/code&gt; 演算子の実装に必要です。たとえば、次の &lt;code&gt;jsonpath&lt;/code&gt; 式はPostgreSQLで有効です。</target>
        </trans-unit>
        <trans-unit id="630b9b00d6c7d46f1803db83394a9ee4f3b0c93b" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of SQL/JSON items (&lt;em&gt;SQL/JSON sequence&lt;/em&gt;) is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="translated">パス式は、 &lt;code&gt;jsonpath&lt;/code&gt; データ型で許可されている一連の要素で構成されます。パス式は左から右に評価されますが、括弧を使用して操作の順序を変更できます。評価が成功すると、SQL / JSON項目の&lt;em&gt;シーケンス&lt;/em&gt;（&lt;em&gt;SQL / JSONシーケンス&lt;/em&gt;）が生成され、評価結果が、指定された計算を完了するJSONクエリ関数に返されます。</target>
        </trans-unit>
        <trans-unit id="5b906a3261066476a4e478667be529d451288613" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be the following:</source>
          <target state="translated">パス式は、パス要素のシーケンスで構成されており、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="46a75a9a8ee3f1ff5de45744e068475e9be0d81b" translate="yes" xml:space="preserve">
          <source>A pattern that contains a dot (&lt;code&gt;.&lt;/code&gt;) is interpreted as a schema name pattern followed by an object name pattern. For example, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; displays all tables whose table name includes &lt;code&gt;bar&lt;/code&gt; that are in schemas whose schema name starts with &lt;code&gt;foo&lt;/code&gt;. When no dot appears, then the pattern matches only objects that are visible in the current schema search path. Again, a dot within double quotes loses its special meaning and is matched literally.</source>
          <target state="translated">ドット（ &lt;code&gt;.&lt;/code&gt; ）を含むパターンは、スキーマ名パターンとして解釈され、その後にオブジェクト名パターンが続きます。たとえば、 &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; は、スキーマ名が &lt;code&gt;foo&lt;/code&gt; で始まるスキーマにある、テーブル名に &lt;code&gt;bar&lt;/code&gt; が含まれるすべてのテーブルを表示します。ドットが表示されない場合、パターンは現在のスキーマ検索パスに表示されているオブジェクトのみに一致します。この場合も、二重引用符内のドットはその特別な意味を失い、文字通り一致します。</target>
        </trans-unit>
        <trans-unit id="7897c4bbe5ec9cccaaddf1f6c43de7d3f2aaad08" translate="yes" xml:space="preserve">
          <source>A point in n-dimensional space, represented internally as a zero-volume cube</source>
          <target state="translated">n次元空間の点で、内部的にはゼロ体積の立方体として表されます。</target>
        </trans-unit>
        <trans-unit id="b4b7209c416eb8b0cd4ad3c6e895e2f5e59edbd1" translate="yes" xml:space="preserve">
          <source>A policy grants the permission to select, insert, update, or delete rows that match the relevant policy expression. Existing table rows are checked against the expression specified in &lt;code&gt;USING&lt;/code&gt;, while new rows that would be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; are checked against the expression specified in &lt;code&gt;WITH CHECK&lt;/code&gt;. When a &lt;code&gt;USING&lt;/code&gt; expression returns true for a given row then that row is visible to the user, while if false or null is returned then the row is not visible. When a &lt;code&gt;WITH CHECK&lt;/code&gt; expression returns true for a row then that row is inserted or updated, while if false or null is returned then an error occurs.</source>
          <target state="translated">ポリシーは、関連するポリシー式に一致する行を選択、挿入、更新、または削除する権限を付与します。既存のテーブル行は &lt;code&gt;USING&lt;/code&gt; で指定された式に対してチェックされ、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; を介して作成される新しい行は &lt;code&gt;WITH CHECK&lt;/code&gt; で指定された式に対してチェックされます。場合 &lt;code&gt;USING&lt;/code&gt; 式は次いで、所与の行に対して真を返し偽またはnullが返された場合、行が表示されていないながら行は、ユーザに表示されること。場合 &lt;code&gt;WITH CHECK&lt;/code&gt; 式が偽またはnullが返された場合、エラーが発生している間、行が挿入または更新されることをその行のために真を返します。</target>
        </trans-unit>
        <trans-unit id="f8e613dc0d26e68918f83658070562d9898412d1" translate="yes" xml:space="preserve">
          <source>A position normally indicates the source word's location in the document. Positional information can be used for &lt;em&gt;proximity ranking&lt;/em&gt;. Position values can range from 1 to 16383; larger numbers are silently set to 16383. Duplicate positions for the same lexeme are discarded.</source>
          <target state="translated">位置は通常、ドキュメント内のソースワードの場所を示します。位置情報は&lt;em&gt;近接ランキングに&lt;/em&gt;使用できます。位置の値の範囲は1〜16383です。大きな数は黙って16383に設定されます。同じ語彙素の重複した位置は破棄されます。</target>
        </trans-unit>
        <trans-unit id="8124e08cb675a3763a841977baebeafd4db084c2" translate="yes" xml:space="preserve">
          <source>A positional parameter reference is used to indicate a value that is supplied externally to an SQL statement. Parameters are used in SQL function definitions and in prepared queries. Some client libraries also support specifying data values separately from the SQL command string, in which case parameters are used to refer to the out-of-line data values. The form of a parameter reference is:</source>
          <target state="translated">位置パラメータ参照は、SQL文に外部から供給される値を示すために使用されます。パラメータはSQL関数の定義や準備されたクエリで使用されます。クライアントライブラリの中には、SQLコマンド文字列とは別にデータ値の指定をサポートしているものもあり、その場合、パラメータは行外のデータ値を参照するために使用されます。パラメータ参照の形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3833bdb7ea9a948094cad484b196a53403718838" translate="yes" xml:space="preserve">
          <source>A positional parameter reference, in the body of a function definition or prepared statement</source>
          <target state="translated">関数定義または準備された文の本文にある位置パラメータの参照</target>
        </trans-unit>
        <trans-unit id="0f115ce95e27f153df6502e75df85ece7a17f10c" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated execution cost for the function, in units of &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;. If the function returns a set, this is the cost per returned row. If the cost is not specified, 1 unit is assumed for C-language and internal functions, and 100 units for functions in all other languages. Larger values cause the planner to try to avoid evaluating the function more often than necessary.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_costの&lt;/a&gt;単位で、関数の推定実行コストを示す正の数。関数がセットを返す場合、これは返される行あたりのコストです。コストが指定されていない場合、C言語および内部関数には1ユニット、他のすべての言語の関数には100ユニットが想定されます。値が大きいと、プランナは必要以上に頻繁に関数を評価しないようにします。</target>
        </trans-unit>
        <trans-unit id="30c1a79cbb9484177e363d4544efe87e3e39ffa7" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated number of rows that the planner should expect the function to return. This is only allowed when the function is declared to return a set. The default assumption is 1000 rows.</source>
          <target state="translated">プランナがこの関数が返すと予想される行数を表す正の数値.これは、関数が集合を返すと宣言されている場合にのみ許可されます。デフォルトでは1000行を想定しています。</target>
        </trans-unit>
        <trans-unit id="02f79e462db5425b448e96c1072a3f594c31942d" translate="yes" xml:space="preserve">
          <source>A possible query to use this index would be:</source>
          <target state="translated">このインデックスを使用する可能性のあるクエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a46068a086ffe6678122c2b4a804a11dab670aaa" translate="yes" xml:space="preserve">
          <source>A prepared statement can be executed with either a &lt;em&gt;generic plan&lt;/em&gt; or a &lt;em&gt;custom plan&lt;/em&gt;. A generic plan is the same across all executions, while a custom plan is generated for a specific execution using the parameter values given in that call. Use of a generic plan avoids planning overhead, but in some situations a custom plan will be much more efficient to execute because the planner can make use of knowledge of the parameter values. (Of course, if the prepared statement has no parameters, then this is moot and a generic plan is always used.)</source>
          <target state="translated">準備済みステートメントは、&lt;em&gt;汎用プラン&lt;/em&gt;または&lt;em&gt;カスタムプラン&lt;/em&gt;で実行できます。汎用プランはすべての実行で同じですが、カスタムプランは、その呼び出しで指定されたパラメーター値を使用して特定の実行に対して生成されます。一般的な計画を使用すると、計画のオーバーヘッドを回避できますが、状況によっては、プランナがパラメータ値の知識を利用できるため、カスタム計画を実行する方がはるかに効率的です。（もちろん、準備されたステートメントにパラメーターがない場合、これは無意味であり、一般的な計画が常に使用されます。）</target>
        </trans-unit>
        <trans-unit id="13348ea1ec457fbeed4d2620cc50c2e7f85fa0ae" translate="yes" xml:space="preserve">
          <source>A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data:</source>
          <target state="translated">主キー制約は、テーブル内の行の一意の識別子として、ある列または列のグループを使用できることを示します。これは、値が一意であり、NULLではないことを要求します。したがって、以下の2つのテーブル定義は、同じデータを受け入れます。</target>
        </trans-unit>
        <trans-unit id="3f893762c520af1aa49b543485b038d4cb74971c" translate="yes" xml:space="preserve">
          <source>A procedural language call handler is declared to return &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">手続き型言語呼び出しハンドラは、 &lt;code&gt;language_handler&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="b598946555659e8de8862e7df2ae169d900a0d4a" translate="yes" xml:space="preserve">
          <source>A publication can only be dropped by its owner or a superuser.</source>
          <target state="translated">出版物は、その所有者またはスーパーユーザによってのみ削除することができます。</target>
        </trans-unit>
        <trans-unit id="ba53206c029e2edfae51f727e267685bcdf05085" translate="yes" xml:space="preserve">
          <source>A publication is created using the &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; command and may later be altered or dropped using corresponding commands.</source>
          <target state="translated">&lt;a href=&quot;sql-createpublication&quot;&gt;パブリケーション&lt;/a&gt;はCREATE PUBLICATIONコマンドを使用して作成され、後で対応するコマンドを使用して変更または削除できます。</target>
        </trans-unit>
        <trans-unit id="c9ab2d1b430251390fd77666a59dc72c11f11cfe" translate="yes" xml:space="preserve">
          <source>A publication is essentially a group of tables whose data changes are intended to be replicated through logical replication. See &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt; for details about how publications fit into the logical replication setup.</source>
          <target state="translated">パブリケーションは、基本的には、データの変更が論理複製を介して複製されることを目的としたテーブルのグループです。参照&lt;a href=&quot;logical-replication-publication&quot;&gt;セクション30.1を&lt;/a&gt;出版は、論理レプリケーションのセットアップに収まる方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="e2338433bd110932bcc29150142a24f592f4dfbb" translate="yes" xml:space="preserve">
          <source>A published table must have a &amp;ldquo;replica identity&amp;rdquo; configured in order to be able to replicate &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operations, so that appropriate rows to update or delete can be identified on the subscriber side. By default, this is the primary key, if there is one. Another unique index (with certain additional requirements) can also be set to be the replica identity. If the table does not have any suitable key, then it can be set to replica identity &amp;ldquo;full&amp;rdquo;, which means the entire row becomes the key. This, however, is very inefficient and should only be used as a fallback if no other solution is possible. If a replica identity other than &amp;ldquo;full&amp;rdquo; is set on the publisher side, a replica identity comprising the same or fewer columns must also be set on the subscriber side. See &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;&lt;code&gt;REPLICA IDENTITY&lt;/code&gt;&lt;/a&gt; for details on how to set the replica identity. If a table without a replica identity is added to a publication that replicates &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations then subsequent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations will cause an error on the publisher. &lt;code&gt;INSERT&lt;/code&gt; operations can proceed regardless of any replica identity.</source>
          <target state="translated">サブスクライバー側で更新または削除する適切な行を識別できるように、公開されたテーブルには、 &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; 操作をレプリケートできるように構成された「レプリカID」が必要です。デフォルトでは、これが主キーです（存在する場合）。別の一意のインデックス（特定の追加要件がある）をレプリカIDとして設定することもできます。テーブルに適切なキーがない場合は、レプリカIDを「完全」に設定できます。つまり、行全体がキーになります。ただし、これは非常に非効率的であり、他に解決策がない場合のフォールバックとしてのみ使用してください。 「フル」以外のレプリカIDがパブリッシャー側で設定されている場合は、サブスクライバー側でも同じか少ない列で構成されるレプリカIDを設定する必要があります。見る&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt; &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; &lt;/a&gt;レプリカIDの設定方法の詳細については、 REPLICA IDENTITYを参照してください。レプリカIDのないテーブルが、 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; 操作をレプリケートするパブリケーションに追加された場合、後続の &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; 操作により、パブリッシャーでエラーが発生します。 &lt;code&gt;INSERT&lt;/code&gt; 操作は、レプリカIDに関係なく続行できます。</target>
        </trans-unit>
        <trans-unit id="0fa8cd1ec75091ae1b152072de83438ac13c7ac1" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.16&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;.</source>
          <target state="translated">定量化されたアトムは、単一の&lt;em&gt;量指定子&lt;/em&gt;が後に続く可能性のある&lt;em&gt;アトム&lt;/em&gt;です。数量詞がない場合、アトムの一致と一致します。量指定子を使用すると、アトムのいくつかの一致に一致できます。&lt;em&gt;原子&lt;/em&gt;に示す可能性のいずれかであることができる&lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;表9.16&lt;/a&gt;。可能な量指定子とその意味を&lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;表9.17に&lt;/a&gt;示します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14b90372a7f382e1ebe5fbc1067a98d78caf7059" translate="yes" xml:space="preserve">
          <source>A quantified atom with a fixed-repetition quantifier (&lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt;) has the same greediness (possibly none) as the atom itself.</source>
          <target state="translated">固定反復量指定子（ &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; または &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; ）を持つ定量化されたアトムは、アトム自体と同じ貪欲さ（おそらくなし）を持っています。</target>
        </trans-unit>
        <trans-unit id="d2086c7d3f841e613b77902ebf9e5b97e2cde610" translate="yes" xml:space="preserve">
          <source>A quantified atom with a non-greedy quantifier (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is non-greedy (prefers shortest match).</source>
          <target state="translated">非貪欲量子化器を用いて定量原子（含む &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; と &lt;code&gt;m&lt;/code&gt; はに等しい &lt;code&gt;n&lt;/code&gt; ）（最短一致を好む）非貪欲です。</target>
        </trans-unit>
        <trans-unit id="044befe289d741f6adb775e3119a52c47ef4c4c1" translate="yes" xml:space="preserve">
          <source>A quantified atom with other normal quantifiers (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is greedy (prefers longest match).</source>
          <target state="translated">（を含む他の正常な数量で定量原子 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; と &lt;code&gt;m&lt;/code&gt; はに等しい &lt;code&gt;n&lt;/code&gt; が）（最長一致を好む）貪欲です。</target>
        </trans-unit>
        <trans-unit id="b0376c8a695cc9a8414ca39502c5036b915645c0" translate="yes" xml:space="preserve">
          <source>A quantifier cannot immediately follow another quantifier, e.g., &lt;code&gt;**&lt;/code&gt; is invalid. A quantifier cannot begin an expression or subexpression or follow &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">数量詞を別の数量詞の直後に続けることはできません。たとえば、 &lt;code&gt;**&lt;/code&gt; は無効です。数量詞は、式または部分式を開始したり、 &lt;code&gt;^&lt;/code&gt; または &lt;code&gt;|&lt;/code&gt; を続けたりできません。。</target>
        </trans-unit>
        <trans-unit id="c4fb059cdfd53bb422968b17a105f57bd04f411c" translate="yes" xml:space="preserve">
          <source>A query (&lt;code&gt;SELECT&lt;/code&gt; statement) that supplies the rows to be inserted. Refer to the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; statement for a description of the syntax.</source>
          <target state="translated">挿入する行を提供するクエリ（ &lt;code&gt;SELECT&lt;/code&gt; ステートメント）。構文の説明については、&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;ステートメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f6cba9f4354114ea501407f47fa13c76eb60151c" translate="yes" xml:space="preserve">
          <source>A query can be &amp;ldquo;qualified&amp;rdquo; by adding a &lt;code&gt;WHERE&lt;/code&gt; clause that specifies which rows are wanted. The &lt;code&gt;WHERE&lt;/code&gt; clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (&lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days:</source>
          <target state="translated">必要な行を指定する &lt;code&gt;WHERE&lt;/code&gt; 句を追加することで、クエリを「修飾」できます。 &lt;code&gt;WHERE&lt;/code&gt; 句には、ブール（真理値）の発現を含み、ブール式が真である行のみが返されます。通常のブール演算子（ &lt;code&gt;AND&lt;/code&gt; 、 &lt;code&gt;OR&lt;/code&gt; 、および &lt;code&gt;NOT&lt;/code&gt; ）を修飾で使用できます。たとえば、次は雨の日のサンフランシスコの天気を取得します。</target>
        </trans-unit>
        <trans-unit id="a3f98fa3c0d12a208eadd01d5ce05b0ffde908aa" translate="yes" xml:space="preserve">
          <source>A read-only SQL transaction cannot alter non-temporary tables. This parameter controls the default read-only status of each new transaction. The default is &lt;code&gt;off&lt;/code&gt; (read/write).</source>
          <target state="translated">読み取り専用SQLトランザクションは、非一時テーブルを変更できません。このパラメータは、新しい各トランザクションのデフォルトの読み取り専用ステータスを制御します。デフォルトは &lt;code&gt;off&lt;/code&gt; （読み取り/書き込み）です。</target>
        </trans-unit>
        <trans-unit id="4a7841fe30d1103325f6249de23cba34804bfa4e" translate="yes" xml:space="preserve">
          <source>A reader should report an error if a field-count word is neither -1 nor the expected number of columns. This provides an extra check against somehow getting out of sync with the data.</source>
          <target state="translated">フィールドカウントの単語が-1でも、期待される列数でもない場合は、読者はエラーを報告しなければなりません。これは、データとの同期が取れなくなっていないかどうかをチェックするための追加チェックです。</target>
        </trans-unit>
        <trans-unit id="fddf89d1b48df3d1a7d816db398c1f9bc279cad0" translate="yes" xml:space="preserve">
          <source>A record can have one of the seven formats</source>
          <target state="translated">レコードは7つのフォーマットのうちの1つを持つことができます。</target>
        </trans-unit>
        <trans-unit id="1b600abb4523a0f2e29ac983d05c8a91aade45f9" translate="yes" xml:space="preserve">
          <source>A recursive &lt;code&gt;DROP COLUMN&lt;/code&gt; operation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; (i.e., &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt;) never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; command will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root.</source>
          <target state="translated">再帰的な &lt;code&gt;DROP COLUMN&lt;/code&gt; 操作は、子孫が他の親からその列を継承せず、列の独立した定義を持たなかった場合にのみ、子孫テーブルの列を削除します。非再帰的な &lt;code&gt;DROP COLUMN&lt;/code&gt; （つまり、 &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt; ）は、子孫の列を削除するのではなく、継承ではなく独立して定義された列としてマークします。テーブルのすべてのパーティションには、パーティション化ルートと同じ列が必要であるため、非再帰 &lt;code&gt;DROP COLUMN&lt;/code&gt; コマンドはパーティション化されたテーブルに対して失敗します。</target>
        </trans-unit>
        <trans-unit id="c8e116c04f64e1769d84da7554d28932fe4d3963" translate="yes" xml:space="preserve">
          <source>A regular expression is a character sequence that is an abbreviated definition of a set of strings (a &lt;em&gt;regular set&lt;/em&gt;). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with &lt;code&gt;LIKE&lt;/code&gt;, pattern characters match string characters exactly unless they are special characters in the regular expression language &amp;mdash; but regular expressions use different special characters than &lt;code&gt;LIKE&lt;/code&gt; does. Unlike &lt;code&gt;LIKE&lt;/code&gt; patterns, a regular expression is allowed to match anywhere within a string, unless the regular expression is explicitly anchored to the beginning or end of the string.</source>
          <target state="translated">正規表現は、一連の文字列（&lt;em&gt;正規セット&lt;/em&gt;）の省略された定義である文字シーケンスです。文字列は、正規表現で記述された正規セットのメンバーである場合、正規表現に一致すると言われます。 &lt;code&gt;LIKE&lt;/code&gt; と同様に、パターン文字は、正規表現言語の特殊文字でない限り、文字列文字と完全に一致します。ただし、正規表現は &lt;code&gt;LIKE&lt;/code&gt; とは異なる特殊文字を使用します。 &lt;code&gt;LIKE&lt;/code&gt; パターンとは異なり、正規表現は、文字列の先頭または末尾に明示的にアンカーされていない限り、文字列内のどこにでも一致できます。</target>
        </trans-unit>
        <trans-unit id="8bcf2029d3dfa5827a2882665f99b1d027b1662c" translate="yes" xml:space="preserve">
          <source>A regular expression is defined as one or more &lt;em&gt;branches&lt;/em&gt;, separated by &lt;code&gt;|&lt;/code&gt;. It matches anything that matches one of the branches.</source>
          <target state="translated">正規表現は、 &lt;code&gt;|&lt;/code&gt; で区切られた1つ以上の&lt;em&gt;ブランチ&lt;/em&gt;として定義されます。。これは、ブランチの1つに一致するすべてのものに一致します。</target>
        </trans-unit>
        <trans-unit id="6f4f1bec4e67db6d8c109c21ce30fc24feb18e6d" translate="yes" xml:space="preserve">
          <source>A rich set of functions and operators is available to perform various geometric operations such as scaling, translation, rotation, and determining intersections. They are explained in &lt;a href=&quot;functions-geometry&quot;&gt;Section 9.11&lt;/a&gt;.</source>
          <target state="translated">豊富な関数と演算子のセットを使用して、スケーリング、変換、回転、交差の決定など、さまざまな幾何学的操作を実行できます。それらは&lt;a href=&quot;functions-geometry&quot;&gt;セクション9.11で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="dd3e55f45b03c0434f66fdb4c772115d77e89a86" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="translated">また、役割には、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章で&lt;/a&gt;説明されている多くの実行時設定の役割固有のデフォルトを設定できます。たとえば、何らかの理由で接続するたびにインデックススキャンを無効にしたい場合（ヒント：良いアイデアではありません）、次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="1819e27998d44ae23e1be32dd84afd40392e29ad" translate="yes" xml:space="preserve">
          <source>A role cannot be removed if it is still referenced in any database of the cluster; an error will be raised if so. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects. The &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; and &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; commands can be useful for this purpose; see &lt;a href=&quot;role-removal&quot;&gt;Section 21.4&lt;/a&gt; for more discussion.</source>
          <target state="translated">クラスターのデータベースで参照されている役割は削除できません。その場合、エラーが発生します。ロールを削除する前に、そのオブジェクトが所有するすべてのオブジェクトを削除（またはその所有権を再割り当て）して、他のオブジェクトに対してそのロールに付与されている特権を取り消す必要があります。&lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGNはOWNED&lt;/a&gt;および&lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt;コマンドは、この目的のために有用であることができます。詳細については、&lt;a href=&quot;role-removal&quot;&gt;セクション21.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca7ed328c6182a99c2ad02ba1bf771cc523959b3" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create databases (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt;.</source>
          <target state="translated">ロールには、データベースを作成する権限が明示的に付与されている必要があります（スーパーユーザーはすべての権限チェックをバイパスするため、スーパーユーザーを除く）。このようなロールを作成するには、 &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d62d4d6cefafa0c4a7b229d226042d5cdbe21812" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create more roles (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt;. A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can alter and drop other roles, too, as well as grant or revoke membership in them. However, to create, alter, drop, or change membership of a superuser role, superuser status is required; &lt;code&gt;CREATEROLE&lt;/code&gt; is insufficient for that.</source>
          <target state="translated">ロールには、追加のロールを作成するための権限が明示的に付与されている必要があります（スーパーユーザーはすべての権限チェックをバイパスするため、スーパーユーザーを除く）。このようなロールを作成するには、 &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt; を使用します。 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、他のロールを変更および削除したり、それらのメンバーシップを付与または取り消したりすることもできます。ただし、スーパーユーザーロールのメンバーシップを作成、変更、削除、または変更するには、スーパーユーザーのステータスが必要です。そのためには &lt;code&gt;CREATEROLE&lt;/code&gt; では不十分です。</target>
        </trans-unit>
        <trans-unit id="17ba5cb05b3fc9de95da7091b339d5cf7b10fc50" translate="yes" xml:space="preserve">
          <source>A role must explicitly be given permission to initiate streaming replication (except for superusers, since those bypass all permission checks). A role used for streaming replication must have &lt;code&gt;LOGIN&lt;/code&gt; permission as well. To create such a role, use &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt;.</source>
          <target state="translated">役割には、ストリーミングレプリケーションを開始する権限が明示的に付与されている必要があります（スーパーユーザーはすべての権限チェックをバイパスするため、スーパーユーザーを除く）。ストリーミングレプリケーションに使用されるロールには、 &lt;code&gt;LOGIN&lt;/code&gt; 権限も必要です。このようなロールを作成するには、 &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="94be28bc6eb3b4ca303ced8b07cef3c876649a6d" translate="yes" xml:space="preserve">
          <source>A role's attributes can be modified after creation with &lt;code&gt;ALTER ROLE&lt;/code&gt;. See the reference pages for the &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; commands for details.</source>
          <target state="translated">ロールの属性は、作成後に &lt;code&gt;ALTER ROLE&lt;/code&gt; で変更できます。詳細は、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE &lt;/a&gt;&lt;a href=&quot;sql-alterrole&quot;&gt;ROLE&lt;/a&gt;コマンドとALTER ROLEコマンドのリファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="081acf24bd36c70b53212a425e34d472f83362f1" translate="yes" xml:space="preserve">
          <source>A row constructor</source>
          <target state="translated">行のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="22f30213b82e4ac8580d06b76fb30db617ce4ae6" translate="yes" xml:space="preserve">
          <source>A row constructor can include the syntax &lt;code&gt;rowvalue&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt;, which will be expanded to a list of the elements of the row value, just as occurs when the &lt;code&gt;.*&lt;/code&gt; syntax is used at the top level of a &lt;code&gt;SELECT&lt;/code&gt; list (see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;). For example, if table &lt;code&gt;t&lt;/code&gt; has columns &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, these are the same:</source>
          <target state="translated">行コンストラクターには、行値の要素のリストに展開される構文 &lt;code&gt;rowvalue&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 含めることができます。これは、 &lt;code&gt;.*&lt;/code&gt; 構文が &lt;code&gt;SELECT&lt;/code&gt; リストのトップレベルで使用される場合と同じです（&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;セクション8.16.5を&lt;/a&gt;参照）。）。たとえば、テーブル &lt;code&gt;t&lt;/code&gt; に列 &lt;code&gt;f1&lt;/code&gt; と &lt;code&gt;f2&lt;/code&gt; がある場合、これらは同じです。</target>
        </trans-unit>
        <trans-unit id="f65566297d0cf76754b5ffd2e69f3d748460cda5" translate="yes" xml:space="preserve">
          <source>A row constructor is an expression that builds a row value (also called a composite value) using values for its member fields. A row constructor consists of the key word &lt;code&gt;ROW&lt;/code&gt;, a left parenthesis, zero or more expressions (separated by commas) for the row field values, and finally a right parenthesis. For example:</source>
          <target state="translated">行コンストラクターは、メンバーフィールドの値を使用して行の値（複合値とも呼ばれます）を構築する式です。行コンストラクターは、キーワード &lt;code&gt;ROW&lt;/code&gt; 、左括弧、行フィールド値の（コンマで区切られた）0個以上の式、および最後に右括弧で構成されます。例えば：</target>
        </trans-unit>
        <trans-unit id="e083a9bfabe61aa93820ae695a4040f7ab7fb65b" translate="yes" xml:space="preserve">
          <source>A rule has significantly more overhead than a trigger, but the overhead is paid once per query rather than once per row, so this method might be advantageous for bulk-insert situations. In most cases, however, the trigger method will offer better performance.</source>
          <target state="translated">ルールはトリガーよりもかなり多くのオーバーヘッドを持ちますが、オーバーヘッドは行ごとではなくクエリごとに支払われるので、バルク挿入の状況ではこの方法が有利かもしれません。しかし、ほとんどの場合では、トリガ方式の方がより良いパフォーマンスを提供します。</target>
        </trans-unit>
        <trans-unit id="3a8ed465468f0b09e900dc84f22e1ad03222e742" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/members&lt;/code&gt; under the data directory, adding one, and then multiplying by 52352 (0xCC80). The file names are in hexadecimal. There is no simple recipe such as the ones for other options of appending zeroes.</source>
          <target state="translated">安全な値は、データディレクトリの下のディレクトリ &lt;code&gt;pg_multixact/members&lt;/code&gt; で数値的に最大のファイル名を探し、1を追加してから、52352（0xCC80）を乗算することによって決定できます。ファイル名は16進数です。ゼロを追加する他のオプションのような簡単なレシピはありません。</target>
        </trans-unit>
        <trans-unit id="427cc987ada87144cf5033e51fd5ca57fac98875" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_xact&lt;/code&gt; under the data directory, adding one, and then multiplying by 1048576 (0x100000). Note that the file names are in hexadecimal. It is usually easiest to specify the option value in hexadecimal too. For example, if &lt;code&gt;0011&lt;/code&gt; is the largest entry in &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;-x 0x1200000&lt;/code&gt; will work (five trailing zeroes provide the proper multiplier).</source>
          <target state="translated">安全な値は、データディレクトリの下のディレクトリ &lt;code&gt;pg_xact&lt;/code&gt; で数値的に最大のファイル名を探し、1を追加して、1048576（0x100000）を乗算することによって決定できます。ファイル名は16進数であることに注意してください。通常、オプション値も16進数で指定するのが最も簡単です。たとえば、 &lt;code&gt;0011&lt;/code&gt; が &lt;code&gt;pg_xact&lt;/code&gt; の最大のエントリである場合、 &lt;code&gt;-x 0x1200000&lt;/code&gt; が機能します（末尾の5つのゼロは適切な乗数を提供します）。</target>
        </trans-unit>
        <trans-unit id="cb05b109b960491956518dbc25a95b68a60bb5b7" translate="yes" xml:space="preserve">
          <source>A safe value for the next multitransaction ID (first part) can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/offsets&lt;/code&gt; under the data directory, adding one, and then multiplying by 65536 (0x10000). Conversely, a safe value for the oldest multitransaction ID (second part of &lt;code&gt;-m&lt;/code&gt;) can be determined by looking for the numerically smallest file name in the same directory and multiplying by 65536. The file names are in hexadecimal, so the easiest way to do this is to specify the option value in hexadecimal and append four zeroes.</source>
          <target state="translated">次のマルチ &lt;code&gt;pg_multixact/offsets&lt;/code&gt; ID（最初の部分）の安全な値は、データディレクトリの下のディレクトリpg_multixact / offsetsで数値的に最大のファイル名を探し、1を追加して、次に65536（0x10000）を掛けることによって決定できます。逆に、最も古いマルチトランザクションID（ &lt;code&gt;-m&lt;/code&gt; の 2番目の部分）の安全な値は、同じディレクトリで数値的に最小のファイル名を検索し、65536を掛けることによって決定できます。ファイル名は16進数なので、最も簡単な方法これは、オプション値を16進数で指定し、4つのゼロを追加することです。</target>
        </trans-unit>
        <trans-unit id="210bab91fc67894e59300e346dd93bb05146f64b" translate="yes" xml:space="preserve">
          <source>A safe value for the oldest transaction ID for which the commit time can be retrieved (first part) can be determined by looking for the numerically smallest file name in the directory &lt;code&gt;pg_commit_ts&lt;/code&gt; under the data directory. Conversely, a safe value for the newest transaction ID for which the commit time can be retrieved (second part) can be determined by looking for the numerically greatest file name in the same directory. The file names are in hexadecimal.</source>
          <target state="translated">コミット時間を取得できる最も古いトランザクションID（最初の部分）の安全な値は、データディレクトリの下のディレクトリ &lt;code&gt;pg_commit_ts&lt;/code&gt; で数値的に最小のファイル名を探すことによって決定できます。逆に、コミット時間を取得できる最新のトランザクションID（2番目の部分）の安全な値は、同じディレクトリで数値的に最大のファイル名を探すことによって決定できます。ファイル名は16進数です。</target>
        </trans-unit>
        <trans-unit id="8c66ea914339b5b34a8487aab28576ebc5ca45da" translate="yes" xml:space="preserve">
          <source>A savepoint is a special mark inside a transaction that allows all commands that are executed after it was established to be rolled back, restoring the transaction state to what it was at the time of the savepoint.</source>
          <target state="translated">セーブポイントは、それが確立された後に実行されたすべてのコマンドをロールバックして、セーブポイントの時点でのトランザクションの状態に戻すことを可能にする、トランザクション内の特別なマークである。</target>
        </trans-unit>
        <trans-unit id="7568eb3ea7434ae7b0d16a00f453676381b783a8" translate="yes" xml:space="preserve">
          <source>A scalar subquery</source>
          <target state="translated">スカラ副問い合わせ</target>
        </trans-unit>
        <trans-unit id="81af8f2f005c91eb2539d9bedb25765441d8772a" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="translated">スカラーサブクエリは、括弧で囲まれた通常の &lt;code&gt;SELECT&lt;/code&gt; クエリで、1つの列と1つの行だけを返します。 （クエリの記述については、&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;第7章を&lt;/a&gt;参照してください。） &lt;code&gt;SELECT&lt;/code&gt; クエリが実行され、単一の戻り値が周囲の値式で使用されます。複数の行または複数の列を返すクエリをスカラーサブクエリとして使用するとエラーになります。 （ただし、特定の実行中にサブクエリが行を返さない場合、エラーは発生しません。スカラー結果はnullであると見なされます。）サブクエリは周囲のクエリからの変数を参照できます。これは、1つの評価中に定数として機能しますサブクエリの。サブクエリに関連する他の式については、&lt;a href=&quot;functions-subquery&quot;&gt;9.22&lt;/a&gt;項も参照してください。</target>
        </trans-unit>
        <trans-unit id="22189bcf116df43b441c919d8d32eb0f9603b0c4" translate="yes" xml:space="preserve">
          <source>A scan key is the internal representation of a &lt;code&gt;WHERE&lt;/code&gt; clause of the form &lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;, where the index key is one of the columns of the index and the operator is one of the members of the operator family associated with that index column. An index scan has zero or more scan keys, which are implicitly ANDed &amp;mdash; the returned tuples are expected to satisfy all the indicated conditions.</source>
          <target state="translated">スキャンキーは、 &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; という形式の &lt;code&gt;WHERE&lt;/code&gt; 句の内部表現です。ここで、インデックスキーはインデックスの列の1つであり、演算子はそのインデックス列に関連付けられた演算子ファミリーのメンバーの1つです。インデックススキャンには、ゼロ以上のスキャンキーがあり、これらは暗黙的にAND演算されます&amp;mdash;返されるタプルは、指定されたすべての条件を満たすことが期待されます。</target>
        </trans-unit>
        <trans-unit id="f42378ba798baf455e1545f6ed59407d2afa77b9" translate="yes" xml:space="preserve">
          <source>A schema can only be dropped by its owner or a superuser. Note that the owner can drop the schema (and thereby all contained objects) even if they do not own some of the objects within the schema.</source>
          <target state="translated">スキーマを削除できるのは所有者かスーパーユーザーだけです。所有者は、スキーマ内のオブジェクトの一部を所有していなくても、スキーマ(およびそれによって含まれるすべてのオブジェクト)を削除することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d6403de1aa8d8ec1e90672c217c0a1e9ee16c135" translate="yes" xml:space="preserve">
          <source>A schema is essentially a namespace: it contains named objects (tables, data types, functions, and operators) whose names can duplicate those of other objects existing in other schemas. Named objects are accessed either by &amp;ldquo;qualifying&amp;rdquo; their names with the schema name as a prefix, or by setting a search path that includes the desired schema(s). A &lt;code&gt;CREATE&lt;/code&gt; command specifying an unqualified object name creates the object in the current schema (the one at the front of the search path, which can be determined with the function &lt;code&gt;current_schema&lt;/code&gt;).</source>
          <target state="translated">スキーマは基本的に名前空間です。名前付きオブジェクト（テーブル、データ型、関数、演算子）が含まれ、その名前は他のスキーマに存在する他のオブジェクトの名前と重複する可能性があります。名前付きオブジェクトにアクセスするには、スキーマ名を接頭辞として使用して名前を「修飾」するか、目的のスキーマを含む検索パスを設定します。 &lt;code&gt;CREATE&lt;/code&gt; 非修飾オブジェクト名を指定するコマンド（関数を用いて決定することができる検索パスの前に1つ、現在のスキーマ内のオブジェクトを作成 &lt;code&gt;current_schema&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="896efd5a8d00dc02d53497ffb75c3ac39fb5a4a6" translate="yes" xml:space="preserve">
          <source>A script file contains one or more SQL commands terminated by semicolons. Empty lines and lines beginning with &lt;code&gt;--&lt;/code&gt; are ignored. Script files can also contain &amp;ldquo;meta commands&amp;rdquo;, which are interpreted by pgbench itself, as described below.</source>
          <target state="translated">スクリプトファイルには、セミコロンで終了する1つ以上のSQLコマンドが含まれています。空行と &lt;code&gt;--&lt;/code&gt; 始まる行は無視されます。スクリプトファイルには、以下に説明するように、pgbench自体によって解釈される「メタコマンド」を含めることもできます。</target>
        </trans-unit>
        <trans-unit id="c4717af9b4226f3b00d724aebfdacf0ab19f7c65" translate="yes" xml:space="preserve">
          <source>A second database, &lt;code&gt;template1&lt;/code&gt;, is also created during database cluster initialization. Whenever a new database is created within the cluster, &lt;code&gt;template1&lt;/code&gt; is essentially cloned. This means that any changes you make in &lt;code&gt;template1&lt;/code&gt; are propagated to all subsequently created databases. Because of this, avoid creating objects in &lt;code&gt;template1&lt;/code&gt; unless you want them propagated to every newly created database. More details appear in &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">2番目のデータベース &lt;code&gt;template1&lt;/code&gt; も、データベースクラスターの初期化中に作成されます。クラスタ内に新しいデータベースが作成されるたびに、 &lt;code&gt;template1&lt;/code&gt; は基本的に複製されます。つまり、 &lt;code&gt;template1&lt;/code&gt; で行った変更は、後で作成されるすべてのデータベースに伝達されます。このため、新しく作成されたすべてのデータベースに伝達したくない場合を除き、 &lt;code&gt;template1&lt;/code&gt; でオブジェクトを作成しないでください。詳細については、&lt;a href=&quot;manage-ag-templatedbs&quot;&gt;セクション22.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c0553fb63d3a8d00dba1af17146ccb321bca9edc" translate="yes" xml:space="preserve">
          <source>A separator (a space or non-letter/non-digit character) in the template string of &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt; matches any single separator in the input string or is skipped, unless the &lt;code&gt;FX&lt;/code&gt; option is used. For example, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; work, but &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; returns an error because the number of separators in the input string exceeds the number of separators in the template.</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; のテンプレート文字列内のセパレーター（スペースまたは文字/数字以外の文字）は、 &lt;code&gt;FX&lt;/code&gt; オプションが使用されていない限り、入力文字列内の単一のセパレーターと一致するか、スキップされます。たとえば、 &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; と &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; 機能しますが、 &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; は戻ります入力文字列の区切り文字の数がテンプレートの区切り文字の数を超えているため、エラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="11592b154f9e554cd84c7343d4d02f52f502b436" translate="yes" xml:space="preserve">
          <source>A sequential scan over this large table takes a long time:</source>
          <target state="translated">この大きなテーブルの上を順次スキャンすると、長い時間がかかります。</target>
        </trans-unit>
        <trans-unit id="79af3c162f9318c384ae01ff487ce072e1768dfe" translate="yes" xml:space="preserve">
          <source>A sequential scan will always necessitate a relation-level predicate lock. This can result in an increased rate of serialization failures. It may be helpful to encourage the use of index scans by reducing &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; and/or increasing &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;. Be sure to weigh any decrease in transaction rollbacks and restarts against any overall change in query execution time.</source>
          <target state="translated">順次スキャンでは、常に関係レベルの述語ロックが必要になります。これにより、シリアル化の失敗率が高くなる可能性があります。減らすことによって、インデックス・スキャンの使用を奨励するために役立つかもしれない&lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_costをし&lt;/a&gt;、および/または増加&lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_costを&lt;/a&gt;。トランザクションのロールバックと再起動の減少と、クエリ実行時間の全体的な変化を比較検討してください。</target>
        </trans-unit>
        <trans-unit id="1bfa1c21333697528077114ccbfbc09a0f9f978f" translate="yes" xml:space="preserve">
          <source>A serious limitation of the inheritance feature is that indexes (including unique constraints) and foreign key constraints only apply to single tables, not to their inheritance children. This is true on both the referencing and referenced sides of a foreign key constraint. Thus, in the terms of the above example:</source>
          <target state="translated">継承機能の深刻な制限は、インデックス(一意制約を含む)と外部キー制約が単一のテーブルにのみ適用され、その継承子には適用されないことです。これは、外部キー制約の参照側と参照される側の両方に当てはまります。したがって、上記の例の用語では</target>
        </trans-unit>
        <trans-unit id="b2bd01559e686b7857df249c11b785bd65be39d9" translate="yes" xml:space="preserve">
          <source>A server process, which manages the database files, accepts connections to the database from client applications, and performs database actions on behalf of the clients. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">データベースファイルを管理するサーバープロセスは、クライアントアプリケーションからデータベースへの接続を受け入れ、クライアントに代わってデータベースアクションを実行します。データベースサーバープログラムは &lt;code&gt;postgres&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="eda9a27048331b66fd1707531a40ce77f3ddd8c9" translate="yes" xml:space="preserve">
          <source>A session can be unregistered for a given notification channel with the &lt;code&gt;UNLISTEN&lt;/code&gt; command. A session's listen registrations are automatically cleared when the session ends.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; コマンドを使用して、特定の通知チャネルのセッションを登録解除できます。セッションのリッスン登録は、セッションが終了すると自動的にクリアされます。</target>
        </trans-unit>
        <trans-unit id="75b584c1806aab227b279342fcda898366eb0bc1" translate="yes" xml:space="preserve">
          <source>A session will allocate temporary buffers as needed up to the limit given by &lt;code&gt;temp_buffers&lt;/code&gt;. The cost of setting a large value in sessions that do not actually need many temporary buffers is only a buffer descriptor, or about 64 bytes, per increment in &lt;code&gt;temp_buffers&lt;/code&gt;. However if a buffer is actually used an additional 8192 bytes will be consumed for it (or in general, &lt;code&gt;BLCKSZ&lt;/code&gt; bytes).</source>
          <target state="translated">セッションは、 &lt;code&gt;temp_buffers&lt;/code&gt; で指定された制限まで、必要に応じて一時バッファーを割り当てます。実際に多くの一時バッファーを必要としないセッションで大きな値を設定するコストは、 &lt;code&gt;temp_buffers&lt;/code&gt; の増分あたりのバッファー記述子、つまり約64バイトのみです。ただし、バッファが実際に使用される場合、追加の8192バイトがバッファに消費されます（または一般に、 &lt;code&gt;BLCKSZ&lt;/code&gt; バイト）。</target>
        </trans-unit>
        <trans-unit id="78d05cbafd4652352f5f70c34a9c2c9722aea37c" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions are available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="translated">SQLデータからXMLコンテンツを生成するための関数と関数に似た式のセットが用意されています。そのため、クエリ結果を XML ドキュメントにフォーマットしてクライアントアプリケーションで処理するのに特に適しています。</target>
        </trans-unit>
        <trans-unit id="675287b9d3c5bb2ab0654e84d04004c09628b2e2" translate="yes" xml:space="preserve">
          <source>A shorthand notation is provided for specifying two common types of grouping set. A clause of the form</source>
          <target state="translated">2つの一般的なタイプのグループ化集合を指定するための略記法が提供されています。形式の節</target>
        </trans-unit>
        <trans-unit id="4eb84b728058fd55ea25770f3f034fccfd80efda" translate="yes" xml:space="preserve">
          <source>A shorthand version of &lt;code&gt;get_raw_page&lt;/code&gt;, for reading from the main fork. Equivalent to &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</source>
          <target state="translated">メインフォークから読み取るための &lt;code&gt;get_raw_page&lt;/code&gt; の簡略版。同等 &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf3b68bae267e9ec8dc713868f0cc42a385b1b59" translate="yes" xml:space="preserve">
          <source>A sign formatted using &lt;code&gt;SG&lt;/code&gt;, &lt;code&gt;PL&lt;/code&gt;, or &lt;code&gt;MI&lt;/code&gt; is not anchored to the number; for example, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; produces &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; but &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; produces &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt;. (The Oracle implementation does not allow the use of &lt;code&gt;MI&lt;/code&gt; before &lt;code&gt;9&lt;/code&gt;, but rather requires that &lt;code&gt;9&lt;/code&gt; precede &lt;code&gt;MI&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;SG&lt;/code&gt; 、 &lt;code&gt;PL&lt;/code&gt; 、または &lt;code&gt;MI&lt;/code&gt; を使用してフォーマットされた符号は、番号に固定されていません。例えば、 &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; 生成する &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; が、 &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; 生成する &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt; 。（Oracle実装は、使用を許可しない &lt;code&gt;MI&lt;/code&gt; を前に &lt;code&gt;9&lt;/code&gt; ではなく、その必要が &lt;code&gt;9&lt;/code&gt; に先行 &lt;code&gt;MI&lt;/code&gt; を。）</target>
        </trans-unit>
        <trans-unit id="28f22335db260bb1a77d3874ff5a159c8ea0367a" translate="yes" xml:space="preserve">
          <source>A signature is a lossy representation of the indexed attribute(s), and as such is prone to reporting false positives; that is, it may be reported that an element is in the set, when it is not. So index search results must always be rechecked using the actual attribute values from the heap entry. Larger signatures reduce the odds of a false positive and thus reduce the number of useless heap visits, but of course also make the index larger and hence slower to scan.</source>
          <target state="translated">シグネチャは、インデックス化された属性の非可逆的な表現であり、偽陽性を報告する傾向があります;すなわち、ある要素がセットの中にあると報告されるかもしれないが、そうでない場合があります。そのため、インデックス検索結果は常にヒープエントリからの実際の属性値を使って再確認しなければなりません。シグネチャを大きくすることで誤検出の確率が下がり、無駄なヒープの訪問回数が減りますが、もちろんインデックスが大きくなり、スキャンが遅くなります。</target>
        </trans-unit>
        <trans-unit id="32035573077f021fbb97ad61e501af43e164ab91" translate="yes" xml:space="preserve">
          <source>A similar approach is used in most non-fiction books: terms and concepts that are frequently looked up by readers are collected in an alphabetic index at the end of the book. The interested reader can scan the index relatively quickly and flip to the appropriate page(s), rather than having to read the entire book to find the material of interest. Just as it is the task of the author to anticipate the items that readers are likely to look up, it is the task of the database programmer to foresee which indexes will be useful.</source>
          <target state="translated">ほとんどのノンフィクション本にも同様のアプローチが採用されています。興味のある読者は、興味のある内容を見つけるために本全体を読むのではなく、比較的素早くインデックスをスキャンして、適切なページをめくることができます。読者が調べそうな項目を予測するのが著者の仕事であるように、どのインデックスが役に立つかを予測するのがデータベースプログラマーの仕事です。</target>
        </trans-unit>
        <trans-unit id="0ce67715832ac88218d019874223da06f72da1b1" translate="yes" xml:space="preserve">
          <source>A similar command will be generated for each new file to be archived.</source>
          <target state="translated">アーカイブする新しいファイルごとに同様のコマンドが生成されます。</target>
        </trans-unit>
        <trans-unit id="3786a908833219f288eb01ce7bf3707543bec989" translate="yes" xml:space="preserve">
          <source>A similar problem occurs with estimation of the cardinality of sets of multiple columns, such as the number of groups that would be generated by a &lt;code&gt;GROUP BY&lt;/code&gt; clause. When &lt;code&gt;GROUP BY&lt;/code&gt; lists a single column, the n-distinct estimate (which is visible as the estimated number of rows returned by the HashAggregate node) is very accurate:</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; 句によって生成されるグループの数など、複数の列のセットのカーディナリティの推定でも同様の問題が発生します。 &lt;code&gt;GROUP BY&lt;/code&gt; が単一の列をリストする場合、n-distinct推定（これはHashAggregateノードによって返される推定行数として表示されます）は非常に正確です。</target>
        </trans-unit>
        <trans-unit id="5d9a6505729509f95a09312b10bc6d90c22cf17c" translate="yes" xml:space="preserve">
          <source>A similar result could be accomplished with a join:</source>
          <target state="translated">同様の結果は、結合でも達成できます。</target>
        </trans-unit>
        <trans-unit id="37fd7a4a35913776332656300b6e6e873ef35bb0" translate="yes" xml:space="preserve">
          <source>A simple GIN index on the &lt;code&gt;jdoc&lt;/code&gt; column can support this query. But note that such an index will store copies of every key and value in the &lt;code&gt;jdoc&lt;/code&gt; column, whereas the expression index of the previous example stores only data found under the &lt;code&gt;tags&lt;/code&gt; key. While the simple-index approach is far more flexible (since it supports queries about any key), targeted expression indexes are likely to be smaller and faster to search than a simple index.</source>
          <target state="translated">&lt;code&gt;jdoc&lt;/code&gt; 列の単純なGINインデックスは、このクエリをサポートできます。しかし、このようなインデックスは、内のすべてのキーと値のコピーを格納します。なお、 &lt;code&gt;jdoc&lt;/code&gt; の前の例の店の発現率は、データのみが下にあるのに対し、列を &lt;code&gt;tags&lt;/code&gt; キー。シンプルインデックスアプローチははるかに柔軟性がありますが（任意のキーに関するクエリをサポートするため）、ターゲット式インデックスは、シンプルインデックスよりも小さく、高速に検索できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1dca6bdccd192c38f7d0a54b1d6c641ecfc4dd07" translate="yes" xml:space="preserve">
          <source>A simple aggregate function is made from one or two ordinary functions: a state transition function &lt;code&gt;sfunc&lt;/code&gt;, and an optional final calculation function &lt;code&gt;ffunc&lt;/code&gt;. These are used as follows:</source>
          <target state="translated">単純な集約関数は、1つまたは2つの通常の関数（状態遷移関数 &lt;code&gt;sfunc&lt;/code&gt; 、およびオプションの最終計算関数 &lt;code&gt;ffunc&lt;/code&gt; )から作成されます。これらは次のように使用されます。</target>
        </trans-unit>
        <trans-unit id="92c5b995463bf0dd676bdb47c7d11c8b07e323eb" translate="yes" xml:space="preserve">
          <source>A simple example of configuration is:</source>
          <target state="translated">設定の簡単な例としては</target>
        </trans-unit>
        <trans-unit id="0929a1c1d2dae1cb142a133fc2a8d2f50ec36161" translate="yes" xml:space="preserve">
          <source>A simple example of these rules is</source>
          <target state="translated">これらのルールの簡単な例としては</target>
        </trans-unit>
        <trans-unit id="a7391df0d455f9692788470d09f0d785e12ddd80" translate="yes" xml:space="preserve">
          <source>A simple kind of query has the form:</source>
          <target state="translated">単純な種類のクエリには、次のような形式があります。</target>
        </trans-unit>
        <trans-unit id="e9cf93d0e888ede997ab50815543f2f23545f52a" translate="yes" xml:space="preserve">
          <source>A single index scan can only use query clauses that use the index's columns with operators of its operator class and are joined with &lt;code&gt;AND&lt;/code&gt;. For example, given an index on &lt;code&gt;(a, b)&lt;/code&gt; a query condition like &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; could use the index, but a query like &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; could not directly use the index.</source>
          <target state="translated">単一のインデックススキャンでは、演算子クラスの演算子でインデックスの列を使用し、 &lt;code&gt;AND&lt;/code&gt; で結合されているクエリ句のみを使用できます。たとえば、 &lt;code&gt;(a, b)&lt;/code&gt; インデックスが指定されている場合、 &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; ようなクエリ条件はインデックスを使用できますが、 &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; ようなクエリはインデックスを直接使用できません。</target>
        </trans-unit>
        <trans-unit id="867794d10e104f13c9e8cf27b9206d3b607f31d5" translate="yes" xml:space="preserve">
          <source>A single operator is provided, shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;Table F.6&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;Table F.6&lt;/a&gt;に示すように、単一の演算子が提供されています。</target>
        </trans-unit>
        <trans-unit id="5d707a25df7385c415429f55133f3338c29d9eb5" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">ソート演算子。詳細については、&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c36087e3651816803cdd143451424471a45426ba" translate="yes" xml:space="preserve">
          <source>A special case that's sometimes useful is that &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; can be used to require that two patterns match the same word.</source>
          <target state="translated">時には便利だ特別な場合は、ということである &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; 二つのパターンが同じ単語に一致することを要求するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="3a70bf6435ed23a7c676143743be435f017bc889" translate="yes" xml:space="preserve">
          <source>A standby acting as both a receiver and a sender is known as a cascading standby. Standbys that are more directly connected to the master are known as upstream servers, while those standby servers further away are downstream servers. Cascading replication does not place limits on the number or arrangement of downstream servers, though each standby connects to only one upstream server which eventually links to a single master/primary server.</source>
          <target state="translated">受信側と送信側の両方の役割を果たすスタンバイは、カスケード・スタンバイと呼ばれています。マスタに直接接続されているスタンバイはアップストリームサーバと呼ばれ、さらに離れたスタンバイサーバはダウンストリームサーバと呼ばれています。カスケード・レプリケーションでは、ダウンストリーム・サーバの数や配置に制限はありませんが、各スタンバイは、最終的には1つのマスター/プライマリ・サーバにリンクする1つのアップストリーム・サーバにしか接続しません。</target>
        </trans-unit>
        <trans-unit id="94007c63f83c2bc9effa88a81f497e0678595186" translate="yes" xml:space="preserve">
          <source>A standby server can be implemented using file-based log shipping (&lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) or streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;), or a combination of both. For information on hot standby, see &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;.</source>
          <target state="translated">スタンバイサーバーは、ファイルベースのログ配布（&lt;a href=&quot;warm-standby&quot;&gt;セクション26.2&lt;/a&gt;）またはストリーミングレプリケーション（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5を&lt;/a&gt;参照）、あるいはその両方の組み合わせを使用して実装できます。ホットスタンバイについては、&lt;a href=&quot;hot-standby&quot;&gt;セクション26.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4eb6647573ef74b2ae4f7352625efc1c166ad8a5" translate="yes" xml:space="preserve">
          <source>A statement can only see rows committed before it began. This is the default.</source>
          <target state="translated">ステートメントは開始前にコミットされた行のみを見ることができます。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="4a7d12fc82f3d9f19299237c20a3b225478fd75c" translate="yes" xml:space="preserve">
          <source>A statistics kind to be computed in this statistics object. Currently supported kinds are &lt;code&gt;ndistinct&lt;/code&gt;, which enables n-distinct statistics, &lt;code&gt;dependencies&lt;/code&gt;, which enables functional dependency statistics, and &lt;code&gt;mcv&lt;/code&gt; which enables most-common values lists. If this clause is omitted, all supported statistics kinds are included in the statistics object. For more information, see &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;Section 14.2.2&lt;/a&gt; and &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;Section 70.2&lt;/a&gt;.</source>
          <target state="translated">この統計オブジェクトで計算される統計の種類。現在サポートされている種類がある &lt;code&gt;ndistinct&lt;/code&gt; 、ndistinct統計を可能にする、 &lt;code&gt;dependencies&lt;/code&gt; 機能依存の統計を可能にする、と &lt;code&gt;mcv&lt;/code&gt; 最も一般的な値のリストを可能にします。この句を省略すると、サポートされているすべての種類の統計が統計オブジェクトに含まれます。詳細については、&lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;セクション14.2.2&lt;/a&gt;および&lt;a href=&quot;multivariate-statistics-examples&quot;&gt;セクション70.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="069a72422c3cc6a607349a4e700ca343dee3bf3a" translate="yes" xml:space="preserve">
          <source>A stored array value can be enlarged by assigning to elements not already present. Any positions between those previously present and the newly assigned elements will be filled with nulls. For example, if array &lt;code&gt;myarray&lt;/code&gt; currently has 4 elements, it will have six elements after an update that assigns to &lt;code&gt;myarray[6]&lt;/code&gt;; &lt;code&gt;myarray[5]&lt;/code&gt; will contain null. Currently, enlargement in this fashion is only allowed for one-dimensional arrays, not multidimensional arrays.</source>
          <target state="translated">格納された配列値は、まだ存在していない要素に割り当てることで拡大できます。以前に存在していたものと新しく割り当てられた要素の間の位置は、ヌルで埋められます。たとえば、配列 &lt;code&gt;myarray&lt;/code&gt; に現在4つの要素がある場合、 &lt;code&gt;myarray[6]&lt;/code&gt; 割り当てる更新後、6つの要素が含まれます。 &lt;code&gt;myarray[5]&lt;/code&gt; にはnullが含まれます。現在、この方法での拡大は、多次元配列ではなく、1次元配列でのみ許可されています。</target>
        </trans-unit>
        <trans-unit id="dffe36d8e51b4ef2ab1fe0c1b3e201415f713820" translate="yes" xml:space="preserve">
          <source>A string constant defining the function; the meaning depends on the language. It can be an internal function name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">関数を定義する文字列定数。これは、内部関数名、オブジェクトファイルへのパス、SQLコマンド、手続き言語のテキストのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="dbfdac594b047310ca108ad639b27f52bf3906ca" translate="yes" xml:space="preserve">
          <source>A string constant defining the procedure; the meaning depends on the language. It can be an internal procedure name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">プロシージャを定義する文字列定数。これは、内部プロシージャ名、オブジェクトファイルへのパス、SQLコマンド、 手続き言語のテキストのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="f2a8b822478dd09960c81d58138d7e54120409b2" translate="yes" xml:space="preserve">
          <source>A string constant in SQL is an arbitrary sequence of characters bounded by single quotes (&lt;code&gt;'&lt;/code&gt;), for example &lt;code&gt;'This is a string'&lt;/code&gt;. To include a single-quote character within a string constant, write two adjacent single quotes, e.g., &lt;code&gt;'Dianne''s horse'&lt;/code&gt;. Note that this is &lt;em&gt;not&lt;/em&gt; the same as a double-quote character (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">SQLの文字列定数は、 &lt;code&gt;'This is a string'&lt;/code&gt; のように、一重引用符（ &lt;code&gt;'&lt;/code&gt; ）で囲まれた任意の文字シーケンスです。文字列定数内に単一引用符を含めるには、 &lt;code&gt;'Dianne''s horse'&lt;/code&gt; ように、2つの隣接する単一引用符を記述します。これは二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）と同じでは&lt;em&gt;ない&lt;/em&gt;ことに注意してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9740675c09c16dac87aea8ba937f0db10ddc9e95" translate="yes" xml:space="preserve">
          <source>A string literal representing the textual label associated with one value of an enum type.</source>
          <target state="translated">列挙型の1つの値に関連付けられたテキストラベルを表す文字列リテラル。</target>
        </trans-unit>
        <trans-unit id="9b5b7ed5b9f283f907a7fca459d4258127f634e3" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;n$&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the index of the argument to print. Index 1 means the first argument after &lt;code&gt;formatstr&lt;/code&gt;. If the &lt;code&gt;position&lt;/code&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="translated">&lt;code&gt;n$&lt;/code&gt; 形式の文字列。ここで、 &lt;code&gt;n&lt;/code&gt; は出力する引数のインデックスです。インデックス1は、 &lt;code&gt;formatstr&lt;/code&gt; の後の最初の引数を意味します。場合は &lt;code&gt;position&lt;/code&gt; 省略され、デフォルトでは、シーケンス内の次の引数を使用することです。</target>
        </trans-unit>
        <trans-unit id="ddfb60a35b54b4a543c700ebe6924626aa1923e3" translate="yes" xml:space="preserve">
          <source>A string-like syntax is used for working with string types and for working with complex extension types. Strings with unspecified type are matched with likely operator candidates.</source>
          <target state="translated">文字列のような構文は、文字列型を扱うため、また複雑な拡張型を扱うために使用されます。型が特定されていない文字列は、演算子の候補と照合されます。</target>
        </trans-unit>
        <trans-unit id="1cc21b370e49b36cc3877fbc8b204fee390f5ba0" translate="yes" xml:space="preserve">
          <source>A sub-&lt;code&gt;SELECT&lt;/code&gt; can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. This acts as though its output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. Note that the sub-&lt;code&gt;SELECT&lt;/code&gt; must be surrounded by parentheses, and an alias &lt;em&gt;must&lt;/em&gt; be provided for it. A &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command can also be used here.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句にサブ &lt;code&gt;SELECT&lt;/code&gt; を含めることができます。これは、この単一の &lt;code&gt;SELECT&lt;/code&gt; コマンドの実行中に、その出力が一時テーブルとして作成されたかのように機能します。サブ &lt;code&gt;SELECT&lt;/code&gt; は括弧で囲む必要があり、エイリアスを指定する&lt;em&gt;必要&lt;/em&gt;があることに注意してください。&lt;a href=&quot;sql-values&quot;&gt;VALUESの&lt;/a&gt;コマンドも、ここで使用することができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="20d744869b3f288cd0f4b443c304ea51738904ae" translate="yes" xml:space="preserve">
          <source>A subquery can also be a &lt;code&gt;VALUES&lt;/code&gt; list:</source>
          <target state="translated">サブクエリは &lt;code&gt;VALUES&lt;/code&gt; リストにすることもできます。</target>
        </trans-unit>
        <trans-unit id="467730923a1355f01d0ecc067917a4e744b3c1af" translate="yes" xml:space="preserve">
          <source>A subscriber node may have multiple subscriptions if desired. It is possible to define multiple subscriptions between a single publisher-subscriber pair, in which case care must be taken to ensure that the subscribed publication objects don't overlap.</source>
          <target state="translated">必要に応じて、サブスクライバ・ノードは複数のサブスクリプションを持つことができます。1 つのパブリッシャとサブスクライバのペア間で複数のサブスクリプションを定義することも可能ですが、その場合は、サブスクライブされたパブリケーション・オブジェクトが重複しないように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="d3b9d35fca34aebbff75a223845b5323b4b90739" translate="yes" xml:space="preserve">
          <source>A subscripted expression</source>
          <target state="translated">添え字式</target>
        </trans-unit>
        <trans-unit id="e3de42d209ab44c2b82ef6de9aa6e4c065c039e8" translate="yes" xml:space="preserve">
          <source>A subscription can only be dropped by a superuser.</source>
          <target state="translated">サブスクリプションは、スーパーユーザーのみがドロップすることができます。</target>
        </trans-unit>
        <trans-unit id="6aba51cc9b50b3a680d08e5aa1b132f7c7c53586" translate="yes" xml:space="preserve">
          <source>A substitute name for &lt;code&gt;table_name&lt;/code&gt;. When an alias is provided, it completely hides the actual name of the table. This is particularly useful when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; targets a table named &lt;code&gt;excluded&lt;/code&gt;, since that will otherwise be taken as the name of the special table representing rows proposed for insertion.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; の代替名。エイリアスを指定すると、テーブルの実際の名前が完全に非表示になります。これは、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; が &lt;code&gt;excluded&lt;/code&gt; という名前のテーブルを対象とする場合に特に役立ちます。そうでない場合は、挿入が提案された行を表す特別なテーブルの名前と見なされるためです。</target>
        </trans-unit>
        <trans-unit id="1a3b95411aa0d3922856aa0c08c5b45d4d583913" translate="yes" xml:space="preserve">
          <source>A substitute name for the &lt;code&gt;FROM&lt;/code&gt; item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given &lt;code&gt;FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;SELECT&lt;/code&gt; must refer to this &lt;code&gt;FROM&lt;/code&gt; item as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.</source>
          <target state="translated">エイリアスを含む &lt;code&gt;FROM&lt;/code&gt; アイテムの代替名。エイリアスは、簡潔にするため、または自己結合の曖昧さをなくすために使用されます（同じテーブルが複数回スキャンされる場合）。エイリアスを指定すると、テーブルまたは関数の実際の名前が完全に非表示になります。たとえば、 &lt;code&gt;FROM foo AS f&lt;/code&gt; の場合、 &lt;code&gt;SELECT&lt;/code&gt; の残りの部分はこの &lt;code&gt;FROM&lt;/code&gt; アイテムを &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;f&lt;/code&gt; として参照する必要があります。エイリアスを作成する場合、列エイリアスリストを作成して、テーブルの1つ以上の列の代替名を提供することもできます。</target>
        </trans-unit>
        <trans-unit id="3b6a0087f5676053b92594d5853d2ef232106666" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;DELETE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">ターゲットテーブルの代替名。エイリアスを指定すると、テーブルの実際の名前が完全に非表示になります。たとえば、 &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt; の場合、 &lt;code&gt;DELETE&lt;/code&gt; ステートメントの残りの部分では、このテーブルを &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;f&lt;/code&gt; として参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="4c430b6c82238597e098d25669857d482151c353" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;UPDATE foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;UPDATE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">ターゲットテーブルの代替名。エイリアスを指定すると、テーブルの実際の名前が完全に非表示になります。たとえば、 &lt;code&gt;UPDATE foo AS f&lt;/code&gt; の場合、 &lt;code&gt;UPDATE&lt;/code&gt; ステートメントの残りの部分では、このテーブルを &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;f&lt;/code&gt; として参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="79a0d38239253966494c7a744510fc637f363e29" translate="yes" xml:space="preserve">
          <source>A successful run will exit with status 0. Exit status 1 indicates static problems such as invalid command-line options. Errors during the run such as database errors or problems in the script will result in exit status 2. In the latter case, pgbench will print partial results.</source>
          <target state="translated">実行が成功すると、ステータス0で終了します。 終了ステータス1は、無効なコマンドラインオプションなどの静的な問題を示します。データベースエラーやスクリプト内の問題など、実行中のエラーは終了ステータス2になります。後者の場合、pgbenchは結果の一部を表示します。</target>
        </trans-unit>
        <trans-unit id="00a652a2bcf1b7844eb4e57bf495f13644006240" translate="yes" xml:space="preserve">
          <source>A synchronous replica receiving changes via logical decoding will work in the scope of a single database. Since, in contrast to that, &lt;em&gt;&lt;code&gt;synchronous_standby_names&lt;/code&gt;&lt;/em&gt; currently is server wide, this means this technique will not work properly if more than one database is actively used.</source>
          <target state="translated">論理デコードを介して変更を受信する同期レプリカは、単一のデータベースのスコープで機能します。これとは対照的に、&lt;em&gt; &lt;code&gt;synchronous_standby_names&lt;/code&gt; は&lt;/em&gt;現在サーバー全体に対応しているため、複数のデータベースがアクティブに使用されている場合、この手法は適切に機能しません。</target>
        </trans-unit>
        <trans-unit id="53732038fc5add15dbcd0175e133d7a901f6ac5b" translate="yes" xml:space="preserve">
          <source>A synchronous standby can be a physical replication standby or a logical replication subscriber. It can also be any other physical or logical WAL replication stream consumer that knows how to send the appropriate feedback messages. Besides the built-in physical and logical replication systems, this includes special programs such as &lt;code&gt;pg_receivewal&lt;/code&gt; and &lt;code&gt;pg_recvlogical&lt;/code&gt; as well as some third-party replication systems and custom programs. Check the respective documentation for details on synchronous replication support.</source>
          <target state="translated">同期スタンバイは、物理レプリケーションスタンバイまたは論理レプリケーションサブスクライバーにすることができます。適切なフィードバックメッセージの送信方法を知っている他の物理的または論理的なWALレプリケーションストリームコンシューマでもかまいません。組み込みの物理的および論理的複製システムに加えて、これには &lt;code&gt;pg_receivewal&lt;/code&gt; や &lt;code&gt;pg_recvlogical&lt;/code&gt; などの特別なプログラム、および一部のサードパーティの複製システムとカスタムプログラムが含まれます。同期複製サポートの詳細については、それぞれのドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="ac835affae95f586b86b74d66f86a082fb9c7b5d" translate="yes" xml:space="preserve">
          <source>A table access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;table_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a pointer to a struct of type &lt;code&gt;TableAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the table access method. The return value needs to be of server lifetime, which is typically achieved by defining it as a &lt;code&gt;static const&lt;/code&gt; variable in global scope. The &lt;code&gt;TableAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, defines the behavior of the access method using callbacks. These callbacks are pointers to plain C functions and are not visible or callable at the SQL level. All the callbacks and their behavior is defined in the &lt;code&gt;TableAmRoutine&lt;/code&gt; structure (with comments inside the struct defining the requirements for callbacks). Most callbacks have wrapper functions, which are documented from the point of view of a user (rather than an implementor) of the table access method. For details, please refer to the &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt;&lt;code&gt;src/include/access/tableam.h&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">テーブルアクセスメソッドハンドラー関数は、 &lt;code&gt;internal&lt;/code&gt; タイプの単一の引数を受け入れ、疑似タイプ &lt;code&gt;table_am_handler&lt;/code&gt; を返すように宣言する必要があります。引数は、ハンドラー関数がSQLコマンドから直接呼び出されないようにするためのダミー値です。関数の結果は、 &lt;code&gt;TableAmRoutine&lt;/code&gt; 型の構造体へのポインターである必要があります。これには、テーブルアクセスメソッドを利用するためにコアコードが知る必要があるすべてのものが含まれています。戻り値はサーバーの有効期間である必要があります。これは通常、グローバルスコープで &lt;code&gt;static const&lt;/code&gt; 変数として定義することによって実現されます。 &lt;code&gt;TableAmRoutine&lt;/code&gt; の構造体、また、アクセス方法のと呼ばれる&lt;em&gt;APIの構造体&lt;/em&gt;、コールバックを使用してアクセス方法の動作を定義します。これらのコールバックは単純なC関数へのポインターであり、SQLレベルでは表示または呼び出しできません。すべてのコールバックとその動作は &lt;code&gt;TableAmRoutine&lt;/code&gt; 構造で定義されます（コールバックの要件を定義する構造体内のコメント付き）。ほとんどのコールバックにはラッパー関数があり、テーブルアクセスメソッドのユーザー（実装者ではなく）の観点から文書化されています。詳細については、&lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt; &lt;code&gt;src/include/access/tableam.h&lt;/code&gt; &lt;/a&gt;ファイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="4ff995032ef85b617d95b6ca1e8cb93045b2fac9" translate="yes" xml:space="preserve">
          <source>A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it.</source>
          <target state="translated">テーブルは、最大で1つの主キーを持つことができます。(機能的にはほとんど同じものですが、主キーとして識別できるのは1つだけです)。リレーショナルデータベースの理論では、すべてのテーブルは主キーを持たなければならないと規定されています。この規則はPostgreSQLでは施行されていませんが、通常はこれに従うのが最善です。</target>
        </trans-unit>
        <trans-unit id="a5dd3a29c662f0d5a9fc9f1c03648ba7178abbb4" translate="yes" xml:space="preserve">
          <source>A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure:</source>
          <target state="translated">テーブルは複数の外部キー制約を持つことができます。これは、テーブル間の多対多の関係を実装するために使用されます。商品と注文に関するテーブルを持っていますが、1つの注文に多くの商品を含めることができるようにしたいとします(上記の構造ではできません)。このようなテーブル構造を使用することができます。</target>
        </trans-unit>
        <trans-unit id="ea2feaef62849b073ab499dff5691a69fec6f5f4" translate="yes" xml:space="preserve">
          <source>A table can inherit from more than one parent table, in which case it has the union of the columns defined by the parent tables. Any columns declared in the child table's definition are added to these. If the same column name appears in multiple parent tables, or in both a parent table and the child's definition, then these columns are &amp;ldquo;merged&amp;rdquo; so that there is only one such column in the child table. To be merged, columns must have the same data types, else an error is raised. Inheritable check constraints and not-null constraints are merged in a similar fashion. Thus, for example, a merged column will be marked not-null if any one of the column definitions it came from is marked not-null. Check constraints are merged if they have the same name, and the merge will fail if their conditions are different.</source>
          <target state="translated">テーブルは複数の親テーブルから継承できます。その場合、親テーブルによって定義された列の和集合があります。子テーブルの定義で宣言された列はすべてこれらに追加されます。同じ列名が複数の親テーブル、または親テーブルと子の定義の両方にある場合、これらの列は「マージ」されて、子テーブルにそのような列が1つだけ存在するようになります。マージするには、列のデータ型が同じである必要があります。そうでない場合、エラーが発生します。継承可能なチェック制約とnull以外の制約は、同様の方法でマージされます。したがって、たとえば、マージされた列の列定義のいずれかが非ヌルとマークされている場合、マージされた列は非ヌルとマークされます。チェック制約は、同じ名前の場合はマージされ、条件が異なる場合はマージが失敗します。</target>
        </trans-unit>
        <trans-unit id="b60ab6e47e92c777a5fb70888a73042517cd9738" translate="yes" xml:space="preserve">
          <source>A table cannot have more than 1600 columns. (In practice, the effective limit is usually lower because of tuple-length constraints.)</source>
          <target state="translated">テーブルは1600以上の列を持つことはできません。(実際には、タプル長制約のため、有効な制限値は通常より低くなります)。</target>
        </trans-unit>
        <trans-unit id="40d4dec2662223321ee541222a2fb74e1b35e9b6" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="translated">リレーショナルデータベースのテーブルは、紙のテーブルとよく似ています。行と列で構成されています。列の数と順序は固定されており、各列には名前があります。行数は可変です。これは、特定の瞬間に保存されるデータの量を反映しています。 SQLは、テーブル内の行の順序については保証しません。テーブルが読み取られると、ソートが明示的に要求されない限り、行は不特定の順序で表示されます。これについては、&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;第7章で説明してい&lt;/a&gt;ます。さらに、SQLは行に一意の識別子を割り当てないため、テーブル内に完全に同一の複数の行を含めることができます。これは、SQLの基礎となる数学的モデルの結果ですが、通常は望ましくありません。この章の後半では、この問題に対処する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="0b7ed2eab9cf794fb325a1b40465300bd26db30b" translate="yes" xml:space="preserve">
          <source>A table reference can be a table name (possibly schema-qualified), or a derived table such as a subquery, a &lt;code&gt;JOIN&lt;/code&gt; construct, or complex combinations of these. If more than one table reference is listed in the &lt;code&gt;FROM&lt;/code&gt; clause, the tables are cross-joined (that is, the Cartesian product of their rows is formed; see below). The result of the &lt;code&gt;FROM&lt;/code&gt; list is an intermediate virtual table that can then be subject to transformations by the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses and is finally the result of the overall table expression.</source>
          <target state="translated">テーブル参照は、テーブル名（おそらくスキーマ修飾）、またはサブクエリ、 &lt;code&gt;JOIN&lt;/code&gt; 構文、またはこれらの複雑な組み合わせなどの派生テーブルにすることができます。 &lt;code&gt;FROM&lt;/code&gt; 句に複数のテーブル参照がリストされている場合、テーブルは相互結合されます（つまり、行のデカルト積が形成されます。以下を参照してください）。 &lt;code&gt;FROM&lt;/code&gt; リストの結果は中間仮想テーブルであり、 &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、および &lt;code&gt;HAVING&lt;/code&gt; 句による変換の対象となり、最終的にテーブル式全体の結果になります。</target>
        </trans-unit>
        <trans-unit id="8ea15f1133af85b529e072e262c881e0f91d10ea" translate="yes" xml:space="preserve">
          <source>A table that has columns with potentially large entries will have an associated &lt;em&gt;TOAST&lt;/em&gt; table, which is used for out-of-line storage of field values that are too large to keep in the table rows proper. &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; links from a table to its TOAST table, if any. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">エントリが大きくなる可能性のある列を持つテーブルには、関連付けられた&lt;em&gt;TOAST&lt;/em&gt;テーブルがあり、テーブルの行を適切に保持するには大きすぎるフィールド値の行外ストレージに使用されます。 &lt;code&gt;pg_class&lt;/code&gt; 。 &lt;code&gt;reltoastrelid&lt;/code&gt; は、もしあれば、テーブルからそのTOASTテーブルにリンクします。詳細については、&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c16bcd4cf40264715bc5e3b5d07ef4d9afb5816" translate="yes" xml:space="preserve">
          <source>A tablesample method handler is declared to return &lt;code&gt;tsm_handler&lt;/code&gt;.</source>
          <target state="translated">tablesampleメソッドハンドラーは &lt;code&gt;tsm_handler&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="816a4cd8c0ed513824b7c88b1bb7cf4571478fb1" translate="yes" xml:space="preserve">
          <source>A tablespace allows superusers to define an alternative location on the file system where the data files containing database objects (such as tables and indexes) can reside.</source>
          <target state="translated">テーブルスペースは、スーパーユーザーがデータベースオブジェクト(テーブルやインデックスなど)を含むデータファイルが存在するファイルシステム上の別の場所を定義することを可能にします。</target>
        </trans-unit>
        <trans-unit id="820b586a949a1d02483ccf3a6e05f26f2fdbeced" translate="yes" xml:space="preserve">
          <source>A tablespace can only be dropped by its owner or a superuser. The tablespace must be empty of all database objects before it can be dropped. It is possible that objects in other databases might still reside in the tablespace even if no objects in the current database are using the tablespace. Also, if the tablespace is listed in the &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; setting of any active session, the &lt;code&gt;DROP&lt;/code&gt; might fail due to temporary files residing in the tablespace.</source>
          <target state="translated">表領域を削除できるのは、その所有者またはスーパーユーザーのみです。テーブルスペースを削除する前に、すべてのデータベースオブジェクトを空にする必要があります。現在のデータベースのオブジェクトがテーブルスペースを使用していない場合でも、他のデータベースのオブジェクトがテーブルスペースに残っている可能性があります。また、テーブルスペースがアクティブなセッションの&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;設定にリストされている場合、テーブルスペースにある一時ファイルが原因で &lt;code&gt;DROP&lt;/code&gt; が失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d48bc9df0b7c8031d0790b2f1fc9c85172017b3e" translate="yes" xml:space="preserve">
          <source>A tablespace cannot be used independently of the cluster in which it is defined; see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">テーブルスペースは、それが定義されているクラスターから独立して使用することはできません。&lt;a href=&quot;manage-ag-tablespaces&quot;&gt;セクション22.6を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d579dc88e9cdf352d2f344d0841a4b50c6608379" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt; and &lt;code&gt;effective_io_concurrency&lt;/code&gt;. Setting either value for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="translated">設定またはリセットされるテーブルスペースパラメータ。現在、使用可能なパラメーターは &lt;code&gt;seq_page_cost&lt;/code&gt; 、 &lt;code&gt;random_page_cost&lt;/code&gt; 、および &lt;code&gt;effective_io_concurrency&lt;/code&gt; のみです。特定のテーブルスペースにいずれかの値を設定すると、同じ名前の構成パラメーターによって確立された、プランナーのそのテーブルスペース内のテーブルからページを読み取るコストの通常の見積もりが上書きされます（&lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;、&lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;、&lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrencyを&lt;/a&gt;参照）。これは、1つのテーブルスペースがI / Oサブシステムの残りの部分より高速または低速のディスク上にある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="9ac97e0fad0b28b51a14115817e32577fe4a0b90" translate="yes" xml:space="preserve">
          <source>A temporary name can be given to tables and complex table references to be used for references to the derived table in the rest of the query. This is called a &lt;em&gt;table alias&lt;/em&gt;.</source>
          <target state="translated">一時的な名前をテーブルおよび複雑なテーブル参照に指定して、残りのクエリで派生テーブルへの参照に使用できます。これは&lt;em&gt;テーブルエイリアス&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="154e0fcec698de6b2015fa25f68088725ba8e1d2" translate="yes" xml:space="preserve">
          <source>A text search configuration binds a parser together with a set of dictionaries to process the parser's output tokens. For each token type that the parser can return, a separate list of dictionaries is specified by the configuration. When a token of that type is found by the parser, each dictionary in the list is consulted in turn, until some dictionary recognizes it as a known word. If it is identified as a stop word, or if no dictionary recognizes the token, it will be discarded and not indexed or searched for. Normally, the first dictionary that returns a non-&lt;code&gt;NULL&lt;/code&gt; output determines the result, and any remaining dictionaries are not consulted; but a filtering dictionary can replace the given word with a modified word, which is then passed to subsequent dictionaries.</source>
          <target state="translated">テキスト検索構成は、パーサーの出力トークンを処理するために、パーサーを一連の辞書とバインドします。パーサーが返すことができるトークンの種類ごとに、辞書の個別のリストが構成によって指定されます。パーサーがそのタイプのトークンを見つけると、リスト内の各辞書が順番に調べられ、いくつかの辞書がそれを既知の単語として認識します。ストップワードとして識別された場合、または辞書がトークンを認識しない場合、そのトークンは破棄され、インデックス付けや検索は行われません。通常、非 &lt;code&gt;NULL&lt;/code&gt; 出力を返す最初のディクショナリが結果を決定し、残りのディクショナリは参照されません。しかし、フィルタリングディクショナリは、指定された単語を変更された単語に置き換え、それをその後の辞書に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b660e99784a0c9ca392fa9c70b6890953f937efa" translate="yes" xml:space="preserve">
          <source>A text search configuration specifies all options necessary to transform a document into a &lt;code&gt;tsvector&lt;/code&gt;: the parser to use to break text into tokens, and the dictionaries to use to transform each token into a lexeme. Every call of &lt;code&gt;to_tsvector&lt;/code&gt; or &lt;code&gt;to_tsquery&lt;/code&gt; needs a text search configuration to perform its processing. The configuration parameter &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; specifies the name of the default configuration, which is the one used by text search functions if an explicit configuration parameter is omitted. It can be set in &lt;code&gt;postgresql.conf&lt;/code&gt;, or set for an individual session using the &lt;code&gt;SET&lt;/code&gt; command.</source>
          <target state="translated">テキスト検索構成は、ドキュメントを &lt;code&gt;tsvector&lt;/code&gt; に変換するために必要なすべてのオプションを指定します。テキストをトークンに分解するために使用するパーサーと、各トークンを語彙素に変換するために使用する辞書です。 &lt;code&gt;to_tsvector&lt;/code&gt; または &lt;code&gt;to_tsquery&lt;/code&gt; を呼び出すたびに、その処理を実行するためのテキスト検索構成が必要です。構成パラメーター&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;は、デフォルト構成の名前を指定します。これは、明示的な構成パラメーターが省略された場合にテキスト検索機能によって使用されるものです。 &lt;code&gt;postgresql.conf&lt;/code&gt; で設定するか、 &lt;code&gt;SET&lt;/code&gt; コマンドを使用して個々のセッションに設定できます。</target>
        </trans-unit>
        <trans-unit id="bbb87e15ef4cfdfbfbbdeb4da5c6a41f2a086081" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary (sometimes abbreviated as TZ) is a collection of words that includes information about the relationships of words and phrases, i.e., broader terms (BT), narrower terms (NT), preferred terms, non-preferred terms, related terms, etc.</source>
          <target state="translated">シソーラス辞書(TZと略されることもある)とは、語句の関係、すなわち、広義語(BT)、狭義語(NT)、好ましい語、非好ましい語、関連語などの情報を含む語句集のことである。</target>
        </trans-unit>
        <trans-unit id="657570ff202cabc5e9df7f56f8f1f48bd50b5f6f" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary uses a &lt;em&gt;subdictionary&lt;/em&gt; (which is specified in the dictionary's configuration) to normalize the input text before checking for phrase matches. It is only possible to select one subdictionary. An error is reported if the subdictionary fails to recognize a word. In that case, you should remove the use of the word or teach the subdictionary about it. You can place an asterisk (&lt;code&gt;*&lt;/code&gt;) at the beginning of an indexed word to skip applying the subdictionary to it, but all sample words &lt;em&gt;must&lt;/em&gt; be known to the subdictionary.</source>
          <target state="translated">シソーラスディクショナリは、&lt;em&gt;サブディクショナリ&lt;/em&gt;（ディクショナリの設定で指定されている）を使用して、フレーズの一致をチェックする前に入力テキストを正規化します。 1つのサブディクショナリのみを選択できます。副辞書が単語を認識できない場合、エラーが報告されます。その場合は、単語の使用を削除するか、その単語について副辞書に教える必要があります。インデックス付けされた単語の先頭にアスタリスク（ &lt;code&gt;*&lt;/code&gt; ）を配置して、サブディクショナリの適用をスキップできますが、サンプルの単語&lt;em&gt;は&lt;/em&gt;すべてサブディクショナリに認識されている&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="555f5a4dff77bb6e52e02e4204a9cef467ac2510" translate="yes" xml:space="preserve">
          <source>A third identifier type used by the system is &lt;code&gt;cid&lt;/code&gt;, or command identifier. This is the data type of the system columns &lt;code&gt;cmin&lt;/code&gt; and &lt;code&gt;cmax&lt;/code&gt;. Command identifiers are also 32-bit quantities.</source>
          <target state="translated">システムで使用される3番目の識別子タイプは &lt;code&gt;cid&lt;/code&gt; （コマンド識別子）です。これは、システム列 &lt;code&gt;cmin&lt;/code&gt; および &lt;code&gt;cmax&lt;/code&gt; のデータ型です。コマンド識別子も32ビットの数量です。</target>
        </trans-unit>
        <trans-unit id="ea6ae6aa8002700db2a8dea433bfc36222024c69" translate="yes" xml:space="preserve">
          <source>A third possible use for partial indexes does not require the index to be used in queries at all. The idea here is to create a unique index over a subset of a table, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;. This enforces uniqueness among the rows that satisfy the index predicate, without constraining those that do not.</source>
          <target state="translated">部分インデックスの3番目の使用方法として、クエリでインデックスを使用する必要はまったくありません。ここでのアイデアは、&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;例11.3の&lt;/a&gt;ように、テーブルのサブセットに対して一意のインデックスを作成することです。これにより、インデックス述語を満たさない行を制約することなく、インデックス述語を満たす行間の一意性が強制されます。</target>
        </trans-unit>
        <trans-unit id="fd6336e70f63a890b86a6cdbf6ec2c2a9832cb6d" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition-date rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="translated">タイムゾーンの略称（例： &lt;code&gt;PST&lt;/code&gt; )。このような仕様は、一連の夏時間の移行日のルールも意味する可能性がある完全なタイムゾーン名とは対照的に、UTCからの特定のオフセットを定義するだけです。認識される略語は &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; ビューにリストされます（&lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;項51.91を&lt;/a&gt;参照）。構成パラメーター&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;または&lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;をタイムゾーンの省略形に設定することはできませんが、日付/時刻の入力値および &lt;code&gt;AT TIME ZONE&lt;/code&gt; 演算子で省略形を使用できます。</target>
        </trans-unit>
        <trans-unit id="1c1c7cede62c34481ae2c11f0263c23892006d69" translate="yes" xml:space="preserve">
          <source>A time zone cannot be specified when processing &lt;code&gt;timestamp without time zone&lt;/code&gt; or &lt;code&gt;interval&lt;/code&gt; inputs. These are always taken at face value.</source>
          <target state="translated">&lt;code&gt;timestamp without time zone&lt;/code&gt; または &lt;code&gt;interval&lt;/code&gt; 入力なしでタイムスタンプを処理するときは、タイムゾーンを指定できません。これらは常に額面どおりに取得されます。</target>
        </trans-unit>
        <trans-unit id="f8aefcc9f6e4a3be95cca7cfd42df6a2625d531c" translate="yes" xml:space="preserve">
          <source>A timezone abbreviation file can contain blank lines and comments beginning with &lt;code&gt;#&lt;/code&gt;. Non-comment lines must have one of these formats:</source>
          <target state="translated">タイムゾーン省略形ファイルには、 &lt;code&gt;#&lt;/code&gt; で始まる空白行とコメントを含めることができます。非コメント行は、次のいずれかの形式である必要があります。</target>
        </trans-unit>
        <trans-unit id="61f64c13915c0871a3186bb5a87ae1ae25b54733" translate="yes" xml:space="preserve">
          <source>A token can be a &lt;em&gt;key word&lt;/em&gt;, an &lt;em&gt;identifier&lt;/em&gt;, a &lt;em&gt;quoted identifier&lt;/em&gt;, a &lt;em&gt;literal&lt;/em&gt; (or constant), or a special character symbol. Tokens are normally separated by whitespace (space, tab, newline), but need not be if there is no ambiguity (which is generally only the case if a special character is adjacent to some other token type).</source>
          <target state="translated">トークンには、&lt;em&gt;キーワード&lt;/em&gt;、&lt;em&gt;識別子&lt;/em&gt;、&lt;em&gt;引用符付き識別子&lt;/em&gt;、&lt;em&gt;リテラル&lt;/em&gt;（または定数）、または特殊文字記号を使用できます。トークンは通常、空白（スペース、タブ、改行）で区切られますが、あいまいさがない場合は不要です（通常、特殊文字が他のトークンタイプに隣接している場合のみです）。</target>
        </trans-unit>
        <trans-unit id="8690158fd0b251c00dae6dfc7ede983456ddc45f" translate="yes" xml:space="preserve">
          <source>A token type emitted by the configuration's parser</source>
          <target state="translated">設定のパーサから出力されるトークン型</target>
        </trans-unit>
        <trans-unit id="c55f58174d7a27cababe64df945ac6699fb690f5" translate="yes" xml:space="preserve">
          <source>A transaction can also see its own statistics (as yet untransmitted to the collector) in the views &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt;, and &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt;. These numbers do not act as stated above; instead they update continuously throughout the transaction.</source>
          <target state="translated">トランザクションは、ビュー &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt; 、 &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt; 、 &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt; 、および &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt; で独自の統計情報（まだコレクターに送信されていない）を表示することもできます。これらの数値は上記のようには機能しません。代わりに、トランザクション全体で継続的に更新されます。</target>
        </trans-unit>
        <trans-unit id="1d7c34d636397a5326ca01bffe81c685d0466ea6" translate="yes" xml:space="preserve">
          <source>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</source>
          <target state="translated">トランザクションは、検索条件を満たす行のセットを返すクエリを再実行し、最近コミットされた別のトランザクションによって条件を満たす行のセットが変更されたことを発見します。</target>
        </trans-unit>
        <trans-unit id="f8c2fd7479305ce91383c02d70969dd66b2acddb" translate="yes" xml:space="preserve">
          <source>A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).</source>
          <target state="translated">トランザクションは、以前に読んだデータを再読み込みし、データが別のトランザクション(最初の読み込み以降にコミットされたもの)によって変更されたことを発見します。</target>
        </trans-unit>
        <trans-unit id="c3382e299466bb042feceee6752ca8ef0259c657" translate="yes" xml:space="preserve">
          <source>A transaction reads data written by a concurrent uncommitted transaction.</source>
          <target state="translated">トランザクションは、並行しているコミットされていないトランザクションによって書き込まれたデータを読み込みます。</target>
        </trans-unit>
        <trans-unit id="f339f7f826bbe705459f4d6147b96402061e9382" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;LISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; を実行したトランザクションは、2フェーズコミットの準備ができません。</target>
        </trans-unit>
        <trans-unit id="3d0230fafa23fc125f62b605c5c7adbafb550941" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;NOTIFY&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; を実行したトランザクションは、2フェーズコミットの準備ができません。</target>
        </trans-unit>
        <trans-unit id="6073bbb0958767b4f02cfd2e64c1259376f80a5e" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;UNLISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; を実行したトランザクションは、2フェーズコミットの準備ができません。</target>
        </trans-unit>
        <trans-unit id="fbb0eb006f978734fefdbee822c93e37ab76e793" translate="yes" xml:space="preserve">
          <source>A transform specifies how to adapt a data type to a procedural language. For example, when writing a function in PL/Python using the &lt;code&gt;hstore&lt;/code&gt; type, PL/Python has no prior knowledge how to present &lt;code&gt;hstore&lt;/code&gt; values in the Python environment. Language implementations usually default to using the text representation, but that is inconvenient when, for example, an associative array or a list would be more appropriate.</source>
          <target state="translated">変換は、データ型を手続き型言語に適合させる方法を指定します。たとえば、 &lt;code&gt;hstore&lt;/code&gt; タイプを使用してPL / Pythonで関数を作成する場合、PL / Pythonには、Python環境で &lt;code&gt;hstore&lt;/code&gt; 値を表示する方法に関する事前の知識がありません。言語の実装では通常、デフォルトでテキスト表現が使用されますが、たとえば、連想配列やリストの方が適している場合は不便です。</target>
        </trans-unit>
        <trans-unit id="8c2b373e9fbb9296093271c1db45ed67d33a82b6" translate="yes" xml:space="preserve">
          <source>A transform specifies two functions:</source>
          <target state="translated">トランスフォームは2つの関数を指定します。</target>
        </trans-unit>
        <trans-unit id="0c9fe367d63aa8028ded2402f8662551682fdc1d" translate="yes" xml:space="preserve">
          <source>A trigger function is declared to return &lt;code&gt;trigger.&lt;/code&gt;</source>
          <target state="translated">トリガー関数はトリガーを返すように宣言されてい &lt;code&gt;trigger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7aece537a33eef527a0311c288ac02d9c4de009" translate="yes" xml:space="preserve">
          <source>A trigger that is marked &lt;code&gt;FOR EACH ROW&lt;/code&gt; is called once for every row that the operation modifies. For example, a &lt;code&gt;DELETE&lt;/code&gt; that affects 10 rows will cause any &lt;code&gt;ON DELETE&lt;/code&gt; triggers on the target relation to be called 10 separate times, once for each deleted row. In contrast, a trigger that is marked &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; only executes once for any given operation, regardless of how many rows it modifies (in particular, an operation that modifies zero rows will still result in the execution of any applicable &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; triggers).</source>
          <target state="translated">&lt;code&gt;FOR EACH ROW&lt;/code&gt; とマークされたトリガーは、操作が変更する行ごとに1回呼び出されます。たとえば、10行に影響する &lt;code&gt;DELETE&lt;/code&gt; を使用すると、ターゲットリレーションの &lt;code&gt;ON DELETE&lt;/code&gt; トリガーが、削除された行ごとに1回ずつ、10回ずつ呼び出されます。対照的に、 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; とマークされたトリガーは、変更する行の数に関係なく、特定の操作に対して一度だけ実行されます（特に、ゼロ行を変更する操作でも、適用可能な &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; トリガーが実行されます）。 。</target>
        </trans-unit>
        <trans-unit id="7eef7b97e3bd1ce7b7ee3cef5b1119d2228d0033" translate="yes" xml:space="preserve">
          <source>A trigram is a group of three consecutive characters taken from a string. We can measure the similarity of two strings by counting the number of trigrams they share. This simple idea turns out to be very effective for measuring the similarity of words in many natural languages.</source>
          <target state="translated">トリグラムとは、文字列から取り出された3つの連続した文字のグループのことです。2つの文字列の類似度は、2つの文字列が共有しているトリグラムの数を数えることで測定できます。この単純なアイデアは、多くの自然言語の単語の類似度を測定するのに非常に効果的であることがわかりました。</target>
        </trans-unit>
        <trans-unit id="a08b1cdf2b0b095b9d5863bddf7e5d8e3d7c32c3" translate="yes" xml:space="preserve">
          <source>A trivial example of &lt;code&gt;LATERAL&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; の簡単な例は</target>
        </trans-unit>
        <trans-unit id="e8e38ccfb8ee20281247054f727fc62c3822f6eb" translate="yes" xml:space="preserve">
          <source>A type cast</source>
          <target state="translated">タイプキャスト</target>
        </trans-unit>
        <trans-unit id="3a3537ff39dd61d4d97ae8731a9b41e347a01f70" translate="yes" xml:space="preserve">
          <source>A type cast specifies a conversion from one data type to another. PostgreSQL accepts two equivalent syntaxes for type casts:</source>
          <target state="translated">型キャストは、あるデータ型から別のデータ型への変換を指定します。PostgreSQLは型キャストに対して2つの同等の構文を受け付けています。</target>
        </trans-unit>
        <trans-unit id="2685b870f0e5693341cc020b2215b601f4f13b60" translate="yes" xml:space="preserve">
          <source>A typical application of table aliases is to assign short identifiers to long table names to keep the join clauses readable. For example:</source>
          <target state="translated">テーブルエイリアスの典型的なアプリケーションは、長いテーブル名に短い識別子を代入して、結合句を読みやすくすることです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="53e9ce7093c6b3d709e92599c2e63f01a872a533" translate="yes" xml:space="preserve">
          <source>A typical cost estimator will proceed as follows:</source>
          <target state="translated">一般的なコストの見積もりは、以下のように進めていきます。</target>
        </trans-unit>
        <trans-unit id="c8d74e530024da711c01ee4999c6bbacc75f1477" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that the semaphore objects used by a PostgreSQL server are removed at apparently random times, leading to the server crashing with log messages like</source>
          <target state="translated">この設定をオンにした場合に観測される典型的な効果は、PostgreSQLサーバで使用されるセマフォオブジェクトが明らかにランダムなタイミングで削除され、以下のようなログメッセージでサーバがクラッシュすることです。</target>
        </trans-unit>
        <trans-unit id="3fc9f5b992a80655782589dd8a0df2c7a647d35a" translate="yes" xml:space="preserve">
          <source>A typical query that can use this index would be:</source>
          <target state="translated">このインデックスを使用できる典型的なクエリは、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="169a523c2d612c2511933ebb2897995bb069e2f2" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication origin. Should never leave the system.</source>
          <target state="translated">レプリケーション元のクラスタ全体で一意な識別子です。決してシステムから離れるべきではありません。</target>
        </trans-unit>
        <trans-unit id="47f21621fe9103c27d1085b3377ce1e6907d3fec" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication slot</source>
          <target state="translated">レプリケーションスロットのクラスタ全体で一意な識別子</target>
        </trans-unit>
        <trans-unit id="5d4bfd425f4eb16bbefa46dacd068b22bd41528d" translate="yes" xml:space="preserve">
          <source>A useful property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling &lt;code&gt;WITH&lt;/code&gt; queries. Thus, expensive calculations that are needed in multiple places can be placed within a &lt;code&gt;WITH&lt;/code&gt; query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is not able to push restrictions from the parent query down into a multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query, since that might affect all uses of the &lt;code&gt;WITH&lt;/code&gt; query's output when it should affect only one. The multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query will be evaluated as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; クエリの有用なプロパティは、親クエリまたは兄弟 &lt;code&gt;WITH&lt;/code&gt; クエリによって複数回参照されている場合でも、通常は親クエリの実行ごとに1回だけ評価されることです。したがって、複数の場所で必要となる高価な計算を &lt;code&gt;WITH&lt;/code&gt; クエリ内に配置して、冗長な作業を回避できます。別の可能なアプリケーションは、副作用のある関数の不要な複数の評価を防ぐことです。ただし、このコインのもう1つの側面は、オプティマイザが親クエリから複数参照の &lt;code&gt;WITH&lt;/code&gt; クエリに制限をプッシュできないことです。これは、 &lt;code&gt;WITH&lt;/code&gt; クエリの出力のすべての使用に影響を与える可能性がある場合に影響を与える可能性があるためです。多重参照 &lt;code&gt;WITH&lt;/code&gt; クエリは、親クエリが後で破棄する可能性がある行を抑制せずに、書き込まれたとおりに評価されます。（しかし、前述のように、クエリへの参照が限られた数の行のみを要求する場合、評価は早期に停止する可能性があります。）</target>
        </trans-unit>
        <trans-unit id="624d70f8d00542243273d8f95b839148832783a9" translate="yes" xml:space="preserve">
          <source>A user can also be allowed to create objects in someone else's schema. To allow that, the &lt;code&gt;CREATE&lt;/code&gt; privilege on the schema needs to be granted. Note that by default, everyone has &lt;code&gt;CREATE&lt;/code&gt; and &lt;code&gt;USAGE&lt;/code&gt; privileges on the schema &lt;code&gt;public&lt;/code&gt;. This allows all users that are able to connect to a given database to create objects in its &lt;code&gt;public&lt;/code&gt; schema. Some &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;usage patterns&lt;/a&gt; call for revoking that privilege:</source>
          <target state="translated">ユーザーは、他の誰かのスキーマにオブジェクトを作成することも許可されます。これを可能にするには、スキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権を付与する必要があります。デフォルトでは、誰もがスキーマ &lt;code&gt;public&lt;/code&gt; に対する &lt;code&gt;CREATE&lt;/code&gt; および &lt;code&gt;USAGE&lt;/code&gt; 特権を持っていることに注意してください。これにより、特定のデータベースに接続できるすべてのユーザーが、その &lt;code&gt;public&lt;/code&gt; スキーマにオブジェクトを作成できます。一部の&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;使用パターンで&lt;/a&gt;は、その特権を取り消す必要があります。</target>
        </trans-unit>
        <trans-unit id="b9aa765822babac771b767a7977f197f0cfd20dc" translate="yes" xml:space="preserve">
          <source>A user can only revoke privileges that were granted directly by that user. If, for example, user A has granted a privilege with grant option to user B, and user B has in turn granted it to user C, then user A cannot revoke the privilege directly from C. Instead, user A could revoke the grant option from user B and use the &lt;code&gt;CASCADE&lt;/code&gt; option so that the privilege is in turn revoked from user C. For another example, if both A and B have granted the same privilege to C, A can revoke their own grant but not B's grant, so C will still effectively have the privilege.</source>
          <target state="translated">ユーザーは、そのユーザーが直接付与した特権のみを取り消すことができます。たとえば、ユーザーAがユーザーBに権限付与オプション付きの権限を付与し、ユーザーBがユーザーCに権限を付与した場合、ユーザーAはCから直接権限を取り消すことはできません。代わりに、ユーザーAが権限付与オプションを取り消すことができます。ユーザーBから &lt;code&gt;CASCADE&lt;/code&gt; オプションを使用して、ユーザーCから特権を取り消します。別の例として、AとBの両方が同じ特権をCに付与した場合、Aは自分の付与を取り消すことができますが、Bの付与は取り消せません。引き続き特権が有効になります。</target>
        </trans-unit>
        <trans-unit id="9eef0500388438dcdd883438e62adfff2b4c59d7" translate="yes" xml:space="preserve">
          <source>A user mapping, defined with &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, is needed as well to identify the role that will be used on the remote server:</source>
          <target state="translated">リモートサーバーで使用されるロールを識別するには、&lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;で定義されたユーザーマッピングも必要です。</target>
        </trans-unit>
        <trans-unit id="cd811596f6c21fd6820e0962c95748afb5dd8832" translate="yes" xml:space="preserve">
          <source>A user may perform &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, etc. on a column if they hold that privilege for either the specific column or its whole table. Granting the privilege at the table level and then revoking it for one column will not do what one might wish: the table-level grant is unaffected by a column-level operation.</source>
          <target state="translated">ユーザーは、特定の列またはそのテーブル全体に対する特権を保持している場合、列に対して &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; などを実行できます。テーブルレベルで権限を付与してから1つの列に対してその権限を取り消すことは、期待することにはなりません。テーブルレベルの付与は、列レベルの操作の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="8d16a3b790258dd6e7bcb147ac82c63396f9dabe" translate="yes" xml:space="preserve">
          <source>A user with appropriate privileges can pass &lt;code&gt;tablespace_name&lt;/code&gt; to &lt;code&gt;CREATE DATABASE&lt;/code&gt;, &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; to have the data files for these objects stored within the specified tablespace.</source>
          <target state="translated">適切な権限を持つユーザーは、 &lt;code&gt;tablespace_name&lt;/code&gt; を &lt;code&gt;CREATE DATABASE&lt;/code&gt; 、 &lt;code&gt;CREATE TABLE&lt;/code&gt; 、 &lt;code&gt;CREATE INDEX&lt;/code&gt; または &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; に渡して、これらのオブジェクトのデータファイルを指定されたテーブルスペース内に格納できます。</target>
        </trans-unit>
        <trans-unit id="cb5146129674511426d710b87f38fac56dd128fd" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no argument and returning type &lt;code&gt;event_trigger&lt;/code&gt;.</source>
          <target state="translated">引数をとらず、タイプ &lt;code&gt;event_trigger&lt;/code&gt; を返すと宣言されたユーザー提供の関数。</target>
        </trans-unit>
        <trans-unit id="944b09ef2e50c44bc480f5f428bf817a45e1996f" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no arguments and returning type &lt;code&gt;trigger&lt;/code&gt;, which is executed when the trigger fires.</source>
          <target state="translated">引数をとらず、トリガーが起動したときに実行される &lt;code&gt;trigger&lt;/code&gt; 型を返すように宣言されたユーザー指定の関数。</target>
        </trans-unit>
        <trans-unit id="3c03a8192bb8c460f615ba363c0076eb7beddfc8" translate="yes" xml:space="preserve">
          <source>A validator function would typically inspect the function body for syntactical correctness, but it can also look at other properties of the function, for example if the language cannot handle certain argument types. To signal an error, the validator function should use the &lt;code&gt;ereport()&lt;/code&gt; function. The return value of the function is ignored.</source>
          <target state="translated">バリデーター関数は通常、構文の正確さについて関数本体を検査しますが、たとえば言語が特定の引数タイプを処理できない場合など、関数の他のプロパティも調べることができます。エラーを通知するには、検証関数は &lt;code&gt;ereport()&lt;/code&gt; 関数を使用する必要があります。関数の戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="7bb559a62e1812965348b9dc25a132908d898b4a" translate="yes" xml:space="preserve">
          <source>A value (but not a key) can be an SQL &lt;code&gt;NULL&lt;/code&gt;. For example:</source>
          <target state="translated">値（キーではない）はSQL &lt;code&gt;NULL&lt;/code&gt; にすることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="f11b15a75cd7fa69b386c1868dbf1a5bd1c71215" translate="yes" xml:space="preserve">
          <source>A value expression is one of the following:</source>
          <target state="translated">値の式は以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="15f463c504877012fea738b4b0d0b079a3d4f123" translate="yes" xml:space="preserve">
          <source>A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: &lt;code&gt;MATCH FULL&lt;/code&gt;, &lt;code&gt;MATCH PARTIAL&lt;/code&gt;, and &lt;code&gt;MATCH SIMPLE&lt;/code&gt; (which is the default). &lt;code&gt;MATCH FULL&lt;/code&gt; will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; allows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; is not yet implemented. (Of course, &lt;code&gt;NOT NULL&lt;/code&gt; constraints can be applied to the referencing column(s) to prevent these cases from arising.)</source>
          <target state="translated">参照列に挿入された値は、指定された一致タイプを使用して、参照テーブルおよび参照列の値と照合されます。マッチタイプには、 &lt;code&gt;MATCH FULL&lt;/code&gt; 、 &lt;code&gt;MATCH PARTIAL&lt;/code&gt; 、および &lt;code&gt;MATCH SIMPLE&lt;/code&gt; （デフォルト）の3つがあります。 &lt;code&gt;MATCH FULL&lt;/code&gt; では、すべての外部キー列がnullでない限り、複数列の外部キーの1つの列をnullにすることはできません。それらがすべてnullの場合、その行は参照先のテーブルで一致する必要はありません。 &lt;code&gt;MATCH SIMPLE&lt;/code&gt; では、任意の外部キー列をnullにすることができます。それらのいずれかがnullの場合、その行は参照されるテーブルで一致する必要はありません。 &lt;code&gt;MATCH PARTIAL&lt;/code&gt; はまだ実装されていません。 （もちろん、 &lt;code&gt;NOT NULL&lt;/code&gt; 参照列に制約を適用して、これらのケースが発生しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="d3f19f348507a8389d8d149cdf77d56e254062cd" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON text to be queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="translated">照会されるJSONテキストを表す変数（&lt;em&gt;コンテキストアイテム&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="6b7ff43247d2073dd8c93ef6f893b8751eb3e7bd" translate="yes" xml:space="preserve">
          <source>A variable representing the result of path evaluation in filter expressions.</source>
          <target state="translated">フィルタ式におけるパス評価の結果を表す変数。</target>
        </trans-unit>
        <trans-unit id="156f0d479c5cbda4c018211d44db7834d2c5eaed" translate="yes" xml:space="preserve">
          <source>A variant of quoted identifiers allows including escaped Unicode characters identified by their code points. This variant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case U followed by ampersand) immediately before the opening double quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the identifier &lt;code&gt;&quot;data&quot;&lt;/code&gt; could be written as</source>
          <target state="translated">引用符で囲まれた識別子のバリアントでは、コードポイントによって識別されるエスケープされたUnicode文字を含めることができます。このバリアントは、開始の二重引用符の直前に &lt;code&gt;U&amp;amp;&lt;/code&gt; （大文字または小文字のUの後にアンパサンドが続く）で始まり、間にスペースはありません（例： &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt; 。 （これにより、演算子 &lt;code&gt;&amp;amp;&lt;/code&gt; で曖昧さが生じることに注意してください。この問題を回避するために、演算子の周りにスペースを使用してください。）引用符内では、バックスラッシュの後に4桁の16進コードポイント番号またはまたは、バックスラッシュとそれに続くプラス記号、それに続く6桁の16進コードポイント番号。たとえば、識別子 &lt;code&gt;&quot;data&quot;&lt;/code&gt; は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="acdae0bdc3109dd35a6d548731ba6bb6d6a12b1e" translate="yes" xml:space="preserve">
          <source>A variant of the above query is</source>
          <target state="translated">上記のクエリの変形例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="86b56417739883cc59cc6c063327a17fce9dbe75" translate="yes" xml:space="preserve">
          <source>A view column name list must be specified for a recursive view.</source>
          <target state="translated">再帰ビューでは、ビューのカラム名リストを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="85b3bfd48768285b52ad306ba0d6292137e9c9f1" translate="yes" xml:space="preserve">
          <source>A view that is simple enough to be automatically updatable (see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;) does not require a user-created rule in order to be updatable. While you can create an explicit rule anyway, the automatic update transformation will generally outperform an explicit rule.</source>
          <target state="translated">自動的に更新できるほど単純なビュー（&lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEWを&lt;/a&gt;参照）では、更新可能にするためにユーザーが作成したルールは必要ありません。とにかく明示的なルールを作成できますが、自動更新変換は通常、明示的なルールよりも優れています。</target>
        </trans-unit>
        <trans-unit id="b5c5c1bad9d2f71be50a1fcf23b697eb7750bb21" translate="yes" xml:space="preserve">
          <source>A window function call</source>
          <target state="translated">ウィンドウ関数の呼び出し</target>
        </trans-unit>
        <trans-unit id="014e860f54b04147bfef99f64476d36d0f965833" translate="yes" xml:space="preserve">
          <source>A window function call always contains an &lt;code&gt;OVER&lt;/code&gt; clause directly following the window function's name and argument(s). This is what syntactically distinguishes it from a normal function or non-window aggregate. The &lt;code&gt;OVER&lt;/code&gt; clause determines exactly how the rows of the query are split up for processing by the window function. The &lt;code&gt;PARTITION BY&lt;/code&gt; clause within &lt;code&gt;OVER&lt;/code&gt; divides the rows into groups, or partitions, that share the same values of the &lt;code&gt;PARTITION BY&lt;/code&gt; expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.</source>
          <target state="translated">ウィンドウ関数呼び出しには、常にウィンドウ関数の名前と引数の直後に &lt;code&gt;OVER&lt;/code&gt; 句が含まれます。これが、通常の関数またはウィンドウ以外の集計と構文的に区別するものです。 &lt;code&gt;OVER&lt;/code&gt; の句は、クエリの行が窓関数を処理するために分割されている正確にどのように決定されます。 &lt;code&gt;OVER&lt;/code&gt; 内の &lt;code&gt;PARTITION BY&lt;/code&gt; 句は、行を &lt;code&gt;PARTITION BY&lt;/code&gt; 式の同じ値を共有するグループまたはパーティションに分割します。各行について、ウィンドウ関数は、現在の行と同じパーティションに分類される行全体で計算されます。</target>
        </trans-unit>
        <trans-unit id="69ff975e62e5e9881d6e40cfa6394518b64c0b59" translate="yes" xml:space="preserve">
          <source>A word is defined as in the specification of &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; above. Constraint escapes are illegal within bracket expressions.</source>
          <target state="translated">単語は、上記の &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; および &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; の仕様のように定義されます。括弧エスケープでは、制約エスケープは無効です。</target>
        </trans-unit>
        <trans-unit id="e7b5c134c4da8e8da4908f5aacc24a6aa1409eb3" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="translated">待機中の &lt;code&gt;restore_command&lt;/code&gt; の実際の例は、&lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt;モジュールで提供されています。上記のロジックを正しく実装する方法のリファレンスとして使用してください。また、特定の構成や環境をサポートするために、必要に応じて拡張することもできます。</target>
        </trans-unit>
        <trans-unit id="4d87e11b3c84c752269b580bca5caeedfc37d702" translate="yes" xml:space="preserve">
          <source>A write transaction has more than 64 subtransactions</source>
          <target state="translated">書き込みトランザクションには64以上のサブトランザクションがあります。</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="7a0ffd6011b0a819cbe07ec59ab6319e323b19e8" translate="yes" xml:space="preserve">
          <source>ABORT &amp;mdash; abort the current transaction</source>
          <target state="translated">ABORT &amp;mdash;現在のトランザクションを中止します</target>
        </trans-unit>
        <trans-unit id="e3a56e2d83c5cd3911209ecd97318531d89949dd" translate="yes" xml:space="preserve">
          <source>ACCESS EXCLUSIVE</source>
          <target state="translated">アクセスエクスクルーシブ</target>
        </trans-unit>
        <trans-unit id="236082e0393025e2b67ccb853e349993a3e685de" translate="yes" xml:space="preserve">
          <source>ACCESS SHARE</source>
          <target state="translated">アクセスシェア</target>
        </trans-unit>
        <trans-unit id="41f215a6d36c7782875bfb5d6d290ebb1e7961df" translate="yes" xml:space="preserve">
          <source>AES</source>
          <target state="translated">AES</target>
        </trans-unit>
        <trans-unit id="7cd735bc88414abeac25ef102606e6871aeba944" translate="yes" xml:space="preserve">
          <source>AIX</source>
          <target state="translated">AIX</target>
        </trans-unit>
        <trans-unit id="d3f3cb97007280f4a9b1e690872959eda00344a5" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE</source>
          <target state="translated">アルターアグリゲート</target>
        </trans-unit>
        <trans-unit id="ed3d1c36faecc14690efbf5d3029f3dd4930091a" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE &amp;mdash; change the definition of an aggregate function</source>
          <target state="translated">ALTER AGGREGATE &amp;mdash;集約関数の定義を変更する</target>
        </trans-unit>
        <trans-unit id="a11472b885174cf0a5b8f565bbd9df33d5c63d9f" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION</source>
          <target state="translated">演算子の変更</target>
        </trans-unit>
        <trans-unit id="56c3d4607ffe2e71e2c5f2646969f8ca0df737b4" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION &amp;mdash; change the definition of a collation</source>
          <target state="translated">ALTER COLLATION &amp;mdash;照合の定義を変更する</target>
        </trans-unit>
        <trans-unit id="41b42a1cc1e0f91fde1b7c9e18dfe7b36339b901" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION</source>
          <target state="translated">アルター変換</target>
        </trans-unit>
        <trans-unit id="ccebf78a2dc7b51b4b857717880c57e697294e8c" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION &amp;mdash; change the definition of a conversion</source>
          <target state="translated">ALTER CONVERSION &amp;mdash;変換の定義を変更する</target>
        </trans-unit>
        <trans-unit id="00ca4087b8df03743dae97498c53fb19953638fa" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE</source>
          <target state="translated">データベースを変更する</target>
        </trans-unit>
        <trans-unit id="bea7726d13edb6ca210b4e6c9e61ad1bc910bed8" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE &amp;mdash; change a database</source>
          <target state="translated">ALTER DATABASE &amp;mdash;データベースを変更する</target>
        </trans-unit>
        <trans-unit id="2d6bcd612a3e7b99bb9476838637e9b5438e3634" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES</source>
          <target state="translated">デフォルト特権の変更</target>
        </trans-unit>
        <trans-unit id="d8ff7f2d5af359b01a54f95e0ec2fd521bd7747c" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES &amp;mdash; define default access privileges</source>
          <target state="translated">ALTER DEFAULT PRIVILEGES &amp;mdash;デフォルトのアクセス権限を定義します</target>
        </trans-unit>
        <trans-unit id="3f3cf48aa306a7a17143c18f42b0b45f1ba91588" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN</source>
          <target state="translated">ディレクトリを変更する</target>
        </trans-unit>
        <trans-unit id="535f7dde2f03c36ca7629e33ff7b1217df1764aa" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN &amp;mdash; change the definition of a domain</source>
          <target state="translated">ALTER DOMAIN &amp;mdash;ドメインの定義を変更する</target>
        </trans-unit>
        <trans-unit id="20933ed39426b19f4475367266e6e6f9a626ffa6" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER</source>
          <target state="translated">イベントトリガーを変更する</target>
        </trans-unit>
        <trans-unit id="10dfbf336834913b8615fd608fa879b835569269" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER &amp;mdash; change the definition of an event trigger</source>
          <target state="translated">ALTER EVENT TRIGGER &amp;mdash;イベントトリガーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="0800582e9a19732ccd7ede52083d298eb7e533f7" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION</source>
          <target state="translated">変更拡張</target>
        </trans-unit>
        <trans-unit id="fceab1548e1fa0086ad916c8c58c48d5f822b214" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION &amp;mdash; change the definition of an extension</source>
          <target state="translated">ALTER EXTENSION &amp;mdash;拡張の定義を変更する</target>
        </trans-unit>
        <trans-unit id="1845d1a7f6884f411e6b6fe79fb5470d0541e6de" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER</source>
          <target state="translated">FOREIGN DATA WRAPPERを変更します。</target>
        </trans-unit>
        <trans-unit id="81f39fe099a4b1e8700a250047ab0bd19b916bbd" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER &amp;mdash; change the definition of a foreign-data wrapper</source>
          <target state="translated">ALTER FOREIGN DATA WRAPPER &amp;mdash;外部データラッパーの定義を変更する</target>
        </trans-unit>
        <trans-unit id="a09c3d2b46b06da9b27051fbdd7021dbe016aef6" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE</source>
          <target state="translated">ALTER FOREIGN TABLE</target>
        </trans-unit>
        <trans-unit id="8624b9015bf6424468dfa21128e81480cb2172bb" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE &amp;mdash; change the definition of a foreign table</source>
          <target state="translated">ALTER FOREIGN TABLE &amp;mdash;外部テーブルの定義を変更する</target>
        </trans-unit>
        <trans-unit id="6f1e4d41d93587f0bfc00e49946d0343d91452a6" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION</source>
          <target state="translated">置換機能</target>
        </trans-unit>
        <trans-unit id="0d8b2dd3aa8516a6e8465a116eb3a3088efc3943" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION &amp;mdash; change the definition of a function</source>
          <target state="translated">ALTER FUNCTION &amp;mdash;関数の定義を変更する</target>
        </trans-unit>
        <trans-unit id="1d015a780bf1ecbd73d8b159554c5fb6595a8014" translate="yes" xml:space="preserve">
          <source>ALTER GROUP</source>
          <target state="translated">アルターグループ</target>
        </trans-unit>
        <trans-unit id="8b6db204989799abd80f3151dc7f1e0c1b92ec62" translate="yes" xml:space="preserve">
          <source>ALTER GROUP &amp;mdash; change role name or membership</source>
          <target state="translated">ALTER GROUP &amp;mdash;ロール名またはメンバーシップを変更します</target>
        </trans-unit>
        <trans-unit id="48c2e5d4cd7c661c29fd2888d9f2286c8fc0c6bf" translate="yes" xml:space="preserve">
          <source>ALTER INDEX</source>
          <target state="translated">アルターインデックス</target>
        </trans-unit>
        <trans-unit id="7af8592c9de99cba72394d1922b6e193f563c137" translate="yes" xml:space="preserve">
          <source>ALTER INDEX &amp;mdash; change the definition of an index</source>
          <target state="translated">ALTER INDEX &amp;mdash;インデックスの定義を変更する</target>
        </trans-unit>
        <trans-unit id="1593f1abf4a97117a0be55f5da7d21f597c8c250" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE</source>
          <target state="translated">言語を変更する</target>
        </trans-unit>
        <trans-unit id="2d47f4538397cbf8b0a1e802f6dfa7cb56556115" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE &amp;mdash; change the definition of a procedural language</source>
          <target state="translated">ALTER LANGUAGE &amp;mdash;手続き型言語の定義を変更する</target>
        </trans-unit>
        <trans-unit id="b8e23037908ab469bed89826c20ecdd2b7ec5245" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT</source>
          <target state="translated">大規模オブジェクトを変更します。</target>
        </trans-unit>
        <trans-unit id="d01f8e01043a2f37f9bf2b4fbe638ce531bf573c" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT &amp;mdash; change the definition of a large object</source>
          <target state="translated">ALTER LARGE OBJECT &amp;mdash;ラージオブジェクトの定義を変更する</target>
        </trans-unit>
        <trans-unit id="acf3facbc79c94e9820cd014a83e0c3bffc8d33e" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW</source>
          <target state="translated">マテリアル表示を変更する</target>
        </trans-unit>
        <trans-unit id="ff19a08e1cc705b85f737d7d03bbe11848829b1c" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW &amp;mdash; change the definition of a materialized view</source>
          <target state="translated">ALTER MATERIALIZED VIEW &amp;mdash;マテリアライズドビューの定義を変更します</target>
        </trans-unit>
        <trans-unit id="dce6c5285005edbbb84e2318b05691c4b30c9b74" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR</source>
          <target state="translated">操作者を変更する</target>
        </trans-unit>
        <trans-unit id="7dafb4a30aeb9191e7113acec86c091ff802f404" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR &amp;mdash; change the definition of an operator</source>
          <target state="translated">ALTER OPERATOR &amp;mdash;オペレーターの定義を変更する</target>
        </trans-unit>
        <trans-unit id="a0e738cb1034a6c7d40880b830a0d0aabd9fe44b" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS</source>
          <target state="translated">オペレータクラスの変更</target>
        </trans-unit>
        <trans-unit id="cb0f6723f3b16452ec4b0d07ef7fe014b4a43893" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS &amp;mdash; change the definition of an operator class</source>
          <target state="translated">ALTER OPERATOR CLASS &amp;mdash;演算子クラスの定義を変更します</target>
        </trans-unit>
        <trans-unit id="0ba7fb1c4beddce29550f5cb8b66990a01471bb0" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY</source>
          <target state="translated">オペレータファミリーの変更</target>
        </trans-unit>
        <trans-unit id="b145c0d850ce88d5e3be9bd1acd90a4f15ebe361" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY &amp;mdash; change the definition of an operator family</source>
          <target state="translated">ALTER OPERATOR FAMILY &amp;mdash;演算子族の定義を変更します</target>
        </trans-unit>
        <trans-unit id="88b3b91499f373dcdd877e9ff64364e5e7e60e0e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY</source>
          <target state="translated">変更ポリシー</target>
        </trans-unit>
        <trans-unit id="833f3039623c0b1cb3fef4e1e4f83cc843bd962e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY &amp;mdash; change the definition of a row level security policy</source>
          <target state="translated">ALTER POLICY &amp;mdash;行レベルのセキュリティポリシーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="6a0674112110b72195624944bfa13c57d5d82cb7" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE</source>
          <target state="translated">手続きを変える</target>
        </trans-unit>
        <trans-unit id="43575de59088420331627e718ac08acff025d18b" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE &amp;mdash; change the definition of a procedure</source>
          <target state="translated">ALTER PROCEDURE &amp;mdash;プロシージャの定義を変更する</target>
        </trans-unit>
        <trans-unit id="54107fe026e19d4f5a11e4537d44c6b6d22b8b09" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION</source>
          <target state="translated">出版を変更する</target>
        </trans-unit>
        <trans-unit id="9597d926bb8a9acc34d0e5930cb8d7cd0d4f568f" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION &amp;mdash; change the definition of a publication</source>
          <target state="translated">ALTER PUBLICATION &amp;mdash;パブリケーションの定義を変更する</target>
        </trans-unit>
        <trans-unit id="8d50cc704f5e61444d52d138269e970c84c316a9" translate="yes" xml:space="preserve">
          <source>ALTER ROLE</source>
          <target state="translated">演算子役割</target>
        </trans-unit>
        <trans-unit id="12cc26ef42f3af7ca4348ac6467248637f685960" translate="yes" xml:space="preserve">
          <source>ALTER ROLE &amp;mdash; change a database role</source>
          <target state="translated">ALTER ROLE &amp;mdash;データベースの役割を変更する</target>
        </trans-unit>
        <trans-unit id="4dcea8729953c25416c614a8e9dd74665955b163" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE</source>
          <target state="translated">変更ルーチン</target>
        </trans-unit>
        <trans-unit id="41b74c3c2f66a654560a7c52136c27e28aece24f" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE &amp;mdash; change the definition of a routine</source>
          <target state="translated">ALTER ROUTINE &amp;mdash;ルーチンの定義を変更する</target>
        </trans-unit>
        <trans-unit id="a0e0dff76fa934f2bd1deef6694b1932d808504f" translate="yes" xml:space="preserve">
          <source>ALTER RULE</source>
          <target state="translated">アルタールール</target>
        </trans-unit>
        <trans-unit id="2fc7414dfcf68c3ac031a4421e6842e26618ab9c" translate="yes" xml:space="preserve">
          <source>ALTER RULE &amp;mdash; change the definition of a rule</source>
          <target state="translated">ALTER RULE &amp;mdash;ルールの定義を変更する</target>
        </trans-unit>
        <trans-unit id="d6fc95f83521d1f149e5c2d72ccf2e6275ceff58" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA</source>
          <target state="translated">アルタースキーマ</target>
        </trans-unit>
        <trans-unit id="a9c6d7baa1a1fa5c1ea1e4302e14b9b0b1cbc91f" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA &amp;mdash; change the definition of a schema</source>
          <target state="translated">ALTER SCHEMA &amp;mdash;スキーマの定義を変更する</target>
        </trans-unit>
        <trans-unit id="e0ff1dd3b5bc12676f75f802c39fe58d3f568b91" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE</source>
          <target state="translated">アルターシーケンス</target>
        </trans-unit>
        <trans-unit id="75ca9fc88afe8b3a138533f529504e99e65095c7" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE &amp;mdash; change the definition of a sequence generator</source>
          <target state="translated">ALTER SEQUENCE &amp;mdash;シーケンスジェネレーターの定義を変更する</target>
        </trans-unit>
        <trans-unit id="4e991c23674edbbd034fbea9f95fd5732fde6594" translate="yes" xml:space="preserve">
          <source>ALTER SERVER</source>
          <target state="translated">アルターサーバー</target>
        </trans-unit>
        <trans-unit id="9097ec6c4fcb5127ed5acb37df744bf114c59cf4" translate="yes" xml:space="preserve">
          <source>ALTER SERVER &amp;mdash; change the definition of a foreign server</source>
          <target state="translated">ALTER SERVER &amp;mdash;外部サーバーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="339516769622a8fe113a08ac4316402cbf0b0186" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS</source>
          <target state="translated">演算子</target>
        </trans-unit>
        <trans-unit id="08e64dea134c405908e303c3bf604acf6999c23f" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS &amp;mdash; change the definition of an extended statistics object</source>
          <target state="translated">ALTER STATISTICS &amp;mdash;拡張統計オブジェクトの定義を変更します</target>
        </trans-unit>
        <trans-unit id="10579de4cfd80edf9752f883f553b098d07c2351" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION</source>
          <target state="translated">サブスクリプションを変更する</target>
        </trans-unit>
        <trans-unit id="3088c38bfc4248dd70925edc22aa9e03938a70b2" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION &amp;mdash; change the definition of a subscription</source>
          <target state="translated">ALTER SUBSCRIPTION &amp;mdash;サブスクリプションの定義を変更します</target>
        </trans-unit>
        <trans-unit id="b751196563736994d3b141da4e3359399f7784c1" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM</source>
          <target state="translated">アルターシステム</target>
        </trans-unit>
        <trans-unit id="43121748c757e8121439597a27c3d6de3f1df5e0" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM &amp;mdash; change a server configuration parameter</source>
          <target state="translated">ALTER SYSTEM &amp;mdash;サーバー構成パラメーターを変更する</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">変更テーブル</target>
        </trans-unit>
        <trans-unit id="afe4c7733f05b900cf17777f836ea5b6c85eae68" translate="yes" xml:space="preserve">
          <source>ALTER TABLE &amp;mdash; change the definition of a table</source>
          <target state="translated">ALTER TABLE &amp;mdash;テーブルの定義を変更する</target>
        </trans-unit>
        <trans-unit id="c9732ec2c1c41131709b9ec601102740f5d08528" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE</source>
          <target state="translated">へんこうテーブルくうかん</target>
        </trans-unit>
        <trans-unit id="e3e82c20f13259759fc74c305fcf89694aa71e4c" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE &amp;mdash; change the definition of a tablespace</source>
          <target state="translated">ALTER TABLESPACE &amp;mdash;テーブルスペースの定義を変更する</target>
        </trans-unit>
        <trans-unit id="ab1241fdf0558dac3416642b6e5e2afa08edd357" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION</source>
          <target state="translated">テキスト検索設定を変更する</target>
        </trans-unit>
        <trans-unit id="2a241bc8e97bcb10c517130c630f0f5969d5e473" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION &amp;mdash; change the definition of a text search configuration</source>
          <target state="translated">ALTER TEXT SEARCH CONFIGURATION &amp;mdash;テキスト検索構成の定義を変更します</target>
        </trans-unit>
        <trans-unit id="a62239565ecd2214c8d0dc9fde76b1033be6c2fc" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY</source>
          <target state="translated">テキスト検索辞書を変更する</target>
        </trans-unit>
        <trans-unit id="13998d90641b194774e8f12cf56ab5eaead8a314" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY &amp;mdash; change the definition of a text search dictionary</source>
          <target state="translated">ALTER TEXT SEARCH DICTIONARY &amp;mdash;テキスト検索辞書の定義を変更します</target>
        </trans-unit>
        <trans-unit id="8179411a0a3b868da4b4880988c7d06f086d844e" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER</source>
          <target state="translated">テキスト検索パーサを変更する</target>
        </trans-unit>
        <trans-unit id="b487f243ff77599a0ebe244a83985f8acf1c14ea" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER &amp;mdash; change the definition of a text search parser</source>
          <target state="translated">ALTER TEXT SEARCH PARSER &amp;mdash;テキスト検索パーサーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="03386acc96b981e6c35c90b75e2cec735105ea3c" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE</source>
          <target state="translated">テキスト検索テンプレートを変更する</target>
        </trans-unit>
        <trans-unit id="285dbc8186deb64394ffb30b6e1363ad0dbe6498" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE &amp;mdash; change the definition of a text search template</source>
          <target state="translated">ALTER TEXT SEARCH TEMPLATE &amp;mdash;テキスト検索テンプレートの定義を変更します</target>
        </trans-unit>
        <trans-unit id="f6742edfb2c8b1a8d27beb1bba87153804373be5" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER</source>
          <target state="translated">変更トリガ</target>
        </trans-unit>
        <trans-unit id="485c6a654f45ba69729bdbf15496fe29a444d1e3" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER &amp;mdash; change the definition of a trigger</source>
          <target state="translated">ALTER TRIGGER &amp;mdash;トリガーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="b8549a9a7b44242713f7d48704380ebba425b154" translate="yes" xml:space="preserve">
          <source>ALTER TYPE</source>
          <target state="translated">アルタータイプ</target>
        </trans-unit>
        <trans-unit id="2921b9477c2e093e0ed29e1dc88121fdd946417d" translate="yes" xml:space="preserve">
          <source>ALTER TYPE &amp;mdash; change the definition of a type</source>
          <target state="translated">ALTER TYPE &amp;mdash;タイプの定義を変更する</target>
        </trans-unit>
        <trans-unit id="0f0117db55477563e4484d9879a151cbea4a27fc" translate="yes" xml:space="preserve">
          <source>ALTER USER</source>
          <target state="translated">アルターユーザ</target>
        </trans-unit>
        <trans-unit id="dc349b6f52ce0d7d5bb23382932a5eb2f67eac63" translate="yes" xml:space="preserve">
          <source>ALTER USER &amp;mdash; change a database role</source>
          <target state="translated">ALTER USER &amp;mdash;データベースの役割を変更する</target>
        </trans-unit>
        <trans-unit id="a375773515175c08cd7fc8e357c209c60d07f13e" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING</source>
          <target state="translated">ユーザマッピングを変更する</target>
        </trans-unit>
        <trans-unit id="84dbc6c571c120a8defca7e0a6c086e648f98854" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING &amp;mdash; change the definition of a user mapping</source>
          <target state="translated">ALTER USER MAPPING &amp;mdash;ユーザーマッピングの定義を変更する</target>
        </trans-unit>
        <trans-unit id="219d78bab64e4f5637643b61ce738d2b84487f00" translate="yes" xml:space="preserve">
          <source>ALTER VIEW</source>
          <target state="translated">ALTER ANSICHT</target>
        </trans-unit>
        <trans-unit id="d3ae485ff52fa79c183c7d3ce9f751addfed0468" translate="yes" xml:space="preserve">
          <source>ALTER VIEW &amp;mdash; change the definition of a view</source>
          <target state="translated">ALTER VIEW &amp;mdash;ビューの定義を変更する</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="21b8417695362cfdc412c95c44c48fa648556dd9" translate="yes" xml:space="preserve">
          <source>ANALYZE &amp;mdash; collect statistics about a database</source>
          <target state="translated">ANALYZE &amp;mdash;データベースに関する統計を収集する</target>
        </trans-unit>
        <trans-unit id="e2f2d6cea163ef0dacf4540366528f7c7edd61f2" translate="yes" xml:space="preserve">
          <source>AND &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">AND &lt;code&gt;tsquery&lt;/code&gt; を一緒に</target>
        </trans-unit>
        <trans-unit id="09b52ce6d8d3ca14c041a1ecfe44ca34c84c93c5" translate="yes" xml:space="preserve">
          <source>ANSI</source>
          <target state="translated">ANSI</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="5fb9ba93128c23898a1b0a61ebd44810a0c6b606" translate="yes" xml:space="preserve">
          <source>ASCII code of the first character of the argument. For UTF8 returns the Unicode code point of the character. For other multibyte encodings, the argument must be an ASCII character.</source>
          <target state="translated">引数の最初の文字のASCIIコード。UTF8 の場合は、その文字の Unicode コードポイントを返します。その他のマルチバイトエンコーディングの場合、引数はASCII文字でなければなりません。</target>
        </trans-unit>
        <trans-unit id="7647bd700c1c10eb12b5de06bf40a88672e3451d" translate="yes" xml:space="preserve">
          <source>Aaron D. Gifford</source>
          <target state="translated">アーロン・D・ギフォード</target>
        </trans-unit>
        <trans-unit id="cd437865cbac7655f8b86519aea764f378093804" translate="yes" xml:space="preserve">
          <source>Abbreviation</source>
          <target state="translated">Abbreviation</target>
        </trans-unit>
        <trans-unit id="1bb9eda0dcf4611f958758d0ccd51e13bf341710" translate="yes" xml:space="preserve">
          <source>Abbreviation (for Pacific Standard Time)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90aba13b6feb8ff1a5141d94cb1fc2fe96e9477" translate="yes" xml:space="preserve">
          <source>Abbreviations</source>
          <target state="translated">Abbreviations</target>
        </trans-unit>
        <trans-unit id="c5fd5b17ae3c41e41caede4fa07a5960ba1a5f2d" translate="yes" xml:space="preserve">
          <source>Abort any statement that takes more than the specified amount of time. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will also be logged. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">指定した時間より長くかかるステートメントを中止します。 &lt;code&gt;log_min_error_statement&lt;/code&gt; が &lt;code&gt;ERROR&lt;/code&gt; 以下に設定されている場合、タイムアウトしたステートメントもログに記録されます。この値が単位なしで指定されている場合、ミリ秒と見なされます。値ゼロ（デフォルト）はタイムアウトを無効にします。</target>
        </trans-unit>
        <trans-unit id="6c33aee3e89187438edae43ea18855e5962050c2" translate="yes" xml:space="preserve">
          <source>Abort any statement that waits longer than the specified amount of time while attempting to acquire a lock on a table, index, row, or other database object. The time limit applies separately to each lock acquisition attempt. The limit applies both to explicit locking requests (such as &lt;code&gt;LOCK TABLE&lt;/code&gt;, or &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; without &lt;code&gt;NOWAIT&lt;/code&gt;) and to implicitly-acquired locks. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">テーブル、インデックス、行、またはその他のデータベースオブジェクトのロックを取得する際に、指定された時間よりも長く待機しているステートメントを中止します。時間制限は、各ロック取得試行に個別に適用されます。この制限は、明示的なロック要求（ &lt;code&gt;LOCK TABLE&lt;/code&gt; 、または &lt;code&gt;NOWAIT&lt;/code&gt; なしの &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; など）と暗黙的に取得されたロックの両方に適用されます。この値が単位なしで指定されている場合、ミリ秒と見なされます。値ゼロ（デフォルト）はタイムアウトを無効にします。</target>
        </trans-unit>
        <trans-unit id="82c17c3ccfec7ab27999f74c3eae394cb4e66713" translate="yes" xml:space="preserve">
          <source>Above, since there is no &lt;code&gt;ORDER BY&lt;/code&gt; in the &lt;code&gt;OVER&lt;/code&gt; clause, the window frame is the same as the partition, which for lack of &lt;code&gt;PARTITION BY&lt;/code&gt; is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an &lt;code&gt;ORDER BY&lt;/code&gt; clause, we get very different results:</source>
          <target state="translated">上記では、 &lt;code&gt;OVER&lt;/code&gt; 句に &lt;code&gt;ORDER BY&lt;/code&gt; がないため、ウィンドウフレームはパーティションと同じで、 &lt;code&gt;PARTITION BY&lt;/code&gt; がない場合はテーブル全体になります。言い換えると、各合計はテーブル全体で取得されるため、各出力行で同じ結果が得られます。しかし、 &lt;code&gt;ORDER BY&lt;/code&gt; 句を追加すると、非常に異なる結果が得られます。</target>
        </trans-unit>
        <trans-unit id="ecc48669a5f045e0b1c73515a6a06d3751ca7ca3" translate="yes" xml:space="preserve">
          <source>Absolute value of the SQL/JSON number</source>
          <target state="translated">SQL/JSON番号の絶対値</target>
        </trans-unit>
        <trans-unit id="95ecf27dff51c67220f14d51d8af97b6912bfba7" translate="yes" xml:space="preserve">
          <source>Access Exclusive locks taken on the primary server, including both explicit &lt;code&gt;LOCK&lt;/code&gt; commands and various DDL actions, conflict with table accesses in standby queries.</source>
          <target state="translated">明示的な &lt;code&gt;LOCK&lt;/code&gt; コマンドとさまざまなDDLアクションの両方を含む、プライマリサーバーで行われたアクセス排他ロックは、スタンバイクエリのテーブルアクセスと競合します。</target>
        </trans-unit>
        <trans-unit id="446d3f34dfbff4e7c337ef9e7b895902f1dba9ef" translate="yes" xml:space="preserve">
          <source>Access methods that always return entries in the natural ordering of their data (such as btree) should set &lt;code&gt;amcanorder&lt;/code&gt; to true. Currently, such access methods must use btree-compatible strategy numbers for their equality and ordering operators.</source>
          <target state="translated">常にデータの自然な順序でエントリを返すアクセスメソッド（btreeなど）は、 &lt;code&gt;amcanorder&lt;/code&gt; をtrueに設定する必要があります。現在、このようなアクセス方法では、等価演算子と順序付け演算子にbtree互換の戦略番号を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b0e23c5a90203bbd16a6b86de50258944a0ed57a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordered scans must support &amp;ldquo;marking&amp;rdquo; a position in a scan and later returning to the marked position. The same position might be restored multiple times. However, only one position need be remembered per scan; a new &lt;code&gt;ammarkpos&lt;/code&gt; call overrides the previously marked position. An access method that does not support ordered scans need not provide &lt;code&gt;ammarkpos&lt;/code&gt; and &lt;code&gt;amrestrpos&lt;/code&gt; functions in &lt;code&gt;IndexAmRoutine&lt;/code&gt;; set those pointers to NULL instead.</source>
          <target state="translated">順序付けされたスキャンをサポートするアクセスメソッドは、スキャンでの位置の「マーク」と、後でマークされた位置への復帰をサポートする必要があります。同じ位置が複数回復元される可能性があります。ただし、1回のスキャンで覚える必要がある位置は1つだけです。新しい &lt;code&gt;ammarkpos&lt;/code&gt; 呼び出しは、以前にマークされた位置をオーバーライドします。注文したスキャンが提供する必要はありませんサポートされていないアクセス方法 &lt;code&gt;ammarkpos&lt;/code&gt; と &lt;code&gt;amrestrpos&lt;/code&gt; で機能 &lt;code&gt;IndexAmRoutine&lt;/code&gt; を。代わりに、これらのポインタをNULLに設定してください。</target>
        </trans-unit>
        <trans-unit id="0fdc357a629c5f7047a03e768a0792d5cbb44b9a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should implement &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; property testing, as the core code does not know how to do that and will return NULL. It may also be advantageous to implement &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; testing, if that can be done more cheaply than by opening the index and calling &lt;code&gt;amcanreturn&lt;/code&gt;, which is the core code's default behavior. The default behavior should be satisfactory for all other standard properties.</source>
          <target state="translated">順序付け演算子をサポートするアクセスメソッドは、 &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; プロパティテストを実装する必要があります。これは、コアコードがその方法を知らず、NULLを返すためです。インデックスを開いてコアコードのデフォルトの動作である &lt;code&gt;amcanreturn&lt;/code&gt; を呼び出すよりも安価に実行できる場合は、 &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; テストを実装することも有利です。他のすべての標準プロパティでは、デフォルトの動作で十分です。</target>
        </trans-unit>
        <trans-unit id="ec93e5f340df1c63a8b7900c8c64d2c56b99c607" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should set &lt;code&gt;amcanorderbyop&lt;/code&gt; to true. This indicates that the index is capable of returning entries in an order satisfying &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Scan modifiers of that form can be passed to &lt;code&gt;amrescan&lt;/code&gt; as described previously.</source>
          <target state="translated">順序付け演算子をサポートするアクセスメソッドは、 &lt;code&gt;amcanorderbyop&lt;/code&gt; をtrueに設定する必要があります。これは、インデックスが &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; を満たす順序でエントリを返すことができることを示しています。前述のように、そのフォームのスキャン修飾子を &lt;code&gt;amrescan&lt;/code&gt; に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="9d5da75b46e072ddd4591be60d218524fe1f309e" translate="yes" xml:space="preserve">
          <source>Access privileges for template (not actually used)</source>
          <target state="translated">テンプレートのアクセス権(実際には使用していません</target>
        </trans-unit>
        <trans-unit id="85f3b04d8d02176eeb1578817040415abfa34698" translate="yes" xml:space="preserve">
          <source>Access privileges that this type of object should have on creation</source>
          <target state="translated">このタイプのオブジェクトが作成時に持つべきアクセス権限</target>
        </trans-unit>
        <trans-unit id="3d73c85183e638c3a5d257c026ae2497dddb1f32" translate="yes" xml:space="preserve">
          <source>Access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">アクセス権; 詳細については、&lt;a href=&quot;ddl-priv&quot;&gt;セクション5.7&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="02bbd73371e69fa85fa69f734c586e2358313738" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="translated">ビューで参照されるテーブルへのアクセスは、ビューの所有者の権限によって決定されます。場合によっては、これを使用して、基になるテーブルへの安全であるが制限されたアクセスを提供できます。ただし、すべてのビューが改ざんに対して安全であるとは限りません。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;項40.5&lt;/a&gt;を参照してください。ビューで呼び出された関数は、ビューを使用してクエリから直接呼び出された場合と同じように扱われます。したがって、ビューのユーザーは、ビューで使用されるすべての関数を呼び出す権限を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="ea538985d43ba38411a22fc78790edc64739cd94" translate="yes" xml:space="preserve">
          <source>Access to the column &lt;code&gt;subconninfo&lt;/code&gt; is revoked from normal users, because it could contain plain-text passwords.</source>
          <target state="translated">列 &lt;code&gt;subconninfo&lt;/code&gt; へのアクセスは、プレーンテキストのパスワードを含む可能性があるため、通常のユーザーから取り消されます。</target>
        </trans-unit>
        <trans-unit id="709b98ad6555808775120e3c01cba15666c7c18d" translate="yes" xml:space="preserve">
          <source>Access to the table &lt;code&gt;pg_statistic&lt;/code&gt; is restricted to superusers, so that ordinary users cannot learn about the contents of the tables of other users from it. Some selectivity estimation functions will use a user-provided operator (either the operator appearing in the query or a related operator) to analyze the stored statistics. For example, in order to determine whether a stored most common value is applicable, the selectivity estimator will have to run the appropriate &lt;code&gt;=&lt;/code&gt; operator to compare the constant in the query to the stored value. Thus the data in &lt;code&gt;pg_statistic&lt;/code&gt; is potentially passed to user-defined operators. An appropriately crafted operator can intentionally leak the passed operands (for example, by logging them or writing them to a different table), or accidentally leak them by showing their values in error messages, in either case possibly exposing data from &lt;code&gt;pg_statistic&lt;/code&gt; to a user who should not be able to see it.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; テーブルへのアクセスはスーパーユーザーに制限されているため、一般ユーザーは他のユーザーのテーブルの内容を知ることができません。一部の選択性推定関数は、ユーザー提供の演算子（クエリに表示される演算子または関連する演算子）を使用して、格納されている統計を分析します。たとえば、保存されている最も一般的な値が適用可能かどうかを判断するために、選択性推定器は適切な &lt;code&gt;=&lt;/code&gt; 演算子を実行して、クエリ内の定数を保存されている値と比較する必要があります。したがって、 &lt;code&gt;pg_statistic&lt;/code&gt; のデータユーザー定義の演算子に渡される可能性があります。適切に作成された演算子は、渡されたオペランドを意図的にリークする（たとえば、ログに記録したり、別のテーブルに書き込んだりする）か、エラーメッセージに値を表示して誤ってリークする可能性があります。いずれの場合も、 &lt;code&gt;pg_statistic&lt;/code&gt; からのデータをそれを見ることができないはずです。</target>
        </trans-unit>
        <trans-unit id="a19557158b233d91213a81525eeee59ee4fa2d0a" translate="yes" xml:space="preserve">
          <source>Access-method-specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としてのアクセス方法固有のオプション</target>
        </trans-unit>
        <trans-unit id="bdebd3af85014736552b079e90a39e39b6b4b3f6" translate="yes" xml:space="preserve">
          <source>Accessing remote data may require authenticating to the external data source. This information can be provided by a &lt;em&gt;user mapping&lt;/em&gt;, which can provide additional data such as user names and passwords based on the current PostgreSQL role.</source>
          <target state="translated">リモートデータにアクセスするには、外部データソースへの認証が必要な場合があります。この情報は、現在のPostgreSQLの役割に基づいてユーザー名やパスワードなどの追加データを提供できる&lt;em&gt;ユーザーマッピング&lt;/em&gt;によって提供できます。</target>
        </trans-unit>
        <trans-unit id="52fe1ef73da9bdc5400467df47e965d263b34732" translate="yes" xml:space="preserve">
          <source>Accessor Operator</source>
          <target state="translated">アクセッサー演算子</target>
        </trans-unit>
        <trans-unit id="af39d0c333f65451fb8a7cecb17f3d648babe73c" translate="yes" xml:space="preserve">
          <source>Accessor operators listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;Table 8.25&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;表8.25に&lt;/a&gt;リストされているアクセサ演算子。</target>
        </trans-unit>
        <trans-unit id="a90102b6831b1be9c270ce8e277051052e425746" translate="yes" xml:space="preserve">
          <source>According to the SQL standard all fields of an interval value must have the same sign, so a leading negative sign applies to all fields; for example the negative sign in the interval literal &lt;code&gt;'-1 2:03:04'&lt;/code&gt; applies to both the days and hour/minute/second parts. PostgreSQL allows the fields to have different signs, and traditionally treats each field in the textual representation as independently signed, so that the hour/minute/second part is considered positive in this example. If &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt; then a leading sign is considered to apply to all fields (but only if no additional signs appear). Otherwise the traditional PostgreSQL interpretation is used. To avoid ambiguity, it's recommended to attach an explicit sign to each field if any field is negative.</source>
          <target state="translated">SQL標準によれば、時間隔値のすべてのフィールドは同じ符号を持つ必要があるため、先頭の負符号はすべてのフィールドに適用されます。たとえば、間隔リテラル &lt;code&gt;'-1 2:03:04'&lt;/code&gt; の負符号は、日と時間/分/秒の両方の部分に適用されます。 PostgreSQLでは、フィールドに異なる符号を付けることができます。従来、テキスト表現の各フィールドは個別に署名されたものとして扱われるため、この例では時間/分/秒の部分が正と見なされます。場合 &lt;code&gt;IntervalStyle&lt;/code&gt; に設定されている &lt;code&gt;sql_standard&lt;/code&gt; その後、先行符号はすべてのフィールドに適用されると見なされます（ただし、追加の符号が表示されない場合のみ）。それ以外の場合、従来のPostgreSQL解釈が使用されます。あいまいさを避けるために、いずれかのフィールドが負の場合は、各フィールドに明示的な符号を付けることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3aa4c2f095ab9191962811c65fa85311b6575f00" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, grant options can be granted to &lt;code&gt;PUBLIC&lt;/code&gt;; PostgreSQL only supports granting grant options to roles.</source>
          <target state="translated">SQL標準によると、付与オプションは &lt;code&gt;PUBLIC&lt;/code&gt; に付与できます。PostgreSQLは、ロールへの付与オプションの付与のみをサポートしています。</target>
        </trans-unit>
        <trans-unit id="b56b4e7b5de2231618fd8815a2cda445e53356b4" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, specifying either &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required in a &lt;code&gt;DROP&lt;/code&gt; command. No database system actually enforces that rule, but whether the default behavior is &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; varies across systems.</source>
          <target state="translated">SQL標準によれば、 &lt;code&gt;DROP&lt;/code&gt; コマンドでは &lt;code&gt;RESTRICT&lt;/code&gt; または &lt;code&gt;CASCADE&lt;/code&gt; のいずれかを指定する必要があります。実際にそのルールを適用するデータベースシステムはありませんが、デフォルトの動作が &lt;code&gt;RESTRICT&lt;/code&gt; か &lt;code&gt;CASCADE&lt;/code&gt; かはシステムによって異なります。</target>
        </trans-unit>
        <trans-unit id="2656819b0489db63b95d67c6ca681b0ebbff6d9d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the &lt;code&gt;PRIVILEGES&lt;/code&gt; key word in &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; is required. The SQL standard does not support setting the privileges on more than one object per command.</source>
          <target state="translated">SQL標準によれば、 &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; の &lt;code&gt;PRIVILEGES&lt;/code&gt; キーワードが必要です。SQL標準では、コマンドごとに複数のオブジェクトに権限を設定することはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="63bbcd2e4bc83757343815f2d0c5cf6131ae122b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the command to set this option is</source>
          <target state="translated">SQL標準によると、このオプションを設定するコマンドは</target>
        </trans-unit>
        <trans-unit id="4b8f45ef50c256265d9c97855d8b0d2a0f3dde8f" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the expressions in the output list should be computed before applying &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, or &lt;code&gt;LIMIT&lt;/code&gt;. This is obviously necessary when using &lt;code&gt;DISTINCT&lt;/code&gt;, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt;; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. PostgreSQL will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt; or &lt;code&gt;GROUP BY&lt;/code&gt;. (As a counterexample, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; clearly must evaluate &lt;code&gt;f(x)&lt;/code&gt; before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that &lt;code&gt;LIMIT&lt;/code&gt; will act to cut off the output from a set-returning function.</source>
          <target state="translated">SQL標準によれば、 &lt;code&gt;DISTINCT&lt;/code&gt; 、 &lt;code&gt;ORDER BY&lt;/code&gt; 、または &lt;code&gt;LIMIT&lt;/code&gt; を適用する前に、出力リストの式を計算する必要があります。 &lt;code&gt;DISTINCT&lt;/code&gt; を使用する場合、これは明らかに必要です。それ以外の場合は、どの値が区別されるのかが明確でないためです。ただし、多くの場合、 &lt;code&gt;ORDER BY&lt;/code&gt; および &lt;code&gt;LIMIT&lt;/code&gt; の後に出力式が計算されると便利です。; 特に、出力リストに揮発性または高価な関数が含まれている場合。この動作により、関数の評価の順序がより直感的になり、出力に表示されない行に対応する評価はありません。PostgreSQLは、それらの式が &lt;code&gt;DISTINCT&lt;/code&gt; 、 &lt;code&gt;ORDER BY&lt;/code&gt; 、または &lt;code&gt;GROUP BY&lt;/code&gt; で参照されていない限り、ソートおよび制限の後に出力式を効果的に評価します。（反例として、 &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; ソート前に &lt;code&gt;f(x)&lt;/code&gt; を明確に評価する必要があります。）セットを返す関数を含む出力式は、ソート後、制限前に効果的に評価されるため、 &lt;code&gt;LIMIT&lt;/code&gt; セットを返す関数からの出力を遮断するように動作します。</target>
        </trans-unit>
        <trans-unit id="6db467e85d8317c698e30a66a7291c8eafa6149b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the owner of a schema always owns all objects within it. PostgreSQL allows schemas to contain objects owned by users other than the schema owner. This can happen only if the schema owner grants the &lt;code&gt;CREATE&lt;/code&gt; privilege on their schema to someone else, or a superuser chooses to create objects in it.</source>
          <target state="translated">SQL標準によれば、スキーマの所有者は常にスキーマ内のすべてのオブジェクトを所有します。PostgreSQLでは、スキーマにスキーマ所有者以外のユーザーが所有するオブジェクトを含めることができます。これは、スキーマの所有者が自分のスキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権を他のユーザーに付与した場合、またはスーパーユーザーがその中にオブジェクトを作成することを選択した場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="3b39ba80593aea6c161c39dff62ffc2f0348762e" translate="yes" xml:space="preserve">
          <source>According to the comp.ai.genetic FAQ it cannot be stressed too strongly that a GA is not a pure random search for a solution to a problem. A GA uses stochastic processes, but the result is distinctly non-random (better than random).</source>
          <target state="translated">comp.ai.genetic FAQによると、GAは問題解決のための純粋なランダム探索ではないことを強く強調することはできません。GAは確率過程を使用しますが、その結果は明らかに非ランダム(ランダムよりも優れています)です。</target>
        </trans-unit>
        <trans-unit id="2666b06563be42700b836e6d4059dfb52c4a608d" translate="yes" xml:space="preserve">
          <source>According to the standard, the first two characters of an error code denote a class of errors, while the last three characters indicate a specific condition within that class. Thus, an application that does not recognize the specific error code might still be able to infer what to do from the error class.</source>
          <target state="translated">規格によると、エラーコードの最初の2文字はエラーのクラスを示し、最後の3文字はそのクラス内の特定の状態を示します。したがって、特定のエラーコードを認識しないアプリケーションでも、エラークラスから何をすべきかを推測することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="61abcddacf93fafde9cc0a4bb6f9d2b6e919d03c" translate="yes" xml:space="preserve">
          <source>According to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns. PostgreSQL only allows the source value to be a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt; or a sub-&lt;code&gt;SELECT&lt;/code&gt;. An individual column's updated value can be specified as &lt;code&gt;DEFAULT&lt;/code&gt; in the row-constructor case, but not inside a sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">標準によれば、ターゲット列名の括弧で囲まれたサブリストのソース値は、正しい数の列を生成する任意の行値式にすることができます。PostgreSQLでは、ソース値を&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;行コンストラクター&lt;/a&gt;またはサブ &lt;code&gt;SELECT&lt;/code&gt; にすることのみが可能です。個々の列の更新された値は、行コンストラクタの場合は &lt;code&gt;DEFAULT&lt;/code&gt; として指定できますが、サブ &lt;code&gt;SELECT&lt;/code&gt; 内では指定できません。</target>
        </trans-unit>
        <trans-unit id="0980056b7787afbd8fbd30571ba2c45b1dbaa749" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE INDEX&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; によって取得されます（ &lt;code&gt;CONCURRENTLY&lt;/code&gt; なし）。</target>
        </trans-unit>
        <trans-unit id="e44eba7914f83fb7f73f8f0a727d44ad52ee7677" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; および一部の形式の &lt;code&gt;ALTER TABLE&lt;/code&gt; によって取得されます（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c03704a90b839a00364666b3432c1fe877f7cfa4" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt; によって同時に取得されます。</target>
        </trans-unit>
        <trans-unit id="35b293b84736887604a4df3e4f117c1dcc96bdfc" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;), &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, and certain &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; variants (for full details see &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; （ &lt;code&gt;FULL&lt;/code&gt; なし）、 &lt;code&gt;ANALYZE&lt;/code&gt; 、 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 、 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 、 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 、特定の &lt;code&gt;ALTER INDEX&lt;/code&gt; および &lt;code&gt;ALTER TABLE&lt;/code&gt; バリアント（詳細については、&lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt;および&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）によって取得されます。</target>
        </trans-unit>
        <trans-unit id="4a64648cce36216f47287c3873ec5299a8307659" translate="yes" xml:space="preserve">
          <source>Acquired by the &lt;code&gt;DROP TABLE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;VACUUM FULL&lt;/code&gt;, and &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;) commands. Many forms of &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; also acquire a lock at this level. This is also the default lock mode for &lt;code&gt;LOCK TABLE&lt;/code&gt; statements that do not specify a mode explicitly.</source>
          <target state="translated">&lt;code&gt;DROP TABLE&lt;/code&gt; 、 &lt;code&gt;TRUNCATE&lt;/code&gt; 、 &lt;code&gt;REINDEX&lt;/code&gt; 、 &lt;code&gt;CLUSTER&lt;/code&gt; 、 &lt;code&gt;VACUUM FULL&lt;/code&gt; 、および &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; （ &lt;code&gt;CONCURRENTLY&lt;/code&gt; なし）コマンドによって取得されます。多くの形式の &lt;code&gt;ALTER INDEX&lt;/code&gt; および &lt;code&gt;ALTER TABLE&lt;/code&gt; も、このレベルでロックを取得します。これは、モードを明示的に指定しない &lt;code&gt;LOCK TABLE&lt;/code&gt; ステートメントのデフォルトのロックモードでもあります。</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="a43a7e7ff4a4d6f955aa729ae7ff758305e7b11f" translate="yes" xml:space="preserve">
          <source>Active txids at the time of the snapshot. The list includes only those active txids between &lt;code&gt;xmin&lt;/code&gt; and &lt;code&gt;xmax&lt;/code&gt;; there might be active txids higher than &lt;code&gt;xmax&lt;/code&gt;. A txid that is &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; and not in this list was already completed at the time of the snapshot, and thus either visible or dead according to its commit status. The list does not include txids of subtransactions.</source>
          <target state="translated">スナップショットの時点でアクティブなtxid。リストには、 &lt;code&gt;xmin&lt;/code&gt; と &lt;code&gt;xmax&lt;/code&gt; の間のアクティブなtxidのみが含まれます。 &lt;code&gt;xmax&lt;/code&gt; より高いアクティブなtxidが存在する可能性があります。あるTXID &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; なく、このリストには、すでにコミット状態に応じていずれかの可視又は死んだ従って、スナップショットの時点で完了しました。リストにはサブトランザクションのtxidは含まれていません。</target>
        </trans-unit>
        <trans-unit id="409557212ade1f78b39e4494cd71d7a5778b675f" translate="yes" xml:space="preserve">
          <source>Activity status of the WAL receiver process</source>
          <target state="translated">WAL受信プロセスのアクティビティ状況</target>
        </trans-unit>
        <trans-unit id="5074d759e3f5dbe3c6aa005b1369aadfa7087d57" translate="yes" xml:space="preserve">
          <source>Actual data stored in the large object. This will never be more than &lt;code&gt;LOBLKSIZE&lt;/code&gt; bytes and might be less.</source>
          <target state="translated">ラージオブジェクトに格納されている実際のデータ。これは &lt;code&gt;LOBLKSIZE&lt;/code&gt; バイトを超えることはなく、少なくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5cef4a325f0a5fb8a611f2f24f0d274a093ec734" translate="yes" xml:space="preserve">
          <source>Actually the preceding paragraph is an oversimplification: there are two cases in which a function-call construct will be treated as a cast request without having matched it to an actual function. If a function call &lt;code&gt;name&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;) does not exactly match any existing function, but &lt;code&gt;name&lt;/code&gt; is the name of a data type and &lt;code&gt;pg_cast&lt;/code&gt; provides a binary-coercible cast to this type from the type of &lt;code&gt;x&lt;/code&gt;, then the call will be construed as a binary-coercible cast. This exception is made so that binary-coercible casts can be invoked using functional syntax, even though they lack any function. Likewise, if there is no &lt;code&gt;pg_cast&lt;/code&gt; entry but the cast would be to or from a string type, the call will be construed as an I/O conversion cast. This exception allows I/O conversion casts to be invoked using functional syntax.</source>
          <target state="translated">実際、前の段落は過度に単純化されています。関数呼び出し構文が実際の関数と一致せずにキャスト要求として扱われる場合が2つあります。関数呼び出し場合 &lt;code&gt;name&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; は）正確に既存の機能と一致していないが、 &lt;code&gt;name&lt;/code&gt; データ・タイプの名前であり、 &lt;code&gt;pg_cast&lt;/code&gt; のはタイプからこのタイプのバイナリ強制可能キャストを提供し &lt;code&gt;x&lt;/code&gt; 、コールはAと解釈されますバイナリ強制キャスト。この例外は、たとえ関数が不足している場合でも、関数型構文を使用してバイナリ強制キャストを呼び出すことができるようにするために行われます。同様に、 &lt;code&gt;pg_cast&lt;/code&gt; がない場合エントリですが、キャストは文字列型への、または文字列型からのキャストである場合、呼び出しはI / O変換キャストとして解釈されます。この例外により、関数構文を使用してI / O変換キャストを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="99bd76b2471dd3de3de3ab7c1c222041031e9e64" translate="yes" xml:space="preserve">
          <source>Actually, each &amp;ldquo;character&amp;rdquo; can be any string not containing whitespace, so &lt;code&gt;unaccent&lt;/code&gt; dictionaries could be used for other sorts of substring substitutions besides diacritic removal.</source>
          <target state="translated">実際、各「文字」は空白を含まない任意の文字列にすることができるので、 &lt;code&gt;unaccent&lt;/code&gt; 記号のない辞書は、発音区別符号の削除以外の種類の部分文字列置換に使用できます。</target>
        </trans-unit>
        <trans-unit id="fb4a150119fee7c38df2ebe67adb1f04cd8a1672" translate="yes" xml:space="preserve">
          <source>Actually, in these example queries, &lt;code&gt;coalesce&lt;/code&gt; should be used to prevent a single &lt;code&gt;NULL&lt;/code&gt; attribute from causing a &lt;code&gt;NULL&lt;/code&gt; result for the whole document.</source>
          <target state="translated">実際、これらのクエリ例では、単一の &lt;code&gt;NULL&lt;/code&gt; 属性がドキュメント全体に &lt;code&gt;NULL&lt;/code&gt; の結果を引き起こすのを防ぐために、 &lt;code&gt;coalesce&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8f0894c46fc9b6047265c297cf124917360edc17" translate="yes" xml:space="preserve">
          <source>Actually, the even more general syntax</source>
          <target state="translated">実際には、さらに一般的な構文</target>
        </trans-unit>
        <trans-unit id="9d49dccdc43481d06a4ef58b29107551c088b828" translate="yes" xml:space="preserve">
          <source>Adaptive?</source>
          <target state="translated">Adaptive?</target>
        </trans-unit>
        <trans-unit id="4415296784c0ee879898fb9df132309b61a61a7c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt; or &lt;code&gt;--column-inserts&lt;/code&gt; is also specified.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; コマンドに &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; を追加します。このオプションは、 &lt;code&gt;--inserts&lt;/code&gt; または &lt;code&gt;--column-inserts&lt;/code&gt; も指定されていない限り無効です。</target>
        </trans-unit>
        <trans-unit id="6e9832f60aad6d89585289ea2e0edf7fc9e5b79b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt;, &lt;code&gt;--column-inserts&lt;/code&gt; or &lt;code&gt;--rows-per-insert&lt;/code&gt; is also specified.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; コマンドに &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; を追加します。このオプションは、 &lt;code&gt;--column-inserts&lt;/code&gt; &lt;code&gt;--inserts&lt;/code&gt; 、-- column- &lt;code&gt;--rows-per-insert&lt;/code&gt; または--rows-per-insertも指定されていない限り無効です。</target>
        </trans-unit>
        <trans-unit id="df59723089709ab5e5075047c1ac7d254b3f6b22" translate="yes" xml:space="preserve">
          <source>Add a key, or update an existing key with a new value:</source>
          <target state="translated">キーを追加したり、既存のキーを新しい値で更新したりします。</target>
        </trans-unit>
        <trans-unit id="bacadfab25c06160832a539f1c1f1901edb824fd" translate="yes" xml:space="preserve">
          <source>Add a transaction script read from &lt;code&gt;filename&lt;/code&gt; to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the test. See below for details.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; から読み取ったトランザクションスクリプトを実行済みスクリプトのリストに追加します。 &lt;code&gt;@&lt;/code&gt; の後にオプションの整数の重みを付けると、テストを描画する確率を調整できます。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="b612d09d7cda7883ad9f9c1e74b2026a76de08a5" translate="yes" xml:space="preserve">
          <source>Add columns</source>
          <target state="translated">列の追加</target>
        </trans-unit>
        <trans-unit id="fdd20704520d17d4473df8ba637e593e3c1e9d32" translate="yes" xml:space="preserve">
          <source>Add constraints</source>
          <target state="translated">制約の追加</target>
        </trans-unit>
        <trans-unit id="7ee44cc339a6c285bac845e10d98461ab1145004" translate="yes" xml:space="preserve">
          <source>Add non-overlapping table constraints to the child tables to define the allowed key values in each.</source>
          <target state="translated">重複しないテーブル制約を子テーブルに追加して、それぞれのテーブルで許可されるキー値を定義します。</target>
        </trans-unit>
        <trans-unit id="48999cb16b06daffee5cbba84a68d9e3c43940fe" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the function is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the function-local setting is removed, so that the function executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all function-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">関数が呼び出されたときに構成パラメーターに行われる割り当てを追加または変更します。場合 &lt;code&gt;value&lt;/code&gt; である &lt;code&gt;DEFAULT&lt;/code&gt; または、等価的に、 &lt;code&gt;RESET&lt;/code&gt; が使用され、関数のローカル設定が除去され、その結果、その環境中に存在する値との関数を実行します。すべての機能ローカル設定をクリアするには、 &lt;code&gt;RESET ALL&lt;/code&gt; を使用します。 &lt;code&gt;SET FROM CURRENT&lt;/code&gt; は、 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; が実行されたときに現在のパラメーターの値を、関数に入ったときに適用される値として保存します。</target>
        </trans-unit>
        <trans-unit id="741a6eebd9634b6405712ee7bced8a90249de64a" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the procedure is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the procedure-local setting is removed, so that the procedure executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all procedure-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">プロシージャが呼び出されたときに構成パラメータに行われる割り当てを追加または変更します。場合 &lt;code&gt;value&lt;/code&gt; である &lt;code&gt;DEFAULT&lt;/code&gt; または、等価的に、 &lt;code&gt;RESET&lt;/code&gt; が使用され、手順、ローカル設定が除去され、その結果、その環境中に存在する値を有する手順を実行します。すべてのプロシージャローカル設定をクリアするには、 &lt;code&gt;RESET ALL&lt;/code&gt; を使用します。 &lt;code&gt;SET FROM CURRENT&lt;/code&gt; は、 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; の実行時に現在のパラメーターの値を、プロシージャーの入力時に適用される値として保存します。</target>
        </trans-unit>
        <trans-unit id="3e939370f13d4d6648fdf6ebce042de2b0c8b35d" translate="yes" xml:space="preserve">
          <source>Add some tables to the publication:</source>
          <target state="translated">出版物にいくつかの表を追加します。</target>
        </trans-unit>
        <trans-unit id="0adf6644f343dab5da55bc308f3c6ee3087cbd49" translate="yes" xml:space="preserve">
          <source>Add the new column, with a default, to &lt;code&gt;pg_proc.h&lt;/code&gt;:</source>
          <target state="translated">新しい列をデフォルトで &lt;code&gt;pg_proc.h&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="752268a69e3b24883f304a215dae5d50dea7c0b0" translate="yes" xml:space="preserve">
          <source>Add the probe definition to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;:</source>
          <target state="translated">プローブ定義を &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="ce0fb0fdfabd7e1bdcafb562c60398cbe55ebe0d" translate="yes" xml:space="preserve">
          <source>Add the probe definitions to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;</source>
          <target state="translated">プローブ定義を &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; に追加します</target>
        </trans-unit>
        <trans-unit id="4acf1110e0d52a03ba3a64c356b491cd2bd51279" translate="yes" xml:space="preserve">
          <source>Add the specified built-in script to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the script. If not specified, it is set to 1. Available built-in scripts are: &lt;code&gt;tpcb-like&lt;/code&gt;, &lt;code&gt;simple-update&lt;/code&gt; and &lt;code&gt;select-only&lt;/code&gt;. Unambiguous prefixes of built-in names are accepted. With special name &lt;code&gt;list&lt;/code&gt;, show the list of built-in scripts and exit immediately.</source>
          <target state="translated">指定した組み込みスクリプトを実行済みスクリプトのリストに追加します。 &lt;code&gt;@&lt;/code&gt; の後にオプションの整数の重みを付けると、スクリプトを描画する確率を調整できます。指定しない場合、1に設定されます。使用可能な組み込みスクリプトは、 &lt;code&gt;tpcb-like&lt;/code&gt; 、 &lt;code&gt;simple-update&lt;/code&gt; 、および &lt;code&gt;select-only&lt;/code&gt; です。組み込み名の明確な接頭辞が受け入れられます。特別な名前 &lt;code&gt;list&lt;/code&gt; を使用して、組み込みスクリプトのリストを表示し、すぐに終了します。</target>
        </trans-unit>
        <trans-unit id="c0ab5a63742ff89241c46899c37233e1df7c86b0" translate="yes" xml:space="preserve">
          <source>Add users to a group:</source>
          <target state="translated">ユーザーをグループに追加します。</target>
        </trans-unit>
        <trans-unit id="8caea2f156f156f661ed21fc3f27f4bbd2fa80f2" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;NOT NULL&lt;/code&gt; constraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite.</source>
          <target state="translated">&lt;code&gt;CHECK&lt;/code&gt; または &lt;code&gt;NOT NULL&lt;/code&gt; 制約を追加するには、テーブルをスキャンして既存の行が制約を満たすことを確認する必要がありますが、テーブルの書き換えは必要ありません。</target>
        </trans-unit>
        <trans-unit id="cffe5a53117b776e99930ab76048f8855b384b5a" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 制約を追加すると、制約で使用される列または列のグループに一意のbtreeインデックスが自動的に作成されます。オプションの &lt;code&gt;INCLUDE&lt;/code&gt; 句を使用すると、インデックスの非キー部分に含まれる列のリストを指定できます。含まれる列には一意性は適用されませんが、制約は依然として列に依存します。その結果、含まれている列に対するいくつかの操作（例： &lt;code&gt;DROP COLUMN&lt;/code&gt; ）は、カスケードされた制約とインデックスの削除を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="c642f86413e7e0c5d8cf9f40dd1b146f4c06e416" translate="yes" xml:space="preserve">
          <source>Adding a column with a volatile &lt;code&gt;DEFAULT&lt;/code&gt; or changing the type of an existing column will require the entire table and its indexes to be rewritten. As an exception, when changing the type of an existing column, if the &lt;code&gt;USING&lt;/code&gt; clause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed; but any indexes on the affected columns must still be rebuilt. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space.</source>
          <target state="translated">揮発性の &lt;code&gt;DEFAULT&lt;/code&gt; を持つ列を追加するか、既存の列のタイプを変更するには、テーブル全体とそのインデックスを書き換える必要があります。例外として、既存の列のタイプを変更する場合、 &lt;code&gt;USING&lt;/code&gt; 句が列の内容を変更せず、古いタイプが新しいタイプにバイナリ強制可能であるか、または新しいタイプに対して制約のないドメインである場合、テーブルの書き換えは不要です。 ;ただし、影響を受ける列のインデックスは引き続き再構築する必要があります。大きなテーブルの場合、テーブルやインデックスの再構築にかなりの時間がかかることがあります。一時的に2倍のディスク容量が必要になります。</target>
        </trans-unit>
        <trans-unit id="c58efc1059381c4bf8b362143436cd8c4af55346" translate="yes" xml:space="preserve">
          <source>Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index using &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, and then install it as an official constraint using this syntax. See the example below.</source>
          <target state="translated">既存のインデックスを使用して制約を追加すると、テーブルの更新を長時間ブロックせずに新しい制約を追加する必要がある場合に役立ちます。これを行うには、 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; を使用してインデックスを作成し、この構文を使用して公式の制約としてインストールします。以下の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="c57d929aced463125ab8b2f66f31b21a04522c5d" translate="yes" xml:space="preserve">
          <source>Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">主キーを追加すると、主キーにリストされた列または列のグループに一意のBツリーインデックスが自動的に作成され、列が &lt;code&gt;NOT NULL&lt;/code&gt; とマークされます。</target>
        </trans-unit>
        <trans-unit id="4ee5dc2437e432908c48ca918b4296acc2f6a028" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a unique &lt;a href=&quot;indexes-partial&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">一意の制約を追加すると、制約にリストされている列または列のグループに一意のBツリーインデックスが自動的に作成されます。一部の行のみを対象とする一意性制限は、一意性制約として書き込むことはできませんが、一意の&lt;a href=&quot;indexes-partial&quot;&gt;部分インデックスを&lt;/a&gt;作成することにより、このような制限を強制することができます。</target>
        </trans-unit>
        <trans-unit id="1e5ef315a51bb0b0043f1a6d7277abada165d078" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">一意の制約を追加すると、制約で使用される列または列のグループに一意のbtreeインデックスが自動的に作成されます。オプションの &lt;code&gt;INCLUDE&lt;/code&gt; 句は、一意性が強制されない1つ以上の列をそのインデックスに追加します。制約は含まれている列には適用されませんが、それでもそれらに依存することに注意してください。その結果、これらの列に対するいくつかの操作（たとえば、 &lt;code&gt;DROP COLUMN&lt;/code&gt; ）は、カスケードされた制約とインデックスの削除を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="8bcad53930a4507d157767aa00d4a8d4f833266c" translate="yes" xml:space="preserve">
          <source>Adding an exclusion constraint will automatically create an index of the type specified in the constraint declaration.</source>
          <target state="translated">除外制約を追加すると、制約宣言で指定された型のインデックスが自動的に作成されます。</target>
        </trans-unit>
        <trans-unit id="7173dacda23801ef619f4e60a2645585a6fe0048" translate="yes" xml:space="preserve">
          <source>Adding parentheses around an RE does not change its greediness.</source>
          <target state="translated">REの周りに括弧を付けても欲張りさは変わりません。</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="65d284b9baecd42d63cb154eecd228122b272bd2" translate="yes" xml:space="preserve">
          <source>Addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table receiving the constraint.</source>
          <target state="translated">外部キー制約を追加するには、制約を受け取るテーブルのロックに加えて、参照されるテーブルの &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; ロックが必要です。</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">追加機能</target>
        </trans-unit>
        <trans-unit id="89c24238b1c616d3f7452d5dd9217a02ce8ecaf1" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.13&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.12&lt;/a&gt;.</source>
          <target state="translated">追加のバイナリ文字列操作関数が利用可能で、&lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;表9.13に&lt;/a&gt;リストされています。それらの一部は、&lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;表9.12に&lt;/a&gt;リストされているSQL標準の文字列関数を実装するために内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="9e5fd4e93e599bcb1fb3d2db4b33749ab6dcc12b" translate="yes" xml:space="preserve">
          <source>Additional considerations apply to the use of generated columns.</source>
          <target state="translated">生成された列の使用には、追加の考慮事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="aa325cbf6ead34348f2e89548944a03a6c03ebc9" translate="yes" xml:space="preserve">
          <source>Additional discussion and practical examples can be found in &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;.</source>
          <target state="translated">追加の説明と実際の例は、&lt;a href=&quot;ddl-rowsecurity&quot;&gt;セクション5.8にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1fbe8c837563c2f0daf28f682cb1a5ab1ec6f6fe" translate="yes" xml:space="preserve">
          <source>Additional enhancements by Andrew Gierth &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;, United Kingdom</source>
          <target state="translated">Andrew Gierth &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt; による追加の機能強化、イギリス</target>
        </trans-unit>
        <trans-unit id="0ef08f4faa1371707ef2f6feef718bf54953d0e6" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="translated">PL / PerlおよびPL / Python言語の &lt;code&gt;hstore&lt;/code&gt; タイプの変換を実装する追加の拡張機能が利用可能です。 PL / Perlの拡張機能は、信頼できるPL / Perlと信頼できないPL / Perlの &lt;code&gt;hstore_plperl&lt;/code&gt; および &lt;code&gt;hstore_plperlu&lt;/code&gt; と呼ばれます。これらの変換をインストールし、関数の作成時にそれらを指定すると、 &lt;code&gt;hstore&lt;/code&gt; 値はPerlハッシュにマップされます。 PL / Pythonの拡張機能は、 &lt;code&gt;hstore_plpythonu&lt;/code&gt; 、 &lt;code&gt;hstore_plpython2u&lt;/code&gt; 、および &lt;code&gt;hstore_plpython3u&lt;/code&gt; と呼ばれます（PL / Pythonの命名規則については、&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;セクション45.1&lt;/a&gt;を参照してください）。それらを使用する場合、 &lt;code&gt;hstore&lt;/code&gt; 値はPython辞書にマップされます。</target>
        </trans-unit>
        <trans-unit id="d6954bc39f2ef60e2e03ec59460cfa1e30432da9" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;jsonb&lt;/code&gt; type for different procedural languages.</source>
          <target state="translated">さまざまな手続き型言語の &lt;code&gt;jsonb&lt;/code&gt; タイプの変換を実装する追加の拡張機能が利用可能です。</target>
        </trans-unit>
        <trans-unit id="041eecca386b7ca679e006e4c9dbf17a8a23f03a" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="translated">PL / Pythonの &lt;code&gt;ltree&lt;/code&gt; タイプの変換を実装する追加の拡張機能が利用可能です。拡張機能は、 &lt;code&gt;ltree_plpythonu&lt;/code&gt; 、 &lt;code&gt;ltree_plpython2u&lt;/code&gt; 、および &lt;code&gt;ltree_plpython3u&lt;/code&gt; と呼ばれます（PL / Pythonの命名規則については、&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;セクション45.1&lt;/a&gt;を参照してください）。これらの変換をインストールし、関数の作成時にそれらを指定すると、 &lt;code&gt;ltree&lt;/code&gt; 値はPythonリストにマップされます。（ただし、その逆は現在サポートされていません。）</target>
        </trans-unit>
        <trans-unit id="848e3ef5eb869b4a42890d26de458d77b4145059" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.20&lt;/a&gt;.</source>
          <target state="translated">統計収集に関連する追加の関数を&lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;表27.20に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="77a49395f2c7e958118c2da8e1de4c14e6b60602" translate="yes" xml:space="preserve">
          <source>Additional information about how to invoke the function. Again, the interpretation is language-specific.</source>
          <target state="translated">関数の呼び出し方についての追加情報。繰り返しになりますが、解釈は言語固有のものです。</target>
        </trans-unit>
        <trans-unit id="284dcb5991a8da2d3edb0ed1251edf3e8b725229" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">サブスクリプションおよび論理レプリケーション全体に関する追加情報は、&lt;a href=&quot;logical-replication-subscription&quot;&gt;セクション30.2&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;第30章にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9eacaa0140464ef9b6f84f47defe84ade132e976" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;code&gt;width&lt;/code&gt; field is also specified.</source>
          <target state="translated">フォーマット指定子の出力のフォーマット方法を制御する追加オプション。現在サポートされている唯一のフラグはマイナス記号（ &lt;code&gt;-&lt;/code&gt; ）で、これによりフォーマット指定子の出力が左揃えになります。 &lt;code&gt;width&lt;/code&gt; フィールドも指定しない限り、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="2fdddce1ec06b246bce73843e8826c300263ddb0" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique indexes are applied to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">一意のインデックスがパーティション分割されたテーブルに適用される場合、追加の制限が適用されます。&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9379cab208a52cab9a14d1960740e0e9980c40a5" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique or primary key constraints are added to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. Also, foreign key constraints on partitioned tables may not be declared &lt;code&gt;NOT VALID&lt;/code&gt; at present.</source>
          <target state="translated">パーティションテーブルに一意キー制約または主キー制約を追加すると、追加の制限が適用されます。&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEを&lt;/a&gt;参照してください。また、パーティション化されたテーブルの外部キー制約は、現時点では &lt;code&gt;NOT VALID&lt;/code&gt; と宣言されていない場合があります。</target>
        </trans-unit>
        <trans-unit id="d8765f8e8e885763ce10457dabe0ae485bb31d5b" translate="yes" xml:space="preserve">
          <source>Additional string manipulation functions are available and are listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;Table 9.10&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;.</source>
          <target state="translated">追加の文字列操作関数が利用可能で、&lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;表9.10に&lt;/a&gt;リストされています。それらの一部は、&lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;表9.9&lt;/a&gt;に示す SQL標準の文字列関数を実装するために内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="010f13497a3e5b588a77355b773385544bc33904" translate="yes" xml:space="preserve">
          <source>Additional updates were made by Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; in July 2006. These include &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; and cleaning up the code to use the V1 call protocol instead of the deprecated V0 protocol.</source>
          <target state="translated">追加の更新は、2006年7月にJoshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; によって行われました。これらには、 &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; および非推奨のV0プロトコルの代わりにV1呼び出しプロトコルを使用するコードのクリーンアップが含まれます。</target>
        </trans-unit>
        <trans-unit id="a5f30130c7eb4575fcc776243da7a4179d9cf6f4" translate="yes" xml:space="preserve">
          <source>Additional, more detailed, description of the parameter</source>
          <target state="translated">パラメータの追加、より詳細な説明</target>
        </trans-unit>
        <trans-unit id="f10aed98f8a0fbbcdcab810e37d64419e4b89806" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;em&gt;comments&lt;/em&gt; can occur in SQL input. They are not tokens, they are effectively equivalent to whitespace.</source>
          <target state="translated">さらに、&lt;em&gt;コメント&lt;/em&gt;はSQL入力で発生する可能性があります。これらはトークンではなく、空白と実質的に同等です。</target>
        </trans-unit>
        <trans-unit id="3ce7d7c047715fd1454a60e6f8ab9c8a858ce3b2" translate="yes" xml:space="preserve">
          <source>Additionally, an alias is required if the table reference is a subquery (see &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;Section 7.2.1.3&lt;/a&gt;).</source>
          <target state="translated">さらに、テーブル参照がサブクエリの場合は、エイリアスが必要です（&lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;セクション7.2.1.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2987436262917a5192b10eeed405ee0544038a4c" translate="yes" xml:space="preserve">
          <source>Additionally, if a query usually requires an implicit conversion for a function, and if then the user defines a new function with the correct argument types, the parser should use this new function and no longer do implicit conversion to use the old function.</source>
          <target state="translated">さらに、クエリが通常関数の暗黙の変換を必要とする場合、ユーザーが正しい引数型を持つ新しい関数を定義した場合、パーサはこの新しい関数を使用し、古い関数を使用するために暗黙の変換を行わないようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="0a6ee1654a9731eebc2384fd193841ff3bb1bd0e" translate="yes" xml:space="preserve">
          <source>Additionally, if you are running PostgreSQL inside a zone, you may need to raise the zone resource usage limits as well. See &quot;Chapter2: Projects and Tasks&quot; in the &lt;em&gt;System Administrator's Guide&lt;/em&gt; for more information on &lt;code&gt;projects&lt;/code&gt; and &lt;code&gt;prctl&lt;/code&gt;.</source>
          <target state="translated">さらに、PostgreSQLをゾーン内で実行している場合は、ゾーンのリソース使用制限も引き上げる必要がある場合があります。 &lt;code&gt;projects&lt;/code&gt; と &lt;code&gt;prctl&lt;/code&gt; の詳細については、 『&lt;em&gt;システム管理者ガイド&lt;/em&gt;』の「第2章：プロジェクトとタスク」を&lt;em&gt;参照&lt;/em&gt;してください。</target>
        </trans-unit>
        <trans-unit id="0aee321f704c4c1848fccdf5704c469a83987cc5" translate="yes" xml:space="preserve">
          <source>Additionally, refresh options as described under &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; may be specified.</source>
          <target state="translated">さらに、 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; で説明されている更新オプションを指定できます。</target>
        </trans-unit>
        <trans-unit id="78567ce71a3b54c604529593f06074abcf105927" translate="yes" xml:space="preserve">
          <source>Additionally, the SQL standard collation name &lt;code&gt;ucs_basic&lt;/code&gt; is available for encoding &lt;code&gt;UTF8&lt;/code&gt;. It is equivalent to &lt;code&gt;C&lt;/code&gt; and sorts by Unicode code point.</source>
          <target state="translated">さらに、SQL標準照合名 &lt;code&gt;ucs_basic&lt;/code&gt; を &lt;code&gt;UTF8&lt;/code&gt; のエンコードに使用できます。これは &lt;code&gt;C&lt;/code&gt; に相当し、Unicodeコードポイントで並べ替えます。</target>
        </trans-unit>
        <trans-unit id="d3c767351a24f76f0563dcac6f0be4bd35c8869c" translate="yes" xml:space="preserve">
          <source>Adjust interval so 24-hour time periods are represented as days</source>
          <target state="translated">24時間の時間帯が日として表現されるように間隔を調整します。</target>
        </trans-unit>
        <trans-unit id="7279c011b0d2f4cdb22e6caf6d21633e1e395dfa" translate="yes" xml:space="preserve">
          <source>Adjust interval so 30-day time periods are represented as months</source>
          <target state="translated">30日の期間が月として表現されるように間隔を調整します。</target>
        </trans-unit>
        <trans-unit id="0d09f290462815bf94d7d19b5220a29471c8dd87" translate="yes" xml:space="preserve">
          <source>Adjust interval using &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt;, with additional sign adjustments</source>
          <target state="translated">&lt;code&gt;justify_days&lt;/code&gt; と &lt;code&gt;justify_hours&lt;/code&gt; を使用して間隔を調整し、さらに符号調整を行う</target>
        </trans-unit>
        <trans-unit id="d5274237f32eaf0cd335b0f45d9e9e406fe2937c" translate="yes" xml:space="preserve">
          <source>Adjust temperature entries and reset precipitation to its default value in one row of the table &lt;code&gt;weather&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;weather&lt;/code&gt; の表の1行で、温度エントリを調整し、降水量をデフォルト値にリセットします。</target>
        </trans-unit>
        <trans-unit id="597cf96132dd221de223e71df7ddc2feda8ca0e0" translate="yes" xml:space="preserve">
          <source>Adjustable printing options are:</source>
          <target state="translated">調整可能な印刷オプションがあります。</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="25a6044596d068aa8f0b03a3756a046b4662f84e" translate="yes" xml:space="preserve">
          <source>Administration Functions</source>
          <target state="translated">管理機能</target>
        </trans-unit>
        <trans-unit id="9ff417ada04d397f658792af845a2743c3df515c" translate="yes" xml:space="preserve">
          <source>Administrators can grant access to these roles to users using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command, for example:</source>
          <target state="translated">管理者は、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;コマンドを使用して、これらのロールへのアクセスをユーザーに付与できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="5748ca9fbce0c666d06fe84d7811e46cfd6b343d" translate="yes" xml:space="preserve">
          <source>Advance sequence and return new value</source>
          <target state="translated">シーケンスを進めて新しい値を返す</target>
        </trans-unit>
        <trans-unit id="4d638e9190ad6b08f1c75c8684e03ac19dde11c0" translate="yes" xml:space="preserve">
          <source>Advance the sequence object to its next value and return that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value.</source>
          <target state="translated">シーケンスオブジェクトを次の値に進め、その値を返します。これはアトミックに行われます。複数のセッションが &lt;code&gt;nextval&lt;/code&gt; を同時に実行した場合でも、それぞれが安全に異なるシーケンス値を受け取ります。</target>
        </trans-unit>
        <trans-unit id="05743e363937b509ed8a8c4f9befec86cf089852" translate="yes" xml:space="preserve">
          <source>Advanced Configuration and Power Interface (ACPI) provides a Power Management (PM) Timer, which Linux refers to as the acpi_pm. The clock derived from acpi_pm will at best provide 300 nanosecond resolution.</source>
          <target state="translated">ACPI (Advanced Configuration and Power Interface)は、Linux では acpi_pm と呼ばれるパワーマネージメント (PM)タイマーを提供しています。acpi_pm から派生したクロックは、最高でも 300 ナノ秒の分解能を提供します。</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高度な機能</target>
        </trans-unit>
        <trans-unit id="40fdbd870880a4ac68ea44233cfb9a2306bc99de" translate="yes" xml:space="preserve">
          <source>Advanced users can use regular-expression notations such as character classes, for example &lt;code&gt;[0-9]&lt;/code&gt; to match any digit. All regular expression special characters work as specified in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;, except for &lt;code&gt;.&lt;/code&gt; which is taken as a separator as mentioned above, &lt;code&gt;*&lt;/code&gt; which is translated to the regular-expression notation &lt;code&gt;.*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; which is translated to &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;$&lt;/code&gt; which is matched literally. You can emulate these pattern characters at need by writing &lt;code&gt;?&lt;/code&gt; for &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;(R+|)&lt;/code&gt; for &lt;code&gt;R*&lt;/code&gt;, or &lt;code&gt;(R|)&lt;/code&gt; for &lt;code&gt;R?&lt;/code&gt;. &lt;code&gt;$&lt;/code&gt; is not needed as a regular-expression character since the pattern must match the whole name, unlike the usual interpretation of regular expressions (in other words, &lt;code&gt;$&lt;/code&gt; is automatically appended to your pattern). Write &lt;code&gt;*&lt;/code&gt; at the beginning and/or end if you don't wish the pattern to be anchored. Note that within double quotes, all regular expression special characters lose their special meanings and are matched literally. Also, the regular expression special characters are matched literally in operator name patterns (i.e., the argument of &lt;code&gt;\do&lt;/code&gt;).</source>
          <target state="translated">上級ユーザーは、 &lt;code&gt;[0-9]&lt;/code&gt; などの文字クラスなどの正規表現表記を使用して、任意の数字を照合できます。を除くすべての正規表現特殊文字は、&lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3項で&lt;/a&gt;指定されているとおりに機能し &lt;code&gt;.&lt;/code&gt; これは上述のようにセパレータとして取られ、 &lt;code&gt;*&lt;/code&gt; 正規表現表記に変換されますか &lt;code&gt;.*&lt;/code&gt; 、 &lt;code&gt;?&lt;/code&gt; に翻訳され &lt;code&gt;.&lt;/code&gt; 、および文字通り一致する &lt;code&gt;$&lt;/code&gt; 。これらのパターン文字を必要に応じてエミュレートするには、 &lt;code&gt;?&lt;/code&gt; のために &lt;code&gt;.&lt;/code&gt; 、 &lt;code&gt;(R+|)&lt;/code&gt; のための &lt;code&gt;R*&lt;/code&gt; 、または &lt;code&gt;(R|)&lt;/code&gt; のための &lt;code&gt;R?&lt;/code&gt; 。 &lt;code&gt;$&lt;/code&gt; 正規表現の通常の解釈とは異なり、パターンは名前全体と一致する必要があるため、$は正規表現文字として必要ありません（つまり、 &lt;code&gt;$&lt;/code&gt; はパターンに自動的に追加されます）。書き込みは &lt;code&gt;*&lt;/code&gt; 最初および/または最後に、あなたはパターンが固定されたくない場合。二重引用符内では、すべての正規表現の特殊文字は特別な意味を失い、文字どおりに一致します。また、正規表現の特殊文字は、演算子名パターン（つまり、 &lt;code&gt;\do&lt;/code&gt; 引数）で文字どおり一致します。</target>
        </trans-unit>
        <trans-unit id="ae1d5d5862d5067d5253f55fa2d10173937d4fc6" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns name of the slot and real position to which it was advanced to.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt;という名前の複製スロットの現在確認されている位置を&lt;em&gt;進め&lt;/em&gt;ます。スロットは後方に移動されず、現在の挿入位置を超えて移動されません。スロットの名前と、それが進んだ先の実際の位置を返します。</target>
        </trans-unit>
        <trans-unit id="9d323581d870eb70c61501cdd5933132dd855a86" translate="yes" xml:space="preserve">
          <source>Advisory locks can be acquired on keys consisting of either a single &lt;code&gt;bigint&lt;/code&gt; value or two integer values. A &lt;code&gt;bigint&lt;/code&gt; key is displayed with its high-order half in the &lt;code&gt;classid&lt;/code&gt; column, its low-order half in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 1. The original &lt;code&gt;bigint&lt;/code&gt; value can be reassembled with the expression &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt;. Integer keys are displayed with the first key in the &lt;code&gt;classid&lt;/code&gt; column, the second key in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 2. The actual meaning of the keys is up to the user. Advisory locks are local to each database, so the &lt;code&gt;database&lt;/code&gt; column is meaningful for an advisory lock.</source>
          <target state="translated">アドバイザリロックは、1つの &lt;code&gt;bigint&lt;/code&gt; 値または2つの整数値で構成されるキーで取得できます。 &lt;code&gt;bigint&lt;/code&gt; キーでその上位半分で表示され &lt;code&gt;classid&lt;/code&gt; カラム、その下位に半分 &lt;code&gt;objid&lt;/code&gt; 列、及び &lt;code&gt;objsubid&lt;/code&gt; 1に等しいが、元の &lt;code&gt;bigint&lt;/code&gt; 値を式で再組立てすることができる &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt; 。整数キーは、最初のキーで表示され &lt;code&gt;classid&lt;/code&gt; 列に第2の鍵 &lt;code&gt;objid&lt;/code&gt; 列、及び &lt;code&gt;objsubid&lt;/code&gt; キーの実際の意味はユーザに任されて2に等しいです。アドバイザリロックは各データベースに対してローカルであるため、 &lt;code&gt;database&lt;/code&gt; 列は、勧告的ロックにとって意味があります。</target>
        </trans-unit>
        <trans-unit id="f6c29c3eec39081073449cf551f29f5ff2063ec1" translate="yes" xml:space="preserve">
          <source>Advisory locks work normally in recovery, including deadlock detection. Note that advisory locks are never WAL logged, so it is impossible for an advisory lock on either the primary or the standby to conflict with WAL replay. Nor is it possible to acquire an advisory lock on the primary and have it initiate a similar advisory lock on the standby. Advisory locks relate only to the server on which they are acquired.</source>
          <target state="translated">アドバイザリロックは、デッドロックの検出を含め、リカバリ時には正常に動作します。勧告ロックは決して WAL ログに記録されないため、プライマリまたはスタンバイのいずれかで勧告ロックが WAL 再生と競合することはありえないことに注意してください。また、プライマリ上のアドバイザリロックを取得して、それがスタンバイ上で同様のアドバイザリロックを開始させることもできません。アドバイザリロックは、取得したサーバにのみ関係します。</target>
        </trans-unit>
        <trans-unit id="87db6f29dc76387bbaab5ded1909ba41ea3e370f" translate="yes" xml:space="preserve">
          <source>After a checkpoint has been made and the log flushed, the checkpoint's position is saved in the file &lt;code&gt;pg_control&lt;/code&gt;. Therefore, at the start of recovery, the server first reads &lt;code&gt;pg_control&lt;/code&gt; and then the checkpoint record; then it performs the REDO operation by scanning forward from the log location indicated in the checkpoint record. Because the entire content of data pages is saved in the log on the first page modification after a checkpoint (assuming &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is not disabled), all pages changed since the checkpoint will be restored to a consistent state.</source>
          <target state="translated">チェックポイントが作成され、ログがフラッシュされた後、チェックポイントの位置が &lt;code&gt;pg_control&lt;/code&gt; ファイルに保存されます。したがって、リカバリの開始時に、サーバーは最初に &lt;code&gt;pg_control&lt;/code&gt; を読み取り、次にチェックポイントレコードを読み取ります。次に、チェックポイントレコードに示されているログの場所から前方にスキャンしてREDO操作を実行します。チェックポイント後の最初のページ変更時にデータページのコンテンツ全体がログに保存されるため（&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;が無効になっていないと想定）、チェックポイント以降のすべてのページが変更され、一貫した状態に復元されます。</target>
        </trans-unit>
        <trans-unit id="c70bb87984515ab084a4a6675924bc032765ff87" translate="yes" xml:space="preserve">
          <source>After a commit record has been written to disk on the primary, the WAL record is then sent to the standby. The standby sends reply messages each time a new batch of WAL data is written to disk, unless &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; is set to zero on the standby. In the case that &lt;code&gt;synchronous_commit&lt;/code&gt; is set to &lt;code&gt;remote_apply&lt;/code&gt;, the standby sends reply messages when the commit record is replayed, making the transaction visible. If the standby is chosen as a synchronous standby, according to the setting of &lt;code&gt;synchronous_standby_names&lt;/code&gt; on the primary, the reply messages from that standby will be considered along with those from other synchronous standbys to decide when to release transactions waiting for confirmation that the commit record has been received. These parameters allow the administrator to specify which standby servers should be synchronous standbys. Note that the configuration of synchronous replication is mainly on the master. Named standbys must be directly connected to the master; the master knows nothing about downstream standby servers using cascaded replication.</source>
          <target state="translated">コミットレコードがプライマリのディスクに書き込まれた後、WALレコードがスタンバイに送信されます。スタンバイで &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; がゼロに設定されていない限り、スタンバイはWALデータの新しいバッチがディスクに書き込まれるたびに応答メッセージを送信します。 &lt;code&gt;synchronous_commit&lt;/code&gt; が &lt;code&gt;remote_apply&lt;/code&gt; に設定されている場合、スタンバイはコミットレコードが再生されるときに応答メッセージを送信し、トランザクションを表示します。スタンバイは、設定に応じて、同期スタンバイとして選択される場合 &lt;code&gt;synchronous_standby_names&lt;/code&gt; プライマリでは、そのスタンバイからの応答メッセージが他の同期スタンバイからの応答メッセージとともに考慮され、コミットレコードが受信されたことの確認を待っているトランザクションをいつ解放するかを決定します。管理者はこれらのパラメーターを使用して、同期スタンバイにするスタンバイサーバーを指定できます。同期レプリケーションの設定は主にマスターで行われることに注意してください。名前付きスタンバイは、マスターに直接接続する必要があります。マスターは、カスケードレプリケーションを使用するダウンストリームスタンバイサーバーについて何も知りません。</target>
        </trans-unit>
        <trans-unit id="94241391dfbbfde4a951b39750ed3743aeb3267e" translate="yes" xml:space="preserve">
          <source>After a query has produced an output table (after the select list has been processed) it can optionally be sorted. If sorting is not chosen, the rows will be returned in an unspecified order. The actual order in that case will depend on the scan and join plan types and the order on disk, but it must not be relied on. A particular output ordering can only be guaranteed if the sort step is explicitly chosen.</source>
          <target state="translated">クエリが出力テーブルを生成した後(セレクトリストが処理された後)、オプションでソートすることができます。ソートが選択されなかった場合、行は指定されていない順序で返されます。この場合の実際の順序は、スキャンや結合プランの種類やディスク上の順序に依存しますが、それに依存してはいけません。特定の出力順序は、ソートステップが明示的に選択された場合にのみ保証されます。</target>
        </trans-unit>
        <trans-unit id="3b97640c2ecb0afe6be98ec8bef630298c29b1bf" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">シーケンスが作成されたら、関数 &lt;code&gt;nextval&lt;/code&gt; 、 &lt;code&gt;currval&lt;/code&gt; 、および &lt;code&gt;setval&lt;/code&gt; を使用してシーケンスを操作します。これらの関数については、&lt;a href=&quot;functions-sequence&quot;&gt;セクション9.16で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="bc113f99607193995354648154db9d5489f2fd2b" translate="yes" xml:space="preserve">
          <source>After an index is created, the system has to keep it synchronized with the table. This adds overhead to data manipulation operations. Therefore indexes that are seldom or never used in queries should be removed.</source>
          <target state="translated">インデックスが作成された後、システムはそれをテーブルと同期させておく必要があります。これはデータ操作操作のオーバーヘッドを追加します。したがって、クエリで滅多に使用されない、あるいは使用されることのないインデックスは削除されるべきです。</target>
        </trans-unit>
        <trans-unit id="07e3f54a730eab0090b9f9763615353b60509ba8" translate="yes" xml:space="preserve">
          <source>After completing the tests, it's recommended you disable the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter:</source>
          <target state="translated">テストが完了したら、 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; パラメータを無効にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b07e5c0448618c87913bcee1323b05d5b460e37c" translate="yes" xml:space="preserve">
          <source>After creating partitions of &lt;code&gt;measurement_y2006m02&lt;/code&gt;, any data inserted into &lt;code&gt;measurement&lt;/code&gt; that is mapped to &lt;code&gt;measurement_y2006m02&lt;/code&gt; (or data that is directly inserted into &lt;code&gt;measurement_y2006m02&lt;/code&gt;, provided it satisfies its partition constraint) will be further redirected to one of its partitions based on the &lt;code&gt;peaktemp&lt;/code&gt; column. The partition key specified may overlap with the parent's partition key, although care should be taken when specifying the bounds of a sub-partition such that the set of data it accepts constitutes a subset of what the partition's own bounds allows; the system does not try to check whether that's really the case.</source>
          <target state="translated">パーティションを作成した後 &lt;code&gt;measurement_y2006m02&lt;/code&gt; を、任意のデータが挿入 &lt;code&gt;measurement&lt;/code&gt; にマッピングされ &lt;code&gt;measurement_y2006m02&lt;/code&gt; （または直接に挿入されるデータ &lt;code&gt;measurement_y2006m02&lt;/code&gt; を、それを満たすそのパーティション制約提供）さらに基づいてそのパーティションの1つにリダイレクトする &lt;code&gt;peaktemp&lt;/code&gt; のカラム。指定されたパーティションキーは親のパーティションキーと重複する可能性がありますが、サブパーティションの境界を指定するときは、それが受け入れるデータのセットがパーティション自体の境界で許可されるもののサブセットを構成するように注意する必要があります。システムは、それが本当にそうであるかどうかをチェックしようとしません。</target>
        </trans-unit>
        <trans-unit id="db536621da1a6c52f06af534df944428be135246" translate="yes" xml:space="preserve">
          <source>After creating the function, we create a trigger which calls the trigger function:</source>
          <target state="translated">関数を作成したら、その関数を呼び出すトリガーを作成します。</target>
        </trans-unit>
        <trans-unit id="c393be77ecb9862e06e4a42080ca1b8d309670b1" translate="yes" xml:space="preserve">
          <source>After modifying that file, a reboot is required for the new settings to take effect.</source>
          <target state="translated">そのファイルを変更した後、新しい設定を有効にするには再起動が必要です。</target>
        </trans-unit>
        <trans-unit id="c876187243218ed419e1b156be87fd9454c80ab8" translate="yes" xml:space="preserve">
          <source>After passing the &lt;code&gt;WHERE&lt;/code&gt; filter, the derived input table might be subject to grouping, using the &lt;code&gt;GROUP BY&lt;/code&gt; clause, and elimination of group rows using the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; フィルターを渡した後、派生した入力テーブルは、 &lt;code&gt;GROUP BY&lt;/code&gt; 句を使用してグループ化され、 &lt;code&gt;HAVING&lt;/code&gt; 句を使用してグループ行が削除される場合があります。</target>
        </trans-unit>
        <trans-unit id="476a32ba88141aeb970e81601edc2ee511e8c4b9" translate="yes" xml:space="preserve">
          <source>After reaching the end of valid WAL, keep polling once per second for new WAL to appear.</source>
          <target state="translated">有効なWALの終了に到達した後、新しいWALが表示されるように1秒に1回のポーリングを続けます。</target>
        </trans-unit>
        <trans-unit id="fd721ac53a17faa8b9db323757ed059c923d71fc" translate="yes" xml:space="preserve">
          <source>After recompiling and running the new binary, check that your newly added probe is available by executing the following DTrace command. You should see similar output:</source>
          <target state="translated">新しいバイナリを再コンパイルして実行した後、以下の DTrace コマンドを実行して、新しく追加したプローブが使用可能であることを確認してください。同様の出力が表示されるはずです。</target>
        </trans-unit>
        <trans-unit id="c206de8ceae00b19b0bbd697b5fe278bf3d62023" translate="yes" xml:space="preserve">
          <source>After restoring a backup, it is wise to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on each database so the query optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. For more advice on how to load large amounts of data into PostgreSQL efficiently, refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt;.</source>
          <target state="translated">バックアップを復元した後、各データベースで&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行して、クエリオプティマイザーが有用な統計を取得できるようにすることをお勧めします。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。大量のデータをPostgreSQLに効率的にロードする方法の詳細については、&lt;a href=&quot;populate&quot;&gt;セクション14.4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="417976bf060ad8e20656ba39a451c14e19b1e474" translate="yes" xml:space="preserve">
          <source>After rolling back to a savepoint, it continues to be defined, so you can roll back to it several times. Conversely, if you are sure you won't need to roll back to a particular savepoint again, it can be released, so the system can free some resources. Keep in mind that either releasing or rolling back to a savepoint will automatically release all savepoints that were defined after it.</source>
          <target state="translated">セーブポイントにロールバックした後も、そのセーブポイントは定義され続けますので、何度かロールバックすることができます。逆に、特定のセーブポイントに再度ロールバックする必要がないと確信している場合は、そのセーブポイントを解放することで、システムがリソースを解放することができます。セーブポイントを解放するかロールバックするかは、その後に定義されたすべてのセーブポイントを自動的に解放することになることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="e2cf5063e2afd451a505eeabbaaa31e6dea2f166" translate="yes" xml:space="preserve">
          <source>After running this command, it should be possible to start the server, but bear in mind that the database might contain inconsistent data due to partially-committed transactions. You should immediately dump your data, run &lt;code&gt;initdb&lt;/code&gt;, and reload. After reload, check for inconsistencies and repair as needed.</source>
          <target state="translated">このコマンドを実行すると、サーバーを起動できるようになりますが、トランザクションが部分的にコミットされているため、データベースに一貫性のないデータが含まれている可能性があることに注意してください。すぐにデータをダンプして &lt;code&gt;initdb&lt;/code&gt; を実行し、リロードする必要があります。リロード後、矛盾がないか確認し、必要に応じて修復します。</target>
        </trans-unit>
        <trans-unit id="f1751e378d5c61831bc66381dd026a28d4a7604f" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;auth-method&lt;/code&gt; field, there can be field(s) of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; that specify options for the authentication method. Details about which options are available for which authentication methods appear below.</source>
          <target state="translated">&lt;code&gt;auth-method&lt;/code&gt; フィールドの後には、 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; という形式のフィールドがあり、認証方法のオプションを指定できます。どの認証方法でどのオプションを使用できるかについての詳細は、以下に表示されます。</target>
        </trans-unit>
        <trans-unit id="129d74f6272df45af1d745e991e7a73feebafe5a" translate="yes" xml:space="preserve">
          <source>After the processing of the &lt;code&gt;FROM&lt;/code&gt; clause is done, each row of the derived virtual table is checked against the search condition. If the result of the condition is true, the row is kept in the output table, otherwise (i.e., if the result is false or null) it is discarded. The search condition typically references at least one column of the table generated in the &lt;code&gt;FROM&lt;/code&gt; clause; this is not required, but otherwise the &lt;code&gt;WHERE&lt;/code&gt; clause will be fairly useless.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句の処理が完了すると、派生仮想テーブルの各行が検索条件に対してチェックされます。条件の結果がtrueの場合、行は出力テーブルに保持されます。それ以外の場合（つまり、結果がfalseまたはnullの場合）は破棄されます。通常、検索条件は &lt;code&gt;FROM&lt;/code&gt; 句で生成されたテーブルの少なくとも1つの列を参照します。これは必須ではありませんが、それ以外の場合、 &lt;code&gt;WHERE&lt;/code&gt; 句はほとんど役に立ちません。</target>
        </trans-unit>
        <trans-unit id="7afbd68cfd57086d9de66444e71b66bfaedc388a" translate="yes" xml:space="preserve">
          <source>After the select list has been processed, the result table can optionally be subject to the elimination of duplicate rows. The &lt;code&gt;DISTINCT&lt;/code&gt; key word is written directly after &lt;code&gt;SELECT&lt;/code&gt; to specify this:</source>
          <target state="translated">選択リストが処理された後、結果表はオプションで重複行の除去の対象になる場合があります。 &lt;code&gt;DISTINCT&lt;/code&gt; キーワードは直後に書かれている &lt;code&gt;SELECT&lt;/code&gt; これを指定するには：</target>
        </trans-unit>
        <trans-unit id="6f94a805413e3bb85d7fa38665d29205c38f9186" translate="yes" xml:space="preserve">
          <source>After this command is executed, the index is &amp;ldquo;owned&amp;rdquo; by the constraint, in the same way as if the index had been built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command. In particular, dropping the constraint will make the index disappear too.</source>
          <target state="translated">このコマンドを実行すると、通常の &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; または &lt;code&gt;ADD UNIQUE&lt;/code&gt; コマンドによってインデックスが作成された場合と同じように、インデックスは制約によって「所有」されます。特に、制約を削除すると、インデックスも非表示になります。</target>
        </trans-unit>
        <trans-unit id="5a54a1d7a070e112cd3e777d9befed8de7b72e73" translate="yes" xml:space="preserve">
          <source>Again connect to the database as a user with rights to run pg_stop_backup (superuser, or a user who has been granted EXECUTE on the function), and issue the command:</source>
          <target state="translated">pg_stop_backupを実行する権限を持つユーザ(スーパーユーザ、または関数に対してEXECUTEを付与されたユーザ)としてデータベースに接続し、コマンドを発行します。</target>
        </trans-unit>
        <trans-unit id="89c328b5eae1533574b7b6b9cb4641c91474c438" translate="yes" xml:space="preserve">
          <source>Again the planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for &lt;code&gt;=&lt;/code&gt;, which is &lt;code&gt;eqsel&lt;/code&gt;. For equality estimation the histogram is not useful; instead the list of &lt;em&gt;most common values&lt;/em&gt; (MCVs) is used to determine the selectivity. Let's have a look at the MCVs, with some additional columns that will be useful later:</source>
          <target state="translated">この場合も、プランナは &lt;code&gt;WHERE&lt;/code&gt; 句の条件を調べ、 &lt;code&gt;=&lt;/code&gt; の選択性関数を &lt;code&gt;eqsel&lt;/code&gt; ます。これはeqselです。等価推定では、ヒストグラムは役に立ちません。代わりに、&lt;em&gt;最も一般的な値&lt;/em&gt;（MCV）のリストを使用して、選択性を決定します。MCVを見てみましょう。後で役立つ列がいくつか追加されています。</target>
        </trans-unit>
        <trans-unit id="4c27783eb44bcd1d4c219fa9ccfc28e663471099" translate="yes" xml:space="preserve">
          <source>Again, a more realistic example:</source>
          <target state="translated">またしても、より現実的な例です。</target>
        </trans-unit>
        <trans-unit id="6c1eea13275ab96326295feeff11f71292c224b0" translate="yes" xml:space="preserve">
          <source>Again, a table alias is required. Assigning alias names to the columns of the &lt;code&gt;VALUES&lt;/code&gt; list is optional, but is good practice. For more information see &lt;a href=&quot;queries-values&quot;&gt;Section 7.7&lt;/a&gt;.</source>
          <target state="translated">ここでも、テーブルのエイリアスが必要です。 &lt;code&gt;VALUES&lt;/code&gt; リストの列へのエイリアス名の割り当てはオプションですが、適切な方法です。詳細については、&lt;a href=&quot;queries-values&quot;&gt;セクション7.7を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fa2e8717405811a7aefb85de6cf3250083c52ac2" translate="yes" xml:space="preserve">
          <source>Again, note that some of these commands are actually allowed during &quot;read only&quot; mode transactions on the primary.</source>
          <target state="translated">繰り返しになりますが、これらのコマンドの中には、プライマリ上の「読み取り専用」モードのトランザクション中に実際に許可されているものがあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d75929b4f5b2f824a7a07da4899bf1820357b131" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="translated">繰り返しますが、詳細については&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="73c2d4672afb28ef558326e3d56d8e571d70b6fe" translate="yes" xml:space="preserve">
          <source>Again, the argument &lt;code&gt;uppercase&lt;/code&gt; was omitted so it is set to &lt;code&gt;false&lt;/code&gt; implicitly. One advantage of using named notation is that the arguments may be specified in any order, for example:</source>
          <target state="translated">この場合も、引数の &lt;code&gt;uppercase&lt;/code&gt; は省略されているため、暗黙的に &lt;code&gt;false&lt;/code&gt; に設定されます。名前付き表記を使用する利点の1つは、引数を任意の順序で指定できることです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">集計機能</target>
        </trans-unit>
        <trans-unit id="78066b1c350419b50af4d9f199ab1be3ff9a7bd9" translate="yes" xml:space="preserve">
          <source>Aggregate functions are an extension.</source>
          <target state="translated">集計機能はその延長線上にある。</target>
        </trans-unit>
        <trans-unit id="41c2d9b93a1fb3de5a512eb3000462da32b26df8" translate="yes" xml:space="preserve">
          <source>Aggregate functions which support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="translated">&lt;em&gt;パーシャルモード&lt;/em&gt;をサポートする集計関数は、並列集計などのさまざまな最適化に参加できます。</target>
        </trans-unit>
        <trans-unit id="90d68cd3e256fbe87b23e489f9c82e0bca666a22" translate="yes" xml:space="preserve">
          <source>Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a &lt;code&gt;FILTER&lt;/code&gt; clause to the aggregate function call; see &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt; for more information. When a &lt;code&gt;FILTER&lt;/code&gt; clause is present, only those rows matching it are included in the input to that aggregate function.</source>
          <target state="translated">使用されている場合、集計関数は、各グループを構成するすべての行にわたって計算され、グループごとに個別の値が生成されます。（集約関数はあるが &lt;code&gt;GROUP BY&lt;/code&gt; 句がない場合、クエリは、選択されたすべての行で構成される単一のグループを持つものとして扱われます。） &lt;code&gt;FILTER&lt;/code&gt; 句を集約関数に付加することにより、各集約関数に供給される行のセットをさらにフィルターできます。コール; 詳細については、&lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;セクション4.2.7&lt;/a&gt;を参照してください。 &lt;code&gt;FILTER&lt;/code&gt; 句が存在する場合、それに一致する行のみがその集約関数への入力に含まれます。</target>
        </trans-unit>
        <trans-unit id="cbff25b6bf81504908e5320d1af957a7ec74d3b6" translate="yes" xml:space="preserve">
          <source>Aggregate kind: &lt;code&gt;n&lt;/code&gt; for &amp;ldquo;normal&amp;rdquo; aggregates, &lt;code&gt;o&lt;/code&gt; for &amp;ldquo;ordered-set&amp;rdquo; aggregates, or &lt;code&gt;h&lt;/code&gt; for &amp;ldquo;hypothetical-set&amp;rdquo; aggregates</source>
          <target state="translated">集約の種類：「通常の」集約の場合は &lt;code&gt;n&lt;/code&gt; 、「順序セット」集約の場合は &lt;code&gt;o&lt;/code&gt; 、「仮想セット」集約の場合は &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67fa6b402dc45ed045bd73c615623304375dc24b" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUPING</source>
          <target state="translated">集計します。グループ化</target>
        </trans-unit>
        <trans-unit id="e7717151bc6adba0544d963b5ecd779cf9aefbe1" translate="yes" xml:space="preserve">
          <source>Aggregate: array_agg</source>
          <target state="translated">集計:array_agg</target>
        </trans-unit>
        <trans-unit id="7671fe3f4aa646a763a41cd74b0f33b4d9825d22" translate="yes" xml:space="preserve">
          <source>Aggregate: avg</source>
          <target state="translated">平均値:平均値</target>
        </trans-unit>
        <trans-unit id="9464ad790968a8c3f29976c4cecb93cf8cb97818" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_and</source>
          <target state="translated">集計:bit_and</target>
        </trans-unit>
        <trans-unit id="f4ff9c9094ce1f94db13530e24012163b5e11d40" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_or</source>
          <target state="translated">集計:bit_or</target>
        </trans-unit>
        <trans-unit id="b9c262247be1030665a29ac642cf245ebfafdc8c" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_and</source>
          <target state="translated">集計:bool_and</target>
        </trans-unit>
        <trans-unit id="a36b04811f8dfcb04687f062eee53e188ba68218" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_or</source>
          <target state="translated">集計:bool_or</target>
        </trans-unit>
        <trans-unit id="6b938ae10da8a5049736d651f7bdf37fa7dd2ec6" translate="yes" xml:space="preserve">
          <source>Aggregate: corr</source>
          <target state="translated">集計:実行</target>
        </trans-unit>
        <trans-unit id="f67c8e60c07fff9ff21ed59ebe5883cf64966901" translate="yes" xml:space="preserve">
          <source>Aggregate: count</source>
          <target state="translated">集計:カウント</target>
        </trans-unit>
        <trans-unit id="a535e7f27744a217a4b4ebbcc5ce09395054c24d" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_pop</source>
          <target state="translated">集計:covar_pop</target>
        </trans-unit>
        <trans-unit id="e42952cf656ba58f6dfa69af76b03eb6f4865935" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_samp</source>
          <target state="translated">集計:covar_samp</target>
        </trans-unit>
        <trans-unit id="affa989634b7b7f9316e718975ac524915a80100" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist WITHIN GROUP</source>
          <target state="translated">集計:cume_dist WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="3ff732a0c7e39824a92acd57f902391a878f3abf" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank WITHIN GROUP</source>
          <target state="translated">集計:dense_rank WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="8dc8d8ebf59b788e17565bab2f4948b36d249316" translate="yes" xml:space="preserve">
          <source>Aggregate: every</source>
          <target state="translated">集計:すべての</target>
        </trans-unit>
        <trans-unit id="cb574ceb369d625e53cf66f30a46474ab01c8d22" translate="yes" xml:space="preserve">
          <source>Aggregate: json_agg</source>
          <target state="translated">集計:json_agg</target>
        </trans-unit>
        <trans-unit id="5daf429a167bfb1204d6816cc327273b7dff3d24" translate="yes" xml:space="preserve">
          <source>Aggregate: json_object_agg</source>
          <target state="translated">集計:json_object_agg</target>
        </trans-unit>
        <trans-unit id="146ad7890c6afaeaa83cf4ce928bc658120656b5" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_agg</source>
          <target state="translated">集計:jsonb_agg</target>
        </trans-unit>
        <trans-unit id="6f7d6e6ca2d445820090cd7f314ec40d5730bd62" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_object_agg</source>
          <target state="translated">集計:jsonb_object_agg</target>
        </trans-unit>
        <trans-unit id="65e31a82796d0cddf371f7a0ba43aa2ede594f67" translate="yes" xml:space="preserve">
          <source>Aggregate: max</source>
          <target state="translated">集計:最大</target>
        </trans-unit>
        <trans-unit id="36d81566b6da93dc64aade9617077054e335a89e" translate="yes" xml:space="preserve">
          <source>Aggregate: min</source>
          <target state="translated">集計:最小</target>
        </trans-unit>
        <trans-unit id="7c96cf40a4dc1d8d1ea12a0b1f5bcf59364dc827" translate="yes" xml:space="preserve">
          <source>Aggregate: mode WITHIN GROUP</source>
          <target state="translated">集計:モード WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="34b5e1912aa5215dcec451af73485fcbfd34b50f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank WITHIN GROUP</source>
          <target state="translated">集計:percent_rank WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="1d40010d0c71e89dc5a258e985609a24fad7370a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont WITHIN GROUP</source>
          <target state="translated">集計:percentile_cont WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="9c269fdb441e6262d2a37b019da9d266f3b3b083" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc WITHIN GROUP</source>
          <target state="translated">集計:percentile_disc WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="66604fc6a8764a0b6d82483c45c9ff5043d563ce" translate="yes" xml:space="preserve">
          <source>Aggregate: rank WITHIN GROUP</source>
          <target state="translated">集計:ランク WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="08db334b9f771618e8d9956b3a35006958baa8aa" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgx</source>
          <target state="translated">集計:regr_avgx</target>
        </trans-unit>
        <trans-unit id="f813e6eb9f1bd8f18122c9d3100e3e1329000930" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgy</source>
          <target state="translated">集計:regr_avgy</target>
        </trans-unit>
        <trans-unit id="db3268966df89189e65fd222205de0442daba3c2" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_count</source>
          <target state="translated">集計:regr_count</target>
        </trans-unit>
        <trans-unit id="4489b8487a16a39dde1e4d8b5fcd20f0950266f5" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_intercept</source>
          <target state="translated">集計:regr_intercept</target>
        </trans-unit>
        <trans-unit id="17dd93536539876bbf56b59964ca4c7379d9ef8f" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_r2</source>
          <target state="translated">集計:regr_r2</target>
        </trans-unit>
        <trans-unit id="bbd0902e24a6b13aeeb42be12d4c6ac689ac39d4" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_slope</source>
          <target state="translated">集計値:regr_slope</target>
        </trans-unit>
        <trans-unit id="83dbb5beff01870dc33ceaa7278e2d80cc920457" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxx</source>
          <target state="translated">集計:regr_sxx</target>
        </trans-unit>
        <trans-unit id="ec7ca11bda1c42f1ba07c7f1bd8a0c3296064181" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxy</source>
          <target state="translated">集計:regr_sxy</target>
        </trans-unit>
        <trans-unit id="f14b071a16428ce5a21dc895086399aaadc762a3" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_syy</source>
          <target state="translated">集計:regr_syy</target>
        </trans-unit>
        <trans-unit id="c004eede3fbd79af583dbd185f768dfae4d466a6" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev</source>
          <target state="translated">集計:stddev</target>
        </trans-unit>
        <trans-unit id="1d5e80f190137dd3cac84ce1a78d10780d5bce34" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_pop</source>
          <target state="translated">集計:stddev_pop</target>
        </trans-unit>
        <trans-unit id="d3b157c6a46f69b3887530f9f9b22d6b9cb4a16e" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_samp</source>
          <target state="translated">集計:stddev_samp</target>
        </trans-unit>
        <trans-unit id="2974203e91cce11e66f9221d5ec28297655cd0a8" translate="yes" xml:space="preserve">
          <source>Aggregate: string_agg</source>
          <target state="translated">集計:string_agg</target>
        </trans-unit>
        <trans-unit id="ee008bd21c90b91f02271735e82b4e05772fdd98" translate="yes" xml:space="preserve">
          <source>Aggregate: sum</source>
          <target state="translated">集計:合計</target>
        </trans-unit>
        <trans-unit id="56a46ffd3d158ae27b092ee54bfe3724f518b2f3" translate="yes" xml:space="preserve">
          <source>Aggregate: var_pop</source>
          <target state="translated">集計:var_pop</target>
        </trans-unit>
        <trans-unit id="3c7dc337d4d493d0b8b497185b09dab2dd6b0e40" translate="yes" xml:space="preserve">
          <source>Aggregate: var_samp</source>
          <target state="translated">集計:var_samp</target>
        </trans-unit>
        <trans-unit id="51e197a4c87920c56f05e65ce1ba4b227834b071" translate="yes" xml:space="preserve">
          <source>Aggregate: variance</source>
          <target state="translated">集計:分散</target>
        </trans-unit>
        <trans-unit id="a2fb0accd998c64e0241184b4242d48e43957e30" translate="yes" xml:space="preserve">
          <source>Aggregate: xmlagg</source>
          <target state="translated">集計:xmlagg</target>
        </trans-unit>
        <trans-unit id="576d72bc3c483daa9c7746a2659f34dd5176aed8" translate="yes" xml:space="preserve">
          <source>Aggregated Argument Type(s)</source>
          <target state="translated">集約された引数タイプ</target>
        </trans-unit>
        <trans-unit id="425a801b77a97dcec7fa5fa5f67892cad03a7787" translate="yes" xml:space="preserve">
          <source>Aggregated Logging</source>
          <target state="translated">集計されたロギング</target>
        </trans-unit>
        <trans-unit id="604697606446ca85390963f1caeb65a8c41712bd" translate="yes" xml:space="preserve">
          <source>Aggregates are also very useful in combination with &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For example, we can get the maximum low temperature observed in each city with:</source>
          <target state="translated">集計は、 &lt;code&gt;GROUP BY&lt;/code&gt; 句と組み合わせて使用​​すると非常に便利です。たとえば、次のようにして、各都市で観測された最高気温を取得できます。</target>
        </trans-unit>
        <trans-unit id="8a83bb8f12f58dc63f8d8450952fc03b0bc1ffde" translate="yes" xml:space="preserve">
          <source>Aggregates that behave like &lt;code&gt;MIN&lt;/code&gt; or &lt;code&gt;MAX&lt;/code&gt; can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a &lt;em&gt;sort operator&lt;/em&gt;. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</source>
          <target state="translated">&lt;code&gt;MIN&lt;/code&gt; または &lt;code&gt;MAX&lt;/code&gt; のように動作する集計は、すべての入力行をスキャンする代わりに、インデックスを調べることによって最適化できる場合があります。この集計を最適化できる場合は、&lt;em&gt;並べ替え演算子を&lt;/em&gt;指定してそれを示します。基本的な要件は、集計によって、演算子によって引き起こされるソート順の最初の要素が生成されることです。言い換えると：</target>
        </trans-unit>
        <trans-unit id="7ec048891025aea562b86e815620f42ae7adb619" translate="yes" xml:space="preserve">
          <source>Aggressive &lt;code&gt;VACUUM&lt;/code&gt; scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact values are advanced, on-disk storage for older multixacts can be removed.</source>
          <target state="translated">積極的な &lt;code&gt;VACUUM&lt;/code&gt; スキャンは、その原因に関係なく、そのテーブルの値を進めることを可能にします。最終的に、すべてのデータベースのすべてのテーブルがスキャンされ、最も古いmultixact値が拡張されるため、古いmultixactのディスク上のストレージを削除できます。</target>
        </trans-unit>
        <trans-unit id="121abf3940fab2d8dbe9b94bbd289148bc06a85b" translate="yes" xml:space="preserve">
          <source>Aggressively &amp;ldquo;freeze&amp;rdquo; tuples.</source>
          <target state="translated">タプルを積極的に「凍結」します。</target>
        </trans-unit>
        <trans-unit id="bcb017abcff2696033726df1d1faa6140cda30fa" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Postgres Professional, Russia</source>
          <target state="translated">Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; 、モスクワ、Postgres Professional、ロシア</target>
        </trans-unit>
        <trans-unit id="aa44f40c0080e2d8f22aa729bc2aa695de07bb55" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; 、Postgres Professional、モスクワ、ロシア</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="1238bd88f43030284835da146c8f594a6e3253c8" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;pgcrypto&lt;/code&gt; functions run inside the database server. That means that all the data and passwords move between &lt;code&gt;pgcrypto&lt;/code&gt; and client applications in clear text. Thus you must:</source>
          <target state="translated">すべての &lt;code&gt;pgcrypto&lt;/code&gt; 関数はデータベースサーバー内で実行されます。つまり、すべてのデータとパスワードが &lt;code&gt;pgcrypto&lt;/code&gt; とクライアントアプリケーションの間をクリアテキストで移動します。したがって、次のことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="0b67ddd3a2de73817c7543968b2cc085a1a78542" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; 以外のすべての &lt;code&gt;storage&lt;/code&gt; 値は、&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;セクション37.13.1で&lt;/a&gt;説明されているように、データ型の関数が&lt;em&gt;トースト&lt;/em&gt;され&lt;em&gt;た&lt;/em&gt;値を処理できることを意味します。指定された他の特定の値は、単にトースト可能なデータ型の列のデフォルトのTOASTストレージ戦略を決定します。ユーザーは、 &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt; を使用して、個々の列に対して他の戦略を選択できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10d6e0687d278d53588734a1b582257aaee1502f" translate="yes" xml:space="preserve">
          <source>All Privileges</source>
          <target state="translated">すべての特権</target>
        </trans-unit>
        <trans-unit id="bf637fbee55bb9d868af3ee61e448c31817bc7e1" translate="yes" xml:space="preserve">
          <source>All UPC, ISBN, ISMN and ISSN numbers can be represented as EAN13 numbers.</source>
          <target state="translated">すべてのUPC、ISBN、ISMN、ISSN番号はEAN13番号で表すことができます。</target>
        </trans-unit>
        <trans-unit id="f057cd68ee57e6fcf443add2a601584e9abb4486" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the master and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="translated">バックアップに必要なすべてのWALレコードには、十分なフルページ書き込みが含まれている必要があります。これには、マスターで &lt;code&gt;full_page_writes&lt;/code&gt; を有効にし、pg_compresslogなどのツールを &lt;code&gt;archive_command&lt;/code&gt; として使用してWALファイルからフルページ書き込みを削除しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="841cc9e5c025174354644ed418b19ab2df80e067" translate="yes" xml:space="preserve">
          <source>All arguments are specified in order. The result is upper case since &lt;code&gt;uppercase&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;. Another example is:</source>
          <target state="translated">すべての引数は順番に指定されます。 &lt;code&gt;uppercase&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に指定されているため、結果は大文字になります。別の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="64cfac4af128aada4a6d6bb5c11a90e45ce7a24e" translate="yes" xml:space="preserve">
          <source>All check constraints and not-null constraints on a parent table are automatically inherited by its children, unless explicitly specified otherwise with &lt;code&gt;NO INHERIT&lt;/code&gt; clauses. Other types of constraints (unique, primary key, and foreign key constraints) are not inherited.</source>
          <target state="translated">&lt;code&gt;NO INHERIT&lt;/code&gt; 句で明示的に指定されていない限り、親テーブルのすべてのチェック制約とnull以外の制約は、その子によって自動的に継承されます。その他のタイプの制約（一意、主キー、および外部キー制約）は継承されません。</target>
        </trans-unit>
        <trans-unit id="89f96ca727311b0e1e924639300601036b23919a" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="translated">すべての列にデフォルト値が入力されます。（この形式では &lt;code&gt;OVERRIDING&lt;/code&gt; 句は使用できません。）</target>
        </trans-unit>
        <trans-unit id="44d64899ac94e8442ee1baa672497f8a2ca162b4" translate="yes" xml:space="preserve">
          <source>All constraints on all children of the parent table are examined during constraint exclusion, so large numbers of children are likely to increase query planning time considerably. So the legacy inheritance based partitioning will work well with up to perhaps a hundred child tables; don't try to use many thousands of children.</source>
          <target state="translated">親テーブルのすべての子テーブルに対するすべての制約は、制約除外時に検査されるので、子テーブルの数が多いと問い合わせ計画時間が大幅に増加します。そのため、レガシー継承ベースのパーティショニングは、おそらく100個までの子テーブルでもうまく機能しますが、何千個もの子テーブルを使おうとしないでください。</target>
        </trans-unit>
        <trans-unit id="153c80dc5116feea616ba3928be18ab8586f5a93" translate="yes" xml:space="preserve">
          <source>All current listen registrations for this session are cleared.</source>
          <target state="translated">このセッションの現在のリスナー登録はすべてクリアされます。</target>
        </trans-unit>
        <trans-unit id="e559ad46dfb12176f9ab6a5068fbbc335264dacf" translate="yes" xml:space="preserve">
          <source>All currently available prepared transactions are listed in the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">現在利用可能なすべての準備済みトランザクションは、&lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt;システムビューに一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="2778b518fdc9b5356b12e2a79dd08d30844b8366" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; リストのすべての要素が計算されます。（ &lt;code&gt;FROM&lt;/code&gt; リストの各要素は実テーブルまたは仮想テーブルです。） &lt;code&gt;FROM&lt;/code&gt; リストで複数の要素が指定されている場合、それらは相互に結合されます。（下記の&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 節を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="3978f2f6a0fc6fd4b0827f0ebd212e7bcc3552c2" translate="yes" xml:space="preserve">
          <source>All failure, rebuild, and reindex cases will be reported by pg_upgrade if they affect your installation; post-upgrade scripts to rebuild tables and indexes will be generated automatically. If you are trying to automate the upgrade of many clusters, you should find that clusters with identical database schemas require the same post-upgrade steps for all cluster upgrades; this is because the post-upgrade steps are based on the database schemas, and not user data.</source>
          <target state="translated">テーブルとインデックスを再構築するためのアップグレード後のスクリプトは自動的に生成されます。多くのクラスタのアップグレードを自動化しようとしている場合、同一のデータベーススキーマを持つクラスタでは、すべてのクラスタアップグレードに同じアップグレード後の手順が必要であることが分かるはずです。</target>
        </trans-unit>
        <trans-unit id="2887bc873471e44a6e402dab0ddec69892effbd0" translate="yes" xml:space="preserve">
          <source>All functions and operators used in an index definition must be &amp;ldquo;immutable&amp;rdquo;, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time). This restriction ensures that the behavior of the index is well-defined. To use a user-defined function in an index expression or &lt;code&gt;WHERE&lt;/code&gt; clause, remember to mark the function immutable when you create it.</source>
          <target state="translated">インデックス定義で使用されるすべての関数と演算子は「不変」でなければなりません。つまり、結果は引数にのみ依存し、外部の影響（別のテーブルの内容や現在の時刻など）に依存してはなりません。この制限により、インデックスの動作が明確に定義されます。インデックス式または &lt;code&gt;WHERE&lt;/code&gt; 句でユーザー定義関数を使用するには、作成時に関数に不変のマークを付けてください。</target>
        </trans-unit>
        <trans-unit id="3ef17a42f49f1b90a3d376b9b52494437e996867" translate="yes" xml:space="preserve">
          <source>All indexes in PostgreSQL are &lt;em&gt;secondary&lt;/em&gt; indexes, meaning that each index is stored separately from the table's main data area (which is called the table's &lt;em&gt;heap&lt;/em&gt; in PostgreSQL terminology). This means that in an ordinary index scan, each row retrieval requires fetching data from both the index and the heap. Furthermore, while the index entries that match a given indexable &lt;code&gt;WHERE&lt;/code&gt; condition are usually close together in the index, the table rows they reference might be anywhere in the heap. The heap-access portion of an index scan thus involves a lot of random access into the heap, which can be slow, particularly on traditional rotating media. (As described in &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt;, bitmap scans try to alleviate this cost by doing the heap accesses in sorted order, but that only goes so far.)</source>
          <target state="translated">PostgreSQLのすべてのインデックスは&lt;em&gt;セカンダリ&lt;/em&gt;インデックスです。つまり、各インデックスはテーブルのメインデータ領域（PostgreSQLの用語ではテーブルの&lt;em&gt;ヒープ&lt;/em&gt;と呼ばれます）とは別に格納されます。これは、通常のインデックススキャンでは、行を取得するたびに、インデックスとヒープの両方からデータをフェッチする必要があることを意味します。さらに、特定のインデックス付け可能な &lt;code&gt;WHERE&lt;/code&gt; 条件に一致するインデックスエントリは通常、インデックス内で互いに近接していますが、それらが参照するテーブル行はヒープ内のどこかにある場合があります。したがって、インデックススキャンのヒープアクセス部分には、ヒープへのランダムアクセスが多数含まれます。これは、特に従来の回転メディアでは遅くなる可能性があります。 （&lt;a href=&quot;indexes-bitmap-scans&quot;&gt;セクション11.5で&lt;/a&gt;説明、ビットマップスキャンは、ソートされた順序でヒープアクセスを行うことでこのコストを軽減しようとしますが、それはこれまでのところです。</target>
        </trans-unit>
        <trans-unit id="db79cd41caf099a5fc97eb22b9bdb081eeb2153e" translate="yes" xml:space="preserve">
          <source>All it takes to get a BRIN access method working is to implement a few user-defined methods, which define the behavior of summary values stored in the index and the way they interact with scan keys. In short, BRIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">BRINアクセス・メソッドを動作させるために必要なのは、インデックスに格納されたサマリー値の動作とスキャン・キーとの相互作用を定義するユーザー定義のメソッドをいくつか実装することだけである。要するに、BRINは拡張性と汎用性、コードの再利用、そしてクリーンなインターフェイスを兼ね備えている。</target>
        </trans-unit>
        <trans-unit id="6e1a7f84a08ba9a0c97ee25a9736132689a50678" translate="yes" xml:space="preserve">
          <source>All it takes to get a GIN access method working is to implement a few user-defined methods, which define the behavior of keys in the tree and the relationships between keys, indexed items, and indexable queries. In short, GIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">GINのアクセスメソッドを動作させるために必要なのは、いくつかのユーザー定義のメソッドを実装することだけです。要するに、GIN は拡張性と汎用性、コードの再利用、そしてクリーンなインターフェイスを兼ね備えています。</target>
        </trans-unit>
        <trans-unit id="932e4d059724c2d4b8d21124cf86633cf4ac8541" translate="yes" xml:space="preserve">
          <source>All it takes to get a GiST access method up and running is to implement several user-defined methods, which define the behavior of keys in the tree. Of course these methods have to be pretty fancy to support fancy queries, but for all the standard queries (B-trees, R-trees, etc.) they're relatively straightforward. In short, GiST combines extensibility along with generality, code reuse, and a clean interface.</source>
          <target state="translated">GiSTのアクセスメソッドを立ち上げて実行するために必要なのは、ツリー内のキーの動作を定義するユーザ定義のメソッドをいくつか実装することだけです。もちろん、これらのメソッドは、派手なクエリをサポートするためにかなり派手なものでなければなりませんが、すべての標準的なクエリ(B木、R木など)に対しては、比較的簡単に実装できます。要するに、GiSTは拡張性と汎用性、コードの再利用、そしてクリーンなインターフェースを兼ね備えています。</target>
        </trans-unit>
        <trans-unit id="f6f094a1f0d931ca3f860e1e2d7b887c4d3d20bd" translate="yes" xml:space="preserve">
          <source>All messages emitted by the PostgreSQL server are assigned five-character error codes that follow the SQL standard's conventions for &amp;ldquo;SQLSTATE&amp;rdquo; codes. Applications that need to know which error condition has occurred should usually test the error code, rather than looking at the textual error message. The error codes are less likely to change across PostgreSQL releases, and also are not subject to change due to localization of error messages. Note that some, but not all, of the error codes produced by PostgreSQL are defined by the SQL standard; some additional error codes for conditions not defined by the standard have been invented or borrowed from other databases.</source>
          <target state="translated">PostgreSQLサーバーによって発行されるすべてのメッセージには、SQL標準の「SQLSTATE」コードの規則に従う5文字のエラーコードが割り当てられます。どのエラー状態が発生したかを知る必要があるアプリケーションは、通常、テキストのエラーメッセージではなく、エラーコードをテストする必要があります。エラーコードはPostgreSQLのリリース間で変更される可能性が低く、エラーメッセージのローカライズにより変更されることもありません。PostgreSQLによって生成されるすべてではなく一部のエラーコードは、SQL標準によって定義されていることに注意してください。標準で定義されていない条件のいくつかの追加のエラーコードは、他のデータベースから発明または借用されています。</target>
        </trans-unit>
        <trans-unit id="5f17dc4d29230530f8f45813d17f855f136a3816" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced by a transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidMultiXactId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">これより前のすべてのmultixact IDは、このテーブルでトランザクションIDに置き換えられています。これは、multixact IDの折り返しを防止するため、または &lt;code&gt;pg_multixact&lt;/code&gt; を縮小できるようにするために、テーブルをバキュームする必要があるかどうかを追跡するために使用されます。リレーションがテーブルでない場合はゼロ（ &lt;code&gt;InvalidMultiXactId&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2dede7220bdd3e91dec2b9b6615dd35bb3933921" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced with a transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; values.</source>
          <target state="translated">これより前のすべてのmultixact IDは、このデータベースでトランザクションIDに置き換えられています。これは、multixact IDの折り返しを防止するため、または &lt;code&gt;pg_multixact&lt;/code&gt; を縮小できるようにするために、データベースをバキュームする必要があるかどうかを追跡するために使用されます。これは、テーブルごとの &lt;code&gt;pg_class&lt;/code&gt; の最小値です。 &lt;code&gt;relminmxid&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="b6a1ec7b62542588df77c091f76d37462abbe3bd" translate="yes" xml:space="preserve">
          <source>All of the OID alias types for objects grouped by namespace accept schema-qualified names, and will display schema-qualified names on output if the object would not be found in the current search path without being qualified. The &lt;code&gt;regproc&lt;/code&gt; and &lt;code&gt;regoper&lt;/code&gt; alias types will only accept input names that are unique (not overloaded), so they are of limited use; for most uses &lt;code&gt;regprocedure&lt;/code&gt; or &lt;code&gt;regoperator&lt;/code&gt; are more appropriate. For &lt;code&gt;regoperator&lt;/code&gt;, unary operators are identified by writing &lt;code&gt;NONE&lt;/code&gt; for the unused operand.</source>
          <target state="translated">名前空間によってグループ化されたオブジェクトのすべてのOIDエイリアスタイプは、スキーマ修飾名を受け入れ、オブジェクトが修飾されていないと現在の検索パスで見つからない場合、スキーマ修飾名を出力に表示します。 &lt;code&gt;regproc&lt;/code&gt; と &lt;code&gt;regoper&lt;/code&gt; エイリアスの種類は、彼らが制限された使用であるので、（オーバーロードされていない）一意である入力名を受け入れます。ほとんどの用途では、 &lt;code&gt;regprocedure&lt;/code&gt; または &lt;code&gt;regoperator&lt;/code&gt; がより適切です。 &lt;code&gt;regoperator&lt;/code&gt; を、単項演算子は書いていないで識別され &lt;code&gt;NONE&lt;/code&gt; を未使用のオペランドの。</target>
        </trans-unit>
        <trans-unit id="37766175956ba6517dd475210dd4e291c6b94f05" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all peer rows.</source>
          <target state="translated">&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60&lt;/a&gt;にリストされているすべての関数は、関連するウィンドウ定義の &lt;code&gt;ORDER BY&lt;/code&gt; 句で指定されたソート順に依存しています。 &lt;code&gt;ORDER BY&lt;/code&gt; 列のみを考慮した場合に区別されない行は、&lt;em&gt;ピア&lt;/em&gt;と呼ばれます。4つのランキング関数（ &lt;code&gt;cume_dist&lt;/code&gt; を含む）は、すべてのピア行に同じ答えを与えるように定義されています。</target>
        </trans-unit>
        <trans-unit id="02fa4b0f473762a8721b052a178d80c186d067cd" translate="yes" xml:space="preserve">
          <source>All of the options except &lt;code&gt;convert-crlf&lt;/code&gt; apply only to encrypt functions. Decrypt functions get the parameters from the PGP data.</source>
          <target state="translated">&lt;code&gt;convert-crlf&lt;/code&gt; を除くすべてのオプションは、暗号化機能にのみ適用されます。復号化関数は、PGPデータからパラメーターを取得します。</target>
        </trans-unit>
        <trans-unit id="592ca33a4522df17e0e57a59e6344510c5d4a80c" translate="yes" xml:space="preserve">
          <source>All of the policies constructed thus far have been permissive policies, meaning that when multiple policies are applied they are combined using the &amp;ldquo;OR&amp;rdquo; Boolean operator. While permissive policies can be constructed to only allow access to rows in the intended cases, it can be simpler to combine permissive policies with restrictive policies (which the records must pass and which are combined using the &amp;ldquo;AND&amp;rdquo; Boolean operator). Building on the example above, we add a restrictive policy to require the administrator to be connected over a local Unix socket to access the records of the &lt;code&gt;passwd&lt;/code&gt; table:</source>
          <target state="translated">これまでに作成されたすべてのポリシーは寛容なポリシーでした。つまり、複数のポリシーが適用される場合、それらは「OR」ブール演算子を使用して結合されます。許可ポリシーは、意図したケースで行へのアクセスのみを許可するように構築できますが、許可ポリシーを制限ポリシー（レコードが通過する必要があり、「AND」ブール演算子を使用して結合される）と組み合わせる方が簡単です。上記の例に基づいて、 &lt;code&gt;passwd&lt;/code&gt; テーブルのレコードにアクセスするために管理者がローカルのUnixソケットを介して接続することを要求する制限的なポリシーを追加します。</target>
        </trans-unit>
        <trans-unit id="068ae9ee084ab21fc5a8a7c0060d57cbf4e3473f" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.23.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="translated">これらの &lt;code&gt;ORDER BY&lt;/code&gt; 句はすべて、行の複合値を指定するため、&lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;9.23.6項で&lt;/a&gt;説明されているルールに従って行がソートされます。ただし、 &lt;code&gt;inventory_item&lt;/code&gt; に &lt;code&gt;c&lt;/code&gt; という名前の列が含まれている場合、最初のケースは他のケースとは異なります。これは、その列のみでソートすることを意味するためです。前に示した列名を考えると、これらのクエリも上記のものと同等です。</target>
        </trans-unit>
        <trans-unit id="abf3c99355ffd14c50c6d5db9b1b5a423f1e1022" translate="yes" xml:space="preserve">
          <source>All of these fields are optional, except &lt;code&gt;commonName&lt;/code&gt;. It depends entirely on your CA's policy which of them would be included and which wouldn't. The meaning of these fields, however, is strictly defined by the X.500 and X.509 standards, so you cannot just assign arbitrary meaning to them.</source>
          <target state="translated">&lt;code&gt;commonName&lt;/code&gt; を除き、これらのフィールドはすべてオプションです。それはCAのポリシーに完全に依存し、それらのうちどれが含まれるか、含まれないかが決まります。ただし、これらのフィールドの意味はX.500およびX.509標準によって厳密に定義されているため、任意の意味を割り当てることはできません。</target>
        </trans-unit>
        <trans-unit id="c6deee271f21fa5ab3c6f7bba891d40136e2c021" translate="yes" xml:space="preserve">
          <source>All of these operations will throw an error if a supplied array contains any NULL elements.</source>
          <target state="translated">これらの操作はすべて、指定された配列にNULL要素が含まれている場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="d9b92f66d52bf42e15e05f0a8c5cb26f0298b448" translate="yes" xml:space="preserve">
          <source>All other parameters are described in detail under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">他のすべてのパラメーターについては、&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;で詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="a4df9c2d50326edae48634d605dfaf0fbdb01416" translate="yes" xml:space="preserve">
          <source>All parameter names are case-insensitive. Every parameter takes a value of one of five types: boolean, string, integer, floating point, or enumerated (enum). The type determines the syntax for setting the parameter:</source>
          <target state="translated">すべてのパラメータ名は大文字小文字を区別しません。すべてのパラメータは、ブール値、文字列、整数、浮動小数点、列挙型 (enum)の 5 つの型のうちいずれかの値を取ります。型は、パラメータを設定するための構文を決定します。</target>
        </trans-unit>
        <trans-unit id="2fd647ad9469bb58fc1688a31c856ba421945ca2" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;&lt;code&gt;WITH&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; リスト内のすべてのクエリが計算されます。これらは、 &lt;code&gt;FROM&lt;/code&gt; リストで参照できる一時テーブルとして効果的に機能します。A &lt;code&gt;WITH&lt;/code&gt; 以上で何度も参照されているクエリ &lt;code&gt;FROM&lt;/code&gt; はで特に指定のない限り、一度だけ計算され &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 。（下記の&lt;a href=&quot;sql-select#SQL-WITH&quot;&gt; &lt;code&gt;WITH&lt;/code&gt; 節を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="f087ce49a12f5467c1e1d2b10a821f36bb151962" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit.</source>
          <target state="translated">一時テーブルのすべての行は、各トランザクションブロックの最後に削除されます。基本的に、自動&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;はコミットごとに行われます。</target>
        </trans-unit>
        <trans-unit id="2033a72b30b992b55fdec7e008bb0316322a754e" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit. When used on a partitioned table, this is not cascaded to its partitions.</source>
          <target state="translated">一時テーブルのすべての行は、各トランザクションブロックの最後に削除されます。基本的に、自動&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;はコミットごとに行われます。パーティションテーブルで使用する場合、これはパーティションにカスケードされません。</target>
        </trans-unit>
        <trans-unit id="6dcf0dcfbfdd9c5f88b82f71ae9c913b23c0891e" translate="yes" xml:space="preserve">
          <source>All rows inserted into a partitioned table will be routed to one of the &lt;em&gt;partitions&lt;/em&gt; based on the value of the partition key. Each partition has a subset of the data defined by its &lt;em&gt;partition bounds&lt;/em&gt;. The currently supported partitioning methods are range, list, and hash.</source>
          <target state="translated">パーティションテーブルに挿入されたすべての行は、パーティションキーの値に基づいて&lt;em&gt;パーティションの&lt;/em&gt; 1つにルーティングされます。各パーティションには、その&lt;em&gt;パーティション境界&lt;/em&gt;によって定義されたデータのサブセットがあります。現在サポートされているパーティション分割方法は、範囲、リスト、およびハッシュです。</target>
        </trans-unit>
        <trans-unit id="4513787ec30b4d30ebbb9895538f30d98e3df810" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="translated">すべての標準および事前定義の照合は確定的であり、すべてのユーザー定義の照合はデフォルトで確定的です。非決定論的な照合は、より正確な動作を提供しますが、特にUnicodeの全機能とその多くの特殊なケースを考慮すると、いくつかの欠点があります。何よりも、それらを使用すると、パフォーマンスが低下します。また、パターンマッチング操作など、特定の操作は非決定的照合では不可能です。したがって、特に必要な場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="33701db90942013a1dfc5834530a8ecffe185cf9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction.</source>
          <target state="translated">現在のトランザクションのすべてのステートメントは、このトランザクションで最初のクエリまたはデータ修正ステートメントが実行される前にコミットされた行のみを見ることができます。</target>
        </trans-unit>
        <trans-unit id="2e14dc15c0e8ebe018dfe9b3ade39c8f85c910d9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction. If a pattern of reads and writes among concurrent serializable transactions would create a situation which could not have occurred for any serial (one-at-a-time) execution of those transactions, one of them will be rolled back with a &lt;code&gt;serialization_failure&lt;/code&gt; error.</source>
          <target state="translated">現在のトランザクションのすべてのステートメントは、このトランザクションで最初のクエリまたはデータ変更ステートメントが実行される前にコミットされた行のみを表示できます。並行シリアライズ可能なトランザクション間での読み取りと書き込みのパターンにより、これらのトランザクションのシリアル（一度に1つずつ）の実行では発生し得なかった状況が発生した場合、そのうちの1つが &lt;code&gt;serialization_failure&lt;/code&gt; エラーでロールバックされます。</target>
        </trans-unit>
        <trans-unit id="fd69152cf9c28ea6bdb8489a69a762ca6be86225" translate="yes" xml:space="preserve">
          <source>All systems would have the same &lt;code&gt;shared.conf&lt;/code&gt;. Each server with a particular amount of memory could share the same &lt;code&gt;memory.conf&lt;/code&gt;; you might have one for all servers with 8GB of RAM, another for those having 16GB. And finally &lt;code&gt;server.conf&lt;/code&gt; could have truly server-specific configuration information in it.</source>
          <target state="translated">すべてのシステムで同じ &lt;code&gt;shared.conf&lt;/code&gt; が使用されます。特定のメモリ容量を持つ各サーバーは、同じ &lt;code&gt;memory.conf&lt;/code&gt; を共有できます。RAMが8GBのすべてのサーバーに1つ、16GBのサーバーにもう1つある場合があります。そして最後に、 &lt;code&gt;server.conf&lt;/code&gt; には、本当にサーバー固有の構成情報を含めることができます。</target>
        </trans-unit>
        <trans-unit id="fdb84efbad86954ba5aa82c861c3c65c57c671dd" translate="yes" xml:space="preserve">
          <source>All table rows are structured in the same way. There is a fixed-size header (occupying 23 bytes on most machines), followed by an optional null bitmap, an optional object ID field, and the user data. The header is detailed in &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;Table 68.4&lt;/a&gt;. The actual user data (columns of the row) begins at the offset indicated by &lt;code&gt;t_hoff&lt;/code&gt;, which must always be a multiple of the MAXALIGN distance for the platform. The null bitmap is only present if the &lt;em&gt;HEAP_HASNULL&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If it is present it begins just after the fixed header and occupies enough bytes to have one bit per data column (that is, the number of bits that equals the attribute count in &lt;code&gt;t_infomask2&lt;/code&gt;). In this list of bits, a 1 bit indicates not-null, a 0 bit is a null. When the bitmap is not present, all columns are assumed not-null. The object ID is only present if the &lt;em&gt;HEAP_HASOID_OLD&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If present, it appears just before the &lt;code&gt;t_hoff&lt;/code&gt; boundary. Any padding needed to make &lt;code&gt;t_hoff&lt;/code&gt; a MAXALIGN multiple will appear between the null bitmap and the object ID. (This in turn ensures that the object ID is suitably aligned.)</source>
          <target state="translated">すべてのテーブル行は同じ方法で構造化されています。固定サイズのヘッダー（ほとんどのマシンで23バイトを占める）があり、その後にオプションのnullビットマップ、オプションのオブジェクトIDフィールド、およびユーザーデータが続きます。ヘッダーの詳細を&lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;表68.4に示し&lt;/a&gt;ます。実際のユーザーデータ（行の列）は、 &lt;code&gt;t_hoff&lt;/code&gt; で示されるオフセットで始まります。これは、プラットフォームのMAXALIGN距離の倍数である必要があります。 nullビットマップは、&lt;em&gt;t_infomaskでHEAP_HASNULL&lt;/em&gt;ビットが設定されている場合にのみ存在し &lt;code&gt;t_infomask&lt;/code&gt; 。存在する場合、それは固定ヘッダーの直後から始まり、データ列ごとに1ビット（つまり、 &lt;code&gt;t_infomask2&lt;/code&gt; の属性カウントに等しいビット数）を確保するのに十分なバイトを占有します。）。このビットのリストでは、1ビットはnull以外を示し、0ビットはnullを示します。ビットマップが存在しない場合、すべての列はnullでないと見なされます。オブジェクトIDは、&lt;em&gt;t_infomaskでHEAP_HASOID_OLD&lt;/em&gt;ビットが設定されている場合にのみ存在し &lt;code&gt;t_infomask&lt;/code&gt; 。存在する場合は、 &lt;code&gt;t_hoff&lt;/code&gt; 境界の直前に表示されます。 &lt;code&gt;t_hoff&lt;/code&gt; をMAXALIGNの倍数にするために必要なパディングは、nullビットマップとオブジェクトIDの間に表示されます。 （これにより、オブジェクトIDが適切に調整されます。）</target>
        </trans-unit>
        <trans-unit id="07e8311d5ee709346fa3f96903022cdc35bc8edc" translate="yes" xml:space="preserve">
          <source>All tables in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all tables to be moved first and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move tables owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command; use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER TABLE&lt;/code&gt; invocations instead if desired. The &lt;code&gt;information_schema&lt;/code&gt; relations are not considered part of the system catalogs and will be moved. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">テーブルスペースの現在のデータベース内のすべてのテーブルは、 &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; フォームを使用して移動できます。これは、最初に移動するすべてのテーブルをロックしてから、それぞれを移動します。このフォームは &lt;code&gt;OWNED BY&lt;/code&gt; もサポートしており、指定されたロールが所有するテーブルのみを移動します。 &lt;code&gt;NOWAIT&lt;/code&gt; オプションが指定されている場合、必要なすべてのロックをすぐに取得できないと、コマンドは失敗します。システムカタログはこのコマンドでは移動されないことに注意してください。使用 &lt;code&gt;ALTER DATABASE&lt;/code&gt; または明示的な &lt;code&gt;ALTER TABLE&lt;/code&gt; の必要に応じて、代わりに呼び出しを。 &lt;code&gt;information_schema&lt;/code&gt; 関係は、システムカタログの一部とは見なされず、移動されます。&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="fba1b0761d495deac6051791b1b8f0b77af030f7" translate="yes" xml:space="preserve">
          <source>All the GiST support methods are normally called in short-lived memory contexts; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will get reset after each tuple is processed. It is therefore not very important to worry about pfree'ing everything you palloc. However, in some cases it's useful for a support method to cache data across repeated calls. To do that, allocate the longer-lived data in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt;, and keep a pointer to it in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt;. Such data will survive for the life of the index operation (e.g., a single GiST index scan, index build, or index tuple insertion). Be careful to pfree the previous value when replacing a &lt;code&gt;fn_extra&lt;/code&gt; value, or the leak will accumulate for the duration of the operation.</source>
          <target state="translated">すべてのGiSTサポートメソッドは、通常、短期間のメモリコンテキストで呼び出されます。つまり、 &lt;code&gt;CurrentMemoryContext&lt;/code&gt; は、各タプルが処理された後にリセットされます。したがって、pallocしたすべてのものをpfreeすることを心配することはあまり重要ではありません。ただし、場合によっては、サポートメソッドが繰り返しの呼び出しにわたってデータをキャッシュすることが役立ちます。これを行うには、より長い寿命のデータを &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt; に割り当て、そのデータへのポインターを &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt; に保持します。そのようなデータは、インデックス操作（たとえば、単一のGiSTインデックススキャン、インデックスビルド、またはインデックスタプルの挿入）の存続期間中存続します。 &lt;code&gt;fn_extra&lt;/code&gt; 値を置き換えるときは、前の値を解放するように注意してください。そうしないと、操作中にリークが蓄積します。</target>
        </trans-unit>
        <trans-unit id="1775f572f652b9b020df7dce36fbde055a9f9549" translate="yes" xml:space="preserve">
          <source>All the SP-GiST support methods are normally called in a short-lived memory context; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will be reset after processing of each tuple. It is therefore not very important to worry about pfree'ing everything you palloc. (The &lt;code&gt;config&lt;/code&gt; method is an exception: it should try to avoid leaking memory. But usually the &lt;code&gt;config&lt;/code&gt; method need do nothing but assign constants into the passed parameter struct.)</source>
          <target state="translated">すべてのSP-GiSTサポートメソッドは通常、存続期間の短いメモリコンテキストで呼び出されます。つまり、各タプルの処理後に &lt;code&gt;CurrentMemoryContext&lt;/code&gt; がリセットされます。したがって、pallocしたすべてのものをpfreeすることを心配することはあまり重要ではありません。（ &lt;code&gt;config&lt;/code&gt; メソッドは例外です。メモリのリークを回避する必要があります。ただし、通常、 &lt;code&gt;config&lt;/code&gt; メソッドは渡されたパラメーター構造体に定数を割り当てるだけで十分です。）</target>
        </trans-unit>
        <trans-unit id="45bde084b879a44097ffbb7f22a89ae3a6f15f28" translate="yes" xml:space="preserve">
          <source>All the actions except &lt;code&gt;RENAME&lt;/code&gt; and &lt;code&gt;SET SCHEMA&lt;/code&gt; can be combined into a list of multiple alterations to apply in parallel. For example, it is possible to add several columns and/or alter the type of several columns in a single command.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; と &lt;code&gt;SET SCHEMA&lt;/code&gt; を除くすべてのアクションは、複数の変更のリストに組み合わせて、並行して適用できます。たとえば、1つのコマンドで複数の列を追加したり、複数の列のタイプを変更したりすることができます。</target>
        </trans-unit>
        <trans-unit id="510081c46bee5d125d10e16db44ba6aa06aa8209" translate="yes" xml:space="preserve">
          <source>All the aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;Table 9.57&lt;/a&gt; ignore null values in their sorted input. For those that take a &lt;code&gt;fraction&lt;/code&gt; parameter, the fraction value must be between 0 and 1; an error is thrown if not. However, a null fraction value simply produces a null result.</source>
          <target state="translated">&lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;表9.57に&lt;/a&gt;リストされているすべての集約は、ソートされた入力のnull値を無視します。 &lt;code&gt;fraction&lt;/code&gt; パラメーターを取るものの場合、分数の値は0から1の間でなければなりません。そうでない場合はエラーがスローされます。ただし、NULLの小数値は単にNULLの結果を生成します。</target>
        </trans-unit>
        <trans-unit id="51ab62b62647a9e48b750694e717b8b41fe65f92" translate="yes" xml:space="preserve">
          <source>All the backslash commands of a given conditional block must appear in the same source file. If EOF is reached on the main input file or an &lt;code&gt;\include&lt;/code&gt;-ed file before all local &lt;code&gt;\if&lt;/code&gt;-blocks have been closed, then psql will raise an error.</source>
          <target state="translated">特定の条件付きブロックのすべてのバックスラッシュコマンドは、同じソースファイルに存在する必要があります。すべてのローカルの &lt;code&gt;\if&lt;/code&gt; -blocksが閉じられる前にメイン入力ファイルまたは &lt;code&gt;\include&lt;/code&gt; -edファイルでEOFに到達すると、psqlはエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="c3df3ceb9c111c6a03e79138ef843c3f5502324f" translate="yes" xml:space="preserve">
          <source>All the constraints that refer to the index are changed to refer to the new index definition, and the names of the indexes are changed. At this point, &lt;code&gt;pg_index.indisvalid&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; for the new index and to &amp;ldquo;false&amp;rdquo; for the old, and a cache invalidation is done causing all sessions that referenced the old index to be invalidated.</source>
          <target state="translated">インデックスを参照するすべての制約が新しいインデックス定義を参照するように変更され、インデックスの名前が変更されます。この時点で、 &lt;code&gt;pg_index.indisvalid&lt;/code&gt; は新しいインデックスでは「true」に、古いインデックスでは「false」に切り替えられ、キャッシュの無効化が行われて、古いインデックスを参照していたすべてのセッションが無効になります。</target>
        </trans-unit>
        <trans-unit id="58e9eb20e27c19e1e0424c58bd8a9c7b575ba760" translate="yes" xml:space="preserve">
          <source>All the date/time data types also accept the special literal value &lt;code&gt;now&lt;/code&gt; to specify the current date and time (again, interpreted as the transaction start time). Thus, the following three all return the same result:</source>
          <target state="translated">すべての日付/時刻データ型も特別なリテラル値を受け入れ &lt;code&gt;now&lt;/code&gt; （再び、トランザクションの開始時刻と解釈される）現在の日付と時刻を指定します。したがって、次の3つはすべて同じ結果を返します。</target>
        </trans-unit>
        <trans-unit id="04a9db0f3580dacac057df2d96a2b53bd9011eea" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt;.</source>
          <target state="translated">すべての詳細は、 &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="7055165401c8e4a16f7e52ca1e39b100c0c219f9" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt;.</source>
          <target state="translated">詳細はすべて &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="11f6c8098d40647f8499682bcc9a9b6ba89c0f7d" translate="yes" xml:space="preserve">
          <source>All the forms of ALTER TABLE that act on a single table, except &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;SET SCHEMA&lt;/code&gt;, &lt;code&gt;ATTACH PARTITION&lt;/code&gt;, and &lt;code&gt;DETACH PARTITION&lt;/code&gt; can be combined into a list of multiple alterations to be applied together. For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 、 &lt;code&gt;SET SCHEMA&lt;/code&gt; 、 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 、および &lt;code&gt;DETACH PARTITION&lt;/code&gt; を除いて、単一のテーブルに作用するすべての形式のALTER TABLEは、一緒に適用される複数の変更のリストに組み合わせることができます。たとえば、1つのコマンドで複数の列を追加したり、複数の列のタイプを変更したりすることができます。これは、テーブルを1回だけ通過する必要があるため、大きなテーブルで特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f31e857d83f608bd0b8b4018bcb4f55f12705482" translate="yes" xml:space="preserve">
          <source>All the functions and operators described below that take &lt;code&gt;time&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt; inputs actually come in two variants: one that takes &lt;code&gt;time with time zone&lt;/code&gt; or &lt;code&gt;timestamp with time zone&lt;/code&gt;, and one that takes &lt;code&gt;time without time zone&lt;/code&gt; or &lt;code&gt;timestamp without time zone&lt;/code&gt;. For brevity, these variants are not shown separately. Also, the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators come in commutative pairs (for example both date + integer and integer + date); we show only one of each such pair.</source>
          <target state="translated">そのテイクの下に記載されているすべての関数と演算子 &lt;code&gt;time&lt;/code&gt; または &lt;code&gt;timestamp&lt;/code&gt; かかる1：入力は、実際には2つの種類が来る &lt;code&gt;time with time zone&lt;/code&gt; か、 &lt;code&gt;timestamp with time zone&lt;/code&gt; 、およびかかる1 &lt;code&gt;time without time zone&lt;/code&gt; か、 &lt;code&gt;timestamp without time zone&lt;/code&gt; 。簡潔にするため、これらのバリアントは個別に表示されていません。また、 &lt;code&gt;+&lt;/code&gt; 演算子と &lt;code&gt;*&lt;/code&gt; 演算子は可換ペアになります（たとえば、日付+整数と整数+日付の両方）。そのような各ペアの1つだけを示します。</target>
        </trans-unit>
        <trans-unit id="782a3c585f1fd27c2deebeab5aeef9142292fec9" translate="yes" xml:space="preserve">
          <source>All the items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; as well as &lt;code&gt;jsonb_insert&lt;/code&gt; except the last item must be present in the &lt;code&gt;target&lt;/code&gt;. If &lt;code&gt;create_missing&lt;/code&gt; is false, all items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; must be present. If these conditions are not met the &lt;code&gt;target&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">最後の項目を除く &lt;code&gt;jsonb_insert&lt;/code&gt; および &lt;code&gt;jsonb_set&lt;/code&gt; の &lt;code&gt;path&lt;/code&gt; パラメータのすべての項目は、 &lt;code&gt;target&lt;/code&gt; 存在する必要があります。場合 &lt;code&gt;create_missing&lt;/code&gt; は falseで、すべての項目 &lt;code&gt;path&lt;/code&gt; のパラメータ &lt;code&gt;jsonb_set&lt;/code&gt; が存在している必要があります。これらの条件が満たされない場合、 &lt;code&gt;target&lt;/code&gt; は変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="16b021d730b6ad62e07cfcc798d60a9ae4e55f2d" translate="yes" xml:space="preserve">
          <source>All the other details are the same as explained in the previous item.</source>
          <target state="translated">その他の詳細は前項目で説明した通りです。</target>
        </trans-unit>
        <trans-unit id="58d1929aa1a1a6a3046413da0a4c92627889c5ff" translate="yes" xml:space="preserve">
          <source>All the text search functions that accept an optional &lt;code&gt;regconfig&lt;/code&gt; argument will use the configuration specified by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; when that argument is omitted.</source>
          <target state="translated">オプションの &lt;code&gt;regconfig&lt;/code&gt; 引数を受け入れるすべてのテキスト検索関数は、その引数が省略されている場合、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_configで&lt;/a&gt;指定された構成を使用します。</target>
        </trans-unit>
        <trans-unit id="5fd8eaf630761d65327b4b1a07fcbae46e8425a5" translate="yes" xml:space="preserve">
          <source>All these actions are performed using the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command, whose reference page contains details beyond those given here.</source>
          <target state="translated">これらのアクションはすべて、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;コマンドを使用して実行されます。そのリファレンスページには、ここに記載されている以上の詳細が含まれています。</target>
        </trans-unit>
        <trans-unit id="fddab2dff735a90badf611e7a98983fea7c65273" translate="yes" xml:space="preserve">
          <source>All these functions require object OIDs to identify the object to be checked. If you want to test an object by name, it is convenient to use the OID alias types (&lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, or &lt;code&gt;regdictionary&lt;/code&gt;), for example:</source>
          <target state="translated">これらすべての関数には、チェックするオブジェクトを識別するためのオブジェクトOIDが必要です。オブジェクトを名前でテストする場合は、OIDエイリアスタイプ（ &lt;code&gt;regclass&lt;/code&gt; 、 &lt;code&gt;regtype&lt;/code&gt; 、 &lt;code&gt;regprocedure&lt;/code&gt; 、 &lt;code&gt;regoperator&lt;/code&gt; 、 &lt;code&gt;regconfig&lt;/code&gt; 、または &lt;code&gt;regdictionary&lt;/code&gt; ）を使用すると便利です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="5eb86c80e753870bd74e864dca4813e41a9bf81c" translate="yes" xml:space="preserve">
          <source>All this is encrypted with the session key and placed in the data packet.</source>
          <target state="translated">これらはすべてセッションキーで暗号化され、データパケットに入れられます。</target>
        </trans-unit>
        <trans-unit id="79ae9218d6216a25f546357f769737d4eb8e6a9b" translate="yes" xml:space="preserve">
          <source>All this is happening within the transaction block, so none of it is visible to other database sessions. When and if you commit the transaction block, the committed actions become visible as a unit to other sessions, while the rolled-back actions never become visible at all.</source>
          <target state="translated">これらはすべてトランザクションブロック内で起こっているので、他のデータベースセッションからは何も見えません。トランザクションブロックをコミットすると、コミットされたアクションは他のセッションからユニットとして見えるようになりますが、ロールバックされたアクションは全く見えなくなります。</target>
        </trans-unit>
        <trans-unit id="f5fad09671c41f98ab40f3e4d5ed6015e3ae8fcb" translate="yes" xml:space="preserve">
          <source>All timezone-aware dates and times are stored internally in UTC. They are converted to local time in the zone specified by the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; configuration parameter before being displayed to the client.</source>
          <target state="translated">すべてのタイムゾーン対応の日付と時刻は、内部でUTCに格納されています。これらは、クライアントに表示される前に、&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;構成パラメーターで指定されたゾーンの現地時間に変換されます。</target>
        </trans-unit>
        <trans-unit id="d5322b3927e2a3af2ef8b19f81ff10045b29cd91" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfrozenxid&lt;/code&gt; values.</source>
          <target state="translated">これより前のすべてのトランザクションIDは、このデータベースで永続的な（「凍結された」）トランザクションIDに置き換えられています。これは、トランザクションIDの折り返しを防止したり、 &lt;code&gt;pg_xact&lt;/code&gt; を縮小したりするために、データベースをバキュームする必要があるかどうかを追跡するために使用されます。これは、テーブルごとの &lt;code&gt;pg_class&lt;/code&gt; の最小値です。 &lt;code&gt;relfrozenxid&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="086e1ad2933d663306e6cec529b31029a01389df" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidTransactionId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">この表の前のすべてのトランザクションIDは、永続的な（「凍結された」）トランザクションIDに置き換えられています。これは、トランザクションIDの折り返しを防止したり、 &lt;code&gt;pg_xact&lt;/code&gt; を縮小したりするために、テーブルをバキュームする必要があるかどうかを追跡するために使用されます。リレーションがテーブルでない場合はゼロ（ &lt;code&gt;InvalidTransactionId&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f420391c504d54ccc175474041008eed502760b8" translate="yes" xml:space="preserve">
          <source>All type conversion rules are designed with several principles in mind:</source>
          <target state="translated">すべてのタイプ変換ルールは、いくつかの原則を念頭に置いて設計されています。</target>
        </trans-unit>
        <trans-unit id="109d3489123ca72cb87beebd6d4f929a800626a1" translate="yes" xml:space="preserve">
          <source>All values must be single-quoted. Escape single quotes used within a value with a backslash. Backslashes meant as data can, but need not, be doubled; this follows Perl's rules for simple quoted literals. Note that backslashes appearing as data will be treated as escapes by the bootstrap scanner, according to the same rules as for escape string constants (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;); for example &lt;code&gt;\t&lt;/code&gt; converts to a tab character. If you actually want a backslash in the final value, you will need to write four of them: Perl strips two, leaving &lt;code&gt;\\&lt;/code&gt; for the bootstrap scanner to see.</source>
          <target state="translated">すべての値は単一引用符で囲む必要があります。値内で使用されている単一引用符をバックスラッシュでエスケープします。データとしてのバックスラッシュは2倍にすることができますが、2倍にする必要はありません。これは、単純な引用符付きリテラルに関するPerlの規則に従います。データとして表示されるバックスラッシュは、エスケープ文字列定数と同じルールに従って（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;セクション4.1.2.2を&lt;/a&gt;参照）、ブートストラップスキャナーによってエスケープとして扱われることに注意してください。たとえば、 &lt;code&gt;\t&lt;/code&gt; はタブ文字に変換されます。最終値に実際にバックスラッシュが必要な場合は、4つ記述する必要があります。Perlは2つを &lt;code&gt;\\&lt;/code&gt; 、ブートストラップスキャナーが表示できるように\\を残します。</target>
        </trans-unit>
        <trans-unit id="b86517f687c2cdb1c2c9f1b4d883ebc3f627ec3f" translate="yes" xml:space="preserve">
          <source>All weather records belonging to Hayward are removed.</source>
          <target state="translated">ヘイワードに属する気象記録はすべて削除されます。</target>
        </trans-unit>
        <trans-unit id="ad7019350bb4e8cf04fe867a5271fe82db68f450" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Andrey Oktyabrski did a great work on adding new functions and operations.</source>
          <target state="translated">すべての作業はTeodor Sigaev（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; ）とOleg Bartunov（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ）によって行われました。詳細については、&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http：//www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;を参照してください。Andrey Oktyabrskiは、新しい機能と操作を追加するのに素晴らしい仕事をしました。</target>
        </trans-unit>
        <trans-unit id="4288707b0efed23059331a4d938505610024687d" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Authors would like to thank Eugeny Rodichev for helpful discussions. Comments and bug reports are welcome.</source>
          <target state="translated">すべての作業はTeodor Sigaev（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt; ）とOleg Bartunov（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ）によって行われました。詳細については、&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http：//www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;を参照してください。著者は、有益な議論をしてくれたEugeny Rodichevに感謝します。コメントやバグレポートは大歓迎です。</target>
        </trans-unit>
        <trans-unit id="f34719d5f269658e4173abae81da05904e2f90b4" translate="yes" xml:space="preserve">
          <source>Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.</source>
          <target state="translated">データベースサーバ上のプログラムを、COPYなどのサーバサイドプログラムの実行を許可する機能で、データベースが実行するユーザとして実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="cb7c466538ce28419fa5a720e552c9faf281f480" translate="yes" xml:space="preserve">
          <source>Allow question mark as placeholder for compatibility reasons. This used to be the default long ago.</source>
          <target state="translated">互換性の理由からプレースホルダとしてクエスチョンマークを許可します。これはずっと前まではデフォルトでした。</target>
        </trans-unit>
        <trans-unit id="45c4206b6f2ee2080c8508868577dbea292b358b" translate="yes" xml:space="preserve">
          <source>Allow reading files from any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">データベースがサーバ上でアクセスできる任意の場所から、COPYや他のファイルアクセス機能を使ってファイルを読み込めるようにします。</target>
        </trans-unit>
        <trans-unit id="4f03ae30c79df36f9c350de6f69bb0b74ebd9a17" translate="yes" xml:space="preserve">
          <source>Allow the connection unconditionally. This method allows anyone that can connect to the PostgreSQL database server to login as any PostgreSQL user they wish, without the need for a password or any other authentication. See &lt;a href=&quot;auth-trust&quot;&gt;Section 20.4&lt;/a&gt; for details.</source>
          <target state="translated">無条件に接続を許可します。この方法では、PostgreSQLデータベースサーバーに接続できるすべてのユーザーが、パスワードやその他の認証を必要とせずに、希望するPostgreSQLユーザーとしてログインできます。詳細は&lt;a href=&quot;auth-trust&quot;&gt;項20.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="015b98532a3fe432082ea0986c77ac2b5c3dbd03" translate="yes" xml:space="preserve">
          <source>Allow writing to files in any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">データベースがサーバ上でアクセスできる任意の場所にあるファイルへの書き込みを、COPYや他のファイルアクセス機能を使って許可します。</target>
        </trans-unit>
        <trans-unit id="f8d71f61a1ee50e974ca597aaf1819fc96625f9e" translate="yes" xml:space="preserve">
          <source>Allowed Access</source>
          <target state="translated">許可されたアクセス</target>
        </trans-unit>
        <trans-unit id="76b9c247fd0d4d88ff31bffe6ae1c77fef7baa54" translate="yes" xml:space="preserve">
          <source>Allowed values of an enum parameter (null for non-enum values)</source>
          <target state="translated">enum パラメータの許容値 (enum 以外の値の場合は null)</target>
        </trans-unit>
        <trans-unit id="52773c9887de8a80602d4df5e04153e486ddd9ba" translate="yes" xml:space="preserve">
          <source>Allowed, but not in PG</source>
          <target state="translated">許可されていますが、PGでは許可されていません。</target>
        </trans-unit>
        <trans-unit id="70154177253445e1612a606653b6fcdbcd216626" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; of a row from a table, view, etc. (In practice, any nontrivial &lt;code&gt;DELETE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to delete.)</source>
          <target state="translated">テーブル、ビューなどからの行の&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;を許可します（削除する行を決定するためにテーブルの列を参照する必要があるため、実際には、重要な &lt;code&gt;DELETE&lt;/code&gt; コマンドも &lt;code&gt;SELECT&lt;/code&gt; 特権を必要とします。）</target>
        </trans-unit>
        <trans-unit id="892a331d54a97c6a90c5cbe15f359d1d4e9d66bd" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; of a new row into a table, view, etc. Can be granted on specific column(s), in which case only those columns may be assigned to in the &lt;code&gt;INSERT&lt;/code&gt; command (other columns will therefore receive default values). Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM.</source>
          <target state="translated">テーブルやビューなどへの新しい行の&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;を許可します。特定の列に付与できます。その場合、 &lt;code&gt;INSERT&lt;/code&gt; コマンドでそれらの列のみを割り当てることができます（したがって、他の列はデフォルト値を受け取ります）。&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROMの使用も許可します。</target>
        </trans-unit>
        <trans-unit id="91a5de46959e59448d7fbb7e22418ff9bdc9f1e0" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; from any column, or specific column(s), of a table, view, materialized view, or other table-like object. Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO. This privilege is also needed to reference existing column values in &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;. For sequences, this privilege also allows use of the &lt;code&gt;currval&lt;/code&gt; function. For large objects, this privilege allows the object to be read.</source>
          <target state="translated">テーブル、ビュー、マテリアライズドビュー、またはその他のテーブルのようなオブジェクトの任意の列または特定の列からの&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;を許可します。&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TOの使用も許可します。この特権は、&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;または&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;で既存の列値を参照するためにも必要です。シーケンスの場合、この特権は &lt;code&gt;currval&lt;/code&gt; 関数の使用も許可します。大きなオブジェクトの場合、この権限により、オブジェクトを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="504fe161b61ac15d1f6a3f6705ae69c3e419baf8" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; on a table, view, etc.</source>
          <target state="translated">テーブル、ビューなどで&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;を許可します。</target>
        </trans-unit>
        <trans-unit id="82bfc74ea2d5fe544ab86144ec140977da660bfb" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; of any column, or specific column(s), of a table, view, etc. (In practice, any nontrivial &lt;code&gt;UPDATE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to update, and/or to compute new values for columns.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; also require this privilege on at least one column, in addition to the &lt;code&gt;SELECT&lt;/code&gt; privilege. For sequences, this privilege allows use of the &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; functions. For large objects, this privilege allows writing or truncating the object.</source>
          <target state="translated">テーブル、ビューなどの任意の列、または特定の列の&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;を許可します（実際には、重要な &lt;code&gt;UPDATE&lt;/code&gt; コマンドでも、更新する行を決定するためにテーブル列を参照する必要があるため、 &lt;code&gt;SELECT&lt;/code&gt; 特権が必要になります。 /または列の新しい値を計算するには。） &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; および &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; には、 &lt;code&gt;SELECT&lt;/code&gt; 特権に加えて、少なくとも1つの列に対するこの特権も必要です。シーケンスの場合、この特権により、 &lt;code&gt;nextval&lt;/code&gt; および &lt;code&gt;setval&lt;/code&gt; 関数を使用できます。大きなオブジェクトの場合、この権限により、オブジェクトの書き込みまたは切り捨てが可能になります。</target>
        </trans-unit>
        <trans-unit id="8b7544659291101bf531ad89a7c0f68e28dd25e9" translate="yes" xml:space="preserve">
          <source>Allows calling a function or procedure, including use of any operators that are implemented on top of the function. This is the only type of privilege that is applicable to functions and procedures.</source>
          <target state="translated">関数またはプロシージャの呼び出しを許可し、その関数の上に実装されている演算子の使用を含めて、関数またはプロシージャの呼び出しを許可します。これは、関数やプロシージャに適用される特権の唯一のタイプです。</target>
        </trans-unit>
        <trans-unit id="572f9c4ee818f964a8f341a7ab3b49d87de0de38" translate="yes" xml:space="preserve">
          <source>Allows creation of a foreign key constraint referencing a table, or specific column(s) of a table.</source>
          <target state="translated">テーブル、またはテーブルの特定の列を参照する外部キー制約の作成を許可します。</target>
        </trans-unit>
        <trans-unit id="3f1fc4350d1383af032d326e29b30797181bb0ee" translate="yes" xml:space="preserve">
          <source>Allows creation of a trigger on a table, view, etc.</source>
          <target state="translated">テーブルやビューなどにトリガーを作成することができます。</target>
        </trans-unit>
        <trans-unit id="3cd1d90a2a8e348dc3397a5abdad6812b9706afc" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details.</source>
          <target state="translated">システムとデータベースのユーザー名の間のマッピングを可能にします。詳細は&lt;a href=&quot;auth-username-maps&quot;&gt;項20.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="62730a57186fa6b4b57c86a98eed1f6819a0f0da" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a GSSAPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">システムとデータベースのユーザー名の間のマッピングを可能にします。詳細は&lt;a href=&quot;auth-username-maps&quot;&gt;項20.2&lt;/a&gt;を参照してください。 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （または、あまり一般的ではないが、 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; /hostbased@EXAMPLE.COM）などのGSSAPI / Kerberosプリンシパルの場合、マッピングに使用されるユーザー名は、 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （または &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )です。それぞれ））、 &lt;code&gt;include_realm&lt;/code&gt; が0に設定されていない限り、その場合、 &lt;code&gt;username&lt;/code&gt; （または &lt;code&gt;username/hostbased&lt;/code&gt; ）は、マッピング時にシステムユーザー名と見なされます。</target>
        </trans-unit>
        <trans-unit id="3a8e3ba433eb210e869a35f227d0944a825933f7" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a SSPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">システムとデータベースのユーザー名の間のマッピングを可能にします。詳細は&lt;a href=&quot;auth-username-maps&quot;&gt;項20.2&lt;/a&gt;を参照してください。 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （または、あまり一般的ではないが、 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; /hostbased@EXAMPLE.COM）などのSSPI / Kerberosプリンシパルの場合、マッピングに使用されるユーザー名は、 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （または &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )です。それぞれ））、 &lt;code&gt;include_realm&lt;/code&gt; が0に設定されていない限り、その場合、 &lt;code&gt;username&lt;/code&gt; （または &lt;code&gt;username/hostbased&lt;/code&gt; ）は、マッピング時にシステムユーザー名と見なされます。</target>
        </trans-unit>
        <trans-unit id="b64278e6ff1ecca0c4404ebfb33c1f4ece933ea1" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables. This is used by &lt;code&gt;initdb&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">システムテーブルの構造を変更できます。これは &lt;code&gt;initdb&lt;/code&gt; によって使用されます。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="f71053472aff6714ed79ad6bf71416990ec41156" translate="yes" xml:space="preserve">
          <source>Allows multiple master servers</source>
          <target state="translated">複数のマスターサーバーを使用可能</target>
        </trans-unit>
        <trans-unit id="7e9d5d5ab57892df439ee070a4596c150e6f73e7" translate="yes" xml:space="preserve">
          <source>Allows remote clients to connect via TCP/IP (Internet domain) connections. Without this option, only local connections are accepted. This option is equivalent to setting &lt;code&gt;listen_addresses&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; or via &lt;code&gt;-h&lt;/code&gt;.</source>
          <target state="translated">リモートクライアントがTCP / IP（インターネットドメイン）接続を介して接続できるようにします。このオプションがない場合、ローカル接続のみが受け入れられます。このオプションは、 &lt;code&gt;postgresql.conf&lt;/code&gt; または &lt;code&gt;-h&lt;/code&gt; で &lt;code&gt;listen_addresses&lt;/code&gt; を &lt;code&gt;*&lt;/code&gt; に設定することと同等です。</target>
        </trans-unit>
        <trans-unit id="63eeac10a55f83f249e5c5462559d1f7da0f93f8" translate="yes" xml:space="preserve">
          <source>Allows temporary tables to be created while using the database.</source>
          <target state="translated">データベースを使用している間に一時的なテーブルを作成できるようにします。</target>
        </trans-unit>
        <trans-unit id="08e9a64b986b6e59ae70cdec6ed43f46a0d1ac74" translate="yes" xml:space="preserve">
          <source>Allows the grantee to connect to the database. This privilege is checked at connection startup (in addition to checking any restrictions imposed by &lt;code&gt;pg_hba.conf&lt;/code&gt;).</source>
          <target state="translated">権限受領者がデータベースに接続できるようにします。この権限は、接続の起動時にチェックされます（ &lt;code&gt;pg_hba.conf&lt;/code&gt; によって課された制限のチェックに加えて）。</target>
        </trans-unit>
        <trans-unit id="755cae42faeb86185341cbd11d37dba18dac7fda" translate="yes" xml:space="preserve">
          <source>Allows the leader process to execute the query plan under &lt;code&gt;Gather&lt;/code&gt; and &lt;code&gt;Gather Merge&lt;/code&gt; nodes instead of waiting for worker processes. The default is &lt;code&gt;on&lt;/code&gt;. Setting this value to &lt;code&gt;off&lt;/code&gt; reduces the likelihood that workers will become blocked because the leader is not reading tuples fast enough, but requires the leader process to wait for worker processes to start up before the first tuples can be produced. The degree to which the leader can help or hinder performance depends on the plan type, number of workers and query duration.</source>
          <target state="translated">リーダープロセスが、ワーカープロセスを待つ代わりに、 &lt;code&gt;Gather&lt;/code&gt; および &lt;code&gt;Gather Merge&lt;/code&gt; ノードの下でクエリプランを実行できるようにします。デフォルトは &lt;code&gt;on&lt;/code&gt; です。この値を &lt;code&gt;off&lt;/code&gt; 設定すると、リーダーがタプルを十分に速く読み取らないためにワーカーがブロックされる可能性が低くなりますが、最初のタプルが生成される前にリーダープロセスがワーカープロセスの起動を待機する必要があります。リーダーがパフォーマンスを支援または阻害できる度合いは、プランのタイプ、ワーカーの数、クエリの期間によって異なります。</target>
        </trans-unit>
        <trans-unit id="65de6c1d93f488d023688afb5ecd9e64a2816fb2" translate="yes" xml:space="preserve">
          <source>Allows the structure of system tables to be modified. This is used by &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">システムテーブルの構造を変更できます。これは &lt;code&gt;initdb&lt;/code&gt; によって使用されます。</target>
        </trans-unit>
        <trans-unit id="eb3d21c22361245b017a84ef20398543e1812a86" translate="yes" xml:space="preserve">
          <source>Allows the use of parallel queries for testing purposes even in cases where no performance benefit is expected. The allowed values of &lt;code&gt;force_parallel_mode&lt;/code&gt; are &lt;code&gt;off&lt;/code&gt; (use parallel mode only when it is expected to improve performance), &lt;code&gt;on&lt;/code&gt; (force parallel query for all queries for which it is thought to be safe), and &lt;code&gt;regress&lt;/code&gt; (like &lt;code&gt;on&lt;/code&gt;, but with additional behavior changes as explained below).</source>
          <target state="translated">パフォーマンスの向上が期待できない場合でも、テスト目的で並列クエリを使用できます。 &lt;code&gt;force_parallel_mode&lt;/code&gt; の許容値は、 &lt;code&gt;off&lt;/code&gt; （パフォーマンスの向上が期待される場合にのみ並列モードを使用）、 &lt;code&gt;on&lt;/code&gt; （安全であると考えられるすべてのクエリに対して並列クエリを強制）、および &lt;code&gt;regress&lt;/code&gt; （ &lt;code&gt;on&lt;/code&gt; と同様ですが、動作の変更が追加されています）以下で説明します）。</target>
        </trans-unit>
        <trans-unit id="8f83e0d9b7de16d5d69bb100f20671e8c51dd641" translate="yes" xml:space="preserve">
          <source>Allows users in the same group as the cluster owner to read all cluster files created by &lt;code&gt;initdb&lt;/code&gt;. This option is ignored on Windows as it does not support POSIX-style group permissions.</source>
          <target state="translated">クラスター所有者と同じグループのユーザーは、 &lt;code&gt;initdb&lt;/code&gt; によって作成されたすべてのクラスターファイルを読み取ることができます。このオプションはPOSIXスタイルのグループ権限をサポートしないため、Windowsでは無視されます。</target>
        </trans-unit>
        <trans-unit id="4cc45bc94d25b1e0d694fb6d8a93df9410ca68c9" translate="yes" xml:space="preserve">
          <source>Almost all &lt;code&gt;DROP&lt;/code&gt; commands in PostgreSQL support specifying &lt;code&gt;CASCADE&lt;/code&gt;. Of course, the nature of the possible dependencies varies with the type of the object. You can also write &lt;code&gt;RESTRICT&lt;/code&gt; instead of &lt;code&gt;CASCADE&lt;/code&gt; to get the default behavior, which is to prevent dropping objects that any other objects depend on.</source>
          <target state="translated">PostgreSQLのほとんどすべての &lt;code&gt;DROP&lt;/code&gt; コマンドは &lt;code&gt;CASCADE&lt;/code&gt; の指定をサポートしています。もちろん、可能な依存関係の性質はオブジェクトのタイプによって異なります。 &lt;code&gt;CASCADE&lt;/code&gt; の代わりに &lt;code&gt;RESTRICT&lt;/code&gt; を記述してデフォルトの動作を取得することもできます。これは、他のオブジェクトが依存しているオブジェクトのドロップを防ぐことです。</target>
        </trans-unit>
        <trans-unit id="328cfccc1cde2a65060e2ec7ece0e64b0b2e4b32" translate="yes" xml:space="preserve">
          <source>Also be careful when making up test data, which is often unavoidable when the application is not yet in production. Values that are very similar, completely random, or inserted in sorted order will skew the statistics away from the distribution that real data would have.</source>
          <target state="translated">また、テストデータを作成する際には、アプリケーションがまだ本番になっていない場合には避けられないことが多いので注意してください。値が非常に似ていたり、完全にランダムだったり、ソートされた順序で挿入されていたりすると、実際のデータが持つであろう分布から統計量が歪んでしまいます。</target>
        </trans-unit>
        <trans-unit id="1e6eb3c256a63ce7e1a4b490a67bfd7124a09fa5" translate="yes" xml:space="preserve">
          <source>Also calculate statistics for use by the optimizer.</source>
          <target state="translated">また、オプティマイザが使用するための統計を計算します。</target>
        </trans-unit>
        <trans-unit id="7f5b262e2738c5ae943ae295de4ef09eb42b98a8" translate="yes" xml:space="preserve">
          <source>Also note that some element types, such as &lt;code&gt;timestamp&lt;/code&gt;, have a notion of &quot;infinity&quot;, which is just another value that can be stored. This is different from &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt;, which are not real values that can be stored, but rather they are ways of saying that the value is unbounded. &lt;code&gt;MAXVALUE&lt;/code&gt; can be thought of as being greater than any other value, including &quot;infinity&quot; and &lt;code&gt;MINVALUE&lt;/code&gt; as being less than any other value, including &quot;minus infinity&quot;. Thus the range &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; is not an empty range; it allows precisely one value to be stored &amp;mdash; &quot;infinity&quot;.</source>
          <target state="translated">また、 &lt;code&gt;timestamp&lt;/code&gt; などの一部の要素タイプには、「無限」という概念があります。これは、格納できるもう1つの値です。これは異なっている &lt;code&gt;MINVALUE&lt;/code&gt; と &lt;code&gt;MAXVALUE&lt;/code&gt; 保存することができ、実際の値ではない、のではなく、彼らは値が無制限であることを言うの方法があります。 &lt;code&gt;MAXVALUE&lt;/code&gt; は「無限大」を含む他のどの値よりも大きいと考えることができ、 &lt;code&gt;MINVALUE&lt;/code&gt; は「マイナス無限大」を含む他のどの値よりも小さいと考えることができます。したがって、範囲 &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; は空の範囲ではありません。正確に1つの値を格納できます&amp;mdash;「無限」。</target>
        </trans-unit>
        <trans-unit id="7722ff63b95d490d6107aefdee57299789fdc839" translate="yes" xml:space="preserve">
          <source>Also of note to those converting from other environments is the fact that &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; does not ensure that a concurrent transaction will not update or delete a selected row. To do that in PostgreSQL you must actually update the row, even if no values need to be changed. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;&lt;em&gt;temporarily blocks&lt;/em&gt; other transactions from acquiring the same lock or executing an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; which would affect the locked row, but once the transaction holding this lock commits or rolls back, a blocked transaction will proceed with the conflicting operation unless an actual &lt;code&gt;UPDATE&lt;/code&gt; of the row was performed while the lock was held.</source>
          <target state="translated">また、他の環境から変換する場合の注意点として、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; は、並行トランザクションが選択された行を更新または削除しないことを保証していません。 PostgreSQLでこれを行うには、値を変更する必要がない場合でも、実際に行を更新する必要があります。 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; は、他のトランザクションが同じロックを取得すること、またはロックされた行に影響を与える &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; を実行することを&lt;em&gt;一時的にブロックし&lt;/em&gt;ますが、このロックを保持するトランザクションがコミットまたはロールバックすると、ブロックされたトランザクションは、実際の &lt;code&gt;UPDATE&lt;/code&gt; でない限り競合する操作を続行します。行がロックされている間に実行されました。</target>
        </trans-unit>
        <trans-unit id="43ae5053feb0121ca9119b68bf8c270c3a3bfe40" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;INHERITS&lt;/code&gt;, columns and constraints copied by &lt;code&gt;LIKE&lt;/code&gt; are not merged with similarly named columns and constraints. If the same name is specified explicitly or in another &lt;code&gt;LIKE&lt;/code&gt; clause, an error is signaled.</source>
          <target state="translated">また、 &lt;code&gt;INHERITS&lt;/code&gt; とは異なり、 &lt;code&gt;LIKE&lt;/code&gt; によってコピーされた列と制約は、同様の名前の列と制約とマージされません。同じ名前が明示的にまたは別の &lt;code&gt;LIKE&lt;/code&gt; 句で指定されている場合、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="4bd7db918c0ec048fb1da60e94aef9f53bffd77b" translate="yes" xml:space="preserve">
          <source>Also you can use an index on the &lt;code&gt;t&lt;/code&gt; column for word similarity or strict word similarity. Typical queries are:</source>
          <target state="translated">また、単語の類似性または厳密な単語の類似性のために &lt;code&gt;t&lt;/code&gt; 列のインデックスを使用できます。一般的なクエリは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d4ce61ad95c8576f718ac10e1c2327127884475a" translate="yes" xml:space="preserve">
          <source>Also you can use the standard SQL syntax &lt;code&gt;SET NAMES&lt;/code&gt; for this purpose:</source>
          <target state="translated">また、この目的で標準SQL構文 &lt;code&gt;SET NAMES&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="a6c555a30398b57943351e6fa4960aad56c86fc4" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;*&lt;/code&gt; can be attached to a lexeme to specify prefix matching:</source>
          <target state="translated">また、 &lt;code&gt;*&lt;/code&gt; を語彙素に付加して、プレフィックスの一致を指定できます。</target>
        </trans-unit>
        <trans-unit id="9a92606f5ea158e9240f422542ed2e1cf20e61fc" translate="yes" xml:space="preserve">
          <source>Also, GIN index supports &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, which perform &lt;code&gt;jsonpath&lt;/code&gt; matching.</source>
          <target state="translated">また、GINインデックスは &lt;code&gt;@@&lt;/code&gt; および &lt;code&gt;@?&lt;/code&gt; をサポートします。 &lt;code&gt;jsonpath&lt;/code&gt; マッチングを実行する演算子。</target>
        </trans-unit>
        <trans-unit id="33ec741b0c71e2493174674607bdd7cee851a3f4" translate="yes" xml:space="preserve">
          <source>Also, a reverse lookup is necessary to implement the suffix matching feature, because the actual client host name needs to be known in order to match it against the pattern.</source>
          <target state="translated">また、サフィックスマッチング機能を実装するためには、実際のクライアントホスト名を知っておく必要があるため、逆引きが必要です。</target>
        </trans-unit>
        <trans-unit id="dbee7ce8bd2c9aaff2ced252585c86f91ebda134" translate="yes" xml:space="preserve">
          <source>Also, a trigger definition can specify a Boolean &lt;code&gt;WHEN&lt;/code&gt; condition, which will be tested to see whether the trigger should be fired. In row-level triggers the &lt;code&gt;WHEN&lt;/code&gt; condition can examine the old and/or new values of columns of the row. Statement-level triggers can also have &lt;code&gt;WHEN&lt;/code&gt; conditions, although the feature is not so useful for them since the condition cannot refer to any values in the table.</source>
          <target state="translated">また、トリガー定義はブール &lt;code&gt;WHEN&lt;/code&gt; 条件を指定できます。これは、トリガーを起動する必要があるかどうかを確認するためにテストされます。行レベルのトリガーでは、 &lt;code&gt;WHEN&lt;/code&gt; 条件は行の列の古い値または新しい値、あるいはその両方を調べることができます。ステートメントレベルのトリガーには &lt;code&gt;WHEN&lt;/code&gt; 条件を設定することもできますが、条件はテーブル内の値を参照できないため、この機能はあまり役に立ちません。</target>
        </trans-unit>
        <trans-unit id="51c091c0aef22b8b4cc2fa3614299c508ab0362c" translate="yes" xml:space="preserve">
          <source>Also, by default there is limited information available about the selectivity of functions. However, if you create an expression index that uses a function call, useful statistics will be gathered about the function, which can greatly improve query plans that use the expression index.</source>
          <target state="translated">また、デフォルトでは関数の選択性について利用できる情報は限られています。しかし、関数呼び出しを使用する式インデックスを作成した場合、関数について有用な統計情報が収集され、式インデックスを使用するクエリプランを大幅に改善することができます。</target>
        </trans-unit>
        <trans-unit id="918098440d0526280449d26ec531d4e4ea959670" translate="yes" xml:space="preserve">
          <source>Also, for B-tree indexes, a freshly-constructed index is slightly faster to access than one that has been updated many times because logically adjacent pages are usually also physically adjacent in a newly built index. (This consideration does not apply to non-B-tree indexes.) It might be worthwhile to reindex periodically just to improve access speed.</source>
          <target state="translated">また、B-treeインデックスの場合、何度も更新されたインデックスよりも、新しく構築されたばかりのインデックスの方がアクセス速度が若干速くなります(この考慮はB-tree以外のインデックスには適用されません)。(この考慮事項は非B-treeインデックスには適用されません。)アクセス速度を向上させるためだけに定期的にインデックスを更新することは価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="be3a3382ab5cfef83a6b9ee1e118c05d47eb696d" translate="yes" xml:space="preserve">
          <source>Also, for data types for which there is a natural distance metric, &lt;code&gt;btree_gist&lt;/code&gt; defines a distance operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and provides GiST index support for nearest-neighbor searches using this operator. Distance operators are provided for &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, &lt;code&gt;timestamp with time zone&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, &lt;code&gt;time without time zone&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, and &lt;code&gt;money&lt;/code&gt;.</source>
          <target state="translated">また、自然距離メトリックが存在するデータ型の場合、 &lt;code&gt;btree_gist&lt;/code&gt; は距離演算子 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; を定義し、この演算子を使用した最近傍検索のGiSTインデックスサポートを提供します。距離演算子のために提供されている &lt;code&gt;int2&lt;/code&gt; 、 &lt;code&gt;int4&lt;/code&gt; 、 &lt;code&gt;int8&lt;/code&gt; 、 &lt;code&gt;float4&lt;/code&gt; 、 &lt;code&gt;float8&lt;/code&gt; 型、 &lt;code&gt;timestamp with time zone&lt;/code&gt; 、 &lt;code&gt;timestamp without time zone&lt;/code&gt; 、 &lt;code&gt;time without time zone&lt;/code&gt; 、 &lt;code&gt;date&lt;/code&gt; 、 &lt;code&gt;interval&lt;/code&gt; 、 &lt;code&gt;oid&lt;/code&gt; 、および &lt;code&gt;money&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf0cd04ab9ab1bc3d1ec06d42e614cb3d497974a" translate="yes" xml:space="preserve">
          <source>Also, if you are using prepared transactions, the &lt;code&gt;virtualtransaction&lt;/code&gt; column can be joined to the &lt;code&gt;transaction&lt;/code&gt; column of the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; view to get more information on prepared transactions that hold locks. (A prepared transaction can never be waiting for a lock, but it continues to hold the locks it acquired while running.) For example:</source>
          <target state="translated">また、準備済みトランザクションを使用している場合、 &lt;code&gt;virtualtransaction&lt;/code&gt; 列を&lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt;ビューの &lt;code&gt;transaction&lt;/code&gt; 列に結合して、ロックを保持する準備済みトランザクションの詳細を取得できます。（準備されたトランザクションはロックを待機することはできませんが、実行中に取得したロックを保持し続けます。）例：</target>
        </trans-unit>
        <trans-unit id="2258b90b04fd050fcb19ba25fa34dc828faad6f7" translate="yes" xml:space="preserve">
          <source>Also, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with &lt;code&gt;*&lt;/code&gt; to specify prefix matching:</source>
          <target state="translated">また、 &lt;code&gt;tsquery&lt;/code&gt; の語彙素は &lt;code&gt;*&lt;/code&gt; でラベル付けして、プレフィックスの一致を指定できます。</target>
        </trans-unit>
        <trans-unit id="d1e5125c3a43842c6c788a2be18af72f0169e16b" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;myschema&lt;/code&gt; is the first element in the path, new objects would by default be created in it.</source>
          <target state="translated">また、 &lt;code&gt;myschema&lt;/code&gt; はパスの最初の要素であるため、新しいオブジェクトはデフォルトでその中に作成されます。</target>
        </trans-unit>
        <trans-unit id="706af9f63feb30c802747e00ad8bdfe7aa3a186c" translate="yes" xml:space="preserve">
          <source>Also, some element types have a notion of &amp;ldquo;infinity&amp;rdquo;, but that is just another value so far as the range type mechanisms are concerned. For example, in timestamp ranges, &lt;code&gt;[today,]&lt;/code&gt; means the same thing as &lt;code&gt;[today,)&lt;/code&gt;. But &lt;code&gt;[today,infinity]&lt;/code&gt; means something different from &lt;code&gt;[today,infinity)&lt;/code&gt; &amp;mdash; the latter excludes the special &lt;code&gt;timestamp&lt;/code&gt; value &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">また、一部の要素タイプには「無限」の概念がありますが、範囲タイプのメカニズムに関する限り、これは単なる別の値です。たとえば、タイムスタンプ範囲では、 &lt;code&gt;[today,]&lt;/code&gt; は &lt;code&gt;[today,)&lt;/code&gt; と同じことを意味します。ただし、 &lt;code&gt;[today,infinity]&lt;/code&gt; は &lt;code&gt;[today,infinity)&lt;/code&gt; とは異なる意味を持ち &lt;code&gt;infinity&lt;/code&gt; 。後者は特別な &lt;code&gt;timestamp&lt;/code&gt; 値infinityを除外しています。</target>
        </trans-unit>
        <trans-unit id="00fb5de01709ab2f402939d3439d7bfb11e30b51" translate="yes" xml:space="preserve">
          <source>Also, system catalogs may contain rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1), indicating that they were inserted during the first phase of initdb. Like &lt;code&gt;FrozenTransactionId&lt;/code&gt;, this special XID is treated as older than every normal XID.</source>
          <target state="translated">また、システムカタログには、 &lt;code&gt;xmin&lt;/code&gt; が &lt;code&gt;BootstrapTransactionId&lt;/code&gt; （1）と等しい行が含まれる場合があり、initdbの最初のフェーズで挿入されたことを示します。 &lt;code&gt;FrozenTransactionId&lt;/code&gt; と同様に、この特別なXIDは、すべての通常のXIDよりも古いものとして扱われます。</target>
        </trans-unit>
        <trans-unit id="93ed94df22ab24f81f04b111c95a216ff81d38c0" translate="yes" xml:space="preserve">
          <source>Also, the Unicode escape syntax for string constants only works when the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is turned on. This is because otherwise this syntax could confuse clients that parse the SQL statements to the point that it could lead to SQL injections and similar security issues. If the parameter is set to off, this syntax will be rejected with an error message.</source>
          <target state="translated">また、文字列定数のUnicodeエスケープ構文は、構成パラメーター&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt;がオンになっている場合にのみ機能します。これは、この構文を使用しないと、SQL文を解析するクライアントを混乱させ、SQLインジェクションや同様のセキュリティ問題が発生する可能性があるためです。パラメータがオフに設定されている場合、この構文はエラーメッセージとともに拒否されます。</target>
        </trans-unit>
        <trans-unit id="58147b7f84be2ece7907815ce52ec7ae85d6c7bf" translate="yes" xml:space="preserve">
          <source>Also, there is no concept of a &lt;code&gt;public&lt;/code&gt; schema in the SQL standard. For maximum conformance to the standard, you should not use the &lt;code&gt;public&lt;/code&gt; schema.</source>
          <target state="translated">また、SQL標準には &lt;code&gt;public&lt;/code&gt; スキーマの概念はありません。標準に最大限準拠するには、 &lt;code&gt;public&lt;/code&gt; スキーマを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="cae58275d441413bb378869b203fcfca0525ccf0" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can be only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="translated">また、並列プラン内で使用した場合に部分的な子しか持つことができない通常の &lt;code&gt;Append&lt;/code&gt; ノードとは異なり、 &lt;code&gt;Parallel Append&lt;/code&gt; ノードは部分的な子プランと非部分的な子プランの両方を持つことができます。部分的でない子は、複数回スキャンすると結果が重複するため、単一のプロセスのみでスキャンされます。したがって、複数の結果セットの追加を伴うプランでは、効率的な部分プランが利用できない場合でも、大まかな並列処理を実現できます。たとえば、並列スキャンをサポートしないインデックスを使用することによってのみ効率的に実装できるパーティションテーブルに対するクエリを考えてみます。計画担当者は、通常の &lt;code&gt;Index Scan&lt;/code&gt; &lt;code&gt;Parallel Append&lt;/code&gt; を選択する場合があります。予定; 個々のインデックススキャンはそれぞれ、単一のプロセスで完了するまで実行する必要がありますが、異なるプロセスで異なるスキャンを同時に実行することもできます。</target>
        </trans-unit>
        <trans-unit id="e805152c6a1ae1d9757b9c8152236b48ab4b4867" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt;.</source>
          <target state="translated">また、終了したばかりのトランザクションをできるだけ早くアーカイブしたい場合は、 &lt;code&gt;pg_switch_wal&lt;/code&gt; を使用して手動でセグメント切り替えを強制できます。WAL管理に関連するその他のユーティリティ関数を&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.84に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="bfbace446db7c85291e8910dc869f82f6687c559" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified labels separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those labels, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start to match any label that doesn't match any of the alternatives.</source>
          <target state="translated">また、 &lt;code&gt;|&lt;/code&gt; で区切られた、変更される可能性のあるいくつかのラベルを書き込むことができます。（または）これらのラベルのいずれかに一致させると、 &lt;code&gt;!&lt;/code&gt; （NOT）最初は、どの代替案とも一致しないラベルに一致します。</target>
        </trans-unit>
        <trans-unit id="8b36099e7952ab489f13b56454238da5e639dbc6" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, add connection options:</source>
          <target state="translated">サーバー &lt;code&gt;foo&lt;/code&gt; を変更し、接続オプションを追加します。</target>
        </trans-unit>
        <trans-unit id="a729ebcf94a23a3c93f6e08f02b494c47b57ffb8" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, change version, change &lt;code&gt;host&lt;/code&gt; option:</source>
          <target state="translated">サーバー &lt;code&gt;foo&lt;/code&gt; の変更、バージョンの変更、 &lt;code&gt;host&lt;/code&gt; オプションの変更：</target>
        </trans-unit>
        <trans-unit id="530e5f9a6ec30da1a641c6dc46a96ff1039a1901" translate="yes" xml:space="preserve">
          <source>Alter the current session user instead of an explicitly identified role.</source>
          <target state="translated">明示的に指定されたロールの代わりに、現在のセッションユーザを変更します。</target>
        </trans-unit>
        <trans-unit id="7d634d2fd0bd3ab5f5b0921201011f77ef8d5f96" translate="yes" xml:space="preserve">
          <source>Alter the current user instead of an explicitly identified role.</source>
          <target state="translated">明示的に指定されたロールの代わりに、現在のユーザを変更します。</target>
        </trans-unit>
        <trans-unit id="2e8aee10a5d127f616d1a417fe30c8e06fd3852f" translate="yes" xml:space="preserve">
          <source>Alternative Method for Log Shipping</source>
          <target state="translated">ログ出荷のための代替方法</target>
        </trans-unit>
        <trans-unit id="8cd965c3bba9ba8b09a134d95e9a1fe544bc4537" translate="yes" xml:space="preserve">
          <source>Alternative location for the command history file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">コマンド履歴ファイルの代替の場所。チルダ（ &lt;code&gt;~&lt;/code&gt; ）展開が実行されます。</target>
        </trans-unit>
        <trans-unit id="0c3a5aa0af507c3b23d9de2d04bd2190286c2e39" translate="yes" xml:space="preserve">
          <source>Alternative location of the user's &lt;code&gt;.psqlrc&lt;/code&gt; file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">ユーザーの &lt;code&gt;.psqlrc&lt;/code&gt; ファイルの代替の場所。チルダ（ &lt;code&gt;~&lt;/code&gt; ）展開が実行されます。</target>
        </trans-unit>
        <trans-unit id="2541ab725e8ecd177759c1c8be6f800623e60558" translate="yes" xml:space="preserve">
          <source>Alternative spelling for &lt;code&gt;TEMPORARY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TEMPORARY&lt;/code&gt; の代替スペル。</target>
        </trans-unit>
        <trans-unit id="af1d73d4699e1562f8a1d0921440facf6a0e5f14" translate="yes" xml:space="preserve">
          <source>Alternative syntaxes for referencing ordered-set aggregates are described under &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt;.</source>
          <target state="translated">順序セット集計を参照するための代替構文については、&lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATEで&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="23e53579bffe248a96cd7c7da0e62e9be194d4f8" translate="yes" xml:space="preserve">
          <source>Alternatively, C-style block comments can be used:</source>
          <target state="translated">あるいは、Cスタイルのブロックコメントを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="7ff9d2f8aa56be6c9fb839910a0ca959de998790" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;time_zone_name&lt;/code&gt; can be given, referencing a zone name defined in the IANA timezone database. The zone's definition is consulted to see whether the abbreviation is or has been in use in that zone, and if so, the appropriate meaning is used &amp;mdash; that is, the meaning that was currently in use at the timestamp whose value is being determined, or the meaning in use immediately before that if it wasn't current at that time, or the oldest meaning if it was used only after that time. This behavior is essential for dealing with abbreviations whose meaning has historically varied. It is also allowed to define an abbreviation in terms of a zone name in which that abbreviation does not appear; then using the abbreviation is just equivalent to writing out the zone name.</source>
          <target state="translated">または、 &lt;code&gt;time_zone_name&lt;/code&gt; を指定して、IANAタイムゾーンデータベースで定義されたゾーン名を参照することもできます。ゾーンの定義が参照され、そのゾーンで略語が使用されているかどうかが確認されます。使用されている場合は、適切な意味が使用されます。つまり、値が決定されるタイムスタンプで現在使用されていた意味、またはその時点で最新ではなかった場合はその直前に使用されていた意味、またはそれ以降に使用された場合は最も古い意味。この振る舞いは、意味が歴史的に変化した略語を処理するために不可欠です。また、省略形が出現しないゾーン名に関して省略形を定義することもできます。省略形を使用することは、ゾーン名を書き出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="15a06f8c724e47a1d8815847200662f59207ad21" translate="yes" xml:space="preserve">
          <source>Alternatively, a regular server session can be started with &lt;code&gt;-P&lt;/code&gt; included in its command line options. The method for doing this varies across clients, but in all libpq-based clients, it is possible to set the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable to &lt;code&gt;-P&lt;/code&gt; before starting the client. Note that while this method does not require locking out other clients, it might still be wise to prevent other users from connecting to the damaged database until repairs have been completed.</source>
          <target state="translated">または、コマンドラインオプションに &lt;code&gt;-P&lt;/code&gt; を含めて通常のサーバーセッションを開始することもできます。これを行う方法はクライアントによって異なりますが、すべてのlibpqベースのクライアントでは、クライアントを起動する前に &lt;code&gt;PGOPTIONS&lt;/code&gt; 環境変数を &lt;code&gt;-P&lt;/code&gt; に設定することが可能です。この方法では他のクライアントをロックアウトする必要はありませんが、修復が完了するまで他のユーザーが破損したデータベースに接続できないようにするのが賢明な場合があります。</target>
        </trans-unit>
        <trans-unit id="d114129fd255b4feb38503a136823f1a3243ffae" translate="yes" xml:space="preserve">
          <source>Alternatively, an arbitrary expression can determine what rows are to be considered distinct:</source>
          <target state="translated">あるいは、任意の式で、どの行を別個のものとみなすかを決定することもできます。</target>
        </trans-unit>
        <trans-unit id="a31da7f4a4f7c70e9c7e0520f23700364a2f38f8" translate="yes" xml:space="preserve">
          <source>Alternatively, any of the following forms can be used for input:</source>
          <target state="translated">あるいは、以下のいずれかのフォームを入力に使用することもできます。</target>
        </trans-unit>
        <trans-unit id="33e9e4beffd0551e6388808105bbbc2dfb18bd73" translate="yes" xml:space="preserve">
          <source>Alternatively, bit-string constants can be specified in hexadecimal notation, using a leading &lt;code&gt;X&lt;/code&gt; (upper or lower case), e.g., &lt;code&gt;X'1FF'&lt;/code&gt;. This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit.</source>
          <target state="translated">または、ビット文字列定数は、先頭に &lt;code&gt;X&lt;/code&gt; （大文字または小文字）を使用して16進表記で指定できます（例： &lt;code&gt;X'1FF'&lt;/code&gt; 。この表記は、各16進数字に4桁の2進数字を持つビット文字列定数と同等です。</target>
        </trans-unit>
        <trans-unit id="251d43a6c1d9b6a2f5aefc3ac8e6be39b17e09eb" translate="yes" xml:space="preserve">
          <source>Alternatively, if only one character is given on a line, instances of that character are deleted; this is useful in languages where accents are represented by separate characters.</source>
          <target state="translated">あるいは、行に 1 文字だけが与えられた場合は、その文字のインスタンスが削除されます;これは、アクセントが別々の文字で表される言語で有用です。</target>
        </trans-unit>
        <trans-unit id="d591ed10c7ebb943dc2bac83e217250069a02625" translate="yes" xml:space="preserve">
          <source>Alternatively, if the operator class does not provide a &lt;code&gt;compare&lt;/code&gt; method, GIN will look up the default btree operator class for the index key data type, and use its comparison function. It is recommended to specify the comparison function in a GIN operator class that is meant for just one data type, as looking up the btree operator class costs a few cycles. However, polymorphic GIN operator classes (such as &lt;code&gt;array_ops&lt;/code&gt;) typically cannot specify a single comparison function.</source>
          <target state="translated">または、演算子クラスが &lt;code&gt;compare&lt;/code&gt; メソッドを提供しない場合、GINはインデックスキーデータ型のデフォルトのbtree演算子クラスを検索し、その比較関数を使用します。 btree演算子クラスの検索には数サイクルかかるため、比較関数を1つのデータ型のみを対象とするGIN演算子クラスで指定することをお勧めします。ただし、通常、ポリモーフィックGIN演算子クラス（ &lt;code&gt;array_ops&lt;/code&gt; など）では、単一の比較関数を指定できません。</target>
        </trans-unit>
        <trans-unit id="72ceaece99de5916dec6956aa5625927bc2fa200" translate="yes" xml:space="preserve">
          <source>Alternatively, if the user account was created incorrectly or cannot be changed, it is recommended to set</source>
          <target state="translated">あるいは、ユーザーアカウントが間違って作成されたか、変更できない場合は</target>
        </trans-unit>
        <trans-unit id="60d8933bc73d549d63a859713e0214c4534a9558" translate="yes" xml:space="preserve">
          <source>Alternatively, one may want to create and populate the new child table before adding it to the table hierarchy. This could allow data to be loaded, checked, and transformed before being made visible to queries on the parent table.</source>
          <target state="translated">あるいは、テーブル階層に追加する前に、新しい子テーブルを作成して入力することもできます。これにより、親テーブルのクエリに表示される前にデータをロード、チェック、変換することができます。</target>
        </trans-unit>
        <trans-unit id="3ff1004e1f07326010cba19c9e266164c058052f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; command can be used to reassign ownership of all objects owned by the role-to-be-dropped to a single other role. Because &lt;code&gt;REASSIGN OWNED&lt;/code&gt; cannot access objects in other databases, it is necessary to run it in each database that contains objects owned by the role. (Note that the first such &lt;code&gt;REASSIGN OWNED&lt;/code&gt; will change the ownership of any shared-across-databases objects, that is databases or tablespaces, that are owned by the role-to-be-dropped.)</source>
          <target state="translated">あるいは、&lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt;コマンドを使用して、ドロップされる役割が所有するすべてのオブジェクトの所有権を他の単一の役割に再割り当てすることができます。 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; は他のデータベースのオブジェクトにアクセスできないため、ロールが所有するオブジェクトを含む各データベースでそれを実行する必要があります。（最初のそのような &lt;code&gt;REASSIGN OWNED&lt;/code&gt; は、データベース間で共有されるオブジェクト（データベースまたはテーブルスペース）の所有権を変更し、削除されるロールが所有することに注意してください。）</target>
        </trans-unit>
        <trans-unit id="0e1e66b725216c8606cc4bf9032cf0c74ece07f1" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;generate_subscripts&lt;/code&gt; function can be used. For example:</source>
          <target state="translated">あるいは、 &lt;code&gt;generate_subscripts&lt;/code&gt; 関数を使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="15fba016cd90434c268101e2e3dcfba0bf0a2532" translate="yes" xml:space="preserve">
          <source>Alternatively, use the &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; parameter:</source>
          <target state="translated">または、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;パラメータを使用します。</target>
        </trans-unit>
        <trans-unit id="0f4a86811d0aa22382b5cf9bd26c67192af09d76" translate="yes" xml:space="preserve">
          <source>Alternatively, use the short commands:</source>
          <target state="translated">または、短いコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="65a8f599c00acf998716acc089534f17921d2aa4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can run &lt;code&gt;initdb&lt;/code&gt; via the &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; program like so:</source>
          <target state="translated">あるいは、次のように&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;プログラムを介して &lt;code&gt;initdb&lt;/code&gt; を実行できます。</target>
        </trans-unit>
        <trans-unit id="98a5c461c82a79025a521674df6f9b47d5588e09" translate="yes" xml:space="preserve">
          <source>Alternatively, you could modify &lt;code&gt;passwordcheck&lt;/code&gt; to reject pre-encrypted passwords, but forcing users to set their passwords in clear text carries its own security risks.</source>
          <target state="translated">または、事前に暗号化された &lt;code&gt;passwordcheck&lt;/code&gt; を拒否するようにpasswordcheckを変更することもできますが、ユーザーにパスワードをクリアテキストで設定するように強制すると、独自のセキュリティリスクが伴います。</target>
        </trans-unit>
        <trans-unit id="5a5bc9685c86de23aa2f7e6abe79e2df58ea2f24" translate="yes" xml:space="preserve">
          <source>Alternatively, you might prefer to use an external log rotation program if you have one that you are already using with other server software. For example, the rotatelogs tool included in the Apache distribution can be used with PostgreSQL. One way to do this is to pipe the server's stderr output to the desired program. If you start the server with &lt;code&gt;pg_ctl&lt;/code&gt;, then stderr is already redirected to stdout, so you just need a pipe command, for example:</source>
          <target state="translated">または、他のサーバーソフトウェアで既に使用しているプログラムがある場合は、外部ログローテーションプログラムを使用することもできます。たとえば、Apacheディストリビューションに含まれているrotatelogsツールは、PostgreSQLで使用できます。これを行う1つの方法は、サーバーのstderr出力を目的のプログラムにパイプすることです。 &lt;code&gt;pg_ctl&lt;/code&gt; を使用してサーバーを起動した場合、stderrはすでにstdoutにリダイレクトされているため、次のようにパイプコマンドが必要です。</target>
        </trans-unit>
        <trans-unit id="a4473ced05716c4f54d00426c2fe62cbfc81eb98" translate="yes" xml:space="preserve">
          <source>Alternatively, you'll get this when attempting Unix-domain socket communication to a local server:</source>
          <target state="translated">あるいは、ローカルサーバにUnixドメインのソケット通信を試みると、このようなメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="3070b53c6b7161861f801a0276cbe1623e985387" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; attempts to verify that existing stored data satisfies the new constraint, this check is not bulletproof, because the command cannot &amp;ldquo;see&amp;rdquo; table rows that are newly inserted or updated and not yet committed. If there is a hazard that concurrent operations might insert bad data, the way to proceed is to add the constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option, commit that command, wait until all transactions started before that commit have finished, and then issue &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; to search for data violating the constraint. This method is reliable because once the constraint is committed, all new transactions are guaranteed to enforce it against new values of the domain type.</source>
          <target state="translated">が &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; 格納されたデータを満足する新しい制約を既存のことを確認するための試みのコマンドは、新たに挿入または更新し、まだコミットされていないテーブルの行を「見る」ことができないので、このチェックは、防弾ではありません。並行操作によって不正なデータが挿入される危険がある場合、続行するには、 &lt;code&gt;NOT VALID&lt;/code&gt; オプションを使用して制約を追加し、そのコマンドをコミットし、そのコミットが完了する前にすべてのトランザクションが開始されるまで待ってから、 &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; を発行します。制約に違反するデータを検索します。制約がコミットされると、すべての新しいトランザクションがドメインタイプの新しい値に対して制約を強制することが保証されるため、この方法は信頼できます。</target>
        </trans-unit>
        <trans-unit id="6e4d5c62b36bd1bff5096ffffc66d8713544d380" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;COALESCE&lt;/code&gt;, &lt;code&gt;GREATEST&lt;/code&gt;, and &lt;code&gt;LEAST&lt;/code&gt; are syntactically similar to functions, they are not ordinary functions, and thus cannot be used with explicit &lt;code&gt;VARIADIC&lt;/code&gt; array arguments.</source>
          <target state="translated">が &lt;code&gt;COALESCE&lt;/code&gt; は、 &lt;code&gt;GREATEST&lt;/code&gt; 、および &lt;code&gt;LEAST&lt;/code&gt; 構文的機能に類似している、彼らは普通の関数ではないので、明示的に使用することはできません &lt;code&gt;VARIADIC&lt;/code&gt; 配列引数。</target>
        </trans-unit>
        <trans-unit id="757c32acfdc3edc5e4ae1b7ef733e95e7cd6d851" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;FOR UPDATE&lt;/code&gt; appears in the SQL standard, the standard allows it only as an option of &lt;code&gt;DECLARE CURSOR&lt;/code&gt;. PostgreSQL allows it in any &lt;code&gt;SELECT&lt;/code&gt; query as well as in sub-&lt;code&gt;SELECT&lt;/code&gt;s, but this is an extension. The &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; and &lt;code&gt;FOR KEY SHARE&lt;/code&gt; variants, as well as the &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; options, do not appear in the standard.</source>
          <target state="translated">が &lt;code&gt;FOR UPDATE&lt;/code&gt; が SQL標準で表示され、標準では唯一のオプションとして、それを可能にする &lt;code&gt;DECLARE CURSOR&lt;/code&gt; 。PostgreSQLでは、すべての &lt;code&gt;SELECT&lt;/code&gt; クエリとサブ &lt;code&gt;SELECT&lt;/code&gt; でこれを使用できますが、これは拡張機能です。 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; は、 &lt;code&gt;FOR SHARE&lt;/code&gt; および &lt;code&gt;FOR KEY SHARE&lt;/code&gt; と同様に、変異体、 &lt;code&gt;NOWAIT&lt;/code&gt; および &lt;code&gt;SKIP LOCKED&lt;/code&gt; オプションを、標準では表示されません。</target>
        </trans-unit>
        <trans-unit id="53588eb1af9a260bf16537d83fb7f9095237ab92" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;initdb&lt;/code&gt; will attempt to create the specified data directory, it might not have permission if the parent directory of the desired data directory is root-owned. To initialize in such a setup, create an empty data directory as root, then use &lt;code&gt;chown&lt;/code&gt; to assign ownership of that directory to the database user account, then &lt;code&gt;su&lt;/code&gt; to become the database user to run &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">が、 &lt;code&gt;initdb&lt;/code&gt; を実行中に指定されたデータディレクトリを作成しようとする所望のデータディレクトリの親ディレクトリがroot所有のであれば、それは権限を持っていない可能性があります。このような設定で初期化するには、rootとして空のデータディレクトリを作成し、 &lt;code&gt;chown&lt;/code&gt; を使用してそのディレクトリの所有権をデータベースユーザーアカウントに割り当て、次に &lt;code&gt;su&lt;/code&gt; を使用して &lt;code&gt;initdb&lt;/code&gt; を実行するデータベースユーザーになります。</target>
        </trans-unit>
        <trans-unit id="2c9e9e73d67adcca66915f7f142192b4fd5640e0" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL does not attempt to enforce constraints on foreign tables, it does assume that they are correct for purposes of query optimization. If there are rows visible in the foreign table that do not satisfy a declared constraint, queries on the table might produce incorrect answers. It is the user's responsibility to ensure that the constraint definition matches reality.</source>
          <target state="translated">PostgreSQLは外部テーブルに制約を強制しようとはしませんが、問い合わせの最適化のために、制約が正しいことを前提としています。宣言された制約を満たさない行が外部テーブルに表示されている場合、そのテーブルに対する問い合わせは誤った答えを生成する可能性があります。制約の定義が現実と一致していることを確認するのはユーザの責任です。</target>
        </trans-unit>
        <trans-unit id="d1a0d48f05bfdc6cec6860f8c1c04ca18ef39017" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL supports Julian Date notation for input and output of dates (and also uses Julian dates for some internal datetime calculations), it does not observe the nicety of having dates run from noon to noon. PostgreSQL treats a Julian Date as running from midnight to midnight.</source>
          <target state="translated">PostgreSQLは日付の入出力にジュリアン日付表記をサポートしていますが(内部の日付時刻計算にもジュリアン日付を使用しています)、正午から正午までの日付を実行することの良さを理解していません。PostgreSQLは、ユリウス語の日付を真夜中から真夜中までの間に実行されているものとして扱います。</target>
        </trans-unit>
        <trans-unit id="aa5958132d1510aabee9c8eff036ee687a13c3b5" translate="yes" xml:space="preserve">
          <source>Although all built-in WAL-logged modules have their own types of WAL records, there is also a generic WAL record type, which describes changes to pages in a generic way. This is useful for extensions that provide custom access methods, because they cannot register their own WAL redo routines.</source>
          <target state="translated">組み込みの WAL-logged モジュールはすべて独自のタイプの WAL レコードを持っていますが、ページへの変更を一般的な方法で記述するジェネリックな WAL レコードタイプもあります。これは、カスタムアクセスメソッドを提供する拡張機能では、独自のWALのやり直しルーチンを登録することができないので便利です。</target>
        </trans-unit>
        <trans-unit id="d6ab224f94330d8699a9bed333303bd23f1e0345" translate="yes" xml:space="preserve">
          <source>Although enum types are primarily intended for static sets of values, there is support for adding new values to an existing enum type, and for renaming values (see &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;). Existing values cannot be removed from an enum type, nor can the sort ordering of such values be changed, short of dropping and re-creating the enum type.</source>
          <target state="translated">列挙型は主に静的な値のセットを対象としていますが、既存の列挙型に新しい値を追加したり、値の名前を変更したりすることもできます（&lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPEを&lt;/a&gt;参照）。列挙型から既存の値を削除することはできません。また、列挙型を削除して再作成しない限り、そのような値の並べ替え順序を変更することもできません。</target>
        </trans-unit>
        <trans-unit id="94ec3fef4f0a92e5c738b8e891b93184d80ce08d" translate="yes" xml:space="preserve">
          <source>Although indexes in PostgreSQL do not need maintenance or tuning, it is still important to check which indexes are actually used by the real-life query workload. Examining index usage for an individual query is done with the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command; its application for this purpose is illustrated in &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt;. It is also possible to gather overall statistics about index usage in a running server, as described in &lt;a href=&quot;monitoring-stats&quot;&gt;Section 27.2&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLのインデックスにはメンテナンスや調整は必要ありませんが、実際のクエリワークロードで実際に使用されているインデックスを確認することが重要です。個々のクエリのインデックスの使用状況を調べるには、&lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;コマンドを使用します。この目的への適用は&lt;a href=&quot;using-explain&quot;&gt;セクション14.1に&lt;/a&gt;示されています。&lt;a href=&quot;monitoring-stats&quot;&gt;セクション27.2で&lt;/a&gt;説明されているように、実行中のサーバーでのインデックスの使用に関する全体的な統計を収集することもできます。</target>
        </trans-unit>
        <trans-unit id="b565c24300a11b353aca42f1a3c2fd6f15be280e" translate="yes" xml:space="preserve">
          <source>Although inheritance is frequently useful, it has not been integrated with unique constraints or foreign keys, which limits its usefulness. See &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; for more detail.</source>
          <target state="translated">継承はしばしば有用ですが、固有の制約や外部キーと統合されていないため、その有用性は制限されています。詳細については、&lt;a href=&quot;ddl-inherit&quot;&gt;セクション5.10&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d3850ba882b09b2bdad99e045dd0ac52d33bb527" translate="yes" xml:space="preserve">
          <source>Although it is possible to copy a database other than &lt;code&gt;template1&lt;/code&gt; by specifying its name as the template, this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the template database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; otherwise, new connections to the template database are locked out until &lt;code&gt;CREATE DATABASE&lt;/code&gt; completes. See &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;template1&lt;/code&gt; として名前を指定して、template1 以外のデータベースをコピーすることは可能ですが、これは（まだ）汎用の「 &lt;code&gt;COPY DATABASE&lt;/code&gt; 」機能としては意図されていません。主な制限は、コピー中は他のセッションをテンプレートデータベースに接続できないことです。開始時に他の接続が存在する場合、 &lt;code&gt;CREATE DATABASE&lt;/code&gt; は失敗します。それ以外の場合、テンプレートデータベースへの新しい接続は、 &lt;code&gt;CREATE DATABASE&lt;/code&gt; が完了するまでロックされます。詳細は&lt;a href=&quot;manage-ag-templatedbs&quot;&gt;項22.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1f7a4620dd953ee89678c8af93ba6b1281ecf21b" translate="yes" xml:space="preserve">
          <source>Although per-column tweaking of &lt;code&gt;ANALYZE&lt;/code&gt; frequency might not be very productive, you might find it worthwhile to do per-column adjustment of the level of detail of the statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;. Columns that are heavily used in &lt;code&gt;WHERE&lt;/code&gt; clauses and have highly irregular data distributions might require a finer-grain data histogram than other columns. See &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;, or change the database-wide default using the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; の頻度を列ごとに微調整することはあまり生産的ではないかもしれませんが、 &lt;code&gt;ANALYZE&lt;/code&gt; によって収集された統計の詳細レベルを列ごとに調整することは価値があるかもしれません。 &lt;code&gt;WHERE&lt;/code&gt; 句で頻繁に使用され、データ分布が非常に不規則な列は、他の列よりも細かいデータヒストグラムを必要とする場合があります。 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; を参照するか、&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;構成パラメーターを使用してデータベース全体のデフォルトを変更してください。</target>
        </trans-unit>
        <trans-unit id="072197dff3ba1069a6848a4f3fc276518f8dd8e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;date&lt;/code&gt; type cannot have an associated time zone, the &lt;code&gt;time&lt;/code&gt; type can. Time zones in the real world have little meaning unless associated with a date as well as a time, since the offset can vary through the year with daylight-saving time boundaries.</source>
          <target state="translated">けれども &lt;code&gt;date&lt;/code&gt; タイプが関連付けられているタイムゾーンを持つことができない、 &lt;code&gt;time&lt;/code&gt; タイプができます。オフセットは1年を通じて夏時間の境界で変化する可能性があるため、実際のタイムゾーンは日付と時刻に関連付けられていない限りほとんど意味がありません。</target>
        </trans-unit>
        <trans-unit id="28fdae260b7b429ca2fc81de6c0ad8518d3a56e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;jsonb_path_ops&lt;/code&gt; operator class supports only queries with the &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, it has notable performance advantages over the default operator class &lt;code&gt;jsonb_ops&lt;/code&gt;. A &lt;code&gt;jsonb_path_ops&lt;/code&gt; index is usually much smaller than a &lt;code&gt;jsonb_ops&lt;/code&gt; index over the same data, and the specificity of searches is better, particularly when queries contain keys that appear frequently in the data. Therefore search operations typically perform better than with the default operator class.</source>
          <target state="translated">が &lt;code&gt;jsonb_path_ops&lt;/code&gt; の演算子クラスのサポートだけで照会 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、 &lt;code&gt;@@&lt;/code&gt; および &lt;code&gt;@?&lt;/code&gt; 演算子を使用すると、デフォルトの演算子クラス &lt;code&gt;jsonb_ops&lt;/code&gt; よりもパフォーマンスが著しく向上します。 &lt;code&gt;jsonb_path_ops&lt;/code&gt; のインデックスは、通常よりもはるかに小さい &lt;code&gt;jsonb_ops&lt;/code&gt; の同じデータに対する索引、および検索の特異性は、クエリがデータに頻繁に表示されるキーを含む場合は特に、良いです。したがって、検索操作は通常、デフォルトの演算子クラスよりもパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="b3909c49c0f3069cf4fdb831ccd03572195110f1" translate="yes" xml:space="preserve">
          <source>Although the error conditions possible on the client side are quite varied and application-dependent, a few of them might be directly related to how the server was started. Conditions other than those shown below should be documented with the respective client application.</source>
          <target state="translated">クライアント側で考えられるエラー条件は非常に多様で、アプリケーションに依存しますが、そのうちのいくつかはサーバの起動方法に直接関係しているかもしれません。以下に示す条件以外は、それぞれのクライアントアプリケーションで文書化する必要があります。</target>
        </trans-unit>
        <trans-unit id="707d4aa12dd0762aad5c962d956cb0615faa21aa" translate="yes" xml:space="preserve">
          <source>Although the main point of a prepared statement is to avoid repeated parse analysis and planning of the statement, PostgreSQL will force re-analysis and re-planning of the statement before using it whenever database objects used in the statement have undergone definitional (DDL) changes since the previous use of the prepared statement. Also, if the value of &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; changes from one use to the next, the statement will be re-parsed using the new &lt;code&gt;search_path&lt;/code&gt;. (This latter behavior is new as of PostgreSQL 9.3.) These rules make use of a prepared statement semantically almost equivalent to re-submitting the same query text over and over, but with a performance benefit if no object definitions are changed, especially if the best plan remains the same across uses. An example of a case where the semantic equivalence is not perfect is that if the statement refers to a table by an unqualified name, and then a new table of the same name is created in a schema appearing earlier in the &lt;code&gt;search_path&lt;/code&gt;, no automatic re-parse will occur since no object used in the statement changed. However, if some other change forces a re-parse, the new table will be referenced in subsequent uses.</source>
          <target state="translated">準備されたステートメントの主なポイントは、ステートメントの解析とプランニングの繰り返しを避けることですが、PostgreSQLは、ステートメントで使用されるデータベースオブジェクトが定義（DDL）の変更を受けた場合は常に、ステートメントの再分析とプランニングを強制してから使用します以前に準備されたステートメントを使用してから。また、&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;の値が1つの用途から次の用途に変更された場合、ステートメントは新しい &lt;code&gt;search_path&lt;/code&gt; を使用して再解析されます。。 （この後者の動作はPostgreSQL 9.3で新たに追加されました。）これらのルールは、意味的にほぼ同じクエリテキストを再送信することとほぼ同等の準備済みステートメントを使用しますが、オブジェクト定義が変更されない場合、特に最良の計画は、どの用途でも同じです。セマンティックの同等性が完全でない場合の例は、ステートメントが修飾されていない名前でテーブルを参照し、同じ名前の新しいテーブルが &lt;code&gt;search_path&lt;/code&gt; の前の方にあるスキーマに作成された場合、自動再ステートメントで使用されているオブジェクトが変更されていないため、解析が発生します。ただし、他の変更によって再解析が強制される場合、新しいテーブルは以降の使用で参照されます。</target>
        </trans-unit>
        <trans-unit id="7b64c47c816d918ee8eceb31b5a14f4992da7fb7" translate="yes" xml:space="preserve">
          <source>Although the syntax of &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; resembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. PostgreSQL instead requires each session to issue its own &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure.</source>
          <target state="translated">&lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; の構文はSQL標準の構文に似ていますが、効果は同じではありません。標準では、一時テーブルは一度だけ定義され、それらを必要とするすべてのセッションで自動的に（空のコンテンツから開始して）存在します。 PostgreSQLは代わりに、各セッションで、使用する各一時テーブルに対して独自の &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; コマンドを発行する必要があります。これにより、異なるセッションが異なる目的で同じ一時テーブル名を使用できるようになりますが、標準のアプローチでは、特定の一時テーブル名のすべてのインスタンスが同じテーブル構造を持つように制限されます。</target>
        </trans-unit>
        <trans-unit id="9eb832cbf2f7969f569f8af2de92f22dbf429240" translate="yes" xml:space="preserve">
          <source>Although the system will let you set &lt;code&gt;random_page_cost&lt;/code&gt; to less than &lt;code&gt;seq_page_cost&lt;/code&gt;, it is not physically sensible to do so. However, setting them equal makes sense if the database is entirely cached in RAM, since in that case there is no penalty for touching pages out of sequence. Also, in a heavily-cached database you should lower both values relative to the CPU parameters, since the cost of fetching a page already in RAM is much smaller than it would normally be.</source>
          <target state="translated">システムはあなたが設定できますが &lt;code&gt;random_page_cost&lt;/code&gt; を以下に &lt;code&gt;seq_page_cost&lt;/code&gt; 、物理的にそうすることが賢明ではありません。ただし、データベースが完全にRAMにキャッシュされている場合は、これらの値を等しく設定することは理にかなっています。その場合、ページを順番どおりに操作しないことによるペナルティがないためです。また、キャッシュが非常に多いデータベースでは、RAMに既にあるページをフェッチするコストが通常よりもはるかに小さいため、CPUパラメータに対して両方の値を低くする必要があります。</target>
        </trans-unit>
        <trans-unit id="f375eb3005a104e4e3133bc9460b959aca6d956c" translate="yes" xml:space="preserve">
          <source>Although these queries will work without an index, most applications will find this approach too slow, except perhaps for occasional ad-hoc searches. Practical use of text searching usually requires creating an index.</source>
          <target state="translated">これらのクエリはインデックスがなくても動作しますが、ほとんどのアプリケーションでは、たまにアドホックな検索を行う場合を除いて、この方法では時間がかかりすぎると感じるでしょう。テキスト検索を実用的に使用するには、通常インデックスを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="d6a53bc14c2fd9a760550de48fb80767bf99cae5" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a large penalty in index size. Each of the single-column btree indexes occupies 214 MB, so the total space needed is over 1.2GB, more than 8 times the space used by the bloom index.</source>
          <target state="translated">このクエリはシングルインデックスよりもはるかに高速に実行されますが、インデックスサイズに大きなペナルティが発生します。シングルカラムのbtreeインデックスはそれぞれ214 MBを占有するので、必要とされる総容量は1.2GB以上になり、bloomインデックスの8倍以上の容量になります。</target>
        </trans-unit>
        <trans-unit id="1200f8928e7bfeba98e8bc2cff21bdd8b6159a1f" translate="yes" xml:space="preserve">
          <source>Although this query's restrictions are superficially similar to the previous example, the semantics are different because a row must be emitted for each row of A that has no matching row in the join of B and C. Therefore the planner has no choice of join order here: it must join B to C and then join A to that result. Accordingly, this query takes less time to plan than the previous query. In other cases, the planner might be able to determine that more than one join order is safe. For example, given:</source>
          <target state="translated">この問い合わせの制約は、表面的には前の例と似ていますが、セマンティクスが異なります。それは、BとCの結合で一致する行がないAの各行について、行を放出しなければならないからです。したがって、このクエリは前のクエリよりも計画にかかる時間が短くなります。他のケースでは、プランナは2つ以上の結合順序が安全であると判断できるかもしれません。例えば、以下のような場合です。</target>
        </trans-unit>
        <trans-unit id="7ef8d68c90c214bb77efeec7b9a407cfbeffef4b" translate="yes" xml:space="preserve">
          <source>Although tuples are a lockable type of object, information about row-level locks is stored on disk, not in memory, and therefore row-level locks normally do not appear in this view. If a process is waiting for a row-level lock, it will usually appear in the view as waiting for the permanent transaction ID of the current holder of that row lock.</source>
          <target state="translated">タプルはロック可能なタイプのオブジェクトですが、行レベルのロックに関する情報はメモリではなくディスクに格納されているため、行レベルのロックは通常このビューには表示されません。プロセスが行レベル・ロックを待っている場合、通常、その行ロックの現在の保持者の永続的なトランザクションIDを待っているとしてビューに表示されます。</target>
        </trans-unit>
        <trans-unit id="72059384cd793d17d014692386f1a5b268fab6d4" translate="yes" xml:space="preserve">
          <source>Although you can use any output format with this feature, the default &lt;code&gt;aligned&lt;/code&gt; format tends to look bad because each group of &lt;code&gt;FETCH_COUNT&lt;/code&gt; rows will be formatted separately, leading to varying column widths across the row groups. The other output formats work better.</source>
          <target state="translated">この機能では任意の出力フォーマットを使用できますが、 &lt;code&gt;FETCH_COUNT&lt;/code&gt; 行の各グループが個別にフォーマットされ、行グループ全体で列幅が変化するため、デフォルトの &lt;code&gt;aligned&lt;/code&gt; 形式は見栄えが悪くなる傾向があります。他の出力フォーマットはよりよく機能します。</target>
        </trans-unit>
        <trans-unit id="29489a7d34435843e1ff1804b48da3fef28fc6ed" translate="yes" xml:space="preserve">
          <source>Although you cannot update a sequence directly, you can use a query like:</source>
          <target state="translated">シーケンスを直接更新することはできませんが、次のようなクエリを使用することができます。</target>
        </trans-unit>
        <trans-unit id="d408d29d181fe5f178e0df0934db0a473f3e4b2d" translate="yes" xml:space="preserve">
          <source>Always -1 in storage, but when loaded into a row descriptor in memory this might be updated to cache the offset of the attribute within the row</source>
          <target state="translated">ストレージ内では常に-1ですが、メモリ内の行ディスクリプタにロードされると、行内の属性のオフセットをキャッシュするために更新されることがあります。</target>
        </trans-unit>
        <trans-unit id="6dadde15ce0973a00fe9eb264f6b51766c085e93" translate="yes" xml:space="preserve">
          <source>Always run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; first. This command collects statistics about the distribution of the values in the table. This information is required to estimate the number of rows returned by a query, which is needed by the planner to assign realistic costs to each possible query plan. In absence of any real statistics, some default values are assumed, which are almost certain to be inaccurate. Examining an application's index usage without having run &lt;code&gt;ANALYZE&lt;/code&gt; is therefore a lost cause. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">常に最初に&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZEを&lt;/a&gt;実行します。このコマンドは、テーブル内の値の分布に関する統計を収集します。この情報は、クエリによって返される行数を見積もるのに必要です。これは、プランナが各可能なクエリプランに現実的なコストを割り当てるために必要です。実際の統計がない場合、いくつかのデフォルト値が想定されますが、これは不正確であることがほぼ確実です。したがって、 &lt;code&gt;ANALYZE&lt;/code&gt; を実行せずにアプリケーションのインデックスの使用状況を調査することは、失われた原因です。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fee90b9468a8f0a4929baba6bf4b3942f402f50f" translate="yes" xml:space="preserve">
          <source>Always run the pg_upgrade binary of the new server, not the old one. pg_upgrade requires the specification of the old and new cluster's data and executable (&lt;code&gt;bin&lt;/code&gt;) directories. You can also specify user and port values, and whether you want the data files linked or cloned instead of the default copy behavior.</source>
          <target state="translated">古いサーバーではなく、常に新しいサーバーのpg_upgradeバイナリを実行します。 pg_upgradeには、新旧のクラスターのデータと実行可能（ &lt;code&gt;bin&lt;/code&gt; ）ディレクトリーの指定が必要です。ユーザーとポートの値、およびデフォルトのコピー動作の代わりにデータファイルをリンクするかクローンするかを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="ed314eaaeb4f7d7933efa77539bb6dd24179fb4e" translate="yes" xml:space="preserve">
          <source>American National Standards Institute</source>
          <target state="translated">べいこくきかくきょうかい</target>
        </trans-unit>
        <trans-unit id="9b0f6aa450d937f102baa99a591a10b175502ace" translate="yes" xml:space="preserve">
          <source>American Standard Code for Information Interchange</source>
          <target state="translated">情報交換のためのアメリカの標準コード</target>
        </trans-unit>
        <trans-unit id="f772502aac0c6acdc4a93caa9a6a863fee25bd39" translate="yes" xml:space="preserve">
          <source>Among all relational operators the most difficult one to process and optimize is the &lt;em&gt;join&lt;/em&gt;. The number of possible query plans grows exponentially with the number of joins in the query. Further optimization effort is caused by the support of a variety of &lt;em&gt;join methods&lt;/em&gt; (e.g., nested loop, hash join, merge join in PostgreSQL) to process individual joins and a diversity of &lt;em&gt;indexes&lt;/em&gt; (e.g., B-tree, hash, GiST and GIN in PostgreSQL) as access paths for relations.</source>
          <target state="translated">すべての関係演算子の中で、処理と最適化が最も難しいのは&lt;em&gt;結合&lt;/em&gt;です。可能なクエリプランの数は、クエリ内の結合の数とともに指数関数的に増加します。個々の結合を処理&lt;em&gt;する&lt;/em&gt;ためのさまざまな&lt;em&gt;結合方法&lt;/em&gt;（ネストされたループ、ハッシュ結合、マージ結合など）のサポートと、さまざまな&lt;em&gt;インデックス&lt;/em&gt;（Bツリー、ハッシュ、GiST、GINなど） PostgreSQL）リレーションのアクセスパスとして。</target>
        </trans-unit>
        <trans-unit id="cb98c34253bd6741e222de32790839f4b0bbf938" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;ordering&amp;rdquo; operator entry indicates that an index of this operator family can be scanned to return rows in the order represented by &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Such an operator could return any sortable data type, though again its left-hand input type must match the index's column data type. The exact semantics of the &lt;code&gt;ORDER BY&lt;/code&gt; are specified by the &lt;code&gt;amopsortfamily&lt;/code&gt; column, which must reference a B-tree operator family for the operator's result type.</source>
          <target state="translated">「順序付け」演算子エントリは、この演算子ファミリのインデックスをスキャンして、 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 表される順序で行を返すことができることを示しています。このような演算子は、ソート可能な任意のデータ型を返すことができますが、左側の入力型はインデックスの列のデータ型と一致する必要があります。 &lt;code&gt;ORDER BY&lt;/code&gt; の正確なセマンティクスは &lt;code&gt;amopsortfamily&lt;/code&gt; 列で指定されます。これは、演算子の結果タイプのBツリー演算子ファミリを参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="ef1279b86476578e5585aff75989181f73dcffd4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=&lt;/code&gt; operator must be an equivalence relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; of the data type:</source>
          <target state="translated">AN &lt;code&gt;=&lt;/code&gt; 演算子は同値関係でなければなりません。つまり、データ型のすべての非null値 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="009a293231558c68203740163c433bc30d08defc" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;in_range&lt;/code&gt; function must have the signature</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 機能は、署名を持っている必要があります</target>
        </trans-unit>
        <trans-unit id="857fc13a44d4059f0989bb54c261a11965498b57" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;unaccent&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 辞書は以下のオプションを受け付けます。</target>
        </trans-unit>
        <trans-unit id="044945d1a76181f7c4bcb8b32669d47c02d34474" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;aggregate expression&lt;/em&gt; represents the application of an aggregate function across the rows selected by a query. An aggregate function reduces multiple inputs to a single output value, such as the sum or average of the inputs. The syntax of an aggregate expression is one of the following:</source>
          <target state="translated">&lt;em&gt;集約式は、&lt;/em&gt;問い合わせによって選択された行を横切って集約関数の適用を表します。集約関数は、複数の入力を、入力の合計や平均などの単一の出力値に削減します。集計式の構文は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="9cf57ce9f4c43bfd5a2501334071928e81cfc082" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;演算子クラスは、&lt;/em&gt;インデックスの各列に指定することができます。演算子クラスは、その列のインデックスで使用される演算子を識別します。たとえば、4バイト整数のBツリーインデックスは &lt;code&gt;int4_ops&lt;/code&gt; クラスを使用します。この演算子クラスには、4バイト整数の比較関数が含まれています。実際には、列のデータ型のデフォルトの演算子クラスで通常は十分です。演算子クラスを持つことの主なポイントは、一部のデータ型では、意味のある順序が複数存在する可能性があることです。たとえば、絶対値または実部のいずれかで複素数データ型を並べ替えることができます。これを行うには、データ型に対して2つの演算子クラスを定義し、インデックスを作成するときに適切なクラスを選択します。演算子クラスの詳細については、&lt;a href=&quot;indexes-opclass&quot;&gt;セクション11.10&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;セクション37.16&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48d61fa80ff015b13be4db7ffab694d479aec5c7" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="translated">AREは&lt;em&gt;埋め込みオプションで&lt;/em&gt;開始でき&lt;em&gt;ます&lt;/em&gt;。シーケンス &lt;code&gt;(?&lt;/code&gt; &lt;code&gt;xyz&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; （ &lt;code&gt;xyz&lt;/code&gt; は1つ以上のアルファベット文字）は、残りのREに影響するオプションを指定します。これらのオプションは、以前に決定されたオプションをオーバーライドします。特に、正規表現演算子によって暗黙に指定された大文字と小文字を区別する動作、または正規表現関数の &lt;code&gt;flags&lt;/code&gt; パラメーターをオーバーライドできます。使用可能なオプション文字を&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23に&lt;/a&gt;示します。これらの同じオプション文字が正規表現関数の &lt;code&gt;flags&lt;/code&gt; パラメータで使用されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8303919571de789ee40617113cb585782a02b887" translate="yes" xml:space="preserve">
          <source>An IP address range is specified using standard numeric notation for the range's starting address, then a slash (&lt;code&gt;/&lt;/code&gt;) and a CIDR mask length. The mask length indicates the number of high-order bits of the client IP address that must match. Bits to the right of this should be zero in the given IP address. There must not be any white space between the IP address, the &lt;code&gt;/&lt;/code&gt;, and the CIDR mask length.</source>
          <target state="translated">IPアドレス範囲は、範囲の開始アドレスに標準の数値表記を使用して指定され、次にスラッシュ（ &lt;code&gt;/&lt;/code&gt; ）とCIDRマスク長が使用されます。マスク長は、一致する必要があるクライアントIPアドレスの高位ビットの数を示します。この右側のビットは、指定されたIPアドレスでゼロでなければなりません。 IPアドレス、 &lt;code&gt;/&lt;/code&gt; 、およびCIDRマスク長の間に空白があってはなりません。</target>
        </trans-unit>
        <trans-unit id="4d44878e850b43c3405e5eb1f7f363ec736fdcdb" translate="yes" xml:space="preserve">
          <source>An RE can begin with one of two special &lt;em&gt;director&lt;/em&gt; prefixes. If an RE begins with &lt;code&gt;***:&lt;/code&gt;, the rest of the RE is taken as an ARE. (This normally has no effect in PostgreSQL, since REs are assumed to be AREs; but it does have an effect if ERE or BRE mode had been specified by the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function.) If an RE begins with &lt;code&gt;***=&lt;/code&gt;, the rest of the RE is taken to be a literal string, with all characters considered ordinary characters.</source>
          <target state="translated">REは、2つの特別な&lt;em&gt;ディレクター&lt;/em&gt;プレフィックスのいずれかで開始できます。REが &lt;code&gt;***:&lt;/code&gt; で始まる場合、RE の残りはAREとして扱われます。（REはAREであると見なされるため、通常、これはPostgreSQLでは効果がありません。ただし、regex関数の &lt;code&gt;flags&lt;/code&gt; パラメータでEREまたはBREモードが指定されている場合は効果があります。）REが &lt;code&gt;***=&lt;/code&gt; で始まる場合、REの残りの部分はリテラル文字列と見なされ、すべての文字が通常の文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="f92f9e66ed8af2bcc3cdde26f5c0bbb45e8250e2" translate="yes" xml:space="preserve">
          <source>An RE cannot end with a backslash (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">REをバックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）で終了することはできません。</target>
        </trans-unit>
        <trans-unit id="081369b9016058fa6fc78b0eda53f1fad864ebdf" translate="yes" xml:space="preserve">
          <source>An RE consisting of two or more branches connected by the &lt;code&gt;|&lt;/code&gt; operator is always greedy.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; で接続された2つ以上のブランチで構成されるRE 演算子は常に貪欲です。</target>
        </trans-unit>
        <trans-unit id="d49fecf670a244dc0b1f819b231bb69a34573ff1" translate="yes" xml:space="preserve">
          <source>An RFC 4516 LDAP URL. This is an alternative way to write some of the other LDAP options in a more compact and standard form. The format is</source>
          <target state="translated">RFC 4516 LDAP URL。これは、他のLDAPオプションのいくつかをよりコンパクトで標準的な形式で記述するための代替方法です。形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f7312c64a5fb73a6994e92da5b12fd76cc61e03e" translate="yes" xml:space="preserve">
          <source>An SHA1 hash of the random prefix and data is appended.</source>
          <target state="translated">ランダムな接頭辞とデータの SHA1 ハッシュが付加されます。</target>
        </trans-unit>
        <trans-unit id="f0fe55953856dbcea542a9b75d2a05e987bd7029" translate="yes" xml:space="preserve">
          <source>An SQL statement defining an object to be created within the schema. Currently, only &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE VIEW&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE SEQUENCE&lt;/code&gt;, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and &lt;code&gt;GRANT&lt;/code&gt; are accepted as clauses within &lt;code&gt;CREATE SCHEMA&lt;/code&gt;. Other kinds of objects may be created in separate commands after the schema is created.</source>
          <target state="translated">スキーマ内に作成されるオブジェクトを定義するSQLステートメント。現在、 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 内の句として受け入れられるのは、 &lt;code&gt;CREATE TABLE&lt;/code&gt; 、 &lt;code&gt;CREATE VIEW&lt;/code&gt; 、 &lt;code&gt;CREATE INDEX&lt;/code&gt; 、 &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; 、 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; および &lt;code&gt;GRANT&lt;/code&gt; のみです。他の種類のオブジェクトは、スキーマの作成後に別のコマンドで作成できます。</target>
        </trans-unit>
        <trans-unit id="48fae02660a1ba4984826c61b82cac7e0aec9ce9" translate="yes" xml:space="preserve">
          <source>An SQL/JSON path expression is typically written in an SQL query as an SQL character string literal, so it must be enclosed in single quotes, and any single quotes desired within the value must be doubled (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;). Some forms of path expressions require string literals within them. These embedded string literals follow JavaScript/ECMAScript conventions: they must be surrounded by double quotes, and backslash escapes may be used within them to represent otherwise-hard-to-type characters. In particular, the way to write a double quote within an embedded string literal is &lt;code&gt;\&quot;&lt;/code&gt;, and to write a backslash itself, you must write &lt;code&gt;\\&lt;/code&gt;. Other special backslash sequences include those recognized in JSON strings: &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\v&lt;/code&gt; for various ASCII control characters, and &lt;code&gt;\uNNNN&lt;/code&gt; for a Unicode character identified by its 4-hex-digit code point. The backslash syntax also includes two cases not allowed by JSON: &lt;code&gt;\xNN&lt;/code&gt; for a character code written with only two hex digits, and &lt;code&gt;\u{N...}&lt;/code&gt; for a character code written with 1 to 6 hex digits.</source>
          <target state="translated">SQL / JSONパス式は通常、SQL文字列リテラルとしてSQLクエリで記述されるため、一重引用符で囲む必要があり、値内で必要な一重引用符はすべて二重にする必要があります（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;セクション4.1.2.1を&lt;/a&gt;参照）。パス式の一部の形式では、その中に文字列リテラルが必要です。これらの埋め込み文字列リテラルは、JavaScript / ECMAScriptの規則に従います。二重引用符で囲む必要があり、バックスラッシュエスケープを使用して、入力が難しい文字を表すことができます。特に、埋め込み文字列リテラル内に二重引用符を記述する方法は &lt;code&gt;\&quot;&lt;/code&gt; で、バックスラッシュ自体を書き込む方法は &lt;code&gt;\\&lt;/code&gt; を記述する必要があります。その他の特殊なバックスラッシュシーケンスには、JSON文字列で認識されるものがあります： &lt;code&gt;\b&lt;/code&gt; 、 &lt;code&gt;\f&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、 &lt;code&gt;\t&lt;/code&gt; 、 &lt;code&gt;\v&lt;/code&gt; はさまざまなASCII制御文字用、 &lt;code&gt;\uNNNN&lt;/code&gt; は4桁の16進コードポイントで識別されるUnicode文字用。バックスラッシュ構文はまた、2つのJSONによって許可されていない場合も含む： &lt;code&gt;\xNN&lt;/code&gt; 2つだけ進数字で書かれた文字コードのため、および &lt;code&gt;\u{N...}&lt;/code&gt; 1〜6進数字で書かれた文字コードのために。</target>
        </trans-unit>
        <trans-unit id="a47144dcc7f07df67a82e2f341e637ce0d341143" translate="yes" xml:space="preserve">
          <source>An additional caveat, if the goal is to avoid recalculating &lt;code&gt;f(x)&lt;/code&gt;, is that the planner won't necessarily match uses of &lt;code&gt;f(x)&lt;/code&gt; that aren't in indexable &lt;code&gt;WHERE&lt;/code&gt; clauses to the index column. It will usually get this right in simple queries such as shown above, but not in queries that involve joins. These deficiencies may be remedied in future versions of PostgreSQL.</source>
          <target state="translated">目標が &lt;code&gt;f(x)&lt;/code&gt; の再計算を回避することである場合の追加の警告は、プランナが必ずしもインデックス可能な &lt;code&gt;WHERE&lt;/code&gt; 句にない &lt;code&gt;f(x)&lt;/code&gt; の使用とインデックス列を一致させることではないということです。これは通常、上に示したような単純なクエリでは正しく行われますが、結合を含むクエリでは正しく行われません。これらの欠陥は、PostgreSQLの将来のバージョンで修正される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7407a4adf6d27ef60782fee33abc21dda639d1bb" translate="yes" xml:space="preserve">
          <source>An additional expectation is that &lt;code&gt;in_range&lt;/code&gt; functions should, if practical, avoid throwing an error if &lt;code&gt;base&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;base&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; would overflow. The correct comparison result can be determined even if that value would be out of the data type's range. Note that if the data type includes concepts such as &amp;ldquo;infinity&amp;rdquo; or &amp;ldquo;NaN&amp;rdquo;, extra care may be needed to ensure that &lt;code&gt;in_range&lt;/code&gt;'s results agree with the normal sort order of the operator family.</source>
          <target state="translated">さらに予想されるのは、 &lt;code&gt;base&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; または &lt;code&gt;base&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; がオーバーフローする場合に、 &lt;code&gt;in_range&lt;/code&gt; 関数が実用的であればエラーをスローしないようにすることです。その値がデータ型の範囲外であっても、正しい比較結果を判断できます。データ型に「無限大」や「NaN」などの概念が含まれている場合は、 &lt;code&gt;in_range&lt;/code&gt; の結果が演算子族の通常の並べ替え順序と一致するように、さらに注意が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="534defd7e745925ed14ebff65872ea3017b9134a" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="translated">パーサーによって提供される追加のヒューリスティックにより、暗黙的なキャストを持つタイプのグループ間での適切なキャスト動作の決定が改善されます。データ型は、 &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;numeric&lt;/code&gt; 、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;bitstring&lt;/code&gt; 、 &lt;code&gt;datetime&lt;/code&gt; 、 &lt;code&gt;timespan&lt;/code&gt; 、 &lt;code&gt;geometric&lt;/code&gt; 、 &lt;code&gt;network&lt;/code&gt; 、およびuser-defined など、いくつかの基本的な&lt;em&gt;型のカテゴリに分類&lt;/em&gt;されます。 （リストについては&lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;表51.64を&lt;/a&gt;参照してください。ただし、カスタムタイプのカテゴリを作成することも可能であることに注意してください。）各カテゴリ内には、1つ以上の&lt;em&gt;優先タイプがあります。&lt;/em&gt;&lt;em&gt;&lt;/em&gt;、可能なタイプの選択肢がある場合に推奨されます。優先する型と利用可能な暗黙のキャストを注意深く選択することで、あいまいな式（複数の解析ソリューション候補があるもの）を便利な方法で解決できるようになります。</target>
        </trans-unit>
        <trans-unit id="7fc0f4d6b418b13b44c7318de707eba4cc69a20d" translate="yes" xml:space="preserve">
          <source>An additional property of most of the OID alias types is the creation of dependencies. If a constant of one of these types appears in a stored expression (such as a column default expression or view), it creates a dependency on the referenced object. For example, if a column has a default expression &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt;, PostgreSQL understands that the default expression depends on the sequence &lt;code&gt;my_seq&lt;/code&gt;; the system will not let the sequence be dropped without first removing the default expression. &lt;code&gt;regrole&lt;/code&gt; is the only exception for the property. Constants of this type are not allowed in such expressions.</source>
          <target state="translated">ほとんどのOIDエイリアスタイプの追加のプロパティは、依存関係の作成です。これらのタイプのいずれかの定数が、格納された式（列のデフォルト式やビューなど）に現れる場合、参照されるオブジェクトへの依存関係を作成します。たとえば、列にデフォルト式 &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt; 場合、PostgreSQLはデフォルト式がシーケンス &lt;code&gt;my_seq&lt;/code&gt; に依存することを理解します。システムは、最初にデフォルトの式を削除しない限り、シーケンスを削除できません。 &lt;code&gt;regrole&lt;/code&gt; は、プロパティの唯一の例外です。このタイプの定数は、このような式では使用できません。</target>
        </trans-unit>
        <trans-unit id="458e50f0c0fe0a599acde7428114320c8fb97644" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;セクション37.12.1で&lt;/a&gt;説明されているように、集約はオプションで&lt;em&gt;移動集約モードを&lt;/em&gt;サポートできます。これには、 &lt;code&gt;MSFUNC&lt;/code&gt; 、 &lt;code&gt;MINVFUNC&lt;/code&gt; 、および &lt;code&gt;MSTYPE&lt;/code&gt; パラメータを指定する必要があり、オプションで &lt;code&gt;MSSPACE&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; 、および &lt;code&gt;MINITCOND&lt;/code&gt; パラメータを指定する必要があります。 &lt;code&gt;MINVFUNC&lt;/code&gt; を除いて、これらのパラメーターは &lt;code&gt;M&lt;/code&gt; なしの対応する単純集計パラメーターと同様に機能します。これらは、逆遷移関数を含む集約の個別の実装を定義します。</target>
        </trans-unit>
        <trans-unit id="4d679ad2d9aaa3f73ccadb1adf16347c9d1df070" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;37.12.4項で&lt;/a&gt;説明するように、集計はオプションで&lt;em&gt;部分集計を&lt;/em&gt;サポートできます。これには、 &lt;code&gt;COMBINEFUNC&lt;/code&gt; パラメータを指定する必要があります。場合 &lt;code&gt;state_data_type&lt;/code&gt; ある &lt;code&gt;internal&lt;/code&gt; 、それは提供するために、適切なも普通だ &lt;code&gt;SERIALFUNC&lt;/code&gt; と &lt;code&gt;DESERIALFUNC&lt;/code&gt; 並列集約が可能になるようにパラメータを。並列集約を有効にするには、集約にも &lt;code&gt;PARALLEL SAFE&lt;/code&gt; のマークを付ける必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2dfc7ac5613e772bc99452f1945c3b220614eb51" translate="yes" xml:space="preserve">
          <source>An aggregate expression</source>
          <target state="translated">集約式</target>
        </trans-unit>
        <trans-unit id="e0807075b6b78aa07561f78a847dd6293e2860ad" translate="yes" xml:space="preserve">
          <source>An aggregate expression can only appear in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; command. It is forbidden in other clauses, such as &lt;code&gt;WHERE&lt;/code&gt;, because those clauses are logically evaluated before the results of aggregates are formed.</source>
          <target state="translated">集計式は、 &lt;code&gt;SELECT&lt;/code&gt; コマンドの結果リストまたは &lt;code&gt;HAVING&lt;/code&gt; 句にのみ表示できます。これらの句は集計の結果が形成される前に論理的に評価されるため、 &lt;code&gt;WHERE&lt;/code&gt; などの他の句では禁止されています。</target>
        </trans-unit>
        <trans-unit id="d5cc6417758e002213e0379735846ccb8b7a9410" translate="yes" xml:space="preserve">
          <source>An aggregate function can provide an initial condition, that is, an initial value for the internal state value. This is specified and stored in the database as a value of type &lt;code&gt;text&lt;/code&gt;, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out null.</source>
          <target state="translated">集約関数は、初期状態、つまり内部状態値の初期値を提供できます。これは &lt;code&gt;text&lt;/code&gt; 型の値として指定され、データベースに格納されますが、状態値のデータ型の定数の有効な外部表現である必要があります。指定しない場合、状態値はnullから始まります。</target>
        </trans-unit>
        <trans-unit id="4c0a9d3ddcc76a8af6ce90bf3fe2aed9cae7fe77" translate="yes" xml:space="preserve">
          <source>An aggregate function is identified by its name and input data type(s). Two aggregates in the same schema can have the same name if they operate on different input types. The name and input data type(s) of an aggregate must also be distinct from the name and input data type(s) of every ordinary function in the same schema. This behavior is identical to overloading of ordinary function names (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;).</source>
          <target state="translated">集約関数は、その名前と入力データ型によって識別されます。同じスキーマ内の2つの集計が異なる入力タイプで動作する場合、それらは同じ名前を持つことができます。集計の名前と入力データ型も、同じスキーマ内のすべての通常の関数の名前と入力データ型とは異なる必要があります。この動作は、通常の関数名の多重定義と同じです（&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTIONを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2b3e0e3a20d60ad454bd8cd7d186466b528e1274" translate="yes" xml:space="preserve">
          <source>An aggregate function whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt; can participate in parallel aggregation only if it has a &lt;code&gt;serialfunc&lt;/code&gt; function, which must serialize the aggregate state into a &lt;code&gt;bytea&lt;/code&gt; value for transmission to another process. This function must take a single argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;bytea&lt;/code&gt;. A corresponding &lt;code&gt;deserialfunc&lt;/code&gt; is also required.</source>
          <target state="translated">&lt;code&gt;state_data_type&lt;/code&gt; が &lt;code&gt;internal&lt;/code&gt; である集約関数は、別のプロセスに送信するために集約状態を &lt;code&gt;bytea&lt;/code&gt; 値にシリアル化する必要がある &lt;code&gt;serialfunc&lt;/code&gt; 関数がある場合にのみ、並列集約に参加できます。この関数は、 &lt;code&gt;internal&lt;/code&gt; 型の引数を1つ取り、型 &lt;code&gt;bytea&lt;/code&gt; を返す必要があります。対応する &lt;code&gt;deserialfunc&lt;/code&gt; も必要です。</target>
        </trans-unit>
        <trans-unit id="df00344c6606cf49c7be60428adf4c46220a9708" translate="yes" xml:space="preserve">
          <source>An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by &lt;code&gt;ORDINALITY&lt;/code&gt; if present.</source>
          <target state="translated">エイリアスは、テーブルの場合と同じ方法で提供できます。エイリアスが記述されている場合、列エイリアスリストを記述して、関数の複合戻り値型の1つ以上の属性の代替名を提供することもできます（ &lt;code&gt;ORDINALITY&lt;/code&gt; によって追加された列がある場合）。</target>
        </trans-unit>
        <trans-unit id="a0250a12b43f45cb324a618ef9cdbd68812da4e5" translate="yes" xml:space="preserve">
          <source>An alternative backup strategy is to directly copy the files that PostgreSQL uses to store the data in the database; &lt;a href=&quot;creating-cluster&quot;&gt;Section 18.2&lt;/a&gt; explains where these files are located. You can use whatever method you prefer for doing file system backups; for example:</source>
          <target state="translated">別のバックアップ戦略は、PostgreSQLがデータベースにデータを格納するために使用するファイルを直接コピーすることです。&lt;a href=&quot;creating-cluster&quot;&gt;セクション18.2&lt;/a&gt;では、これらのファイルの場所について説明しています。ファイルシステムのバックアップには、任意の方法を使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="b61de693c26d02887a03f9b9c2b1cd2f4c796982" translate="yes" xml:space="preserve">
          <source>An alternative file-system backup approach is to make a &amp;ldquo;consistent snapshot&amp;rdquo; of the data directory, if the file system supports that functionality (and you are willing to trust that it is implemented correctly). The typical procedure is to make a &amp;ldquo;frozen snapshot&amp;rdquo; of the volume containing the database, then copy the whole data directory (not just parts, see above) from the snapshot to a backup device, then release the frozen snapshot. This will work even while the database server is running. However, a backup created in this way saves the database files in a state as if the database server was not properly shut down; therefore, when you start the database server on the backed-up data, it will think the previous server instance crashed and will replay the WAL log. This is not a problem; just be aware of it (and be sure to include the WAL files in your backup). You can perform a &lt;code&gt;CHECKPOINT&lt;/code&gt; before taking the snapshot to reduce recovery time.</source>
          <target state="translated">別のファイルシステムバックアップアプローチは、データシステムの「一貫性のあるスナップショット」を作成することです。ただし、ファイルシステムがその機能をサポートしている場合（および、ファイルシステムが正しく実装されていると信頼してもかまいません）。典型的な手順は、データベースを含むボリュームの「凍結されたスナップショット」を作成し、スナップショットからバックアップデバイスにデータディレクトリー全体（一部だけではなく、上記を参照）をコピーして、凍結されたスナップショットを解放することです。これは、データベースサーバーの実行中でも機能します。ただし、この方法で作成されたバックアップは、データベースサーバーが適切にシャットダウンされなかったかのようにデータベースファイルを保存します。したがって、バックアップデータでデータベースサーバーを起動すると、以前のサーバーインスタンスがクラッシュしたと見なされ、WALログが再生されます。これは問題ではありません。これに注意してください（バックアップにWALファイルを含めるようにしてください）。あなたは &lt;code&gt;CHECKPOINT&lt;/code&gt; スナップショットを作成する前にチェックポイントを設定して、復旧時間を短縮します。</target>
        </trans-unit>
        <trans-unit id="c3c3283b5d81a417bf78d55aa00de334b32f532e" translate="yes" xml:space="preserve">
          <source>An alternative syntax, which conforms to the SQL standard by using the keyword &lt;code&gt;ARRAY&lt;/code&gt;, can be used for one-dimensional arrays. &lt;code&gt;pay_by_quarter&lt;/code&gt; could have been defined as:</source>
          <target state="translated">キーワード &lt;code&gt;ARRAY&lt;/code&gt; を使用してSQL標準に準拠する代替構文を1次元配列に使用できます。 &lt;code&gt;pay_by_quarter&lt;/code&gt; は次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="638c7c832e5e9b62d5fb5f6d733b2905e931d645" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="translated">前のセクションで説明した組み込みのスタンバイモードの代わりに、アーカイブの場所をポーリングする &lt;code&gt;restore_command&lt;/code&gt; を使用することができます。これは、バージョン8.4以前で使用できる唯一のオプションでした。このリファレンス実装については、&lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="fa59772716d4044140c10df2d8b7a5924c081417" translate="yes" xml:space="preserve">
          <source>An alternative way to specify connection parameters is in a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string or a URI, which is used instead of a database name. This mechanism give you very wide control over the connection. For example:</source>
          <target state="translated">接続パラメータを指定する別の方法は、データベース名の代わりに使用される&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;文字列またはURIです。このメカニズムにより、接続を非常に幅広く制御できます。例えば：</target>
        </trans-unit>
        <trans-unit id="8ec33e5bc23fcb877ba4c42aa95a3a9f21f59a6d" translate="yes" xml:space="preserve">
          <source>An arbitrary identifier that later identifies this transaction for &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. The identifier must be written as a string literal, and must be less than 200 bytes long. It must not be the same as the identifier used for any currently prepared transaction.</source>
          <target state="translated">&lt;code&gt;COMMIT PREPARED&lt;/code&gt; または &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; についてこのトランザクションを後で識別する任意の識別子。識別子は文字列リテラルとして記述する必要があり、長さは200バイト未満でなければなりません。現在準備されているトランザクションに使用される識別子と同じであってはなりません。</target>
        </trans-unit>
        <trans-unit id="154d8a4c4e542e35a1befe68e1484bcdb9bfce9b" translate="yes" xml:space="preserve">
          <source>An arbitrary name given to this particular prepared statement. It must be unique within a single session and is subsequently used to execute or deallocate a previously prepared statement.</source>
          <target state="translated">この特定の準備されたステートメントに与えられる任意の名前。この名前は単一のセッション内で一意でなければならず、その後、以前に準備されたステートメントを実行したり解放したりするために使用されます。</target>
        </trans-unit>
        <trans-unit id="8cfd518cee734d4e6e12ef304061cfa2c5efcc5d" translate="yes" xml:space="preserve">
          <source>An array can also be constructed by using the functions &lt;code&gt;array_prepend&lt;/code&gt;, &lt;code&gt;array_append&lt;/code&gt;, or &lt;code&gt;array_cat&lt;/code&gt;. The first two only support one-dimensional arrays, but &lt;code&gt;array_cat&lt;/code&gt; supports multidimensional arrays. Some examples:</source>
          <target state="translated">配列は、関数 &lt;code&gt;array_prepend&lt;/code&gt; 、 &lt;code&gt;array_append&lt;/code&gt; 、または &lt;code&gt;array_cat&lt;/code&gt; を使用して構築することもできます。最初の2つは1次元配列のみをサポートしますが、 &lt;code&gt;array_cat&lt;/code&gt; は多次元配列をサポートします。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="b9253fad046b597c92ebf100d62457d49600956f" translate="yes" xml:space="preserve">
          <source>An array can also be updated at a single element:</source>
          <target state="translated">配列は1つの要素で更新することもできます。</target>
        </trans-unit>
        <trans-unit id="207ba5c2689d9a2decbdf9a201e85765c620f79a" translate="yes" xml:space="preserve">
          <source>An array constructor</source>
          <target state="translated">配列のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="22dde08afcbb8b9d32ea23d688400ce811c7d712" translate="yes" xml:space="preserve">
          <source>An array constructor is an expression that builds an array value using values for its member elements. A simple array constructor consists of the key word &lt;code&gt;ARRAY&lt;/code&gt;, a left square bracket &lt;code&gt;[&lt;/code&gt;, a list of expressions (separated by commas) for the array element values, and finally a right square bracket &lt;code&gt;]&lt;/code&gt;. For example:</source>
          <target state="translated">配列コンストラクターは、メンバー要素の値を使用して配列値を構築する式です。単純な配列コンストラクターは、キーワード &lt;code&gt;ARRAY&lt;/code&gt; 、左大括弧 &lt;code&gt;[&lt;/code&gt; 、配列要素値の式のリスト（コンマで区切られた）、最後に右大括弧 &lt;code&gt;]&lt;/code&gt; で構成されます。例えば：</target>
        </trans-unit>
        <trans-unit id="7dbcd90a7826ddce4d84f03c4037551f65cc619b" translate="yes" xml:space="preserve">
          <source>An array containing codes for the enabled statistic kinds; valid values are: &lt;code&gt;d&lt;/code&gt; for n-distinct statistics, &lt;code&gt;f&lt;/code&gt; for functional dependency statistics, and &lt;code&gt;m&lt;/code&gt; for most common values (MCV) list statistics</source>
          <target state="translated">有効な統計の種類のコードを含む配列。有効な値は、n-distinct統計の場合は &lt;code&gt;d&lt;/code&gt; 、機能依存関係統計の場合は &lt;code&gt;f&lt;/code&gt; 、最も一般的な値（MCV）リスト統計の場合は &lt;code&gt;m&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="27ac7c03cbb87eb7b9fd6d5d5942fb204a13357b" translate="yes" xml:space="preserve">
          <source>An array containing the IDs of the roles in this group</source>
          <target state="translated">このグループのロールのIDを含む配列</target>
        </trans-unit>
        <trans-unit id="96036220e810514b07282609308d02f0cce74ab2" translate="yes" xml:space="preserve">
          <source>An array of attribute numbers, indicating which table columns are covered by this statistics object; for example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns are covered</source>
          <target state="translated">この統計オブジェクトによってカバーされるテーブル列を示す属性番号の配列。たとえば、 &lt;code&gt;1 3&lt;/code&gt; の値は、最初と3番目のテーブル列がカバーされることを意味します</target>
        </trans-unit>
        <trans-unit id="b19c35ad447cc03eaa08f8712bc2b7258decc833" translate="yes" xml:space="preserve">
          <source>An array slice expression likewise yields null if the array itself or any of the subscript expressions are null. However, in other cases such as selecting an array slice that is completely outside the current array bounds, a slice expression yields an empty (zero-dimensional) array instead of null. (This does not match non-slice behavior and is done for historical reasons.) If the requested slice partially overlaps the array bounds, then it is silently reduced to just the overlapping region instead of returning null.</source>
          <target state="translated">配列スライス式も同様に、配列自体または添え字式のいずれかが null の場合は null を返します。ただし、現在の配列の境界から完全に外れた配列スライスを選択するなど、その他のケースでは、スライス式は NULL の代わりに空の (ゼロ次元の)配列を返します (これは、スライス以外の動作とは一致せず、歴史的な理由から行われています)。(これは、スライス以外の動作とは一致せず、歴史的な理由から行われています。)要求されたスライスが配列の境界と部分的に重なっている場合は、NULL を返す代わりに、重なっている領域だけに縮小されます。</target>
        </trans-unit>
        <trans-unit id="1acc2bad9c714dff64f3a38358f5e30f839c8b6c" translate="yes" xml:space="preserve">
          <source>An array subscript expression will return null if either the array itself or any of the subscript expressions are null. Also, null is returned if a subscript is outside the array bounds (this case does not raise an error). For example, if &lt;code&gt;schedule&lt;/code&gt; currently has the dimensions &lt;code&gt;[1:3][1:2]&lt;/code&gt; then referencing &lt;code&gt;schedule[3][3]&lt;/code&gt; yields NULL. Similarly, an array reference with the wrong number of subscripts yields a null rather than an error.</source>
          <target state="translated">配列の添字式は、配列自体または添え字式のいずれかがnullの場合、nullを返します。また、添え字が配列の境界の外にある場合はnullが返されます（この場合、エラーは発生しません）。たとえば、 &lt;code&gt;schedule&lt;/code&gt; のディメンションが現在 &lt;code&gt;[1:3][1:2]&lt;/code&gt; の場合、 &lt;code&gt;schedule[3][3]&lt;/code&gt; するとNULLになります。同様に、添え字の数が間違っている配列参照は、エラーではなくnullになります。</target>
        </trans-unit>
        <trans-unit id="0832096d10a386e248df7b28cfa12adfe25aab94" translate="yes" xml:space="preserve">
          <source>An array value can be replaced completely:</source>
          <target state="translated">配列の値を完全に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="af4fc25fcb8b1fcdab019c9c24576221478e42a1" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes all arguments (including &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments); however, if all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripting is 1-based, whereas for historical reasons &lt;code&gt;proargtypes&lt;/code&gt; is subscripted from 0.</source>
          <target state="translated">関数の引数のデータ型を含む配列。これには、すべての引数（ &lt;code&gt;OUT&lt;/code&gt; および &lt;code&gt;INOUT&lt;/code&gt; 引数を含む）が含まれます。ただし、すべての引数が &lt;code&gt;IN&lt;/code&gt; 引数の場合、このフィールドはnullになります。添え字は1ベースですが、歴史的な理由から &lt;code&gt;proargtypes&lt;/code&gt; は0から添え字が付けられていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b1056fb2643af14679cc3ecd97ee8851fd6939a7" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes only input arguments (including &lt;code&gt;INOUT&lt;/code&gt; and &lt;code&gt;VARIADIC&lt;/code&gt; arguments), and thus represents the call signature of the function.</source>
          <target state="translated">関数の引数のデータ型を含む配列。これには入力引数（ &lt;code&gt;INOUT&lt;/code&gt; および &lt;code&gt;VARIADIC&lt;/code&gt; 引数を含む）のみが含まれるため、関数の呼び出しシグネチャを表します。</target>
        </trans-unit>
        <trans-unit id="56e64d796da368f4732fec1eac245d18f34b8c2b" translate="yes" xml:space="preserve">
          <source>An array with the modes of the function arguments, encoded as &lt;code&gt;i&lt;/code&gt; for &lt;code&gt;IN&lt;/code&gt; arguments, &lt;code&gt;o&lt;/code&gt; for &lt;code&gt;OUT&lt;/code&gt; arguments, &lt;code&gt;b&lt;/code&gt; for &lt;code&gt;INOUT&lt;/code&gt; arguments, &lt;code&gt;v&lt;/code&gt; for &lt;code&gt;VARIADIC&lt;/code&gt; arguments, &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;TABLE&lt;/code&gt; arguments. If all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">符号化関数の引数のモードを有する配列、 &lt;code&gt;i&lt;/code&gt; のために &lt;code&gt;IN&lt;/code&gt; の引数、 &lt;code&gt;o&lt;/code&gt; 用 &lt;code&gt;OUT&lt;/code&gt; 引数、 &lt;code&gt;b&lt;/code&gt; 用 &lt;code&gt;INOUT&lt;/code&gt; の引数、 &lt;code&gt;v&lt;/code&gt; 用 &lt;code&gt;VARIADIC&lt;/code&gt; の引数、 &lt;code&gt;t&lt;/code&gt; のための &lt;code&gt;TABLE&lt;/code&gt; 引数。すべての引数が &lt;code&gt;IN&lt;/code&gt; 引数の場合、このフィールドはnullになります。添え字は &lt;code&gt;proallargtypes&lt;/code&gt; なく &lt;code&gt;proargtypes&lt;/code&gt; 位置に対応することに注意してください。</target>
        </trans-unit>
        <trans-unit id="19750404179dcfe4198dc9453208db71584c69d3" translate="yes" xml:space="preserve">
          <source>An array with the names of the function arguments. Arguments without a name are set to empty strings in the array. If none of the arguments have a name, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">関数の引数の名前を含む配列。名前のない引数は、配列内の空の文字列に設定されます。引数に名前がない場合、このフィールドはnullになります。添え字は &lt;code&gt;proallargtypes&lt;/code&gt; なく &lt;code&gt;proargtypes&lt;/code&gt; 位置に対応することに注意してください。</target>
        </trans-unit>
        <trans-unit id="f01a907c7341c3e9fdd4bc077438737e13efc650" translate="yes" xml:space="preserve">
          <source>An asterisk (&lt;code&gt;*&lt;/code&gt;) can be placed at the end of a synonym in the configuration file. This indicates that the synonym is a prefix. The asterisk is ignored when the entry is used in &lt;code&gt;to_tsvector()&lt;/code&gt;, but when it is used in &lt;code&gt;to_tsquery()&lt;/code&gt;, the result will be a query item with the prefix match marker (see &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;Section 12.3.2&lt;/a&gt;). For example, suppose we have these entries in &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt;:</source>
          <target state="translated">アスタリスク（ &lt;code&gt;*&lt;/code&gt; ）は、構成ファイルの同義語の終わりに置くことができます。これは、シノニムがプレフィックスであることを示しています。アスタリスクは、エントリがで使用されている場合は無視され &lt;code&gt;to_tsvector()&lt;/code&gt; が、それはで使用されている場合 &lt;code&gt;to_tsquery()&lt;/code&gt; 、結果は前方一致マーカー（参照とクエリ項目となります&lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;12.3.2項を&lt;/a&gt;）。たとえば、 &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt; 次のエントリがあるとします。</target>
        </trans-unit>
        <trans-unit id="c86af8f966441072cea93666c92eea93103579c8" translate="yes" xml:space="preserve">
          <source>An automatically updatable view may contain a mix of updatable and non-updatable columns. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read-only, and an error will be raised if an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; statement attempts to assign a value to it.</source>
          <target state="translated">自動的に更新可能なビューには、更新可能な列と更新不可能な列が混在する場合があります。基になる基本リレーションの更新可能な列への単純な参照である場合、列は更新可能です。それ以外の場合、列は読み取り専用であり、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; ステートメントが値を割り当てようとするとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="13229daa72676e5cc65b4f01d9a20d25d5a2a7d0" translate="yes" xml:space="preserve">
          <source>An encrypted PGP message consists of 2 parts, or &lt;em&gt;packets&lt;/em&gt;:</source>
          <target state="translated">暗号化されたPGPメッセージは2つの部分、つまり&lt;em&gt;パケットで&lt;/em&gt;構成され&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="09f724c84938e490e8dc9343f32211856b8b0d2e" translate="yes" xml:space="preserve">
          <source>An entry given in IPv4 format will match only IPv4 connections, and an entry given in IPv6 format will match only IPv6 connections, even if the represented address is in the IPv4-in-IPv6 range. Note that entries in IPv6 format will be rejected if the system's C library does not have support for IPv6 addresses.</source>
          <target state="translated">IPv4形式で指定されたエントリは、IPv4接続のみにマッチし、IPv6形式で指定されたエントリは、表現されたアドレスがIPv4-in-IPv6の範囲内であっても、IPv6接続のみにマッチします。システムのCライブラリがIPv6アドレスをサポートしていない場合、IPv6形式のエントリは拒否されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="938494e5885c658c095719a63c4ba845fac9421d" translate="yes" xml:space="preserve">
          <source>An entry's &lt;code&gt;amopmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family (including &lt;code&gt;amopmethod&lt;/code&gt; here is an intentional denormalization of the catalog structure for performance reasons). Also, &lt;code&gt;amoplefttype&lt;/code&gt; and &lt;code&gt;amoprighttype&lt;/code&gt; must match the &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields of the referenced &lt;code&gt;pg_operator&lt;/code&gt; entry.</source>
          <target state="translated">エントリの &lt;code&gt;amopmethod&lt;/code&gt; は、それを含む演算子ファミリの &lt;code&gt;opfmethod&lt;/code&gt; と一致する必要があります（ここでの &lt;code&gt;amopmethod&lt;/code&gt; は、パフォーマンス上の理由から、意図的なカタログ構造の非正規化です）。また、 &lt;code&gt;amoplefttype&lt;/code&gt; と &lt;code&gt;amoprighttype&lt;/code&gt; は、参照される &lt;code&gt;pg_operator&lt;/code&gt; エントリの &lt;code&gt;oprleft&lt;/code&gt; および &lt;code&gt;oprright&lt;/code&gt; フィールドと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="d1d1086ba8d92dc57d5ff412fcf067dd0fa10959" translate="yes" xml:space="preserve">
          <source>An enum value occupies four bytes on disk. The length of an enum value's textual label is limited by the &lt;code&gt;NAMEDATALEN&lt;/code&gt; setting compiled into PostgreSQL; in standard builds this means at most 63 bytes.</source>
          <target state="translated">列挙値はディスク上で4バイトを占有します。enum値のテキストラベルの長さは、PostgreSQLにコンパイルされた &lt;code&gt;NAMEDATALEN&lt;/code&gt; 設定によって制限されます。標準ビルドでは、これは最大63バイトを意味します。</target>
        </trans-unit>
        <trans-unit id="7d926b20cea28dde9ab53148cbd01bb72e3b71c1" translate="yes" xml:space="preserve">
          <source>An error like:</source>
          <target state="translated">のようなエラー。</target>
        </trans-unit>
        <trans-unit id="73f7ed75cabe931d593b5e23922ed970c7f9a2c6" translate="yes" xml:space="preserve">
          <source>An event trigger function is declared to return &lt;code&gt;event_trigger.&lt;/code&gt;</source>
          <target state="translated">イベントトリガー関数は、 &lt;code&gt;event_trigger.&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="e5d03b1b3e9330df5ef72cedfa521226e3904563" translate="yes" xml:space="preserve">
          <source>An example command to insert a row would be:</source>
          <target state="translated">行を挿入するコマンドの例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="77db1d337bb2340f6b1a45dac50171d5552245cf" translate="yes" xml:space="preserve">
          <source>An example is:</source>
          <target state="translated">例を挙げると</target>
        </trans-unit>
        <trans-unit id="ab2ae23169c6ecf2d8724ae3dd48f5aec7d41be5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a priority-based multiple synchronous standbys is:</source>
          <target state="translated">優先度に基づく複数の同期スタンバイの &lt;code&gt;synchronous_standby_names&lt;/code&gt; の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a98fc82d0f241f92e10ef779f12a66f98cdb0af5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a quorum-based multiple synchronous standbys is:</source>
          <target state="translated">クォーラムベースの複数の同期スタンバイの &lt;code&gt;synchronous_standby_names&lt;/code&gt; の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="dd7d7ba1d423d1278de206e487f072bf081d0594" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are rows in the table that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER TABLE&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.</source>
          <target state="translated">この仮定を破る一般的な方法の例は、 &lt;code&gt;CHECK&lt;/code&gt; 式でユーザー定義関数を参照してから、その関数の動作を変更することです。 PostgreSQLはこれを禁止していませんが、 &lt;code&gt;CHECK&lt;/code&gt; 制約に違反している行がテーブルにあるかどうかはわかりません。これにより、後続のデータベースのダンプとリロードが失敗します。このような変更を処理するための推奨される方法は、（ &lt;code&gt;ALTER TABLE&lt;/code&gt; を使用して）制約を削除し、関数定義を調整し、制約を再度追加して、すべてのテーブル行に対して制約を再チェックすることです。</target>
        </trans-unit>
        <trans-unit id="0fc2dcac68631535509b1c9851983c8f16591ded" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are stored values of the domain type that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER DOMAIN&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against stored data.</source>
          <target state="translated">この仮定を破る一般的な方法の例は、 &lt;code&gt;CHECK&lt;/code&gt; 式でユーザー定義関数を参照してから、その関数の動作を変更することです。 PostgreSQLはこれを禁止していませんが、 &lt;code&gt;CHECK&lt;/code&gt; 制約に違反しているドメインタイプの格納された値があるかどうかはわかりません。これにより、後続のデータベースのダンプとリロードが失敗します。このような変更を処理するための推奨される方法は、（ &lt;code&gt;ALTER DOMAIN&lt;/code&gt; を使用して）制約を削除し、関数定義を調整し、制約を再度追加して、格納されたデータに対して制約を再チェックすることです。</target>
        </trans-unit>
        <trans-unit id="f4d8042a8aacf4dd946a6de3a479fedbae68b9bb" translate="yes" xml:space="preserve">
          <source>An example of an ordered-set aggregate call is:</source>
          <target state="translated">順序付き集合集合の呼び出しの例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9b9fd9076643bacdf456e68d66e8b722bd4cc414" translate="yes" xml:space="preserve">
          <source>An example of the problem situation is an administrator on the primary server running &lt;code&gt;DROP TABLE&lt;/code&gt; on a table that is currently being queried on the standby server. Clearly the standby query cannot continue if the &lt;code&gt;DROP TABLE&lt;/code&gt; is applied on the standby. If this situation occurred on the primary, the &lt;code&gt;DROP TABLE&lt;/code&gt; would wait until the other query had finished. But when &lt;code&gt;DROP TABLE&lt;/code&gt; is run on the primary, the primary doesn't have information about what queries are running on the standby, so it will not wait for any such standby queries. The WAL change records come through to the standby while the standby query is still running, causing a conflict. The standby server must either delay application of the WAL records (and everything after them, too) or else cancel the conflicting query so that the &lt;code&gt;DROP TABLE&lt;/code&gt; can be applied.</source>
          <target state="translated">問題の状況の例は、現在スタンバイサーバーで照会されているテーブルで &lt;code&gt;DROP TABLE&lt;/code&gt; を実行しているプラ​​イマリサーバーの管理者です。 &lt;code&gt;DROP TABLE&lt;/code&gt; がスタンバイに適用されている場合、明らかにスタンバイクエリを続行できません。この状況がプライマリで発生した場合、 &lt;code&gt;DROP TABLE&lt;/code&gt; は他のクエリが完了するまで待機します。しかし、 &lt;code&gt;DROP TABLE&lt;/code&gt; はプライマリで実行されますが、プライマリにはスタンバイで実行されているクエリに関する情報がないため、そのようなスタンバイクエリを待機しません。スタンバイクエリの実行中にWAL変更レコードがスタンバイに到達し、競合が発生します。スタンバイサーバーは、WALレコード（およびその後のすべて）の適用を遅らせるか、 &lt;code&gt;DROP TABLE&lt;/code&gt; を適用できるように競合するクエリをキャンセルする必要があります。</target>
        </trans-unit>
        <trans-unit id="c0584ea6554a34671913f19351974da1f1774aa3" translate="yes" xml:space="preserve">
          <source>An example of what this means:</source>
          <target state="translated">これが何を意味するかの一例。</target>
        </trans-unit>
        <trans-unit id="24ac5f040ccbfd7714847e1bf2aa5f6494899ae9" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; could be undesirable is</source>
          <target state="translated">&lt;code&gt;NOT MATERIALIZED&lt;/code&gt; が望ましくない例は</target>
        </trans-unit>
        <trans-unit id="17447c2100c81f31ba62252077dc9a9361cd71f9" translate="yes" xml:space="preserve">
          <source>An example with one unspecified argument:</source>
          <target state="translated">不特定多数の引数を持つ例。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="79f0ca45e1236a1cb1c9feb4290eadf0487b4ef6" translate="yes" xml:space="preserve">
          <source>An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">例外として、シグナル(データベースサーバのシャットダウンの一部として使用されるSIGTERM以外のコマンド)やシェルによるエラー(コマンドが見つからないなど)によってコマンドが終了した場合、リカバリーが中止され、サーバは起動しません。</target>
        </trans-unit>
        <trans-unit id="fcd7932740e5471bcd0a087d5b26ec1edd628fbb" translate="yes" xml:space="preserve">
          <source>An explicit attribute name need not be specified if the attribute value is a column reference, in which case the column's name will be used as the attribute name by default. In other cases, the attribute must be given an explicit name. So this example is valid:</source>
          <target state="translated">属性値が列の参照である場合には、明示的な属性名を指定する必要はありません。それ以外の場合は、属性に明示的な名前を指定しなければなりません。したがって、この例は有効です。</target>
        </trans-unit>
        <trans-unit id="a0537d02ca5df21a5cff0228c3c1f8c6cfa4f59b" translate="yes" xml:space="preserve">
          <source>An explicit type cast can usually be omitted if there is no ambiguity as to the type that a value expression must produce (for example, when it is assigned to a table column); the system will automatically apply a type cast in such cases. However, automatic casting is only done for casts that are marked &amp;ldquo;OK to apply implicitly&amp;rdquo; in the system catalogs. Other casts must be invoked with explicit casting syntax. This restriction is intended to prevent surprising conversions from being applied silently.</source>
          <target state="translated">値式が生成する必要のある型についてあいまいさがなければ（たとえば、それがテーブル列に割り当てられる場合）、明示的な型キャストは通常​​省略できます。このような場合、システムは自動的に型キャストを適用します。ただし、自動キャストは、システムカタログで「暗黙的に適用してよい」とマークされているキャストに対してのみ実行されます。その他のキャストは、明示的なキャスト構文で呼び出す必要があります。この制限は、意外な変換がサイレントに適用されるのを防ぐためのものです。</target>
        </trans-unit>
        <trans-unit id="8eb162f28e2597cd06bef15cc6b421aa23ae9738" translate="yes" xml:space="preserve">
          <source>An expression based on one or more columns of the table. The expression usually must be written with surrounding parentheses, as shown in the syntax. However, the parentheses can be omitted if the expression has the form of a function call.</source>
          <target state="translated">テーブルの1つ以上の列に基づく式。式は通常、構文に示されているように、周囲の括弧で書かれなければなりません。しかし、式が関数呼び出しの形をしている場合は、括弧を省略することができます。</target>
        </trans-unit>
        <trans-unit id="dfb3ba678ed8043b837cdccde74a8dfa30c47a0d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">結果の行をソートする方法を示す式または整数定数。この式は、 &lt;code&gt;VALUES&lt;/code&gt; 結果の列を &lt;code&gt;column1&lt;/code&gt; 、 &lt;code&gt;column2&lt;/code&gt; などとして参照できます。詳細については、&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bf2a060cd8aff34f17e0e2630c016f3f2cecf035" translate="yes" xml:space="preserve">
          <source>An expression or value to assign to the corresponding column.</source>
          <target state="translated">対応する列に割り当てる式または値。</target>
        </trans-unit>
        <trans-unit id="346258a0cd22cd6472088d2210ee4c5f296cc7a7" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be deleted.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型の値を返す式。この式が &lt;code&gt;true&lt;/code&gt; を返す行のみが削除されます。</target>
        </trans-unit>
        <trans-unit id="3b5a1cfe641c92cec7cffaf0f485f58266a8e8c9" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated, although all rows will be locked when the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; action is taken. Note that &lt;code&gt;condition&lt;/code&gt; is evaluated last, after a conflict has been identified as a candidate to update.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型の値を返す式。 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; アクションが実行されると、すべての行がロックされますが、この式が &lt;code&gt;true&lt;/code&gt; を返す行のみが更新されます。更新の候補として競合が特定された後、 &lt;code&gt;condition&lt;/code&gt; が最後に評価されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="51d351d5b4985c09126cf102d05f81d64ae9d961" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型の値を返す式。この式が &lt;code&gt;true&lt;/code&gt; を返す行のみが更新されます。</target>
        </trans-unit>
        <trans-unit id="6469ea06c0d7a0f1185226a5a8416487a9a270db" translate="yes" xml:space="preserve">
          <source>An expression to assign to the column. The expression can use the old values of this and other columns in the table.</source>
          <target state="translated">カラムに代入する式。この式は、テーブル内のこのカラムと他のカラムの古い値を使用することができます。</target>
        </trans-unit>
        <trans-unit id="8157c1c94fdd707dcc3e7f541c66bda5c99059b6" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;DELETE&lt;/code&gt; command after each row is deleted. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;USING&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">各行が削除された後に &lt;code&gt;DELETE&lt;/code&gt; コマンドによって計算および返される式。式では、 &lt;code&gt;table_name&lt;/code&gt; または &lt;code&gt;USING&lt;/code&gt; にリストされているテーブルで指定されたテーブルの任意の列名を使用できます。 &lt;code&gt;*&lt;/code&gt; を書き込むと、すべての列が返されます。</target>
        </trans-unit>
        <trans-unit id="05948f44935d2d1795c3b150edf4c95d54d4a6f0" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;INSERT&lt;/code&gt; command after each row is inserted or updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns of the inserted or updated row(s).</source>
          <target state="translated">各行が挿入または更新された後に &lt;code&gt;INSERT&lt;/code&gt; コマンドによって計算および返される式。式では、 &lt;code&gt;table_name&lt;/code&gt; で指定されたテーブルの任意の列名を使用できます。挿入または更新された行のすべての列を返すには、 &lt;code&gt;*&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="711a38c8f40969b059c836aa598a46d28bd6408a" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;UPDATE&lt;/code&gt; command after each row is updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;FROM&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">各行が更新された後に &lt;code&gt;UPDATE&lt;/code&gt; コマンドによって計算および返される式。式では、 &lt;code&gt;table_name&lt;/code&gt; または &lt;code&gt;FROM&lt;/code&gt; にリストされているテーブルで指定されたテーブルの任意の列名を使用できます。 &lt;code&gt;*&lt;/code&gt; を書き込むと、すべての列が返されます。</target>
        </trans-unit>
        <trans-unit id="1a2196f96cc62fad9b61f7b17e09f3003661a8d1" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">パラメータが指定されていない場合にデフォルト値として使用される式。この式は、パラメータの引数タイプに対応していなければなりません。デフォルト値を持つパラメータに続くすべての入力パラメータは、同様にデフォルト値を持たなければなりません。</target>
        </trans-unit>
        <trans-unit id="33129ed19c1151cbd1e641d74c28498304306825" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. Only input (including &lt;code&gt;INOUT&lt;/code&gt;) parameters can have a default value. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">パラメータが指定されていない場合にデフォルト値として使用される式。式は、パラメーターの引数の型に強制変換できる必要があります。入力（ &lt;code&gt;INOUT&lt;/code&gt; を含む）パラメータのみがデフォルト値を持つことができます。デフォルト値を持つパラメーターに続くすべての入力パラメーターには、デフォルト値も必要です。</target>
        </trans-unit>
        <trans-unit id="e3cc897e9290dc3056730f190eeba85a57f89dca" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="translated">外部プログラムは &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; 関数（&lt;a href=&quot;functions-admin&quot;&gt;セクション9.26を&lt;/a&gt;参照）を呼び出して、WALの現在の終わりのファイル名とその中の正確なバイトオフセットを見つけることができます。その後、WALファイルに直接アクセスし、WALの最後の既知の端から現在の端を経由してスタンバイサーバーにデータをコピーできます。このアプローチでは、データ損失のウィンドウはコピープログラムのポーリングサイクルタイムであり、非常に小さくなり、部分的に使用されているセグメントファイルを強制的にアーカイブすることによる帯域幅の浪費がありません。スタンバイサーバーの &lt;code&gt;restore_command&lt;/code&gt; スクリプトはWALファイル全体のみを処理できるため、通常、増分コピーされたデータはスタンバイサーバーで利用できません。これは、プライマリが停止したときにのみ使用されます。最後の部分的なWALファイルは、起動する前にスタンバイに送られます。このプロセスを正しく実装するには、 &lt;code&gt;restore_command&lt;/code&gt; スクリプトとデータコピープログラムの連携が必要です。</target>
        </trans-unit>
        <trans-unit id="94b6e6917365cf5b071c6d2030b18320b138edde" translate="yes" xml:space="preserve">
          <source>An immediate-mode shutdown is equivalent to a server crash, and will therefore cause loss of any unflushed asynchronous commits.</source>
          <target state="translated">即時モードでのシャットダウンはサーバのクラッシュと同等であり、そのため、アンフラッシュされていない非同期コミットはすべて失われます。</target>
        </trans-unit>
        <trans-unit id="40eea77fc7125e69a1e10d852d75c5913c0b8a4f" translate="yes" xml:space="preserve">
          <source>An important advantage of pg_dump over the other backup methods described later is that pg_dump's output can generally be re-loaded into newer versions of PostgreSQL, whereas file-level backups and continuous archiving are both extremely server-version-specific. pg_dump is also the only method that will work when transferring a database to a different machine architecture, such as going from a 32-bit to a 64-bit server.</source>
          <target state="translated">pg_dumpが後述する他のバックアップ方法と比較して重要な利点は、pg_dumpの出力が一般的にPostgreSQLの新しいバージョンに再ロードできることです。</target>
        </trans-unit>
        <trans-unit id="779e5fbc91351efe2bbe3fc71a519dfce1b2cb29" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="translated">ストリーミングレプリケーションの重要なヘルスインジケータは、プライマリで生成されたが、スタンバイではまだ適用されていないWALレコードの量です。プライマリ上の現在のWAL書き込み場所を、スタンバイによって受信された最後のWAL場所と比較することにより、この遅延を計算できます。これらの場所は、それぞれプライマリの &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; とスタンバイの &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; を使用して取得できます（詳細については、&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.84&lt;/a&gt;および&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85&lt;/a&gt;を参照してください）。スタンバイの最後のWAL受信場所は、 &lt;code&gt;ps&lt;/code&gt; コマンドを使用して表示されるWALレシーバープロセスのプロセスステータスにも表示されます（詳細については、&lt;a href=&quot;monitoring-ps&quot;&gt;セクション27.1&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="8738ccf906ae7704aa616ed666eef87dd66384c2" translate="yes" xml:space="preserve">
          <source>An important restriction, however, is that each database's character set must be compatible with the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; (character classification) and &lt;code&gt;LC_COLLATE&lt;/code&gt; (string sort order) locale settings. For &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; locale, any character set is allowed, but for other libc-provided locales there is only one character set that will work correctly. (On Windows, however, UTF-8 encoding can be used with any locale.) If you have ICU support configured, ICU-provided locales can be used with most but not all server-side encodings.</source>
          <target state="translated">ただし、重要な制限は、各データベースの文字セットがデータベースの &lt;code&gt;LC_CTYPE&lt;/code&gt; （文字分類）および &lt;code&gt;LC_COLLATE&lt;/code&gt; （文字列のソート順）ロケール設定と互換性がある必要があることです。以下のために &lt;code&gt;C&lt;/code&gt; または &lt;code&gt;POSIX&lt;/code&gt; ロケール、任意の文字セットが許可されていますが、他のlibcが提供するロケールで正常に動作する唯一の文字セットがあります。 （ただし、Windowsでは、UTF-8エンコーディングを任意のロケールで使用できます。）ICUサポートが構成されている場合、ICU提供のロケールは、すべてではないがほとんどのサーバー側エンコーディングで使用できます。</target>
        </trans-unit>
        <trans-unit id="0f5ae435c6587408d50bbebe9d66abc0ceb67394" translate="yes" xml:space="preserve">
          <source>An index access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;index_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a palloc'd struct of type &lt;code&gt;IndexAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the index access method. The &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, includes fields specifying assorted fixed properties of the access method, such as whether it can support multicolumn indexes. More importantly, it contains pointers to support functions for the access method, which do all of the real work to access indexes. These support functions are plain C functions and are not visible or callable at the SQL level. The support functions are described in &lt;a href=&quot;index-functions&quot;&gt;Section 61.2&lt;/a&gt;.</source>
          <target state="translated">インデックスアクセスメソッドハンドラー関数は、 &lt;code&gt;internal&lt;/code&gt; タイプの単一の引数を受け入れ、疑似タイプ &lt;code&gt;index_am_handler&lt;/code&gt; を返すように宣言する必要があります。引数は、ハンドラー関数がSQLコマンドから直接呼び出されないようにするためのダミー値です。関数の結果は、タイプのpallocさ、構造体でなければなりません &lt;code&gt;IndexAmRoutine&lt;/code&gt; コアコードのニーズはインデックスアクセスメソッドを利用するために知っていることすべてが含まれ、。 &lt;code&gt;IndexAmRoutine&lt;/code&gt; の構造体、また、アクセス方法のと呼ばれる&lt;em&gt;APIの構造体&lt;/em&gt;には、複数列のインデックスをサポートできるかどうかなど、アクセス方法のさまざまな固定プロパティを指定するフィールドが含まれています。さらに重要なことには、インデックスにアクセスするための実際の作業をすべて実行する、アクセスメソッドのサポート関数へのポインターが含まれています。これらのサポート関数はプレーンなC関数であり、SQLレベルでは表示または呼び出しできません。サポート関数については、&lt;a href=&quot;index-functions&quot;&gt;セクション61.2で&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="bb532d7978fa5df32b453f561220dfbe06086e40" translate="yes" xml:space="preserve">
          <source>An index access method handler is declared to return &lt;code&gt;index_am_handler&lt;/code&gt;.</source>
          <target state="translated">インデックスアクセスメソッドハンドラーは、 &lt;code&gt;index_am_handler&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="7b07d3910aeda52b29f538101381247d79d370d4" translate="yes" xml:space="preserve">
          <source>An index can be defined on more than one column of a table. For example, if you have a table of this form:</source>
          <target state="translated">インデックスは、テーブルの複数の列に定義することができます。例えば、このような形式のテーブルがあるとします。</target>
        </trans-unit>
        <trans-unit id="c6cedebd8f5962a85979ac8b01f76ed8117fa855" translate="yes" xml:space="preserve">
          <source>An index can support only one collation per index column. If multiple collations are of interest, multiple indexes may be needed.</source>
          <target state="translated">1つのインデックスは、インデックス列ごとに1つの照合順序しかサポートできません。複数の照合が注目される場合は、複数のインデックスが必要になることがあります。</target>
        </trans-unit>
        <trans-unit id="af32b6cb0c87ebb15770ca088fe87a22f82c7725" translate="yes" xml:space="preserve">
          <source>An index column need not be just a column of the underlying table, but can be a function or scalar expression computed from one or more columns of the table. This feature is useful to obtain fast access to tables based on the results of computations.</source>
          <target state="translated">インデックス列は、基になるテーブルの列だけである必要はなく、テーブルの1つ以上の列から計算された関数やスカラー式であっても構いません。この機能は、計算結果に基づいてテーブルへの高速なアクセスを得るのに便利です。</target>
        </trans-unit>
        <trans-unit id="38f15f32a54b60a4d97bf16f8c60ceef26c5914e" translate="yes" xml:space="preserve">
          <source>An index definition can specify an &lt;em&gt;operator class&lt;/em&gt; for each column of an index.</source>
          <target state="translated">インデックス定義では、インデックスの列ごとに&lt;em&gt;演算子クラス&lt;/em&gt;を指定できます。</target>
        </trans-unit>
        <trans-unit id="0ef2323f17ff30aac9494d8039a3c3612271c42a" translate="yes" xml:space="preserve">
          <source>An index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed on &lt;code&gt;upper(col)&lt;/code&gt; would allow the clause &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; to use an index.</source>
          <target state="translated">インデックスフィールドは、テーブル行の1つ以上の列の値から計算された式にすることができます。この機能を使用すると、基本データの変換に基づいてデータに高速にアクセスできます。たとえば、 &lt;code&gt;upper(col)&lt;/code&gt; で計算されたインデックスでは、 &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; 句でインデックスを使用できます。</target>
        </trans-unit>
        <trans-unit id="3aeae44b3c790fd037b93e2535adf3aedad79c0a" translate="yes" xml:space="preserve">
          <source>An index has become &amp;ldquo;bloated&amp;rdquo;, that is it contains many empty or nearly-empty pages. This can occur with B-tree indexes in PostgreSQL under certain uncommon access patterns. &lt;code&gt;REINDEX&lt;/code&gt; provides a way to reduce the space consumption of the index by writing a new version of the index without the dead pages. See &lt;a href=&quot;routine-reindex&quot;&gt;Section 24.2&lt;/a&gt; for more information.</source>
          <target state="translated">インデックスは「肥大化」し、つまり、空のページまたは空に近いページが多数含まれています。これは、特定の一般的でないアクセスパターンの下で、PostgreSQLのBツリーインデックスで発生する可能性があります。 &lt;code&gt;REINDEX&lt;/code&gt; は、デッドページのない新しいバージョンのインデックスを書き込むことにより、インデックスのスペース消費を削減する方法を提供します。詳細は&lt;a href=&quot;routine-reindex&quot;&gt;項24.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="121b8423d6baa50b53be4c3d49a8a3b7e064ae7d" translate="yes" xml:space="preserve">
          <source>An index has become corrupted, and no longer contains valid data. Although in theory this should never happen, in practice indexes can become corrupted due to software bugs or hardware failures. &lt;code&gt;REINDEX&lt;/code&gt; provides a recovery method.</source>
          <target state="translated">インデックスが破損し、有効なデータが含まれていません。理論的にはこれが発生することはありませんが、実際には、ソフトウェアのバグやハードウェアの障害によりインデックスが破損する可能性があります。 &lt;code&gt;REINDEX&lt;/code&gt; は回復方法を提供します。</target>
        </trans-unit>
        <trans-unit id="fd114c1d6538ba92c251db5881779687c2ba09a7" translate="yes" xml:space="preserve">
          <source>An index scan must maintain a pin on the index page holding the item last returned by &lt;code&gt;amgettuple&lt;/code&gt;, and &lt;code&gt;ambulkdelete&lt;/code&gt; cannot delete entries from pages that are pinned by other backends. The need for this rule is explained below.</source>
          <target state="translated">インデックス・スキャンは、最後から返されたアイテム保持インデックスページ上のピンを維持しなければならない &lt;code&gt;amgettuple&lt;/code&gt; 、と &lt;code&gt;ambulkdelete&lt;/code&gt; 他のバックエンドで固定されているページから缶削除しないエントリー。このルールの必要性については、以下で説明します。</target>
        </trans-unit>
        <trans-unit id="091f10c301d94d87ecd9a27b3366c6d6b064df7e" translate="yes" xml:space="preserve">
          <source>An index stored in ascending order with nulls first can satisfy either &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; or &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; depending on which direction it is scanned in.</source>
          <target state="translated">最初にnullを使用して昇順で格納されたインデックスは、スキャンされる方向に応じて、 &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; または &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; のいずれかを満たすことができます。</target>
        </trans-unit>
        <trans-unit id="4b9a05a65dbb6edc07d784a35f9d93afabbd7c69" translate="yes" xml:space="preserve">
          <source>An individual index is defined by a &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt; entry that describes it as a physical relation, plus a &lt;a href=&quot;catalog-pg-index&quot;&gt;&lt;code&gt;pg_index&lt;/code&gt;&lt;/a&gt; entry that shows the logical content of the index &amp;mdash; that is, the set of index columns it has and the semantics of those columns, as captured by the associated operator classes. The index columns (key values) can be either simple columns of the underlying table or expressions over the table rows. The index access method normally has no interest in where the index key values come from (it is always handed precomputed key values) but it will be very interested in the operator class information in &lt;code&gt;pg_index&lt;/code&gt;. Both of these catalog entries can be accessed as part of the &lt;code&gt;Relation&lt;/code&gt; data structure that is passed to all operations on the index.</source>
          <target state="translated">個々のインデックスは、それを物理的な関係として説明する&lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt;エントリと、インデックスの論理的な内容を示す&lt;a href=&quot;catalog-pg-index&quot;&gt; &lt;code&gt;pg_index&lt;/code&gt; &lt;/a&gt;エントリによって定義されます。つまり、インデックスの列のセットと、関連する演算子クラス。インデックス列（キー値）は、基になるテーブルの単純な列またはテーブル行の式のいずれかです。インデックスアクセスメソッドは通常、インデックスキー値がどこから来るか（常に事前計算されたキー値が渡されます）には関係ありませんが、 &lt;code&gt;pg_index&lt;/code&gt; の演算子クラス情報に非常に興味があります。これらのカタログエントリはどちらも、 &lt;code&gt;Relation&lt;/code&gt; 一部としてアクセスできます。 インデックスのすべての操作に渡されるデータ構造。</target>
        </trans-unit>
        <trans-unit id="c51c50438ea0481d3519a43885b20aa32e128cb3" translate="yes" xml:space="preserve">
          <source>An input argument for the procedure call. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for the full details on function and procedure call syntax, including use of named parameters.</source>
          <target state="translated">プロシージャコールの入力引数。参照&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;セクション4.3を&lt;/a&gt;名前付きパラメータの使用を含む関数とプロシージャの呼び出し構文、上の完全な詳細については。</target>
        </trans-unit>
        <trans-unit id="73ddb8fe436cada6d2cfbe35b934979d06f7b361" translate="yes" xml:space="preserve">
          <source>An input data type on which the aggregate function operates. To reference a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. To reference an ordered-set aggregate function, write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications.</source>
          <target state="translated">集計関数が動作する入力データ型。引数なしの集約関数を参照するには、引数指定のリストの代わりに &lt;code&gt;*&lt;/code&gt; を記述します。順序付き集合関数を参照するには、直接引数と集約引数の指定の間に &lt;code&gt;ORDER BY&lt;/code&gt; を記述します。</target>
        </trans-unit>
        <trans-unit id="8a9fa698ac8ae654cf211647b74f7c8723ee0347" translate="yes" xml:space="preserve">
          <source>An input data type on which this aggregate function operates. To create a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. (An example of such an aggregate is &lt;code&gt;count(*)&lt;/code&gt;.)</source>
          <target state="translated">この集約関数が動作する入力データ型。引数なしの集約関数を作成するには、引数指定のリストの代わりに &lt;code&gt;*&lt;/code&gt; を記述します。（そのような集計の例は &lt;code&gt;count(*)&lt;/code&gt; です。）</target>
        </trans-unit>
        <trans-unit id="2c437a292efa6b573c836047b51a1cf9f32df694" translate="yes" xml:space="preserve">
          <source>An introduction to the btree index implementation can be found in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt;.</source>
          <target state="translated">btreeインデックス実装の &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; はsrc / backend / access / nbtree / READMEにあります。</target>
        </trans-unit>
        <trans-unit id="43d220b2360555baed12a7c95e72685b6f39b9dd" translate="yes" xml:space="preserve">
          <source>An n-dimensional cube represented by a pair of its diagonally opposite corners</source>
          <target state="translated">対角線上の対角線の対で表されるn次元立方体</target>
        </trans-unit>
        <trans-unit id="49b0e219e8853ca29533ecae37f9efd990522911" translate="yes" xml:space="preserve">
          <source>An object can be assigned to a new owner with an &lt;code&gt;ALTER&lt;/code&gt; command of the appropriate kind for the object, for example</source>
          <target state="translated">たとえば、オブジェクトに適切な種類の &lt;code&gt;ALTER&lt;/code&gt; コマンドを使用して、オブジェクトを新しい所有者に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="cd7347c4e72d5111690a2e6b553a4bb95eecefbe" translate="yes" xml:space="preserve">
          <source>An obsolete type name that formerly served many of the above purposes.</source>
          <target state="translated">以前は上記の目的の多くを果たしていた旧式のタイプ名。</target>
        </trans-unit>
        <trans-unit id="e67e0cc488404bddd9185d257d8376a78bb5f89d" translate="yes" xml:space="preserve">
          <source>An older syntax based on &quot;:=&quot; is supported for backward compatibility:</source>
          <target state="translated">下位互換性のために、「:=」に基づく古い構文がサポートされています。</target>
        </trans-unit>
        <trans-unit id="a2ec14d06c6e5e0d12a30237502776f169012b3d" translate="yes" xml:space="preserve">
          <source>An open cursor's name.</source>
          <target state="translated">開いているカーソルの名前。</target>
        </trans-unit>
        <trans-unit id="56d15480825e451d724a77515f8cbd596240aa64" translate="yes" xml:space="preserve">
          <source>An operator class for bloom indexes requires only a hash function for the indexed data type and an equality operator for searching. This example shows the operator class definition for the &lt;code&gt;text&lt;/code&gt; data type:</source>
          <target state="translated">ブルームインデックスの演算子クラスには、インデックス付きデータ型のハッシュ関数と検索用の等号演算子のみが必要です。この例は、 &lt;code&gt;text&lt;/code&gt; データタイプの演算子クラス定義を示しています。</target>
        </trans-unit>
        <trans-unit id="6eb7653b3723c58c344a731c25071cc3711f5e86" translate="yes" xml:space="preserve">
          <source>An operator class is actually just a subset of a larger structure called an &lt;em&gt;operator family&lt;/em&gt;. In cases where several data types have similar behaviors, it is frequently useful to define cross-data-type operators and allow these to work with indexes. To do this, the operator classes for each of the types must be grouped into the same operator family. The cross-type operators are members of the family, but are not associated with any single class within the family.</source>
          <target state="translated">演算子クラスは、実際には、&lt;em&gt;演算子族&lt;/em&gt;と呼ばれるより大きな構造のサブセットにすぎません。複数のデータ型が同様の動作をする場合、データ型間演算子を定義し、これらをインデックスで使用できるようにすることがしばしば役立ちます。これを行うには、各タイプの演算子クラスを同じ演算子ファミリーにグループ化する必要があります。クロスタイプ演算子はファミリーのメンバーですが、ファミリー内のどの単一クラスにも関連付けられていません。</target>
        </trans-unit>
        <trans-unit id="f7d235f30c792ff196a94c50c4549a98a2d7a764" translate="yes" xml:space="preserve">
          <source>An operator class must also provide a function to check if an indexed item matches the query. It comes in two flavors, a Boolean &lt;code&gt;consistent&lt;/code&gt; function, and a ternary &lt;code&gt;triConsistent&lt;/code&gt; function. &lt;code&gt;triConsistent&lt;/code&gt; covers the functionality of both, so providing &lt;code&gt;triConsistent&lt;/code&gt; alone is sufficient. However, if the Boolean variant is significantly cheaper to calculate, it can be advantageous to provide both. If only the Boolean variant is provided, some optimizations that depend on refuting index items before fetching all the keys are disabled.</source>
          <target state="translated">演算子クラスは、インデックス付きアイテムがクエリと一致するかどうかをチェックする関数も提供する必要があります。これには、ブール &lt;code&gt;consistent&lt;/code&gt; 関数と3項 &lt;code&gt;triConsistent&lt;/code&gt; 関数の2つのフレーバーがあります。 &lt;code&gt;triConsistent&lt;/code&gt; は両方の機能をカバーするので、 &lt;code&gt;triConsistent&lt;/code&gt; を提供するだけで十分です。ただし、ブールバリアントの計算の方が大幅にコストが低い場合は、両方を提供する方が有利です。ブールバリアントのみが提供されている場合、すべてのキーをフェッチする前にインデックス項目を変更することに依存する一部の最適化は無効になります。</target>
        </trans-unit>
        <trans-unit id="6e523c5f9d2c574da0fb6483337cb467c258e68f" translate="yes" xml:space="preserve">
          <source>An operator class's &lt;code&gt;opcmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family. Also, there must be no more than one &lt;code&gt;pg_opclass&lt;/code&gt; row having &lt;code&gt;opcdefault&lt;/code&gt; true for any given combination of &lt;code&gt;opcmethod&lt;/code&gt; and &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">演算子クラスの &lt;code&gt;opcmethod&lt;/code&gt; は、それを含む演算子ファミリの &lt;code&gt;opfmethod&lt;/code&gt; と一致する必要があります。また、 &lt;code&gt;opcmethod&lt;/code&gt; と &lt;code&gt;opcintype&lt;/code&gt; の任意の組み合わせに対して、 &lt;code&gt;opcdefault&lt;/code&gt; が trueである &lt;code&gt;pg_opclass&lt;/code&gt; 行は1つだけでなければなりません。</target>
        </trans-unit>
        <trans-unit id="0a6550b54250a9ead01f2b3553646b2303a4a1ed" translate="yes" xml:space="preserve">
          <source>An operator invocation</source>
          <target state="translated">演算子呼び出し</target>
        </trans-unit>
        <trans-unit id="61b072351eb6c6fa27b9ae84a318cc236116df90" translate="yes" xml:space="preserve">
          <source>An operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">オペレーター名は、以下のリストの &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1（デフォルトでは63）文字までのシーケンスです。</target>
        </trans-unit>
        <trans-unit id="d3a80b67bf09fd16cb2674622b6e5dcf9a0716b6" translate="yes" xml:space="preserve">
          <source>An operator used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot would show the &lt;code&gt;&amp;lt;&lt;/code&gt; operator that defines the sort order of the data.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 番目の「スロット」に格納されている統計を導出するために使用される演算子。たとえば、ヒストグラムスロットには、データの並べ替え順序を定義する &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子が表示されます。</target>
        </trans-unit>
        <trans-unit id="36745dfcd4a31015998a201702d690d18fcba0c2" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;+&lt;/code&gt; produces more details.</source>
          <target state="translated">オプションの &lt;code&gt;+&lt;/code&gt; は、詳細を生成します。</target>
        </trans-unit>
        <trans-unit id="15280e346b927d3a2d54ca3d61b3ae948a862eb2" translate="yes" xml:space="preserve">
          <source>An optional collation for the domain. If no collation is specified, the underlying data type's default collation is used. The underlying type must be collatable if &lt;code&gt;COLLATE&lt;/code&gt; is specified.</source>
          <target state="translated">ドメインのオプションの照合。照合順序が指定されていない場合、基になるデータ型のデフォルトの照合順序が使用されます。 &lt;code&gt;COLLATE&lt;/code&gt; が指定されている場合、基になるタイプは照合可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="60e65907bee0f7f6070fd34b3f416cb8bb6f6e36" translate="yes" xml:space="preserve">
          <source>An optional comma-separated list of arguments to be provided to the function when the trigger is executed. The arguments are literal string constants. Simple names and numeric constants can be written here, too, but they will all be converted to strings. Please check the description of the implementation language of the trigger function to find out how these arguments can be accessed within the function; it might be different from normal function arguments.</source>
          <target state="translated">トリガが実行されたときに関数に提供される引数のオプションのカンマ区切りリスト。引数はリテラル文字列定数です。単純な名前や数値定数もここに書くことができますが、すべて文字列に変換されます。これらの引数が関数内でどのようにアクセスできるかについては、トリガー関数の実装言語の記述を確認してください;通常の関数の引数とは異なるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c4ca636c20fca55bda068decba0ca12e4c60f9d3" translate="yes" xml:space="preserve">
          <source>An optional list of columns to be copied. If no column list is specified, all columns of the table except generated columns will be copied.</source>
          <target state="translated">コピーする列のオプションのリスト。カラムリストが指定されていない場合は、生成されたカラムを除くテーブルのすべてのカラムがコピーされます。</target>
        </trans-unit>
        <trans-unit id="f37b6dea6bba7854fbb2a25222ccbd3742c1fd86" translate="yes" xml:space="preserve">
          <source>An optional list of names to be used for columns of the view. If not given, the column names are deduced from the query.</source>
          <target state="translated">ビューのカラムに使用する名前のオプションのリスト。指定しない場合、カラム名はクエリから推測されます。</target>
        </trans-unit>
        <trans-unit id="a1745e8f3d8a818bb59434a30224b4bc70bd52ef" translate="yes" xml:space="preserve">
          <source>An optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names like &lt;code&gt;col must be positive&lt;/code&gt; can be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.</source>
          <target state="translated">列またはテーブル制約のオプションの名前。制約に違反すると、制約名がエラーメッセージに表示されるため、 &lt;code&gt;col must be positive&lt;/code&gt; などの正の制約名を使用して、クライアントアプリケーションに役立つ制約情報を伝えることができます。（スペースを含む制約名を指定するには、二重引用符が必要です。）制約名が指定されていない場合、システムが名前を生成します。</target>
        </trans-unit>
        <trans-unit id="f3ae3fadcc76fcc5b9297de7bc96718990dc996d" translate="yes" xml:space="preserve">
          <source>An optional name for a constraint. If not specified, the system generates a name.</source>
          <target state="translated">制約のオプションの名前。指定しない場合は、システムが名前を生成します。</target>
        </trans-unit>
        <trans-unit id="bd6568613ce7c67d34419866e38138da4ce733d2" translate="yes" xml:space="preserve">
          <source>An output column's name can be used to refer to the column's value in &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;GROUP BY&lt;/code&gt; clauses, but not in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;HAVING&lt;/code&gt; clauses; there you must write out the expression instead.</source>
          <target state="translated">出力列の名前を使用して、 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 句とGROUP BY句の列の値を参照できますが、 &lt;code&gt;WHERE&lt;/code&gt; 句や &lt;code&gt;HAVING&lt;/code&gt; 句では使用できません。そこで、代わりに式を書き出す必要があります。</target>
        </trans-unit>
        <trans-unit id="b29ad290e8bd770fdebcb84bad7370f20ace4e23" translate="yes" xml:space="preserve">
          <source>Analogous statements with inverted conditions hold when &lt;code&gt;less&lt;/code&gt; = false.</source>
          <target state="translated">条件が反転した類似のステートメントは、 &lt;code&gt;less&lt;/code&gt; = falseの場合に成立します。</target>
        </trans-unit>
        <trans-unit id="602ef0777e13fcee9897969f97ef1e867cdf140e" translate="yes" xml:space="preserve">
          <source>Analogous to &lt;code&gt;ON DELETE&lt;/code&gt; there is also &lt;code&gt;ON UPDATE&lt;/code&gt; which is invoked when a referenced column is changed (updated). The possible actions are the same. In this case, &lt;code&gt;CASCADE&lt;/code&gt; means that the updated values of the referenced column(s) should be copied into the referencing row(s).</source>
          <target state="translated">類似 &lt;code&gt;ON DELETE&lt;/code&gt; もある &lt;code&gt;ON UPDATE&lt;/code&gt; 参照列が変更されたときに呼び出される（更新）。可能なアクションは同じです。この場合、 &lt;code&gt;CASCADE&lt;/code&gt; は、参照される列の更新された値を参照する行にコピーする必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="5c83db21cadbb2756e96e53b9c14b7e7a2b514a6" translate="yes" xml:space="preserve">
          <source>Ancient distributions might not have the &lt;code&gt;sysctl&lt;/code&gt; program, but equivalent changes can be made by manipulating the &lt;code&gt;/proc&lt;/code&gt; file system:</source>
          <target state="translated">古代のディストリビューションには &lt;code&gt;sysctl&lt;/code&gt; プログラムがないかもしれませんが、 &lt;code&gt;/proc&lt;/code&gt; ファイルシステムを操作することで同等の変更を行うことができます。</target>
        </trans-unit>
        <trans-unit id="0d93beb44d205136520d673b54b56936f6980aa2" translate="yes" xml:space="preserve">
          <source>And finally create the transform to connect them all together:</source>
          <target state="translated">そして最終的にはそれらを全て繋げるトランスフォームを作成します。</target>
        </trans-unit>
        <trans-unit id="43c2b85844ed32a3fb79c6e1b9f3ea8d1ebdd551" translate="yes" xml:space="preserve">
          <source>And finally, most disk drives have caches. Some are write-through while some are write-back, and the same concerns about data loss exist for write-back drive caches as for disk controller caches. Consumer-grade IDE and SATA drives are particularly likely to have write-back caches that will not survive a power failure. Many solid-state drives (SSD) also have volatile write-back caches.</source>
          <target state="translated">最後に、ほとんどのディスクドライブにはキャッシュがあります。ライトスルー型もあれば、ライトバック型もあり、ディスクコントローラのキャッシュと同様に、ライトバック型ドライブのキャッシュにもデータ損失に関する懸念が存在します。コンシューマグレードの IDE および SATA ドライブは、特に電源障害に耐えられないライトバックキャッシュを持つ可能性が高いです。多くのソリッドステートドライブ (SSD)にも、揮発性のライトバックキャッシュがあります。</target>
        </trans-unit>
        <trans-unit id="f5abe4b1cbcb838f669f793ea91def6b18bb7e30" translate="yes" xml:space="preserve">
          <source>And on the subscriber database:</source>
          <target state="translated">加入者データベースにも</target>
        </trans-unit>
        <trans-unit id="e24853104ecb700e47b83196c8cd650b56525c5b" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;.dict&lt;/code&gt; file has the following structure:</source>
          <target state="translated">また、 &lt;code&gt;.dict&lt;/code&gt; ファイルの構造は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="588ca16f318d70344d76b4537a5c7291a5cee916" translate="yes" xml:space="preserve">
          <source>And the matching code in the C module could then follow this skeleton:</source>
          <target state="translated">そして、Cモジュール内のマッチするコードは、このスケルトンに従うことができます。</target>
        </trans-unit>
        <trans-unit id="680044bb057f2caf79b08b39f3f6077a48b66315" translate="yes" xml:space="preserve">
          <source>And to get 2-D cubes ordered by the first coordinate of the upper right corner descending:</source>
          <target state="translated">そして、右上の角が下降する最初の座標から順に2次元立方体を取得する。</target>
        </trans-unit>
        <trans-unit id="6871b449d2c079d96e59fe6f124b014ba15535f8" translate="yes" xml:space="preserve">
          <source>And we can specify subfields as targets for &lt;code&gt;INSERT&lt;/code&gt;, too:</source>
          <target state="translated">また、サブフィールドを &lt;code&gt;INSERT&lt;/code&gt; のターゲットとして指定することもできます。</target>
        </trans-unit>
        <trans-unit id="a145997c5dd507c46627dcb8aa745e601bfd3eab" translate="yes" xml:space="preserve">
          <source>And, if the function is called with an argument of type &lt;code&gt;integer&lt;/code&gt;, the parser will try to convert that to &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">そして、関数が &lt;code&gt;integer&lt;/code&gt; 型の引数で呼び出された場合、パーサーはそれを &lt;code&gt;text&lt;/code&gt; に変換しようとします：</target>
        </trans-unit>
        <trans-unit id="20ab5b725ed73e7635d9823c37915d8903343a0f" translate="yes" xml:space="preserve">
          <source>Another alternative worth considering is to use &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers (see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;) in place of rules.</source>
          <target state="translated">検討する価値のある別の代替手段は、ルールの代わりに &lt;code&gt;INSTEAD OF&lt;/code&gt; トリガー（&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGERを&lt;/a&gt;参照）を使用することです。</target>
        </trans-unit>
        <trans-unit id="e823a73742793d80b913d4d208ddb3ca9056df81" translate="yes" xml:space="preserve">
          <source>Another approach is to create a separate &lt;code&gt;tsvector&lt;/code&gt; column to hold the output of &lt;code&gt;to_tsvector&lt;/code&gt;. To keep this column automatically up to date with its source data, use a stored generated column. This example is a concatenation of &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;, using &lt;code&gt;coalesce&lt;/code&gt; to ensure that one field will still be indexed when the other is &lt;code&gt;NULL&lt;/code&gt;:</source>
          <target state="translated">別のアプローチは、別の &lt;code&gt;tsvector&lt;/code&gt; 列を作成して、to_tsvectorの出力を保持すること &lt;code&gt;to_tsvector&lt;/code&gt; 。この列をソースデータで自動的に最新に保つには、保存された生成列を使用します。次の例は、 &lt;code&gt;title&lt;/code&gt; と &lt;code&gt;body&lt;/code&gt; を連結したものです &lt;code&gt;coalesce&lt;/code&gt; を使用して、他のフィールドが &lt;code&gt;NULL&lt;/code&gt; の場合でも1つのフィールドが引き続きインデックス付けされるようにします。</target>
        </trans-unit>
        <trans-unit id="c88aeeb193209d03f36ea4052749971eef461a5a" translate="yes" xml:space="preserve">
          <source>Another approach to querying is to exploit containment, for example:</source>
          <target state="translated">クエリへの別のアプローチとしては、例えば、封じ込めを利用することがあります。</target>
        </trans-unit>
        <trans-unit id="0f6657768acd9084b11e644584f044a4fc45d8af" translate="yes" xml:space="preserve">
          <source>Another approach, which can be used with or without altering &lt;code&gt;vm.overcommit_memory&lt;/code&gt;, is to set the process-specific &lt;em&gt;OOM score adjustment&lt;/em&gt; value for the postmaster process to &lt;code&gt;-1000&lt;/code&gt;, thereby guaranteeing it will not be targeted by the OOM killer. The simplest way to do this is to execute</source>
          <target state="translated">&lt;code&gt;vm.overcommit_memory&lt;/code&gt; を変更してもしなくても使用できる別のアプローチは、postmasterプロセスのプロセス固有の&lt;em&gt;OOMスコア調整&lt;/em&gt;値を &lt;code&gt;-1000&lt;/code&gt; に設定することです。これにより、OOMキラーのターゲットにならないことが保証されます。これを行う最も簡単な方法は、実行することです</target>
        </trans-unit>
        <trans-unit id="0157777d67f21431cd43979bf17bb15a2c6fa069" translate="yes" xml:space="preserve">
          <source>Another caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails. Also, if a failure does occur in the second scan, the &amp;ldquo;invalid&amp;rdquo; index continues to enforce its uniqueness constraint afterwards.</source>
          <target state="translated">一意のインデックスを同時に作成する際のもう1つの注意点は、2番目のテーブルスキャンの開始時に、一意性制約が他のトランザクションに対して既に適用されていることです。つまり、インデックスが使用可能になる前に、またはインデックスの作成が最終的に失敗した場合でも、他のクエリで制約違反が報告される可能性があります。また、2回目のスキャンで障害が発生した場合、「無効な」インデックスはその後も一意性制約を適用し続けます。</target>
        </trans-unit>
        <trans-unit id="8366e5720bf81785c8af920367ca1956fa9f6126" translate="yes" xml:space="preserve">
          <source>Another common reason for copying &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt; is that new encoding and locale settings can be specified when copying &lt;code&gt;template0&lt;/code&gt;, whereas a copy of &lt;code&gt;template1&lt;/code&gt; must use the same settings it does. This is because &lt;code&gt;template1&lt;/code&gt; might contain encoding-specific or locale-specific data, while &lt;code&gt;template0&lt;/code&gt; is known not to.</source>
          <target state="translated">コピーするためのもう一つの一般的な理由 &lt;code&gt;template0&lt;/code&gt; の代わり &lt;code&gt;template1&lt;/code&gt; コピーするときに新しいエンコーディングとロケール設定を指定することができるということである &lt;code&gt;template0&lt;/code&gt; コピーに対し、 &lt;code&gt;template1&lt;/code&gt; をはそれがないと同じ設定を使用する必要があります。これは、 &lt;code&gt;template1&lt;/code&gt; が認識されていないのに、 &lt;code&gt;template0&lt;/code&gt; がエンコード固有またはロケール固有のデータを含む可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="fbb209aa36c1a4990c8b7ddd6d829419598146fa" translate="yes" xml:space="preserve">
          <source>Another consideration is that a &lt;code&gt;setval&lt;/code&gt; executed on such a sequence will not be noticed by other sessions until they have used up any preallocated values they have cached.</source>
          <target state="translated">別の考慮事項は、そのようなシーケンスで実行された &lt;code&gt;setval&lt;/code&gt; は、キャッシュされている事前割り当てされた値を使い切るまで、他のセッションによって通知されないことです。</target>
        </trans-unit>
        <trans-unit id="3dd197e47ceae278b1382e01aa4231fc834370d4" translate="yes" xml:space="preserve">
          <source>Another disadvantage of the rule approach is that there is no simple way to force an error if the set of rules doesn't cover the insertion date; the data will silently go into the master table instead.</source>
          <target state="translated">ルールアプローチのもう一つの欠点は、ルールのセットが挿入日をカバーしていない場合、エラーを強制的に発生させる簡単な方法がないことです。</target>
        </trans-unit>
        <trans-unit id="b74b279225b01a4f9a49098a715c0c2cd2860bb8" translate="yes" xml:space="preserve">
          <source>Another effect of &lt;code&gt;RECURSIVE&lt;/code&gt; is that &lt;code&gt;WITH&lt;/code&gt; queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without &lt;code&gt;RECURSIVE&lt;/code&gt;, &lt;code&gt;WITH&lt;/code&gt; queries can only reference sibling &lt;code&gt;WITH&lt;/code&gt; queries that are earlier in the &lt;code&gt;WITH&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;RECURSIVE&lt;/code&gt; のもう1つの効果は、 &lt;code&gt;WITH&lt;/code&gt; クエリを順序付けする必要がないことです。クエリは、リストの後半にある別のクエリを参照できます。（ただし、循環参照または相互再帰は実装されていません。） &lt;code&gt;RECURSIVE&lt;/code&gt; がない場合、 &lt;code&gt;WITH&lt;/code&gt; クエリは、 &lt;code&gt;WITH&lt;/code&gt; リストの前にある兄弟 &lt;code&gt;WITH&lt;/code&gt; クエリのみを参照できます。</target>
        </trans-unit>
        <trans-unit id="f949f8323c537df82042ad10748a3400dd5e3c94" translate="yes" xml:space="preserve">
          <source>Another example &amp;mdash; the PostgreSQL mailing list archives contained 910,989 unique words with 57,491,343 lexemes in 461,020 messages.</source>
          <target state="translated">別の例&amp;mdash; PostgreSQLメーリングリストのアーカイブには、910,989個の一意の単語が含まれ、57,491,343個の語彙素が461,020個のメッセージに含まれていました。</target>
        </trans-unit>
        <trans-unit id="e840dc5efd9dcea852680d04861f5d19522482d9" translate="yes" xml:space="preserve">
          <source>Another example demonstrating these concepts is that all these queries mean the same thing:</source>
          <target state="translated">これらの概念を示すもう一つの例は、これらのクエリはすべて同じことを意味するということです。</target>
        </trans-unit>
        <trans-unit id="448793ead43f5a4696dde796c384f50ddecfec35" translate="yes" xml:space="preserve">
          <source>Another example with &lt;code&gt;--rate=100&lt;/code&gt; and &lt;code&gt;--latency-limit=5&lt;/code&gt; (note the additional &lt;code&gt;schedule_lag&lt;/code&gt; column):</source>
          <target state="translated">&lt;code&gt;--rate=100&lt;/code&gt; および &lt;code&gt;--latency-limit=5&lt;/code&gt; を使用した別の例（追加の &lt;code&gt;schedule_lag&lt;/code&gt; 列に注意してください）：</target>
        </trans-unit>
        <trans-unit id="1eb54ef0acd3e1a10201fcaabd71c9780026708a" translate="yes" xml:space="preserve">
          <source>Another form of table aliasing gives temporary names to the columns of the table, as well as the table itself:</source>
          <target state="translated">テーブルエイリアスのもう一つの形式は、テーブル自体と同様に、テーブルの列に一時的な名前を与えることです。</target>
        </trans-unit>
        <trans-unit id="52020177212290ca0e1ac022789f990b2cddb766" translate="yes" xml:space="preserve">
          <source>Another identifier type used by the system is &lt;code&gt;xid&lt;/code&gt;, or transaction (abbreviated</source>
          <target state="translated">システムで使用されるもう1つの識別子タイプは、 &lt;code&gt;xid&lt;/code&gt; またはトランザクション（省略形）です。</target>
        </trans-unit>
        <trans-unit id="aed7ef2e15652a392b1a6ed9c8e4d99caec1a67e" translate="yes" xml:space="preserve">
          <source>Another important point is that when a server process is asked to display any of these statistics, it first fetches the most recent report emitted by the collector process and then continues to use this snapshot for all statistical views and functions until the end of its current transaction. So the statistics will show static information as long as you continue the current transaction. Similarly, information about the current queries of all sessions is collected when any such information is first requested within a transaction, and the same information will be displayed throughout the transaction. This is a feature, not a bug, because it allows you to perform several queries on the statistics and correlate the results without worrying that the numbers are changing underneath you. But if you want to see new results with each query, be sure to do the queries outside any transaction block. Alternatively, you can invoke &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt;(), which will discard the current transaction's statistics snapshot (if any). The next use of statistical information will cause a new snapshot to be fetched.</source>
          <target state="translated">別の重要な点は、サーバープロセスがこれらの統計のいずれかを表示するように要求された場合、最初にコレクタプロセスによって発行された最新のレポートをフェッチし、その後、現在のトランザクションが終了するまで、すべての統計ビューおよび機能に対してこのスナップショットを使用し続けることです。 。したがって、現在のトランザクションを続行している限り、統計には静的な情報が表示されます。同様に、すべてのセッションの現在のクエリに関する情報は、そのような情報がトランザクション内で最初に要求されたときに収集され、同じ情報がトランザクション全体で表示されます。これはバグではなく機能です。統計情報に対していくつかのクエリを実行し、数値が自分の下で変化することを心配せずに結果を関連付けることができるためです。しかし、クエリごとに新しい結果を表示したい場合は、クエリはトランザクションブロックの外で実行してください。別の方法として、 &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt; （）。現在のトランザクションの統計スナップショット（存在する場合）を破棄します。次に統計情報を使用すると、新しいスナップショットがフェッチされます。</target>
        </trans-unit>
        <trans-unit id="b8503372565f5e8246e4f400f8ddf376d816116a" translate="yes" xml:space="preserve">
          <source>Another important property of transactional databases is closely related to the notion of atomic updates: when multiple transactions are running concurrently, each one should not be able to see the incomplete changes made by others. For example, if one transaction is busy totalling all the branch balances, it would not do for it to include the debit from Alice's branch but not the credit to Bob's branch, nor vice versa. So transactions must be all-or-nothing not only in terms of their permanent effect on the database, but also in terms of their visibility as they happen. The updates made so far by an open transaction are invisible to other transactions until the transaction completes, whereupon all the updates become visible simultaneously.</source>
          <target state="translated">トランザクションデータベースのもう一つの重要な特性は、アトミックアップデートの概念と密接に関連しています。複数のトランザクションが同時に実行されている場合、それぞれのトランザクションは他のトランザクションによる不完全な変更を見ることができないはずです。例えば、あるトランザクションがすべての支店の残高を合計するのに忙しい場合、アリスの支店からの引き落としは含まれていても、ボブの支店への引き落としは含まれていない、あるいはその逆は含まれていないということになります。つまり、トランザクションはデータベースへの永続的な影響だけでなく、発生時の可視性の観点からもオールオア・ナッシングでなければなりません。オープンなトランザクションによってこれまでに行われた更新は、トランザクションが完了するまで他のトランザクションからは見えません。</target>
        </trans-unit>
        <trans-unit id="23097e202fa3204d32b939bd963d1f1a19f9bc71" translate="yes" xml:space="preserve">
          <source>Another limitation is that when an inner tuple's node points to a set of leaf tuples, those tuples must all be in the same index page. (This is a design decision to reduce seeking and save space in the links that chain such tuples together.) If the set of leaf tuples grows too large for a page, a split is performed and an intermediate inner tuple is inserted. For this to fix the problem, the new inner tuple &lt;em&gt;must&lt;/em&gt; divide the set of leaf values into more than one node group. If the operator class's &lt;code&gt;picksplit&lt;/code&gt; function fails to do that, the SP-GiST core resorts to extraordinary measures described in &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;.</source>
          <target state="translated">別の制限は、内部タプルのノードがリーフタプルのセットを指す場合、それらのタプルはすべて同じインデックスページにある必要があることです。 （これは、このようなタプルをチェーンするリンクのシークを減らし、スペースを節約するための設計上の決定です。）リーフタプルのセットがページに対して大きくなりすぎると、分割が実行され、中間の内部タプルが挿入されます。これで問題を解決するには、新しい内部タプルがリーフ値のセットを複数のノードグループに分割する&lt;em&gt;必要があり&lt;/em&gt;ます。演算子クラスの &lt;code&gt;picksplit&lt;/code&gt; 関数がそれを実行できない場合、SP-GiSTコアは、&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;セクション65.4.3で&lt;/a&gt;説明されている異常な手段を使用します。</target>
        </trans-unit>
        <trans-unit id="3c5682b61a20f627d46e59c868bdcce430ea3716" translate="yes" xml:space="preserve">
          <source>Another limitation of the same kind is that a &lt;code&gt;CASE&lt;/code&gt; cannot prevent evaluation of an aggregate expression contained within it, because aggregate expressions are computed before other expressions in a &lt;code&gt;SELECT&lt;/code&gt; list or &lt;code&gt;HAVING&lt;/code&gt; clause are considered. For example, the following query can cause a division-by-zero error despite seemingly having protected against it:</source>
          <target state="translated">同じ種類のもう1つの制限は、 &lt;code&gt;CASE&lt;/code&gt; は &lt;code&gt;SELECT&lt;/code&gt; リストまたは &lt;code&gt;HAVING&lt;/code&gt; 句の他の式が考慮される前に集計式が計算されるため、その中に含まれる集計式の評価を防止できないことです。たとえば、次のクエリは、保護されているように見えても、ゼロ除算エラーを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="7a59e6837fb64d2b0ae7bbcb08e5b72fd153fb2c" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 接続のもう1つのオプションは、クライアントが&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt; &lt;code&gt;requirepeer&lt;/code&gt; &lt;/a&gt;を使用して、ソケットに接続されているサーバープロセスの必要な所有者を指定することです。</target>
        </trans-unit>
        <trans-unit id="cb5714af00c74e15b8a5da4136ed86aaafa447c5" translate="yes" xml:space="preserve">
          <source>Another option is to increase &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; on the primary server, so that dead rows will not be cleaned up as quickly as they normally would be. This will allow more time for queries to execute before they are canceled on the standby, without having to set a high &lt;code&gt;max_standby_streaming_delay&lt;/code&gt;. However it is difficult to guarantee any specific execution-time window with this approach, since &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; is measured in transactions executed on the primary server.</source>
          <target state="translated">もう1つのオプションは、プライマリサーバーの&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;を増やして、デッド行が通常のように迅速にクリーンアップされないようにすることです。これにより、 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; を高く設定しなくても、クエリがスタンバイでキャンセルされる前に実行する時間が長くなります。ただし、 &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; はプライマリサーバーで実行されるトランザクションで測定されるため、このアプローチで特定の実行時間ウィンドウを保証することは困難です。</target>
        </trans-unit>
        <trans-unit id="7e21e953eee19c97f61f831dca8e524d5dd57839" translate="yes" xml:space="preserve">
          <source>Another option is to use rsync to perform a file system backup. This is done by first running rsync while the database server is running, then shutting down the database server long enough to do an &lt;code&gt;rsync --checksum&lt;/code&gt;. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) The second rsync will be quicker than the first, because it has relatively little data to transfer, and the end result will be consistent because the server was down. This method allows a file system backup to be performed with minimal downtime.</source>
          <target state="translated">別のオプションは、rsyncを使用してファイルシステムのバックアップを実行することです。これは、データベースサーバーの実行中に最初にrsyncを実行し、次に &lt;code&gt;rsync --checksum&lt;/code&gt; を実行するのに十分な時間データベースサーバーをシャットダウンすることによって行われます。 （ &lt;code&gt;--checksum&lt;/code&gt; が必要なのは、 &lt;code&gt;rsync&lt;/code&gt; のファイル変更時間の粒度が1秒しかないためです。）2番目のrsyncは、転送するデータが比較的少ないため、最初のrsyncよりも速くなり、サーバーがダウン。この方法により、最小限のダウンタイムでファイルシステムのバックアップを実行できます。</target>
        </trans-unit>
        <trans-unit id="7c34c9f74979196480818c068869e2f214816a27" translate="yes" xml:space="preserve">
          <source>Another option that is often preferable is to remove the partition from the partitioned table but retain access to it as a table in its own right:</source>
          <target state="translated">他にも、パーティショニングされたテーブルからパーティションを削除しても、それ自体はテーブルとしてアクセスできるようにしておくという方法が好ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="2a69438b1163aac867f43267272d34d1c58b2559" translate="yes" xml:space="preserve">
          <source>Another point to keep in mind is that by default, execute privilege is granted to &lt;code&gt;PUBLIC&lt;/code&gt; for newly created functions (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for more information). Frequently you will wish to restrict use of a security definer function to only some users. To do that, you must revoke the default &lt;code&gt;PUBLIC&lt;/code&gt; privileges and then grant execute privilege selectively. To avoid having a window where the new function is accessible to all, create it and set the privileges within a single transaction. For example:</source>
          <target state="translated">留意すべきもう1つの点は、デフォルトでは、新しく作成された関数の実行権限が &lt;code&gt;PUBLIC&lt;/code&gt; に付与されることです（詳細は、&lt;a href=&quot;ddl-priv&quot;&gt;5.7項を&lt;/a&gt;参照）。多くの場合、セキュリティ定義機能の使用を一部のユーザーのみに制限する必要があります。そのためには、デフォルトの &lt;code&gt;PUBLIC&lt;/code&gt; 特権を取り消してから、実行特権を選択的に付与する必要があります。すべてのユーザーが新しい関数にアクセスできるウィンドウが表示されないようにするには、ウィンドウを作成して、1つのトランザクション内で特権を設定します。例えば：</target>
        </trans-unit>
        <trans-unit id="c64ca403c18f38074dbf9506c7423e6c0d47b0ca" translate="yes" xml:space="preserve">
          <source>Another possibility is to create a configuration file directory and put this information into files there. For example, a &lt;code&gt;conf.d&lt;/code&gt; directory could be referenced at the end of &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">別の可能性は、設定ファイルのディレクトリを作成し、この情報をそこにあるファイルに入れることです。たとえば、 &lt;code&gt;postgresql.conf&lt;/code&gt; の末尾で &lt;code&gt;conf.d&lt;/code&gt; ディレクトリを参照できます。</target>
        </trans-unit>
        <trans-unit id="e15bc878f1b5a7c697e8423bcee242bc5167d6a2" translate="yes" xml:space="preserve">
          <source>Another possibility is to store the documents as simple text files in the file system. In this case, the database can be used to store the full text index and to execute searches, and some unique identifier can be used to retrieve the document from the file system. However, retrieving files from outside the database requires superuser permissions or special function support, so this is usually less convenient than keeping all the data inside PostgreSQL. Also, keeping everything inside the database allows easy access to document metadata to assist in indexing and display.</source>
          <target state="translated">別の可能性としては、文書をファイルシステム内の単純なテキストファイルとして格納することが考えられる。この場合、データベースを使用してフルテキストインデックスを格納したり、検索を実行したりすることができ、ファイルシステムから文書を取得するためにいくつかのユニークな識別子を使用することができます。しかし、データベースの外部からファイルを取得するには、スーパーユーザ権限や特別な関数のサポートが必要なため、通常はすべてのデータをPostgreSQLの内部に保持するよりも便利ではありません。また、すべてのデータをデータベース内に保持することで、文書のメタデータに簡単にアクセスしてインデックス作成や表示を支援することができます。</target>
        </trans-unit>
        <trans-unit id="8fbada3201971de13171c32bf7cda835bc3fd1af" translate="yes" xml:space="preserve">
          <source>Another possible type of join is a merge join, illustrated here:</source>
          <target state="translated">もう一つの可能性のある結合のタイプは、マージ結合です。</target>
        </trans-unit>
        <trans-unit id="19829ac1739436800f592d8b7c21c52fef4c33d8" translate="yes" xml:space="preserve">
          <source>Another possible use for a partial index is to exclude values from the index that the typical query workload is not interested in; this is shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;Example 11.2&lt;/a&gt;. This results in the same advantages as listed above, but it prevents the &amp;ldquo;uninteresting&amp;rdquo; values from being accessed via that index, even if an index scan might be profitable in that case. Obviously, setting up partial indexes for this kind of scenario will require a lot of care and experimentation.</source>
          <target state="translated">部分インデックスのもう1つの可能な使用法は、典型的なクエリのワークロードが関心のないインデックスから値を除外することです。これを&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;例11.2に&lt;/a&gt;示します。これにより、上記と同じ利点が得られますが、その場合、インデックススキャンが有益である場合でも、そのインデックスを介して「興味のない」値にアクセスできなくなります。明らかに、この種のシナリオに部分インデックスを設定するには、多くの注意と実験が必要になります。</target>
        </trans-unit>
        <trans-unit id="f28a354a8ba88184cb3beacb89675afbd6c03d21" translate="yes" xml:space="preserve">
          <source>Another production-grade approach to managing log output is to send it to syslog and let syslog deal with file rotation. To do this, set the configuration parameter &lt;code&gt;log_destination&lt;/code&gt; to &lt;code&gt;syslog&lt;/code&gt; (to log to syslog only) in &lt;code&gt;postgresql.conf&lt;/code&gt;. Then you can send a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the syslog daemon whenever you want to force it to start writing a new log file. If you want to automate log rotation, the logrotate program can be configured to work with log files from syslog.</source>
          <target state="translated">ログ出力を管理するための本番環境レベルの別のアプローチは、ログをsyslogに送信して、syslogにファイルローテーションを処理させることです。これを行うには、 &lt;code&gt;postgresql.conf&lt;/code&gt; で構成パラメーター &lt;code&gt;log_destination&lt;/code&gt; を &lt;code&gt;syslog&lt;/code&gt; に設定します（syslogにのみログを記録するため）。その後、新しいログファイルの書き込みを強制的に開始したい場合はいつでも、syslogデーモンに &lt;code&gt;SIGHUP&lt;/code&gt; シグナルを送信できます。ログローテーションを自動化する場合は、syslogのログファイルを使用するようにlogrotateプログラムを構成できます。</target>
        </trans-unit>
        <trans-unit id="0d7e78b3e262e81affaac44d4c64dc15d4edfbba" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;FOR UPDATE&lt;/code&gt; is that without it, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; might fail if the cursor query does not meet the SQL standard's rules for being &amp;ldquo;simply updatable&amp;rdquo; (in particular, the cursor must reference just one table and not use grouping or &lt;code&gt;ORDER BY&lt;/code&gt;). Cursors that are not simply updatable might work, or might not, depending on plan choice details; so in the worst case, an application might work in testing and then fail in production. If &lt;code&gt;FOR UPDATE&lt;/code&gt; is specified, the cursor is guaranteed to be updatable.</source>
          <target state="translated">&lt;code&gt;FOR UPDATE&lt;/code&gt; を使用するもう1つの理由は、FOR UPDATEがないと、カーソルクエリが「単純に更新可能」であるというSQL標準のルールを満たさない場合、後続の &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; が失敗する可能性があるためです（特に、カーソルは1つのテーブルのみを参照し、グループ化を使用しないでください）または &lt;code&gt;ORDER BY&lt;/code&gt; ）。単に更新可能ではないカーソルは、計画の選択の詳細に応じて機能する場合と機能しない場合があります。したがって、最悪の場合、アプリケーションはテストで機能し、その後本番で失敗する可能性があります。場合は &lt;code&gt;FOR UPDATE&lt;/code&gt; が指定され、カーソルが更新可能であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="6f33d845713febc0898090d451e4ee3ef8ebffb5" translate="yes" xml:space="preserve">
          <source>Another requirement for a multiple-data-type family is that any implicit or binary-coercion casts that are defined between data types included in the operator family must not change the associated sort ordering.</source>
          <target state="translated">複数データ型ファミリのもう一つの要件は、演算子ファミリに含まれるデータ型間で定義される暗黙的またはバイナリ強制キャストは、関連するソート順序を変更してはならないということです。</target>
        </trans-unit>
        <trans-unit id="9114df95c9c9d6782e38dbaee1edab69dd63ee66" translate="yes" xml:space="preserve">
          <source>Another response could be this:</source>
          <target state="translated">もう一つの対応はこれかもしれません。</target>
        </trans-unit>
        <trans-unit id="67c38a78e448cde09317f71b64feae68f30e256d" translate="yes" xml:space="preserve">
          <source>Another risk of data loss is posed by the disk platter write operations themselves. Disk platters are divided into sectors, commonly 512 bytes each. Every physical read or write operation processes a whole sector. When a write request arrives at the drive, it might be for some multiple of 512 bytes (PostgreSQL typically writes 8192 bytes, or 16 sectors, at a time), and the process of writing could fail due to power loss at any time, meaning some of the 512-byte sectors were written while others were not. To guard against such failures, PostgreSQL periodically writes full page images to permanent WAL storage &lt;em&gt;before&lt;/em&gt; modifying the actual page on disk. By doing this, during crash recovery PostgreSQL can restore partially-written pages from WAL. If you have file-system software that prevents partial page writes (e.g., ZFS), you can turn off this page imaging by turning off the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. Battery-Backed Unit (BBU) disk controllers do not prevent partial page writes unless they guarantee that data is written to the BBU as full (8kB) pages.</source>
          <target state="translated">データ損失の別のリスクは、ディスクプラッターの書き込み操作自体によってもたらされます。ディスクプラッタは、通常512バイトのセクターに分割されます。すべての物理的な読み取りまたは書き込み操作は、セクター全体を処理します。書き込み要求がドライブに到着すると、512バイトの倍数である可能性があり（PostgreSQLは通常、一度に8192バイト、つまり16セクターを書き込みます）、電力損失が原因で書き込み処理がいつでも失敗する可能性があります。 512バイトのセクターの一部は書き込まれ、一部は書き込まれませんでした。このような障害を防ぐために、PostgreSQLは定期的にフルページのイメージを永続的なWALストレージ&lt;em&gt;に&lt;/em&gt;定期的に書き込みます。&lt;em&gt;&lt;/em&gt;ディスク上の実際のページを変更します。これにより、クラッシュリカバリ中にPostgreSQLはWALから部分的に書き込まれたページを復元できます。部分的なページ書き込みを防止するファイルシステムソフトウェア（ZFSなど）がある場合は、&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;パラメーターをオフにすることで、このページイメージングをオフにできます。バッテリーバックアップユニット（BBU）ディスクコントローラーは、データが完全な（8kB）ページとしてBBUに書き込まれることを保証しない限り、部分的なページ書き込みを防止しません。</target>
        </trans-unit>
        <trans-unit id="a64140ba6c591322306ded2e563c831d5063eb12" translate="yes" xml:space="preserve">
          <source>Another special feature is that during input, you can write &lt;code&gt;?&lt;/code&gt; in place of the check digit, and the correct check digit will be inserted automatically.</source>
          <target state="translated">もう1つの特別な機能は、入力時に次のように記述できること &lt;code&gt;?&lt;/code&gt; チェックディジットの代わりに、正しいチェックディジットが自動的に挿入されます。</target>
        </trans-unit>
        <trans-unit id="d8a7029d22a4fea1aec3f6a0a7967d7366ab11c8" translate="yes" xml:space="preserve">
          <source>Another special syntactical behavior associated with composite values is that we can use &lt;em&gt;functional notation&lt;/em&gt; for extracting a field of a composite value. The simple way to explain this is that the notations &lt;code&gt;field(table)&lt;/code&gt; and &lt;code&gt;table.field&lt;/code&gt; are interchangeable. For example, these queries are equivalent:</source>
          <target state="translated">複合値に関連するもう1つの特殊な構文動作は、複合&lt;em&gt;表記&lt;/em&gt;のフィールドを抽出するために&lt;em&gt;関数表記&lt;/em&gt;を使用できることです。これを説明する簡単な方法は、 &lt;code&gt;field(table)&lt;/code&gt; と &lt;code&gt;table.field&lt;/code&gt; の表記が交換可能であることです。たとえば、これらのクエリは同等です。</target>
        </trans-unit>
        <trans-unit id="2d14ebbe44cc336bb06782ca5c2e2a5afdbf5d04" translate="yes" xml:space="preserve">
          <source>Another type of extra information is the number of rows removed by a filter condition:</source>
          <target state="translated">別のタイプの追加情報は、フィルタ条件によって削除された行の数です。</target>
        </trans-unit>
        <trans-unit id="de04ff7f29beb7d9f803262abe6fbc7f7a247ce7" translate="yes" xml:space="preserve">
          <source>Another type of statistics stored for each column are most-common value lists. This allows very accurate estimates for individual columns, but may result in significant misestimates for queries with conditions on multiple columns.</source>
          <target state="translated">各カラムに対して保存されるもう一つのタイプの統計量は、最も一般的な値のリストです。これにより、個々のカラムに対して非常に正確な推定値を得ることができますが、複数のカラムに条件があるクエリでは、大幅な誤推定値が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="aef386cf940d64dd2d0246974eb986d99db04233" translate="yes" xml:space="preserve">
          <source>Another useful tool for monitoring database activity is the &lt;code&gt;pg_locks&lt;/code&gt; system table. It allows the database administrator to view information about the outstanding locks in the lock manager. For example, this capability can be used to:</source>
          <target state="translated">データベースアクティビティを監視するためのもう1つの便利なツールは、 &lt;code&gt;pg_locks&lt;/code&gt; システムテーブルです。これにより、データベース管理者は、ロックマネージャの未処理のロックに関する情報を表示できます。たとえば、この機能は次の目的で使用できます。</target>
        </trans-unit>
        <trans-unit id="973de1b89f5a19d8493a281c676145e3c2762491" translate="yes" xml:space="preserve">
          <source>Another value expression in parentheses (used to group subexpressions and override precedence)</source>
          <target state="translated">括弧内の別の値式 (副式をグループ化して優先順位を上書きするために使用)</target>
        </trans-unit>
        <trans-unit id="7a50bf5d6a0c79646db228f587b35fc8dbea931f" translate="yes" xml:space="preserve">
          <source>Another way to do it is:</source>
          <target state="translated">もう一つの方法としては</target>
        </trans-unit>
        <trans-unit id="09b69091260be1fa872b4a938337bcecea2b0096" translate="yes" xml:space="preserve">
          <source>Another way to get the same effect is to use the &lt;code&gt;regclass&lt;/code&gt; alias type, which will print the table OID symbolically:</source>
          <target state="translated">同じ効果を得るもう1つの方法は、 &lt;code&gt;regclass&lt;/code&gt; エイリアスタイプを使用することです。これにより、テーブルのOIDがシンボリックに出力されます。</target>
        </trans-unit>
        <trans-unit id="77f482e38cebbd37d2bd4865436228573a9f332c" translate="yes" xml:space="preserve">
          <source>Another way to obtain the same result as &lt;code&gt;\copy ... to&lt;/code&gt; is to use the SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; command and terminate it with &lt;code&gt;\g filename&lt;/code&gt; or &lt;code&gt;\g |program&lt;/code&gt;. Unlike &lt;code&gt;\copy&lt;/code&gt;, this method allows the command to span multiple lines; also, variable interpolation and backquote expansion can be used.</source>
          <target state="translated">&lt;code&gt;\copy ... to&lt;/code&gt; と同じ結果を得る別の方法は、SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; コマンドを使用して、 &lt;code&gt;\g filename&lt;/code&gt; または &lt;code&gt;\g |program&lt;/code&gt; 終了することです。 &lt;code&gt;\copy&lt;/code&gt; とは異なり、この方法ではコマンドが複数行にまたがることができます。また、変数補間とバッククォート拡張を使用できます。</target>
        </trans-unit>
        <trans-unit id="af0ee54bbb9066194d74463e9d95fe7b567d2abb" translate="yes" xml:space="preserve">
          <source>Another way to return multiple columns is to use a &lt;code&gt;TABLE&lt;/code&gt; function:</source>
          <target state="translated">複数の列を返す別の方法は、 &lt;code&gt;TABLE&lt;/code&gt; 関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="886fca6d2b20a157de482df72d3dea2c336eadc6" translate="yes" xml:space="preserve">
          <source>Another way to think about a discrete range type is that there is a clear idea of a &amp;ldquo;next&amp;rdquo; or &amp;ldquo;previous&amp;rdquo; value for each element value. Knowing that, it is possible to convert between inclusive and exclusive representations of a range's bounds, by choosing the next or previous element value instead of the one originally given. For example, in an integer range type &lt;code&gt;[4,8]&lt;/code&gt; and &lt;code&gt;(3,9)&lt;/code&gt; denote the same set of values; but this would not be so for a range over numeric.</source>
          <target state="translated">離散範囲タイプについて考えるもう1つの方法は、各要素の値に「次の」または「前の」値の明確なアイデアがあるということです。そのことを知っていれば、範囲の境界の包括的表現と排他的表現の間で、元々与えられたものの代わりに次または前の要素の値を選択することによって変換することが可能です。たとえば、整数の範囲では、タイプ &lt;code&gt;[4,8]&lt;/code&gt; と &lt;code&gt;(3,9)&lt;/code&gt; は同じ値のセットを示します。しかし、これは数値を超える範囲には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="d84849349152ff8e618adbfaeb1704c4dc99ecf7" translate="yes" xml:space="preserve">
          <source>Another way to work with angles measured in degrees is to use the unit transformation functions &lt;code&gt;radians()&lt;/code&gt; and &lt;code&gt;degrees()&lt;/code&gt; shown earlier. However, using the degree-based trigonometric functions is preferred, as that way avoids round-off error for special cases such as &lt;code&gt;sind(30)&lt;/code&gt;.</source>
          <target state="translated">度で測定された角度を操作する別の方法は、前に示した単位変換関数 &lt;code&gt;radians()&lt;/code&gt; および &lt;code&gt;degrees()&lt;/code&gt; を使用することです。ただし、次数に基づく三角関数を使用することをお &lt;code&gt;sind(30)&lt;/code&gt; ます。これにより、sind（30）などの特殊な場合の丸め誤差が回避されます。</target>
        </trans-unit>
        <trans-unit id="efdd30de2aea5b5d5befd3533f098d92f63380ab" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DECLARE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; statement, whose execution plan you wish to see.</source>
          <target state="translated">任意の &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;VALUES&lt;/code&gt; 、 &lt;code&gt;EXECUTE&lt;/code&gt; 、 &lt;code&gt;DECLARE&lt;/code&gt; 、 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 、または &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; 実行計画あなたが見たい文を、。</target>
        </trans-unit>
        <trans-unit id="386ffc8dd49c3fb7f2ddd349b2b9b4201e8b40ad" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; statement.</source>
          <target state="translated">任意の &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;VALUES&lt;/code&gt; の声明。</target>
        </trans-unit>
        <trans-unit id="450e11982aec06ef4f3dbb171ba6a8eb1e20a7be" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly or explicitly; therefore, the functions shown above as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value. In addition, you can cast a text value to &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; using normal casting syntax: for example, &lt;code&gt;inet(expression)&lt;/code&gt; or &lt;code&gt;colname::cidr&lt;/code&gt;.</source>
          <target state="translated">任意の &lt;code&gt;cidr&lt;/code&gt; 値を暗黙的または明示的に &lt;code&gt;inet&lt;/code&gt; にキャストできます。したがって、 &lt;code&gt;inet&lt;/code&gt; で動作する上記の関数は、 &lt;code&gt;cidr&lt;/code&gt; 値でも機能します。 （ &lt;code&gt;inet&lt;/code&gt; と &lt;code&gt;cidr&lt;/code&gt; に別々の関数がある場合、これは2つのケースで動作が異なるためです。）また、 &lt;code&gt;inet&lt;/code&gt; 値を &lt;code&gt;cidr&lt;/code&gt; にキャストすることもできます。これが行われると、ネットマスクの右側のビットは何も表示されずにゼロになり、有効な &lt;code&gt;cidr&lt;/code&gt; 値が作成されます。さらに、通常のキャスト構文を使用して、テキスト値を &lt;code&gt;inet&lt;/code&gt; または &lt;code&gt;cidr&lt;/code&gt; にキャストできます。たとえば、 &lt;code&gt;inet(expression)&lt;/code&gt; または &lt;code&gt;colname::cidr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97a5e9f25fdf2d6789317985300af494edaa42f6" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The condition expression cannot refer to any tables except &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt;, and cannot contain aggregate functions.</source>
          <target state="translated">SQL条件式（ &lt;code&gt;boolean&lt;/code&gt; ）。条件式は &lt;code&gt;NEW&lt;/code&gt; および &lt;code&gt;OLD&lt;/code&gt; 以外のテーブルを参照できません。また、集計関数を含めることもできません。</target>
        </trans-unit>
        <trans-unit id="7f04645af195b0769f156d1c9178d5413d13947d" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be added to queries that refer to the table if row level security is enabled. Rows for which the expression returns true will be visible. Any rows for which the expression returns false or null will not be visible to the user (in a &lt;code&gt;SELECT&lt;/code&gt;), and will not be available for modification (in an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;). Such rows are silently suppressed; no error is reported.</source>
          <target state="translated">SQL条件式（ &lt;code&gt;boolean&lt;/code&gt; ）。条件式に集計関数やウィンドウ関数を含めることはできません。行レベルのセキュリティが有効になっている場合、この式はテーブルを参照するクエリに追加されます。式がtrueを返す行が表示されます。式がfalseまたはnullを返す行は、ユーザーには表示されず（ &lt;code&gt;SELECT&lt;/code&gt; で）、変更できません（ &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; で）。そのような行は黙って抑制されます。エラーは報告されません。</target>
        </trans-unit>
        <trans-unit id="9d0a8e5978d0613618d7d621bf1cd5c083979c7e" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be used in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; queries against the table if row level security is enabled. Only rows for which the expression evaluates to true will be allowed. An error will be thrown if the expression evaluates to false or null for any of the records inserted or any of the records that result from the update. Note that the &lt;code&gt;check_expression&lt;/code&gt; is evaluated against the proposed new contents of the row, not the original contents.</source>
          <target state="translated">SQL条件式（ &lt;code&gt;boolean&lt;/code&gt; ）。条件式に集計関数やウィンドウ関数を含めることはできません。行レベルのセキュリティが有効になっている場合、この式はテーブルに対する &lt;code&gt;INSERT&lt;/code&gt; および &lt;code&gt;UPDATE&lt;/code&gt; クエリで使用されます。式がtrueと評価される行のみが許可されます。挿入されたレコードのいずれか、または更新の結果として生じたレコードのいずれかについて式がfalseまたはnullと評価された場合、エラーがスローされます。 &lt;code&gt;check_expression&lt;/code&gt; は、元のコンテンツではなく、行の提案された新しいコンテンツに対して評価されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e356ac9cfe76e1d8f07ddb1a43d7eac6d271ea2" translate="yes" xml:space="preserve">
          <source>Any character in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; that matches a character in the &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; set is replaced by the corresponding character in the &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt; set. If &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; is longer than &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;, occurrences of the extra characters in &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; are removed.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;セットの&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;と一致する&lt;em&gt;string&lt;/em&gt;内の&lt;em&gt;文字&lt;/em&gt;は、&lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt;セットの対応する文字に置き換えられます。場合&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;より長い&lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt;、中に余分な文字の出現&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;削除されます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12f81b0886507c6c81c137ed43e36901064a888a" translate="yes" xml:space="preserve">
          <source>Any developer of a new &lt;code&gt;table access method&lt;/code&gt; can refer to the existing &lt;code&gt;heap&lt;/code&gt; implementation present in &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; for details of its implementation.</source>
          <target state="translated">新しい &lt;code&gt;table access method&lt;/code&gt; 開発者は、実装の詳細について &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; にある既存の &lt;code&gt;heap&lt;/code&gt; 実装を参照できます。</target>
        </trans-unit>
        <trans-unit id="144550beabeed185659254b872d28c678638c93a" translate="yes" xml:space="preserve">
          <source>Any digest algorithm OpenSSL supports is automatically picked up. This is not possible with ciphers, which need to be supported explicitly.</source>
          <target state="translated">OpenSSL がサポートするすべてのダイジェストアルゴリズムは自動的にピックアップされます。これは、明示的にサポートされている必要がある暗号では不可能です。</target>
        </trans-unit>
        <trans-unit id="c4c8c401fe264a209ebccf99c5f886fc113da7d7" translate="yes" xml:space="preserve">
          <source>Any file or directory beginning with &lt;code&gt;pgsql_tmp&lt;/code&gt; can be omitted from the backup. These files are removed on postmaster start and the directories will be recreated as needed.</source>
          <target state="translated">&lt;code&gt;pgsql_tmp&lt;/code&gt; で始まるファイルまたはディレクトリは、バックアップから除外できます。これらのファイルはpostmasterの起動時に削除され、ディレクトリは必要に応じて再作成されます。</target>
        </trans-unit>
        <trans-unit id="a836141ba30a8aa1360f43439d3c24535024a80a" translate="yes" xml:space="preserve">
          <source>Any generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns.</source>
          <target state="translated">コピーされた列定義の生成式はすべてコピーされます。デフォルトでは、新しいカラムは通常の基底カラムになります。</target>
        </trans-unit>
        <trans-unit id="5e18734ff6a37a9bb9fd3457eedcb31fb70163d6" translate="yes" xml:space="preserve">
          <source>Any identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table.</source>
          <target state="translated">コピーされた列定義のすべての同一性指定はコピーされます。新しいテーブルの各 ID 列に対して、古いテーブルに関連付けられたシーケンスとは別に、新しいシーケンスが作成されます。</target>
        </trans-unit>
        <trans-unit id="feba919d6ac95ebb1703749287894bc69e982374" translate="yes" xml:space="preserve">
          <source>Any memberships in the group role are automatically revoked (but the member roles are not otherwise affected).</source>
          <target state="translated">グループ・ロール内のすべてのメンバーシップは自動的に取り消されます(ただし、メンバー・ロールには他の影響はありません)。</target>
        </trans-unit>
        <trans-unit id="f42a74d5d4ceddfdc2731676cd56c9941e931e10" translate="yes" xml:space="preserve">
          <source>Any other backslashed character that is not mentioned in the above table will be taken to represent itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end-of-data marker (&lt;code&gt;\.&lt;/code&gt;) or the null string (&lt;code&gt;\N&lt;/code&gt; by default). These strings will be recognized before any other backslash processing is done.</source>
          <target state="translated">上記の表に記載されていないバックスラッシュ文字は、それ自体を表すものと見なされます。ただし、バックスラッシュを不必要に追加すると、データの終わりマーカー（ &lt;code&gt;\.&lt;/code&gt; ）またはnull文字列（デフォルトでは &lt;code&gt;\N&lt;/code&gt; ）に一致する文字列が誤って生成される可能性があるため、注意してください。これらの文字列は、他のバックスラッシュ処理が行われる前に認識されます。</target>
        </trans-unit>
        <trans-unit id="59556037a647190d9808748d3940223c9b60fa38" translate="yes" xml:space="preserve">
          <source>Any other character following a backslash is taken literally. Thus, to include a backslash character, write two backslashes (&lt;code&gt;\\&lt;/code&gt;). Also, a single quote can be included in an escape string by writing &lt;code&gt;\'&lt;/code&gt;, in addition to the normal way of &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">バックスラッシュに続く他の文字は文字通りに解釈されます。したがって、バックスラッシュ文字を含めるには、2つのバックスラッシュ（ &lt;code&gt;\\&lt;/code&gt; ）を記述します。また、 &lt;code&gt;''&lt;/code&gt; の通常の方法に加えて、 &lt;code&gt;\'&lt;/code&gt; と書くことにより、エスケープ文字列に単一引用符を含めることができます。</target>
        </trans-unit>
        <trans-unit id="6176992a355fd17e3c78216ef8246e171f7a7f5d" translate="yes" xml:space="preserve">
          <source>Any rows whose updated values do not pass the &lt;code&gt;WITH CHECK&lt;/code&gt; expression will cause an error, and the entire command will be aborted. If only a &lt;code&gt;USING&lt;/code&gt; clause is specified, then that clause will be used for both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; cases.</source>
          <target state="translated">更新された値が &lt;code&gt;WITH CHECK&lt;/code&gt; 式を通過しない行があると、エラーが発生し、コマンド全体が中止されます。 &lt;code&gt;USING&lt;/code&gt; 句のみが指定されている場合、その句は &lt;code&gt;USING&lt;/code&gt; と &lt;code&gt;WITH CHECK&lt;/code&gt; の両方のケースで使用されます。</target>
        </trans-unit>
        <trans-unit id="e53b9947d34df736f27a314411d8d097ccb99c38" translate="yes" xml:space="preserve">
          <source>Any two opposite corners can be supplied on input, but the values will be reordered as needed to store the upper right and lower left corners, in that order.</source>
          <target state="translated">入力時に任意の2つの反対側の角を与えることができますが、値は必要に応じて、右上と左下の角を格納するために、その順番に並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="9cd48f92d0048ad74a4b2a1c77759555487aa4a5" translate="yes" xml:space="preserve">
          <source>Any value of &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; greater than 0 selects the shortest-precise format.</source>
          <target state="translated">いずれかの値&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; 0選択最短正確な形式よりも大きいです。</target>
        </trans-unit>
        <trans-unit id="6e1092ad7e1aa0d329dcf1a1dc88a2fd1167428b" translate="yes" xml:space="preserve">
          <source>Anything you enter in psql that begins with an unquoted backslash is a psql meta-command that is processed by psql itself. These commands make psql more useful for administration or scripting. Meta-commands are often called slash or backslash commands.</source>
          <target state="translated">psqlに入力したもので、引用符なしのバックスラッシュで始まるものはすべてpsqlメタコマンドで、psql自身が処理します。これらのコマンドにより、psqlは管理やスクリプトをより便利にします。メタコマンドは、スラッシュコマンドやバックスラッシュコマンドと呼ばれることが多いです。</target>
        </trans-unit>
        <trans-unit id="ca34db883b90f5136d142c2d8962aac808f06344" translate="yes" xml:space="preserve">
          <source>Append the server log output to &lt;code&gt;filename&lt;/code&gt;. If the file does not exist, it is created. The umask is set to 077, so access to the log file is disallowed to other users by default.</source>
          <target state="translated">サーバーログ出力を &lt;code&gt;filename&lt;/code&gt; に追加します。ファイルが存在しない場合は作成されます。umaskは077に設定されているため、デフォルトでは、ログファイルへのアクセスは他のユーザーに許可されていません。</target>
        </trans-unit>
        <trans-unit id="8837d91fde54bfbd4c7276bc104dbd7eb57e326a" translate="yes" xml:space="preserve">
          <source>Appendix A. PostgreSQL Error Codes</source>
          <target state="translated">付録A.PostgreSQLエラーコード</target>
        </trans-unit>
        <trans-unit id="8f525f98762ab18cc61fb77a68f4661a9eaa0966" translate="yes" xml:space="preserve">
          <source>Appendix B. Date/Time Support</source>
          <target state="translated">付録B.日付/時間のサポート</target>
        </trans-unit>
        <trans-unit id="0a4fd0d75b5e8cb67c2577d915d2f158e36d619c" translate="yes" xml:space="preserve">
          <source>Appendix C. SQL Key Words</source>
          <target state="translated">付録 C.SQLのキーワード</target>
        </trans-unit>
        <trans-unit id="2d3d6ce5d75b048ec4b4bfd56085229d360ae080" translate="yes" xml:space="preserve">
          <source>Appendix D. SQL Conformance</source>
          <target state="translated">付録D.SQLの適合性</target>
        </trans-unit>
        <trans-unit id="1c760d4057771bdbd912b1a26d17b99309626b19" translate="yes" xml:space="preserve">
          <source>Appendix E. Release Notes</source>
          <target state="translated">付録 E.リリースノート</target>
        </trans-unit>
        <trans-unit id="3cc083a7e98cb9a510c3b8e9fe828f669dae8eb2" translate="yes" xml:space="preserve">
          <source>Appendix F. Additional Supplied Modules</source>
          <target state="translated">付録F.追加供給モジュール</target>
        </trans-unit>
        <trans-unit id="0a757b9f46902730f7dbc09c2b987bcc9b1402c2" translate="yes" xml:space="preserve">
          <source>Appendix G. Additional Supplied Programs</source>
          <target state="translated">付録G.追加供給されたプログラム</target>
        </trans-unit>
        <trans-unit id="f731ac7aad79287ad6a9d70b29b7d9f22f9d74ad" translate="yes" xml:space="preserve">
          <source>Appendix K. PostgreSQL Limits</source>
          <target state="translated">付録K.PostgreSQLの限界</target>
        </trans-unit>
        <trans-unit id="6b2f6b4afe56f03c3636cff98cc090e912a2978a" translate="yes" xml:space="preserve">
          <source>Appendix L. Acronyms</source>
          <target state="translated">付録L.略語</target>
        </trans-unit>
        <trans-unit id="5e2daf479a3e3b6ca8645aabab30691c459271fc" translate="yes" xml:space="preserve">
          <source>Appendix: Additional Supplied Modules</source>
          <target state="translated">付録 追加供給モジュール</target>
        </trans-unit>
        <trans-unit id="5fe175a1da37b9c50cabd865124df334aa3597f0" translate="yes" xml:space="preserve">
          <source>Appendix: Date/Time Support</source>
          <target state="translated">付録です。日付・時間のサポート</target>
        </trans-unit>
        <trans-unit id="a8d8b25f2c37eff5457e8db6ccb6dece99f46eb0" translate="yes" xml:space="preserve">
          <source>Appendix: SQL Conformance</source>
          <target state="translated">付録:SQLの適合性</target>
        </trans-unit>
        <trans-unit id="1f6da0679b0bcee42966e5109a37944191c26ca8" translate="yes" xml:space="preserve">
          <source>Appendixes</source>
          <target state="translated">Appendixes</target>
        </trans-unit>
        <trans-unit id="99005fc867cd3e54c80bd91ee175bcce277708d9" translate="yes" xml:space="preserve">
          <source>Applicable Object Types</source>
          <target state="translated">適用オブジェクトの種類</target>
        </trans-unit>
        <trans-unit id="a63f73a380e6bb14bdd2ad6b10a8f68e5d42a5ad" translate="yes" xml:space="preserve">
          <source>Application Programming Interface</source>
          <target state="translated">アプリケーションプログラミングインタフェース</target>
        </trans-unit>
        <trans-unit id="2f16f8fd5e0553e004d0e86eda56a845aa102673" translate="yes" xml:space="preserve">
          <source>Application name</source>
          <target state="translated">アプリケーション名</target>
        </trans-unit>
        <trans-unit id="b03ebc2274f172652f6125e87dba0dd896ad4421" translate="yes" xml:space="preserve">
          <source>Application of Multiple Policies</source>
          <target state="translated">複数のポリシーの適用</target>
        </trans-unit>
        <trans-unit id="00135b8aa11b060725023cffb44e0b589a9f25a0" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with queries accessing the target page on the standby, whether or not the data to be removed is visible.</source>
          <target state="translated">WALからのバキュームクリーンアップレコードの適用は、削除対象のデータが表示されているかどうかに関わらず、待機中の対象ページにアクセスするクエリと競合します。</target>
        </trans-unit>
        <trans-unit id="3256ed72d4783ec493be93406d6bd97d0d7b90f1" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with standby transactions whose snapshots can still &amp;ldquo;see&amp;rdquo; any of the rows to be removed.</source>
          <target state="translated">WALからのバキュームクリーンアップレコードの適用は、削除される行をスナップショットがまだ「見る」ことができるスタンバイトランザクションと競合します。</target>
        </trans-unit>
        <trans-unit id="76c74bd071dd73f01696fddbbffc77712a479faf" translate="yes" xml:space="preserve">
          <source>Applications</source>
          <target state="translated">Applications</target>
        </trans-unit>
        <trans-unit id="6b5428213daf1d5aba6d1295a6bbb19c08864fc0" translate="yes" xml:space="preserve">
          <source>Applications that wanted precise values have historically had to set &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.</source>
          <target state="translated">正確な値を必要とするアプリケーションは、これまで、それらを取得するために&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt;を3に設定する必要がありました。バージョン間の最大の互換性のために、彼らはそうし続けるべきです。</target>
        </trans-unit>
        <trans-unit id="ed624d6999cad953cb5b1bedd94e985196972ebd" translate="yes" xml:space="preserve">
          <source>Applications that wish to use backslash as escape should be modified to use escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;), because the default behavior of ordinary strings is now to treat backslash as an ordinary character, per SQL standard. This variable can be enabled to help locate code that needs to be changed.</source>
          <target state="translated">バックスラッシュをエスケープとして使用するアプリケーションは、エスケープ文字列構文（ &lt;code&gt;E'...'&lt;/code&gt; ）を使用するように変更する必要があります。これは、通常の文字列のデフォルトの動作では、バックスラッシュがSQL標準に従って通常の文字として扱われるためです。この変数を有効にすると、変更が必要なコードを見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="85980229b9ae48d13b46796fb33f530f87d73b8b" translate="yes" xml:space="preserve">
          <source>Applications using this level must be prepared to retry transactions due to serialization failures.</source>
          <target state="translated">このレベルを使用するアプリケーションは、シリアライゼーションの失敗によるトランザクションの再試行に備える必要があります。</target>
        </trans-unit>
        <trans-unit id="55278f2bfbaabfad19c2fee75ec3133e8897d48a" translate="yes" xml:space="preserve">
          <source>Apply modifications to the page images obtained in the previous step.</source>
          <target state="translated">前のステップで取得したページ画像に修正を適用します。</target>
        </trans-unit>
        <trans-unit id="068d74cbbe7303d0ad643d8aa0d60cbff0956278" translate="yes" xml:space="preserve">
          <source>Apply the WAL from the source cluster, starting from the checkpoint created at failover. (Strictly speaking, pg_rewind doesn't apply the WAL, it just creates a backup label file that makes PostgreSQL start by replaying all WAL from that checkpoint forward.)</source>
          <target state="translated">フェイルオーバー時に作成されたチェックポイントから開始して、ソースクラスタからWALを適用します。(厳密に言えば、pg_rewindはWALを適用せず、単にバックアップラベルファイルを作成し、そのチェックポイントから先のすべてのWALを再生してPostgreSQLを起動させます。)</target>
        </trans-unit>
        <trans-unit id="e486b3d6c0bcfe71e975768cf7354a58fa17fa9a" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data for moving-aggregate mode, or zero to use a default estimate</source>
          <target state="translated">移動アグリゲート・モードの遷移状態データのおおよその平均サイズ(バイト単位)、またはデフォルトの推定値を使用するにはゼロ</target>
        </trans-unit>
        <trans-unit id="caafece427e1163ffa963b4dffa3cc2b00260a07" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data, or zero to use a default estimate</source>
          <target state="translated">遷移状態データのおおよその平均サイズ(バイト単位)、またはデフォルトの推定値を使用するにはゼロ</target>
        </trans-unit>
        <trans-unit id="d737059a7023272b67d00f7bdeb9dfcc94048eda" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from an SQL/JSON number or a string</source>
          <target state="translated">SQL/JSONの数値または文字列から変換されたおおよその浮動小数点数</target>
        </trans-unit>
        <trans-unit id="befde54a108cb9dc6ad6e0ebd28720531a6855e6" translate="yes" xml:space="preserve">
          <source>Apr</source>
          <target state="translated">Apr</target>
        </trans-unit>
        <trans-unit id="a0393902db1f516ef5f95f6830938558a88fb23c" translate="yes" xml:space="preserve">
          <source>April</source>
          <target state="translated">April</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="2e6a8c2f54eea95c918815af873f318c8b75d1ee" translate="yes" xml:space="preserve">
          <source>Arbitrary text that serves as the description of this object</source>
          <target state="translated">このオブジェクトの説明となる任意のテキスト</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="c2745399d3dc1caef67349072200fb056fc4129e" translate="yes" xml:space="preserve">
          <source>Architecture: Initial Snapshot</source>
          <target state="translated">アーキテクチャ 初期スナップショット</target>
        </trans-unit>
        <trans-unit id="67a9118149c6042fe6daa560647e16f79a2d3d97" translate="yes" xml:space="preserve">
          <source>Are horizontally aligned?</source>
          <target state="translated">横並びになっていますか?</target>
        </trans-unit>
        <trans-unit id="8897c493ba700783f2c64a4d0f20f14b01d7b1e3" translate="yes" xml:space="preserve">
          <source>Are parallel?</source>
          <target state="translated">パラレルですか?</target>
        </trans-unit>
        <trans-unit id="5cba229ff1c565c58441b7f5908ac5643aeb85b7" translate="yes" xml:space="preserve">
          <source>Are the left JSON path/value entries contained at the top level within the right JSON value?</source>
          <target state="translated">左のJSONパス/値のエントリは、右のJSON値の中にトップレベルで含まれていますか?</target>
        </trans-unit>
        <trans-unit id="6ea55540eda7f3ae150bdf50ff88e357b0470bd4" translate="yes" xml:space="preserve">
          <source>Are vertically aligned?</source>
          <target state="translated">垂直に並んでいますか?</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">引数の種類</target>
        </trans-unit>
        <trans-unit id="227b299c7388311800207bda7f4dca4cbfe39510" translate="yes" xml:space="preserve">
          <source>Argument Type(s)</source>
          <target state="translated">引数タイプ</target>
        </trans-unit>
        <trans-unit id="a051df2e8379a7a94517621abf96e2d1c250d0c1" translate="yes" xml:space="preserve">
          <source>Argument strings to pass to trigger, each NULL-terminated</source>
          <target state="translated">トリガに渡す引数文字列、それぞれNULL終端</target>
        </trans-unit>
        <trans-unit id="3106eca9fcc5b17fbc0ab862b2b3e2e5d8ec1882" translate="yes" xml:space="preserve">
          <source>Arranges to save future query results to the file &lt;code&gt;filename&lt;/code&gt; or pipe future results to the shell command &lt;code&gt;command&lt;/code&gt;. If no argument is specified, the query output is reset to the standard output.</source>
          <target state="translated">将来のクエリ結果をファイル &lt;code&gt;filename&lt;/code&gt; に保存するか、将来の結果をシェルコマンド &lt;code&gt;command&lt;/code&gt; にパイプするように調整します。引数を指定しない場合、クエリ出力は標準出力にリセットされます。</target>
        </trans-unit>
        <trans-unit id="7a061ed91f80bf08d4b0e706de1a73a36b812215" translate="yes" xml:space="preserve">
          <source>Array Comparisons</source>
          <target state="translated">配列の比較</target>
        </trans-unit>
        <trans-unit id="2cce75772b9783560b7ecdf1a652525e088ff999" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ALL (array)</source>
          <target state="translated">配列の比較。ALL (配列)</target>
        </trans-unit>
        <trans-unit id="ebbce493c47b875446149a16fbeabd59af95b506" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ANY/SOME (array)</source>
          <target state="translated">配列の比較。ANY/SOME (配列)</target>
        </trans-unit>
        <trans-unit id="266d7d8ad9ef21fb1cf43acafe88df1627794e31" translate="yes" xml:space="preserve">
          <source>Array Comparisons: IN</source>
          <target state="translated">配列比較。IN</target>
        </trans-unit>
        <trans-unit id="cb5525261d1827b03403d3e1f7d54e339ee3bdc7" translate="yes" xml:space="preserve">
          <source>Array Comparisons: NOT IN</source>
          <target state="translated">配列比較。ではありません。</target>
        </trans-unit>
        <trans-unit id="378bd5c012fe9a2d09b80c0502903a9f1a4e46ef" translate="yes" xml:space="preserve">
          <source>Array Functions and Operators</source>
          <target state="translated">配列関数と演算子</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="989d38553686cf9420b0efeacfb98e0cb0491104" translate="yes" xml:space="preserve">
          <source>Array element accessor. &lt;code&gt;subscript&lt;/code&gt; can be given in two forms: &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;start_index to end_index&lt;/code&gt;. The first form returns a single array element by its index. The second form returns an array slice by the range of indexes, including the elements that correspond to the provided &lt;code&gt;start_index&lt;/code&gt; and &lt;code&gt;end_index&lt;/code&gt;.</source>
          <target state="translated">配列要素アクセサー。 &lt;code&gt;subscript&lt;/code&gt; は、 &lt;code&gt;index&lt;/code&gt; または &lt;code&gt;start_index to end_index&lt;/code&gt; の 2つの形式で指定できます。最初の形式は、インデックスによって単一の配列要素を返します。2番目の形式は、指定された &lt;code&gt;start_index&lt;/code&gt; および &lt;code&gt;end_index&lt;/code&gt; に対応する要素を含む、インデックスの範囲によって配列スライスを返します。</target>
        </trans-unit>
        <trans-unit id="88048034955012a6a9f12b6c23a529e19a83c1b1" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;WHERE&lt;/code&gt;-clause filter conditions for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">拡張機能の構成テーブルの &lt;code&gt;WHERE&lt;/code&gt; 句フィルター条件の配列。存在しない場合は &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01ffa4580cea8a6c482fb4eea9629be04c79e61e" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;regclass&lt;/code&gt; OIDs for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">拡張機能の構成テーブルの &lt;code&gt;regclass&lt;/code&gt; OIDの配列、ない場合は &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24c2e81a77c22cd6c4b27ed6a767d8a3da693d5f" translate="yes" xml:space="preserve">
          <source>Array of item identifiers pointing to the actual items. Each entry is an (offset,length) pair. 4 bytes per item.</source>
          <target state="translated">実際のアイテムを指すアイテム識別子の配列。各エントリは (offset,length)のペアです。1項目あたり4バイト。</target>
        </trans-unit>
        <trans-unit id="be15b795f8a08c896c323efe48ed797caf42d6d4" translate="yes" xml:space="preserve">
          <source>Array of subscribed publication names. These reference the publications on the publisher server. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">サブスクライブされたパブリケーション名の配列。これらは、パブリッシャーサーバー上のパブリケーションを参照します。出版物の詳細については、&lt;a href=&quot;logical-replication-publication&quot;&gt;セクション30.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="31177effc11eb7035c25f786c3b9f262ea8dee25" translate="yes" xml:space="preserve">
          <source>Array: &amp;amp;&amp;amp;</source>
          <target state="translated">配列：&amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="24e29718edd609d75b45a77aa875138df131bbd7" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;</source>
          <target state="translated">配列：&amp;gt;</target>
        </trans-unit>
        <trans-unit id="811842a370e6ca7314ad3ee641887ae43eed6200" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;=</source>
          <target state="translated">配列：&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="736b98ce8f814e8462d7673c06a73e5d2921d61d" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;</source>
          <target state="translated">配列：&amp;lt;</target>
        </trans-unit>
        <trans-unit id="72683d381cd2860b3b1a8eab0a2c5eedfb795924" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;&amp;gt;</source>
          <target state="translated">配列：&amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="397f0e2a9b9f910336a8ea8c6c32ba6704d652eb" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;=</source>
          <target state="translated">配列：&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="5df64d9374ce5e9d00462533f6beea8afb43679c" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;@</source>
          <target state="translated">配列：&amp;lt;@</target>
        </trans-unit>
        <trans-unit id="d7d17f1eb33a5388e6bfb317a245a8c37e5b460a" translate="yes" xml:space="preserve">
          <source>Array: =</source>
          <target state="translated">配列:==のようになります。</target>
        </trans-unit>
        <trans-unit id="db0f2c477d3b5e5a1ea32beab72408f0ff3b2f71" translate="yes" xml:space="preserve">
          <source>Array: @&amp;gt;</source>
          <target state="translated">配列：@&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d9bbda7ebf850fa729d9606dbdfd7d1f3599ec47" translate="yes" xml:space="preserve">
          <source>Array: array_append</source>
          <target state="translated">配列:array_append</target>
        </trans-unit>
        <trans-unit id="af82c1377e93f02d0993b9aadeb7d8e17521a1bc" translate="yes" xml:space="preserve">
          <source>Array: array_cat</source>
          <target state="translated">配列:array_cat</target>
        </trans-unit>
        <trans-unit id="243f29a4a2e10d2646f7903c1f4a2d39c2a3d0a4" translate="yes" xml:space="preserve">
          <source>Array: array_dims</source>
          <target state="translated">配列:array_dims</target>
        </trans-unit>
        <trans-unit id="5beacc0ab51ffbcd3c4683bef89fb252cd5ecd4f" translate="yes" xml:space="preserve">
          <source>Array: array_fill</source>
          <target state="translated">配列:array_fill</target>
        </trans-unit>
        <trans-unit id="0a700d1340312f7d432d241fb96c7d69e0d7cbc8" translate="yes" xml:space="preserve">
          <source>Array: array_length</source>
          <target state="translated">配列:array_length</target>
        </trans-unit>
        <trans-unit id="e39f07efeb19c70308a1b05104d42f13e6750589" translate="yes" xml:space="preserve">
          <source>Array: array_lower</source>
          <target state="translated">配列:array_lower</target>
        </trans-unit>
        <trans-unit id="55bec9b1ab2dd7b5615b888955aa1685d7d9176c" translate="yes" xml:space="preserve">
          <source>Array: array_ndims</source>
          <target state="translated">配列:array_ndims</target>
        </trans-unit>
        <trans-unit id="6abfbc8e90ab3825fd22a987883a8130d8647c22" translate="yes" xml:space="preserve">
          <source>Array: array_position</source>
          <target state="translated">配列:array_position</target>
        </trans-unit>
        <trans-unit id="dc8f46967ae5b46ce3023fe830845635cbddc3a2" translate="yes" xml:space="preserve">
          <source>Array: array_positions</source>
          <target state="translated">配列:array_positions</target>
        </trans-unit>
        <trans-unit id="170bb418b8b592fa19a657e9b3372281a737a509" translate="yes" xml:space="preserve">
          <source>Array: array_prepend</source>
          <target state="translated">配列:array_prepend</target>
        </trans-unit>
        <trans-unit id="23c081b8640d7683a9a9eb917682404db2a9d9cf" translate="yes" xml:space="preserve">
          <source>Array: array_remove</source>
          <target state="translated">配列:array_remove</target>
        </trans-unit>
        <trans-unit id="0bb70da04daab39f1a179be9e60eceee76a3242d" translate="yes" xml:space="preserve">
          <source>Array: array_replace</source>
          <target state="translated">配列:array_replace</target>
        </trans-unit>
        <trans-unit id="d1576bf750554857f928eff64376711410524f13" translate="yes" xml:space="preserve">
          <source>Array: array_to_string</source>
          <target state="translated">配列:array_to_string</target>
        </trans-unit>
        <trans-unit id="f1d1655c390920a19930233b2ba0cbcc608406ea" translate="yes" xml:space="preserve">
          <source>Array: array_upper</source>
          <target state="translated">配列:array_upper</target>
        </trans-unit>
        <trans-unit id="f07fdded6b4337ac290721bed8d559d25ce497d7" translate="yes" xml:space="preserve">
          <source>Array: cardinality</source>
          <target state="translated">配列:カーディナリティ</target>
        </trans-unit>
        <trans-unit id="b45177789238b533ec64ce75c721f78be3e3490d" translate="yes" xml:space="preserve">
          <source>Array: string_to_array</source>
          <target state="translated">配列:string_to_array</target>
        </trans-unit>
        <trans-unit id="1b1aca770dcf002c23a04ca801aee9819ce75321" translate="yes" xml:space="preserve">
          <source>Array: unnest</source>
          <target state="translated">配列:アンネスト</target>
        </trans-unit>
        <trans-unit id="8cbda94f98fa6831a0fab631dfd36cfb855d6147" translate="yes" xml:space="preserve">
          <source>Array: ||</source>
          <target state="translated">配列です。||</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7ff0d6e651880818d49ef5a4d284aa7441e9760b" translate="yes" xml:space="preserve">
          <source>Arrays are not sets; searching for specific array elements can be a sign of database misdesign. Consider using a separate table with a row for each item that would be an array element. This will be easier to search, and is likely to scale better for a large number of elements.</source>
          <target state="translated">配列は集合ではありません。特定の配列要素を検索することは、データベースの設計ミスの兆候である可能性があります。特定の配列要素を検索するには、データベースの設計ミスのサインになる可能性があります。配列要素となる各項目の行を持つ別のテーブルを使用することを検討してください。これは検索が容易になりますし、要素の数が多い場合のスケーリングも容易になります。</target>
        </trans-unit>
        <trans-unit id="86a798d810f86ee1f57761b0f4f378302a450ab0" translate="yes" xml:space="preserve">
          <source>As PostgreSQL stands, this doesn't occur. Large objects are treated as objects in their own right; a table entry can reference a large object by OID, but there can be multiple table entries referencing the same large object OID, so the system doesn't delete the large object just because you change or remove one such entry.</source>
          <target state="translated">PostgreSQLの現状では、このようなことは起こりません。ラージオブジェクトはそれ自体がオブジェクトとして扱われます。テーブルエントリはラージオブジェクトをOIDで参照することができますが、同じラージオブジェクトのOIDを参照しているテーブルエントリが複数存在する可能性があるため、1つのエントリを変更したり削除したりしたからといってシステムがラージオブジェクトを削除することはありません。</target>
        </trans-unit>
        <trans-unit id="96ee90014e2be91ae6a2c0ff19bfbdac86380915" translate="yes" xml:space="preserve">
          <source>As a consequence, it is unwise to use functions with side effects as part of complex expressions. It is particularly dangerous to rely on side effects or evaluation order in &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses, since those clauses are extensively reprocessed as part of developing an execution plan. Boolean expressions (&lt;code&gt;AND&lt;/code&gt;/&lt;code&gt;OR&lt;/code&gt;/&lt;code&gt;NOT&lt;/code&gt; combinations) in those clauses can be reorganized in any manner allowed by the laws of Boolean algebra.</source>
          <target state="translated">結果として、副作用のある関数を複雑な式の一部として使用することは賢明ではありません。 &lt;code&gt;WHERE&lt;/code&gt; 句と &lt;code&gt;HAVING&lt;/code&gt; 句の副作用や評価順序に依存することは特に危険です。これらの句は、実行プランの開発の一環として広範囲にわたって再処理されるためです。これらの句のブール式（ &lt;code&gt;AND&lt;/code&gt; / &lt;code&gt;OR&lt;/code&gt; / &lt;code&gt;NOT&lt;/code&gt; の組み合わせ）は、ブール代数の法則で許可されている方法で再編成できます。</target>
        </trans-unit>
        <trans-unit id="c00aa4eef1a46e7541eb69499cd40ccfaa63754a" translate="yes" xml:space="preserve">
          <source>As a convenience, there is a program you can execute from the shell to create new databases, &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">便宜上、シェルから新しいデータベースを作成するために実行できるプログラム &lt;code&gt;createdb&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="d25ac520ed3e5e990af0f244faf971c940fd4e71" translate="yes" xml:space="preserve">
          <source>As a general rule, if you get spurious parser errors for commands that contain any of the listed key words as an identifier you should try to quote the identifier to see if the problem goes away.</source>
          <target state="translated">一般的なルールとして、リストされたキーワードを識別子として含むコマンドのパーサエラーが発生した場合、問題が解決するかどうかを確認するために識別子を引用してみてください。</target>
        </trans-unit>
        <trans-unit id="2a80a71669f88eae465ab66545f1b21816ccdfcd" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed. But note that &lt;code&gt;NOT NULL&lt;/code&gt; constraints are only enforced in the executor, not against tuples that are generated by random C code, so care is still needed when manually creating or updating catalog rows.</source>
          <target state="translated">このタイプのエラーに対する部分的な保護策として、可変長フィールドまたはNULL可能フィールドをCコンパイラに直接表示しないでください。これは、 &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; （ &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; は定義されていないシンボルです）でそれらをラップすることによって実現されます。これにより、Cコードが存在しない、または他のオフセットにある可能性のあるフィールドに不用意にアクセスするのを防ぎます。不正な行を作成しないようにするための独立した保護策として、nullにすることができないすべての列を &lt;code&gt;pg_attribute&lt;/code&gt; でマークする必要があります。ブートストラップコードはカタログ列を自動的に &lt;code&gt;NOT NULL&lt;/code&gt; としてマークします固定幅であり、その前にnull許容列がない場合。このルールが不適切な場合は、必要に応じて &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; および &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; アノテーションを使用して、正しいマーキングを強制できます。ただし、 &lt;code&gt;NOT NULL&lt;/code&gt; 制約はexecutorでのみ適用され、ランダムなCコードによって生成されたタプルに対しては適用されないため、手動でカタログ行を作成または更新する場合は注意が必要です。</target>
        </trans-unit>
        <trans-unit id="47b0b4c39b5ede77f7f7daa11745dc4255dd8757" translate="yes" xml:space="preserve">
          <source>As a partitioned table does not have any data directly, attempts to use &lt;code&gt;TRUNCATE&lt;/code&gt;&lt;code&gt;ONLY&lt;/code&gt; on a partitioned table will always return an error.</source>
          <target state="translated">パーティションテーブルには直接データがないため、パーティションテーブルで &lt;code&gt;TRUNCATE&lt;/code&gt; &lt;code&gt;ONLY&lt;/code&gt; を使用しようとすると、常にエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="ff2aae32fe6bdd83d73023e8256b2cd3508deffa" translate="yes" xml:space="preserve">
          <source>As a result, you cannot create additional indexes that exist solely on the standby, nor statistics that exist solely on the standby. If these administration commands are needed, they should be executed on the primary, and eventually those changes will propagate to the standby.</source>
          <target state="translated">その結果、スタンバイのみに存在する追加のインデックスや、スタンバイのみに存在する統計情報を作成することはできません。これらの管理コマンドが必要な場合は、プライマリ上で実行する必要があり、最終的にはそれらの変更がスタンバイに伝搬します。</target>
        </trans-unit>
        <trans-unit id="94f064aeef44b2237a7b84960c6af3e282dc0f3d" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, &lt;code&gt;queryid&lt;/code&gt; values can be assumed to be stable and comparable only so long as the underlying server version and catalog metadata details stay exactly the same. Two servers participating in replication based on physical WAL replay can be expected to have identical &lt;code&gt;queryid&lt;/code&gt; values for the same query. However, logical replication schemes do not promise to keep replicas identical in all relevant details, so &lt;code&gt;queryid&lt;/code&gt; will not be a useful identifier for accumulating costs across a set of logical replicas. If in doubt, direct testing is recommended.</source>
          <target state="translated">経験則として、基礎となるサーバーのバージョンとカタログのメタデータの詳細がまったく同じである限り、 &lt;code&gt;queryid&lt;/code&gt; 値は安定していて比較可能であると見なすことができます。物理WAL再生に基づくレプリケーションに参加している2つのサーバーは、同じクエリに対して同一の &lt;code&gt;queryid&lt;/code&gt; 値を持つことが期待できます。ただし、論理レプリケーションスキームは、レプリカを関連するすべての詳細で同一に保つことを約束しないため、 &lt;code&gt;queryid&lt;/code&gt; は、一連の論理レプリカにわたってコストを累積するための有用な識別子にはなりません。疑わしい場合は、直接テストをお勧めします。</target>
        </trans-unit>
        <trans-unit id="84cdd8b719c9d8f34c7f1d4c72b4f9ce0fe4768b" translate="yes" xml:space="preserve">
          <source>As a safety device, an aggressive vacuum scan will occur for any table whose multixact-age is greater than &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;. Aggressive vacuum scans will also occur progressively for all tables, starting with those that have the oldest multixact-age, if the amount of used member storage space exceeds the amount 50% of the addressable storage space. Both of these kinds of aggressive scans will occur even if autovacuum is nominally disabled.</source>
          <target state="translated">安全装置として、multixact-ageが&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;より大きいテーブルに対して積極的なバキュームスキャンが行われます。使用中のメンバーストレージスペースの量がアドレス可能なストレージスペースの量の50％を超えると、最も古いmultixact-ageを持つテーブルから始めて、すべてのテーブルに対して積極的なバキュームスキャンも徐々に行われます。自動バキュームが名目上無効になっている場合でも、これら両方の積極的なスキャンが行われます。</target>
        </trans-unit>
        <trans-unit id="2b18e01bd003b97bb977c2d73b7cfc8923da784c" translate="yes" xml:space="preserve">
          <source>As a sanity check, &lt;code&gt;seg&lt;/code&gt; rejects intervals with the lower bound greater than the upper, for example &lt;code&gt;5 .. 2&lt;/code&gt;.</source>
          <target state="translated">健全性チェックとして、 &lt;code&gt;seg&lt;/code&gt; は上限よりも大きい下限、たとえば &lt;code&gt;5 .. 2&lt;/code&gt; 間隔を拒否します。</target>
        </trans-unit>
        <trans-unit id="e65f5f3343ba0b45af614f4022a156a7c42809b5" translate="yes" xml:space="preserve">
          <source>As a simple example, here is how to create a policy on the &lt;code&gt;account&lt;/code&gt; relation to allow only members of the &lt;code&gt;managers&lt;/code&gt; role to access rows, and only rows of their accounts:</source>
          <target state="translated">簡単な例として、 &lt;code&gt;managers&lt;/code&gt; ロールのメンバーのみに行へのアクセスを許可し、 &lt;code&gt;account&lt;/code&gt; 行のみにアクセスを許可するアカウント関係のポリシーを作成する方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="05f66f343edd96e743819d53bcce1284f5be3d29" translate="yes" xml:space="preserve">
          <source>As a special exception to the general principle that the structures must match, an array may contain a primitive value:</source>
          <target state="translated">構造体が一致しなければならないという一般的な原則に対する特別な例外として、配列はプリミティブ値を含むことができます。</target>
        </trans-unit>
        <trans-unit id="4dafe6722800c895e7fb824e24cdc22785e38231" translate="yes" xml:space="preserve">
          <source>As a workaround to allow PostgreSQL to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses under a non-C locale, several custom operator classes exist. These allow the creation of an index that performs a strict character-by-character comparison, ignoring locale comparison rules. Refer to &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; for more information. Another approach is to create indexes using the &lt;code&gt;C&lt;/code&gt; collation, as discussed in &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLがC以外のロケールで &lt;code&gt;LIKE&lt;/code&gt; 句を含むインデックスを使用できるようにする回避策として、いくつかのカスタム演算子クラスが存在します。これらにより、ロケール比較ルールを無視して、厳密な文字ごとの比較を実行するインデックスを作成できます。詳細については、&lt;a href=&quot;indexes-opclass&quot;&gt;セクション11.10&lt;/a&gt;を参照してください。&lt;a href=&quot;collation&quot;&gt;セクション23.2で&lt;/a&gt;説明されているように、 &lt;code&gt;C&lt;/code&gt; 照合を使用してインデックスを作成する方法もあります。</target>
        </trans-unit>
        <trans-unit id="38727bf2878bdfdd88e444d27be405dc29a205b6" translate="yes" xml:space="preserve">
          <source>As above, but import only the two tables &lt;code&gt;actors&lt;/code&gt; and &lt;code&gt;directors&lt;/code&gt; (if they exist):</source>
          <target state="translated">上記と同じですが、 &lt;code&gt;actors&lt;/code&gt; と &lt;code&gt;directors&lt;/code&gt; （存在する場合）の2つのテーブルのみをインポートします。</target>
        </trans-unit>
        <trans-unit id="fc0ab2ce564629da1cade53f45b45700cfa6ba3f" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-D&lt;/code&gt; option, you can set the environment variable &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-D&lt;/code&gt; オプションの代わりに、環境変数 &lt;code&gt;PGDATA&lt;/code&gt; 設定できます。</target>
        </trans-unit>
        <trans-unit id="431e9cdc01712eabff181abecb6b83e3af47f9a9" translate="yes" xml:space="preserve">
          <source>As an alternative, it is sometimes more convenient to create the new table outside the partition structure, and make it a proper partition later. This allows the data to be loaded, checked, and transformed prior to it appearing in the partitioned table:</source>
          <target state="translated">別の方法として、新しいテーブルをパーティション構造の外側に作成して、後で適切なパーティションにした方が便利な場合があります。これにより、データがパーティション化されたテーブルに現れる前に、データをロードし、チェックし、変換することができます。</target>
        </trans-unit>
        <trans-unit id="d0e3b2ce01a4421ab4c72defc488724bdaa1c1a4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Figure 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="translated">これらの関数によって生成された出力を使用する例として、&lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;図9.1&lt;/a&gt;は、 &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; の出力をテーブルデータの表形式のレンディションを含むHTMLドキュメントに変換するXSLTスタイルシートを示しています。同様に、これらの関数の結果を他のXMLベースの形式に変換できます。</target>
        </trans-unit>
        <trans-unit id="0d1f3783f0bee859f0f7fd07d8117b96c39c5dbf" translate="yes" xml:space="preserve">
          <source>As an example we will create a configuration &lt;code&gt;pg&lt;/code&gt;, starting by duplicating the built-in &lt;code&gt;english&lt;/code&gt; configuration:</source>
          <target state="translated">例として、組み込みの &lt;code&gt;english&lt;/code&gt; 構成を複製することから始める構成 &lt;code&gt;pg&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="75dd3c213ab262bc0285b838849480821b38de49" translate="yes" xml:space="preserve">
          <source>As an example, consider a table &lt;code&gt;mytab&lt;/code&gt;, initially containing:</source>
          <target state="translated">例として、最初に以下を含むテーブル &lt;code&gt;mytab&lt;/code&gt; を考えます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
